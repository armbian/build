diff --git a/drivers/net/wireless/rtl8814au/Makefile b/drivers/net/wireless/rtl8814au/Makefile
index f848e2a..2802bf9 100644
--- a/drivers/net/wireless/rtl8814au/Makefile
+++ b/drivers/net/wireless/rtl8814au/Makefile
@@ -16,7 +16,11 @@ EXTRA_CFLAGS += -Wno-unused
 EXTRA_CFLAGS += -Wno-date-time
 EXTRA_CFLAGS += -Wno-misleading-indentation
 EXTRA_CFLAGS += -Wno-uninitialized
-EXTRA_CFLAGS += -Wno-error=date-time	# Fix compile error on gcc 4.9 and later
+
+GCC_VER_49 := $(shell echo `$(CC) -dumpversion | cut -f1-2 -d.` \>= 4.9 | bc )
+ifeq ($(GCC_VER_49),1)
+EXTRA_CFLAGS += -Wno-date-time	# Fix compile error && warning on gcc 4.9 and later
+endif
 
 EXTRA_CFLAGS += -I$(src)/include
 EXTRA_CFLAGS += -I$(src)/hal/phydm
@@ -44,13 +48,13 @@ CONFIG_PCI_HCI = n
 CONFIG_SDIO_HCI = n
 CONFIG_GSPI_HCI = n
 ########################## Features ###########################
+CONFIG_NET_NS = y
 CONFIG_MP_INCLUDED = y
 CONFIG_POWER_SAVING = n
 CONFIG_USB_AUTOSUSPEND = n
 CONFIG_HW_PWRP_DETECTION = n
 CONFIG_WIFI_TEST = n
 CONFIG_BT_COEXIST = n
-CONFIG_INTEL_WIDI = n
 CONFIG_WAPI_SUPPORT = n
 CONFIG_EFUSE_CONFIG_FILE = y
 CONFIG_EXT_CLK = n
@@ -58,10 +62,10 @@ CONFIG_TRAFFIC_PROTECT = y
 CONFIG_LOAD_PHY_PARA_FROM_FILE = y
 CONFIG_CALIBRATE_TX_POWER_BY_REGULATORY = n
 CONFIG_CALIBRATE_TX_POWER_TO_MAX = y
-CONFIG_RTW_ADAPTIVITY_EN = disable
+CONFIG_RTW_ADAPTIVITY_EN = auto
 CONFIG_RTW_ADAPTIVITY_MODE = normal
 CONFIG_SIGNAL_SCALE_MAPPING = n
-CONFIG_80211W = n
+CONFIG_80211W = y
 CONFIG_REDUCE_TX_CPU_LOADING = n
 CONFIG_BR_EXT = y
 CONFIG_TDLS = n
@@ -133,6 +137,7 @@ CONFIG_PLATFORM_ARM_RTD299X = n
 CONFIG_PLATFORM_ARM_SPREADTRUM_6820 = n
 CONFIG_PLATFORM_ARM_SPREADTRUM_8810 = n
 CONFIG_PLATFORM_ARM_WMT = n
+CONFIG_PLATFORM_ARM_RPI = n
 CONFIG_PLATFORM_TI_DM365 = n
 CONFIG_PLATFORM_MOZART = n
 CONFIG_PLATFORM_RTK119X = n
@@ -886,15 +891,10 @@ ifeq ($(CONFIG_BT_COEXIST), y)
 EXTRA_CFLAGS += -DCONFIG_BT_COEXIST
 endif
 
-ifeq ($(CONFIG_INTEL_WIDI), y)
-EXTRA_CFLAGS += -DCONFIG_INTEL_WIDI
-endif
-
 ifeq ($(CONFIG_WAPI_SUPPORT), y)
 EXTRA_CFLAGS += -DCONFIG_WAPI_SUPPORT
 endif
 
-
 ifeq ($(CONFIG_EFUSE_CONFIG_FILE), y)
 EXTRA_CFLAGS += -DCONFIG_EFUSE_CONFIG_FILE
 
@@ -1059,7 +1059,7 @@ EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
 SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
 ARCH ?= $(SUBARCH)
 CROSS_COMPILE ?=
-KVER  := $(shell uname -r)
+KVER  ?= $(shell uname -r)
 KSRC := /lib/modules/$(KVER)/build
 MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/
 INSTALL_PREFIX :=
@@ -1071,13 +1071,12 @@ EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFO
 ARCH := $(R_ARCH)
 #CROSS_COMPILE := arm-none-linux-gnueabi-
 CROSS_COMPILE := $(R_CROSS_COMPILE)
-KVER:= 3.4.0
+KVER ?= 3.4.0
 #KSRC := ../../../../build/out/kernel
 KSRC := $(KERNEL_BUILD_PATH)
 MODULE_NAME :=wlan
 endif
 
-
 ifeq ($(CONFIG_PLATFORM_ACTIONS_ATM705X), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
 #EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC
@@ -1135,10 +1134,10 @@ endif
 
 ifeq ($(CONFIG_PLATFORM_MSTAR_TITANIA12), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MSTAR -DCONFIG_PLATFORM_MSTAR_TITANIA12
-ARCH:=mips
+ARCH :=mips
 CROSS_COMPILE:= /usr/src/Mstar_kernel/mips-4.3/bin/mips-linux-gnu-
-KVER:= 2.6.28.9
-KSRC:= /usr/src/Mstar_kernel/2.6.28.9/
+KVER ?= 2.6.28.9
+KSRC := /usr/src/Mstar_kernel/2.6.28.9/
 endif
 
 ifeq ($(CONFIG_PLATFORM_MSTAR), y)
@@ -1146,10 +1145,10 @@ EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
 EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MSTAR -DCONFIG_USE_USB_BUFFER_ALLOC_TX -DCONFIG_FIX_NR_BULKIN_BUFFER -DCONFIG_PREALLOC_RX_SKB_BUFFER
 EXTRA_CFLAGS += -DCONFIG_PLATFORM_MSTAR_HIGH
-ARCH:=arm
+ARCH :=arm
 CROSS_COMPILE:= /usr/src/bin/arm-none-linux-gnueabi-
-KVER:= 3.1.10
-KSRC:= /usr/src/Mstar_kernel/3.1.10/
+KVER ?= 3.1.10
+KSRC := /usr/src/Mstar_kernel/3.1.10/
 endif
 
 ifeq ($(CONFIG_PLATFORM_ANDROID_X86), y)
@@ -1188,7 +1187,7 @@ ifeq ($(CONFIG_PLATFORM_ARM_PXA2XX), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
 ARCH := arm
 CROSS_COMPILE := arm-none-linux-gnueabi-
-KVER  := 2.6.34.1
+KVER  ?= 2.6.34.1
 KSRC ?= /usr/src/linux-2.6.34.1
 endif
 
@@ -1196,7 +1195,7 @@ ifeq ($(CONFIG_PLATFORM_ARM_S3C2K4), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
 ARCH := arm
 CROSS_COMPILE := arm-linux-
-KVER  := 2.6.24.7_$(ARCH)
+KVER  ?= 2.6.24.7_$(ARCH)
 KSRC := /usr/src/kernels/linux-$(KVER)
 endif
 
@@ -1204,40 +1203,40 @@ ifeq ($(CONFIG_PLATFORM_ARM_S3C6K4), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
 ARCH := arm
 CROSS_COMPILE := arm-none-linux-gnueabi-
-KVER  := 2.6.34.1
+KVER  ?= 2.6.34.1
 KSRC ?= /usr/src/linux-2.6.34.1
 endif
 
 ifeq ($(CONFIG_PLATFORM_RTD2880B), y)
 EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN -DCONFIG_PLATFORM_RTD2880B
-ARCH:=
+ARCH :=
 CROSS_COMPILE:=
-KVER:=
-KSRC:=
+KVER ?=
+KSRC :=
 endif
 
 ifeq ($(CONFIG_PLATFORM_MIPS_RMI), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
-ARCH:=mips
+ARCH :=mips
 CROSS_COMPILE:=mipsisa32r2-uclibc-
-KVER:=
-KSRC:= /root/work/kernel_realtek
+KVER ?=
+KSRC := /root/work/kernel_realtek
 endif
 
 ifeq ($(CONFIG_PLATFORM_MIPS_PLM), y)
 EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN
-ARCH:=mips
+ARCH :=mips
 CROSS_COMPILE:=mipsisa32r2-uclibc-
-KVER:=
-KSRC:= /root/work/kernel_realtek
+KVER ?=
+KSRC := /root/work/kernel_realtek
 endif
 
 ifeq ($(CONFIG_PLATFORM_MSTAR389), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MSTAR389
-ARCH:=mips
+ARCH :=mips
 CROSS_COMPILE:= mips-linux-gnu-
-KVER:= 2.6.28.10
-KSRC:= /home/mstar/mstar_linux/2.6.28.9/
+KVER ?= 2.6.28.10
+KSRC := /home/mstar/mstar_linux/2.6.28.9/
 endif
 
 ifeq ($(CONFIG_PLATFORM_MIPS_AR9132), y)
@@ -1261,25 +1260,25 @@ EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
 ifeq ($(CONFIG_USB_HCI), y)
 _PLATFORM_FILES += platform/platform_RTK_DMP_usb.o
 endif
-ARCH:=mips
-CROSS_COMPILE:=mipsel-linux-
-KVER:=
+ARCH :=mips
+CROSS_COMPILE :=mipsel-linux-
+KVER ?=
 KSRC ?= /usr/src/DMP_Kernel/jupiter/linux-2.6.12
 endif
 
 ifeq ($(CONFIG_PLATFORM_MT53XX), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MT53XX
-ARCH:= arm
+ARCH := arm
 CROSS_COMPILE:= arm11_mtk_le-
-KVER:= 2.6.27
-KSRC?= /proj/mtk00802/BD_Compare/BDP/Dev/BDP_V301/BDP_Linux/linux-2.6.27
+KVER ?= 2.6.27
+KSRC ?= /proj/mtk00802/BD_Compare/BDP/Dev/BDP_V301/BDP_Linux/linux-2.6.27
 endif
 
 ifeq ($(CONFIG_PLATFORM_ARM_MX51_241H), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_WISTRON_PLATFORM
 ARCH := arm
 CROSS_COMPILE := /opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/arm-none-linux-gnueabi-
-KVER  := 2.6.31
+KVER ?= 2.6.31
 KSRC ?= /lib/modules/2.6.31-770-g0e46b52/source
 endif
 
@@ -1290,13 +1289,11 @@ CROSS_COMPILE := /home/share/CusEnv/FreeScale/arm-eabi-4.4.3/bin/arm-eabi-
 KSRC ?= /home/share/CusEnv/FreeScale/FS_kernel_env
 endif
 
-
-
 ifeq ($(CONFIG_PLATFORM_ACTIONS_ATJ227X), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ACTIONS_ATJ227X
 ARCH := mips
 CROSS_COMPILE := /home/cnsd4/project/actions/tools-2.6.27/bin/mipsel-linux-gnu-
-KVER  := 2.6.27
+KVER  ?= 2.6.27
 KSRC := /home/cnsd4/project/actions/linux-2.6.27.28
 endif
 
@@ -1310,14 +1307,14 @@ ARCH := arm
 CROSS_COMPILE := /opt/montavista/pro5.0/devkit/arm/v5t_le/bin/arm-linux-
 KSRC:= /home/vivotek/lsp/DM365/kernel_platform/kernel/linux-2.6.18
 KERNELOUTPUT := ${PRODUCTDIR}/tmp
-KVER  := 2.6.18
+KVER  ?= 2.6.18
 endif
 
 ifeq ($(CONFIG_PLATFORM_MOZART), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MOZART
 ARCH := arm
 CROSS_COMPILE := /home/vivotek/lsp/mozart3v2/Mozart3e_Toolchain/build_arm_nofpu/usr/bin/arm-linux-
-KVER  := $(shell uname -r)
+KVER  ?= $(shell uname -r)
 KSRC:= /opt/Vivotek/lsp/mozart3v2/kernel_platform/kernel/mozart_kernel-1.17
 KERNELOUTPUT := /home/pink/sample/ODM/IP8136W-VINT/tmp/kernel
 endif
@@ -1442,8 +1439,8 @@ ifeq ($(CONFIG_PLATFORM_SZEBOOK), y)
 EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN
 ARCH:=arm
 CROSS_COMPILE:=/opt/crosstool2/bin/armeb-unknown-linux-gnueabi-
-KVER:= 2.6.31.6
-KSRC:= ../code/linux-2.6.31.6-2020/
+KVER ?= 2.6.31.6
+KSRC := ../code/linux-2.6.31.6-2020/
 endif
 
 #Add setting for MN10300
@@ -1451,12 +1448,11 @@ ifeq ($(CONFIG_PLATFORM_MN10300), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MN10300
 ARCH := mn10300
 CROSS_COMPILE := mn10300-linux-
-KVER := 2.6.32.2
+KVER ?= 2.6.32.2
 KSRC := /home/winuser/work/Plat_sLD2T_V3010/usr/src/linux-2.6.32.2
 INSTALL_PREFIX :=
 endif
 
-
 ifeq ($(CONFIG_PLATFORM_ARM_SUNxI), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
 EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUNxI
@@ -1478,7 +1474,7 @@ endif
 ARCH := arm
 #CROSS_COMPILE := arm-none-linux-gnueabi-
 CROSS_COMPILE=/home/android_sdk/Allwinner/a10/android-jb42/lichee-jb42/buildroot/output/external-toolchain/bin/arm-none-linux-gnueabi-
-KVER  := 3.0.8
+KVER  ?= 3.0.8
 #KSRC:= ../lichee/linux-3.0/
 KSRC=/home/android_sdk/Allwinner/a10/android-jb42/lichee-jb42/linux-3.0
 endif
@@ -1716,6 +1712,15 @@ MODULE_NAME := 8192eu
 
 endif
 
+ifeq ($(CONFIG_PLATFORM_ARM_RPI), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+ARCH := arm
+CROSS_COMPILE :=
+KVER ?= $(shell uname -r)
+KSRC ?= /lib/modules/$(KVER)/build
+MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/
+endif
+
 ifeq ($(CONFIG_PLATFORM_RTK129X), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
 EXTRA_CFLAGS += -DRTK_129X_PLATFORM
@@ -1755,7 +1760,7 @@ EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_RX
 EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
 ARCH ?= arm
 CROSS_COMPILE := arm-linux-gnueabihf-
-KVER := 3.8.0
+KVER ?= 3.8.0
 KSRC := /Custom/Novatek/TCL/linux-3.8_header
 #KSRC := $(KERNELDIR)
 endif
@@ -1797,7 +1802,6 @@ ifeq ($(CONFIG_PCI_HCI), y)
 MODULE_NAME := rtw_pci
 endif
 
-
 endif
 
 USER_MODULE_NAME ?=
@@ -1841,8 +1845,6 @@ endif
 
 $(MODULE_NAME)-y += $(rtk_core)
 
-$(MODULE_NAME)-$(CONFIG_INTEL_WIDI) += core/rtw_intel_widi.o
-
 $(MODULE_NAME)-$(CONFIG_WAPI_SUPPORT) += core/rtw_wapi.o	\
 					core/rtw_wapi_sms4.o
 
@@ -1866,7 +1868,7 @@ export CONFIG_RTL8812AU = m
 all: modules
 
 modules:
-	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KSRC) M=$(shell pwd)  modules
+	$(MAKE) -j $(shell nproc || echo 1) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KSRC) M=$(shell pwd)  modules
 
 strip:
 	$(CROSS_COMPILE)strip $(MODULE_NAME).ko --strip-unneeded
@@ -1883,7 +1885,6 @@ config_r:
 	@echo "make config"
 	/bin/bash script/Configure script/config.in
 
-
 .PHONY: modules clean
 
 clean:
@@ -1901,4 +1902,3 @@ clean:
 	rm -fr *.mod.c *.mod *.o .*.cmd *.ko *~
 	rm -fr .tmp_versions
 endif
-
diff --git a/drivers/net/wireless/rtl8814au/core/efuse/rtw_efuse.c b/drivers/net/wireless/rtl8814au/core/efuse/rtw_efuse.c
index e3554f8..aa05ce8 100644
--- a/drivers/net/wireless/rtl8814au/core/efuse/rtw_efuse.c
+++ b/drivers/net/wireless/rtl8814au/core/efuse/rtw_efuse.c
@@ -337,6 +337,61 @@ u16 rtw_get_efuse_mask_arraylen(PADAPTER pAdapter)
 }
 
 
+VOID efuse_PreUpdateAction(
+	PADAPTER	pAdapter,
+	pu4Byte	BackupRegs)
+{
+	if (IS_HARDWARE_TYPE_8812AU(pAdapter)) {
+		/* <20131115, Kordan> Turn off Rx to prevent from being busy when writing the EFUSE. (Asked by Chunchu.)*/
+		BackupRegs[0] = PHY_QueryMacReg(pAdapter, REG_RCR, bMaskDWord);
+		BackupRegs[1] = PHY_QueryMacReg(pAdapter, REG_RXFLTMAP0, bMaskDWord);
+		BackupRegs[2] = PHY_QueryMacReg(pAdapter, REG_RXFLTMAP0+4, bMaskDWord);
+		BackupRegs[3] = PHY_QueryMacReg(pAdapter, REG_AFE_MISC, bMaskDWord);
+
+		PlatformEFIOWrite4Byte(pAdapter, REG_RCR, 0x1);
+		PlatformEFIOWrite1Byte(pAdapter, REG_RXFLTMAP0, 0);
+		PlatformEFIOWrite1Byte(pAdapter, REG_RXFLTMAP0+1, 0);
+		PlatformEFIOWrite1Byte(pAdapter, REG_RXFLTMAP0+2, 0);
+		PlatformEFIOWrite1Byte(pAdapter, REG_RXFLTMAP0+3, 0);
+		PlatformEFIOWrite1Byte(pAdapter, REG_RXFLTMAP0+4, 0);
+		PlatformEFIOWrite1Byte(pAdapter, REG_RXFLTMAP0+5, 0);
+
+		/* <20140410, Kordan> 0x11 = 0x4E, lower down LX_SPS0 voltage. (Asked by Chunchu)*/
+		PHY_SetMacReg(pAdapter, REG_AFE_MISC, bMaskByte1, 0x4E);
+		}
+	if (IS_HARDWARE_TYPE_8814AU(pAdapter)) {
+		/* <20131115, Kordan> Turn off Rx to prevent from being busy when writing the EFUSE. (Asked by Chunchu.)*/
+		BackupRegs[0] = PHY_QueryMacReg(pAdapter, REG_RCR, bMaskDWord);
+		BackupRegs[1] = PHY_QueryMacReg(pAdapter, REG_RXFLTMAP0, bMaskDWord);
+		BackupRegs[2] = PHY_QueryMacReg(pAdapter, REG_RXFLTMAP0+4, bMaskDWord);
+		BackupRegs[3] = PHY_QueryMacReg(pAdapter, REG_AFE_MISC, bMaskDWord);
+
+		PlatformEFIOWrite4Byte(pAdapter, REG_RCR, 0x1);
+		PlatformEFIOWrite1Byte(pAdapter, REG_RXFLTMAP0, 0);
+		PlatformEFIOWrite1Byte(pAdapter, REG_RXFLTMAP0+1, 0);
+		PlatformEFIOWrite1Byte(pAdapter, REG_RXFLTMAP0+2, 0);
+		PlatformEFIOWrite1Byte(pAdapter, REG_RXFLTMAP0+3, 0);
+		PlatformEFIOWrite1Byte(pAdapter, REG_RXFLTMAP0+4, 0);
+		PlatformEFIOWrite1Byte(pAdapter, REG_RXFLTMAP0+5, 0);
+
+		/* <20140410, Kordan> 0x11 = 0x4E, lower down LX_SPS0 voltage. (Asked by Chunchu)*/
+		PHY_SetMacReg(pAdapter, REG_AFE_MISC, bMaskByte1, 0x4E);
+		}
+}
+
+VOID efuse_PostUpdateAction(
+	PADAPTER	pAdapter,
+	pu4Byte	BackupRegs)
+{
+	if (IS_HARDWARE_TYPE_8812AU(pAdapter)) {
+		/* <20131115, Kordan> Turn on Rx and restore the registers. (Asked by Chunchu.)*/
+		PHY_SetMacReg(pAdapter, REG_RCR, bMaskDWord, BackupRegs[0]);
+		PHY_SetMacReg(pAdapter, REG_RXFLTMAP0, bMaskDWord, BackupRegs[1]);
+		PHY_SetMacReg(pAdapter, REG_RXFLTMAP0+4, bMaskDWord, BackupRegs[2]);
+		PHY_SetMacReg(pAdapter, REG_AFE_MISC, bMaskDWord, BackupRegs[3]);
+	}
+}
+
 #ifdef RTW_HALMAC
 #include "../../hal/hal_halmac.h"
 
@@ -1574,6 +1617,8 @@ efuse_OneByteWrite(
 	} else
 		rtw_write32(pAdapter, EFUSE_CTRL, efuseValue);
 
+	rtw_mdelay_os(1);
+
 	while ((0x80 &  rtw_read8(pAdapter, EFUSE_CTRL + 3)) && (tmpidx < 100)) {
 		rtw_mdelay_os(1);
 		tmpidx++;
@@ -1676,6 +1719,9 @@ u8 rtw_efuse_access(PADAPTER padapter, u8 bWrite, u16 start_addr, u16 cnts, u8 *
 	u16	real_content_len = 0, max_available_size = 0;
 	u8 res = _FAIL ;
 	u8(*rw8)(PADAPTER, u16, u8 *);
+	u32	backupRegs[4] = {0};
+
+	efuse_PreUpdateAction(padapter, backupRegs);
 
 	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_REAL_CONTENT_LEN, (PVOID)&real_content_len, _FALSE);
 	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
@@ -1706,6 +1752,8 @@ u8 rtw_efuse_access(PADAPTER padapter, u8 bWrite, u16 start_addr, u16 cnts, u8 *
 
 	Efuse_PowerSwitch(padapter, bWrite, _FALSE);
 
+	efuse_PostUpdateAction(padapter, backupRegs);
+
 	return res;
 }
 /* ------------------------------------------------------------------------------ */
@@ -1797,8 +1845,11 @@ u8 rtw_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data)
 	s32	i, j, idx;
 	u8	ret = _SUCCESS;
 	u16	mapLen = 0;
+	u32	backupRegs[4] = {0};
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
 
+	efuse_PreUpdateAction(padapter, backupRegs);
+
 	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (PVOID)&mapLen, _FALSE);
 
 	if ((addr + cnts) > mapLen)
@@ -1871,6 +1922,7 @@ u8 rtw_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data)
 	/*Efuse_PowerSwitch(padapter, _TRUE, _FALSE);*/
 
 exit:
+	efuse_PostUpdateAction(padapter, backupRegs);
 
 	rtw_mfree(map, mapLen);
 
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_ap.c b/drivers/net/wireless/rtl8814au/core/rtw_ap.c
index 1527834..0250880 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_ap.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_ap.c
@@ -3567,6 +3567,25 @@ void start_ap_mode(_adapter *padapter)
 
 }
 
+void rtw_ap_bcmc_sta_flush(_adapter *padapter)
+{
+#ifdef CONFIG_CONCURRENT_MODE
+	int cam_id = -1;
+	u8 *addr = adapter_mac_addr(padapter);
+
+	cam_id = rtw_iface_bcmc_id_get(padapter);
+	if (cam_id != INVALID_SEC_MAC_CAM_ID) {
+		RTW_PRINT("clear group key for "ADPT_FMT" addr:"MAC_FMT", camid:%d\n",
+			ADPT_ARG(padapter), MAC_ARG(addr), cam_id);
+		clear_cam_entry(padapter, cam_id);
+		rtw_camid_free(padapter, cam_id);
+		rtw_iface_bcmc_id_set(padapter, INVALID_SEC_MAC_CAM_ID);	/*init default value*/
+	}
+#else
+	invalidate_cam_all(padapter);
+#endif
+}
+
 void stop_ap_mode(_adapter *padapter)
 {
 	_irqL irqL;
@@ -3599,6 +3618,7 @@ void stop_ap_mode(_adapter *padapter)
 #endif
 
 	rtw_sta_flush(padapter, _TRUE);
+	rtw_ap_bcmc_sta_flush(padapter);
 
 	/* free_assoc_sta_resources	 */
 	rtw_free_all_stainfo(padapter);
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_cmd.c b/drivers/net/wireless/rtl8814au/core/rtw_cmd.c
index 1dc8d31..2ee0b51 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_cmd.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_cmd.c
@@ -4109,11 +4109,6 @@ u8 rtw_drvextra_cmd_hdl(_adapter *padapter, unsigned char *pbuf)
 		rtw_chk_hi_queue_hdl(padapter);
 		break;
 #endif
-#ifdef CONFIG_INTEL_WIDI
-	case INTEl_WIDI_WK_CID:
-		intel_widi_wk_hdl(padapter, pdrvextra_cmd->type, pdrvextra_cmd->pbuf);
-		break;
-#endif
 	/* add for CONFIG_IEEE80211W, none 11w can use it */
 	case RESET_SECURITYPRIV:
 		reset_securitypriv_hdl(padapter);
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_debug.c b/drivers/net/wireless/rtl8814au/core/rtw_debug.c
index f32ba0b..166f6ca 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_debug.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_debug.c
@@ -47,7 +47,6 @@ const char *rtw_log_level_str[] = {
 void dump_drv_version(void *sel)
 {
 	RTW_PRINT_SEL(sel, "%s %s\n", DRV_NAME, DRIVERVERSION);
-	RTW_PRINT_SEL(sel, "build time: %s %s\n", __DATE__, __TIME__);
 }
 
 void dump_drv_cfg(void *sel)
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_mlme.c b/drivers/net/wireless/rtl8814au/core/rtw_mlme.c
index 71ffc2a..5954790 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_mlme.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_mlme.c
@@ -1228,8 +1228,12 @@ void rtw_surveydone_event_callback(_adapter	*adapter, u8 *pbuf)
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_set_timer(&adapter->recvpriv.signal_stat_timer, adapter->recvpriv.signal_stat_sampling_interval);
+#else
 	rtw_set_signal_stat_timer(&adapter->recvpriv);
 #endif
+#endif
 
 	if (pmlmepriv->to_join == _TRUE) {
 		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)) {
@@ -1279,13 +1283,6 @@ void rtw_surveydone_event_callback(_adapter	*adapter, u8 *pbuf)
 					    || _SUCCESS != rtw_sitesurvey_cmd(adapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)
 					   ) {
 						rtw_set_to_roam(adapter, 0);
-#ifdef CONFIG_INTEL_WIDI
-						if (adapter->mlmepriv.widi_state == INTEL_WIDI_STATE_ROAMING) {
-							_rtw_memset(pmlmepriv->sa_ext, 0x00, L2SDTA_SERVICE_VE_LEN);
-							intel_widi_wk_cmd(adapter, INTEL_WIDI_LISTEN_WK, NULL, 0);
-							RTW_INFO("change to widi listen\n");
-						}
-#endif /* CONFIG_INTEL_WIDI */
 						rtw_free_assoc_resources(adapter, 1);
 						rtw_indicate_disconnect(adapter, 0, _FALSE);
 					} else
@@ -1515,20 +1512,12 @@ void rtw_indicate_connect(_adapter *padapter)
 	}
 
 	rtw_set_to_roam(padapter, 0);
-#ifdef CONFIG_INTEL_WIDI
-	if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_ROAMING) {
-		_rtw_memset(pmlmepriv->sa_ext, 0x00, L2SDTA_SERVICE_VE_LEN);
-		intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_WK, NULL, 0);
-		RTW_INFO("change to widi listen\n");
-	}
-#endif /* CONFIG_INTEL_WIDI */
 	if (!check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE))
 		rtw_mi_set_scan_deny(padapter, 3000);
 
 
 }
 
-
 /*
 *rtw_indicate_disconnect: the caller has to lock pmlmepriv->lock
 */
@@ -1840,8 +1829,12 @@ static void rtw_joinbss_update_network(_adapter *padapter, struct wlan_network *
 
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_set_timer(&padapter->recvpriv.signal_stat_timer, padapter->recvpriv.signal_stat_sampling_interval);
+#else
 	rtw_set_signal_stat_timer(&padapter->recvpriv);
 #endif
+#endif
 	padapter->recvpriv.signal_strength = ptarget_wlan->network.PhyInfo.SignalStrength;
 	padapter->recvpriv.signal_qual = ptarget_wlan->network.PhyInfo.SignalQuality;
 	/* the ptarget_wlan->network.Rssi is raw data, we use ptarget_wlan->network.PhyInfo.SignalStrength instead (has scaled) */
@@ -1856,8 +1849,12 @@ static void rtw_joinbss_update_network(_adapter *padapter, struct wlan_network *
 		);
 #endif
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_set_timer(&padapter->recvpriv.signal_stat_timer, padapter->recvpriv.signal_stat_sampling_interval);
+#else
 	rtw_set_signal_stat_timer(&padapter->recvpriv);
 #endif
+#endif
 
 	/* update fw_state */ /* will clr _FW_UNDER_LINKING here indirectly */
 
@@ -2442,10 +2439,6 @@ void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf)
 			roam = _TRUE;
 			roam_target = pmlmepriv->roam_network;
 		}
-#ifdef CONFIG_INTEL_WIDI
-		else if (adapter->mlmepriv.widi_state == INTEL_WIDI_STATE_CONNECTED)
-			roam = _TRUE;
-#endif /* CONFIG_INTEL_WIDI */
 
 		if (roam == _TRUE) {
 			if (rtw_to_roam(adapter) > 0)
@@ -2471,10 +2464,6 @@ void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf)
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 
 		rtw_indicate_disconnect(adapter, *(u16 *)pstadel->rsvd, pstadel->locally_generated);
-#ifdef CONFIG_INTEL_WIDI
-		if (!rtw_to_roam(adapter))
-			process_intel_widi_disconnect(adapter, 1);
-#endif /* CONFIG_INTEL_WIDI */
 
 		_rtw_roaming(adapter, roam_target);
 	}
@@ -2593,13 +2582,6 @@ void _rtw_join_timeout_handler(_adapter *adapter)
 				}
 				break;
 			} else {
-#ifdef CONFIG_INTEL_WIDI
-				if (adapter->mlmepriv.widi_state == INTEL_WIDI_STATE_ROAMING) {
-					_rtw_memset(pmlmepriv->sa_ext, 0x00, L2SDTA_SERVICE_VE_LEN);
-					intel_widi_wk_cmd(adapter, INTEL_WIDI_LISTEN_WK, NULL, 0);
-					RTW_INFO("change to widi listen\n");
-				}
-#endif /* CONFIG_INTEL_WIDI */
 				RTW_INFO("%s We've try roaming but fail\n", __FUNCTION__);
 				rtw_indicate_disconnect(adapter, 0, _FALSE);
 				break;
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_mlme_ext.c b/drivers/net/wireless/rtl8814au/core/rtw_mlme_ext.c
index 9ff7eaf..cc65410 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_mlme_ext.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_mlme_ext.c
@@ -5645,9 +5645,6 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
 #endif
-#ifdef CONFIG_INTEL_WIDI
-	u8 zero_array_check[L2SDTA_SERVICE_VE_LEN] = { 0x00 };
-#endif /* CONFIG_INTEL_WIDI */
 
 	/* RTW_INFO("%s\n", __FUNCTION__); */
 
@@ -5749,39 +5746,6 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 		/*	Value: */
 		wpsie[wpsielen++] = WPS_VERSION_1;	/*	Version 1.0 */
 
-#ifdef CONFIG_INTEL_WIDI
-		/*	Commented by Kurt */
-		/*	Appended WiDi info. only if we did issued_probereq_widi(), and then we saved ven. ext. in pmlmepriv->sa_ext. */
-		if (_rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == _FALSE
-		    || pmlmepriv->num_p2p_sdt != 0) {
-			/* Sec dev type */
-			*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_SEC_DEV_TYPE_LIST);
-			wpsielen += 2;
-
-			/*	Length: */
-			*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0008);
-			wpsielen += 2;
-
-			/*	Value: */
-			/*	Category ID */
-			*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_PDT_CID_DISPLAYS);
-			wpsielen += 2;
-
-			/*	OUI */
-			*(u32 *)(wpsie + wpsielen) = cpu_to_be32(INTEL_DEV_TYPE_OUI);
-			wpsielen += 4;
-
-			*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_PDT_SCID_WIDI_CONSUMER_SINK);
-			wpsielen += 2;
-
-			if (_rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == _FALSE) {
-				/*	Vendor Extension */
-				_rtw_memcpy(wpsie + wpsielen, pmlmepriv->sa_ext, L2SDTA_SERVICE_VE_LEN);
-				wpsielen += L2SDTA_SERVICE_VE_LEN;
-			}
-		}
-#endif /* CONFIG_INTEL_WIDI */
-
 		/*	WiFi Simple Config State */
 		/*	Type: */
 		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_SIMPLE_CONF_STATE);
@@ -6406,13 +6370,6 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 
 			result = process_p2p_group_negotation_req(pwdinfo, frame_body, len);
 			issue_p2p_GO_response(padapter, GetAddr2Ptr(pframe), frame_body, len, result);
-#ifdef CONFIG_INTEL_WIDI
-			if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) {
-				padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
-				_cancel_timer_ex(&(padapter->mlmepriv.listen_timer));
-				intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL, 0);
-			}
-#endif /* CONFIG_INTEL_WIDI */
 
 			/*	Commented by Albert 20110718 */
 			/*	No matter negotiating or negotiation failure, the driver should set up the restore P2P state timer. */
@@ -6564,11 +6521,6 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 									}
 								} else {
 									rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_DISMATCH);
-#ifdef CONFIG_INTEL_WIDI
-									_rtw_memcpy(pwdinfo->p2p_peer_device_addr, group_id.go_device_addr , ETH_ALEN);
-									rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
-#endif /* CONFIG_INTEL_WIDI */
-
 									status_code = P2P_STATUS_FAIL_UNKNOWN_P2PGROUP;
 								}
 							}
@@ -6614,13 +6566,6 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 				issue_p2p_invitation_response(padapter, GetAddr2Ptr(pframe), pwdinfo->inviteresp_info.token, status_code);
 				_set_timer(&pwdinfo->restore_p2p_state_timer, 3000);
 			}
-#ifdef CONFIG_INTEL_WIDI
-			if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) {
-				padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
-				_cancel_timer_ex(&(padapter->mlmepriv.listen_timer));
-				intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL, 0);
-			}
-#endif /* CONFIG_INTEL_WIDI */
 			break;
 		}
 		case P2P_INVIT_RESP: {
@@ -6685,13 +6630,6 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ);
 			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
-#ifdef CONFIG_INTEL_WIDI
-			if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) {
-				padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
-				_cancel_timer_ex(&(padapter->mlmepriv.listen_timer));
-				intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL, 0);
-			}
-#endif /* CONFIG_INTEL_WIDI */
 			break;
 
 		case P2P_PROVISION_DISC_RESP:
@@ -10500,12 +10438,6 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 
 	}
 
-#ifdef CONFIG_INTEL_WIDI
-	/* process_intel_widi_query_or_tigger(padapter, bssid); */
-	if (process_intel_widi_query_or_tigger(padapter, bssid))
-		return _FAIL;
-#endif /* CONFIG_INTEL_WIDI */
-
 #if defined(DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED) & 1
 	if (strcmp(bssid->Ssid.Ssid, DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED) == 0) {
 		RTW_INFO("Receiving %s("MAC_FMT", DSConfig:%u) from ch%u with ss:%3u, sq:%3u, RawRSSI:%3ld\n"
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_p2p.c b/drivers/net/wireless/rtl8814au/core/rtw_p2p.c
index ca69e57..7b6bd4f 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_p2p.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_p2p.c
@@ -1867,16 +1867,6 @@ u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
 	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
 	u32 len = 0, p2pielen = 0;
-#ifdef CONFIG_INTEL_WIDI
-	struct mlme_priv *pmlmepriv = &(pwdinfo->padapter->mlmepriv);
-	u8 zero_array_check[L2SDTA_SERVICE_VE_LEN] = { 0x00 };
-	u8 widi_version = 0, i = 0;
-
-	if (_rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == _FALSE)
-		widi_version = 35;
-	else if (pmlmepriv->num_p2p_sdt != 0)
-		widi_version = 40;
-#endif /* CONFIG_INTEL_WIDI */
 
 	/*	P2P OUI */
 	p2pielen = 0;
@@ -1959,13 +1949,7 @@ u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	/*	21->P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)  */
 	/*	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
 	/* *(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len ); */
-#ifdef CONFIG_INTEL_WIDI
-	if (widi_version == 35)
-		RTW_PUT_LE16(p2pie + p2pielen, 21 + 8 + pwdinfo->device_name_len);
-	else if (widi_version == 40)
-		RTW_PUT_LE16(p2pie + p2pielen, 21 + 8 * pmlmepriv->num_p2p_sdt + pwdinfo->device_name_len);
-	else
-#endif /* CONFIG_INTEL_WIDI */
+
 		RTW_PUT_LE16(p2pie + p2pielen, 21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
@@ -1980,25 +1964,6 @@ u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	RTW_PUT_BE16(p2pie + p2pielen, pwdinfo->supported_wps_cm);
 	p2pielen += 2;
 
-#ifdef CONFIG_INTEL_WIDI
-	if (widi_version == 40) {
-		/*	Primary Device Type */
-		/*	Category ID */
-		/* *(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA ); */
-		RTW_PUT_BE16(p2pie + p2pielen, pmlmepriv->p2p_pdt_cid);
-		p2pielen += 2;
-
-		/*	OUI */
-		/* *(u32*) ( p2pie + p2pielen ) = cpu_to_be32( WPSOUI ); */
-		RTW_PUT_BE32(p2pie + p2pielen, WPSOUI);
-		p2pielen += 4;
-
-		/*	Sub Category ID */
-		/* *(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_SCID_MEDIA_SERVER ); */
-		RTW_PUT_BE16(p2pie + p2pielen, pmlmepriv->p2p_pdt_scid);
-		p2pielen += 2;
-	} else
-#endif /* CONFIG_INTEL_WIDI */
 	{
 		/*	Primary Device Type */
 		/*	Category ID */
@@ -2018,32 +1983,6 @@ u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	}
 
 	/*	Number of Secondary Device Types */
-#ifdef CONFIG_INTEL_WIDI
-	if (widi_version == 35) {
-		p2pie[p2pielen++] = 0x01;
-
-		RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_CID_DISPLAYS);
-		p2pielen += 2;
-
-		RTW_PUT_BE32(p2pie + p2pielen, INTEL_DEV_TYPE_OUI);
-		p2pielen += 4;
-
-		RTW_PUT_BE16(p2pie + p2pielen, P2P_SCID_WIDI_CONSUMER_SINK);
-		p2pielen += 2;
-	} else if (widi_version == 40) {
-		p2pie[p2pielen++] = pmlmepriv->num_p2p_sdt;
-		for (; i < pmlmepriv->num_p2p_sdt; i++) {
-			RTW_PUT_BE16(p2pie + p2pielen, pmlmepriv->p2p_sdt_cid[i]);
-			p2pielen += 2;
-
-			RTW_PUT_BE32(p2pie + p2pielen, INTEL_DEV_TYPE_OUI);
-			p2pielen += 4;
-
-			RTW_PUT_BE16(p2pie + p2pielen, pmlmepriv->p2p_sdt_scid[i]);
-			p2pielen += 2;
-		}
-	} else
-#endif /* CONFIG_INTEL_WIDI */
 		p2pie[p2pielen++] = 0x00;	/*	No Secondary Device Type List */
 
 	/*	Device Name */
@@ -3330,9 +3269,17 @@ static void ro_ch_handler(_adapter *padapter)
 
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+static void ro_ch_timer_process(struct timer_list *t)
+#else
 static void ro_ch_timer_process(void *FunctionContext)
+#endif
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_adapter *adapter = from_timer(adapter, t, cfg80211_wdinfo.remain_on_ch_timer);
+#else
 	_adapter *adapter = (_adapter *)FunctionContext;
+#endif
 	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(adapter);
 
 	/* printk("%s\n", __FUNCTION__); */
@@ -4127,7 +4074,11 @@ void rtw_init_cfg80211_wifidirect_info(_adapter	*padapter)
 
 	_rtw_memset(pcfg80211_wdinfo, 0x00, sizeof(struct cfg80211_wifidirect_info));
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	timer_setup(&pcfg80211_wdinfo->remain_on_ch_timer, ro_ch_timer_process, 0);
+#else
 	_init_timer(&pcfg80211_wdinfo->remain_on_ch_timer, padapter->pnetdev, ro_ch_timer_process, padapter);
+#endif
 }
 #endif /* CONFIG_IOCTL_CFG80211	 */
 
@@ -4209,7 +4160,6 @@ int process_p2p_cross_connect_ie(PADAPTER padapter, u8 *IEs, u32 IELength)
 
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-
 	if (IELength <= _BEACON_IE_OFFSET_)
 		return ret;
 
@@ -4246,7 +4196,6 @@ void process_p2p_ps_ie(PADAPTER padapter, u8 *IEs, u32 IELength)
 	u8	find_p2p = _FALSE, find_p2p_ps = _FALSE;
 	u8	noa_offset, noa_num, noa_index;
 
-
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 #ifdef CONFIG_CONCURRENT_MODE
@@ -4329,7 +4278,6 @@ void p2p_ps_wk_hdl(_adapter *padapter, u8 p2p_ps_state)
 	struct pwrctrl_priv		*pwrpriv = adapter_to_pwrctl(padapter);
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-
 	/* Pre action for p2p state */
 	switch (p2p_ps_state) {
 	case P2P_PS_DISABLE:
@@ -4394,7 +4342,6 @@ u8 p2p_ps_wk_cmd(_adapter *padapter, u8 p2p_ps_state, u8 enqueue)
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8	res = _SUCCESS;
 
-
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
 #ifdef CONFIG_CONCURRENT_MODE
 	    || (padapter->hw_port != HW_PORT0)
@@ -4429,15 +4376,22 @@ u8 p2p_ps_wk_cmd(_adapter *padapter, u8 p2p_ps_state, u8 enqueue)
 
 exit:
 
-
 	return res;
 
 }
 #endif /* CONFIG_P2P_PS */
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+static void reset_ch_sitesurvey_timer_process(struct timer_list *t)
+#else
 static void reset_ch_sitesurvey_timer_process(void *FunctionContext)
+#endif
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_adapter *adapter = from_timer(adapter, t, wdinfo.reset_ch_sitesurvey);
+#else
 	_adapter *adapter = (_adapter *)FunctionContext;
+#endif
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -4454,9 +4408,17 @@ static void reset_ch_sitesurvey_timer_process(void *FunctionContext)
 	pwdinfo->rx_invitereq_info.scan_op_ch_only = 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+static void reset_ch_sitesurvey_timer_process2(struct timer_list *t)
+#else
 static void reset_ch_sitesurvey_timer_process2(void *FunctionContext)
+#endif
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_adapter *adapter = from_timer(adapter, t, wdinfo.reset_ch_sitesurvey2);
+#else
 	_adapter *adapter = (_adapter *)FunctionContext;
+#endif
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -4473,9 +4435,17 @@ static void reset_ch_sitesurvey_timer_process2(void *FunctionContext)
 	pwdinfo->p2p_info.scan_op_ch_only = 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+static void restore_p2p_state_timer_process (struct timer_list *t)
+#else
 static void restore_p2p_state_timer_process(void *FunctionContext)
+#endif
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_adapter *adapter = from_timer(adapter, t, wdinfo.restore_p2p_state_timer);
+#else
 	_adapter *adapter = (_adapter *)FunctionContext;
+#endif
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -4484,9 +4454,17 @@ static void restore_p2p_state_timer_process(void *FunctionContext)
 	p2p_protocol_wk_cmd(adapter, P2P_RESTORE_STATE_WK);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+static void pre_tx_scan_timer_process (struct timer_list *t)
+#else
 static void pre_tx_scan_timer_process(void *FunctionContext)
+#endif
 {
-	_adapter							*adapter = (_adapter *) FunctionContext;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+        _adapter *adapter = from_timer(adapter, t, wdinfo.pre_tx_scan_timer);
+#else
+	_adapter *adapter = (_adapter *) FunctionContext;
+#endif
 	struct	wifidirect_info				*pwdinfo = &adapter->wdinfo;
 	_irqL							irqL;
 	struct mlme_priv					*pmlmepriv = &adapter->mlmepriv;
@@ -4497,7 +4475,6 @@ static void pre_tx_scan_timer_process(void *FunctionContext)
 
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
-
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ)) {
 		if (_TRUE == pwdinfo->tx_prov_disc_info.benable) {	/*	the provision discovery request frame is trigger to send or not */
 			p2p_protocol_wk_cmd(adapter, P2P_PRE_TX_PROVDISC_PROCESS_WK);
@@ -4516,9 +4493,17 @@ static void pre_tx_scan_timer_process(void *FunctionContext)
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+static void find_phase_timer_process(struct timer_list *t)
+#else
 static void find_phase_timer_process(void *FunctionContext)
+#endif
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_adapter *adapter = from_timer(adapter, t, wdinfo.find_phase_timer);
+#else
 	_adapter *adapter = (_adapter *)FunctionContext;
+#endif
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -4775,6 +4760,16 @@ void rtw_init_wifidirect_timers(_adapter *padapter)
 {
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	timer_setup(&pwdinfo->find_phase_timer, find_phase_timer_process, 0);
+	timer_setup(&pwdinfo->restore_p2p_state_timer, restore_p2p_state_timer_process, 0);
+	timer_setup(&pwdinfo->pre_tx_scan_timer, pre_tx_scan_timer_process, 0);
+	timer_setup(&pwdinfo->reset_ch_sitesurvey, reset_ch_sitesurvey_timer_process, 0);
+	timer_setup(&pwdinfo->reset_ch_sitesurvey2, reset_ch_sitesurvey_timer_process2, 0);
+#ifdef CONFIG_CONCURRENT_MODE
+	timer_setup(&pwdinfo->ap_p2p_switch_timer, ap_p2p_switch_timer_process, 0);
+#endif
+#else
 	_init_timer(&pwdinfo->find_phase_timer, padapter->pnetdev, find_phase_timer_process, padapter);
 	_init_timer(&pwdinfo->restore_p2p_state_timer, padapter->pnetdev, restore_p2p_state_timer_process, padapter);
 	_init_timer(&pwdinfo->pre_tx_scan_timer, padapter->pnetdev, pre_tx_scan_timer_process, padapter);
@@ -4783,6 +4778,7 @@ void rtw_init_wifidirect_timers(_adapter *padapter)
 #ifdef CONFIG_CONCURRENT_MODE
 	_init_timer(&pwdinfo->ap_p2p_switch_timer, padapter->pnetdev, ap_p2p_switch_timer_process, padapter);
 #endif
+#endif
 }
 
 void rtw_init_wifidirect_addrs(_adapter *padapter, u8 *dev_addr, u8 *iface_addr)
@@ -5091,7 +5087,6 @@ void dbg_rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role, co
 }
 #endif /* CONFIG_DBG_P2P */
 
-
 int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 {
 	int ret = _SUCCESS;
@@ -5133,17 +5128,12 @@ int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 #endif
 
 	} else if (role == P2P_ROLE_DISABLE) {
-#ifdef CONFIG_INTEL_WIDI
-		if (padapter->mlmepriv.p2p_reject_disable == _TRUE)
-			return ret;
-#endif /* CONFIG_INTEL_WIDI */
 
 #ifdef CONFIG_IOCTL_CFG80211
 		if (padapter->wdinfo.driver_interface == DRIVER_CFG80211)
 			adapter_wdev_data(padapter)->p2p_enabled = _FALSE;
 #endif /* CONFIG_IOCTL_CFG80211 */
 
-
 		/* Disable P2P function */
 		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
 			_cancel_timer_ex(&pwdinfo->find_phase_timer);
@@ -5151,8 +5141,13 @@ int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 			_cancel_timer_ex(&pwdinfo->pre_tx_scan_timer);
 			_cancel_timer_ex(&pwdinfo->reset_ch_sitesurvey);
 			_cancel_timer_ex(&pwdinfo->reset_ch_sitesurvey2);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+			reset_ch_sitesurvey_timer_process(&pwdinfo->reset_ch_sitesurvey);
+			reset_ch_sitesurvey_timer_process2(&pwdinfo->reset_ch_sitesurvey2);
+#else
 			reset_ch_sitesurvey_timer_process(padapter);
 			reset_ch_sitesurvey_timer_process2(padapter);
+#endif
 #ifdef CONFIG_CONCURRENT_MODE
 			_cancel_timer_ex(&pwdinfo->ap_p2p_switch_timer);
 #endif
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_pwrctrl.c b/drivers/net/wireless/rtl8814au/core/rtw_pwrctrl.c
index d8b45f4..f61a5b3 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_pwrctrl.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_pwrctrl.c
@@ -393,10 +393,17 @@ void rtw_ps_processor(_adapter *padapter)
 	return;
 }
 
-void pwr_state_check_handler(RTW_TIMER_HDL_ARGS);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+void pwr_state_check_handler(struct timer_list *t)
+#else
 void pwr_state_check_handler(RTW_TIMER_HDL_ARGS)
+#endif
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_adapter *padapter = from_timer(padapter, t, pwrctrlpriv.pwr_state_check_timer);
+#else
 	_adapter *padapter = (_adapter *)FunctionContext;
+#endif
 	rtw_ps_cmd(padapter);
 }
 
@@ -1968,7 +1975,11 @@ void rtw_init_pwrctrl_priv(PADAPTER padapter)
 #endif /* CONFIG_LPS_RPWM_TIMER */
 #endif /* CONFIG_LPS_LCLK */
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	timer_setup(&pwrctrlpriv->pwr_state_check_timer, pwr_state_check_handler, 0);
+#else
 	rtw_init_timer(&pwrctrlpriv->pwr_state_check_timer, padapter, pwr_state_check_handler);
+#endif
 
 	pwrctrlpriv->wowlan_mode = _FALSE;
 	pwrctrlpriv->wowlan_ap_mode = _FALSE;
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_recv.c b/drivers/net/wireless/rtl8814au/core/rtw_recv.c
index d4deb85..ff37aa0 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_recv.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_recv.c
@@ -28,9 +28,12 @@
 
 #endif
 
-
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+void rtw_signal_stat_timer_hdl(struct timer_list *t);
+#else
 void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS);
+#endif
 
 enum {
 	SIGNAL_STAT_CALC_PROFILE_0 = 0,
@@ -52,8 +55,6 @@ u8 signal_stat_calc_profile[SIGNAL_STAT_CALC_PROFILE_MAX][2] = {
 void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
 {
 
-
-
 	_rtw_memset((u8 *)psta_recvpriv, 0, sizeof(struct sta_recv_priv));
 
 	_rtw_spinlock_init(&psta_recvpriv->lock);
@@ -63,7 +64,6 @@ void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
 
 	_rtw_init_queue(&psta_recvpriv->defrag_q);
 
-
 }
 
 sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
@@ -73,7 +73,6 @@ sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
 	union recv_frame *precvframe;
 	sint	res = _SUCCESS;
 
-
 	/* We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc(). */
 	/* _rtw_memset((unsigned char *)precvpriv, 0, sizeof (struct  recv_priv)); */
 
@@ -113,7 +112,6 @@ sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
 
 	precvframe = (union recv_frame *) precvpriv->precv_frame_buf;
 
-
 	for (i = 0; i < NR_RECVFRAME ; i++) {
 		_rtw_init_listhead(&(precvframe->u.list));
 
@@ -139,17 +137,24 @@ sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
 	res = rtw_hal_init_recv_priv(padapter);
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	timer_setup(&precvpriv->signal_stat_timer, rtw_signal_stat_timer_hdl, 0);
+#else
 	rtw_init_timer(&precvpriv->signal_stat_timer, padapter, RTW_TIMER_HDL_NAME(signal_stat));
+#endif
 
 	precvpriv->signal_stat_sampling_interval = 2000; /* ms */
 	/* precvpriv->signal_stat_converging_constant = 5000; */ /* ms */
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_set_timer(&precvpriv->signal_stat_timer, precvpriv->signal_stat_sampling_interval);
+#else
 	rtw_set_signal_stat_timer(precvpriv);
+#endif
 #endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 exit:
 
-
 	return res;
 
 }
@@ -4245,16 +4185,21 @@ s32 rtw_recv_entry(union recv_frame *precvframe)
 		padapter->mppriv.rx_pktloss = precvpriv->rx_drop;
 #endif
 
-
-
 	return ret;
 }
 
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+void rtw_signal_stat_timer_hdl(struct timer_list *t)
+#else
 void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS)
+#endif
 {
-	_adapter *adapter = (_adapter *)FunctionContext;
-	struct recv_priv *recvpriv = &adapter->recvpriv;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_adapter *padapter = from_timer(padapter, t, recvpriv.signal_stat_timer);
+#else
+	_adapter *padapter = (_adapter *)FunctionContext;
+#endif
+	struct recv_priv *recvpriv = &padapter->recvpriv;
 
 	u32 tmp_s, tmp_q;
 	u8 avg_signal_strength = 0;
@@ -4263,10 +4208,10 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS)
 	u32 num_signal_qual = 0;
 	u8 ratio_pre_stat = 0, ratio_curr_stat = 0, ratio_total = 0, ratio_profile = SIGNAL_STAT_CALC_PROFILE_0;
 
-	if (adapter->recvpriv.is_signal_dbg) {
+	if(padapter->recvpriv.is_signal_dbg) {
 		/* update the user specific value, signal_strength_dbg, to signal_strength, rssi */
-		adapter->recvpriv.signal_strength = adapter->recvpriv.signal_strength_dbg;
-		adapter->recvpriv.rssi = (s8)translate_percentage_to_dbm((u8)adapter->recvpriv.signal_strength_dbg);
+		padapter->recvpriv.signal_strength = padapter->recvpriv.signal_strength_dbg;
+		padapter->recvpriv.rssi=(s8)translate_percentage_to_dbm((u8)padapter->recvpriv.signal_strength_dbg);
 	} else {
 
 		if (recvpriv->signal_strength_data.update_req == 0) { /* update_req is clear, means we got rx */
@@ -4284,14 +4229,14 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS)
 		}
 
 		if (num_signal_strength == 0) {
-			if (rtw_get_on_cur_ch_time(adapter) == 0
-			    || rtw_get_passing_time_ms(rtw_get_on_cur_ch_time(adapter)) < 2 * adapter->mlmeextpriv.mlmext_info.bcn_interval
+			if (rtw_get_on_cur_ch_time(padapter) == 0
+			    || rtw_get_passing_time_ms(rtw_get_on_cur_ch_time(padapter)) < 2 * padapter->mlmeextpriv.mlmext_info.bcn_interval
 			   )
 				goto set_timer;
 		}
 
-		if (check_fwstate(&adapter->mlmepriv, _FW_UNDER_SURVEY) == _TRUE
-		    || check_fwstate(&adapter->mlmepriv, _FW_LINKED) == _FALSE
+		if (check_fwstate(&padapter->mlmepriv, _FW_UNDER_SURVEY) == _TRUE
+		    || check_fwstate(&padapter->mlmepriv, _FW_LINKED) == _FALSE
 		   )
 			goto set_timer;
 
@@ -4344,10 +4289,12 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS)
 	}
 
 set_timer:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_set_timer(&recvpriv->signal_stat_timer, recvpriv->signal_stat_sampling_interval);
+#else
 	rtw_set_signal_stat_timer(recvpriv);
-
-}
 #endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
+}
 
 static void rx_process_rssi(_adapter *padapter, union recv_frame *prframe)
 {
@@ -4589,7 +4536,6 @@ void rtw_reset_continual_no_rx_packet(struct sta_info *sta, int tid_index)
 	ATOMIC_SET(&sta->continual_no_rx_packet[tid_index], 0);
 }
 
-
 s32 pre_recv_entry(union recv_frame *precvframe, u8 *pphy_status)
 {
 	s32 ret = _SUCCESS;
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_tdls.c b/drivers/net/wireless/rtl8814au/core/rtw_tdls.c
index be31530..1e4c8d1 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_tdls.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_tdls.c
@@ -3141,9 +3141,17 @@ void rtw_build_tunneled_probe_rsp_ies(_adapter *padapter, struct xmit_frame *pxm
 }
 #endif /* CONFIG_WFD */
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+void _tdls_tpk_timer_hdl(struct timer_list *t)
+#else
 void _tdls_tpk_timer_hdl(void *FunctionContext)
+#endif
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	struct sta_info *ptdls_sta = from_timer(ptdls_sta, t, sta.TPK_timer);
+#else
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
+#endif
 	struct tdls_txmgmt txmgmt;
 
 	_rtw_memset(&txmgmt, 0x00, sizeof(struct tdls_txmgmt));
@@ -3246,7 +3254,11 @@ void _tdls_pti_timer_hdl(void *FunctionContext)
 void rtw_init_tdls_timer(_adapter *padapter, struct sta_info *psta)
 {
 	psta->padapter = padapter;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	timer_setup(&psta->TPK_timer, _TPK_timer_hdl, 0);
+#else
 	_init_timer(&psta->TPK_timer, padapter->pnetdev, _tdls_tpk_timer_hdl, psta);
+#endif
 #ifdef CONFIG_TDLS_CH_SW
 	_init_timer(&psta->ch_sw_timer, padapter->pnetdev, _tdls_ch_switch_timer_hdl, psta);
 	_init_timer(&psta->delay_timer, padapter->pnetdev, _tdls_delay_timer_hdl, psta);
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_wlan_util.c b/drivers/net/wireless/rtl8814au/core/rtw_wlan_util.c
index 5943c12..54c9a35 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_wlan_util.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_wlan_util.c
@@ -3038,11 +3038,6 @@ void update_tx_basic_rate(_adapter *padapter, u8 wirelessmode)
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 #endif /* CONFIG_P2P */
-#ifdef CONFIG_INTEL_WIDI
-	if (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_NONE)
-		return;
-#endif /* CONFIG_INTEL_WIDI */
-
 	_rtw_memset(supported_rates, 0, NDIS_802_11_LENGTH_RATES_EX);
 
 	/* clear B mod if current channel is in 5G band, avoid tx cck rate in 5G band. */
diff --git a/drivers/net/wireless/rtl8814au/dkms.conf b/drivers/net/wireless/rtl8814au/dkms.conf
index b67a286..acadace 100644
--- a/drivers/net/wireless/rtl8814au/dkms.conf
+++ b/drivers/net/wireless/rtl8814au/dkms.conf
@@ -1,5 +1,5 @@
 PACKAGE_NAME="realtek-rtl88xxau"
-PACKAGE_VERSION="5.1.5~20171022"
+PACKAGE_VERSION="5.1.5~20171206"
 CLEAN="make clean"
 BUILT_MODULE_NAME[0]=8812au
 DEST_MODULE_LOCATION[0]="/updates"
diff --git a/drivers/net/wireless/rtl8814au/hal/hal_com_phycfg.c b/drivers/net/wireless/rtl8814au/hal/hal_com_phycfg.c
index dc28867..9b448d2 100644
--- a/drivers/net/wireless/rtl8814au/hal/hal_com_phycfg.c
+++ b/drivers/net/wireless/rtl8814au/hal/hal_com_phycfg.c
@@ -3491,9 +3491,8 @@ PHY_SetTxPowerLimit(
 		if (powerLimit < prevPowerLimit)
 			pHalData->TxPwrLimit_2_4G[regulation][bandwidth][rateSection][channelIndex][RF_PATH_A] = powerLimit;
 
-		if (0)
-			RTW_INFO("2.4G Band value : [regulation %d][bw %d][rate_section %d][chnl %d][val %d]\n"
-				, regulation, bandwidth, rateSection, channelIndex, pHalData->TxPwrLimit_2_4G[regulation][bandwidth][rateSection][channelIndex][ODM_RF_PATH_A]);
+		RTW_INFO("2.4G Band value : [regulation %d][bw %d][rate_section %d][chnl %d][val %d]\n"
+			, regulation, bandwidth, rateSection, channelIndex, pHalData->TxPwrLimit_2_4G[regulation][bandwidth][rateSection][channelIndex][ODM_RF_PATH_A]);
 	} else if (eqNByte(Band, (u8 *)("5G"), 2)) {
 
 		channelIndex = phy_GetChannelIndexOfTxPowerLimit(BAND_ON_5G, channel);
@@ -3512,9 +3511,8 @@ PHY_SetTxPowerLimit(
 		if (powerLimit < prevPowerLimit)
 			pHalData->TxPwrLimit_5G[regulation][bandwidth][rateSection][channelIndex][RF_PATH_A] = powerLimit;
 
-		if (0)
-			RTW_INFO("5G Band value : [regulation %d][bw %d][rate_section %d][chnl %d][val %d]\n"
-				, regulation, bandwidth, rateSection, channel, pHalData->TxPwrLimit_5G[regulation][bandwidth][rateSection][channelIndex][RF_PATH_A]);
+		RTW_INFO("5G Band value : [regulation %d][bw %d][rate_section %d][chnl %d][val %d]\n"
+			, regulation, bandwidth, rateSection, channel, pHalData->TxPwrLimit_5G[regulation][bandwidth][rateSection][channelIndex][RF_PATH_A]);
 	} else {
 		RTW_PRINT("Cannot recognize the band info in %s\n", Band);
 		return;
diff --git a/drivers/net/wireless/rtl8814au/hal/hal_mp.c b/drivers/net/wireless/rtl8814au/hal/hal_mp.c
index 4f53504..f7d8618 100644
--- a/drivers/net/wireless/rtl8814au/hal/hal_mp.c
+++ b/drivers/net/wireless/rtl8814au/hal/hal_mp.c
@@ -985,8 +985,9 @@ void mpt_SetRFPath_8812A(PADAPTER pAdapter)
 	}
 
 	switch (ulAntennaRx) {
-		u32 reg0xC50 = 0;
+		u32 reg0xC50;
 	case ANTENNA_A:
+		reg0xC50 = 0;
 		PHY_SetBBReg(pAdapter, rRxPath_Jaguar, bMaskByte0, 0x11);
 		PHY_SetRFReg(pAdapter, ODM_RF_PATH_B, RF_AC_Jaguar, 0xF0000, 0x1); /*/ RF_B_0x0[19:16] = 1, Standby mode*/
 		PHY_SetBBReg(pAdapter, rCCK_RX_Jaguar, bCCK_RX_Jaguar, 0x0);
@@ -1013,6 +1014,7 @@ void mpt_SetRFPath_8812A(PADAPTER pAdapter)
 		}
 		break;
 	case ANTENNA_B:
+		reg0xC50 = 0;
 		PHY_SetBBReg(pAdapter, rRxPath_Jaguar, bMaskByte0, 0x22);
 		PHY_SetRFReg(pAdapter, ODM_RF_PATH_A, RF_AC_Jaguar, 0xF0000, 0x1);/*/ RF_A_0x0[19:16] = 1, Standby mode */
 		PHY_SetBBReg(pAdapter, rCCK_RX_Jaguar, bCCK_RX_Jaguar, 0x1);
diff --git a/drivers/net/wireless/rtl8814au/hal/led/hal_usb_led.c b/drivers/net/wireless/rtl8814au/hal/led/hal_usb_led.c
index 117bc93..ae0535c 100644
--- a/drivers/net/wireless/rtl8814au/hal/led/hal_usb_led.c
+++ b/drivers/net/wireless/rtl8814au/hal/led/hal_usb_led.c
@@ -1815,9 +1815,17 @@ void BlinkHandler(PLED_USB pLed)
  *		Callback function of LED BlinkTimer,
  *		it just schedules to corresponding BlinkWorkItem/led_blink_hdl
  *   */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+void BlinkTimerCallback(struct timer_list *t)
+#else
 void BlinkTimerCallback(void *data)
+#endif
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	PLED_USB	 pLed = from_timer(pLed, t, BlinkTimer);
+#else
 	PLED_USB	 pLed = (PLED_USB)data;
+#endif
 	_adapter		*padapter = pLed->padapter;
 
 	/* RTW_INFO("%s\n", __FUNCTION__); */
@@ -4229,7 +4237,11 @@ InitLed(
 	pLed->LedPin = LedPin;
 
 	ResetLedStatus(pLed);
-	_init_timer(&(pLed->BlinkTimer), padapter->pnetdev, BlinkTimerCallback, pLed);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	timer_setup(&pLed->BlinkTimer, BlinkTimerCallback, 0);
+#else
+	_init_timer(&pLed->BlinkTimer, padapter->pnetdev, BlinkTimerCallback, pLed);
+#endif
 	_init_workitem(&(pLed->BlinkWorkItem), BlinkWorkItemCallback, pLed);
 }
 
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/rtl8814au_xmit.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/rtl8814au_xmit.c
index 9102560..5746dbb 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/rtl8814au_xmit.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/rtl8814au_xmit.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -22,7 +22,6 @@
 //#include <drv_types.h>
 #include <rtl8814a_hal.h>
 
-
 s32	rtl8814au_init_xmit_priv(_adapter *padapter)
 {
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
@@ -45,22 +44,22 @@ void	rtl8814au_free_xmit_priv(_adapter *padapter)
 }
 
 static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bagg_pkt)
-{	
+{
       int	pull=0;
 	uint	qsel;
 	u8 data_rate,pwr_status,offset;
 	_adapter			*padapter = pxmitframe->padapter;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;		
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
 	u8	*ptxdesc =  pmem;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	sint	bmcst = IS_MCAST(pattrib->ra);
-	u16				SWDefineContent = 0x0;	
+	u16				SWDefineContent = 0x0;
 	u8				DriverFixedRate = 0x0;
 
-#ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX 
+#ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
 	if (padapter->registrypriv.mp_mode == 0)
 	{
 		if((PACKET_OFFSET_SZ != 0) && (!bagg_pkt) &&(rtw_usb_bulk_size_boundary(padapter,TXDESC_SIZE+sz)==_FALSE))
@@ -73,20 +72,20 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 #endif	// CONFIG_USE_USB_BUFFER_ALLOC_TX
 
 	_rtw_memset(ptxdesc, 0, TXDESC_SIZE);
-	
+
         //4 offset 0
 	//SET_TX_DESC_FIRST_SEG_8812(ptxdesc, 1);
 	SET_TX_DESC_LAST_SEG_8814A(ptxdesc, 1);
 	//SET_TX_DESC_OWN_8812(ptxdesc, 1);
-		
+
 	//RTW_INFO("%s==> pkt_len=%d,bagg_pkt=%02x\n",__FUNCTION__,sz,bagg_pkt);
 	SET_TX_DESC_PKT_SIZE_8814A(ptxdesc, sz);
-	
-	offset = TXDESC_SIZE + OFFSET_SZ;		
 
-#ifdef CONFIG_TX_EARLY_MODE	
-	if(bagg_pkt){		
-		offset += EARLY_MODE_INFO_SIZE ;//0x28			
+	offset = TXDESC_SIZE + OFFSET_SZ;
+
+#ifdef CONFIG_TX_EARLY_MODE
+	if(bagg_pkt){
+		offset += EARLY_MODE_INFO_SIZE ;//0x28
 	}
 #endif
 	//RTW_INFO("%s==>offset(0x%02x)  \n",__FUNCTION__,offset);
@@ -100,11 +99,11 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 	if (padapter->registrypriv.mp_mode == 0)
 	{
 		if((PACKET_OFFSET_SZ != 0) && (!bagg_pkt)){
-			if((pull) && (pxmitframe->pkt_offset>0)) {	
-				pxmitframe->pkt_offset = pxmitframe->pkt_offset -1;		
+			if((pull) && (pxmitframe->pkt_offset>0)) {
+				pxmitframe->pkt_offset = pxmitframe->pkt_offset -1;
 			}
 		}
-	}	
+	}
 #endif
 
 	//RTW_INFO("%s, pkt_offset=0x%02x\n",__FUNCTION__,pxmitframe->pkt_offset);
@@ -135,7 +134,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 
 	if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
 	{
-		//RTW_INFO("pxmitframe->frame_tag == DATA_FRAMETAG\n");		
+		//RTW_INFO("pxmitframe->frame_tag == DATA_FRAMETAG\n");
 
 		rtl8814a_fill_txdesc_sectype(pattrib, ptxdesc);
 
@@ -195,7 +194,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 
 			if (padapter->fix_rate != 0xFF) { // modify data rate by iwpriv
 				SET_TX_DESC_USE_RATE_8814A(ptxdesc, 1);
-				DriverFixedRate = 0x01;				
+				DriverFixedRate = 0x01;
 				if(padapter->fix_rate & BIT(7))
 					SET_TX_DESC_DATA_SHORT_8814A(ptxdesc, 	1);
 
@@ -206,9 +205,9 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 
 			if (pattrib->ldpc)
 				SET_TX_DESC_DATA_LDPC_8814A(ptxdesc, 1);
-			if (pattrib->stbc)	
+			if (pattrib->stbc)
 				SET_TX_DESC_DATA_STBC_8814A(ptxdesc, 1);
-			
+
 			//work arond before fixing RA
 			//SET_TX_DESC_USE_RATE_8814A(ptxdesc, 1);
 			//SET_TX_DESC_TX_RATE_8814A(ptxdesc, 0x10);
@@ -234,7 +233,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 	}
 	else if((pxmitframe->frame_tag&0x0f)== MGNT_FRAMETAG)
 	{
-		//RTW_INFO("pxmitframe->frame_tag == MGNT_FRAMETAG\n");	
+		//RTW_INFO("pxmitframe->frame_tag == MGNT_FRAMETAG\n");
 
 		SET_TX_DESC_USE_RATE_8814A(ptxdesc, 1);
 		DriverFixedRate = 0x01;
@@ -251,7 +250,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 		}
 
 		// VHT NDPA or HT NDPA Packet for Beamformer.
-		if((pattrib->subtype == WIFI_NDPA) || 
+		if((pattrib->subtype == WIFI_NDPA) ||
 			((pattrib->subtype == WIFI_ACTION_NOACK) && (pattrib->order == 1)))
 		{
 			SET_TX_DESC_NAV_USE_HDR_8814A(ptxdesc, 1);
@@ -266,7 +265,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			//if(pattrib->rts_cca)
 			//{
 			//	SET_TX_DESC_NDPA_8812(ptxdesc, 2);
-			//}	
+			//}
 			//else
 			{
 				SET_TX_DESC_NDPA_8814A(ptxdesc, 1);
@@ -316,7 +315,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 	SET_TX_DESC_SW_DEFINE_8814A(ptxdesc,  SWDefineContent);
 
 	SET_TX_DESC_GID_8814A(ptxdesc, pattrib->txbf_g_id);
-	SET_TX_DESC_PAID_8814A(ptxdesc, pattrib->txbf_p_aid);				
+	SET_TX_DESC_PAID_8814A(ptxdesc, pattrib->txbf_p_aid);
 
 /* injected frame */
 	if(pattrib->inject == 0xa5) {
@@ -335,7 +334,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 		SET_TX_DESC_TX_RATE_8814A(ptxdesc, MRateToHwRate(pattrib->rate));
 		if (pattrib->ldpc) {
 			SET_TX_DESC_DATA_LDPC_8814A(ptxdesc, 1);
-		} else { 
+		} else {
 			SET_TX_DESC_DATA_LDPC_8814A(ptxdesc, 0);
 		}
 		SET_TX_DESC_DATA_STBC_8814A(ptxdesc, pattrib->stbc & 3);
@@ -343,7 +342,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 	}
 
 	rtl8814a_cal_txdesc_chksum(ptxdesc);
-	_dbg_dump_tx_info(padapter,pxmitframe->frame_tag,ptxdesc);	
+	_dbg_dump_tx_info(padapter,pxmitframe->frame_tag,ptxdesc);
 	return pull;
 }
 
@@ -438,18 +437,18 @@ static s32 rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 	mem_addr = pxmitframe->buf_addr;
 
 	//RTW_INFO("rtw_dump_xframe()\n");
-	
+
 	for (t = 0; t < pattrib->nr_frags; t++)
 	{
 		if (inner_ret != _SUCCESS && ret == _SUCCESS)
 			ret = _FAIL;
-			
+
 		if (t != (pattrib->nr_frags - 1))
 		{
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("pattrib->nr_frags=%d\n", pattrib->nr_frags));
 
 			sz = pxmitpriv->frag_len;
-			sz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 : pattrib->icv_len);					
+			sz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 : pattrib->icv_len);
 		}
 		else //no frag
 		{
@@ -457,12 +456,12 @@ static s32 rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 		}
 
 		pull = update_txdesc(pxmitframe, mem_addr, sz, _FALSE);
-             
+
 		if(pull)
 		{
 			mem_addr += PACKET_OFFSET_SZ; //pull txdesc head
-			
-			//pxmitbuf ->pbuf = mem_addr;			
+
+			//pxmitbuf ->pbuf = mem_addr;
 			pxmitframe->buf_addr = mem_addr;
 
 			w_sz = sz + TXDESC_SIZE;
@@ -470,7 +469,7 @@ static s32 rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 		else
 		{
 			w_sz = sz + TXDESC_SIZE + PACKET_OFFSET_SZ;
-		}	
+		}
 
 		ff_hwaddr = rtw_get_ff_hwaddr(pxmitframe);
 
@@ -484,19 +483,19 @@ static s32 rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 		rtw_count_tx_stats(padapter, pxmitframe, sz);
 
 		//RTW_INFO("rtw_write_port, w_sz=%d\n", w_sz);
-		//RTW_INFO("rtw_write_port, w_sz=%d, sz=%d, txdesc_sz=%d, tid=%d\n", w_sz, sz, w_sz-sz, pattrib->priority);      
+		//RTW_INFO("rtw_write_port, w_sz=%d, sz=%d, txdesc_sz=%d, tid=%d\n", w_sz, sz, w_sz-sz, pattrib->priority);
 
 		mem_addr += w_sz;
 
 		mem_addr = (u8 *)RND4(((SIZE_PTR)(mem_addr)));
 
 	}
-	
+
 	rtw_free_xmitframe(pxmitpriv, pxmitframe);
-	
+
 	if  (ret != _SUCCESS)
 		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_UNKNOWN);
-	
+
 	return ret;
 }
 
@@ -568,7 +567,7 @@ s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 	//3 1. pick up first frame
 	do {
 		rtw_free_xmitframe(pxmitpriv, pxmitframe);
-			
+
 		pxmitframe = rtw_dequeue_xframe(pxmitpriv, pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);
 		if (pxmitframe == NULL) {
 			// no more xmit frame, release xmit buffer
@@ -629,9 +628,10 @@ s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 	// check pkt amount in one bulk
 	descCount = 0;
 	bulkPtr = bulkSize;
-	if (pbuf < bulkPtr)
+	if (pbuf < bulkPtr) {
 		descCount++;
-		if (descCount == pHalData->UsbTxAggDescNum)
+	}
+	if (descCount == pHalData->UsbTxAggDescNum)
 			goto agg_end;
 	else {
 		descCount = 0;
@@ -678,7 +678,7 @@ s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 
 	xmitframe_phead = get_list_head(&ptxservq->sta_pending);
 	xmitframe_plist = get_next(xmitframe_phead);
-	
+
 	while (rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist) == _FALSE)
 	{
 		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
@@ -686,23 +686,23 @@ s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 
 		if(_FAIL == rtw_hal_busagg_qsel_check(padapter,pfirstframe->attrib.qsel,pxmitframe->attrib.qsel))
 			break;
-		
+
              pxmitframe->agg_num = 0; // not first frame of aggregation
 		#ifdef CONFIG_TX_EARLY_MODE
 		pxmitframe->pkt_offset = 1;// not first frame of aggregation,reserve offset for EM Info
 		#else
 		pxmitframe->pkt_offset = 0; // not first frame of aggregation, no need to reserve offset
-		#endif	
+		#endif
 
 		len = xmitframe_need_length(pxmitframe) + TXDESC_SIZE +(pxmitframe->pkt_offset*PACKET_OFFSET_SZ);
-		
+
 		if (_RND8(pbuf + len) > MAX_XMITBUF_SZ)
 		//if (_RND8(pbuf + len) > (MAX_XMITBUF_SZ/2))//to do : for TX TP finial tune , Georgia 2012-0323
 		{
 			//RTW_INFO("%s....len> MAX_XMITBUF_SZ\n",__FUNCTION__);
 			pxmitframe->agg_num = 1;
-			pxmitframe->pkt_offset = 1;			
-			break;		
+			pxmitframe->pkt_offset = 1;
+			break;
 		}
 		rtw_list_delete(&pxmitframe->list);
 		ptxservq->qcnt--;
@@ -731,7 +731,7 @@ s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 
 //		pxmitframe->pxmitbuf = pxmitbuf;
 		pxmitframe->buf_addr = pxmitbuf->pbuf + pbuf;
-	
+
 		if (rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe) == _FALSE) {
 			RTW_INFO("%s coalesce failed \n",__FUNCTION__);
 			rtw_free_xmitframe(pxmitpriv, pxmitframe);
@@ -744,7 +744,7 @@ s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 
 		// (len - TXDESC_SIZE) == pxmitframe->attrib.last_txcmdsz
 		update_txdesc(pxmitframe, pxmitframe->buf_addr, pxmitframe->attrib.last_txcmdsz,_TRUE);
-				
+
 		// don't need xmitframe any more
 		rtw_free_xmitframe(pxmitpriv, pxmitframe);
 
@@ -754,9 +754,9 @@ s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 
 
 		pfirstframe->agg_num++;
-#ifdef CONFIG_TX_EARLY_MODE	
-		pxmitpriv->agg_pkt[pfirstframe->agg_num-1].offset = _RND8(len); 			
-		pxmitpriv->agg_pkt[pfirstframe->agg_num-1].pkt_len = pxmitframe->attrib.last_txcmdsz;						
+#ifdef CONFIG_TX_EARLY_MODE
+		pxmitpriv->agg_pkt[pfirstframe->agg_num-1].offset = _RND8(len);
+		pxmitpriv->agg_pkt[pfirstframe->agg_num-1].pkt_len = pxmitframe->attrib.last_txcmdsz;
 #endif
 		if (MAX_TX_AGG_PACKET_NUMBER == pfirstframe->agg_num)
 			break;
@@ -801,27 +801,25 @@ s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 #endif	// CONFIG_USE_USB_BUFFER_ALLOC_TX
 
 	update_txdesc(pfirstframe, pfirstframe->buf_addr, pfirstframe->attrib.last_txcmdsz,_TRUE);
-		
+
         #ifdef CONFIG_TX_EARLY_MODE
 	//prepare EM info for first frame, agg_num value start from 1
 	pxmitpriv->agg_pkt[0].offset = _RND8(pfirstframe->attrib.last_txcmdsz +TXDESC_SIZE +(pfirstframe->pkt_offset*PACKET_OFFSET_SZ));
-	pxmitpriv->agg_pkt[0].pkt_len = pfirstframe->attrib.last_txcmdsz;//get from rtw_xmitframe_coalesce 			
+	pxmitpriv->agg_pkt[0].pkt_len = pfirstframe->attrib.last_txcmdsz;//get from rtw_xmitframe_coalesce
 
 	UpdateEarlyModeInfo8812(pxmitpriv,pxmitbuf );
 	#endif
-	
+
 	//3 4. write xmit buffer to USB FIFO
 	ff_hwaddr = rtw_get_ff_hwaddr(pfirstframe);
 //RTW_INFO("%s ===================================== write port,buf_size(%d) \n",__FUNCTION__,pbuf_tail);
 	// xmit address == ((xmit_frame*)pxmitbuf->priv_data)->buf_addr
 	rtw_write_port(padapter, ff_hwaddr, pbuf_tail, (u8*)pxmitbuf);
 
-
 	//3 5. update statisitc
 	pbuf_tail -= (pfirstframe->agg_num * TXDESC_SIZE);
 	pbuf_tail -= (pfirstframe->pkt_offset * PACKET_OFFSET_SZ);
-	
-	
+
 	rtw_count_tx_stats(padapter, pfirstframe, pbuf_tail);
 
 	rtw_free_xmitframe(pxmitpriv, pfirstframe);
@@ -832,11 +830,11 @@ s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 #else //CONFIG_USB_TX_AGGREGATION
 
 s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
-{		
+{
 
 	struct hw_xmit *phwxmits;
 	sint hwentry;
-	struct xmit_frame *pxmitframe=NULL;	
+	struct xmit_frame *pxmitframe=NULL;
 	int res=_SUCCESS, xcnt = 0;
 
 	phwxmits = pxmitpriv->hwxmits;
@@ -846,70 +844,65 @@ s32 rtl8814au_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 
 	if(pxmitbuf==NULL)
 	{
-		pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);		
+		pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
 		if(!pxmitbuf)
 		{
 			return _FALSE;
-		}			
-	}	
-
+		}
+	}
 
 	do
-	{		
+	{
 		pxmitframe =  rtw_dequeue_xframe(pxmitpriv, phwxmits, hwentry);
-		
+
 		if(pxmitframe)
 		{
-			pxmitframe->pxmitbuf = pxmitbuf;				
+			pxmitframe->pxmitbuf = pxmitbuf;
 
 			pxmitframe->buf_addr = pxmitbuf->pbuf;
 
-			pxmitbuf->priv_data = pxmitframe;	
+			pxmitbuf->priv_data = pxmitframe;
 
 			if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
-			{	
+			{
 				if(pxmitframe->attrib.priority<=15)//TID0~15
 				{
 					res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
-				}	
+				}
 				//RTW_INFO("==> pxmitframe->attrib.priority:%d\n",pxmitframe->attrib.priority);
 				rtw_os_xmit_complete(padapter, pxmitframe);//always return ndis_packet after rtw_xmitframe_coalesce 			
 			}
 
-				
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("xmitframe_complete(): rtw_dump_xframe\n"));
 
-			
 			if(res == _SUCCESS)
 			{
-				rtw_dump_xframe(padapter, pxmitframe);		 
+				rtw_dump_xframe(padapter, pxmitframe);
 			}
 			else
 			{
 				rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
-				rtw_free_xmitframe(pxmitpriv, pxmitframe);	
+				rtw_free_xmitframe(pxmitpriv, pxmitframe);
 			}
-	 			 		
+
 			xcnt++;
-			
+
 		}
 		else
-		{			
+		{
 			rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
 			return _FALSE;
 		}
 
 		break;
-		
+
 	}while(0/*xcnt < (NR_XMITFRAME >> 3)*/);
 
 	return _TRUE;
-	
+
 }
 #endif
 
-
-
 static s32 xmitframe_direct(_adapter *padapter, struct xmit_frame *pxmitframe)
 {
 	s32 res = _SUCCESS;
@@ -1006,12 +999,12 @@ s32	 rtl8814au_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmi
 {
 	struct xmit_priv 	*pxmitpriv = &padapter->xmitpriv;
 	s32 err;
-	
-	if ((err=rtw_xmitframe_enqueue(padapter, pxmitframe)) != _SUCCESS) 
+
+	if ((err=rtw_xmitframe_enqueue(padapter, pxmitframe)) != _SUCCESS)
 	{
 		rtw_free_xmitframe(pxmitpriv, pxmitframe);
 
-		pxmitpriv->tx_drop++;					
+		pxmitpriv->tx_drop++;
 	}
 	else
 	{
@@ -1019,46 +1012,44 @@ s32	 rtl8814au_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmi
 		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
 #endif
 	}
-	
+
 	return err;
-	
-}
 
+}
 
 #ifdef  CONFIG_HOSTAPD_MLME
 
 static void rtl8814au_hostap_mgnt_xmit_cb(struct urb *urb)
-{	
+{
 #ifdef PLATFORM_LINUX
 	struct sk_buff *skb = (struct sk_buff *)urb->context;
 
 	//RTW_INFO("%s\n", __FUNCTION__);
 
 	rtw_skb_free(skb);
-#endif	
+#endif
 }
 
 s32 rtl8814au_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt)
 {
 #ifdef PLATFORM_LINUX
 	u16 fc;
-	int rc, len, pipe;	
+	int rc, len, pipe;
 	unsigned int bmcst, tid, qsel;
 	struct sk_buff *skb, *pxmit_skb;
 	struct urb *urb;
 	unsigned char *pxmitbuf;
 	struct tx_desc *ptxdesc;
 	struct rtw_ieee80211_hdr *tx_hdr;
-	struct hostapd_priv *phostapdpriv = padapter->phostapdpriv;	
+	struct hostapd_priv *phostapdpriv = padapter->phostapdpriv;
 	struct net_device *pnetdev = padapter->pnetdev;
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
-	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);	
+	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
 
-	
 	//RTW_INFO("%s\n", __FUNCTION__);
 
 	skb = pkt;
-	
+
 	len = skb->len;
 	tx_hdr = (struct rtw_ieee80211_hdr *)(skb->data);
 	fc = le16_to_cpu(tx_hdr->frame_ctl);
@@ -1079,42 +1070,40 @@ s32 rtl8814au_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt)
 		goto _exit;
 	}
 
-	// ----- fill tx desc -----	
-	ptxdesc = (struct tx_desc *)pxmitbuf;	
+	// ----- fill tx desc -----
+	ptxdesc = (struct tx_desc *)pxmitbuf;
 	_rtw_memset(ptxdesc, 0, sizeof(*ptxdesc));
-		
-	//offset 0	
-	ptxdesc->txdw0 |= cpu_to_le32(len&0x0000ffff); 
+
+	//offset 0
+	ptxdesc->txdw0 |= cpu_to_le32(len&0x0000ffff);
 	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);//default = 32 bytes for TX Desc
 	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
 
-	if(bmcst)	
+	if(bmcst)
 	{
 		ptxdesc->txdw0 |= cpu_to_le32(BIT(24));
-	}	
+	}
 
-	//offset 4	
+	//offset 4
 	ptxdesc->txdw1 |= cpu_to_le32(0x00);//MAC_ID
 
 	ptxdesc->txdw1 |= cpu_to_le32((0x12<<QSEL_SHT)&0x00001f00);
 
 	ptxdesc->txdw1 |= cpu_to_le32((0x06<< 16) & 0x000f0000);//b mode
 
-	//offset 8			
+	//offset 8
 
-	//offset 12		
+	//offset 12
 	ptxdesc->txdw3 |= cpu_to_le32((le16_to_cpu(tx_hdr->seq_ctl)<<16)&0xffff0000);
 
-	//offset 16		
+	//offset 16
 	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
-		
-	//offset 20
 
+	//offset 20
 
 	//HW append seq
 	ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); // Hw set sequence number
 	ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); //set bit3 to 1. Suugested by TimChen. 2009.12.29.
-	
 
 	rtl8188eu_cal_txdesc_chksum(ptxdesc);
 	// ----- end of fill tx desc -----
@@ -1126,16 +1115,15 @@ s32 rtl8814au_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt)
 
 	//RTW_INFO("mgnt_xmit, len=%x\n", pxmit_skb->len);
 
-
 	// ----- prepare urb for submit -----
-	
+
 	//translate DMA FIFO addr to pipehandle
 	//pipe = ffaddr2pipehdl(pdvobj, MGT_QUEUE_INX);
 	pipe = usb_sndbulkpipe(pdvobj->pusbdev, pHalData->Queue2EPNum[(u8)MGT_QUEUE_INX]&0x0f);
-	
+
 	usb_fill_bulk_urb(urb, pdvobj->pusbdev, pipe,
 			  pxmit_skb->data, pxmit_skb->len, rtl8192cu_hostap_mgnt_xmit_cb, pxmit_skb);
-	
+
 	urb->transfer_flags |= URB_ZERO_PACKET;
 	usb_anchor_urb(urb, &phostapdpriv->anchored);
 	rc = usb_submit_urb(urb, GFP_ATOMIC);
@@ -1145,9 +1133,8 @@ s32 rtl8814au_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt)
 	}
 	usb_free_urb(urb);
 
-	
-_exit:	
-	
+_exit:
+
 	rtw_skb_free(skb);
 
 #endif
@@ -1156,4 +1143,3 @@ s32 rtl8814au_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt)
 
 }
 #endif
-
diff --git a/drivers/net/wireless/rtl8814au/include/drv_types.h b/drivers/net/wireless/rtl8814au/include/drv_types.h
index 3d400f9..9d03776 100644
--- a/drivers/net/wireless/rtl8814au/include/drv_types.h
+++ b/drivers/net/wireless/rtl8814au/include/drv_types.h
@@ -73,10 +73,6 @@ typedef struct _ADAPTER _adapter, ADAPTER, *PADAPTER;
 	#include <rtw_vht.h>
 #endif
 
-#ifdef CONFIG_INTEL_WIDI
-	#include <rtw_intel_widi.h>
-#endif
-
 #include <rtw_cmd.h>
 #include <cmd_osdep.h>
 #include <rtw_security.h>
diff --git a/drivers/net/wireless/rtl8814au/include/osdep_service_linux.h b/drivers/net/wireless/rtl8814au/include/osdep_service_linux.h
index f371343..342c2aa 100644
--- a/drivers/net/wireless/rtl8814au/include/osdep_service_linux.h
+++ b/drivers/net/wireless/rtl8814au/include/osdep_service_linux.h
@@ -269,14 +269,14 @@ __inline static void rtw_list_delete(_list *plist)
 }
 
 #define RTW_TIMER_HDL_ARGS void *FunctionContext
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 __inline static void _init_timer(_timer *ptimer, _nic_hdl nic_hdl, void *pfunc, void *cntx)
 {
-	/* setup_timer(ptimer, pfunc,(u32)cntx);	 */
 	ptimer->function = pfunc;
 	ptimer->data = (unsigned long)cntx;
 	init_timer(ptimer);
 }
+#endif
 
 __inline static void _set_timer(_timer *ptimer, u32 delay_time)
 {
@@ -429,5 +429,4 @@ extern struct net_device *rtw_alloc_etherdev(int sizeof_priv);
 
 #define STRUCT_PACKED __attribute__ ((packed))
 
-
 #endif
diff --git a/drivers/net/wireless/rtl8814au/include/rtw_mlme.h b/drivers/net/wireless/rtl8814au/include/rtw_mlme.h
index 1761f97..6205484 100644
--- a/drivers/net/wireless/rtl8814au/include/rtw_mlme.h
+++ b/drivers/net/wireless/rtl8814au/include/rtw_mlme.h
@@ -20,7 +20,6 @@
 #ifndef __RTW_MLME_H_
 #define __RTW_MLME_H_
 
-
 #define	MAX_BSS_CNT	128
 /* #define   MAX_JOIN_TIMEOUT	2000 */
 /* #define   MAX_JOIN_TIMEOUT	2500 */
@@ -162,7 +161,6 @@ enum SCAN_RESULT_TYPE {
 };
 
 /*
-
 there are several "locks" in mlme_priv,
 since mlme_priv is a shared resource between many threads,
 like ISR/Call-Back functions, the OID handlers, and even timer functions.
@@ -173,10 +171,8 @@ Other items are protected by mlme_priv.lock.
 
 To avoid possible dead lock, any thread trying to modifiying mlme_priv
 SHALL not lock up more than one locks at a time!
-
 */
 
-
 #define traffic_threshold	10
 #define	traffic_scan_period	500
 
@@ -710,33 +706,6 @@ struct mlme_priv {
 	_workitem	Linkup_workitem;
 	_workitem	Linkdown_workitem;
 #endif
-
-#ifdef CONFIG_INTEL_WIDI
-	int	widi_state;
-	int	listen_state;
-	_timer	listen_timer;
-	ATOMIC_T	rx_probe_rsp; /* 1:receive probe respone from RDS source. */
-	u8	*l2sdTaBuffer;
-	u8	channel_idx;
-	u8	group_cnt;	/* In WiDi 3.5, they specified another scan algo. for WFD/RDS co-existed */
-	u8	sa_ext[L2SDTA_SERVICE_VE_LEN];
-
-	u8	widi_enable;
-	/**
-	 * For WiDi 4; upper layer would set
-	 * p2p_primary_device_type_category_id
-	 * p2p_primary_device_type_sub_category_id
-	 * p2p_secondary_device_type_category_id
-	 * p2p_secondary_device_type_sub_category_id
-	 */
-	u16	p2p_pdt_cid;
-	u16	p2p_pdt_scid;
-	u8	num_p2p_sdt;
-	u16	p2p_sdt_cid[MAX_NUM_P2P_SDT];
-	u16	p2p_sdt_scid[MAX_NUM_P2P_SDT];
-	u8	p2p_reject_disable;	/* When starting NL80211 wpa_supplicant/hostapd, it will call netdev_close */
-							/* such that it will cause p2p disabled. Use this flag to reject. */
-#endif /* CONFIG_INTEL_WIDI */
 	u32 lastscantime;
 #ifdef CONFIG_CONCURRENT_MODE
 	u8	scanning_via_buddy_intf;
@@ -788,7 +757,6 @@ extern int hostapd_mode_init(_adapter *padapter);
 extern void hostapd_mode_unload(_adapter *padapter);
 #endif
 
-
 extern void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf);
 extern void rtw_survey_event_callback(_adapter *adapter, u8 *pbuf);
 extern void rtw_surveydone_event_callback(_adapter *adapter, u8 *pbuf);
@@ -802,8 +770,14 @@ extern void rtw_wmm_event_callback(PADAPTER padapter, u8 *pbuf);
 #ifdef CONFIG_IEEE80211W
 void rtw_sta_timeout_event_callback(_adapter *adapter, u8 *pbuf);
 #endif /* CONFIG_IEEE80211W */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+void rtw_join_timeout_handler(struct timer_list *t);
+void _rtw_scan_timeout_handler(struct timer_list *t);
+#else
 extern void rtw_join_timeout_handler(RTW_TIMER_HDL_ARGS);
 extern void _rtw_scan_timeout_handler(RTW_TIMER_HDL_ARGS);
+#endif
 
 thread_return event_thread(thread_context context);
 
@@ -983,16 +957,13 @@ void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv);
 int rtw_mlme_update_wfd_ie_data(struct mlme_priv *mlme, u8 type, u8 *ie, u32 ie_len);
 #endif
 
-
 /* extern struct wlan_network* _rtw_dequeue_network(_queue *queue); */
 
 extern struct wlan_network *_rtw_alloc_network(struct mlme_priv *pmlmepriv);
 
-
 extern void _rtw_free_network(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork, u8 isfreeall);
 extern void _rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork);
 
-
 extern struct wlan_network *_rtw_find_network(_queue *scanned_queue, u8 *addr);
 
 extern void _rtw_free_network_queue(_adapter *padapter, u8 isfreeall);
@@ -1005,7 +976,6 @@ u8 *rtw_get_capability_from_ie(u8 *ie);
 u8 *rtw_get_timestampe_from_ie(u8 *ie);
 u8 *rtw_get_beacon_interval_from_ie(u8 *ie);
 
-
 void rtw_joinbss_reset(_adapter *padapter);
 
 #ifdef CONFIG_80211N_HT
diff --git a/drivers/net/wireless/rtl8814au/include/rtw_recv.h b/drivers/net/wireless/rtl8814au/include/rtw_recv.h
index ef3886f..f6dcd82 100644
--- a/drivers/net/wireless/rtl8814au/include/rtw_recv.h
+++ b/drivers/net/wireless/rtl8814au/include/rtw_recv.h
@@ -68,7 +68,6 @@
 #define PHY_RSSI_SLID_WIN_MAX				100
 #define PHY_LINKQUALITY_SLID_WIN_MAX		20
 
-
 #define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
 
 #define RX_MPDU_QUEUE				0
@@ -125,7 +124,6 @@ struct	stainfo_rxcache	{
 #endif
 };
 
-
 struct smooth_rssi_data {
 	u32	elements[100];	/* array to store values */
 	u32	index;			/* index to current array to store */
@@ -218,7 +216,6 @@ struct rx_raw_rssi {
 	u8 ofdm_snr[4];
 };
 
-
 struct rx_pkt_attrib	{
 	u16	pkt_len;
 	u8	physt;
@@ -283,7 +280,6 @@ struct rx_pkt_attrib	{
 	struct phy_info phy_info;
 };
 
-
 /* These definition is used for Rx packet reordering. */
 #define SN_LESS(a, b)		(((a-b) & 0x800) != 0)
 #define SN_EQUAL(a, b)	(a == b)
@@ -359,8 +355,6 @@ struct rtw_rx_ring {
 };
 #endif
 
-
-
 /*
 accesser of recv_priv: rtw_recv_entry(dispatch / passive level); recv_thread(passive) ; returnpkt(dispatch)
 ; halt(passive) ;
@@ -488,7 +482,9 @@ struct recv_priv {
 };
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 #define rtw_set_signal_stat_timer(recvpriv) _set_timer(&(recvpriv)->signal_stat_timer, (recvpriv)->signal_stat_sampling_interval)
+#endif
 #endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 struct sta_recv_priv {
@@ -507,7 +503,6 @@ struct sta_recv_priv {
 
 };
 
-
 struct recv_buf {
 	_list list;
 
@@ -565,7 +560,6 @@ struct recv_buf {
 
 		tail  ----->
 
-
 	end   ----->
 
 	len = (unsigned int )(tail - data);
@@ -597,7 +591,6 @@ struct recv_frame_hdr {
 
 	void *precvbuf;
 
-
 	/*  */
 	struct sta_info *psta;
 
@@ -614,7 +607,6 @@ struct recv_frame_hdr {
 
 };
 
-
 union recv_frame {
 
 	union {
@@ -699,7 +691,6 @@ __inline static u8 *recvframe_push(union recv_frame *precvframe, sint sz)
 	if (precvframe == NULL)
 		return NULL;
 
-
 	precvframe->u.hdr.rx_data -= sz ;
 	if (precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head) {
 		precvframe->u.hdr.rx_data += sz ;
@@ -712,18 +703,15 @@ __inline static u8 *recvframe_push(union recv_frame *precvframe, sint sz)
 
 }
 
-
 __inline static u8 *recvframe_pull(union recv_frame *precvframe, sint sz)
 {
 	/* rx_data += sz; move rx_data sz bytes  hereafter */
 
 	/* used for extract sz bytes from rx_data, update rx_data and return the updated rx_data to the caller */
 
-
 	if (precvframe == NULL)
 		return NULL;
 
-
 	precvframe->u.hdr.rx_data += sz;
 
 	if (precvframe->u.hdr.rx_data > precvframe->u.hdr.rx_tail) {
@@ -765,8 +753,6 @@ __inline static u8 *recvframe_put(union recv_frame *precvframe, sint sz)
 
 }
 
-
-
 __inline static u8 *recvframe_pull_tail(union recv_frame *precvframe, sint sz)
 {
 	/* rmv data from rx_tail (by yitsen) */
@@ -790,8 +776,6 @@ __inline static u8 *recvframe_pull_tail(union recv_frame *precvframe, sint sz)
 
 }
 
-
-
 __inline static _buffer *get_rxbuf_desc(union recv_frame *precvframe)
 {
 	_buffer *buf_desc;
@@ -805,7 +789,6 @@ __inline static _buffer *get_rxbuf_desc(union recv_frame *precvframe)
 	return buf_desc;
 }
 
-
 __inline static union recv_frame *rxmem_to_recvframe(u8 *rxmem)
 {
 	/* due to the design of 2048 bytes alignment of recv_frame, we can reference the union recv_frame */
@@ -876,7 +859,6 @@ __inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)
 	return SignalPower;
 }
 
-
 struct sta_info;
 
 extern void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv);
diff --git a/drivers/net/wireless/rtl8814au/include/rtw_wifi_regd.h b/drivers/net/wireless/rtl8814au/include/rtw_wifi_regd.h
index 249a894..69bd71d 100644
--- a/drivers/net/wireless/rtl8814au/include/rtw_wifi_regd.h
+++ b/drivers/net/wireless/rtl8814au/include/rtw_wifi_regd.h
@@ -7,18 +7,6 @@
 #ifndef __RTW_WIFI_REGD_H__
 #define __RTW_WIFI_REGD_H__
 
-struct country_code_to_enum_rd {
-	u16 countrycode;
-	const char *iso_name;
-};
-
-enum country_code_type_t {
-	COUNTRY_CODE_USER = 0,
-
-	/*add new channel plan above this line */
-	COUNTRY_CODE_MAX
-};
-
 int rtw_regd_init(_adapter *padapter);
 void rtw_reg_notify_by_driver(_adapter *adapter);
 
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_cfg80211.c
index 75635ab..3b96594 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_cfg80211.c
@@ -77,7 +77,6 @@
 
 #endif /* CONFIG_WAPI_SUPPORT */
 
-
 static const u32 rtw_cipher_suites[] = {
 	WLAN_CIPHER_SUITE_WEP40,
 	WLAN_CIPHER_SUITE_WEP104,
@@ -196,7 +195,6 @@ static struct ieee80211_channel rtw_5ghz_a_channels[] = {
 	CHAN5G(216, 0),
 };
 
-
 void rtw_2g_channels_init(struct ieee80211_channel *channels)
 {
 	_rtw_memcpy((void *)channels, (void *)rtw_2ghz_channels,
@@ -471,7 +469,6 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	}
 	/* _exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL); */
 
-
 	channel = pnetwork->network.Configuration.DSConfig;
 	freq = rtw_ch2freq(channel);
 	notify_channel = ieee80211_get_channel(wiphy, freq);
@@ -524,7 +521,6 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	_rtw_memcpy(pwlanhdr->addr2, pnetwork->network.MacAddress, ETH_ALEN);
 	_rtw_memcpy(pwlanhdr->addr3, pnetwork->network.MacAddress, ETH_ALEN);
 
-
 	/* pbuf += sizeof(struct rtw_ieee80211_hdr_3addr); */
 	len = sizeof(struct rtw_ieee80211_hdr_3addr);
 	_rtw_memcpy((pbuf + len), pnetwork->network.IEs, pnetwork->network.IELength);
@@ -894,7 +890,6 @@ void rtw_cfg80211_indicate_disconnect(_adapter *padapter, u16 reason, u8 locally
 	}
 }
 
-
 #ifdef CONFIG_AP_MODE
 static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
 {
@@ -3731,6 +3726,8 @@ static int rtw_cfg80211_add_monitor_if(_adapter *padapter, char *name, struct ne
 	mon_ndev->name[IFNAMSIZ - 1] = 0;
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12 ,0))
 	mon_ndev->needs_free_netdev = true;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 9))
+	mon_ndev->priv_destructor = rtw_ndev_destructor;
 #else
 	mon_ndev->destructor = rtw_ndev_destructor;
 #endif
@@ -4370,9 +4367,9 @@ static int cfg80211_rtw_get_channel(struct wiphy *wiphy, struct wireless_dev *wd
 	_adapter *padapter= wiphy_to_adapter(wiphy);
 	int channel;
 	int control_freq;
-	int center_freq;
+	int center_freq=0;
 	int center_freq2=0;
-	int width;
+	int width=0;
 	int band;
 	int bandWidth;
 	int offset;
@@ -6495,6 +6492,10 @@ static void rtw_cfg80211_preinit_wiphy(_adapter *adapter, struct wiphy *wiphy)
 		wiphy->bands[IEEE80211_BAND_5GHZ] = rtw_spt_band_alloc(IEEE80211_BAND_5GHZ);
 #endif
 
+#if defined(CONFIG_NET_NS)
+	wiphy->flags |= WIPHY_FLAG_NETNS_OK;
+#endif //CONFIG_NET_NS
+
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38) && LINUX_VERSION_CODE < KERNEL_VERSION(3, 0, 0))
 #if defined(CONFIG_NET_NS)
 	wiphy->flags |= WIPHY_FLAG_NETNS_OK;
@@ -6595,6 +6596,7 @@ static struct cfg80211_ops rtw_cfg80211_ops = {
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
 	.set_channel = cfg80211_rtw_set_channel,
 #endif
+
 	/* .auth = cfg80211_rtw_auth, */
 	/* .assoc = cfg80211_rtw_assoc,	 */
 #endif /* CONFIG_AP_MODE */
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_linux.c b/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_linux.c
index c1adefb..3cc32bc 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_linux.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_linux.c
@@ -4285,10 +4285,6 @@ static int rtw_wps_start(struct net_device *dev,
 	else if (u32wps_start == 3)   /* WPS Stop because of wps fail */
 		rtw_led_control(padapter, LED_CTL_STOP_WPS_FAIL);
 
-#ifdef CONFIG_INTEL_WIDI
-	process_intel_widi_wps_status(padapter, u32wps_start);
-#endif /* CONFIG_INTEL_WIDI */
-
 exit:
 
 	return ret;
@@ -5184,13 +5180,6 @@ static int rtw_p2p_connect(struct net_device *dev,
 		return ret;
 	}
 
-#ifdef CONFIG_INTEL_WIDI
-	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
-		RTW_INFO("[%s] WiFi is under survey!\n", __FUNCTION__);
-		return ret;
-	}
-#endif /* CONFIG_INTEL_WIDI	 */
-
 	if (pwdinfo->ui_got_wps_info == P2P_NO_WPSINFO)
 		return -1;
 
@@ -5273,19 +5262,6 @@ static int rtw_p2p_connect(struct net_device *dev,
 
 	} else {
 		RTW_INFO("[%s] Not Found in Scanning Queue~\n", __FUNCTION__);
-#ifdef CONFIG_INTEL_WIDI
-		_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
-		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
-		rtw_free_network_queue(padapter, _TRUE);
-		/**
-		 * For WiDi, if we can't find candidate device in scanning queue,
-		 * driver will do scanning itself
-		 */
-		_enter_critical_bh(&pmlmepriv->lock, &irqL);
-		rtw_sitesurvey_cmd(padapter, NULL, 0, NULL, 0);
-		_exit_critical_bh(&pmlmepriv->lock, &irqL);
-#endif /* CONFIG_INTEL_WIDI */
 		ret = -1;
 	}
 exit:
@@ -5854,13 +5830,6 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 		RTW_INFO("[%s] WiFi Direct is disable!\n", __FUNCTION__);
 		return ret;
 	} else {
-#ifdef CONFIG_INTEL_WIDI
-		if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
-			RTW_INFO("[%s] WiFi is under survey!\n", __FUNCTION__);
-			return ret;
-		}
-#endif /* CONFIG_INTEL_WIDI */
-
 		/*	Reset the content of struct tx_provdisc_req_info excluded the wps_config_method_request. */
 		_rtw_memset(pwdinfo->tx_prov_disc_info.peerDevAddr, 0x00, ETH_ALEN);
 		_rtw_memset(pwdinfo->tx_prov_disc_info.peerIFAddr, 0x00, ETH_ALEN);
@@ -5930,18 +5899,6 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 
 		}
 
-#ifdef CONFIG_INTEL_WIDI
-		/* Some Intel WiDi source may not provide P2P IE, */
-		/* so we could only compare mac addr by 802.11 Source Address */
-		if (pmlmepriv->widi_state == INTEL_WIDI_STATE_WFD_CONNECTION
-		    && uintPeerChannel == 0) {
-			if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN)) {
-				uintPeerChannel = pnetwork->network.Configuration.DSConfig;
-				break;
-			}
-		}
-#endif /* CONFIG_INTEL_WIDI */
-
 		plist = get_next(plist);
 
 	}
@@ -6031,15 +5988,6 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 
 	} else {
 		RTW_INFO("[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__);
-#ifdef CONFIG_INTEL_WIDI
-		_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
-		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
-		rtw_free_network_queue(padapter, _TRUE);
-		_enter_critical_bh(&pmlmepriv->lock, &irqL);
-		rtw_sitesurvey_cmd(padapter, NULL, 0, NULL, 0);
-		_exit_critical_bh(&pmlmepriv->lock, &irqL);
-#endif /* CONFIG_INTEL_WIDI */
 	}
 exit:
 
@@ -11527,46 +11475,6 @@ static int rtw_tdls_get(struct net_device *dev,
 	return ret;
 }
 
-
-
-
-
-#ifdef CONFIG_INTEL_WIDI
-static int rtw_widi_set(struct net_device *dev,
-			struct iw_request_info *info,
-			union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-
-	process_intel_widi_cmd(padapter, extra);
-
-	return ret;
-}
-
-static int rtw_widi_set_probe_request(struct net_device *dev,
-				      struct iw_request_info *info,
-				      union iwreq_data *wrqu, char *extra)
-{
-	int	ret = 0;
-	u8	*pbuf = NULL;
-	_adapter	*padapter = (_adapter *)rtw_netdev_priv(dev);
-
-	pbuf = rtw_malloc(sizeof(l2_msg_t));
-	if (pbuf) {
-		if (copy_from_user(pbuf, wrqu->data.pointer, wrqu->data.length))
-			ret = -EFAULT;
-		/* _rtw_memcpy(pbuf, wrqu->data.pointer, wrqu->data.length); */
-
-		if (wrqu->data.flags == 0)
-			intel_widi_wk_cmd(padapter, INTEL_WIDI_ISSUE_PROB_WK, pbuf, sizeof(l2_msg_t));
-		else if (wrqu->data.flags == 1)
-			rtw_set_wfd_rds_sink_info(padapter, (l2_msg_t *)pbuf);
-	}
-	return ret;
-}
-#endif /* CONFIG_INTEL_WIDI */
-
 #ifdef CONFIG_MAC_LOOPBACK_DRIVER
 
 #if defined(CONFIG_RTL8188E)
@@ -12411,18 +12319,6 @@ static const struct iw_priv_args rtw_private_args[] = {
 		SIOCIWFIRSTPRIV + 0x1D,
 		IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 0x7FF, "test"
 	},
-
-#ifdef CONFIG_INTEL_WIDI
-	{
-		SIOCIWFIRSTPRIV + 0x1E,
-		IW_PRIV_TYPE_CHAR | 1024, 0, "widi_set"
-	},
-	{
-		SIOCIWFIRSTPRIV + 0x1F,
-		IW_PRIV_TYPE_CHAR | 128, 0, "widi_prob_req"
-	},
-#endif /* CONFIG_INTEL_WIDI */
-
 	{ SIOCIWFIRSTPRIV + 0x0E, IW_PRIV_TYPE_CHAR | 1024, 0 , ""},  /* set  */
 	{ SIOCIWFIRSTPRIV + 0x0F, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , ""},/* get
  * --- sub-ioctls definitions --- */
@@ -12547,10 +12443,6 @@ static iw_handler rtw_private_handler[] = {
 #endif
 	NULL,							/* 0x1C is reserved for hostapd */
 	rtw_test,						/* 0x1D */
-#ifdef CONFIG_INTEL_WIDI
-	rtw_widi_set,					/* 0x1E */
-	rtw_widi_set_probe_request,		/* 0x1F */
-#endif /* CONFIG_INTEL_WIDI */
 };
 
 #if WIRELESS_EXT >= 17
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/os_intfs.c b/drivers/net/wireless/rtl8814au/os_dep/linux/os_intfs.c
index 1079a7a..6d34c0e 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/os_intfs.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/os_intfs.c
@@ -826,9 +826,6 @@ uint loadparam(_adapter *padapter)
 
 #ifdef CONFIG_LAYER2_ROAMING
 	registry_par->max_roaming_times = (u8)rtw_max_roaming_times;
-#ifdef CONFIG_INTEL_WIDI
-	registry_par->max_roaming_times = (u8)rtw_max_roaming_times + 2;
-#endif /* CONFIG_INTEL_WIDI */
 #endif
 
 #ifdef CONFIG_IOL
@@ -1829,20 +1826,21 @@ u8 rtw_reset_drv_sw(_adapter *padapter)
 	mlmeext_set_scan_state(&padapter->mlmeextpriv, SCAN_DISABLE);
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	_set_timer(&padapter->recvpriv.signal_stat_timer, padapter->recvpriv.signal_stat_sampling_interval);
+#else
 	rtw_set_signal_stat_timer(&padapter->recvpriv);
 #endif
+#endif
 
 	return ret8;
 }
 
-
 u8 rtw_init_drv_sw(_adapter *padapter)
 {
 
 	u8	ret8 = _SUCCESS;
 
-
-
 	_rtw_init_listhead(&padapter->list);
 
 	ret8 = rtw_init_default_value(padapter);
@@ -1948,14 +1946,6 @@ u8 rtw_init_drv_sw(_adapter *padapter)
 	rtw_hal_sreset_init(padapter);
 #endif
 
-#ifdef CONFIG_INTEL_WIDI
-	if (rtw_init_intel_widi(padapter) == _FAIL) {
-		RTW_INFO("Can't rtw_init_intel_widi\n");
-		ret8 = _FAIL;
-		goto exit;
-	}
-#endif /* CONFIG_INTEL_WIDI */
-
 #ifdef CONFIG_WAPI_SUPPORT
 	padapter->WapiSupport = true; /* set true temp, will revise according to Efuse or Registry value later. */
 	rtw_wapi_init(padapter);
@@ -1967,8 +1957,6 @@ u8 rtw_init_drv_sw(_adapter *padapter)
 
 exit:
 
-
-
 	return ret8;
 
 }
@@ -2055,10 +2043,6 @@ u8 rtw_free_drv_sw(_adapter *padapter)
 	_rtw_spinlock_free(&padapter->br_ext_lock);
 #endif /* CONFIG_BR_EXT */
 
-#ifdef CONFIG_INTEL_WIDI
-	rtw_free_intel_widi(padapter);
-#endif /* CONFIG_INTEL_WIDI */
-
 	free_mlme_ext_priv(&padapter->mlmeextpriv);
 
 #ifdef CONFIG_TDLS
@@ -2089,7 +2073,6 @@ u8 rtw_free_drv_sw(_adapter *padapter)
 
 	rtw_hal_free_data(padapter);
 
-
 	/* free the old_pnetdev */
 	if (padapter->rereg_nd_name_priv.old_pnetdev) {
 		free_netdev(padapter->rereg_nd_name_priv.old_pnetdev);
@@ -2293,7 +2276,6 @@ _adapter *rtw_drv_add_vir_if(_adapter *primary_padapter,
 	padapter->hw_port = HW_PORT1;
 #endif
 
-
 	/****** hook vir if into dvobj ******/
 	pdvobjpriv = adapter_to_dvobj(padapter);
 	padapter->iface_id = pdvobjpriv->iface_nums;
@@ -2311,7 +2293,6 @@ _adapter *rtw_drv_add_vir_if(_adapter *primary_padapter,
 	if (rtw_init_drv_sw(padapter) != _SUCCESS)
 		goto free_drv_sw;
 
-
 	/*get mac address from primary_padapter*/
 	_rtw_memcpy(mac, adapter_mac_addr(primary_padapter), ETH_ALEN);
 
@@ -2792,7 +2773,6 @@ int  ips_netdrv_open(_adapter *padapter)
 	return _FAIL;
 }
 
-
 int rtw_ips_pwr_up(_adapter *padapter)
 {
 	int result;
@@ -2856,7 +2836,6 @@ void rtw_ips_dev_unload(_adapter *padapter)
 
 }
 
-
 int pm_netdev_open(struct net_device *pnetdev, u8 bnormal)
 {
 	int status = 0;
@@ -3317,7 +3296,6 @@ void rtw_dev_unload(PADAPTER padapter)
 
 		rtw_intf_stop(padapter);
 
-
 		if (!pwrctl->bInternalAutoSuspend)
 			rtw_stop_drv_threads(padapter);
 
@@ -3332,7 +3310,6 @@ void rtw_dev_unload(PADAPTER padapter)
 			}
 		}
 
-
 		/* check the status of IPS */
 		if (rtw_hal_check_ips_status(padapter) == _TRUE || pwrctl->rf_pwrstate == rf_off) { /* check HW status and SW state */
 			RTW_PRINT("%s: driver in IPS-FWLPS\n", __func__);
@@ -3444,7 +3421,6 @@ int rtw_suspend_wow(_adapter *padapter)
 
 	RTW_INFO("==> "FUNC_ADPT_FMT" entry....\n", FUNC_ADPT_ARG(padapter));
 
-
 	RTW_INFO("wowlan_mode: %d\n", pwrpriv->wowlan_mode);
 	RTW_INFO("wowlan_pno_enable: %d\n", pwrpriv->wowlan_pno_enable);
 #ifdef CONFIG_P2P_WOWLAN
@@ -3654,7 +3630,6 @@ int rtw_suspend_ap_wow(_adapter *padapter)
 }
 #endif /* #ifdef CONFIG_AP_WOWLAN */
 
-
 int rtw_suspend_normal(_adapter *padapter)
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -3673,7 +3648,6 @@ int rtw_suspend_normal(_adapter *padapter)
 	    || (adapter_to_pwrctl(padapter)->rf_pwrstate == rf_off))
 		RTW_PRINT("%s: ### ERROR #### driver in IPS ####ERROR###!!!\n", __FUNCTION__);
 
-
 #ifdef CONFIG_CONCURRENT_MODE
 	rtw_mi_buddy_dev_unload(padapter);
 #endif
@@ -3774,7 +3748,6 @@ int rtw_suspend_common(_adapter *padapter)
 	} else
 		rtw_suspend_normal(padapter);
 
-
 	RTW_PRINT("rtw suspend success in %d ms\n",
 		  rtw_get_passing_time_ms(start_time));
 
@@ -3856,7 +3829,6 @@ int rtw_resume_process_wow(_adapter *padapter)
 		if (psta)
 			set_sta_rate(padapter, psta);
 
-
 		rtw_clr_drv_stopped(padapter);
 		RTW_INFO("%s: wowmode resuming, DriverStopped:%s\n", __func__, rtw_is_drv_stopped(padapter) ? "True" : "False");
 
@@ -3978,7 +3950,6 @@ int rtw_resume_process_ap_wow(_adapter *padapter)
 		goto exit;
 	}
 
-
 #ifdef CONFIG_LPS
 	rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0, "AP-WOWLAN");
 #endif /* CONFIG_LPS */
@@ -4206,7 +4177,6 @@ int rtw_resume_common(_adapter *padapter)
 	RTW_PRINT("%s:%d in %d ms\n", __FUNCTION__ , ret,
 		  rtw_get_passing_time_ms(start_time));
 
-
 	return ret;
 }
 
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/recv_linux.c b/drivers/net/wireless/rtl8814au/os_dep/linux/recv_linux.c
index a534c4b..fa84bcb 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/recv_linux.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/recv_linux.c
@@ -73,7 +73,6 @@ int rtw_os_alloc_recvframe(_adapter *padapter, union recv_frame *precvframe, u8
 		return res;
 	}
 
-
 	/*	Modified by Albert 20101213 */
 	/*	For 8 bytes IP header alignment. */
 	shift_sz = pattrib->qos ? 6 : 0; /*	Qos data, wireless lan header length is 26 */
@@ -398,7 +397,6 @@ void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attri
 		rcu_read_unlock();
 #endif /* (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 
-
 		if (br_port && (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE) == _TRUE)) {
 			int nat25_handle_frame(_adapter *priv, struct sk_buff *skb);
 			if (nat25_handle_frame(padapter, pkt) == -1) {
@@ -511,7 +509,6 @@ void rtw_hostapd_mlme_rx(_adapter *padapter, union recv_frame *precv_frame)
 	struct hostapd_priv *phostapdpriv  = padapter->phostapdpriv;
 	struct net_device *pmgnt_netdev = phostapdpriv->pmgnt_netdev;
 
-
 	skb = precv_frame->u.hdr.pkt;
 
 	if (skb == NULL)
@@ -667,7 +664,6 @@ int rtw_recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
 		goto _recv_indicatepkt_drop;
 	}
 
-
 	skb->data = precv_frame->u.hdr.rx_data;
 
 	skb_set_tail_pointer(skb, precv_frame->u.hdr.len);
@@ -750,8 +746,6 @@ int rtw_recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
 
 	rtw_free_recvframe(precv_frame, pfree_recv_queue);
 
-
-
 	return _SUCCESS;
 
 _recv_indicatepkt_drop:
@@ -789,10 +783,18 @@ void rtw_os_read_port(_adapter *padapter, struct recv_buf *precvbuf)
 #endif
 
 }
-void _rtw_reordering_ctrl_timeout_handler(void *FunctionContext);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+void _rtw_reordering_ctrl_timeout_handler(struct timer_list *t)
+#else
 void _rtw_reordering_ctrl_timeout_handler(void *FunctionContext)
+#endif
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	struct recv_reorder_ctrl *preorder_ctrl = from_timer(preorder_ctrl, t, reordering_ctrl_timer);
+#else
 	struct recv_reorder_ctrl *preorder_ctrl = (struct recv_reorder_ctrl *)FunctionContext;
+#endif
 	rtw_reordering_ctrl_timeout_handler(preorder_ctrl);
 }
 
@@ -800,6 +802,9 @@ void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)
 {
 	_adapter *padapter = preorder_ctrl->padapter;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+	timer_setup(&preorder_ctrl->reordering_ctrl_timer, _rtw_reordering_ctrl_timeout_handler, 0);
+#else
 	_init_timer(&(preorder_ctrl->reordering_ctrl_timer), padapter->pnetdev, _rtw_reordering_ctrl_timeout_handler, preorder_ctrl);
-
+#endif
 }
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/rtw_radiotap.c b/drivers/net/wireless/rtl8814au/os_dep/linux/rtw_radiotap.c
index b8df1ae..56cf92f 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/rtw_radiotap.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/rtw_radiotap.c
@@ -183,8 +183,6 @@ static void find_ns(struct ieee80211_radiotap_iterator *iterator,
 	}
 }
 
-
-
 /**
  * ieee80211_radiotap_iterator_next - return next radiotap parser iterator arg
  * @iterator: radiotap_iterator to move to next arg (if any)
@@ -366,4 +364,3 @@ int rtw_ieee80211_radiotap_iterator_next(
 			return 0;
 	}
 }
-
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/usb_intf.c b/drivers/net/wireless/rtl8814au/os_dep/linux/usb_intf.c
index 0fc63b6..6ed4e72 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/usb_intf.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/usb_intf.c
@@ -42,12 +42,10 @@ extern int rtw_ampdu_enable;/* for enable tx_ampdu */
 int ui_pid[3] = {0, 0, 0};
 #endif
 
-
 extern int pm_netdev_open(struct net_device *pnetdev, u8 bnormal);
 static int rtw_suspend(struct usb_interface *intf, pm_message_t message);
 static int rtw_resume(struct usb_interface *intf);
 
-
 static int rtw_drv_init(struct usb_interface *pusb_intf, const struct usb_device_id *pdid);
 static void rtw_dev_remove(struct usb_interface *pusb_intf);
 
@@ -85,13 +83,11 @@ static void rtw_dev_shutdown(struct device *dev)
 #define USB_DEVICE_ID_MATCH_INT_PROTOCOL		 0x0200
 #define USB_DEVICE_ID_MATCH_INT_NUMBER		 0x0400
 
-
 #define USB_DEVICE_ID_MATCH_INT_INFO \
 	(USB_DEVICE_ID_MATCH_INT_CLASS | \
 	 USB_DEVICE_ID_MATCH_INT_SUBCLASS | \
 	 USB_DEVICE_ID_MATCH_INT_PROTOCOL)
 
-
 #define USB_DEVICE_AND_INTERFACE_INFO(vend, prod, cl, sc, pr) \
 	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \
 		       | USB_DEVICE_ID_MATCH_DEVICE, \
@@ -125,10 +121,8 @@ static void rtw_dev_shutdown(struct device *dev)
 /* ----------------------------------------------------------------------- */
 #endif
 
-
 #define USB_VENDER_ID_REALTEK		0x0BDA
 
-
 /* DID_USB_v916_20130116 */
 static struct usb_device_id rtw_usb_id_tbl[] = {
 #ifdef CONFIG_RTL8188E
@@ -202,6 +196,7 @@ static struct usb_device_id rtw_usb_id_tbl[] = {
 	{USB_DEVICE(0x2019, 0xAB32), .driver_info = RTL8821}, /* Planex - GW-450S */
 	{USB_DEVICE(0x0846, 0x9052), .driver_info = RTL8821}, /* Netgear - A6100 */
 	{USB_DEVICE(0x0411, 0x029B), .driver_info = RTL8821}, /* Buffalo - WI-U2-433DHP */
+	{USB_DEVICE(0x056E, 0x4007), .driver_info = RTL8821}, /* Elecom - WDC-433DU2HBK */
 #endif
 
 #ifdef CONFIG_RTL8192E
@@ -226,10 +221,12 @@ static struct usb_device_id rtw_usb_id_tbl[] = {
 	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8813), .driver_info = RTL8814A},
 	{USB_DEVICE(0x2001, 0x331A), .driver_info = RTL8814A}, /* D-Link - D-Link */
 	{USB_DEVICE(0x0B05, 0x1817), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
+	{USB_DEVICE(0x0B05, 0x1852), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
 	{USB_DEVICE(0x056E, 0x400B), .driver_info = RTL8814A}, /* ELECOM - ELECOM */
 	{USB_DEVICE(0x056E, 0x400D), .driver_info = RTL8814A}, /* ELECOM - ELECOM */
 	{USB_DEVICE(0x7392, 0xA834), .driver_info = RTL8814A}, /* Edimax - Edimax */
 	{USB_DEVICE(0x7392, 0xA833), .driver_info = RTL8814A}, /* Edimax - AC1750 */
+	{USB_DEVICE(0x0BDA, 0x8813), .driver_info = RTL8814A}, /* Edimax - EDUP Adapters */
 	{USB_DEVICE(0x2357, 0x0106), .driver_info = RTL8814A}, /* TP-LINK Archer T9UH */
 	{USB_DEVICE(0x20F4, 0x809A), .driver_info = RTL8814A}, /* TRENDnet - TRENDnet */
 	{USB_DEVICE(0x20F4, 0x809B), .driver_info = RTL8814A}, /* TRENDnet TEW-809UB */
@@ -353,7 +350,6 @@ static u8 rtw_init_intf_priv(struct dvobj_priv *dvobj)
 	_rtw_mutex_init(&dvobj->usb_vendor_req_mutex);
 #endif
 
-
 #ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
 	dvobj->usb_alloc_vendor_req_buf = rtw_zmalloc(MAX_USB_IO_CTL_SIZE);
 	if (dvobj->usb_alloc_vendor_req_buf == NULL) {
@@ -455,13 +451,10 @@ static struct dvobj_priv *usb_dvobj_init(struct usb_interface *usb_intf, const s
 	struct usb_endpoint_descriptor	*pendp_desc;
 	struct usb_device				*pusbd;
 
-
-
 	pdvobjpriv = devobj_init();
 	if (pdvobjpriv == NULL)
 		goto exit;
 
-
 	pdvobjpriv->pusbintf = usb_intf ;
 	pusbd = pdvobjpriv->pusbdev = interface_to_usbdev(usb_intf);
 	usb_set_intfdata(usb_intf, pdvobjpriv);
@@ -665,26 +658,7 @@ static int usb_reprobe_switch_usb_mode(PADAPTER Adapter)
 	if (registry_par->switch_usb_mode == 0)
 		goto exit;
 
-#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A) || defined(CONFIG_RTL8814A)
-        if (IS_HIGH_SPEED_USB(Adapter)) {
-          if ((rtw_read8(Adapter, 0x74) & (BIT(2)|BIT(3))) != BIT(3)) {
-            rtw_write8(Adapter, 0x74, 0x8);
-            rtw_write8(Adapter, 0x70, 0x2);
-            rtw_write8(Adapter, 0x3e, 0x1);
-            rtw_write8(Adapter, 0x3d, 0x3);
-            /* usb disconnect */
-            rtw_write8(Adapter, 0x5, 0x80);
-            ret = _TRUE;
-          }
-
-        } else if (IS_SUPER_SPEED_USB(Adapter)) {
-          rtw_write8(Adapter, 0x70, rtw_read8(Adapter, 0x70) & (~BIT(1)));
-          rtw_write8(Adapter, 0x3e, rtw_read8(Adapter, 0x3e) & (~BIT(0)));
-        }
-#else
 	rtw_hal_set_hwreg(Adapter, HW_VAR_USB_MODE, &ret);
-#endif
-
 exit:
 	return ret;
 }
@@ -738,7 +712,6 @@ u8 rtw_set_hal_ops(_adapter *padapter)
 		rtl8723du_set_hal_ops(padapter);
 #endif /* CONFIG_RTL8723D */
 
-
 #ifdef CONFIG_RTL8821C
 	if (rtw_get_chip_type(padapter) == RTL8821C) {
 		if (rtl8821cu_set_hal_ops(padapter) == _FAIL)
@@ -920,7 +893,6 @@ int rtw_hw_resume(_adapter *padapter)
 	pwrpriv->bips_processing = _FALSE;
 	_exit_pwrlock(&pwrpriv->lock);
 
-
 	return 0;
 error_exit:
 	RTW_INFO("%s, Open net dev failed\n", __FUNCTION__);
@@ -936,7 +908,6 @@ static int rtw_suspend(struct usb_interface *pusb_intf, pm_message_t message)
 	PADAPTER padapter;
 	int ret = 0;
 
-
 	dvobj = usb_get_intfdata(pusb_intf);
 	pwrpriv = dvobj_to_pwrctl(dvobj);
 	pdbgpriv = &dvobj->drv_dbg;
@@ -976,7 +947,6 @@ int rtw_resume_process(_adapter *padapter)
 	struct dvobj_priv *pdvobj = padapter->dvobj;
 	struct debug_priv *pdbgpriv = &pdvobj->drv_dbg;
 
-
 	if (pwrpriv->bInSuspend == _FALSE) {
 		pdbgpriv->dbg_resume_error_cnt++;
 		RTW_INFO("%s bInSuspend = %d\n", __FUNCTION__, pwrpriv->bInSuspend);
@@ -1036,7 +1006,6 @@ int rtw_resume_process(_adapter *padapter)
 	}
 #endif/* CONFIG_AUTOSUSPEND */
 
-
 	return ret;
 }
 
@@ -1049,7 +1018,6 @@ static int rtw_resume(struct usb_interface *pusb_intf)
 	struct mlme_ext_priv *pmlmeext;
 	int ret = 0;
 
-
 	dvobj = usb_get_intfdata(pusb_intf);
 	pwrpriv = dvobj_to_pwrctl(dvobj);
 	pdbgpriv = &dvobj->drv_dbg;
@@ -1088,8 +1056,6 @@ static int rtw_resume(struct usb_interface *pusb_intf)
 	return ret;
 }
 
-
-
 #ifdef CONFIG_AUTOSUSPEND
 void autosuspend_enter(_adapter *padapter)
 {
@@ -1235,7 +1201,6 @@ _adapter *rtw_usb_primary_adapter_init(struct dvobj_priv *dvobj,
 
 	padapter->dvobj = dvobj;
 
-
 	rtw_set_drv_stopped(padapter);/*init*/
 
 	dvobj->padapters[dvobj->iface_nums++] = padapter;
@@ -1258,7 +1223,6 @@ _adapter *rtw_usb_primary_adapter_init(struct dvobj_priv *dvobj,
 	if (rtw_set_hal_ops(padapter) == _FAIL)
 		goto free_hal_data;
 
-
 	padapter->intf_start = &usb_intf_start;
 	padapter->intf_stop = &usb_intf_stop;
 
@@ -1482,7 +1446,6 @@ static int rtw_drv_init(struct usb_interface *pusb_intf, const struct usb_device
 	rtd2885_wlan_netlink_sendMsg("linkup", "8712");
 #endif
 
-
 	status = _SUCCESS;
 
 #if 0 /* not used now */
@@ -1521,7 +1484,6 @@ static void rtw_dev_remove(struct usb_interface *pusb_intf)
 	struct net_device *pnetdev = padapter->pnetdev;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-
 	RTW_INFO("+rtw_dev_remove\n");
 
 	dvobj->processing_dev_remove = _TRUE;
@@ -1574,12 +1536,10 @@ static void rtw_dev_remove(struct usb_interface *pusb_intf)
 
 	RTW_INFO("-r871xu_dev_remove, done\n");
 
-
 #ifdef CONFIG_INTEL_PROXIM
 	rtw_sw_export = NULL;
 #endif
 
-
 	return;
 
 }
@@ -1646,7 +1606,6 @@ static void __exit rtw_drv_halt(void)
 	rtw_mstat_dump(RTW_DBGDUMP);
 }
 
-
 module_init(rtw_drv_entry);
 module_exit(rtw_drv_halt);
 
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/wifi_regd.c b/drivers/net/wireless/rtl8814au/os_dep/linux/wifi_regd.c
index b2c6052..fa8ba7b 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/wifi_regd.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/wifi_regd.c
@@ -10,519 +10,13 @@
 
 #include <rtw_wifi_regd.h>
 
-static struct country_code_to_enum_rd allCountries[] = {
-	{COUNTRY_CODE_USER, "RD"},
-};
-
-/*
- * REG_RULE(freq start, freq end, bandwidth, max gain, eirp, reg_flags)
- */
-
-/*
- *Only these channels all allow active
- *scan on all world regulatory domains
- */
-
-/* 2G chan 01 - chan 11 */
-#define RTW_2GHZ_CH01_11	\
-	REG_RULE(2412-10, 2462+10, 40, 0, 20, 0)
-
-/*
- *We enable active scan on these a case
- *by case basis by regulatory domain
- */
-
-/* 2G chan 12 - chan 13, PASSIV SCAN */
-#define RTW_2GHZ_CH12_13	\
-	REG_RULE(2467-10, 2472+10, 40, 0, 20,	\
-		 NL80211_RRF_PASSIVE_SCAN)
-
-/* 2G chan 14, PASSIVS SCAN, NO OFDM (B only) */
-#define RTW_2GHZ_CH14	\
-	REG_RULE(2484-10, 2484+10, 40, 0, 20,	\
-		 NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_OFDM)
-
-/* 5G chan 36 - chan 64 */
-#define RTW_5GHZ_5150_5350	\
-	REG_RULE(5150-10, 5350+10, 80, 0, 30,	\
-	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
-
-/* 5G chan 100 - chan 165 */
-#define RTW_5GHZ_5470_5850	\
-	REG_RULE(5470-10, 5850+10, 80, 0, 30, \
-	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
-
-/* 5G chan 149 - chan 165 */
-#define RTW_5GHZ_5725_5850	\
-	REG_RULE(5725-10, 5850+10, 80, 0, 30, \
-	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
-
-/* 5G chan 36 - chan 165 */
-#define RTW_5GHZ_5150_5850	\
-	REG_RULE(5150-10, 5850+10, 80, 0, 30,	\
-	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
-
-static const struct ieee80211_regdomain rtw_regdom_rd = {
-	.n_reg_rules = 4,
-	.alpha2 = "99",
-	.reg_rules = {
-		RTW_2GHZ_CH01_11,
-		RTW_2GHZ_CH12_13,
-		RTW_2GHZ_CH14,
-		RTW_5GHZ_5150_5850,
-	}
-};
-#if 0
-static const struct ieee80211_regdomain rtw_regdom_11 = {
-	.n_reg_rules = 1,
-	.alpha2 = "99",
-	.reg_rules = {
-		RTW_2GHZ_CH01_11,
-	}
-};
-
-static const struct ieee80211_regdomain rtw_regdom_12_13 = {
-	.n_reg_rules = 2,
-	.alpha2 = "99",
-	.reg_rules = {
-		RTW_2GHZ_CH01_11,
-		RTW_2GHZ_CH12_13,
-	}
-};
-
-static const struct ieee80211_regdomain rtw_regdom_no_midband = {
-	.n_reg_rules = 3,
-	.alpha2 = "99",
-	.reg_rules = {
-		RTW_2GHZ_CH01_11,
-		RTW_5GHZ_5150_5350,
-		RTW_5GHZ_5725_5850,
-	}
-};
-
-static const struct ieee80211_regdomain rtw_regdom_60_64 = {
-	.n_reg_rules = 3,
-	.alpha2 = "99",
-	.reg_rules = {
-		RTW_2GHZ_CH01_11,
-		RTW_2GHZ_CH12_13,
-		RTW_5GHZ_5725_5850,
-	}
-};
-
-static const struct ieee80211_regdomain rtw_regdom_14_60_64 = {
-	.n_reg_rules = 4,
-	.alpha2 = "99",
-	.reg_rules = {
-		RTW_2GHZ_CH01_11,
-		RTW_2GHZ_CH12_13,
-		RTW_2GHZ_CH14,
-		RTW_5GHZ_5725_5850,
-	}
-};
-
-static const struct ieee80211_regdomain rtw_regdom_14 = {
-	.n_reg_rules = 3,
-	.alpha2 = "99",
-	.reg_rules = {
-		RTW_2GHZ_CH01_11,
-		RTW_2GHZ_CH12_13,
-		RTW_2GHZ_CH14,
-	}
-};
-#endif
-#if 0
-static struct rtw_regulatory *rtw_regd;
-#endif
-
-static bool _rtw_is_radar_freq(u16 center_freq)
-{
-	return center_freq >= 5260 && center_freq <= 5700;
-}
-
-#if 0 /* not_yet */
-static void _rtw_reg_apply_beaconing_flags(struct wiphy *wiphy,
-		enum nl80211_reg_initiator initiator)
-{
-	enum ieee80211_band band;
-	struct ieee80211_supported_band *sband;
-	const struct ieee80211_reg_rule *reg_rule;
-	struct ieee80211_channel *ch;
-	unsigned int i;
-	u32 bandwidth = 0;
-	int r;
-
-	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
-
-		if (!wiphy->bands[band])
-			continue;
-
-		sband = wiphy->bands[band];
-
-		for (i = 0; i < sband->n_channels; i++) {
-			ch = &sband->channels[i];
-			if (_rtw_is_radar_freq(ch->center_freq) ||
-			    (ch->flags & IEEE80211_CHAN_RADAR))
-				continue;
-			if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-				r = freq_reg_info(wiphy, ch->center_freq,
-						  bandwidth, &reg_rule);
-				if (r)
-					continue;
-
-				/*
-				 *If 11d had a rule for this channel ensure
-				 *we enable adhoc/beaconing if it allows us to
-				 *use it. Note that we would have disabled it
-				 *by applying our static world regdomain by
-				 *default during init, prior to calling our
-				 *regulatory_hint().
-				 */
-
-				if (!(reg_rule->flags & NL80211_RRF_NO_IBSS))
-					ch->flags &= ~IEEE80211_CHAN_NO_IBSS;
-				if (!
-				    (reg_rule->flags &
-				     NL80211_RRF_PASSIVE_SCAN))
-					ch->flags &=
-						~IEEE80211_CHAN_PASSIVE_SCAN;
-			} else {
-				if (ch->beacon_found)
-					ch->flags &= ~(IEEE80211_CHAN_NO_IBSS |
-						IEEE80211_CHAN_PASSIVE_SCAN);
-			}
-		}
-	}
-}
-
-/* Allows active scan scan on Ch 12 and 13 */
-static void _rtw_reg_apply_active_scan_flags(struct wiphy *wiphy,
-		enum nl80211_reg_initiator
-		initiator)
-{
-	struct ieee80211_supported_band *sband;
-	struct ieee80211_channel *ch;
-	const struct ieee80211_reg_rule *reg_rule;
-	u32 bandwidth = 0;
-	int r;
-
-	if (!wiphy->bands[IEEE80211_BAND_2GHZ])
-		return;
-	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
-
-	/*
-	 * If no country IE has been received always enable active scan
-	 * on these channels. This is only done for specific regulatory SKUs
-	 */
-	if (initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-		ch = &sband->channels[11];	/* CH 12 */
-		if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-			ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
-		ch = &sband->channels[12];	/* CH 13 */
-		if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-			ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
-		return;
-	}
-
-	/*
-	 * If a country IE has been received check its rule for this
-	 * channel first before enabling active scan. The passive scan
-	 * would have been enforced by the initial processing of our
-	 * custom regulatory domain.
-	 */
-
-	ch = &sband->channels[11];	/* CH 12 */
-	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
-	if (!r) {
-		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
-			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
-	}
-
-	ch = &sband->channels[12];	/* CH 13 */
-	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
-	if (!r) {
-		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
-			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
-	}
-}
-#endif
-
-/*
- * Always apply Radar/DFS rules on
- * freq range 5260 MHz - 5700 MHz
- */
-static void _rtw_reg_apply_radar_flags(struct wiphy *wiphy)
-{
-	struct ieee80211_supported_band *sband;
-	struct ieee80211_channel *ch;
-	unsigned int i;
-
-	if (!wiphy->bands[IEEE80211_BAND_5GHZ])
-		return;
-
-	sband = wiphy->bands[IEEE80211_BAND_5GHZ];
-
-	for (i = 0; i < sband->n_channels; i++) {
-		ch = &sband->channels[i];
-		if (!_rtw_is_radar_freq(ch->center_freq))
-			continue;
-#ifdef CONFIG_DFS
-		#if !defined(CONFIG_DFS_MASTER)
-		if (!(ch->flags & IEEE80211_CHAN_DISABLED)) {
-			ch->flags |= IEEE80211_CHAN_RADAR;
-			#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
-			ch->flags |= (IEEE80211_CHAN_NO_IBSS | IEEE80211_CHAN_PASSIVE_SCAN);
-			#else
-			ch->flags |= IEEE80211_CHAN_NO_IR;
-			#endif
-		}
-		#endif
-#endif /* CONFIG_DFS */
-
-#if 0
-		/*
-		 * We always enable radar detection/DFS on this
-		 * frequency range. Additionally we also apply on
-		 * this frequency range:
-		 * - If STA mode does not yet have DFS supports disable
-		 *  active scanning
-		 * - If adhoc mode does not support DFS yet then disable
-		 *  adhoc in the frequency.
-		 * - If AP mode does not yet support radar detection/DFS
-		 *  do not allow AP mode
-		 */
-		if (!(ch->flags & IEEE80211_CHAN_DISABLED))
-			ch->flags |= IEEE80211_CHAN_RADAR |
-				     IEEE80211_CHAN_NO_IBSS |
-				     IEEE80211_CHAN_PASSIVE_SCAN;
-#endif
-	}
-}
-
-static void _rtw_reg_apply_flags(struct wiphy *wiphy)
-{
-#if 1				/* by channel plan */
-	_adapter *padapter = wiphy_to_adapter(wiphy);
-
-	struct ieee80211_supported_band *sband;
-	struct ieee80211_channel *ch;
-	unsigned int i, j;
-	u16 channel;
-
-	/* all channels disable */
-	for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
-		sband = wiphy->bands[i];
-
-		if (sband) {
-			for (j = 0; j < sband->n_channels; j++) {
-				ch = &sband->channels[j];
-
-				if (ch)
-					ch->flags &= ~(IEEE80211_CHAN_DISABLED|IEEE80211_CHAN_NO_HT40PLUS|
-						IEEE80211_CHAN_NO_HT40MINUS|IEEE80211_CHAN_NO_80MHZ|
-						IEEE80211_CHAN_NO_160MHZ|
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0))
-						IEEE80211_CHAN_NO_IBSS|IEEE80211_CHAN_PASSIVE_SCAN);	
-#else
-						IEEE80211_CHAN_NO_IR);
-#endif
-			}
-		}
-	}
-
-#else
-	struct ieee80211_supported_band *sband;
-	struct ieee80211_channel *ch;
-	unsigned int i, j;
-	u16 channels[37] = {
-		1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 36, 40, 44, 48, 52, 56,
-		60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140,
-		149, 153,
-		157, 161, 165
-	};
-	u16 channel;
-	u32 freq;
-
-	for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
-		sband = wiphy->bands[i];
-
-		if (sband)
-			for (j = 0; j < sband->n_channels; j++) {
-				ch = &sband->channels[j];
-
-				if (ch)
-					ch->flags = IEEE80211_CHAN_DISABLED;
-			}
-	}
-
-	for (i = 0; i < 37; i++) {
-		channel = channels[i];
-		freq = rtw_ch2freq(channel);
-
-		ch = ieee80211_get_channel(wiphy, freq);
-		if (ch) {
-			if (channel <= 11)
-				ch->flags = 0;
-			else
-				ch->flags = 0;	/* IEEE80211_CHAN_PASSIVE_SCAN; */
-		}
-		/* printk("%s: freq %d(%d) flag 0x%02X\n", __func__, freq, channel, ch->flags); */
-	}
-#endif
-}
-
-static void _rtw_reg_apply_world_flags(struct wiphy *wiphy,
-				       enum nl80211_reg_initiator initiator,
-				       struct rtw_regulatory *reg)
-{
-	/* _rtw_reg_apply_beaconing_flags(wiphy, initiator); */
-	/* _rtw_reg_apply_active_scan_flags(wiphy, initiator); */
-	return;
-}
-
-static int _rtw_reg_notifier_apply(struct wiphy *wiphy,
-				   struct regulatory_request *request,
-				   struct rtw_regulatory *reg)
-{
-
-	/* Hard code flags */
-	_rtw_reg_apply_flags(wiphy);
-
-	/* We always apply this */
-	_rtw_reg_apply_radar_flags(wiphy);
-
-	switch (request->initiator) {
-	case NL80211_REGDOM_SET_BY_DRIVER:
-		RTW_INFO("%s: %s\n", __func__, "NL80211_REGDOM_SET_BY_DRIVER");
-		_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER,
-					   reg);
-		break;
-	case NL80211_REGDOM_SET_BY_CORE:
-		RTW_INFO("%s: %s\n", __func__,
-			 "NL80211_REGDOM_SET_BY_CORE to DRV");
-		_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER,
-					   reg);
-		break;
-	case NL80211_REGDOM_SET_BY_USER:
-		RTW_INFO("%s: %s\n", __func__,
-			 "NL80211_REGDOM_SET_BY_USER to DRV");
-		_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER,
-					   reg);
-		break;
-	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
-		RTW_INFO("%s: %s\n", __func__,
-			 "NL80211_REGDOM_SET_BY_COUNTRY_IE");
-		_rtw_reg_apply_world_flags(wiphy, request->initiator, reg);
-		break;
-	}
-
-	return 0;
-}
-
-static const struct ieee80211_regdomain *_rtw_regdomain_select(struct
-		rtw_regulatory
-		*reg)
-{
-#if 0
-	switch (reg->country_code) {
-	case COUNTRY_CODE_USER:
-	default:
-		return &rtw_regdom_rd;
-	}
-#else
-	return &rtw_regdom_rd;
-#endif
-}
-
-void _rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
-{
-	struct rtw_regulatory *reg = NULL;
-
-	RTW_INFO("%s\n", __func__);
-
-	_rtw_reg_notifier_apply(wiphy, request, reg);
-}
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0))
-int rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
-#else
-void rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
-#endif
-{
-	_rtw_reg_notifier(wiphy, request);
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0))
-	return 0;
-#endif
-}
-
 void rtw_reg_notify_by_driver(_adapter *adapter)
 {
-	if ((adapter->rtw_wdev != NULL) && (adapter->rtw_wdev->wiphy)) {
-		struct regulatory_request request;
-		request.initiator = NL80211_REGDOM_SET_BY_DRIVER;
-		rtw_reg_notifier(adapter->rtw_wdev->wiphy, &request);
-	}
-}
-
-static void _rtw_regd_init_wiphy(struct rtw_regulatory *reg, struct wiphy *wiphy)
-{
-	const struct ieee80211_regdomain *regd;
-
-	wiphy->reg_notifier = rtw_reg_notifier;
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
-	wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
-	wiphy->flags &= ~WIPHY_FLAG_STRICT_REGULATORY;
-	wiphy->flags &= ~WIPHY_FLAG_DISABLE_BEACON_HINTS;
-#else
-	wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
-	wiphy->regulatory_flags &= ~REGULATORY_STRICT_REG;
-	wiphy->regulatory_flags &= ~REGULATORY_DISABLE_BEACON_HINTS;
-#endif
-
-	regd = _rtw_regdomain_select(reg);
-	wiphy_apply_custom_regulatory(wiphy, regd);
-
-	/* Hard code flags */
-	_rtw_reg_apply_flags(wiphy);
-	_rtw_reg_apply_radar_flags(wiphy);
-	_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
-}
-
-static struct country_code_to_enum_rd *_rtw_regd_find_country(u16 countrycode)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(allCountries); i++) {
-		if (allCountries[i].countrycode == countrycode)
-			return &allCountries[i];
-	}
-	return NULL;
+	return;
 }
 
 int rtw_regd_init(_adapter *padapter)
 {
-	struct wiphy *wiphy = padapter->rtw_wdev->wiphy;
-
-#if 0
-	if (rtw_regd == NULL) {
-		rtw_regd = (struct rtw_regulatory *)
-			   rtw_malloc(sizeof(struct rtw_regulatory));
-
-		rtw_regd->alpha2[0] = '9';
-		rtw_regd->alpha2[1] = '9';
-
-		rtw_regd->country_code = COUNTRY_CODE_USER;
-	}
-
-	RTW_INFO("%s: Country alpha2 being used: %c%c\n",
-		 __func__, rtw_regd->alpha2[0], rtw_regd->alpha2[1]);
-#endif
-
-	_rtw_regd_init_wiphy(NULL, wiphy);
-
 	return 0;
 }
 #endif /* CONFIG_IOCTL_CFG80211 */
diff --git a/drivers/net/wireless/rtl8814au/os_dep/osdep_service.c b/drivers/net/wireless/rtl8814au/os_dep/osdep_service.c
index 13a5bea..6fa4e82 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/osdep_service.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/osdep_service.c
@@ -18,7 +18,6 @@
  *
  ******************************************************************************/
 
-
 #define _OSDEP_SERVICE_C_
 
 #include <drv_types.h>
@@ -32,7 +31,6 @@ atomic_t _malloc_size = ATOMIC_INIT(0);
 #endif
 #endif /* DBG_MEMORY_LEAK */
 
-
 #if defined(PLATFORM_LINUX)
 /*
 * Translate the OS dependent @param error_code to OS independent RTW_STATUS_CODE
@@ -998,20 +996,15 @@ void rtw_list_insert_tail(_list *plist, _list *phead)
 
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 void rtw_init_timer(_timer *ptimer, void *padapter, void *pfunc)
 {
 	_adapter *adapter = (_adapter *)padapter;
 
-#ifdef PLATFORM_LINUX
 	_init_timer(ptimer, adapter->pnetdev, pfunc, adapter);
-#endif
-#ifdef PLATFORM_FREEBSD
-	_init_timer(ptimer, adapter->pifp, pfunc, adapter->mlmepriv.nic_hdl);
-#endif
-#ifdef PLATFORM_WINDOWS
-	_init_timer(ptimer, adapter->hndis_adapter, pfunc, adapter->mlmepriv.nic_hdl);
-#endif
+
 }
+#endif
 
 /*
 
@@ -1019,7 +1012,6 @@ Caller must check if the list is empty before calling rtw_list_delete
 
 */
 
-
 void _rtw_init_sema(_sema	*sema, int init_val)
 {
 
@@ -1212,7 +1204,6 @@ void rtw_mtx_unlock(_lock *plock)
 }
 #endif /* PLATFORM_FREEBSD */
 
-
 void	_rtw_spinlock(_lock	*plock)
 {
 
@@ -1288,8 +1279,6 @@ void	_rtw_spinunlock_ex(_lock *plock)
 #endif
 }
 
-
-
 void _rtw_init_queue(_queue *pqueue)
 {
 	_rtw_init_listhead(&(pqueue->queue));
@@ -1389,7 +1378,6 @@ inline s32 rtw_get_time_interval_ms(u32 start, u32 end)
 #endif
 }
 
-
 void rtw_sleep_schedulable(int ms)
 {
 
@@ -1420,7 +1408,6 @@ void rtw_sleep_schedulable(int ms)
 
 }
 
-
 void rtw_msleep_os(int ms)
 {
 
@@ -1445,7 +1432,6 @@ void rtw_msleep_os(int ms)
 
 #endif
 
-
 }
 void rtw_usleep_os(int us)
 {
@@ -1474,10 +1460,8 @@ void rtw_usleep_os(int us)
 
 #endif
 
-
 }
 
-
 #ifdef DBG_DELAY_OS
 void _rtw_mdelay_os(int ms, const char *func, const int line)
 {
@@ -1488,7 +1472,6 @@ void _rtw_mdelay_os(int ms, const char *func, const int line)
 	return;
 #endif
 
-
 	RTW_INFO("%s:%d %s(%d)\n", func, line, __FUNCTION__, ms);
 
 #if defined(PLATFORM_LINUX)
@@ -1501,7 +1484,6 @@ void _rtw_mdelay_os(int ms, const char *func, const int line)
 
 #endif
 
-
 }
 void _rtw_udelay_os(int us, const char *func, const int line)
 {
@@ -1517,7 +1499,6 @@ void _rtw_udelay_os(int us, const char *func, const int line)
 
 	RTW_INFO("%s:%d %s(%d)\n", func, line, __FUNCTION__, us);
 
-
 #if defined(PLATFORM_LINUX)
 
 	udelay((unsigned long)us);
@@ -1548,7 +1529,6 @@ void rtw_mdelay_os(int ms)
 
 #endif
 
-
 }
 void rtw_udelay_os(int us)
 {
@@ -1872,7 +1852,6 @@ inline int ATOMIC_DEC_RETURN(ATOMIC_T *v)
 #endif
 }
 
-
 #ifdef PLATFORM_LINUX
 /*
 * Open a file with the specific @param path, @param flag, @param mode
@@ -1919,12 +1898,10 @@ static int readFile(struct file *fp, char *buf, int len)
 		return -EPERM;
 
 	while (sum < len) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0))
 		rlen = kernel_read(fp, buf + sum, len - sum, &fp->f_pos);
-#else
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 		rlen = __vfs_read(fp, buf + sum, len - sum, &fp->f_pos);
-#endif
 #else
 		rlen = fp->f_op->read(fp, buf + sum, len - sum, &fp->f_pos);
 #endif
@@ -2282,7 +2259,6 @@ copy_to_user(void *to, const void *from, unsigned long n)
 	return 0;
 }
 
-
 /*
  * The usb_register and usb_deregister functions are used to register
  * usb drivers with the usb subsystem. In this compatibility layer
@@ -2298,7 +2274,6 @@ usb_register(struct usb_driver *driver)
 	return 0;
 }
 
-
 int
 usb_deregister(struct usb_driver *driver)
 {
@@ -2414,7 +2389,6 @@ void rtw_buf_update(u8 **buf, u32 *buf_len, u8 *src, u32 src_len)
 		rtw_mfree(ori, ori_len);
 }
 
-
 /**
  * rtw_cbuf_full - test if cbuf is full
  * @cbuf: pointer of struct rtw_cbuf
