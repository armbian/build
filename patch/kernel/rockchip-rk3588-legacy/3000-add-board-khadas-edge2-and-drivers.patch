From 498b68833515c25bba637ae715d07d0599b5c7e1 Mon Sep 17 00:00:00 2001
From: Jack Zhao <jack.zhao@wesion.com>
Date: Tue, 19 Jul 2022 08:55:30 +0800
Subject: Some of Khadas Edge2 DT, mcu stuff extracted from Khadas .66 tree,
 rebased against .100

This does not include all changes from Khadas, has has
- all the DT, modified to avoid clashing with the common dtsi files
- some new drivers used in the DT: mcu, wdt
- hacks to other drivers

---
 arch/arm64/boot/dts/rockchip/rk3588-nvr-demo-khadas-edge2.dtsi     |  832 +++++
 arch/arm64/boot/dts/rockchip/rk3588-rk806-single-khadas-edge2.dtsi |  396 +++
 arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2-camera.dtsi      |  468 +++
 arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2.dts              |  951 ++++++
 arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2.dtsi             | 1705 ++++++++++
 drivers/bluetooth/btbcm.c                                          |    1 +
 drivers/input/sensors/accel/kxtj9.c                                |   18 +-
 drivers/input/sensors/sensor-dev.c                                 |    2 +-
 drivers/leds/leds-gpio.c                                           |   40 +-
 drivers/misc/Kconfig                                               |   18 +-
 drivers/misc/Makefile                                              |    4 +-
 drivers/misc/khadas-mcu.c                                          |  696 ++++
 drivers/thermal/rockchip_thermal.c                                 |   17 +
 drivers/watchdog/Kconfig                                           |   10 +
 drivers/watchdog/Makefile                                          |    1 +
 drivers/watchdog/khadas_wdt.c                                      |  157 +
 include/dt-bindings/soc/rockchip,boot-mode.h                       |    3 +-
 17 files changed, 5305 insertions(+), 14 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3588-nvr-demo-khadas-edge2.dtsi b/arch/arm64/boot/dts/rockchip/rk3588-nvr-demo-khadas-edge2.dtsi
new file mode 100644
index 000000000000..ea7304d7e60d
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3588-nvr-demo-khadas-edge2.dtsi
@@ -0,0 +1,832 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#include "rk3588.dtsi"
+#include "rk3588-nvr.dtsi"
+#include "rk3588-rk806-single.dtsi"
+
+/ {
+	i2s0_sound: i2s0-sound {
+		status = "okay";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,name = "rockchip,es8311";
+		simple-audio-card,dai-link@0 {
+			format = "i2s";
+			cpu {
+				sound-dai = <&i2s0_8ch>;
+			};
+			codec {
+				sound-dai = <&es8311>;
+			};
+		};
+	};
+
+	leds: leds {
+		compatible = "gpio-leds";
+		hdd_led: hdd-led {
+			gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		net_led: net-led {
+			gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		work_led: work-led {
+			gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	pcie30_avdd0v75: pcie30-avdd0v75 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd0v75";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <750000>;
+		regulator-max-microvolt = <750000>;
+		vin-supply = <&vdd_0v75_s0>;
+	};
+
+	pcie30_avdd1v8: pcie30-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd1v8";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc3v3_pcie30: vcc3v3-pcie30 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie30";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpios = <&gpio3 RK_PD5 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <7500>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_sys>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+	};
+
+	vcc5v0_otg: vcc5v0-otg-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_otg";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_sys>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_otg_en>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+};
+
+&combphy0_ps {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sata0_pm_reset>;
+	status = "okay";
+};
+
+&combphy1_ps {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sata1_pm_reset>;
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&dp0 {
+	pinctrl-0 = <&dp0m2_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&dp0_in_vp0 {
+	status = "okay";
+};
+
+&dp0_in_vp1 {
+	status = "okay";
+};
+
+&dp0_in_vp2 {
+	status = "okay";
+};
+
+&dp1 {
+	pinctrl-0 = <&dp1m2_pins &dp1_hdmi_ctl>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&dp1_in_vp0 {
+	status = "okay";
+};
+
+&dp1_in_vp1 {
+	status = "okay";
+};
+
+&dp1_in_vp2 {
+	status = "okay";
+};
+
+&gmac0 {
+	/* Use rgmii-rxid mode to disable rx delay inside Soc */
+	phy-mode = "rgmii-rxid";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio4 RK_PB3 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac0_miim
+		     &gmac0_tx_bus2
+		     &gmac0_rx_bus2
+		     &gmac0_rgmii_clk
+		     &gmac0_rgmii_bus>;
+
+	tx_delay = <0x44>;
+	/* rx_delay = <0x4f>; */
+
+	phy-handle = <&rgmii_phy0>;
+	status = "okay";
+};
+
+&gmac1 {
+	/* Use rgmii-rxid mode to disable rx delay inside Soc */
+	phy-mode = "rgmii-rxid";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio4 RK_PA2 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1_miim
+		     &gmac1_tx_bus2
+		     &gmac1_rx_bus2
+		     &gmac1_rgmii_clk
+		     &gmac1_rgmii_bus>;
+
+	tx_delay = <0x42>;
+	/* rx_delay = <0x4f>; */
+
+	phy-handle = <&rgmii_phy1>;
+	status = "okay";
+};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&hdmi0_in_vp1 {
+	status = "okay";
+};
+
+&hdmi0_in_vp2 {
+	status = "okay";
+};
+
+&hdmi0_sound {
+	status = "okay";
+};
+
+&hdmi1 {
+	enable-gpios = <&gpio4 RK_PB2 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&hdmi1_in_vp0 {
+	status = "okay";
+};
+
+&hdmi1_in_vp1 {
+	status = "okay";
+};
+
+&hdmi1_in_vp2 {
+	status = "okay";
+};
+
+&hdmi1_sound {
+	status = "okay";
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+&hdptxphy_hdmi1 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	es8311: es8311@18 {
+		status = "okay";
+		compatible = "everest,es8311";
+		reg = <0x18>;
+		#sound-dai-cells = <0>;
+		adc-pga-gain = <6>;     /* 18dB */
+		adc-volume = <0xbf>;    /* 0dB */
+		dac-volume = <0xbf>;    /* 0dB */
+		aec-mode = "adc left, adc right";
+		clocks = <&cru I2S0_8CH_MCLKOUT>;
+		clock-names = "mclk";
+		assigned-clocks = <&cru I2S0_8CH_MCLKOUT>;
+		assigned-clock-rates = <12288000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s0_mclk>;
+	};
+};
+
+&i2c4 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4m3_xfer>;
+};
+
+&i2c5 {
+	status = "okay";
+};
+
+&i2c6 {
+	status = "okay";
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		reg = <0x51>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&rtc_int>;
+
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PB2 IRQ_TYPE_LEVEL_LOW>;
+		wakeup-source;
+	};
+};
+
+&i2s0_8ch {
+	status = "okay";
+	pinctrl-0 = <&i2s0_lrck
+		     &i2s0_sclk
+		     &i2s0_sdi0
+		     &i2s0_sdo0>;
+};
+
+&i2s5_8ch {
+	status = "okay";
+};
+
+&i2s6_8ch {
+	status = "okay";
+};
+
+&mdio0 {
+	rgmii_phy0: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&mdio1 {
+	rgmii_phy1: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&pcie30phy {
+	status = "okay";
+};
+
+&pcie3x4 {
+	reset-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie30>;
+	status = "okay";
+};
+
+&pwm3 {
+	compatible = "rockchip,remotectl-pwm";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm3m0_pins>;
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	remote_support_psci = <0>;
+	status = "okay";
+
+	ir_key1 {
+		rockchip,usercode = <0x4040>;
+		rockchip,key_table =
+			<0xf2	KEY_REPLY>,
+			<0xba	KEY_BACK>,
+			<0xf4	KEY_UP>,
+			<0xf1	KEY_DOWN>,
+			<0xef	KEY_LEFT>,
+			<0xee	KEY_RIGHT>,
+			<0xbd	KEY_HOME>,
+			<0xea	KEY_VOLUMEUP>,
+			<0xe3	KEY_VOLUMEDOWN>,
+			<0xe2	KEY_SEARCH>,
+			<0xb2	KEY_POWER>,
+			<0xbc	KEY_MUTE>,
+			<0xec	KEY_MENU>,
+			<0xbf	0x190>,
+			<0xe0	0x191>,
+			<0xe1	0x192>,
+			<0xe9	183>,
+			<0xe6	248>,
+			<0xe8	185>,
+			<0xe7	186>,
+			<0xf0	388>,
+			<0xbe	0x175>;
+	};
+
+	ir_key2 {
+		rockchip,usercode = <0xff00>;
+		rockchip,key_table =
+			<0xf9	KEY_HOME>,
+			<0xbf	KEY_BACK>,
+			<0xfb	KEY_MENU>,
+			<0xaa	KEY_REPLY>,
+			<0xb9	KEY_UP>,
+			<0xe9	KEY_DOWN>,
+			<0xb8	KEY_LEFT>,
+			<0xea	KEY_RIGHT>,
+			<0xeb	KEY_VOLUMEDOWN>,
+			<0xef	KEY_VOLUMEUP>,
+			<0xf7	KEY_MUTE>,
+			<0xe7	KEY_POWER>,
+			<0xfc	KEY_POWER>,
+			<0xa9	KEY_VOLUMEDOWN>,
+			<0xa8	KEY_PLAYPAUSE>,
+			<0xe0	KEY_VOLUMEDOWN>,
+			<0xa5	KEY_VOLUMEDOWN>,
+			<0xab	183>,
+			<0xb7	388>,
+			<0xe8	388>,
+			<0xf8	184>,
+			<0xaf	185>,
+			<0xed	KEY_VOLUMEDOWN>,
+			<0xee	186>,
+			<0xb3	KEY_VOLUMEDOWN>,
+			<0xf1	KEY_VOLUMEDOWN>,
+			<0xf2	KEY_VOLUMEDOWN>,
+			<0xf3	KEY_SEARCH>,
+			<0xb4	KEY_VOLUMEDOWN>,
+			<0xa4	KEY_SETUP>,
+			<0xbe	KEY_SEARCH>;
+	};
+
+	ir_key3 {
+		rockchip,usercode = <0x1dcc>;
+		rockchip,key_table =
+			<0xee	KEY_REPLY>,
+			<0xf0	KEY_BACK>,
+			<0xf8	KEY_UP>,
+			<0xbb	KEY_DOWN>,
+			<0xef	KEY_LEFT>,
+			<0xed	KEY_RIGHT>,
+			<0xfc	KEY_HOME>,
+			<0xf1	KEY_VOLUMEUP>,
+			<0xfd	KEY_VOLUMEDOWN>,
+			<0xb7	KEY_SEARCH>,
+			<0xff	KEY_POWER>,
+			<0xf3	KEY_MUTE>,
+			<0xbf	KEY_MENU>,
+			<0xf9	0x191>,
+			<0xf5	0x192>,
+			<0xb3	388>,
+			<0xbe	KEY_1>,
+			<0xba	KEY_2>,
+			<0xb2	KEY_3>,
+			<0xbd	KEY_4>,
+			<0xf9	KEY_5>,
+			<0xb1	KEY_6>,
+			<0xfc	KEY_7>,
+			<0xf8	KEY_8>,
+			<0xb0	KEY_9>,
+			<0xb6	KEY_0>,
+			<0xb5	KEY_BACKSPACE>;
+	};
+};
+/*
+&rk806single {
+	pinctrl-names = "default", "pmic-power-off";
+	pinctrl-0 = <&pmic_pins>, <&rk806_dvs1_null>, <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+	pinctrl-1 = <&rk806_dvs1_slp>, <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+
+	regulators {
+		avcc_1v8_s0: PLDO_REG1 {
+			regulator-always-on;
+			regulator-boot-on;
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-name = "avcc_1v8_s0";
+			regulator-state-mem {
+				regulator-on-in-suspend;
+				regulator-suspend-microvolt = <1800000>;
+			};
+		};
+	};
+};
+*/
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+	rockchip,virtual-poweroff = <1>;
+	rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_ARMOFF_DDRPD
+		)
+	>;
+	rockchip,wakeup-config = <
+		(0
+		| RKPM_CPU0_WKUP_EN
+		| RKPM_GPIO_WKUP_EN
+		)
+	>;
+};
+
+&route_dp0 {
+	status = "okay";
+	force-output;
+	connect = <&vp2_out_dp0>;
+
+	force_timing {
+		clock-frequency = <65000000>;
+		hactive = <1024>;
+		vactive = <768>;
+		hfront-porch = <24>;
+		hsync-len = <136>;
+		hback-porch = <160>;
+		vfront-porch = <3>;
+		vsync-len = <6>;
+		vback-porch = <29>;
+		hsync-active = <0>;
+		vsync-active = <0>;
+		de-active = <0>;
+		pixelclk-active = <0>;
+	};
+
+};
+
+&route_dp1 {
+	status = "okay";
+	force-output;
+	connect = <&vp2_out_dp1>;
+
+	force_timing {
+		clock-frequency = <65000000>;
+		hactive = <1024>;
+		vactive = <768>;
+		hfront-porch = <24>;
+		hsync-len = <136>;
+		hback-porch = <160>;
+		vfront-porch = <3>;
+		vsync-len = <6>;
+		vback-porch = <29>;
+		hsync-active = <0>;
+		vsync-active = <0>;
+		de-active = <0>;
+		pixelclk-active = <0>;
+	};
+
+};
+
+&route_hdmi0 {
+	status = "okay";
+	force-output;
+	connect = <&vp2_out_hdmi0>;
+
+	force_timing {
+		clock-frequency = <65000000>;
+		hactive = <1024>;
+		vactive = <768>;
+		hfront-porch = <24>;
+		hsync-len = <136>;
+		hback-porch = <160>;
+		vfront-porch = <3>;
+		vsync-len = <6>;
+		vback-porch = <29>;
+		hsync-active = <0>;
+		vsync-active = <0>;
+		de-active = <0>;
+		pixelclk-active = <0>;
+	};
+
+};
+
+&route_hdmi1 {
+	status = "okay";
+	force-output;
+	connect = <&vp2_out_hdmi1>;
+
+	force_timing {
+		clock-frequency = <65000000>;
+		hactive = <1024>;
+		vactive = <768>;
+		hfront-porch = <24>;
+		hsync-len = <136>;
+		hback-porch = <160>;
+		vfront-porch = <3>;
+		vsync-len = <6>;
+		vback-porch = <29>;
+		hsync-active = <0>;
+		vsync-active = <0>;
+		de-active = <0>;
+		pixelclk-active = <0>;
+	};
+
+};
+
+&sata0 {
+	status = "okay";
+};
+
+&sata1 {
+	status = "okay";
+};
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	status = "okay";
+};
+
+&pinctrl {
+	dp {
+		dp1_hdmi_ctl: dp-hdmi-ctl {
+			rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>,
+					<3 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	rtc {
+		rtc_int: rtc-int {
+			rockchip,pins = <0 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		vcc5v0_otg_en: vcc5v0-otg-en {
+			rockchip,pins = <4 RK_PA7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	sata {
+		sata0_pm_reset: sata0-pm-reset {
+			rockchip,pins = <4 RK_PA0 RK_FUNC_GPIO &pcfg_output_high>;
+		};
+		sata1_pm_reset: sata1-pm-reset {
+			rockchip,pins = <4 RK_PA1 RK_FUNC_GPIO &pcfg_output_high>;
+		};
+	};
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy1 {
+	status = "okay";
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	vbus-supply = <&vcc5v0_otg>;
+	status = "okay";
+};
+
+&u2phy1_otg {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&u2phy2_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&u2phy3_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	rockchip,dp-lane-mux = < 2 3 >;
+	status = "okay";
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdp_phy1 {
+	rockchip,dp-lane-mux = < 0 1 2 3 >;
+	status = "okay";
+};
+
+&usbdp_phy1_dp {
+	status = "okay";
+};
+
+&usbdp_phy1_u3 {
+	maximum-speed = "high-speed";
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "peripheral";
+	status = "okay";
+};
+
+&usbdrd_dwc3_1 {
+	dr_mode = "host";
+	maximum-speed = "high-speed";
+	status = "okay";
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&vdd_log_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <750000>;
+	};
+};
+
+&vdd_vdenc_s0 {
+	regulator-init-microvolt = <750000>;
+};
+
diff --git a/arch/arm64/boot/dts/rockchip/rk3588-rk806-single-khadas-edge2.dtsi b/arch/arm64/boot/dts/rockchip/rk3588-rk806-single-khadas-edge2.dtsi
new file mode 100644
index 000000000000..a65a39564ba2
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3588-rk806-single-khadas-edge2.dtsi
@@ -0,0 +1,396 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Wesion Technology Co., Ltd.
+ *
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+&spi2 {
+	status = "okay";
+	assigned-clocks = <&cru CLK_SPI2>;
+	assigned-clock-rates = <200000000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi2m2_cs0 &spi2m2_pins>;
+	num-cs = <1>;
+
+	rk806single: rk806single@0 {
+		compatible = "rockchip,rk806";
+		spi-max-frequency = <1000000>;
+		reg = <0x0>;
+
+		interrupt-parent = <&gpio0>;
+		interrupts = <7 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default", "pmic-power-off";
+		pinctrl-0 = <&pmic_pins>, <&rk806_dvs1_null>, <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+		pinctrl-1 = <&rk806_dvs1_pwrdn>;
+
+		/* 2800mv-3500mv */
+		low_voltage_threshold = <3000>;
+		/* 2700mv-3400mv */
+		shutdown_voltage_threshold = <2700>;
+		/* 140 160 */
+		shutdown_temperture_threshold = <160>;
+		hotdie_temperture_threshold = <115>;
+
+		/* 0: restart PMU;
+		 * 1: reset all the power off reset registers,
+		 *    forcing the state to switch to ACTIVE mode;
+		 * 2: Reset all the power off reset registers,
+		 *    forcing the state to switch to ACTIVE mode,
+		 *    and simultaneously pull down the RESETB PIN for 5mS before releasing
+		 */
+		pmic-reset-func = <1>;
+
+		vcc1-supply = <&vcc5v0_sys>;
+		vcc2-supply = <&vcc5v0_sys>;
+		vcc3-supply = <&vcc5v0_sys>;
+		vcc4-supply = <&vcc5v0_sys>;
+		vcc5-supply = <&vcc5v0_sys>;
+		vcc6-supply = <&vcc5v0_sys>;
+		vcc7-supply = <&vcc5v0_sys>;
+		vcc8-supply = <&vcc5v0_sys>;
+		vcc9-supply = <&vcc5v0_sys>;
+		vcc10-supply = <&vcc5v0_sys>;
+		vcc11-supply = <&vcc_2v0_pldo_s3>;
+		vcc12-supply = <&vcc5v0_sys>;
+		vcc13-supply = <&vcc_1v1_nldo_s3>;
+		vcc14-supply = <&vcc_1v1_nldo_s3>;
+		vcca-supply = <&vcc5v0_sys>;
+
+		pwrkey {
+			status = "okay";
+		};
+
+		pinctrl_rk806: pinctrl_rk806 {
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			rk806_dvs1_null: rk806_dvs1_null {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun0";
+			};
+
+			rk806_dvs1_slp: rk806_dvs1_slp {
+				pins = "gpio_pwrctrl1";
+				function = "pin_fun1";
+			};
+
+			rk806_dvs1_pwrdn: rk806_dvs1_pwrdn {
+				pins = "gpio_pwrctrl1";
+				function = "pin_fun2";
+			};
+
+			rk806_dvs1_rst: rk806_dvs1_rst {
+				pins = "gpio_pwrctrl1";
+				function = "pin_fun3";
+			};
+
+			rk806_dvs2_null: rk806_dvs2_null {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun0";
+			};
+
+			rk806_dvs2_slp: rk806_dvs2_slp {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun1";
+			};
+
+			rk806_dvs2_pwrdn: rk806_dvs2_pwrdn {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun2";
+			};
+
+			rk806_dvs2_rst: rk806_dvs2_rst {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun3";
+			};
+
+			rk806_dvs2_dvs: rk806_dvs2_dvs {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun4";
+			};
+
+			rk806_dvs2_gpio: rk806_dvs2_gpio {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun5";
+			};
+
+			rk806_dvs3_null: rk806_dvs3_null {
+				pins = "gpio_pwrctrl3";
+				function = "pin_fun0";
+			};
+
+			rk806_dvs3_slp: rk806_dvs3_slp {
+				pins = "gpio_pwrctrl3";
+				function = "pin_fun1";
+			};
+
+			rk806_dvs3_pwrdn: rk806_dvs3_pwrdn {
+				pins = "gpio_pwrctrl3";
+				function = "pin_fun2";
+			};
+
+			rk806_dvs3_rst: rk806_dvs3_rst {
+				pins = "gpio_pwrctrl3";
+				function = "pin_fun3";
+			};
+
+			rk806_dvs3_dvs: rk806_dvs3_dvs {
+				pins = "gpio_pwrctrl3";
+				function = "pin_fun4";
+			};
+
+			rk806_dvs3_gpio: rk806_dvs3_gpio {
+				pins = "gpio_pwrctrl3";
+				function = "pin_fun5";
+			};
+		};
+
+		regulators {
+			vdd_gpu_s0: vdd_gpu_mem_s0: DCDC_REG1 {
+				regulator-boot-on;
+				regulator-min-microvolt = <550000>;
+				regulator-max-microvolt = <950000>;
+				regulator-ramp-delay = <12500>;
+				regulator-name = "vdd_gpu_s0";
+				regulator-enable-ramp-delay = <400>;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_cpu_lit_s0: vdd_cpu_lit_mem_s0: DCDC_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <550000>;
+				regulator-max-microvolt = <950000>;
+				regulator-ramp-delay = <12500>;
+				regulator-name = "vdd_cpu_lit_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_log_s0: DCDC_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <675000>;
+				regulator-max-microvolt = <750000>;
+				regulator-ramp-delay = <12500>;
+				regulator-name = "vdd_log_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <750000>;
+				};
+			};
+
+			vdd_vdenc_s0: vdd_vdenc_mem_s0: DCDC_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <550000>;
+				regulator-max-microvolt = <950000>;
+				regulator-init-microvolt = <750000>;
+				regulator-ramp-delay = <12500>;
+				regulator-name = "vdd_vdenc_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_ddr_s0: DCDC_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <675000>;
+				regulator-max-microvolt = <900000>;
+				regulator-ramp-delay = <12500>;
+				regulator-name = "vdd_ddr_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <850000>;
+				};
+			};
+
+			vdd2_ddr_s3: DCDC_REG6 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vdd2_ddr_s3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc_2v0_pldo_s3: DCDC_REG7 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <2000000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-name = "vdd_2v0_pldo_s3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <2000000>;
+				};
+			};
+
+			vcc_3v3_s3: DCDC_REG8 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc_3v3_s3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vddq_ddr_s0: DCDC_REG9 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vddq_ddr_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_1v8_s3: DCDC_REG10 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_1v8_s3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			avcc_1v8_s0: PLDO_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "avcc_1v8_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_1v8_s0: PLDO_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_1v8_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			avdd_1v2_s0: PLDO_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1200000>;
+				regulator-name = "avdd_1v2_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_3v3_s0: PLDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc_3v3_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vccio_sd_s0: PLDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vccio_sd_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			pldo6_s3: PLDO_REG6 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "pldo6_s3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vdd_0v75_s3: NLDO_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <750000>;
+				regulator-name = "vdd_0v75_s3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <750000>;
+				};
+			};
+
+			vdd_ddr_pll_s0: NLDO_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <850000>;
+				regulator-max-microvolt = <850000>;
+				regulator-name = "vdd_ddr_pll_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <850000>;
+				};
+			};
+
+			avdd_0v75_s0: NLDO_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <837500>;
+				regulator-max-microvolt = <837500>;
+				regulator-name = "avdd_0v75_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_0v85_s0: NLDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <850000>;
+				regulator-max-microvolt = <850000>;
+				regulator-name = "vdd_0v85_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_0v75_s0: NLDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <750000>;
+				regulator-name = "vdd_0v75_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2-camera.dtsi b/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2-camera.dtsi
new file mode 100644
index 000000000000..2e27954aed42
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2-camera.dtsi
@@ -0,0 +1,468 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Wesion Technology Co., Ltd.
+ *
+ */
+
+&csi2_dcphy0 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi_in_dcphy0: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&imx415b_out0>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csidcphy0_out: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&mipi0_csi2_input>;
+			};
+		};
+	};
+};
+
+&mipi_dcphy0 {
+	status = "okay";
+};
+
+&csi2_dcphy1 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi_in_dcphy1: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&imx415f_out1>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csidcphy1_out: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&mipi1_csi2_input>;
+			};
+		};
+	};
+};
+
+&mipi_dcphy1 {
+	status = "okay";
+};
+
+&csi2_dphy0 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipidphy0_in_ucam0: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&imx415c_out0>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csidphy0_out: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&mipi2_csi2_input>;
+			};
+		};
+	};
+};
+
+&csi2_dphy0_hw {
+	status = "okay";
+};
+
+&i2c4 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4m3_xfer>;
+
+	dw9714b: dw9714b@c {
+		compatible = "dongwoon,dw9714";
+		status = "okay";
+		reg = <0x0c>;
+		pinctrl-names = "focusb_gpios";
+		pinctrl-0 = <&focusb_gpio>;
+		focus-gpios = <&gpio1 RK_PA0 GPIO_ACTIVE_HIGH>;
+		rockchip,vcm-start-current = <20>;
+		rockchip,vcm-rated-current = <76>;
+		rockchip,vcm-step-mode = <0>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+	};
+
+	imx415b: imx415b@1a {
+		compatible = "sony,imx415";
+		status = "okay";
+		reg = <0x1a>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M1>;
+		clock-names = "xvclk";
+		power-domains = <&power RK3588_PD_VI>;
+		pinctrl-names = "default", "camb_gpios";
+		pinctrl-0 = <&mipim1_camera1_clk>, <&camb_gpio>;
+		rockchip,grf = <&sys_grf>;
+		reset-gpios = <&gpio1 RK_PB2 GPIO_ACTIVE_LOW>;
+		pwdn-gpios = <&gpio1 RK_PB3 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "CMK-OT2022-PX1";
+		rockchip,camera-module-lens-name = "IR0147-50IRC-8M-F20";
+		lens-focus = <&dw9714b>;
+		port {
+			imx415b_out0: endpoint {
+				remote-endpoint = <&mipi_in_dcphy0>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c3m0_xfer>;
+
+	dw9714f: dw9714f@c {
+		compatible = "dongwoon,dw9714";
+		status = "okay";
+		reg = <0x0c>;
+		pinctrl-names = "focusf_gpios";
+		pinctrl-0 = <&focusf_gpio>;
+		focus-gpios = <&gpio1 RK_PA1 GPIO_ACTIVE_HIGH>;
+		rockchip,vcm-start-current = <20>;
+		rockchip,vcm-rated-current = <76>;
+		rockchip,vcm-step-mode = <0>;
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "front";
+	};
+
+	imx415f: imx415f@1a {
+		compatible = "sony,imx415";
+		status = "okay";
+		reg = <0x1a>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M2>;
+		clock-names = "xvclk";
+		power-domains = <&power RK3588_PD_VI>;
+		pinctrl-names = "default", "camf_gpios";
+		pinctrl-0 = <&mipim1_camera2_clk>, <&camf_gpio>;
+		rockchip,grf = <&sys_grf>;
+		reset-gpios = <&gpio3 RK_PC6 GPIO_ACTIVE_LOW>;
+		pwdn-gpios = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "front";
+		rockchip,camera-module-name = "CMK-OT2022-PX1";
+		rockchip,camera-module-lens-name = "IR0147-50IRC-8M-F20";
+		lens-focus = <&dw9714f>;
+		port {
+			imx415f_out1: endpoint {
+				remote-endpoint = <&mipi_in_dcphy1>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+	};
+};
+
+&i2c8 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c8m2_xfer>;
+
+	dw9714c: dw9714c@c {
+		compatible = "dongwoon,dw9714";
+		status = "okay";
+		reg = <0x0c>;
+		pinctrl-names = "focusc_gpios";
+		pinctrl-0 = <&focusc_gpio>;
+		focus-gpios = <&gpio1 RK_PA6 GPIO_ACTIVE_HIGH>;
+		rockchip,vcm-start-current = <20>;
+		rockchip,vcm-rated-current = <76>;
+		rockchip,vcm-step-mode = <0>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+	};
+
+	imx415: imx415@1a {
+		compatible = "sony,imx415";
+		reg = <0x1a>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M3>;
+		clock-names = "xvclk";
+		pinctrl-names = "default", "camc_gpios";
+		pinctrl-0 = <&mipim1_camera3_clk>, <&camc_gpio>;
+		power-domains = <&power RK3588_PD_VI>;
+		reset-gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;	
+		pwdn-gpios = <&gpio1 RK_PA4 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "CMK-OT2022-PX1";
+		rockchip,camera-module-lens-name = "IR0147-50IRC-8M-F20";
+		lens-focus = <&dw9714c>;
+		port {
+			imx415c_out0: endpoint {
+				remote-endpoint = <&mipidphy0_in_ucam0>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+	};
+};
+
+&pinctrl {
+	cam {
+		camf_gpio: camf-gpio {
+			rockchip,pins =
+				<3 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>,
+				<3 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		camb_gpio: camb-gpio {
+			rockchip,pins =
+				<1 RK_PB2 RK_FUNC_GPIO &pcfg_pull_none>,
+				<1 RK_PB3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		camc_gpio: camc-gpio {
+			rockchip,pins =
+				<3 RK_PB4 RK_FUNC_GPIO &pcfg_pull_none>,
+				<1 RK_PA4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		focusb_gpio: focusb-gpio {
+			rockchip,pins =
+				<1 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		focusf_gpio: focusf-gpio {
+			rockchip,pins =
+				<1 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		focusc_gpio: focusc-gpio {
+			rockchip,pins =
+				<1 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&mipi0_csi2 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi0_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csidcphy0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi0_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi_in0>;
+			};
+		};
+	};
+};
+
+&mipi1_csi2 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi1_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csidcphy1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi1_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi_in1>;
+			};
+		};
+	};
+};
+
+&mipi2_csi2 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi2_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csidphy0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi2_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi2_in0>;
+			};
+		};
+	};
+};
+
+&rkcif {
+	status = "okay";
+};
+
+&rkcif_mipi_lvds {
+	status = "okay";
+
+	port {
+		cif_mipi_in0: endpoint {
+			remote-endpoint = <&mipi0_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds_sditf {
+	status = "okay";
+
+	port {
+		mipi_lvds_sditf: endpoint {
+			remote-endpoint = <&isp1_in1>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds1 {
+	status = "okay";
+
+	port {
+		cif_mipi_in1: endpoint {
+			remote-endpoint = <&mipi1_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds1_sditf {
+	status = "okay";
+
+	port {
+		mipi1_lvds_sditf: endpoint {
+			remote-endpoint = <&isp1_in2>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds2 {
+	status = "okay";
+
+	port {
+		cif_mipi2_in0: endpoint {
+			remote-endpoint = <&mipi2_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds2_sditf {
+	status = "okay";
+
+	port {
+		mipi_lvds2_sditf: endpoint {
+			remote-endpoint = <&isp0_vir0>;
+		};
+	};
+};
+
+&rkcif_mmu {
+	status = "okay";
+};
+
+&rkisp_unite {
+	status = "okay";
+
+};
+
+&rkisp_unite_mmu {
+	status = "okay";
+};
+
+&rkisp0_vir0 {
+	status = "okay";
+	/*
+	 * dual isp process image case
+	 * other rkisp hw and virtual nodes should disabled
+	 */
+	rockchip,hw = <&rkisp_unite>;
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		isp1_in1: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&mipi_lvds_sditf>;
+		};
+		isp1_in2: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&mipi1_lvds_sditf>;
+		};
+		isp0_vir0: endpoint@2 {
+			reg = <2>;
+			remote-endpoint = <&mipi_lvds2_sditf>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2.dts b/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2.dts
new file mode 100644
index 000000000000..dfacb4da2db7
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2.dts
@@ -0,0 +1,951 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Wesion Technology Co., Ltd.
+ *
+ */
+/dts-v1/;
+
+#include "dt-bindings/usb/pd.h"
+#include "rk3588s.dtsi"
+#include "rk3588s-khadas-edge2.dtsi"
+#include "rk3588-rk806-single-khadas-edge2.dtsi"
+#include "rk3588-linux.dtsi"
+#include "rk3588s-khadas-edge2-camera.dtsi"
+
+
+/ {
+	model = "Khadas Edge2";
+	compatible = "khadas,edge2", "rockchip,rk3588";
+
+	combophy_avdd0v85: combophy-avdd0v85 {
+		compatible = "regulator-fixed";
+		regulator-name = "combophy_avdd0v85";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <850000>;
+		regulator-max-microvolt = <850000>;
+		vin-supply = <&vdd_0v85_s0>;
+	};
+
+	combophy_avdd1v8: combophy-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "combophy_avdd1v8";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	sound_micarray: sound-micarray {
+		status = "okay";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,name = "rockchip,sound-micarray";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,dai-link@0 {
+			format = "pdm";
+			cpu {
+				sound-dai = <&pdm0>;
+			};
+			codec {
+				sound-dai = <&dummy_codec>;
+			};
+		};
+	};
+
+	dummy_codec: dummy-codec {
+		compatible = "rockchip,dummy-codec";
+		#sound-dai-cells = <0>;
+		status = "okay";
+	};
+
+	es8316_sound: es8316-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,name = "rockchip,es8316-codec";
+		simple-audio-card,dai-link@0 {
+			format = "i2s";
+			cpu {
+				sound-dai = <&i2s0_8ch>;
+			};
+			codec {
+				sound-dai = <&es8316>;
+			};
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&red_led_gpio &green_led_gpio &blue_led_gpio>;
+
+		red_led {
+			gpios = <&gpio4 RK_PB4 GPIO_ACTIVE_HIGH>;
+			label = "red_led";
+			linux,default-trigger = "none";
+			default-state = "off";
+		};
+
+		green_led {
+			gpios = <&gpio4 RK_PB2 GPIO_ACTIVE_HIGH>;
+			label = "green_led";
+			linux,default-trigger = "default-on";
+			default-state = "on";
+		};
+
+		blue_led {
+			gpios = <&gpio4 RK_PB3 GPIO_ACTIVE_HIGH>;
+			label = "blue_led";
+			linux,default-trigger = "none";
+			default-state = "off";
+		};
+	};
+
+	khadas_wdt {
+		compatible = "linux,wdt-khadas";
+		status = "okay";
+		hw_margin_ms = <500>;
+		hw-gpios = <&gpio0 RK_PB0 GPIO_ACTIVE_HIGH>;
+	};
+
+//	fan: pwm-fan {
+//		compatible = "pwm-fan";
+//		#cooling-cells = <2>;
+//		pwms = <&pwm11 0 50000 0>;
+//	};
+
+	vbus5v0_typec: vbus5v0-typec {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus5v0_typec";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio3 RK_PA4 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&typec5v_pwren>;
+	};
+
+	vcc3v3_pcie20: vcc3v3-pcie20 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie20";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpios = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <5000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_host: vcc5v0-host {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio1 RK_PB1 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+	};
+
+	vcc_sd: vcc-sd {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_sd";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpio = <&gpio1 RK_PB6 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc_3v3_s3>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc_sd_en>;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	wireless_bluetooth: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&pt7c4363>;
+		clock-names = "ext_clock";
+		uart_rts_gpios = <&gpio3 RK_PD2 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart9m2_rtsn>, <&bt_gpio>;
+		pinctrl-1 = <&uart9_gpios>;
+		BT,reset_gpio    = <&gpio0 RK_PD4 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio0 RK_PD3 GPIO_ACTIVE_HIGH>;
+		BT,wake_host_irq = <&gpio0 RK_PD5 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	bt-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "dsp_a";
+		simple-audio-card,bitclock-inversion = <1>;
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,name = "rockchip,bt";
+		simple-audio-card,cpu {
+			sound-dai = <&i2s2_2ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&bt_sco>;
+		};
+	};
+
+	bt_sco: bt-sco {
+		compatible = "delta,dfbmcs320";
+		#sound-dai-cells = <0>;
+		status = "okay";
+	};
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		wifi_chip_type = "ap6275p";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_host_wake_irq>;
+		WIFI,host_wake_irq = <&gpio0 RK_PA0 GPIO_ACTIVE_HIGH>;
+	//	WIFI,poweren_gpio = <&gpio0 RK_PC7 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	vcc3v3_lcd1_en: vcc3v3-lcd1-en {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_lcd1_en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio4 RK_PA4 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-boot-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+
+	};
+
+	vcc3v3_lcd2_en: vcc3v3-lcd2-en {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_lcd2_en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-boot-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+
+	};
+
+};
+
+&backlight_mipi0 {
+	pwms = <&pwm12 0 25000 0>;
+	power-supply = <&vcc3v3_lcd1_en>;
+	status = "okay";
+};
+
+&backlight_mipi1 {
+	pwms = <&pwm13 0 25000 0>;
+	power-supply = <&vcc3v3_lcd2_en>;
+	status = "disabled";
+};
+
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&cru {
+	assigned-clock-rates =
+            <1100000000>, <786432000>,
+            <850000000>, <1188000000>,
+            <702000000>,
+            <400000000>, <500000000>,
+            <800000000>, <100000000>,
+            <400000000>, <100000000>,
+            <200000000>, <800000000>,
+            <375000000>, <150000000>,
+            <200000000>;
+};
+
+&dp0 {
+	status = "okay";
+};
+
+&dp0_in_vp2 {
+	status = "okay";
+};
+
+&dp0_sound{
+	status = "okay";
+};
+
+&dsi0 {
+	status = "disabled";
+	reset-delay-ms = <20>;
+	reset-gpios = <&gpio4 RK_PA3 GPIO_ACTIVE_HIGH>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcd1_rst_gpio>;
+
+};
+
+&dsi0_panel {
+	status = "okay";
+	power-supply = <&vcc3v3_lcd1_en>;
+};
+
+&dsi0_in_vp2 {
+	status = "disabled";
+};
+
+&dsi0_in_vp3 {
+	status = "okay";
+};
+
+&hdmi0_sound {
+	status = "okay";
+};
+
+&route_dsi0 {
+	status = "okay";
+	connect = <&vp3_out_dsi0>;
+};
+
+&mipi_dcphy0 {
+	status = "okay";
+};
+
+&dsi1 {
+	reset-delay-ms = <20>;
+	reset-gpios = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcd2_rst_gpio1>;
+	status = "disabled";
+};
+
+&dsi1_panel {
+	status = "disabled";
+	power-supply = <&vcc3v3_lcd2_en>;
+};
+
+&mipi_dcphy1 {
+	status = "okay";
+};
+
+&dsi1_in_vp2 {
+	status = "disabled";
+};
+
+&dsi1_in_vp3 {
+	status = "disabled";
+};
+
+&route_dsi1 {
+	status = "disabled";
+	connect = <&vp3_out_dsi1>;
+};
+
+//&hdptxphy0 {
+	/* Single Vdiff Training Table for power reduction (optional) */
+//	training-table = /bits/ 8 <
+		/* voltage swing 0, pre-emphasis 0->3 */
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+		/* voltage swing 1, pre-emphasis 0->2 */
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+		/* voltage swing 2, pre-emphasis 0->1 */
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+		/* voltage swing 3, pre-emphasis 0 */
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//	>;
+//	status = "okay";
+//};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+ };
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+ };
+
+&i2s2_2ch {
+	status = "okay";
+};
+
+&i2c0 {
+    status = "okay";
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c0m2_xfer>;
+
+    vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+        compatible = "rockchip,rk8602";
+        reg = <0x42>;
+        vin-supply = <&vcc5v0_sys>;
+        regulator-compatible = "rk860x-reg";
+        regulator-name = "vdd_cpu_big0_s0";
+        regulator-min-microvolt = <550000>;
+        regulator-max-microvolt = <1050000>;
+        regulator-ramp-delay = <12500>;
+        rockchip,suspend-voltage-selector = <1>;
+        regulator-boot-on;
+        regulator-always-on;
+        regulator-state-mem {
+            regulator-off-in-suspend;
+        };
+    };
+
+    vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+        compatible = "rockchip,rk8603";
+        reg = <0x43>;
+        vin-supply = <&vcc5v0_sys>;
+        regulator-compatible = "rk860x-reg";
+        regulator-name = "vdd_cpu_big1_s0";
+        regulator-min-microvolt = <550000>;
+        regulator-max-microvolt = <1050000>;
+        regulator-ramp-delay = <12500>;
+        rockchip,suspend-voltage-selector = <1>;
+        regulator-boot-on;
+        regulator-always-on;
+        regulator-state-mem {
+            regulator-off-in-suspend;
+        };
+    };
+};
+
+&i2s5_8ch {
+	status = "okay";
+};
+
+&i2c2 {
+
+    status = "okay";
+
+    vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+        compatible = "rockchip,rk8602";
+        reg = <0x42>;
+        vin-supply = <&vcc5v0_sys>;
+        regulator-compatible = "rk860x-reg";
+        regulator-name = "vdd_npu_s0";
+        regulator-min-microvolt = <550000>;
+        regulator-max-microvolt = <950000>;
+        regulator-ramp-delay = <12500>;
+        rockchip,suspend-voltage-selector = <1>;
+        regulator-boot-on;
+        regulator-always-on;
+        regulator-state-mem {
+            regulator-off-in-suspend;
+        };
+    };
+
+    usbc0: fusb302@22 {
+        compatible = "fcs,fusb302";
+        reg = <0x22>;
+        interrupt-parent = <&gpio1>;
+        interrupts = <RK_PB5 IRQ_TYPE_LEVEL_LOW>;
+        int-n-gpios = <&gpio1 RK_PB5 GPIO_ACTIVE_LOW>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&usbc0_int>;
+        vbus-supply = <&vbus5v0_typec>;
+        status = "okay";
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                reg = <0>;
+                usbc0_role_sw: endpoint@0 {
+                    remote-endpoint = <&dwc3_0_role_switch>;
+                };
+            };
+        };
+
+        usb_con: connector {
+            compatible = "usb-c-connector";
+            label = "USB-C";
+            data-role = "dual";
+            power-role = "dual";
+            try-power-role = "sink";
+            op-sink-microwatt = <1000000>;
+            sink-pdos =
+                <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
+                 PDO_FIXED(9000, 3000, PDO_FIXED_USB_COMM)
+                 PDO_FIXED(12000, 3000, PDO_FIXED_USB_COMM)>;
+            source-pdos =
+                <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+
+            altmodes {
+                #address-cells = <1>;
+                #size-cells = <0>;
+
+                altmode@0 {
+                    reg = <0>;
+                    svid = <0xff01>;
+                    vdo = <0xffffffff>;
+                };
+            };
+
+             ports {
+                #address-cells = <1>;
+                #size-cells = <0>;
+
+                port@0 {
+                    reg = <0>;
+                    usbc0_orien_sw: endpoint {
+                        remote-endpoint = <&usbdp_phy0_orientation_switch>;
+                    };
+                };
+
+                port@1 {
+                    reg = <1>;
+                    dp_altmode_mux: endpoint {
+                        remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+                    };
+                };
+            };
+        };
+    };
+
+    pt7c4363: pt7c4363@51 {
+        compatible = "haoyu,hym8563";
+        reg = <0x51>;
+        #clock-cells = <0>;
+        clock-frequency = <32768>;
+        clock-output-names = "pt7c4363";
+        wakeup-source;
+    };
+
+    mcu: khadas-mcu@18 {
+        compatible = "khadas-mcu";
+        status = "okay";
+        reg = <0x18>;
+        fan,trig_temp_level0 = <50>;
+        fan,trig_temp_level1 = <60>;
+        fan,trig_temp_level2 = <70>;
+        fan,trig_temp_level3 = <80>;
+        hwver = "EDGE2.V11";
+
+    };
+};
+
+&reboot_mode {
+	mode-reboot_test = <BOOT_REBOOT_TEST>;
+};
+
+&i2c3 {
+	status = "okay";
+
+	gs_kxtj3: gs_kxtj3@e {
+		compatible = "gs_kxtj3";
+		reg = <0x0e>;
+		irq-gpio = <&gpio1 RK_PB0 IRQ_TYPE_EDGE_RISING>;
+		irq_enable = <0>;
+		poll_delay_ms = <30>;
+		type = <SENSOR_TYPE_ACCEL>;
+		layout = <0>;
+		status = "okay";
+	};
+
+	es8316: es8316@10 {
+		status = "okay";
+		#sound-dai-cells = <0>;
+		compatible = "everest,es8316";
+		reg = <0x10>;
+		clocks = <&cru I2S0_8CH_MCLKOUT>;
+		clock-names = "mclk";
+		assigned-clocks = <&cru I2S0_8CH_MCLKOUT>;
+		assigned-clock-rates = <12288000>;
+		pinctrl-names = "default","hp_det","spk_con";
+		pinctrl-0 = <&i2s0_mclk>,<&hp_det>,<&spk_con>;
+		spk-con-gpio = <&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>;
+		hp-det-gpio = <&gpio1 RK_PD3 GPIO_ACTIVE_LOW>;
+	};
+
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4m3_xfer>;
+	status = "okay";
+};
+
+&i2c5 {
+	status = "disabled";
+
+	ls_stk3332: light@47 {
+		compatible = "ls_stk3332";
+		status = "disabled";
+		reg = <0x47>;
+		type = <SENSOR_TYPE_LIGHT>;
+		irq_enable = <0>;
+		als_threshold_high = <100>;
+		als_threshold_low = <10>;
+		als_ctrl_gain = <2>; /* 0:x1 1:x4 2:x16 3:x64 */
+		poll_delay_ms = <100>;
+	};
+
+	ps_stk3332: proximity@47 {
+		compatible = "ps_stk3332";
+		status = "disabled";
+		reg = <0x47>;
+		type = <SENSOR_TYPE_PROXIMITY>;
+		//pinctrl-names = "default";
+		//pinctrl-0 = <&gpio3_c6>;
+		//irq-gpio = <&gpio3 RK_PC6 IRQ_TYPE_LEVEL_LOW>;
+		//irq_enable = <1>;
+		ps_threshold_high = <0x200>;
+		ps_threshold_low = <0x100>;
+		ps_ctrl_gain = <3>; /* 0:x1 1:x2 2:x5 3:x8 */
+		ps_led_current = <4>; /* 0:3.125mA 1:6.25mA 2:12.5mA 3:25mA 4:50mA 5:100mA*/
+		poll_delay_ms = <100>;
+	};
+
+	mpu6500_acc: mpu_acc@68 {
+		compatible = "mpu6500_acc";
+		reg = <0x68>;
+		irq-gpio = <&gpio3 RK_PB4 IRQ_TYPE_EDGE_RISING>;
+		irq_enable = <0>;
+		poll_delay_ms = <30>;
+		type = <SENSOR_TYPE_ACCEL>;
+		layout = <5>;
+	};
+
+	mpu6500_gyro: mpu_gyro@68 {
+		compatible = "mpu6500_gyro";
+		reg = <0x68>;
+		poll_delay_ms = <30>;
+		type = <SENSOR_TYPE_GYROSCOPE>;
+		layout = <5>;
+	};
+};
+
+&i2c6 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c6m0_xfer>;
+
+	ft5336@38 {
+		compatible = "edt,edt-ft5336", "ft5x06";
+		reg = <0x38>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PC6 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpio = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&tp_rst_gpio>;
+		status = "okay";
+	};
+
+};
+
+&pcie2x1l1 {
+//	reset-gpios = <&gpio4 RK_PA2 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie20>;
+	status = "disabled";
+};
+
+&pcie2x1l2 {
+//	reset-gpios = <&gpio4 RK_PC1 GPIO_ACTIVE_HIGH>;
+	reset-gpios = <&gpio3 RK_PD1 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie20>;
+	rockchip,skip-scan-in-resume;
+	status = "okay";
+};
+
+&pdm0 {
+	pinctrl-names = "default";
+    pinctrl-0 = <&pdm0m0_clk
+    &pdm0m0_clk1
+    &pdm0m0_sdi0
+    &pdm0m0_sdi1
+    &pdm0m0_sdi2>;
+    rockchip,path-map = <0 1 2 3>;
+    status = "okay";
+};
+
+&pinctrl {
+	audio {
+		hp_det: hp-det {
+			rockchip,pins = <1 RK_PD3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		spk_con: spk-con {
+			rockchip,pins = <1 RK_PD0 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	lcd {
+		lcd1_rst_gpio: lcd1-rst-gpio {
+			rockchip,pins = <4 RK_PA3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		lcd2_rst_gpio1: lcd2-rst-gpio1 {
+			rockchip,pins = <4 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	leds {
+		red_led_gpio: red-led-gpio {
+			rockchip,pins = <4 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		green_led_gpio: green-led-gpio {
+			rockchip,pins = <4 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		blue_led_gpio: blue-led-gpio {
+			rockchip,pins = <4 RK_PB3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <1 RK_PB1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	vcc_sd {
+		vcc_sd_en: vcc-sd-en {
+			rockchip,pins = <1 RK_PB6 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <1 RK_PB5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		typec5v_pwren: typec5v-pwren {
+			rockchip,pins = <3 RK_PA4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	ft5336 {
+		tp_rst_gpio: tp-rst-gpio {
+			rockchip,pins = <0 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+       };
+   };
+
+	wireless-bluetooth {
+		uart9_gpios: uart9-gpios {
+			rockchip,pins = <3 RK_PD2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_gpio: bt-gpio {
+			rockchip,pins =
+				<0 RK_PD4 RK_FUNC_GPIO &pcfg_pull_none>,
+				<0 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>,
+				<0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	wireless-wlan {
+		wifi_host_wake_irq: wifi-host-wake-irq {
+			rockchip,pins = <0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+	//	wifi_poweren_gpio: wifi-poweren-gpio {
+	//		rockchip,pins = <0 RK_PC7 RK_FUNC_GPIO &pcfg_pull_up>;
+	//	};
+	};
+};
+
+&pwm3 {
+	compatible = "rockchip,remotectl-pwm";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm3m3_pins>;
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	remote_support_psci = <0>;
+	status = "okay";
+
+	ir_key1 {
+		rockchip,usercode = <0xff00>;
+		rockchip,key_table =
+			<0xeb 116>,		//KEY_POWER
+			<0xec 139>,		//KEY_MENU
+			<0xfc 103>,		//KEY_UP
+			<0xfd 108>,		//KEY_DOWN
+			<0xf1 105>,		//KEY_LEFT
+			<0xe5 106>,		//KEY_RIGHT
+			<0xf8 28>, 		//KEY_Enter
+			<0xa7 114>,		//KEY_VOLUMEDOWN
+			<0xa3 388>,
+			<0xa4 388>,		//KEY_CURSOR
+			<0xf4 115>,		//KEY_VOLUMEUP
+			<0xfe 158>,		//KEY_BACK
+			<0xb7 172>;		//KEY_HOMEPAGE
+	};
+};
+
+&pwm7 {
+	pinctrl-0 = <&pwm7m0_pins>;
+	status = "disabled";
+};
+
+&pwm12 {
+	pinctrl-0 = <&pwm12m1_pins>;
+	status = "okay";
+};
+
+&pwm13 {
+	pinctrl-0 = <&pwm13m1_pins>;
+	status = "okay";
+};
+
+
+&rockchip_suspend {
+
+    rockchip,sleep-mode-config = <
+        (0
+        | RKPM_SLP_ARMOFF_DDRPD
+        | RKPM_SLP_PMU_PMUALIVE_32K
+        | RKPM_SLP_PMU_DIS_OSC
+        | RKPM_SLP_32K_EXT
+        | RKPM_SLP_PMU_DBG
+        )
+    >;
+};
+
+&route_hdmi0 {
+    status = "okay";
+    connect = <&vp0_out_hdmi0>;
+    /delete-property/ force-output;
+    /delete-node/ force_timing;
+};
+
+&sdmmc {
+	status = "okay";
+	card-detect-delay = <1200>;
+};
+
+&sfc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&fspim2_pins>;
+	status = "okay";
+};
+
+&spdif_tx1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spdif1m1_tx>;
+};
+
+&spdif_tx1_dc {
+	status = "disabled";
+};
+
+&spdif_tx1_sound {
+	status = "disabled";
+};
+
+&spdif_tx2 {
+	status = "okay";
+};
+
+&spi1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi1m1_cs0 &spi1m1_pins>;
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	rockchip,typec-vbus-det;
+};
+
+&u2phy2_host {
+	phy-supply = <&vcc5v0_host>;
+};
+
+&u2phy3_host {
+	phy-supply = <&vcc5v0_host>;
+};
+
+&uart9 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart9m2_xfer &uart9m2_ctsn>;
+};
+
+&usbdp_phy0 {
+	orientation-switch;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio4 RK_PA0 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio4 RK_PA1 GPIO_ACTIVE_HIGH>;
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&usbdrd_dwc3_0 {
+	usb-role-switch;
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&vdd_log_s0 {
+    regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <750000>;
+    };
+};
+
+&vcc_1v8_s0 {
+    /delete-property/ regulator-state-mem;
+    regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <1800000>;
+    };
+};
+
+&vcc_3v3_s0 {
+    /delete-property/ regulator-state-mem;
+    regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <3300000>;
+    };
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2.dtsi b/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2.dtsi
new file mode 100644
index 000000000000..c06bc4fda155
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2.dtsi
@@ -0,0 +1,1705 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Wesion Technology Co., Ltd.
+ *
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+
+/ {
+	adc_keys: adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 1>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1800000>;
+		poll-interval = <100>;
+
+		home-key {
+			label = "home";
+			linux,code = <KEY_HOMEPAGE>;
+			press-threshold-microvolt = <17000>;
+		};
+	};
+
+	backlight_mipi0: backlight-mipi0 {
+		compatible = "pwm-backlight";
+		brightness-levels = <
+			  0  20  20  21  21  22  22  23
+			 23  24  24  25  25  26  26  27
+			 27  28  28  29  29  30  30  31
+			 31  32  32  33  33  34  34  35
+			 35  36  36  37  37  38  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255
+		>;
+		default-brightness-level = <200>;
+	};
+
+	dp0_sound: dp0-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,card-name= "rockchip,dp0";
+		rockchip,mclk-fs = <512>;
+		rockchip,cpu = <&spdif_tx2>;
+		rockchip,codec = <&dp0 1>;
+		rockchip,jack-det;
+	};
+
+	backlight_mipi1: backlight-mipi1 {
+        compatible = "pwm-backlight";
+        brightness-levels = <
+              0  20  20  21  21  22  22  23
+             23  24  24  25  25  26  26  27
+             27  28  28  29  29  30  30  31
+             31  32  32  33  33  34  34  35
+             35  36  36  37  37  38  38  39
+             40  41  42  43  44  45  46  47
+             48  49  50  51  52  53  54  55
+             56  57  58  59  60  61  62  63
+             64  65  66  67  68  69  70  71
+             72  73  74  75  76  77  78  79
+             80  81  82  83  84  85  86  87
+             88  89  90  91  92  93  94  95
+             96  97  98  99 100 101 102 103
+            104 105 106 107 108 109 110 111
+            112 113 114 115 116 117 118 119
+            120 121 122 123 124 125 126 127
+            128 129 130 131 132 133 134 135
+            136 137 138 139 140 141 142 143
+            144 145 146 147 148 149 150 151
+            152 153 154 155 156 157 158 159
+            160 161 162 163 164 165 166 167
+            168 169 170 171 172 173 174 175
+            176 177 178 179 180 181 182 183
+            184 185 186 187 188 189 190 191
+            192 193 194 195 196 197 198 199
+            200 201 202 203 204 205 206 207
+            208 209 210 211 212 213 214 215
+            216 217 218 219 220 221 222 223
+            224 225 226 227 228 229 230 231
+            232 233 234 235 236 237 238 239
+            240 241 242 243 244 245 246 247
+            248 249 250 251 252 253 254 255
+        >;
+        default-brightness-level = <200>;
+    };
+
+
+
+	hdmi0_sound: hdmi0-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <128>;
+		simple-audio-card,name = "rockchip,hdmi0";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s5_8ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&hdmi0>;
+		};
+	};
+
+	spdif_tx1_dc: spdif-tx1-dc {
+		status = "disabled";
+		compatible = "linux,spdif-dit";
+		#sound-dai-cells = <0>;
+	};
+
+	spdif_tx1_sound: spdif-tx1-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "rockchip,spdif-tx1";
+		simple-audio-card,cpu {
+			sound-dai = <&spdif_tx1>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&spdif_tx1_dc>;
+		};
+	};
+
+	test-power {
+		status = "okay";
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+        compatible = "regulator-fixed";
+        regulator-name = "vcc_1v1_nldo_s3";
+        regulator-always-on;
+        regulator-boot-on;
+        regulator-min-microvolt = <1100000>;
+        regulator-max-microvolt = <1100000>;
+        vin-supply = <&vcc5v0_sys>;
+    };
+
+	vcc5v0_usbdcin: vcc5v0-usbdcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usbdcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_usb: vcc5v0-usb {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usb";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc5v0_usbdcin>;
+	};
+};
+
+&av1d_mmu {
+	status = "okay";
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_lit_s0>;
+	mem-supply = <&vdd_cpu_lit_mem_s0>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_big0_s0>;
+	mem-supply = <&vdd_cpu_big0_mem_s0>;
+};
+
+&cpu_b2 {
+	cpu-supply = <&vdd_cpu_big1_s0>;
+	mem-supply = <&vdd_cpu_big1_mem_s0>;
+};
+
+&dsi0 {
+	status = "disabled";
+	//rockchip,lane-rate = <1000>;
+	dsi0_panel: panel@0 {
+		status = "okay";
+		compatible = "simple-panel-dsi";
+		reg = <0>;
+		backlight = <&backlight_mipi0>;
+	//	reset-delay-ms = <60>;
+		enable-delay-ms = <60>;
+		prepare-delay-ms = <60>;
+		unprepare-delay-ms = <60>;
+		disable-delay-ms = <60>;
+		dsi,flags = <(MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_EOT_PACKET)>;
+		dsi,format = <MIPI_DSI_FMT_RGB888>;
+		dsi,lanes  = <4>;
+		panel-init-sequence = [
+			15 00 02 FF 05
+			15 00 02 FB 01
+			15 64 02 C5 01
+			15 00 02 FF EE
+			15 00 02 FB 01
+			15 00 02 1F 45
+			15 00 02 24 4F
+			15 00 02 38 C8
+			15 00 02 39 27
+			15 00 02 1E 77
+			15 00 02 1D 0F
+			15 00 02 7E 71
+			15 00 02 7C 03
+			15 00 02 FF 00
+			15 00 02 FB 01
+			15 00 02 35 01
+			15 00 02 FF 01
+			15 00 02 FB 01
+			15 00 02 00 01
+			15 00 02 01 55
+			15 00 02 02 40
+			15 00 02 05 40
+			15 00 02 06 4A
+			15 00 02 07 24
+			15 00 02 08 0C
+			15 00 02 0B 7D
+			15 00 02 0C 7D
+			15 00 02 0E B0
+			15 00 02 0F AE
+			15 00 02 11 10
+			15 00 02 12 10
+			15 00 02 13 03
+			15 00 02 14 4A
+			15 00 02 15 12
+			15 00 02 16 12
+			15 00 02 18 00
+			15 00 02 19 77
+			15 00 02 1A 55
+			15 00 02 1B 13
+			15 00 02 1C 00
+			15 00 02 1D 00
+			15 00 02 1E 13
+			15 00 02 1F 00
+			15 00 02 23 00
+			15 00 02 24 00
+			15 00 02 25 00
+			15 00 02 26 00
+			15 00 02 27 00
+			15 00 02 28 00
+			15 00 02 35 00
+			15 00 02 66 00
+			15 00 02 58 82
+			15 00 02 59 02
+			15 00 02 5A 02
+			15 00 02 5B 02
+			15 00 02 5C 82
+			15 00 02 5D 82
+			15 00 02 5E 02
+			15 00 02 5F 02
+			15 00 02 72 31
+			15 00 02 FF 05
+			15 00 02 FB 01
+			15 00 02 00 01
+			15 00 02 01 0B
+			15 00 02 02 0C
+			15 00 02 03 09
+			15 00 02 04 0A
+			15 00 02 05 00
+			15 00 02 06 0F
+			15 00 02 07 10
+			15 00 02 08 00
+			15 00 02 09 00
+			15 00 02 0A 00
+			15 00 02 0B 00
+			15 00 02 0C 00
+			15 00 02 0D 13
+			15 00 02 0E 15
+			15 00 02 0F 17
+			15 00 02 10 01
+			15 00 02 11 0B
+			15 00 02 12 0C
+			15 00 02 13 09
+			15 00 02 14 0A
+			15 00 02 15 00
+			15 00 02 16 0F
+			15 00 02 17 10
+			15 00 02 18 00
+			15 00 02 19 00
+			15 00 02 1A 00
+			15 00 02 1B 00
+			15 00 02 1C 00
+			15 00 02 1D 13
+			15 00 02 1E 15
+			15 00 02 1F 17
+			15 00 02 20 00
+			15 00 02 21 03
+			15 00 02 22 01
+			15 00 02 23 40
+			15 00 02 24 40
+			15 00 02 25 ED
+			15 00 02 29 58
+			15 00 02 2A 12
+			15 00 02 2B 01
+			15 00 02 4B 06
+			15 00 02 4C 11
+			15 00 02 4D 20
+			15 00 02 4E 02
+			15 00 02 4F 02
+			15 00 02 50 20
+			15 00 02 51 61
+			15 00 02 52 01
+			15 00 02 53 63
+			15 00 02 54 77
+			15 00 02 55 ED
+			15 00 02 5B 00
+			15 00 02 5C 00
+			15 00 02 5D 00
+			15 00 02 5E 00
+			15 00 02 5F 15
+			15 00 02 60 75
+			15 00 02 61 00
+			15 00 02 62 00
+			15 00 02 63 00
+			15 00 02 64 00
+			15 00 02 65 00
+			15 00 02 66 00
+			15 00 02 67 00
+			15 00 02 68 04
+			15 00 02 69 00
+			15 00 02 6A 00
+			15 00 02 6C 40
+			15 00 02 75 01
+			15 00 02 76 01
+			15 00 02 7A 80
+			15 00 02 7B A3
+			15 00 02 7C D8
+			15 00 02 7D 60
+			15 00 02 7F 15
+			15 00 02 80 81
+			15 00 02 83 05
+			15 00 02 93 08
+			15 00 02 94 10
+			15 00 02 8A 00
+			15 00 02 9B 0F
+			15 00 02 EA FF
+			15 00 02 EC 00
+			15 00 02 FF 01
+			15 00 02 FB 01
+			15 00 02 75 00
+			15 00 02 76 DF
+			15 00 02 77 00
+			15 00 02 78 E4
+			15 00 02 79 00
+			15 00 02 7A ED
+			15 00 02 7B 00
+			15 00 02 7C F6
+			15 00 02 7D 00
+			15 00 02 7E FF
+			15 00 02 7F 01
+			15 00 02 80 07
+			15 00 02 81 01
+			15 00 02 82 10
+			15 00 02 83 01
+			15 00 02 84 18
+			15 00 02 85 01
+			15 00 02 86 20
+			15 00 02 87 01
+			15 00 02 88 3D
+			15 00 02 89 01
+			15 00 02 8A 56
+			15 00 02 8B 01
+			15 00 02 8C 84
+			15 00 02 8D 01
+			15 00 02 8E AB
+			15 00 02 8F 01
+			15 00 02 90 EC
+			15 00 02 91 02
+			15 00 02 92 22
+			15 00 02 93 02
+			15 00 02 94 23
+			15 00 02 95 02
+			15 00 02 96 55
+			15 00 02 97 02
+			15 00 02 98 8B
+			15 00 02 99 02
+			15 00 02 9A AF
+			15 00 02 9B 02
+			15 00 02 9C DF
+			15 00 02 9D 03
+			15 00 02 9E 01
+			15 00 02 9F 03
+			15 00 02 A0 2C
+			15 00 02 A2 03
+			15 00 02 A3 39
+			15 00 02 A4 03
+			15 00 02 A5 47
+			15 00 02 A6 03
+			15 00 02 A7 56
+			15 00 02 A9 03
+			15 00 02 AA 66
+			15 00 02 AB 03
+			15 00 02 AC 76
+			15 00 02 AD 03
+			15 00 02 AE 85
+			15 00 02 AF 03
+			15 00 02 B0 90
+			15 00 02 B1 03
+			15 00 02 B2 CB
+			15 00 02 B3 00
+			15 00 02 B4 DF
+			15 00 02 B5 00
+			15 00 02 B6 E4
+			15 00 02 B7 00
+			15 00 02 B8 ED
+			15 00 02 B9 00
+			15 00 02 BA F6
+			15 00 02 BB 00
+			15 00 02 BC FF
+			15 00 02 BD 01
+			15 00 02 BE 07
+			15 00 02 BF 01
+			15 00 02 C0 10
+			15 00 02 C1 01
+			15 00 02 C2 18
+			15 00 02 C3 01
+			15 00 02 C4 20
+			15 00 02 C5 01
+			15 00 02 C6 3D
+			15 00 02 C7 01
+			15 00 02 C8 56
+			15 00 02 C9 01
+			15 00 02 CA 84
+			15 00 02 CB 01
+			15 00 02 CC AB
+			15 00 02 CD 01
+			15 00 02 CE EC
+			15 00 02 CF 02
+			15 00 02 D0 22
+			15 00 02 D1 02
+			15 00 02 D2 23
+			15 00 02 D3 02
+			15 00 02 D4 55
+			15 00 02 D5 02
+			15 00 02 D6 8B
+			15 00 02 D7 02
+			15 00 02 D8 AF
+			15 00 02 D9 02
+			15 00 02 DA DF
+			15 00 02 DB 03
+			15 00 02 DC 01
+			15 00 02 DD 03
+			15 00 02 DE 2C
+			15 00 02 DF 03
+			15 00 02 E0 39
+			15 00 02 E1 03
+			15 00 02 E2 47
+			15 00 02 E3 03
+			15 00 02 E4 56
+			15 00 02 E5 03
+			15 00 02 E6 66
+			15 00 02 E7 03
+			15 00 02 E8 76
+			15 00 02 E9 03
+			15 00 02 EA 85
+			15 00 02 EB 03
+			15 00 02 EC 90
+			15 00 02 ED 03
+			15 00 02 EE CB
+			15 00 02 EF 00
+			15 00 02 F0 BB
+			15 00 02 F1 00
+			15 00 02 F2 C0
+			15 00 02 F3 00
+			15 00 02 F4 CC
+			15 00 02 F5 00
+			15 00 02 F6 D6
+			15 00 02 F7 00
+			15 00 02 F8 E1
+			15 00 02 F9 00
+			15 00 02 FA EA
+			15 00 02 FF 02
+			15 00 02 FB 01
+			15 00 02 00 00
+			15 00 02 01 F4
+			15 00 02 02 00
+			15 00 02 03 EF
+			15 00 02 04 01
+			15 00 02 05 07
+			15 00 02 06 01
+			15 00 02 07 28
+			15 00 02 08 01
+			15 00 02 09 44
+			15 00 02 0A 01
+			15 00 02 0B 76
+			15 00 02 0C 01
+			15 00 02 0D A0
+			15 00 02 0E 01
+			15 00 02 0F E7
+			15 00 02 10 02
+			15 00 02 11 1F
+			15 00 02 12 02
+			15 00 02 13 22
+			15 00 02 14 02
+			15 00 02 15 54
+			15 00 02 16 02
+			15 00 02 17 8B
+			15 00 02 18 02
+			15 00 02 19 AF
+			15 00 02 1A 02
+			15 00 02 1B E0
+			15 00 02 1C 03
+			15 00 02 1D 01
+			15 00 02 1E 03
+			15 00 02 1F 2D
+			15 00 02 20 03
+			15 00 02 21 39
+			15 00 02 22 03
+			15 00 02 23 47
+			15 00 02 24 03
+			15 00 02 25 57
+			15 00 02 26 03
+			15 00 02 27 65
+			15 00 02 28 03
+			15 00 02 29 77
+			15 00 02 2A 03
+			15 00 02 2B 85
+			15 00 02 2D 03
+			15 00 02 2F 8F
+			15 00 02 30 03
+			15 00 02 31 CB
+			15 00 02 32 00
+			15 00 02 33 BB
+			15 00 02 34 00
+			15 00 02 35 C0
+			15 00 02 36 00
+			15 00 02 37 CC
+			15 00 02 38 00
+			15 00 02 39 D6
+			15 00 02 3A 00
+			15 00 02 3B E1
+			15 00 02 3D 00
+			15 00 02 3F EA
+			15 00 02 40 00
+			15 00 02 41 F4
+			15 00 02 42 00
+			15 00 02 43 FE
+			15 00 02 44 01
+			15 00 02 45 07
+			15 00 02 46 01
+			15 00 02 47 28
+			15 00 02 48 01
+			15 00 02 49 44
+			15 00 02 4A 01
+			15 00 02 4B 76
+			15 00 02 4C 01
+			15 00 02 4D A0
+			15 00 02 4E 01
+			15 00 02 4F E7
+			15 00 02 50 02
+			15 00 02 51 1F
+			15 00 02 52 02
+			15 00 02 53 22
+			15 00 02 54 02
+			15 00 02 55 54
+			15 00 02 56 02
+			15 00 02 58 8B
+			15 00 02 59 02
+			15 00 02 5A AF
+			15 00 02 5B 02
+			15 00 02 5C E0
+			15 00 02 5D 03
+			15 00 02 5E 01
+			15 00 02 5F 03
+			15 00 02 60 2D
+			15 00 02 61 03
+			15 00 02 62 39
+			15 00 02 63 03
+			15 00 02 64 47
+			15 00 02 65 03
+			15 00 02 66 57
+			15 00 02 67 03
+			15 00 02 68 65
+			15 00 02 69 03
+			15 00 02 6A 77
+			15 00 02 6B 03
+			15 00 02 6C 85
+			15 00 02 6D 03
+			15 00 02 6E 8F
+			15 00 02 6F 03
+			15 00 02 70 CB
+			15 00 02 71 00
+			15 00 02 72 00
+			15 00 02 73 00
+			15 00 02 74 21
+			15 00 02 75 00
+			15 00 02 76 4C
+			15 00 02 77 00
+			15 00 02 78 6B
+			15 00 02 79 00
+			15 00 02 7A 85
+			15 00 02 7B 00
+			15 00 02 7C 9A
+			15 00 02 7D 00
+			15 00 02 7E AD
+			15 00 02 7F 00
+			15 00 02 80 BE
+			15 00 02 81 00
+			15 00 02 82 CD
+			15 00 02 83 01
+			15 00 02 84 01
+			15 00 02 85 01
+			15 00 02 86 29
+			15 00 02 87 01
+			15 00 02 88 68
+			15 00 02 89 01
+			15 00 02 8A 98
+			15 00 02 8B 01
+			15 00 02 8C E5
+			15 00 02 8D 02
+			15 00 02 8E 1E
+			15 00 02 8F 02
+			15 00 02 90 30
+			15 00 02 91 02
+			15 00 02 92 52
+			15 00 02 93 02
+			15 00 02 94 88
+			15 00 02 95 02
+			15 00 02 96 AA
+			15 00 02 97 02
+			15 00 02 98 D7
+			15 00 02 99 02
+			15 00 02 9A F7
+			15 00 02 9B 03
+			15 00 02 9C 21
+			15 00 02 9D 03
+			15 00 02 9E 2E
+			15 00 02 9F 03
+			15 00 02 A0 3D
+			15 00 02 A2 03
+			15 00 02 A3 4C
+			15 00 02 A4 03
+			15 00 02 A5 5E
+			15 00 02 A6 03
+			15 00 02 A7 71
+			15 00 02 A9 03
+			15 00 02 AA 86
+			15 00 02 AB 03
+			15 00 02 AC 94
+			15 00 02 AD 03
+			15 00 02 AE FA
+			15 00 02 AF 00
+			15 00 02 B0 00
+			15 00 02 B1 00
+			15 00 02 B2 21
+			15 00 02 B3 00
+			15 00 02 B4 4C
+			15 00 02 B5 00
+			15 00 02 B6 6B
+			15 00 02 B7 00
+			15 00 02 B8 85
+			15 00 02 B9 00
+			15 00 02 BA 9A
+			15 00 02 BB 00
+			15 00 02 BC AD
+			15 00 02 BD 00
+			15 00 02 BE BE
+			15 00 02 BF 00
+			15 00 02 C0 CD
+			15 00 02 C1 01
+			15 00 02 C2 01
+			15 00 02 C3 01
+			15 00 02 C4 29
+			15 00 02 C5 01
+			15 00 02 C6 68
+			15 00 02 C7 01
+			15 00 02 C8 98
+			15 00 02 C9 01
+			15 00 02 CA E5
+			15 00 02 CB 02
+			15 00 02 CC 1E
+			15 00 02 CD 02
+			15 00 02 CE 20
+			15 00 02 CF 02
+			15 00 02 D0 52
+			15 00 02 D1 02
+			15 00 02 D2 88
+			15 00 02 D3 02
+			15 00 02 D4 AA
+			15 00 02 D5 02
+			15 00 02 D6 D7
+			15 00 02 D7 02
+			15 00 02 D8 F7
+			15 00 02 D9 03
+			15 00 02 DA 21
+			15 00 02 DB 03
+			15 00 02 DC 2E
+			15 00 02 DD 03
+			15 00 02 DE 3D
+			15 00 02 DF 03
+			15 00 02 E0 4C
+			15 00 02 E1 03
+			15 00 02 E2 5E
+			15 00 02 E3 03
+			15 00 02 E4 71
+			15 00 02 E5 03
+			15 00 02 E6 86
+			15 00 02 E7 03
+			15 00 02 E8 94
+			15 00 02 E9 03
+			15 00 02 EA FA
+			15 00 02 FF 01
+			15 00 02 FB 01
+			15 00 02 FF 02
+			15 00 02 FB 01
+			15 00 02 FF 04
+			15 00 02 FB 01
+			15 00 02 FF 00
+			15 00 02 D3 05
+			15 00 02 D4 04
+			05 78 01 11
+			15 00 02 FF 00
+			15 00 02 35 00
+			05 0A 01 29
+		];
+
+		panel-exit-sequence = [
+			05 05 01 28
+			05 78 01 10
+		];
+
+		disp_timings0: display-timings {
+			native-mode = <&dsi0_timing0>;
+			dsi0_timing0: timing0 {
+				clock-frequency = <152198100>;
+				hactive = <1080>;
+				vactive = <1920>;
+				hfront-porch = <104>;
+				hsync-len = <4>;
+				hback-porch = <127>;
+				vfront-porch = <4>;
+				vsync-len = <2>;
+				vback-porch = <3>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <0>;
+				pixelclk-active = <0>;
+			};
+		};
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				panel_in_dsi: endpoint {
+					remote-endpoint = <&dsi_out_panel>;
+				};
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			dsi_out_panel: endpoint {
+				remote-endpoint = <&panel_in_dsi>;
+			};
+		};
+	};
+
+};
+
+&dsi1 {
+	status = "disabled";
+	//rockchip,lane-rate = <1000>;
+	dsi1_panel: panel@0 {
+		status = "disabled";
+		compatible = "simple-panel-dsi";
+		reg = <0>;
+		backlight = <&backlight_mipi1>;
+//		reset-delay-ms = <60>;
+		enable-delay-ms = <60>;
+		prepare-delay-ms = <60>;
+		unprepare-delay-ms = <60>;
+		disable-delay-ms = <60>;
+		dsi,flags = <(MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_EOT_PACKET)>;
+		dsi,format = <MIPI_DSI_FMT_RGB888>;
+		dsi,lanes  = <4>;
+		panel-init-sequence = [
+			15 00 02 FF 05
+			15 00 02 FB 01
+			15 64 02 C5 01
+			15 00 02 FF EE
+			15 00 02 FB 01
+			15 00 02 1F 45
+			15 00 02 24 4F
+			15 00 02 38 C8
+			15 00 02 39 27
+			15 00 02 1E 77
+			15 00 02 1D 0F
+			15 00 02 7E 71
+			15 00 02 7C 03
+			15 00 02 FF 00
+			15 00 02 FB 01
+			15 00 02 35 01
+			15 00 02 FF 01
+			15 00 02 FB 01
+			15 00 02 00 01
+			15 00 02 01 55
+			15 00 02 02 40
+			15 00 02 05 40
+			15 00 02 06 4A
+			15 00 02 07 24
+			15 00 02 08 0C
+			15 00 02 0B 7D
+			15 00 02 0C 7D
+			15 00 02 0E B0
+			15 00 02 0F AE
+			15 00 02 11 10
+			15 00 02 12 10
+			15 00 02 13 03
+			15 00 02 14 4A
+			15 00 02 15 12
+			15 00 02 16 12
+			15 00 02 18 00
+			15 00 02 19 77
+			15 00 02 1A 55
+			15 00 02 1B 13
+			15 00 02 1C 00
+			15 00 02 1D 00
+			15 00 02 1E 13
+			15 00 02 1F 00
+			15 00 02 23 00
+			15 00 02 24 00
+			15 00 02 25 00
+			15 00 02 26 00
+			15 00 02 27 00
+			15 00 02 28 00
+			15 00 02 35 00
+			15 00 02 66 00
+			15 00 02 58 82
+			15 00 02 59 02
+			15 00 02 5A 02
+			15 00 02 5B 02
+			15 00 02 5C 82
+			15 00 02 5D 82
+			15 00 02 5E 02
+			15 00 02 5F 02
+			15 00 02 72 31
+			15 00 02 FF 05
+			15 00 02 FB 01
+			15 00 02 00 01
+			15 00 02 01 0B
+			15 00 02 02 0C
+			15 00 02 03 09
+			15 00 02 04 0A
+			15 00 02 05 00
+			15 00 02 06 0F
+			15 00 02 07 10
+			15 00 02 08 00
+			15 00 02 09 00
+			15 00 02 0A 00
+			15 00 02 0B 00
+			15 00 02 0C 00
+			15 00 02 0D 13
+			15 00 02 0E 15
+			15 00 02 0F 17
+			15 00 02 10 01
+			15 00 02 11 0B
+			15 00 02 12 0C
+			15 00 02 13 09
+			15 00 02 14 0A
+			15 00 02 15 00
+			15 00 02 16 0F
+			15 00 02 17 10
+			15 00 02 18 00
+			15 00 02 19 00
+			15 00 02 1A 00
+			15 00 02 1B 00
+			15 00 02 1C 00
+			15 00 02 1D 13
+			15 00 02 1E 15
+			15 00 02 1F 17
+			15 00 02 20 00
+			15 00 02 21 03
+			15 00 02 22 01
+			15 00 02 23 40
+			15 00 02 24 40
+			15 00 02 25 ED
+			15 00 02 29 58
+			15 00 02 2A 12
+			15 00 02 2B 01
+			15 00 02 4B 06
+			15 00 02 4C 11
+			15 00 02 4D 20
+			15 00 02 4E 02
+			15 00 02 4F 02
+			15 00 02 50 20
+			15 00 02 51 61
+			15 00 02 52 01
+			15 00 02 53 63
+			15 00 02 54 77
+			15 00 02 55 ED
+			15 00 02 5B 00
+			15 00 02 5C 00
+			15 00 02 5D 00
+			15 00 02 5E 00
+			15 00 02 5F 15
+			15 00 02 60 75
+			15 00 02 61 00
+			15 00 02 62 00
+			15 00 02 63 00
+			15 00 02 64 00
+			15 00 02 65 00
+			15 00 02 66 00
+			15 00 02 67 00
+			15 00 02 68 04
+			15 00 02 69 00
+			15 00 02 6A 00
+			15 00 02 6C 40
+			15 00 02 75 01
+			15 00 02 76 01
+			15 00 02 7A 80
+			15 00 02 7B A3
+			15 00 02 7C D8
+			15 00 02 7D 60
+			15 00 02 7F 15
+			15 00 02 80 81
+			15 00 02 83 05
+			15 00 02 93 08
+			15 00 02 94 10
+			15 00 02 8A 00
+			15 00 02 9B 0F
+			15 00 02 EA FF
+			15 00 02 EC 00
+			15 00 02 FF 01
+			15 00 02 FB 01
+			15 00 02 75 00
+			15 00 02 76 DF
+			15 00 02 77 00
+			15 00 02 78 E4
+			15 00 02 79 00
+			15 00 02 7A ED
+			15 00 02 7B 00
+			15 00 02 7C F6
+			15 00 02 7D 00
+			15 00 02 7E FF
+			15 00 02 7F 01
+			15 00 02 80 07
+			15 00 02 81 01
+			15 00 02 82 10
+			15 00 02 83 01
+			15 00 02 84 18
+			15 00 02 85 01
+			15 00 02 86 20
+			15 00 02 87 01
+			15 00 02 88 3D
+			15 00 02 89 01
+			15 00 02 8A 56
+			15 00 02 8B 01
+			15 00 02 8C 84
+			15 00 02 8D 01
+			15 00 02 8E AB
+			15 00 02 8F 01
+			15 00 02 90 EC
+			15 00 02 91 02
+			15 00 02 92 22
+			15 00 02 93 02
+			15 00 02 94 23
+			15 00 02 95 02
+			15 00 02 96 55
+			15 00 02 97 02
+			15 00 02 98 8B
+			15 00 02 99 02
+			15 00 02 9A AF
+			15 00 02 9B 02
+			15 00 02 9C DF
+			15 00 02 9D 03
+			15 00 02 9E 01
+			15 00 02 9F 03
+			15 00 02 A0 2C
+			15 00 02 A2 03
+			15 00 02 A3 39
+			15 00 02 A4 03
+			15 00 02 A5 47
+			15 00 02 A6 03
+			15 00 02 A7 56
+			15 00 02 A9 03
+			15 00 02 AA 66
+			15 00 02 AB 03
+			15 00 02 AC 76
+			15 00 02 AD 03
+			15 00 02 AE 85
+			15 00 02 AF 03
+			15 00 02 B0 90
+			15 00 02 B1 03
+			15 00 02 B2 CB
+			15 00 02 B3 00
+			15 00 02 B4 DF
+			15 00 02 B5 00
+			15 00 02 B6 E4
+			15 00 02 B7 00
+			15 00 02 B8 ED
+			15 00 02 B9 00
+			15 00 02 BA F6
+			15 00 02 BB 00
+			15 00 02 BC FF
+			15 00 02 BD 01
+			15 00 02 BE 07
+			15 00 02 BF 01
+			15 00 02 C0 10
+			15 00 02 C1 01
+			15 00 02 C2 18
+			15 00 02 C3 01
+			15 00 02 C4 20
+			15 00 02 C5 01
+			15 00 02 C6 3D
+			15 00 02 C7 01
+			15 00 02 C8 56
+			15 00 02 C9 01
+			15 00 02 CA 84
+			15 00 02 CB 01
+			15 00 02 CC AB
+			15 00 02 CD 01
+			15 00 02 CE EC
+			15 00 02 CF 02
+			15 00 02 D0 22
+			15 00 02 D1 02
+			15 00 02 D2 23
+			15 00 02 D3 02
+			15 00 02 D4 55
+			15 00 02 D5 02
+			15 00 02 D6 8B
+			15 00 02 D7 02
+			15 00 02 D8 AF
+			15 00 02 D9 02
+			15 00 02 DA DF
+			15 00 02 DB 03
+			15 00 02 DC 01
+			15 00 02 DD 03
+			15 00 02 DE 2C
+			15 00 02 DF 03
+			15 00 02 E0 39
+			15 00 02 E1 03
+			15 00 02 E2 47
+			15 00 02 E3 03
+			15 00 02 E4 56
+			15 00 02 E5 03
+			15 00 02 E6 66
+			15 00 02 E7 03
+			15 00 02 E8 76
+			15 00 02 E9 03
+			15 00 02 EA 85
+			15 00 02 EB 03
+			15 00 02 EC 90
+			15 00 02 ED 03
+			15 00 02 EE CB
+			15 00 02 EF 00
+			15 00 02 F0 BB
+			15 00 02 F1 00
+			15 00 02 F2 C0
+			15 00 02 F3 00
+			15 00 02 F4 CC
+			15 00 02 F5 00
+			15 00 02 F6 D6
+			15 00 02 F7 00
+			15 00 02 F8 E1
+			15 00 02 F9 00
+			15 00 02 FA EA
+			15 00 02 FF 02
+			15 00 02 FB 01
+			15 00 02 00 00
+			15 00 02 01 F4
+			15 00 02 02 00
+			15 00 02 03 EF
+			15 00 02 04 01
+			15 00 02 05 07
+			15 00 02 06 01
+			15 00 02 07 28
+			15 00 02 08 01
+			15 00 02 09 44
+			15 00 02 0A 01
+			15 00 02 0B 76
+			15 00 02 0C 01
+			15 00 02 0D A0
+			15 00 02 0E 01
+			15 00 02 0F E7
+			15 00 02 10 02
+			15 00 02 11 1F
+			15 00 02 12 02
+			15 00 02 13 22
+			15 00 02 14 02
+			15 00 02 15 54
+			15 00 02 16 02
+			15 00 02 17 8B
+			15 00 02 18 02
+			15 00 02 19 AF
+			15 00 02 1A 02
+			15 00 02 1B E0
+			15 00 02 1C 03
+			15 00 02 1D 01
+			15 00 02 1E 03
+			15 00 02 1F 2D
+			15 00 02 20 03
+			15 00 02 21 39
+			15 00 02 22 03
+			15 00 02 23 47
+			15 00 02 24 03
+			15 00 02 25 57
+			15 00 02 26 03
+			15 00 02 27 65
+			15 00 02 28 03
+			15 00 02 29 77
+			15 00 02 2A 03
+			15 00 02 2B 85
+			15 00 02 2D 03
+			15 00 02 2F 8F
+			15 00 02 30 03
+			15 00 02 31 CB
+			15 00 02 32 00
+			15 00 02 33 BB
+			15 00 02 34 00
+			15 00 02 35 C0
+			15 00 02 36 00
+			15 00 02 37 CC
+			15 00 02 38 00
+			15 00 02 39 D6
+			15 00 02 3A 00
+			15 00 02 3B E1
+			15 00 02 3D 00
+			15 00 02 3F EA
+			15 00 02 40 00
+			15 00 02 41 F4
+			15 00 02 42 00
+			15 00 02 43 FE
+			15 00 02 44 01
+			15 00 02 45 07
+			15 00 02 46 01
+			15 00 02 47 28
+			15 00 02 48 01
+			15 00 02 49 44
+			15 00 02 4A 01
+			15 00 02 4B 76
+			15 00 02 4C 01
+			15 00 02 4D A0
+			15 00 02 4E 01
+			15 00 02 4F E7
+			15 00 02 50 02
+			15 00 02 51 1F
+			15 00 02 52 02
+			15 00 02 53 22
+			15 00 02 54 02
+			15 00 02 55 54
+			15 00 02 56 02
+			15 00 02 58 8B
+			15 00 02 59 02
+			15 00 02 5A AF
+			15 00 02 5B 02
+			15 00 02 5C E0
+			15 00 02 5D 03
+			15 00 02 5E 01
+			15 00 02 5F 03
+			15 00 02 60 2D
+			15 00 02 61 03
+			15 00 02 62 39
+			15 00 02 63 03
+			15 00 02 64 47
+			15 00 02 65 03
+			15 00 02 66 57
+			15 00 02 67 03
+			15 00 02 68 65
+			15 00 02 69 03
+			15 00 02 6A 77
+			15 00 02 6B 03
+			15 00 02 6C 85
+			15 00 02 6D 03
+			15 00 02 6E 8F
+			15 00 02 6F 03
+			15 00 02 70 CB
+			15 00 02 71 00
+			15 00 02 72 00
+			15 00 02 73 00
+			15 00 02 74 21
+			15 00 02 75 00
+			15 00 02 76 4C
+			15 00 02 77 00
+			15 00 02 78 6B
+			15 00 02 79 00
+			15 00 02 7A 85
+			15 00 02 7B 00
+			15 00 02 7C 9A
+			15 00 02 7D 00
+			15 00 02 7E AD
+			15 00 02 7F 00
+			15 00 02 80 BE
+			15 00 02 81 00
+			15 00 02 82 CD
+			15 00 02 83 01
+			15 00 02 84 01
+			15 00 02 85 01
+			15 00 02 86 29
+			15 00 02 87 01
+			15 00 02 88 68
+			15 00 02 89 01
+			15 00 02 8A 98
+			15 00 02 8B 01
+			15 00 02 8C E5
+			15 00 02 8D 02
+			15 00 02 8E 1E
+			15 00 02 8F 02
+			15 00 02 90 30
+			15 00 02 91 02
+			15 00 02 92 52
+			15 00 02 93 02
+			15 00 02 94 88
+			15 00 02 95 02
+			15 00 02 96 AA
+			15 00 02 97 02
+			15 00 02 98 D7
+			15 00 02 99 02
+			15 00 02 9A F7
+			15 00 02 9B 03
+			15 00 02 9C 21
+			15 00 02 9D 03
+			15 00 02 9E 2E
+			15 00 02 9F 03
+			15 00 02 A0 3D
+			15 00 02 A2 03
+			15 00 02 A3 4C
+			15 00 02 A4 03
+			15 00 02 A5 5E
+			15 00 02 A6 03
+			15 00 02 A7 71
+			15 00 02 A9 03
+			15 00 02 AA 86
+			15 00 02 AB 03
+			15 00 02 AC 94
+			15 00 02 AD 03
+			15 00 02 AE FA
+			15 00 02 AF 00
+			15 00 02 B0 00
+			15 00 02 B1 00
+			15 00 02 B2 21
+			15 00 02 B3 00
+			15 00 02 B4 4C
+			15 00 02 B5 00
+			15 00 02 B6 6B
+			15 00 02 B7 00
+			15 00 02 B8 85
+			15 00 02 B9 00
+			15 00 02 BA 9A
+			15 00 02 BB 00
+			15 00 02 BC AD
+			15 00 02 BD 00
+			15 00 02 BE BE
+			15 00 02 BF 00
+			15 00 02 C0 CD
+			15 00 02 C1 01
+			15 00 02 C2 01
+			15 00 02 C3 01
+			15 00 02 C4 29
+			15 00 02 C5 01
+			15 00 02 C6 68
+			15 00 02 C7 01
+			15 00 02 C8 98
+			15 00 02 C9 01
+			15 00 02 CA E5
+			15 00 02 CB 02
+			15 00 02 CC 1E
+			15 00 02 CD 02
+			15 00 02 CE 20
+			15 00 02 CF 02
+			15 00 02 D0 52
+			15 00 02 D1 02
+			15 00 02 D2 88
+			15 00 02 D3 02
+			15 00 02 D4 AA
+			15 00 02 D5 02
+			15 00 02 D6 D7
+			15 00 02 D7 02
+			15 00 02 D8 F7
+			15 00 02 D9 03
+			15 00 02 DA 21
+			15 00 02 DB 03
+			15 00 02 DC 2E
+			15 00 02 DD 03
+			15 00 02 DE 3D
+			15 00 02 DF 03
+			15 00 02 E0 4C
+			15 00 02 E1 03
+			15 00 02 E2 5E
+			15 00 02 E3 03
+			15 00 02 E4 71
+			15 00 02 E5 03
+			15 00 02 E6 86
+			15 00 02 E7 03
+			15 00 02 E8 94
+			15 00 02 E9 03
+			15 00 02 EA FA
+			15 00 02 FF 01
+			15 00 02 FB 01
+			15 00 02 FF 02
+			15 00 02 FB 01
+			15 00 02 FF 04
+			15 00 02 FB 01
+			15 00 02 FF 00
+			15 00 02 D3 05
+			15 00 02 D4 04
+			05 78 01 11
+			15 00 02 FF 00
+			15 00 02 35 00
+			05 0A 01 29
+		];
+
+		panel-exit-sequence = [
+			05 05 01 28
+			05 78 01 10
+		];
+
+		disp_timings1: display-timings {
+			native-mode = <&dsi1_timing0>;
+			dsi1_timing0: timing0 {
+				clock-frequency = <152198100>;
+				hactive = <1080>;
+				vactive = <1920>;
+				hfront-porch = <104>;
+				hsync-len = <4>;
+				hback-porch = <127>;
+				vfront-porch = <4>;
+				vsync-len = <2>;
+				vback-porch = <3>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <0>;
+				pixelclk-active = <0>;
+			};
+		};
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				panel_in_dsi1: endpoint {
+					remote-endpoint = <&dsi1_out_panel>;
+				};
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			dsi1_out_panel: endpoint {
+				remote-endpoint = <&panel_in_dsi1>;
+			};
+		};
+	};
+
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu_s0>;
+	mem-supply = <&vdd_gpu_mem_s0>;
+	status = "okay";
+};
+
+&i2s0_8ch {
+	status = "okay";
+	pinctrl-0 = <&i2s0_lrck
+		     &i2s0_sclk
+		     &i2s0_sdi0
+		     &i2s0_sdo0>;
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&jpege_ccu {
+	status = "okay";
+};
+
+&jpege0 {
+	status = "okay";
+};
+
+&jpege0_mmu {
+	status = "okay";
+};
+
+&jpege1 {
+	status = "okay";
+};
+
+&jpege1_mmu {
+	status = "okay";
+};
+
+&jpege2 {
+	status = "okay";
+};
+
+&jpege2_mmu {
+	status = "okay";
+};
+
+&jpege3 {
+	status = "okay";
+};
+
+&jpege3_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&rga3_core0 {
+	status = "okay";
+};
+
+&rga3_0_mmu {
+	status = "okay";
+};
+
+&rga3_core1 {
+	status = "okay";
+};
+
+&rga3_1_mmu {
+	status = "okay";
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rknpu {
+	rknpu-supply = <&vdd_npu_s0>;
+	mem-supply = <&vdd_npu_mem_s0>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&rkvdec_ccu {
+	status = "okay";
+};
+
+&rkvdec0 {
+	status = "okay";
+};
+
+&rkvdec0_mmu {
+	status = "okay";
+};
+
+&rkvdec1 {
+	status = "okay";
+};
+
+&rkvdec1_mmu {
+	status = "okay";
+};
+
+&rkvenc_ccu {
+	status = "okay";
+};
+
+&rkvenc0 {
+	status = "okay";
+};
+
+&rkvenc0_mmu {
+	status = "okay";
+};
+
+&rkvenc1 {
+	status = "okay";
+};
+
+&rkvenc1_mmu {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcc_1v8_s0>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	status = "okay";
+};
+
+&sdmmc {
+	max-frequency = <150000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_sd>;
+	vqmmc-supply = <&vccio_sd_s0>;
+	status = "disabled";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	status = "okay";
+};
+
+&u2phy2_host {
+	status = "okay";
+};
+
+&u2phy3_host {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	status = "okay";
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+/* vp0 & vp1 splice for 8K output */
+&vp0 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART0>;
+};
+
+&vp1 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART1>;
+};
+
+&vp2 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART2>;
+};
+
+&vp3 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART3>;
+};
diff --git a/drivers/bluetooth/btbcm.c b/drivers/bluetooth/btbcm.c
index 1b9743b7f2ef..c5af5715cd17 100644
--- a/drivers/bluetooth/btbcm.c
+++ b/drivers/bluetooth/btbcm.c
@@ -387,6 +387,7 @@ struct bcm_subver_table {
 };
 
 static const struct bcm_subver_table bcm_uart_subver_table[] = {
+	{ 0x1111, "BCM4362A2"	},	/* 000.017.017 */
 	{ 0x4103, "BCM4330B1"	},	/* 002.001.003 */
 	{ 0x410d, "BCM4334B0"	},	/* 002.001.013 */
 	{ 0x410e, "BCM43341B0"	},	/* 002.001.014 */
diff --git a/drivers/input/sensors/accel/kxtj9.c b/drivers/input/sensors/accel/kxtj9.c
index 4726c5f73b54..116f7b605d74 100644
--- a/drivers/input/sensors/accel/kxtj9.c
+++ b/drivers/input/sensors/accel/kxtj9.c
@@ -32,6 +32,7 @@
 #include <linux/sensor-dev.h>
 
 
+#define KXTJ3_DEVID 0x35 //KXTJ3 id
 #define KXTJ9_DEVID	0x09	//chip id
 #define KXTJ9_RANGE	(2 * 16384)
 
@@ -78,6 +79,7 @@
 /* CONTROL REGISTER 1 BITS */
 #define KXTJ9_DISABLE			0x7F
 #define KXTJ9_ENABLE			(1 << 7)
+#define KXTJ3_INT_ENABLE               (1 << 5)
 /* INPUT_ABS CONSTANTS */
 #define FUZZ			3
 #define FLAT			3
@@ -109,6 +111,7 @@
 #define KXTJ9_PRECISION       12
 #define KXTJ9_BOUNDARY        (0x1 << (KXTJ9_PRECISION - 1))
 #define KXTJ9_GRAVITY_STEP    KXTJ9_RANGE / KXTJ9_BOUNDARY
+#define KXTJ3_GRAVITY_STEP    KXTJ9_RANGE / KXTJ9_BOUNDARY
 
 
 /****************operate according to sensor chip:start************/
@@ -176,6 +179,9 @@ static int sensor_init(struct i2c_client *client)
 	}
 	
 	sensor->ops->ctrl_data = (KXTJ9_RES_12BIT | KXTJ9_G_2G);
+	if(sensor->pdata->irq_enable)
+		sensor->ops->ctrl_data |= KXTJ3_INT_ENABLE;
+
 	result = sensor_write_reg(client, sensor->ops->ctrl_reg, sensor->ops->ctrl_data);
 	if(result)
 	{
@@ -192,7 +198,12 @@ static short sensor_convert_data(struct i2c_client *client, char high_byte, char
 	struct sensor_private_data *sensor =
 	    (struct sensor_private_data *) i2c_get_clientdata(client);	
 	//int precision = sensor->ops->precision;
-	switch (sensor->devid) {	
+	switch (sensor->devid) {
+		case KXTJ3_DEVID:
+			result = (((short)high_byte << 8) | ((short)low_byte)) >> 4;
+			result *= KXTJ3_GRAVITY_STEP;
+			break;
+
 		case KXTJ9_DEVID:		
 			result = (((short)high_byte << 8) | ((short)low_byte)) >> 4;
 			result *= KXTJ9_GRAVITY_STEP;
@@ -284,7 +295,7 @@ static struct sensor_operate gsensor_kxtj9_ops = {
 	.read_reg			= KXTJ9_XOUT_L,
 	.read_len			= 6,
 	.id_reg			= KXTJ9_WHO_AM_I,
-	.id_data			= KXTJ9_DEVID,
+	.id_data			= KXTJ3_DEVID,
 	.precision			= KXTJ9_PRECISION,
 	.ctrl_reg			= KXTJ9_CTRL_REG1,
 	.int_status_reg	= KXTJ9_INT_REL,
@@ -309,6 +320,7 @@ static int gsensor_kxtj9_remove(struct i2c_client *client)
 
 static const struct i2c_device_id gsensor_kxtj9_id[] = {
 	{"gs_kxtj9", ACCEL_ID_KXTJ9},
+	{"gs_kxtj3", ACCEL_ID_KXTJ9},
 	{}
 };
 
@@ -318,7 +330,7 @@ static struct i2c_driver gsensor_kxtj9_driver = {
 	.shutdown = sensor_shutdown,
 	.id_table = gsensor_kxtj9_id,
 	.driver = {
-		.name = "gsensor_kxtj9",
+		.name = "gsensor_kxtj3",
 	#ifdef CONFIG_PM
 		.pm = &sensor_pm_ops,
 	#endif
diff --git a/drivers/input/sensors/sensor-dev.c b/drivers/input/sensors/sensor-dev.c
index eb93e19157ea..1c873d3c1b15 100644
--- a/drivers/input/sensors/sensor-dev.c
+++ b/drivers/input/sensors/sensor-dev.c
@@ -1447,7 +1447,7 @@ static int sensor_misc_device_register(struct sensor_private_data *sensor, int t
 			sensor->fops.release = gsensor_dev_release;
 
 			sensor->miscdev.minor = MISC_DYNAMIC_MINOR;
-			sensor->miscdev.name = "mma8452_daemon";
+			sensor->miscdev.name = "accel";
 			sensor->miscdev.fops = &sensor->fops;
 		} else {
 			memcpy(&sensor->miscdev, sensor->ops->misc_dev, sizeof(*sensor->ops->misc_dev));
diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 93f5b1b60fde..7d7b3c7581ed 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -78,6 +78,25 @@ static int create_gpio_led(const struct gpio_led *template,
 	struct led_init_data init_data = {};
 	int ret, state;
 
+	led_dat->gpiod = template->gpiod;
+	if (!led_dat->gpiod) {
+		unsigned long flags = GPIOF_OUT_INIT_LOW;
+		if (!gpio_is_valid(template->gpio)) {
+			dev_info(parent, "Skipping unavailable LED gpio %d (%s)\n",
+					template->gpio, template->name);
+			return 0;
+		}
+		if (template->active_low)
+			flags |= GPIOF_ACTIVE_LOW;
+		ret = devm_gpio_request_one(parent, template->gpio, flags,
+									template->name);
+		if (ret < 0)
+			return ret;
+		led_dat->gpiod = gpio_to_desc(template->gpio);
+		if (!led_dat->gpiod)
+			return -EINVAL;
+	}
+	led_dat->cdev.name = template->name;
 	led_dat->cdev.default_trigger = template->default_trigger;
 	led_dat->can_sleep = gpiod_cansleep(led_dat->gpiod);
 	if (!led_dat->can_sleep)
@@ -125,6 +144,12 @@ struct gpio_leds_priv {
 	struct gpio_led_data leds[];
 };
 
+static inline int sizeof_gpio_leds_priv(int num_leds)
+{
+	return sizeof(struct gpio_leds_priv) +
+			(sizeof(struct gpio_led_data) * num_leds);
+}
+
 static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -145,19 +170,30 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		struct gpio_led led = {};
 		const char *state = NULL;
 
+		struct device_node *np = to_of_node(child);
+		ret = fwnode_property_read_string(child, "label", &led.name);
+		if (ret && IS_ENABLED(CONFIG_OF) && np)
+			led.name = np->name;
+		if (!led.name) {
+			fwnode_handle_put(child);
+			return ERR_PTR(-EINVAL);
+		}
+
 		/*
 		 * Acquire gpiod from DT with uninitialized label, which
 		 * will be updated after LED class device is registered,
 		 * Only then the final LED name is known.
 		 */
 		led.gpiod = devm_fwnode_get_gpiod_from_child(dev, NULL, child,
-							     GPIOD_ASIS,
-							     NULL);
+							     GPIOD_ASIS,led.name);
 		if (IS_ERR(led.gpiod)) {
 			fwnode_handle_put(child);
 			return ERR_CAST(led.gpiod);
 		}
 
+		fwnode_property_read_string(child, "linux,default-trigger",
+						&led.default_trigger);
+
 		led_dat->gpiod = led.gpiod;
 
 		if (!fwnode_property_read_string(child, "default-state",
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 62f35ba898de..9b51e716f7f8 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -5,12 +5,6 @@
 
 menu "Misc devices"
 
-config RK803
-	tristate "RK803"
-	default n
-	help
-	  Driver for RK803 which is used for driving porjector and IR flood LED.
-
 config SENSORS_LIS3LV02D
 	tristate
 	depends on INPUT
@@ -487,6 +481,18 @@ config HISI_HIKEY_USB
 	  switching between the dual-role USB-C port and the USB-A host ports
 	  using only one USB controller.
 
+config RK803
+	tristate "RK803"
+	default n
+	help
+	  Driver for RK803 which is used for driving porjector and IR flood LED.
+
+config KHADAS_MCU
+	tristate "Khadas MCU control driver"
+	default n
+	help
+	  This driver allow to control MCU.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 8be76bac6eb8..574b8ff68cda 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -3,7 +3,7 @@
 # Makefile for misc devices that really don't fit anywhere else.
 #
 
-obj-$(CONFIG_RK803)		+= rk803.o
+KBUILD_CFLAGS += -Wno-unused-function
 obj-$(CONFIG_IBM_ASM)		+= ibmasm/
 obj-$(CONFIG_IBMVMC)		+= ibmvmc.o
 obj-$(CONFIG_AD525X_DPOT)	+= ad525x_dpot.o
@@ -59,3 +59,5 @@ obj-$(CONFIG_UACCE)		+= uacce/
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
 obj-$(CONFIG_HISI_HIKEY_USB)	+= hisi_hikey_usb.o
 obj-$(CONFIG_UID_SYS_STATS)	+= uid_sys_stats.o
+obj-$(CONFIG_RK803)		+= rk803.o
+obj-$(CONFIG_KHADAS_MCU) += khadas-mcu.o
diff --git a/drivers/misc/khadas-mcu.c b/drivers/misc/khadas-mcu.c
new file mode 100644
index 000000000000..03f4eedbb62d
--- /dev/null
+++ b/drivers/misc/khadas-mcu.c
@@ -0,0 +1,696 @@
+/*
+ * Khadas Edge2 MCU control driver
+ *
+ * Written by: Nick <nick@khadas.com>
+ *
+ * Copyright (C) 2022 Wesion Technologies Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/sysfs.h>
+#include <linux/ctype.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+/* Device registers */
+#define MCU_PWR_OFF_CMD_REG       0x80
+#define MCU_SHUTDOWN_NORMAL_REG   0x2c
+
+/*Fan device*/
+#define MCU_CMD_FAN_STATUS_CTRL_REGv2   0x8A
+
+#define MCU_FAN_TRIG_TEMP_LEVEL0        60  // 50 degree if not set
+#define MCU_FAN_TRIG_TEMP_LEVEL1        80  // 60 degree if not set
+#define MCU_FAN_TRIG_TEMP_LEVEL2        100 // 70 degree if not set
+#define MCU_FAN_TRIG_MAXTEMP            105
+#define MCU_FAN_LOOP_SECS               (30 * HZ)   // 30 seconds
+#define MCU_FAN_TEST_LOOP_SECS          (5 * HZ)  // 5 seconds
+#define MCU_FAN_LOOP_NODELAY_SECS       0
+#define MCU_FAN_SPEED_OFF               0
+#define MCU_FAN_SPEED_LOW               1
+#define MCU_FAN_SPEED_MID               2
+#define MCU_FAN_SPEED_HIGH              3
+#define MCU_FAN_SPEED_LOW_V2            0x32
+#define MCU_FAN_SPEED_MID_V2            0x48
+#define MCU_FAN_SPEED_HIGH_V2           0x64
+
+enum khadas_board {
+	KHADAS_BOARD_NONE = 0,
+	KHADAS_BOARD_EDGE2
+};
+
+enum khadas_board_hwver {
+	KHADAS_BOARD_HWVER_NONE = 0,
+	KHADAS_BOARD_HWVER_V11
+};
+
+enum mcu_fan_mode {
+	MCU_FAN_MODE_MANUAL = 0,
+	MCU_FAN_MODE_AUTO
+};
+
+enum mcu_fan_level {
+	MCU_FAN_LEVEL_0 = 0,
+	MCU_FAN_LEVEL_1,
+	MCU_FAN_LEVEL_2,
+	MCU_FAN_LEVEL_3
+};
+
+enum mcu_fan_status {
+	MCU_FAN_STATUS_DISABLE = 0,
+	MCU_FAN_STATUS_ENABLE,
+};
+
+struct mcu_fan_data {
+    struct platform_device *pdev;
+    struct class *fan_class;
+    struct delayed_work work;
+    struct delayed_work fan_test_work;
+    enum mcu_fan_status enable;
+    enum mcu_fan_mode mode;
+    enum mcu_fan_level level;
+    int trig_temp_level0;
+    int trig_temp_level1;
+    int trig_temp_level2;
+};
+
+struct mcu_data {
+	struct i2c_client *client;
+	struct class *mcu_class;
+	enum khadas_board board;
+	enum khadas_board_hwver hwver;
+	struct mcu_fan_data fan_data;
+};
+
+struct mcu_data *g_mcu_data;
+
+static int i2c_master_reg8_send(const struct i2c_client *client,
+		const char reg, const char *buf, int count)
+{
+	struct i2c_adapter *adap = client->adapter;
+	struct i2c_msg msg;
+	int ret;
+	char *tx_buf = kzalloc(count + 1, GFP_KERNEL);
+	if (!tx_buf)
+		return -ENOMEM;
+	tx_buf[0] = reg;
+	memcpy(tx_buf+1, buf, count);
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = count + 1;
+	msg.buf = (char *)tx_buf;
+
+	ret = i2c_transfer(adap, &msg, 1);
+	kfree(tx_buf);
+	return (ret == 1) ? count : ret;
+}
+
+static int i2c_master_reg8_recv(const struct i2c_client *client,
+		const char reg, char *buf, int count)
+{
+	struct i2c_adapter *adap = client->adapter;
+	struct i2c_msg msgs[2];
+	int ret;
+	char reg_buf = reg;
+
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].len = 1;
+	msgs[0].buf = &reg_buf;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].len = count;
+	msgs[1].buf = (char *)buf;
+
+	ret = i2c_transfer(adap, msgs, 2);
+
+	return (ret == 2) ? count : ret;
+}
+
+static int mcu_i2c_read_regs(struct i2c_client *client,
+		u8 reg, u8 buf[], unsigned len)
+{
+	int ret;
+	ret = i2c_master_reg8_recv(client, reg, buf, len);
+	return ret;
+}
+
+static int mcu_i2c_write_regs(struct i2c_client *client,
+		u8 reg, u8 const buf[], __u16 len)
+{
+	int ret;
+
+	ret = i2c_master_reg8_send(client, reg, buf, (int)len);
+
+	return ret;
+}
+
+static int is_mcu_fan_control_supported(void)
+{
+	// MCU FAN control is supported for:
+	// 1. Khadas EDGE2
+	if (g_mcu_data->board == KHADAS_BOARD_EDGE2) {
+		if (g_mcu_data->hwver >= KHADAS_BOARD_HWVER_V11)
+			return 1;
+		else
+			return 0;
+	} else {
+			return 0;
+	}
+
+}
+static void mcu_fan_level_set(struct mcu_fan_data *fan_data, int level)
+{
+    if (is_mcu_fan_control_supported()) {
+        int ret;
+        u8 data = 0;
+
+        g_mcu_data->fan_data.level = level;
+
+		if (g_mcu_data->board == KHADAS_BOARD_EDGE2) {
+            if (level == 0)
+                data = MCU_FAN_SPEED_OFF;
+            else if (level == 1)
+                data = MCU_FAN_SPEED_LOW_V2;
+            else if (level == 2)
+                data = MCU_FAN_SPEED_MID_V2;
+            else if (level == 3)
+                data = MCU_FAN_SPEED_HIGH_V2;
+            ret = mcu_i2c_write_regs(g_mcu_data->client,
+                    MCU_CMD_FAN_STATUS_CTRL_REGv2,
+                    &data, 1);
+            if (ret < 0) {
+                pr_debug("write fan control err\n");
+                return;
+            }
+	      }
+    }
+}
+
+extern int rk_get_temperature(void);
+
+static void fan_work_func(struct work_struct *_work)
+{
+    if (is_mcu_fan_control_supported()) {
+        int temp = -EINVAL;
+        struct mcu_fan_data *fan_data = &g_mcu_data->fan_data;
+
+		if (g_mcu_data->board == KHADAS_BOARD_EDGE2) {
+            temp = rk_get_temperature();
+		} else {
+           temp = fan_data->trig_temp_level0;
+		}
+
+		if (temp != -EINVAL) {
+            if (temp < fan_data->trig_temp_level0)
+                mcu_fan_level_set(fan_data, 0);
+            else if (temp < fan_data->trig_temp_level1)
+                mcu_fan_level_set(fan_data, 1);
+            else if (temp < fan_data->trig_temp_level2)
+                mcu_fan_level_set(fan_data, 2);
+            else
+                mcu_fan_level_set(fan_data, 3);
+        }
+
+        schedule_delayed_work(&fan_data->work, MCU_FAN_LOOP_SECS);
+    }
+}
+
+static void khadas_fan_set(struct mcu_fan_data  *fan_data)
+{
+	if (is_mcu_fan_control_supported()) {
+        cancel_delayed_work(&fan_data->work);
+        if (fan_data->enable == MCU_FAN_STATUS_DISABLE) {
+            mcu_fan_level_set(fan_data, 0);
+            return;
+        }
+        switch (fan_data->mode) {
+        case MCU_FAN_MODE_MANUAL:
+            switch (fan_data->level) {
+				case MCU_FAN_LEVEL_0:
+					mcu_fan_level_set(fan_data, 0);
+					break;
+				case MCU_FAN_LEVEL_1:
+					mcu_fan_level_set(fan_data, 1);
+					break;
+				case MCU_FAN_LEVEL_2:
+					mcu_fan_level_set(fan_data, 2);
+					break;
+				case MCU_FAN_LEVEL_3:
+					mcu_fan_level_set(fan_data, 3);
+					break;
+				default:
+					break;
+            }
+            break;
+		case MCU_FAN_MODE_AUTO:
+            // FIXME: achieve with a better way
+			schedule_delayed_work(&fan_data->work,
+                    MCU_FAN_LOOP_NODELAY_SECS);
+			break;
+		default:
+			break;
+        }
+    }
+}
+
+static ssize_t show_fan_enable(struct class *cls,
+             struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "Fan enable: %d\n", g_mcu_data->fan_data.enable);
+}
+
+static ssize_t store_fan_enable(struct class *cls, struct class_attribute *attr,
+               const char *buf, size_t count)
+{
+    int enable;
+
+    if (kstrtoint(buf, 0, &enable))
+        return -EINVAL;
+
+    // 0: manual, 1: auto
+    if (enable >= 0 && enable < 2) {
+        g_mcu_data->fan_data.enable = enable;
+        khadas_fan_set(&g_mcu_data->fan_data);
+    }
+
+	return count;
+}
+
+
+static ssize_t show_fan_mode(struct class *cls,
+             struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "Fan mode: %d\n", g_mcu_data->fan_data.mode);
+}
+
+static ssize_t store_fan_mode(struct class *cls, struct class_attribute *attr,
+               const char *buf, size_t count)
+{
+    int mode;
+
+    if (kstrtoint(buf, 0, &mode))
+        return -EINVAL;
+
+    // 0: manual, 1: auto
+    if (mode >= 0 && mode < 2) {
+        g_mcu_data->fan_data.mode = mode;
+        khadas_fan_set(&g_mcu_data->fan_data);
+    }
+
+    return count;
+}
+
+static ssize_t show_fan_level(struct class *cls,
+             struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "Fan level: %d\n", g_mcu_data->fan_data.level);
+}
+
+static ssize_t store_fan_level(struct class *cls, struct class_attribute *attr,
+               const char *buf, size_t count)
+{
+    int level;
+
+    if (kstrtoint(buf, 0, &level))
+        return -EINVAL;
+
+    if (level >= 0 && level < 4) {
+        g_mcu_data->fan_data.level = level;
+        khadas_fan_set(&g_mcu_data->fan_data);
+    }
+
+    return count;
+}
+
+static ssize_t show_fan_temp(struct class *cls,
+             struct class_attribute *attr, char *buf)
+{
+    struct mcu_fan_data *fan_data = &g_mcu_data->fan_data;
+    int temp = -EINVAL;
+
+    if (g_mcu_data->board == KHADAS_BOARD_EDGE2)
+        temp = rk_get_temperature();
+    else
+        temp = fan_data->trig_temp_level0;
+
+    return sprintf(buf,
+            "cpu_temp:%d\nFan trigger temperature: level0:%d level1:%d level2:%d\n",
+            temp, g_mcu_data->fan_data.trig_temp_level0,
+            g_mcu_data->fan_data.trig_temp_level1,
+            g_mcu_data->fan_data.trig_temp_level2);
+}
+
+void fan_level_set(struct mcu_data *ug_mcu_data)
+{
+    struct mcu_fan_data *fan_data = &g_mcu_data->fan_data;
+    int temp = -EINVAL;
+
+    if (ug_mcu_data->board == KHADAS_BOARD_EDGE2)
+        temp = rk_get_temperature();
+    else
+        temp = fan_data->trig_temp_level0;
+
+    if (temp != -EINVAL) {
+        if (temp < ug_mcu_data->fan_data.trig_temp_level0)
+            mcu_fan_level_set(fan_data, 0);
+        else if (temp < ug_mcu_data->fan_data.trig_temp_level1)
+            mcu_fan_level_set(fan_data, 1);
+        else if (temp < ug_mcu_data->fan_data.trig_temp_level2)
+            mcu_fan_level_set(fan_data, 2);
+        else
+            mcu_fan_level_set(fan_data, 3);
+    }
+}
+
+static ssize_t show_fan_trigger_low(struct class *cls,
+        struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf,
+            "Fan trigger low speed temperature:%d\n",
+            g_mcu_data->fan_data.trig_temp_level0);
+}
+
+static ssize_t store_fan_trigger_low(struct class *cls,
+        struct class_attribute *attr,
+        const char *buf, size_t count)
+{
+    int trigger;
+
+    if (kstrtoint(buf, 0, &trigger))
+        return -EINVAL;
+
+    if (trigger >= g_mcu_data->fan_data.trig_temp_level1) {
+        pr_err("Invalid parameter\n");
+        return -EINVAL;
+    }
+
+    g_mcu_data->fan_data.trig_temp_level0 = trigger;
+
+    fan_level_set(g_mcu_data);
+
+    return count;
+}
+
+static ssize_t show_fan_trigger_mid(struct class *cls,
+        struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf,
+            "Fan trigger mid speed temperature:%d\n",
+            g_mcu_data->fan_data.trig_temp_level1);
+}
+
+static ssize_t store_fan_trigger_mid(struct class *cls,
+        struct class_attribute *attr,
+        const char *buf, size_t count)
+{
+    int trigger;
+
+    if (kstrtoint(buf, 0, &trigger))
+        return -EINVAL;
+
+    if (trigger >= g_mcu_data->fan_data.trig_temp_level2 ||
+            trigger <= g_mcu_data->fan_data.trig_temp_level0){
+        pr_err("Invalid parameter\n");
+        return -EINVAL;
+    }
+
+    g_mcu_data->fan_data.trig_temp_level1 = trigger;
+
+    fan_level_set(g_mcu_data);
+
+    return count;
+}
+
+static ssize_t show_fan_trigger_high(struct class *cls,
+        struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf,
+            "Fan trigger high speed temperature:%d\n",
+            g_mcu_data->fan_data.trig_temp_level2);
+}
+
+static ssize_t store_fan_trigger_high(struct class *cls,
+        struct class_attribute *attr,
+        const char *buf, size_t count)
+{
+    int trigger;
+
+    if (kstrtoint(buf, 0, &trigger))
+        return -EINVAL;
+
+    if (trigger <= g_mcu_data->fan_data.trig_temp_level1) {
+        pr_err("Invalid parameter\n");
+        return -EINVAL;
+    }
+
+    g_mcu_data->fan_data.trig_temp_level2 = trigger;
+
+    fan_level_set(g_mcu_data);
+
+    return count;
+}
+
+static ssize_t store_mcu_poweroff(struct class *cls,struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	int val;
+	char reg;
+
+	if (kstrtoint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 1)
+		return -EINVAL;
+
+	reg = (char)val;
+
+	ret = mcu_i2c_write_regs(g_mcu_data->client,MCU_PWR_OFF_CMD_REG,
+							&reg, 1);
+	if (ret < 0) {
+		pr_debug("write poweroff cmd error\n");
+		return ret;
+	}
+
+	return count;
+}
+
+static ssize_t store_mcu_rst(struct class *cls, struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	char reg;
+	int ret;
+	int rst;
+
+	if (kstrtoint(buf, 0, &rst))
+		return -EINVAL;
+
+	reg = rst;
+	ret = mcu_i2c_write_regs(g_mcu_data->client,MCU_SHUTDOWN_NORMAL_REG,
+							&reg, 1);
+	if (ret < 0) {
+		pr_debug("write poweroff cmd error\n");
+		return ret;
+	}
+
+	return count;
+}
+
+static struct class_attribute fan_class_attrs[] = {
+    __ATTR(enable, 0644, show_fan_enable, store_fan_enable),
+    __ATTR(mode, 0644, show_fan_mode, store_fan_mode),
+    __ATTR(level, 0644, show_fan_level, store_fan_level),
+    __ATTR(trigger_temp_low, 0644,
+            show_fan_trigger_low, store_fan_trigger_low),
+    __ATTR(trigger_temp_mid, 0644,
+            show_fan_trigger_mid, store_fan_trigger_mid),
+    __ATTR(trigger_temp_high, 0644,
+            show_fan_trigger_high, store_fan_trigger_high),
+    __ATTR(temp, 0644, show_fan_temp, NULL),
+};
+
+static struct class_attribute mcu_class_attrs[] = {
+	__ATTR(poweroff, 0644, NULL, store_mcu_poweroff),
+	__ATTR(rst, 0644, NULL, store_mcu_rst),
+};
+
+static void create_mcu_attrs(void) {
+	int i;
+
+	g_mcu_data->mcu_class = class_create(THIS_MODULE, "mcu");
+	if (IS_ERR(g_mcu_data->mcu_class)) {
+		pr_err("create mcu_class debug class fail\n");
+
+		return;
+	}
+	for (i = 0; i < ARRAY_SIZE(mcu_class_attrs); i++) {
+		if (class_create_file(g_mcu_data->mcu_class, &mcu_class_attrs[i]));
+			pr_err("create mcu attribute %s fail\n",
+							mcu_class_attrs[i].attr.name);
+	}
+
+	if (is_mcu_fan_control_supported()) {
+		g_mcu_data->fan_data.fan_class = class_create(THIS_MODULE, "fan");
+			if (IS_ERR(g_mcu_data->fan_data.fan_class)) {
+				pr_err("create fan_class debug class fail\n");
+				return;
+			}
+			for (i = 0; i < ARRAY_SIZE(fan_class_attrs); i++) {
+				if (class_create_file(g_mcu_data->fan_data.fan_class,
+                        &fan_class_attrs[i]))
+					pr_err("create fan attribute %s fail\n", fan_class_attrs[i].attr.name);
+        }
+	}
+}
+
+static int mcu_parse_dt(struct device *dev)
+{
+	int ret = 0;
+	const char *hwver = NULL;
+
+	if (NULL == dev) return -EINVAL;
+
+	ret = of_property_read_string(dev->of_node, "hwver", &hwver);
+	if (ret < 0) {
+			return 0;
+	} else {
+			if (strstr(hwver, "EDGE2"))
+					g_mcu_data->board = KHADAS_BOARD_EDGE2;
+			else
+					g_mcu_data->board = KHADAS_BOARD_NONE;
+
+			if (g_mcu_data->board == KHADAS_BOARD_EDGE2) {
+					if (strcmp(hwver, "EDGE2.V11") == 0)
+							g_mcu_data->hwver = KHADAS_BOARD_HWVER_V11;
+			}
+	}
+
+		ret = of_property_read_u32(dev->of_node,
+            "fan,trig_temp_level0",
+            &g_mcu_data->fan_data.trig_temp_level0);
+    if (ret < 0)
+        g_mcu_data->fan_data.trig_temp_level0 =
+            MCU_FAN_TRIG_TEMP_LEVEL0;
+    ret = of_property_read_u32(dev->of_node,
+            "fan,trig_temp_level1",
+            &g_mcu_data->fan_data.trig_temp_level1);
+    if (ret < 0)
+        g_mcu_data->fan_data.trig_temp_level1 =
+            MCU_FAN_TRIG_TEMP_LEVEL1;
+    ret = of_property_read_u32(dev->of_node,
+            "fan,trig_temp_level2",&g_mcu_data->fan_data.trig_temp_level2);
+    if (ret < 0){
+        g_mcu_data->fan_data.trig_temp_level2 =MCU_FAN_TRIG_TEMP_LEVEL2;
+	}
+
+	return ret;
+}
+
+static int mcu_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	printk("%s\n", __func__);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	g_mcu_data = kzalloc(sizeof(struct mcu_data), GFP_KERNEL);
+
+	if (g_mcu_data == NULL)
+		return -ENOMEM;
+
+	mcu_parse_dt(&client->dev);
+
+	g_mcu_data->client = client;
+
+	g_mcu_data->fan_data.mode = MCU_FAN_MODE_AUTO;
+	g_mcu_data->fan_data.level = MCU_FAN_LEVEL_0;
+	g_mcu_data->fan_data.enable = MCU_FAN_STATUS_ENABLE;
+
+	INIT_DELAYED_WORK(&g_mcu_data->fan_data.work, fan_work_func);
+	mcu_fan_level_set(&g_mcu_data->fan_data, 0);
+	schedule_delayed_work(&g_mcu_data->fan_data.work, MCU_FAN_LOOP_SECS);
+	create_mcu_attrs();
+
+	return 0;
+}
+
+static int mcu_remove(struct i2c_client *client)
+{
+	kfree(g_mcu_data);
+	return 0;
+}
+
+static void khadas_fan_shutdown(struct i2c_client *client)
+{
+    g_mcu_data->fan_data.enable = MCU_FAN_STATUS_DISABLE;
+    khadas_fan_set(&g_mcu_data->fan_data);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int khadas_fan_suspend(struct device *dev)
+{
+    cancel_delayed_work(&g_mcu_data->fan_data.work);
+    mcu_fan_level_set(&g_mcu_data->fan_data, 0);
+
+    return 0;
+}
+
+static int khadas_fan_resume(struct device *dev)
+{
+    khadas_fan_set(&g_mcu_data->fan_data);
+
+    return 0;
+}
+
+static const struct dev_pm_ops fan_dev_pm_ops = {
+    SET_SYSTEM_SLEEP_PM_OPS(khadas_fan_suspend, khadas_fan_resume)
+};
+
+#define FAN_PM_OPS (&(fan_dev_pm_ops))
+
+#endif
+
+static const struct i2c_device_id mcu_id[] = {
+	{ "khadas-mcu", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, mcu_id);
+
+
+static struct of_device_id mcu_dt_ids[] = {
+	{ .compatible = "khadas-mcu" },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, mcu_dt_ids);
+
+struct i2c_driver mcu_driver = {
+	.driver  = {
+		.name   = "khadas-mcu",
+		.owner  = THIS_MODULE,
+		.of_match_table = of_match_ptr(mcu_dt_ids),
+#ifdef CONFIG_PM_SLEEP
+		.pm = FAN_PM_OPS,
+#endif
+	},
+	.probe		= mcu_probe,
+	.remove 	= mcu_remove,
+	.shutdown = khadas_fan_shutdown,
+	.id_table	= mcu_id,
+};
+module_i2c_driver(mcu_driver);
+
+MODULE_AUTHOR("Nick <nick@khadas.com>");
+MODULE_DESCRIPTION("Khadas Edge2 MCU control driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/thermal/rockchip_thermal.c b/drivers/thermal/rockchip_thermal.c
index 4e8b45219431..73a7e54b6051 100644
--- a/drivers/thermal/rockchip_thermal.c
+++ b/drivers/thermal/rockchip_thermal.c
@@ -328,6 +328,8 @@ struct tsadc_table {
 	int temp;
 };
 
+static struct rockchip_thermal_sensor  *g_tsensor_data_ptr;
+
 static const struct tsadc_table rv1106_code_table[] = {
 	{0, -40000},
 	{396, -40000},
@@ -1854,6 +1856,20 @@ static int rockchip_thermal_get_temp(void *_sensor, int *out_temp)
 	return retval;
 }
 
+int rk_get_temperature(void)
+{
+	int temp;
+	int ret;
+
+	ret = rockchip_thermal_get_temp(g_tsensor_data_ptr, &temp);
+		if (ret) {
+			pr_debug("rk_get_temp failed!\n");
+			return ret;
+		}
+	     return temp / 1000;
+}
+EXPORT_SYMBOL(rk_get_temperature);
+
 static const struct thermal_zone_of_device_ops rockchip_of_thermal_ops = {
 	.get_temp = rockchip_thermal_get_temp,
 	.set_trips = rockchip_thermal_set_trips,
@@ -2198,6 +2214,7 @@ static int rockchip_thermal_probe(struct platform_device *pdev)
 	thermal->panic_nb.notifier_call = rockchip_thermal_panic;
 	atomic_notifier_chain_register(&panic_notifier_list,
 				       &thermal->panic_nb);
+	g_tsensor_data_ptr = &thermal->sensors[0];
 
 	dev_info(&pdev->dev, "tsadc is probed successfully!\n");
 
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 01ce3f41cc21..bde9e629ec45 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -865,6 +865,16 @@ config MEDIATEK_WATCHDOG
 	  To compile this driver as a module, choose M here: the
 	  module will be called mtk_wdt.
 
+config KHADAS_WATCHDOG
+	tristate "KHADAS watchdog support"
+	default y
+	help
+	 Say Y here to include watchdog support embedded into KHADAS.
+	 If the watchdog timer expires, TPS3851 will shut down all its power
+	 supplies.
+	 To compile this driver as a module, choose M here: the
+	 module will be called KHADAS_wdt.
+
 config DIGICOLOR_WATCHDOG
 	tristate "Conexant Digicolor SoCs watchdog support"
 	depends on ARCH_DIGICOLOR || COMPILE_TEST
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 071a2e50be98..0dc45e86a352 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_WATCHDOG_PRETIMEOUT_GOV_PANIC)	+= pretimeout_panic.o
 obj-$(CONFIG_PCWATCHDOG) += pcwd.o
 obj-$(CONFIG_MIXCOMWD) += mixcomwd.o
 obj-$(CONFIG_WDT) += wdt.o
+obj-$(CONFIG_KHADAS_WATCHDOG) += khadas_wdt.o
 
 # PCI-based Watchdog Cards
 obj-$(CONFIG_PCIPCWATCHDOG) += pcwd_pci.o
diff --git a/drivers/watchdog/khadas_wdt.c b/drivers/watchdog/khadas_wdt.c
new file mode 100644
index 000000000000..3b28a52fd6ae
--- /dev/null
+++ b/drivers/watchdog/khadas_wdt.c
@@ -0,0 +1,157 @@
+//#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+
+static struct timer_list mytimer;
+static unsigned int hw_margin = 3;
+static int khadas_input_pin;
+static unsigned int khadas_enble = 1;
+
+static void time_pre(struct timer_list *timer)
+{
+	static unsigned int flag=0;
+    flag = !flag;
+	gpio_direction_output(khadas_input_pin, flag);
+
+    //printk("%s\n", __func__);
+    mytimer.expires = jiffies + hw_margin * HZ/1000;  // 500ms 
+	if(khadas_enble)
+		mod_timer(&mytimer, mytimer.expires);
+}
+
+/*
+static void wdt_exit(void)
+{
+    if(timer_pending(&mytimer))
+    {
+        del_timer(&mytimer);
+    }
+    printk("exit Success \n");
+}*/
+
+static ssize_t show_enble(struct class *cls,
+				struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", khadas_enble);
+}
+
+static ssize_t store_enble(struct class *cls, struct class_attribute *attr,
+		        const char *buf, size_t count)
+{
+	int enable;
+
+	if (kstrtoint(buf, 0, &enable)){
+		printk("khadas_enble error\n");
+		return -EINVAL;
+	}
+	printk("khadas_enble=%d\n",enable);
+	khadas_enble = enable;
+	if(khadas_enble){
+		mytimer.expires = jiffies + hw_margin * HZ/1000;  // 500ms 
+		mod_timer(&mytimer, mytimer.expires);
+	}
+	return count;
+}
+
+static ssize_t store_pin_out(struct class *cls, struct class_attribute *attr,
+		        const char *buf, size_t count)
+{
+	int enable;
+
+	if (kstrtoint(buf, 0, &enable)){
+		printk("khadas_pin_out error\n");
+		return -EINVAL;
+	}
+	printk("khadas_pin_out=%d\n",enable);
+	gpio_direction_output(khadas_input_pin, enable);
+	return count;
+}
+
+static struct class_attribute khadas_attrs[] = {
+	__ATTR(enble, 0644, show_enble, store_enble),
+	__ATTR(pin_out, 0644, NULL, store_pin_out),
+};
+
+static void create_khadas_attrs(void)
+{
+	int i;
+	struct class *khadas_class;
+	printk("%s\n",__func__);
+	khadas_class = class_create(THIS_MODULE, "khadas");
+	if (IS_ERR(khadas_class)) {
+		pr_err("create khadas_class debug class fail\n");
+		return;
+	}
+	for (i = 0; i < ARRAY_SIZE(khadas_attrs); i++) {
+		if (class_create_file(khadas_class, &khadas_attrs[i]))
+			pr_err("create khadas attribute %s fail\n", khadas_attrs[i].attr.name);
+	}
+}
+
+static int wdt_probe(struct platform_device *pdev)
+{
+	const char *value;
+	int ret;
+	printk("hw_wdt enter probe\n");
+
+	ret = of_property_read_u32(pdev->dev.of_node,"hw_margin_ms", &hw_margin);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_string(pdev->dev.of_node,
+					  "hw-gpios", &value);
+	if (ret) {
+		printk("no hw-gpios");
+		return -1;
+	} else {
+		khadas_input_pin = of_get_named_gpio_flags
+						(pdev->dev.of_node,
+						"hw-gpios",
+						0, NULL);
+		printk("hlm hw-gpios: %d.\n", khadas_input_pin);
+		ret = gpio_request(khadas_input_pin, "khadas");
+	}
+
+    timer_setup(&mytimer, time_pre, 0);
+    mytimer.expires = jiffies + hw_margin * HZ/1000; //// 5ms 
+    add_timer(&mytimer);
+	create_khadas_attrs();
+	return 0;
+}
+
+static const struct of_device_id hw_khadas_wdt_dt_ids[] = {
+	{ .compatible = "linux,wdt-khadas", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hw_khadas_wdt_dt_ids);
+
+static struct platform_driver khadas_wdt_driver = {
+	.driver	= {
+		.name		= "hw_khadas_wdt",
+		.of_match_table	= hw_khadas_wdt_dt_ids,
+	},
+	.probe	= wdt_probe,
+};
+
+static int __init wdt_drv_init(void)
+{
+	return platform_driver_register(&khadas_wdt_driver);
+}
+arch_initcall(wdt_drv_init);
+
+MODULE_LICENSE("GPL");
diff --git a/include/dt-bindings/soc/rockchip,boot-mode.h b/include/dt-bindings/soc/rockchip,boot-mode.h
index 1436e1d32619..c617db54b09c 100644
--- a/include/dt-bindings/soc/rockchip,boot-mode.h
+++ b/include/dt-bindings/soc/rockchip,boot-mode.h
@@ -20,5 +20,6 @@
 #define BOOT_CHARGING		(REBOOT_FLAG + 11)
 /* enter usb mass storage mode */
 #define BOOT_UMS		(REBOOT_FLAG + 12)
-
+/* enter reboot test mode */
+#define BOOT_REBOOT_TEST        (REBOOT_FLAG + 14)
 #endif
-- 
Armbian

