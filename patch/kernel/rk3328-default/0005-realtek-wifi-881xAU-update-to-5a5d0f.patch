diff --git a/drivers/net/wireless/rtl8812au/core/rtw_mlme_ext.c b/drivers/net/wireless/rtl8812au/core/rtw_mlme_ext.c
index cc65410..050bfa3 100644
--- a/drivers/net/wireless/rtl8812au/core/rtw_mlme_ext.c
+++ b/drivers/net/wireless/rtl8812au/core/rtw_mlme_ext.c
@@ -1420,10 +1420,11 @@ void mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame)
 #ifdef CONFIG_AP_MODE
 	switch (GetFrameSubType(pframe)) {
 	case WIFI_AUTH:
-		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE) {
 			ptable->func = &OnAuth;
-		else
+		} else
 			ptable->func = &OnAuthClient;
+	/* Intentional fallthrough */
 	/* pass through */
 	case WIFI_ASSOCREQ:
 	case WIFI_REASSOCREQ:
@@ -2201,14 +2202,15 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 			if (rtw_is_list_empty(&pstat->asoc_list) == _FALSE) {
 				rtw_list_delete(&pstat->asoc_list);
 				pstapriv->asoc_list_cnt--;
-				if (pstat->expire_to > 0)
+				if (pstat->expire_to > 0) {
 					;/* TODO: STA re_auth within expire_to */
+				}
 			}
 			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
-			if (seq == 1)
+			if (seq == 1) {
 				; /* TODO: STA re_auth and auth timeout */
-
+			}
 		}
 	}
 
diff --git a/drivers/net/wireless/rtl8812au/core/rtw_pwrctrl.c b/drivers/net/wireless/rtl8812au/core/rtw_pwrctrl.c
index d8b45f4..0a596db 100644
--- a/drivers/net/wireless/rtl8812au/core/rtw_pwrctrl.c
+++ b/drivers/net/wireless/rtl8812au/core/rtw_pwrctrl.c
@@ -219,6 +219,7 @@ bool rtw_pwr_unassociated_idle(_adapter *adapter)
 			    || check_fwstate(pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS)
 			    || check_fwstate(pmlmepriv, WIFI_AP_STATE)
 			    || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE)
+			    || check_fwstate(pmlmepriv, WIFI_MONITOR_STATE)
 #if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
 			    || pcfg80211_wdinfo->is_ro_ch
 #elif defined(CONFIG_P2P)
@@ -618,6 +619,7 @@ u8 PS_RDY_CHECK(_adapter *padapter)
 	    || check_fwstate(pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS)
 	    || check_fwstate(pmlmepriv, WIFI_AP_STATE)
 	    || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE)
+	    || check_fwstate(pmlmepriv, WIFI_MONITOR_STATE)
 #if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
 	    || pcfg80211_wdinfo->is_ro_ch
 #endif
diff --git a/drivers/net/wireless/rtl8812au/core/rtw_recv.c b/drivers/net/wireless/rtl8812au/core/rtw_recv.c
index 83ed24e..8bb59ee 100644
--- a/drivers/net/wireless/rtl8812au/core/rtw_recv.c
+++ b/drivers/net/wireless/rtl8812au/core/rtw_recv.c
@@ -2125,7 +2125,7 @@ sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 			if ((bDumpRxPkt == 4) && (eth_type == 0x888e))
 				dump_rx_packet(ptr);
 #endif
-		} else
+		} else {
 			DBG_COUNTER(adapter->rx_logs.core_rx_pre_data_handled);
 		break;
 	default:
@@ -2136,6 +2136,7 @@ sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 		retval = _FAIL;
 		break;
 	}
+}
 
 exit:
 
@@ -3607,8 +3608,15 @@ static sint fill_radiotap_hdr(_adapter *padapter, union recv_frame *precvframe)
 	if (pattrib->mfrag)
 		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FRAG;
 
-	/* always append FCS */
-	/* hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FCS; */
+#ifdef CONFIG_RX_PACKET_APPEND_FCS
+        // Start by always indicating FCS is there:
+        hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FCS;
+
+        // Next, test for prior conditions that will remove FCS, and update flag accordingly:
+        if(check_fwstate(&padapter->mlmepriv,WIFI_MONITOR_STATE) == _FALSE)
+                if((pattrib->pkt_rpt_type == NORMAL_RX) && (pHalData->ReceiveConfig & RCR_APPFCS))
+                        hdr_buf[rt_len] &= ~IEEE80211_RADIOTAP_F_FCS;
+#endif
 
 	if (0)
 		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_DATAPAD;
diff --git a/drivers/net/wireless/rtl8812au/core/rtw_wlan_util.c b/drivers/net/wireless/rtl8812au/core/rtw_wlan_util.c
index 54c9a35..6de4e2e 100644
--- a/drivers/net/wireless/rtl8812au/core/rtw_wlan_util.c
+++ b/drivers/net/wireless/rtl8812au/core/rtw_wlan_util.c
@@ -2353,8 +2353,7 @@ int rtw_get_bcn_keys(ADAPTER *Adapter, u8 *pframe, u32 packet_len,
 
 		_rtw_memcpy(recv_beacon->ssid, elems.ssid, elems.ssid_len);
 		recv_beacon->ssid_len = elems.ssid_len;
-	} else
-		; /* means hidden ssid */
+	} else { ; } /* means hidden ssid */
 
 	/* checking RSN first */
 	if (elems.rsn_ie && elems.rsn_ie_len) {
diff --git a/drivers/net/wireless/rtl8812au/core/rtw_xmit.c b/drivers/net/wireless/rtl8812au/core/rtw_xmit.c
index 1620473..c1019bb 100644
--- a/drivers/net/wireless/rtl8812au/core/rtw_xmit.c
+++ b/drivers/net/wireless/rtl8812au/core/rtw_xmit.c
@@ -1254,10 +1254,11 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
 		_rtw_memcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);
 		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_ap);
-	} else
+	} else {
 		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_unknown);
 
 	bmcast = IS_MCAST(pattrib->ra);
+	}
 	if (bmcast) {
 		psta = rtw_get_bcmc_stainfo(padapter);
 		if (psta == NULL) { /* if we cannot get psta => drop the pkt */
@@ -3874,7 +3875,7 @@ s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
 	u32 len = skb->len;
 	u8 category, action;
 	int type = -1;
-	
+
 	//RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	if (skb)
@@ -3922,17 +3923,17 @@ s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
 					fixed_rate = 0;
 				fixed_rate += MGN_MCS0;
 			}
-			if ((mcs_have & 4) && 
+			if ((mcs_have & 4) &&
 			    (iterator.this_arg[1] & 4))
 				sgi = 1;
-			if ((mcs_have & 1) && 
+			if ((mcs_have & 1) &&
 			    (iterator.this_arg[1] & 1))
 				bwidth = 1;
-			if ((mcs_have & 0x10) && 
+			if ((mcs_have & 0x10) &&
 			    (iterator.this_arg[1] & 0x10))
 				ldpc = 1;
 			if ((mcs_have & 0x20))
-				stbc = (iterator.this_arg[1] >> 5) & 3;	
+				stbc = (iterator.this_arg[1] >> 5) & 3;
 		}
 		break;
 
@@ -3994,9 +3995,9 @@ s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
 	pattrib->ldpc = ldpc;
 	pattrib->stbc = stbc;
 	pattrib->retry_ctrl = (txflags & 0x08)?_FALSE:_TRUE;
-	pattrib->sw_seq = (txflags & 0x10)?_TRUE:_FALSE;
+	// pattrib->sw_seq = (txflags & 0x10)?_TRUE:_FALSE;  // Adds support for pre-configured SeqNum via RadioTap
+
 
-	
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 
 	pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
diff --git a/drivers/net/wireless/rtl8812au/hal/btc/HalBtcOutSrc.h b/drivers/net/wireless/rtl8812au/hal/btc/HalBtcOutSrc.h
index 9a8c8fb..545223b 100644
--- a/drivers/net/wireless/rtl8812au/hal/btc/HalBtcOutSrc.h
+++ b/drivers/net/wireless/rtl8812au/hal/btc/HalBtcOutSrc.h
@@ -146,7 +146,7 @@ typedef enum _BTC_WIFI_ROLE{
 typedef enum _BTC_WIRELESS_FREQ{
 	BTC_FREQ_2_4G					= 0x0,
 	BTC_FREQ_5G						= 0x1,
-	BTC_FREQ_MAX	
+	BTC_FREQ_MAX
 }BTC_WIRELESS_FREQ,*PBTC_WIRELESS_FREQ;
 
 typedef enum _BTC_WIFI_BW_MODE{
@@ -155,13 +155,13 @@ typedef enum _BTC_WIFI_BW_MODE{
 	BTC_WIFI_BW_HT40					= 0x2,
 	BTC_WIFI_BW_HT80					= 0x3,
 	BTC_WIFI_BW_HT160					= 0x4,
-	BTC_WIFI_BW_MAX	
+	BTC_WIFI_BW_MAX
 }BTC_WIFI_BW_MODE,*PBTC_WIFI_BW_MODE;
 
 typedef enum _BTC_WIFI_TRAFFIC_DIR{
 	BTC_WIFI_TRAFFIC_TX					= 0x0,
 	BTC_WIFI_TRAFFIC_RX					= 0x1,
-	BTC_WIFI_TRAFFIC_MAX	
+	BTC_WIFI_TRAFFIC_MAX
 }BTC_WIFI_TRAFFIC_DIR,*PBTC_WIFI_TRAFFIC_DIR;
 
 typedef enum _BTC_WIFI_PNP{
@@ -179,14 +179,14 @@ typedef enum _BTC_IOT_PEER
 	BTC_IOT_PEER_RALINK = 4,
 	BTC_IOT_PEER_ATHEROS = 5,
 	BTC_IOT_PEER_CISCO = 6,
-	BTC_IOT_PEER_MERU = 7,	
+	BTC_IOT_PEER_MERU = 7,
 	BTC_IOT_PEER_MARVELL = 8,
 	BTC_IOT_PEER_REALTEK_SOFTAP = 9,// peer is RealTek SOFT_AP, by Bohn, 2009.12.17
 	BTC_IOT_PEER_SELF_SOFTAP = 10, // Self is SoftAP
 	BTC_IOT_PEER_AIRGO = 11,
-	BTC_IOT_PEER_INTEL 				= 12, 
-	BTC_IOT_PEER_RTK_APCLIENT 		= 13, 
-	BTC_IOT_PEER_REALTEK_81XX 		= 14,	
+	BTC_IOT_PEER_INTEL 				= 12,
+	BTC_IOT_PEER_RTK_APCLIENT 		= 13,
+	BTC_IOT_PEER_REALTEK_81XX 		= 14,
 	BTC_IOT_PEER_REALTEK_WOW 		= 15,
 	BTC_IOT_PEER_REALTEK_JAGUAR_BCUTAP = 16,
 	BTC_IOT_PEER_REALTEK_JAGUAR_CCUTAP = 17,
@@ -215,7 +215,7 @@ typedef enum _BTC_ANT_TYPE{
 
 typedef enum _BTC_VENDOR{
 	BTC_VENDOR_LENOVO,
-	BTC_VENDOR_ASUS,	
+	BTC_VENDOR_ASUS,
 	BTC_VENDOR_OTHER
 }BTC_VENDOR,*PBTC_VENDOR;
 
@@ -242,7 +242,7 @@ typedef enum _BTC_GET_TYPE{
 	// type s4Byte
 	BTC_GET_S4_WIFI_RSSI,
 	BTC_GET_S4_HS_RSSI,
-	
+
 	// type u4Byte
 	BTC_GET_U4_WIFI_BW,
 	BTC_GET_U4_WIFI_TRAFFIC_DIRECTION,
@@ -543,21 +543,21 @@ typedef VOID
 	IN	u4Byte			BitMask,
 	IN	u4Byte			Data
 	);
-typedef u4Byte 
+typedef u4Byte
 (*BFP_BTC_GET_BB_REG)(
 	IN 	PVOID			pBtcContext,
 	IN	u4Byte			RegAddr,
 	IN	u4Byte			BitMask
 	);
 typedef VOID
-(*BFP_BTC_SET_RF_REG)(	
+(*BFP_BTC_SET_RF_REG)(
 	IN 	PVOID			pBtcContext,
 	IN	u1Byte			eRFPath,
 	IN	u4Byte			RegAddr,
 	IN	u4Byte			BitMask,
 	IN	u4Byte			Data
 	);
-typedef u4Byte 
+typedef u4Byte
 (*BFP_BTC_GET_RF_REG)(
 	IN 	PVOID			pBtcContext,
 	IN	u1Byte			eRFPath,
@@ -598,7 +598,7 @@ typedef BOOLEAN
 	IN	u1Byte			txTime,
 	IN	u1Byte			btChnl
 	);
-typedef u2Byte 
+typedef u2Byte
 (*BFP_BTC_GET_BT_REG)(
 	IN 	PVOID			pBtcContext,
 	IN	u1Byte			regType,
@@ -620,17 +620,17 @@ typedef COL_H2C_STATUS
 	IN	u1Byte			h2c_par_len
 	);
 
-typedef u4Byte 
+typedef u4Byte
 (*BFP_BTC_GET_BT_COEX_SUPPORTED_FEATURE)(
 	IN 	PVOID			pBtcContext
 	);
 
-typedef u4Byte 
+typedef u4Byte
 (*BFP_BTC_GET_BT_COEX_SUPPORTED_VERSION)(
 	IN 	PVOID			pBtcContext
 	);
 
-typedef u4Byte 
+typedef u4Byte
 (*BFP_BTC_GET_PHYDM_VERSION)(
 	IN 	PVOID			pBtcContext
 	);
@@ -775,7 +775,7 @@ extern struct btc_coexist	GLBtCoexist;
 
 BOOLEAN
 EXhalbtcoutsrc_InitlizeVariables(
-	IN	PVOID		Adapter	
+	IN	PVOID		Adapter
 	);
 VOID
 EXhalbtcoutsrc_PowerOnSetting(
diff --git a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c
index 22f793c..b7ff6f6 100644
--- a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c
+++ b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 #include <drv_types.h>
 
@@ -25,7 +25,7 @@
 *                           MPCIE.TXT
 ******************************************************************************/
 
-u1Byte Array_MP_8814A_MPCIE[] = { 
+u1Byte Array_MP_8814A_MPCIE[] = {
 		0xFF,
 		0xFF,
 		0xFF,
diff --git a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h
index 8b51c1b..9b4d7c5 100644
--- a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h
+++ b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 
 
diff --git a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c
index cd80e92..d882d92 100644
--- a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c
+++ b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 #include <drv_types.h>
 
@@ -25,7 +25,7 @@
 *                           MUSB.TXT
 ******************************************************************************/
 
-u1Byte Array_MP_8814A_MUSB[] = { 
+u1Byte Array_MP_8814A_MUSB[] = {
 		0xFF,
 		0xFF,
 		0xFF,
diff --git a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h
index 4262400..be33e37 100644
--- a/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h
+++ b/drivers/net/wireless/rtl8812au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 
 
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/halhwimg.h b/drivers/net/wireless/rtl8812au/hal/phydm/halhwimg.h
index 108f715..f072094 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/halhwimg.h
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/halhwimg.h
@@ -29,7 +29,7 @@
 	#define		RTL8188EE_HWIMG_SUPPORT					0
 	#define		RTL8188EU_HWIMG_SUPPORT					0
 	#define		RTL8188ES_HWIMG_SUPPORT					0
-	
+
 	#elif (DEV_BUS_TYPE == RT_USB_INTERFACE)
 	// For 92C
 	#define 	RTL8192CE_HWIMG_SUPPORT 				0
@@ -52,7 +52,7 @@
 	#define		RTL8188EE_HWIMG_SUPPORT					0
 	#define		RTL8188EU_HWIMG_SUPPORT					0
 	#define		RTL8188ES_HWIMG_SUPPORT					0
-	
+
 	#elif (DEV_BUS_TYPE == RT_SDIO_INTERFACE)
 	// For 92C
 	#define 	RTL8192CE_HWIMG_SUPPORT 				0
@@ -102,7 +102,7 @@
 	#define		RTL8188EU_HWIMG_SUPPORT					0
 	#define		RTL8188ES_HWIMG_SUPPORT					0
 
-	#else 
+	#else
 
 	// For 8723
 	#define		RTL8723E_HWIMG_SUPPORT					1
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/halphyrf_ce.c b/drivers/net/wireless/rtl8812au/hal/phydm/halphyrf_ce.c
index fa93177..400e3ca 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/halphyrf_ce.c
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/halphyrf_ce.c
@@ -46,7 +46,7 @@ void ConfigureTxpowerTrack(
 #if RTL8192E_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8192E)
 		ConfigureTxpowerTrack_8192E(pConfig);
-#endif	
+#endif
 #if RTL8821A_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8821)
 		ConfigureTxpowerTrack_8821A(pConfig);
@@ -58,7 +58,7 @@ void ConfigureTxpowerTrack(
 #if RTL8188E_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8188E)
 		ConfigureTxpowerTrack_8188E(pConfig);
-#endif 
+#endif
 
 #if RTL8723B_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8723B)
@@ -78,24 +78,24 @@ void ConfigureTxpowerTrack(
 #if RTL8188F_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8188F)
 		ConfigureTxpowerTrack_8188F(pConfig);
-#endif 
+#endif
 #if RTL8723D_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8723D)
 		ConfigureTxpowerTrack_8723D(pConfig);
-#endif 
+#endif
 #if RTL8822B_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8822B)
 		ConfigureTxpowerTrack_8822B(pConfig);
-#endif 
+#endif
 
 }
 
 //======================================================================
 // <20121113, Kordan> This function should be called when TxAGC changed.
-// Otherwise the previous compensation is gone, because we record the 
+// Otherwise the previous compensation is gone, because we record the
 // delta of temperature between two TxPowerTracking watch dogs.
 //
-// NOTE: If Tx BB swing or Tx scaling is varified during run-time, still 
+// NOTE: If Tx BB swing or Tx scaling is varified during run-time, still
 //       need to call this function.
 //======================================================================
 VOID
@@ -107,13 +107,12 @@ ODM_ClearTxPowerTrackingState(
 	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(pDM_Odm->Adapter);
 	u1Byte 			p = 0;
 	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
-	
+
 	pRFCalibrateInfo->BbSwingIdxCckBase = pRFCalibrateInfo->DefaultCckIndex;
 	pRFCalibrateInfo->BbSwingIdxCck = pRFCalibrateInfo->DefaultCckIndex;
 	pDM_Odm->RFCalibrateInfo.CCK_index = 0;
-	
-	for (p = ODM_RF_PATH_A; p < MAX_RF_PATH; ++p)
-	{
+
+	for (p = ODM_RF_PATH_A; p < MAX_RF_PATH; ++p) {
 		pRFCalibrateInfo->BbSwingIdxOfdmBase[p] = pRFCalibrateInfo->DefaultOfdmIndex;
 		pRFCalibrateInfo->BbSwingIdxOfdm[p] = pRFCalibrateInfo->DefaultOfdmIndex;
 		pRFCalibrateInfo->OFDM_index[p] = pRFCalibrateInfo->DefaultOfdmIndex;
@@ -123,10 +122,10 @@ ODM_ClearTxPowerTrackingState(
 		pRFCalibrateInfo->DeltaPowerIndexLast[p] = 0;
 
 		pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = 0;    /* Initial Mix mode power tracking*/
-		pRFCalibrateInfo->Remnant_OFDMSwingIdx[p] = 0;			  
+		pRFCalibrateInfo->Remnant_OFDMSwingIdx[p] = 0;
 		pRFCalibrateInfo->KfreeOffset[p] = 0;
 	}
-	
+
 	pRFCalibrateInfo->Modify_TxAGC_Flag_PathA = FALSE;       /*Initial at Modify Tx Scaling Mode*/
 	pRFCalibrateInfo->Modify_TxAGC_Flag_PathB = FALSE;       /*Initial at Modify Tx Scaling Mode*/
 	pRFCalibrateInfo->Modify_TxAGC_Flag_PathC = FALSE;       /*Initial at Modify Tx Scaling Mode*/
@@ -163,7 +162,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 	u1Byte			ThermalValue = 0, delta, delta_LCK, delta_IQK, p = 0, i = 0;
 	s1Byte			diff_DPK[4] = {0};
 	u1Byte			ThermalValue_AVG_count = 0;
-	u4Byte			ThermalValue_AVG = 0, RegC80, RegCd0, RegCd4, Regab4;	
+	u4Byte			ThermalValue_AVG = 0, RegC80, RegCd0, RegCd4, Regab4;
 
 	u1Byte			OFDM_min_index = 0;  // OFDM BB Swing should be less than +3.0dB, which is required by Arthur
 	u1Byte			Indexforchannel = 0; // GetRightChnlPlaceforIQK(pHalData->CurrentChannel)
@@ -196,10 +195,10 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 	if (pDM_Odm->SupportICType & ODM_RTL8814A)	/*for 8814 path C & D*/
 		(*c.GetDeltaSwingTable8814only)(pDM_Odm, (pu1Byte *)&deltaSwingTableIdx_TUP_C, (pu1Byte *)&deltaSwingTableIdx_TDOWN_C,
 			(pu1Byte *)&deltaSwingTableIdx_TUP_D, (pu1Byte *)&deltaSwingTableIdx_TDOWN_D);
-	
+
 	if (pDM_Odm->SupportICType & (ODM_RTL8703B | ODM_RTL8723D))	/*for Xtal Offset*/
 		(*c.GetDeltaSwingXtalTable)(pDM_Odm, (ps1Byte *)&deltaSwingTableXtal_UP, (ps1Byte *)&deltaSwingTableXtal_DOWN);
-	
+
 	pRFCalibrateInfo->TXPowerTrackingCallbackCnt++;	/*cosa add for debug*/
 	pRFCalibrateInfo->bTXPowerTrackingInit = TRUE;
 
@@ -216,15 +215,15 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 	#endif
 
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-		("===>ODM_TXPowerTrackingCallback_ThermalMeter\n pRFCalibrateInfo->BbSwingIdxCckBase: %d, pRFCalibrateInfo->BbSwingIdxOfdmBase[A]: %d, pRFCalibrateInfo->DefaultOfdmIndex: %d\n", 
+		("===>ODM_TXPowerTrackingCallback_ThermalMeter\n pRFCalibrateInfo->BbSwingIdxCckBase: %d, pRFCalibrateInfo->BbSwingIdxOfdmBase[A]: %d, pRFCalibrateInfo->DefaultOfdmIndex: %d\n",
 		pRFCalibrateInfo->BbSwingIdxCckBase, pRFCalibrateInfo->BbSwingIdxOfdmBase[ODM_RF_PATH_A], pRFCalibrateInfo->DefaultOfdmIndex));
 
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 		("pRFCalibrateInfo->TxPowerTrackControl=%d,  pHalData->EEPROMThermalMeter %d\n", pRFCalibrateInfo->TxPowerTrackControl,  pHalData->EEPROMThermalMeter));
 	ThermalValue = (u1Byte)ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, c.ThermalRegAddr, 0xfc00);	//0x42: RF Reg[15:10] 88E
 
 	/*add log by zhao he, check c80/c94/c14/ca0 value*/
-	if (pDM_Odm->SupportICType == ODM_RTL8723D) {	
+	if (pDM_Odm->SupportICType == ODM_RTL8723D) {
 		RegC80 = ODM_GetBBReg(pDM_Odm, 0xc80, bMaskDWord);
 		RegCd0 = ODM_GetBBReg(pDM_Odm, 0xcd0, bMaskDWord);
 		RegCd4 = ODM_GetBBReg(pDM_Odm, 0xcd4, bMaskDWord);
@@ -238,31 +237,30 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 
 	/*4 3. Initialize ThermalValues of RFCalibrateInfo*/
 
-	if (pRFCalibrateInfo->bReloadtxpowerindex)
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("reload ofdm index for band switch\n"));				
+	if (pRFCalibrateInfo->bReloadtxpowerindex) {
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("reload ofdm index for band switch\n"));
+	}
 
 	/*4 4. Calculate average thermal meter*/
-	
+
 	pRFCalibrateInfo->ThermalValue_AVG[pRFCalibrateInfo->ThermalValue_AVG_index] = ThermalValue;
 	pRFCalibrateInfo->ThermalValue_AVG_index++;
 	if (pRFCalibrateInfo->ThermalValue_AVG_index == c.AverageThermalNum)   /*Average times =  c.AverageThermalNum*/
 		pRFCalibrateInfo->ThermalValue_AVG_index = 0;
 
-	for(i = 0; i < c.AverageThermalNum; i++)
-	{
+	for (i = 0; i < c.AverageThermalNum; i++) {
 		if (pRFCalibrateInfo->ThermalValue_AVG[i]) {
 			ThermalValue_AVG += pRFCalibrateInfo->ThermalValue_AVG[i];
 			ThermalValue_AVG_count++;
 		}
 	}
 
-	if(ThermalValue_AVG_count)               //Calculate Average ThermalValue after average enough times
-	{
+	if (ThermalValue_AVG_count) { //Calculate Average ThermalValue after average enough times
 		ThermalValue = (u1Byte)(ThermalValue_AVG / ThermalValue_AVG_count);
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-			("AVG Thermal Meter = 0x%X, EFUSE Thermal Base = 0x%X\n", ThermalValue, pHalData->EEPROMThermalMeter));					
+			("AVG Thermal Meter = 0x%X, EFUSE Thermal Base = 0x%X\n", ThermalValue, pHalData->EEPROMThermalMeter));
 	}
-			
+
 	//4 5. Calculate delta, delta_LCK, delta_IQK.
 
 	//"delta" here is used to determine whether thermal value changes or not.
@@ -275,7 +273,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 		delta_IQK = (ThermalValue > pRFCalibrateInfo->ThermalValue_IQK)?(ThermalValue - pRFCalibrateInfo->ThermalValue_IQK):(pRFCalibrateInfo->ThermalValue_IQK - ThermalValue);
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("no PG, use ThermalValue for IQK\n"));
 	}
-	
+
 	for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
 		diff_DPK[p] = (s1Byte)ThermalValue - (s1Byte)pRFCalibrateInfo->DpkThermal[p];
 
@@ -291,7 +289,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				if (c.PHY_LCCalibrate)
 					(*c.PHY_LCCalibrate)(pDM_Odm);
 			}
-			
+
 			delta_LCK = (ThermalValue > pRFCalibrateInfo->ThermalValue_LCK)?(ThermalValue - pRFCalibrateInfo->ThermalValue_LCK):(pRFCalibrateInfo->ThermalValue_LCK - ThermalValue);
 		}
 
@@ -310,25 +308,24 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 		}
 	}
 
-	/*3 7. If necessary, move the index of swing table to adjust Tx power.*/	
-	
-	if (delta > 0 && pRFCalibrateInfo->TxPowerTrackControl)
-	{
+	/*3 7. If necessary, move the index of swing table to adjust Tx power.*/
+
+	if (delta > 0 && pRFCalibrateInfo->TxPowerTrackControl) {
 		//"delta" here is used to record the absolute value of differrence.
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))			
-	    delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);		
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	    delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);
 #else
-	    delta = (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther)?(ThermalValue - pDM_Odm->priv->pmib->dot11RFEntry.ther):(pDM_Odm->priv->pmib->dot11RFEntry.ther - ThermalValue);		
+	    delta = (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther)?(ThermalValue - pDM_Odm->priv->pmib->dot11RFEntry.ther):(pDM_Odm->priv->pmib->dot11RFEntry.ther - ThermalValue);
 #endif
 		if (delta >= TXPWR_TRACK_TABLE_SIZE)
 			delta = TXPWR_TRACK_TABLE_SIZE - 1;
 
 		/*4 7.1 The Final Power Index = BaseIndex + PowerIndexOffset*/
-		
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))				
-		if(ThermalValue > pHalData->EEPROMThermalMeter) {
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+		if (ThermalValue > pHalData->EEPROMThermalMeter) {
 #else
-		if(ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther) {
+		if (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther) {
 #endif
 
 			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
@@ -336,12 +333,12 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				switch (p) {
 				case ODM_RF_PATH_B:
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("deltaSwingTableIdx_TUP_B[%d] = %d\n", delta, deltaSwingTableIdx_TUP_B[delta])); 
+						("deltaSwingTableIdx_TUP_B[%d] = %d\n", delta, deltaSwingTableIdx_TUP_B[delta]));
 
 					pRFCalibrateInfo->DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_B[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_B[delta];       /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+						("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 
 				case ODM_RF_PATH_C:
@@ -351,7 +348,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 					pRFCalibrateInfo->DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_C[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_C[delta];       /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-							("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+							("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 
 				case ODM_RF_PATH_D:
@@ -361,17 +358,17 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 						pRFCalibrateInfo->DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_D[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_D[delta];       /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+						("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 
 				default:
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 						("deltaSwingTableIdx_TUP_A[%d] = %d\n", delta, deltaSwingTableIdx_TUP_A[delta]));
 
 					pRFCalibrateInfo->DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_A[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_A[delta];        /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-							("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+							("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 				}
 			}
@@ -379,7 +376,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 			if (pDM_Odm->SupportICType & (ODM_RTL8703B | ODM_RTL8723D)) {
 				/*Save XtalOffset from Xtal table*/
 				pRFCalibrateInfo->XtalOffsetLast = pRFCalibrateInfo->XtalOffset;	/*recording last Xtal offset*/
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 								("[Xtal] deltaSwingTableXtal_UP[%d] = %d\n", delta, deltaSwingTableXtal_UP[delta]));
 				pRFCalibrateInfo->XtalOffset = deltaSwingTableXtal_UP[delta];
 
@@ -388,7 +385,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				else
 					XtalOffsetEanble = 1;
 			}
-		
+
 		} else {
 			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
 				pRFCalibrateInfo->DeltaPowerIndexLast[p] = pRFCalibrateInfo->DeltaPowerIndex[p];	/*recording poer index offset*/
@@ -396,46 +393,46 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				switch (p) {
 				case ODM_RF_PATH_B:
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("deltaSwingTableIdx_TDOWN_B[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_B[delta]));  
+						("deltaSwingTableIdx_TDOWN_B[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_B[delta]));
 					pRFCalibrateInfo->DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_B[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_B[delta];        /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p])); 
+						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 
 				case ODM_RF_PATH_C:
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("deltaSwingTableIdx_TDOWN_C[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_C[delta]));  
+						("deltaSwingTableIdx_TDOWN_C[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_C[delta]));
 					pRFCalibrateInfo->DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_C[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_C[delta];        /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));   
+						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 
 				case ODM_RF_PATH_D:
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("deltaSwingTableIdx_TDOWN_D[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_D[delta]));  
+						("deltaSwingTableIdx_TDOWN_D[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_D[delta]));
 					pRFCalibrateInfo->DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_D[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_D[delta];        /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 
 				default:
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("deltaSwingTableIdx_TDOWN_A[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_A[delta]));  
+						("deltaSwingTableIdx_TDOWN_A[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_A[delta]));
 					pRFCalibrateInfo->DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_A[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_A[delta];        /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
-				}	
+				}
 			}
 
 			if (pDM_Odm->SupportICType & (ODM_RTL8703B | ODM_RTL8723D)) {
 				/*Save XtalOffset from Xtal table*/
 				pRFCalibrateInfo->XtalOffsetLast = pRFCalibrateInfo->XtalOffset;	/*recording last Xtal offset*/
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 								("[Xtal] deltaSwingTableXtal_DOWN[%d] = %d\n", delta, deltaSwingTableXtal_DOWN[delta]));
 				pRFCalibrateInfo->XtalOffset = deltaSwingTableXtal_DOWN[delta];
 
@@ -446,10 +443,10 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 			}
 
 		}
-		
+
 		for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-				("\n\n=========================== [Path-%d] Calculating PowerIndexOffset===========================\n", p));  
+				("\n\n=========================== [Path-%d] Calculating PowerIndexOffset===========================\n", p));
 
 			if (pRFCalibrateInfo->DeltaPowerIndex[p] == pRFCalibrateInfo->DeltaPowerIndexLast[p])         /*If Thermal value changes but lookup table value still the same*/
 				pRFCalibrateInfo->PowerIndexOffset[p] = 0;
@@ -458,12 +455,12 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 				("[Path-%d] PowerIndexOffset(%d) = DeltaPowerIndex(%d) - DeltaPowerIndexLast(%d)\n", p, pRFCalibrateInfo->PowerIndexOffset[p], pRFCalibrateInfo->DeltaPowerIndex[p], pRFCalibrateInfo->DeltaPowerIndexLast[p]));
-		
+
 			pRFCalibrateInfo->OFDM_index[p] = pRFCalibrateInfo->BbSwingIdxOfdmBase[p] + pRFCalibrateInfo->PowerIndexOffset[p];
 			pRFCalibrateInfo->CCK_index = pRFCalibrateInfo->BbSwingIdxCckBase + pRFCalibrateInfo->PowerIndexOffset[p];
 
-			pRFCalibrateInfo->BbSwingIdxCck = pRFCalibrateInfo->CCK_index;	
-			pRFCalibrateInfo->BbSwingIdxOfdm[p] = pRFCalibrateInfo->OFDM_index[p];	
+			pRFCalibrateInfo->BbSwingIdxCck = pRFCalibrateInfo->CCK_index;
+			pRFCalibrateInfo->BbSwingIdxOfdm[p] = pRFCalibrateInfo->OFDM_index[p];
 
 			/*************Print BB Swing Base and Index Offset*************/
 
@@ -473,15 +470,15 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				("The 'OFDM' final index(%d) = BaseIndex[%d](%d) + PowerIndexOffset(%d)\n", pRFCalibrateInfo->BbSwingIdxOfdm[p], p, pRFCalibrateInfo->BbSwingIdxOfdmBase[p], pRFCalibrateInfo->PowerIndexOffset[p]));
 
 			/*4 7.1 Handle boundary conditions of index.*/
-		
+
 			if (pRFCalibrateInfo->OFDM_index[p] > c.SwingTableSize_OFDM-1)
 				pRFCalibrateInfo->OFDM_index[p] = c.SwingTableSize_OFDM-1;
 			else if (pRFCalibrateInfo->OFDM_index[p] <= OFDM_min_index)
 				pRFCalibrateInfo->OFDM_index[p] = OFDM_min_index;
 		}
-		
+
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-			("\n\n========================================================================================================\n"));  
+			("\n\n========================================================================================================\n"));
 
 		if (pRFCalibrateInfo->CCK_index > c.SwingTableSize_CCK-1)
 			pRFCalibrateInfo->CCK_index = c.SwingTableSize_CCK-1;
@@ -489,7 +486,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 			pRFCalibrateInfo->CCK_index = 0;
 	} else {
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-			("The thermal meter is unchanged or TxPowerTracking OFF(%d): ThermalValue: %d , pRFCalibrateInfo->ThermalValue: %d\n", 
+			("The thermal meter is unchanged or TxPowerTracking OFF(%d): ThermalValue: %d , pRFCalibrateInfo->ThermalValue: %d\n",
 			pRFCalibrateInfo->TxPowerTrackControl, ThermalValue, pRFCalibrateInfo->ThermalValue));
 
 		for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
@@ -497,7 +494,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 	}
 
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-		("TxPowerTracking: [CCK] Swing Current Index: %d, Swing Base Index: %d\n", 
+		("TxPowerTracking: [CCK] Swing Current Index: %d, Swing Base Index: %d\n",
 			pRFCalibrateInfo->CCK_index, pRFCalibrateInfo->BbSwingIdxCckBase));       /*Print Swing base & current*/
 
 	for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
@@ -508,7 +505,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 
 	if ((pDM_Odm->SupportICType & ODM_RTL8814A)) {
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("PowerTrackingType=%d\n", PowerTrackingType));
-		
+
 		if (PowerTrackingType == 0) {
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("**********Enter POWER Tracking MIX_MODE**********\n"));
 			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
@@ -527,15 +524,15 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, TSSI_MODE, p, 0);
 		}
 		pRFCalibrateInfo->ThermalValue = ThermalValue;         /*Record last Power Tracking Thermal Value*/
-	
+
 	} else if ((pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_A] != 0 ||
 		pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_B] != 0 ||
 		pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_C] != 0 ||
-		pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_D] != 0) && 
+		pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_D] != 0) &&
 		pRFCalibrateInfo->TxPowerTrackControl && (pHalData->EEPROMThermalMeter != 0xff)) {
 		//4 7.2 Configure the Swing Table to adjust Tx Power.
-		
-		pRFCalibrateInfo->bTxPowerChanged = TRUE;	/*Always TRUE after Tx Power is adjusted by power tracking.*/			
+
+		pRFCalibrateInfo->bTxPowerChanged = TRUE;	/*Always TRUE after Tx Power is adjusted by power tracking.*/
 		//
 		// 2012/04/23 MH According to Luke's suggestion, we can not write BB digital
 		// to increase TX power. Otherwise, EVM will be bad.
@@ -544,14 +541,14 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 		if (ThermalValue > pRFCalibrateInfo->ThermalValue) {
 			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-					("Temperature Increasing(%d): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n", 
-					p, pRFCalibrateInfo->PowerIndexOffset[p], delta, ThermalValue, pHalData->EEPROMThermalMeter, pRFCalibrateInfo->ThermalValue));	
+					("Temperature Increasing(%d): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n",
+					p, pRFCalibrateInfo->PowerIndexOffset[p], delta, ThermalValue, pHalData->EEPROMThermalMeter, pRFCalibrateInfo->ThermalValue));
 			}
 		} else if (ThermalValue < pRFCalibrateInfo->ThermalValue) {	/*Low temperature*/
 			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 					("Temperature Decreasing(%d): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n",
-					p, pRFCalibrateInfo->PowerIndexOffset[p], delta, ThermalValue, pHalData->EEPROMThermalMeter, pRFCalibrateInfo->ThermalValue));				
+					p, pRFCalibrateInfo->PowerIndexOffset[p], delta, ThermalValue, pHalData->EEPROMThermalMeter, pRFCalibrateInfo->ThermalValue));
 			}
 		}
 
@@ -562,7 +559,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 #endif
 		{
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-				("Temperature(%d) higher than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));			
+				("Temperature(%d) higher than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));
 
 			if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8821 ||
 				pDM_Odm->SupportICType == ODM_RTL8812 || pDM_Odm->SupportICType == ODM_RTL8723B || pDM_Odm->SupportICType == ODM_RTL8814A ||
@@ -576,9 +573,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
 					(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, BBSWING, p, Indexforchannel);
 			}
-		}
-		else
-		{
+		} else {
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 				("Temperature(%d) lower than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));
 
@@ -594,7 +589,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
 					(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, BBSWING, p, Indexforchannel);
 			}
-			
+
 		}
 
 		pRFCalibrateInfo->BbSwingIdxCckBase = pRFCalibrateInfo->BbSwingIdxCck;    /*Record last time Power Tracking result as base.*/
@@ -603,7 +598,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 			("pRFCalibrateInfo->ThermalValue = %d ThermalValue= %d\n", pRFCalibrateInfo->ThermalValue, ThermalValue));
-		
+
 		pRFCalibrateInfo->ThermalValue = ThermalValue;         /*Record last Power Tracking Thermal Value*/
 
 	}
@@ -621,11 +616,11 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 			if (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther) {
 #endif
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-					("Temperature(%d) higher than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));			
+					("Temperature(%d) higher than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));
 				(*c.ODM_TxXtalTrackSetXtal)(pDM_Odm);
 			} else {
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-					("Temperature(%d) lower than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));			
+					("Temperature(%d) lower than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));
 				(*c.ODM_TxXtalTrackSetXtal)(pDM_Odm);
 			}
 		}
@@ -638,17 +633,17 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 		/*Delta temperature is equal to or larger than 20 centigrade (When threshold is 8).*/
 		if (delta_IQK >= c.Threshold_IQK) {
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("delta_IQK(%d) >= Threshold_IQK(%d)\n", delta_IQK, c.Threshold_IQK));
-			if (!pRFCalibrateInfo->bIQKInProgress) 
+			if (!pRFCalibrateInfo->bIQKInProgress)
 				(*c.DoIQK)(pDM_Odm, delta_IQK, ThermalValue, 8);
 		}
 	}
 	if (pRFCalibrateInfo->DpkThermal[ODM_RF_PATH_A] != 0) {
-		if (diff_DPK[ODM_RF_PATH_A] >= c.Threshold_DPK) { 
+		if (diff_DPK[ODM_RF_PATH_A] >= c.Threshold_DPK) {
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0xcc4, BIT14|BIT13|BIT12|BIT11|BIT10, (diff_DPK[ODM_RF_PATH_A] / c.Threshold_DPK));
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
 		} else if ((diff_DPK[ODM_RF_PATH_A] <= -1 * c.Threshold_DPK)) {
-			s4Byte value = 0x20 + (diff_DPK[ODM_RF_PATH_A] / c.Threshold_DPK);	
+			s4Byte value = 0x20 + (diff_DPK[ODM_RF_PATH_A] / c.Threshold_DPK);
 
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0xcc4, BIT14|BIT13|BIT12|BIT11|BIT10, value);
@@ -656,16 +651,16 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 		} else {
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0xcc4, BIT14|BIT13|BIT12|BIT11|BIT10, 0);
-			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);	
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
 		}
 	}
 	if (pRFCalibrateInfo->DpkThermal[ODM_RF_PATH_B] != 0) {
-		if (diff_DPK[ODM_RF_PATH_B] >= c.Threshold_DPK) { 
+		if (diff_DPK[ODM_RF_PATH_B] >= c.Threshold_DPK) {
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0xec4, BIT14|BIT13|BIT12|BIT11|BIT10, (diff_DPK[ODM_RF_PATH_B] / c.Threshold_DPK));
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
 		} else if ((diff_DPK[ODM_RF_PATH_B] <= -1 * c.Threshold_DPK)) {
-			s4Byte value = 0x20 + (diff_DPK[ODM_RF_PATH_B] / c.Threshold_DPK);	
+			s4Byte value = 0x20 + (diff_DPK[ODM_RF_PATH_B] / c.Threshold_DPK);
 
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0xec4, BIT14|BIT13|BIT12|BIT11|BIT10, value);
@@ -673,14 +668,14 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 		} else {
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0xec4, BIT14|BIT13|BIT12|BIT11|BIT10, 0);
-			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);	
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
 		}
 	}
 
-#endif		
-			
+#endif
+
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("<===ODM_TXPowerTrackingCallback_ThermalMeter\n"));
-	
+
 	pRFCalibrateInfo->TXPowercount = 0;
 }
 
@@ -700,21 +695,18 @@ ODM_ResetIQKResult(
 #if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
 u1Byte ODM_GetRightChnlPlaceforIQK(u1Byte chnl)
 {
-	u1Byte	channel_all[ODM_TARGET_CHNL_NUM_2G_5G] = 
+	u1Byte	channel_all[ODM_TARGET_CHNL_NUM_2G_5G] =
 	{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
 	u1Byte	place = chnl;
 
-	
-	if(chnl > 14)
-	{
-		for(place = 14; place<sizeof(channel_all); place++)
-		{
-			if(channel_all[place] == chnl)
-			{
+
+	if (chnl > 14) {
+		for (place = 14; place<sizeof(channel_all); place++) {
+			if (channel_all[place] == chnl) {
 				return place-13;
 			}
 		}
-	}	
+	}
 	return 0;
 
 }
@@ -722,21 +714,21 @@ u1Byte ODM_GetRightChnlPlaceforIQK(u1Byte chnl)
 
 VOID
 odm_IQCalibrate(
-		IN	PDM_ODM_T	pDM_Odm 
+		IN	PDM_ODM_T	pDM_Odm
 		)
 {
 	PADAPTER	Adapter = pDM_Odm->Adapter;
 
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	if (*pDM_Odm->pIsFcsModeEnable)
 		return;
 #endif
-	
+
 #if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
 	if (IS_HARDWARE_TYPE_8812AU(Adapter))
 		return;
 #endif
-	
+
 	if (pDM_Odm->bLinked) {
 		if ((*pDM_Odm->pChannel != pDM_Odm->preChannel) && (!*pDM_Odm->pbScanInProcess)) {
 			pDM_Odm->preChannel = *pDM_Odm->pChannel;
@@ -745,24 +737,24 @@ odm_IQCalibrate(
 
 		if (pDM_Odm->LinkedInterval < 3)
 			pDM_Odm->LinkedInterval++;
-		
+
 		if (pDM_Odm->LinkedInterval == 2) {
 			if (IS_HARDWARE_TYPE_8814A(Adapter)) {
-				#if (RTL8814A_SUPPORT == 1)	
+				#if (RTL8814A_SUPPORT == 1)
 				PHY_IQCalibrate_8814A(pDM_Odm, FALSE);
 				#endif
-			} 
-			
+			}
+
 			#if (RTL8822B_SUPPORT == 1)
 			else if (IS_HARDWARE_TYPE_8822B(Adapter))
 				PHY_IQCalibrate_8822B(pDM_Odm, FALSE);
 			#endif
-			
+
 			#if (RTL8821C_SUPPORT == 1)
 			else if (IS_HARDWARE_TYPE_8821C(Adapter))
 				PHY_IQCalibrate_8821C(pDM_Odm, FALSE);
 			#endif
-			
+
 			#if (RTL8821A_SUPPORT == 1)
 			else if (IS_HARDWARE_TYPE_8821(Adapter))
 				PHY_IQCalibrate_8821A(pDM_Odm, FALSE);
@@ -778,14 +770,14 @@ void phydm_rf_init(IN	PVOID		pDM_VOID)
 	odm_TXPowerTrackingInit(pDM_Odm);
 
 #if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
-	ODM_ClearTxPowerTrackingState(pDM_Odm);	
+	ODM_ClearTxPowerTrackingState(pDM_Odm);
 #endif
 
 #if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
-#if (RTL8814A_SUPPORT == 1)		
+#if (RTL8814A_SUPPORT == 1)
 	if (pDM_Odm->SupportICType & ODM_RTL8814A)
 		PHY_IQCalibrate_8814A_Init(pDM_Odm);
-#endif	
+#endif
 #endif
 
 }
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/mp_precomp.h b/drivers/net/wireless/rtl8812au/hal/phydm/mp_precomp.h
index 2ae8110..322bce0 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/mp_precomp.h
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/mp_precomp.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/phydm.c b/drivers/net/wireless/rtl8812au/hal/phydm/phydm.c
index e6a6af2..fd4fd8e 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/phydm.c
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/phydm.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -76,21 +76,19 @@ ODM_PWdB_Conversion(
 	s4Byte Y, integer = 0, decimal = 0;
 	u4Byte i;
 
-	if(X == 0)
+	if (X == 0)
 		X = 1; // log2(x), x can't be 0
 
-	for(i = (TotalBit-1); i > 0; i--)
-	{
-		if(X & BIT(i))
-		{
+	for (i = (TotalBit-1); i > 0; i--) {
+		if (X & BIT(i)) {
 			integer = i;
-			if(i > 0)
-				decimal = (X & BIT(i-1))?2:0; //decimal is 0.5dB*3=1.5dB~=2dB 
+			if (i > 0)
+				decimal = (X & BIT(i-1))?2:0; //decimal is 0.5dB*3=1.5dB~=2dB
 			break;
 		}
 	}
-	
-	Y = 3*(integer-DecimalBit)+decimal; //10*log(x)=3*log2(x), 
+
+	Y = 3*(integer-DecimalBit)+decimal; //10*log(x)=3*log2(x),
 
 	return Y;
 }
@@ -101,17 +99,17 @@ ODM_SignConversion(
     IN  u4Byte TotalBit
     )
 {
-	if(value&BIT(TotalBit-1))
+	if (value&BIT(TotalBit-1))
 		value -= BIT(TotalBit);
 	return value;
 }
 
 void
-phydm_seq_sorting( 
+phydm_seq_sorting(
 	IN		PVOID	pDM_VOID,
 	IN OUT	u4Byte	*p_value,
 	IN OUT	u4Byte	*rank_idx,
-	IN OUT	u4Byte	*p_idx_out,	
+	IN OUT	u4Byte	*p_idx_out,
 	IN		u1Byte	seq_length
 )
 {
@@ -126,9 +124,9 @@ phydm_seq_sorting(
 	}
 
 	for (i = 0; i < (seq_length - 1); i++) {
-		
+
 		for (j = 0; j < (seq_length - 1 - i); j++) {
-		
+
 			tmp_a = p_value[j];
 			tmp_b = p_value[j+1];
 
@@ -138,20 +136,20 @@ phydm_seq_sorting(
 			if (tmp_a < tmp_b) {
 				p_value[j] = tmp_b;
 				p_value[j+1] = tmp_a;
-				
+
 				rank_idx[j] = tmp_idx_b;
 				rank_idx[j+1] = tmp_idx_a;
 			}
-		}		
+		}
 	}
 
 	for (i = 0; i < seq_length; i++) {
 		p_idx_out[rank_idx[i]] = i+1;
 		/**/
 	}
-	
 
-	
+
+
 }
 
 VOID
@@ -180,7 +178,7 @@ ODM_InitMpDriverStatus(
 	prtl8192cd_priv	 priv = pDM_Odm->priv;
 
 	pDM_Odm->mp_mode = (BOOLEAN)priv->pshare->rf_ft_var.mp_specific;
-	
+
 #endif
 }
 
@@ -223,19 +221,19 @@ PHYDM_InitTRXAntennaSetting(
 	} else if (pDM_Odm->SupportICType & (ODM_RTL8723D | ODM_RTL8821C)) {
 		pDM_Odm->TXAntStatus = 0x1;
 		pDM_Odm->RXAntStatus = 0x1;
-			
+
 	}
 /*#endif*/
 }
 
 void
-phydm_traffic_load_decision( 
+phydm_traffic_load_decision(
 	IN		PVOID	pDM_VOID
 	)
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	
+
 	/*---trafic load decision---*/
 	pDM_Odm->curTxOkCnt =  *(pDM_Odm->pNumTxBytesUnicast) - pDM_Odm->lastTxOkCnt;
 	pDM_Odm->curRxOkCnt =  *(pDM_Odm->pNumRxBytesUnicast) - pDM_Odm->lastRxOkCnt;
@@ -249,25 +247,25 @@ phydm_traffic_load_decision(
 	pDM_Odm->tx_tp = ((pDM_Odm->tx_tp)>>1) + (u4Byte)(((pDM_Odm->curTxOkCnt)>>18)>>1); /* <<3(8bit), >>20(10^6,M), >>1(2sec)*/
 	pDM_Odm->rx_tp = ((pDM_Odm->rx_tp)>>1) + (u4Byte)(((pDM_Odm->curRxOkCnt)>>18)>>1); /* <<3(8bit), >>20(10^6,M), >>1(2sec)*/
 	#endif
-	pDM_Odm->total_tp = pDM_Odm->tx_tp + pDM_Odm->rx_tp; 
-	
+	pDM_Odm->total_tp = pDM_Odm->tx_tp + pDM_Odm->rx_tp;
+
 
 	pDM_Odm->pre_TrafficLoad = pDM_Odm->TrafficLoad;
-	
+
 	if (pDM_Odm->curTxOkCnt > 1875000 || pDM_Odm->curRxOkCnt > 1875000) {		/* ( 1.875M * 8bit ) / 2sec= 7.5M bits /sec )*/
-	
+
 		pDM_Odm->TrafficLoad = TRAFFIC_HIGH;
 		/**/
 	} else if (pDM_Odm->curTxOkCnt > 500000 || pDM_Odm->curRxOkCnt > 500000) { /*( 0.5M * 8bit ) / 2sec =  2M bits /sec )*/
-	
+
 		pDM_Odm->TrafficLoad = TRAFFIC_MID;
 		/**/
 	} else if (pDM_Odm->curTxOkCnt > 100000 || pDM_Odm->curRxOkCnt > 100000)  { /*( 0.1M * 8bit ) / 2sec =  0.4M bits /sec )*/
-	
+
 		pDM_Odm->TrafficLoad = TRAFFIC_LOW;
 		/**/
 	} else {
-	
+
 		pDM_Odm->TrafficLoad = TRAFFIC_ULTRA_LOW;
 		/**/
 	}
@@ -283,7 +281,7 @@ phydm_config_ofdm_tx_path(
 
 	#if (RTL8192E_SUPPORT == 1)
 	if (pDM_Odm->SupportICType & (ODM_RTL8192E)) {
-		
+
 		if (path == PHYDM_A) {
 			ODM_SetBBReg(pDM_Odm, 0x90c , bMaskDWord, 0x81321311);
 			/**/
@@ -294,8 +292,8 @@ phydm_config_ofdm_tx_path(
 			ODM_SetBBReg(pDM_Odm, 0x90c , bMaskDWord, 0x83321333);
 			/**/
 		}
-		
-		
+
+
 	}
 	#endif
 }
@@ -310,7 +308,7 @@ phydm_config_ofdm_rx_path(
 
 	#if (RTL8192E_SUPPORT == 1)
 	if (pDM_Odm->SupportICType & (ODM_RTL8192E)) {
-		
+
 		if (path == PHYDM_A) {
 			ofdm_rx_path = 1;
 			/**/
@@ -321,7 +319,7 @@ phydm_config_ofdm_rx_path(
 			ofdm_rx_path = 3;
 			/**/
 		}
-		
+
 		ODM_SetBBReg(pDM_Odm, 0xC04 , 0xff, (((ofdm_rx_path)<<4)|ofdm_rx_path));
 		ODM_SetBBReg(pDM_Odm, 0xD04 , 0xf, ofdm_rx_path);
 	}
@@ -335,7 +333,7 @@ phydm_config_cck_rx_antenna_init(
 {
 	#if (RTL8192E_SUPPORT == 1)
 	if (pDM_Odm->SupportICType & (ODM_RTL8192E)) {
-	
+
 		/*CCK 2R CCA parameters*/
 		ODM_SetBBReg(pDM_Odm, 0xa2c , BIT18, 1); /*enable 2R Rx path*/
 		ODM_SetBBReg(pDM_Odm, 0xa2c , BIT22, 1); /*enable 2R MRC*/
@@ -360,7 +358,7 @@ phydm_config_cck_rx_path(
 
 	#if (RTL8192E_SUPPORT == 1)
 	if (pDM_Odm->SupportICType & (ODM_RTL8192E)) {
-		
+
 		if (path == PHYDM_A) {
 			path_div_select = 0;
 			cck_1_path = 0;
@@ -368,21 +366,21 @@ phydm_config_cck_rx_path(
 		} else if (path == PHYDM_B) {
 			path_div_select = 0;
 			cck_1_path = 1;
-			cck_2_path = 1;			
+			cck_2_path = 1;
 		} else  if (path == PHYDM_AB) {
-		
+
 			if (path_div_en == CCA_PATHDIV_ENABLE)
 				path_div_select = 1;
-			
+
 			cck_1_path = 0;
-			cck_2_path = 1;	
-			
+			cck_2_path = 1;
+
 		}
-		
+
 		ODM_SetBBReg(pDM_Odm, 0xa04 , (BIT27|BIT26), cck_1_path);
 		ODM_SetBBReg(pDM_Odm, 0xa04 , (BIT25|BIT24), cck_2_path);
 		ODM_SetBBReg(pDM_Odm, 0xa74 , BIT8, path_div_select);
-		
+
 	}
 	#endif
 }
@@ -403,7 +401,7 @@ phydm_config_trx_path(
 
 	/* CCK */
 	if (dm_value[0] == 0) {
-		
+
 		if (dm_value[1] == 1) { /*TX*/
 			if (dm_value[2] == 1)
 				ODM_SetBBReg(pDM_Odm, 0xa04, 0xf0000000, 0x8);
@@ -412,9 +410,9 @@ phydm_config_trx_path(
 			else if (dm_value[2] == 3)
 				ODM_SetBBReg(pDM_Odm, 0xa04, 0xf0000000, 0xc);
 		} else if (dm_value[1] == 2) { /*RX*/
-		
+
 			phydm_config_cck_rx_antenna_init(pDM_Odm);
-			
+
 			if (dm_value[2] == 1) {
 				phydm_config_cck_rx_path(pDM_Odm, PHYDM_A, CCA_PATHDIV_DISABLE);
 			} else  if (dm_value[2] == 2) {
@@ -426,7 +424,7 @@ phydm_config_trx_path(
 					phydm_config_cck_rx_path(pDM_Odm, PHYDM_B, CCA_PATHDIV_DISABLE);
 			}
 		}
-	} 
+	}
 	/* OFDM */
 	else if (dm_value[0] == 1) {
 
@@ -447,7 +445,7 @@ phydm_config_trx_path(
 		(dm_value[2] & 0x4)?"C":"",
 		(dm_value[2] & 0x8)?"D":""
 		));
-		
+
 }
 
 VOID
@@ -460,19 +458,17 @@ phydm_Init_cck_setting(
 	pDM_Odm->bCckHighPower = (BOOLEAN) ODM_GetBBReg(pDM_Odm, ODM_REG(CCK_RPT_FORMAT,pDM_Odm), ODM_BIT(CCK_RPT_FORMAT,pDM_Odm));
 
 	#if (RTL8192E_SUPPORT == 1)
-	if(pDM_Odm->SupportICType & (ODM_RTL8192E))
-	{
+	if (pDM_Odm->SupportICType & (ODM_RTL8192E)) {
 		#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 		phydm_config_cck_rx_antenna_init(pDM_Odm);
 		phydm_config_cck_rx_path(pDM_Odm, PHYDM_A, CCA_PATHDIV_DISABLE);
 		#endif
-	
+
 		/* 0x824[9] = 0x82C[9] = 0xA80[7]  those registers setting should be equal or CCK RSSI report may be incorrect */
 		value_824 = ODM_GetBBReg(pDM_Odm, 0x824, BIT9);
 		value_82c = ODM_GetBBReg(pDM_Odm, 0x82c, BIT9);
-		
-		if(value_824 != value_82c)
-		{
+
+		if (value_824 != value_82c) {
 			ODM_SetBBReg(pDM_Odm, 0x82c , BIT9, value_824);
 		}
 		ODM_SetBBReg(pDM_Odm, 0xa80 , BIT7, value_824);
@@ -481,19 +477,19 @@ phydm_Init_cck_setting(
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("cck_agc_report_type = (( %d )), ExtLNAGain = (( %d ))\n", pDM_Odm->cck_agc_report_type, pDM_Odm->ExtLNAGain));
 	}
 	#endif
-	
+
 #if ((RTL8703B_SUPPORT == 1) || (RTL8723D_SUPPORT == 1))
 	if (pDM_Odm->SupportICType & (ODM_RTL8703B|ODM_RTL8723D)) {
 
 		pDM_Odm->cck_agc_report_type = ODM_GetBBReg(pDM_Odm, 0x950, BIT11) ? 1 : 0; /*1: 4bit LNA , 0: 3bit LNA */
-		
+
 		if (pDM_Odm->cck_agc_report_type != 1) {
 			DbgPrint("[Warning] 8703B/8723D CCK should be 4bit LNA, ie. 0x950[11] = 1\n");
 			/**/
 		}
 	}
 #endif
-	
+
 #if ((RTL8723D_SUPPORT == 1) || (RTL8822B_SUPPORT == 1) || (RTL8197F_SUPPORT == 1))
 
 	if (pDM_Odm->SupportICType & (ODM_RTL8723D|ODM_RTL8822B|ODM_RTL8197F)) {
@@ -501,7 +497,7 @@ phydm_Init_cck_setting(
 	} else
 #endif
 		pDM_Odm->cck_new_agc = FALSE;
-	
+
 }
 
 VOID
@@ -535,7 +531,7 @@ odm_CommonInfoSelfInit(
 {
 	phydm_Init_cck_setting(pDM_Odm);
 	pDM_Odm->RFPathRxEnable = (u1Byte) ODM_GetBBReg(pDM_Odm, ODM_REG(BB_RX_PATH,pDM_Odm), ODM_BIT(BB_RX_PATH,pDM_Odm));
-#if (DM_ODM_SUPPORT_TYPE != ODM_CE)	
+#if (DM_ODM_SUPPORT_TYPE != ODM_CE)
 	pDM_Odm->pbNet_closed = &pDM_Odm->BOOLEAN_temp;
 #endif
 
@@ -559,7 +555,7 @@ odm_CommonInfoSelfInit(
 	pDM_Odm->TrafficLoad = TRAFFIC_LOW;
 
 	pDM_Odm->nbi_set_result = 0;
-	
+
 }
 
 VOID
@@ -602,8 +598,7 @@ odm_CommonInfoSelfUpdate(
 
 /* THis variable cannot be used because it is wrong*/
 #if (DM_ODM_SUPPORT_TYPE == ODM_AP)
-	if (*(pDM_Odm->pBandWidth) == ODM_BW40M)
-	{
+	if (*(pDM_Odm->pBandWidth) == ODM_BW40M) {
 		if (*(pDM_Odm->pSecChOffset) == 1)
 			pDM_Odm->ControlChannel = *(pDM_Odm->pChannel) + 2;
 		else if (*(pDM_Odm->pSecChOffset) == 2)
@@ -625,14 +620,11 @@ odm_CommonInfoSelfUpdate(
 		pDM_Odm->ControlChannel = *(pDM_Odm->pChannel);
 #endif
 
-	for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
-	{
+	for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++) {
 		pEntry = pDM_Odm->pODM_StaInfo[i];
-		if(IS_STA_VALID(pEntry))
-		{
+		if (IS_STA_VALID(pEntry)) {
 			EntryCnt++;
-			if(EntryCnt==1)
-			{
+			if (EntryCnt==1) {
 				OneEntry_MACID=i;
 			}
 
@@ -640,15 +632,14 @@ odm_CommonInfoSelfUpdate(
 				ma_rx_tp =  (pEntry->rx_byte_cnt_LowMAW)<<3; /*  low moving average RX  TP   ( bit /sec)*/
 
 				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("ClientTP[%d]: ((%d )) bit/sec\n", i, ma_rx_tp));
-				
+
 				if (ma_rx_tp > ACTIVE_TP_THRESHOLD)
 					num_active_client++;
 			#endif
                 }
 	}
-	
-	if(EntryCnt == 1)
-	{
+
+	if (EntryCnt == 1) {
 		pDM_Odm->bOneEntryOnly = TRUE;
 		pDM_Odm->OneEntry_MACID=OneEntry_MACID;
 	}
@@ -657,15 +648,15 @@ odm_CommonInfoSelfUpdate(
 
 	pDM_Odm->pre_number_linked_client = pDM_Odm->number_linked_client;
 	pDM_Odm->pre_number_active_client = pDM_Odm->number_active_client;
-	
+
 	pDM_Odm->number_linked_client = EntryCnt;
-	pDM_Odm->number_active_client = num_active_client;	
+	pDM_Odm->number_active_client = num_active_client;
 
 	/* Update MP driver status*/
 	ODM_UpdateMpDriverStatus(pDM_Odm);
 
 	/*Traffic load information update*/
-	phydm_traffic_load_decision(pDM_Odm);	
+	phydm_traffic_load_decision(pDM_Odm);
 }
 
 VOID
@@ -691,7 +682,7 @@ PhyDM_Get_Structure(
 		case	PHYDM_FALSEALMCNT:
 			pStruct = &FalseAlmCnt;
 		break;
-		
+
 		case	PHYDM_CFOTRACK:
 			pStruct = &DM_CfoTrack;
 		break;
@@ -699,7 +690,7 @@ PhyDM_Get_Structure(
 		case	PHYDM_ADAPTIVITY:
 			pStruct = &(pDM_Odm->Adaptivity);
 		break;
-		
+
 		default:
 		break;
 	}
@@ -709,7 +700,7 @@ PhyDM_Get_Structure(
 		case	PHYDM_FALSEALMCNT:
 			pStruct = &(pDM_Odm->FalseAlmCnt);
 		break;
-		
+
 		case	PHYDM_CFOTRACK:
 			pStruct = &(pDM_Odm->DM_CfoTrack);
 		break;
@@ -717,7 +708,7 @@ PhyDM_Get_Structure(
 		case	PHYDM_ADAPTIVITY:
 			pStruct = &(pDM_Odm->Adaptivity);
 		break;
-		
+
 		default:
 		break;
 	}
@@ -732,7 +723,7 @@ odm_HWSetting(
 	)
 {
 #if (RTL8821A_SUPPORT == 1)
-	if(pDM_Odm->SupportICType & ODM_RTL8821)
+	if (pDM_Odm->SupportICType & ODM_RTL8821)
 		odm_HWSetting_8821A(pDM_Odm);
 #endif
 
@@ -774,7 +765,7 @@ ODM_DMInit(
 	odm_PathDiversityInit(pDM_Odm);
 	odm_DynamicTxPowerInit(pDM_Odm);
 	phydm_initRaInfo(pDM_Odm);
-	
+
 #if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
 #ifdef BEAMFORMING_VERSION_1
 	if (pHalData->BeamformingVersion == BEAMFORMING_VERSION_1)
@@ -782,29 +773,27 @@ ODM_DMInit(
 	{
 		phydm_Beamforming_Init(pDM_Odm);
 	}
-#endif	
+#endif
 
-	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-	{
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
 		odm_DynamicBBPowerSavingInit(pDM_Odm);
 
 #if (RTL8188E_SUPPORT == 1)
-		if(pDM_Odm->SupportICType==ODM_RTL8188E)
-		{
+		if (pDM_Odm->SupportICType==ODM_RTL8188E) {
 			ODM_PrimaryCCA_Init(pDM_Odm);
 			ODM_RAInfo_Init_all(pDM_Odm);
 		}
 #endif
 
 #if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
-	
+
 	#if (RTL8723B_SUPPORT == 1)
-		if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		if (pDM_Odm->SupportICType == ODM_RTL8723B)
 			odm_SwAntDetectInit(pDM_Odm);
 	#endif
 
 	#if (RTL8192E_SUPPORT == 1)
-		if(pDM_Odm->SupportICType==ODM_RTL8192E)
+		if (pDM_Odm->SupportICType==ODM_RTL8192E)
 			odm_PrimaryCCA_Check_Init(pDM_Odm);
 	#endif
 
@@ -821,7 +810,7 @@ ODM_DMReset(
 {
 	pDIG_T pDM_DigTable = &pDM_Odm->DM_DigTable;
 
-	ODM_AntDivReset(pDM_Odm);	
+	ODM_AntDivReset(pDM_Odm);
 	phydm_setEDCCAThresholdAPI(pDM_Odm, pDM_DigTable->CurIGValue);
 }
 
@@ -840,10 +829,9 @@ phydm_support_ability_debug(
 	u4Byte used = *_used;
 	u4Byte out_len = *_out_len;
 
-	pre_support_ability = pDM_Odm->SupportAbility ;	
+	pre_support_ability = pDM_Odm->SupportAbility ;
 	PHYDM_SNPRINTF((output+used, out_len-used,"\n%s\n", "================================"));
-	if(dm_value[0] == 100)
-	{
+	if (dm_value[0] == 100) {
 		PHYDM_SNPRINTF((output+used, out_len-used, "[Supportability] PhyDM Selection\n"));
 		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "================================"));
 		PHYDM_SNPRINTF((output+used, out_len-used, "00. (( %s ))DIG\n", ((pDM_Odm->SupportAbility & ODM_BB_DIG)?("V"):("."))));
@@ -851,20 +839,20 @@ phydm_support_ability_debug(
 		PHYDM_SNPRINTF((output+used, out_len-used, "02. (( %s ))DYNAMIC_TXPWR\n", ((pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_TXPWR)?("V"):("."))));		
 		PHYDM_SNPRINTF((output+used, out_len-used, "03. (( %s ))FA_CNT\n", ((pDM_Odm->SupportAbility & ODM_BB_FA_CNT)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "04. (( %s ))RSSI_MONITOR\n", ((pDM_Odm->SupportAbility & ODM_BB_RSSI_MONITOR)?("V"):("."))));
-		PHYDM_SNPRINTF((output+used, out_len-used, "05. (( %s ))CCK_PD\n", ((pDM_Odm->SupportAbility & ODM_BB_CCK_PD)?("V"):("."))));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "05. (( %s ))CCK_PD\n", ((pDM_Odm->SupportAbility & ODM_BB_CCK_PD)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "06. (( %s ))ANT_DIV\n", ((pDM_Odm->SupportAbility & ODM_BB_ANT_DIV)?("V"):("."))));
-		PHYDM_SNPRINTF((output+used, out_len-used, "08. (( %s ))PWR_TRAIN\n", ((pDM_Odm->SupportAbility & ODM_BB_PWR_TRAIN)?("V"):("."))));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "08. (( %s ))PWR_TRAIN\n", ((pDM_Odm->SupportAbility & ODM_BB_PWR_TRAIN)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "09. (( %s ))RATE_ADAPTIVE\n", ((pDM_Odm->SupportAbility & ODM_BB_RATE_ADAPTIVE)?("V"):("."))));
-		PHYDM_SNPRINTF((output+used, out_len-used, "10. (( %s ))PATH_DIV\n", ((pDM_Odm->SupportAbility & ODM_BB_PATH_DIV)?("V"):(".")))); 
-		PHYDM_SNPRINTF((output+used, out_len-used, "13. (( %s ))ADAPTIVITY\n", ((pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY)?("V"):("."))));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "10. (( %s ))PATH_DIV\n", ((pDM_Odm->SupportAbility & ODM_BB_PATH_DIV)?("V"):("."))));
+		PHYDM_SNPRINTF((output+used, out_len-used, "13. (( %s ))ADAPTIVITY\n", ((pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "14. (( %s ))CFO_TRACKING\n", ((pDM_Odm->SupportAbility & ODM_BB_CFO_TRACKING)?("V"):("."))));
-		PHYDM_SNPRINTF((output+used, out_len-used, "15. (( %s ))NHM_CNT\n", ((pDM_Odm->SupportAbility & ODM_BB_NHM_CNT)?("V"):("."))));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "15. (( %s ))NHM_CNT\n", ((pDM_Odm->SupportAbility & ODM_BB_NHM_CNT)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "16. (( %s ))PRIMARY_CCA\n", ((pDM_Odm->SupportAbility & ODM_BB_PRIMARY_CCA)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "17. (( %s ))TXBF\n", ((pDM_Odm->SupportAbility & ODM_BB_TXBF)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "18. (( %s ))DYNAMIC_ARFR\n", ((pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_ARFR)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "20. (( %s ))EDCA_TURBO\n", ((pDM_Odm->SupportAbility & ODM_MAC_EDCA_TURBO)?("V"):("."))));	
 		PHYDM_SNPRINTF((output+used, out_len-used, "21. (( %s ))EARLY_MODE\n", ((pDM_Odm->SupportAbility & ODM_MAC_EARLY_MODE)?("V"):("."))));
-		PHYDM_SNPRINTF((output+used, out_len-used, "24. (( %s ))TX_PWR_TRACK\n", ((pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK)?("V"):("."))));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "24. (( %s ))TX_PWR_TRACK\n", ((pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "25. (( %s ))RX_GAIN_TRACK\n", ((pDM_Odm->SupportAbility & ODM_RF_RX_GAIN_TRACK)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "26. (( %s ))RF_CALIBRATION\n", ((pDM_Odm->SupportAbility & ODM_RF_CALIBRATION)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "================================"));
@@ -874,31 +862,25 @@ phydm_support_ability_debug(
 	{
 		pDM_Odm->SupportAbility = 0 ;
 		DbgPrint("Disable all SupportAbility components \n");
-		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "Disable all SupportAbility components"));	
+		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "Disable all SupportAbility components"));
 	}
 	*/
-	else
-	{
+	else {
 
-		if(dm_value[1] == 1) //enable
-		{
+		if (dm_value[1] == 1) { //enable
 			pDM_Odm->SupportAbility |= BIT(dm_value[0]) ;
-			if(BIT(dm_value[0]) & ODM_BB_PATH_DIV)
-			{
+			if (BIT(dm_value[0]) & ODM_BB_PATH_DIV) {
 				odm_PathDiversityInit(pDM_Odm);
 			}
 		}
-		else if(dm_value[1] == 2) //disable
-		{
+		else if (dm_value[1] == 2) { //disable
 			pDM_Odm->SupportAbility &= ~(BIT(dm_value[0])) ;
-		}
-		else
-		{
+		} else {
 			//DbgPrint("\n[Warning!!!]  1:enable,  2:disable \n\n");
 			PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "[Warning!!!]  1:enable,  2:disable"));
 		}
 	}
-	PHYDM_SNPRINTF((output+used, out_len-used,"pre-SupportAbility  =  0x%x\n",  pre_support_ability ));	
+	PHYDM_SNPRINTF((output+used, out_len-used,"pre-SupportAbility  =  0x%x\n",  pre_support_ability ));
 	PHYDM_SNPRINTF((output+used, out_len-used,"Curr-SupportAbility =  0x%x\n", pDM_Odm->SupportAbility ));
 	PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "================================"));
 }
@@ -911,15 +893,15 @@ VOID
 ODM_DMWatchdog_LPS(
 	IN		PDM_ODM_T		pDM_Odm
 	)
-{	
+{
 	odm_CommonInfoSelfUpdate(pDM_Odm);
 	odm_FalseAlarmCounterStatistics(pDM_Odm);
 	odm_RSSIMonitorCheck(pDM_Odm);
-	odm_DIGbyRSSI_LPS(pDM_Odm);	
+	odm_DIGbyRSSI_LPS(pDM_Odm);
 	odm_CCKPacketDetectionThresh(pDM_Odm);
 	odm_CommonInfoSelfReset(pDM_Odm);
 
-	if(*(pDM_Odm->pbPowerSaving)==TRUE)
+	if (*(pDM_Odm->pbPowerSaving)==TRUE)
 		return;
 }
 #endif
@@ -940,17 +922,16 @@ ODM_DMWatchdog(
 #if (DM_ODM_SUPPORT_TYPE == ODM_AP)
 	{
 	prtl8192cd_priv priv		= pDM_Odm->priv;
-	if( (priv->auto_channel != 0) && (priv->auto_channel != 2) )//if ACS running, do not do FA/CCA counter read
+	if ( (priv->auto_channel != 0) && (priv->auto_channel != 2) )//if ACS running, do not do FA/CCA counter read
 		return;
 	}
-#endif	
+#endif
 	odm_FalseAlarmCounterStatistics(pDM_Odm);
 	phydm_NoisyDetection(pDM_Odm);
-	
+
 	odm_RSSIMonitorCheck(pDM_Odm);
 
-	if(*(pDM_Odm->pbPowerSaving) == TRUE)
-	{
+	if (*(pDM_Odm->pbPowerSaving) == TRUE) {
 		odm_DIGbyRSSI_LPS(pDM_Odm);
 		{
 			pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
@@ -962,7 +943,7 @@ ODM_DMWatchdog(
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("DMWatchdog in power saving mode\n"));
 		return;
 	}
-	
+
 	Phydm_CheckAdaptivity(pDM_Odm);
 	odm_UpdatePowerTrainingState(pDM_Odm);
 	odm_DIG(pDM_Odm);
@@ -971,7 +952,7 @@ ODM_DMWatchdog(
 		Phydm_Adaptivity(pDM_Odm, pDM_DigTable->CurIGValue);
 	}
 	odm_CCKPacketDetectionThresh(pDM_Odm);
-	
+
 	phydm_ra_info_watchdog(pDM_Odm);
 	odm_EdcaTurboCheck(pDM_Odm);
 	odm_PathDiversity(pDM_Odm);
@@ -984,9 +965,8 @@ ODM_DMWatchdog(
 
 	phydm_rf_watchdog(pDM_Odm);
 
-	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-	{
-	        
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
+
 #if (RTL8188E_SUPPORT == 1)
 		if (pDM_Odm->SupportICType == ODM_RTL8188E)
 			ODM_DynamicPrimaryCCA(pDM_Odm);
@@ -995,8 +975,8 @@ ODM_DMWatchdog(
 #if( DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
 
 	#if (RTL8192E_SUPPORT == 1)
-		if(pDM_Odm->SupportICType==ODM_RTL8192E)
-			odm_DynamicPrimaryCCA_Check(pDM_Odm); 
+		if (pDM_Odm->SupportICType==ODM_RTL8192E)
+			odm_DynamicPrimaryCCA_Check(pDM_Odm);
 	#endif
 #endif
 	}
@@ -1006,7 +986,7 @@ ODM_DMWatchdog(
 #endif
 
 	odm_CommonInfoSelfReset(pDM_Odm);
-	
+
 }
 
 
@@ -1017,7 +997,7 @@ VOID
 ODM_CmnInfoInit(
 	IN		PDM_ODM_T		pDM_Odm,
 	IN		ODM_CMNINFO_E	CmnInfo,
-	IN		u4Byte			Value	
+	IN		u4Byte			Value
 	)
 {
 	//
@@ -1047,7 +1027,7 @@ ODM_CmnInfoInit(
 		case	ODM_CMNINFO_MP_TEST_CHIP:
 			pDM_Odm->bIsMPChip= (u1Byte)Value;
 			break;
-            
+
 		case	ODM_CMNINFO_IC_TYPE:
 			pDM_Odm->SupportICType = Value;
 			break;
@@ -1068,14 +1048,14 @@ ODM_CmnInfoInit(
 		case    ODM_CMNINFO_RF_ANTENNA_TYPE:
 			pDM_Odm->AntDivType= (u1Byte)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_WITH_EXT_ANTENNA_SWITCH:
 			pDM_Odm->with_extenal_ant_switch = (u1Byte)Value;
-			break;	
-			
+			break;
+
 		case    ODM_CMNINFO_BE_FIX_TX_ANT:
 			pDM_Odm->DM_FatTable.b_fix_tx_ant = (u1Byte)Value;
-			break;	
+			break;
 
 		case	ODM_CMNINFO_BOARD_TYPE:
 			if (!pDM_Odm->bInitHwInfoByRfe)
@@ -1111,17 +1091,17 @@ ODM_CmnInfoInit(
 			if (!pDM_Odm->bInitHwInfoByRfe)
 				pDM_Odm->TypeGPA = (u2Byte)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_APA:
 			if (!pDM_Odm->bInitHwInfoByRfe)
 				pDM_Odm->TypeAPA = (u2Byte)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_GLNA:
 			if (!pDM_Odm->bInitHwInfoByRfe)
 				pDM_Odm->TypeGLNA = (u2Byte)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_ALNA:
 			if (!pDM_Odm->bInitHwInfoByRfe)
 				pDM_Odm->TypeALNA = (u2Byte)Value;
@@ -1141,7 +1121,7 @@ ODM_CmnInfoInit(
 			break;
 		case 	ODM_CMNINFO_BWIFI_TEST:
 			pDM_Odm->WIFITest = (u1Byte)Value;
-			break;	
+			break;
 		case	ODM_CMNINFO_SMART_CONCURRENT:
 			pDM_Odm->bDualMacSmartConcurrent = (BOOLEAN )Value;
 			break;
@@ -1171,11 +1151,11 @@ ODM_CmnInfoInit(
 			pDM_Odm->DFS_RegionDomain = (u1Byte)Value;
 			break;
 #endif
-		//To remove the compiler warning, must add an empty default statement to handle the other values.	
+		//To remove the compiler warning, must add an empty default statement to handle the other values.
 		default:
 			//do nothing
-			break;	
-		
+			break;
+
 	}
 
 }
@@ -1185,7 +1165,7 @@ VOID
 ODM_CmnInfoHook(
 	IN		PDM_ODM_T		pDM_Odm,
 	IN		ODM_CMNINFO_E	CmnInfo,
-	IN		PVOID			pValue	
+	IN		PVOID			pValue
 	)
 {
 	//
@@ -1199,7 +1179,7 @@ ODM_CmnInfoHook(
 		case	ODM_CMNINFO_MAC_PHY_MODE:
 			pDM_Odm->pMacPhyMode = (u1Byte *)pValue;
 			break;
-		
+
 		case	ODM_CMNINFO_TX_UNI:
 			pDM_Odm->pNumTxBytesUnicast = (u8Byte *)pValue;
 			break;
@@ -1231,7 +1211,7 @@ ODM_CmnInfoHook(
 		case	ODM_CMNINFO_CHNL:
 			pDM_Odm->pChannel = (u1Byte *)pValue;
 			break;
-		
+
 		case	ODM_CMNINFO_DMSP_GET_VALUE:
 			pDM_Odm->pbGetValueFromOtherMac = (BOOLEAN *)pValue;
 			break;
@@ -1291,7 +1271,7 @@ ODM_CmnInfoHook(
 		case 	ODM_CMNINFO_IS1ANTENNA:
 			pDM_Odm->pIs1Antenna = (BOOLEAN *)pValue;
 			break;
-			
+
 		case 	ODM_CMNINFO_RFDEFAULTPATH:
 			pDM_Odm->pRFDefaultPath= (u1Byte *)pValue;
 			break;
@@ -1328,7 +1308,7 @@ ODM_CmnInfoHook(
 		//	break;
 
 		//case	ODM_CMNINFO_BT_COEXIST:
-		//	pDM_Odm->BTCoexist = (BOOLEAN *)pValue;		
+		//	pDM_Odm->BTCoexist = (BOOLEAN *)pValue;
 
 		//case	ODM_CMNINFO_STA_STATUS:
 			//pDM_Odm->pODM_StaInfo[] = (PSTA_INFO_T)pValue;
@@ -1341,7 +1321,7 @@ ODM_CmnInfoHook(
 		//case	ODM_CMNINFO_MAC_STATUS:
 		//	pDM_Odm->pMacInfo = (ODM_MAC_INFO *)pValue;
 		//	break;
-		//To remove the compiler warning, must add an empty default statement to handle the other values.				
+		//To remove the compiler warning, must add an empty default statement to handle the other values.
 		default:
 			//do nothing
 			break;
@@ -1356,7 +1336,7 @@ ODM_CmnInfoPtrArrayHook(
 	IN		PDM_ODM_T		pDM_Odm,
 	IN		ODM_CMNINFO_E	CmnInfo,
 	IN		u2Byte			Index,
-	IN		PVOID			pValue	
+	IN		PVOID			pValue
 	)
 {
 	//
@@ -1366,10 +1346,10 @@ ODM_CmnInfoPtrArrayHook(
 	{
 		//
 		// Dynamic call by reference pointer.
-		//		
+		//
 		case	ODM_CMNINFO_STA_STATUS:
 			pDM_Odm->pODM_StaInfo[Index] = (PSTA_INFO_T)pValue;
-			
+
 			if (IS_STA_VALID(pDM_Odm->pODM_StaInfo[Index]))
 			#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 				pDM_Odm->platform2phydm_macid_table[((PSTA_INFO_T)pValue)->AssociatedMacId] = Index; /*AssociatedMacId are unique bttween different Adapter*/
@@ -1378,14 +1358,14 @@ ODM_CmnInfoPtrArrayHook(
 			#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
 				pDM_Odm->platform2phydm_macid_table[((PSTA_INFO_T)pValue)->mac_id] = Index;
 			#endif
-			
-			break;		
-		//To remove the compiler warning, must add an empty default statement to handle the other values.				
+
+			break;
+		//To remove the compiler warning, must add an empty default statement to handle the other values.
 		default:
 			//do nothing
 			break;
 	}
-	
+
 }
 
 
@@ -1396,7 +1376,7 @@ VOID
 ODM_CmnInfoUpdate(
 	IN		PDM_ODM_T		pDM_Odm,
 	IN		u4Byte			CmnInfo,
-	IN		u8Byte			Value	
+	IN		u8Byte			Value
 	)
 {
 	//
@@ -1407,7 +1387,7 @@ ODM_CmnInfoUpdate(
 		case ODM_CMNINFO_LINK_IN_PROGRESS:
 			pDM_Odm->bLinkInProcess = (BOOLEAN)Value;
 			break;
-		
+
 		case	ODM_CMNINFO_ABILITY:
 			pDM_Odm->SupportAbility = (u4Byte)Value;
 			break;
@@ -1431,7 +1411,7 @@ ODM_CmnInfoUpdate(
 		case	ODM_CMNINFO_STATION_STATE:
 			pDM_Odm->bsta_state = (BOOLEAN)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_RSSI_MIN:
 			pDM_Odm->RSSI_Min= (u1Byte)Value;
 			break;
@@ -1455,30 +1435,30 @@ ODM_CmnInfoUpdate(
 		case ODM_CMNINFO_BT_ENABLED:
 			pDM_Odm->bBtEnabled = (BOOLEAN)Value;
 			break;
-			
+
 		case ODM_CMNINFO_BT_HS_CONNECT_PROCESS:
 			pDM_Odm->bBtConnectProcess = (BOOLEAN)Value;
 			break;
-		
+
 		case ODM_CMNINFO_BT_HS_RSSI:
 			pDM_Odm->btHsRssi = (u1Byte)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_BT_OPERATION:
 			pDM_Odm->bBtHsOperation = (BOOLEAN)Value;
 			break;
 
 		case	ODM_CMNINFO_BT_LIMITED_DIG:
 			pDM_Odm->bBtLimitedDig = (BOOLEAN)Value;
-			break;	
+			break;
 
 		case ODM_CMNINFO_BT_DIG:
 			pDM_Odm->btHsDigVal = (u1Byte)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_BT_BUSY:
 			pDM_Odm->bBtBusy = (BOOLEAN)Value;
-			break;	
+			break;
 
 		case	ODM_CMNINFO_BT_DISABLE_EDCA:
 			pDM_Odm->bBtDisableEdcaTurbo = (BOOLEAN)Value;
@@ -1534,14 +1514,14 @@ ODM_CmnInfoUpdate(
 
 		case	ODM_CMNINFO_CHNL:
 			pDM_Odm->Channel = (u1Byte)Value;
-			break;			
-*/	
+			break;
+*/
                 default:
 			//do nothing
 			break;
 	}
 
-	
+
 }
 
 
@@ -1553,59 +1533,59 @@ ODM_InitAllWorkItems(IN PDM_ODM_T	pDM_Odm )
 	PADAPTER		pAdapter = pDM_Odm->Adapter;
 #if USE_WORKITEM
 	#ifdef CONFIG_S0S1_SW_ANTENNA_DIVERSITY
-	ODM_InitializeWorkItem(	pDM_Odm, 
-							&pDM_Odm->DM_SWAT_Table.phydm_SwAntennaSwitchWorkitem, 
+	ODM_InitializeWorkItem(	pDM_Odm,
+							&pDM_Odm->DM_SWAT_Table.phydm_SwAntennaSwitchWorkitem,
 							(RT_WORKITEM_CALL_BACK)ODM_SW_AntDiv_WorkitemCallback,
 							(PVOID)pAdapter,
 							"AntennaSwitchWorkitem");
 	#endif
 	#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
-	ODM_InitializeWorkItem(pDM_Odm, 
-						&pDM_Odm->dm_sat_table.hl_smart_antenna_workitem, 
+	ODM_InitializeWorkItem(pDM_Odm,
+						&pDM_Odm->dm_sat_table.hl_smart_antenna_workitem,
 						(RT_WORKITEM_CALL_BACK)phydm_beam_switch_workitem_callback,
 						(PVOID)pAdapter,
 						"hl_smart_ant_workitem");
 
-	ODM_InitializeWorkItem(pDM_Odm, 
-						&pDM_Odm->dm_sat_table.hl_smart_antenna_decision_workitem, 
+	ODM_InitializeWorkItem(pDM_Odm,
+						&pDM_Odm->dm_sat_table.hl_smart_antenna_decision_workitem,
 						(RT_WORKITEM_CALL_BACK)phydm_beam_decision_workitem_callback,
 						(PVOID)pAdapter,
 						"hl_smart_ant_decision_workitem");
 	#endif
-	
+
 	ODM_InitializeWorkItem(
 		pDM_Odm,
-		&(pDM_Odm->PathDivSwitchWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_PathDivChkAntSwitchWorkitemCallback, 
+		&(pDM_Odm->PathDivSwitchWorkitem),
+		(RT_WORKITEM_CALL_BACK)odm_PathDivChkAntSwitchWorkitemCallback,
 		(PVOID)pAdapter,
 		"SWAS_WorkItem");
 
 	ODM_InitializeWorkItem(
 		pDM_Odm,
-		&(pDM_Odm->CCKPathDiversityWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_CCKTXPathDiversityWorkItemCallback, 
+		&(pDM_Odm->CCKPathDiversityWorkitem),
+		(RT_WORKITEM_CALL_BACK)odm_CCKTXPathDiversityWorkItemCallback,
 		(PVOID)pAdapter,
 		"CCKTXPathDiversityWorkItem");
 
 	ODM_InitializeWorkItem(
 		pDM_Odm,
-		&(pDM_Odm->MPT_DIGWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_MPT_DIGWorkItemCallback, 
+		&(pDM_Odm->MPT_DIGWorkitem),
+		(RT_WORKITEM_CALL_BACK)odm_MPT_DIGWorkItemCallback,
 		(PVOID)pAdapter,
 		"MPT_DIGWorkitem");
 
 	ODM_InitializeWorkItem(
 		pDM_Odm,
-		&(pDM_Odm->RaRptWorkitem), 
-		(RT_WORKITEM_CALL_BACK)ODM_UpdateInitRateWorkItemCallback, 
+		&(pDM_Odm->RaRptWorkitem),
+		(RT_WORKITEM_CALL_BACK)ODM_UpdateInitRateWorkItemCallback,
 		(PVOID)pAdapter,
 		"RaRptWorkitem");
 
 #if( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
 	ODM_InitializeWorkItem(
 		pDM_Odm,
-		&(pDM_Odm->FastAntTrainingWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_FastAntTrainingWorkItemCallback, 
+		&(pDM_Odm->FastAntTrainingWorkitem),
+		(RT_WORKITEM_CALL_BACK)odm_FastAntTrainingWorkItemCallback,
 		(PVOID)pAdapter,
 		"FastAntTrainingWorkitem");
 #endif
@@ -1619,14 +1599,14 @@ ODM_InitAllWorkItems(IN PDM_ODM_T	pDM_Odm )
 		(RT_WORKITEM_CALL_BACK)halComTxbf_EnterWorkItemCallback,
 		(PVOID)pAdapter,
 		"Txbf_EnterWorkItem");
-	
+
 	ODM_InitializeWorkItem(
 		pDM_Odm,
 		&(pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_LeaveWorkItem),
 		(RT_WORKITEM_CALL_BACK)halComTxbf_LeaveWorkItemCallback,
 		(PVOID)pAdapter,
 		"Txbf_LeaveWorkItem");
-	
+
 	ODM_InitializeWorkItem(
 		pDM_Odm,
 		&(pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_FwNdpaWorkItem),
@@ -1700,7 +1680,7 @@ ODM_FreeAllWorkItems(IN PDM_ODM_T	pDM_Odm )
 	ODM_FreeWorkItem(&(pDM_Odm->dm_sat_table.hl_smart_antenna_decision_workitem));
 #endif
 
-	ODM_FreeWorkItem(&(pDM_Odm->PathDivSwitchWorkitem));      
+	ODM_FreeWorkItem(&(pDM_Odm->PathDivSwitchWorkitem));
 	ODM_FreeWorkItem(&(pDM_Odm->CCKPathDiversityWorkitem));
 #if (defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY)) || (defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY))
 	ODM_FreeWorkItem(&(pDM_Odm->FastAntTrainingWorkitem));
@@ -1759,15 +1739,15 @@ odm_IsLinked(
 {
 	u4Byte i;
 	BOOLEAN Linked = FALSE;
-	
+
 	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
 	{
 			if(IS_STA_VALID(pDM_Odm->pODM_StaInfo[i]) )
-			{			
+			{
 				Linked = TRUE;
 				break;
 			}
-		
+
 	}
 
 	pDM_Odm->bLinked = Linked;
@@ -1776,7 +1756,7 @@ odm_IsLinked(
 
 VOID
 ODM_InitAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
+	IN PDM_ODM_T	pDM_Odm
 	)
 {
 #if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
@@ -1785,22 +1765,22 @@ ODM_InitAllTimers(
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_AP)
 #ifdef MP_TEST
-	if (pDM_Odm->priv->pshare->rf_ft_var.mp_specific) 
-		ODM_InitializeTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer, 
-			(RT_TIMER_CALL_BACK)odm_MPT_DIGCallback, NULL, "MPT_DIGTimer");	
+	if (pDM_Odm->priv->pshare->rf_ft_var.mp_specific)
+		ODM_InitializeTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer,
+			(RT_TIMER_CALL_BACK)odm_MPT_DIGCallback, NULL, "MPT_DIGTimer");
 #endif
 #elif(DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer, 
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer,
 		(RT_TIMER_CALL_BACK)odm_MPT_DIGCallback, NULL, "MPT_DIGTimer");
 #endif
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer,
 		(RT_TIMER_CALL_BACK)odm_PathDivChkAntSwitchCallback, NULL, "PathDivTimer");
-	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer, 
-		(RT_TIMER_CALL_BACK)odm_CCKTXPathDiversityCallback, NULL, "CCKPathDiversityTimer"); 
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer,
+		(RT_TIMER_CALL_BACK)odm_CCKTXPathDiversityCallback, NULL, "CCKPathDiversityTimer");
 	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->sbdcnt_timer,
-		(RT_TIMER_CALL_BACK)phydm_sbd_callback, NULL, "SbdTimer"); 
+		(RT_TIMER_CALL_BACK)phydm_sbd_callback, NULL, "SbdTimer");
 #if (BEAMFORMING_SUPPORT == 1)
 	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_FwNdpaTimer,
 		(RT_TIMER_CALL_BACK)halComTxbf_FwNdpaTimerCallback, NULL, "Txbf_FwNdpaTimer");
@@ -1817,16 +1797,16 @@ ODM_InitAllTimers(
 
 VOID
 ODM_CancelAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
+	IN PDM_ODM_T	pDM_Odm
 	)
 {
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	//
-	// 2012/01/12 MH Temp BSOD fix. We need to find NIC allocate mem fail reason in 
+	// 2012/01/12 MH Temp BSOD fix. We need to find NIC allocate mem fail reason in
 	// win7 platform.
 	//
 	HAL_ADAPTER_STS_CHK(pDM_Odm)
-#endif	
+#endif
 
 #if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
 	ODM_AntDivTimers(pDM_Odm,CANCEL_ANTDIV_TIMMER);
@@ -1862,7 +1842,7 @@ ODM_CancelAllTimers(
 
 VOID
 ODM_ReleaseAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
+	IN PDM_ODM_T	pDM_Odm
 	)
 {
 #if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
@@ -1906,7 +1886,7 @@ ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer);
 #if (DM_ODM_SUPPORT_TYPE == ODM_AP)
 VOID
 ODM_InitAllThreads(
-	IN PDM_ODM_T	pDM_Odm 
+	IN PDM_ODM_T	pDM_Odm
 	)
 {
 	#ifdef TPT_THREAD
@@ -1916,17 +1896,17 @@ ODM_InitAllThreads(
 
 VOID
 ODM_StopAllThreads(
-	IN PDM_ODM_T	pDM_Odm 
+	IN PDM_ODM_T	pDM_Odm
 	)
 {
 	#ifdef TPT_THREAD
 	kTPT_task_stop(pDM_Odm->priv);
 	#endif
 }
-#endif	
+#endif
 
 
-#if( DM_ODM_SUPPORT_TYPE == ODM_WIN) 
+#if( DM_ODM_SUPPORT_TYPE == ODM_WIN)
 //
 // 2011/07/26 MH Add an API for testing IQK fail case.
 //
@@ -1941,19 +1921,17 @@ ODM_CheckPowerStatus(
 	PMGNT_INFO			pMgntInfo	= &(Adapter->MgntInfo);
 
 	// 2011/07/27 MH We are not testing ready~~!! We may fail to get correct value when init sequence.
-	if (pMgntInfo->init_adpt_in_progress == TRUE)
-	{
+	if (pMgntInfo->init_adpt_in_progress == TRUE){
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ODM_CheckPowerStatus Return TRUE, due to initadapter\n"));
 		return	TRUE;
 	}
-	
+
 	//
 	//	2011/07/19 MH We can not execute tx pwoer tracking/ LLC calibrate or IQK.
 	//
-	Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));	
-	if(Adapter->bDriverStopped || Adapter->bDriverIsGoingToPnpSetPowerSleep || rtState == eRfOff)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n", 
+	Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));
+	if (Adapter->bDriverStopped || Adapter->bDriverIsGoingToPnpSetPowerSleep || rtState == eRfOff) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n",
 		Adapter->bDriverStopped, Adapter->bDriverIsGoingToPnpSetPowerSleep, rtState));
 		return	FALSE;
 	}
@@ -1980,10 +1958,10 @@ ODM_CheckPowerStatus(
 	//
 	//	2011/07/19 MH We can not execute tx pwoer tracking/ LLC calibrate or IQK.
 	//
-	Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));	
+	Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));
 	if(Adapter->bDriverStopped || Adapter->bDriverIsGoingToPnpSetPowerSleep || rtState == eRfOff)
 	{
-	ODM_RT_TRACE(pDM_Odm,COMP_INIT, DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n", 
+	ODM_RT_TRACE(pDM_Odm,COMP_INIT, DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n",
 	Adapter->bDriverStopped, Adapter->bDriverIsGoingToPnpSetPowerSleep, rtState));
 	return	FALSE;
 	}
@@ -2005,7 +1983,7 @@ GetPSDData(
 	//unsigned int	val, rfval;
 	//int	psd_report;
 	u4Byte	psd_report;
-	
+
 	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
 	//Debug Message
 	//val = PHY_QueryBBReg(Adapter,0x908, bMaskDWord);
@@ -2026,7 +2004,7 @@ GetPSDData(
 	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 0);
 	//Read PSD report, Reg8B4[15:0]
 	psd_report = ODM_GetBBReg(pDM_Odm,0x8B4, bMaskDWord) & 0x0000FFFF;
-	
+
 #if 1//(DEV_BUS_TYPE == RT_PCI_INTERFACE) && ( (RT_PLATFORM == PLATFORM_LINUX) || (RT_PLATFORM == PLATFORM_MACOSX))
 	psd_report = (u4Byte) (odm_ConvertTo_dB(psd_report))+(u4Byte)(initial_gain_psd-0x1c);
 #else
@@ -2034,11 +2012,11 @@ GetPSDData(
 #endif
 
 	return psd_report;
-	
+
 }
 #endif
 
-u4Byte 
+u4Byte
 odm_ConvertTo_dB(
 	u4Byte 	Value)
 {
@@ -2048,23 +2026,18 @@ odm_ConvertTo_dB(
 
 	Value = Value & 0xFFFF;
 
-	for (i = 0; i < 12; i++)
-	{
-		if (Value <= dB_Invert_Table[i][7])
-		{
+	for (i = 0; i < 12; i++) {
+		if (Value <= dB_Invert_Table[i][7]) {
 			break;
 		}
 	}
 
-	if (i >= 12)
-	{
+	if (i >= 12) {
 		return (96);	// maximum 96 dB
 	}
 
-	for (j = 0; j < 8; j++)
-	{
-		if (Value <= dB_Invert_Table[i][j])
-		{
+	for (j = 0; j < 8; j++) {
+		if (Value <= dB_Invert_Table[i][j]) {
 			break;
 		}
 	}
@@ -2074,16 +2047,16 @@ odm_ConvertTo_dB(
 	return (dB);
 }
 
-u4Byte 
+u4Byte
 odm_ConvertTo_linear(
 	u4Byte 	Value)
 {
 	u1Byte i;
 	u1Byte j;
 	u4Byte linear;
-	
+
 	/* 1dB~96dB */
-	
+
 	Value = Value & 0xFF;
 
 	i = (u1Byte)((Value - 1) >> 3);
@@ -2112,22 +2085,20 @@ ODM_AsocEntry_Init(
 
 	ODM_CmnInfoPtrArrayHook(pDM_OutSrc, ODM_CMNINFO_STA_STATUS, 0, &pLoopAdapter->MgntInfo.DefaultPort[0]);
 	pLoopAdapter->MgntInfo.DefaultPort[0].MultiPortStationIdx = TotalAssocEntryNum;
-		
+
 	adaptercount += 1;
-	RT_TRACE(COMP_INIT, DBG_LOUD, ("adaptercount=%d\n", adaptercount));	
+	RT_TRACE(COMP_INIT, DBG_LOUD, ("adaptercount=%d\n", adaptercount));
 	pLoopAdapter = GetNextExtAdapter(pLoopAdapter);
 	TotalAssocEntryNum +=1;
 
-	while(pLoopAdapter)
-	{
-		for (index = 0; index <ASSOCIATE_ENTRY_NUM; index++)
-		{
+	while (pLoopAdapter) {
+		for (index = 0; index <ASSOCIATE_ENTRY_NUM; index++) {
 			ODM_CmnInfoPtrArrayHook(pDM_OutSrc, ODM_CMNINFO_STA_STATUS, TotalAssocEntryNum+index, &pLoopAdapter->MgntInfo.AsocEntry[index]);
-			pLoopAdapter->MgntInfo.AsocEntry[index].MultiPortStationIdx = TotalAssocEntryNum+index;				
+			pLoopAdapter->MgntInfo.AsocEntry[index].MultiPortStationIdx = TotalAssocEntryNum+index;
 		}
-		
+
 		TotalAssocEntryNum+= index;
-		if(IS_HARDWARE_TYPE_8188E((pDM_Odm->Adapter)))
+		if (IS_HARDWARE_TYPE_8188E((pDM_Odm->Adapter)))
 			pLoopAdapter->RASupport = TRUE;
 		adaptercount += 1;
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("adaptercount=%d\n", adaptercount));
@@ -2136,7 +2107,7 @@ ODM_AsocEntry_Init(
 
 	RT_TRACE(COMP_INIT, DBG_LOUD, ("TotalAssocEntryNum = %d\n", TotalAssocEntryNum));
 	if (TotalAssocEntryNum < (ODM_ASSOCIATE_ENTRY_NUM-1)) {
-	
+
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("In hook null\n"));
 		for (index = TotalAssocEntryNum; index < ODM_ASSOCIATE_ENTRY_NUM; index++)
 			ODM_CmnInfoPtrArrayHook(pDM_OutSrc, ODM_CMNINFO_STA_STATUS, index, NULL);
@@ -2191,8 +2162,7 @@ void odm_dtc(PDM_ODM_T pDM_Odm)
 	if (DTC_BASE < pDM_Odm->RSSI_Min) {
 		/* need to decade the CTS TX power */
 		sign = 1;
-		for (i=0;i<ARRAY_SIZE(dtc_table_down);i++)
-		{
+		for (i=0;i<ARRAY_SIZE(dtc_table_down);i++) {
 			if ((dtc_table_down[i] >= pDM_Odm->RSSI_Min) || (dtc_steps >= 6))
 				break;
 			else
@@ -2200,13 +2170,11 @@ void odm_dtc(PDM_ODM_T pDM_Odm)
 		}
 	}
 #if 0
-	else if (DTC_DWN_BASE > pDM_Odm->RSSI_Min)
-	{
+	else if (DTC_DWN_BASE > pDM_Odm->RSSI_Min) {
 		/* needs to increase the CTS TX power */
 		sign = 0;
 		dtc_steps = 1;
-		for (i=0;i<ARRAY_SIZE(dtc_table_up);i++)
-		{
+		for (i=0;i<ARRAY_SIZE(dtc_table_up);i++) {
 			if ((dtc_table_up[i] <= pDM_Odm->RSSI_Min) || (dtc_steps>=10))
 				break;
 			else
@@ -2241,21 +2209,19 @@ odm_UpdatePowerTrainingState(
 	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
 	u4Byte						score = 0;
 
-	if(!(pDM_Odm->SupportAbility & ODM_BB_PWR_TRAIN))
+	if (!(pDM_Odm->SupportAbility & ODM_BB_PWR_TRAIN))
 		return;
 
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState()============>\n"));
 	pDM_Odm->bChangeState = FALSE;
 
 	// Debug command
-	if(pDM_Odm->ForcePowerTrainingState)
-	{
-		if(pDM_Odm->ForcePowerTrainingState == 1 && !pDM_Odm->bDisablePowerTraining)
-		{
+	if (pDM_Odm->ForcePowerTrainingState) {
+		if (pDM_Odm->ForcePowerTrainingState == 1 && !pDM_Odm->bDisablePowerTraining) {
 			pDM_Odm->bChangeState = TRUE;
 			pDM_Odm->bDisablePowerTraining = TRUE;
 		}
-		else if(pDM_Odm->ForcePowerTrainingState == 2 && pDM_Odm->bDisablePowerTraining)
+		else if (pDM_Odm->ForcePowerTrainingState == 2 && pDM_Odm->bDisablePowerTraining)
 		{
 			pDM_Odm->bChangeState = TRUE;
 			pDM_Odm->bDisablePowerTraining = FALSE;
@@ -2268,13 +2234,12 @@ odm_UpdatePowerTrainingState(
 			pDM_Odm->ForcePowerTrainingState));
 		return;
 	}
-	
-	if(!pDM_Odm->bLinked)
+
+	if (!pDM_Odm->bLinked)
 		return;
-	
+
 	// First connect
-	if((pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE))
-	{
+	if ((pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE)) {
 		pDM_Odm->PT_score = 0;
 		pDM_Odm->bChangeState = TRUE;
 		pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = 0;
@@ -2284,54 +2249,48 @@ odm_UpdatePowerTrainingState(
 	}
 
 	// Compute score
-	if(pDM_Odm->NHM_cnt_0 >= 215)
+	if (pDM_Odm->NHM_cnt_0 >= 215)
 		score = 2;
-	else if(pDM_Odm->NHM_cnt_0 >= 190) 
+	else if (pDM_Odm->NHM_cnt_0 >= 190)
 		score = 1;							// unknow state
-	else
-	{
+	else {
 		u4Byte	RX_Pkt_Cnt;
-		
+
 		RX_Pkt_Cnt = (u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM) + (u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK);
-		
-		if((FalseAlmCnt->Cnt_CCA_all > 31 && RX_Pkt_Cnt > 31) && (FalseAlmCnt->Cnt_CCA_all >= RX_Pkt_Cnt))
-		{
-			if((RX_Pkt_Cnt + (RX_Pkt_Cnt >> 1)) <= FalseAlmCnt->Cnt_CCA_all)
+
+		if ((FalseAlmCnt->Cnt_CCA_all > 31 && RX_Pkt_Cnt > 31) && (FalseAlmCnt->Cnt_CCA_all >= RX_Pkt_Cnt)) {
+			if ((RX_Pkt_Cnt + (RX_Pkt_Cnt >> 1)) <= FalseAlmCnt->Cnt_CCA_all)
 				score = 0;
-			else if((RX_Pkt_Cnt + (RX_Pkt_Cnt >> 2)) <= FalseAlmCnt->Cnt_CCA_all)
+			else if ((RX_Pkt_Cnt + (RX_Pkt_Cnt >> 2)) <= FalseAlmCnt->Cnt_CCA_all)
 				score = 1;
 			else
 				score = 2;
 		}
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): RX_Pkt_Cnt = %d, Cnt_CCA_all = %d\n", 
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): RX_Pkt_Cnt = %d, Cnt_CCA_all = %d\n",
 			RX_Pkt_Cnt, FalseAlmCnt->Cnt_CCA_all));
 	}
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): NumQryPhyStatusOFDM = %d, NumQryPhyStatusCCK = %d\n",
 			(u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM), (u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK)));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): NHM_cnt_0 = %d, score = %d\n", 
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): NHM_cnt_0 = %d, score = %d\n",
 		pDM_Odm->NHM_cnt_0, score));
 
 	// smoothing
 	pDM_Odm->PT_score = (score << 4) + (pDM_Odm->PT_score>>1) + (pDM_Odm->PT_score>>2);
 	score = (pDM_Odm->PT_score + 32) >> 6;
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): PT_score = %d, score after smoothing = %d\n", 
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): PT_score = %d, score after smoothing = %d\n",
 		pDM_Odm->PT_score, score));
 
 	// Mode decision
-	if(score == 2)
-	{
-		if(pDM_Odm->bDisablePowerTraining)
-		{
+	if (score == 2) {
+		if (pDM_Odm->bDisablePowerTraining) {
 			pDM_Odm->bChangeState = TRUE;
 			pDM_Odm->bDisablePowerTraining = FALSE;
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Change state\n"));
 		}
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Enable Power Training\n"));
 	}
-	else if(score == 0)
-	{
-		if(!pDM_Odm->bDisablePowerTraining)
-		{
+	else if (score == 0) {
+		if (!pDM_Odm->bDisablePowerTraining) {
 			pDM_Odm->bChangeState = TRUE;
 			pDM_Odm->bDisablePowerTraining = TRUE;
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Change state\n"));
@@ -2358,14 +2317,14 @@ u1Byte GetRightChnlPlaceforIQK(u1Byte chnl)
 		102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 149, 151, 153, 155, 157, 159, 161, 163, 165};
 	u1Byte	place = chnl;
 
-	
+
 	if (chnl > 14) {
 		for (place = 14; place < sizeof(channel_all); place++) {
 			if (channel_all[place] == chnl)
 				return place-13;
 		}
 	}
-	
+
 	return 0;
 }
 
@@ -2379,17 +2338,17 @@ phydm_NoisyDetection(
 {
 	u4Byte  Total_FA_Cnt, Total_CCA_Cnt;
 	u4Byte  Score = 0, i, Score_Smooth;
-    
+
 	Total_CCA_Cnt = pDM_Odm->FalseAlmCnt.Cnt_CCA_all;
-	Total_FA_Cnt  = pDM_Odm->FalseAlmCnt.Cnt_all;    
+	Total_FA_Cnt  = pDM_Odm->FalseAlmCnt.Cnt_all;
 
 /*
     if( Total_FA_Cnt*16>=Total_CCA_Cnt*14 )         // 87.5
-    
+
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*12 )    // 75
-    
+
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*10 )    // 56.25
-    
+
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*8 )     // 50
 
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*7 )     // 43.75
@@ -2397,7 +2356,7 @@ phydm_NoisyDetection(
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*6 )     // 37.5
 
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*5 )     // 31.25%
-        
+
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*4 )     // 25%
 
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*3 )     // 18.75%
@@ -2406,10 +2365,8 @@ phydm_NoisyDetection(
 
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*1 )     // 6.25%
 */
-    for(i=0;i<=16;i++)
-    {
-        if( Total_FA_Cnt*16>=Total_CCA_Cnt*(16-i) )
-        {
+    for (i=0;i<=16;i++) {
+        if ( Total_FA_Cnt*16>=Total_CCA_Cnt*(16-i) ) {
             Score = 16-i;
             break;
         }
@@ -2487,7 +2444,7 @@ phydm_NoisyDetection(
             break;
         case 15:
             ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
-            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=93.75%%\n"));            
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=93.75%%\n"));
             break;
         case 16:
             ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
@@ -2495,13 +2452,13 @@ phydm_NoisyDetection(
             break;
         default:
             ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
-            ("[NoisyDetection] Unknown Value!! Need Check!!\n"));            
+            ("[NoisyDetection] Unknown Value!! Need Check!!\n"));
     }
-*/        
+*/
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_NOISY_DETECT, ODM_DBG_LOUD,
 	("[NoisyDetection] Total_CCA_Cnt=%d, Total_FA_Cnt=%d, NoisyDecision_Smooth=%d, Score=%d, Score_Smooth=%d, pDM_Odm->NoisyDecision=%d\n",
 	Total_CCA_Cnt, Total_FA_Cnt, pDM_Odm->NoisyDecision_Smooth, Score, Score_Smooth, pDM_Odm->NoisyDecision));
-	
+
 }
 
 VOID
@@ -2514,18 +2471,18 @@ phydm_csi_mask_enable(
 	u4Byte		reg_value = 0;
 
 	reg_value = (enable == CSI_MASK_ENABLE) ? 1 : 0;
-	
+
 	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
 
 		ODM_SetBBReg(pDM_Odm, 0xD2C, BIT28, reg_value);
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_API, ODM_DBG_LOUD, ("Enable CSI Mask:  Reg 0xD2C[28] = ((0x%x))\n", reg_value));
-		
+
 	} else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
 
 		ODM_SetBBReg(pDM_Odm, 0x874, BIT0, reg_value);
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_API, ODM_DBG_LOUD, ("Enable CSI Mask:  Reg 0x874[0] = ((0x%x))\n", reg_value));
 	}
-	
+
 }
 
 VOID
@@ -2536,14 +2493,14 @@ phydm_clean_all_csi_mask(
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
 	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
-		
+
 		ODM_SetBBReg(pDM_Odm, 0xD40, bMaskDWord, 0);
 		ODM_SetBBReg(pDM_Odm, 0xD44, bMaskDWord, 0);
 		ODM_SetBBReg(pDM_Odm, 0xD48, bMaskDWord, 0);
 		ODM_SetBBReg(pDM_Odm, 0xD4c, bMaskDWord, 0);
-		
+
 	} else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
-	
+
 		ODM_SetBBReg(pDM_Odm, 0x880, bMaskDWord, 0);
 		ODM_SetBBReg(pDM_Odm, 0x884, bMaskDWord, 0);
 		ODM_SetBBReg(pDM_Odm, 0x888, bMaskDWord, 0);
@@ -2580,37 +2537,37 @@ phydm_set_csi_mask_reg(
 
 		tone_num = 64;
 		csi_mask_reg_p = 0xD40;
-		csi_mask_reg_n = 0xD48;		
-		
+		csi_mask_reg_n = 0xD48;
+
 	} else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
 
 		tone_num = 128;
 		csi_mask_reg_p = 0x880;
-		csi_mask_reg_n = 0x890;	
+		csi_mask_reg_n = 0x890;
 	}
-	
+
 	if (tone_direction == FREQ_POSITIVE) {
 
 		if (tone_idx_tmp >= (tone_num - 1))
 			tone_idx_tmp = (tone_num - 1);
-		
+
 		byte_offset = (u1Byte)(tone_idx_tmp >> 3);
 		bit_offset = (u1Byte)(tone_idx_tmp & 0x7);
 		target_reg = csi_mask_reg_p + byte_offset;
-		
+
 	} else {
 		tone_num_shift = tone_num;
-	
+
 		if (tone_idx_tmp >= tone_num)
 			tone_idx_tmp = tone_num;
 
 		tone_idx_tmp = tone_num - tone_idx_tmp;
-		
+
 		byte_offset = (u1Byte)(tone_idx_tmp >> 3);
-		bit_offset = (u1Byte)(tone_idx_tmp & 0x7);			
+		bit_offset = (u1Byte)(tone_idx_tmp & 0x7);
 		target_reg = csi_mask_reg_n + byte_offset;
 	}
-	
+
 	reg_tmp_value = ODM_Read1Byte(pDM_Odm, target_reg);
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_API, ODM_DBG_LOUD, ("Pre Mask tone idx[%d]:  Reg0x%x = ((0x%x))\n", (tone_idx_tmp + tone_num_shift), target_reg, reg_tmp_value));
 	reg_tmp_value |= BIT(bit_offset);
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/phydm_beamforming.c b/drivers/net/wireless/rtl8812au/hal/phydm/phydm_beamforming.c
index 1078cc9..c6fdd26 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/phydm_beamforming.c
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/phydm_beamforming.c
@@ -25,7 +25,7 @@ phydm_staInfoInit(
 	PRT_VERY_HIGH_THROUGHPUT	pVHTInfo = GET_VHT_INFO(pMgntInfo);
 
 	ODM_MoveMemory(pDM_Odm, pEntry->MyMacAddr, Adapter->CurrentAddress, 6);
-	
+
 	pEntry->HtBeamformCap = pHTInfo->HtBeamformCap;
 	pEntry->VhtBeamformCap = pVHTInfo->VhtBeamformCap;
 
@@ -44,15 +44,15 @@ phydm_staInfoInit(
 		pEntry->WirelessMode = pMgntInfo->dot11CurrentWirelessMode;
 		pEntry->BW = pMgntInfo->dot11CurrentChannelBandWidth;
 		pEntry->CurBeamform = pHTInfo->HtCurBeamform;
-	}	
+	}
 
 	if ((pEntry->WirelessMode & WIRELESS_MODE_AC_5G) || (pEntry->WirelessMode & WIRELESS_MODE_AC_24G)) {
 		if (staIdx != 0)
 			pEntry->CurBeamformVHT = pSTA->VHTInfo.VhtCurBeamform;
 		else
-			pEntry->CurBeamformVHT = pVHTInfo->VhtCurBeamform;	
+			pEntry->CurBeamformVHT = pVHTInfo->VhtCurBeamform;
 		}
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("pSTA->wireless_mode = 0x%x, staidx = %d\n", pSTA->WirelessMode, staIdx));
 #elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
 
@@ -91,16 +91,16 @@ void phydm_staInfoUpdate(
 	)
 {
 	PSTA_INFO_T pSTA = pDM_Odm->pODM_StaInfo[staIdx];
-	
+
 	if (!IS_STA_VALID(pSTA))
 		return;
-	
+
 #if (DM_ODM_SUPPORT_TYPE == ODM_CE)
 	pSTA->txbf_paid = pBeamformEntry->P_AID;
 	pSTA->txbf_gid = pBeamformEntry->G_ID;
-#endif	
+#endif
 }
-	
+
 
 u1Byte
 Beamforming_GetHTNDPTxRate(
@@ -112,12 +112,12 @@ Beamforming_GetHTNDPTxRate(
 	u1Byte Nr_index = 0;
 	u1Byte NDPTxRate;
 	/*Find Nr*/
-	
+
 	if (pDM_Odm->SupportICType & ODM_RTL8814A)
 		Nr_index = TxBF_Nr(halTxbf8814A_GetNtx(pDM_Odm), CompSteeringNumofBFer);
 	else
 		Nr_index = TxBF_Nr(1, CompSteeringNumofBFer);
-	
+
 	switch (Nr_index) {
 	case 1:
 	NDPTxRate = MGN_MCS8;
@@ -130,7 +130,7 @@ Beamforming_GetHTNDPTxRate(
 	case 3:
 	NDPTxRate = MGN_MCS24;
 	break;
-			
+
 	default:
 	NDPTxRate = MGN_MCS8;
 	break;
@@ -154,7 +154,7 @@ Beamforming_GetVHTNDPTxRate(
 		Nr_index = TxBF_Nr(halTxbf8814A_GetNtx(pDM_Odm), CompSteeringNumofBFer);
 	else
 		Nr_index = TxBF_Nr(1, CompSteeringNumofBFer);
-	
+
 	switch (Nr_index) {
 	case 1:
 	NDPTxRate = MGN_VHT2SS_MCS0;
@@ -167,7 +167,7 @@ Beamforming_GetVHTNDPTxRate(
 	case 3:
 	NDPTxRate = MGN_VHT4SS_MCS0;
 	break;
-			
+
 	default:
 	NDPTxRate = MGN_VHT2SS_MCS0;
 	break;
@@ -188,7 +188,7 @@ phydm_Beamforming_GetBFeeEntryByAddr(
 	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	u1Byte	i = 0;
 	PRT_BEAMFORMING_INFO pBeamInfo = &pDM_Odm->BeamformingInfo;
-	
+
 	for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
 		if (pBeamInfo->BeamformeeEntry[i].bUsed && (eqMacAddr(RA, pBeamInfo->BeamformeeEntry[i].MacAddr))) {
 			*Idx = i;
@@ -209,7 +209,7 @@ phydm_Beamforming_GetBFerEntryByAddr(
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	u1Byte		i = 0;
 	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
-	
+
 	for (i = 0; i < BEAMFORMER_ENTRY_NUM; i++) {
 		if (pBeamInfo->BeamformerEntry[i].bUsed &&  (eqMacAddr(TA, pBeamInfo->BeamformerEntry[i].MacAddr))) {
 			*Idx = i;
@@ -231,7 +231,7 @@ phydm_Beamforming_GetEntryByMacId(
 	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	u1Byte	i = 0;
 	PRT_BEAMFORMING_INFO pBeamInfo = &pDM_Odm->BeamformingInfo;
-	
+
 	for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
 		if (pBeamInfo->BeamformeeEntry[i].bUsed && (MacId == pBeamInfo->BeamformeeEntry[i].MacId)) {
 			*Idx = i;
@@ -253,7 +253,7 @@ phydm_Beamforming_GetEntryBeamCapByMacId(
 	u1Byte	i = 0;
 	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
 	BEAMFORMING_CAP			BeamformEntryCap = BEAMFORMING_CAP_NONE;
-	
+
 	for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
 		if (pBeamInfo->BeamformeeEntry[i].bUsed && (MacId == pBeamInfo->BeamformeeEntry[i].MacId)) {
 			BeamformEntryCap =  pBeamInfo->BeamformeeEntry[i].BeamformEntryCap;
@@ -279,7 +279,7 @@ phydm_Beamforming_GetFreeBFeeEntry(
 		if (pBeamInfo->BeamformeeEntry[i].bUsed == FALSE) {
 			*Idx = i;
 			return &(pBeamInfo->BeamformeeEntry[i]);
-		}	
+		}
 	}
 	return NULL;
 }
@@ -300,7 +300,7 @@ phydm_Beamforming_GetFreeBFerEntry(
 		if (pBeamInfo->BeamformerEntry[i].bUsed == FALSE) {
 			*Idx = i;
 			return &(pBeamInfo->BeamformerEntry[i]);
-		}	
+		}
 	}
 	return NULL;
 }
@@ -324,11 +324,11 @@ phydm_Beamforming_GetFirstMUBFeeEntryIdx(
 	BOOLEAN					bFound = FALSE;
 
 	for (idx = 0; idx < BEAMFORMEE_ENTRY_NUM; idx++) {
-		if (pBeamInfo->BeamformeeEntry[idx].bUsed && pBeamInfo->BeamformeeEntry[idx].is_mu_sta) {			
+		if (pBeamInfo->BeamformeeEntry[idx].bUsed && pBeamInfo->BeamformeeEntry[idx].is_mu_sta) {
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] idx=%d!\n", __func__, idx));
 			bFound = TRUE;
 			break;
-		}	
+		}
 	}
 
 	if (!bFound)
@@ -354,13 +354,13 @@ Beamforming_AddBFeeEntry(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
 
-	if (pEntry != NULL) {	
+	if (pEntry != NULL) {
 		pEntry->bUsed = TRUE;
 		pEntry->AID = pSTA->AID;
 		pEntry->MacId = pSTA->MacID;
 		pEntry->SoundBW = pSTA->BW;
 		ODM_MoveMemory(pDM_Odm, pEntry->MyMacAddr, pSTA->MyMacAddr, 6);
-		
+
 		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_AP)) {
 			/*BSSID[44:47] xor BSSID[40:43]*/
 			u2Byte BSSID = ((pSTA->MyMacAddr[5] & 0xf0) >> 4) ^ (pSTA->MyMacAddr[5] & 0xf);
@@ -433,7 +433,7 @@ Beamforming_AddBFerEntry(
 		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_AP)) {
 			/*BSSID[44:47] xor BSSID[40:43]*/
 			u2Byte BSSID = ((pSTA->MyMacAddr[5] & 0xf0) >> 4) ^ (pSTA->MyMacAddr[5] & 0xf);
-			
+
 			pEntry->P_AID = (pSTA->AID + BSSID * 32) & 0x1ff;
 			pEntry->G_ID = 63;
 			/*(dec(A) + dec(B)*32) mod 512*/
@@ -447,7 +447,7 @@ Beamforming_AddBFerEntry(
 			pEntry->G_ID = 0;
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: P_AID addressed to AP=0x%X\n", __func__, pEntry->P_AID));
 		}
-		
+
 		cpMacAddr(pEntry->MacAddr, pSTA->RA);
 		pEntry->BeamformEntryCap = BeamformCap;
 
@@ -488,18 +488,18 @@ Beamforming_RemoveEntry(
 	PRT_BEAMFORMER_ENTRY	pBFerEntry = phydm_Beamforming_GetBFerEntryByAddr(pDM_Odm, RA, Idx);
 	PRT_BEAMFORMEE_ENTRY	pEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, Idx);
 	BOOLEAN ret = FALSE;
-    
+
 	RT_DISP(FBEAM, FBEAM_FUN, ("[Beamforming]@%s Start!\n", __func__));
 	RT_DISP(FBEAM, FBEAM_FUN, ("[Beamforming]@%s, pBFerEntry=0x%x\n", __func__, pBFerEntry));
 	RT_DISP(FBEAM, FBEAM_FUN, ("[Beamforming]@%s, pEntry=0x%x\n", __func__, pEntry));
-	
-	if (pEntry != NULL) {	
+
+	if (pEntry != NULL) {
 		pEntry->bUsed = FALSE;
 		pEntry->BeamformEntryCap = BEAMFORMING_CAP_NONE;
 		/*pEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_UNINITIALIZE;*/
 		pEntry->bBeamformingInProgress = FALSE;
 		ret = TRUE;
-	} 
+	}
 	if (pBFerEntry != NULL) {
 		pBFerEntry->bUsed = FALSE;
 		pBFerEntry->BeamformEntryCap = BEAMFORMING_CAP_NONE;
@@ -514,13 +514,13 @@ Beamforming_RemoveEntry(
 VOID
 phydm_Beamforming_NDPARate(
 	IN	PVOID		pDM_VOID,
-	CHANNEL_WIDTH 	BW, 
+	CHANNEL_WIDTH 	BW,
 	u1Byte			Rate
 )
 {
 	u2Byte			NDPARate = Rate;
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
 
 	if (NDPARate == 0) {
@@ -561,9 +561,9 @@ phydm_Beamforming_DymNDPARate(
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s End, NDPA Rate = 0x%X\n", __func__, NDPARate));
 }
 
-/*	
-*	SW Sounding : SW Timer unit 1ms 
-*				 HW Timer unit (1/32000) s  32k is clock. 
+/*
+*	SW Sounding : SW Timer unit 1ms
+*				 HW Timer unit (1/32000) s  32k is clock.
 *	FW Sounding : FW Timer unit 10ms
 */
 VOID
@@ -573,7 +573,7 @@ Beamforming_DymPeriod(
 )
 {
 	u1Byte 					Idx;
-	BOOLEAN					bChangePeriod = FALSE;	
+	BOOLEAN					bChangePeriod = FALSE;
 	u2Byte					SoundPeriod_SW, SoundPeriod_FW;
 	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
@@ -584,7 +584,7 @@ Beamforming_DymPeriod(
 	PRT_BEAMFORMEE_ENTRY	pEntry = &(pBeamInfo->BeamformeeEntry[pBeamInfo->BeamformeeCurIdx]);
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
-	
+
 	//3 TODO  per-client throughput caculation.
 
 	if ((*(pDM_Odm->pCurrentTxTP) + *(pDM_Odm->pCurrentRxTP) > 2) && ((pEntry->LogStatusFailCnt <= 20) || status)) {
@@ -598,16 +598,16 @@ Beamforming_DymPeriod(
 
 	for (Idx = 0; Idx < BEAMFORMEE_ENTRY_NUM; Idx++) {
 		pBeamformEntry = pBeamInfo->BeamformeeEntry+Idx;
-		
+
 		if (pBeamformEntry->DefaultCSICnt > 20) {
 			/*Modified by David*/
 			SoundPeriod_SW = 4000;
 			SoundPeriod_FW = 400;
 		}
-		
-		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Period = %d\n", __func__, SoundPeriod_SW));		
+
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Period = %d\n", __func__, SoundPeriod_SW));
 		if (pBeamformEntry->BeamformEntryCap & (BEAMFORMER_CAP_HT_EXPLICIT | BEAMFORMER_CAP_VHT_SU)) {
-			if (pSoundInfo->SoundMode == SOUNDING_FW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_FW_HT_TIMER) {				
+			if (pSoundInfo->SoundMode == SOUNDING_FW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_FW_HT_TIMER) {
 				if (pBeamformEntry->SoundPeriod != SoundPeriod_FW) {
 					pBeamformEntry->SoundPeriod = SoundPeriod_FW;
 					bChangePeriod = TRUE;		/*Only FW sounding need to send H2C packet to change sound period. */
@@ -623,8 +623,6 @@ Beamforming_DymPeriod(
 }
 
 
-
-
 BOOLEAN
 Beamforming_SendHTNDPAPacket(
 	IN	PVOID			pDM_VOID,
@@ -645,7 +643,6 @@ Beamforming_SendHTNDPAPacket(
 }
 
 
-
 BOOLEAN
 Beamforming_SendVHTNDPAPacket(
 	IN	PVOID			pDM_VOID,
@@ -780,7 +777,7 @@ phydm_beamforming_SoundingMode(
 	if (BeamOidInfo.SoundOidMode == SOUNDING_SW_VHT_TIMER || BeamOidInfo.SoundOidMode == SOUNDING_HW_VHT_TIMER) {
 		if (BeamEntry.BeamformEntryCap & BEAMFORMER_CAP_VHT_SU)
 			Mode = BeamOidInfo.SoundOidMode;
-		else 
+		else
 			Mode = SOUNDING_STOP_All_TIMER;
 	} else if (BeamOidInfo.SoundOidMode == SOUNDING_SW_HT_TIMER || BeamOidInfo.SoundOidMode == SOUNDING_HW_HT_TIMER) {
 		if (BeamEntry.BeamformEntryCap & BEAMFORMER_CAP_HT_EXPLICIT)
@@ -797,7 +794,7 @@ phydm_beamforming_SoundingMode(
 			Mode = SOUNDING_FW_HT_TIMER;
 		else
 			Mode = SOUNDING_SW_HT_TIMER;
-	} else 
+	} else
 		Mode = SOUNDING_STOP_All_TIMER;
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SupportInterface=%d, Mode=%d\n", __func__, SupportInterface, Mode));
@@ -851,7 +848,7 @@ phydm_beamforming_SoundingBW(
 	else if (Mode == SOUNDING_SW_HT_TIMER || Mode == SOUNDING_SW_VHT_TIMER)
 		/*Modified by David*/
 		SoundingBW = BeamEntry.SoundBW;		/*BeamOidInfo.SoundOidBW;*/
-	else 
+	else
 		SoundingBW = BeamEntry.SoundBW;
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, SoundingBW=0x%X\n", __func__, SoundingBW));
@@ -878,7 +875,7 @@ phydm_Beamforming_SelectBeamEntry(
 		pSoundInfo->SoundMode = phydm_beamforming_SoundingMode(pDM_Odm, pBeamInfo, pSoundInfo->SoundIdx);
 	else
 		pSoundInfo->SoundMode = SOUNDING_STOP_All_TIMER;
-	
+
 	if (SOUNDING_STOP_All_TIMER == pSoundInfo->SoundMode) {
 		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Return because of SOUNDING_STOP_All_TIMER\n", __func__));
 		return FALSE;
@@ -899,8 +896,8 @@ phydm_beamforming_StartPeriod(
 	PADAPTER					Adapter = pDM_Odm->Adapter;
 	BOOLEAN						Ret = TRUE;
 	PRT_BEAMFORMING_INFO 		pBeamInfo = &pDM_Odm->BeamformingInfo;
-	PRT_SOUNDING_INFO			pSoundInfo = &(pBeamInfo->SoundingInfo); 
-	
+	PRT_SOUNDING_INFO			pSoundInfo = &(pBeamInfo->SoundingInfo);
+
 	phydm_Beamforming_DymNDPARate(pDM_Odm);
 
 	phydm_Beamforming_SelectBeamEntry(pDM_Odm, pBeamInfo);		// Modified
@@ -927,7 +924,7 @@ phydm_beamforming_StartPeriod(
 	else
 		Ret = FALSE;
 
-	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SoundIdx=%d, SoundMode=%d, SoundBW=%d, SoundPeriod=%d\n", __func__, 
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SoundIdx=%d, SoundMode=%d, SoundBW=%d, SoundPeriod=%d\n", __func__,
 			pSoundInfo->SoundIdx, pSoundInfo->SoundMode, pSoundInfo->SoundBW, pSoundInfo->SoundPeriod));
 
 	return Ret;
@@ -944,7 +941,7 @@ phydm_beamforming_EndPeriod_SW(
 	PADAPTER					Adapter = pDM_Odm->Adapter;
 	PRT_BEAMFORMING_INFO 		pBeamInfo = &pDM_Odm->BeamformingInfo;
 	PRT_SOUNDING_INFO			pSoundInfo = &(pBeamInfo->SoundingInfo);
-	
+
 	HAL_HW_TIMER_TYPE TimerType = HAL_TIMER_TXBF;
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
@@ -972,7 +969,7 @@ phydm_beamforming_EndPeriod_FW(
 
 
 /*SU BFee Entry Only*/
-VOID 
+VOID
 phydm_beamforming_ClearEntry_SW(
 	IN	PVOID			pDM_VOID,
 	BOOLEAN				IsDelete,
@@ -1009,13 +1006,13 @@ phydm_beamforming_ClearEntry_SW(
 			/*Used after bSounding=RESET, and will clear the setting of "ever sounded" entry, which is not necessarily be deleted.*/
 			/*This function is mainly used in case "BeamOidInfo.SoundOidMode == SOUNDING_STOP_All_TIMER".*/
 			/*However, setting oid doesn't delete entries (bUsed is still TRUE), new entries may fail to be added in.*/
-		
+
 			if (pBeamformEntry->bSound) {
 				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SW reset BFee entry %d\n", __func__, Idx));
-				/*	
-				*	If End procedure is 
+				/*
+				*	If End procedure is
 				*	1. Between (Send NDPA, C2H packet return), reset state to initialized.
-				*	After C2H packet return , status bit will be set to zero. 
+				*	After C2H packet return , status bit will be set to zero.
 				*
 				*	2. After C2H packet, then reset state to initialized and clear status bit.
 				*/
@@ -1064,17 +1061,17 @@ phydm_beamforming_ClearEntry_FW(
 			/*Used after bSounding=RESET, and will clear the setting of "ever sounded" entry, which is not necessarily be deleted.*/
 			/*This function is mainly used in case "BeamOidInfo.SoundOidMode == SOUNDING_STOP_All_TIMER".*/
 			/*However, setting oid doesn't delete entries (bUsed is still TRUE), new entries may fail to be added in.*/
-		
+
 			if (pBeamformEntry->bSound) {
 				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]FW reset BFee entry %d\n", __func__, Idx));
-				/*	
-				*	If End procedure is 
+				/*
+				*	If End procedure is
 				*	1. Between (Send NDPA, C2H packet return), reset state to initialized.
-				*	After C2H packet return , status bit will be set to zero. 
+				*	After C2H packet return , status bit will be set to zero.
 				*
 				*	2. After C2H packet, then reset state to initialized and clear status bit.
 				*/
-				
+
 				pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZED;
 				pBeamformEntry->bSound = FALSE;
 			}
@@ -1083,7 +1080,7 @@ phydm_beamforming_ClearEntry_FW(
 }
 
 /*
-* 	Called : 
+* 	Called :
 *	1. Add and delete entry : Beamforming_Enter/Beamforming_Leave
 *	2. FW trigger :  Beamforming_SetTxBFen
 *	3. Set OID_RT_BEAMFORMING_PERIOD : BeamformingControl_V2
@@ -1105,7 +1102,6 @@ phydm_Beamforming_Notify(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, Before notify, bSounding=%d, Idx=%d\n", __func__, bSounding, Idx));
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: pBeamInfo->beamformee_su_cnt = %d\n", __func__, pBeamInfo->beamformee_su_cnt));
-	
 
 	switch (bSounding) {
 	case BEAMFORMEE_NOTIFY_ADD_SU:
@@ -1136,8 +1132,9 @@ phydm_Beamforming_Notify(
 			/*if (pSoundInfo->SoundMode == SOUNDING_SW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_SW_HT_TIMER)
 				ODM_SetTimer(pDM_Odm, &pBeamInfo->BeamformingTimer, pSoundInfo->SoundPeriod);*/
 			ODM_SetTimer(pDM_Odm, &pBeamInfo->BeamformingTimer, 1000); /*Do MU sounding every 1sec*/
-		} else
+		} else {
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: Less or larger than 2 MU STAs, not to set timer\n", __func__));
+		}
 	break;
 
 	case BEAMFORMEE_NOTIFY_DELETE_MU:
@@ -1151,7 +1148,7 @@ phydm_Beamforming_Notify(
 	break;
 
 	case BEAMFORMING_NOTIFY_RESET:
-		if (pSoundInfo->SoundMode == SOUNDING_FW_HT_TIMER || pSoundInfo->SoundMode == SOUNDING_FW_VHT_TIMER) {	
+		if (pSoundInfo->SoundMode == SOUNDING_FW_HT_TIMER || pSoundInfo->SoundMode == SOUNDING_FW_VHT_TIMER) {
 			phydm_beamforming_ClearEntry_FW(pDM_Odm, FALSE, Idx);
 			phydm_beamforming_EndPeriod_FW(pDM_Odm);
 		} else {
@@ -1168,7 +1165,6 @@ phydm_Beamforming_Notify(
 }
 
 
-
 BOOLEAN
 Beamforming_InitEntry(
 	IN	PVOID		pDM_VOID,
@@ -1188,7 +1184,7 @@ Beamforming_InitEntry(
 
 	/*The current setting does not support Beaforming*/
 	if (BEAMFORMING_CAP_NONE == pSTA->HtBeamformCap && BEAMFORMING_CAP_NONE == pSTA->VhtBeamformCap) {
-		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("The configuration disabled Beamforming! Skip...\n"));		
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("The configuration disabled Beamforming! Skip...\n"));
 		return FALSE;
 	}
 
@@ -1210,7 +1206,7 @@ Beamforming_InitEntry(
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] HT NumofSoundingDim=%d, CompSteeringNumofBFer=%d\n", __func__, NumofSoundingDim, CompSteeringNumofBFer));
 		}
 #if	(ODM_IC_11AC_SERIES_SUPPORT == 1)
-		if (pSTA->WirelessMode & WIRELESS_MODE_AC_5G || pSTA->WirelessMode & WIRELESS_MODE_AC_24G) {	/*VHT*/	
+		if (pSTA->WirelessMode & WIRELESS_MODE_AC_5G || pSTA->WirelessMode & WIRELESS_MODE_AC_24G) {	/*VHT*/
 
 			/* We are Beamformee because the STA is SU Beamformer*/
 			if (TEST_FLAG(pSTA->CurBeamformVHT, BEAMFORMING_VHT_BEAMFORMER_ENABLE)) {
@@ -1238,7 +1234,7 @@ Beamforming_InitEntry(
 			}
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]VHT CurBeamformVHT=0x%X, BeamformCap=0x%X\n", __func__, pSTA->CurBeamformVHT, BeamformCap));
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]VHT NumofSoundingDim=0x%X, CompSteeringNumofBFer=0x%X\n", __func__, NumofSoundingDim, CompSteeringNumofBFer));
-			
+
 		}
 #endif
 	}
@@ -1246,17 +1242,18 @@ Beamforming_InitEntry(
 
 	if(BeamformCap == BEAMFORMING_CAP_NONE)
 		return FALSE;
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Self BF Entry Cap = 0x%02X\n", __func__, BeamformCap));
 
 	/*We are BFee, so the entry is BFer*/
 	if (BeamformCap & (BEAMFORMEE_CAP_VHT_MU | BEAMFORMEE_CAP_VHT_SU | BEAMFORMEE_CAP_HT_EXPLICIT)) {
 		pBeamformerEntry = phydm_Beamforming_GetBFerEntryByAddr(pDM_Odm, pSTA->RA, &BFerIdx);
-		
+
 		if (pBeamformerEntry == NULL) {
 			pBeamformerEntry = Beamforming_AddBFerEntry(pDM_Odm, pSTA, BeamformCap, NumofSoundingDim , &BFerIdx);
-			if (pBeamformerEntry == NULL)
+			if (pBeamformerEntry == NULL) {
 				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]Not enough BFer entry!!!!!\n", __func__));
+			}
 		}
 	}
 
@@ -1272,17 +1269,19 @@ Beamforming_InitEntry(
 
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]: Add BFee entry %d\n", __func__, BFeeIdx));
 
-			if (pBeamformEntry == NULL)
+			if (pBeamformEntry == NULL) {
 				return FALSE;
-			else
+			} else {
 				pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZEING;
+			}
 		} else {
 			/*Entry has been created. If entry is initialing or progressing then errors occur.*/
-			if (pBeamformEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_INITIALIZED && 
+			if (pBeamformEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_INITIALIZED &&
 				pBeamformEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_PROGRESSED) {
 				return FALSE;
-			} else
+			} else {
 				pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZEING;
+			}
 		}
 		pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZED;
 		phydm_staInfoUpdate(pDM_Odm, staIdx, pBeamformEntry);
@@ -1309,7 +1308,7 @@ Beamforming_DeInitEntry(
 	BOOLEAN ret = FALSE;
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n",  __func__));
-	
+
 	if (pBFeeEntry != NULL) {
 		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, pBFeeEntry\n", __func__));
 		pBFeeEntry->bUsed = FALSE;
@@ -1322,8 +1321,8 @@ Beamforming_DeInitEntry(
 			pDM_Odm->BeamformingInfo.beamformee_su_cnt -= 1;
 		}
 		ret = TRUE;
-	} 
-	
+	}
+
 	if (pBFerEntry != NULL) {
 		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, pBFerEntry\n", __func__));
 		pBFerEntry->bUsed = FALSE;
@@ -1356,7 +1355,7 @@ BeamformingStart_V1(
 	PRT_BEAMFORMEE_ENTRY	pEntry;
 	BOOLEAN					ret = TRUE;
 	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
-	
+
 	pEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
 
 	if (pEntry->bUsed == FALSE) {
@@ -1368,7 +1367,7 @@ BeamformingStart_V1(
 
 		pEntry->bBeamformingInProgress = TRUE;
 
-		if (Mode == 1) {	
+		if (Mode == 1) {
 			if (!(pEntry->BeamformEntryCap & BEAMFORMER_CAP_HT_EXPLICIT)) {
 				pEntry->bBeamformingInProgress = FALSE;
 				return FALSE;
@@ -1395,7 +1394,7 @@ BeamformingStart_V1(
 	HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_STATUS, (pu1Byte)&Idx);
 
 	if (Mode == 1)
-		ret = Beamforming_SendHTNDPAPacket(pDM_Odm, RA, BW, NORMAL_QUEUE);	
+		ret = Beamforming_SendHTNDPAPacket(pDM_Odm, RA, BW, NORMAL_QUEUE);
 	else
 		ret = Beamforming_SendVHTNDPAPacket(pDM_Odm, RA, pEntry->AID, BW, NORMAL_QUEUE);
 
@@ -1414,7 +1413,7 @@ BOOLEAN
 BeamformingStart_SW(
 	IN	PVOID		pDM_VOID,
 	u1Byte			Idx,
-	u1Byte			Mode, 
+	u1Byte			Mode,
 	CHANNEL_WIDTH	BW
 	)
 {
@@ -1444,8 +1443,8 @@ BeamformingStart_SW(
 
 			pEntry->bBeamformingInProgress = TRUE;
 			RA = pEntry->MacAddr;
-			
-			if (Mode == SOUNDING_SW_HT_TIMER || Mode == SOUNDING_HW_HT_TIMER || Mode == SOUNDING_AUTO_HT_TIMER) {	
+
+			if (Mode == SOUNDING_SW_HT_TIMER || Mode == SOUNDING_HW_HT_TIMER || Mode == SOUNDING_AUTO_HT_TIMER) {
 				if (!(pEntry->BeamformEntryCap & BEAMFORMER_CAP_HT_EXPLICIT)) {
 					pEntry->bBeamformingInProgress = FALSE;
 					ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Return by not support BEAMFORMER_CAP_HT_EXPLICIT <==\n", __func__));
@@ -1470,12 +1469,12 @@ BeamformingStart_SW(
 
 		pBeamInfo->BeamformeeCurIdx = Idx;
 	}
-	
+
 	/*2014.12.22 Luke: Need to be checked*/
 	/*GET_TXBF_INFO(Adapter)->fTxbfSet(Adapter, TXBF_SET_SOUNDING_STATUS, (pu1Byte)&Idx);*/
 
 	if (Mode == SOUNDING_SW_HT_TIMER || Mode == SOUNDING_HW_HT_TIMER || Mode == SOUNDING_AUTO_HT_TIMER)
-		ret = Beamforming_SendHTNDPAPacket(pDM_Odm, RA , BW, NORMAL_QUEUE);	
+		ret = Beamforming_SendHTNDPAPacket(pDM_Odm, RA , BW, NORMAL_QUEUE);
 	else
 		ret = Beamforming_SendVHTNDPAPacket(pDM_Odm, RA , pEntry->AID, BW, NORMAL_QUEUE);
 
@@ -1485,7 +1484,7 @@ BeamformingStart_SW(
 		return FALSE;
 	}
 
-	
+
 	/*--------------------------
 	// Send BF Report Poll for MU BF
 	--------------------------*/
@@ -1494,9 +1493,9 @@ BeamformingStart_SW(
 {
 	u1Byte				idx, PollSTACnt = 0;
 	BOOLEAN				bGetFirstBFee = FALSE;
-	
+
 	if (pBeamInfo->beamformee_mu_cnt > 1) { /* More than 1 MU STA*/
-	
+
 		for (idx = 0; idx < BEAMFORMEE_ENTRY_NUM; idx++) {
 			pEntry = &(pBeamInfo->BeamformeeEntry[idx]);
 			if (pEntry->is_mu_sta) {
@@ -1538,7 +1537,7 @@ BeamformingStart_FW(
 	pEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_PROGRESSING;
 	pEntry->bSound = TRUE;
 	HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_FW_NDPA, (pu1Byte)&Idx);
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] End, Idx=0x%X\n", __func__, Idx));
 	return TRUE;
 }
@@ -1546,7 +1545,7 @@ BeamformingStart_FW(
 VOID
 Beamforming_CheckSoundingSuccess(
 	IN PVOID			pDM_VOID,
-	BOOLEAN			Status	
+	BOOLEAN			Status
 )
 {
 	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
@@ -1573,7 +1572,7 @@ Beamforming_CheckSoundingSuccess(
 VOID
 phydm_Beamforming_End_SW(
 	IN PVOID		pDM_VOID,
-	BOOLEAN			Status	
+	BOOLEAN			Status
 	)
 {
 	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
@@ -1604,20 +1603,20 @@ phydm_Beamforming_End_SW(
 			HalComTxbf_Set(pDM_Odm, TXBF_SET_TX_PATH_RESET, (pu1Byte)&(pBeamInfo->BeamformeeCurIdx));
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] LogStatusFailCnt %d\n", __func__, pEntry->LogStatusFailCnt));
 		}
-		
+
 		if (pEntry->LogStatusFailCnt > 50) {
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s LogStatusFailCnt > 50, Stop SOUNDING\n", __func__));
 			pEntry->bSound = FALSE;
-			Beamforming_DeInitEntry(pDM_Odm, pEntry->MacAddr); 
+			Beamforming_DeInitEntry(pDM_Odm, pEntry->MacAddr);
 
 			/*Modified by David - Every action of deleting entry should follow by Notify*/
 			phydm_Beamforming_Notify(pDM_Odm);
-		}	
-		
+		}
+
 		pEntry->bBeamformingInProgress = FALSE;
 	}
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: Status=%d\n", __func__, Status));
-}	
+}
 
 
 VOID
@@ -1645,28 +1644,29 @@ Beamforming_TimerCallback(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
 
-	if (pBeamInfo->is_mu_sounding)
+	if (pBeamInfo->is_mu_sounding) {
 		bBeamformingInProgress = pBeamInfo->is_mu_sounding_in_progress;
-	else
+	} else {
 		bBeamformingInProgress = pEntry->bBeamformingInProgress;
-
+	}
 	if (bBeamformingInProgress) {
 	 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("bBeamformingInProgress, reset it\n"));
 		phydm_Beamforming_End_SW(pDM_Odm, 0);
-	 }
+	}
 
 	ret = phydm_Beamforming_SelectBeamEntry(pDM_Odm, pBeamInfo);
 #if (SUPPORT_MU_BF == 1)
-	if (ret && pBeamInfo->beamformee_mu_cnt > 1)
+	if (ret && pBeamInfo->beamformee_mu_cnt > 1) {
 		ret = 1;
-	else
+	} else {
 		ret = 0;
+	}
 #endif
-	if (ret)
+	if (ret) {
 		ret = BeamformingStart_SW(pDM_Odm, pSoundInfo->SoundIdx, pSoundInfo->SoundMode, pSoundInfo->SoundBW);
-	else
+	} else {
 		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, Error value return from BeamformingStart_V2\n", __func__));
-
+	}
 	if ((pBeamInfo->beamformee_su_cnt != 0) || (pBeamInfo->beamformee_mu_cnt > 1)) {
 		if (pSoundInfo->SoundMode == SOUNDING_SW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_SW_HT_TIMER)
 			ODM_SetTimer(pDM_Odm, &pBeamInfo->BeamformingTimer, pSoundInfo->SoundPeriod);
@@ -1691,7 +1691,7 @@ Beamforming_SWTimerCallback(
 	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 	Beamforming_TimerCallback(pDM_Odm);
 #elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
@@ -1776,7 +1776,7 @@ Beamforming_Enter(
 {
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	u1Byte			BFerBFeeIdx = 0xff;
-	
+
 	if (Beamforming_InitEntry(pDM_Odm, staIdx, &BFerBFeeIdx))
 		HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_ENTER, (pu1Byte)&BFerBFeeIdx);
 
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/phydm_hwconfig.c b/drivers/net/wireless/rtl8812au/hal/phydm/phydm_hwconfig.c
index 48d31a1..769381f 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/phydm_hwconfig.c
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/phydm_hwconfig.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -42,7 +42,7 @@
 
 
 #define READ_FIRMWARE_MP(ic, txt) 		(ODM_ReadFirmware_MP_##ic##txt(pDM_Odm, pFirmware, pSize))
-#define READ_FIRMWARE_TC(ic, txt) 		(ODM_ReadFirmware_TC_##ic##txt(pDM_Odm, pFirmware, pSize))		
+#define READ_FIRMWARE_TC(ic, txt) 		(ODM_ReadFirmware_TC_##ic##txt(pDM_Odm, pFirmware, pSize))
 
 #if (PHYDM_TESTCHIP_SUPPORT == 1)
 #define READ_FIRMWARE(ic, txt) do {\
@@ -50,11 +50,11 @@
 							READ_FIRMWARE_MP(ic,txt);\
 						else\
 							READ_FIRMWARE_TC(ic,txt);\
-					} while(0) 
+					} while(0)
 #else
 #define READ_FIRMWARE     READ_FIRMWARE_MP
 #endif
-						
+
 #define GET_VERSION_MP(ic, txt) 		(ODM_GetVersion_MP_##ic##txt())
 #define GET_VERSION_TC(ic, txt) 		(ODM_GetVersion_TC_##ic##txt())
 #define GET_VERSION(ic, txt) (pDM_Odm->bIsMPChip?GET_VERSION_MP(ic,txt):GET_VERSION_TC(ic,txt))
@@ -78,14 +78,14 @@ odm_QueryRxPwrPercentage(
 // IF other SW team do not support the feature, remove this section.??
 //
 s4Byte
-odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Lenovo(	
+odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Lenovo(
 	IN OUT PDM_ODM_T pDM_Odm,
-	s4Byte CurrSig 
+	s4Byte CurrSig
 )
-{	
+{
 	s4Byte RetSig = 0;
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	//if(pDM_Odm->SupportInterface  == ODM_ITRF_PCIE) 
+	//if(pDM_Odm->SupportInterface  == ODM_ITRF_PCIE)
 	{
 		// Step 1. Scale mapping.
 		// 20100611 Joseph: Re-tunning RSSI presentation for Lenovo.
@@ -116,16 +116,16 @@ odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Lenovo(
 }
 
 s4Byte
-odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Netcore(	
+odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Netcore(
 	IN OUT PDM_ODM_T pDM_Odm,
-	s4Byte CurrSig 
+	s4Byte CurrSig
 )
 {
 	s4Byte RetSig = 0;
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	//if(pDM_Odm->SupportInterface  == ODM_ITRF_USB)
 	{
-		// Netcore request this modification because 2009.04.13 SU driver use it. 
+		// Netcore request this modification because 2009.04.13 SU driver use it.
 		if (CurrSig >= 31 && CurrSig <= 100)
 			RetSig = 100;
 		else if (CurrSig >= 21 && CurrSig <= 30)
@@ -155,14 +155,14 @@ odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Netcore(
 
 
 s4Byte
-odm_SignalScaleMapping_92CSeries(	
+odm_SignalScaleMapping_92CSeries(
 	IN OUT PDM_ODM_T pDM_Odm,
-	IN s4Byte CurrSig 
+	IN s4Byte CurrSig
 )
 {
-	s4Byte RetSig = 0; 
-#if (DEV_BUS_TYPE == RT_PCI_INTERFACE) 
-	if (pDM_Odm->SupportInterface  == ODM_ITRF_PCIE) 
+	s4Byte RetSig = 0;
+#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)
+	if (pDM_Odm->SupportInterface  == ODM_ITRF_PCIE)
 	{
 		// Step 1. Scale mapping.
 		if(CurrSig >= 61 && CurrSig <= 100)
@@ -1279,6 +1279,9 @@ odm_RxPhyStatusJaguarSeries_Parsing(
 							EVM += 20;
 							if (EVM > 100)
 								EVM = 100;
+						} else {
+							// it's a made up value, but Realtek apparently assumed 'this would never happen'
+							EVM = 0;
 						}
 					} else {
 						if (i < ODM_RF_PATH_C) {
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/phydm_kfree.c b/drivers/net/wireless/rtl8812au/hal/phydm/phydm_kfree.c
index a91cdee..889c050 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/phydm_kfree.c
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/phydm_kfree.c
@@ -38,7 +38,7 @@ phydm_SetKfreeToRF_8814A(
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
 	BOOLEAN bOdd;
-	
+
 	if ((Data%2) != 0) {	/*odd -> positive*/
 		Data = Data - 1;
 		ODM_SetRFReg(pDM_Odm, eRFPath, rRF_TxGainOffset, BIT19, 1);
@@ -113,9 +113,9 @@ phydm_SetKfreeToRF_8814A(
 	/*that means Kfree offset is negative, we need to record it.*/
 		pRFCalibrateInfo->KfreeOffset[eRFPath] = (-1)*pRFCalibrateInfo->KfreeOffset[eRFPath];
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_MP, ODM_DBG_LOUD, ("phy_ConfigKFree8814A(): KfreeOffset = %d\n", pRFCalibrateInfo->KfreeOffset[eRFPath]));
-	} else
+	} else {
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_MP, ODM_DBG_LOUD, ("phy_ConfigKFree8814A(): KfreeOffset = %d\n", pRFCalibrateInfo->KfreeOffset[eRFPath]));
-	
+	}
 }
 
 
@@ -127,7 +127,7 @@ phydm_SetKfreeToRF(
 	)
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	
+
 	if (pDM_Odm->SupportICType & ODM_RTL8814A)
 		phydm_SetKfreeToRF_8814A(pDM_Odm, eRFPath, Data);
 }
@@ -150,9 +150,9 @@ phydm_ConfigKFree(
 		maxRFpath = 2;	/*0~1*/
 	else
 		maxRFpath = 1;
-	
+
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_MP, ODM_DBG_LOUD, ("===>phy_ConfigKFree8814A()\n"));
-	
+
 	if (pRFCalibrateInfo->RegRfKFreeEnable == 2) {
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_MP, ODM_DBG_LOUD, ("phy_ConfigKFree8814A(): RegRfKFreeEnable == 2, Disable\n"));
 		return;
@@ -188,4 +188,3 @@ phydm_ConfigKFree(
 	}
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_MP, ODM_DBG_LOUD, ("<===phy_ConfigKFree8814A()\n"));
 }
-
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/phydm_pathdiv.c b/drivers/net/wireless/rtl8812au/hal/phydm/phydm_pathdiv.c
index 0ddeba3..d6aa427 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/phydm_pathdiv.c
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/phydm_pathdiv.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -37,34 +37,28 @@ phydm_dtp_fix_tx_path(
 	pPATHDIV_T		pDM_PathDiv = &pDM_Odm->DM_PathDiv;
 	u1Byte			i,num_enable_path=0;
 
-	if(path==pDM_PathDiv->pre_tx_path)
-	{
+	if (path==pDM_PathDiv->pre_tx_path) {
 		return;
-	}
-	else
-	{
+	} else {
 		pDM_PathDiv->pre_tx_path=path;
 	}
 
 	ODM_SetBBReg( pDM_Odm, 0x93c, BIT18|BIT19, 3);
 
-	for(i=0; i<4; i++)
-	{
-		if(path&BIT(i))
+	for (i=0; i<4; i++) {
+		if (path&BIT(i))
 			num_enable_path++;
 	}
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Number of trun-on path : (( %d ))\n", num_enable_path));
 
-	if(num_enable_path == 1)
-	{
+	if (num_enable_path == 1) {
 		ODM_SetBBReg( pDM_Odm, 0x93c, 0xf00000, path);
-	
-		if(path==PHYDM_A)//1-1
-		{
+
+		if (path==PHYDM_A) { //1-1
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A ))\n"));
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
 		}
-		else 	if(path==PHYDM_B)//1-2
+		else 	if (path==PHYDM_B)//1-2
 		{
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( B ))\n"));
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 0);
@@ -82,20 +76,19 @@ phydm_dtp_fix_tx_path(
 		}
 
 	}
-	else 	if(num_enable_path == 2)
+	else 	if (num_enable_path == 2)
 	{
 		ODM_SetBBReg( pDM_Odm, 0x93c, 0xf00000, path);
 		ODM_SetBBReg( pDM_Odm, 0x940, 0xf0, path);
-	
-		if(path==PHYDM_AB)//2-1
-		{
+
+		if (path==PHYDM_AB) { //2-1
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A B ))\n"));
 			//set for 1ss
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 1);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);			
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);
 		}
 		else 	if(path==PHYDM_AC)//2-2
 		{
@@ -105,7 +98,7 @@ phydm_dtp_fix_tx_path(
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 1);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);	
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);
 		}
 		else 	if(path==PHYDM_AD)//2-3
 		{
@@ -115,7 +108,7 @@ phydm_dtp_fix_tx_path(
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 1);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);	
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);
 		}
 		else 	if(path==PHYDM_BC)//2-4
 		{
@@ -125,7 +118,7 @@ phydm_dtp_fix_tx_path(
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 1);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);	
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);
 		}
 		else 	if(path==PHYDM_BD)//2-5
 		{
@@ -135,7 +128,7 @@ phydm_dtp_fix_tx_path(
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 1);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);	
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);
 		}
 		else 	if(path==PHYDM_CD)//2-6
 		{
@@ -145,7 +138,7 @@ phydm_dtp_fix_tx_path(
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 1);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);	
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);
 		}
 
 	}
@@ -154,14 +147,13 @@ phydm_dtp_fix_tx_path(
 		ODM_SetBBReg( pDM_Odm, 0x93c, 0xf00000, path);
 		ODM_SetBBReg( pDM_Odm, 0x940, 0xf0, path);
 		ODM_SetBBReg( pDM_Odm, 0x940, 0xf0000, path);
-	
-		if(path==PHYDM_ABC)//3-1
-		{
+
+		if(path==PHYDM_ABC) { //3-1
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A B C))\n"));
 			//set for 1ss
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 1);
-			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 2);			
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 2);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);
@@ -176,11 +168,11 @@ phydm_dtp_fix_tx_path(
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A B D ))\n"));
 			//set for 1ss
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
-			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 1);		
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 1);
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);		
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 2);
 			//set for 3ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT21|BIT20, 0);
@@ -194,7 +186,7 @@ phydm_dtp_fix_tx_path(
 			//set for 1ss
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 1);
-			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);			
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);
@@ -210,7 +202,7 @@ phydm_dtp_fix_tx_path(
 			//set for 1ss
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 0);
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 1);
-			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);			
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 0);
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);
@@ -268,9 +260,7 @@ phydm_find_default_path(
 		{
 			pDM_PathDiv->is_pathA_exist=FALSE;
 		}
-	}
-	else
-	{
+	} else {
 		if( (rssi_avg_a >=rssi_avg_b) && (rssi_avg_a >=rssi_avg_c)&&(rssi_avg_a >=rssi_avg_d))
 			pDM_PathDiv->default_path=PATH_A;
 		else if(  (rssi_avg_b >=rssi_avg_c)&&(rssi_avg_b >=rssi_avg_d))
@@ -294,19 +284,14 @@ phydm_candidate_dtp_update(
 	pPATHDIV_T		pDM_PathDiv = &pDM_Odm->DM_PathDiv;
 
 	pDM_PathDiv->num_candidate=3;
-	
-	if(pDM_PathDiv->use_path_a_as_default_ant == 1)
-	{
-		if(pDM_PathDiv->num_tx_path==3)
-		{
-			if(pDM_PathDiv->is_pathA_exist)
-			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD; 
+
+	if(pDM_PathDiv->use_path_a_as_default_ant == 1) {
+		if(pDM_PathDiv->num_tx_path==3) {
+			if(pDM_PathDiv->is_pathA_exist) {
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD;
 				pDM_PathDiv->ant_candidate_3 =  PHYDM_ACD;
-			}
-			else // use path BCD 
-			{
+			} else { // use path BCD
 				pDM_PathDiv->num_candidate=1;
 				phydm_dtp_fix_tx_path(pDM_Odm, PHYDM_BCD);
 				return;
@@ -316,75 +301,69 @@ phydm_candidate_dtp_update(
 		{
 			if(pDM_PathDiv->is_pathA_exist)
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_AC; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_AD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_AC;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_AD;
+			} else {
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_BC;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_BD;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_CD;
 			}
-			else
-			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_BC; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_BD; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_CD; 
-			}	
 		}
-	}
-	else
-	{
-		//2 3 TX Mode 
-		if(pDM_PathDiv->num_tx_path==3)//choose 3 ant form 4 
-		{
-			if(pDM_PathDiv->default_path == PATH_A) //choose 2 ant form 3
-			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_ACD; 
+	} else {
+		//2 3 TX Mode
+		if(pDM_PathDiv->num_tx_path==3) { //choose 3 ant form 4
+			if(pDM_PathDiv->default_path == PATH_A) { //choose 2 ant form 3
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_ACD;
 			}
 			else if(pDM_PathDiv->default_path==PATH_B)
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD;
 			}
 			else if(pDM_PathDiv->default_path == PATH_C)
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_ACD; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ACD;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD;
 			}
 			else if(pDM_PathDiv->default_path == PATH_D)
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABD; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_ACD; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABD;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ACD;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD;
 			}
 		}
-		
-		//2 2 TX Mode 
-		else if(pDM_PathDiv->num_tx_path==2)//choose 2 ant form 4 
+
+		//2 2 TX Mode
+		else if(pDM_PathDiv->num_tx_path==2)//choose 2 ant form 4
 		{
 			if(pDM_PathDiv->default_path == PATH_A) //choose 2 ant form 3
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_AC; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_AD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_AC;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_AD;
 			}
 			else if(pDM_PathDiv->default_path==PATH_B)
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_BC; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_BD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_BC;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_BD;
 			}
 			else if(pDM_PathDiv->default_path == PATH_C)
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_AC; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_BC; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_CD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_AC;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_BC;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_CD;
 			}
 			else if(pDM_PathDiv->default_path == PATH_D)
 			{
-				pDM_PathDiv->ant_candidate_1=  PHYDM_AD; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_BD; 
-				pDM_PathDiv->ant_candidate_3=  PHYDM_CD; 
+				pDM_PathDiv->ant_candidate_1=  PHYDM_AD;
+				pDM_PathDiv->ant_candidate_2=  PHYDM_BD;
+				pDM_PathDiv->ant_candidate_3=  PHYDM_CD;
 			}
 		}
 	}
@@ -397,108 +376,96 @@ phydm_dynamic_tx_path(
 )
 {
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	pPATHDIV_T		pDM_PathDiv = &pDM_Odm->DM_PathDiv;	
-	
+	pPATHDIV_T		pDM_PathDiv = &pDM_Odm->DM_PathDiv;
+
 	PSTA_INFO_T   	pEntry;
 	u4Byte	i;
 	u1Byte	num_client=0;
 	u1Byte	H2C_Parameter[6] ={0};
 
 
-	if(!pDM_Odm->bLinked) //bLinked==False
-	{
+	if(!pDM_Odm->bLinked) { //bLinked==False
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("DTP_8814 [No Link!!!]\n"));
-		
-		if(pDM_PathDiv->bBecomeLinked == TRUE)
-		{
+
+		if(pDM_PathDiv->bBecomeLinked == TRUE) {
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" [Be disconnected]----->\n"));
 			pDM_PathDiv->bBecomeLinked = pDM_Odm->bLinked;
 		}
 		return;
-	}	
-	else
-	{
-		if(pDM_PathDiv->bBecomeLinked ==FALSE)
-		{
+	} else {
+		if(pDM_PathDiv->bBecomeLinked ==FALSE) {
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" [Be Linked !!!]----->\n"));
 			pDM_PathDiv->bBecomeLinked = pDM_Odm->bLinked;
-		}	
-	}	
-	
-	//2 [Period CTRL]
-	if(pDM_PathDiv->dtp_period >=2)
-	{
-		pDM_PathDiv->dtp_period=0;	
+		}
 	}
-	else
-	{	
+
+	//2 [Period CTRL]
+	if(pDM_PathDiv->dtp_period >=2) {
+		pDM_PathDiv->dtp_period=0;
+	} else {
 		//ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("Phydm_Dynamic_Tx_Path_8814A()  Stay = (( %d ))\n",pDM_PathDiv->dtp_period));
-		pDM_PathDiv->dtp_period++;		
+		pDM_PathDiv->dtp_period++;
 		return;
 	}
-	
+
 
 	//2 [Fix Path]
 	if (pDM_Odm->path_select != PHYDM_AUTO_PATH)
 	{
 		return;
 	}
-	
-	//2 [Check Bfer]	
+
+	//2 [Check Bfer]
 	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	#if (BEAMFORMING_SUPPORT == 1)
 	{
 		BEAMFORMING_CAP		BeamformCap = (pDM_Odm->BeamformingInfo.BeamformCap);
 
 		if( BeamformCap & BEAMFORMER_CAP ) //  BFmer On  &&   Div On ->  Div Off
-		{	
-			if( pDM_PathDiv->fix_path_bfer == 0) 
+		{
+			if( pDM_PathDiv->fix_path_bfer == 0)
 			{
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("[ PathDiv : OFF ]   BFmer ==1  \n"));
-				pDM_PathDiv->fix_path_bfer = 1 ;			
+				pDM_PathDiv->fix_path_bfer = 1 ;
 			}
 			return;
 		}
 		else // BFmer Off   &&   Div Off ->  Div On
 		{
-			if( pDM_PathDiv->fix_path_bfer == 1 ) 
+			if( pDM_PathDiv->fix_path_bfer == 1 )
 			{
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("[ PathDiv : ON ]   BFmer ==0 \n"));
 				pDM_PathDiv->fix_path_bfer = 0;
 			}
 		}
 	}
-	#endif	
+	#endif
 	#endif
 
-	if(pDM_PathDiv->use_path_a_as_default_ant ==1)
-	{
+	if(pDM_PathDiv->use_path_a_as_default_ant ==1) {
 		phydm_find_default_path(pDM_Odm);
-		phydm_candidate_dtp_update(pDM_Odm);	
-	}
-	else
-	{
-		if( pDM_PathDiv->dtp_state == PHYDM_DTP_INIT)
-		{
+		phydm_candidate_dtp_update(pDM_Odm);
+	} else {
+		if( pDM_PathDiv->dtp_state == PHYDM_DTP_INIT) {
 			phydm_find_default_path(pDM_Odm);
 			phydm_candidate_dtp_update(pDM_Odm);
 			pDM_PathDiv->dtp_state = PHYDM_DTP_RUNNING_1;
 		}
-		
+
 		else 	if( pDM_PathDiv->dtp_state == PHYDM_DTP_RUNNING_1)
 		{
 			pDM_PathDiv->dtp_check_patha_counter++;
-			
+
 			if(pDM_PathDiv->dtp_check_patha_counter>=NUM_RESET_DTP_PERIOD)
 			{
 				pDM_PathDiv->dtp_check_patha_counter=0;
 				pDM_PathDiv->dtp_state = PHYDM_DTP_INIT;
 			}
-			//2 Search space update		
+			//2 Search space update
 			else
 			{
 				// 1.  find the worst candidate
-				
+
 
 				// 2. repalce the worst candidate
 			}
@@ -507,17 +474,14 @@ phydm_dynamic_tx_path(
 
 	//2 Dynamic Path Selection H2C
 
-	if(pDM_PathDiv->num_candidate == 1)
-	{
+	if(pDM_PathDiv->num_candidate == 1) {
 		return;
-	}
-	else
-	{	
+	} else {
 		H2C_Parameter[0] =  pDM_PathDiv->num_candidate;
-		H2C_Parameter[1] =  pDM_PathDiv->num_tx_path;	
-		H2C_Parameter[2] =  pDM_PathDiv->ant_candidate_1; 
-		H2C_Parameter[3] =  pDM_PathDiv->ant_candidate_2; 
-		H2C_Parameter[4] =  pDM_PathDiv->ant_candidate_3; 
+		H2C_Parameter[1] =  pDM_PathDiv->num_tx_path;
+		H2C_Parameter[2] =  pDM_PathDiv->ant_candidate_1;
+		H2C_Parameter[3] =  pDM_PathDiv->ant_candidate_2;
+		H2C_Parameter[4] =  pDM_PathDiv->ant_candidate_3;
 
 		ODM_FillH2CCmd(pDM_Odm, PHYDM_H2C_DYNAMIC_TX_PATH, 6, H2C_Parameter);
 	}
@@ -525,7 +489,6 @@ phydm_dynamic_tx_path(
 }
 
 
-
 VOID
 phydm_dynamic_tx_path_init(
 	IN	PVOID	pDM_VOID
@@ -552,29 +515,25 @@ phydm_dynamic_tx_path_init(
 	memcpy(&(pDM_PathDiv->search_space_3[0]), &(search_space_3[0]), NUM_CHOOSE3_FROM4);
 
 	pDM_PathDiv->use_path_a_as_default_ant= 1;
-	pDM_PathDiv->dtp_state = PHYDM_DTP_INIT;	
+	pDM_PathDiv->dtp_state = PHYDM_DTP_INIT;
 	pDM_Odm->path_select = PHYDM_AUTO_PATH;
 	pDM_PathDiv->path_div_type = PHYDM_4R_PATH_DIV;
 
-	
-	if(pDM_PathDiv->is_u3_mode )
-	{
+
+	if(pDM_PathDiv->is_u3_mode ) {
 		pDM_PathDiv->num_tx_path=3;
 		phydm_dtp_fix_tx_path(pDM_Odm, PHYDM_BCD);/* 3TX  Set Init TX Path*/
-		
-	}
-	else
-	{
+	} else {
 		pDM_PathDiv->num_tx_path=2;
 		phydm_dtp_fix_tx_path(pDM_Odm, PHYDM_BC);/* 2TX // Set Init TX Path*/
 	}
-	
+
 }
 
 
 VOID
-phydm_process_rssi_for_path_div(	
-	IN OUT		PVOID			pDM_VOID,	
+phydm_process_rssi_for_path_div(
+	IN OUT		PVOID			pDM_VOID,
 	IN			PVOID			p_phy_info_void,
 	IN			PVOID			p_pkt_info_void
 	)
@@ -595,20 +554,18 @@ phydm_process_rssi_for_path_div(
 				{
 					pDM_PathDiv->path_a_sum_all+=pPhyInfo->RxMIMOSignalStrength[0];
 					pDM_PathDiv->path_a_cnt_all++;
-					
+
 					pDM_PathDiv->path_b_sum_all+=pPhyInfo->RxMIMOSignalStrength[1];
 					pDM_PathDiv->path_b_cnt_all++;
-					
+
 					pDM_PathDiv->path_c_sum_all+=pPhyInfo->RxMIMOSignalStrength[2];
 					pDM_PathDiv->path_c_cnt_all++;
-					
+
 					pDM_PathDiv->path_d_sum_all+=pPhyInfo->RxMIMOSignalStrength[3];
 					pDM_PathDiv->path_d_cnt_all++;
 				}
 				#endif
-			}
-			else
-			{
+			} else {
 				pDM_PathDiv->PathA_Sum[pPktinfo->StationID]+=pPhyInfo->RxMIMOSignalStrength[0];
 				pDM_PathDiv->PathA_Cnt[pPktinfo->StationID]++;
 
@@ -617,8 +574,6 @@ phydm_process_rssi_for_path_div(
 			}
 		}
 	}
-	
-	
 }
 
 #endif //#if RTL8814A_SUPPORT
@@ -636,10 +591,10 @@ odm_pathdiv_debug(
 	pPATHDIV_T			pDM_PathDiv  = &(pDM_Odm->DM_PathDiv);
 	u4Byte used = *_used;
 	u4Byte out_len = *_out_len;
-	
+
 	pDM_Odm->path_select = (dm_value[0] & 0xf);
 	PHYDM_SNPRINTF((output+used, out_len-used,"Path_select = (( 0x%x ))\n",pDM_Odm->path_select ));
-	
+
 	//2 [Fix Path]
 	if (pDM_Odm->path_select != PHYDM_AUTO_PATH)
 	{
@@ -648,11 +603,9 @@ odm_pathdiv_debug(
 			((pDM_Odm->path_select) & 0x2)?"B":"",
 			((pDM_Odm->path_select) & 0x4)?"C":"",
 			((pDM_Odm->path_select) & 0x8)?"D":"" ));
-		
+
 		phydm_dtp_fix_tx_path( pDM_Odm, pDM_Odm->path_select );
-	}
-	else
-	{
+	} else {
 		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n","Auto Path"));
 	}
 }
@@ -670,8 +623,8 @@ phydm_c2h_dtp_handler(
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	pPATHDIV_T		pDM_PathDiv  = &(pDM_Odm->DM_PathDiv);
 
-	u1Byte  macid = CmdBuf[0]; 
-	u1Byte  target = CmdBuf[1];	
+	u1Byte  macid = CmdBuf[0];
+	u1Byte  target = CmdBuf[1];
 	u1Byte  nsc_1 = CmdBuf[2];
 	u1Byte  nsc_2 = CmdBuf[3];
 	u1Byte  nsc_3 = CmdBuf[4];
@@ -688,10 +641,10 @@ phydm_c2h_dtp_handler(
 	}
 	else
 	{
-		phydm_dtp_fix_tx_path(pDM_Odm, pDM_PathDiv->ant_candidate_3);	
+		phydm_dtp_fix_tx_path(pDM_Odm, pDM_PathDiv->ant_candidate_3);
 	}
 	*/
-#endif	
+#endif
 }
 
 VOID
@@ -732,7 +685,7 @@ odm_PathDiversityInit(
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
 	/*pDM_Odm->SupportAbility |= ODM_BB_PATH_DIV;*/
-	
+
 	if(pDM_Odm->mp_mode == TRUE)
 		return;
 
@@ -752,7 +705,7 @@ odm_PathDiversityInit(
 		if(pDM_Odm->SupportICType & ODM_RTL8814A)
 			phydm_dynamic_tx_path_init(pDM_Odm);
 		else
-	#endif	
+	#endif
 		{}
 #endif
 }
@@ -807,4 +760,3 @@ odm_SwAntDivConstructScanChnl(
 }
 
 #endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/rtchnlplan.c b/drivers/net/wireless/rtl8812au/hal/phydm/rtchnlplan.c
index 4b41ff1..6fa9894 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/rtchnlplan.c
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/rtchnlplan.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -19,12 +19,12 @@
  ******************************************************************************/
 
 /******************************************************************************
-     
+
  History:
 	Data		Who		Remark (Internal History)
-	
+
 	05/14/2012	MH		Collect RTK inernal infromation and generate channel plan draft.
-	
+
 ******************************************************************************/
 
 //============================================================
@@ -41,73 +41,73 @@
 //
 
 /*
-	Channel Plan Contents					
-	Domain Code		EEPROM	Countries in Specific Domain		
-			2G RD		5G RD		Bit[6:0]	2G	5G	
-	Case	Old Define				00h~1Fh	Old Define	Old Define	
-	1		2G_WORLD	5G_NULL		20h		Worldwird 13	NA	
-	2		2G_ETSI1	5G_NULL		21h		Europe 2G		NA	
-	3		2G_FCC1		5G_NULL		22h		US 2G			NA	
-	4		2G_MKK1		5G_NULL		23h		Japan 2G		NA	
-	5		2G_ETSI2	5G_NULL		24h		France 2G		NA	
+	Channel Plan Contents
+	Domain Code		EEPROM	Countries in Specific Domain
+			2G RD		5G RD		Bit[6:0]	2G	5G
+	Case	Old Define				00h~1Fh	Old Define	Old Define
+	1		2G_WORLD	5G_NULL		20h		Worldwird 13	NA
+	2		2G_ETSI1	5G_NULL		21h		Europe 2G		NA
+	3		2G_FCC1		5G_NULL		22h		US 2G			NA
+	4		2G_MKK1		5G_NULL		23h		Japan 2G		NA
+	5		2G_ETSI2	5G_NULL		24h		France 2G		NA
 	6		2G_FCC1		5G_FCC1		25h		US 2G			US 5G					Kj{
 	7		2G_WORLD	5G_ETSI1	26h		Worldwird 13	Europe					Kj{
 	8		2G_MKK1		5G_MKK1		27h		Japan 2G		Japan 5G				Kj{
 	9		2G_WORLD	5G_KCC1		28h		Worldwird 13	Korea					Kj{
-	10		2G_WORLD	5G_FCC2		29h		Worldwird 13	US o/w DFS Channels		
-	11		2G_WORLD	5G_FCC3		30h		Worldwird 13	India, Mexico	    	
-	12		2G_WORLD	5G_FCC4		31h		Worldwird 13	Venezuela	        	
-	13		2G_WORLD	5G_FCC5		32h		Worldwird 13	China	            	
-	14		2G_WORLD	5G_FCC6		33h		Worldwird 13	Israel	            	
+	10		2G_WORLD	5G_FCC2		29h		Worldwird 13	US o/w DFS Channels
+	11		2G_WORLD	5G_FCC3		30h		Worldwird 13	India, Mexico
+	12		2G_WORLD	5G_FCC4		31h		Worldwird 13	Venezuela
+	13		2G_WORLD	5G_FCC5		32h		Worldwird 13	China
+	14		2G_WORLD	5G_FCC6		33h		Worldwird 13	Israel
 	15		2G_FCC1		5G_FCC7		34h		US 2G			US/Canada				Kj{
 	16		2G_WORLD	5G_ETSI2	35h		Worldwird 13	Australia, New Zealand	Kj{
-	17		2G_WORLD	5G_ETSI3	36h		Worldwird 13	Russia	
-	18		2G_MKK1		5G_MKK2		37h		Japan 2G		Japan (W52, W53)	
-	19		2G_MKK1		5G_MKK3		38h		Japan 2G		Japan (W56)	
+	17		2G_WORLD	5G_ETSI3	36h		Worldwird 13	Russia
+	18		2G_MKK1		5G_MKK2		37h		Japan 2G		Japan (W52, W53)
+	19		2G_MKK1		5G_MKK3		38h		Japan 2G		Japan (W56)
 	20		2G_FCC1		5G_NCC1		39h		US 2G			Taiwan					Kj{
-						
+
 	NA		2G_WORLD	5G_FCC1		7F		FCC	FCC DFS Channels	Realtek Define
-						
-						
-						
-						
-						
-	2.4G 	Regulatory 	Domains					
+
+
+
+
+
+	2.4G 	Regulatory 	Domains
 	Case	2G RD		Regulation	Channels	Frequencyes		Note					Countries in Specific Domain
 	1		2G_WORLD	ETSI		1~13		2412~2472		Passive scan CH 12, 13	Worldwird 13
 	2		2G_ETSI1	ETSI		1~13		2412~2472								Europe
 	3		2G_FCC1		FCC			1~11		2412~2462								US
 	4		2G_MKK1		MKK			1~13, 14	2412~2472, 2484							Japan
 	5		2G_ETSI2	ETSI		10~13		2457~2472								France
-						
-						
-						
-						
-	5G Regulatory Domains					
+
+
+
+
+	5G Regulatory Domains
 	Case	5G RD		Regulation	Channels			Frequencyes					Note											Countries in Specific Domain
-	1		5G_NULL		NA			NA					NA							Do not support 5GHz	
-	2		5G_ETSI1	ETSI		"36~48, 52~64,  	
+	1		5G_NULL		NA			NA					NA							Do not support 5GHz
+	2		5G_ETSI1	ETSI		"36~48, 52~64,
 									100~140"			"5180~5240, 5260~5230
 														5500~5700"					Band1, Ban2, Band3								Europe
-	3		5G_ETSI2	ETSI		"36~48, 52~64, 
+	3		5G_ETSI2	ETSI		"36~48, 52~64,
 									100~140, 149~165"	"5180~5240, 5260~5230
 														5500~5700, 5745~5825"		Band1, Ban2, Band3, Band4						Australia, New Zealand
-	4		5G_ETSI3	ETSI		"36~48, 52~64, 
-														100~132, 149~165"	
+	4		5G_ETSI3	ETSI		"36~48, 52~64,
+														100~132, 149~165"
 														"5180~5240, 5260~5230
 														5500~5660, 5745~5825"		Band1, Ban2, Band3(except CH 136, 140), Band4"	Russia
-	5		5G_FCC1		FCC			"36~48, 52~64, 
-									100~140, 149~165"	
+	5		5G_FCC1		FCC			"36~48, 52~64,
+									100~140, 149~165"
 														"5180~5240, 5260~5230
 														5500~5700, 5745~5825"		Band1(5150~5250MHz), 
 																					Band2(5250~5350MHz),
 																					Band3(5470~5725MHz),
 																					Band4(5725~5850MHz)"							US
 	6		5G_FCC2		FCC			36~48, 149~165		5180~5240, 5745~5825		Band1, Band4	FCC o/w DFS Channels
-	7		5G_FCC3		FCC			"36~48, 52~64, 
+	7		5G_FCC3		FCC			"36~48, 52~64,
 									149~165"			"5180~5240, 5260~5230
 														5745~5825"					Band1, Ban2, Band4								India, Mexico
-	8		5G_FCC4		FCC			"36~48, 52~64, 
+	8		5G_FCC4		FCC			"36~48, 52~64,
 									149~161"			"5180~5240, 5260~5230
 														5745~5805"					Band1, Ban2,
 																					Band4(except CH 165)"							Venezuela
@@ -115,20 +115,20 @@
 	10		5G_FCC6		FCC			36~48, 52~64		5180~5240, 5260~5230		Band1, Band2									Israel
 	11		5G_FCC7
 			5G_IC1		FCC
-						IC"			"36~48, 52~64, 
-									100~116, 136, 140, 
+						IC"			"36~48, 52~64,
+									100~116, 136, 140,
 									149~165"			"5180~5240, 5260~5230
-														5500~5580, 5680, 5700, 
+														5500~5580, 5680, 5700,
 														5745~5825"					"Band1, Band2, 
 																					Band3(except 5600~5650MHz),
 																					Band4"											"US
 																																	Canada"
-	12		5G_KCC1		KCC			"36~48, 52~64, 
+	12		5G_KCC1		KCC			"36~48, 52~64,
 									100~124, 149~165"	"5180~5240, 5260~5230
 														5500~5620, 5745~5825"		"Band1, Ban2, 
 																					Band3(5470~5650MHz),
 																					Band4"											Korea
-	13		5G_MKK1		MKK			"36~48, 52~64, 
+	13		5G_MKK1		MKK			"36~48, 52~64,
 									100~140"			"5180~5240, 5260~5230
 														5500~5700"					W52, W53, W56									Japan
 	14		5G_MKK2		MKK			36~48, 52~64		5180~5240, 5260~5230		W52, W53										Japan (W52, W53)
@@ -136,17 +136,17 @@
 	16		5G_NCC1		NCC			"56~64,
 									100~116, 136, 140,
 									149~165"			"5260~5320
-														5500~5580, 5680, 5700, 
+														5500~5580, 5680, 5700,
 														5745~5825"					"Band2(except CH 52), 
 																					Band3(except 5600~5650MHz),
 																					Band4"											Taiwan
-						
-						
-*/						
-						
+
+
+*/
+
+//
+// 2.4G CHannel
 //
-// 2.4G CHannel 
-//						
 /*
 
 	2.4G Band		Regulatory Domains																RTL8192D	
@@ -176,7 +176,7 @@
 //
 /*
 
-	5G Band		RTL8192D	RTL8195 (Jaguar)				Jaguar 2	Regulatory Domains											
+	5G Band		RTL8192D	RTL8195 (Jaguar)				Jaguar 2	Regulatory Domains
 	Channel Number	Channel Frequency	Global	Global				Global	"US
 (FCC 15.407)"	"Canada
 (FCC, except 5.6~5.65GHz)"	Argentina, Australia, New Zealand, Brazil, S. Africa (FCC/ETSI)	"Europe
@@ -199,7 +199,7 @@
 	56	5280	v	v				v	v	v	v	Indoor		v	Indoor	Indoor	v	v	Indoor	v
 	60	5300	v	v	v			v	v	v	v	Indoor		v	Indoor	Indoor	v	v	Indoor	v
 	64	5320	v	v				v	v	v	v	Indoor		v	Indoor	Indoor	v	v	Indoor	v
-																				
+
 "Band 3
 5.47GHz
 ~
@@ -209,13 +209,13 @@
 	108	5540	v	v	v			v	v	v	v	v				v	v	v	v	
 	112	5560	v	v				v	v	v	v	v				v	v	v	v	
 	116	5580	v	v	v	v		v	v	v	v	v				v	v	v	v	
-	120	5600	v	v				v	Indoor		v	Indoor				v	v	v		
-	124	5620	v	v	v			v	Indoor		v	Indoor				v	v	v		
-	128	5640	v	v				v	Indoor		v	Indoor				v		v		
-	132	5660	v	v	v	E		v	Indoor		v	Indoor				v		v		
+	120	5600	v	v				v	Indoor		v	Indoor				v	v	v
+	124	5620	v	v	v			v	Indoor		v	Indoor				v	v	v
+	128	5640	v	v				v	Indoor		v	Indoor				v		v
+	132	5660	v	v	v	E		v	Indoor		v	Indoor				v		v
 	136	5680	v	v				v	v	v	v	v				v			v	
 	140	5700	v	v	E			v	v	v	v	v				v			v	
-	144	5720	E	E				E												
+	144	5720	E	E				E
 "Band 4
 5.725GHz
 ~
@@ -225,14 +225,14 @@
 	157	5785	v	v	v			v	v	v	v		v	v			v	v	v	v
 	161	5805	v	v				v	v	v	v		v	v			v	v	v	v
 	165	5825	v	v	P	P		v	v	v	v		v	v			v	v	v	
-	169	5845	P	P				P												
-	173	5865	P	P	P			P												
-	177	5885	P	P				P												
+	169	5845	P	P				P
+	173	5865	P	P	P			P
+	177	5885	P	P				P
 Channel Count			28	28	14	7	0	28	24	20	24	19	5	13	8	19	20	22	15	12
 			E: FCC accepted the ask for CH144 from Accord.					PS: 160MHz  80MHz+80MHz{H			Argentina	Belgium (Q)		India	Israel			Russia		
 			P: Customer's requirement from James.								Australia	The Netherlands ()		Mexico	Turkey			Ukraine		
-											New Zealand	UK (^)		Singapore						
-											Brazil	Switzerland (h)								
+											New Zealand	UK (^)		Singapore
+											Brazil	Switzerland (h)
 
 
 */
@@ -240,11 +240,11 @@ Channel Count			28	28	14	7	0	28	24	20	24	19	5	13	8	19	20	22	15	12
 /*---------------------------Define Local Constant---------------------------*/
 
 
-// define Maximum Power v.s each band for each region 
+// define Maximum Power v.s each band for each region
 // ISRAEL
 // Format:
 // RT_CHANNEL_DOMAIN_Region ={{{Chnl_Start, Chnl_end, Pwr_dB_Max}, {Chn2_Start, Chn2_end, Pwr_dB_Max}, {Chn3_Start, Chn3_end, Pwr_dB_Max}, {Chn4_Start, Chn4_end, Pwr_dB_Max}, {Chn5_Start, Chn5_end, Pwr_dB_Max}}, Limit_Num} */
-// RT_CHANNEL_DOMAIN_FCC ={{{01,11,30}, {36,48,17}, {52,64,24}, {100,140,24}, {149,165,30}}, 5} 
+// RT_CHANNEL_DOMAIN_FCC ={{{01,11,30}, {36,48,17}, {52,64,24}, {100,140,24}, {149,165,30}}, 5}
 // "NR" is non-release channle.
 // Issue--- Israel--Russia--New Zealand
 // DOMAIN_01= (2G_WORLD, 5G_NULL)
@@ -272,8 +272,8 @@ Channel Count			28	28	14	7	0	28	24	20	24	19	5	13	8	19	20	22	15	12
 
 static	RT_CHANNEL_PLAN_MAXPWR	ChnlPlanPwrMax_2G[] = {
 
-	// 2G_WORLD, 
-	{{1, 13, 20}, 1},	
+	// 2G_WORLD,
+	{{1, 13, 20}, 1},
 
 	// 2G_ETSI1
 	{{1, 13, 20}, 1},
@@ -292,7 +292,7 @@ static	RT_CHANNEL_PLAN_MAXPWR	ChnlPlanPwrMax_2G[] = {
 /*
 //===========================================1:(2G_WORLD, 5G_NULL)
 
-RT_CHANNEL_PLAN_MAXPWR	RT_DOMAIN_01 ={{{01,13,20}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}}, 1} 
+RT_CHANNEL_PLAN_MAXPWR	RT_DOMAIN_01 ={{{01,13,20}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}}, 1}
 
 //===========================================2:(2G_ETSI1, 5G_NULL)
 
@@ -374,56 +374,56 @@ RT_DOMAIN_23 ={{{01,13,20}, {36,48,23}, {52,64,23}, {100,140,30}, {149,165,30}},
 //
 // Counter & Realtek Channel plan transfer table.
 //
-RT_CHNL_CTRY_TBL	RtCtryChnlTbl[] = 
+RT_CHNL_CTRY_TBL	RtCtryChnlTbl[] =
 {
 
 	{
-		RT_CTRY_AL,							//	"Albania"					
+		RT_CTRY_AL,							//	"Albania"
 		"AL",
 		RT_2G_WORLD,
-		RT_5G_WORLD,		
+		RT_5G_WORLD,
 		RT_CHANNEL_DOMAIN_UNDEFINED			// 2G/5G world.
 	},
-#if 0	
+#if 0
 	{
-		RT_CTRY_BB,							//  "Barbadosh"				
+		RT_CTRY_BB,							//  "Barbadosh"
 		"BB",
 		RT_2G_WORLD,
-		RT_5G_NULL,		
+		RT_5G_NULL,
 		RT_CHANNEL_DOMAIN_EFUSE_0x20		// 2G world. 5G_NULL
 	},
-	
+
 	{
-		RT_CTRY_DE,							//  "Germanyw"					
+		RT_CTRY_DE,							//  "Germanyw"
 		"DE",
 		RT_2G_WORLD,
-		RT_5G_ETSI1,		
+		RT_5G_ETSI1,
 		RT_CHANNEL_DOMAIN_EFUSE_0x26
 	},
-	
+
 	{
-		RT_CTRY_US,							//  "Germanyw"					
+		RT_CTRY_US,							//  "Germanyw"
 		"US",
 		RT_2G_FCC1,
-		RT_5G_FCC7,		
+		RT_5G_FCC7,
 		RT_CHANNEL_DOMAIN_EFUSE_0x34
 	},
 
 	{
-		RT_CTRY_JP,							//  "Germanyw"					
+		RT_CTRY_JP,							//  "Germanyw"
 		"JP",
 		RT_2G_MKK1,
-		RT_5G_MKK1,		
+		RT_5G_MKK1,
 		RT_CHANNEL_DOMAIN_EFUSE_0x34
 	},
-		
+
 	{
-		RT_CTRY_TW,							//  "Germanyw"					
+		RT_CTRY_TW,							//  "Germanyw"
 		"TW",
 		RT_2G_FCC1,
-		RT_5G_NCC1,		
+		RT_5G_NCC1,
 		RT_CHANNEL_DOMAIN_EFUSE_0x39
-	},	
+	},
 #endif
 
 };	// RtCtryChnlTbl
@@ -437,13 +437,13 @@ static	RT_CHANNEL_PLAN_NEW		RtChnlPlan[] =
 {
 	// Channel Plan   0x20.
 	{
-		&RtCtryChnlTbl[1],					// RT_CHNL_CTRY_TBL Country & channel plan transfer table.		
-		RT_CHANNEL_DOMAIN_EFUSE_0x20,		// RT_CHANNEL_DOMAIN RT Channel Plan Define 
+		&RtCtryChnlTbl[1],					// RT_CHNL_CTRY_TBL Country & channel plan transfer table.
+		RT_CHANNEL_DOMAIN_EFUSE_0x20,		// RT_CHANNEL_DOMAIN RT Channel Plan Define
 		RT_2G_WORLD,						// RT_REGULATION_2G
 		RT_5G_NULL,							// RT_REGULATION_5G
 		RT_WORLD,							// RT_REGULATION_CMN RT Regulatory domain definition.
 		RT_SREQ_NA,							// RT Channel plan special & customerize requirement.
-		
+
 		CHNL_RT_2G_WORLD,
 		CHNL_RT_2G_WORLD_SCAN_TYPE,
 		&ChnlPlanPwrMax_2G[0],
@@ -451,31 +451,27 @@ static	RT_CHANNEL_PLAN_NEW		RtChnlPlan[] =
 		CHNL_RT_5G_NULL,
 		CHNL_RT_5G_NULL_SCAN_TYPE,
 
-		
+
 	},
-	
+
 	// Channel Plan   0x26.
 	{
-		&RtCtryChnlTbl[1],					// RT_CHNL_CTRY_TBL Country & channel plan transfer table.		
-		RT_CHANNEL_DOMAIN_EFUSE_0x26,		// RT_CHANNEL_DOMAIN RT Channel Plan Define 
+		&RtCtryChnlTbl[1],					// RT_CHNL_CTRY_TBL Country & channel plan transfer table.
+		RT_CHANNEL_DOMAIN_EFUSE_0x26,		// RT_CHANNEL_DOMAIN RT Channel Plan Define
 		RT_2G_WORLD,						// RT_REGULATION_2G
 		RT_5G_ETSI1,						// RT_REGULATION_5G
 		RT_WORLD,							// RT_REGULATION_CMN RT Regulatory domain definition.
 		RT_SREQ_NA,							// RT Channel plan special & customerize requirement.
-		
+
 		CHNL_RT_2G_WORLD,					// 2G workd cannel
 		CHNL_RT_2G_WORLD_SCAN_TYPE,
 		&ChnlPlanPwrMax_2G[1],
-		
+
 		CHNL_RT_5G_ETSI1,
 		CHNL_RT_5G_ETSI1_SCAN_TYPE,
-		
-	}
-	
-	
-};
-#endif
-
 
+	}
 
 
+};
+#endif
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/rtchnlplan.h b/drivers/net/wireless/rtl8812au/hal/phydm/rtchnlplan.h
index 37786cf..4589257 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/rtchnlplan.h
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/rtchnlplan.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -41,7 +41,7 @@ typedef enum _RT_CHANNEL_DOMAIN_NEW
 	// .....
 
 	RT_CHANNEL_DOMAIN_MAX_NEW,
-	
+
 }RT_CHANNEL_DOMAIN_NEW, *PRT_CHANNEL_DOMAIN_NEW;
 
 
@@ -90,7 +90,7 @@ typedef enum _RT_CHANNEL_DOMAIN_NEW
 #define DOMAIN_CODE_5G_NCC1 \
         {56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 24
 #define DOMAIN_CODE_5G_NCC2 \
-        {56,60,64,149,153,157,161,165}, 8  			
+        {56,60,64,149,153,157,161,165}, 8
 #define UNDEFINED \
         {0}, 0
 #endif
@@ -103,157 +103,157 @@ typedef enum _RT_CHANNEL_DOMAIN_NEW
 Countries							"Country Abbreviation"	Domain Code					SKU's	Ch# of 20MHz
 															2G			5G						Ch# of 40MHz
 "Albania"					AL													Local Test	
-									    					        	            	
-"AlgeriaQ"					DZ									CE TCF	    	
-					                    					        	            	
-"Antigua & Barbudawq&F"	AG						2G_WORLD					FCC TCF	
-					                    					        	        		
+
+"AlgeriaQ"					DZ									CE TCF
+
+"Antigua & Barbudawq&F"			AG						2G_WORLD					FCC TCF
+
 "Argentina"					AR						2G_WORLD					Local Test	
-									    					        	        		
+
 "Armenia"					AM						2G_WORLD					ETSI	
-									    					        	        		
+
 "Aruba|q"						AW						2G_WORLD					FCC TCF	
-															        	
-"AustraliaDw"						AU						2G_WORLD		5G_ETSI2		
-															        	
-"AustriaaQ"						AT						2G_WORLD		5G_ETSI1	CE	
-					    			    					        	
-"Azerbaijan"				AZ						2G_WORLD					CE TCF	
-					                    					        	
-"Bahamas"						BS						2G_WORLD				
-									    					        	
+
+"AustraliaDw"						AU						2G_WORLD		5G_ETSI2
+
+"AustriaaQ"						AT						2G_WORLD		5G_ETSI1	CE
+
+"Azerbaijan"					AZ						2G_WORLD					CE TCF	
+
+"Bahamas"						BS						2G_WORLD
+
 "Barbadosh"					BB						2G_WORLD					FCC TCF	
-									    					        	
-"BelgiumQ"						BE						2G_WORLD		5G_ETSI1	CE	
-															        	
-"Bermuda}F"						BM						2G_WORLD					FCC TCF	
-															        	        		
+
+"BelgiumQ"						BE						2G_WORLD		5G_ETSI1	CE
+
+"Bermuda}F"						BM						2G_WORLD					FCC TCF
+
 "Brazil"						BR						2G_WORLD					Local Test	
-									    					        	
-"BulgariaO[Q"					BG						2G_WORLD		5G_ETSI1	CE	
-									    					        	
+
+"BulgariaO[Q"					BG						2G_WORLD		5G_ETSI1	CE
+
 "Canada[j"						CA						2G_FCC1			5G_FCC7		IC / FCC	IC / FCC
-					                    					        	
-"Cayman Islands}sq"			KY						2G_WORLD		5G_ETSI1	CE	
-					                    					        	
-"ChileQ"							CL						2G_WORLD					FCC TCF	
-																    	
-"China"							CN						2G_WORLD		5G_FCC5		H?i2002j353? 	
-					                    					        	
-"Columbia"					CO						2G_WORLD					Voluntary 	
-					    			    					        	
-"Costa RicaF["				CR						2G_WORLD					FCC TCF	
-					    			    					        	
-"Cyprus"					CY						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Czech J"						CZ						2G_WORLD		5G_ETSI1	CE	
-															        	
-"Denmark"						DK						2G_WORLD		5G_ETSI1	CE	
-					                    					        	
-"Dominican Republich[@M"	DO						2G_WORLD					FCC TCF	
-					                    					        	
-"EgyptJ"	EG	2G_WORLD			CE T												CF	    	
-					                    					        	
-"El Salvadorh"				SV						2G_WORLD					Voluntary	
-					        		    					        	
-"EstoniaRF"					EE						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Finland"						FI						2G_WORLD		5G_ETSI1	CE	
-															        	
-"Francek"						FR										5G_E		TSI1	CE	
-															        	
-"Germanyw"						DE						2G_WORLD		5G_ETSI1	CE	
-															        	
-"Greece "						GR						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Guamq"							GU						2G_WORLD				
-									    					        	
-"Guatemalaa"					GT						2G_WORLD				
-									    					        	
-"Haitia"							HT						2G_WORLD					FCC TCF	
-									    					        	
-"Honduras"					HN						2G_WORLD					FCC TCF	
-									    					        	
-"HungaryIQ"						HU						2G_WORLD		5G_ETSI1	CE	
-															        	
-"IcelandBq"						IS						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"IndiaL"							IN						2G_WORLD		5G_FCC3		FCC/CE TCF	
-															        	
-"IrelandR"						IE						2G_WORLD		5G_ETSI1	CE	
-															        	
-"IsraelHC"						IL										5G_F		CC6	CE TCF	
-															        	
-"ItalyqjQ"						IT						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Japan"							JP						2G_MKK1			5G_MKK1		MKK	MKK
-																    	
-"Korea"							KR						2G_WORLD		5G_KCC1		KCC	KCC
-									    					        	
-"Latvia"					LV						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Lithuania{"					LT						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Luxembourgc"					LU						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Malaysia"					MY						2G_WORLD					Local Test	
-									    					        	
-"MaltaL"						MT						2G_WORLD		5G_ETSI1	CE	
-															        	
-"Mexico"						MX						2G_WORLD		5G_FCC3		Local Test	
-															        	
-"Morocco"						MA													CE TCF	
-									    					        	
-"Netherlands"					NL						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"New Zealand"					NZ						2G_WORLD		5G_ETSI2		
-									    					        	
-"Norway"						NO						2G_WORLD		5G_ETSI1	CE	
-															        	
+
+"Cayman Islands}sq"					KY						2G_WORLD		5G_ETSI1	CE
+
+"ChileQ"						CL						2G_WORLD					FCC TCF	
+
+"China"						CN						2G_WORLD		5G_FCC5		H?i2002j353? 	
+
+"Columbia"					CO						2G_WORLD					Voluntary
+
+"Costa RicaF["					CR						2G_WORLD					FCC TCF	
+
+"Cyprus"					CY						2G_WORLD		5G_ETSI1	CE
+
+"Czech J"						CZ						2G_WORLD		5G_ETSI1	CE
+
+"Denmark"						DK						2G_WORLD		5G_ETSI1	CE
+
+"Dominican Republich[@M"			DO						2G_WORLD					FCC TCF
+
+"EgyptJ"						EG						2G_WORLD				CE T												CF
+
+"El Salvadorh"					SV						2G_WORLD					Voluntary
+
+"EstoniaRF"					EE						2G_WORLD		5G_ETSI1	CE
+
+"Finland"						FI						2G_WORLD		5G_ETSI1	CE
+
+"Francek"						FR									5G_E		TSI1	CE
+
+"Germanyw"						DE						2G_WORLD		5G_ETSI1	CE
+
+"Greece "						GR						2G_WORLD		5G_ETSI1	CE
+
+"Guamq"						GU						2G_WORLD
+
+"Guatemalaa"					GT						2G_WORLD
+
+"Haitia"						HT						2G_WORLD				FCC TCF
+
+"Honduras"					HN						2G_WORLD				FCC TCF
+
+"HungaryIQ"						HU						2G_WORLD		5G_ETSI1	CE
+
+"IcelandBq"						IS						2G_WORLD		5G_ETSI1	CE
+
+"IndiaL"						IN						2G_WORLD		5G_FCC3		FCC/CE TCF	
+
+"IrelandR"						IE						2G_WORLD		5G_ETSI1	CE
+
+"IsraelHC"						IL									5G_F		CC6	CE TCF	
+
+"ItalyqjQ"						IT						2G_WORLD		5G_ETSI1	CE
+
+"Japan"						JP						2G_MKK1			5G_MKK1		MKK	MKK
+
+"Korea"						KR						2G_WORLD		5G_KCC1		KCC	KCC
+
+"Latvia"						LV						2G_WORLD		5G_ETSI1	CE
+
+"Lithuania{"						LT						2G_WORLD		5G_ETSI1	CE
+
+"Luxembourgc"					LU						2G_WORLD		5G_ETSI1	CE
+
+"Malaysia"					MY						2G_WORLD					Local Test
+
+"MaltaL"						MT						2G_WORLD		5G_ETSI1	CE
+
+"Mexico"						MX						2G_WORLD		5G_FCC3		Local Test
+
+"Morocco"						MA													CE TCF
+
+"Netherlands"					NL						2G_WORLD		5G_ETSI1	CE
+
+"New Zealand"					NZ						2G_WORLD		5G_ETSI2
+
+"Norway"						NO						2G_WORLD		5G_ETSI1	CE
+
 "Panama "						PA						2G_FCC1						Voluntary	
-									    					        	
+
 "Philippines"					PH						2G_WORLD					FCC TCF	
-									    					        	
-"Polandi"						PL						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Portugal"					PT						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Romania"					RO						2G_WORLD		5G_ETSI1	CE	
-					        		    					        	
-"RussiaX"						RU						2G_WORLD		5G_ETSI3	CE TCF	
-					        		    					        	
-"Saudi ArabiaFaB"			SA						2G_WORLD					CE TCF	
-					        		    					        	
-"Singapores[Y"					SG						2G_WORLD				
-									    					        	
-"SlovakiaJ"					SK						2G_WORLD		5G_ETSI1	CE	
-					    			    					        	
-"Slovenia"				SI						2G_WORLD		5G_ETSI1	CE	
-					    			    					        	
-"South AfricanD"					ZA						2G_WORLD					CE TCF	
-					        		    					        	
-"SpainZ"						ES										5G_ETSI1	CE	
-															        	
-"Sweden"						SE						2G_WORLD		5G_ETSI1	CE	
-					        		    					        	
-"Switzerlandh"					CH						2G_WORLD		5G_ETSI1	CE	
-					        		    					        	
-"TaiwanOW"						TW						2G_FCC1			5G_NCC1	NCC	
-															        	
-"Thailand"						TH						2G_WORLD					FCC/CE TCF	
-															        	
-"Turkeyg"						TR						2G_WORLD				
-															        	
-"UkraineQJ"						UA						2G_WORLD					Local Test	
-					        		    					        	
-"United Kingdom^"				GB						2G_WORLD		5G_ETSI1	CE	ETSI
-					    			    					        	
+
+"Polandi"						PL						2G_WORLD		5G_ETSI1	CE
+
+"Portugal"					PT						2G_WORLD		5G_ETSI1	CE
+
+"Romania"					RO						2G_WORLD		5G_ETSI1	CE
+
+"RussiaX"						RU						2G_WORLD		5G_ETSI3	CE TCF
+
+"Saudi ArabiaFaB"					SA						2G_WORLD					CE TCF
+
+"Singapores[Y"					SG						2G_WORLD
+
+"SlovakiaJ"					SK						2G_WORLD		5G_ETSI1	CE
+
+"Slovenia"					SI						2G_WORLD		5G_ETSI1	CE
+
+"South AfricanD"					ZA						2G_WORLD					CE TCF
+
+"SpainZ"						ES									5G_ETSI1	CE
+
+"Sweden"						SE						2G_WORLD		5G_ETSI1	CE
+
+"Switzerlandh"					CH						2G_WORLD		5G_ETSI1	CE
+
+"TaiwanOW"						TW						2G_FCC1			5G_NCC1	NCC
+
+"Thailand"						TH						2G_WORLD					FCC/CE TCF
+
+"Turkeyg"						TR						2G_WORLD
+
+"UkraineQJ"						UA						2G_WORLD					Local Test
+
+"United Kingdom^"					GB						2G_WORLD		5G_ETSI1	CE	ETSI
+
 "United States"					US						2G_FCC1			5G_FCC7		FCC	FCC
-					    			    					        	
+
 "Venezuelae"					VE						2G_WORLD		5G_FCC4		FCC TCF	
-					    			    					        	
+
 "VietnamVn"						VN						2G_WORLD					FCC/CE TCF	
-					
+
 
 
 */
@@ -261,86 +261,86 @@ Countries							"Country Abbreviation"	Domain Code					SKU's	Ch# of 20MHz
 // Counter abbervation.
 typedef enum _RT_COUNTRY_DEFINE_NUM
 {
-	RT_CTRY_AL,				//	"Albania"					
-	RT_CTRY_DZ,             //  "AlgeriaQ"					
-	RT_CTRY_AG,             //  "Antigua & Barbudawq&F"	
-	RT_CTRY_AR,             //  "Argentina"					
-	RT_CTRY_AM,             //  "Armenia"					
-	RT_CTRY_AW,             //  "Aruba|q"						
-	RT_CTRY_AU,             //  "AustraliaDw"						
-	RT_CTRY_AT,             //  "AustriaaQ"						
-	RT_CTRY_AZ,             //  "Azerbaijan"				
-	RT_CTRY_BS,             //  "Bahamas"					
-	RT_CTRY_BB,             //  "Barbadosh"				
-	RT_CTRY_BE,             //  "BelgiumQ"					
-	RT_CTRY_BM,             //  "Bermuda}F"					
-	RT_CTRY_BR,             //  "Brazil"						
-	RT_CTRY_BG,             //  "BulgariaO[Q"				
-	RT_CTRY_CA,             //  "Canada[j"					
-	RT_CTRY_KY,             //  "Cayman Islands}sq"			
-	RT_CTRY_CL,             //  "ChileQ"						
-	RT_CTRY_CN,             //  "China"						
-	RT_CTRY_CO,             //  "Columbia"				
-	RT_CTRY_CR,             //  "Costa RicaF["			
-	RT_CTRY_CY,             //  "Cyprus"					
-	RT_CTRY_CZ,             //  "Czech J"						
-	RT_CTRY_DK,             //  "Denmark"					
-	RT_CTRY_DO,             //  "Dominican Republich[@M"	
-	RT_CTRY_CE,             //  "EgyptJ"	EG	2G_WORLD			
-	RT_CTRY_SV,             //  "El Salvadorh"				
-	RT_CTRY_EE,             //  "EstoniaRF"					
-	RT_CTRY_FI,             //  "Finland"						
-	RT_CTRY_FR,             //  "Francek"						
-	RT_CTRY_DE,             //  "Germanyw"					
-	RT_CTRY_GR,             //  "Greece "					
-	RT_CTRY_GU,             //  "Guamq"						
-	RT_CTRY_GT,             //  "Guatemalaa"				
-	RT_CTRY_HT,             //  "Haitia"						
-	RT_CTRY_HN,             //  "Honduras"				
-	RT_CTRY_HU,             //  "HungaryIQ"					
-	RT_CTRY_IS,             //  "IcelandBq"					
-	RT_CTRY_IN,             //  "IndiaL"						
-	RT_CTRY_IE,             //  "IrelandR"					
-	RT_CTRY_IL,             //  "IsraelHC"					
-	RT_CTRY_IT,             //  "ItalyqjQ"					
-	RT_CTRY_JP,             //  "Japan"						
-	RT_CTRY_KR,             //  "Korea"						
-	RT_CTRY_LV,             //  "Latvia"					
-	RT_CTRY_LT,             //  "Lithuania{"				
-	RT_CTRY_LU,             //  "Luxembourgc"				
-	RT_CTRY_MY,             //  "Malaysia"				
-	RT_CTRY_MT,             //  "MaltaL"					
-	RT_CTRY_MX,             //  "Mexico"					
-	RT_CTRY_MA,             //  "Morocco"					
-	RT_CTRY_NL,             //  "Netherlands"				
-	RT_CTRY_NZ,             //  "New Zealand"				
-	RT_CTRY_NO,             //  "Norway"						
-	RT_CTRY_PA,             //  "Panama "					
-	RT_CTRY_PH,             //  "Philippines"				
-	RT_CTRY_PL,             //  "Polandi"						
-	RT_CTRY_PT,             //  "Portugal"					
-	RT_CTRY_RO,             //  "Romania"				
-	RT_CTRY_RU,             //  "RussiaX"					
-	RT_CTRY_SA,             //  "Saudi ArabiaFaB"			
-	RT_CTRY_SG,             //  "Singapores[Y"				
-	RT_CTRY_SK,             //  "SlovakiaJ"				
-	RT_CTRY_SI,             //  "Slovenia"				
-	RT_CTRY_ZA,             //  "South AfricanD"				
-	RT_CTRY_ES,             //  "SpainZ"					
-	RT_CTRY_SE,             //  "Sweden"						
-	RT_CTRY_CH,             //  "Switzerlandh"				
-	RT_CTRY_TW,             //  "TaiwanOW"						
-	RT_CTRY_TH,             //  "Thailand"					
-	RT_CTRY_TR,             //  "Turkeyg"					
-	RT_CTRY_UA,             //  "UkraineQJ"					
-	RT_CTRY_GB,             //  "United Kingdom^"				
-	RT_CTRY_US,             //  "United States"				
-	RT_CTRY_VE,             //  "Venezuelae"				
-	RT_CTRY_VN,             //  "VietnamVn"					
-	RT_CTRY_MAX,            //  
-	
+	RT_CTRY_AL,				//	"Albania"
+	RT_CTRY_DZ,             //  "AlgeriaQ"
+	RT_CTRY_AG,             //  "Antigua & Barbudawq&F"
+	RT_CTRY_AR,             //  "Argentina"
+	RT_CTRY_AM,             //  "Armenia"
+	RT_CTRY_AW,             //  "Aruba|q"
+	RT_CTRY_AU,             //  "AustraliaDw"
+	RT_CTRY_AT,             //  "AustriaaQ"
+	RT_CTRY_AZ,             //  "Azerbaijan"
+	RT_CTRY_BS,             //  "Bahamas"
+	RT_CTRY_BB,             //  "Barbadosh"
+	RT_CTRY_BE,             //  "BelgiumQ"
+	RT_CTRY_BM,             //  "Bermuda}F"
+	RT_CTRY_BR,             //  "Brazil"
+	RT_CTRY_BG,             //  "BulgariaO[Q"
+	RT_CTRY_CA,             //  "Canada[j"
+	RT_CTRY_KY,             //  "Cayman Islands}sq"
+	RT_CTRY_CL,             //  "ChileQ"
+	RT_CTRY_CN,             //  "China"
+	RT_CTRY_CO,             //  "Columbia"
+	RT_CTRY_CR,             //  "Costa RicaF["
+	RT_CTRY_CY,             //  "Cyprus"
+	RT_CTRY_CZ,             //  "Czech J"
+	RT_CTRY_DK,             //  "Denmark"
+	RT_CTRY_DO,             //  "Dominican Republich[@M"
+	RT_CTRY_CE,             //  "EgyptJ"	EG	2G_WORLD
+	RT_CTRY_SV,             //  "El Salvadorh"
+	RT_CTRY_EE,             //  "EstoniaRF"
+	RT_CTRY_FI,             //  "Finland"
+	RT_CTRY_FR,             //  "Francek"
+	RT_CTRY_DE,             //  "Germanyw"
+	RT_CTRY_GR,             //  "Greece "
+	RT_CTRY_GU,             //  "Guamq"
+	RT_CTRY_GT,             //  "Guatemalaa"
+	RT_CTRY_HT,             //  "Haitia"
+	RT_CTRY_HN,             //  "Honduras"
+	RT_CTRY_HU,             //  "HungaryIQ"
+	RT_CTRY_IS,             //  "IcelandBq"
+	RT_CTRY_IN,             //  "IndiaL"
+	RT_CTRY_IE,             //  "IrelandR"
+	RT_CTRY_IL,             //  "IsraelHC"
+	RT_CTRY_IT,             //  "ItalyqjQ"
+	RT_CTRY_JP,             //  "Japan"
+	RT_CTRY_KR,             //  "Korea"
+	RT_CTRY_LV,             //  "Latvia"
+	RT_CTRY_LT,             //  "Lithuania{"
+	RT_CTRY_LU,             //  "Luxembourgc"
+	RT_CTRY_MY,             //  "Malaysia"
+	RT_CTRY_MT,             //  "MaltaL"
+	RT_CTRY_MX,             //  "Mexico"
+	RT_CTRY_MA,             //  "Morocco"
+	RT_CTRY_NL,             //  "Netherlands"
+	RT_CTRY_NZ,             //  "New Zealand"
+	RT_CTRY_NO,             //  "Norway"
+	RT_CTRY_PA,             //  "Panama "
+	RT_CTRY_PH,             //  "Philippines"
+	RT_CTRY_PL,             //  "Polandi"
+	RT_CTRY_PT,             //  "Portugal"
+	RT_CTRY_RO,             //  "Romania"
+	RT_CTRY_RU,             //  "RussiaX"
+	RT_CTRY_SA,             //  "Saudi ArabiaFaB"
+	RT_CTRY_SG,             //  "Singapores[Y"
+	RT_CTRY_SK,             //  "SlovakiaJ"
+	RT_CTRY_SI,             //  "Slovenia"
+	RT_CTRY_ZA,             //  "South AfricanD"
+	RT_CTRY_ES,             //  "SpainZ"
+	RT_CTRY_SE,             //  "Sweden"
+	RT_CTRY_CH,             //  "Switzerlandh"
+	RT_CTRY_TW,             //  "TaiwanOW"
+	RT_CTRY_TH,             //  "Thailand"
+	RT_CTRY_TR,             //  "Turkeyg"
+	RT_CTRY_UA,             //  "UkraineQJ"
+	RT_CTRY_GB,             //  "United Kingdom^"
+	RT_CTRY_US,             //  "United States"
+	RT_CTRY_VE,             //  "Venezuelae"
+	RT_CTRY_VN,             //  "VietnamVn"
+	RT_CTRY_MAX,            //
+
 }RT_COUNTRY_NAME, *PRT_COUNTRY_NAME;
-    
+
 // Scan type including active and passive scan.
 typedef enum _RT_SCAN_TYPE_NEW
 {
@@ -349,32 +349,32 @@ typedef enum _RT_SCAN_TYPE_NEW
 	SCAN_PAS,
 	SCAN_BOTH,
 }RT_SCAN_TYPE_NEW, *PRT_SCAN_TYPE_NEW;
-    
+
 
 // Power table sample.
 
 typedef struct _RT_CHNL_PLAN_LIMIT
 {
 	u2Byte	Chnl_Start;
-	u2Byte	Chnl_end;	
-	
+	u2Byte	Chnl_end;
+
 	u2Byte	Freq_Start;
-	u2Byte	Freq_end;	
+	u2Byte	Freq_end;
 }RT_CHNL_PLAN_LIMIT, *PRT_CHNL_PLAN_LIMIT;
 
-    
-//    
+
+//
 // 2.4G Regulatory Domains
 //
 typedef enum _RT_REGULATION_DOMAIN_2G
 {
-	RT_2G_NULL,   
+	RT_2G_NULL,
 	RT_2G_WORLD,
 	RT_2G_ETSI1,
 	RT_2G_FCC1,
 	RT_2G_MKK1,
-	RT_2G_ETSI2	
-	
+	RT_2G_ETSI2
+
 }RT_REGULATION_2G, *PRT_REGULATION_2G;
 
 
@@ -382,12 +382,12 @@ typedef enum _RT_REGULATION_DOMAIN_2G
 //{
 //	u1Byte	Chnl;
 //	RT_SCAN_TYPE_NEW
-//	
+//
 //}RT_CHANNEL_BEHAVIOR, *PRT_CHANNEL_BEHAVIOR;
 
 //typedef struct _RT_CHANNEL_PLAN_TYPE
 //{
-//	RT_CHANNEL_BEHAVIOR		
+//	RT_CHANNEL_BEHAVIOR
 //	u1Byte					Chnl_num;
 //}RT_CHNL_PLAN_TYPE, *PRT_CHNL_PLAN_TYPE;
 
@@ -447,17 +447,17 @@ typedef enum _RT_REGULATION_DOMAIN_2G
         {2457, 2472}, 1
 
 
-//    
+//
 // 5G Regulatory Domains
 //
 typedef enum _RT_REGULATION_DOMAIN_5G
-{   
+{
 	RT_5G_NULL,
 	RT_5G_WORLD,
 	RT_5G_ETSI1,
 	RT_5G_ETSI2,
 	RT_5G_ETSI3,
-	RT_5G_FCC1,	
+	RT_5G_FCC1,
 	RT_5G_FCC2,
 	RT_5G_FCC3,
 	RT_5G_FCC4,
@@ -470,7 +470,7 @@ typedef enum _RT_REGULATION_DOMAIN_5G
 	RT_5G_MKK2,
 	RT_5G_MKK3,
 	RT_5G_NCC1,
-	
+
 }RT_REGULATION_5G, *PRT_REGULATION_5G;
 
 //
@@ -511,7 +511,7 @@ typedef enum _RT_REGULATION_DOMAIN_5G
 #define CHNL_RT_5G_MKK3 \
         {56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 24
 #define CHNL_RT_5G_NCC1 \
-        {56,60,64,149,153,157,161,165}, 8  	
+        {56,60,64,149,153,157,161,165}, 8
 
 //
 // 5G Channel Active or passive scan.
@@ -551,26 +551,26 @@ typedef enum _RT_REGULATION_DOMAIN_5G
 #define CHNL_RT_5G_MKK3_SCAN_TYPE \
         {56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 24
 #define CHNL_RT_5G_NCC1_SCAN_TYPE \
-        {56,60,64,149,153,157,161,165}, 8  	
+        {56,60,64,149,153,157,161,165}, 8
 
-//    
+//
 // Global Regulation
 //
 typedef enum _RT_REGULATION_COMMON
 {
-	RT_WORLD,   
-	RT_FCC,   
+	RT_WORLD,
+	RT_FCC,
 	RT_MKK,
 	RT_ETSI,
 	RT_IC,
 	RT_CE,
 	RT_NCC,
-	
+
 }RT_REGULATION_CMN, *PRT_REGULATION_CMN;
 
 
 
-//    
+//
 // Special requirement for different regulation domain.
 // For internal test or customerize special request.
 //
@@ -580,46 +580,46 @@ typedef enum _RT_CHNLPLAN_SREQ
 	RT_SREQ_2G_ADHOC_11N			= 0x00000001,
 	RT_SREQ_2G_ADHOC_11B			= 0x00000002,
 	RT_SREQ_2G_ALL_PASS				= 0x00000004,
-	RT_SREQ_2G_ALL_ACT				= 0x00000008,	
+	RT_SREQ_2G_ALL_ACT				= 0x00000008,
 	RT_SREQ_5G_ADHOC_11N			= 0x00000010,
 	RT_SREQ_5G_ADHOC_11AC			= 0x00000020,
 	RT_SREQ_5G_ALL_PASS				= 0x00000040,
 	RT_SREQ_5G_ALL_ACT				= 0x00000080,
-	RT_SREQ_C1_PLAN					= 0x00000100,	
-	RT_SREQ_C2_PLAN					= 0x00000200,	
-	RT_SREQ_C3_PLAN					= 0x00000400,	
-	RT_SREQ_C4_PLAN					= 0x00000800,	
-	RT_SREQ_NFC_ON					= 0x00001000,	
+	RT_SREQ_C1_PLAN					= 0x00000100,
+	RT_SREQ_C2_PLAN					= 0x00000200,
+	RT_SREQ_C3_PLAN					= 0x00000400,
+	RT_SREQ_C4_PLAN					= 0x00000800,
+	RT_SREQ_NFC_ON					= 0x00001000,
 	RT_SREQ_MASK					= 0x0000FFFF,   /* Requirements bit mask */
-	
+
 }RT_CHNLPLAN_SREQ, *PRT_CHNLPLAN_SREQ;
 
 
 //
 // RT_COUNTRY_NAME & RT_REGULATION_2G & RT_REGULATION_5G transfer table
-// 
+//
 //
 typedef struct _RT_CHANNEL_PLAN_COUNTRY_TRANSFER_TABLE
-{   
+{
+	//
+	// Define countery domain and corresponding
 	//
-	// Define countery domain and corresponding 
-	//	
 	RT_COUNTRY_NAME		Country_Enum;
 	char				Country_Name[3];
-	
+
 	//char		Domain_Name[12];
-	RT_REGULATION_2G	Domain_2G;	
+	RT_REGULATION_2G	Domain_2G;
 
-	RT_REGULATION_5G	Domain_5G;	
+	RT_REGULATION_5G	Domain_5G;
 
 	RT_CHANNEL_DOMAIN	RtChDomain;
 	//u1Byte		Country_Area;
-    
+
 }RT_CHNL_CTRY_TBL, *PRT_CHNL_CTRY_TBL;
-    
+
 
 #define		RT_MAX_CHNL_NUM_2G		13
-#define		RT_MAX_CHNL_NUM_5G		44	
+#define		RT_MAX_CHNL_NUM_5G		44
 
 // Power table sample.
 
@@ -640,7 +640,7 @@ typedef struct _RT_CHANNEL_PLAN_MAXPWR
 	RT_CHNL_PWR_LIMIT	Chnl[RT_MAX_BAND_NUM];
 	u1Byte				Band_Useful_Num;
 
-	
+
 }RT_CHANNEL_PLAN_MAXPWR, *PRT_CHANNEL_PLAN_MAXPWR;
 
 
@@ -651,49 +651,45 @@ typedef struct _RT_CHANNEL_PLAN_MAXPWR
 
 
 typedef struct _RT_CHANNEL_PLAN_NEW
-{   
+{
 	//
-	// Define countery domain and corresponding 
+	// Define countery domain and corresponding
 	//
 	//char		Country_Name[36];
 	//u1Byte		Country_Enum;
-	
+
 	//char		Domain_Name[12];
 
-	
+
 	PRT_CHNL_CTRY_TBL		pCtryTransfer;
-	
-	RT_CHANNEL_DOMAIN		RtChDomain;	
+
+	RT_CHANNEL_DOMAIN		RtChDomain;
 
 	RT_REGULATION_2G		Domain_2G;
 
-	RT_REGULATION_5G		Domain_5G;	
+	RT_REGULATION_5G		Domain_5G;
 
 	RT_REGULATION_CMN		Regulator;
 
 	RT_CHNLPLAN_SREQ		ChnlSreq;
-	
+
 	//RT_CHNL_PLAN_LIMIT		RtChnl;
-		
+
 	u1Byte	Chnl2G[MAX_CHANNEL_NUM];				// CHNL_RT_2G_WORLD
 	u1Byte	Len2G;
 	u1Byte	Chnl2GScanTp[MAX_CHANNEL_NUM];			// CHNL_RT_2G_WORLD_SCAN_TYPE
 	//u1Byte	Freq2G[2];								// FREQ_RT_2G_WORLD
 
-	u1Byte	Chnl5G[MAX_CHANNEL_NUM];				
+	u1Byte	Chnl5G[MAX_CHANNEL_NUM];
 	u1Byte	Len5G;
 	u1Byte	Chnl5GScanTp[MAX_CHANNEL_NUM];
 	//u1Byte	Freq2G[2];								// FREQ_RT_2G_WORLD
 
 	RT_CHANNEL_PLAN_MAXPWR	ChnlMaxPwr;
-	
-    
+
+
 }RT_CHANNEL_PLAN_NEW, *PRT_CHANNEL_PLAN_NEW;
-    
-    
+
+
 #endif	// __RT_CHANNELPLAN_H__
-    
-    
-    
-    
- 
+
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/rtl8821a/phydm_iqk_8821a_ce.c b/drivers/net/wireless/rtl8812au/hal/phydm/rtl8821a/phydm_iqk_8821a_ce.c
index 28905fd..b3f7bc2 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/rtl8821a/phydm_iqk_8821a_ce.c
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/rtl8821a/phydm_iqk_8821a_ce.c
@@ -33,10 +33,10 @@
 void DoIQK_8821A(
 	PVOID		pDM_VOID,
 	u1Byte 		DeltaThermalIndex,
-	u1Byte		ThermalValue,	
+	u1Byte		ThermalValue,
 	u1Byte 		Threshold
 	)
-{	
+{
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	pDM_Odm->RFCalibrateInfo.ThermalValue_IQK= ThermalValue;
 	PHY_IQCalibrate_8821A(pDM_Odm, FALSE);
@@ -47,7 +47,7 @@ void _IQK_RX_FillIQC_8821A(
 	IN ODM_RF_RADIO_PATH_E 	Path,
 	IN unsigned int			RX_X,
 	IN unsigned int			RX_Y
-	) 
+	)
 {
 	switch (Path) {
 	case ODM_RF_PATH_A:
@@ -60,8 +60,8 @@ void _IQK_RX_FillIQC_8821A(
 		}
 		break;
 	default:
-		break;					
-	};	
+		break;
+	};
 }
 
 void _IQK_TX_FillIQC_8821A(
@@ -69,7 +69,7 @@ void _IQK_TX_FillIQC_8821A(
 	IN ODM_RF_RADIO_PATH_E 	Path,
 	IN unsigned int			TX_X,
 	IN unsigned int			TX_Y
-	) 
+	)
 {
 	switch (Path) {
 	case ODM_RF_PATH_A:
@@ -85,14 +85,14 @@ void _IQK_TX_FillIQC_8821A(
 		}
 		break;
 	default:
-		break;					
-	};	
+		break;
+	};
 }
 
 void _IQK_BackupMacBB_8821A(
 	IN PDM_ODM_T	pDM_Odm,
 	IN pu4Byte		MACBB_backup,
-	IN pu4Byte		Backup_MACBB_REG, 
+	IN pu4Byte		Backup_MACBB_REG,
 	IN u4Byte		MACBB_NUM
 	)
 {
@@ -102,17 +102,17 @@ void _IQK_BackupMacBB_8821A(
 	for (i = 0; i < MACBB_NUM; i++){
 		MACBB_backup[i] = ODM_Read4Byte(pDM_Odm, Backup_MACBB_REG[i]);
 	}
-	
+
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("BackupMacBB Success!!!!\n"));
 }
 
 void _IQK_BackupRF_8821A(
 	IN PDM_ODM_T	pDM_Odm,
 	IN pu4Byte		RFA_backup,
-	IN pu4Byte		RFB_backup, 
-	IN pu4Byte		Backup_RF_REG, 
+	IN pu4Byte		RFB_backup,
+	IN pu4Byte		Backup_RF_REG,
 	IN u4Byte		RF_NUM
-	)	
+	)
 {
 
 	u4Byte i;
@@ -127,15 +127,15 @@ void _IQK_BackupRF_8821A(
 void _IQK_BackupAFE_8821A(
 	IN PDM_ODM_T		pDM_Odm,
 	IN pu4Byte		AFE_backup,
-	IN pu4Byte		Backup_AFE_REG, 
+	IN pu4Byte		Backup_AFE_REG,
 	IN u4Byte		AFE_NUM
 	)
 {
 	u4Byte i;
 	ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
-	//Save AFE Parameters 
+	//Save AFE Parameters
     	for (i = 0; i < AFE_NUM; i++){
-        	AFE_backup[i] = ODM_Read4Byte(pDM_Odm, Backup_AFE_REG[i]);	
+        	AFE_backup[i] = ODM_Read4Byte(pDM_Odm, Backup_AFE_REG[i]);
     	}
     	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("BackupAFE Success!!!!\n"));
 }
@@ -143,13 +143,13 @@ void _IQK_BackupAFE_8821A(
 void _IQK_RestoreMacBB_8821A(
 	IN PDM_ODM_T		pDM_Odm,
 	IN pu4Byte		MACBB_backup,
-	IN pu4Byte		Backup_MACBB_REG, 
+	IN pu4Byte		Backup_MACBB_REG,
 	IN u4Byte		MACBB_NUM
-	)	
+	)
 {
 	u4Byte i;
 	ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
-	//Reload MacBB Parameters 
+	//Reload MacBB Parameters
     	for (i = 0; i < MACBB_NUM; i++){
         	ODM_Write4Byte(pDM_Odm, Backup_MACBB_REG[i], MACBB_backup[i]);
     	}
@@ -163,7 +163,7 @@ void _IQK_RestoreRF_8821A(
 	IN pu4Byte 				RF_backup,
 	IN u4Byte				RF_REG_NUM
 	)
-{	
+{
 	u4Byte i;
 
 	ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
@@ -184,13 +184,13 @@ void _IQK_RestoreRF_8821A(
 void _IQK_RestoreAFE_8821A(
 	IN PDM_ODM_T		pDM_Odm,
 	IN pu4Byte		AFE_backup,
-	IN pu4Byte		Backup_AFE_REG, 
+	IN pu4Byte		Backup_AFE_REG,
 	IN u4Byte		AFE_NUM
 	)
 {
 	u4Byte i;
 	ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
-	//Reload AFE Parameters 
+	//Reload AFE Parameters
     	for (i = 0; i < AFE_NUM; i++){
         	ODM_Write4Byte(pDM_Odm, Backup_AFE_REG[i], AFE_backup[i]);
     	}
@@ -240,7 +240,7 @@ void _IQK_Tx_8821A(
 	while (cal < cal_num_8821A){
 		switch (Path) {
 			case ODM_RF_PATH_A:
-			{	
+			{
 				//Path-A LOK
 				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
 				// ========Path-A AFE all on========
@@ -291,7 +291,7 @@ void _IQK_Tx_8821A(
 
 				ODM_delay_ms(10); //Delay 10ms
 				ODM_Write4Byte(pDM_Odm, 0xcb8, 0x00000000);
-				
+
 				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
 				ODM_SetRFReg(pDM_Odm, Path, 0x58, 0x7fe00, ODM_GetRFReg(pDM_Odm, Path, 0x8, 0xffc00)); // Load LOK
 				switch (*pDM_Odm->pBandWidth)
@@ -305,12 +305,12 @@ void _IQK_Tx_8821A(
 						{
 						ODM_SetRFReg(pDM_Odm, Path, 0x18, 0x00c00, 0x0);
 						}
-						break;					
+						break;
 					default:
 							break;
 					}
 				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1); // [31] = 1 --> Page C1
-				
+
 				// 3. TX RF Setting
 				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
 				ODM_SetRFReg(pDM_Odm, Path, 0xef, bRFRegOffsetMask, 0x80000);
@@ -390,19 +390,18 @@ void _IQK_Tx_8821A(
 				                        	}
 				                    	}
 
-							if (delay_count < 20){							// If 20ms No Result, then cal_retry++
+							if (delay_count < 20) {							// If 20ms No Result, then cal_retry++
 					              	// ============TXIQK Check==============
 								TX_fail = ODM_GetBBReg(pDM_Odm, 0xd00, BIT(12));
-								
-								if (~TX_fail){
+
+								if (~TX_fail) {
 									ODM_Write4Byte(pDM_Odm, 0xcb8, 0x02000000);
 									VDF_X[k] = ODM_GetBBReg(pDM_Odm, 0xd00, 0x07ff0000)<<21;
 									ODM_Write4Byte(pDM_Odm, 0xcb8, 0x04000000);
 									VDF_Y[k] = ODM_GetBBReg(pDM_Odm, 0xd00, 0x07ff0000)<<21;
 									TX0IQKOK = TRUE;
 									break;
-								}
-								else{
+								} else {
 									ODM_SetBBReg(pDM_Odm, 0xccc, 0x000007ff, 0x0);
 									ODM_SetBBReg(pDM_Odm, 0xcd4, 0x000007ff, 0x200);
 									TX0IQKOK = FALSE;
@@ -411,8 +410,7 @@ void _IQK_Tx_8821A(
 										break;
 									}
 								}
-							}
-				                    else{
+							} else {
 				                    		TX0IQKOK = FALSE;
 				                        	cal_retry++;
 				                        	if (cal_retry == 10){
@@ -421,17 +419,16 @@ void _IQK_Tx_8821A(
 				                    }
 				       	}
 					}
-					if (k == 3){
+					if (k == 3) {
 						TX_X0[cal] = VDF_X[k-1] ;
 						TX_Y0[cal] = VDF_Y[k-1];
 					}
-				}
-				else{
+				} else {
 				ODM_Write4Byte(pDM_Odm, 0xc80, 0x18008c10);// TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16
 				ODM_Write4Byte(pDM_Odm, 0xc84, 0x38008c10);// RX_Tone_idx[9:0], RxK_Mask[29]
 				ODM_Write4Byte(pDM_Odm, 0xcb8, 0x00100000);// cb8[20] N SI/PI v iqk_dpk module
 				cal_retry = 0;
-				while(1){
+				while (1) {
 					// one shot
 					ODM_Write4Byte(pDM_Odm, 0x980, 0xfa000000);
 					ODM_Write4Byte(pDM_Odm, 0x980, 0xf8000000);
@@ -439,12 +436,11 @@ void _IQK_Tx_8821A(
 						ODM_delay_ms(10); //Delay 10ms
 					ODM_Write4Byte(pDM_Odm, 0xcb8, 0x00000000);
 					delay_count = 0;
-					while (1){
+					while (1) {
 						IQK_ready = ODM_GetBBReg(pDM_Odm, 0xd00, BIT(10));
 						if ((~IQK_ready) || (delay_count>20)) {
 					       	break;
-					}
-					else{
+					} else {
 							ODM_delay_ms(1);
 					       delay_count++;
 					}
@@ -453,7 +449,7 @@ void _IQK_Tx_8821A(
 					if (delay_count < 20){							// If 20ms No Result, then cal_retry++
 				       // ============TXIQK Check==============
 					TX_fail = ODM_GetBBReg(pDM_Odm, 0xd00, BIT(12));
-							
+
 						if (~TX_fail){
 							ODM_Write4Byte(pDM_Odm, 0xcb8, 0x02000000);
 							TX_X0[cal] = ODM_GetBBReg(pDM_Odm, 0xd00, 0x07ff0000)<<21;
@@ -461,8 +457,7 @@ void _IQK_Tx_8821A(
 							TX_Y0[cal] = ODM_GetBBReg(pDM_Odm, 0xd00, 0x07ff0000)<<21;
 							TX0IQKOK = TRUE;
 							break;
-						}
-						else{
+						} else {
 							ODM_SetBBReg(pDM_Odm, 0xccc, 0x000007ff, 0x0);
 							ODM_SetBBReg(pDM_Odm, 0xcd4, 0x000007ff, 0x200);
 							TX0IQKOK = FALSE;
@@ -471,19 +466,18 @@ void _IQK_Tx_8821A(
 								break;
 							}
 						}
-					}
-	                    		else{
+					} else {
 	                        		TX0IQKOK = FALSE;
 	                        		cal_retry++;
 	                        		if (cal_retry == 10)
-	                            		break;	
+	                            		break;
 	                    		}
 	                	}
 			}
 
 			if (TX0IQKOK == FALSE)
 				break;				// TXK fail, Don't do RXK
-			
+
                 	//====== RX IQK ======
                 	ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
 			// 1. RX RF Setting
@@ -494,28 +488,27 @@ void _IQK_Tx_8821A(
 			ODM_SetRFReg(pDM_Odm, Path, 0x8f, bRFRegOffsetMask, 0x88001);
 			ODM_SetRFReg(pDM_Odm, Path, 0x65, bRFRegOffsetMask, 0x931d8);
 			ODM_SetRFReg(pDM_Odm, Path, 0xef, bRFRegOffsetMask, 0x00000);
-			
+
 			ODM_SetBBReg(pDM_Odm, 0x978, 0x03FF8000, (TX_X0[cal])>>21&0x000007ff);
-                     ODM_SetBBReg(pDM_Odm, 0x978, 0x000007FF, (TX_Y0[cal])>>21&0x000007ff);
+                        ODM_SetBBReg(pDM_Odm, 0x978, 0x000007FF, (TX_Y0[cal])>>21&0x000007ff);
 			ODM_SetBBReg(pDM_Odm, 0x978, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0x97c, BIT(31), 0x0);
 			ODM_Write4Byte(pDM_Odm, 0x90c, 0x00008000);
 			ODM_Write4Byte(pDM_Odm, 0x984, 0x0046a911);
-			
+
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1); // [31] = 1 --> Page C1
 			ODM_Write4Byte(pDM_Odm, 0xc80, 0x38008c10);// TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16
 			ODM_Write4Byte(pDM_Odm, 0xc84, 0x18008c10);// RX_Tone_idx[9:0], RxK_Mask[29]
 			ODM_Write4Byte(pDM_Odm, 0xc88, 0x02140119);
 
-			if (pDM_Odm->SupportInterface == 1){
+			if (pDM_Odm->SupportInterface == 1) {
 				RXIQK_Loop = 2;				// for 2% fail;
-			}
-			else{
+			} else {
 				RXIQK_Loop = 1;
 			}
-			for(i = 0; i < RXIQK_Loop; i++){
+			for (i = 0; i < RXIQK_Loop; i++) {
 				if (pDM_Odm->SupportInterface == 1)
-						if(i == 0)
+						if (i == 0)
 							ODM_Write4Byte(pDM_Odm, 0xc8c, 0x28161100);  //Good
 						else
 							ODM_Write4Byte(pDM_Odm, 0xc8c, 0x28160d00);
@@ -523,9 +516,9 @@ void _IQK_Tx_8821A(
 					ODM_Write4Byte(pDM_Odm, 0xc8c, 0x28160d00);
 
 				ODM_Write4Byte(pDM_Odm, 0xcb8, 0x00100000);// cb8[20] N SI/PI v iqk_dpk module
-				
+
 				cal_retry = 0;
-				while(1){
+				while(1) {
 					// one shot
 					ODM_Write4Byte(pDM_Odm, 0x980, 0xfa000000);
 					ODM_Write4Byte(pDM_Odm, 0x980, 0xf8000000);
@@ -533,17 +526,16 @@ void _IQK_Tx_8821A(
 					ODM_delay_ms(10); //Delay 10ms
 					ODM_Write4Byte(pDM_Odm, 0xcb8, 0x00000000);
 					delay_count = 0;
-					while (1){
+					while (1) {
 						IQK_ready = ODM_GetBBReg(pDM_Odm, 0xd00, BIT(10));
 						if ((~IQK_ready)||(delay_count>20)){
 							break;
-						}
-						else{
+						} else {
 							ODM_delay_ms(1);
 							delay_count++;
 						}
 					}
-							
+
 					if (delay_count < 20){	// If 20ms No Result, then cal_retry++
 						// ============RXIQK Check==============
 						RX_fail = ODM_GetBBReg(pDM_Odm, 0xd00, BIT(11));
@@ -564,33 +556,31 @@ void _IQK_Tx_8821A(
 							Image_Power = (reg2<<32)+reg1;
 							DbgPrint("After PW = %d\n", Image_Power);
 							*/
-							
+
 							ODM_Write4Byte(pDM_Odm, 0xcb8, 0x06000000);
 								RX_X0[i][cal] = ODM_GetBBReg(pDM_Odm, 0xd00, 0x07ff0000)<<21;
 							ODM_Write4Byte(pDM_Odm, 0xcb8, 0x08000000);
 								RX_Y0[i][cal] = ODM_GetBBReg(pDM_Odm, 0xd00, 0x07ff0000)<<21;
 							RX0IQKOK = TRUE;
 							break;
-						}
-						else{
+						} else {
 							ODM_SetBBReg(pDM_Odm, 0xc10, 0x000003ff, 0x200>>1);
 							ODM_SetBBReg(pDM_Odm, 0xc10, 0x03ff0000, 0x0>>1);
 							RX0IQKOK = FALSE;
 							cal_retry++;
 							if (cal_retry == 10)
 								break;
-								
+
 						}
-					}
-					else{
+					} else {
 			                    	RX0IQKOK = FALSE;
 			                    	cal_retry++;
 			                    	if (cal_retry == 10)
 			                     	break;
 	                    		}
 				}
-			}	
-			
+			}
+
                 	if (TX0IQKOK)
                     		TX_Average++;
 			if (RX0IQKOK)
@@ -598,27 +588,27 @@ void _IQK_Tx_8821A(
 		}
 		break;
 	default:
-		break;					
+		break;
 		}
 	cal++;
 	}
 	// FillIQK Result
-	switch (Path){
+	switch (Path) {
 	case ODM_RF_PATH_A:
        {
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("========Path_A =======\n"));
 		if (TX_Average == 0)
 		    	break;
-		
-		for (i = 0; i < TX_Average; i++){
+
+		for (i = 0; i < TX_Average; i++) {
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("TX_X0[%d] = %x ;; TX_Y0[%d] = %x\n", i, (TX_X0[i])>>21&0x000007ff, i, (TX_Y0[i])>>21&0x000007ff));
 		}
-		for (i = 0; i < TX_Average; i++){
-			for (ii = i+1; ii <TX_Average; ii++){
+		for (i = 0; i < TX_Average; i++) {
+			for (ii = i+1; ii <TX_Average; ii++) {
 				dx = (TX_X0[i]>>21) - (TX_X0[ii]>>21);
-				if (dx < 3 && dx > -3){
+				if (dx < 3 && dx > -3) {
 					dy = (TX_Y0[i]>>21) - (TX_Y0[ii]>>21);
-						if (dy < 3 && dy > -3){
+						if (dy < 3 && dy > -3) {
 							TX_X = ((TX_X0[i]>>21) + (TX_X0[ii]>>21))/2;
 							TX_Y = ((TX_Y0[i]>>21) + (TX_Y0[ii]>>21))/2;
 							TX_finish = 1;
@@ -628,22 +618,22 @@ void _IQK_Tx_8821A(
 			}
 			if (TX_finish == 1)
 				break;
-		}	
+		}
 
 		if (TX_finish == 1){
 			_IQK_TX_FillIQC_8821A(pDM_Odm, Path, TX_X, TX_Y);
-		}
-		else{
+		} else {
 			_IQK_TX_FillIQC_8821A(pDM_Odm, Path, 0x200, 0x0);
 		}
-		
+
 		if (RX_Average == 0)
 		    	break;
-		
+
 		for (i = 0; i < RX_Average; i++){
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("RX_X0[0][%d] = %x ;; RX_Y0[0][%d] = %x\n", i, (RX_X0[0][i])>>21&0x000007ff, i, (RX_Y0[0][i])>>21&0x000007ff));
-			if (RXIQK_Loop == 2)
+			if (RXIQK_Loop == 2) {
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("RX_X0[1][%d] = %x ;; RX_Y0[1][%d] = %x\n", i, (RX_X0[1][i])>>21&0x000007ff, i, (RX_Y0[1][i])>>21&0x000007ff));
+			}
 		}
 		for (i = 0; i < RX_Average; i++){
 			for (ii = i+1; ii <RX_Average; ii++){
@@ -680,7 +670,7 @@ void _IQK_Tx_8821A(
 				}
 					if (RX_finish2 == 1)
 					break;
-			}	
+			}
 			if(RX_finish1 && RX_finish2){
 				RX_X = (RX_X+RX_X_temp)/2;
 				RX_Y = (RX_Y+RX_Y_temp)/2;
@@ -688,8 +678,7 @@ void _IQK_Tx_8821A(
 		}
 		if (RX_finish1 || RX_finish2){
 			_IQK_RX_FillIQC_8821A(pDM_Odm, Path, RX_X, RX_Y);
-		}
-		else{
+		} else {
 			_IQK_RX_FillIQC_8821A(pDM_Odm, Path, 0x200, 0x0);
 		}
 		}
@@ -699,7 +688,7 @@ void _IQK_Tx_8821A(
 	}
 }
 
-#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)                         
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
 VOID
 phy_IQCalibrate_By_FW_8821A(
 	IN 	PDM_ODM_T	pDM_Odm
@@ -727,34 +716,34 @@ phy_IQCalibrate_By_FW_8821A(
 		Buf2 = 0x1<<2;
 	else
 		Buf2 = 0x1<<3;
-	
+
 	IQKcmd[1] = Buf1 | Buf2;
 	IQKcmd[2] = pDM_Odm->ExtPA5G | pDM_Odm->ExtLNA5G<<1;
-	
+
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("== FW IQK Start ==\n"));
 	pDM_Odm->RFCalibrateInfo.IQK_StartTime = 0;
 	pDM_Odm->RFCalibrateInfo.IQK_StartTime = ODM_GetCurrentTime( pDM_Odm);
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("== StartTime: %lld\n", pDM_Odm->RFCalibrateInfo.IQK_StartTime));
 	ODM_FillH2CCmd(pDM_Odm, ODM_H2C_IQ_CALIBRATION, 3, IQKcmd);
-	
+
 
 }
 #endif
-                         
-VOID	
+
+VOID
 phy_IQCalibrate_8821A(
 	IN PDM_ODM_T		pDM_Odm
 	)
 {
 	u4Byte	MACBB_backup[MACBB_REG_NUM_8821A], AFE_backup[AFE_REG_NUM_8821A], RFA_backup[RF_REG_NUM_8821A], RFB_backup[RF_REG_NUM_8821A];
-	u4Byte 	Backup_MACBB_REG[MACBB_REG_NUM_8821A] = {0x520, 0x550, 0x808, 0xa04, 0x90c, 0xc00, 0x838, 0x82c}; 
-	u4Byte 	Backup_AFE_REG[AFE_REG_NUM_8821A] = {0xc5c, 0xc60, 0xc64, 0xc68}; 
-	u4Byte 	Backup_RF_REG[RF_REG_NUM_8821A] = {0x65, 0x8f, 0x0}; 
+	u4Byte 	Backup_MACBB_REG[MACBB_REG_NUM_8821A] = {0x520, 0x550, 0x808, 0xa04, 0x90c, 0xc00, 0x838, 0x82c};
+	u4Byte 	Backup_AFE_REG[AFE_REG_NUM_8821A] = {0xc5c, 0xc60, 0xc64, 0xc68};
+	u4Byte 	Backup_RF_REG[RF_REG_NUM_8821A] = {0x65, 0x8f, 0x0};
 
 	_IQK_BackupMacBB_8821A(pDM_Odm, MACBB_backup, Backup_MACBB_REG, MACBB_REG_NUM_8821A);
 	_IQK_BackupAFE_8821A(pDM_Odm, AFE_backup, Backup_AFE_REG, AFE_REG_NUM_8821A);
 	_IQK_BackupRF_8821A(pDM_Odm, RFA_backup, RFB_backup, Backup_RF_REG, RF_REG_NUM_8821A);
-	
+
 	_IQK_ConfigureMAC_8821A(pDM_Odm);
 	_IQK_Tx_8821A(pDM_Odm, ODM_RF_PATH_A);
 
@@ -763,7 +752,7 @@ phy_IQCalibrate_8821A(
 	_IQK_RestoreMacBB_8821A(pDM_Odm, MACBB_backup, Backup_MACBB_REG, MACBB_REG_NUM_8821A);
 }
 
-VOID 
+VOID
 PHY_ResetIQKResult_8821A(
 	IN	PDM_ODM_T	pDM_Odm
 )
@@ -786,12 +775,12 @@ PHY_IQCalibrate_8821A(
 {
 #if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
 	PADAPTER 		pAdapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 
-	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
-	u4Byte			counter = 0;	
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	u4Byte			counter = 0;
 	#endif
-#endif	
+#endif
 
 #if (DM_ODM_SUPPORT_TYPE & ODM_WIN )
 	if (ODM_CheckPowerStatus(pAdapter) == FALSE)
@@ -799,26 +788,24 @@ PHY_IQCalibrate_8821A(
 #endif
 
 	if (pDM_Odm->mp_mode){   		//(MP_DRIVER == 1)
-		#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+		#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 			#if (MP_DRIVER == 1)
-		PMPT_CONTEXT	pMptCtx = &(pAdapter->MptCtx);	
+		PMPT_CONTEXT	pMptCtx = &(pAdapter->MptCtx);
 				if( pMptCtx->bSingleTone || pMptCtx->bCarrierSuppression)
 				return;
 			#endif
 		#else// (DM_ODM_SUPPORT_TYPE == ODM_CE)
-		PMPT_CONTEXT	pMptCtx = &(pAdapter->mppriv.MptCtx);		
+		PMPT_CONTEXT	pMptCtx = &(pAdapter->mppriv.MptCtx);
 		if( pMptCtx->bSingleTone || pMptCtx->bCarrierSuppression)
 			return;
-		#endif	
-		
+		#endif
+
 	}
 	pDM_Odm->IQKFWOffload = 0;
-	
+
 	//3 == FW IQK ==
-	if(pDM_Odm->IQKFWOffload)
-	{
-		if ( ! pDM_Odm->RFCalibrateInfo.bIQKInProgress) 
-		{
+	if(pDM_Odm->IQKFWOffload) {
+		if ( ! pDM_Odm->RFCalibrateInfo.bIQKInProgress) {
 			ODM_AcquireSpinLock( pDM_Odm, RT_IQK_SPINLOCK);
 			pDM_Odm->RFCalibrateInfo.bIQKInProgress = TRUE;
 			ODM_ReleaseSpinLock( pDM_Odm, RT_IQK_SPINLOCK);
@@ -850,7 +837,7 @@ PHY_IQCalibrate_8821A(
 		}
 	}
 	//3 == Driver IQK ==
-	else {			
+	else {
 		if ( ! pDM_Odm->RFCalibrateInfo.bIQKInProgress) {
 			ODM_AcquireSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
 			pDM_Odm->RFCalibrateInfo.bIQKInProgress = TRUE;
@@ -860,17 +847,14 @@ PHY_IQCalibrate_8821A(
 			phy_IQCalibrate_8821A(pDM_Odm);
 			pDM_Odm->RFCalibrateInfo.IQK_ProgressingTime = ODM_GetProgressingTime( pDM_Odm, pDM_Odm->RFCalibrateInfo.IQK_StartTime);
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("IQK ProgressingTime = %lld ms\n", pDM_Odm->RFCalibrateInfo.IQK_ProgressingTime));
-			
+
 			ODM_AcquireSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
 			pDM_Odm->RFCalibrateInfo.bIQKInProgress = FALSE;
 			ODM_ReleaseSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
-		}
-		else
-		{
+		} else {
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("== Return the IQK CMD, because the IQK in Progress ==\n"));
 		}
 	}
-	
+
 }
 #endif
-
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/txbf/halcomtxbf.c b/drivers/net/wireless/rtl8812au/hal/phydm/txbf/halcomtxbf.c
index 395a217..d4bc10c 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/txbf/halcomtxbf.c
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/txbf/halcomtxbf.c
@@ -17,8 +17,9 @@ halComTxbf_beamformInit(
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
-	if (pDM_Odm->SupportICType & ODM_RTL8822B)
+	if (pDM_Odm->SupportICType & ODM_RTL8822B) {
 		HalTxbf8822B_Init(pDM_Odm);
+	}
 }
 
 /*Only used for MU BFer Entry when get GID management frame (self is as MU STA)*/
@@ -29,8 +30,9 @@ halComTxbf_ConfigGtab(
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
-	if (pDM_Odm->SupportICType & ODM_RTL8822B)
+	if (pDM_Odm->SupportICType & ODM_RTL8822B) {
 		HalTxbf8822B_ConfigGtab(pDM_Odm);
+	}
 }
 
 VOID
@@ -167,7 +169,7 @@ phydm_beamformSetGetTxRate(
 #endif
 }
 
-VOID 
+VOID
 halComTxbf_EnterWorkItemCallback(
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	IN	PADAPTER		Adapter
@@ -184,20 +186,24 @@ halComTxbf_EnterWorkItemCallback(
 #endif
 	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
 	u1Byte			Idx = pTxbfInfo->TXBFIdx;
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
-	
-	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821))
+
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821)) {
 		HalTxbfJaguar_Enter(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E) {
 		HalTxbf8192E_Enter(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_Enter(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8822B)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8822B) {
 		HalTxbf8822B_Enter(pDM_Odm, Idx);
+	}
 }
 
-VOID 
+VOID
 halComTxbf_LeaveWorkItemCallback(
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	IN	PADAPTER		Adapter
@@ -218,18 +224,22 @@ halComTxbf_LeaveWorkItemCallback(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
-	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821))
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821)) {
 		HalTxbfJaguar_Leave(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E) {
 		HalTxbf8192E_Leave(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_Leave(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8822B)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8822B) {
 		HalTxbf8822B_Leave(pDM_Odm, Idx);
+	}
 }
 
 
-VOID 
+VOID
 halComTxbf_FwNdpaWorkItemCallback(
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	IN	PADAPTER		Adapter
@@ -249,14 +259,18 @@ halComTxbf_FwNdpaWorkItemCallback(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
-	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821))
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821)) {
 		HalTxbfJaguar_FwTxBF(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E) {
 		HalTxbf8192E_FwTxBF(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_FwTxBF(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8822B)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8822B) {
 		HalTxbf8822B_FwTxBF(pDM_Odm, Idx);
+	}
 }
 
 VOID
@@ -277,14 +291,15 @@ halComTxbf_ClkWorkItemCallback(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
-	if (pDM_Odm->SupportICType & ODM_RTL8812)
+	if (pDM_Odm->SupportICType & ODM_RTL8812) {
 		HalTxbfJaguar_Clk_8812A(pDM_Odm);
+	}
 }
 
 
 
 VOID
-halComTxbf_RateWorkItemCallback(	
+halComTxbf_RateWorkItemCallback(
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	IN	PADAPTER		Adapter
 #else
@@ -300,22 +315,24 @@ halComTxbf_RateWorkItemCallback(
 #endif
 	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
 	u1Byte			BW = pTxbfInfo->BW;
-	u1Byte			Rate = pTxbfInfo->Rate;	
-	
+	u1Byte			Rate = pTxbfInfo->Rate;
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
-	if (pDM_Odm->SupportICType & ODM_RTL8812)
+	if (pDM_Odm->SupportICType & ODM_RTL8812) {
 		HalTxbf8812A_setNDPArate(pDM_Odm, BW, Rate);
-	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E) {
 		HalTxbf8192E_setNDPArate(pDM_Odm, BW, Rate);
-	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_setNDPArate(pDM_Odm, BW, Rate);
-	
+	}
 }
 
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-VOID 
+VOID
 halComTxbf_FwNdpaTimerCallback(
 	IN	PRT_TIMER		pTimer
 	)
@@ -327,13 +344,14 @@ halComTxbf_FwNdpaTimerCallback(
 
 	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
 
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
-	if (*pDM_Odm->pbFwDwRsvdPageInProgress)
+	if (*pDM_Odm->pbFwDwRsvdPageInProgress) {
 		ODM_SetTimer(pDM_Odm, &(pTxbfInfo->Txbf_FwNdpaTimer), 5);
-	else
+	} else {
 		PlatformScheduleWorkItem(&(pTxbfInfo->Txbf_FwNdpaWorkItem));
+	}
 }
 #endif
 
@@ -359,14 +377,18 @@ halComTxbf_StatusWorkItemCallback(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
-	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821))
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821)) {
 		HalTxbfJaguar_Status(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E) {
 		HalTxbf8192E_Status(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_Status(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8822B)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8822B) {
 		HalTxbf8822B_Status(pDM_Odm, Idx);
+	}
 }
 
 VOID
@@ -388,9 +410,9 @@ halComTxbf_ResetTxPathWorkItemCallback(
 
 	u1Byte			Idx = pTxbfInfo->TXBFIdx;
 
-	if (pDM_Odm->SupportICType & ODM_RTL8814A)
+	if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_ResetTxPath(pDM_Odm, Idx);
-	
+	}
 }
 
 VOID
@@ -408,9 +430,10 @@ halComTxbf_GetTxRateWorkItemCallback(
 #else
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 #endif
-	
-	if (pDM_Odm->SupportICType & ODM_RTL8814A)
+
+	if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_GetTxRate(pDM_Odm);
+	}
 }
 
 
@@ -426,7 +449,7 @@ HalComTxbf_Set(
 	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] setType = 0x%X\n", __func__, setType));
-	
+
 	switch(setType){
 	case TXBF_SET_SOUNDING_ENTER:
 	pTxbfInfo->TXBFIdx = *pU1Tmp;
@@ -457,7 +480,7 @@ HalComTxbf_Set(
 	case TXBF_SET_SOUNDING_CLK:
 	phydm_beamformSetSoundingClk(pDM_Odm);
 	break;
-		
+
 	case TXBF_SET_TX_PATH_RESET:
 	pTxbfInfo->TXBFIdx = *pU1Tmp;
 	phydm_beamformSetResetTxPath(pDM_Odm);
@@ -466,7 +489,7 @@ HalComTxbf_Set(
 	case TXBF_SET_GET_TX_RATE:
 	phydm_beamformSetGetTxRate(pDM_Odm);
 	break;
-	
+
 	}
 
 	return TRUE;
@@ -498,7 +521,7 @@ HalComTxbf_Get(
 			*pBoolean = FALSE;
 	} else if (getType == TXBF_GET_EXPLICIT_BEAMFORMER) {
 		if (IS_HARDWARE_TYPE_OLDER_THAN_8812A(Adapter))
-			*pBoolean = FALSE;		
+			*pBoolean = FALSE;
 		else	if (/*IS_HARDWARE_TYPE_8822B(Adapter)	||*/
 				IS_HARDWARE_TYPE_8821B(Adapter) 	||
 				IS_HARDWARE_TYPE_8192E(Adapter) 	||
@@ -519,18 +542,18 @@ HalComTxbf_Get(
 
 
 	} else if (getType == TXBF_GET_MU_MIMO_AP) {
-#if (RTL8822B_SUPPORT == 1)	
+#if (RTL8822B_SUPPORT == 1)
 		if (IS_HARDWARE_TYPE_8822B(Adapter))
 			*pBoolean = TRUE;
 		else
 #endif
 			*pBoolean = FALSE;
 	}
-	
+
 	return TRUE;
-}	
+}
 #endif
 
 
-#endif 
+#endif
 
diff --git a/drivers/net/wireless/rtl8812au/hal/phydm/txbf/haltxbfjaguar.c b/drivers/net/wireless/rtl8812au/hal/phydm/txbf/haltxbfjaguar.c
index e125371..83671d8 100644
--- a/drivers/net/wireless/rtl8812au/hal/phydm/txbf/haltxbfjaguar.c
+++ b/drivers/net/wireless/rtl8812au/hal/phydm/txbf/haltxbfjaguar.c
@@ -17,8 +17,8 @@ HalTxbf8812A_setNDPArate(
 )
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	
-	ODM_Write1Byte(pDM_Odm, REG_NDPA_OPT_CTRL_8812A,  (Rate << 2 | BW));	
+
+	ODM_Write1Byte(pDM_Odm, REG_NDPA_OPT_CTRL_8812A,  (Rate << 2 | BW));
 
 }
 
@@ -29,7 +29,7 @@ halTxbfJaguar_RfMode(
 )
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	
+
 	if (pDM_Odm->RFType == ODM_1T1R)
 		return;
 
@@ -133,9 +133,9 @@ halTxbfJaguar_DownloadNDPA(
 		DLBcnCount++;
 	} while (!(BcnValidReg & BIT0) && DLBcnCount < 5);
 
-	if (!(BcnValidReg & BIT0))
+	if (!(BcnValidReg & BIT0)) {
 		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Download RSVD page failed!\n", __func__));
-
+	}
 	/*TDECTRL[15:8] 0x209[7:0] = 0xF6	Beacon Head for TXDMA*/
 	ODM_Write1Byte(pDM_Odm, REG_TDECTRL_8812A + 1, TxPageBndy);
 
@@ -306,7 +306,7 @@ HalTxbfJaguar_Leave(
 	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
 	RT_BEAMFORMER_ENTRY	BeamformerEntry;
 	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
-	
+
 	if (Idx < BEAMFORMER_ENTRY_NUM) {
 		BeamformerEntry = pBeamformingInfo->BeamformerEntry[Idx];
 		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[Idx];
@@ -318,7 +318,7 @@ HalTxbfJaguar_Leave(
 	/*Clear P_AID of Beamformee*/
 	/*Clear MAC address of Beamformer*/
 	/*Clear Associated Bfmee Sel*/
-	
+
 	if (BeamformerEntry.BeamformEntryCap == BEAMFORMING_CAP_NONE) {
 		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8812A, 0xC8);
 		if (Idx == 0) {
@@ -346,7 +346,7 @@ HalTxbfJaguar_Leave(
 			ODM_Write2Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 2, ODM_Read2Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 2) & 0x60);
 		}
 	}
-	
+
 }
 
 
@@ -440,14 +440,14 @@ HalTxbfJaguar_Clk_8812A(
 	u2Byte	u2btmp;
 	u1Byte	Count = 0, u1btmp;
 	PADAPTER	Adapter = pDM_Odm->Adapter;
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
 	if (*(pDM_Odm->pbScanInProcess)) {
 		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] return by Scan\n", __func__));
 		return;
 	}
-#if DEV_BUS_TYPE == RT_PCI_INTERFACE	
+#if DEV_BUS_TYPE == RT_PCI_INTERFACE
 	/*Stop PCIe TxDMA*/
 	ODM_Write1Byte(pDM_Odm, REG_PCIE_CTRL_REG_8812A + 1, 0xFE);
 #endif
@@ -521,7 +521,4 @@ HalTxbfJaguar_Clk_8812A(
 
 #endif
 
-
-
 #endif
-
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8812a/usb/rtl8812au_xmit.c b/drivers/net/wireless/rtl8812au/hal/rtl8812a/usb/rtl8812au_xmit.c
index 68ee167..bc5f941 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8812a/usb/rtl8812au_xmit.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8812a/usb/rtl8812au_xmit.c
@@ -112,7 +112,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz , u8 ba
 
 	/* offset 12 */
 
-	if (!pattrib->qos_en && pattrib->sw_seq == _FALSE) {
+	if (!pattrib->qos_en) {
 		SET_TX_DESC_HWSEQ_EN_8812(ptxdesc, 1); /* Hw set sequence number */
 	} else
 		SET_TX_DESC_SEQ_8812(ptxdesc, pattrib->seqnum);
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c b/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c
index 423ba9f..f0a247a 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c
@@ -554,7 +554,6 @@ PHY_ConfigBB_8814A(
 }
 
 
-
 //2 3.3 RF Config
 
 s32
@@ -1157,7 +1156,7 @@ PHY_GetTxPowerIndex_8814A(
 	tpt_offset = PHY_GetTxPowerTrackingOffset(pAdapter, RFPath, Rate);
 
 	powerDiffByRate = powerDiffByRate > limit ? limit : powerDiffByRate;
-	/*RTW_INFO("Rate-0x%x: (TxPower, PowerDiffByRate Path-%c) = (0x%X, %d)\n", Rate, ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), txPower, powerDiffByRate);*/
+	RTW_INFO("Rate-0x%x: (TxPower, PowerDiffByRate Path-%c) = (0x%X, %d)\n", Rate, ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), txPower, powerDiffByRate);
 
 	txPower += powerDiffByRate;
 
@@ -1184,8 +1183,8 @@ PHY_GetTxPowerIndex_8814A(
 		//(pHalData->bautoload_fail_flag || pHalData->EfuseMap[EFUSE_INIT_MAP][EEPROM_TX_PWR_INX_JAGUAR] == 0xFF))
 		//txPower = 0x12;
 
-	/*RTW_INFO("Final Tx Power(RF-%c, Channel: %d) = %d(0x%X)\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), Channel,
-		txPower, txPower);*/
+	RTW_INFO("Final Tx Power(RF-%c, Channel: %d) = %d(0x%X)\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), Channel,
+		txPower, txPower);
 
 	return (u8) txPower;
 }
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_sreset.c b/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_sreset.c
index 4a7947e..b9e83fd 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_sreset.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_sreset.c
@@ -93,7 +93,7 @@ void rtl8814_sreset_linked_status_check(_adapter *padapter)
 	regc58 = rtw_read32(padapter,0xc58);
 	reg824 = rtw_read32(padapter,0x824);
 	reg800 = rtw_read32(padapter,0x800);
-	if(	((regc50&0xFFFFFF00)!= 0x69543400)||
+	if (	((regc50&0xFFFFFF00)!= 0x69543400)||
 		((regc58&0xFFFFFF00)!= 0x69543400)||
 		(((reg824&0xFFFFFF00)!= 0x00390000)&&(((reg824&0xFFFFFF00)!= 0x80390000)))||
 		( ((reg800&0xFFFFFF00)!= 0x03040000)&&((reg800&0xFFFFFF00)!= 0x83040000)))
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_xmit.c b/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_xmit.c
index 43b8268..bb6cdd8 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_xmit.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8814a/rtl8814a_xmit.c
@@ -172,7 +172,6 @@ InsertEMContent_8814(
 }
 
 
-
 void UpdateEarlyModeInfo8814(struct xmit_priv *pxmitpriv,struct xmit_buf *pxmitbuf )
 {
 	//_adapter *padapter, struct xmit_frame *pxmitframe,struct tx_servq	*ptxservq
@@ -254,7 +253,6 @@ void rtl8814a_cal_txdesc_chksum(u8 *ptxdesc)
 	u32 index;
 	u16 checksum = 0;
 
-
 	usPtr = (u16*)ptxdesc;
 	// checksume is always calculated by first 32 bytes,
 	// and it doesn't depend on TX DESC length.
@@ -439,7 +437,7 @@ BWMapping_8814(
 		else
 			BWSettingOfDesc = 0;
 	}
-	else if(pHalData->CurrentChannelBW== CHANNEL_WIDTH_40) {
+	else if (pHalData->CurrentChannelBW== CHANNEL_WIDTH_40) {
 		if ((pattrib->bwmode == CHANNEL_WIDTH_40) || (pattrib->bwmode == CHANNEL_WIDTH_80))
 			BWSettingOfDesc = 1;
 		else
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/rtl8814au_xmit.c b/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/rtl8814au_xmit.c
index 8200263..0f4d3e1 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/rtl8814au_xmit.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/rtl8814au_xmit.c
@@ -61,7 +61,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
 	if (padapter->registrypriv.mp_mode == 0) {
-		if((PACKET_OFFSET_SZ != 0) && (!bagg_pkt) &&(rtw_usb_bulk_size_boundary(padapter,TXDESC_SIZE+sz)==_FALSE)) {
+		if ((PACKET_OFFSET_SZ != 0) && (!bagg_pkt) &&(rtw_usb_bulk_size_boundary(padapter,TXDESC_SIZE+sz)==_FALSE)) {
 			ptxdesc = (pmem+PACKET_OFFSET_SZ);
 			//RTW_INFO("==> non-agg-pkt,shift pointer...\n");
 			pull = 1;
@@ -94,10 +94,9 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 	}
 
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
-	if (padapter->registrypriv.mp_mode == 0)
-	{
-		if((PACKET_OFFSET_SZ != 0) && (!bagg_pkt)){
-			if((pull) && (pxmitframe->pkt_offset>0)) {
+	if (padapter->registrypriv.mp_mode == 0) {
+		if ((PACKET_OFFSET_SZ != 0) && (!bagg_pkt)) {
+			if ((pull) && (pxmitframe->pkt_offset>0)) {
 				pxmitframe->pkt_offset = pxmitframe->pkt_offset -1;
 			}
 		}
@@ -119,10 +118,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 
 	if (!pattrib->qos_en) {
 		/* HW sequence, to fix to use 0 queue. todo: 4AC packets to use auto queue select */
-		if (pattrib->sw_seq == _FALSE)
-			SET_TX_DESC_HWSEQ_EN_8814A(ptxdesc, 1); // Hw set sequence number
-		else
-			SET_TX_DESC_SEQ_8814A(ptxdesc, pattrib->seqnum);
+		SET_TX_DESC_HWSEQ_EN_8814A(ptxdesc, 1); // Hw set sequence number
 		SET_TX_DESC_EN_HWEXSEQ_8814A(ptxdesc, 0);
 		SET_TX_DESC_DISQSELSEQ_8814A(ptxdesc, 1);
 		SET_TX_DESC_HW_SSN_SEL_8814A(ptxdesc, 0);
@@ -130,8 +126,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 		SET_TX_DESC_SEQ_8814A(ptxdesc, pattrib->seqnum);
 	}
 
-	if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
-	{
+	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {
 		//RTW_INFO("pxmitframe->frame_tag == DATA_FRAMETAG\n");
 
 		rtl8814a_fill_txdesc_sectype(pattrib, ptxdesc);
@@ -189,7 +184,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			if (padapter->fix_rate != 0xFF) { // modify data rate by iwpriv
 				SET_TX_DESC_USE_RATE_8814A(ptxdesc, 1);
 				DriverFixedRate = 0x01;
-				if(padapter->fix_rate & BIT(7))
+				if (padapter->fix_rate & BIT(7))
 					SET_TX_DESC_DATA_SHORT_8814A(ptxdesc, 	1);
 
 				SET_TX_DESC_TX_RATE_8814A(ptxdesc, (padapter->fix_rate & 0x7F));
@@ -202,7 +197,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			if (pattrib->stbc)
 				SET_TX_DESC_DATA_STBC_8814A(ptxdesc, 1);
 
-			//work arond before fixing RA
+			//work around before fixing RA
 			//SET_TX_DESC_USE_RATE_8814A(ptxdesc, 1);
 			//SET_TX_DESC_TX_RATE_8814A(ptxdesc, 0x10);
 		} else {
@@ -253,7 +248,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			SET_TX_DESC_DATA_RETRY_LIMIT_8814A(ptxdesc, 5);
 			SET_TX_DESC_DISABLE_FB_8814A(ptxdesc, 1);
 
-			//if(pattrib->rts_cca)
+			//if (pattrib->rts_cca)
 			//{
 			//	SET_TX_DESC_NDPA_8812(ptxdesc, 2);
 			//}
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_halinit.c b/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_halinit.c
index b134d5a..e9a5c68 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_halinit.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_halinit.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -33,8 +33,7 @@ static void _dbg_dump_macreg(_adapter *padapter)
 	u32 offset = 0;
 	u32 val32 = 0;
 	u32 index =0 ;
-	for(index=0;index<64;index++)
-	{
+	for (index=0;index<64;index++) {
 		offset = index*4;
 		val32 = rtw_read32(padapter,offset);
 		RTW_INFO("offset : 0x%02x ,val:0x%08x\n",offset,val32);
@@ -52,11 +51,11 @@ _ConfigChipOutEP_8814(
 	pHalData->OutEpQueueSel = 0;
 	pHalData->OutEpNumber = 0;
 
-	switch(NumOutPipe){
+	switch (NumOutPipe) {
 		case 	4:
 				pHalData->OutEpQueueSel=TX_SELE_HQ| TX_SELE_LQ|TX_SELE_NQ;
 				pHalData->OutEpNumber=4;
-				break;		
+				break;
 		case 	3:
 				pHalData->OutEpQueueSel=TX_SELE_HQ| TX_SELE_LQ|TX_SELE_NQ;
 				pHalData->OutEpNumber=3;
@@ -69,9 +68,9 @@ _ConfigChipOutEP_8814(
 				pHalData->OutEpQueueSel=TX_SELE_HQ;
 				pHalData->OutEpNumber=1;
 				break;
-		default:				
+		default:
 				break;
-			
+
 	}
 	RTW_INFO("%s OutEpQueueSel(0x%02x), OutEpNumber(%d) \n",__FUNCTION__,pHalData->OutEpQueueSel,pHalData->OutEpNumber );
 
@@ -87,10 +86,10 @@ static BOOLEAN HalUsbSetQueuePipeMapping8814AUsb(
 	BOOLEAN			result		= _FALSE;
 
 	_ConfigChipOutEP_8814(pAdapter, NumOutPipe);
-	
+
 	// Normal chip with one IN and one OUT doesn't have interrupt IN EP.
-	if(1 == pHalData->OutEpNumber){
-		if(1 != NumInPipe){
+	if (1 == pHalData->OutEpNumber) {
+		if (1 != NumInPipe) {
 			return result;
 		}
 	}
@@ -101,7 +100,7 @@ static BOOLEAN HalUsbSetQueuePipeMapping8814AUsb(
 	//}
 
 	result = Hal_MappingOutPipe(pAdapter, NumOutPipe);
-	
+
 	return result;
 
 }
@@ -173,55 +172,45 @@ _InitBurstPktLen(IN PADAPTER Adapter)
 {
 	u8 			u1bTmp;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
- 
+
 	//yx_qi 131128 move to 0x1448, 144c
 	rtw_write32(Adapter, REG_FAST_EDCA_VOVI_SETTING_8814A, 0x08070807); //yx_qi 131128
 	rtw_write32(Adapter, REG_FAST_EDCA_BEBK_SETTING_8814A, 0x08070807); //yx_qi 131128
-	
+
 	u1bTmp = rtw_read8(Adapter, 0xff); //check device operation speed: SS 0xff bit7
-	
-	if(u1bTmp & BIT7)   //USB2/1.1 Mode
-	{
+
+	if (u1bTmp & BIT7) { //USB2/1.1 Mode
  		pHalData->bSupportUSB3 = FALSE;
-	}
-	else  //USB3 Mode
-	{		
+	} else { //USB3 Mode
 		pHalData->bSupportUSB3 = TRUE;
 	}
-	
-	if(pHalData->bSupportUSB3 == _FALSE)   //USB2/1.1 Mode
-	{
-		if(pHalData->UsbBulkOutSize == 512)
-		{
+
+	if (pHalData->bSupportUSB3 == _FALSE) { //USB2/1.1 Mode
+		if (pHalData->UsbBulkOutSize == 512) {
 			//set burst pkt len=512B
 			rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x1e);
-		}
-		else
-		{
+		} else {
 			//set burst pkt len=64B
-			rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x2e);		
+			rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x2e);
 		}
 
 		rtw_write16(Adapter, REG_RXDMA_AGG_PG_TH_8814A,0x2005); //dmc agg th 20K
-	}
-	else  //USB3 Mode
-	{		
+	} else { //USB3 Mode
 		//set burst pkt len=1k
-		rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x0e);				
+		rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x0e);
 		rtw_write16(Adapter, REG_RXDMA_AGG_PG_TH_8814A,0x0a05); //dmc agg th 20K
-		
+
 		// set Reg 0xf008[3:4] to 2'00 to disable U1/U2 Mode to avoid 2.5G spur in USB3.0. added by page, 20120712
 		rtw_write8(Adapter, 0xf008, rtw_read8(Adapter, 0xf008)&0xE7);
 		//to avoid usb 3.0 H2C fail
 		rtw_write16(Adapter, 0xf002, 0);
-		
+
 		rtw_write8(Adapter, REG_SW_AMPDU_BURST_MODE_CTRL_8814A, rtw_read8(Adapter, REG_SW_AMPDU_BURST_MODE_CTRL_8814A) & ~BIT(6));
 		RTW_INFO("turn off the LDPC pre-TX\n");
-		
-	} 
 
-	if(pHalData->AMPDUBurstMode)
-	{
+	}
+
+	if (pHalData->AMPDUBurstMode) {
 		rtw_write8(Adapter,REG_SW_AMPDU_BURST_MODE_CTRL_8814A,  0x5F);
 	}
 }
@@ -232,7 +221,7 @@ _InitQueueReservedPage_8814AUsb(
 	)
 {
 	struct registry_priv	*pregistrypriv = &Adapter->registrypriv;
-	u16		txpktbuf_bndy; 
+	u16		txpktbuf_bndy;
 
 	RTW_INFO("===>_InitQueueReservedPage_8814AUsb()\n");
 
@@ -246,7 +235,7 @@ _InitQueueReservedPage_8814AUsb(
 
 	rtw_write32(Adapter, REG_RQPN_CTRL_2_8814A, 0x80000000);
 
-	if(!pregistrypriv->wifi_spec)
+	if (!pregistrypriv->wifi_spec)
 		txpktbuf_bndy = TX_PAGE_BOUNDARY_8814A;
 	else		// for WMM
 		txpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY_8814A;
@@ -260,7 +249,7 @@ _InitQueueReservedPage_8814AUsb(
 	rtw_write16(Adapter,REG_FIFOPAGE_CTRL_2_8814A, txpktbuf_bndy);
 	//The head page of packet of Bcnq1
 	rtw_write16(Adapter,REG_FIFOPAGE_CTRL_2_8814A+2,txpktbuf_bndy);
-	
+
 	RTW_INFO("<===_InitQueueReservedPage_8814AUsb()\n");
 }
 
@@ -273,7 +262,7 @@ static u32 _InitPowerOn_8814AU(_adapter *padapter)
 	u8	u1btmp = rtw_read8(padapter, 0x10C2);
 	rtw_write8(padapter, 0x10C2, (u1btmp | BIT1));
 
-	if(!HalPwrSeqCmdParsing(padapter, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8814A_NIC_ENABLE_FLOW))
+	if (!HalPwrSeqCmdParsing(padapter, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8814A_NIC_ENABLE_FLOW))
 		return _FAIL;
 
 	// Enable MAC DMA/WMAC/SCHEDULE/SEC block
@@ -320,9 +309,9 @@ _InitPageBoundary_8814AUsb(
 {
 	//20130416 KaiYuan modified for 8814
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
-	
+
 	rtw_write16(Adapter, REG_RXFF_PTR_8814A, RX_DMA_BOUNDARY_8814A); //yx_qi 20140331
-	
+
 }
 
 static VOID
@@ -353,11 +342,11 @@ _InitNormalChipTwoOutEpPriority_8814AUsb(
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 	struct registry_priv	*pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
-	
+
 	u16	valueHi = 0;
 	u16	valueLow = 0;
-	
-	switch(pHalData->OutEpQueueSel)
+
+	switch (pHalData->OutEpQueueSel)
 	{
 		case (TX_SELE_HQ | TX_SELE_LQ):
 			valueHi = QUEUE_HIGH;
@@ -373,27 +362,27 @@ _InitNormalChipTwoOutEpPriority_8814AUsb(
 			break;
 		default:
 			valueHi = QUEUE_HIGH;
-			valueLow = QUEUE_NORMAL;			
+			valueLow = QUEUE_NORMAL;
 			break;
 	}
 
-	if(!pregistrypriv->wifi_spec){
+	if (!pregistrypriv->wifi_spec) {
 		beQ 		= valueLow;
 		bkQ 		= valueLow;
 		viQ		= valueHi;
 		voQ 		= valueHi;
-		mgtQ 	= valueHi; 
-		hiQ 		= valueHi;								
+		mgtQ 	= valueHi;
+		hiQ 		= valueHi;
 	}
-	else{//for WMM ,CONFIG_OUT_EP_WIFI_MODE
+	else { //for WMM ,CONFIG_OUT_EP_WIFI_MODE
 		beQ		= valueLow;
 		bkQ 		= valueHi;
 		viQ 		= valueHi;
 		voQ 		= valueLow;
 		mgtQ 	= valueHi;
-		hiQ 		= valueHi;							
+		hiQ 		= valueHi;
 	}
-	
+
 	_InitNormalChipRegPriority_8814AUsb(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
 }
 
@@ -405,21 +394,20 @@ _InitNormalChipThreeOutEpPriority_8814AUsb(
 	struct registry_priv	*pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
 
-	if(!pregistrypriv->wifi_spec){// typical setting
+	if (!pregistrypriv->wifi_spec) { // typical setting
 		beQ		= QUEUE_LOW;
 		bkQ 		= QUEUE_LOW;
 		viQ 		= QUEUE_NORMAL;
 		voQ 		= QUEUE_HIGH;
 		mgtQ 	= QUEUE_HIGH;
-		hiQ 		= QUEUE_HIGH;			
-	}
-	else{// for WMM
+		hiQ 		= QUEUE_HIGH;
+	} else { // for WMM
 		beQ		= QUEUE_LOW;
 		bkQ 		= QUEUE_NORMAL;
 		viQ 		= QUEUE_NORMAL;
 		voQ 		= QUEUE_HIGH;
 		mgtQ 	= QUEUE_HIGH;
-		hiQ 		= QUEUE_HIGH;			
+		hiQ 		= QUEUE_HIGH;
 	}
 	_InitNormalChipRegPriority_8814AUsb(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
 }
@@ -431,7 +419,7 @@ _InitQueuePriority_8814AUsb(
 {
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 
-	switch(pHalData->OutEpNumber)
+	switch (pHalData->OutEpNumber)
 	{
 		case 2:
 			_InitNormalChipTwoOutEpPriority_8814AUsb(Adapter);
@@ -499,8 +487,8 @@ _InitWMACSetting_8814A(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
 	//pHalData->ReceiveConfig = AAP | APM | AM | AB | APP_ICV | ADF | AMF | APP_FCS | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;
-	pHalData->ReceiveConfig = 
-	RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYST_RXFF;	  
+	pHalData->ReceiveConfig =
+	RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYST_RXFF;
 
 #if (1 == RTL8812A_RX_PACKET_INCLUDE_CRC)
 	pHalData->ReceiveConfig |= ACRC32;
@@ -539,7 +527,7 @@ _InitWMACSetting_8814A(
 	//rtw_write16(Adapter, REG_RXFLTMAP0, value16);
 
 	//enable RX_SHIFT bits
-	//rtw_write8(Adapter, REG_TRXDMA_CTRL, rtw_read8(Adapter, REG_TRXDMA_CTRL)|BIT(1));	
+	//rtw_write8(Adapter, REG_TRXDMA_CTRL, rtw_read8(Adapter, REG_TRXDMA_CTRL)|BIT(1));
 
 }
 */
@@ -553,21 +541,21 @@ _InitMacConfigure_8814A(
 	u16			value16;
 	u32			regRRSR;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	
+
 	switch (Adapter->registrypriv.wireless_mode)
 	{
 		case WIRELESS_11B:
 			regRRSR = RATE_ALL_CCK;
 			break;
-		
+
 		case WIRELESS_11G:
 		case WIRELESS_11A:
 		case WIRELESS_11_5N:
-		case WIRELESS_11A_5N://Todo: no basic rate for ofdm ?
+		case WIRELESS_11A_5N: //Todo: no basic rate for ofdm ?
 		case WIRELESS_11_5AC:
 			regRRSR = RATE_ALL_OFDM_AG;
 			break;
-		
+
 		case WIRELESS_11BG:
 		case WIRELESS_11G_24N:
 		case WIRELESS_11_24N:
@@ -575,7 +563,7 @@ _InitMacConfigure_8814A(
 		default:
 			regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 			break;
-	
+
 	}
 
 	// Init value for RRSR.
@@ -584,7 +572,7 @@ _InitMacConfigure_8814A(
 	// Retry Limit
 	value16 = _LRL(0x30) | _SRL(0x30);
 	rtw_write16(Adapter, REG_RETRY_LIMIT_8814A, value16);
-	
+
 	pHalData->ReceiveConfig = RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYST_RXFF;
 	pHalData->ReceiveConfig |= FORCEACK;
 #if (1 == RTL8812A_RX_PACKET_INCLUDE_CRC)
@@ -608,8 +596,8 @@ _InitMacConfigure_8814A(
 
 	// 201409/25 MH When RA is enabled, we need to reduce the value.
 	rtw_write8(Adapter, REG_MAX_AGGR_NUM_8814A, 0x36);
-	rtw_write8(Adapter, REG_RTS_MAX_AGGR_NUM_8814A,0x36); 
-	
+	rtw_write8(Adapter, REG_RTS_MAX_AGGR_NUM_8814A,0x36);
+
 }
 
 /*
@@ -643,7 +631,7 @@ _InitAdaptiveCtrl_8812AUsb(
 	// Retry Limit
 	value16 = _LRL(0x30) | _SRL(0x30);
 	rtw_write16(Adapter, REG_RL, value16);
-	
+
 }*/
 
 static VOID
@@ -656,7 +644,7 @@ _InitEDCA_8814AUsb(
 	rtw_write16(Adapter,REG_MAC_SPEC_SIFS, 0x100a);
 
 	// Set SIFS for CCK
-	rtw_write16(Adapter,REG_SIFS_CTX, 0x100a);	
+	rtw_write16(Adapter,REG_SIFS_CTX, 0x100a);
 
 	// Set SIFS for OFDM
 	rtw_write16(Adapter,REG_SIFS_TRX, 0x100a);
@@ -679,9 +667,9 @@ _InitBeaconMaxError_8814A(
 	)
 {
 #ifdef CONFIG_ADHOC_WORKAROUND_SETTING
-	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);	
+	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
 #else
-	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));	
+	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));
 #endif
 }
 
@@ -689,12 +677,12 @@ _InitBeaconMaxError_8814A(
 static void _InitHWLed(PADAPTER Adapter)
 {
 	struct led_priv *pledpriv = &(Adapter->ledpriv);
-	
-	if( pledpriv->LedStrategy != HW_LED)
+
+	if ( pledpriv->LedStrategy != HW_LED)
 		return;
-	
+
 // HW led control
-// to do .... 
+// to do ....
 //must consider cases of antenna diversity/ commbo card/solo card/mini card
 
 }
@@ -717,7 +705,7 @@ _InitRetryFunction_8814A(
 	)
 {
 	u8	value8;
-	
+
 	value8 = rtw_read8(Adapter, REG_FWHW_TXQ_CTRL);
 	value8 |= EN_AMPDU_RTY_NEW;
 	rtw_write8(Adapter, REG_FWHW_TXQ_CTRL, value8);
@@ -730,7 +718,7 @@ _InitRetryFunction_8814A(
 /*-----------------------------------------------------------------------------
  * Function:	usb_AggSettingTxUpdate()
  *
- * Overview:	Seperate TX/RX parameters update independent for TP detection and 
+ * Overview:	Seperate TX/RX parameters update independent for TP detection and
  *			dynamic TX/RX aggreagtion parameters update.
  *
  * Input:			PADAPTER
@@ -751,25 +739,25 @@ usb_AggSettingTxUpdate_8814A(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u32			value32;
 
-	if(Adapter->registrypriv.wifi_spec)
+	if (Adapter->registrypriv.wifi_spec)
 		pHalData->UsbTxAggDescNum = 1;
 
-	if(pHalData->UsbTxAggMode){
+	if (pHalData->UsbTxAggMode){
 		value32 = rtw_read32(Adapter, REG_TDECTRL);
 		value32 = value32 & ~(BLK_DESC_NUM_MASK << BLK_DESC_NUM_SHIFT);
 		value32 |= ((pHalData->UsbTxAggDescNum & BLK_DESC_NUM_MASK) << BLK_DESC_NUM_SHIFT);
-		
+
 		rtw_write32(Adapter, REG_TDECTRL, value32);
 		rtw_write8(Adapter, REG_TDECTRL+3, pHalData->UsbTxAggDescNum<<1);
 	}
-	
+
 #endif //CONFIG_USB_TX_AGGREGATION
 }	// usb_AggSettingTxUpdate
 
 /*-----------------------------------------------------------------------------
  * Function:	usb_AggSettingRxUpdate()
  *
- * Overview:	Seperate TX/RX parameters update independent for TP detection and 
+ * Overview:	Seperate TX/RX parameters update independent for TP detection and
  *			dynamic TX/RX aggreagtion parameters update.
  *
  * Input:			PADAPTER
@@ -793,7 +781,7 @@ usb_AggSettingRxUpdate_8814A(
 
 	valueDMA = rtw_read8(Adapter, REG_TRXDMA_CTRL_8814A);
 	valueUSB = rtw_read8(Adapter, REG_RXDMA_AGG_PG_TH_8814A+3);
-	switch(pHalData->rxagg_mode)
+	switch (pHalData->rxagg_mode)
 	{
 		case RX_AGG_DMA:
 			valueDMA |= RXDMA_AGG_EN;
@@ -853,7 +841,7 @@ init_UsbAggregationSetting_8814A(
  *
  * Revised History:
  *	When		Who		Remark
- *	12/10/2010	MHC		Create Version 0.  
+ *	12/10/2010	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
 VOID
@@ -866,37 +854,33 @@ USB_AggModeSwitch(
 	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
 
 	//pHalData->UsbRxHighSpeedMode = _FALSE;
-	// How to measure the RX speed? We assume that when traffic is more than 
+	// How to measure the RX speed? We assume that when traffic is more than
 	if (pMgntInfo->bRegAggDMEnable == _FALSE)
 	{
 		return;	// Inf not support.
 	}
-		
-	if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _TRUE && 
+
+	if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _TRUE &&
 		pHalData->UsbRxHighSpeedMode == _FALSE)
 	{
 		pHalData->UsbRxHighSpeedMode = _TRUE;
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("UsbAggModeSwitchCheck to HIGH\n"));
 	}
-	else if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _FALSE && 
+	else if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _FALSE &&
 		pHalData->UsbRxHighSpeedMode == _TRUE)
 	{
 		pHalData->UsbRxHighSpeedMode = _FALSE;
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("UsbAggModeSwitchCheck to LOW\n"));
+	} else {
+		return;
 	}
-	else
-	{
-		return; 
-	}
-	
+
 #if USB_RX_AGGREGATION_92C
-	if (pHalData->UsbRxHighSpeedMode == _TRUE)	
-	{
+	if (pHalData->UsbRxHighSpeedMode == _TRUE) {
 		// 2010/12/10 MH The parameter is tested by SD1 engineer and SD3 channel emulator.
 		// USB mode
 #if (RT_PLATFORM == PLATFORM_LINUX)
-		if (pMgntInfo->LinkDetectInfo.bTxBusyTraffic)
-		{
+		if (pMgntInfo->LinkDetectInfo.bTxBusyTraffic) {
 			pHalData->RxAggBlockCount	= 16;
 			pHalData->RxAggBlockTimeout	= 7;
 		}
@@ -908,23 +892,20 @@ USB_AggModeSwitch(
 		}
 		// Mix mode
 		pHalData->RxAggPageCount	= 72;
-		pHalData->RxAggPageTimeout	= 6;		
-	}
-	else
-	{
+		pHalData->RxAggPageTimeout	= 6;
+	} else {
 		// USB mode
 		pHalData->RxAggBlockCount	= pMgntInfo->RegRxAggBlockCount;
-		pHalData->RxAggBlockTimeout	= pMgntInfo->RegRxAggBlockTimeout;	
+		pHalData->RxAggBlockTimeout	= pMgntInfo->RegRxAggBlockTimeout;
 		// Mix mode
 		pHalData->RxAggPageCount		= pMgntInfo->RegRxAggPageCount;
-		pHalData->RxAggPageTimeout	= pMgntInfo->RegRxAggPageTimeout;	
+		pHalData->RxAggPageTimeout	= pMgntInfo->RegRxAggPageTimeout;
 	}
 
 	if (pHalData->RxAggBlockCount > MAX_RX_AGG_BLKCNT)
 		pHalData->RxAggBlockCount = MAX_RX_AGG_BLKCNT;
 #if (OS_WIN_FROM_VISTA(OS_VERSION)) || (RT_PLATFORM == PLATFORM_LINUX)	// do not support WINXP to prevent usbehci.sys BSOD
-	if (IS_WIRELESS_MODE_N_24G(Adapter) || IS_WIRELESS_MODE_N_5G(Adapter))
-	{
+	if (IS_WIRELESS_MODE_N_24G(Adapter) || IS_WIRELESS_MODE_N_5G(Adapter)) {
 		//
 		// 2010/12/24 MH According to V1012 QC IOT test, XP BSOD happen when running chariot test
 		// with the aggregation dynamic change!! We need to disable the function to prevent it is broken
@@ -933,12 +914,12 @@ USB_AggModeSwitch(
 		usb_AggSettingRxUpdate_8188E(Adapter);
 
 		// 2010/12/27 MH According to designer's suggstion, we can only modify Timeout value. Otheriwse
-		// there might many HW incorrect behavior, the XP BSOD at usbehci.sys may be relative to the 
+		// there might many HW incorrect behavior, the XP BSOD at usbehci.sys may be relative to the
 		// issue. Base on the newest test, we can not enable block cnt > 30, otherwise XP usbehci.sys may
 		// BSOD.
 	}
 #endif
-	
+
 #endif
 #endif
 }	// USB_AggModeSwitch
@@ -957,7 +938,7 @@ _InitOperationMode_8814A(
 	//
 	// Set RRSR, RATR, and REG_BWOPMODE registers
 	//
-	switch(Adapter->RegWirelessMode)
+	switch (Adapter->RegWirelessMode)
 	{
 		case WIRELESS_MODE_B:
 			regBwOpMode = BW_OPMODE_20MHZ;
@@ -975,14 +956,11 @@ _InitOperationMode_8814A(
 			regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 			break;
 		case WIRELESS_MODE_AUTO:
-			if (Adapter->bInHctTest)
-			{
+			if (Adapter->bInHctTest) {
 			    regBwOpMode = BW_OPMODE_20MHZ;
 			    regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 			    regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
-			}
-			else
-			{
+			} else {
 			    regBwOpMode = BW_OPMODE_20MHZ;
 			    regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
 			    regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
@@ -1000,7 +978,7 @@ _InitOperationMode_8814A(
 			regRATR = RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
 			regRRSR = RATE_ALL_OFDM_AG;
 			break;
-			
+
 		default: //for MacOSX compiler warning.
 			break;
 	}
@@ -1039,20 +1017,19 @@ static VOID _RfPowerSave(
 	return;
 #endif
 
-	if(pMgntInfo->RegRfOff == _TRUE){ // User disable RF via registry.
+	if (pMgntInfo->RegRfOff == _TRUE) { // User disable RF via registry.
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RegRfOff.\n"));
 		MgntActSet_RF_State(Adapter, eRfOff, RF_CHANGE_BY_SW);
 		// Those action will be discard in MgntActSet_RF_State because off the same state
 		for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 			PHY_SetRFReg(Adapter, eRFPath, 0x4, 0xC00, 0x0);
 	}
-	else if(pMgntInfo->RfOffReason > RF_CHANGE_BY_PS){ // H/W or S/W RF OFF before sleep.
+	else if (pMgntInfo->RfOffReason > RF_CHANGE_BY_PS) { // H/W or S/W RF OFF before sleep.
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason));
 		MgntActSet_RF_State(Adapter, eRfOff, pMgntInfo->RfOffReason);
-	}
-	else{
+	} else {
 		pHalData->eRFPowerState = eRfOn;
-		pMgntInfo->RfOffReason = 0; 
+		pMgntInfo->RfOffReason = 0;
 		if(Adapter->bInSetPower || Adapter->bResetInProgress)
 			PlatformUsbEnableInPipes(Adapter);
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): RF is on.\n"));
@@ -1062,7 +1039,7 @@ static VOID _RfPowerSave(
 */
 enum {
 	Antenna_Lfet = 1,
-	Antenna_Right = 2,	
+	Antenna_Right = 2,
 };
 
 static VOID
@@ -1071,21 +1048,21 @@ _InitAntenna_Selection_8814A(IN	PADAPTER Adapter)
 
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 
-	if(pHalData->AntDivCfg==0)
+	if (pHalData->AntDivCfg==0)
 		return;
-/*		
-	RTW_INFO("==>  %s ....\n",__FUNCTION__);		
+/*
+	RTW_INFO("==>  %s ....\n",__FUNCTION__);
 
 	rtw_write8(Adapter, REG_LEDCFG2, 0x82);
 
 	PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
-		
+
 	if(PHY_QueryBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300) == MAIN_ANT)
 		pHalData->CurAntenna = MAIN_ANT;
 	else
 		pHalData->CurAntenna = AUX_ANT;
 	RTW_INFO("%s,Cur_ant:(%x)%s\n",__FUNCTION__,pHalData->CurAntenna,(pHalData->CurAntenna == MAIN_ANT)?"MAIN_ANT":"AUX_ANT");
-			
+
 */
 }
 
@@ -1104,28 +1081,24 @@ HalDetectSelectiveSuspendMode(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(Adapter);
 
-	// If support HW radio detect, we need to enable WOL ability, otherwise, we 
+	// If support HW radio detect, we need to enable WOL ability, otherwise, we
 	// can not use FW to notify host the power state switch.
-	
+
 	EFUSE_ShadowRead(Adapter, 1, EEPROM_USB_OPTIONAL1, (u32 *)&tmpvalue);
 
 	DBG_8192C("HalDetectSelectiveSuspendMode(): SS ");
-	if(tmpvalue & BIT1)
-	{
+	if (tmpvalue & BIT1) {
 		DBG_8192C("Enable\n");
-	}
-	else
-	{
+	} else {
 		DBG_8192C("Disable\n");
 		pdvobjpriv->RegUsbSS = _FALSE;
 	}
 
 	// 2010/09/01 MH According to Dongle Selective Suspend INF. We can switch SS mode.
-	if (pdvobjpriv->RegUsbSS && !SUPPORT_HW_RADIO_DETECT(pHalData))
-	{
+	if (pdvobjpriv->RegUsbSS && !SUPPORT_HW_RADIO_DETECT(pHalData)) {
 		//PMGNT_INFO				pMgntInfo = &(Adapter->MgntInfo);
 
-		//if (!pMgntInfo->bRegDongleSS)	
+		//if (!pMgntInfo->bRegDongleSS)
 		//{
 		//	RT_TRACE(COMP_INIT, DBG_LOUD, ("Dongle disable SS\n"));
 			pdvobjpriv->RegUsbSS = _FALSE;
@@ -1156,12 +1129,11 @@ static void rtl8814au_hw_reset(_adapter *Adapter)
 {
 #if 0
                 u8 reg_val=0;
-	if(rtw_read8(Adapter, REG_MCUFWDL)&BIT7)
-	{		
-		_8051Reset8812(Adapter);  
+	if (rtw_read8(Adapter, REG_MCUFWDL)&BIT7) {
+		_8051Reset8812(Adapter);
 		rtw_write8(Adapter, REG_MCUFWDL, 0x00);
 		//before BB reset should do clock gated
-		rtw_write32(Adapter, rFPGA0_XCD_RFPara, 
+		rtw_write32(Adapter, rFPGA0_XCD_RFPara,
 			rtw_read32(Adapter, rFPGA0_XCD_RFPara)|(BIT6));
 		//reset BB
 		reg_val = rtw_read8(Adapter, REG_SYS_FUNC_EN);
@@ -1172,16 +1144,16 @@ static void rtl8814au_hw_reset(_adapter *Adapter)
 		//reset TRX path
 		rtw_write16(Adapter, REG_CR, 0);
 		//reset MAC
-		reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1); 
+		reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1);
 		reg_val |= BIT(1);
 		reg_val = rtw_write8(Adapter, REG_APS_FSMCO+1, reg_val);       //reg0x5[1] ,auto FSM off
 
 		reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1);
- 
+
 		//check if   reg0x5[1] auto cleared
-		while(reg_val & BIT(1)){
+		while (reg_val & BIT(1)) {
 			rtw_udelay_os(1);
-			reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1); 
+			reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1);
 		}
 		reg_val |= BIT(0);
 		reg_val = rtw_write8(Adapter, REG_APS_FSMCO+1, reg_val);     //reg0x5[0] ,auto FSM on
@@ -1272,7 +1244,7 @@ u32 rtl8814au_hal_init(PADAPTER Adapter)
 	int hal_init_profiling_i;
 	u32 hal_init_stages_timestamp[HAL_INIT_STAGES_NUM]; //used to record the time of each stage's starting point
 
-	for(hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM;hal_init_profiling_i++)
+	for (hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM;hal_init_profiling_i++)
 		hal_init_stages_timestamp[hal_init_profiling_i]=0;
 
 	#define HAL_INIT_PROFILE_TAG(stage) hal_init_stages_timestamp[(stage)]=rtw_get_current_time();
@@ -1281,15 +1253,12 @@ u32 rtl8814au_hal_init(PADAPTER Adapter)
 #endif //DBG_HAL_INIT_PROFILING
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
-	if(pwrctrlpriv->bkeepfwalive)
-	{
+	if (pwrctrlpriv->bkeepfwalive) {
 		_ps_open_RF(Adapter);
 
-		if(pHalData->bIQKInitialized){
+		if (pHalData->bIQKInitialized) {
 			//PHY_IQCalibrate_8812A(Adapter,_TRUE);
-		}
-		else
-		{
+		} else {
 			//PHY_IQCalibrate_8812A(Adapter,_FALSE);
 			//pHalData->bIQKInitialized = _TRUE;
 		}
@@ -1301,16 +1270,13 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 	}
 
 	// Check if MAC has already power on. by tynli. 2011.05.27.
-	value8 = rtw_read8(Adapter, REG_SYS_CLKR+1);	
+	value8 = rtw_read8(Adapter, REG_SYS_CLKR+1);
 	u1bRegCR = rtw_read8(Adapter, REG_CR);
 	RTW_INFO(" power-on :REG_SYS_CLKR 0x09=0x%02x. REG_CR 0x100=0x%02x.\n", value8, u1bRegCR);
-	if((value8&BIT3)  && (u1bRegCR != 0 && u1bRegCR != 0xEA))
-	{
+	if ((value8&BIT3)  && (u1bRegCR != 0 && u1bRegCR != 0xEA)) {
 		//pHalData->bMACFuncEnable = _TRUE;
 		RTW_INFO(" MAC has already power on.\n");
-	}
-	else
-	{
+	} else {
 		//pHalData->bMACFuncEnable = _FALSE;
 		// Set FwPSState to ALL_ON mode to prevent from the I/O be return because of 32k
 		// state which is set before sleep under wowlan mode. 2012.01.04. by tynli.
@@ -1332,7 +1298,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 	}*/
 
 /*
-	If HW didn't go through a complete de-initial procedure,  
+	If HW didn't go through a complete de-initial procedure,
 	it probably occurs some problem for double initial procedure.
 	Like "CONFIG_DEINIT_BEFORE_INIT" in 92du chip
 */
@@ -1340,15 +1306,15 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PW_ON);
 	status = _InitPowerOn_8814AU(Adapter);
-	if(status == _FAIL){
+	if (status == _FAIL) {
 		RTW_INFO("Failed to init power on!\n");
 		goto exit;
 	}
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_LLTT);
-	
+
 	status =  InitLLTTable8814A(Adapter);
-	if(status == _FAIL){
+	if (status == _FAIL) {
 		RTW_INFO("Failed to init LLT table\n");
 		goto exit;
 	}
@@ -1375,8 +1341,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOWNLOAD_FW);
 	}
 
 	InitializeFirmwareVars8814(Adapter);
-	
-	if(pwrctrlpriv->reg_rfoff == _TRUE){
+
+	if (pwrctrlpriv->reg_rfoff == _TRUE) {
 		pwrctrlpriv->rf_pwrstate = rf_off;
 	}
 
@@ -1393,16 +1359,15 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOWNLOAD_FW);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MAC);
 #if (HAL_MAC_ENABLE == 1)
 	status = PHY_MACConfig8814(Adapter);
-	if(status == _FAIL)
-	{
+	if (status == _FAIL) {
 		goto exit;
 	}
 #endif //HAL_MAC_ENABLE
-	
+
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC01);
-	
+
 	_InitQueuePriority_8814AUsb(Adapter);
-	_InitPageBoundary_8814AUsb(Adapter);	
+	_InitPageBoundary_8814AUsb(Adapter);
 
 	_InitTransferPageSize_8814AUsb(Adapter);
 
@@ -1411,8 +1376,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 	_InitDriverInfoSize_8814A(Adapter, DRVINFO_SZ);
 
 	_InitInterrupt_8814AU(Adapter);
-	_InitID_8814A(Adapter);//set mac_address
-	_InitNetworkType_8814A(Adapter);//set msr	
+	_InitID_8814A(Adapter); //set mac_address
+	_InitNetworkType_8814A(Adapter); //set msr
 	_InitMacConfigure_8814A(Adapter);
 	//_InitWMACSetting_8814A(Adapter);
 	//_InitAdaptiveCtrl_8814AUsb(Adapter);
@@ -1428,7 +1393,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 
 	//
 	// Init CR MACTXEN, MACRXEN after setting RxFF boundary REG_TRXFF_BNDY to patch
-	// Hw bug which Hw initials RxFF boundry size to a value which is larger than the real Rx buffer size in 88E. 
+	// Hw bug which Hw initials RxFF boundry size to a value which is larger than the real Rx buffer size in 88E.
 	// 2011.08.05. by tynli.
 	//
 	value8 = rtw_read8(Adapter, REG_CR);
@@ -1449,7 +1414,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 	rtw_write16(Adapter, REG_PKT_BE_BK_LIFE_TIME, 0x3000);	// unit: 256us. 3s
 #endif	// CONFIG_TX_MCAST2UNI
 #endif	// CONFIG_CONCURRENT_MODE || CONFIG_TX_MCAST2UNI
-	
+
 #ifdef CONFIG_LED
 	_InitHWLed(Adapter);
 #endif //CONFIG_LED
@@ -1461,8 +1426,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB);
 #if (HAL_BB_ENABLE == 1)
 	status = PHY_BBConfig8814(Adapter);
-	if(status == _FAIL)
-	{
+	if (status == _FAIL) {
 		goto exit;
 	}
 #endif //HAL_BB_ENABLE
@@ -1472,9 +1436,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF);
 #if (HAL_RF_ENABLE == 1)
-	status = PHY_RFConfig8814A(Adapter);	
-	if(status == _FAIL)
-	{
+	status = PHY_RFConfig8814A(Adapter);
+	if (status == _FAIL) {
 		goto exit;
 	}
 
@@ -1485,12 +1448,12 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF);
 
 	PHY_ConfigBB_8814A(Adapter);
 
-	if(Adapter->registrypriv.channel <= 14)
+	if (Adapter->registrypriv.channel <= 14)
 		PHY_SwitchWirelessBand8814A(Adapter, BAND_ON_2_4G);
 	else
 		PHY_SwitchWirelessBand8814A(Adapter, BAND_ON_5G);
 
-	rtw_hal_set_chnl_bw(Adapter, Adapter->registrypriv.channel, 
+	rtw_hal_set_chnl_bw(Adapter, Adapter->registrypriv.channel,
 		CHANNEL_WIDTH_20, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_TURN_ON_BLOCK);
@@ -1503,9 +1466,9 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 
 	// HW SEQ CTRL
 	//set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM.
-	rtw_write8(Adapter,REG_HWSEQ_CTRL, 0xFF); 
-	
-	// 
+	rtw_write8(Adapter,REG_HWSEQ_CTRL, 0xFF);
+
+	//
 	// Disable BAR, suggested by Scott
 	// 2010.04.09 add by hpfan
 	//
@@ -1513,7 +1476,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 
 	rtw_write8(Adapter,REG_SECONDARY_CCA_CTRL_8814A,0x03);
 
-	if(pregistrypriv->wifi_spec)
+	if (pregistrypriv->wifi_spec)
 		rtw_write16(Adapter,REG_FAST_EDCA_CTRL ,0);
 	//adjust EDCCA to avoid collision
 	/*if(pregistrypriv->wifi_spec)
@@ -1525,21 +1488,21 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_HAL_DM);
 	rtl8814_InitHalDm(Adapter);
-	
+
 	//
 	// 2010/08/11 MH Merge from 8192SE for Minicard init. We need to confirm current radio status
-	// and then decide to enable RF or not.!!!??? For Selective suspend mode. We may not 
+	// and then decide to enable RF or not.!!!??? For Selective suspend mode. We may not
 	// call init_adapter. May cause some problem??
 	//
-	// Fix the bug that Hw/Sw radio off before S3/S4, the RF off action will not be executed 
-	// in MgntActSet_RF_State() after wake up, because the value of pHalData->eRFPowerState 
+	// Fix the bug that Hw/Sw radio off before S3/S4, the RF off action will not be executed
+	// in MgntActSet_RF_State() after wake up, because the value of pHalData->eRFPowerState
 	// is the same as eRfOff, we should change it to eRfOn after we config RF parameters.
 	// Added by tynli. 2010.03.30.
 	pwrctrlpriv->rf_pwrstate = rf_on;
 
 	PHY_IQCalibrate_8814A_Init(&pHalData->odmpriv);
 
-#if (HAL_BB_ENABLE == 1)	
+#if (HAL_BB_ENABLE == 1)
 	PHY_SetRFEReg8814A(Adapter, _TRUE, pHalData->CurrentBandType);
 #endif //HAL_BB_ENABLE
 
@@ -1561,13 +1524,12 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_HAL_DM);
 	// Reset USB mode switch setting
 	rtw_write8(Adapter, REG_SDIO_CTRL_8814A, 0x0);
 	rtw_write8(Adapter, REG_ACLK_MON, 0x0);
-	
+
 	//RT_TRACE(COMP_INIT, DBG_TRACE, ("InitializeAdapter8188EUsb() <====\n"));
-	
+
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_IQK);
 	// 2010/08/26 MH Merge from 8192CE.
-	if(pwrctrlpriv->rf_pwrstate == rf_on)
-	{
+	if (pwrctrlpriv->rf_pwrstate == rf_on) {
 /*		if(IS_HARDWARE_TYPE_8812AU(Adapter))
 		{
 #if (RTL8812A_SUPPORT == 1)
@@ -1584,9 +1546,9 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_IQK);
 	//this should be done by rf team using phydm code
 	//PHY_IQCalibrate_8814A(&pHalData->odmpriv, _FALSE);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_PW_TRACK);
-		
+
 		//ODM_TXPowerTrackingCheck(&pHalData->odmpriv );
-		
+
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_LCK);
 		//PHY_LCCalibrate_8812A(Adapter);
 	}
@@ -1596,8 +1558,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC21);
 //HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PABIAS);
 //	_InitPABias(Adapter);
 #if (MP_DRIVER == 1)
-	if (Adapter->registrypriv.mp_mode == 1)
-	{
+	if (Adapter->registrypriv.mp_mode == 1) {
 		Adapter->mppriv.channel = pHalData->CurrentChannel;
 		MPT_InitializeAdapter(Adapter, Adapter->mppriv.channel);
 	}
@@ -1610,13 +1571,10 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BT_COEXIST);
 	// suspend mode automatically.
 	//HwSuspendModeEnable92Cu(Adapter, _FALSE);
 
-	if ( _TRUE == pHalData->EEPROMBluetoothCoexist)
-        {
-               // Init BT hw config.
-                rtw_btcoex_HAL_Initialize(Adapter, _FALSE);      
-        }
-        else
-        {
+	if ( _TRUE == pHalData->EEPROMBluetoothCoexist) {
+		// Init BT hw config.
+                rtw_btcoex_HAL_Initialize(Adapter, _FALSE);
+        } else {
                 // In combo card run wifi only , must setting some hardware reg.
                 rtl8812a_combo_card_WifiOnlyHwInit(Adapter);
         }
@@ -1633,18 +1591,18 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC31);
 
 	//misc
 	{
-		int i;		
+		int i;
 		u8 mac_addr[6];
-		for(i=0; i<6; i++)
-		{			
+		for (i=0; i<6; i++)
+		{
 #ifdef CONFIG_CONCURRENT_MODE
-			if(Adapter->iface_type == IFACE_PORT1)
+			if (Adapter->iface_type == IFACE_PORT1)
 				mac_addr[i] = rtw_read8(Adapter, REG_MACID1+i);
 			else
 #endif
-			mac_addr[i] = rtw_read8(Adapter, REG_MACID+i);		
+			mac_addr[i] = rtw_read8(Adapter, REG_MACID+i);
 		}
-		
+
 		RTW_INFO("MAC Address from REG_MACID = "MAC_FMT"\n", MAC_ARG(mac_addr));
 	}
 
@@ -1656,14 +1614,14 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END);
 	#ifdef DBG_HAL_INIT_PROFILING
 	hal_init_stages_timestamp[HAL_INIT_STAGES_END]=rtw_get_current_time();
 
-	for(hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM-1;hal_init_profiling_i++) {
+	for (hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM-1;hal_init_profiling_i++) {
 		RTW_INFO("DBG_HAL_INIT_PROFILING: %35s, %u, %5u, %5u\n"
 			, hal_init_stages_str[hal_init_profiling_i]
 			, hal_init_stages_timestamp[hal_init_profiling_i]
 			, (hal_init_stages_timestamp[hal_init_profiling_i+1]-hal_init_stages_timestamp[hal_init_profiling_i])
 			, rtw_get_time_interval_ms(hal_init_stages_timestamp[hal_init_profiling_i], hal_init_stages_timestamp[hal_init_profiling_i+1])
 		);
-	}	
+	}
 	#endif
 
 	return status;
@@ -1671,30 +1629,30 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END);
 
 VOID
 hal_carddisable_8814(
-	IN	PADAPTER			Adapter 
+	IN	PADAPTER			Adapter
 )
 {
 	u8	u1bTmp;
 
 	RTW_INFO("CardDisableRTL8814AU\n");
 
-	// stop rx 
+	// stop rx
 	rtw_write8(Adapter, REG_CR_8814A, 0x0);
 
 	// Card disable power action flow
 	HalPwrSeqCmdParsing(Adapter, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8814A_NIC_DISABLE_FLOW);
 
 	Adapter->bFWReady = _FALSE;
-	
+
 }
 
 static void rtl8814au_hw_power_down(_adapter *padapter)
 {
 	// 2010/-8/09 MH For power down module, we need to enable register block contrl reg at 0x1c.
 	// Then enable power down control bit of register 0x04 BIT4 and BIT15 as 1.
-		
+
 	// Enable register area 0x0-0xc.
-	rtw_write8(padapter,REG_RSV_CTRL, 0x0);			
+	rtw_write8(padapter,REG_RSV_CTRL, 0x0);
 	rtw_write16(padapter, REG_APS_FSMCO, 0x8812);
 }
 
@@ -1705,8 +1663,7 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
    	RTW_INFO("==> %s \n",__FUNCTION__);
 
 #ifdef CONFIG_BT_COEXIST
-	if (hal_btcoex_IsBtExist(Adapter))
-	{
+	if (hal_btcoex_IsBtExist(Adapter)) {
 		RTW_INFO("BT module enable SIC\n");
 		// Only under WIN7 we can support selective suspend and enter D3 state when system call halt adapter.
 
@@ -1720,8 +1677,7 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
 		rtw_write16(Adapter, REG_GPIO_MUXCFG, rtw_read16(Adapter, REG_GPIO_MUXCFG)&(~BIT12));
 	}
 
-	if(pHalData->bSupportUSB3 == _TRUE)
-	{
+	if (pHalData->bSupportUSB3 == _TRUE) {
 		// set Reg 0xf008[3:4] to 2'11 to eable U1/U2 Mode in USB3.0. added by page, 20120712
 		rtw_write8(Adapter, 0xf008, rtw_read8(Adapter, 0xf008)|0x18);
 	}
@@ -1733,33 +1689,32 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
 
  #ifdef SUPPORT_HW_RFOFF_DETECTED
  	RTW_INFO("bkeepfwalive(%x)\n", pwrctl->bkeepfwalive);
- 	if(pwrctl->bkeepfwalive)
- 	{
-		_ps_close_RF(Adapter);		
-		if((pwrctl->bHWPwrPindetect) && (pwrctl->bHWPowerdown))
+ 	if (pwrctl->bkeepfwalive) {
+		_ps_close_RF(Adapter);
+		if ((pwrctl->bHWPwrPindetect) && (pwrctl->bHWPowerdown))
 			rtl8814au_hw_power_down(Adapter);
  	}
 	else
 #endif
-	{	
+	{
 		if (rtw_is_hw_init_completed(Adapter)) {
 			hal_carddisable_8814(Adapter);
 
-			if((pwrctl->bHWPwrPindetect ) && (pwrctl->bHWPowerdown))
+			if ((pwrctl->bHWPwrPindetect ) && (pwrctl->bHWPowerdown))
 				rtl8814au_hw_power_down(Adapter);
 		}
-	}		
+	}
 	return _SUCCESS;
  }
 
 unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
-{	
-	u8 i;	
+{
+	u8 i;
 	struct recv_buf *precvbuf;
 	uint	status;
 	struct dvobj_priv *pdev= adapter_to_dvobj(Adapter);
 	struct intf_hdl * pintfhdl=&Adapter->iopriv.intf;
-	struct recv_priv *precvpriv = &(Adapter->recvpriv);	
+	struct recv_priv *precvpriv = &(Adapter->recvpriv);
 	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
@@ -1770,22 +1725,20 @@ unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
 
 	status = _SUCCESS;
 
-	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("===> usb_inirp_init \n"));	
-		
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("===> usb_inirp_init \n"));
+
 	precvpriv->ff_hwaddr = RECV_BULK_IN_ADDR;
 
-	//issue Rx irp to receive data	
-	precvbuf = (struct recv_buf *)precvpriv->precv_buf;	
-	for(i=0; i<NR_RECVBUFF; i++)
-	{
-		if(_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == _FALSE )
-		{
+	//issue Rx irp to receive data
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	for (i=0; i<NR_RECVBUFF; i++) {
+		if (_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == _FALSE ) {
 			RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_port error \n"));
 			status = _FAIL;
 			goto exit;
 		}
-		
-		precvbuf++;		
+
+		precvbuf++;
 		precvpriv->free_recv_buf_queue_cnt--;
 	}
 
@@ -1794,17 +1747,16 @@ unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
 		status = _FAIL;
 		RTW_INFO("%s =>Warning !! Have not USB Int-IN pipe, RtIntInPipe(%d)!!!\n", __func__, pdev->RtInPipe[REALTEK_USB_IN_INT_EP_IDX]);
 		goto exit;
-	}	
+	}
 	_read_interrupt = pintfhdl->io_ops._read_interrupt;
-	if(_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == _FALSE )
-	{
+	if (_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == _FALSE ) {
 		RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_interrupt error \n"));
 		status = _FAIL;
 	}
 #endif
 
 exit:
-	
+
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("<=== usb_inirp_init \n"));
 
 	return status;
@@ -1812,9 +1764,9 @@ exit:
 }
 
 unsigned int rtl8814au_inirp_deinit(PADAPTER Adapter)
-{	
+{
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n ===> usb_rx_deinit \n"));
-	
+
 	rtw_read_port_cancel(Adapter);
 
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n <=== usb_rx_deinit \n"));
@@ -1836,25 +1788,22 @@ hal_ReadIDs_8814AU(
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
-	if( !AutoloadFail )
-	{
+	if ( !AutoloadFail ) {
 		pHalData->EEPROMVID = EF2Byte( *(pu2Byte)&PROMContent[EEPROM_VID_8814AU] );
-		pHalData->EEPROMPID = EF2Byte( *(pu2Byte)&PROMContent[EEPROM_PID_8814AU] );		
-		
-		// Customer ID, 0x00 and 0xff are reserved for Realtek. 		
+		pHalData->EEPROMPID = EF2Byte( *(pu2Byte)&PROMContent[EEPROM_PID_8814AU] );
+
+		// Customer ID, 0x00 and 0xff are reserved for Realtek.
 		pHalData->EEPROMCustomerID = *(pu1Byte)&PROMContent[EEPROM_CustomID_8814];
 		pHalData->EEPROMSubCustomerID = EEPROM_Default_SubCustomerID;
-	}
-	else
-	{
+	} else {
 		pHalData->EEPROMVID 			= EEPROM_Default_VID;
 		pHalData->EEPROMPID 			= EEPROM_Default_PID;
 
-		// Customer ID, 0x00 and 0xff are reserved for Realtek. 		
+		// Customer ID, 0x00 and 0xff are reserved for Realtek.
 		pHalData->EEPROMCustomerID		= EEPROM_Default_CustomerID;
 		pHalData->EEPROMSubCustomerID	= EEPROM_Default_SubCustomerID;
 	}
-	
+
 	RTW_INFO("VID = 0x%04X, PID = 0x%04X\n", pHalData->EEPROMVID, pHalData->EEPROMPID);
 	RTW_INFO("Customer ID: 0x%02X, SubCustomer ID: 0x%02X\n", pHalData->EEPROMCustomerID, pHalData->EEPROMSubCustomerID);
 }
@@ -1869,18 +1818,15 @@ hal_InitPGData_8814A(
 	u32			i;
 	u16			value16;
 
-	if(_FALSE == pHalData->bautoload_fail_flag)
-	{ // autoload OK.
+	if (_FALSE == pHalData->bautoload_fail_flag) { // autoload OK.
 		// hal_ReadeFuse_8814A is FW offload read efuse, todo
 	//#if ((DEV_BUS_TYPE==RT_USB_INTERFACE || DEV_BUS_TYPE==RT_SDIO_INTERFACE))  && (MP_DRIVER != 1)
 		//if(hal_ReadeFuse_8814A(pAdapter) == _FAIL)
 	//#endif
-		
+
 		// Read EFUSE real map to shadow.
 		EFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI, _FALSE);
-	}
-	else
-	{//autoload fail
+	} else { //autoload fail
 		RTW_INFO("AutoLoad Fail reported from CR9346!!\n");
 		//update to default value 0xFF
 		EFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI, _FALSE);
@@ -1899,11 +1845,11 @@ hal_CustomizedBehavior_8814AU(
 	IN	PADAPTER	Adapter
 	)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct led_priv	*pledpriv = &(Adapter->ledpriv);
-	
+
 	// Led mode
-	switch(pHalData->CustomerID)
+	switch (pHalData->CustomerID)
 	{
 		case RT_CID_DEFAULT:
 			pledpriv->LedStrategy = SW_LED_MODE9;
@@ -1922,48 +1868,48 @@ hal_CustomizeByCustomerID_8814AU(
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	
+
 	RTW_INFO("PID= 0x%x, VID=  %x\n",pHalData->EEPROMPID,pHalData->EEPROMVID);
-	
+
 	//	Decide CustomerID according to VID/DID or EEPROM
-	switch(pHalData->EEPROMCustomerID)
+	switch (pHalData->EEPROMCustomerID)
 	{
 		case EEPROM_CID_DEFAULT:
-			if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3308))
+			if ((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3308))
 				pHalData->CustomerID = RT_CID_DLINK;
-			else if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3309))
+			else if ((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3309))
 				pHalData->CustomerID = RT_CID_DLINK;
-			else if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x330a))
+			else if ((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x330a))
 				pHalData->CustomerID = RT_CID_DLINK;
-			else if((pHalData->EEPROMVID == 0x0BFF) && (pHalData->EEPROMPID == 0x8160))
+			else if ((pHalData->EEPROMVID == 0x0BFF) && (pHalData->EEPROMPID == 0x8160))
 			{
 				pHalData->CustomerID = RT_CID_CHINA_MOBILE;
-			}	
-			else if((pHalData->EEPROMVID == 0x0BDA) &&	(pHalData->EEPROMPID == 0x5088))
+			}
+			else if ((pHalData->EEPROMVID == 0x0BDA) &&	(pHalData->EEPROMPID == 0x5088))
 				pHalData->CustomerID = RT_CID_CC_C;
-			
+
 			break;
 		case EEPROM_CID_WHQL:
 			//padapter->bInHctTest = _TRUE;
-	
+
 			//pMgntInfo->bSupportTurboMode = _FALSE;
 			//pMgntInfo->bAutoTurboBy8186 = _FALSE;
-	
+
 			//pMgntInfo->PowerSaveControl.bInactivePs = _FALSE;
 			//pMgntInfo->PowerSaveControl.bIPSModeBackup = _FALSE;
 			//pMgntInfo->PowerSaveControl.bLeisurePs = _FALSE;
 			//pMgntInfo->PowerSaveControl.bLeisurePsModeBackup = _FALSE;
 			//pMgntInfo->keepAliveLevel = 0;
-	
+
 			//padapter->bUnloadDriverwhenS3S4 = _FALSE;
-			break;			
+			break;
 		default:
 			pHalData->CustomerID = RT_CID_DEFAULT;
 			break;
-			
+
 	}
 	RTW_INFO("Customer ID: 0x%2x\n", pHalData->CustomerID);
-	
+
 	hal_CustomizedBehavior_8814AU(pAdapter);
 }
 
@@ -1975,7 +1921,7 @@ hal_ReadUsbModeSwitch_8814AU(
 	)
 {
   	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
-	
+
 	if (AutoloadFail)
 		pHalData->EEPROMUsbSwitch = _FALSE;
 	else
@@ -1985,7 +1931,7 @@ hal_ReadUsbModeSwitch_8814AU(
 
 static VOID
 ReadLEDSetting_8814AU(
-	IN	PADAPTER	Adapter,	
+	IN	PADAPTER	Adapter,
 	IN	u8*		PROMContent,
 	IN	BOOLEAN		AutoloadFail
 	)
@@ -2015,19 +1961,19 @@ InitAdapterVariablesByPROM_8814AU(
 	hal_ReadTxPowerInfo8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadBoardType8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_Read_TRX_antenna_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
-	
+
 	//
 	// Read Bluetooth co-exist and initialize
 	//
 	hal_EfuseParseBTCoexistInfo8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
-	
+
 	hal_ReadChannelPlan8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_EfuseParseXtal_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);	
 	hal_ReadThermalMeter_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadRemoteWakeup_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadAntennaDiversity8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadRFEType_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
-	
+
 	ReadLEDSetting_8814AU(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 
 	hal_ReadUsbModeSwitch_8814AU(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
@@ -2041,7 +1987,7 @@ InitAdapterVariablesByPROM_8814AU(
 static void hal_ReadPROMContent_8814A(
 	IN PADAPTER 		Adapter
 	)
-{	
+{
 	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(Adapter);
 	u8			eeValue;
 
@@ -2064,7 +2010,7 @@ ReadAdapterInfo8814AU(
 	)
 {
 	Hal_InitEfuseVars_8814A(Adapter);
-	
+
 	// Read all content in Efuse/EEPROM.
 	hal_ReadPROMContent_8814A(Adapter);
 
@@ -2079,21 +2025,21 @@ void UpdateInterruptMask8814AU(PADAPTER padapter,u8 bHIMR0 ,u32 AddMSR, u32 Remo
 	u32 *himr;
 	pHalData = GET_HAL_DATA(padapter);
 
-	if(bHIMR0)
+	if (bHIMR0)
 		himr = &(pHalData->IntrMask[0]);
 	else
 		himr = &(pHalData->IntrMask[1]);
-	
+
 	if (AddMSR)
 		*himr |= AddMSR;
 
 	if (RemoveMSR)
 		*himr &= (~RemoveMSR);
 
-	if(bHIMR0)	
+	if (bHIMR0)
 		rtw_write32(padapter, REG_HIMR0_8814A, *himr);
 	else
-		rtw_write32(padapter, REG_HIMR1_8814A, *himr);	
+		rtw_write32(padapter, REG_HIMR1_8814A, *himr);
 
 }
 
@@ -2103,7 +2049,7 @@ void SetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(Adapter);
 	struct registry_priv *registry_par = &Adapter->registrypriv;
 
-	switch(variable)
+	switch (variable)
 	{
 		case HW_VAR_RXDMA_AGG_PG_TH:
 #ifdef CONFIG_USB_RX_AGGREGATION
@@ -2185,9 +2131,9 @@ void SetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 
 void GetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
-	switch(variable)
+	switch (variable)
 	{
 		default:
 			GetHwReg8814A(Adapter,variable,val);
@@ -2210,7 +2156,7 @@ SetHalDefVar8814AUsb(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u8			bResult = _SUCCESS;
 
-	switch(eVariable)
+	switch (eVariable)
 	{
 		default:
 			SetHalDefVar8814A(Adapter,eVariable,pValue);
@@ -2221,7 +2167,7 @@ SetHalDefVar8814AUsb(
 }
 
 //
-//	Description: 
+//	Description:
 //		Query setting of specified variable.
 //
 u8
@@ -2234,7 +2180,7 @@ GetHalDefVar8814AUsb(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u8			bResult = _SUCCESS;
 
-	switch(eVariable)
+	switch (eVariable)
 	{
 		default:
 			GetHalDefVar8814A(Adapter,eVariable,pValue);
@@ -2302,9 +2248,9 @@ static void rtl8814au_init_default_value(_adapter * padapter)
 }
 
 static u8 rtl8814au_ps_func(PADAPTER Adapter,HAL_INTF_PS_FUNC efunc_id, u8 *val)
-{	
+{
 	u8 bResult = _TRUE;
-	switch(efunc_id){
+	switch (efunc_id) {
 
 		#if defined(CONFIG_AUTOSUSPEND) && defined(SUPPORT_HW_RFOFF_DETECTED)
 		case HAL_USB_SELECT_SUSPEND:
@@ -2327,7 +2273,7 @@ void rtl8814au_set_hal_ops(_adapter * padapter)
 
 	pHalFunc->hal_power_on = _InitPowerOn_8814AU;
 	pHalFunc->hal_power_off = hal_carddisable_8814;
-	
+
 	pHalFunc->hal_init = &rtl8814au_hal_init;
 	pHalFunc->hal_deinit = &rtl8814au_hal_deinit;
 
@@ -2345,12 +2291,12 @@ void rtl8814au_set_hal_ops(_adapter * padapter)
 #else //case of hw led or no led
 	pHalFunc->InitSwLeds = NULL;
 	pHalFunc->DeInitSwLeds = NULL;
-#endif//CONFIG_SW_LED
-	
+#endif //CONFIG_SW_LED
+
 	pHalFunc->init_default_value = &rtl8814au_init_default_value;
 	pHalFunc->intf_chip_configure = &rtl8814au_interface_configure;
 	pHalFunc->read_adapter_info = &ReadAdapterInfo8814AU;
- 
+
 	pHalFunc->SetHwRegHandler = &SetHwReg8814AU;
 	pHalFunc->GetHwRegHandler = &GetHwReg8814AU;
   	pHalFunc->GetHalDefVarHandler = &GetHalDefVar8814AUsb;
diff --git a/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_ops_linux.c b/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_ops_linux.c
index 59281f9..d2fea87 100644
--- a/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_ops_linux.c
+++ b/drivers/net/wireless/rtl8812au/hal/rtl8814a/usb/usb_ops_linux.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -24,17 +24,16 @@
 
 #ifdef CONFIG_SUPPORT_USB_INT
 void interrupt_handler_8814au(_adapter *padapter,u16 pkt_len,u8 *pbuf)
-{	
+{
 	HAL_DATA_TYPE	*pHalData=GET_HAL_DATA(padapter);
 	struct reportpwrstate_parm pwr_rpt;
-	
-	if ( pkt_len != INTERRUPT_MSG_FORMAT_LEN )
-	{
+
+	if ( pkt_len != INTERRUPT_MSG_FORMAT_LEN ) {
 		RTW_INFO("%s Invalid interrupt content length (%d)!\n", __FUNCTION__, pkt_len);
 		return ;
 	}
 
-	// HISR 
+	// HISR
 	_rtw_memcpy(&(pHalData->IntArray[0]), &(pbuf[USB_INTR_CONTENT_HISR_OFFSET]), 4);
 	_rtw_memcpy(&(pHalData->IntArray[1]), &(pbuf[USB_INTR_CONTENT_HISRE_OFFSET]), 4);
 
@@ -42,25 +41,24 @@ void interrupt_handler_8814au(_adapter *padapter,u16 pkt_len,u8 *pbuf)
 	{
 		u32 hisr=0 ,hisr_ex=0;
 		_rtw_memcpy(&hisr,&(pHalData->IntArray[0]),4);
-		hisr = le32_to_cpu(hisr);	
-		
+		hisr = le32_to_cpu(hisr);
+
 		_rtw_memcpy(&hisr_ex,&(pHalData->IntArray[1]),4);
 		hisr_ex = le32_to_cpu(hisr_ex);
-		
-		if((hisr != 0) || (hisr_ex!=0))
+
+		if ((hisr != 0) || (hisr_ex!=0))
 			RTW_INFO("===> %s hisr:0x%08x ,hisr_ex:0x%08x \n",__FUNCTION__,hisr,hisr_ex);
 	}
 	#endif
 
 
 #ifdef CONFIG_LPS_LCLK
-	if(  pHalData->IntArray[0]  & IMR_CPWM_88E )
-	{
+	if (  pHalData->IntArray[0]  & IMR_CPWM_88E ) {
 		_rtw_memcpy(&pwr_rpt.state, &(pbuf[USB_INTR_CONTENT_CPWM1_OFFSET]), 1);
 		//_rtw_memcpy(&pwr_rpt.state2, &(pbuf[USB_INTR_CONTENT_CPWM2_OFFSET]), 1);
 
-		//88e's cpwm value only change BIT0, so driver need to add PS_STATE_S2 for LPS flow.		
-		pwr_rpt.state |= PS_STATE_S2;		
+		//88e's cpwm value only change BIT0, so driver need to add PS_STATE_S2 for LPS flow.
+		pwr_rpt.state |= PS_STATE_S2;
 		_set_workitem(&(adapter_to_pwrctl(padapter)->cpwm_event));
 	}
 #endif//CONFIG_LPS_LCLK
@@ -72,40 +70,38 @@ void interrupt_handler_8814au(_adapter *padapter,u16 pkt_len,u8 *pbuf)
 	#endif
 	#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
 	if (pHalData->IntArray[0] & (IMR_TBDER_88E|IMR_TBDOK_88E))
-	#endif	
-	{		
+	#endif
+	{
 		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 		#if 0
-		if(pHalData->IntArray[0] & IMR_BCNDMAINT0_88E)
+		if (pHalData->IntArray[0] & IMR_BCNDMAINT0_88E)
 			RTW_INFO("%s: HISR_BCNERLY_INT\n", __func__);
-		if(pHalData->IntArray[0] & IMR_TBDOK_88E)
+		if (pHalData->IntArray[0] & IMR_TBDOK_88E)
 			RTW_INFO("%s: HISR_TXBCNOK\n", __func__);
-		if(pHalData->IntArray[0] & IMR_TBDER_88E)
+		if (pHalData->IntArray[0] & IMR_TBDER_88E)
 			RTW_INFO("%s: HISR_TXBCNERR\n", __func__);
 		#endif
-		
 
-		if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
-		{
+
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 			//send_beacon(padapter);
-			if(pmlmepriv->update_bcn == _TRUE)
+			if (pmlmepriv->update_bcn == _TRUE)
 			{
 				//tx_beacon_hdl(padapter, NULL);
 				set_tx_beacon_cmd(padapter);
 			}
 		}
 #ifdef CONFIG_CONCURRENT_MODE
-		if(check_buddy_fwstate(padapter, WIFI_AP_STATE))
-		{
+		if (check_buddy_fwstate(padapter, WIFI_AP_STATE)) {
 			//send_beacon(padapter);
-			if(padapter->pbuddy_adapter->mlmepriv.update_bcn == _TRUE)
+			if (padapter->pbuddy_adapter->mlmepriv.update_bcn == _TRUE)
 			{
 				//tx_beacon_hdl(padapter, NULL);
 				set_tx_beacon_cmd(padapter->pbuddy_adapter);
 			}
 		}
 #endif
-		
+
 	}
 #endif //CONFIG_INTERRUPT_BASED_TXBCN
 
@@ -361,8 +357,9 @@ int recvbuf2recvframe(PADAPTER padapter, void *ptr)
 		}
 
 #ifdef CONFIG_RX_PACKET_APPEND_FCS
-		if(pattrib->pkt_rpt_type == NORMAL_RX)
-			pattrib->pkt_len -= IEEE80211_FCS_LEN;
+                if (check_fwstate(&padapter->mlmepriv, WIFI_MONITOR_STATE) == _FALSE)
+                        if ((pattrib->pkt_rpt_type == NORMAL_RX) && (pHalData->ReceiveConfig & RCR_APPFCS))
+                                pattrib->pkt_len -= IEEE80211_FCS_LEN;
 #endif
 		if(rtw_os_alloc_recvframe(padapter, precvframe, 
 			(pbuf + pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE), pskb) == _FAIL)
diff --git a/drivers/net/wireless/rtl8812au/include/autoconf.h b/drivers/net/wireless/rtl8812au/include/autoconf.h
index 2e1c614..3c1713f 100644
--- a/drivers/net/wireless/rtl8812au/include/autoconf.h
+++ b/drivers/net/wireless/rtl8812au/include/autoconf.h
@@ -309,7 +309,6 @@
 #endif /* !CONFIG_BT_COEXIST */
 
 
-
 #ifdef CONFIG_USB_TX_AGGREGATION
 /* #define	CONFIG_TX_EARLY_MODE */
 #endif
@@ -347,12 +346,11 @@
 /* #define DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED "jeff-ap" */
 
 
-
 /* #define DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE */
 /* #define DBG_ROAMING_TEST */
 
 /* #define DBG_HAL_INIT_PROFILING */
 
-/*#define DBG_MEMORY_LEAK*/
+/* #define DBG_MEMORY_LEAK*/
 #define	DBG_RX_DFRAME_RAW_DATA
-/*#define CONFIG_USE_EXTERNAL_POWER  */        /* NOT USB2.0 power, so no 500mA power constraint, no limitation in Power by Rate*/
+/* #define CONFIG_USE_EXTERNAL_POWER */        /* NOT USB2.0 power, so no 500mA power constraint, no limitation in Power by Rate */
diff --git a/drivers/net/wireless/rtl8812au/include/rtw_wifi_regd.h b/drivers/net/wireless/rtl8812au/include/rtw_wifi_regd.h
index 69bd71d..7acbb95 100644
--- a/drivers/net/wireless/rtl8812au/include/rtw_wifi_regd.h
+++ b/drivers/net/wireless/rtl8812au/include/rtw_wifi_regd.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 #ifndef __RTW_WIFI_REGD_H__
-#define __RTW_WIFI_REGD_H__
+#define __RTW_WIFI_REGD_H__ 
 
 int rtw_regd_init(_adapter *padapter);
 void rtw_reg_notify_by_driver(_adapter *adapter);
diff --git a/drivers/net/wireless/rtl8812au/include/rtw_xmit.h b/drivers/net/wireless/rtl8812au/include/rtw_xmit.h
index d372338..6b5ea43 100644
--- a/drivers/net/wireless/rtl8812au/include/rtw_xmit.h
+++ b/drivers/net/wireless/rtl8812au/include/rtw_xmit.h
@@ -421,7 +421,7 @@ struct pkt_attrib {
 	u8	rate;
 	u8	intel_proxim;
 	u8	retry_ctrl;
-	u8	sw_seq;
+	//u8	sw_seq; // Add support for pre-configured SeqNum via RadioTap
 	u8   mbssid;
 	u8	ldpc;
 	u8	stbc;
diff --git a/drivers/net/wireless/rtl8812au/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/rtl8812au/os_dep/linux/ioctl_cfg80211.c
index 8a7e088..17937e7 100644
--- a/drivers/net/wireless/rtl8812au/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/rtl8812au/os_dep/linux/ioctl_cfg80211.c
@@ -1750,6 +1750,7 @@ static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 
 		sinfo->filled |= STATION_INFO_BSS_PARAM;
 
+#if defined (LINUX_VERSION_CODE) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 20, 0))
 		if (!psta->no_short_preamble_set)
 		  sinfo->bss_param.flags |= STATION_INFO_BSS_PARAM_SHORT_PREAMBLE;
 
@@ -1765,6 +1766,7 @@ static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 		sinfo->bss_param.dtim_period = pwrctl->dtim;
 		
 		sinfo->bss_param.beacon_interval = get_beacon_interval(&cur_network->network);
+#endif
 
 	}
 
diff --git a/drivers/net/wireless/rtl8812au/os_dep/linux/recv_linux.c b/drivers/net/wireless/rtl8812au/os_dep/linux/recv_linux.c
index 52fbba5..a802a9d 100644
--- a/drivers/net/wireless/rtl8812au/os_dep/linux/recv_linux.c
+++ b/drivers/net/wireless/rtl8812au/os_dep/linux/recv_linux.c
@@ -445,10 +445,11 @@ void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attri
 #endif /* CONFIG_TCP_CSUM_OFFLOAD_RX */
 
 		ret = rtw_netif_rx(padapter->pnetdev, pkt);
-		if (ret == NET_RX_SUCCESS)
+		if (ret == NET_RX_SUCCESS) {
 			DBG_COUNTER(padapter->rx_logs.os_netif_ok);
-		else
+		} else {
 			DBG_COUNTER(padapter->rx_logs.os_netif_err);
+		}
 	}
 }
 
diff --git a/drivers/net/wireless/rtl8812au/os_dep/linux/usb_intf.c b/drivers/net/wireless/rtl8812au/os_dep/linux/usb_intf.c
index 6ed4e72..47b3435 100644
--- a/drivers/net/wireless/rtl8812au/os_dep/linux/usb_intf.c
+++ b/drivers/net/wireless/rtl8812au/os_dep/linux/usb_intf.c
@@ -222,6 +222,7 @@ static struct usb_device_id rtw_usb_id_tbl[] = {
 	{USB_DEVICE(0x2001, 0x331A), .driver_info = RTL8814A}, /* D-Link - D-Link */
 	{USB_DEVICE(0x0B05, 0x1817), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
 	{USB_DEVICE(0x0B05, 0x1852), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
+	{USB_DEVICE(0x0B05, 0x1853), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
 	{USB_DEVICE(0x056E, 0x400B), .driver_info = RTL8814A}, /* ELECOM - ELECOM */
 	{USB_DEVICE(0x056E, 0x400D), .driver_info = RTL8814A}, /* ELECOM - ELECOM */
 	{USB_DEVICE(0x7392, 0xA834), .driver_info = RTL8814A}, /* Edimax - Edimax */
diff --git a/drivers/net/wireless/rtl8812au/os_dep/linux/wifi_regd.c b/drivers/net/wireless/rtl8812au/os_dep/linux/wifi_regd.c
index fa8ba7b..b0a4abd 100644
--- a/drivers/net/wireless/rtl8812au/os_dep/linux/wifi_regd.c
+++ b/drivers/net/wireless/rtl8812au/os_dep/linux/wifi_regd.c
@@ -15,8 +15,8 @@ void rtw_reg_notify_by_driver(_adapter *adapter)
 	return;
 }
 
-int rtw_regd_init(_adapter *padapter)
+int rtw_regd_init(_adapter * padapter)
 {
 	return 0;
 }
-#endif /* CONFIG_IOCTL_CFG80211 */
+#endif //CONFIG_IOCTL_CFG80211
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_mlme_ext.c b/drivers/net/wireless/rtl8814au/core/rtw_mlme_ext.c
index cc65410..050bfa3 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_mlme_ext.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_mlme_ext.c
@@ -1420,10 +1420,11 @@ void mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame)
 #ifdef CONFIG_AP_MODE
 	switch (GetFrameSubType(pframe)) {
 	case WIFI_AUTH:
-		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE) {
 			ptable->func = &OnAuth;
-		else
+		} else
 			ptable->func = &OnAuthClient;
+	/* Intentional fallthrough */
 	/* pass through */
 	case WIFI_ASSOCREQ:
 	case WIFI_REASSOCREQ:
@@ -2201,14 +2202,15 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 			if (rtw_is_list_empty(&pstat->asoc_list) == _FALSE) {
 				rtw_list_delete(&pstat->asoc_list);
 				pstapriv->asoc_list_cnt--;
-				if (pstat->expire_to > 0)
+				if (pstat->expire_to > 0) {
 					;/* TODO: STA re_auth within expire_to */
+				}
 			}
 			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
-			if (seq == 1)
+			if (seq == 1) {
 				; /* TODO: STA re_auth and auth timeout */
-
+			}
 		}
 	}
 
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_pwrctrl.c b/drivers/net/wireless/rtl8814au/core/rtw_pwrctrl.c
index d8b45f4..0a596db 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_pwrctrl.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_pwrctrl.c
@@ -219,6 +219,7 @@ bool rtw_pwr_unassociated_idle(_adapter *adapter)
 			    || check_fwstate(pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS)
 			    || check_fwstate(pmlmepriv, WIFI_AP_STATE)
 			    || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE)
+			    || check_fwstate(pmlmepriv, WIFI_MONITOR_STATE)
 #if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
 			    || pcfg80211_wdinfo->is_ro_ch
 #elif defined(CONFIG_P2P)
@@ -618,6 +619,7 @@ u8 PS_RDY_CHECK(_adapter *padapter)
 	    || check_fwstate(pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS)
 	    || check_fwstate(pmlmepriv, WIFI_AP_STATE)
 	    || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE)
+	    || check_fwstate(pmlmepriv, WIFI_MONITOR_STATE)
 #if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
 	    || pcfg80211_wdinfo->is_ro_ch
 #endif
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_recv.c b/drivers/net/wireless/rtl8814au/core/rtw_recv.c
index 83ed24e..8bb59ee 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_recv.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_recv.c
@@ -2125,7 +2125,7 @@ sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 			if ((bDumpRxPkt == 4) && (eth_type == 0x888e))
 				dump_rx_packet(ptr);
 #endif
-		} else
+		} else {
 			DBG_COUNTER(adapter->rx_logs.core_rx_pre_data_handled);
 		break;
 	default:
@@ -2136,6 +2136,7 @@ sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 		retval = _FAIL;
 		break;
 	}
+}
 
 exit:
 
@@ -3607,8 +3608,15 @@ static sint fill_radiotap_hdr(_adapter *padapter, union recv_frame *precvframe)
 	if (pattrib->mfrag)
 		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FRAG;
 
-	/* always append FCS */
-	/* hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FCS; */
+#ifdef CONFIG_RX_PACKET_APPEND_FCS
+        // Start by always indicating FCS is there:
+        hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FCS;
+
+        // Next, test for prior conditions that will remove FCS, and update flag accordingly:
+        if(check_fwstate(&padapter->mlmepriv,WIFI_MONITOR_STATE) == _FALSE)
+                if((pattrib->pkt_rpt_type == NORMAL_RX) && (pHalData->ReceiveConfig & RCR_APPFCS))
+                        hdr_buf[rt_len] &= ~IEEE80211_RADIOTAP_F_FCS;
+#endif
 
 	if (0)
 		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_DATAPAD;
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_wlan_util.c b/drivers/net/wireless/rtl8814au/core/rtw_wlan_util.c
index 54c9a35..6de4e2e 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_wlan_util.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_wlan_util.c
@@ -2353,8 +2353,7 @@ int rtw_get_bcn_keys(ADAPTER *Adapter, u8 *pframe, u32 packet_len,
 
 		_rtw_memcpy(recv_beacon->ssid, elems.ssid, elems.ssid_len);
 		recv_beacon->ssid_len = elems.ssid_len;
-	} else
-		; /* means hidden ssid */
+	} else { ; } /* means hidden ssid */
 
 	/* checking RSN first */
 	if (elems.rsn_ie && elems.rsn_ie_len) {
diff --git a/drivers/net/wireless/rtl8814au/core/rtw_xmit.c b/drivers/net/wireless/rtl8814au/core/rtw_xmit.c
index 1620473..c1019bb 100644
--- a/drivers/net/wireless/rtl8814au/core/rtw_xmit.c
+++ b/drivers/net/wireless/rtl8814au/core/rtw_xmit.c
@@ -1254,10 +1254,11 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
 		_rtw_memcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);
 		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_ap);
-	} else
+	} else {
 		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_unknown);
 
 	bmcast = IS_MCAST(pattrib->ra);
+	}
 	if (bmcast) {
 		psta = rtw_get_bcmc_stainfo(padapter);
 		if (psta == NULL) { /* if we cannot get psta => drop the pkt */
@@ -3874,7 +3875,7 @@ s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
 	u32 len = skb->len;
 	u8 category, action;
 	int type = -1;
-	
+
 	//RTW_INFO(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	if (skb)
@@ -3922,17 +3923,17 @@ s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
 					fixed_rate = 0;
 				fixed_rate += MGN_MCS0;
 			}
-			if ((mcs_have & 4) && 
+			if ((mcs_have & 4) &&
 			    (iterator.this_arg[1] & 4))
 				sgi = 1;
-			if ((mcs_have & 1) && 
+			if ((mcs_have & 1) &&
 			    (iterator.this_arg[1] & 1))
 				bwidth = 1;
-			if ((mcs_have & 0x10) && 
+			if ((mcs_have & 0x10) &&
 			    (iterator.this_arg[1] & 0x10))
 				ldpc = 1;
 			if ((mcs_have & 0x20))
-				stbc = (iterator.this_arg[1] >> 5) & 3;	
+				stbc = (iterator.this_arg[1] >> 5) & 3;
 		}
 		break;
 
@@ -3994,9 +3995,9 @@ s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
 	pattrib->ldpc = ldpc;
 	pattrib->stbc = stbc;
 	pattrib->retry_ctrl = (txflags & 0x08)?_FALSE:_TRUE;
-	pattrib->sw_seq = (txflags & 0x10)?_TRUE:_FALSE;
+	// pattrib->sw_seq = (txflags & 0x10)?_TRUE:_FALSE;  // Adds support for pre-configured SeqNum via RadioTap
+
 
-	
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 
 	pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
diff --git a/drivers/net/wireless/rtl8814au/hal/btc/HalBtcOutSrc.h b/drivers/net/wireless/rtl8814au/hal/btc/HalBtcOutSrc.h
index 9a8c8fb..545223b 100644
--- a/drivers/net/wireless/rtl8814au/hal/btc/HalBtcOutSrc.h
+++ b/drivers/net/wireless/rtl8814au/hal/btc/HalBtcOutSrc.h
@@ -146,7 +146,7 @@ typedef enum _BTC_WIFI_ROLE{
 typedef enum _BTC_WIRELESS_FREQ{
 	BTC_FREQ_2_4G					= 0x0,
 	BTC_FREQ_5G						= 0x1,
-	BTC_FREQ_MAX	
+	BTC_FREQ_MAX
 }BTC_WIRELESS_FREQ,*PBTC_WIRELESS_FREQ;
 
 typedef enum _BTC_WIFI_BW_MODE{
@@ -155,13 +155,13 @@ typedef enum _BTC_WIFI_BW_MODE{
 	BTC_WIFI_BW_HT40					= 0x2,
 	BTC_WIFI_BW_HT80					= 0x3,
 	BTC_WIFI_BW_HT160					= 0x4,
-	BTC_WIFI_BW_MAX	
+	BTC_WIFI_BW_MAX
 }BTC_WIFI_BW_MODE,*PBTC_WIFI_BW_MODE;
 
 typedef enum _BTC_WIFI_TRAFFIC_DIR{
 	BTC_WIFI_TRAFFIC_TX					= 0x0,
 	BTC_WIFI_TRAFFIC_RX					= 0x1,
-	BTC_WIFI_TRAFFIC_MAX	
+	BTC_WIFI_TRAFFIC_MAX
 }BTC_WIFI_TRAFFIC_DIR,*PBTC_WIFI_TRAFFIC_DIR;
 
 typedef enum _BTC_WIFI_PNP{
@@ -179,14 +179,14 @@ typedef enum _BTC_IOT_PEER
 	BTC_IOT_PEER_RALINK = 4,
 	BTC_IOT_PEER_ATHEROS = 5,
 	BTC_IOT_PEER_CISCO = 6,
-	BTC_IOT_PEER_MERU = 7,	
+	BTC_IOT_PEER_MERU = 7,
 	BTC_IOT_PEER_MARVELL = 8,
 	BTC_IOT_PEER_REALTEK_SOFTAP = 9,// peer is RealTek SOFT_AP, by Bohn, 2009.12.17
 	BTC_IOT_PEER_SELF_SOFTAP = 10, // Self is SoftAP
 	BTC_IOT_PEER_AIRGO = 11,
-	BTC_IOT_PEER_INTEL 				= 12, 
-	BTC_IOT_PEER_RTK_APCLIENT 		= 13, 
-	BTC_IOT_PEER_REALTEK_81XX 		= 14,	
+	BTC_IOT_PEER_INTEL 				= 12,
+	BTC_IOT_PEER_RTK_APCLIENT 		= 13,
+	BTC_IOT_PEER_REALTEK_81XX 		= 14,
 	BTC_IOT_PEER_REALTEK_WOW 		= 15,
 	BTC_IOT_PEER_REALTEK_JAGUAR_BCUTAP = 16,
 	BTC_IOT_PEER_REALTEK_JAGUAR_CCUTAP = 17,
@@ -215,7 +215,7 @@ typedef enum _BTC_ANT_TYPE{
 
 typedef enum _BTC_VENDOR{
 	BTC_VENDOR_LENOVO,
-	BTC_VENDOR_ASUS,	
+	BTC_VENDOR_ASUS,
 	BTC_VENDOR_OTHER
 }BTC_VENDOR,*PBTC_VENDOR;
 
@@ -242,7 +242,7 @@ typedef enum _BTC_GET_TYPE{
 	// type s4Byte
 	BTC_GET_S4_WIFI_RSSI,
 	BTC_GET_S4_HS_RSSI,
-	
+
 	// type u4Byte
 	BTC_GET_U4_WIFI_BW,
 	BTC_GET_U4_WIFI_TRAFFIC_DIRECTION,
@@ -543,21 +543,21 @@ typedef VOID
 	IN	u4Byte			BitMask,
 	IN	u4Byte			Data
 	);
-typedef u4Byte 
+typedef u4Byte
 (*BFP_BTC_GET_BB_REG)(
 	IN 	PVOID			pBtcContext,
 	IN	u4Byte			RegAddr,
 	IN	u4Byte			BitMask
 	);
 typedef VOID
-(*BFP_BTC_SET_RF_REG)(	
+(*BFP_BTC_SET_RF_REG)(
 	IN 	PVOID			pBtcContext,
 	IN	u1Byte			eRFPath,
 	IN	u4Byte			RegAddr,
 	IN	u4Byte			BitMask,
 	IN	u4Byte			Data
 	);
-typedef u4Byte 
+typedef u4Byte
 (*BFP_BTC_GET_RF_REG)(
 	IN 	PVOID			pBtcContext,
 	IN	u1Byte			eRFPath,
@@ -598,7 +598,7 @@ typedef BOOLEAN
 	IN	u1Byte			txTime,
 	IN	u1Byte			btChnl
 	);
-typedef u2Byte 
+typedef u2Byte
 (*BFP_BTC_GET_BT_REG)(
 	IN 	PVOID			pBtcContext,
 	IN	u1Byte			regType,
@@ -620,17 +620,17 @@ typedef COL_H2C_STATUS
 	IN	u1Byte			h2c_par_len
 	);
 
-typedef u4Byte 
+typedef u4Byte
 (*BFP_BTC_GET_BT_COEX_SUPPORTED_FEATURE)(
 	IN 	PVOID			pBtcContext
 	);
 
-typedef u4Byte 
+typedef u4Byte
 (*BFP_BTC_GET_BT_COEX_SUPPORTED_VERSION)(
 	IN 	PVOID			pBtcContext
 	);
 
-typedef u4Byte 
+typedef u4Byte
 (*BFP_BTC_GET_PHYDM_VERSION)(
 	IN 	PVOID			pBtcContext
 	);
@@ -775,7 +775,7 @@ extern struct btc_coexist	GLBtCoexist;
 
 BOOLEAN
 EXhalbtcoutsrc_InitlizeVariables(
-	IN	PVOID		Adapter	
+	IN	PVOID		Adapter
 	);
 VOID
 EXhalbtcoutsrc_PowerOnSetting(
diff --git a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c
index 22f793c..b7ff6f6 100644
--- a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c
+++ b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.c
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 #include <drv_types.h>
 
@@ -25,7 +25,7 @@
 *                           MPCIE.TXT
 ******************************************************************************/
 
-u1Byte Array_MP_8814A_MPCIE[] = { 
+u1Byte Array_MP_8814A_MPCIE[] = {
 		0xFF,
 		0xFF,
 		0xFF,
diff --git a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h
index 8b51c1b..9b4d7c5 100644
--- a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h
+++ b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_PCIE.h
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 
 
diff --git a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c
index cd80e92..d882d92 100644
--- a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c
+++ b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.c
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 #include <drv_types.h>
 
@@ -25,7 +25,7 @@
 *                           MUSB.TXT
 ******************************************************************************/
 
-u1Byte Array_MP_8814A_MUSB[] = { 
+u1Byte Array_MP_8814A_MUSB[] = {
 		0xFF,
 		0xFF,
 		0xFF,
diff --git a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h
index 4262400..be33e37 100644
--- a/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h
+++ b/drivers/net/wireless/rtl8814au/hal/efuse/rtl8814a/HalEfuseMask8814A_USB.h
@@ -1,21 +1,21 @@
-/****************************************************************************** 
-* 
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
-* 
-* This program is free software; you can redistribute it and/or modify it 
-* under the terms of version 2 of the GNU General Public License as 
-* published by the Free Software Foundation. 
-* 
-* This program is distributed in the hope that it will be useful, but WITHOUT 
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
-* more details. 
-* 
-* You should have received a copy of the GNU General Public License along with 
-* this program; if not, write to the Free Software Foundation, Inc., 
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
-* 
-* 
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
 ******************************************************************************/
 
 
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/halhwimg.h b/drivers/net/wireless/rtl8814au/hal/phydm/halhwimg.h
index 108f715..f072094 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/halhwimg.h
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/halhwimg.h
@@ -29,7 +29,7 @@
 	#define		RTL8188EE_HWIMG_SUPPORT					0
 	#define		RTL8188EU_HWIMG_SUPPORT					0
 	#define		RTL8188ES_HWIMG_SUPPORT					0
-	
+
 	#elif (DEV_BUS_TYPE == RT_USB_INTERFACE)
 	// For 92C
 	#define 	RTL8192CE_HWIMG_SUPPORT 				0
@@ -52,7 +52,7 @@
 	#define		RTL8188EE_HWIMG_SUPPORT					0
 	#define		RTL8188EU_HWIMG_SUPPORT					0
 	#define		RTL8188ES_HWIMG_SUPPORT					0
-	
+
 	#elif (DEV_BUS_TYPE == RT_SDIO_INTERFACE)
 	// For 92C
 	#define 	RTL8192CE_HWIMG_SUPPORT 				0
@@ -102,7 +102,7 @@
 	#define		RTL8188EU_HWIMG_SUPPORT					0
 	#define		RTL8188ES_HWIMG_SUPPORT					0
 
-	#else 
+	#else
 
 	// For 8723
 	#define		RTL8723E_HWIMG_SUPPORT					1
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/halphyrf_ce.c b/drivers/net/wireless/rtl8814au/hal/phydm/halphyrf_ce.c
index fa93177..400e3ca 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/halphyrf_ce.c
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/halphyrf_ce.c
@@ -46,7 +46,7 @@ void ConfigureTxpowerTrack(
 #if RTL8192E_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8192E)
 		ConfigureTxpowerTrack_8192E(pConfig);
-#endif	
+#endif
 #if RTL8821A_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8821)
 		ConfigureTxpowerTrack_8821A(pConfig);
@@ -58,7 +58,7 @@ void ConfigureTxpowerTrack(
 #if RTL8188E_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8188E)
 		ConfigureTxpowerTrack_8188E(pConfig);
-#endif 
+#endif
 
 #if RTL8723B_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8723B)
@@ -78,24 +78,24 @@ void ConfigureTxpowerTrack(
 #if RTL8188F_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8188F)
 		ConfigureTxpowerTrack_8188F(pConfig);
-#endif 
+#endif
 #if RTL8723D_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8723D)
 		ConfigureTxpowerTrack_8723D(pConfig);
-#endif 
+#endif
 #if RTL8822B_SUPPORT
 	if (pDM_Odm->SupportICType == ODM_RTL8822B)
 		ConfigureTxpowerTrack_8822B(pConfig);
-#endif 
+#endif
 
 }
 
 //======================================================================
 // <20121113, Kordan> This function should be called when TxAGC changed.
-// Otherwise the previous compensation is gone, because we record the 
+// Otherwise the previous compensation is gone, because we record the
 // delta of temperature between two TxPowerTracking watch dogs.
 //
-// NOTE: If Tx BB swing or Tx scaling is varified during run-time, still 
+// NOTE: If Tx BB swing or Tx scaling is varified during run-time, still
 //       need to call this function.
 //======================================================================
 VOID
@@ -107,13 +107,12 @@ ODM_ClearTxPowerTrackingState(
 	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(pDM_Odm->Adapter);
 	u1Byte 			p = 0;
 	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
-	
+
 	pRFCalibrateInfo->BbSwingIdxCckBase = pRFCalibrateInfo->DefaultCckIndex;
 	pRFCalibrateInfo->BbSwingIdxCck = pRFCalibrateInfo->DefaultCckIndex;
 	pDM_Odm->RFCalibrateInfo.CCK_index = 0;
-	
-	for (p = ODM_RF_PATH_A; p < MAX_RF_PATH; ++p)
-	{
+
+	for (p = ODM_RF_PATH_A; p < MAX_RF_PATH; ++p) {
 		pRFCalibrateInfo->BbSwingIdxOfdmBase[p] = pRFCalibrateInfo->DefaultOfdmIndex;
 		pRFCalibrateInfo->BbSwingIdxOfdm[p] = pRFCalibrateInfo->DefaultOfdmIndex;
 		pRFCalibrateInfo->OFDM_index[p] = pRFCalibrateInfo->DefaultOfdmIndex;
@@ -123,10 +122,10 @@ ODM_ClearTxPowerTrackingState(
 		pRFCalibrateInfo->DeltaPowerIndexLast[p] = 0;
 
 		pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] = 0;    /* Initial Mix mode power tracking*/
-		pRFCalibrateInfo->Remnant_OFDMSwingIdx[p] = 0;			  
+		pRFCalibrateInfo->Remnant_OFDMSwingIdx[p] = 0;
 		pRFCalibrateInfo->KfreeOffset[p] = 0;
 	}
-	
+
 	pRFCalibrateInfo->Modify_TxAGC_Flag_PathA = FALSE;       /*Initial at Modify Tx Scaling Mode*/
 	pRFCalibrateInfo->Modify_TxAGC_Flag_PathB = FALSE;       /*Initial at Modify Tx Scaling Mode*/
 	pRFCalibrateInfo->Modify_TxAGC_Flag_PathC = FALSE;       /*Initial at Modify Tx Scaling Mode*/
@@ -163,7 +162,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 	u1Byte			ThermalValue = 0, delta, delta_LCK, delta_IQK, p = 0, i = 0;
 	s1Byte			diff_DPK[4] = {0};
 	u1Byte			ThermalValue_AVG_count = 0;
-	u4Byte			ThermalValue_AVG = 0, RegC80, RegCd0, RegCd4, Regab4;	
+	u4Byte			ThermalValue_AVG = 0, RegC80, RegCd0, RegCd4, Regab4;
 
 	u1Byte			OFDM_min_index = 0;  // OFDM BB Swing should be less than +3.0dB, which is required by Arthur
 	u1Byte			Indexforchannel = 0; // GetRightChnlPlaceforIQK(pHalData->CurrentChannel)
@@ -196,10 +195,10 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 	if (pDM_Odm->SupportICType & ODM_RTL8814A)	/*for 8814 path C & D*/
 		(*c.GetDeltaSwingTable8814only)(pDM_Odm, (pu1Byte *)&deltaSwingTableIdx_TUP_C, (pu1Byte *)&deltaSwingTableIdx_TDOWN_C,
 			(pu1Byte *)&deltaSwingTableIdx_TUP_D, (pu1Byte *)&deltaSwingTableIdx_TDOWN_D);
-	
+
 	if (pDM_Odm->SupportICType & (ODM_RTL8703B | ODM_RTL8723D))	/*for Xtal Offset*/
 		(*c.GetDeltaSwingXtalTable)(pDM_Odm, (ps1Byte *)&deltaSwingTableXtal_UP, (ps1Byte *)&deltaSwingTableXtal_DOWN);
-	
+
 	pRFCalibrateInfo->TXPowerTrackingCallbackCnt++;	/*cosa add for debug*/
 	pRFCalibrateInfo->bTXPowerTrackingInit = TRUE;
 
@@ -216,15 +215,15 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 	#endif
 
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-		("===>ODM_TXPowerTrackingCallback_ThermalMeter\n pRFCalibrateInfo->BbSwingIdxCckBase: %d, pRFCalibrateInfo->BbSwingIdxOfdmBase[A]: %d, pRFCalibrateInfo->DefaultOfdmIndex: %d\n", 
+		("===>ODM_TXPowerTrackingCallback_ThermalMeter\n pRFCalibrateInfo->BbSwingIdxCckBase: %d, pRFCalibrateInfo->BbSwingIdxOfdmBase[A]: %d, pRFCalibrateInfo->DefaultOfdmIndex: %d\n",
 		pRFCalibrateInfo->BbSwingIdxCckBase, pRFCalibrateInfo->BbSwingIdxOfdmBase[ODM_RF_PATH_A], pRFCalibrateInfo->DefaultOfdmIndex));
 
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 		("pRFCalibrateInfo->TxPowerTrackControl=%d,  pHalData->EEPROMThermalMeter %d\n", pRFCalibrateInfo->TxPowerTrackControl,  pHalData->EEPROMThermalMeter));
 	ThermalValue = (u1Byte)ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, c.ThermalRegAddr, 0xfc00);	//0x42: RF Reg[15:10] 88E
 
 	/*add log by zhao he, check c80/c94/c14/ca0 value*/
-	if (pDM_Odm->SupportICType == ODM_RTL8723D) {	
+	if (pDM_Odm->SupportICType == ODM_RTL8723D) {
 		RegC80 = ODM_GetBBReg(pDM_Odm, 0xc80, bMaskDWord);
 		RegCd0 = ODM_GetBBReg(pDM_Odm, 0xcd0, bMaskDWord);
 		RegCd4 = ODM_GetBBReg(pDM_Odm, 0xcd4, bMaskDWord);
@@ -238,31 +237,30 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 
 	/*4 3. Initialize ThermalValues of RFCalibrateInfo*/
 
-	if (pRFCalibrateInfo->bReloadtxpowerindex)
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("reload ofdm index for band switch\n"));				
+	if (pRFCalibrateInfo->bReloadtxpowerindex) {
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("reload ofdm index for band switch\n"));
+	}
 
 	/*4 4. Calculate average thermal meter*/
-	
+
 	pRFCalibrateInfo->ThermalValue_AVG[pRFCalibrateInfo->ThermalValue_AVG_index] = ThermalValue;
 	pRFCalibrateInfo->ThermalValue_AVG_index++;
 	if (pRFCalibrateInfo->ThermalValue_AVG_index == c.AverageThermalNum)   /*Average times =  c.AverageThermalNum*/
 		pRFCalibrateInfo->ThermalValue_AVG_index = 0;
 
-	for(i = 0; i < c.AverageThermalNum; i++)
-	{
+	for (i = 0; i < c.AverageThermalNum; i++) {
 		if (pRFCalibrateInfo->ThermalValue_AVG[i]) {
 			ThermalValue_AVG += pRFCalibrateInfo->ThermalValue_AVG[i];
 			ThermalValue_AVG_count++;
 		}
 	}
 
-	if(ThermalValue_AVG_count)               //Calculate Average ThermalValue after average enough times
-	{
+	if (ThermalValue_AVG_count) { //Calculate Average ThermalValue after average enough times
 		ThermalValue = (u1Byte)(ThermalValue_AVG / ThermalValue_AVG_count);
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-			("AVG Thermal Meter = 0x%X, EFUSE Thermal Base = 0x%X\n", ThermalValue, pHalData->EEPROMThermalMeter));					
+			("AVG Thermal Meter = 0x%X, EFUSE Thermal Base = 0x%X\n", ThermalValue, pHalData->EEPROMThermalMeter));
 	}
-			
+
 	//4 5. Calculate delta, delta_LCK, delta_IQK.
 
 	//"delta" here is used to determine whether thermal value changes or not.
@@ -275,7 +273,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 		delta_IQK = (ThermalValue > pRFCalibrateInfo->ThermalValue_IQK)?(ThermalValue - pRFCalibrateInfo->ThermalValue_IQK):(pRFCalibrateInfo->ThermalValue_IQK - ThermalValue);
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("no PG, use ThermalValue for IQK\n"));
 	}
-	
+
 	for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
 		diff_DPK[p] = (s1Byte)ThermalValue - (s1Byte)pRFCalibrateInfo->DpkThermal[p];
 
@@ -291,7 +289,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				if (c.PHY_LCCalibrate)
 					(*c.PHY_LCCalibrate)(pDM_Odm);
 			}
-			
+
 			delta_LCK = (ThermalValue > pRFCalibrateInfo->ThermalValue_LCK)?(ThermalValue - pRFCalibrateInfo->ThermalValue_LCK):(pRFCalibrateInfo->ThermalValue_LCK - ThermalValue);
 		}
 
@@ -310,25 +308,24 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 		}
 	}
 
-	/*3 7. If necessary, move the index of swing table to adjust Tx power.*/	
-	
-	if (delta > 0 && pRFCalibrateInfo->TxPowerTrackControl)
-	{
+	/*3 7. If necessary, move the index of swing table to adjust Tx power.*/
+
+	if (delta > 0 && pRFCalibrateInfo->TxPowerTrackControl) {
 		//"delta" here is used to record the absolute value of differrence.
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))			
-	    delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);		
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	    delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);
 #else
-	    delta = (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther)?(ThermalValue - pDM_Odm->priv->pmib->dot11RFEntry.ther):(pDM_Odm->priv->pmib->dot11RFEntry.ther - ThermalValue);		
+	    delta = (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther)?(ThermalValue - pDM_Odm->priv->pmib->dot11RFEntry.ther):(pDM_Odm->priv->pmib->dot11RFEntry.ther - ThermalValue);
 #endif
 		if (delta >= TXPWR_TRACK_TABLE_SIZE)
 			delta = TXPWR_TRACK_TABLE_SIZE - 1;
 
 		/*4 7.1 The Final Power Index = BaseIndex + PowerIndexOffset*/
-		
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))				
-		if(ThermalValue > pHalData->EEPROMThermalMeter) {
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+		if (ThermalValue > pHalData->EEPROMThermalMeter) {
 #else
-		if(ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther) {
+		if (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther) {
 #endif
 
 			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
@@ -336,12 +333,12 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				switch (p) {
 				case ODM_RF_PATH_B:
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("deltaSwingTableIdx_TUP_B[%d] = %d\n", delta, deltaSwingTableIdx_TUP_B[delta])); 
+						("deltaSwingTableIdx_TUP_B[%d] = %d\n", delta, deltaSwingTableIdx_TUP_B[delta]));
 
 					pRFCalibrateInfo->DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_B[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_B[delta];       /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+						("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 
 				case ODM_RF_PATH_C:
@@ -351,7 +348,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 					pRFCalibrateInfo->DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_C[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_C[delta];       /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-							("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+							("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 
 				case ODM_RF_PATH_D:
@@ -361,17 +358,17 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 						pRFCalibrateInfo->DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_D[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_D[delta];       /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+						("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 
 				default:
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 						("deltaSwingTableIdx_TUP_A[%d] = %d\n", delta, deltaSwingTableIdx_TUP_A[delta]));
 
 					pRFCalibrateInfo->DeltaPowerIndex[p] = deltaSwingTableIdx_TUP_A[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  deltaSwingTableIdx_TUP_A[delta];        /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-							("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+							("******Temp is higher and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 				}
 			}
@@ -379,7 +376,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 			if (pDM_Odm->SupportICType & (ODM_RTL8703B | ODM_RTL8723D)) {
 				/*Save XtalOffset from Xtal table*/
 				pRFCalibrateInfo->XtalOffsetLast = pRFCalibrateInfo->XtalOffset;	/*recording last Xtal offset*/
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 								("[Xtal] deltaSwingTableXtal_UP[%d] = %d\n", delta, deltaSwingTableXtal_UP[delta]));
 				pRFCalibrateInfo->XtalOffset = deltaSwingTableXtal_UP[delta];
 
@@ -388,7 +385,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				else
 					XtalOffsetEanble = 1;
 			}
-		
+
 		} else {
 			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
 				pRFCalibrateInfo->DeltaPowerIndexLast[p] = pRFCalibrateInfo->DeltaPowerIndex[p];	/*recording poer index offset*/
@@ -396,46 +393,46 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				switch (p) {
 				case ODM_RF_PATH_B:
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("deltaSwingTableIdx_TDOWN_B[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_B[delta]));  
+						("deltaSwingTableIdx_TDOWN_B[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_B[delta]));
 					pRFCalibrateInfo->DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_B[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_B[delta];        /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p])); 
+						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_B] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 
 				case ODM_RF_PATH_C:
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("deltaSwingTableIdx_TDOWN_C[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_C[delta]));  
+						("deltaSwingTableIdx_TDOWN_C[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_C[delta]));
 					pRFCalibrateInfo->DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_C[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_C[delta];        /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));   
+						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_C] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 
 				case ODM_RF_PATH_D:
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("deltaSwingTableIdx_TDOWN_D[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_D[delta]));  
+						("deltaSwingTableIdx_TDOWN_D[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_D[delta]));
 					pRFCalibrateInfo->DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_D[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_D[delta];        /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_D] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
 
 				default:
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("deltaSwingTableIdx_TDOWN_A[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_A[delta]));  
+						("deltaSwingTableIdx_TDOWN_A[%d] = %d\n", delta, deltaSwingTableIdx_TDOWN_A[delta]));
 					pRFCalibrateInfo->DeltaPowerIndex[p] = -1 * deltaSwingTableIdx_TDOWN_A[delta];
 					pRFCalibrateInfo->Absolute_OFDMSwingIdx[p] =  -1 * deltaSwingTableIdx_TDOWN_A[delta];        /*Record delta swing for mix mode power tracking*/
 					ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));  
+						("******Temp is lower and pRFCalibrateInfo->Absolute_OFDMSwingIdx[ODM_RF_PATH_A] = %d\n", pRFCalibrateInfo->Absolute_OFDMSwingIdx[p]));
 					break;
-				}	
+				}
 			}
 
 			if (pDM_Odm->SupportICType & (ODM_RTL8703B | ODM_RTL8723D)) {
 				/*Save XtalOffset from Xtal table*/
 				pRFCalibrateInfo->XtalOffsetLast = pRFCalibrateInfo->XtalOffset;	/*recording last Xtal offset*/
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, 
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 								("[Xtal] deltaSwingTableXtal_DOWN[%d] = %d\n", delta, deltaSwingTableXtal_DOWN[delta]));
 				pRFCalibrateInfo->XtalOffset = deltaSwingTableXtal_DOWN[delta];
 
@@ -446,10 +443,10 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 			}
 
 		}
-		
+
 		for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-				("\n\n=========================== [Path-%d] Calculating PowerIndexOffset===========================\n", p));  
+				("\n\n=========================== [Path-%d] Calculating PowerIndexOffset===========================\n", p));
 
 			if (pRFCalibrateInfo->DeltaPowerIndex[p] == pRFCalibrateInfo->DeltaPowerIndexLast[p])         /*If Thermal value changes but lookup table value still the same*/
 				pRFCalibrateInfo->PowerIndexOffset[p] = 0;
@@ -458,12 +455,12 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 				("[Path-%d] PowerIndexOffset(%d) = DeltaPowerIndex(%d) - DeltaPowerIndexLast(%d)\n", p, pRFCalibrateInfo->PowerIndexOffset[p], pRFCalibrateInfo->DeltaPowerIndex[p], pRFCalibrateInfo->DeltaPowerIndexLast[p]));
-		
+
 			pRFCalibrateInfo->OFDM_index[p] = pRFCalibrateInfo->BbSwingIdxOfdmBase[p] + pRFCalibrateInfo->PowerIndexOffset[p];
 			pRFCalibrateInfo->CCK_index = pRFCalibrateInfo->BbSwingIdxCckBase + pRFCalibrateInfo->PowerIndexOffset[p];
 
-			pRFCalibrateInfo->BbSwingIdxCck = pRFCalibrateInfo->CCK_index;	
-			pRFCalibrateInfo->BbSwingIdxOfdm[p] = pRFCalibrateInfo->OFDM_index[p];	
+			pRFCalibrateInfo->BbSwingIdxCck = pRFCalibrateInfo->CCK_index;
+			pRFCalibrateInfo->BbSwingIdxOfdm[p] = pRFCalibrateInfo->OFDM_index[p];
 
 			/*************Print BB Swing Base and Index Offset*************/
 
@@ -473,15 +470,15 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				("The 'OFDM' final index(%d) = BaseIndex[%d](%d) + PowerIndexOffset(%d)\n", pRFCalibrateInfo->BbSwingIdxOfdm[p], p, pRFCalibrateInfo->BbSwingIdxOfdmBase[p], pRFCalibrateInfo->PowerIndexOffset[p]));
 
 			/*4 7.1 Handle boundary conditions of index.*/
-		
+
 			if (pRFCalibrateInfo->OFDM_index[p] > c.SwingTableSize_OFDM-1)
 				pRFCalibrateInfo->OFDM_index[p] = c.SwingTableSize_OFDM-1;
 			else if (pRFCalibrateInfo->OFDM_index[p] <= OFDM_min_index)
 				pRFCalibrateInfo->OFDM_index[p] = OFDM_min_index;
 		}
-		
+
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-			("\n\n========================================================================================================\n"));  
+			("\n\n========================================================================================================\n"));
 
 		if (pRFCalibrateInfo->CCK_index > c.SwingTableSize_CCK-1)
 			pRFCalibrateInfo->CCK_index = c.SwingTableSize_CCK-1;
@@ -489,7 +486,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 			pRFCalibrateInfo->CCK_index = 0;
 	} else {
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-			("The thermal meter is unchanged or TxPowerTracking OFF(%d): ThermalValue: %d , pRFCalibrateInfo->ThermalValue: %d\n", 
+			("The thermal meter is unchanged or TxPowerTracking OFF(%d): ThermalValue: %d , pRFCalibrateInfo->ThermalValue: %d\n",
 			pRFCalibrateInfo->TxPowerTrackControl, ThermalValue, pRFCalibrateInfo->ThermalValue));
 
 		for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
@@ -497,7 +494,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 	}
 
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-		("TxPowerTracking: [CCK] Swing Current Index: %d, Swing Base Index: %d\n", 
+		("TxPowerTracking: [CCK] Swing Current Index: %d, Swing Base Index: %d\n",
 			pRFCalibrateInfo->CCK_index, pRFCalibrateInfo->BbSwingIdxCckBase));       /*Print Swing base & current*/
 
 	for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
@@ -508,7 +505,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 
 	if ((pDM_Odm->SupportICType & ODM_RTL8814A)) {
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("PowerTrackingType=%d\n", PowerTrackingType));
-		
+
 		if (PowerTrackingType == 0) {
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("**********Enter POWER Tracking MIX_MODE**********\n"));
 			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
@@ -527,15 +524,15 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, TSSI_MODE, p, 0);
 		}
 		pRFCalibrateInfo->ThermalValue = ThermalValue;         /*Record last Power Tracking Thermal Value*/
-	
+
 	} else if ((pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_A] != 0 ||
 		pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_B] != 0 ||
 		pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_C] != 0 ||
-		pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_D] != 0) && 
+		pRFCalibrateInfo->PowerIndexOffset[ODM_RF_PATH_D] != 0) &&
 		pRFCalibrateInfo->TxPowerTrackControl && (pHalData->EEPROMThermalMeter != 0xff)) {
 		//4 7.2 Configure the Swing Table to adjust Tx Power.
-		
-		pRFCalibrateInfo->bTxPowerChanged = TRUE;	/*Always TRUE after Tx Power is adjusted by power tracking.*/			
+
+		pRFCalibrateInfo->bTxPowerChanged = TRUE;	/*Always TRUE after Tx Power is adjusted by power tracking.*/
 		//
 		// 2012/04/23 MH According to Luke's suggestion, we can not write BB digital
 		// to increase TX power. Otherwise, EVM will be bad.
@@ -544,14 +541,14 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 		if (ThermalValue > pRFCalibrateInfo->ThermalValue) {
 			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-					("Temperature Increasing(%d): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n", 
-					p, pRFCalibrateInfo->PowerIndexOffset[p], delta, ThermalValue, pHalData->EEPROMThermalMeter, pRFCalibrateInfo->ThermalValue));	
+					("Temperature Increasing(%d): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n",
+					p, pRFCalibrateInfo->PowerIndexOffset[p], delta, ThermalValue, pHalData->EEPROMThermalMeter, pRFCalibrateInfo->ThermalValue));
 			}
 		} else if (ThermalValue < pRFCalibrateInfo->ThermalValue) {	/*Low temperature*/
 			for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++) {
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 					("Temperature Decreasing(%d): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n",
-					p, pRFCalibrateInfo->PowerIndexOffset[p], delta, ThermalValue, pHalData->EEPROMThermalMeter, pRFCalibrateInfo->ThermalValue));				
+					p, pRFCalibrateInfo->PowerIndexOffset[p], delta, ThermalValue, pHalData->EEPROMThermalMeter, pRFCalibrateInfo->ThermalValue));
 			}
 		}
 
@@ -562,7 +559,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 #endif
 		{
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-				("Temperature(%d) higher than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));			
+				("Temperature(%d) higher than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));
 
 			if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8821 ||
 				pDM_Odm->SupportICType == ODM_RTL8812 || pDM_Odm->SupportICType == ODM_RTL8723B || pDM_Odm->SupportICType == ODM_RTL8814A ||
@@ -576,9 +573,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
 					(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, BBSWING, p, Indexforchannel);
 			}
-		}
-		else
-		{
+		} else {
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 				("Temperature(%d) lower than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));
 
@@ -594,7 +589,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 				for (p = ODM_RF_PATH_A; p < c.RfPathCount; p++)
 					(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, BBSWING, p, Indexforchannel);
 			}
-			
+
 		}
 
 		pRFCalibrateInfo->BbSwingIdxCckBase = pRFCalibrateInfo->BbSwingIdxCck;    /*Record last time Power Tracking result as base.*/
@@ -603,7 +598,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
 			("pRFCalibrateInfo->ThermalValue = %d ThermalValue= %d\n", pRFCalibrateInfo->ThermalValue, ThermalValue));
-		
+
 		pRFCalibrateInfo->ThermalValue = ThermalValue;         /*Record last Power Tracking Thermal Value*/
 
 	}
@@ -621,11 +616,11 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 			if (ThermalValue > pDM_Odm->priv->pmib->dot11RFEntry.ther) {
 #endif
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-					("Temperature(%d) higher than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));			
+					("Temperature(%d) higher than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));
 				(*c.ODM_TxXtalTrackSetXtal)(pDM_Odm);
 			} else {
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,
-					("Temperature(%d) lower than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));			
+					("Temperature(%d) lower than PG value(%d)\n", ThermalValue, pHalData->EEPROMThermalMeter));
 				(*c.ODM_TxXtalTrackSetXtal)(pDM_Odm);
 			}
 		}
@@ -638,17 +633,17 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 		/*Delta temperature is equal to or larger than 20 centigrade (When threshold is 8).*/
 		if (delta_IQK >= c.Threshold_IQK) {
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("delta_IQK(%d) >= Threshold_IQK(%d)\n", delta_IQK, c.Threshold_IQK));
-			if (!pRFCalibrateInfo->bIQKInProgress) 
+			if (!pRFCalibrateInfo->bIQKInProgress)
 				(*c.DoIQK)(pDM_Odm, delta_IQK, ThermalValue, 8);
 		}
 	}
 	if (pRFCalibrateInfo->DpkThermal[ODM_RF_PATH_A] != 0) {
-		if (diff_DPK[ODM_RF_PATH_A] >= c.Threshold_DPK) { 
+		if (diff_DPK[ODM_RF_PATH_A] >= c.Threshold_DPK) {
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0xcc4, BIT14|BIT13|BIT12|BIT11|BIT10, (diff_DPK[ODM_RF_PATH_A] / c.Threshold_DPK));
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
 		} else if ((diff_DPK[ODM_RF_PATH_A] <= -1 * c.Threshold_DPK)) {
-			s4Byte value = 0x20 + (diff_DPK[ODM_RF_PATH_A] / c.Threshold_DPK);	
+			s4Byte value = 0x20 + (diff_DPK[ODM_RF_PATH_A] / c.Threshold_DPK);
 
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0xcc4, BIT14|BIT13|BIT12|BIT11|BIT10, value);
@@ -656,16 +651,16 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 		} else {
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0xcc4, BIT14|BIT13|BIT12|BIT11|BIT10, 0);
-			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);	
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
 		}
 	}
 	if (pRFCalibrateInfo->DpkThermal[ODM_RF_PATH_B] != 0) {
-		if (diff_DPK[ODM_RF_PATH_B] >= c.Threshold_DPK) { 
+		if (diff_DPK[ODM_RF_PATH_B] >= c.Threshold_DPK) {
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0xec4, BIT14|BIT13|BIT12|BIT11|BIT10, (diff_DPK[ODM_RF_PATH_B] / c.Threshold_DPK));
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
 		} else if ((diff_DPK[ODM_RF_PATH_B] <= -1 * c.Threshold_DPK)) {
-			s4Byte value = 0x20 + (diff_DPK[ODM_RF_PATH_B] / c.Threshold_DPK);	
+			s4Byte value = 0x20 + (diff_DPK[ODM_RF_PATH_B] / c.Threshold_DPK);
 
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0xec4, BIT14|BIT13|BIT12|BIT11|BIT10, value);
@@ -673,14 +668,14 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 		} else {
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0xec4, BIT14|BIT13|BIT12|BIT11|BIT10, 0);
-			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);	
+			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0);
 		}
 	}
 
-#endif		
-			
+#endif
+
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD, ("<===ODM_TXPowerTrackingCallback_ThermalMeter\n"));
-	
+
 	pRFCalibrateInfo->TXPowercount = 0;
 }
 
@@ -700,21 +695,18 @@ ODM_ResetIQKResult(
 #if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
 u1Byte ODM_GetRightChnlPlaceforIQK(u1Byte chnl)
 {
-	u1Byte	channel_all[ODM_TARGET_CHNL_NUM_2G_5G] = 
+	u1Byte	channel_all[ODM_TARGET_CHNL_NUM_2G_5G] =
 	{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
 	u1Byte	place = chnl;
 
-	
-	if(chnl > 14)
-	{
-		for(place = 14; place<sizeof(channel_all); place++)
-		{
-			if(channel_all[place] == chnl)
-			{
+
+	if (chnl > 14) {
+		for (place = 14; place<sizeof(channel_all); place++) {
+			if (channel_all[place] == chnl) {
 				return place-13;
 			}
 		}
-	}	
+	}
 	return 0;
 
 }
@@ -722,21 +714,21 @@ u1Byte ODM_GetRightChnlPlaceforIQK(u1Byte chnl)
 
 VOID
 odm_IQCalibrate(
-		IN	PDM_ODM_T	pDM_Odm 
+		IN	PDM_ODM_T	pDM_Odm
 		)
 {
 	PADAPTER	Adapter = pDM_Odm->Adapter;
 
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	if (*pDM_Odm->pIsFcsModeEnable)
 		return;
 #endif
-	
+
 #if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
 	if (IS_HARDWARE_TYPE_8812AU(Adapter))
 		return;
 #endif
-	
+
 	if (pDM_Odm->bLinked) {
 		if ((*pDM_Odm->pChannel != pDM_Odm->preChannel) && (!*pDM_Odm->pbScanInProcess)) {
 			pDM_Odm->preChannel = *pDM_Odm->pChannel;
@@ -745,24 +737,24 @@ odm_IQCalibrate(
 
 		if (pDM_Odm->LinkedInterval < 3)
 			pDM_Odm->LinkedInterval++;
-		
+
 		if (pDM_Odm->LinkedInterval == 2) {
 			if (IS_HARDWARE_TYPE_8814A(Adapter)) {
-				#if (RTL8814A_SUPPORT == 1)	
+				#if (RTL8814A_SUPPORT == 1)
 				PHY_IQCalibrate_8814A(pDM_Odm, FALSE);
 				#endif
-			} 
-			
+			}
+
 			#if (RTL8822B_SUPPORT == 1)
 			else if (IS_HARDWARE_TYPE_8822B(Adapter))
 				PHY_IQCalibrate_8822B(pDM_Odm, FALSE);
 			#endif
-			
+
 			#if (RTL8821C_SUPPORT == 1)
 			else if (IS_HARDWARE_TYPE_8821C(Adapter))
 				PHY_IQCalibrate_8821C(pDM_Odm, FALSE);
 			#endif
-			
+
 			#if (RTL8821A_SUPPORT == 1)
 			else if (IS_HARDWARE_TYPE_8821(Adapter))
 				PHY_IQCalibrate_8821A(pDM_Odm, FALSE);
@@ -778,14 +770,14 @@ void phydm_rf_init(IN	PVOID		pDM_VOID)
 	odm_TXPowerTrackingInit(pDM_Odm);
 
 #if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
-	ODM_ClearTxPowerTrackingState(pDM_Odm);	
+	ODM_ClearTxPowerTrackingState(pDM_Odm);
 #endif
 
 #if (DM_ODM_SUPPORT_TYPE & (ODM_AP))
-#if (RTL8814A_SUPPORT == 1)		
+#if (RTL8814A_SUPPORT == 1)
 	if (pDM_Odm->SupportICType & ODM_RTL8814A)
 		PHY_IQCalibrate_8814A_Init(pDM_Odm);
-#endif	
+#endif
 #endif
 
 }
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/mp_precomp.h b/drivers/net/wireless/rtl8814au/hal/phydm/mp_precomp.h
index 2ae8110..322bce0 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/mp_precomp.h
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/mp_precomp.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/phydm.c b/drivers/net/wireless/rtl8814au/hal/phydm/phydm.c
index e6a6af2..fd4fd8e 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/phydm.c
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/phydm.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -76,21 +76,19 @@ ODM_PWdB_Conversion(
 	s4Byte Y, integer = 0, decimal = 0;
 	u4Byte i;
 
-	if(X == 0)
+	if (X == 0)
 		X = 1; // log2(x), x can't be 0
 
-	for(i = (TotalBit-1); i > 0; i--)
-	{
-		if(X & BIT(i))
-		{
+	for (i = (TotalBit-1); i > 0; i--) {
+		if (X & BIT(i)) {
 			integer = i;
-			if(i > 0)
-				decimal = (X & BIT(i-1))?2:0; //decimal is 0.5dB*3=1.5dB~=2dB 
+			if (i > 0)
+				decimal = (X & BIT(i-1))?2:0; //decimal is 0.5dB*3=1.5dB~=2dB
 			break;
 		}
 	}
-	
-	Y = 3*(integer-DecimalBit)+decimal; //10*log(x)=3*log2(x), 
+
+	Y = 3*(integer-DecimalBit)+decimal; //10*log(x)=3*log2(x),
 
 	return Y;
 }
@@ -101,17 +99,17 @@ ODM_SignConversion(
     IN  u4Byte TotalBit
     )
 {
-	if(value&BIT(TotalBit-1))
+	if (value&BIT(TotalBit-1))
 		value -= BIT(TotalBit);
 	return value;
 }
 
 void
-phydm_seq_sorting( 
+phydm_seq_sorting(
 	IN		PVOID	pDM_VOID,
 	IN OUT	u4Byte	*p_value,
 	IN OUT	u4Byte	*rank_idx,
-	IN OUT	u4Byte	*p_idx_out,	
+	IN OUT	u4Byte	*p_idx_out,
 	IN		u1Byte	seq_length
 )
 {
@@ -126,9 +124,9 @@ phydm_seq_sorting(
 	}
 
 	for (i = 0; i < (seq_length - 1); i++) {
-		
+
 		for (j = 0; j < (seq_length - 1 - i); j++) {
-		
+
 			tmp_a = p_value[j];
 			tmp_b = p_value[j+1];
 
@@ -138,20 +136,20 @@ phydm_seq_sorting(
 			if (tmp_a < tmp_b) {
 				p_value[j] = tmp_b;
 				p_value[j+1] = tmp_a;
-				
+
 				rank_idx[j] = tmp_idx_b;
 				rank_idx[j+1] = tmp_idx_a;
 			}
-		}		
+		}
 	}
 
 	for (i = 0; i < seq_length; i++) {
 		p_idx_out[rank_idx[i]] = i+1;
 		/**/
 	}
-	
 
-	
+
+
 }
 
 VOID
@@ -180,7 +178,7 @@ ODM_InitMpDriverStatus(
 	prtl8192cd_priv	 priv = pDM_Odm->priv;
 
 	pDM_Odm->mp_mode = (BOOLEAN)priv->pshare->rf_ft_var.mp_specific;
-	
+
 #endif
 }
 
@@ -223,19 +221,19 @@ PHYDM_InitTRXAntennaSetting(
 	} else if (pDM_Odm->SupportICType & (ODM_RTL8723D | ODM_RTL8821C)) {
 		pDM_Odm->TXAntStatus = 0x1;
 		pDM_Odm->RXAntStatus = 0x1;
-			
+
 	}
 /*#endif*/
 }
 
 void
-phydm_traffic_load_decision( 
+phydm_traffic_load_decision(
 	IN		PVOID	pDM_VOID
 	)
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	
+
 	/*---trafic load decision---*/
 	pDM_Odm->curTxOkCnt =  *(pDM_Odm->pNumTxBytesUnicast) - pDM_Odm->lastTxOkCnt;
 	pDM_Odm->curRxOkCnt =  *(pDM_Odm->pNumRxBytesUnicast) - pDM_Odm->lastRxOkCnt;
@@ -249,25 +247,25 @@ phydm_traffic_load_decision(
 	pDM_Odm->tx_tp = ((pDM_Odm->tx_tp)>>1) + (u4Byte)(((pDM_Odm->curTxOkCnt)>>18)>>1); /* <<3(8bit), >>20(10^6,M), >>1(2sec)*/
 	pDM_Odm->rx_tp = ((pDM_Odm->rx_tp)>>1) + (u4Byte)(((pDM_Odm->curRxOkCnt)>>18)>>1); /* <<3(8bit), >>20(10^6,M), >>1(2sec)*/
 	#endif
-	pDM_Odm->total_tp = pDM_Odm->tx_tp + pDM_Odm->rx_tp; 
-	
+	pDM_Odm->total_tp = pDM_Odm->tx_tp + pDM_Odm->rx_tp;
+
 
 	pDM_Odm->pre_TrafficLoad = pDM_Odm->TrafficLoad;
-	
+
 	if (pDM_Odm->curTxOkCnt > 1875000 || pDM_Odm->curRxOkCnt > 1875000) {		/* ( 1.875M * 8bit ) / 2sec= 7.5M bits /sec )*/
-	
+
 		pDM_Odm->TrafficLoad = TRAFFIC_HIGH;
 		/**/
 	} else if (pDM_Odm->curTxOkCnt > 500000 || pDM_Odm->curRxOkCnt > 500000) { /*( 0.5M * 8bit ) / 2sec =  2M bits /sec )*/
-	
+
 		pDM_Odm->TrafficLoad = TRAFFIC_MID;
 		/**/
 	} else if (pDM_Odm->curTxOkCnt > 100000 || pDM_Odm->curRxOkCnt > 100000)  { /*( 0.1M * 8bit ) / 2sec =  0.4M bits /sec )*/
-	
+
 		pDM_Odm->TrafficLoad = TRAFFIC_LOW;
 		/**/
 	} else {
-	
+
 		pDM_Odm->TrafficLoad = TRAFFIC_ULTRA_LOW;
 		/**/
 	}
@@ -283,7 +281,7 @@ phydm_config_ofdm_tx_path(
 
 	#if (RTL8192E_SUPPORT == 1)
 	if (pDM_Odm->SupportICType & (ODM_RTL8192E)) {
-		
+
 		if (path == PHYDM_A) {
 			ODM_SetBBReg(pDM_Odm, 0x90c , bMaskDWord, 0x81321311);
 			/**/
@@ -294,8 +292,8 @@ phydm_config_ofdm_tx_path(
 			ODM_SetBBReg(pDM_Odm, 0x90c , bMaskDWord, 0x83321333);
 			/**/
 		}
-		
-		
+
+
 	}
 	#endif
 }
@@ -310,7 +308,7 @@ phydm_config_ofdm_rx_path(
 
 	#if (RTL8192E_SUPPORT == 1)
 	if (pDM_Odm->SupportICType & (ODM_RTL8192E)) {
-		
+
 		if (path == PHYDM_A) {
 			ofdm_rx_path = 1;
 			/**/
@@ -321,7 +319,7 @@ phydm_config_ofdm_rx_path(
 			ofdm_rx_path = 3;
 			/**/
 		}
-		
+
 		ODM_SetBBReg(pDM_Odm, 0xC04 , 0xff, (((ofdm_rx_path)<<4)|ofdm_rx_path));
 		ODM_SetBBReg(pDM_Odm, 0xD04 , 0xf, ofdm_rx_path);
 	}
@@ -335,7 +333,7 @@ phydm_config_cck_rx_antenna_init(
 {
 	#if (RTL8192E_SUPPORT == 1)
 	if (pDM_Odm->SupportICType & (ODM_RTL8192E)) {
-	
+
 		/*CCK 2R CCA parameters*/
 		ODM_SetBBReg(pDM_Odm, 0xa2c , BIT18, 1); /*enable 2R Rx path*/
 		ODM_SetBBReg(pDM_Odm, 0xa2c , BIT22, 1); /*enable 2R MRC*/
@@ -360,7 +358,7 @@ phydm_config_cck_rx_path(
 
 	#if (RTL8192E_SUPPORT == 1)
 	if (pDM_Odm->SupportICType & (ODM_RTL8192E)) {
-		
+
 		if (path == PHYDM_A) {
 			path_div_select = 0;
 			cck_1_path = 0;
@@ -368,21 +366,21 @@ phydm_config_cck_rx_path(
 		} else if (path == PHYDM_B) {
 			path_div_select = 0;
 			cck_1_path = 1;
-			cck_2_path = 1;			
+			cck_2_path = 1;
 		} else  if (path == PHYDM_AB) {
-		
+
 			if (path_div_en == CCA_PATHDIV_ENABLE)
 				path_div_select = 1;
-			
+
 			cck_1_path = 0;
-			cck_2_path = 1;	
-			
+			cck_2_path = 1;
+
 		}
-		
+
 		ODM_SetBBReg(pDM_Odm, 0xa04 , (BIT27|BIT26), cck_1_path);
 		ODM_SetBBReg(pDM_Odm, 0xa04 , (BIT25|BIT24), cck_2_path);
 		ODM_SetBBReg(pDM_Odm, 0xa74 , BIT8, path_div_select);
-		
+
 	}
 	#endif
 }
@@ -403,7 +401,7 @@ phydm_config_trx_path(
 
 	/* CCK */
 	if (dm_value[0] == 0) {
-		
+
 		if (dm_value[1] == 1) { /*TX*/
 			if (dm_value[2] == 1)
 				ODM_SetBBReg(pDM_Odm, 0xa04, 0xf0000000, 0x8);
@@ -412,9 +410,9 @@ phydm_config_trx_path(
 			else if (dm_value[2] == 3)
 				ODM_SetBBReg(pDM_Odm, 0xa04, 0xf0000000, 0xc);
 		} else if (dm_value[1] == 2) { /*RX*/
-		
+
 			phydm_config_cck_rx_antenna_init(pDM_Odm);
-			
+
 			if (dm_value[2] == 1) {
 				phydm_config_cck_rx_path(pDM_Odm, PHYDM_A, CCA_PATHDIV_DISABLE);
 			} else  if (dm_value[2] == 2) {
@@ -426,7 +424,7 @@ phydm_config_trx_path(
 					phydm_config_cck_rx_path(pDM_Odm, PHYDM_B, CCA_PATHDIV_DISABLE);
 			}
 		}
-	} 
+	}
 	/* OFDM */
 	else if (dm_value[0] == 1) {
 
@@ -447,7 +445,7 @@ phydm_config_trx_path(
 		(dm_value[2] & 0x4)?"C":"",
 		(dm_value[2] & 0x8)?"D":""
 		));
-		
+
 }
 
 VOID
@@ -460,19 +458,17 @@ phydm_Init_cck_setting(
 	pDM_Odm->bCckHighPower = (BOOLEAN) ODM_GetBBReg(pDM_Odm, ODM_REG(CCK_RPT_FORMAT,pDM_Odm), ODM_BIT(CCK_RPT_FORMAT,pDM_Odm));
 
 	#if (RTL8192E_SUPPORT == 1)
-	if(pDM_Odm->SupportICType & (ODM_RTL8192E))
-	{
+	if (pDM_Odm->SupportICType & (ODM_RTL8192E)) {
 		#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 		phydm_config_cck_rx_antenna_init(pDM_Odm);
 		phydm_config_cck_rx_path(pDM_Odm, PHYDM_A, CCA_PATHDIV_DISABLE);
 		#endif
-	
+
 		/* 0x824[9] = 0x82C[9] = 0xA80[7]  those registers setting should be equal or CCK RSSI report may be incorrect */
 		value_824 = ODM_GetBBReg(pDM_Odm, 0x824, BIT9);
 		value_82c = ODM_GetBBReg(pDM_Odm, 0x82c, BIT9);
-		
-		if(value_824 != value_82c)
-		{
+
+		if (value_824 != value_82c) {
 			ODM_SetBBReg(pDM_Odm, 0x82c , BIT9, value_824);
 		}
 		ODM_SetBBReg(pDM_Odm, 0xa80 , BIT7, value_824);
@@ -481,19 +477,19 @@ phydm_Init_cck_setting(
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("cck_agc_report_type = (( %d )), ExtLNAGain = (( %d ))\n", pDM_Odm->cck_agc_report_type, pDM_Odm->ExtLNAGain));
 	}
 	#endif
-	
+
 #if ((RTL8703B_SUPPORT == 1) || (RTL8723D_SUPPORT == 1))
 	if (pDM_Odm->SupportICType & (ODM_RTL8703B|ODM_RTL8723D)) {
 
 		pDM_Odm->cck_agc_report_type = ODM_GetBBReg(pDM_Odm, 0x950, BIT11) ? 1 : 0; /*1: 4bit LNA , 0: 3bit LNA */
-		
+
 		if (pDM_Odm->cck_agc_report_type != 1) {
 			DbgPrint("[Warning] 8703B/8723D CCK should be 4bit LNA, ie. 0x950[11] = 1\n");
 			/**/
 		}
 	}
 #endif
-	
+
 #if ((RTL8723D_SUPPORT == 1) || (RTL8822B_SUPPORT == 1) || (RTL8197F_SUPPORT == 1))
 
 	if (pDM_Odm->SupportICType & (ODM_RTL8723D|ODM_RTL8822B|ODM_RTL8197F)) {
@@ -501,7 +497,7 @@ phydm_Init_cck_setting(
 	} else
 #endif
 		pDM_Odm->cck_new_agc = FALSE;
-	
+
 }
 
 VOID
@@ -535,7 +531,7 @@ odm_CommonInfoSelfInit(
 {
 	phydm_Init_cck_setting(pDM_Odm);
 	pDM_Odm->RFPathRxEnable = (u1Byte) ODM_GetBBReg(pDM_Odm, ODM_REG(BB_RX_PATH,pDM_Odm), ODM_BIT(BB_RX_PATH,pDM_Odm));
-#if (DM_ODM_SUPPORT_TYPE != ODM_CE)	
+#if (DM_ODM_SUPPORT_TYPE != ODM_CE)
 	pDM_Odm->pbNet_closed = &pDM_Odm->BOOLEAN_temp;
 #endif
 
@@ -559,7 +555,7 @@ odm_CommonInfoSelfInit(
 	pDM_Odm->TrafficLoad = TRAFFIC_LOW;
 
 	pDM_Odm->nbi_set_result = 0;
-	
+
 }
 
 VOID
@@ -602,8 +598,7 @@ odm_CommonInfoSelfUpdate(
 
 /* THis variable cannot be used because it is wrong*/
 #if (DM_ODM_SUPPORT_TYPE == ODM_AP)
-	if (*(pDM_Odm->pBandWidth) == ODM_BW40M)
-	{
+	if (*(pDM_Odm->pBandWidth) == ODM_BW40M) {
 		if (*(pDM_Odm->pSecChOffset) == 1)
 			pDM_Odm->ControlChannel = *(pDM_Odm->pChannel) + 2;
 		else if (*(pDM_Odm->pSecChOffset) == 2)
@@ -625,14 +620,11 @@ odm_CommonInfoSelfUpdate(
 		pDM_Odm->ControlChannel = *(pDM_Odm->pChannel);
 #endif
 
-	for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
-	{
+	for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++) {
 		pEntry = pDM_Odm->pODM_StaInfo[i];
-		if(IS_STA_VALID(pEntry))
-		{
+		if (IS_STA_VALID(pEntry)) {
 			EntryCnt++;
-			if(EntryCnt==1)
-			{
+			if (EntryCnt==1) {
 				OneEntry_MACID=i;
 			}
 
@@ -640,15 +632,14 @@ odm_CommonInfoSelfUpdate(
 				ma_rx_tp =  (pEntry->rx_byte_cnt_LowMAW)<<3; /*  low moving average RX  TP   ( bit /sec)*/
 
 				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_RA_DBG, ODM_DBG_LOUD, ("ClientTP[%d]: ((%d )) bit/sec\n", i, ma_rx_tp));
-				
+
 				if (ma_rx_tp > ACTIVE_TP_THRESHOLD)
 					num_active_client++;
 			#endif
                 }
 	}
-	
-	if(EntryCnt == 1)
-	{
+
+	if (EntryCnt == 1) {
 		pDM_Odm->bOneEntryOnly = TRUE;
 		pDM_Odm->OneEntry_MACID=OneEntry_MACID;
 	}
@@ -657,15 +648,15 @@ odm_CommonInfoSelfUpdate(
 
 	pDM_Odm->pre_number_linked_client = pDM_Odm->number_linked_client;
 	pDM_Odm->pre_number_active_client = pDM_Odm->number_active_client;
-	
+
 	pDM_Odm->number_linked_client = EntryCnt;
-	pDM_Odm->number_active_client = num_active_client;	
+	pDM_Odm->number_active_client = num_active_client;
 
 	/* Update MP driver status*/
 	ODM_UpdateMpDriverStatus(pDM_Odm);
 
 	/*Traffic load information update*/
-	phydm_traffic_load_decision(pDM_Odm);	
+	phydm_traffic_load_decision(pDM_Odm);
 }
 
 VOID
@@ -691,7 +682,7 @@ PhyDM_Get_Structure(
 		case	PHYDM_FALSEALMCNT:
 			pStruct = &FalseAlmCnt;
 		break;
-		
+
 		case	PHYDM_CFOTRACK:
 			pStruct = &DM_CfoTrack;
 		break;
@@ -699,7 +690,7 @@ PhyDM_Get_Structure(
 		case	PHYDM_ADAPTIVITY:
 			pStruct = &(pDM_Odm->Adaptivity);
 		break;
-		
+
 		default:
 		break;
 	}
@@ -709,7 +700,7 @@ PhyDM_Get_Structure(
 		case	PHYDM_FALSEALMCNT:
 			pStruct = &(pDM_Odm->FalseAlmCnt);
 		break;
-		
+
 		case	PHYDM_CFOTRACK:
 			pStruct = &(pDM_Odm->DM_CfoTrack);
 		break;
@@ -717,7 +708,7 @@ PhyDM_Get_Structure(
 		case	PHYDM_ADAPTIVITY:
 			pStruct = &(pDM_Odm->Adaptivity);
 		break;
-		
+
 		default:
 		break;
 	}
@@ -732,7 +723,7 @@ odm_HWSetting(
 	)
 {
 #if (RTL8821A_SUPPORT == 1)
-	if(pDM_Odm->SupportICType & ODM_RTL8821)
+	if (pDM_Odm->SupportICType & ODM_RTL8821)
 		odm_HWSetting_8821A(pDM_Odm);
 #endif
 
@@ -774,7 +765,7 @@ ODM_DMInit(
 	odm_PathDiversityInit(pDM_Odm);
 	odm_DynamicTxPowerInit(pDM_Odm);
 	phydm_initRaInfo(pDM_Odm);
-	
+
 #if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE))
 #ifdef BEAMFORMING_VERSION_1
 	if (pHalData->BeamformingVersion == BEAMFORMING_VERSION_1)
@@ -782,29 +773,27 @@ ODM_DMInit(
 	{
 		phydm_Beamforming_Init(pDM_Odm);
 	}
-#endif	
+#endif
 
-	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-	{
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
 		odm_DynamicBBPowerSavingInit(pDM_Odm);
 
 #if (RTL8188E_SUPPORT == 1)
-		if(pDM_Odm->SupportICType==ODM_RTL8188E)
-		{
+		if (pDM_Odm->SupportICType==ODM_RTL8188E) {
 			ODM_PrimaryCCA_Init(pDM_Odm);
 			ODM_RAInfo_Init_all(pDM_Odm);
 		}
 #endif
 
 #if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
-	
+
 	#if (RTL8723B_SUPPORT == 1)
-		if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		if (pDM_Odm->SupportICType == ODM_RTL8723B)
 			odm_SwAntDetectInit(pDM_Odm);
 	#endif
 
 	#if (RTL8192E_SUPPORT == 1)
-		if(pDM_Odm->SupportICType==ODM_RTL8192E)
+		if (pDM_Odm->SupportICType==ODM_RTL8192E)
 			odm_PrimaryCCA_Check_Init(pDM_Odm);
 	#endif
 
@@ -821,7 +810,7 @@ ODM_DMReset(
 {
 	pDIG_T pDM_DigTable = &pDM_Odm->DM_DigTable;
 
-	ODM_AntDivReset(pDM_Odm);	
+	ODM_AntDivReset(pDM_Odm);
 	phydm_setEDCCAThresholdAPI(pDM_Odm, pDM_DigTable->CurIGValue);
 }
 
@@ -840,10 +829,9 @@ phydm_support_ability_debug(
 	u4Byte used = *_used;
 	u4Byte out_len = *_out_len;
 
-	pre_support_ability = pDM_Odm->SupportAbility ;	
+	pre_support_ability = pDM_Odm->SupportAbility ;
 	PHYDM_SNPRINTF((output+used, out_len-used,"\n%s\n", "================================"));
-	if(dm_value[0] == 100)
-	{
+	if (dm_value[0] == 100) {
 		PHYDM_SNPRINTF((output+used, out_len-used, "[Supportability] PhyDM Selection\n"));
 		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "================================"));
 		PHYDM_SNPRINTF((output+used, out_len-used, "00. (( %s ))DIG\n", ((pDM_Odm->SupportAbility & ODM_BB_DIG)?("V"):("."))));
@@ -851,20 +839,20 @@ phydm_support_ability_debug(
 		PHYDM_SNPRINTF((output+used, out_len-used, "02. (( %s ))DYNAMIC_TXPWR\n", ((pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_TXPWR)?("V"):("."))));		
 		PHYDM_SNPRINTF((output+used, out_len-used, "03. (( %s ))FA_CNT\n", ((pDM_Odm->SupportAbility & ODM_BB_FA_CNT)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "04. (( %s ))RSSI_MONITOR\n", ((pDM_Odm->SupportAbility & ODM_BB_RSSI_MONITOR)?("V"):("."))));
-		PHYDM_SNPRINTF((output+used, out_len-used, "05. (( %s ))CCK_PD\n", ((pDM_Odm->SupportAbility & ODM_BB_CCK_PD)?("V"):("."))));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "05. (( %s ))CCK_PD\n", ((pDM_Odm->SupportAbility & ODM_BB_CCK_PD)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "06. (( %s ))ANT_DIV\n", ((pDM_Odm->SupportAbility & ODM_BB_ANT_DIV)?("V"):("."))));
-		PHYDM_SNPRINTF((output+used, out_len-used, "08. (( %s ))PWR_TRAIN\n", ((pDM_Odm->SupportAbility & ODM_BB_PWR_TRAIN)?("V"):("."))));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "08. (( %s ))PWR_TRAIN\n", ((pDM_Odm->SupportAbility & ODM_BB_PWR_TRAIN)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "09. (( %s ))RATE_ADAPTIVE\n", ((pDM_Odm->SupportAbility & ODM_BB_RATE_ADAPTIVE)?("V"):("."))));
-		PHYDM_SNPRINTF((output+used, out_len-used, "10. (( %s ))PATH_DIV\n", ((pDM_Odm->SupportAbility & ODM_BB_PATH_DIV)?("V"):(".")))); 
-		PHYDM_SNPRINTF((output+used, out_len-used, "13. (( %s ))ADAPTIVITY\n", ((pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY)?("V"):("."))));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "10. (( %s ))PATH_DIV\n", ((pDM_Odm->SupportAbility & ODM_BB_PATH_DIV)?("V"):("."))));
+		PHYDM_SNPRINTF((output+used, out_len-used, "13. (( %s ))ADAPTIVITY\n", ((pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "14. (( %s ))CFO_TRACKING\n", ((pDM_Odm->SupportAbility & ODM_BB_CFO_TRACKING)?("V"):("."))));
-		PHYDM_SNPRINTF((output+used, out_len-used, "15. (( %s ))NHM_CNT\n", ((pDM_Odm->SupportAbility & ODM_BB_NHM_CNT)?("V"):("."))));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "15. (( %s ))NHM_CNT\n", ((pDM_Odm->SupportAbility & ODM_BB_NHM_CNT)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "16. (( %s ))PRIMARY_CCA\n", ((pDM_Odm->SupportAbility & ODM_BB_PRIMARY_CCA)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "17. (( %s ))TXBF\n", ((pDM_Odm->SupportAbility & ODM_BB_TXBF)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "18. (( %s ))DYNAMIC_ARFR\n", ((pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_ARFR)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "20. (( %s ))EDCA_TURBO\n", ((pDM_Odm->SupportAbility & ODM_MAC_EDCA_TURBO)?("V"):("."))));	
 		PHYDM_SNPRINTF((output+used, out_len-used, "21. (( %s ))EARLY_MODE\n", ((pDM_Odm->SupportAbility & ODM_MAC_EARLY_MODE)?("V"):("."))));
-		PHYDM_SNPRINTF((output+used, out_len-used, "24. (( %s ))TX_PWR_TRACK\n", ((pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK)?("V"):("."))));	
+		PHYDM_SNPRINTF((output+used, out_len-used, "24. (( %s ))TX_PWR_TRACK\n", ((pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "25. (( %s ))RX_GAIN_TRACK\n", ((pDM_Odm->SupportAbility & ODM_RF_RX_GAIN_TRACK)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used, "26. (( %s ))RF_CALIBRATION\n", ((pDM_Odm->SupportAbility & ODM_RF_CALIBRATION)?("V"):("."))));
 		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "================================"));
@@ -874,31 +862,25 @@ phydm_support_ability_debug(
 	{
 		pDM_Odm->SupportAbility = 0 ;
 		DbgPrint("Disable all SupportAbility components \n");
-		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "Disable all SupportAbility components"));	
+		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "Disable all SupportAbility components"));
 	}
 	*/
-	else
-	{
+	else {
 
-		if(dm_value[1] == 1) //enable
-		{
+		if (dm_value[1] == 1) { //enable
 			pDM_Odm->SupportAbility |= BIT(dm_value[0]) ;
-			if(BIT(dm_value[0]) & ODM_BB_PATH_DIV)
-			{
+			if (BIT(dm_value[0]) & ODM_BB_PATH_DIV) {
 				odm_PathDiversityInit(pDM_Odm);
 			}
 		}
-		else if(dm_value[1] == 2) //disable
-		{
+		else if (dm_value[1] == 2) { //disable
 			pDM_Odm->SupportAbility &= ~(BIT(dm_value[0])) ;
-		}
-		else
-		{
+		} else {
 			//DbgPrint("\n[Warning!!!]  1:enable,  2:disable \n\n");
 			PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "[Warning!!!]  1:enable,  2:disable"));
 		}
 	}
-	PHYDM_SNPRINTF((output+used, out_len-used,"pre-SupportAbility  =  0x%x\n",  pre_support_ability ));	
+	PHYDM_SNPRINTF((output+used, out_len-used,"pre-SupportAbility  =  0x%x\n",  pre_support_ability ));
 	PHYDM_SNPRINTF((output+used, out_len-used,"Curr-SupportAbility =  0x%x\n", pDM_Odm->SupportAbility ));
 	PHYDM_SNPRINTF((output+used, out_len-used,"%s\n", "================================"));
 }
@@ -911,15 +893,15 @@ VOID
 ODM_DMWatchdog_LPS(
 	IN		PDM_ODM_T		pDM_Odm
 	)
-{	
+{
 	odm_CommonInfoSelfUpdate(pDM_Odm);
 	odm_FalseAlarmCounterStatistics(pDM_Odm);
 	odm_RSSIMonitorCheck(pDM_Odm);
-	odm_DIGbyRSSI_LPS(pDM_Odm);	
+	odm_DIGbyRSSI_LPS(pDM_Odm);
 	odm_CCKPacketDetectionThresh(pDM_Odm);
 	odm_CommonInfoSelfReset(pDM_Odm);
 
-	if(*(pDM_Odm->pbPowerSaving)==TRUE)
+	if (*(pDM_Odm->pbPowerSaving)==TRUE)
 		return;
 }
 #endif
@@ -940,17 +922,16 @@ ODM_DMWatchdog(
 #if (DM_ODM_SUPPORT_TYPE == ODM_AP)
 	{
 	prtl8192cd_priv priv		= pDM_Odm->priv;
-	if( (priv->auto_channel != 0) && (priv->auto_channel != 2) )//if ACS running, do not do FA/CCA counter read
+	if ( (priv->auto_channel != 0) && (priv->auto_channel != 2) )//if ACS running, do not do FA/CCA counter read
 		return;
 	}
-#endif	
+#endif
 	odm_FalseAlarmCounterStatistics(pDM_Odm);
 	phydm_NoisyDetection(pDM_Odm);
-	
+
 	odm_RSSIMonitorCheck(pDM_Odm);
 
-	if(*(pDM_Odm->pbPowerSaving) == TRUE)
-	{
+	if (*(pDM_Odm->pbPowerSaving) == TRUE) {
 		odm_DIGbyRSSI_LPS(pDM_Odm);
 		{
 			pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
@@ -962,7 +943,7 @@ ODM_DMWatchdog(
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("DMWatchdog in power saving mode\n"));
 		return;
 	}
-	
+
 	Phydm_CheckAdaptivity(pDM_Odm);
 	odm_UpdatePowerTrainingState(pDM_Odm);
 	odm_DIG(pDM_Odm);
@@ -971,7 +952,7 @@ ODM_DMWatchdog(
 		Phydm_Adaptivity(pDM_Odm, pDM_DigTable->CurIGValue);
 	}
 	odm_CCKPacketDetectionThresh(pDM_Odm);
-	
+
 	phydm_ra_info_watchdog(pDM_Odm);
 	odm_EdcaTurboCheck(pDM_Odm);
 	odm_PathDiversity(pDM_Odm);
@@ -984,9 +965,8 @@ ODM_DMWatchdog(
 
 	phydm_rf_watchdog(pDM_Odm);
 
-	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-	{
-	        
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
+
 #if (RTL8188E_SUPPORT == 1)
 		if (pDM_Odm->SupportICType == ODM_RTL8188E)
 			ODM_DynamicPrimaryCCA(pDM_Odm);
@@ -995,8 +975,8 @@ ODM_DMWatchdog(
 #if( DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
 
 	#if (RTL8192E_SUPPORT == 1)
-		if(pDM_Odm->SupportICType==ODM_RTL8192E)
-			odm_DynamicPrimaryCCA_Check(pDM_Odm); 
+		if (pDM_Odm->SupportICType==ODM_RTL8192E)
+			odm_DynamicPrimaryCCA_Check(pDM_Odm);
 	#endif
 #endif
 	}
@@ -1006,7 +986,7 @@ ODM_DMWatchdog(
 #endif
 
 	odm_CommonInfoSelfReset(pDM_Odm);
-	
+
 }
 
 
@@ -1017,7 +997,7 @@ VOID
 ODM_CmnInfoInit(
 	IN		PDM_ODM_T		pDM_Odm,
 	IN		ODM_CMNINFO_E	CmnInfo,
-	IN		u4Byte			Value	
+	IN		u4Byte			Value
 	)
 {
 	//
@@ -1047,7 +1027,7 @@ ODM_CmnInfoInit(
 		case	ODM_CMNINFO_MP_TEST_CHIP:
 			pDM_Odm->bIsMPChip= (u1Byte)Value;
 			break;
-            
+
 		case	ODM_CMNINFO_IC_TYPE:
 			pDM_Odm->SupportICType = Value;
 			break;
@@ -1068,14 +1048,14 @@ ODM_CmnInfoInit(
 		case    ODM_CMNINFO_RF_ANTENNA_TYPE:
 			pDM_Odm->AntDivType= (u1Byte)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_WITH_EXT_ANTENNA_SWITCH:
 			pDM_Odm->with_extenal_ant_switch = (u1Byte)Value;
-			break;	
-			
+			break;
+
 		case    ODM_CMNINFO_BE_FIX_TX_ANT:
 			pDM_Odm->DM_FatTable.b_fix_tx_ant = (u1Byte)Value;
-			break;	
+			break;
 
 		case	ODM_CMNINFO_BOARD_TYPE:
 			if (!pDM_Odm->bInitHwInfoByRfe)
@@ -1111,17 +1091,17 @@ ODM_CmnInfoInit(
 			if (!pDM_Odm->bInitHwInfoByRfe)
 				pDM_Odm->TypeGPA = (u2Byte)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_APA:
 			if (!pDM_Odm->bInitHwInfoByRfe)
 				pDM_Odm->TypeAPA = (u2Byte)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_GLNA:
 			if (!pDM_Odm->bInitHwInfoByRfe)
 				pDM_Odm->TypeGLNA = (u2Byte)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_ALNA:
 			if (!pDM_Odm->bInitHwInfoByRfe)
 				pDM_Odm->TypeALNA = (u2Byte)Value;
@@ -1141,7 +1121,7 @@ ODM_CmnInfoInit(
 			break;
 		case 	ODM_CMNINFO_BWIFI_TEST:
 			pDM_Odm->WIFITest = (u1Byte)Value;
-			break;	
+			break;
 		case	ODM_CMNINFO_SMART_CONCURRENT:
 			pDM_Odm->bDualMacSmartConcurrent = (BOOLEAN )Value;
 			break;
@@ -1171,11 +1151,11 @@ ODM_CmnInfoInit(
 			pDM_Odm->DFS_RegionDomain = (u1Byte)Value;
 			break;
 #endif
-		//To remove the compiler warning, must add an empty default statement to handle the other values.	
+		//To remove the compiler warning, must add an empty default statement to handle the other values.
 		default:
 			//do nothing
-			break;	
-		
+			break;
+
 	}
 
 }
@@ -1185,7 +1165,7 @@ VOID
 ODM_CmnInfoHook(
 	IN		PDM_ODM_T		pDM_Odm,
 	IN		ODM_CMNINFO_E	CmnInfo,
-	IN		PVOID			pValue	
+	IN		PVOID			pValue
 	)
 {
 	//
@@ -1199,7 +1179,7 @@ ODM_CmnInfoHook(
 		case	ODM_CMNINFO_MAC_PHY_MODE:
 			pDM_Odm->pMacPhyMode = (u1Byte *)pValue;
 			break;
-		
+
 		case	ODM_CMNINFO_TX_UNI:
 			pDM_Odm->pNumTxBytesUnicast = (u8Byte *)pValue;
 			break;
@@ -1231,7 +1211,7 @@ ODM_CmnInfoHook(
 		case	ODM_CMNINFO_CHNL:
 			pDM_Odm->pChannel = (u1Byte *)pValue;
 			break;
-		
+
 		case	ODM_CMNINFO_DMSP_GET_VALUE:
 			pDM_Odm->pbGetValueFromOtherMac = (BOOLEAN *)pValue;
 			break;
@@ -1291,7 +1271,7 @@ ODM_CmnInfoHook(
 		case 	ODM_CMNINFO_IS1ANTENNA:
 			pDM_Odm->pIs1Antenna = (BOOLEAN *)pValue;
 			break;
-			
+
 		case 	ODM_CMNINFO_RFDEFAULTPATH:
 			pDM_Odm->pRFDefaultPath= (u1Byte *)pValue;
 			break;
@@ -1328,7 +1308,7 @@ ODM_CmnInfoHook(
 		//	break;
 
 		//case	ODM_CMNINFO_BT_COEXIST:
-		//	pDM_Odm->BTCoexist = (BOOLEAN *)pValue;		
+		//	pDM_Odm->BTCoexist = (BOOLEAN *)pValue;
 
 		//case	ODM_CMNINFO_STA_STATUS:
 			//pDM_Odm->pODM_StaInfo[] = (PSTA_INFO_T)pValue;
@@ -1341,7 +1321,7 @@ ODM_CmnInfoHook(
 		//case	ODM_CMNINFO_MAC_STATUS:
 		//	pDM_Odm->pMacInfo = (ODM_MAC_INFO *)pValue;
 		//	break;
-		//To remove the compiler warning, must add an empty default statement to handle the other values.				
+		//To remove the compiler warning, must add an empty default statement to handle the other values.
 		default:
 			//do nothing
 			break;
@@ -1356,7 +1336,7 @@ ODM_CmnInfoPtrArrayHook(
 	IN		PDM_ODM_T		pDM_Odm,
 	IN		ODM_CMNINFO_E	CmnInfo,
 	IN		u2Byte			Index,
-	IN		PVOID			pValue	
+	IN		PVOID			pValue
 	)
 {
 	//
@@ -1366,10 +1346,10 @@ ODM_CmnInfoPtrArrayHook(
 	{
 		//
 		// Dynamic call by reference pointer.
-		//		
+		//
 		case	ODM_CMNINFO_STA_STATUS:
 			pDM_Odm->pODM_StaInfo[Index] = (PSTA_INFO_T)pValue;
-			
+
 			if (IS_STA_VALID(pDM_Odm->pODM_StaInfo[Index]))
 			#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 				pDM_Odm->platform2phydm_macid_table[((PSTA_INFO_T)pValue)->AssociatedMacId] = Index; /*AssociatedMacId are unique bttween different Adapter*/
@@ -1378,14 +1358,14 @@ ODM_CmnInfoPtrArrayHook(
 			#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
 				pDM_Odm->platform2phydm_macid_table[((PSTA_INFO_T)pValue)->mac_id] = Index;
 			#endif
-			
-			break;		
-		//To remove the compiler warning, must add an empty default statement to handle the other values.				
+
+			break;
+		//To remove the compiler warning, must add an empty default statement to handle the other values.
 		default:
 			//do nothing
 			break;
 	}
-	
+
 }
 
 
@@ -1396,7 +1376,7 @@ VOID
 ODM_CmnInfoUpdate(
 	IN		PDM_ODM_T		pDM_Odm,
 	IN		u4Byte			CmnInfo,
-	IN		u8Byte			Value	
+	IN		u8Byte			Value
 	)
 {
 	//
@@ -1407,7 +1387,7 @@ ODM_CmnInfoUpdate(
 		case ODM_CMNINFO_LINK_IN_PROGRESS:
 			pDM_Odm->bLinkInProcess = (BOOLEAN)Value;
 			break;
-		
+
 		case	ODM_CMNINFO_ABILITY:
 			pDM_Odm->SupportAbility = (u4Byte)Value;
 			break;
@@ -1431,7 +1411,7 @@ ODM_CmnInfoUpdate(
 		case	ODM_CMNINFO_STATION_STATE:
 			pDM_Odm->bsta_state = (BOOLEAN)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_RSSI_MIN:
 			pDM_Odm->RSSI_Min= (u1Byte)Value;
 			break;
@@ -1455,30 +1435,30 @@ ODM_CmnInfoUpdate(
 		case ODM_CMNINFO_BT_ENABLED:
 			pDM_Odm->bBtEnabled = (BOOLEAN)Value;
 			break;
-			
+
 		case ODM_CMNINFO_BT_HS_CONNECT_PROCESS:
 			pDM_Odm->bBtConnectProcess = (BOOLEAN)Value;
 			break;
-		
+
 		case ODM_CMNINFO_BT_HS_RSSI:
 			pDM_Odm->btHsRssi = (u1Byte)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_BT_OPERATION:
 			pDM_Odm->bBtHsOperation = (BOOLEAN)Value;
 			break;
 
 		case	ODM_CMNINFO_BT_LIMITED_DIG:
 			pDM_Odm->bBtLimitedDig = (BOOLEAN)Value;
-			break;	
+			break;
 
 		case ODM_CMNINFO_BT_DIG:
 			pDM_Odm->btHsDigVal = (u1Byte)Value;
 			break;
-			
+
 		case	ODM_CMNINFO_BT_BUSY:
 			pDM_Odm->bBtBusy = (BOOLEAN)Value;
-			break;	
+			break;
 
 		case	ODM_CMNINFO_BT_DISABLE_EDCA:
 			pDM_Odm->bBtDisableEdcaTurbo = (BOOLEAN)Value;
@@ -1534,14 +1514,14 @@ ODM_CmnInfoUpdate(
 
 		case	ODM_CMNINFO_CHNL:
 			pDM_Odm->Channel = (u1Byte)Value;
-			break;			
-*/	
+			break;
+*/
                 default:
 			//do nothing
 			break;
 	}
 
-	
+
 }
 
 
@@ -1553,59 +1533,59 @@ ODM_InitAllWorkItems(IN PDM_ODM_T	pDM_Odm )
 	PADAPTER		pAdapter = pDM_Odm->Adapter;
 #if USE_WORKITEM
 	#ifdef CONFIG_S0S1_SW_ANTENNA_DIVERSITY
-	ODM_InitializeWorkItem(	pDM_Odm, 
-							&pDM_Odm->DM_SWAT_Table.phydm_SwAntennaSwitchWorkitem, 
+	ODM_InitializeWorkItem(	pDM_Odm,
+							&pDM_Odm->DM_SWAT_Table.phydm_SwAntennaSwitchWorkitem,
 							(RT_WORKITEM_CALL_BACK)ODM_SW_AntDiv_WorkitemCallback,
 							(PVOID)pAdapter,
 							"AntennaSwitchWorkitem");
 	#endif
 	#ifdef CONFIG_HL_SMART_ANTENNA_TYPE1
-	ODM_InitializeWorkItem(pDM_Odm, 
-						&pDM_Odm->dm_sat_table.hl_smart_antenna_workitem, 
+	ODM_InitializeWorkItem(pDM_Odm,
+						&pDM_Odm->dm_sat_table.hl_smart_antenna_workitem,
 						(RT_WORKITEM_CALL_BACK)phydm_beam_switch_workitem_callback,
 						(PVOID)pAdapter,
 						"hl_smart_ant_workitem");
 
-	ODM_InitializeWorkItem(pDM_Odm, 
-						&pDM_Odm->dm_sat_table.hl_smart_antenna_decision_workitem, 
+	ODM_InitializeWorkItem(pDM_Odm,
+						&pDM_Odm->dm_sat_table.hl_smart_antenna_decision_workitem,
 						(RT_WORKITEM_CALL_BACK)phydm_beam_decision_workitem_callback,
 						(PVOID)pAdapter,
 						"hl_smart_ant_decision_workitem");
 	#endif
-	
+
 	ODM_InitializeWorkItem(
 		pDM_Odm,
-		&(pDM_Odm->PathDivSwitchWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_PathDivChkAntSwitchWorkitemCallback, 
+		&(pDM_Odm->PathDivSwitchWorkitem),
+		(RT_WORKITEM_CALL_BACK)odm_PathDivChkAntSwitchWorkitemCallback,
 		(PVOID)pAdapter,
 		"SWAS_WorkItem");
 
 	ODM_InitializeWorkItem(
 		pDM_Odm,
-		&(pDM_Odm->CCKPathDiversityWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_CCKTXPathDiversityWorkItemCallback, 
+		&(pDM_Odm->CCKPathDiversityWorkitem),
+		(RT_WORKITEM_CALL_BACK)odm_CCKTXPathDiversityWorkItemCallback,
 		(PVOID)pAdapter,
 		"CCKTXPathDiversityWorkItem");
 
 	ODM_InitializeWorkItem(
 		pDM_Odm,
-		&(pDM_Odm->MPT_DIGWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_MPT_DIGWorkItemCallback, 
+		&(pDM_Odm->MPT_DIGWorkitem),
+		(RT_WORKITEM_CALL_BACK)odm_MPT_DIGWorkItemCallback,
 		(PVOID)pAdapter,
 		"MPT_DIGWorkitem");
 
 	ODM_InitializeWorkItem(
 		pDM_Odm,
-		&(pDM_Odm->RaRptWorkitem), 
-		(RT_WORKITEM_CALL_BACK)ODM_UpdateInitRateWorkItemCallback, 
+		&(pDM_Odm->RaRptWorkitem),
+		(RT_WORKITEM_CALL_BACK)ODM_UpdateInitRateWorkItemCallback,
 		(PVOID)pAdapter,
 		"RaRptWorkitem");
 
 #if( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) ) ||( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
 	ODM_InitializeWorkItem(
 		pDM_Odm,
-		&(pDM_Odm->FastAntTrainingWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_FastAntTrainingWorkItemCallback, 
+		&(pDM_Odm->FastAntTrainingWorkitem),
+		(RT_WORKITEM_CALL_BACK)odm_FastAntTrainingWorkItemCallback,
 		(PVOID)pAdapter,
 		"FastAntTrainingWorkitem");
 #endif
@@ -1619,14 +1599,14 @@ ODM_InitAllWorkItems(IN PDM_ODM_T	pDM_Odm )
 		(RT_WORKITEM_CALL_BACK)halComTxbf_EnterWorkItemCallback,
 		(PVOID)pAdapter,
 		"Txbf_EnterWorkItem");
-	
+
 	ODM_InitializeWorkItem(
 		pDM_Odm,
 		&(pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_LeaveWorkItem),
 		(RT_WORKITEM_CALL_BACK)halComTxbf_LeaveWorkItemCallback,
 		(PVOID)pAdapter,
 		"Txbf_LeaveWorkItem");
-	
+
 	ODM_InitializeWorkItem(
 		pDM_Odm,
 		&(pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_FwNdpaWorkItem),
@@ -1700,7 +1680,7 @@ ODM_FreeAllWorkItems(IN PDM_ODM_T	pDM_Odm )
 	ODM_FreeWorkItem(&(pDM_Odm->dm_sat_table.hl_smart_antenna_decision_workitem));
 #endif
 
-	ODM_FreeWorkItem(&(pDM_Odm->PathDivSwitchWorkitem));      
+	ODM_FreeWorkItem(&(pDM_Odm->PathDivSwitchWorkitem));
 	ODM_FreeWorkItem(&(pDM_Odm->CCKPathDiversityWorkitem));
 #if (defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY)) || (defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY))
 	ODM_FreeWorkItem(&(pDM_Odm->FastAntTrainingWorkitem));
@@ -1759,15 +1739,15 @@ odm_IsLinked(
 {
 	u4Byte i;
 	BOOLEAN Linked = FALSE;
-	
+
 	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
 	{
 			if(IS_STA_VALID(pDM_Odm->pODM_StaInfo[i]) )
-			{			
+			{
 				Linked = TRUE;
 				break;
 			}
-		
+
 	}
 
 	pDM_Odm->bLinked = Linked;
@@ -1776,7 +1756,7 @@ odm_IsLinked(
 
 VOID
 ODM_InitAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
+	IN PDM_ODM_T	pDM_Odm
 	)
 {
 #if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
@@ -1785,22 +1765,22 @@ ODM_InitAllTimers(
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_AP)
 #ifdef MP_TEST
-	if (pDM_Odm->priv->pshare->rf_ft_var.mp_specific) 
-		ODM_InitializeTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer, 
-			(RT_TIMER_CALL_BACK)odm_MPT_DIGCallback, NULL, "MPT_DIGTimer");	
+	if (pDM_Odm->priv->pshare->rf_ft_var.mp_specific)
+		ODM_InitializeTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer,
+			(RT_TIMER_CALL_BACK)odm_MPT_DIGCallback, NULL, "MPT_DIGTimer");
 #endif
 #elif(DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer, 
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer,
 		(RT_TIMER_CALL_BACK)odm_MPT_DIGCallback, NULL, "MPT_DIGTimer");
 #endif
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer,
 		(RT_TIMER_CALL_BACK)odm_PathDivChkAntSwitchCallback, NULL, "PathDivTimer");
-	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer, 
-		(RT_TIMER_CALL_BACK)odm_CCKTXPathDiversityCallback, NULL, "CCKPathDiversityTimer"); 
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer,
+		(RT_TIMER_CALL_BACK)odm_CCKTXPathDiversityCallback, NULL, "CCKPathDiversityTimer");
 	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->sbdcnt_timer,
-		(RT_TIMER_CALL_BACK)phydm_sbd_callback, NULL, "SbdTimer"); 
+		(RT_TIMER_CALL_BACK)phydm_sbd_callback, NULL, "SbdTimer");
 #if (BEAMFORMING_SUPPORT == 1)
 	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->BeamformingInfo.TxbfInfo.Txbf_FwNdpaTimer,
 		(RT_TIMER_CALL_BACK)halComTxbf_FwNdpaTimerCallback, NULL, "Txbf_FwNdpaTimer");
@@ -1817,16 +1797,16 @@ ODM_InitAllTimers(
 
 VOID
 ODM_CancelAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
+	IN PDM_ODM_T	pDM_Odm
 	)
 {
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	//
-	// 2012/01/12 MH Temp BSOD fix. We need to find NIC allocate mem fail reason in 
+	// 2012/01/12 MH Temp BSOD fix. We need to find NIC allocate mem fail reason in
 	// win7 platform.
 	//
 	HAL_ADAPTER_STS_CHK(pDM_Odm)
-#endif	
+#endif
 
 #if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
 	ODM_AntDivTimers(pDM_Odm,CANCEL_ANTDIV_TIMMER);
@@ -1862,7 +1842,7 @@ ODM_CancelAllTimers(
 
 VOID
 ODM_ReleaseAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
+	IN PDM_ODM_T	pDM_Odm
 	)
 {
 #if (defined(CONFIG_PHYDM_ANTENNA_DIVERSITY))
@@ -1906,7 +1886,7 @@ ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer);
 #if (DM_ODM_SUPPORT_TYPE == ODM_AP)
 VOID
 ODM_InitAllThreads(
-	IN PDM_ODM_T	pDM_Odm 
+	IN PDM_ODM_T	pDM_Odm
 	)
 {
 	#ifdef TPT_THREAD
@@ -1916,17 +1896,17 @@ ODM_InitAllThreads(
 
 VOID
 ODM_StopAllThreads(
-	IN PDM_ODM_T	pDM_Odm 
+	IN PDM_ODM_T	pDM_Odm
 	)
 {
 	#ifdef TPT_THREAD
 	kTPT_task_stop(pDM_Odm->priv);
 	#endif
 }
-#endif	
+#endif
 
 
-#if( DM_ODM_SUPPORT_TYPE == ODM_WIN) 
+#if( DM_ODM_SUPPORT_TYPE == ODM_WIN)
 //
 // 2011/07/26 MH Add an API for testing IQK fail case.
 //
@@ -1941,19 +1921,17 @@ ODM_CheckPowerStatus(
 	PMGNT_INFO			pMgntInfo	= &(Adapter->MgntInfo);
 
 	// 2011/07/27 MH We are not testing ready~~!! We may fail to get correct value when init sequence.
-	if (pMgntInfo->init_adpt_in_progress == TRUE)
-	{
+	if (pMgntInfo->init_adpt_in_progress == TRUE){
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ODM_CheckPowerStatus Return TRUE, due to initadapter\n"));
 		return	TRUE;
 	}
-	
+
 	//
 	//	2011/07/19 MH We can not execute tx pwoer tracking/ LLC calibrate or IQK.
 	//
-	Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));	
-	if(Adapter->bDriverStopped || Adapter->bDriverIsGoingToPnpSetPowerSleep || rtState == eRfOff)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n", 
+	Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));
+	if (Adapter->bDriverStopped || Adapter->bDriverIsGoingToPnpSetPowerSleep || rtState == eRfOff) {
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n",
 		Adapter->bDriverStopped, Adapter->bDriverIsGoingToPnpSetPowerSleep, rtState));
 		return	FALSE;
 	}
@@ -1980,10 +1958,10 @@ ODM_CheckPowerStatus(
 	//
 	//	2011/07/19 MH We can not execute tx pwoer tracking/ LLC calibrate or IQK.
 	//
-	Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));	
+	Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));
 	if(Adapter->bDriverStopped || Adapter->bDriverIsGoingToPnpSetPowerSleep || rtState == eRfOff)
 	{
-	ODM_RT_TRACE(pDM_Odm,COMP_INIT, DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n", 
+	ODM_RT_TRACE(pDM_Odm,COMP_INIT, DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n",
 	Adapter->bDriverStopped, Adapter->bDriverIsGoingToPnpSetPowerSleep, rtState));
 	return	FALSE;
 	}
@@ -2005,7 +1983,7 @@ GetPSDData(
 	//unsigned int	val, rfval;
 	//int	psd_report;
 	u4Byte	psd_report;
-	
+
 	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
 	//Debug Message
 	//val = PHY_QueryBBReg(Adapter,0x908, bMaskDWord);
@@ -2026,7 +2004,7 @@ GetPSDData(
 	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 0);
 	//Read PSD report, Reg8B4[15:0]
 	psd_report = ODM_GetBBReg(pDM_Odm,0x8B4, bMaskDWord) & 0x0000FFFF;
-	
+
 #if 1//(DEV_BUS_TYPE == RT_PCI_INTERFACE) && ( (RT_PLATFORM == PLATFORM_LINUX) || (RT_PLATFORM == PLATFORM_MACOSX))
 	psd_report = (u4Byte) (odm_ConvertTo_dB(psd_report))+(u4Byte)(initial_gain_psd-0x1c);
 #else
@@ -2034,11 +2012,11 @@ GetPSDData(
 #endif
 
 	return psd_report;
-	
+
 }
 #endif
 
-u4Byte 
+u4Byte
 odm_ConvertTo_dB(
 	u4Byte 	Value)
 {
@@ -2048,23 +2026,18 @@ odm_ConvertTo_dB(
 
 	Value = Value & 0xFFFF;
 
-	for (i = 0; i < 12; i++)
-	{
-		if (Value <= dB_Invert_Table[i][7])
-		{
+	for (i = 0; i < 12; i++) {
+		if (Value <= dB_Invert_Table[i][7]) {
 			break;
 		}
 	}
 
-	if (i >= 12)
-	{
+	if (i >= 12) {
 		return (96);	// maximum 96 dB
 	}
 
-	for (j = 0; j < 8; j++)
-	{
-		if (Value <= dB_Invert_Table[i][j])
-		{
+	for (j = 0; j < 8; j++) {
+		if (Value <= dB_Invert_Table[i][j]) {
 			break;
 		}
 	}
@@ -2074,16 +2047,16 @@ odm_ConvertTo_dB(
 	return (dB);
 }
 
-u4Byte 
+u4Byte
 odm_ConvertTo_linear(
 	u4Byte 	Value)
 {
 	u1Byte i;
 	u1Byte j;
 	u4Byte linear;
-	
+
 	/* 1dB~96dB */
-	
+
 	Value = Value & 0xFF;
 
 	i = (u1Byte)((Value - 1) >> 3);
@@ -2112,22 +2085,20 @@ ODM_AsocEntry_Init(
 
 	ODM_CmnInfoPtrArrayHook(pDM_OutSrc, ODM_CMNINFO_STA_STATUS, 0, &pLoopAdapter->MgntInfo.DefaultPort[0]);
 	pLoopAdapter->MgntInfo.DefaultPort[0].MultiPortStationIdx = TotalAssocEntryNum;
-		
+
 	adaptercount += 1;
-	RT_TRACE(COMP_INIT, DBG_LOUD, ("adaptercount=%d\n", adaptercount));	
+	RT_TRACE(COMP_INIT, DBG_LOUD, ("adaptercount=%d\n", adaptercount));
 	pLoopAdapter = GetNextExtAdapter(pLoopAdapter);
 	TotalAssocEntryNum +=1;
 
-	while(pLoopAdapter)
-	{
-		for (index = 0; index <ASSOCIATE_ENTRY_NUM; index++)
-		{
+	while (pLoopAdapter) {
+		for (index = 0; index <ASSOCIATE_ENTRY_NUM; index++) {
 			ODM_CmnInfoPtrArrayHook(pDM_OutSrc, ODM_CMNINFO_STA_STATUS, TotalAssocEntryNum+index, &pLoopAdapter->MgntInfo.AsocEntry[index]);
-			pLoopAdapter->MgntInfo.AsocEntry[index].MultiPortStationIdx = TotalAssocEntryNum+index;				
+			pLoopAdapter->MgntInfo.AsocEntry[index].MultiPortStationIdx = TotalAssocEntryNum+index;
 		}
-		
+
 		TotalAssocEntryNum+= index;
-		if(IS_HARDWARE_TYPE_8188E((pDM_Odm->Adapter)))
+		if (IS_HARDWARE_TYPE_8188E((pDM_Odm->Adapter)))
 			pLoopAdapter->RASupport = TRUE;
 		adaptercount += 1;
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("adaptercount=%d\n", adaptercount));
@@ -2136,7 +2107,7 @@ ODM_AsocEntry_Init(
 
 	RT_TRACE(COMP_INIT, DBG_LOUD, ("TotalAssocEntryNum = %d\n", TotalAssocEntryNum));
 	if (TotalAssocEntryNum < (ODM_ASSOCIATE_ENTRY_NUM-1)) {
-	
+
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("In hook null\n"));
 		for (index = TotalAssocEntryNum; index < ODM_ASSOCIATE_ENTRY_NUM; index++)
 			ODM_CmnInfoPtrArrayHook(pDM_OutSrc, ODM_CMNINFO_STA_STATUS, index, NULL);
@@ -2191,8 +2162,7 @@ void odm_dtc(PDM_ODM_T pDM_Odm)
 	if (DTC_BASE < pDM_Odm->RSSI_Min) {
 		/* need to decade the CTS TX power */
 		sign = 1;
-		for (i=0;i<ARRAY_SIZE(dtc_table_down);i++)
-		{
+		for (i=0;i<ARRAY_SIZE(dtc_table_down);i++) {
 			if ((dtc_table_down[i] >= pDM_Odm->RSSI_Min) || (dtc_steps >= 6))
 				break;
 			else
@@ -2200,13 +2170,11 @@ void odm_dtc(PDM_ODM_T pDM_Odm)
 		}
 	}
 #if 0
-	else if (DTC_DWN_BASE > pDM_Odm->RSSI_Min)
-	{
+	else if (DTC_DWN_BASE > pDM_Odm->RSSI_Min) {
 		/* needs to increase the CTS TX power */
 		sign = 0;
 		dtc_steps = 1;
-		for (i=0;i<ARRAY_SIZE(dtc_table_up);i++)
-		{
+		for (i=0;i<ARRAY_SIZE(dtc_table_up);i++) {
 			if ((dtc_table_up[i] <= pDM_Odm->RSSI_Min) || (dtc_steps>=10))
 				break;
 			else
@@ -2241,21 +2209,19 @@ odm_UpdatePowerTrainingState(
 	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
 	u4Byte						score = 0;
 
-	if(!(pDM_Odm->SupportAbility & ODM_BB_PWR_TRAIN))
+	if (!(pDM_Odm->SupportAbility & ODM_BB_PWR_TRAIN))
 		return;
 
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState()============>\n"));
 	pDM_Odm->bChangeState = FALSE;
 
 	// Debug command
-	if(pDM_Odm->ForcePowerTrainingState)
-	{
-		if(pDM_Odm->ForcePowerTrainingState == 1 && !pDM_Odm->bDisablePowerTraining)
-		{
+	if (pDM_Odm->ForcePowerTrainingState) {
+		if (pDM_Odm->ForcePowerTrainingState == 1 && !pDM_Odm->bDisablePowerTraining) {
 			pDM_Odm->bChangeState = TRUE;
 			pDM_Odm->bDisablePowerTraining = TRUE;
 		}
-		else if(pDM_Odm->ForcePowerTrainingState == 2 && pDM_Odm->bDisablePowerTraining)
+		else if (pDM_Odm->ForcePowerTrainingState == 2 && pDM_Odm->bDisablePowerTraining)
 		{
 			pDM_Odm->bChangeState = TRUE;
 			pDM_Odm->bDisablePowerTraining = FALSE;
@@ -2268,13 +2234,12 @@ odm_UpdatePowerTrainingState(
 			pDM_Odm->ForcePowerTrainingState));
 		return;
 	}
-	
-	if(!pDM_Odm->bLinked)
+
+	if (!pDM_Odm->bLinked)
 		return;
-	
+
 	// First connect
-	if((pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE))
-	{
+	if ((pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE)) {
 		pDM_Odm->PT_score = 0;
 		pDM_Odm->bChangeState = TRUE;
 		pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = 0;
@@ -2284,54 +2249,48 @@ odm_UpdatePowerTrainingState(
 	}
 
 	// Compute score
-	if(pDM_Odm->NHM_cnt_0 >= 215)
+	if (pDM_Odm->NHM_cnt_0 >= 215)
 		score = 2;
-	else if(pDM_Odm->NHM_cnt_0 >= 190) 
+	else if (pDM_Odm->NHM_cnt_0 >= 190)
 		score = 1;							// unknow state
-	else
-	{
+	else {
 		u4Byte	RX_Pkt_Cnt;
-		
+
 		RX_Pkt_Cnt = (u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM) + (u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK);
-		
-		if((FalseAlmCnt->Cnt_CCA_all > 31 && RX_Pkt_Cnt > 31) && (FalseAlmCnt->Cnt_CCA_all >= RX_Pkt_Cnt))
-		{
-			if((RX_Pkt_Cnt + (RX_Pkt_Cnt >> 1)) <= FalseAlmCnt->Cnt_CCA_all)
+
+		if ((FalseAlmCnt->Cnt_CCA_all > 31 && RX_Pkt_Cnt > 31) && (FalseAlmCnt->Cnt_CCA_all >= RX_Pkt_Cnt)) {
+			if ((RX_Pkt_Cnt + (RX_Pkt_Cnt >> 1)) <= FalseAlmCnt->Cnt_CCA_all)
 				score = 0;
-			else if((RX_Pkt_Cnt + (RX_Pkt_Cnt >> 2)) <= FalseAlmCnt->Cnt_CCA_all)
+			else if ((RX_Pkt_Cnt + (RX_Pkt_Cnt >> 2)) <= FalseAlmCnt->Cnt_CCA_all)
 				score = 1;
 			else
 				score = 2;
 		}
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): RX_Pkt_Cnt = %d, Cnt_CCA_all = %d\n", 
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): RX_Pkt_Cnt = %d, Cnt_CCA_all = %d\n",
 			RX_Pkt_Cnt, FalseAlmCnt->Cnt_CCA_all));
 	}
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): NumQryPhyStatusOFDM = %d, NumQryPhyStatusCCK = %d\n",
 			(u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM), (u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK)));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): NHM_cnt_0 = %d, score = %d\n", 
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): NHM_cnt_0 = %d, score = %d\n",
 		pDM_Odm->NHM_cnt_0, score));
 
 	// smoothing
 	pDM_Odm->PT_score = (score << 4) + (pDM_Odm->PT_score>>1) + (pDM_Odm->PT_score>>2);
 	score = (pDM_Odm->PT_score + 32) >> 6;
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): PT_score = %d, score after smoothing = %d\n", 
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): PT_score = %d, score after smoothing = %d\n",
 		pDM_Odm->PT_score, score));
 
 	// Mode decision
-	if(score == 2)
-	{
-		if(pDM_Odm->bDisablePowerTraining)
-		{
+	if (score == 2) {
+		if (pDM_Odm->bDisablePowerTraining) {
 			pDM_Odm->bChangeState = TRUE;
 			pDM_Odm->bDisablePowerTraining = FALSE;
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Change state\n"));
 		}
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Enable Power Training\n"));
 	}
-	else if(score == 0)
-	{
-		if(!pDM_Odm->bDisablePowerTraining)
-		{
+	else if (score == 0) {
+		if (!pDM_Odm->bDisablePowerTraining) {
 			pDM_Odm->bChangeState = TRUE;
 			pDM_Odm->bDisablePowerTraining = TRUE;
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Change state\n"));
@@ -2358,14 +2317,14 @@ u1Byte GetRightChnlPlaceforIQK(u1Byte chnl)
 		102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 149, 151, 153, 155, 157, 159, 161, 163, 165};
 	u1Byte	place = chnl;
 
-	
+
 	if (chnl > 14) {
 		for (place = 14; place < sizeof(channel_all); place++) {
 			if (channel_all[place] == chnl)
 				return place-13;
 		}
 	}
-	
+
 	return 0;
 }
 
@@ -2379,17 +2338,17 @@ phydm_NoisyDetection(
 {
 	u4Byte  Total_FA_Cnt, Total_CCA_Cnt;
 	u4Byte  Score = 0, i, Score_Smooth;
-    
+
 	Total_CCA_Cnt = pDM_Odm->FalseAlmCnt.Cnt_CCA_all;
-	Total_FA_Cnt  = pDM_Odm->FalseAlmCnt.Cnt_all;    
+	Total_FA_Cnt  = pDM_Odm->FalseAlmCnt.Cnt_all;
 
 /*
     if( Total_FA_Cnt*16>=Total_CCA_Cnt*14 )         // 87.5
-    
+
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*12 )    // 75
-    
+
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*10 )    // 56.25
-    
+
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*8 )     // 50
 
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*7 )     // 43.75
@@ -2397,7 +2356,7 @@ phydm_NoisyDetection(
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*6 )     // 37.5
 
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*5 )     // 31.25%
-        
+
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*4 )     // 25%
 
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*3 )     // 18.75%
@@ -2406,10 +2365,8 @@ phydm_NoisyDetection(
 
     else if( Total_FA_Cnt*16>=Total_CCA_Cnt*1 )     // 6.25%
 */
-    for(i=0;i<=16;i++)
-    {
-        if( Total_FA_Cnt*16>=Total_CCA_Cnt*(16-i) )
-        {
+    for (i=0;i<=16;i++) {
+        if ( Total_FA_Cnt*16>=Total_CCA_Cnt*(16-i) ) {
             Score = 16-i;
             break;
         }
@@ -2487,7 +2444,7 @@ phydm_NoisyDetection(
             break;
         case 15:
             ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
-            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=93.75%%\n"));            
+            ("[NoisyDetection] Total_FA_Cnt/Total_CCA_Cnt=93.75%%\n"));
             break;
         case 16:
             ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
@@ -2495,13 +2452,13 @@ phydm_NoisyDetection(
             break;
         default:
             ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,
-            ("[NoisyDetection] Unknown Value!! Need Check!!\n"));            
+            ("[NoisyDetection] Unknown Value!! Need Check!!\n"));
     }
-*/        
+*/
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_NOISY_DETECT, ODM_DBG_LOUD,
 	("[NoisyDetection] Total_CCA_Cnt=%d, Total_FA_Cnt=%d, NoisyDecision_Smooth=%d, Score=%d, Score_Smooth=%d, pDM_Odm->NoisyDecision=%d\n",
 	Total_CCA_Cnt, Total_FA_Cnt, pDM_Odm->NoisyDecision_Smooth, Score, Score_Smooth, pDM_Odm->NoisyDecision));
-	
+
 }
 
 VOID
@@ -2514,18 +2471,18 @@ phydm_csi_mask_enable(
 	u4Byte		reg_value = 0;
 
 	reg_value = (enable == CSI_MASK_ENABLE) ? 1 : 0;
-	
+
 	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
 
 		ODM_SetBBReg(pDM_Odm, 0xD2C, BIT28, reg_value);
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_API, ODM_DBG_LOUD, ("Enable CSI Mask:  Reg 0xD2C[28] = ((0x%x))\n", reg_value));
-		
+
 	} else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
 
 		ODM_SetBBReg(pDM_Odm, 0x874, BIT0, reg_value);
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_API, ODM_DBG_LOUD, ("Enable CSI Mask:  Reg 0x874[0] = ((0x%x))\n", reg_value));
 	}
-	
+
 }
 
 VOID
@@ -2536,14 +2493,14 @@ phydm_clean_all_csi_mask(
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
 	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
-		
+
 		ODM_SetBBReg(pDM_Odm, 0xD40, bMaskDWord, 0);
 		ODM_SetBBReg(pDM_Odm, 0xD44, bMaskDWord, 0);
 		ODM_SetBBReg(pDM_Odm, 0xD48, bMaskDWord, 0);
 		ODM_SetBBReg(pDM_Odm, 0xD4c, bMaskDWord, 0);
-		
+
 	} else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
-	
+
 		ODM_SetBBReg(pDM_Odm, 0x880, bMaskDWord, 0);
 		ODM_SetBBReg(pDM_Odm, 0x884, bMaskDWord, 0);
 		ODM_SetBBReg(pDM_Odm, 0x888, bMaskDWord, 0);
@@ -2580,37 +2537,37 @@ phydm_set_csi_mask_reg(
 
 		tone_num = 64;
 		csi_mask_reg_p = 0xD40;
-		csi_mask_reg_n = 0xD48;		
-		
+		csi_mask_reg_n = 0xD48;
+
 	} else if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {
 
 		tone_num = 128;
 		csi_mask_reg_p = 0x880;
-		csi_mask_reg_n = 0x890;	
+		csi_mask_reg_n = 0x890;
 	}
-	
+
 	if (tone_direction == FREQ_POSITIVE) {
 
 		if (tone_idx_tmp >= (tone_num - 1))
 			tone_idx_tmp = (tone_num - 1);
-		
+
 		byte_offset = (u1Byte)(tone_idx_tmp >> 3);
 		bit_offset = (u1Byte)(tone_idx_tmp & 0x7);
 		target_reg = csi_mask_reg_p + byte_offset;
-		
+
 	} else {
 		tone_num_shift = tone_num;
-	
+
 		if (tone_idx_tmp >= tone_num)
 			tone_idx_tmp = tone_num;
 
 		tone_idx_tmp = tone_num - tone_idx_tmp;
-		
+
 		byte_offset = (u1Byte)(tone_idx_tmp >> 3);
-		bit_offset = (u1Byte)(tone_idx_tmp & 0x7);			
+		bit_offset = (u1Byte)(tone_idx_tmp & 0x7);
 		target_reg = csi_mask_reg_n + byte_offset;
 	}
-	
+
 	reg_tmp_value = ODM_Read1Byte(pDM_Odm, target_reg);
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_API, ODM_DBG_LOUD, ("Pre Mask tone idx[%d]:  Reg0x%x = ((0x%x))\n", (tone_idx_tmp + tone_num_shift), target_reg, reg_tmp_value));
 	reg_tmp_value |= BIT(bit_offset);
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/phydm_beamforming.c b/drivers/net/wireless/rtl8814au/hal/phydm/phydm_beamforming.c
index 1078cc9..c6fdd26 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/phydm_beamforming.c
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/phydm_beamforming.c
@@ -25,7 +25,7 @@ phydm_staInfoInit(
 	PRT_VERY_HIGH_THROUGHPUT	pVHTInfo = GET_VHT_INFO(pMgntInfo);
 
 	ODM_MoveMemory(pDM_Odm, pEntry->MyMacAddr, Adapter->CurrentAddress, 6);
-	
+
 	pEntry->HtBeamformCap = pHTInfo->HtBeamformCap;
 	pEntry->VhtBeamformCap = pVHTInfo->VhtBeamformCap;
 
@@ -44,15 +44,15 @@ phydm_staInfoInit(
 		pEntry->WirelessMode = pMgntInfo->dot11CurrentWirelessMode;
 		pEntry->BW = pMgntInfo->dot11CurrentChannelBandWidth;
 		pEntry->CurBeamform = pHTInfo->HtCurBeamform;
-	}	
+	}
 
 	if ((pEntry->WirelessMode & WIRELESS_MODE_AC_5G) || (pEntry->WirelessMode & WIRELESS_MODE_AC_24G)) {
 		if (staIdx != 0)
 			pEntry->CurBeamformVHT = pSTA->VHTInfo.VhtCurBeamform;
 		else
-			pEntry->CurBeamformVHT = pVHTInfo->VhtCurBeamform;	
+			pEntry->CurBeamformVHT = pVHTInfo->VhtCurBeamform;
 		}
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("pSTA->wireless_mode = 0x%x, staidx = %d\n", pSTA->WirelessMode, staIdx));
 #elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
 
@@ -91,16 +91,16 @@ void phydm_staInfoUpdate(
 	)
 {
 	PSTA_INFO_T pSTA = pDM_Odm->pODM_StaInfo[staIdx];
-	
+
 	if (!IS_STA_VALID(pSTA))
 		return;
-	
+
 #if (DM_ODM_SUPPORT_TYPE == ODM_CE)
 	pSTA->txbf_paid = pBeamformEntry->P_AID;
 	pSTA->txbf_gid = pBeamformEntry->G_ID;
-#endif	
+#endif
 }
-	
+
 
 u1Byte
 Beamforming_GetHTNDPTxRate(
@@ -112,12 +112,12 @@ Beamforming_GetHTNDPTxRate(
 	u1Byte Nr_index = 0;
 	u1Byte NDPTxRate;
 	/*Find Nr*/
-	
+
 	if (pDM_Odm->SupportICType & ODM_RTL8814A)
 		Nr_index = TxBF_Nr(halTxbf8814A_GetNtx(pDM_Odm), CompSteeringNumofBFer);
 	else
 		Nr_index = TxBF_Nr(1, CompSteeringNumofBFer);
-	
+
 	switch (Nr_index) {
 	case 1:
 	NDPTxRate = MGN_MCS8;
@@ -130,7 +130,7 @@ Beamforming_GetHTNDPTxRate(
 	case 3:
 	NDPTxRate = MGN_MCS24;
 	break;
-			
+
 	default:
 	NDPTxRate = MGN_MCS8;
 	break;
@@ -154,7 +154,7 @@ Beamforming_GetVHTNDPTxRate(
 		Nr_index = TxBF_Nr(halTxbf8814A_GetNtx(pDM_Odm), CompSteeringNumofBFer);
 	else
 		Nr_index = TxBF_Nr(1, CompSteeringNumofBFer);
-	
+
 	switch (Nr_index) {
 	case 1:
 	NDPTxRate = MGN_VHT2SS_MCS0;
@@ -167,7 +167,7 @@ Beamforming_GetVHTNDPTxRate(
 	case 3:
 	NDPTxRate = MGN_VHT4SS_MCS0;
 	break;
-			
+
 	default:
 	NDPTxRate = MGN_VHT2SS_MCS0;
 	break;
@@ -188,7 +188,7 @@ phydm_Beamforming_GetBFeeEntryByAddr(
 	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	u1Byte	i = 0;
 	PRT_BEAMFORMING_INFO pBeamInfo = &pDM_Odm->BeamformingInfo;
-	
+
 	for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
 		if (pBeamInfo->BeamformeeEntry[i].bUsed && (eqMacAddr(RA, pBeamInfo->BeamformeeEntry[i].MacAddr))) {
 			*Idx = i;
@@ -209,7 +209,7 @@ phydm_Beamforming_GetBFerEntryByAddr(
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	u1Byte		i = 0;
 	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
-	
+
 	for (i = 0; i < BEAMFORMER_ENTRY_NUM; i++) {
 		if (pBeamInfo->BeamformerEntry[i].bUsed &&  (eqMacAddr(TA, pBeamInfo->BeamformerEntry[i].MacAddr))) {
 			*Idx = i;
@@ -231,7 +231,7 @@ phydm_Beamforming_GetEntryByMacId(
 	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	u1Byte	i = 0;
 	PRT_BEAMFORMING_INFO pBeamInfo = &pDM_Odm->BeamformingInfo;
-	
+
 	for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
 		if (pBeamInfo->BeamformeeEntry[i].bUsed && (MacId == pBeamInfo->BeamformeeEntry[i].MacId)) {
 			*Idx = i;
@@ -253,7 +253,7 @@ phydm_Beamforming_GetEntryBeamCapByMacId(
 	u1Byte	i = 0;
 	PRT_BEAMFORMING_INFO	pBeamInfo = &pDM_Odm->BeamformingInfo;
 	BEAMFORMING_CAP			BeamformEntryCap = BEAMFORMING_CAP_NONE;
-	
+
 	for (i = 0; i < BEAMFORMEE_ENTRY_NUM; i++) {
 		if (pBeamInfo->BeamformeeEntry[i].bUsed && (MacId == pBeamInfo->BeamformeeEntry[i].MacId)) {
 			BeamformEntryCap =  pBeamInfo->BeamformeeEntry[i].BeamformEntryCap;
@@ -279,7 +279,7 @@ phydm_Beamforming_GetFreeBFeeEntry(
 		if (pBeamInfo->BeamformeeEntry[i].bUsed == FALSE) {
 			*Idx = i;
 			return &(pBeamInfo->BeamformeeEntry[i]);
-		}	
+		}
 	}
 	return NULL;
 }
@@ -300,7 +300,7 @@ phydm_Beamforming_GetFreeBFerEntry(
 		if (pBeamInfo->BeamformerEntry[i].bUsed == FALSE) {
 			*Idx = i;
 			return &(pBeamInfo->BeamformerEntry[i]);
-		}	
+		}
 	}
 	return NULL;
 }
@@ -324,11 +324,11 @@ phydm_Beamforming_GetFirstMUBFeeEntryIdx(
 	BOOLEAN					bFound = FALSE;
 
 	for (idx = 0; idx < BEAMFORMEE_ENTRY_NUM; idx++) {
-		if (pBeamInfo->BeamformeeEntry[idx].bUsed && pBeamInfo->BeamformeeEntry[idx].is_mu_sta) {			
+		if (pBeamInfo->BeamformeeEntry[idx].bUsed && pBeamInfo->BeamformeeEntry[idx].is_mu_sta) {
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] idx=%d!\n", __func__, idx));
 			bFound = TRUE;
 			break;
-		}	
+		}
 	}
 
 	if (!bFound)
@@ -354,13 +354,13 @@ Beamforming_AddBFeeEntry(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
 
-	if (pEntry != NULL) {	
+	if (pEntry != NULL) {
 		pEntry->bUsed = TRUE;
 		pEntry->AID = pSTA->AID;
 		pEntry->MacId = pSTA->MacID;
 		pEntry->SoundBW = pSTA->BW;
 		ODM_MoveMemory(pDM_Odm, pEntry->MyMacAddr, pSTA->MyMacAddr, 6);
-		
+
 		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_AP)) {
 			/*BSSID[44:47] xor BSSID[40:43]*/
 			u2Byte BSSID = ((pSTA->MyMacAddr[5] & 0xf0) >> 4) ^ (pSTA->MyMacAddr[5] & 0xf);
@@ -433,7 +433,7 @@ Beamforming_AddBFerEntry(
 		if (phydm_actingDetermine(pDM_Odm, PhyDM_ACTING_AS_AP)) {
 			/*BSSID[44:47] xor BSSID[40:43]*/
 			u2Byte BSSID = ((pSTA->MyMacAddr[5] & 0xf0) >> 4) ^ (pSTA->MyMacAddr[5] & 0xf);
-			
+
 			pEntry->P_AID = (pSTA->AID + BSSID * 32) & 0x1ff;
 			pEntry->G_ID = 63;
 			/*(dec(A) + dec(B)*32) mod 512*/
@@ -447,7 +447,7 @@ Beamforming_AddBFerEntry(
 			pEntry->G_ID = 0;
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: P_AID addressed to AP=0x%X\n", __func__, pEntry->P_AID));
 		}
-		
+
 		cpMacAddr(pEntry->MacAddr, pSTA->RA);
 		pEntry->BeamformEntryCap = BeamformCap;
 
@@ -488,18 +488,18 @@ Beamforming_RemoveEntry(
 	PRT_BEAMFORMER_ENTRY	pBFerEntry = phydm_Beamforming_GetBFerEntryByAddr(pDM_Odm, RA, Idx);
 	PRT_BEAMFORMEE_ENTRY	pEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, Idx);
 	BOOLEAN ret = FALSE;
-    
+
 	RT_DISP(FBEAM, FBEAM_FUN, ("[Beamforming]@%s Start!\n", __func__));
 	RT_DISP(FBEAM, FBEAM_FUN, ("[Beamforming]@%s, pBFerEntry=0x%x\n", __func__, pBFerEntry));
 	RT_DISP(FBEAM, FBEAM_FUN, ("[Beamforming]@%s, pEntry=0x%x\n", __func__, pEntry));
-	
-	if (pEntry != NULL) {	
+
+	if (pEntry != NULL) {
 		pEntry->bUsed = FALSE;
 		pEntry->BeamformEntryCap = BEAMFORMING_CAP_NONE;
 		/*pEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_UNINITIALIZE;*/
 		pEntry->bBeamformingInProgress = FALSE;
 		ret = TRUE;
-	} 
+	}
 	if (pBFerEntry != NULL) {
 		pBFerEntry->bUsed = FALSE;
 		pBFerEntry->BeamformEntryCap = BEAMFORMING_CAP_NONE;
@@ -514,13 +514,13 @@ Beamforming_RemoveEntry(
 VOID
 phydm_Beamforming_NDPARate(
 	IN	PVOID		pDM_VOID,
-	CHANNEL_WIDTH 	BW, 
+	CHANNEL_WIDTH 	BW,
 	u1Byte			Rate
 )
 {
 	u2Byte			NDPARate = Rate;
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
 
 	if (NDPARate == 0) {
@@ -561,9 +561,9 @@ phydm_Beamforming_DymNDPARate(
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s End, NDPA Rate = 0x%X\n", __func__, NDPARate));
 }
 
-/*	
-*	SW Sounding : SW Timer unit 1ms 
-*				 HW Timer unit (1/32000) s  32k is clock. 
+/*
+*	SW Sounding : SW Timer unit 1ms
+*				 HW Timer unit (1/32000) s  32k is clock.
 *	FW Sounding : FW Timer unit 10ms
 */
 VOID
@@ -573,7 +573,7 @@ Beamforming_DymPeriod(
 )
 {
 	u1Byte 					Idx;
-	BOOLEAN					bChangePeriod = FALSE;	
+	BOOLEAN					bChangePeriod = FALSE;
 	u2Byte					SoundPeriod_SW, SoundPeriod_FW;
 	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
@@ -584,7 +584,7 @@ Beamforming_DymPeriod(
 	PRT_BEAMFORMEE_ENTRY	pEntry = &(pBeamInfo->BeamformeeEntry[pBeamInfo->BeamformeeCurIdx]);
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
-	
+
 	//3 TODO  per-client throughput caculation.
 
 	if ((*(pDM_Odm->pCurrentTxTP) + *(pDM_Odm->pCurrentRxTP) > 2) && ((pEntry->LogStatusFailCnt <= 20) || status)) {
@@ -598,16 +598,16 @@ Beamforming_DymPeriod(
 
 	for (Idx = 0; Idx < BEAMFORMEE_ENTRY_NUM; Idx++) {
 		pBeamformEntry = pBeamInfo->BeamformeeEntry+Idx;
-		
+
 		if (pBeamformEntry->DefaultCSICnt > 20) {
 			/*Modified by David*/
 			SoundPeriod_SW = 4000;
 			SoundPeriod_FW = 400;
 		}
-		
-		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Period = %d\n", __func__, SoundPeriod_SW));		
+
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Period = %d\n", __func__, SoundPeriod_SW));
 		if (pBeamformEntry->BeamformEntryCap & (BEAMFORMER_CAP_HT_EXPLICIT | BEAMFORMER_CAP_VHT_SU)) {
-			if (pSoundInfo->SoundMode == SOUNDING_FW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_FW_HT_TIMER) {				
+			if (pSoundInfo->SoundMode == SOUNDING_FW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_FW_HT_TIMER) {
 				if (pBeamformEntry->SoundPeriod != SoundPeriod_FW) {
 					pBeamformEntry->SoundPeriod = SoundPeriod_FW;
 					bChangePeriod = TRUE;		/*Only FW sounding need to send H2C packet to change sound period. */
@@ -623,8 +623,6 @@ Beamforming_DymPeriod(
 }
 
 
-
-
 BOOLEAN
 Beamforming_SendHTNDPAPacket(
 	IN	PVOID			pDM_VOID,
@@ -645,7 +643,6 @@ Beamforming_SendHTNDPAPacket(
 }
 
 
-
 BOOLEAN
 Beamforming_SendVHTNDPAPacket(
 	IN	PVOID			pDM_VOID,
@@ -780,7 +777,7 @@ phydm_beamforming_SoundingMode(
 	if (BeamOidInfo.SoundOidMode == SOUNDING_SW_VHT_TIMER || BeamOidInfo.SoundOidMode == SOUNDING_HW_VHT_TIMER) {
 		if (BeamEntry.BeamformEntryCap & BEAMFORMER_CAP_VHT_SU)
 			Mode = BeamOidInfo.SoundOidMode;
-		else 
+		else
 			Mode = SOUNDING_STOP_All_TIMER;
 	} else if (BeamOidInfo.SoundOidMode == SOUNDING_SW_HT_TIMER || BeamOidInfo.SoundOidMode == SOUNDING_HW_HT_TIMER) {
 		if (BeamEntry.BeamformEntryCap & BEAMFORMER_CAP_HT_EXPLICIT)
@@ -797,7 +794,7 @@ phydm_beamforming_SoundingMode(
 			Mode = SOUNDING_FW_HT_TIMER;
 		else
 			Mode = SOUNDING_SW_HT_TIMER;
-	} else 
+	} else
 		Mode = SOUNDING_STOP_All_TIMER;
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SupportInterface=%d, Mode=%d\n", __func__, SupportInterface, Mode));
@@ -851,7 +848,7 @@ phydm_beamforming_SoundingBW(
 	else if (Mode == SOUNDING_SW_HT_TIMER || Mode == SOUNDING_SW_VHT_TIMER)
 		/*Modified by David*/
 		SoundingBW = BeamEntry.SoundBW;		/*BeamOidInfo.SoundOidBW;*/
-	else 
+	else
 		SoundingBW = BeamEntry.SoundBW;
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, SoundingBW=0x%X\n", __func__, SoundingBW));
@@ -878,7 +875,7 @@ phydm_Beamforming_SelectBeamEntry(
 		pSoundInfo->SoundMode = phydm_beamforming_SoundingMode(pDM_Odm, pBeamInfo, pSoundInfo->SoundIdx);
 	else
 		pSoundInfo->SoundMode = SOUNDING_STOP_All_TIMER;
-	
+
 	if (SOUNDING_STOP_All_TIMER == pSoundInfo->SoundMode) {
 		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Return because of SOUNDING_STOP_All_TIMER\n", __func__));
 		return FALSE;
@@ -899,8 +896,8 @@ phydm_beamforming_StartPeriod(
 	PADAPTER					Adapter = pDM_Odm->Adapter;
 	BOOLEAN						Ret = TRUE;
 	PRT_BEAMFORMING_INFO 		pBeamInfo = &pDM_Odm->BeamformingInfo;
-	PRT_SOUNDING_INFO			pSoundInfo = &(pBeamInfo->SoundingInfo); 
-	
+	PRT_SOUNDING_INFO			pSoundInfo = &(pBeamInfo->SoundingInfo);
+
 	phydm_Beamforming_DymNDPARate(pDM_Odm);
 
 	phydm_Beamforming_SelectBeamEntry(pDM_Odm, pBeamInfo);		// Modified
@@ -927,7 +924,7 @@ phydm_beamforming_StartPeriod(
 	else
 		Ret = FALSE;
 
-	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SoundIdx=%d, SoundMode=%d, SoundBW=%d, SoundPeriod=%d\n", __func__, 
+	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SoundIdx=%d, SoundMode=%d, SoundBW=%d, SoundPeriod=%d\n", __func__,
 			pSoundInfo->SoundIdx, pSoundInfo->SoundMode, pSoundInfo->SoundBW, pSoundInfo->SoundPeriod));
 
 	return Ret;
@@ -944,7 +941,7 @@ phydm_beamforming_EndPeriod_SW(
 	PADAPTER					Adapter = pDM_Odm->Adapter;
 	PRT_BEAMFORMING_INFO 		pBeamInfo = &pDM_Odm->BeamformingInfo;
 	PRT_SOUNDING_INFO			pSoundInfo = &(pBeamInfo->SoundingInfo);
-	
+
 	HAL_HW_TIMER_TYPE TimerType = HAL_TIMER_TXBF;
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
@@ -972,7 +969,7 @@ phydm_beamforming_EndPeriod_FW(
 
 
 /*SU BFee Entry Only*/
-VOID 
+VOID
 phydm_beamforming_ClearEntry_SW(
 	IN	PVOID			pDM_VOID,
 	BOOLEAN				IsDelete,
@@ -1009,13 +1006,13 @@ phydm_beamforming_ClearEntry_SW(
 			/*Used after bSounding=RESET, and will clear the setting of "ever sounded" entry, which is not necessarily be deleted.*/
 			/*This function is mainly used in case "BeamOidInfo.SoundOidMode == SOUNDING_STOP_All_TIMER".*/
 			/*However, setting oid doesn't delete entries (bUsed is still TRUE), new entries may fail to be added in.*/
-		
+
 			if (pBeamformEntry->bSound) {
 				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] SW reset BFee entry %d\n", __func__, Idx));
-				/*	
-				*	If End procedure is 
+				/*
+				*	If End procedure is
 				*	1. Between (Send NDPA, C2H packet return), reset state to initialized.
-				*	After C2H packet return , status bit will be set to zero. 
+				*	After C2H packet return , status bit will be set to zero.
 				*
 				*	2. After C2H packet, then reset state to initialized and clear status bit.
 				*/
@@ -1064,17 +1061,17 @@ phydm_beamforming_ClearEntry_FW(
 			/*Used after bSounding=RESET, and will clear the setting of "ever sounded" entry, which is not necessarily be deleted.*/
 			/*This function is mainly used in case "BeamOidInfo.SoundOidMode == SOUNDING_STOP_All_TIMER".*/
 			/*However, setting oid doesn't delete entries (bUsed is still TRUE), new entries may fail to be added in.*/
-		
+
 			if (pBeamformEntry->bSound) {
 				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]FW reset BFee entry %d\n", __func__, Idx));
-				/*	
-				*	If End procedure is 
+				/*
+				*	If End procedure is
 				*	1. Between (Send NDPA, C2H packet return), reset state to initialized.
-				*	After C2H packet return , status bit will be set to zero. 
+				*	After C2H packet return , status bit will be set to zero.
 				*
 				*	2. After C2H packet, then reset state to initialized and clear status bit.
 				*/
-				
+
 				pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZED;
 				pBeamformEntry->bSound = FALSE;
 			}
@@ -1083,7 +1080,7 @@ phydm_beamforming_ClearEntry_FW(
 }
 
 /*
-* 	Called : 
+* 	Called :
 *	1. Add and delete entry : Beamforming_Enter/Beamforming_Leave
 *	2. FW trigger :  Beamforming_SetTxBFen
 *	3. Set OID_RT_BEAMFORMING_PERIOD : BeamformingControl_V2
@@ -1105,7 +1102,6 @@ phydm_Beamforming_Notify(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, Before notify, bSounding=%d, Idx=%d\n", __func__, bSounding, Idx));
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: pBeamInfo->beamformee_su_cnt = %d\n", __func__, pBeamInfo->beamformee_su_cnt));
-	
 
 	switch (bSounding) {
 	case BEAMFORMEE_NOTIFY_ADD_SU:
@@ -1136,8 +1132,9 @@ phydm_Beamforming_Notify(
 			/*if (pSoundInfo->SoundMode == SOUNDING_SW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_SW_HT_TIMER)
 				ODM_SetTimer(pDM_Odm, &pBeamInfo->BeamformingTimer, pSoundInfo->SoundPeriod);*/
 			ODM_SetTimer(pDM_Odm, &pBeamInfo->BeamformingTimer, 1000); /*Do MU sounding every 1sec*/
-		} else
+		} else {
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: Less or larger than 2 MU STAs, not to set timer\n", __func__));
+		}
 	break;
 
 	case BEAMFORMEE_NOTIFY_DELETE_MU:
@@ -1151,7 +1148,7 @@ phydm_Beamforming_Notify(
 	break;
 
 	case BEAMFORMING_NOTIFY_RESET:
-		if (pSoundInfo->SoundMode == SOUNDING_FW_HT_TIMER || pSoundInfo->SoundMode == SOUNDING_FW_VHT_TIMER) {	
+		if (pSoundInfo->SoundMode == SOUNDING_FW_HT_TIMER || pSoundInfo->SoundMode == SOUNDING_FW_VHT_TIMER) {
 			phydm_beamforming_ClearEntry_FW(pDM_Odm, FALSE, Idx);
 			phydm_beamforming_EndPeriod_FW(pDM_Odm);
 		} else {
@@ -1168,7 +1165,6 @@ phydm_Beamforming_Notify(
 }
 
 
-
 BOOLEAN
 Beamforming_InitEntry(
 	IN	PVOID		pDM_VOID,
@@ -1188,7 +1184,7 @@ Beamforming_InitEntry(
 
 	/*The current setting does not support Beaforming*/
 	if (BEAMFORMING_CAP_NONE == pSTA->HtBeamformCap && BEAMFORMING_CAP_NONE == pSTA->VhtBeamformCap) {
-		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("The configuration disabled Beamforming! Skip...\n"));		
+		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("The configuration disabled Beamforming! Skip...\n"));
 		return FALSE;
 	}
 
@@ -1210,7 +1206,7 @@ Beamforming_InitEntry(
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] HT NumofSoundingDim=%d, CompSteeringNumofBFer=%d\n", __func__, NumofSoundingDim, CompSteeringNumofBFer));
 		}
 #if	(ODM_IC_11AC_SERIES_SUPPORT == 1)
-		if (pSTA->WirelessMode & WIRELESS_MODE_AC_5G || pSTA->WirelessMode & WIRELESS_MODE_AC_24G) {	/*VHT*/	
+		if (pSTA->WirelessMode & WIRELESS_MODE_AC_5G || pSTA->WirelessMode & WIRELESS_MODE_AC_24G) {	/*VHT*/
 
 			/* We are Beamformee because the STA is SU Beamformer*/
 			if (TEST_FLAG(pSTA->CurBeamformVHT, BEAMFORMING_VHT_BEAMFORMER_ENABLE)) {
@@ -1238,7 +1234,7 @@ Beamforming_InitEntry(
 			}
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]VHT CurBeamformVHT=0x%X, BeamformCap=0x%X\n", __func__, pSTA->CurBeamformVHT, BeamformCap));
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]VHT NumofSoundingDim=0x%X, CompSteeringNumofBFer=0x%X\n", __func__, NumofSoundingDim, CompSteeringNumofBFer));
-			
+
 		}
 #endif
 	}
@@ -1246,17 +1242,18 @@ Beamforming_InitEntry(
 
 	if(BeamformCap == BEAMFORMING_CAP_NONE)
 		return FALSE;
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Self BF Entry Cap = 0x%02X\n", __func__, BeamformCap));
 
 	/*We are BFee, so the entry is BFer*/
 	if (BeamformCap & (BEAMFORMEE_CAP_VHT_MU | BEAMFORMEE_CAP_VHT_SU | BEAMFORMEE_CAP_HT_EXPLICIT)) {
 		pBeamformerEntry = phydm_Beamforming_GetBFerEntryByAddr(pDM_Odm, pSTA->RA, &BFerIdx);
-		
+
 		if (pBeamformerEntry == NULL) {
 			pBeamformerEntry = Beamforming_AddBFerEntry(pDM_Odm, pSTA, BeamformCap, NumofSoundingDim , &BFerIdx);
-			if (pBeamformerEntry == NULL)
+			if (pBeamformerEntry == NULL) {
 				ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]Not enough BFer entry!!!!!\n", __func__));
+			}
 		}
 	}
 
@@ -1272,17 +1269,19 @@ Beamforming_InitEntry(
 
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s]: Add BFee entry %d\n", __func__, BFeeIdx));
 
-			if (pBeamformEntry == NULL)
+			if (pBeamformEntry == NULL) {
 				return FALSE;
-			else
+			} else {
 				pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZEING;
+			}
 		} else {
 			/*Entry has been created. If entry is initialing or progressing then errors occur.*/
-			if (pBeamformEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_INITIALIZED && 
+			if (pBeamformEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_INITIALIZED &&
 				pBeamformEntry->BeamformEntryState != BEAMFORMING_ENTRY_STATE_PROGRESSED) {
 				return FALSE;
-			} else
+			} else {
 				pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZEING;
+			}
 		}
 		pBeamformEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_INITIALIZED;
 		phydm_staInfoUpdate(pDM_Odm, staIdx, pBeamformEntry);
@@ -1309,7 +1308,7 @@ Beamforming_DeInitEntry(
 	BOOLEAN ret = FALSE;
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n",  __func__));
-	
+
 	if (pBFeeEntry != NULL) {
 		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, pBFeeEntry\n", __func__));
 		pBFeeEntry->bUsed = FALSE;
@@ -1322,8 +1321,8 @@ Beamforming_DeInitEntry(
 			pDM_Odm->BeamformingInfo.beamformee_su_cnt -= 1;
 		}
 		ret = TRUE;
-	} 
-	
+	}
+
 	if (pBFerEntry != NULL) {
 		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, pBFerEntry\n", __func__));
 		pBFerEntry->bUsed = FALSE;
@@ -1356,7 +1355,7 @@ BeamformingStart_V1(
 	PRT_BEAMFORMEE_ENTRY	pEntry;
 	BOOLEAN					ret = TRUE;
 	PRT_BEAMFORMING_INFO	pBeamInfo = &(pDM_Odm->BeamformingInfo);
-	
+
 	pEntry = phydm_Beamforming_GetBFeeEntryByAddr(pDM_Odm, RA, &Idx);
 
 	if (pEntry->bUsed == FALSE) {
@@ -1368,7 +1367,7 @@ BeamformingStart_V1(
 
 		pEntry->bBeamformingInProgress = TRUE;
 
-		if (Mode == 1) {	
+		if (Mode == 1) {
 			if (!(pEntry->BeamformEntryCap & BEAMFORMER_CAP_HT_EXPLICIT)) {
 				pEntry->bBeamformingInProgress = FALSE;
 				return FALSE;
@@ -1395,7 +1394,7 @@ BeamformingStart_V1(
 	HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_STATUS, (pu1Byte)&Idx);
 
 	if (Mode == 1)
-		ret = Beamforming_SendHTNDPAPacket(pDM_Odm, RA, BW, NORMAL_QUEUE);	
+		ret = Beamforming_SendHTNDPAPacket(pDM_Odm, RA, BW, NORMAL_QUEUE);
 	else
 		ret = Beamforming_SendVHTNDPAPacket(pDM_Odm, RA, pEntry->AID, BW, NORMAL_QUEUE);
 
@@ -1414,7 +1413,7 @@ BOOLEAN
 BeamformingStart_SW(
 	IN	PVOID		pDM_VOID,
 	u1Byte			Idx,
-	u1Byte			Mode, 
+	u1Byte			Mode,
 	CHANNEL_WIDTH	BW
 	)
 {
@@ -1444,8 +1443,8 @@ BeamformingStart_SW(
 
 			pEntry->bBeamformingInProgress = TRUE;
 			RA = pEntry->MacAddr;
-			
-			if (Mode == SOUNDING_SW_HT_TIMER || Mode == SOUNDING_HW_HT_TIMER || Mode == SOUNDING_AUTO_HT_TIMER) {	
+
+			if (Mode == SOUNDING_SW_HT_TIMER || Mode == SOUNDING_HW_HT_TIMER || Mode == SOUNDING_AUTO_HT_TIMER) {
 				if (!(pEntry->BeamformEntryCap & BEAMFORMER_CAP_HT_EXPLICIT)) {
 					pEntry->bBeamformingInProgress = FALSE;
 					ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Return by not support BEAMFORMER_CAP_HT_EXPLICIT <==\n", __func__));
@@ -1470,12 +1469,12 @@ BeamformingStart_SW(
 
 		pBeamInfo->BeamformeeCurIdx = Idx;
 	}
-	
+
 	/*2014.12.22 Luke: Need to be checked*/
 	/*GET_TXBF_INFO(Adapter)->fTxbfSet(Adapter, TXBF_SET_SOUNDING_STATUS, (pu1Byte)&Idx);*/
 
 	if (Mode == SOUNDING_SW_HT_TIMER || Mode == SOUNDING_HW_HT_TIMER || Mode == SOUNDING_AUTO_HT_TIMER)
-		ret = Beamforming_SendHTNDPAPacket(pDM_Odm, RA , BW, NORMAL_QUEUE);	
+		ret = Beamforming_SendHTNDPAPacket(pDM_Odm, RA , BW, NORMAL_QUEUE);
 	else
 		ret = Beamforming_SendVHTNDPAPacket(pDM_Odm, RA , pEntry->AID, BW, NORMAL_QUEUE);
 
@@ -1485,7 +1484,7 @@ BeamformingStart_SW(
 		return FALSE;
 	}
 
-	
+
 	/*--------------------------
 	// Send BF Report Poll for MU BF
 	--------------------------*/
@@ -1494,9 +1493,9 @@ BeamformingStart_SW(
 {
 	u1Byte				idx, PollSTACnt = 0;
 	BOOLEAN				bGetFirstBFee = FALSE;
-	
+
 	if (pBeamInfo->beamformee_mu_cnt > 1) { /* More than 1 MU STA*/
-	
+
 		for (idx = 0; idx < BEAMFORMEE_ENTRY_NUM; idx++) {
 			pEntry = &(pBeamInfo->BeamformeeEntry[idx]);
 			if (pEntry->is_mu_sta) {
@@ -1538,7 +1537,7 @@ BeamformingStart_FW(
 	pEntry->BeamformEntryState = BEAMFORMING_ENTRY_STATE_PROGRESSING;
 	pEntry->bSound = TRUE;
 	HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_FW_NDPA, (pu1Byte)&Idx);
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] End, Idx=0x%X\n", __func__, Idx));
 	return TRUE;
 }
@@ -1546,7 +1545,7 @@ BeamformingStart_FW(
 VOID
 Beamforming_CheckSoundingSuccess(
 	IN PVOID			pDM_VOID,
-	BOOLEAN			Status	
+	BOOLEAN			Status
 )
 {
 	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
@@ -1573,7 +1572,7 @@ Beamforming_CheckSoundingSuccess(
 VOID
 phydm_Beamforming_End_SW(
 	IN PVOID		pDM_VOID,
-	BOOLEAN			Status	
+	BOOLEAN			Status
 	)
 {
 	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
@@ -1604,20 +1603,20 @@ phydm_Beamforming_End_SW(
 			HalComTxbf_Set(pDM_Odm, TXBF_SET_TX_PATH_RESET, (pu1Byte)&(pBeamInfo->BeamformeeCurIdx));
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] LogStatusFailCnt %d\n", __func__, pEntry->LogStatusFailCnt));
 		}
-		
+
 		if (pEntry->LogStatusFailCnt > 50) {
 			ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s LogStatusFailCnt > 50, Stop SOUNDING\n", __func__));
 			pEntry->bSound = FALSE;
-			Beamforming_DeInitEntry(pDM_Odm, pEntry->MacAddr); 
+			Beamforming_DeInitEntry(pDM_Odm, pEntry->MacAddr);
 
 			/*Modified by David - Every action of deleting entry should follow by Notify*/
 			phydm_Beamforming_Notify(pDM_Odm);
-		}	
-		
+		}
+
 		pEntry->bBeamformingInProgress = FALSE;
 	}
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s: Status=%d\n", __func__, Status));
-}	
+}
 
 
 VOID
@@ -1645,28 +1644,29 @@ Beamforming_TimerCallback(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Start!\n", __func__));
 
-	if (pBeamInfo->is_mu_sounding)
+	if (pBeamInfo->is_mu_sounding) {
 		bBeamformingInProgress = pBeamInfo->is_mu_sounding_in_progress;
-	else
+	} else {
 		bBeamformingInProgress = pEntry->bBeamformingInProgress;
-
+	}
 	if (bBeamformingInProgress) {
 	 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("bBeamformingInProgress, reset it\n"));
 		phydm_Beamforming_End_SW(pDM_Odm, 0);
-	 }
+	}
 
 	ret = phydm_Beamforming_SelectBeamEntry(pDM_Odm, pBeamInfo);
 #if (SUPPORT_MU_BF == 1)
-	if (ret && pBeamInfo->beamformee_mu_cnt > 1)
+	if (ret && pBeamInfo->beamformee_mu_cnt > 1) {
 		ret = 1;
-	else
+	} else {
 		ret = 0;
+	}
 #endif
-	if (ret)
+	if (ret) {
 		ret = BeamformingStart_SW(pDM_Odm, pSoundInfo->SoundIdx, pSoundInfo->SoundMode, pSoundInfo->SoundBW);
-	else
+	} else {
 		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s, Error value return from BeamformingStart_V2\n", __func__));
-
+	}
 	if ((pBeamInfo->beamformee_su_cnt != 0) || (pBeamInfo->beamformee_mu_cnt > 1)) {
 		if (pSoundInfo->SoundMode == SOUNDING_SW_VHT_TIMER || pSoundInfo->SoundMode == SOUNDING_SW_HT_TIMER)
 			ODM_SetTimer(pDM_Odm, &pBeamInfo->BeamformingTimer, pSoundInfo->SoundPeriod);
@@ -1691,7 +1691,7 @@ Beamforming_SWTimerCallback(
 	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 	Beamforming_TimerCallback(pDM_Odm);
 #elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
@@ -1776,7 +1776,7 @@ Beamforming_Enter(
 {
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	u1Byte			BFerBFeeIdx = 0xff;
-	
+
 	if (Beamforming_InitEntry(pDM_Odm, staIdx, &BFerBFeeIdx))
 		HalComTxbf_Set(pDM_Odm, TXBF_SET_SOUNDING_ENTER, (pu1Byte)&BFerBFeeIdx);
 
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/phydm_hwconfig.c b/drivers/net/wireless/rtl8814au/hal/phydm/phydm_hwconfig.c
index 48d31a1..769381f 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/phydm_hwconfig.c
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/phydm_hwconfig.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -42,7 +42,7 @@
 
 
 #define READ_FIRMWARE_MP(ic, txt) 		(ODM_ReadFirmware_MP_##ic##txt(pDM_Odm, pFirmware, pSize))
-#define READ_FIRMWARE_TC(ic, txt) 		(ODM_ReadFirmware_TC_##ic##txt(pDM_Odm, pFirmware, pSize))		
+#define READ_FIRMWARE_TC(ic, txt) 		(ODM_ReadFirmware_TC_##ic##txt(pDM_Odm, pFirmware, pSize))
 
 #if (PHYDM_TESTCHIP_SUPPORT == 1)
 #define READ_FIRMWARE(ic, txt) do {\
@@ -50,11 +50,11 @@
 							READ_FIRMWARE_MP(ic,txt);\
 						else\
 							READ_FIRMWARE_TC(ic,txt);\
-					} while(0) 
+					} while(0)
 #else
 #define READ_FIRMWARE     READ_FIRMWARE_MP
 #endif
-						
+
 #define GET_VERSION_MP(ic, txt) 		(ODM_GetVersion_MP_##ic##txt())
 #define GET_VERSION_TC(ic, txt) 		(ODM_GetVersion_TC_##ic##txt())
 #define GET_VERSION(ic, txt) (pDM_Odm->bIsMPChip?GET_VERSION_MP(ic,txt):GET_VERSION_TC(ic,txt))
@@ -78,14 +78,14 @@ odm_QueryRxPwrPercentage(
 // IF other SW team do not support the feature, remove this section.??
 //
 s4Byte
-odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Lenovo(	
+odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Lenovo(
 	IN OUT PDM_ODM_T pDM_Odm,
-	s4Byte CurrSig 
+	s4Byte CurrSig
 )
-{	
+{
 	s4Byte RetSig = 0;
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	//if(pDM_Odm->SupportInterface  == ODM_ITRF_PCIE) 
+	//if(pDM_Odm->SupportInterface  == ODM_ITRF_PCIE)
 	{
 		// Step 1. Scale mapping.
 		// 20100611 Joseph: Re-tunning RSSI presentation for Lenovo.
@@ -116,16 +116,16 @@ odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Lenovo(
 }
 
 s4Byte
-odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Netcore(	
+odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Netcore(
 	IN OUT PDM_ODM_T pDM_Odm,
-	s4Byte CurrSig 
+	s4Byte CurrSig
 )
 {
 	s4Byte RetSig = 0;
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	//if(pDM_Odm->SupportInterface  == ODM_ITRF_USB)
 	{
-		// Netcore request this modification because 2009.04.13 SU driver use it. 
+		// Netcore request this modification because 2009.04.13 SU driver use it.
 		if (CurrSig >= 31 && CurrSig <= 100)
 			RetSig = 100;
 		else if (CurrSig >= 21 && CurrSig <= 30)
@@ -155,14 +155,14 @@ odm_SignalScaleMapping_92CSeries_patch_RT_CID_819x_Netcore(
 
 
 s4Byte
-odm_SignalScaleMapping_92CSeries(	
+odm_SignalScaleMapping_92CSeries(
 	IN OUT PDM_ODM_T pDM_Odm,
-	IN s4Byte CurrSig 
+	IN s4Byte CurrSig
 )
 {
-	s4Byte RetSig = 0; 
-#if (DEV_BUS_TYPE == RT_PCI_INTERFACE) 
-	if (pDM_Odm->SupportInterface  == ODM_ITRF_PCIE) 
+	s4Byte RetSig = 0;
+#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)
+	if (pDM_Odm->SupportInterface  == ODM_ITRF_PCIE)
 	{
 		// Step 1. Scale mapping.
 		if(CurrSig >= 61 && CurrSig <= 100)
@@ -1279,6 +1279,9 @@ odm_RxPhyStatusJaguarSeries_Parsing(
 							EVM += 20;
 							if (EVM > 100)
 								EVM = 100;
+						} else {
+							// it's a made up value, but Realtek apparently assumed 'this would never happen'
+							EVM = 0;
 						}
 					} else {
 						if (i < ODM_RF_PATH_C) {
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/phydm_kfree.c b/drivers/net/wireless/rtl8814au/hal/phydm/phydm_kfree.c
index a91cdee..889c050 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/phydm_kfree.c
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/phydm_kfree.c
@@ -38,7 +38,7 @@ phydm_SetKfreeToRF_8814A(
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	PODM_RF_CAL_T	pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
 	BOOLEAN bOdd;
-	
+
 	if ((Data%2) != 0) {	/*odd -> positive*/
 		Data = Data - 1;
 		ODM_SetRFReg(pDM_Odm, eRFPath, rRF_TxGainOffset, BIT19, 1);
@@ -113,9 +113,9 @@ phydm_SetKfreeToRF_8814A(
 	/*that means Kfree offset is negative, we need to record it.*/
 		pRFCalibrateInfo->KfreeOffset[eRFPath] = (-1)*pRFCalibrateInfo->KfreeOffset[eRFPath];
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_MP, ODM_DBG_LOUD, ("phy_ConfigKFree8814A(): KfreeOffset = %d\n", pRFCalibrateInfo->KfreeOffset[eRFPath]));
-	} else
+	} else {
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_MP, ODM_DBG_LOUD, ("phy_ConfigKFree8814A(): KfreeOffset = %d\n", pRFCalibrateInfo->KfreeOffset[eRFPath]));
-	
+	}
 }
 
 
@@ -127,7 +127,7 @@ phydm_SetKfreeToRF(
 	)
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	
+
 	if (pDM_Odm->SupportICType & ODM_RTL8814A)
 		phydm_SetKfreeToRF_8814A(pDM_Odm, eRFPath, Data);
 }
@@ -150,9 +150,9 @@ phydm_ConfigKFree(
 		maxRFpath = 2;	/*0~1*/
 	else
 		maxRFpath = 1;
-	
+
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_MP, ODM_DBG_LOUD, ("===>phy_ConfigKFree8814A()\n"));
-	
+
 	if (pRFCalibrateInfo->RegRfKFreeEnable == 2) {
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_MP, ODM_DBG_LOUD, ("phy_ConfigKFree8814A(): RegRfKFreeEnable == 2, Disable\n"));
 		return;
@@ -188,4 +188,3 @@ phydm_ConfigKFree(
 	}
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_MP, ODM_DBG_LOUD, ("<===phy_ConfigKFree8814A()\n"));
 }
-
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/phydm_pathdiv.c b/drivers/net/wireless/rtl8814au/hal/phydm/phydm_pathdiv.c
index 0ddeba3..d6aa427 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/phydm_pathdiv.c
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/phydm_pathdiv.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -37,34 +37,28 @@ phydm_dtp_fix_tx_path(
 	pPATHDIV_T		pDM_PathDiv = &pDM_Odm->DM_PathDiv;
 	u1Byte			i,num_enable_path=0;
 
-	if(path==pDM_PathDiv->pre_tx_path)
-	{
+	if (path==pDM_PathDiv->pre_tx_path) {
 		return;
-	}
-	else
-	{
+	} else {
 		pDM_PathDiv->pre_tx_path=path;
 	}
 
 	ODM_SetBBReg( pDM_Odm, 0x93c, BIT18|BIT19, 3);
 
-	for(i=0; i<4; i++)
-	{
-		if(path&BIT(i))
+	for (i=0; i<4; i++) {
+		if (path&BIT(i))
 			num_enable_path++;
 	}
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Number of trun-on path : (( %d ))\n", num_enable_path));
 
-	if(num_enable_path == 1)
-	{
+	if (num_enable_path == 1) {
 		ODM_SetBBReg( pDM_Odm, 0x93c, 0xf00000, path);
-	
-		if(path==PHYDM_A)//1-1
-		{
+
+		if (path==PHYDM_A) { //1-1
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A ))\n"));
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
 		}
-		else 	if(path==PHYDM_B)//1-2
+		else 	if (path==PHYDM_B)//1-2
 		{
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( B ))\n"));
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 0);
@@ -82,20 +76,19 @@ phydm_dtp_fix_tx_path(
 		}
 
 	}
-	else 	if(num_enable_path == 2)
+	else 	if (num_enable_path == 2)
 	{
 		ODM_SetBBReg( pDM_Odm, 0x93c, 0xf00000, path);
 		ODM_SetBBReg( pDM_Odm, 0x940, 0xf0, path);
-	
-		if(path==PHYDM_AB)//2-1
-		{
+
+		if (path==PHYDM_AB) { //2-1
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A B ))\n"));
 			//set for 1ss
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 1);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);			
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);
 		}
 		else 	if(path==PHYDM_AC)//2-2
 		{
@@ -105,7 +98,7 @@ phydm_dtp_fix_tx_path(
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 1);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);	
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);
 		}
 		else 	if(path==PHYDM_AD)//2-3
 		{
@@ -115,7 +108,7 @@ phydm_dtp_fix_tx_path(
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 1);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);	
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);
 		}
 		else 	if(path==PHYDM_BC)//2-4
 		{
@@ -125,7 +118,7 @@ phydm_dtp_fix_tx_path(
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 1);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);	
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);
 		}
 		else 	if(path==PHYDM_BD)//2-5
 		{
@@ -135,7 +128,7 @@ phydm_dtp_fix_tx_path(
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 1);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);	
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);
 		}
 		else 	if(path==PHYDM_CD)//2-6
 		{
@@ -145,7 +138,7 @@ phydm_dtp_fix_tx_path(
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 1);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);	
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 1);
 		}
 
 	}
@@ -154,14 +147,13 @@ phydm_dtp_fix_tx_path(
 		ODM_SetBBReg( pDM_Odm, 0x93c, 0xf00000, path);
 		ODM_SetBBReg( pDM_Odm, 0x940, 0xf0, path);
 		ODM_SetBBReg( pDM_Odm, 0x940, 0xf0000, path);
-	
-		if(path==PHYDM_ABC)//3-1
-		{
+
+		if(path==PHYDM_ABC) { //3-1
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A B C))\n"));
 			//set for 1ss
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 1);
-			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 2);			
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 2);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);
@@ -176,11 +168,11 @@ phydm_dtp_fix_tx_path(
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" Trun on path (( A B D ))\n"));
 			//set for 1ss
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
-			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 1);		
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 1);
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
-			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);		
+			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 1);
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT15|BIT14, 2);
 			//set for 3ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT21|BIT20, 0);
@@ -194,7 +186,7 @@ phydm_dtp_fix_tx_path(
 			//set for 1ss
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT25|BIT24, 0);
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 1);
-			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);			
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT9|BIT8, 0);
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);
@@ -210,7 +202,7 @@ phydm_dtp_fix_tx_path(
 			//set for 1ss
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT27|BIT26, 0);
 			ODM_SetBBReg( pDM_Odm, 0x93c, BIT29|BIT28, 1);
-			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);			
+			ODM_SetBBReg( pDM_Odm, 0x93c, BIT31|BIT30, 2);
 			//set for 2ss
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT11|BIT10, 0);
 			ODM_SetBBReg( pDM_Odm, 0x940, BIT13|BIT12, 1);
@@ -268,9 +260,7 @@ phydm_find_default_path(
 		{
 			pDM_PathDiv->is_pathA_exist=FALSE;
 		}
-	}
-	else
-	{
+	} else {
 		if( (rssi_avg_a >=rssi_avg_b) && (rssi_avg_a >=rssi_avg_c)&&(rssi_avg_a >=rssi_avg_d))
 			pDM_PathDiv->default_path=PATH_A;
 		else if(  (rssi_avg_b >=rssi_avg_c)&&(rssi_avg_b >=rssi_avg_d))
@@ -294,19 +284,14 @@ phydm_candidate_dtp_update(
 	pPATHDIV_T		pDM_PathDiv = &pDM_Odm->DM_PathDiv;
 
 	pDM_PathDiv->num_candidate=3;
-	
-	if(pDM_PathDiv->use_path_a_as_default_ant == 1)
-	{
-		if(pDM_PathDiv->num_tx_path==3)
-		{
-			if(pDM_PathDiv->is_pathA_exist)
-			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD; 
+
+	if(pDM_PathDiv->use_path_a_as_default_ant == 1) {
+		if(pDM_PathDiv->num_tx_path==3) {
+			if(pDM_PathDiv->is_pathA_exist) {
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD;
 				pDM_PathDiv->ant_candidate_3 =  PHYDM_ACD;
-			}
-			else // use path BCD 
-			{
+			} else { // use path BCD
 				pDM_PathDiv->num_candidate=1;
 				phydm_dtp_fix_tx_path(pDM_Odm, PHYDM_BCD);
 				return;
@@ -316,75 +301,69 @@ phydm_candidate_dtp_update(
 		{
 			if(pDM_PathDiv->is_pathA_exist)
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_AC; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_AD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_AC;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_AD;
+			} else {
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_BC;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_BD;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_CD;
 			}
-			else
-			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_BC; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_BD; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_CD; 
-			}	
 		}
-	}
-	else
-	{
-		//2 3 TX Mode 
-		if(pDM_PathDiv->num_tx_path==3)//choose 3 ant form 4 
-		{
-			if(pDM_PathDiv->default_path == PATH_A) //choose 2 ant form 3
-			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_ACD; 
+	} else {
+		//2 3 TX Mode
+		if(pDM_PathDiv->num_tx_path==3) { //choose 3 ant form 4
+			if(pDM_PathDiv->default_path == PATH_A) { //choose 2 ant form 3
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_ACD;
 			}
 			else if(pDM_PathDiv->default_path==PATH_B)
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ABD;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD;
 			}
 			else if(pDM_PathDiv->default_path == PATH_C)
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_ACD; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABC;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ACD;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD;
 			}
 			else if(pDM_PathDiv->default_path == PATH_D)
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABD; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_ACD; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_ABD;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_ACD;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_BCD;
 			}
 		}
-		
-		//2 2 TX Mode 
-		else if(pDM_PathDiv->num_tx_path==2)//choose 2 ant form 4 
+
+		//2 2 TX Mode
+		else if(pDM_PathDiv->num_tx_path==2)//choose 2 ant form 4
 		{
 			if(pDM_PathDiv->default_path == PATH_A) //choose 2 ant form 3
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_AC; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_AD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_AC;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_AD;
 			}
 			else if(pDM_PathDiv->default_path==PATH_B)
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_BC; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_BD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_AB;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_BC;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_BD;
 			}
 			else if(pDM_PathDiv->default_path == PATH_C)
 			{
-				pDM_PathDiv->ant_candidate_1 =  PHYDM_AC; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_BC; 
-				pDM_PathDiv->ant_candidate_3 =  PHYDM_CD; 
+				pDM_PathDiv->ant_candidate_1 =  PHYDM_AC;
+				pDM_PathDiv->ant_candidate_2 =  PHYDM_BC;
+				pDM_PathDiv->ant_candidate_3 =  PHYDM_CD;
 			}
 			else if(pDM_PathDiv->default_path == PATH_D)
 			{
-				pDM_PathDiv->ant_candidate_1=  PHYDM_AD; 
-				pDM_PathDiv->ant_candidate_2 =  PHYDM_BD; 
-				pDM_PathDiv->ant_candidate_3=  PHYDM_CD; 
+				pDM_PathDiv->ant_candidate_1=  PHYDM_AD;
+				pDM_PathDiv->ant_candidate_2=  PHYDM_BD;
+				pDM_PathDiv->ant_candidate_3=  PHYDM_CD;
 			}
 		}
 	}
@@ -397,108 +376,96 @@ phydm_dynamic_tx_path(
 )
 {
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	pPATHDIV_T		pDM_PathDiv = &pDM_Odm->DM_PathDiv;	
-	
+	pPATHDIV_T		pDM_PathDiv = &pDM_Odm->DM_PathDiv;
+
 	PSTA_INFO_T   	pEntry;
 	u4Byte	i;
 	u1Byte	num_client=0;
 	u1Byte	H2C_Parameter[6] ={0};
 
 
-	if(!pDM_Odm->bLinked) //bLinked==False
-	{
+	if(!pDM_Odm->bLinked) { //bLinked==False
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("DTP_8814 [No Link!!!]\n"));
-		
-		if(pDM_PathDiv->bBecomeLinked == TRUE)
-		{
+
+		if(pDM_PathDiv->bBecomeLinked == TRUE) {
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" [Be disconnected]----->\n"));
 			pDM_PathDiv->bBecomeLinked = pDM_Odm->bLinked;
 		}
 		return;
-	}	
-	else
-	{
-		if(pDM_PathDiv->bBecomeLinked ==FALSE)
-		{
+	} else {
+		if(pDM_PathDiv->bBecomeLinked ==FALSE) {
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, (" [Be Linked !!!]----->\n"));
 			pDM_PathDiv->bBecomeLinked = pDM_Odm->bLinked;
-		}	
-	}	
-	
-	//2 [Period CTRL]
-	if(pDM_PathDiv->dtp_period >=2)
-	{
-		pDM_PathDiv->dtp_period=0;	
+		}
 	}
-	else
-	{	
+
+	//2 [Period CTRL]
+	if(pDM_PathDiv->dtp_period >=2) {
+		pDM_PathDiv->dtp_period=0;
+	} else {
 		//ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("Phydm_Dynamic_Tx_Path_8814A()  Stay = (( %d ))\n",pDM_PathDiv->dtp_period));
-		pDM_PathDiv->dtp_period++;		
+		pDM_PathDiv->dtp_period++;
 		return;
 	}
-	
+
 
 	//2 [Fix Path]
 	if (pDM_Odm->path_select != PHYDM_AUTO_PATH)
 	{
 		return;
 	}
-	
-	//2 [Check Bfer]	
+
+	//2 [Check Bfer]
 	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	#if (BEAMFORMING_SUPPORT == 1)
 	{
 		BEAMFORMING_CAP		BeamformCap = (pDM_Odm->BeamformingInfo.BeamformCap);
 
 		if( BeamformCap & BEAMFORMER_CAP ) //  BFmer On  &&   Div On ->  Div Off
-		{	
-			if( pDM_PathDiv->fix_path_bfer == 0) 
+		{
+			if( pDM_PathDiv->fix_path_bfer == 0)
 			{
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("[ PathDiv : OFF ]   BFmer ==1  \n"));
-				pDM_PathDiv->fix_path_bfer = 1 ;			
+				pDM_PathDiv->fix_path_bfer = 1 ;
 			}
 			return;
 		}
 		else // BFmer Off   &&   Div Off ->  Div On
 		{
-			if( pDM_PathDiv->fix_path_bfer == 1 ) 
+			if( pDM_PathDiv->fix_path_bfer == 1 )
 			{
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("[ PathDiv : ON ]   BFmer ==0 \n"));
 				pDM_PathDiv->fix_path_bfer = 0;
 			}
 		}
 	}
-	#endif	
+	#endif
 	#endif
 
-	if(pDM_PathDiv->use_path_a_as_default_ant ==1)
-	{
+	if(pDM_PathDiv->use_path_a_as_default_ant ==1) {
 		phydm_find_default_path(pDM_Odm);
-		phydm_candidate_dtp_update(pDM_Odm);	
-	}
-	else
-	{
-		if( pDM_PathDiv->dtp_state == PHYDM_DTP_INIT)
-		{
+		phydm_candidate_dtp_update(pDM_Odm);
+	} else {
+		if( pDM_PathDiv->dtp_state == PHYDM_DTP_INIT) {
 			phydm_find_default_path(pDM_Odm);
 			phydm_candidate_dtp_update(pDM_Odm);
 			pDM_PathDiv->dtp_state = PHYDM_DTP_RUNNING_1;
 		}
-		
+
 		else 	if( pDM_PathDiv->dtp_state == PHYDM_DTP_RUNNING_1)
 		{
 			pDM_PathDiv->dtp_check_patha_counter++;
-			
+
 			if(pDM_PathDiv->dtp_check_patha_counter>=NUM_RESET_DTP_PERIOD)
 			{
 				pDM_PathDiv->dtp_check_patha_counter=0;
 				pDM_PathDiv->dtp_state = PHYDM_DTP_INIT;
 			}
-			//2 Search space update		
+			//2 Search space update
 			else
 			{
 				// 1.  find the worst candidate
-				
+
 
 				// 2. repalce the worst candidate
 			}
@@ -507,17 +474,14 @@ phydm_dynamic_tx_path(
 
 	//2 Dynamic Path Selection H2C
 
-	if(pDM_PathDiv->num_candidate == 1)
-	{
+	if(pDM_PathDiv->num_candidate == 1) {
 		return;
-	}
-	else
-	{	
+	} else {
 		H2C_Parameter[0] =  pDM_PathDiv->num_candidate;
-		H2C_Parameter[1] =  pDM_PathDiv->num_tx_path;	
-		H2C_Parameter[2] =  pDM_PathDiv->ant_candidate_1; 
-		H2C_Parameter[3] =  pDM_PathDiv->ant_candidate_2; 
-		H2C_Parameter[4] =  pDM_PathDiv->ant_candidate_3; 
+		H2C_Parameter[1] =  pDM_PathDiv->num_tx_path;
+		H2C_Parameter[2] =  pDM_PathDiv->ant_candidate_1;
+		H2C_Parameter[3] =  pDM_PathDiv->ant_candidate_2;
+		H2C_Parameter[4] =  pDM_PathDiv->ant_candidate_3;
 
 		ODM_FillH2CCmd(pDM_Odm, PHYDM_H2C_DYNAMIC_TX_PATH, 6, H2C_Parameter);
 	}
@@ -525,7 +489,6 @@ phydm_dynamic_tx_path(
 }
 
 
-
 VOID
 phydm_dynamic_tx_path_init(
 	IN	PVOID	pDM_VOID
@@ -552,29 +515,25 @@ phydm_dynamic_tx_path_init(
 	memcpy(&(pDM_PathDiv->search_space_3[0]), &(search_space_3[0]), NUM_CHOOSE3_FROM4);
 
 	pDM_PathDiv->use_path_a_as_default_ant= 1;
-	pDM_PathDiv->dtp_state = PHYDM_DTP_INIT;	
+	pDM_PathDiv->dtp_state = PHYDM_DTP_INIT;
 	pDM_Odm->path_select = PHYDM_AUTO_PATH;
 	pDM_PathDiv->path_div_type = PHYDM_4R_PATH_DIV;
 
-	
-	if(pDM_PathDiv->is_u3_mode )
-	{
+
+	if(pDM_PathDiv->is_u3_mode ) {
 		pDM_PathDiv->num_tx_path=3;
 		phydm_dtp_fix_tx_path(pDM_Odm, PHYDM_BCD);/* 3TX  Set Init TX Path*/
-		
-	}
-	else
-	{
+	} else {
 		pDM_PathDiv->num_tx_path=2;
 		phydm_dtp_fix_tx_path(pDM_Odm, PHYDM_BC);/* 2TX // Set Init TX Path*/
 	}
-	
+
 }
 
 
 VOID
-phydm_process_rssi_for_path_div(	
-	IN OUT		PVOID			pDM_VOID,	
+phydm_process_rssi_for_path_div(
+	IN OUT		PVOID			pDM_VOID,
 	IN			PVOID			p_phy_info_void,
 	IN			PVOID			p_pkt_info_void
 	)
@@ -595,20 +554,18 @@ phydm_process_rssi_for_path_div(
 				{
 					pDM_PathDiv->path_a_sum_all+=pPhyInfo->RxMIMOSignalStrength[0];
 					pDM_PathDiv->path_a_cnt_all++;
-					
+
 					pDM_PathDiv->path_b_sum_all+=pPhyInfo->RxMIMOSignalStrength[1];
 					pDM_PathDiv->path_b_cnt_all++;
-					
+
 					pDM_PathDiv->path_c_sum_all+=pPhyInfo->RxMIMOSignalStrength[2];
 					pDM_PathDiv->path_c_cnt_all++;
-					
+
 					pDM_PathDiv->path_d_sum_all+=pPhyInfo->RxMIMOSignalStrength[3];
 					pDM_PathDiv->path_d_cnt_all++;
 				}
 				#endif
-			}
-			else
-			{
+			} else {
 				pDM_PathDiv->PathA_Sum[pPktinfo->StationID]+=pPhyInfo->RxMIMOSignalStrength[0];
 				pDM_PathDiv->PathA_Cnt[pPktinfo->StationID]++;
 
@@ -617,8 +574,6 @@ phydm_process_rssi_for_path_div(
 			}
 		}
 	}
-	
-	
 }
 
 #endif //#if RTL8814A_SUPPORT
@@ -636,10 +591,10 @@ odm_pathdiv_debug(
 	pPATHDIV_T			pDM_PathDiv  = &(pDM_Odm->DM_PathDiv);
 	u4Byte used = *_used;
 	u4Byte out_len = *_out_len;
-	
+
 	pDM_Odm->path_select = (dm_value[0] & 0xf);
 	PHYDM_SNPRINTF((output+used, out_len-used,"Path_select = (( 0x%x ))\n",pDM_Odm->path_select ));
-	
+
 	//2 [Fix Path]
 	if (pDM_Odm->path_select != PHYDM_AUTO_PATH)
 	{
@@ -648,11 +603,9 @@ odm_pathdiv_debug(
 			((pDM_Odm->path_select) & 0x2)?"B":"",
 			((pDM_Odm->path_select) & 0x4)?"C":"",
 			((pDM_Odm->path_select) & 0x8)?"D":"" ));
-		
+
 		phydm_dtp_fix_tx_path( pDM_Odm, pDM_Odm->path_select );
-	}
-	else
-	{
+	} else {
 		PHYDM_SNPRINTF((output+used, out_len-used,"%s\n","Auto Path"));
 	}
 }
@@ -670,8 +623,8 @@ phydm_c2h_dtp_handler(
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	pPATHDIV_T		pDM_PathDiv  = &(pDM_Odm->DM_PathDiv);
 
-	u1Byte  macid = CmdBuf[0]; 
-	u1Byte  target = CmdBuf[1];	
+	u1Byte  macid = CmdBuf[0];
+	u1Byte  target = CmdBuf[1];
 	u1Byte  nsc_1 = CmdBuf[2];
 	u1Byte  nsc_2 = CmdBuf[3];
 	u1Byte  nsc_3 = CmdBuf[4];
@@ -688,10 +641,10 @@ phydm_c2h_dtp_handler(
 	}
 	else
 	{
-		phydm_dtp_fix_tx_path(pDM_Odm, pDM_PathDiv->ant_candidate_3);	
+		phydm_dtp_fix_tx_path(pDM_Odm, pDM_PathDiv->ant_candidate_3);
 	}
 	*/
-#endif	
+#endif
 }
 
 VOID
@@ -732,7 +685,7 @@ odm_PathDiversityInit(
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
 	/*pDM_Odm->SupportAbility |= ODM_BB_PATH_DIV;*/
-	
+
 	if(pDM_Odm->mp_mode == TRUE)
 		return;
 
@@ -752,7 +705,7 @@ odm_PathDiversityInit(
 		if(pDM_Odm->SupportICType & ODM_RTL8814A)
 			phydm_dynamic_tx_path_init(pDM_Odm);
 		else
-	#endif	
+	#endif
 		{}
 #endif
 }
@@ -807,4 +760,3 @@ odm_SwAntDivConstructScanChnl(
 }
 
 #endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/rtchnlplan.c b/drivers/net/wireless/rtl8814au/hal/phydm/rtchnlplan.c
index 4b41ff1..6fa9894 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/rtchnlplan.c
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/rtchnlplan.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -19,12 +19,12 @@
  ******************************************************************************/
 
 /******************************************************************************
-     
+
  History:
 	Data		Who		Remark (Internal History)
-	
+
 	05/14/2012	MH		Collect RTK inernal infromation and generate channel plan draft.
-	
+
 ******************************************************************************/
 
 //============================================================
@@ -41,73 +41,73 @@
 //
 
 /*
-	Channel Plan Contents					
-	Domain Code		EEPROM	Countries in Specific Domain		
-			2G RD		5G RD		Bit[6:0]	2G	5G	
-	Case	Old Define				00h~1Fh	Old Define	Old Define	
-	1		2G_WORLD	5G_NULL		20h		Worldwird 13	NA	
-	2		2G_ETSI1	5G_NULL		21h		Europe 2G		NA	
-	3		2G_FCC1		5G_NULL		22h		US 2G			NA	
-	4		2G_MKK1		5G_NULL		23h		Japan 2G		NA	
-	5		2G_ETSI2	5G_NULL		24h		France 2G		NA	
+	Channel Plan Contents
+	Domain Code		EEPROM	Countries in Specific Domain
+			2G RD		5G RD		Bit[6:0]	2G	5G
+	Case	Old Define				00h~1Fh	Old Define	Old Define
+	1		2G_WORLD	5G_NULL		20h		Worldwird 13	NA
+	2		2G_ETSI1	5G_NULL		21h		Europe 2G		NA
+	3		2G_FCC1		5G_NULL		22h		US 2G			NA
+	4		2G_MKK1		5G_NULL		23h		Japan 2G		NA
+	5		2G_ETSI2	5G_NULL		24h		France 2G		NA
 	6		2G_FCC1		5G_FCC1		25h		US 2G			US 5G					Kj{
 	7		2G_WORLD	5G_ETSI1	26h		Worldwird 13	Europe					Kj{
 	8		2G_MKK1		5G_MKK1		27h		Japan 2G		Japan 5G				Kj{
 	9		2G_WORLD	5G_KCC1		28h		Worldwird 13	Korea					Kj{
-	10		2G_WORLD	5G_FCC2		29h		Worldwird 13	US o/w DFS Channels		
-	11		2G_WORLD	5G_FCC3		30h		Worldwird 13	India, Mexico	    	
-	12		2G_WORLD	5G_FCC4		31h		Worldwird 13	Venezuela	        	
-	13		2G_WORLD	5G_FCC5		32h		Worldwird 13	China	            	
-	14		2G_WORLD	5G_FCC6		33h		Worldwird 13	Israel	            	
+	10		2G_WORLD	5G_FCC2		29h		Worldwird 13	US o/w DFS Channels
+	11		2G_WORLD	5G_FCC3		30h		Worldwird 13	India, Mexico
+	12		2G_WORLD	5G_FCC4		31h		Worldwird 13	Venezuela
+	13		2G_WORLD	5G_FCC5		32h		Worldwird 13	China
+	14		2G_WORLD	5G_FCC6		33h		Worldwird 13	Israel
 	15		2G_FCC1		5G_FCC7		34h		US 2G			US/Canada				Kj{
 	16		2G_WORLD	5G_ETSI2	35h		Worldwird 13	Australia, New Zealand	Kj{
-	17		2G_WORLD	5G_ETSI3	36h		Worldwird 13	Russia	
-	18		2G_MKK1		5G_MKK2		37h		Japan 2G		Japan (W52, W53)	
-	19		2G_MKK1		5G_MKK3		38h		Japan 2G		Japan (W56)	
+	17		2G_WORLD	5G_ETSI3	36h		Worldwird 13	Russia
+	18		2G_MKK1		5G_MKK2		37h		Japan 2G		Japan (W52, W53)
+	19		2G_MKK1		5G_MKK3		38h		Japan 2G		Japan (W56)
 	20		2G_FCC1		5G_NCC1		39h		US 2G			Taiwan					Kj{
-						
+
 	NA		2G_WORLD	5G_FCC1		7F		FCC	FCC DFS Channels	Realtek Define
-						
-						
-						
-						
-						
-	2.4G 	Regulatory 	Domains					
+
+
+
+
+
+	2.4G 	Regulatory 	Domains
 	Case	2G RD		Regulation	Channels	Frequencyes		Note					Countries in Specific Domain
 	1		2G_WORLD	ETSI		1~13		2412~2472		Passive scan CH 12, 13	Worldwird 13
 	2		2G_ETSI1	ETSI		1~13		2412~2472								Europe
 	3		2G_FCC1		FCC			1~11		2412~2462								US
 	4		2G_MKK1		MKK			1~13, 14	2412~2472, 2484							Japan
 	5		2G_ETSI2	ETSI		10~13		2457~2472								France
-						
-						
-						
-						
-	5G Regulatory Domains					
+
+
+
+
+	5G Regulatory Domains
 	Case	5G RD		Regulation	Channels			Frequencyes					Note											Countries in Specific Domain
-	1		5G_NULL		NA			NA					NA							Do not support 5GHz	
-	2		5G_ETSI1	ETSI		"36~48, 52~64,  	
+	1		5G_NULL		NA			NA					NA							Do not support 5GHz
+	2		5G_ETSI1	ETSI		"36~48, 52~64,
 									100~140"			"5180~5240, 5260~5230
 														5500~5700"					Band1, Ban2, Band3								Europe
-	3		5G_ETSI2	ETSI		"36~48, 52~64, 
+	3		5G_ETSI2	ETSI		"36~48, 52~64,
 									100~140, 149~165"	"5180~5240, 5260~5230
 														5500~5700, 5745~5825"		Band1, Ban2, Band3, Band4						Australia, New Zealand
-	4		5G_ETSI3	ETSI		"36~48, 52~64, 
-														100~132, 149~165"	
+	4		5G_ETSI3	ETSI		"36~48, 52~64,
+														100~132, 149~165"
 														"5180~5240, 5260~5230
 														5500~5660, 5745~5825"		Band1, Ban2, Band3(except CH 136, 140), Band4"	Russia
-	5		5G_FCC1		FCC			"36~48, 52~64, 
-									100~140, 149~165"	
+	5		5G_FCC1		FCC			"36~48, 52~64,
+									100~140, 149~165"
 														"5180~5240, 5260~5230
 														5500~5700, 5745~5825"		Band1(5150~5250MHz), 
 																					Band2(5250~5350MHz),
 																					Band3(5470~5725MHz),
 																					Band4(5725~5850MHz)"							US
 	6		5G_FCC2		FCC			36~48, 149~165		5180~5240, 5745~5825		Band1, Band4	FCC o/w DFS Channels
-	7		5G_FCC3		FCC			"36~48, 52~64, 
+	7		5G_FCC3		FCC			"36~48, 52~64,
 									149~165"			"5180~5240, 5260~5230
 														5745~5825"					Band1, Ban2, Band4								India, Mexico
-	8		5G_FCC4		FCC			"36~48, 52~64, 
+	8		5G_FCC4		FCC			"36~48, 52~64,
 									149~161"			"5180~5240, 5260~5230
 														5745~5805"					Band1, Ban2,
 																					Band4(except CH 165)"							Venezuela
@@ -115,20 +115,20 @@
 	10		5G_FCC6		FCC			36~48, 52~64		5180~5240, 5260~5230		Band1, Band2									Israel
 	11		5G_FCC7
 			5G_IC1		FCC
-						IC"			"36~48, 52~64, 
-									100~116, 136, 140, 
+						IC"			"36~48, 52~64,
+									100~116, 136, 140,
 									149~165"			"5180~5240, 5260~5230
-														5500~5580, 5680, 5700, 
+														5500~5580, 5680, 5700,
 														5745~5825"					"Band1, Band2, 
 																					Band3(except 5600~5650MHz),
 																					Band4"											"US
 																																	Canada"
-	12		5G_KCC1		KCC			"36~48, 52~64, 
+	12		5G_KCC1		KCC			"36~48, 52~64,
 									100~124, 149~165"	"5180~5240, 5260~5230
 														5500~5620, 5745~5825"		"Band1, Ban2, 
 																					Band3(5470~5650MHz),
 																					Band4"											Korea
-	13		5G_MKK1		MKK			"36~48, 52~64, 
+	13		5G_MKK1		MKK			"36~48, 52~64,
 									100~140"			"5180~5240, 5260~5230
 														5500~5700"					W52, W53, W56									Japan
 	14		5G_MKK2		MKK			36~48, 52~64		5180~5240, 5260~5230		W52, W53										Japan (W52, W53)
@@ -136,17 +136,17 @@
 	16		5G_NCC1		NCC			"56~64,
 									100~116, 136, 140,
 									149~165"			"5260~5320
-														5500~5580, 5680, 5700, 
+														5500~5580, 5680, 5700,
 														5745~5825"					"Band2(except CH 52), 
 																					Band3(except 5600~5650MHz),
 																					Band4"											Taiwan
-						
-						
-*/						
-						
+
+
+*/
+
+//
+// 2.4G CHannel
 //
-// 2.4G CHannel 
-//						
 /*
 
 	2.4G Band		Regulatory Domains																RTL8192D	
@@ -176,7 +176,7 @@
 //
 /*
 
-	5G Band		RTL8192D	RTL8195 (Jaguar)				Jaguar 2	Regulatory Domains											
+	5G Band		RTL8192D	RTL8195 (Jaguar)				Jaguar 2	Regulatory Domains
 	Channel Number	Channel Frequency	Global	Global				Global	"US
 (FCC 15.407)"	"Canada
 (FCC, except 5.6~5.65GHz)"	Argentina, Australia, New Zealand, Brazil, S. Africa (FCC/ETSI)	"Europe
@@ -199,7 +199,7 @@
 	56	5280	v	v				v	v	v	v	Indoor		v	Indoor	Indoor	v	v	Indoor	v
 	60	5300	v	v	v			v	v	v	v	Indoor		v	Indoor	Indoor	v	v	Indoor	v
 	64	5320	v	v				v	v	v	v	Indoor		v	Indoor	Indoor	v	v	Indoor	v
-																				
+
 "Band 3
 5.47GHz
 ~
@@ -209,13 +209,13 @@
 	108	5540	v	v	v			v	v	v	v	v				v	v	v	v	
 	112	5560	v	v				v	v	v	v	v				v	v	v	v	
 	116	5580	v	v	v	v		v	v	v	v	v				v	v	v	v	
-	120	5600	v	v				v	Indoor		v	Indoor				v	v	v		
-	124	5620	v	v	v			v	Indoor		v	Indoor				v	v	v		
-	128	5640	v	v				v	Indoor		v	Indoor				v		v		
-	132	5660	v	v	v	E		v	Indoor		v	Indoor				v		v		
+	120	5600	v	v				v	Indoor		v	Indoor				v	v	v
+	124	5620	v	v	v			v	Indoor		v	Indoor				v	v	v
+	128	5640	v	v				v	Indoor		v	Indoor				v		v
+	132	5660	v	v	v	E		v	Indoor		v	Indoor				v		v
 	136	5680	v	v				v	v	v	v	v				v			v	
 	140	5700	v	v	E			v	v	v	v	v				v			v	
-	144	5720	E	E				E												
+	144	5720	E	E				E
 "Band 4
 5.725GHz
 ~
@@ -225,14 +225,14 @@
 	157	5785	v	v	v			v	v	v	v		v	v			v	v	v	v
 	161	5805	v	v				v	v	v	v		v	v			v	v	v	v
 	165	5825	v	v	P	P		v	v	v	v		v	v			v	v	v	
-	169	5845	P	P				P												
-	173	5865	P	P	P			P												
-	177	5885	P	P				P												
+	169	5845	P	P				P
+	173	5865	P	P	P			P
+	177	5885	P	P				P
 Channel Count			28	28	14	7	0	28	24	20	24	19	5	13	8	19	20	22	15	12
 			E: FCC accepted the ask for CH144 from Accord.					PS: 160MHz  80MHz+80MHz{H			Argentina	Belgium (Q)		India	Israel			Russia		
 			P: Customer's requirement from James.								Australia	The Netherlands ()		Mexico	Turkey			Ukraine		
-											New Zealand	UK (^)		Singapore						
-											Brazil	Switzerland (h)								
+											New Zealand	UK (^)		Singapore
+											Brazil	Switzerland (h)
 
 
 */
@@ -240,11 +240,11 @@ Channel Count			28	28	14	7	0	28	24	20	24	19	5	13	8	19	20	22	15	12
 /*---------------------------Define Local Constant---------------------------*/
 
 
-// define Maximum Power v.s each band for each region 
+// define Maximum Power v.s each band for each region
 // ISRAEL
 // Format:
 // RT_CHANNEL_DOMAIN_Region ={{{Chnl_Start, Chnl_end, Pwr_dB_Max}, {Chn2_Start, Chn2_end, Pwr_dB_Max}, {Chn3_Start, Chn3_end, Pwr_dB_Max}, {Chn4_Start, Chn4_end, Pwr_dB_Max}, {Chn5_Start, Chn5_end, Pwr_dB_Max}}, Limit_Num} */
-// RT_CHANNEL_DOMAIN_FCC ={{{01,11,30}, {36,48,17}, {52,64,24}, {100,140,24}, {149,165,30}}, 5} 
+// RT_CHANNEL_DOMAIN_FCC ={{{01,11,30}, {36,48,17}, {52,64,24}, {100,140,24}, {149,165,30}}, 5}
 // "NR" is non-release channle.
 // Issue--- Israel--Russia--New Zealand
 // DOMAIN_01= (2G_WORLD, 5G_NULL)
@@ -272,8 +272,8 @@ Channel Count			28	28	14	7	0	28	24	20	24	19	5	13	8	19	20	22	15	12
 
 static	RT_CHANNEL_PLAN_MAXPWR	ChnlPlanPwrMax_2G[] = {
 
-	// 2G_WORLD, 
-	{{1, 13, 20}, 1},	
+	// 2G_WORLD,
+	{{1, 13, 20}, 1},
 
 	// 2G_ETSI1
 	{{1, 13, 20}, 1},
@@ -292,7 +292,7 @@ static	RT_CHANNEL_PLAN_MAXPWR	ChnlPlanPwrMax_2G[] = {
 /*
 //===========================================1:(2G_WORLD, 5G_NULL)
 
-RT_CHANNEL_PLAN_MAXPWR	RT_DOMAIN_01 ={{{01,13,20}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}}, 1} 
+RT_CHANNEL_PLAN_MAXPWR	RT_DOMAIN_01 ={{{01,13,20}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}, {NR,NR,0}}, 1}
 
 //===========================================2:(2G_ETSI1, 5G_NULL)
 
@@ -374,56 +374,56 @@ RT_DOMAIN_23 ={{{01,13,20}, {36,48,23}, {52,64,23}, {100,140,30}, {149,165,30}},
 //
 // Counter & Realtek Channel plan transfer table.
 //
-RT_CHNL_CTRY_TBL	RtCtryChnlTbl[] = 
+RT_CHNL_CTRY_TBL	RtCtryChnlTbl[] =
 {
 
 	{
-		RT_CTRY_AL,							//	"Albania"					
+		RT_CTRY_AL,							//	"Albania"
 		"AL",
 		RT_2G_WORLD,
-		RT_5G_WORLD,		
+		RT_5G_WORLD,
 		RT_CHANNEL_DOMAIN_UNDEFINED			// 2G/5G world.
 	},
-#if 0	
+#if 0
 	{
-		RT_CTRY_BB,							//  "Barbadosh"				
+		RT_CTRY_BB,							//  "Barbadosh"
 		"BB",
 		RT_2G_WORLD,
-		RT_5G_NULL,		
+		RT_5G_NULL,
 		RT_CHANNEL_DOMAIN_EFUSE_0x20		// 2G world. 5G_NULL
 	},
-	
+
 	{
-		RT_CTRY_DE,							//  "Germanyw"					
+		RT_CTRY_DE,							//  "Germanyw"
 		"DE",
 		RT_2G_WORLD,
-		RT_5G_ETSI1,		
+		RT_5G_ETSI1,
 		RT_CHANNEL_DOMAIN_EFUSE_0x26
 	},
-	
+
 	{
-		RT_CTRY_US,							//  "Germanyw"					
+		RT_CTRY_US,							//  "Germanyw"
 		"US",
 		RT_2G_FCC1,
-		RT_5G_FCC7,		
+		RT_5G_FCC7,
 		RT_CHANNEL_DOMAIN_EFUSE_0x34
 	},
 
 	{
-		RT_CTRY_JP,							//  "Germanyw"					
+		RT_CTRY_JP,							//  "Germanyw"
 		"JP",
 		RT_2G_MKK1,
-		RT_5G_MKK1,		
+		RT_5G_MKK1,
 		RT_CHANNEL_DOMAIN_EFUSE_0x34
 	},
-		
+
 	{
-		RT_CTRY_TW,							//  "Germanyw"					
+		RT_CTRY_TW,							//  "Germanyw"
 		"TW",
 		RT_2G_FCC1,
-		RT_5G_NCC1,		
+		RT_5G_NCC1,
 		RT_CHANNEL_DOMAIN_EFUSE_0x39
-	},	
+	},
 #endif
 
 };	// RtCtryChnlTbl
@@ -437,13 +437,13 @@ static	RT_CHANNEL_PLAN_NEW		RtChnlPlan[] =
 {
 	// Channel Plan   0x20.
 	{
-		&RtCtryChnlTbl[1],					// RT_CHNL_CTRY_TBL Country & channel plan transfer table.		
-		RT_CHANNEL_DOMAIN_EFUSE_0x20,		// RT_CHANNEL_DOMAIN RT Channel Plan Define 
+		&RtCtryChnlTbl[1],					// RT_CHNL_CTRY_TBL Country & channel plan transfer table.
+		RT_CHANNEL_DOMAIN_EFUSE_0x20,		// RT_CHANNEL_DOMAIN RT Channel Plan Define
 		RT_2G_WORLD,						// RT_REGULATION_2G
 		RT_5G_NULL,							// RT_REGULATION_5G
 		RT_WORLD,							// RT_REGULATION_CMN RT Regulatory domain definition.
 		RT_SREQ_NA,							// RT Channel plan special & customerize requirement.
-		
+
 		CHNL_RT_2G_WORLD,
 		CHNL_RT_2G_WORLD_SCAN_TYPE,
 		&ChnlPlanPwrMax_2G[0],
@@ -451,31 +451,27 @@ static	RT_CHANNEL_PLAN_NEW		RtChnlPlan[] =
 		CHNL_RT_5G_NULL,
 		CHNL_RT_5G_NULL_SCAN_TYPE,
 
-		
+
 	},
-	
+
 	// Channel Plan   0x26.
 	{
-		&RtCtryChnlTbl[1],					// RT_CHNL_CTRY_TBL Country & channel plan transfer table.		
-		RT_CHANNEL_DOMAIN_EFUSE_0x26,		// RT_CHANNEL_DOMAIN RT Channel Plan Define 
+		&RtCtryChnlTbl[1],					// RT_CHNL_CTRY_TBL Country & channel plan transfer table.
+		RT_CHANNEL_DOMAIN_EFUSE_0x26,		// RT_CHANNEL_DOMAIN RT Channel Plan Define
 		RT_2G_WORLD,						// RT_REGULATION_2G
 		RT_5G_ETSI1,						// RT_REGULATION_5G
 		RT_WORLD,							// RT_REGULATION_CMN RT Regulatory domain definition.
 		RT_SREQ_NA,							// RT Channel plan special & customerize requirement.
-		
+
 		CHNL_RT_2G_WORLD,					// 2G workd cannel
 		CHNL_RT_2G_WORLD_SCAN_TYPE,
 		&ChnlPlanPwrMax_2G[1],
-		
+
 		CHNL_RT_5G_ETSI1,
 		CHNL_RT_5G_ETSI1_SCAN_TYPE,
-		
-	}
-	
-	
-};
-#endif
-
 
+	}
 
 
+};
+#endif
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/rtchnlplan.h b/drivers/net/wireless/rtl8814au/hal/phydm/rtchnlplan.h
index 37786cf..4589257 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/rtchnlplan.h
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/rtchnlplan.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -41,7 +41,7 @@ typedef enum _RT_CHANNEL_DOMAIN_NEW
 	// .....
 
 	RT_CHANNEL_DOMAIN_MAX_NEW,
-	
+
 }RT_CHANNEL_DOMAIN_NEW, *PRT_CHANNEL_DOMAIN_NEW;
 
 
@@ -90,7 +90,7 @@ typedef enum _RT_CHANNEL_DOMAIN_NEW
 #define DOMAIN_CODE_5G_NCC1 \
         {56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 24
 #define DOMAIN_CODE_5G_NCC2 \
-        {56,60,64,149,153,157,161,165}, 8  			
+        {56,60,64,149,153,157,161,165}, 8
 #define UNDEFINED \
         {0}, 0
 #endif
@@ -103,157 +103,157 @@ typedef enum _RT_CHANNEL_DOMAIN_NEW
 Countries							"Country Abbreviation"	Domain Code					SKU's	Ch# of 20MHz
 															2G			5G						Ch# of 40MHz
 "Albania"					AL													Local Test	
-									    					        	            	
-"AlgeriaQ"					DZ									CE TCF	    	
-					                    					        	            	
-"Antigua & Barbudawq&F"	AG						2G_WORLD					FCC TCF	
-					                    					        	        		
+
+"AlgeriaQ"					DZ									CE TCF
+
+"Antigua & Barbudawq&F"			AG						2G_WORLD					FCC TCF
+
 "Argentina"					AR						2G_WORLD					Local Test	
-									    					        	        		
+
 "Armenia"					AM						2G_WORLD					ETSI	
-									    					        	        		
+
 "Aruba|q"						AW						2G_WORLD					FCC TCF	
-															        	
-"AustraliaDw"						AU						2G_WORLD		5G_ETSI2		
-															        	
-"AustriaaQ"						AT						2G_WORLD		5G_ETSI1	CE	
-					    			    					        	
-"Azerbaijan"				AZ						2G_WORLD					CE TCF	
-					                    					        	
-"Bahamas"						BS						2G_WORLD				
-									    					        	
+
+"AustraliaDw"						AU						2G_WORLD		5G_ETSI2
+
+"AustriaaQ"						AT						2G_WORLD		5G_ETSI1	CE
+
+"Azerbaijan"					AZ						2G_WORLD					CE TCF	
+
+"Bahamas"						BS						2G_WORLD
+
 "Barbadosh"					BB						2G_WORLD					FCC TCF	
-									    					        	
-"BelgiumQ"						BE						2G_WORLD		5G_ETSI1	CE	
-															        	
-"Bermuda}F"						BM						2G_WORLD					FCC TCF	
-															        	        		
+
+"BelgiumQ"						BE						2G_WORLD		5G_ETSI1	CE
+
+"Bermuda}F"						BM						2G_WORLD					FCC TCF
+
 "Brazil"						BR						2G_WORLD					Local Test	
-									    					        	
-"BulgariaO[Q"					BG						2G_WORLD		5G_ETSI1	CE	
-									    					        	
+
+"BulgariaO[Q"					BG						2G_WORLD		5G_ETSI1	CE
+
 "Canada[j"						CA						2G_FCC1			5G_FCC7		IC / FCC	IC / FCC
-					                    					        	
-"Cayman Islands}sq"			KY						2G_WORLD		5G_ETSI1	CE	
-					                    					        	
-"ChileQ"							CL						2G_WORLD					FCC TCF	
-																    	
-"China"							CN						2G_WORLD		5G_FCC5		H?i2002j353? 	
-					                    					        	
-"Columbia"					CO						2G_WORLD					Voluntary 	
-					    			    					        	
-"Costa RicaF["				CR						2G_WORLD					FCC TCF	
-					    			    					        	
-"Cyprus"					CY						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Czech J"						CZ						2G_WORLD		5G_ETSI1	CE	
-															        	
-"Denmark"						DK						2G_WORLD		5G_ETSI1	CE	
-					                    					        	
-"Dominican Republich[@M"	DO						2G_WORLD					FCC TCF	
-					                    					        	
-"EgyptJ"	EG	2G_WORLD			CE T												CF	    	
-					                    					        	
-"El Salvadorh"				SV						2G_WORLD					Voluntary	
-					        		    					        	
-"EstoniaRF"					EE						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Finland"						FI						2G_WORLD		5G_ETSI1	CE	
-															        	
-"Francek"						FR										5G_E		TSI1	CE	
-															        	
-"Germanyw"						DE						2G_WORLD		5G_ETSI1	CE	
-															        	
-"Greece "						GR						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Guamq"							GU						2G_WORLD				
-									    					        	
-"Guatemalaa"					GT						2G_WORLD				
-									    					        	
-"Haitia"							HT						2G_WORLD					FCC TCF	
-									    					        	
-"Honduras"					HN						2G_WORLD					FCC TCF	
-									    					        	
-"HungaryIQ"						HU						2G_WORLD		5G_ETSI1	CE	
-															        	
-"IcelandBq"						IS						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"IndiaL"							IN						2G_WORLD		5G_FCC3		FCC/CE TCF	
-															        	
-"IrelandR"						IE						2G_WORLD		5G_ETSI1	CE	
-															        	
-"IsraelHC"						IL										5G_F		CC6	CE TCF	
-															        	
-"ItalyqjQ"						IT						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Japan"							JP						2G_MKK1			5G_MKK1		MKK	MKK
-																    	
-"Korea"							KR						2G_WORLD		5G_KCC1		KCC	KCC
-									    					        	
-"Latvia"					LV						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Lithuania{"					LT						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Luxembourgc"					LU						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Malaysia"					MY						2G_WORLD					Local Test	
-									    					        	
-"MaltaL"						MT						2G_WORLD		5G_ETSI1	CE	
-															        	
-"Mexico"						MX						2G_WORLD		5G_FCC3		Local Test	
-															        	
-"Morocco"						MA													CE TCF	
-									    					        	
-"Netherlands"					NL						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"New Zealand"					NZ						2G_WORLD		5G_ETSI2		
-									    					        	
-"Norway"						NO						2G_WORLD		5G_ETSI1	CE	
-															        	
+
+"Cayman Islands}sq"					KY						2G_WORLD		5G_ETSI1	CE
+
+"ChileQ"						CL						2G_WORLD					FCC TCF	
+
+"China"						CN						2G_WORLD		5G_FCC5		H?i2002j353? 	
+
+"Columbia"					CO						2G_WORLD					Voluntary
+
+"Costa RicaF["					CR						2G_WORLD					FCC TCF	
+
+"Cyprus"					CY						2G_WORLD		5G_ETSI1	CE
+
+"Czech J"						CZ						2G_WORLD		5G_ETSI1	CE
+
+"Denmark"						DK						2G_WORLD		5G_ETSI1	CE
+
+"Dominican Republich[@M"			DO						2G_WORLD					FCC TCF
+
+"EgyptJ"						EG						2G_WORLD				CE T												CF
+
+"El Salvadorh"					SV						2G_WORLD					Voluntary
+
+"EstoniaRF"					EE						2G_WORLD		5G_ETSI1	CE
+
+"Finland"						FI						2G_WORLD		5G_ETSI1	CE
+
+"Francek"						FR									5G_E		TSI1	CE
+
+"Germanyw"						DE						2G_WORLD		5G_ETSI1	CE
+
+"Greece "						GR						2G_WORLD		5G_ETSI1	CE
+
+"Guamq"						GU						2G_WORLD
+
+"Guatemalaa"					GT						2G_WORLD
+
+"Haitia"						HT						2G_WORLD				FCC TCF
+
+"Honduras"					HN						2G_WORLD				FCC TCF
+
+"HungaryIQ"						HU						2G_WORLD		5G_ETSI1	CE
+
+"IcelandBq"						IS						2G_WORLD		5G_ETSI1	CE
+
+"IndiaL"						IN						2G_WORLD		5G_FCC3		FCC/CE TCF	
+
+"IrelandR"						IE						2G_WORLD		5G_ETSI1	CE
+
+"IsraelHC"						IL									5G_F		CC6	CE TCF	
+
+"ItalyqjQ"						IT						2G_WORLD		5G_ETSI1	CE
+
+"Japan"						JP						2G_MKK1			5G_MKK1		MKK	MKK
+
+"Korea"						KR						2G_WORLD		5G_KCC1		KCC	KCC
+
+"Latvia"						LV						2G_WORLD		5G_ETSI1	CE
+
+"Lithuania{"						LT						2G_WORLD		5G_ETSI1	CE
+
+"Luxembourgc"					LU						2G_WORLD		5G_ETSI1	CE
+
+"Malaysia"					MY						2G_WORLD					Local Test
+
+"MaltaL"						MT						2G_WORLD		5G_ETSI1	CE
+
+"Mexico"						MX						2G_WORLD		5G_FCC3		Local Test
+
+"Morocco"						MA													CE TCF
+
+"Netherlands"					NL						2G_WORLD		5G_ETSI1	CE
+
+"New Zealand"					NZ						2G_WORLD		5G_ETSI2
+
+"Norway"						NO						2G_WORLD		5G_ETSI1	CE
+
 "Panama "						PA						2G_FCC1						Voluntary	
-									    					        	
+
 "Philippines"					PH						2G_WORLD					FCC TCF	
-									    					        	
-"Polandi"						PL						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Portugal"					PT						2G_WORLD		5G_ETSI1	CE	
-									    					        	
-"Romania"					RO						2G_WORLD		5G_ETSI1	CE	
-					        		    					        	
-"RussiaX"						RU						2G_WORLD		5G_ETSI3	CE TCF	
-					        		    					        	
-"Saudi ArabiaFaB"			SA						2G_WORLD					CE TCF	
-					        		    					        	
-"Singapores[Y"					SG						2G_WORLD				
-									    					        	
-"SlovakiaJ"					SK						2G_WORLD		5G_ETSI1	CE	
-					    			    					        	
-"Slovenia"				SI						2G_WORLD		5G_ETSI1	CE	
-					    			    					        	
-"South AfricanD"					ZA						2G_WORLD					CE TCF	
-					        		    					        	
-"SpainZ"						ES										5G_ETSI1	CE	
-															        	
-"Sweden"						SE						2G_WORLD		5G_ETSI1	CE	
-					        		    					        	
-"Switzerlandh"					CH						2G_WORLD		5G_ETSI1	CE	
-					        		    					        	
-"TaiwanOW"						TW						2G_FCC1			5G_NCC1	NCC	
-															        	
-"Thailand"						TH						2G_WORLD					FCC/CE TCF	
-															        	
-"Turkeyg"						TR						2G_WORLD				
-															        	
-"UkraineQJ"						UA						2G_WORLD					Local Test	
-					        		    					        	
-"United Kingdom^"				GB						2G_WORLD		5G_ETSI1	CE	ETSI
-					    			    					        	
+
+"Polandi"						PL						2G_WORLD		5G_ETSI1	CE
+
+"Portugal"					PT						2G_WORLD		5G_ETSI1	CE
+
+"Romania"					RO						2G_WORLD		5G_ETSI1	CE
+
+"RussiaX"						RU						2G_WORLD		5G_ETSI3	CE TCF
+
+"Saudi ArabiaFaB"					SA						2G_WORLD					CE TCF
+
+"Singapores[Y"					SG						2G_WORLD
+
+"SlovakiaJ"					SK						2G_WORLD		5G_ETSI1	CE
+
+"Slovenia"					SI						2G_WORLD		5G_ETSI1	CE
+
+"South AfricanD"					ZA						2G_WORLD					CE TCF
+
+"SpainZ"						ES									5G_ETSI1	CE
+
+"Sweden"						SE						2G_WORLD		5G_ETSI1	CE
+
+"Switzerlandh"					CH						2G_WORLD		5G_ETSI1	CE
+
+"TaiwanOW"						TW						2G_FCC1			5G_NCC1	NCC
+
+"Thailand"						TH						2G_WORLD					FCC/CE TCF
+
+"Turkeyg"						TR						2G_WORLD
+
+"UkraineQJ"						UA						2G_WORLD					Local Test
+
+"United Kingdom^"					GB						2G_WORLD		5G_ETSI1	CE	ETSI
+
 "United States"					US						2G_FCC1			5G_FCC7		FCC	FCC
-					    			    					        	
+
 "Venezuelae"					VE						2G_WORLD		5G_FCC4		FCC TCF	
-					    			    					        	
+
 "VietnamVn"						VN						2G_WORLD					FCC/CE TCF	
-					
+
 
 
 */
@@ -261,86 +261,86 @@ Countries							"Country Abbreviation"	Domain Code					SKU's	Ch# of 20MHz
 // Counter abbervation.
 typedef enum _RT_COUNTRY_DEFINE_NUM
 {
-	RT_CTRY_AL,				//	"Albania"					
-	RT_CTRY_DZ,             //  "AlgeriaQ"					
-	RT_CTRY_AG,             //  "Antigua & Barbudawq&F"	
-	RT_CTRY_AR,             //  "Argentina"					
-	RT_CTRY_AM,             //  "Armenia"					
-	RT_CTRY_AW,             //  "Aruba|q"						
-	RT_CTRY_AU,             //  "AustraliaDw"						
-	RT_CTRY_AT,             //  "AustriaaQ"						
-	RT_CTRY_AZ,             //  "Azerbaijan"				
-	RT_CTRY_BS,             //  "Bahamas"					
-	RT_CTRY_BB,             //  "Barbadosh"				
-	RT_CTRY_BE,             //  "BelgiumQ"					
-	RT_CTRY_BM,             //  "Bermuda}F"					
-	RT_CTRY_BR,             //  "Brazil"						
-	RT_CTRY_BG,             //  "BulgariaO[Q"				
-	RT_CTRY_CA,             //  "Canada[j"					
-	RT_CTRY_KY,             //  "Cayman Islands}sq"			
-	RT_CTRY_CL,             //  "ChileQ"						
-	RT_CTRY_CN,             //  "China"						
-	RT_CTRY_CO,             //  "Columbia"				
-	RT_CTRY_CR,             //  "Costa RicaF["			
-	RT_CTRY_CY,             //  "Cyprus"					
-	RT_CTRY_CZ,             //  "Czech J"						
-	RT_CTRY_DK,             //  "Denmark"					
-	RT_CTRY_DO,             //  "Dominican Republich[@M"	
-	RT_CTRY_CE,             //  "EgyptJ"	EG	2G_WORLD			
-	RT_CTRY_SV,             //  "El Salvadorh"				
-	RT_CTRY_EE,             //  "EstoniaRF"					
-	RT_CTRY_FI,             //  "Finland"						
-	RT_CTRY_FR,             //  "Francek"						
-	RT_CTRY_DE,             //  "Germanyw"					
-	RT_CTRY_GR,             //  "Greece "					
-	RT_CTRY_GU,             //  "Guamq"						
-	RT_CTRY_GT,             //  "Guatemalaa"				
-	RT_CTRY_HT,             //  "Haitia"						
-	RT_CTRY_HN,             //  "Honduras"				
-	RT_CTRY_HU,             //  "HungaryIQ"					
-	RT_CTRY_IS,             //  "IcelandBq"					
-	RT_CTRY_IN,             //  "IndiaL"						
-	RT_CTRY_IE,             //  "IrelandR"					
-	RT_CTRY_IL,             //  "IsraelHC"					
-	RT_CTRY_IT,             //  "ItalyqjQ"					
-	RT_CTRY_JP,             //  "Japan"						
-	RT_CTRY_KR,             //  "Korea"						
-	RT_CTRY_LV,             //  "Latvia"					
-	RT_CTRY_LT,             //  "Lithuania{"				
-	RT_CTRY_LU,             //  "Luxembourgc"				
-	RT_CTRY_MY,             //  "Malaysia"				
-	RT_CTRY_MT,             //  "MaltaL"					
-	RT_CTRY_MX,             //  "Mexico"					
-	RT_CTRY_MA,             //  "Morocco"					
-	RT_CTRY_NL,             //  "Netherlands"				
-	RT_CTRY_NZ,             //  "New Zealand"				
-	RT_CTRY_NO,             //  "Norway"						
-	RT_CTRY_PA,             //  "Panama "					
-	RT_CTRY_PH,             //  "Philippines"				
-	RT_CTRY_PL,             //  "Polandi"						
-	RT_CTRY_PT,             //  "Portugal"					
-	RT_CTRY_RO,             //  "Romania"				
-	RT_CTRY_RU,             //  "RussiaX"					
-	RT_CTRY_SA,             //  "Saudi ArabiaFaB"			
-	RT_CTRY_SG,             //  "Singapores[Y"				
-	RT_CTRY_SK,             //  "SlovakiaJ"				
-	RT_CTRY_SI,             //  "Slovenia"				
-	RT_CTRY_ZA,             //  "South AfricanD"				
-	RT_CTRY_ES,             //  "SpainZ"					
-	RT_CTRY_SE,             //  "Sweden"						
-	RT_CTRY_CH,             //  "Switzerlandh"				
-	RT_CTRY_TW,             //  "TaiwanOW"						
-	RT_CTRY_TH,             //  "Thailand"					
-	RT_CTRY_TR,             //  "Turkeyg"					
-	RT_CTRY_UA,             //  "UkraineQJ"					
-	RT_CTRY_GB,             //  "United Kingdom^"				
-	RT_CTRY_US,             //  "United States"				
-	RT_CTRY_VE,             //  "Venezuelae"				
-	RT_CTRY_VN,             //  "VietnamVn"					
-	RT_CTRY_MAX,            //  
-	
+	RT_CTRY_AL,				//	"Albania"
+	RT_CTRY_DZ,             //  "AlgeriaQ"
+	RT_CTRY_AG,             //  "Antigua & Barbudawq&F"
+	RT_CTRY_AR,             //  "Argentina"
+	RT_CTRY_AM,             //  "Armenia"
+	RT_CTRY_AW,             //  "Aruba|q"
+	RT_CTRY_AU,             //  "AustraliaDw"
+	RT_CTRY_AT,             //  "AustriaaQ"
+	RT_CTRY_AZ,             //  "Azerbaijan"
+	RT_CTRY_BS,             //  "Bahamas"
+	RT_CTRY_BB,             //  "Barbadosh"
+	RT_CTRY_BE,             //  "BelgiumQ"
+	RT_CTRY_BM,             //  "Bermuda}F"
+	RT_CTRY_BR,             //  "Brazil"
+	RT_CTRY_BG,             //  "BulgariaO[Q"
+	RT_CTRY_CA,             //  "Canada[j"
+	RT_CTRY_KY,             //  "Cayman Islands}sq"
+	RT_CTRY_CL,             //  "ChileQ"
+	RT_CTRY_CN,             //  "China"
+	RT_CTRY_CO,             //  "Columbia"
+	RT_CTRY_CR,             //  "Costa RicaF["
+	RT_CTRY_CY,             //  "Cyprus"
+	RT_CTRY_CZ,             //  "Czech J"
+	RT_CTRY_DK,             //  "Denmark"
+	RT_CTRY_DO,             //  "Dominican Republich[@M"
+	RT_CTRY_CE,             //  "EgyptJ"	EG	2G_WORLD
+	RT_CTRY_SV,             //  "El Salvadorh"
+	RT_CTRY_EE,             //  "EstoniaRF"
+	RT_CTRY_FI,             //  "Finland"
+	RT_CTRY_FR,             //  "Francek"
+	RT_CTRY_DE,             //  "Germanyw"
+	RT_CTRY_GR,             //  "Greece "
+	RT_CTRY_GU,             //  "Guamq"
+	RT_CTRY_GT,             //  "Guatemalaa"
+	RT_CTRY_HT,             //  "Haitia"
+	RT_CTRY_HN,             //  "Honduras"
+	RT_CTRY_HU,             //  "HungaryIQ"
+	RT_CTRY_IS,             //  "IcelandBq"
+	RT_CTRY_IN,             //  "IndiaL"
+	RT_CTRY_IE,             //  "IrelandR"
+	RT_CTRY_IL,             //  "IsraelHC"
+	RT_CTRY_IT,             //  "ItalyqjQ"
+	RT_CTRY_JP,             //  "Japan"
+	RT_CTRY_KR,             //  "Korea"
+	RT_CTRY_LV,             //  "Latvia"
+	RT_CTRY_LT,             //  "Lithuania{"
+	RT_CTRY_LU,             //  "Luxembourgc"
+	RT_CTRY_MY,             //  "Malaysia"
+	RT_CTRY_MT,             //  "MaltaL"
+	RT_CTRY_MX,             //  "Mexico"
+	RT_CTRY_MA,             //  "Morocco"
+	RT_CTRY_NL,             //  "Netherlands"
+	RT_CTRY_NZ,             //  "New Zealand"
+	RT_CTRY_NO,             //  "Norway"
+	RT_CTRY_PA,             //  "Panama "
+	RT_CTRY_PH,             //  "Philippines"
+	RT_CTRY_PL,             //  "Polandi"
+	RT_CTRY_PT,             //  "Portugal"
+	RT_CTRY_RO,             //  "Romania"
+	RT_CTRY_RU,             //  "RussiaX"
+	RT_CTRY_SA,             //  "Saudi ArabiaFaB"
+	RT_CTRY_SG,             //  "Singapores[Y"
+	RT_CTRY_SK,             //  "SlovakiaJ"
+	RT_CTRY_SI,             //  "Slovenia"
+	RT_CTRY_ZA,             //  "South AfricanD"
+	RT_CTRY_ES,             //  "SpainZ"
+	RT_CTRY_SE,             //  "Sweden"
+	RT_CTRY_CH,             //  "Switzerlandh"
+	RT_CTRY_TW,             //  "TaiwanOW"
+	RT_CTRY_TH,             //  "Thailand"
+	RT_CTRY_TR,             //  "Turkeyg"
+	RT_CTRY_UA,             //  "UkraineQJ"
+	RT_CTRY_GB,             //  "United Kingdom^"
+	RT_CTRY_US,             //  "United States"
+	RT_CTRY_VE,             //  "Venezuelae"
+	RT_CTRY_VN,             //  "VietnamVn"
+	RT_CTRY_MAX,            //
+
 }RT_COUNTRY_NAME, *PRT_COUNTRY_NAME;
-    
+
 // Scan type including active and passive scan.
 typedef enum _RT_SCAN_TYPE_NEW
 {
@@ -349,32 +349,32 @@ typedef enum _RT_SCAN_TYPE_NEW
 	SCAN_PAS,
 	SCAN_BOTH,
 }RT_SCAN_TYPE_NEW, *PRT_SCAN_TYPE_NEW;
-    
+
 
 // Power table sample.
 
 typedef struct _RT_CHNL_PLAN_LIMIT
 {
 	u2Byte	Chnl_Start;
-	u2Byte	Chnl_end;	
-	
+	u2Byte	Chnl_end;
+
 	u2Byte	Freq_Start;
-	u2Byte	Freq_end;	
+	u2Byte	Freq_end;
 }RT_CHNL_PLAN_LIMIT, *PRT_CHNL_PLAN_LIMIT;
 
-    
-//    
+
+//
 // 2.4G Regulatory Domains
 //
 typedef enum _RT_REGULATION_DOMAIN_2G
 {
-	RT_2G_NULL,   
+	RT_2G_NULL,
 	RT_2G_WORLD,
 	RT_2G_ETSI1,
 	RT_2G_FCC1,
 	RT_2G_MKK1,
-	RT_2G_ETSI2	
-	
+	RT_2G_ETSI2
+
 }RT_REGULATION_2G, *PRT_REGULATION_2G;
 
 
@@ -382,12 +382,12 @@ typedef enum _RT_REGULATION_DOMAIN_2G
 //{
 //	u1Byte	Chnl;
 //	RT_SCAN_TYPE_NEW
-//	
+//
 //}RT_CHANNEL_BEHAVIOR, *PRT_CHANNEL_BEHAVIOR;
 
 //typedef struct _RT_CHANNEL_PLAN_TYPE
 //{
-//	RT_CHANNEL_BEHAVIOR		
+//	RT_CHANNEL_BEHAVIOR
 //	u1Byte					Chnl_num;
 //}RT_CHNL_PLAN_TYPE, *PRT_CHNL_PLAN_TYPE;
 
@@ -447,17 +447,17 @@ typedef enum _RT_REGULATION_DOMAIN_2G
         {2457, 2472}, 1
 
 
-//    
+//
 // 5G Regulatory Domains
 //
 typedef enum _RT_REGULATION_DOMAIN_5G
-{   
+{
 	RT_5G_NULL,
 	RT_5G_WORLD,
 	RT_5G_ETSI1,
 	RT_5G_ETSI2,
 	RT_5G_ETSI3,
-	RT_5G_FCC1,	
+	RT_5G_FCC1,
 	RT_5G_FCC2,
 	RT_5G_FCC3,
 	RT_5G_FCC4,
@@ -470,7 +470,7 @@ typedef enum _RT_REGULATION_DOMAIN_5G
 	RT_5G_MKK2,
 	RT_5G_MKK3,
 	RT_5G_NCC1,
-	
+
 }RT_REGULATION_5G, *PRT_REGULATION_5G;
 
 //
@@ -511,7 +511,7 @@ typedef enum _RT_REGULATION_DOMAIN_5G
 #define CHNL_RT_5G_MKK3 \
         {56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 24
 #define CHNL_RT_5G_NCC1 \
-        {56,60,64,149,153,157,161,165}, 8  	
+        {56,60,64,149,153,157,161,165}, 8
 
 //
 // 5G Channel Active or passive scan.
@@ -551,26 +551,26 @@ typedef enum _RT_REGULATION_DOMAIN_5G
 #define CHNL_RT_5G_MKK3_SCAN_TYPE \
         {56,60,64,100,104,108,112,116,136,140,149,153,157,161,165}, 24
 #define CHNL_RT_5G_NCC1_SCAN_TYPE \
-        {56,60,64,149,153,157,161,165}, 8  	
+        {56,60,64,149,153,157,161,165}, 8
 
-//    
+//
 // Global Regulation
 //
 typedef enum _RT_REGULATION_COMMON
 {
-	RT_WORLD,   
-	RT_FCC,   
+	RT_WORLD,
+	RT_FCC,
 	RT_MKK,
 	RT_ETSI,
 	RT_IC,
 	RT_CE,
 	RT_NCC,
-	
+
 }RT_REGULATION_CMN, *PRT_REGULATION_CMN;
 
 
 
-//    
+//
 // Special requirement for different regulation domain.
 // For internal test or customerize special request.
 //
@@ -580,46 +580,46 @@ typedef enum _RT_CHNLPLAN_SREQ
 	RT_SREQ_2G_ADHOC_11N			= 0x00000001,
 	RT_SREQ_2G_ADHOC_11B			= 0x00000002,
 	RT_SREQ_2G_ALL_PASS				= 0x00000004,
-	RT_SREQ_2G_ALL_ACT				= 0x00000008,	
+	RT_SREQ_2G_ALL_ACT				= 0x00000008,
 	RT_SREQ_5G_ADHOC_11N			= 0x00000010,
 	RT_SREQ_5G_ADHOC_11AC			= 0x00000020,
 	RT_SREQ_5G_ALL_PASS				= 0x00000040,
 	RT_SREQ_5G_ALL_ACT				= 0x00000080,
-	RT_SREQ_C1_PLAN					= 0x00000100,	
-	RT_SREQ_C2_PLAN					= 0x00000200,	
-	RT_SREQ_C3_PLAN					= 0x00000400,	
-	RT_SREQ_C4_PLAN					= 0x00000800,	
-	RT_SREQ_NFC_ON					= 0x00001000,	
+	RT_SREQ_C1_PLAN					= 0x00000100,
+	RT_SREQ_C2_PLAN					= 0x00000200,
+	RT_SREQ_C3_PLAN					= 0x00000400,
+	RT_SREQ_C4_PLAN					= 0x00000800,
+	RT_SREQ_NFC_ON					= 0x00001000,
 	RT_SREQ_MASK					= 0x0000FFFF,   /* Requirements bit mask */
-	
+
 }RT_CHNLPLAN_SREQ, *PRT_CHNLPLAN_SREQ;
 
 
 //
 // RT_COUNTRY_NAME & RT_REGULATION_2G & RT_REGULATION_5G transfer table
-// 
+//
 //
 typedef struct _RT_CHANNEL_PLAN_COUNTRY_TRANSFER_TABLE
-{   
+{
+	//
+	// Define countery domain and corresponding
 	//
-	// Define countery domain and corresponding 
-	//	
 	RT_COUNTRY_NAME		Country_Enum;
 	char				Country_Name[3];
-	
+
 	//char		Domain_Name[12];
-	RT_REGULATION_2G	Domain_2G;	
+	RT_REGULATION_2G	Domain_2G;
 
-	RT_REGULATION_5G	Domain_5G;	
+	RT_REGULATION_5G	Domain_5G;
 
 	RT_CHANNEL_DOMAIN	RtChDomain;
 	//u1Byte		Country_Area;
-    
+
 }RT_CHNL_CTRY_TBL, *PRT_CHNL_CTRY_TBL;
-    
+
 
 #define		RT_MAX_CHNL_NUM_2G		13
-#define		RT_MAX_CHNL_NUM_5G		44	
+#define		RT_MAX_CHNL_NUM_5G		44
 
 // Power table sample.
 
@@ -640,7 +640,7 @@ typedef struct _RT_CHANNEL_PLAN_MAXPWR
 	RT_CHNL_PWR_LIMIT	Chnl[RT_MAX_BAND_NUM];
 	u1Byte				Band_Useful_Num;
 
-	
+
 }RT_CHANNEL_PLAN_MAXPWR, *PRT_CHANNEL_PLAN_MAXPWR;
 
 
@@ -651,49 +651,45 @@ typedef struct _RT_CHANNEL_PLAN_MAXPWR
 
 
 typedef struct _RT_CHANNEL_PLAN_NEW
-{   
+{
 	//
-	// Define countery domain and corresponding 
+	// Define countery domain and corresponding
 	//
 	//char		Country_Name[36];
 	//u1Byte		Country_Enum;
-	
+
 	//char		Domain_Name[12];
 
-	
+
 	PRT_CHNL_CTRY_TBL		pCtryTransfer;
-	
-	RT_CHANNEL_DOMAIN		RtChDomain;	
+
+	RT_CHANNEL_DOMAIN		RtChDomain;
 
 	RT_REGULATION_2G		Domain_2G;
 
-	RT_REGULATION_5G		Domain_5G;	
+	RT_REGULATION_5G		Domain_5G;
 
 	RT_REGULATION_CMN		Regulator;
 
 	RT_CHNLPLAN_SREQ		ChnlSreq;
-	
+
 	//RT_CHNL_PLAN_LIMIT		RtChnl;
-		
+
 	u1Byte	Chnl2G[MAX_CHANNEL_NUM];				// CHNL_RT_2G_WORLD
 	u1Byte	Len2G;
 	u1Byte	Chnl2GScanTp[MAX_CHANNEL_NUM];			// CHNL_RT_2G_WORLD_SCAN_TYPE
 	//u1Byte	Freq2G[2];								// FREQ_RT_2G_WORLD
 
-	u1Byte	Chnl5G[MAX_CHANNEL_NUM];				
+	u1Byte	Chnl5G[MAX_CHANNEL_NUM];
 	u1Byte	Len5G;
 	u1Byte	Chnl5GScanTp[MAX_CHANNEL_NUM];
 	//u1Byte	Freq2G[2];								// FREQ_RT_2G_WORLD
 
 	RT_CHANNEL_PLAN_MAXPWR	ChnlMaxPwr;
-	
-    
+
+
 }RT_CHANNEL_PLAN_NEW, *PRT_CHANNEL_PLAN_NEW;
-    
-    
+
+
 #endif	// __RT_CHANNELPLAN_H__
-    
-    
-    
-    
- 
+
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/rtl8821a/phydm_iqk_8821a_ce.c b/drivers/net/wireless/rtl8814au/hal/phydm/rtl8821a/phydm_iqk_8821a_ce.c
index 28905fd..b3f7bc2 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/rtl8821a/phydm_iqk_8821a_ce.c
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/rtl8821a/phydm_iqk_8821a_ce.c
@@ -33,10 +33,10 @@
 void DoIQK_8821A(
 	PVOID		pDM_VOID,
 	u1Byte 		DeltaThermalIndex,
-	u1Byte		ThermalValue,	
+	u1Byte		ThermalValue,
 	u1Byte 		Threshold
 	)
-{	
+{
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	pDM_Odm->RFCalibrateInfo.ThermalValue_IQK= ThermalValue;
 	PHY_IQCalibrate_8821A(pDM_Odm, FALSE);
@@ -47,7 +47,7 @@ void _IQK_RX_FillIQC_8821A(
 	IN ODM_RF_RADIO_PATH_E 	Path,
 	IN unsigned int			RX_X,
 	IN unsigned int			RX_Y
-	) 
+	)
 {
 	switch (Path) {
 	case ODM_RF_PATH_A:
@@ -60,8 +60,8 @@ void _IQK_RX_FillIQC_8821A(
 		}
 		break;
 	default:
-		break;					
-	};	
+		break;
+	};
 }
 
 void _IQK_TX_FillIQC_8821A(
@@ -69,7 +69,7 @@ void _IQK_TX_FillIQC_8821A(
 	IN ODM_RF_RADIO_PATH_E 	Path,
 	IN unsigned int			TX_X,
 	IN unsigned int			TX_Y
-	) 
+	)
 {
 	switch (Path) {
 	case ODM_RF_PATH_A:
@@ -85,14 +85,14 @@ void _IQK_TX_FillIQC_8821A(
 		}
 		break;
 	default:
-		break;					
-	};	
+		break;
+	};
 }
 
 void _IQK_BackupMacBB_8821A(
 	IN PDM_ODM_T	pDM_Odm,
 	IN pu4Byte		MACBB_backup,
-	IN pu4Byte		Backup_MACBB_REG, 
+	IN pu4Byte		Backup_MACBB_REG,
 	IN u4Byte		MACBB_NUM
 	)
 {
@@ -102,17 +102,17 @@ void _IQK_BackupMacBB_8821A(
 	for (i = 0; i < MACBB_NUM; i++){
 		MACBB_backup[i] = ODM_Read4Byte(pDM_Odm, Backup_MACBB_REG[i]);
 	}
-	
+
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("BackupMacBB Success!!!!\n"));
 }
 
 void _IQK_BackupRF_8821A(
 	IN PDM_ODM_T	pDM_Odm,
 	IN pu4Byte		RFA_backup,
-	IN pu4Byte		RFB_backup, 
-	IN pu4Byte		Backup_RF_REG, 
+	IN pu4Byte		RFB_backup,
+	IN pu4Byte		Backup_RF_REG,
 	IN u4Byte		RF_NUM
-	)	
+	)
 {
 
 	u4Byte i;
@@ -127,15 +127,15 @@ void _IQK_BackupRF_8821A(
 void _IQK_BackupAFE_8821A(
 	IN PDM_ODM_T		pDM_Odm,
 	IN pu4Byte		AFE_backup,
-	IN pu4Byte		Backup_AFE_REG, 
+	IN pu4Byte		Backup_AFE_REG,
 	IN u4Byte		AFE_NUM
 	)
 {
 	u4Byte i;
 	ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
-	//Save AFE Parameters 
+	//Save AFE Parameters
     	for (i = 0; i < AFE_NUM; i++){
-        	AFE_backup[i] = ODM_Read4Byte(pDM_Odm, Backup_AFE_REG[i]);	
+        	AFE_backup[i] = ODM_Read4Byte(pDM_Odm, Backup_AFE_REG[i]);
     	}
     	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("BackupAFE Success!!!!\n"));
 }
@@ -143,13 +143,13 @@ void _IQK_BackupAFE_8821A(
 void _IQK_RestoreMacBB_8821A(
 	IN PDM_ODM_T		pDM_Odm,
 	IN pu4Byte		MACBB_backup,
-	IN pu4Byte		Backup_MACBB_REG, 
+	IN pu4Byte		Backup_MACBB_REG,
 	IN u4Byte		MACBB_NUM
-	)	
+	)
 {
 	u4Byte i;
 	ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
-	//Reload MacBB Parameters 
+	//Reload MacBB Parameters
     	for (i = 0; i < MACBB_NUM; i++){
         	ODM_Write4Byte(pDM_Odm, Backup_MACBB_REG[i], MACBB_backup[i]);
     	}
@@ -163,7 +163,7 @@ void _IQK_RestoreRF_8821A(
 	IN pu4Byte 				RF_backup,
 	IN u4Byte				RF_REG_NUM
 	)
-{	
+{
 	u4Byte i;
 
 	ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
@@ -184,13 +184,13 @@ void _IQK_RestoreRF_8821A(
 void _IQK_RestoreAFE_8821A(
 	IN PDM_ODM_T		pDM_Odm,
 	IN pu4Byte		AFE_backup,
-	IN pu4Byte		Backup_AFE_REG, 
+	IN pu4Byte		Backup_AFE_REG,
 	IN u4Byte		AFE_NUM
 	)
 {
 	u4Byte i;
 	ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
-	//Reload AFE Parameters 
+	//Reload AFE Parameters
     	for (i = 0; i < AFE_NUM; i++){
         	ODM_Write4Byte(pDM_Odm, Backup_AFE_REG[i], AFE_backup[i]);
     	}
@@ -240,7 +240,7 @@ void _IQK_Tx_8821A(
 	while (cal < cal_num_8821A){
 		switch (Path) {
 			case ODM_RF_PATH_A:
-			{	
+			{
 				//Path-A LOK
 				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
 				// ========Path-A AFE all on========
@@ -291,7 +291,7 @@ void _IQK_Tx_8821A(
 
 				ODM_delay_ms(10); //Delay 10ms
 				ODM_Write4Byte(pDM_Odm, 0xcb8, 0x00000000);
-				
+
 				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
 				ODM_SetRFReg(pDM_Odm, Path, 0x58, 0x7fe00, ODM_GetRFReg(pDM_Odm, Path, 0x8, 0xffc00)); // Load LOK
 				switch (*pDM_Odm->pBandWidth)
@@ -305,12 +305,12 @@ void _IQK_Tx_8821A(
 						{
 						ODM_SetRFReg(pDM_Odm, Path, 0x18, 0x00c00, 0x0);
 						}
-						break;					
+						break;
 					default:
 							break;
 					}
 				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1); // [31] = 1 --> Page C1
-				
+
 				// 3. TX RF Setting
 				ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
 				ODM_SetRFReg(pDM_Odm, Path, 0xef, bRFRegOffsetMask, 0x80000);
@@ -390,19 +390,18 @@ void _IQK_Tx_8821A(
 				                        	}
 				                    	}
 
-							if (delay_count < 20){							// If 20ms No Result, then cal_retry++
+							if (delay_count < 20) {							// If 20ms No Result, then cal_retry++
 					              	// ============TXIQK Check==============
 								TX_fail = ODM_GetBBReg(pDM_Odm, 0xd00, BIT(12));
-								
-								if (~TX_fail){
+
+								if (~TX_fail) {
 									ODM_Write4Byte(pDM_Odm, 0xcb8, 0x02000000);
 									VDF_X[k] = ODM_GetBBReg(pDM_Odm, 0xd00, 0x07ff0000)<<21;
 									ODM_Write4Byte(pDM_Odm, 0xcb8, 0x04000000);
 									VDF_Y[k] = ODM_GetBBReg(pDM_Odm, 0xd00, 0x07ff0000)<<21;
 									TX0IQKOK = TRUE;
 									break;
-								}
-								else{
+								} else {
 									ODM_SetBBReg(pDM_Odm, 0xccc, 0x000007ff, 0x0);
 									ODM_SetBBReg(pDM_Odm, 0xcd4, 0x000007ff, 0x200);
 									TX0IQKOK = FALSE;
@@ -411,8 +410,7 @@ void _IQK_Tx_8821A(
 										break;
 									}
 								}
-							}
-				                    else{
+							} else {
 				                    		TX0IQKOK = FALSE;
 				                        	cal_retry++;
 				                        	if (cal_retry == 10){
@@ -421,17 +419,16 @@ void _IQK_Tx_8821A(
 				                    }
 				       	}
 					}
-					if (k == 3){
+					if (k == 3) {
 						TX_X0[cal] = VDF_X[k-1] ;
 						TX_Y0[cal] = VDF_Y[k-1];
 					}
-				}
-				else{
+				} else {
 				ODM_Write4Byte(pDM_Odm, 0xc80, 0x18008c10);// TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16
 				ODM_Write4Byte(pDM_Odm, 0xc84, 0x38008c10);// RX_Tone_idx[9:0], RxK_Mask[29]
 				ODM_Write4Byte(pDM_Odm, 0xcb8, 0x00100000);// cb8[20] N SI/PI v iqk_dpk module
 				cal_retry = 0;
-				while(1){
+				while (1) {
 					// one shot
 					ODM_Write4Byte(pDM_Odm, 0x980, 0xfa000000);
 					ODM_Write4Byte(pDM_Odm, 0x980, 0xf8000000);
@@ -439,12 +436,11 @@ void _IQK_Tx_8821A(
 						ODM_delay_ms(10); //Delay 10ms
 					ODM_Write4Byte(pDM_Odm, 0xcb8, 0x00000000);
 					delay_count = 0;
-					while (1){
+					while (1) {
 						IQK_ready = ODM_GetBBReg(pDM_Odm, 0xd00, BIT(10));
 						if ((~IQK_ready) || (delay_count>20)) {
 					       	break;
-					}
-					else{
+					} else {
 							ODM_delay_ms(1);
 					       delay_count++;
 					}
@@ -453,7 +449,7 @@ void _IQK_Tx_8821A(
 					if (delay_count < 20){							// If 20ms No Result, then cal_retry++
 				       // ============TXIQK Check==============
 					TX_fail = ODM_GetBBReg(pDM_Odm, 0xd00, BIT(12));
-							
+
 						if (~TX_fail){
 							ODM_Write4Byte(pDM_Odm, 0xcb8, 0x02000000);
 							TX_X0[cal] = ODM_GetBBReg(pDM_Odm, 0xd00, 0x07ff0000)<<21;
@@ -461,8 +457,7 @@ void _IQK_Tx_8821A(
 							TX_Y0[cal] = ODM_GetBBReg(pDM_Odm, 0xd00, 0x07ff0000)<<21;
 							TX0IQKOK = TRUE;
 							break;
-						}
-						else{
+						} else {
 							ODM_SetBBReg(pDM_Odm, 0xccc, 0x000007ff, 0x0);
 							ODM_SetBBReg(pDM_Odm, 0xcd4, 0x000007ff, 0x200);
 							TX0IQKOK = FALSE;
@@ -471,19 +466,18 @@ void _IQK_Tx_8821A(
 								break;
 							}
 						}
-					}
-	                    		else{
+					} else {
 	                        		TX0IQKOK = FALSE;
 	                        		cal_retry++;
 	                        		if (cal_retry == 10)
-	                            		break;	
+	                            		break;
 	                    		}
 	                	}
 			}
 
 			if (TX0IQKOK == FALSE)
 				break;				// TXK fail, Don't do RXK
-			
+
                 	//====== RX IQK ======
                 	ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x0); // [31] = 0 --> Page C
 			// 1. RX RF Setting
@@ -494,28 +488,27 @@ void _IQK_Tx_8821A(
 			ODM_SetRFReg(pDM_Odm, Path, 0x8f, bRFRegOffsetMask, 0x88001);
 			ODM_SetRFReg(pDM_Odm, Path, 0x65, bRFRegOffsetMask, 0x931d8);
 			ODM_SetRFReg(pDM_Odm, Path, 0xef, bRFRegOffsetMask, 0x00000);
-			
+
 			ODM_SetBBReg(pDM_Odm, 0x978, 0x03FF8000, (TX_X0[cal])>>21&0x000007ff);
-                     ODM_SetBBReg(pDM_Odm, 0x978, 0x000007FF, (TX_Y0[cal])>>21&0x000007ff);
+                        ODM_SetBBReg(pDM_Odm, 0x978, 0x000007FF, (TX_Y0[cal])>>21&0x000007ff);
 			ODM_SetBBReg(pDM_Odm, 0x978, BIT(31), 0x1);
 			ODM_SetBBReg(pDM_Odm, 0x97c, BIT(31), 0x0);
 			ODM_Write4Byte(pDM_Odm, 0x90c, 0x00008000);
 			ODM_Write4Byte(pDM_Odm, 0x984, 0x0046a911);
-			
+
 			ODM_SetBBReg(pDM_Odm, 0x82c, BIT(31), 0x1); // [31] = 1 --> Page C1
 			ODM_Write4Byte(pDM_Odm, 0xc80, 0x38008c10);// TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16
 			ODM_Write4Byte(pDM_Odm, 0xc84, 0x18008c10);// RX_Tone_idx[9:0], RxK_Mask[29]
 			ODM_Write4Byte(pDM_Odm, 0xc88, 0x02140119);
 
-			if (pDM_Odm->SupportInterface == 1){
+			if (pDM_Odm->SupportInterface == 1) {
 				RXIQK_Loop = 2;				// for 2% fail;
-			}
-			else{
+			} else {
 				RXIQK_Loop = 1;
 			}
-			for(i = 0; i < RXIQK_Loop; i++){
+			for (i = 0; i < RXIQK_Loop; i++) {
 				if (pDM_Odm->SupportInterface == 1)
-						if(i == 0)
+						if (i == 0)
 							ODM_Write4Byte(pDM_Odm, 0xc8c, 0x28161100);  //Good
 						else
 							ODM_Write4Byte(pDM_Odm, 0xc8c, 0x28160d00);
@@ -523,9 +516,9 @@ void _IQK_Tx_8821A(
 					ODM_Write4Byte(pDM_Odm, 0xc8c, 0x28160d00);
 
 				ODM_Write4Byte(pDM_Odm, 0xcb8, 0x00100000);// cb8[20] N SI/PI v iqk_dpk module
-				
+
 				cal_retry = 0;
-				while(1){
+				while(1) {
 					// one shot
 					ODM_Write4Byte(pDM_Odm, 0x980, 0xfa000000);
 					ODM_Write4Byte(pDM_Odm, 0x980, 0xf8000000);
@@ -533,17 +526,16 @@ void _IQK_Tx_8821A(
 					ODM_delay_ms(10); //Delay 10ms
 					ODM_Write4Byte(pDM_Odm, 0xcb8, 0x00000000);
 					delay_count = 0;
-					while (1){
+					while (1) {
 						IQK_ready = ODM_GetBBReg(pDM_Odm, 0xd00, BIT(10));
 						if ((~IQK_ready)||(delay_count>20)){
 							break;
-						}
-						else{
+						} else {
 							ODM_delay_ms(1);
 							delay_count++;
 						}
 					}
-							
+
 					if (delay_count < 20){	// If 20ms No Result, then cal_retry++
 						// ============RXIQK Check==============
 						RX_fail = ODM_GetBBReg(pDM_Odm, 0xd00, BIT(11));
@@ -564,33 +556,31 @@ void _IQK_Tx_8821A(
 							Image_Power = (reg2<<32)+reg1;
 							DbgPrint("After PW = %d\n", Image_Power);
 							*/
-							
+
 							ODM_Write4Byte(pDM_Odm, 0xcb8, 0x06000000);
 								RX_X0[i][cal] = ODM_GetBBReg(pDM_Odm, 0xd00, 0x07ff0000)<<21;
 							ODM_Write4Byte(pDM_Odm, 0xcb8, 0x08000000);
 								RX_Y0[i][cal] = ODM_GetBBReg(pDM_Odm, 0xd00, 0x07ff0000)<<21;
 							RX0IQKOK = TRUE;
 							break;
-						}
-						else{
+						} else {
 							ODM_SetBBReg(pDM_Odm, 0xc10, 0x000003ff, 0x200>>1);
 							ODM_SetBBReg(pDM_Odm, 0xc10, 0x03ff0000, 0x0>>1);
 							RX0IQKOK = FALSE;
 							cal_retry++;
 							if (cal_retry == 10)
 								break;
-								
+
 						}
-					}
-					else{
+					} else {
 			                    	RX0IQKOK = FALSE;
 			                    	cal_retry++;
 			                    	if (cal_retry == 10)
 			                     	break;
 	                    		}
 				}
-			}	
-			
+			}
+
                 	if (TX0IQKOK)
                     		TX_Average++;
 			if (RX0IQKOK)
@@ -598,27 +588,27 @@ void _IQK_Tx_8821A(
 		}
 		break;
 	default:
-		break;					
+		break;
 		}
 	cal++;
 	}
 	// FillIQK Result
-	switch (Path){
+	switch (Path) {
 	case ODM_RF_PATH_A:
        {
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("========Path_A =======\n"));
 		if (TX_Average == 0)
 		    	break;
-		
-		for (i = 0; i < TX_Average; i++){
+
+		for (i = 0; i < TX_Average; i++) {
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("TX_X0[%d] = %x ;; TX_Y0[%d] = %x\n", i, (TX_X0[i])>>21&0x000007ff, i, (TX_Y0[i])>>21&0x000007ff));
 		}
-		for (i = 0; i < TX_Average; i++){
-			for (ii = i+1; ii <TX_Average; ii++){
+		for (i = 0; i < TX_Average; i++) {
+			for (ii = i+1; ii <TX_Average; ii++) {
 				dx = (TX_X0[i]>>21) - (TX_X0[ii]>>21);
-				if (dx < 3 && dx > -3){
+				if (dx < 3 && dx > -3) {
 					dy = (TX_Y0[i]>>21) - (TX_Y0[ii]>>21);
-						if (dy < 3 && dy > -3){
+						if (dy < 3 && dy > -3) {
 							TX_X = ((TX_X0[i]>>21) + (TX_X0[ii]>>21))/2;
 							TX_Y = ((TX_Y0[i]>>21) + (TX_Y0[ii]>>21))/2;
 							TX_finish = 1;
@@ -628,22 +618,22 @@ void _IQK_Tx_8821A(
 			}
 			if (TX_finish == 1)
 				break;
-		}	
+		}
 
 		if (TX_finish == 1){
 			_IQK_TX_FillIQC_8821A(pDM_Odm, Path, TX_X, TX_Y);
-		}
-		else{
+		} else {
 			_IQK_TX_FillIQC_8821A(pDM_Odm, Path, 0x200, 0x0);
 		}
-		
+
 		if (RX_Average == 0)
 		    	break;
-		
+
 		for (i = 0; i < RX_Average; i++){
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("RX_X0[0][%d] = %x ;; RX_Y0[0][%d] = %x\n", i, (RX_X0[0][i])>>21&0x000007ff, i, (RX_Y0[0][i])>>21&0x000007ff));
-			if (RXIQK_Loop == 2)
+			if (RXIQK_Loop == 2) {
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("RX_X0[1][%d] = %x ;; RX_Y0[1][%d] = %x\n", i, (RX_X0[1][i])>>21&0x000007ff, i, (RX_Y0[1][i])>>21&0x000007ff));
+			}
 		}
 		for (i = 0; i < RX_Average; i++){
 			for (ii = i+1; ii <RX_Average; ii++){
@@ -680,7 +670,7 @@ void _IQK_Tx_8821A(
 				}
 					if (RX_finish2 == 1)
 					break;
-			}	
+			}
 			if(RX_finish1 && RX_finish2){
 				RX_X = (RX_X+RX_X_temp)/2;
 				RX_Y = (RX_Y+RX_Y_temp)/2;
@@ -688,8 +678,7 @@ void _IQK_Tx_8821A(
 		}
 		if (RX_finish1 || RX_finish2){
 			_IQK_RX_FillIQC_8821A(pDM_Odm, Path, RX_X, RX_Y);
-		}
-		else{
+		} else {
 			_IQK_RX_FillIQC_8821A(pDM_Odm, Path, 0x200, 0x0);
 		}
 		}
@@ -699,7 +688,7 @@ void _IQK_Tx_8821A(
 	}
 }
 
-#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)                         
+#if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
 VOID
 phy_IQCalibrate_By_FW_8821A(
 	IN 	PDM_ODM_T	pDM_Odm
@@ -727,34 +716,34 @@ phy_IQCalibrate_By_FW_8821A(
 		Buf2 = 0x1<<2;
 	else
 		Buf2 = 0x1<<3;
-	
+
 	IQKcmd[1] = Buf1 | Buf2;
 	IQKcmd[2] = pDM_Odm->ExtPA5G | pDM_Odm->ExtLNA5G<<1;
-	
+
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("== FW IQK Start ==\n"));
 	pDM_Odm->RFCalibrateInfo.IQK_StartTime = 0;
 	pDM_Odm->RFCalibrateInfo.IQK_StartTime = ODM_GetCurrentTime( pDM_Odm);
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("== StartTime: %lld\n", pDM_Odm->RFCalibrateInfo.IQK_StartTime));
 	ODM_FillH2CCmd(pDM_Odm, ODM_H2C_IQ_CALIBRATION, 3, IQKcmd);
-	
+
 
 }
 #endif
-                         
-VOID	
+
+VOID
 phy_IQCalibrate_8821A(
 	IN PDM_ODM_T		pDM_Odm
 	)
 {
 	u4Byte	MACBB_backup[MACBB_REG_NUM_8821A], AFE_backup[AFE_REG_NUM_8821A], RFA_backup[RF_REG_NUM_8821A], RFB_backup[RF_REG_NUM_8821A];
-	u4Byte 	Backup_MACBB_REG[MACBB_REG_NUM_8821A] = {0x520, 0x550, 0x808, 0xa04, 0x90c, 0xc00, 0x838, 0x82c}; 
-	u4Byte 	Backup_AFE_REG[AFE_REG_NUM_8821A] = {0xc5c, 0xc60, 0xc64, 0xc68}; 
-	u4Byte 	Backup_RF_REG[RF_REG_NUM_8821A] = {0x65, 0x8f, 0x0}; 
+	u4Byte 	Backup_MACBB_REG[MACBB_REG_NUM_8821A] = {0x520, 0x550, 0x808, 0xa04, 0x90c, 0xc00, 0x838, 0x82c};
+	u4Byte 	Backup_AFE_REG[AFE_REG_NUM_8821A] = {0xc5c, 0xc60, 0xc64, 0xc68};
+	u4Byte 	Backup_RF_REG[RF_REG_NUM_8821A] = {0x65, 0x8f, 0x0};
 
 	_IQK_BackupMacBB_8821A(pDM_Odm, MACBB_backup, Backup_MACBB_REG, MACBB_REG_NUM_8821A);
 	_IQK_BackupAFE_8821A(pDM_Odm, AFE_backup, Backup_AFE_REG, AFE_REG_NUM_8821A);
 	_IQK_BackupRF_8821A(pDM_Odm, RFA_backup, RFB_backup, Backup_RF_REG, RF_REG_NUM_8821A);
-	
+
 	_IQK_ConfigureMAC_8821A(pDM_Odm);
 	_IQK_Tx_8821A(pDM_Odm, ODM_RF_PATH_A);
 
@@ -763,7 +752,7 @@ phy_IQCalibrate_8821A(
 	_IQK_RestoreMacBB_8821A(pDM_Odm, MACBB_backup, Backup_MACBB_REG, MACBB_REG_NUM_8821A);
 }
 
-VOID 
+VOID
 PHY_ResetIQKResult_8821A(
 	IN	PDM_ODM_T	pDM_Odm
 )
@@ -786,12 +775,12 @@ PHY_IQCalibrate_8821A(
 {
 #if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
 	PADAPTER 		pAdapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 
-	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
-	u4Byte			counter = 0;	
+	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	u4Byte			counter = 0;
 	#endif
-#endif	
+#endif
 
 #if (DM_ODM_SUPPORT_TYPE & ODM_WIN )
 	if (ODM_CheckPowerStatus(pAdapter) == FALSE)
@@ -799,26 +788,24 @@ PHY_IQCalibrate_8821A(
 #endif
 
 	if (pDM_Odm->mp_mode){   		//(MP_DRIVER == 1)
-		#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+		#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 			#if (MP_DRIVER == 1)
-		PMPT_CONTEXT	pMptCtx = &(pAdapter->MptCtx);	
+		PMPT_CONTEXT	pMptCtx = &(pAdapter->MptCtx);
 				if( pMptCtx->bSingleTone || pMptCtx->bCarrierSuppression)
 				return;
 			#endif
 		#else// (DM_ODM_SUPPORT_TYPE == ODM_CE)
-		PMPT_CONTEXT	pMptCtx = &(pAdapter->mppriv.MptCtx);		
+		PMPT_CONTEXT	pMptCtx = &(pAdapter->mppriv.MptCtx);
 		if( pMptCtx->bSingleTone || pMptCtx->bCarrierSuppression)
 			return;
-		#endif	
-		
+		#endif
+
 	}
 	pDM_Odm->IQKFWOffload = 0;
-	
+
 	//3 == FW IQK ==
-	if(pDM_Odm->IQKFWOffload)
-	{
-		if ( ! pDM_Odm->RFCalibrateInfo.bIQKInProgress) 
-		{
+	if(pDM_Odm->IQKFWOffload) {
+		if ( ! pDM_Odm->RFCalibrateInfo.bIQKInProgress) {
 			ODM_AcquireSpinLock( pDM_Odm, RT_IQK_SPINLOCK);
 			pDM_Odm->RFCalibrateInfo.bIQKInProgress = TRUE;
 			ODM_ReleaseSpinLock( pDM_Odm, RT_IQK_SPINLOCK);
@@ -850,7 +837,7 @@ PHY_IQCalibrate_8821A(
 		}
 	}
 	//3 == Driver IQK ==
-	else {			
+	else {
 		if ( ! pDM_Odm->RFCalibrateInfo.bIQKInProgress) {
 			ODM_AcquireSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
 			pDM_Odm->RFCalibrateInfo.bIQKInProgress = TRUE;
@@ -860,17 +847,14 @@ PHY_IQCalibrate_8821A(
 			phy_IQCalibrate_8821A(pDM_Odm);
 			pDM_Odm->RFCalibrateInfo.IQK_ProgressingTime = ODM_GetProgressingTime( pDM_Odm, pDM_Odm->RFCalibrateInfo.IQK_StartTime);
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("IQK ProgressingTime = %lld ms\n", pDM_Odm->RFCalibrateInfo.IQK_ProgressingTime));
-			
+
 			ODM_AcquireSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
 			pDM_Odm->RFCalibrateInfo.bIQKInProgress = FALSE;
 			ODM_ReleaseSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
-		}
-		else
-		{
+		} else {
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("== Return the IQK CMD, because the IQK in Progress ==\n"));
 		}
 	}
-	
+
 }
 #endif
-
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/txbf/halcomtxbf.c b/drivers/net/wireless/rtl8814au/hal/phydm/txbf/halcomtxbf.c
index 395a217..d4bc10c 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/txbf/halcomtxbf.c
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/txbf/halcomtxbf.c
@@ -17,8 +17,9 @@ halComTxbf_beamformInit(
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
-	if (pDM_Odm->SupportICType & ODM_RTL8822B)
+	if (pDM_Odm->SupportICType & ODM_RTL8822B) {
 		HalTxbf8822B_Init(pDM_Odm);
+	}
 }
 
 /*Only used for MU BFer Entry when get GID management frame (self is as MU STA)*/
@@ -29,8 +30,9 @@ halComTxbf_ConfigGtab(
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
-	if (pDM_Odm->SupportICType & ODM_RTL8822B)
+	if (pDM_Odm->SupportICType & ODM_RTL8822B) {
 		HalTxbf8822B_ConfigGtab(pDM_Odm);
+	}
 }
 
 VOID
@@ -167,7 +169,7 @@ phydm_beamformSetGetTxRate(
 #endif
 }
 
-VOID 
+VOID
 halComTxbf_EnterWorkItemCallback(
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	IN	PADAPTER		Adapter
@@ -184,20 +186,24 @@ halComTxbf_EnterWorkItemCallback(
 #endif
 	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
 	u1Byte			Idx = pTxbfInfo->TXBFIdx;
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
-	
-	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821))
+
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821)) {
 		HalTxbfJaguar_Enter(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E) {
 		HalTxbf8192E_Enter(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_Enter(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8822B)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8822B) {
 		HalTxbf8822B_Enter(pDM_Odm, Idx);
+	}
 }
 
-VOID 
+VOID
 halComTxbf_LeaveWorkItemCallback(
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	IN	PADAPTER		Adapter
@@ -218,18 +224,22 @@ halComTxbf_LeaveWorkItemCallback(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
-	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821))
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821)) {
 		HalTxbfJaguar_Leave(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E) {
 		HalTxbf8192E_Leave(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_Leave(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8822B)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8822B) {
 		HalTxbf8822B_Leave(pDM_Odm, Idx);
+	}
 }
 
 
-VOID 
+VOID
 halComTxbf_FwNdpaWorkItemCallback(
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	IN	PADAPTER		Adapter
@@ -249,14 +259,18 @@ halComTxbf_FwNdpaWorkItemCallback(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
-	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821))
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821)) {
 		HalTxbfJaguar_FwTxBF(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E) {
 		HalTxbf8192E_FwTxBF(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_FwTxBF(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8822B)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8822B) {
 		HalTxbf8822B_FwTxBF(pDM_Odm, Idx);
+	}
 }
 
 VOID
@@ -277,14 +291,15 @@ halComTxbf_ClkWorkItemCallback(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
-	if (pDM_Odm->SupportICType & ODM_RTL8812)
+	if (pDM_Odm->SupportICType & ODM_RTL8812) {
 		HalTxbfJaguar_Clk_8812A(pDM_Odm);
+	}
 }
 
 
 
 VOID
-halComTxbf_RateWorkItemCallback(	
+halComTxbf_RateWorkItemCallback(
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 	IN	PADAPTER		Adapter
 #else
@@ -300,22 +315,24 @@ halComTxbf_RateWorkItemCallback(
 #endif
 	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
 	u1Byte			BW = pTxbfInfo->BW;
-	u1Byte			Rate = pTxbfInfo->Rate;	
-	
+	u1Byte			Rate = pTxbfInfo->Rate;
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
-	if (pDM_Odm->SupportICType & ODM_RTL8812)
+	if (pDM_Odm->SupportICType & ODM_RTL8812) {
 		HalTxbf8812A_setNDPArate(pDM_Odm, BW, Rate);
-	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E) {
 		HalTxbf8192E_setNDPArate(pDM_Odm, BW, Rate);
-	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_setNDPArate(pDM_Odm, BW, Rate);
-	
+	}
 }
 
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-VOID 
+VOID
 halComTxbf_FwNdpaTimerCallback(
 	IN	PRT_TIMER		pTimer
 	)
@@ -327,13 +344,14 @@ halComTxbf_FwNdpaTimerCallback(
 
 	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
 
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
-	if (*pDM_Odm->pbFwDwRsvdPageInProgress)
+	if (*pDM_Odm->pbFwDwRsvdPageInProgress) {
 		ODM_SetTimer(pDM_Odm, &(pTxbfInfo->Txbf_FwNdpaTimer), 5);
-	else
+	} else {
 		PlatformScheduleWorkItem(&(pTxbfInfo->Txbf_FwNdpaWorkItem));
+	}
 }
 #endif
 
@@ -359,14 +377,18 @@ halComTxbf_StatusWorkItemCallback(
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
-	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821))
+	if (pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821)) {
 		HalTxbfJaguar_Status(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8192E)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8192E) {
 		HalTxbf8192E_Status(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8814A)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_Status(pDM_Odm, Idx);
-	else if (pDM_Odm->SupportICType & ODM_RTL8822B)
+	}
+	else if (pDM_Odm->SupportICType & ODM_RTL8822B) {
 		HalTxbf8822B_Status(pDM_Odm, Idx);
+	}
 }
 
 VOID
@@ -388,9 +410,9 @@ halComTxbf_ResetTxPathWorkItemCallback(
 
 	u1Byte			Idx = pTxbfInfo->TXBFIdx;
 
-	if (pDM_Odm->SupportICType & ODM_RTL8814A)
+	if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_ResetTxPath(pDM_Odm, Idx);
-	
+	}
 }
 
 VOID
@@ -408,9 +430,10 @@ halComTxbf_GetTxRateWorkItemCallback(
 #else
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 #endif
-	
-	if (pDM_Odm->SupportICType & ODM_RTL8814A)
+
+	if (pDM_Odm->SupportICType & ODM_RTL8814A) {
 		HalTxbf8814A_GetTxRate(pDM_Odm);
+	}
 }
 
 
@@ -426,7 +449,7 @@ HalComTxbf_Set(
 	PHAL_TXBF_INFO	pTxbfInfo = &pDM_Odm->BeamformingInfo.TxbfInfo;
 
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] setType = 0x%X\n", __func__, setType));
-	
+
 	switch(setType){
 	case TXBF_SET_SOUNDING_ENTER:
 	pTxbfInfo->TXBFIdx = *pU1Tmp;
@@ -457,7 +480,7 @@ HalComTxbf_Set(
 	case TXBF_SET_SOUNDING_CLK:
 	phydm_beamformSetSoundingClk(pDM_Odm);
 	break;
-		
+
 	case TXBF_SET_TX_PATH_RESET:
 	pTxbfInfo->TXBFIdx = *pU1Tmp;
 	phydm_beamformSetResetTxPath(pDM_Odm);
@@ -466,7 +489,7 @@ HalComTxbf_Set(
 	case TXBF_SET_GET_TX_RATE:
 	phydm_beamformSetGetTxRate(pDM_Odm);
 	break;
-	
+
 	}
 
 	return TRUE;
@@ -498,7 +521,7 @@ HalComTxbf_Get(
 			*pBoolean = FALSE;
 	} else if (getType == TXBF_GET_EXPLICIT_BEAMFORMER) {
 		if (IS_HARDWARE_TYPE_OLDER_THAN_8812A(Adapter))
-			*pBoolean = FALSE;		
+			*pBoolean = FALSE;
 		else	if (/*IS_HARDWARE_TYPE_8822B(Adapter)	||*/
 				IS_HARDWARE_TYPE_8821B(Adapter) 	||
 				IS_HARDWARE_TYPE_8192E(Adapter) 	||
@@ -519,18 +542,18 @@ HalComTxbf_Get(
 
 
 	} else if (getType == TXBF_GET_MU_MIMO_AP) {
-#if (RTL8822B_SUPPORT == 1)	
+#if (RTL8822B_SUPPORT == 1)
 		if (IS_HARDWARE_TYPE_8822B(Adapter))
 			*pBoolean = TRUE;
 		else
 #endif
 			*pBoolean = FALSE;
 	}
-	
+
 	return TRUE;
-}	
+}
 #endif
 
 
-#endif 
+#endif
 
diff --git a/drivers/net/wireless/rtl8814au/hal/phydm/txbf/haltxbfjaguar.c b/drivers/net/wireless/rtl8814au/hal/phydm/txbf/haltxbfjaguar.c
index e125371..83671d8 100644
--- a/drivers/net/wireless/rtl8814au/hal/phydm/txbf/haltxbfjaguar.c
+++ b/drivers/net/wireless/rtl8814au/hal/phydm/txbf/haltxbfjaguar.c
@@ -17,8 +17,8 @@ HalTxbf8812A_setNDPArate(
 )
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	
-	ODM_Write1Byte(pDM_Odm, REG_NDPA_OPT_CTRL_8812A,  (Rate << 2 | BW));	
+
+	ODM_Write1Byte(pDM_Odm, REG_NDPA_OPT_CTRL_8812A,  (Rate << 2 | BW));
 
 }
 
@@ -29,7 +29,7 @@ halTxbfJaguar_RfMode(
 )
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	
+
 	if (pDM_Odm->RFType == ODM_1T1R)
 		return;
 
@@ -133,9 +133,9 @@ halTxbfJaguar_DownloadNDPA(
 		DLBcnCount++;
 	} while (!(BcnValidReg & BIT0) && DLBcnCount < 5);
 
-	if (!(BcnValidReg & BIT0))
+	if (!(BcnValidReg & BIT0)) {
 		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("%s Download RSVD page failed!\n", __func__));
-
+	}
 	/*TDECTRL[15:8] 0x209[7:0] = 0xF6	Beacon Head for TXDMA*/
 	ODM_Write1Byte(pDM_Odm, REG_TDECTRL_8812A + 1, TxPageBndy);
 
@@ -306,7 +306,7 @@ HalTxbfJaguar_Leave(
 	PRT_BEAMFORMING_INFO	pBeamformingInfo = &pDM_Odm->BeamformingInfo;
 	RT_BEAMFORMER_ENTRY	BeamformerEntry;
 	RT_BEAMFORMEE_ENTRY	BeamformeeEntry;
-	
+
 	if (Idx < BEAMFORMER_ENTRY_NUM) {
 		BeamformerEntry = pBeamformingInfo->BeamformerEntry[Idx];
 		BeamformeeEntry = pBeamformingInfo->BeamformeeEntry[Idx];
@@ -318,7 +318,7 @@ HalTxbfJaguar_Leave(
 	/*Clear P_AID of Beamformee*/
 	/*Clear MAC address of Beamformer*/
 	/*Clear Associated Bfmee Sel*/
-	
+
 	if (BeamformerEntry.BeamformEntryCap == BEAMFORMING_CAP_NONE) {
 		ODM_Write1Byte(pDM_Odm, REG_SND_PTCL_CTRL_8812A, 0xC8);
 		if (Idx == 0) {
@@ -346,7 +346,7 @@ HalTxbfJaguar_Leave(
 			ODM_Write2Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 2, ODM_Read2Byte(pDM_Odm, REG_BFMEE_SEL_8812A + 2) & 0x60);
 		}
 	}
-	
+
 }
 
 
@@ -440,14 +440,14 @@ HalTxbfJaguar_Clk_8812A(
 	u2Byte	u2btmp;
 	u1Byte	Count = 0, u1btmp;
 	PADAPTER	Adapter = pDM_Odm->Adapter;
-	
+
 	ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] Start!\n", __func__));
 
 	if (*(pDM_Odm->pbScanInProcess)) {
 		ODM_RT_TRACE(pDM_Odm, PHYDM_COMP_TXBF, ODM_DBG_LOUD, ("[%s] return by Scan\n", __func__));
 		return;
 	}
-#if DEV_BUS_TYPE == RT_PCI_INTERFACE	
+#if DEV_BUS_TYPE == RT_PCI_INTERFACE
 	/*Stop PCIe TxDMA*/
 	ODM_Write1Byte(pDM_Odm, REG_PCIE_CTRL_REG_8812A + 1, 0xFE);
 #endif
@@ -521,7 +521,4 @@ HalTxbfJaguar_Clk_8812A(
 
 #endif
 
-
-
 #endif
-
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8812a/usb/rtl8812au_xmit.c b/drivers/net/wireless/rtl8814au/hal/rtl8812a/usb/rtl8812au_xmit.c
index 68ee167..bc5f941 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8812a/usb/rtl8812au_xmit.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8812a/usb/rtl8812au_xmit.c
@@ -112,7 +112,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz , u8 ba
 
 	/* offset 12 */
 
-	if (!pattrib->qos_en && pattrib->sw_seq == _FALSE) {
+	if (!pattrib->qos_en) {
 		SET_TX_DESC_HWSEQ_EN_8812(ptxdesc, 1); /* Hw set sequence number */
 	} else
 		SET_TX_DESC_SEQ_8812(ptxdesc, pattrib->seqnum);
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_phycfg.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_phycfg.c
index 423ba9f..f0a247a 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_phycfg.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_phycfg.c
@@ -554,7 +554,6 @@ PHY_ConfigBB_8814A(
 }
 
 
-
 //2 3.3 RF Config
 
 s32
@@ -1157,7 +1156,7 @@ PHY_GetTxPowerIndex_8814A(
 	tpt_offset = PHY_GetTxPowerTrackingOffset(pAdapter, RFPath, Rate);
 
 	powerDiffByRate = powerDiffByRate > limit ? limit : powerDiffByRate;
-	/*RTW_INFO("Rate-0x%x: (TxPower, PowerDiffByRate Path-%c) = (0x%X, %d)\n", Rate, ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), txPower, powerDiffByRate);*/
+	RTW_INFO("Rate-0x%x: (TxPower, PowerDiffByRate Path-%c) = (0x%X, %d)\n", Rate, ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), txPower, powerDiffByRate);
 
 	txPower += powerDiffByRate;
 
@@ -1184,8 +1183,8 @@ PHY_GetTxPowerIndex_8814A(
 		//(pHalData->bautoload_fail_flag || pHalData->EfuseMap[EFUSE_INIT_MAP][EEPROM_TX_PWR_INX_JAGUAR] == 0xFF))
 		//txPower = 0x12;
 
-	/*RTW_INFO("Final Tx Power(RF-%c, Channel: %d) = %d(0x%X)\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), Channel,
-		txPower, txPower);*/
+	RTW_INFO("Final Tx Power(RF-%c, Channel: %d) = %d(0x%X)\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), Channel,
+		txPower, txPower);
 
 	return (u8) txPower;
 }
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_sreset.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_sreset.c
index 4a7947e..b9e83fd 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_sreset.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_sreset.c
@@ -93,7 +93,7 @@ void rtl8814_sreset_linked_status_check(_adapter *padapter)
 	regc58 = rtw_read32(padapter,0xc58);
 	reg824 = rtw_read32(padapter,0x824);
 	reg800 = rtw_read32(padapter,0x800);
-	if(	((regc50&0xFFFFFF00)!= 0x69543400)||
+	if (	((regc50&0xFFFFFF00)!= 0x69543400)||
 		((regc58&0xFFFFFF00)!= 0x69543400)||
 		(((reg824&0xFFFFFF00)!= 0x00390000)&&(((reg824&0xFFFFFF00)!= 0x80390000)))||
 		( ((reg800&0xFFFFFF00)!= 0x03040000)&&((reg800&0xFFFFFF00)!= 0x83040000)))
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_xmit.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_xmit.c
index 43b8268..bb6cdd8 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_xmit.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/rtl8814a_xmit.c
@@ -172,7 +172,6 @@ InsertEMContent_8814(
 }
 
 
-
 void UpdateEarlyModeInfo8814(struct xmit_priv *pxmitpriv,struct xmit_buf *pxmitbuf )
 {
 	//_adapter *padapter, struct xmit_frame *pxmitframe,struct tx_servq	*ptxservq
@@ -254,7 +253,6 @@ void rtl8814a_cal_txdesc_chksum(u8 *ptxdesc)
 	u32 index;
 	u16 checksum = 0;
 
-
 	usPtr = (u16*)ptxdesc;
 	// checksume is always calculated by first 32 bytes,
 	// and it doesn't depend on TX DESC length.
@@ -439,7 +437,7 @@ BWMapping_8814(
 		else
 			BWSettingOfDesc = 0;
 	}
-	else if(pHalData->CurrentChannelBW== CHANNEL_WIDTH_40) {
+	else if (pHalData->CurrentChannelBW== CHANNEL_WIDTH_40) {
 		if ((pattrib->bwmode == CHANNEL_WIDTH_40) || (pattrib->bwmode == CHANNEL_WIDTH_80))
 			BWSettingOfDesc = 1;
 		else
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/rtl8814au_xmit.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/rtl8814au_xmit.c
index 8200263..0f4d3e1 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/rtl8814au_xmit.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/rtl8814au_xmit.c
@@ -61,7 +61,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
 	if (padapter->registrypriv.mp_mode == 0) {
-		if((PACKET_OFFSET_SZ != 0) && (!bagg_pkt) &&(rtw_usb_bulk_size_boundary(padapter,TXDESC_SIZE+sz)==_FALSE)) {
+		if ((PACKET_OFFSET_SZ != 0) && (!bagg_pkt) &&(rtw_usb_bulk_size_boundary(padapter,TXDESC_SIZE+sz)==_FALSE)) {
 			ptxdesc = (pmem+PACKET_OFFSET_SZ);
 			//RTW_INFO("==> non-agg-pkt,shift pointer...\n");
 			pull = 1;
@@ -94,10 +94,9 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 	}
 
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
-	if (padapter->registrypriv.mp_mode == 0)
-	{
-		if((PACKET_OFFSET_SZ != 0) && (!bagg_pkt)){
-			if((pull) && (pxmitframe->pkt_offset>0)) {
+	if (padapter->registrypriv.mp_mode == 0) {
+		if ((PACKET_OFFSET_SZ != 0) && (!bagg_pkt)) {
+			if ((pull) && (pxmitframe->pkt_offset>0)) {
 				pxmitframe->pkt_offset = pxmitframe->pkt_offset -1;
 			}
 		}
@@ -119,10 +118,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 
 	if (!pattrib->qos_en) {
 		/* HW sequence, to fix to use 0 queue. todo: 4AC packets to use auto queue select */
-		if (pattrib->sw_seq == _FALSE)
-			SET_TX_DESC_HWSEQ_EN_8814A(ptxdesc, 1); // Hw set sequence number
-		else
-			SET_TX_DESC_SEQ_8814A(ptxdesc, pattrib->seqnum);
+		SET_TX_DESC_HWSEQ_EN_8814A(ptxdesc, 1); // Hw set sequence number
 		SET_TX_DESC_EN_HWEXSEQ_8814A(ptxdesc, 0);
 		SET_TX_DESC_DISQSELSEQ_8814A(ptxdesc, 1);
 		SET_TX_DESC_HW_SSN_SEL_8814A(ptxdesc, 0);
@@ -130,8 +126,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 		SET_TX_DESC_SEQ_8814A(ptxdesc, pattrib->seqnum);
 	}
 
-	if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
-	{
+	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {
 		//RTW_INFO("pxmitframe->frame_tag == DATA_FRAMETAG\n");
 
 		rtl8814a_fill_txdesc_sectype(pattrib, ptxdesc);
@@ -189,7 +184,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			if (padapter->fix_rate != 0xFF) { // modify data rate by iwpriv
 				SET_TX_DESC_USE_RATE_8814A(ptxdesc, 1);
 				DriverFixedRate = 0x01;
-				if(padapter->fix_rate & BIT(7))
+				if (padapter->fix_rate & BIT(7))
 					SET_TX_DESC_DATA_SHORT_8814A(ptxdesc, 	1);
 
 				SET_TX_DESC_TX_RATE_8814A(ptxdesc, (padapter->fix_rate & 0x7F));
@@ -202,7 +197,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			if (pattrib->stbc)
 				SET_TX_DESC_DATA_STBC_8814A(ptxdesc, 1);
 
-			//work arond before fixing RA
+			//work around before fixing RA
 			//SET_TX_DESC_USE_RATE_8814A(ptxdesc, 1);
 			//SET_TX_DESC_TX_RATE_8814A(ptxdesc, 0x10);
 		} else {
@@ -253,7 +248,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz ,u8 bag
 			SET_TX_DESC_DATA_RETRY_LIMIT_8814A(ptxdesc, 5);
 			SET_TX_DESC_DISABLE_FB_8814A(ptxdesc, 1);
 
-			//if(pattrib->rts_cca)
+			//if (pattrib->rts_cca)
 			//{
 			//	SET_TX_DESC_NDPA_8812(ptxdesc, 2);
 			//}
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_halinit.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_halinit.c
index b134d5a..e9a5c68 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_halinit.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_halinit.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -33,8 +33,7 @@ static void _dbg_dump_macreg(_adapter *padapter)
 	u32 offset = 0;
 	u32 val32 = 0;
 	u32 index =0 ;
-	for(index=0;index<64;index++)
-	{
+	for (index=0;index<64;index++) {
 		offset = index*4;
 		val32 = rtw_read32(padapter,offset);
 		RTW_INFO("offset : 0x%02x ,val:0x%08x\n",offset,val32);
@@ -52,11 +51,11 @@ _ConfigChipOutEP_8814(
 	pHalData->OutEpQueueSel = 0;
 	pHalData->OutEpNumber = 0;
 
-	switch(NumOutPipe){
+	switch (NumOutPipe) {
 		case 	4:
 				pHalData->OutEpQueueSel=TX_SELE_HQ| TX_SELE_LQ|TX_SELE_NQ;
 				pHalData->OutEpNumber=4;
-				break;		
+				break;
 		case 	3:
 				pHalData->OutEpQueueSel=TX_SELE_HQ| TX_SELE_LQ|TX_SELE_NQ;
 				pHalData->OutEpNumber=3;
@@ -69,9 +68,9 @@ _ConfigChipOutEP_8814(
 				pHalData->OutEpQueueSel=TX_SELE_HQ;
 				pHalData->OutEpNumber=1;
 				break;
-		default:				
+		default:
 				break;
-			
+
 	}
 	RTW_INFO("%s OutEpQueueSel(0x%02x), OutEpNumber(%d) \n",__FUNCTION__,pHalData->OutEpQueueSel,pHalData->OutEpNumber );
 
@@ -87,10 +86,10 @@ static BOOLEAN HalUsbSetQueuePipeMapping8814AUsb(
 	BOOLEAN			result		= _FALSE;
 
 	_ConfigChipOutEP_8814(pAdapter, NumOutPipe);
-	
+
 	// Normal chip with one IN and one OUT doesn't have interrupt IN EP.
-	if(1 == pHalData->OutEpNumber){
-		if(1 != NumInPipe){
+	if (1 == pHalData->OutEpNumber) {
+		if (1 != NumInPipe) {
 			return result;
 		}
 	}
@@ -101,7 +100,7 @@ static BOOLEAN HalUsbSetQueuePipeMapping8814AUsb(
 	//}
 
 	result = Hal_MappingOutPipe(pAdapter, NumOutPipe);
-	
+
 	return result;
 
 }
@@ -173,55 +172,45 @@ _InitBurstPktLen(IN PADAPTER Adapter)
 {
 	u8 			u1bTmp;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
- 
+
 	//yx_qi 131128 move to 0x1448, 144c
 	rtw_write32(Adapter, REG_FAST_EDCA_VOVI_SETTING_8814A, 0x08070807); //yx_qi 131128
 	rtw_write32(Adapter, REG_FAST_EDCA_BEBK_SETTING_8814A, 0x08070807); //yx_qi 131128
-	
+
 	u1bTmp = rtw_read8(Adapter, 0xff); //check device operation speed: SS 0xff bit7
-	
-	if(u1bTmp & BIT7)   //USB2/1.1 Mode
-	{
+
+	if (u1bTmp & BIT7) { //USB2/1.1 Mode
  		pHalData->bSupportUSB3 = FALSE;
-	}
-	else  //USB3 Mode
-	{		
+	} else { //USB3 Mode
 		pHalData->bSupportUSB3 = TRUE;
 	}
-	
-	if(pHalData->bSupportUSB3 == _FALSE)   //USB2/1.1 Mode
-	{
-		if(pHalData->UsbBulkOutSize == 512)
-		{
+
+	if (pHalData->bSupportUSB3 == _FALSE) { //USB2/1.1 Mode
+		if (pHalData->UsbBulkOutSize == 512) {
 			//set burst pkt len=512B
 			rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x1e);
-		}
-		else
-		{
+		} else {
 			//set burst pkt len=64B
-			rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x2e);		
+			rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x2e);
 		}
 
 		rtw_write16(Adapter, REG_RXDMA_AGG_PG_TH_8814A,0x2005); //dmc agg th 20K
-	}
-	else  //USB3 Mode
-	{		
+	} else { //USB3 Mode
 		//set burst pkt len=1k
-		rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x0e);				
+		rtw_write8(Adapter, REG_RXDMA_MODE_8814A, 0x0e);
 		rtw_write16(Adapter, REG_RXDMA_AGG_PG_TH_8814A,0x0a05); //dmc agg th 20K
-		
+
 		// set Reg 0xf008[3:4] to 2'00 to disable U1/U2 Mode to avoid 2.5G spur in USB3.0. added by page, 20120712
 		rtw_write8(Adapter, 0xf008, rtw_read8(Adapter, 0xf008)&0xE7);
 		//to avoid usb 3.0 H2C fail
 		rtw_write16(Adapter, 0xf002, 0);
-		
+
 		rtw_write8(Adapter, REG_SW_AMPDU_BURST_MODE_CTRL_8814A, rtw_read8(Adapter, REG_SW_AMPDU_BURST_MODE_CTRL_8814A) & ~BIT(6));
 		RTW_INFO("turn off the LDPC pre-TX\n");
-		
-	} 
 
-	if(pHalData->AMPDUBurstMode)
-	{
+	}
+
+	if (pHalData->AMPDUBurstMode) {
 		rtw_write8(Adapter,REG_SW_AMPDU_BURST_MODE_CTRL_8814A,  0x5F);
 	}
 }
@@ -232,7 +221,7 @@ _InitQueueReservedPage_8814AUsb(
 	)
 {
 	struct registry_priv	*pregistrypriv = &Adapter->registrypriv;
-	u16		txpktbuf_bndy; 
+	u16		txpktbuf_bndy;
 
 	RTW_INFO("===>_InitQueueReservedPage_8814AUsb()\n");
 
@@ -246,7 +235,7 @@ _InitQueueReservedPage_8814AUsb(
 
 	rtw_write32(Adapter, REG_RQPN_CTRL_2_8814A, 0x80000000);
 
-	if(!pregistrypriv->wifi_spec)
+	if (!pregistrypriv->wifi_spec)
 		txpktbuf_bndy = TX_PAGE_BOUNDARY_8814A;
 	else		// for WMM
 		txpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY_8814A;
@@ -260,7 +249,7 @@ _InitQueueReservedPage_8814AUsb(
 	rtw_write16(Adapter,REG_FIFOPAGE_CTRL_2_8814A, txpktbuf_bndy);
 	//The head page of packet of Bcnq1
 	rtw_write16(Adapter,REG_FIFOPAGE_CTRL_2_8814A+2,txpktbuf_bndy);
-	
+
 	RTW_INFO("<===_InitQueueReservedPage_8814AUsb()\n");
 }
 
@@ -273,7 +262,7 @@ static u32 _InitPowerOn_8814AU(_adapter *padapter)
 	u8	u1btmp = rtw_read8(padapter, 0x10C2);
 	rtw_write8(padapter, 0x10C2, (u1btmp | BIT1));
 
-	if(!HalPwrSeqCmdParsing(padapter, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8814A_NIC_ENABLE_FLOW))
+	if (!HalPwrSeqCmdParsing(padapter, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8814A_NIC_ENABLE_FLOW))
 		return _FAIL;
 
 	// Enable MAC DMA/WMAC/SCHEDULE/SEC block
@@ -320,9 +309,9 @@ _InitPageBoundary_8814AUsb(
 {
 	//20130416 KaiYuan modified for 8814
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
-	
+
 	rtw_write16(Adapter, REG_RXFF_PTR_8814A, RX_DMA_BOUNDARY_8814A); //yx_qi 20140331
-	
+
 }
 
 static VOID
@@ -353,11 +342,11 @@ _InitNormalChipTwoOutEpPriority_8814AUsb(
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 	struct registry_priv	*pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
-	
+
 	u16	valueHi = 0;
 	u16	valueLow = 0;
-	
-	switch(pHalData->OutEpQueueSel)
+
+	switch (pHalData->OutEpQueueSel)
 	{
 		case (TX_SELE_HQ | TX_SELE_LQ):
 			valueHi = QUEUE_HIGH;
@@ -373,27 +362,27 @@ _InitNormalChipTwoOutEpPriority_8814AUsb(
 			break;
 		default:
 			valueHi = QUEUE_HIGH;
-			valueLow = QUEUE_NORMAL;			
+			valueLow = QUEUE_NORMAL;
 			break;
 	}
 
-	if(!pregistrypriv->wifi_spec){
+	if (!pregistrypriv->wifi_spec) {
 		beQ 		= valueLow;
 		bkQ 		= valueLow;
 		viQ		= valueHi;
 		voQ 		= valueHi;
-		mgtQ 	= valueHi; 
-		hiQ 		= valueHi;								
+		mgtQ 	= valueHi;
+		hiQ 		= valueHi;
 	}
-	else{//for WMM ,CONFIG_OUT_EP_WIFI_MODE
+	else { //for WMM ,CONFIG_OUT_EP_WIFI_MODE
 		beQ		= valueLow;
 		bkQ 		= valueHi;
 		viQ 		= valueHi;
 		voQ 		= valueLow;
 		mgtQ 	= valueHi;
-		hiQ 		= valueHi;							
+		hiQ 		= valueHi;
 	}
-	
+
 	_InitNormalChipRegPriority_8814AUsb(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
 }
 
@@ -405,21 +394,20 @@ _InitNormalChipThreeOutEpPriority_8814AUsb(
 	struct registry_priv	*pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
 
-	if(!pregistrypriv->wifi_spec){// typical setting
+	if (!pregistrypriv->wifi_spec) { // typical setting
 		beQ		= QUEUE_LOW;
 		bkQ 		= QUEUE_LOW;
 		viQ 		= QUEUE_NORMAL;
 		voQ 		= QUEUE_HIGH;
 		mgtQ 	= QUEUE_HIGH;
-		hiQ 		= QUEUE_HIGH;			
-	}
-	else{// for WMM
+		hiQ 		= QUEUE_HIGH;
+	} else { // for WMM
 		beQ		= QUEUE_LOW;
 		bkQ 		= QUEUE_NORMAL;
 		viQ 		= QUEUE_NORMAL;
 		voQ 		= QUEUE_HIGH;
 		mgtQ 	= QUEUE_HIGH;
-		hiQ 		= QUEUE_HIGH;			
+		hiQ 		= QUEUE_HIGH;
 	}
 	_InitNormalChipRegPriority_8814AUsb(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
 }
@@ -431,7 +419,7 @@ _InitQueuePriority_8814AUsb(
 {
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 
-	switch(pHalData->OutEpNumber)
+	switch (pHalData->OutEpNumber)
 	{
 		case 2:
 			_InitNormalChipTwoOutEpPriority_8814AUsb(Adapter);
@@ -499,8 +487,8 @@ _InitWMACSetting_8814A(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
 	//pHalData->ReceiveConfig = AAP | APM | AM | AB | APP_ICV | ADF | AMF | APP_FCS | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;
-	pHalData->ReceiveConfig = 
-	RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYST_RXFF;	  
+	pHalData->ReceiveConfig =
+	RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYST_RXFF;
 
 #if (1 == RTL8812A_RX_PACKET_INCLUDE_CRC)
 	pHalData->ReceiveConfig |= ACRC32;
@@ -539,7 +527,7 @@ _InitWMACSetting_8814A(
 	//rtw_write16(Adapter, REG_RXFLTMAP0, value16);
 
 	//enable RX_SHIFT bits
-	//rtw_write8(Adapter, REG_TRXDMA_CTRL, rtw_read8(Adapter, REG_TRXDMA_CTRL)|BIT(1));	
+	//rtw_write8(Adapter, REG_TRXDMA_CTRL, rtw_read8(Adapter, REG_TRXDMA_CTRL)|BIT(1));
 
 }
 */
@@ -553,21 +541,21 @@ _InitMacConfigure_8814A(
 	u16			value16;
 	u32			regRRSR;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	
+
 	switch (Adapter->registrypriv.wireless_mode)
 	{
 		case WIRELESS_11B:
 			regRRSR = RATE_ALL_CCK;
 			break;
-		
+
 		case WIRELESS_11G:
 		case WIRELESS_11A:
 		case WIRELESS_11_5N:
-		case WIRELESS_11A_5N://Todo: no basic rate for ofdm ?
+		case WIRELESS_11A_5N: //Todo: no basic rate for ofdm ?
 		case WIRELESS_11_5AC:
 			regRRSR = RATE_ALL_OFDM_AG;
 			break;
-		
+
 		case WIRELESS_11BG:
 		case WIRELESS_11G_24N:
 		case WIRELESS_11_24N:
@@ -575,7 +563,7 @@ _InitMacConfigure_8814A(
 		default:
 			regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 			break;
-	
+
 	}
 
 	// Init value for RRSR.
@@ -584,7 +572,7 @@ _InitMacConfigure_8814A(
 	// Retry Limit
 	value16 = _LRL(0x30) | _SRL(0x30);
 	rtw_write16(Adapter, REG_RETRY_LIMIT_8814A, value16);
-	
+
 	pHalData->ReceiveConfig = RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYST_RXFF;
 	pHalData->ReceiveConfig |= FORCEACK;
 #if (1 == RTL8812A_RX_PACKET_INCLUDE_CRC)
@@ -608,8 +596,8 @@ _InitMacConfigure_8814A(
 
 	// 201409/25 MH When RA is enabled, we need to reduce the value.
 	rtw_write8(Adapter, REG_MAX_AGGR_NUM_8814A, 0x36);
-	rtw_write8(Adapter, REG_RTS_MAX_AGGR_NUM_8814A,0x36); 
-	
+	rtw_write8(Adapter, REG_RTS_MAX_AGGR_NUM_8814A,0x36);
+
 }
 
 /*
@@ -643,7 +631,7 @@ _InitAdaptiveCtrl_8812AUsb(
 	// Retry Limit
 	value16 = _LRL(0x30) | _SRL(0x30);
 	rtw_write16(Adapter, REG_RL, value16);
-	
+
 }*/
 
 static VOID
@@ -656,7 +644,7 @@ _InitEDCA_8814AUsb(
 	rtw_write16(Adapter,REG_MAC_SPEC_SIFS, 0x100a);
 
 	// Set SIFS for CCK
-	rtw_write16(Adapter,REG_SIFS_CTX, 0x100a);	
+	rtw_write16(Adapter,REG_SIFS_CTX, 0x100a);
 
 	// Set SIFS for OFDM
 	rtw_write16(Adapter,REG_SIFS_TRX, 0x100a);
@@ -679,9 +667,9 @@ _InitBeaconMaxError_8814A(
 	)
 {
 #ifdef CONFIG_ADHOC_WORKAROUND_SETTING
-	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);	
+	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
 #else
-	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));	
+	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));
 #endif
 }
 
@@ -689,12 +677,12 @@ _InitBeaconMaxError_8814A(
 static void _InitHWLed(PADAPTER Adapter)
 {
 	struct led_priv *pledpriv = &(Adapter->ledpriv);
-	
-	if( pledpriv->LedStrategy != HW_LED)
+
+	if ( pledpriv->LedStrategy != HW_LED)
 		return;
-	
+
 // HW led control
-// to do .... 
+// to do ....
 //must consider cases of antenna diversity/ commbo card/solo card/mini card
 
 }
@@ -717,7 +705,7 @@ _InitRetryFunction_8814A(
 	)
 {
 	u8	value8;
-	
+
 	value8 = rtw_read8(Adapter, REG_FWHW_TXQ_CTRL);
 	value8 |= EN_AMPDU_RTY_NEW;
 	rtw_write8(Adapter, REG_FWHW_TXQ_CTRL, value8);
@@ -730,7 +718,7 @@ _InitRetryFunction_8814A(
 /*-----------------------------------------------------------------------------
  * Function:	usb_AggSettingTxUpdate()
  *
- * Overview:	Seperate TX/RX parameters update independent for TP detection and 
+ * Overview:	Seperate TX/RX parameters update independent for TP detection and
  *			dynamic TX/RX aggreagtion parameters update.
  *
  * Input:			PADAPTER
@@ -751,25 +739,25 @@ usb_AggSettingTxUpdate_8814A(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u32			value32;
 
-	if(Adapter->registrypriv.wifi_spec)
+	if (Adapter->registrypriv.wifi_spec)
 		pHalData->UsbTxAggDescNum = 1;
 
-	if(pHalData->UsbTxAggMode){
+	if (pHalData->UsbTxAggMode){
 		value32 = rtw_read32(Adapter, REG_TDECTRL);
 		value32 = value32 & ~(BLK_DESC_NUM_MASK << BLK_DESC_NUM_SHIFT);
 		value32 |= ((pHalData->UsbTxAggDescNum & BLK_DESC_NUM_MASK) << BLK_DESC_NUM_SHIFT);
-		
+
 		rtw_write32(Adapter, REG_TDECTRL, value32);
 		rtw_write8(Adapter, REG_TDECTRL+3, pHalData->UsbTxAggDescNum<<1);
 	}
-	
+
 #endif //CONFIG_USB_TX_AGGREGATION
 }	// usb_AggSettingTxUpdate
 
 /*-----------------------------------------------------------------------------
  * Function:	usb_AggSettingRxUpdate()
  *
- * Overview:	Seperate TX/RX parameters update independent for TP detection and 
+ * Overview:	Seperate TX/RX parameters update independent for TP detection and
  *			dynamic TX/RX aggreagtion parameters update.
  *
  * Input:			PADAPTER
@@ -793,7 +781,7 @@ usb_AggSettingRxUpdate_8814A(
 
 	valueDMA = rtw_read8(Adapter, REG_TRXDMA_CTRL_8814A);
 	valueUSB = rtw_read8(Adapter, REG_RXDMA_AGG_PG_TH_8814A+3);
-	switch(pHalData->rxagg_mode)
+	switch (pHalData->rxagg_mode)
 	{
 		case RX_AGG_DMA:
 			valueDMA |= RXDMA_AGG_EN;
@@ -853,7 +841,7 @@ init_UsbAggregationSetting_8814A(
  *
  * Revised History:
  *	When		Who		Remark
- *	12/10/2010	MHC		Create Version 0.  
+ *	12/10/2010	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
 VOID
@@ -866,37 +854,33 @@ USB_AggModeSwitch(
 	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
 
 	//pHalData->UsbRxHighSpeedMode = _FALSE;
-	// How to measure the RX speed? We assume that when traffic is more than 
+	// How to measure the RX speed? We assume that when traffic is more than
 	if (pMgntInfo->bRegAggDMEnable == _FALSE)
 	{
 		return;	// Inf not support.
 	}
-		
-	if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _TRUE && 
+
+	if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _TRUE &&
 		pHalData->UsbRxHighSpeedMode == _FALSE)
 	{
 		pHalData->UsbRxHighSpeedMode = _TRUE;
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("UsbAggModeSwitchCheck to HIGH\n"));
 	}
-	else if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _FALSE && 
+	else if (pMgntInfo->LinkDetectInfo.bHigherBusyRxTraffic == _FALSE &&
 		pHalData->UsbRxHighSpeedMode == _TRUE)
 	{
 		pHalData->UsbRxHighSpeedMode = _FALSE;
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("UsbAggModeSwitchCheck to LOW\n"));
+	} else {
+		return;
 	}
-	else
-	{
-		return; 
-	}
-	
+
 #if USB_RX_AGGREGATION_92C
-	if (pHalData->UsbRxHighSpeedMode == _TRUE)	
-	{
+	if (pHalData->UsbRxHighSpeedMode == _TRUE) {
 		// 2010/12/10 MH The parameter is tested by SD1 engineer and SD3 channel emulator.
 		// USB mode
 #if (RT_PLATFORM == PLATFORM_LINUX)
-		if (pMgntInfo->LinkDetectInfo.bTxBusyTraffic)
-		{
+		if (pMgntInfo->LinkDetectInfo.bTxBusyTraffic) {
 			pHalData->RxAggBlockCount	= 16;
 			pHalData->RxAggBlockTimeout	= 7;
 		}
@@ -908,23 +892,20 @@ USB_AggModeSwitch(
 		}
 		// Mix mode
 		pHalData->RxAggPageCount	= 72;
-		pHalData->RxAggPageTimeout	= 6;		
-	}
-	else
-	{
+		pHalData->RxAggPageTimeout	= 6;
+	} else {
 		// USB mode
 		pHalData->RxAggBlockCount	= pMgntInfo->RegRxAggBlockCount;
-		pHalData->RxAggBlockTimeout	= pMgntInfo->RegRxAggBlockTimeout;	
+		pHalData->RxAggBlockTimeout	= pMgntInfo->RegRxAggBlockTimeout;
 		// Mix mode
 		pHalData->RxAggPageCount		= pMgntInfo->RegRxAggPageCount;
-		pHalData->RxAggPageTimeout	= pMgntInfo->RegRxAggPageTimeout;	
+		pHalData->RxAggPageTimeout	= pMgntInfo->RegRxAggPageTimeout;
 	}
 
 	if (pHalData->RxAggBlockCount > MAX_RX_AGG_BLKCNT)
 		pHalData->RxAggBlockCount = MAX_RX_AGG_BLKCNT;
 #if (OS_WIN_FROM_VISTA(OS_VERSION)) || (RT_PLATFORM == PLATFORM_LINUX)	// do not support WINXP to prevent usbehci.sys BSOD
-	if (IS_WIRELESS_MODE_N_24G(Adapter) || IS_WIRELESS_MODE_N_5G(Adapter))
-	{
+	if (IS_WIRELESS_MODE_N_24G(Adapter) || IS_WIRELESS_MODE_N_5G(Adapter)) {
 		//
 		// 2010/12/24 MH According to V1012 QC IOT test, XP BSOD happen when running chariot test
 		// with the aggregation dynamic change!! We need to disable the function to prevent it is broken
@@ -933,12 +914,12 @@ USB_AggModeSwitch(
 		usb_AggSettingRxUpdate_8188E(Adapter);
 
 		// 2010/12/27 MH According to designer's suggstion, we can only modify Timeout value. Otheriwse
-		// there might many HW incorrect behavior, the XP BSOD at usbehci.sys may be relative to the 
+		// there might many HW incorrect behavior, the XP BSOD at usbehci.sys may be relative to the
 		// issue. Base on the newest test, we can not enable block cnt > 30, otherwise XP usbehci.sys may
 		// BSOD.
 	}
 #endif
-	
+
 #endif
 #endif
 }	// USB_AggModeSwitch
@@ -957,7 +938,7 @@ _InitOperationMode_8814A(
 	//
 	// Set RRSR, RATR, and REG_BWOPMODE registers
 	//
-	switch(Adapter->RegWirelessMode)
+	switch (Adapter->RegWirelessMode)
 	{
 		case WIRELESS_MODE_B:
 			regBwOpMode = BW_OPMODE_20MHZ;
@@ -975,14 +956,11 @@ _InitOperationMode_8814A(
 			regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 			break;
 		case WIRELESS_MODE_AUTO:
-			if (Adapter->bInHctTest)
-			{
+			if (Adapter->bInHctTest) {
 			    regBwOpMode = BW_OPMODE_20MHZ;
 			    regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 			    regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
-			}
-			else
-			{
+			} else {
 			    regBwOpMode = BW_OPMODE_20MHZ;
 			    regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
 			    regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
@@ -1000,7 +978,7 @@ _InitOperationMode_8814A(
 			regRATR = RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
 			regRRSR = RATE_ALL_OFDM_AG;
 			break;
-			
+
 		default: //for MacOSX compiler warning.
 			break;
 	}
@@ -1039,20 +1017,19 @@ static VOID _RfPowerSave(
 	return;
 #endif
 
-	if(pMgntInfo->RegRfOff == _TRUE){ // User disable RF via registry.
+	if (pMgntInfo->RegRfOff == _TRUE) { // User disable RF via registry.
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RegRfOff.\n"));
 		MgntActSet_RF_State(Adapter, eRfOff, RF_CHANGE_BY_SW);
 		// Those action will be discard in MgntActSet_RF_State because off the same state
 		for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 			PHY_SetRFReg(Adapter, eRFPath, 0x4, 0xC00, 0x0);
 	}
-	else if(pMgntInfo->RfOffReason > RF_CHANGE_BY_PS){ // H/W or S/W RF OFF before sleep.
+	else if (pMgntInfo->RfOffReason > RF_CHANGE_BY_PS) { // H/W or S/W RF OFF before sleep.
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason));
 		MgntActSet_RF_State(Adapter, eRfOff, pMgntInfo->RfOffReason);
-	}
-	else{
+	} else {
 		pHalData->eRFPowerState = eRfOn;
-		pMgntInfo->RfOffReason = 0; 
+		pMgntInfo->RfOffReason = 0;
 		if(Adapter->bInSetPower || Adapter->bResetInProgress)
 			PlatformUsbEnableInPipes(Adapter);
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): RF is on.\n"));
@@ -1062,7 +1039,7 @@ static VOID _RfPowerSave(
 */
 enum {
 	Antenna_Lfet = 1,
-	Antenna_Right = 2,	
+	Antenna_Right = 2,
 };
 
 static VOID
@@ -1071,21 +1048,21 @@ _InitAntenna_Selection_8814A(IN	PADAPTER Adapter)
 
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 
-	if(pHalData->AntDivCfg==0)
+	if (pHalData->AntDivCfg==0)
 		return;
-/*		
-	RTW_INFO("==>  %s ....\n",__FUNCTION__);		
+/*
+	RTW_INFO("==>  %s ....\n",__FUNCTION__);
 
 	rtw_write8(Adapter, REG_LEDCFG2, 0x82);
 
 	PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
-		
+
 	if(PHY_QueryBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300) == MAIN_ANT)
 		pHalData->CurAntenna = MAIN_ANT;
 	else
 		pHalData->CurAntenna = AUX_ANT;
 	RTW_INFO("%s,Cur_ant:(%x)%s\n",__FUNCTION__,pHalData->CurAntenna,(pHalData->CurAntenna == MAIN_ANT)?"MAIN_ANT":"AUX_ANT");
-			
+
 */
 }
 
@@ -1104,28 +1081,24 @@ HalDetectSelectiveSuspendMode(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(Adapter);
 
-	// If support HW radio detect, we need to enable WOL ability, otherwise, we 
+	// If support HW radio detect, we need to enable WOL ability, otherwise, we
 	// can not use FW to notify host the power state switch.
-	
+
 	EFUSE_ShadowRead(Adapter, 1, EEPROM_USB_OPTIONAL1, (u32 *)&tmpvalue);
 
 	DBG_8192C("HalDetectSelectiveSuspendMode(): SS ");
-	if(tmpvalue & BIT1)
-	{
+	if (tmpvalue & BIT1) {
 		DBG_8192C("Enable\n");
-	}
-	else
-	{
+	} else {
 		DBG_8192C("Disable\n");
 		pdvobjpriv->RegUsbSS = _FALSE;
 	}
 
 	// 2010/09/01 MH According to Dongle Selective Suspend INF. We can switch SS mode.
-	if (pdvobjpriv->RegUsbSS && !SUPPORT_HW_RADIO_DETECT(pHalData))
-	{
+	if (pdvobjpriv->RegUsbSS && !SUPPORT_HW_RADIO_DETECT(pHalData)) {
 		//PMGNT_INFO				pMgntInfo = &(Adapter->MgntInfo);
 
-		//if (!pMgntInfo->bRegDongleSS)	
+		//if (!pMgntInfo->bRegDongleSS)
 		//{
 		//	RT_TRACE(COMP_INIT, DBG_LOUD, ("Dongle disable SS\n"));
 			pdvobjpriv->RegUsbSS = _FALSE;
@@ -1156,12 +1129,11 @@ static void rtl8814au_hw_reset(_adapter *Adapter)
 {
 #if 0
                 u8 reg_val=0;
-	if(rtw_read8(Adapter, REG_MCUFWDL)&BIT7)
-	{		
-		_8051Reset8812(Adapter);  
+	if (rtw_read8(Adapter, REG_MCUFWDL)&BIT7) {
+		_8051Reset8812(Adapter);
 		rtw_write8(Adapter, REG_MCUFWDL, 0x00);
 		//before BB reset should do clock gated
-		rtw_write32(Adapter, rFPGA0_XCD_RFPara, 
+		rtw_write32(Adapter, rFPGA0_XCD_RFPara,
 			rtw_read32(Adapter, rFPGA0_XCD_RFPara)|(BIT6));
 		//reset BB
 		reg_val = rtw_read8(Adapter, REG_SYS_FUNC_EN);
@@ -1172,16 +1144,16 @@ static void rtl8814au_hw_reset(_adapter *Adapter)
 		//reset TRX path
 		rtw_write16(Adapter, REG_CR, 0);
 		//reset MAC
-		reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1); 
+		reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1);
 		reg_val |= BIT(1);
 		reg_val = rtw_write8(Adapter, REG_APS_FSMCO+1, reg_val);       //reg0x5[1] ,auto FSM off
 
 		reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1);
- 
+
 		//check if   reg0x5[1] auto cleared
-		while(reg_val & BIT(1)){
+		while (reg_val & BIT(1)) {
 			rtw_udelay_os(1);
-			reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1); 
+			reg_val = rtw_read8(Adapter, REG_APS_FSMCO+1);
 		}
 		reg_val |= BIT(0);
 		reg_val = rtw_write8(Adapter, REG_APS_FSMCO+1, reg_val);     //reg0x5[0] ,auto FSM on
@@ -1272,7 +1244,7 @@ u32 rtl8814au_hal_init(PADAPTER Adapter)
 	int hal_init_profiling_i;
 	u32 hal_init_stages_timestamp[HAL_INIT_STAGES_NUM]; //used to record the time of each stage's starting point
 
-	for(hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM;hal_init_profiling_i++)
+	for (hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM;hal_init_profiling_i++)
 		hal_init_stages_timestamp[hal_init_profiling_i]=0;
 
 	#define HAL_INIT_PROFILE_TAG(stage) hal_init_stages_timestamp[(stage)]=rtw_get_current_time();
@@ -1281,15 +1253,12 @@ u32 rtl8814au_hal_init(PADAPTER Adapter)
 #endif //DBG_HAL_INIT_PROFILING
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
-	if(pwrctrlpriv->bkeepfwalive)
-	{
+	if (pwrctrlpriv->bkeepfwalive) {
 		_ps_open_RF(Adapter);
 
-		if(pHalData->bIQKInitialized){
+		if (pHalData->bIQKInitialized) {
 			//PHY_IQCalibrate_8812A(Adapter,_TRUE);
-		}
-		else
-		{
+		} else {
 			//PHY_IQCalibrate_8812A(Adapter,_FALSE);
 			//pHalData->bIQKInitialized = _TRUE;
 		}
@@ -1301,16 +1270,13 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 	}
 
 	// Check if MAC has already power on. by tynli. 2011.05.27.
-	value8 = rtw_read8(Adapter, REG_SYS_CLKR+1);	
+	value8 = rtw_read8(Adapter, REG_SYS_CLKR+1);
 	u1bRegCR = rtw_read8(Adapter, REG_CR);
 	RTW_INFO(" power-on :REG_SYS_CLKR 0x09=0x%02x. REG_CR 0x100=0x%02x.\n", value8, u1bRegCR);
-	if((value8&BIT3)  && (u1bRegCR != 0 && u1bRegCR != 0xEA))
-	{
+	if ((value8&BIT3)  && (u1bRegCR != 0 && u1bRegCR != 0xEA)) {
 		//pHalData->bMACFuncEnable = _TRUE;
 		RTW_INFO(" MAC has already power on.\n");
-	}
-	else
-	{
+	} else {
 		//pHalData->bMACFuncEnable = _FALSE;
 		// Set FwPSState to ALL_ON mode to prevent from the I/O be return because of 32k
 		// state which is set before sleep under wowlan mode. 2012.01.04. by tynli.
@@ -1332,7 +1298,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 	}*/
 
 /*
-	If HW didn't go through a complete de-initial procedure,  
+	If HW didn't go through a complete de-initial procedure,
 	it probably occurs some problem for double initial procedure.
 	Like "CONFIG_DEINIT_BEFORE_INIT" in 92du chip
 */
@@ -1340,15 +1306,15 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PW_ON);
 	status = _InitPowerOn_8814AU(Adapter);
-	if(status == _FAIL){
+	if (status == _FAIL) {
 		RTW_INFO("Failed to init power on!\n");
 		goto exit;
 	}
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_LLTT);
-	
+
 	status =  InitLLTTable8814A(Adapter);
-	if(status == _FAIL){
+	if (status == _FAIL) {
 		RTW_INFO("Failed to init LLT table\n");
 		goto exit;
 	}
@@ -1375,8 +1341,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOWNLOAD_FW);
 	}
 
 	InitializeFirmwareVars8814(Adapter);
-	
-	if(pwrctrlpriv->reg_rfoff == _TRUE){
+
+	if (pwrctrlpriv->reg_rfoff == _TRUE) {
 		pwrctrlpriv->rf_pwrstate = rf_off;
 	}
 
@@ -1393,16 +1359,15 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOWNLOAD_FW);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MAC);
 #if (HAL_MAC_ENABLE == 1)
 	status = PHY_MACConfig8814(Adapter);
-	if(status == _FAIL)
-	{
+	if (status == _FAIL) {
 		goto exit;
 	}
 #endif //HAL_MAC_ENABLE
-	
+
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC01);
-	
+
 	_InitQueuePriority_8814AUsb(Adapter);
-	_InitPageBoundary_8814AUsb(Adapter);	
+	_InitPageBoundary_8814AUsb(Adapter);
 
 	_InitTransferPageSize_8814AUsb(Adapter);
 
@@ -1411,8 +1376,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 	_InitDriverInfoSize_8814A(Adapter, DRVINFO_SZ);
 
 	_InitInterrupt_8814AU(Adapter);
-	_InitID_8814A(Adapter);//set mac_address
-	_InitNetworkType_8814A(Adapter);//set msr	
+	_InitID_8814A(Adapter); //set mac_address
+	_InitNetworkType_8814A(Adapter); //set msr
 	_InitMacConfigure_8814A(Adapter);
 	//_InitWMACSetting_8814A(Adapter);
 	//_InitAdaptiveCtrl_8814AUsb(Adapter);
@@ -1428,7 +1393,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 
 	//
 	// Init CR MACTXEN, MACRXEN after setting RxFF boundary REG_TRXFF_BNDY to patch
-	// Hw bug which Hw initials RxFF boundry size to a value which is larger than the real Rx buffer size in 88E. 
+	// Hw bug which Hw initials RxFF boundry size to a value which is larger than the real Rx buffer size in 88E.
 	// 2011.08.05. by tynli.
 	//
 	value8 = rtw_read8(Adapter, REG_CR);
@@ -1449,7 +1414,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 	rtw_write16(Adapter, REG_PKT_BE_BK_LIFE_TIME, 0x3000);	// unit: 256us. 3s
 #endif	// CONFIG_TX_MCAST2UNI
 #endif	// CONFIG_CONCURRENT_MODE || CONFIG_TX_MCAST2UNI
-	
+
 #ifdef CONFIG_LED
 	_InitHWLed(Adapter);
 #endif //CONFIG_LED
@@ -1461,8 +1426,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB);
 #if (HAL_BB_ENABLE == 1)
 	status = PHY_BBConfig8814(Adapter);
-	if(status == _FAIL)
-	{
+	if (status == _FAIL) {
 		goto exit;
 	}
 #endif //HAL_BB_ENABLE
@@ -1472,9 +1436,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF);
 #if (HAL_RF_ENABLE == 1)
-	status = PHY_RFConfig8814A(Adapter);	
-	if(status == _FAIL)
-	{
+	status = PHY_RFConfig8814A(Adapter);
+	if (status == _FAIL) {
 		goto exit;
 	}
 
@@ -1485,12 +1448,12 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF);
 
 	PHY_ConfigBB_8814A(Adapter);
 
-	if(Adapter->registrypriv.channel <= 14)
+	if (Adapter->registrypriv.channel <= 14)
 		PHY_SwitchWirelessBand8814A(Adapter, BAND_ON_2_4G);
 	else
 		PHY_SwitchWirelessBand8814A(Adapter, BAND_ON_5G);
 
-	rtw_hal_set_chnl_bw(Adapter, Adapter->registrypriv.channel, 
+	rtw_hal_set_chnl_bw(Adapter, Adapter->registrypriv.channel,
 		CHANNEL_WIDTH_20, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_TURN_ON_BLOCK);
@@ -1503,9 +1466,9 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 
 	// HW SEQ CTRL
 	//set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM.
-	rtw_write8(Adapter,REG_HWSEQ_CTRL, 0xFF); 
-	
-	// 
+	rtw_write8(Adapter,REG_HWSEQ_CTRL, 0xFF);
+
+	//
 	// Disable BAR, suggested by Scott
 	// 2010.04.09 add by hpfan
 	//
@@ -1513,7 +1476,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 
 	rtw_write8(Adapter,REG_SECONDARY_CCA_CTRL_8814A,0x03);
 
-	if(pregistrypriv->wifi_spec)
+	if (pregistrypriv->wifi_spec)
 		rtw_write16(Adapter,REG_FAST_EDCA_CTRL ,0);
 	//adjust EDCCA to avoid collision
 	/*if(pregistrypriv->wifi_spec)
@@ -1525,21 +1488,21 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_HAL_DM);
 	rtl8814_InitHalDm(Adapter);
-	
+
 	//
 	// 2010/08/11 MH Merge from 8192SE for Minicard init. We need to confirm current radio status
-	// and then decide to enable RF or not.!!!??? For Selective suspend mode. We may not 
+	// and then decide to enable RF or not.!!!??? For Selective suspend mode. We may not
 	// call init_adapter. May cause some problem??
 	//
-	// Fix the bug that Hw/Sw radio off before S3/S4, the RF off action will not be executed 
-	// in MgntActSet_RF_State() after wake up, because the value of pHalData->eRFPowerState 
+	// Fix the bug that Hw/Sw radio off before S3/S4, the RF off action will not be executed
+	// in MgntActSet_RF_State() after wake up, because the value of pHalData->eRFPowerState
 	// is the same as eRfOff, we should change it to eRfOn after we config RF parameters.
 	// Added by tynli. 2010.03.30.
 	pwrctrlpriv->rf_pwrstate = rf_on;
 
 	PHY_IQCalibrate_8814A_Init(&pHalData->odmpriv);
 
-#if (HAL_BB_ENABLE == 1)	
+#if (HAL_BB_ENABLE == 1)
 	PHY_SetRFEReg8814A(Adapter, _TRUE, pHalData->CurrentBandType);
 #endif //HAL_BB_ENABLE
 
@@ -1561,13 +1524,12 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_HAL_DM);
 	// Reset USB mode switch setting
 	rtw_write8(Adapter, REG_SDIO_CTRL_8814A, 0x0);
 	rtw_write8(Adapter, REG_ACLK_MON, 0x0);
-	
+
 	//RT_TRACE(COMP_INIT, DBG_TRACE, ("InitializeAdapter8188EUsb() <====\n"));
-	
+
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_IQK);
 	// 2010/08/26 MH Merge from 8192CE.
-	if(pwrctrlpriv->rf_pwrstate == rf_on)
-	{
+	if (pwrctrlpriv->rf_pwrstate == rf_on) {
 /*		if(IS_HARDWARE_TYPE_8812AU(Adapter))
 		{
 #if (RTL8812A_SUPPORT == 1)
@@ -1584,9 +1546,9 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_IQK);
 	//this should be done by rf team using phydm code
 	//PHY_IQCalibrate_8814A(&pHalData->odmpriv, _FALSE);
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_PW_TRACK);
-		
+
 		//ODM_TXPowerTrackingCheck(&pHalData->odmpriv );
-		
+
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_LCK);
 		//PHY_LCCalibrate_8812A(Adapter);
 	}
@@ -1596,8 +1558,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC21);
 //HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PABIAS);
 //	_InitPABias(Adapter);
 #if (MP_DRIVER == 1)
-	if (Adapter->registrypriv.mp_mode == 1)
-	{
+	if (Adapter->registrypriv.mp_mode == 1) {
 		Adapter->mppriv.channel = pHalData->CurrentChannel;
 		MPT_InitializeAdapter(Adapter, Adapter->mppriv.channel);
 	}
@@ -1610,13 +1571,10 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BT_COEXIST);
 	// suspend mode automatically.
 	//HwSuspendModeEnable92Cu(Adapter, _FALSE);
 
-	if ( _TRUE == pHalData->EEPROMBluetoothCoexist)
-        {
-               // Init BT hw config.
-                rtw_btcoex_HAL_Initialize(Adapter, _FALSE);      
-        }
-        else
-        {
+	if ( _TRUE == pHalData->EEPROMBluetoothCoexist) {
+		// Init BT hw config.
+                rtw_btcoex_HAL_Initialize(Adapter, _FALSE);
+        } else {
                 // In combo card run wifi only , must setting some hardware reg.
                 rtl8812a_combo_card_WifiOnlyHwInit(Adapter);
         }
@@ -1633,18 +1591,18 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC31);
 
 	//misc
 	{
-		int i;		
+		int i;
 		u8 mac_addr[6];
-		for(i=0; i<6; i++)
-		{			
+		for (i=0; i<6; i++)
+		{
 #ifdef CONFIG_CONCURRENT_MODE
-			if(Adapter->iface_type == IFACE_PORT1)
+			if (Adapter->iface_type == IFACE_PORT1)
 				mac_addr[i] = rtw_read8(Adapter, REG_MACID1+i);
 			else
 #endif
-			mac_addr[i] = rtw_read8(Adapter, REG_MACID+i);		
+			mac_addr[i] = rtw_read8(Adapter, REG_MACID+i);
 		}
-		
+
 		RTW_INFO("MAC Address from REG_MACID = "MAC_FMT"\n", MAC_ARG(mac_addr));
 	}
 
@@ -1656,14 +1614,14 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END);
 	#ifdef DBG_HAL_INIT_PROFILING
 	hal_init_stages_timestamp[HAL_INIT_STAGES_END]=rtw_get_current_time();
 
-	for(hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM-1;hal_init_profiling_i++) {
+	for (hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM-1;hal_init_profiling_i++) {
 		RTW_INFO("DBG_HAL_INIT_PROFILING: %35s, %u, %5u, %5u\n"
 			, hal_init_stages_str[hal_init_profiling_i]
 			, hal_init_stages_timestamp[hal_init_profiling_i]
 			, (hal_init_stages_timestamp[hal_init_profiling_i+1]-hal_init_stages_timestamp[hal_init_profiling_i])
 			, rtw_get_time_interval_ms(hal_init_stages_timestamp[hal_init_profiling_i], hal_init_stages_timestamp[hal_init_profiling_i+1])
 		);
-	}	
+	}
 	#endif
 
 	return status;
@@ -1671,30 +1629,30 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END);
 
 VOID
 hal_carddisable_8814(
-	IN	PADAPTER			Adapter 
+	IN	PADAPTER			Adapter
 )
 {
 	u8	u1bTmp;
 
 	RTW_INFO("CardDisableRTL8814AU\n");
 
-	// stop rx 
+	// stop rx
 	rtw_write8(Adapter, REG_CR_8814A, 0x0);
 
 	// Card disable power action flow
 	HalPwrSeqCmdParsing(Adapter, ~PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8814A_NIC_DISABLE_FLOW);
 
 	Adapter->bFWReady = _FALSE;
-	
+
 }
 
 static void rtl8814au_hw_power_down(_adapter *padapter)
 {
 	// 2010/-8/09 MH For power down module, we need to enable register block contrl reg at 0x1c.
 	// Then enable power down control bit of register 0x04 BIT4 and BIT15 as 1.
-		
+
 	// Enable register area 0x0-0xc.
-	rtw_write8(padapter,REG_RSV_CTRL, 0x0);			
+	rtw_write8(padapter,REG_RSV_CTRL, 0x0);
 	rtw_write16(padapter, REG_APS_FSMCO, 0x8812);
 }
 
@@ -1705,8 +1663,7 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
    	RTW_INFO("==> %s \n",__FUNCTION__);
 
 #ifdef CONFIG_BT_COEXIST
-	if (hal_btcoex_IsBtExist(Adapter))
-	{
+	if (hal_btcoex_IsBtExist(Adapter)) {
 		RTW_INFO("BT module enable SIC\n");
 		// Only under WIN7 we can support selective suspend and enter D3 state when system call halt adapter.
 
@@ -1720,8 +1677,7 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
 		rtw_write16(Adapter, REG_GPIO_MUXCFG, rtw_read16(Adapter, REG_GPIO_MUXCFG)&(~BIT12));
 	}
 
-	if(pHalData->bSupportUSB3 == _TRUE)
-	{
+	if (pHalData->bSupportUSB3 == _TRUE) {
 		// set Reg 0xf008[3:4] to 2'11 to eable U1/U2 Mode in USB3.0. added by page, 20120712
 		rtw_write8(Adapter, 0xf008, rtw_read8(Adapter, 0xf008)|0x18);
 	}
@@ -1733,33 +1689,32 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
 
  #ifdef SUPPORT_HW_RFOFF_DETECTED
  	RTW_INFO("bkeepfwalive(%x)\n", pwrctl->bkeepfwalive);
- 	if(pwrctl->bkeepfwalive)
- 	{
-		_ps_close_RF(Adapter);		
-		if((pwrctl->bHWPwrPindetect) && (pwrctl->bHWPowerdown))
+ 	if (pwrctl->bkeepfwalive) {
+		_ps_close_RF(Adapter);
+		if ((pwrctl->bHWPwrPindetect) && (pwrctl->bHWPowerdown))
 			rtl8814au_hw_power_down(Adapter);
  	}
 	else
 #endif
-	{	
+	{
 		if (rtw_is_hw_init_completed(Adapter)) {
 			hal_carddisable_8814(Adapter);
 
-			if((pwrctl->bHWPwrPindetect ) && (pwrctl->bHWPowerdown))
+			if ((pwrctl->bHWPwrPindetect ) && (pwrctl->bHWPowerdown))
 				rtl8814au_hw_power_down(Adapter);
 		}
-	}		
+	}
 	return _SUCCESS;
  }
 
 unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
-{	
-	u8 i;	
+{
+	u8 i;
 	struct recv_buf *precvbuf;
 	uint	status;
 	struct dvobj_priv *pdev= adapter_to_dvobj(Adapter);
 	struct intf_hdl * pintfhdl=&Adapter->iopriv.intf;
-	struct recv_priv *precvpriv = &(Adapter->recvpriv);	
+	struct recv_priv *precvpriv = &(Adapter->recvpriv);
 	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
@@ -1770,22 +1725,20 @@ unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
 
 	status = _SUCCESS;
 
-	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("===> usb_inirp_init \n"));	
-		
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("===> usb_inirp_init \n"));
+
 	precvpriv->ff_hwaddr = RECV_BULK_IN_ADDR;
 
-	//issue Rx irp to receive data	
-	precvbuf = (struct recv_buf *)precvpriv->precv_buf;	
-	for(i=0; i<NR_RECVBUFF; i++)
-	{
-		if(_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == _FALSE )
-		{
+	//issue Rx irp to receive data
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	for (i=0; i<NR_RECVBUFF; i++) {
+		if (_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == _FALSE ) {
 			RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_port error \n"));
 			status = _FAIL;
 			goto exit;
 		}
-		
-		precvbuf++;		
+
+		precvbuf++;
 		precvpriv->free_recv_buf_queue_cnt--;
 	}
 
@@ -1794,17 +1747,16 @@ unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
 		status = _FAIL;
 		RTW_INFO("%s =>Warning !! Have not USB Int-IN pipe, RtIntInPipe(%d)!!!\n", __func__, pdev->RtInPipe[REALTEK_USB_IN_INT_EP_IDX]);
 		goto exit;
-	}	
+	}
 	_read_interrupt = pintfhdl->io_ops._read_interrupt;
-	if(_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == _FALSE )
-	{
+	if (_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == _FALSE ) {
 		RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_interrupt error \n"));
 		status = _FAIL;
 	}
 #endif
 
 exit:
-	
+
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("<=== usb_inirp_init \n"));
 
 	return status;
@@ -1812,9 +1764,9 @@ exit:
 }
 
 unsigned int rtl8814au_inirp_deinit(PADAPTER Adapter)
-{	
+{
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n ===> usb_rx_deinit \n"));
-	
+
 	rtw_read_port_cancel(Adapter);
 
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n <=== usb_rx_deinit \n"));
@@ -1836,25 +1788,22 @@ hal_ReadIDs_8814AU(
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
-	if( !AutoloadFail )
-	{
+	if ( !AutoloadFail ) {
 		pHalData->EEPROMVID = EF2Byte( *(pu2Byte)&PROMContent[EEPROM_VID_8814AU] );
-		pHalData->EEPROMPID = EF2Byte( *(pu2Byte)&PROMContent[EEPROM_PID_8814AU] );		
-		
-		// Customer ID, 0x00 and 0xff are reserved for Realtek. 		
+		pHalData->EEPROMPID = EF2Byte( *(pu2Byte)&PROMContent[EEPROM_PID_8814AU] );
+
+		// Customer ID, 0x00 and 0xff are reserved for Realtek.
 		pHalData->EEPROMCustomerID = *(pu1Byte)&PROMContent[EEPROM_CustomID_8814];
 		pHalData->EEPROMSubCustomerID = EEPROM_Default_SubCustomerID;
-	}
-	else
-	{
+	} else {
 		pHalData->EEPROMVID 			= EEPROM_Default_VID;
 		pHalData->EEPROMPID 			= EEPROM_Default_PID;
 
-		// Customer ID, 0x00 and 0xff are reserved for Realtek. 		
+		// Customer ID, 0x00 and 0xff are reserved for Realtek.
 		pHalData->EEPROMCustomerID		= EEPROM_Default_CustomerID;
 		pHalData->EEPROMSubCustomerID	= EEPROM_Default_SubCustomerID;
 	}
-	
+
 	RTW_INFO("VID = 0x%04X, PID = 0x%04X\n", pHalData->EEPROMVID, pHalData->EEPROMPID);
 	RTW_INFO("Customer ID: 0x%02X, SubCustomer ID: 0x%02X\n", pHalData->EEPROMCustomerID, pHalData->EEPROMSubCustomerID);
 }
@@ -1869,18 +1818,15 @@ hal_InitPGData_8814A(
 	u32			i;
 	u16			value16;
 
-	if(_FALSE == pHalData->bautoload_fail_flag)
-	{ // autoload OK.
+	if (_FALSE == pHalData->bautoload_fail_flag) { // autoload OK.
 		// hal_ReadeFuse_8814A is FW offload read efuse, todo
 	//#if ((DEV_BUS_TYPE==RT_USB_INTERFACE || DEV_BUS_TYPE==RT_SDIO_INTERFACE))  && (MP_DRIVER != 1)
 		//if(hal_ReadeFuse_8814A(pAdapter) == _FAIL)
 	//#endif
-		
+
 		// Read EFUSE real map to shadow.
 		EFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI, _FALSE);
-	}
-	else
-	{//autoload fail
+	} else { //autoload fail
 		RTW_INFO("AutoLoad Fail reported from CR9346!!\n");
 		//update to default value 0xFF
 		EFUSE_ShadowMapUpdate(padapter, EFUSE_WIFI, _FALSE);
@@ -1899,11 +1845,11 @@ hal_CustomizedBehavior_8814AU(
 	IN	PADAPTER	Adapter
 	)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct led_priv	*pledpriv = &(Adapter->ledpriv);
-	
+
 	// Led mode
-	switch(pHalData->CustomerID)
+	switch (pHalData->CustomerID)
 	{
 		case RT_CID_DEFAULT:
 			pledpriv->LedStrategy = SW_LED_MODE9;
@@ -1922,48 +1868,48 @@ hal_CustomizeByCustomerID_8814AU(
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	
+
 	RTW_INFO("PID= 0x%x, VID=  %x\n",pHalData->EEPROMPID,pHalData->EEPROMVID);
-	
+
 	//	Decide CustomerID according to VID/DID or EEPROM
-	switch(pHalData->EEPROMCustomerID)
+	switch (pHalData->EEPROMCustomerID)
 	{
 		case EEPROM_CID_DEFAULT:
-			if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3308))
+			if ((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3308))
 				pHalData->CustomerID = RT_CID_DLINK;
-			else if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3309))
+			else if ((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x3309))
 				pHalData->CustomerID = RT_CID_DLINK;
-			else if((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x330a))
+			else if ((pHalData->EEPROMVID == 0x2001) && (pHalData->EEPROMPID == 0x330a))
 				pHalData->CustomerID = RT_CID_DLINK;
-			else if((pHalData->EEPROMVID == 0x0BFF) && (pHalData->EEPROMPID == 0x8160))
+			else if ((pHalData->EEPROMVID == 0x0BFF) && (pHalData->EEPROMPID == 0x8160))
 			{
 				pHalData->CustomerID = RT_CID_CHINA_MOBILE;
-			}	
-			else if((pHalData->EEPROMVID == 0x0BDA) &&	(pHalData->EEPROMPID == 0x5088))
+			}
+			else if ((pHalData->EEPROMVID == 0x0BDA) &&	(pHalData->EEPROMPID == 0x5088))
 				pHalData->CustomerID = RT_CID_CC_C;
-			
+
 			break;
 		case EEPROM_CID_WHQL:
 			//padapter->bInHctTest = _TRUE;
-	
+
 			//pMgntInfo->bSupportTurboMode = _FALSE;
 			//pMgntInfo->bAutoTurboBy8186 = _FALSE;
-	
+
 			//pMgntInfo->PowerSaveControl.bInactivePs = _FALSE;
 			//pMgntInfo->PowerSaveControl.bIPSModeBackup = _FALSE;
 			//pMgntInfo->PowerSaveControl.bLeisurePs = _FALSE;
 			//pMgntInfo->PowerSaveControl.bLeisurePsModeBackup = _FALSE;
 			//pMgntInfo->keepAliveLevel = 0;
-	
+
 			//padapter->bUnloadDriverwhenS3S4 = _FALSE;
-			break;			
+			break;
 		default:
 			pHalData->CustomerID = RT_CID_DEFAULT;
 			break;
-			
+
 	}
 	RTW_INFO("Customer ID: 0x%2x\n", pHalData->CustomerID);
-	
+
 	hal_CustomizedBehavior_8814AU(pAdapter);
 }
 
@@ -1975,7 +1921,7 @@ hal_ReadUsbModeSwitch_8814AU(
 	)
 {
   	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
-	
+
 	if (AutoloadFail)
 		pHalData->EEPROMUsbSwitch = _FALSE;
 	else
@@ -1985,7 +1931,7 @@ hal_ReadUsbModeSwitch_8814AU(
 
 static VOID
 ReadLEDSetting_8814AU(
-	IN	PADAPTER	Adapter,	
+	IN	PADAPTER	Adapter,
 	IN	u8*		PROMContent,
 	IN	BOOLEAN		AutoloadFail
 	)
@@ -2015,19 +1961,19 @@ InitAdapterVariablesByPROM_8814AU(
 	hal_ReadTxPowerInfo8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadBoardType8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_Read_TRX_antenna_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
-	
+
 	//
 	// Read Bluetooth co-exist and initialize
 	//
 	hal_EfuseParseBTCoexistInfo8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
-	
+
 	hal_ReadChannelPlan8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_EfuseParseXtal_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);	
 	hal_ReadThermalMeter_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadRemoteWakeup_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadAntennaDiversity8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 	hal_ReadRFEType_8814A(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
-	
+
 	ReadLEDSetting_8814AU(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
 
 	hal_ReadUsbModeSwitch_8814AU(Adapter, pHalData->efuse_eeprom_data, pHalData->bautoload_fail_flag);
@@ -2041,7 +1987,7 @@ InitAdapterVariablesByPROM_8814AU(
 static void hal_ReadPROMContent_8814A(
 	IN PADAPTER 		Adapter
 	)
-{	
+{
 	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(Adapter);
 	u8			eeValue;
 
@@ -2064,7 +2010,7 @@ ReadAdapterInfo8814AU(
 	)
 {
 	Hal_InitEfuseVars_8814A(Adapter);
-	
+
 	// Read all content in Efuse/EEPROM.
 	hal_ReadPROMContent_8814A(Adapter);
 
@@ -2079,21 +2025,21 @@ void UpdateInterruptMask8814AU(PADAPTER padapter,u8 bHIMR0 ,u32 AddMSR, u32 Remo
 	u32 *himr;
 	pHalData = GET_HAL_DATA(padapter);
 
-	if(bHIMR0)
+	if (bHIMR0)
 		himr = &(pHalData->IntrMask[0]);
 	else
 		himr = &(pHalData->IntrMask[1]);
-	
+
 	if (AddMSR)
 		*himr |= AddMSR;
 
 	if (RemoveMSR)
 		*himr &= (~RemoveMSR);
 
-	if(bHIMR0)	
+	if (bHIMR0)
 		rtw_write32(padapter, REG_HIMR0_8814A, *himr);
 	else
-		rtw_write32(padapter, REG_HIMR1_8814A, *himr);	
+		rtw_write32(padapter, REG_HIMR1_8814A, *himr);
 
 }
 
@@ -2103,7 +2049,7 @@ void SetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(Adapter);
 	struct registry_priv *registry_par = &Adapter->registrypriv;
 
-	switch(variable)
+	switch (variable)
 	{
 		case HW_VAR_RXDMA_AGG_PG_TH:
 #ifdef CONFIG_USB_RX_AGGREGATION
@@ -2185,9 +2131,9 @@ void SetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 
 void GetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
-	switch(variable)
+	switch (variable)
 	{
 		default:
 			GetHwReg8814A(Adapter,variable,val);
@@ -2210,7 +2156,7 @@ SetHalDefVar8814AUsb(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u8			bResult = _SUCCESS;
 
-	switch(eVariable)
+	switch (eVariable)
 	{
 		default:
 			SetHalDefVar8814A(Adapter,eVariable,pValue);
@@ -2221,7 +2167,7 @@ SetHalDefVar8814AUsb(
 }
 
 //
-//	Description: 
+//	Description:
 //		Query setting of specified variable.
 //
 u8
@@ -2234,7 +2180,7 @@ GetHalDefVar8814AUsb(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u8			bResult = _SUCCESS;
 
-	switch(eVariable)
+	switch (eVariable)
 	{
 		default:
 			GetHalDefVar8814A(Adapter,eVariable,pValue);
@@ -2302,9 +2248,9 @@ static void rtl8814au_init_default_value(_adapter * padapter)
 }
 
 static u8 rtl8814au_ps_func(PADAPTER Adapter,HAL_INTF_PS_FUNC efunc_id, u8 *val)
-{	
+{
 	u8 bResult = _TRUE;
-	switch(efunc_id){
+	switch (efunc_id) {
 
 		#if defined(CONFIG_AUTOSUSPEND) && defined(SUPPORT_HW_RFOFF_DETECTED)
 		case HAL_USB_SELECT_SUSPEND:
@@ -2327,7 +2273,7 @@ void rtl8814au_set_hal_ops(_adapter * padapter)
 
 	pHalFunc->hal_power_on = _InitPowerOn_8814AU;
 	pHalFunc->hal_power_off = hal_carddisable_8814;
-	
+
 	pHalFunc->hal_init = &rtl8814au_hal_init;
 	pHalFunc->hal_deinit = &rtl8814au_hal_deinit;
 
@@ -2345,12 +2291,12 @@ void rtl8814au_set_hal_ops(_adapter * padapter)
 #else //case of hw led or no led
 	pHalFunc->InitSwLeds = NULL;
 	pHalFunc->DeInitSwLeds = NULL;
-#endif//CONFIG_SW_LED
-	
+#endif //CONFIG_SW_LED
+
 	pHalFunc->init_default_value = &rtl8814au_init_default_value;
 	pHalFunc->intf_chip_configure = &rtl8814au_interface_configure;
 	pHalFunc->read_adapter_info = &ReadAdapterInfo8814AU;
- 
+
 	pHalFunc->SetHwRegHandler = &SetHwReg8814AU;
 	pHalFunc->GetHwRegHandler = &GetHwReg8814AU;
   	pHalFunc->GetHalDefVarHandler = &GetHalDefVar8814AUsb;
diff --git a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_ops_linux.c b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_ops_linux.c
index 59281f9..d2fea87 100644
--- a/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_ops_linux.c
+++ b/drivers/net/wireless/rtl8814au/hal/rtl8814a/usb/usb_ops_linux.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -24,17 +24,16 @@
 
 #ifdef CONFIG_SUPPORT_USB_INT
 void interrupt_handler_8814au(_adapter *padapter,u16 pkt_len,u8 *pbuf)
-{	
+{
 	HAL_DATA_TYPE	*pHalData=GET_HAL_DATA(padapter);
 	struct reportpwrstate_parm pwr_rpt;
-	
-	if ( pkt_len != INTERRUPT_MSG_FORMAT_LEN )
-	{
+
+	if ( pkt_len != INTERRUPT_MSG_FORMAT_LEN ) {
 		RTW_INFO("%s Invalid interrupt content length (%d)!\n", __FUNCTION__, pkt_len);
 		return ;
 	}
 
-	// HISR 
+	// HISR
 	_rtw_memcpy(&(pHalData->IntArray[0]), &(pbuf[USB_INTR_CONTENT_HISR_OFFSET]), 4);
 	_rtw_memcpy(&(pHalData->IntArray[1]), &(pbuf[USB_INTR_CONTENT_HISRE_OFFSET]), 4);
 
@@ -42,25 +41,24 @@ void interrupt_handler_8814au(_adapter *padapter,u16 pkt_len,u8 *pbuf)
 	{
 		u32 hisr=0 ,hisr_ex=0;
 		_rtw_memcpy(&hisr,&(pHalData->IntArray[0]),4);
-		hisr = le32_to_cpu(hisr);	
-		
+		hisr = le32_to_cpu(hisr);
+
 		_rtw_memcpy(&hisr_ex,&(pHalData->IntArray[1]),4);
 		hisr_ex = le32_to_cpu(hisr_ex);
-		
-		if((hisr != 0) || (hisr_ex!=0))
+
+		if ((hisr != 0) || (hisr_ex!=0))
 			RTW_INFO("===> %s hisr:0x%08x ,hisr_ex:0x%08x \n",__FUNCTION__,hisr,hisr_ex);
 	}
 	#endif
 
 
 #ifdef CONFIG_LPS_LCLK
-	if(  pHalData->IntArray[0]  & IMR_CPWM_88E )
-	{
+	if (  pHalData->IntArray[0]  & IMR_CPWM_88E ) {
 		_rtw_memcpy(&pwr_rpt.state, &(pbuf[USB_INTR_CONTENT_CPWM1_OFFSET]), 1);
 		//_rtw_memcpy(&pwr_rpt.state2, &(pbuf[USB_INTR_CONTENT_CPWM2_OFFSET]), 1);
 
-		//88e's cpwm value only change BIT0, so driver need to add PS_STATE_S2 for LPS flow.		
-		pwr_rpt.state |= PS_STATE_S2;		
+		//88e's cpwm value only change BIT0, so driver need to add PS_STATE_S2 for LPS flow.
+		pwr_rpt.state |= PS_STATE_S2;
 		_set_workitem(&(adapter_to_pwrctl(padapter)->cpwm_event));
 	}
 #endif//CONFIG_LPS_LCLK
@@ -72,40 +70,38 @@ void interrupt_handler_8814au(_adapter *padapter,u16 pkt_len,u8 *pbuf)
 	#endif
 	#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
 	if (pHalData->IntArray[0] & (IMR_TBDER_88E|IMR_TBDOK_88E))
-	#endif	
-	{		
+	#endif
+	{
 		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 		#if 0
-		if(pHalData->IntArray[0] & IMR_BCNDMAINT0_88E)
+		if (pHalData->IntArray[0] & IMR_BCNDMAINT0_88E)
 			RTW_INFO("%s: HISR_BCNERLY_INT\n", __func__);
-		if(pHalData->IntArray[0] & IMR_TBDOK_88E)
+		if (pHalData->IntArray[0] & IMR_TBDOK_88E)
 			RTW_INFO("%s: HISR_TXBCNOK\n", __func__);
-		if(pHalData->IntArray[0] & IMR_TBDER_88E)
+		if (pHalData->IntArray[0] & IMR_TBDER_88E)
 			RTW_INFO("%s: HISR_TXBCNERR\n", __func__);
 		#endif
-		
 
-		if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
-		{
+
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 			//send_beacon(padapter);
-			if(pmlmepriv->update_bcn == _TRUE)
+			if (pmlmepriv->update_bcn == _TRUE)
 			{
 				//tx_beacon_hdl(padapter, NULL);
 				set_tx_beacon_cmd(padapter);
 			}
 		}
 #ifdef CONFIG_CONCURRENT_MODE
-		if(check_buddy_fwstate(padapter, WIFI_AP_STATE))
-		{
+		if (check_buddy_fwstate(padapter, WIFI_AP_STATE)) {
 			//send_beacon(padapter);
-			if(padapter->pbuddy_adapter->mlmepriv.update_bcn == _TRUE)
+			if (padapter->pbuddy_adapter->mlmepriv.update_bcn == _TRUE)
 			{
 				//tx_beacon_hdl(padapter, NULL);
 				set_tx_beacon_cmd(padapter->pbuddy_adapter);
 			}
 		}
 #endif
-		
+
 	}
 #endif //CONFIG_INTERRUPT_BASED_TXBCN
 
@@ -361,8 +357,9 @@ int recvbuf2recvframe(PADAPTER padapter, void *ptr)
 		}
 
 #ifdef CONFIG_RX_PACKET_APPEND_FCS
-		if(pattrib->pkt_rpt_type == NORMAL_RX)
-			pattrib->pkt_len -= IEEE80211_FCS_LEN;
+                if (check_fwstate(&padapter->mlmepriv, WIFI_MONITOR_STATE) == _FALSE)
+                        if ((pattrib->pkt_rpt_type == NORMAL_RX) && (pHalData->ReceiveConfig & RCR_APPFCS))
+                                pattrib->pkt_len -= IEEE80211_FCS_LEN;
 #endif
 		if(rtw_os_alloc_recvframe(padapter, precvframe, 
 			(pbuf + pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE), pskb) == _FAIL)
diff --git a/drivers/net/wireless/rtl8814au/include/autoconf.h b/drivers/net/wireless/rtl8814au/include/autoconf.h
index 2e1c614..3c1713f 100644
--- a/drivers/net/wireless/rtl8814au/include/autoconf.h
+++ b/drivers/net/wireless/rtl8814au/include/autoconf.h
@@ -309,7 +309,6 @@
 #endif /* !CONFIG_BT_COEXIST */
 
 
-
 #ifdef CONFIG_USB_TX_AGGREGATION
 /* #define	CONFIG_TX_EARLY_MODE */
 #endif
@@ -347,12 +346,11 @@
 /* #define DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED "jeff-ap" */
 
 
-
 /* #define DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE */
 /* #define DBG_ROAMING_TEST */
 
 /* #define DBG_HAL_INIT_PROFILING */
 
-/*#define DBG_MEMORY_LEAK*/
+/* #define DBG_MEMORY_LEAK*/
 #define	DBG_RX_DFRAME_RAW_DATA
-/*#define CONFIG_USE_EXTERNAL_POWER  */        /* NOT USB2.0 power, so no 500mA power constraint, no limitation in Power by Rate*/
+/* #define CONFIG_USE_EXTERNAL_POWER */        /* NOT USB2.0 power, so no 500mA power constraint, no limitation in Power by Rate */
diff --git a/drivers/net/wireless/rtl8814au/include/rtw_wifi_regd.h b/drivers/net/wireless/rtl8814au/include/rtw_wifi_regd.h
index 69bd71d..7acbb95 100644
--- a/drivers/net/wireless/rtl8814au/include/rtw_wifi_regd.h
+++ b/drivers/net/wireless/rtl8814au/include/rtw_wifi_regd.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 #ifndef __RTW_WIFI_REGD_H__
-#define __RTW_WIFI_REGD_H__
+#define __RTW_WIFI_REGD_H__ 
 
 int rtw_regd_init(_adapter *padapter);
 void rtw_reg_notify_by_driver(_adapter *adapter);
diff --git a/drivers/net/wireless/rtl8814au/include/rtw_xmit.h b/drivers/net/wireless/rtl8814au/include/rtw_xmit.h
index d372338..6b5ea43 100644
--- a/drivers/net/wireless/rtl8814au/include/rtw_xmit.h
+++ b/drivers/net/wireless/rtl8814au/include/rtw_xmit.h
@@ -421,7 +421,7 @@ struct pkt_attrib {
 	u8	rate;
 	u8	intel_proxim;
 	u8	retry_ctrl;
-	u8	sw_seq;
+	//u8	sw_seq; // Add support for pre-configured SeqNum via RadioTap
 	u8   mbssid;
 	u8	ldpc;
 	u8	stbc;
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_cfg80211.c
index 8a7e088..17937e7 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/ioctl_cfg80211.c
@@ -1750,6 +1750,7 @@ static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 
 		sinfo->filled |= STATION_INFO_BSS_PARAM;
 
+#if defined (LINUX_VERSION_CODE) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 20, 0))
 		if (!psta->no_short_preamble_set)
 		  sinfo->bss_param.flags |= STATION_INFO_BSS_PARAM_SHORT_PREAMBLE;
 
@@ -1765,6 +1766,7 @@ static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 		sinfo->bss_param.dtim_period = pwrctl->dtim;
 		
 		sinfo->bss_param.beacon_interval = get_beacon_interval(&cur_network->network);
+#endif
 
 	}
 
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/recv_linux.c b/drivers/net/wireless/rtl8814au/os_dep/linux/recv_linux.c
index 52fbba5..a802a9d 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/recv_linux.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/recv_linux.c
@@ -445,10 +445,11 @@ void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attri
 #endif /* CONFIG_TCP_CSUM_OFFLOAD_RX */
 
 		ret = rtw_netif_rx(padapter->pnetdev, pkt);
-		if (ret == NET_RX_SUCCESS)
+		if (ret == NET_RX_SUCCESS) {
 			DBG_COUNTER(padapter->rx_logs.os_netif_ok);
-		else
+		} else {
 			DBG_COUNTER(padapter->rx_logs.os_netif_err);
+		}
 	}
 }
 
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/usb_intf.c b/drivers/net/wireless/rtl8814au/os_dep/linux/usb_intf.c
index 6ed4e72..47b3435 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/usb_intf.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/usb_intf.c
@@ -222,6 +222,7 @@ static struct usb_device_id rtw_usb_id_tbl[] = {
 	{USB_DEVICE(0x2001, 0x331A), .driver_info = RTL8814A}, /* D-Link - D-Link */
 	{USB_DEVICE(0x0B05, 0x1817), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
 	{USB_DEVICE(0x0B05, 0x1852), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
+	{USB_DEVICE(0x0B05, 0x1853), .driver_info = RTL8814A}, /* ASUS - ASUSTeK */
 	{USB_DEVICE(0x056E, 0x400B), .driver_info = RTL8814A}, /* ELECOM - ELECOM */
 	{USB_DEVICE(0x056E, 0x400D), .driver_info = RTL8814A}, /* ELECOM - ELECOM */
 	{USB_DEVICE(0x7392, 0xA834), .driver_info = RTL8814A}, /* Edimax - Edimax */
diff --git a/drivers/net/wireless/rtl8814au/os_dep/linux/wifi_regd.c b/drivers/net/wireless/rtl8814au/os_dep/linux/wifi_regd.c
index fa8ba7b..b0a4abd 100644
--- a/drivers/net/wireless/rtl8814au/os_dep/linux/wifi_regd.c
+++ b/drivers/net/wireless/rtl8814au/os_dep/linux/wifi_regd.c
@@ -15,8 +15,8 @@ void rtw_reg_notify_by_driver(_adapter *adapter)
 	return;
 }
 
-int rtw_regd_init(_adapter *padapter)
+int rtw_regd_init(_adapter * padapter)
 {
 	return 0;
 }
-#endif /* CONFIG_IOCTL_CFG80211 */
+#endif //CONFIG_IOCTL_CFG80211
