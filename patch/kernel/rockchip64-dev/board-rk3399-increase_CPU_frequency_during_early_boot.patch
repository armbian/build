From 0a2aa023e6180b6d0416ed61310a57ce24d03dba Mon Sep 17 00:00:00 2001
From: Heiher <r@hev.cc>
Date: Fri, 20 Mar 2020 00:46:13 +0800
Subject: [PATCH] arm64: rk3399: increase CPU frequency during early boot

This is a workaround to fix the following issues. The right way should
be to increase frequency of CPU before boot linux kernel in bootloader.

[   92.165850] watchdog: BUG: soft lockup - CPU#4 stuck for 22s! [swapper/0:1]
[   92.166643] Modules linked in:
[   92.167463] CPU: 4 PID: 1 Comm: swapper/0 Not tainted 5.5.10-ARCH #1
[   92.168025] Hardware name: FriendlyElec NanoPi M4 (DT)
[   92.168672] pstate: 20000005 (nzCv daif -PAN -UAO)
[   92.169504] pc : trace_event_eval_update+0xfc/0x348
[   92.170164] lr : trace_event_eval_update+0x144/0x348
[   92.170652] sp : ffff80001004bcf0
[   92.171112] x29: ffff80001004bcf0 x28: 0000000000000001
[   92.171834] x27: ffff8000118d2228 x26: ffff8000111710b0
[   92.172502] x25: ffff80001180db98 x24: 000000000000000e
[   92.173134] x23: ffff800011746428 x22: 00000000000000ec
[   92.173749] x21: 0000000000000264 x20: 0000000000000158
[   92.174352] x19: ffff8000118bc778 x18: 0000000000000001
[   92.174951] x17: 00000000ed34b782 x16: 00000000d54c3662
[   92.175549] x15: 2d20377b1910031c x14: ff00000000000000
[   92.176140] x13: 0000000000000000 x12: 0000000000000007
[   92.176731] x11: 0101010101010101 x10: 0000000000000005
[   92.177322] x9 : 0000000000000003 x8 : 0000000000000008
[   92.177922] x7 : 1c0310197b37202d x6 : 2d20377b1910031c
[   92.178506] x5 : 0000000000000000 x4 : 000000000000000e
[   92.179085] x3 : ffff8000118bbbee x2 : 0000000000000045
[   92.179671] x1 : 000000000000002c x0 : 0000000000000000
[   92.180263] Call trace:
[   92.180921]  trace_event_eval_update+0xfc/0x348
[   92.181652]  tracer_init_tracefs+0x160/0x1e8
[   92.182304]  do_one_initcall+0x4c/0x218
[   92.182949]  kernel_init_freeable+0x1d0/0x240
[   92.183652]  kernel_init+0x18/0x104
[   92.184245]  ret_from_fork+0x10/0x18

[  133.872912] cpufreq: cpufreq_online: CPU4: Running at unlisted freq: 12000 KHz
[  133.891606] cpufreq: cpufreq_online: CPU4: Unlisted initial frequency changed to: 408000 KHz
---
 arch/arm64/kernel/setup.c | 43 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 43 insertions(+)

diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c
index 56f6645617548..81f4538f231fe 100644
--- a/arch/arm64/kernel/setup.c
+++ b/arch/arm64/kernel/setup.c
@@ -23,6 +23,7 @@
 #include <linux/interrupt.h>
 #include <linux/smp.h>
 #include <linux/fs.h>
+#include <linux/clk.h>
 #include <linux/proc_fs.h>
 #include <linux/memblock.h>
 #include <linux/of_fdt.h>
@@ -373,6 +374,36 @@ static inline bool cpu_can_disable(unsigned int cpu)
 	return false;
 }
 
+static unsigned long __init cpu_max_freq(unsigned int cpu)
+{
+	unsigned long max_freq = 0;
+	struct device_node *cpu_node;
+	struct device_node *op_node;
+	struct device_node *np;
+
+	cpu_node = of_get_cpu_node(cpu, NULL);
+	if (!cpu_node)
+		return 0;
+
+	op_node = of_parse_phandle(cpu_node, "operating-points-v2", 0);
+	of_node_put(cpu_node);
+	if (!op_node)
+		return 0;
+
+	for_each_available_child_of_node(op_node, np) {
+		u64 freq;
+
+		if (of_property_read_u64(np, "opp-hz", &freq) < 0)
+			continue;
+
+		if (freq > max_freq)
+			max_freq = freq;
+	}
+	of_node_put(op_node);
+
+	return max_freq;
+}
+
 static int __init topology_init(void)
 {
 	int i;
@@ -386,6 +417,18 @@ static int __init topology_init(void)
 		register_cpu(cpu, i);
 	}
 
+	for_each_possible_cpu(i) {
+		struct device *cpu_dev = get_cpu_device(i);
+		unsigned long cpu_freq = cpu_max_freq(i);
+		if (cpu_dev && cpu_freq) {
+			struct clk *cpu_clk = clk_get(cpu_dev, NULL);
+			if (!PTR_ERR_OR_ZERO(cpu_clk)) {
+				clk_set_rate(cpu_clk, cpu_freq);
+				clk_put(cpu_clk);
+			}
+		}
+	}
+
 	return 0;
 }
 subsys_initcall(topology_init);
