
From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 26 Jul 2025 14:21:33 +0000
Subject: WIP: net: stmmac: dwmac-rk: Allow use of rx/tx delayline for rgmii-id
 modes

Signed-off-by: Jonas Karlman <jonas@kwiboo.se>
---
 drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c | 37 ++++------
 1 file changed, 15 insertions(+), 22 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
index 111111111111..222222222222 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
@@ -1580,23 +1580,23 @@ static struct rk_priv_data *rk_gmac_setup(struct platform_device *pdev,
 
 	ret = of_property_read_u32(dev->of_node, "tx_delay", &value);
 	if (ret) {
-		bsp_priv->tx_delay = 0x30;
-		dev_err(dev, "Can not read property: tx_delay.");
-		dev_err(dev, "set tx_delay to 0x%x\n",
-			bsp_priv->tx_delay);
+		if (plat->phy_interface == PHY_INTERFACE_MODE_RGMII_ID ||
+		    plat->phy_interface == PHY_INTERFACE_MODE_RGMII_TXID)
+			bsp_priv->tx_delay = 0;
+		else
+			bsp_priv->tx_delay = 0x30;
 	} else {
-		dev_info(dev, "TX delay(0x%x).\n", value);
 		bsp_priv->tx_delay = value;
 	}
 
 	ret = of_property_read_u32(dev->of_node, "rx_delay", &value);
 	if (ret) {
-		bsp_priv->rx_delay = 0x10;
-		dev_err(dev, "Can not read property: rx_delay.");
-		dev_err(dev, "set rx_delay to 0x%x\n",
-			bsp_priv->rx_delay);
+		if (plat->phy_interface == PHY_INTERFACE_MODE_RGMII_ID ||
+		    plat->phy_interface == PHY_INTERFACE_MODE_RGMII_RXID)
+			bsp_priv->rx_delay = 0;
+		else
+			bsp_priv->rx_delay = 0x10;
 	} else {
-		dev_info(dev, "RX delay(0x%x).\n", value);
 		bsp_priv->rx_delay = value;
 	}
 
@@ -1675,21 +1675,14 @@ static int rk_gmac_powerup(struct rk_priv_data *bsp_priv)
 	/*rmii or rgmii*/
 	switch (bsp_priv->phy_iface) {
 	case PHY_INTERFACE_MODE_RGMII:
-		dev_info(dev, "init for RGMII\n");
-		bsp_priv->ops->set_to_rgmii(bsp_priv, bsp_priv->tx_delay,
-					    bsp_priv->rx_delay);
-		break;
 	case PHY_INTERFACE_MODE_RGMII_ID:
-		dev_info(dev, "init for RGMII_ID\n");
-		bsp_priv->ops->set_to_rgmii(bsp_priv, 0, 0);
-		break;
 	case PHY_INTERFACE_MODE_RGMII_RXID:
-		dev_info(dev, "init for RGMII_RXID\n");
-		bsp_priv->ops->set_to_rgmii(bsp_priv, bsp_priv->tx_delay, 0);
-		break;
 	case PHY_INTERFACE_MODE_RGMII_TXID:
-		dev_info(dev, "init for RGMII_TXID\n");
-		bsp_priv->ops->set_to_rgmii(bsp_priv, 0, bsp_priv->rx_delay);
+		dev_info(dev, "init for %s with delay (tx: 0x%x, rx: 0x%x)\n",
+			 phy_modes(bsp_priv->phy_iface),
+			 bsp_priv->tx_delay, bsp_priv->rx_delay);
+		bsp_priv->ops->set_to_rgmii(bsp_priv, bsp_priv->tx_delay,
+					    bsp_priv->rx_delay);
 		break;
 	case PHY_INTERFACE_MODE_RMII:
 		dev_info(dev, "init for RMII\n");
-- 
Armbian

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 26 Jul 2025 15:19:15 +0000
Subject: WIP: net: stmmac: dwmac-rk: Use CRU as default TX clk source for
 RGMII modes

The original meaning of the clock_in_out prop typically only had any
meaning for RMII modes, with 'input' meaning that clk source is from the
PHY and 'output' meaning clk source is from the internal CRU.

'input' means PHY provides the reference clock(50MHz), 'output' means GMAC provides the reference clock.

For RGMII the meaning of 'input' and 'output' is somewhat ambiguous, the
RX clk is input from PHY and the TX clock is output to the PHY. The
dt-binding also mention

Rockchip TRMs make it clear that for RGMII modes the TX clk source must
be from CRU. However, for RK3568 there is also support for using the PHY
output clk as a

Signed-off-by: Jonas Karlman <jonas@kwiboo.se>
---
 drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c | 15 +++++++---
 1 file changed, 11 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
index 111111111111..222222222222 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
@@ -1567,17 +1567,22 @@ static struct rk_priv_data *rk_gmac_setup(struct platform_device *pdev,
 
 	ret = of_property_read_string(dev->of_node, "clock_in_out", &strings);
 	if (ret) {
-		dev_err(dev, "Can not read property: clock_in_out.\n");
 		bsp_priv->clock_input = true;
 	} else {
-		dev_info(dev, "clock input or output? (%s).\n",
-			 strings);
 		if (!strcmp(strings, "input"))
 			bsp_priv->clock_input = true;
 		else
 			bsp_priv->clock_input = false;
 	}
 
+	/* For RGMII, clock_in_out 'input' means main 125MHz clock is sourced
+	 * from PHY and not from an internal PLL. Use of PHY or PLL as clock
+	 * source for the 125MHz clock only affect the CRU clock tree.
+	 * For RGMII modes, GMAC must always use CRU as the TX clock source.
+	 */
+	if (phy_interface_mode_is_rgmii(plat->phy_interface))
+		bsp_priv->clock_input = false;
+
 	ret = of_property_read_u32(dev->of_node, "tx_delay", &value);
 	if (ret) {
 		if (plat->phy_interface == PHY_INTERFACE_MODE_RGMII_ID ||
@@ -1685,7 +1690,9 @@ static int rk_gmac_powerup(struct rk_priv_data *bsp_priv)
 					    bsp_priv->rx_delay);
 		break;
 	case PHY_INTERFACE_MODE_RMII:
-		dev_info(dev, "init for RMII\n");
+		dev_info(dev, "init for %s with %s clock\n",
+			 phy_modes(bsp_priv->phy_iface),
+			 bsp_priv->clock_input ? "input" : "output");
 		bsp_priv->ops->set_to_rmii(bsp_priv);
 		break;
 	default:
-- 
Armbian

