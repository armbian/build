From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: HackingGate <i@hackinggate.com>
Date: Sat, 25 Oct 2025 23:14:12 +0900
Subject: [PATCH 2/2] arm64: rockchip: rk3576: add photonicat usb watchdog

---
 drivers/staging/Kconfig                       |   2 +
 drivers/staging/Makefile                      |   1 +
 drivers/staging/photonicat-usb-wdt/Kconfig    |  10 +
 drivers/staging/photonicat-usb-wdt/Makefile   |   1 +
 .../photonicat-usb-wdt/photonicat-usb-wdt.c   | 278 ++++++++++++++++++
 5 files changed, 292 insertions(+)
 create mode 100644 drivers/staging/photonicat-usb-wdt/Kconfig
 create mode 100644 drivers/staging/photonicat-usb-wdt/Makefile
 create mode 100644 drivers/staging/photonicat-usb-wdt/photonicat-usb-wdt.c

diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index 3fe77abdb77c..dc853abae222 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -52,4 +52,6 @@ source "drivers/staging/gpib/Kconfig"
 
 source "drivers/staging/photonicat-pm/Kconfig"
 
+source "drivers/staging/photonicat-usb-wdt/Kconfig"
+
 endif # STAGING
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index dce556962331..7c4b66691f17 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_XIL_AXIS_FIFO)	+= axis-fifo/
 obj-$(CONFIG_GPIB)	 	+= gpib/
 obj-$(CONFIG_RTL8723CS)                += rtl8723cs/
 obj-$(CONFIG_PHOTONICAT_PM)	+= photonicat-pm/
+obj-$(CONFIG_PHOTONICAT_USB_WDT)	+= photonicat-usb-wdt/
diff --git a/drivers/staging/photonicat-usb-wdt/Kconfig b/drivers/staging/photonicat-usb-wdt/Kconfig
new file mode 100644
index 000000000000..d5a03b176f81
--- /dev/null
+++ b/drivers/staging/photonicat-usb-wdt/Kconfig
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+config PHOTONICAT_USB_WDT
+	tristate "photonicat USB watchdog"
+	depends on OF && GPIOLIB
+	depends on USB
+	select WATCHDOG_CORE
+	help
+	  USB watchdog for photonicat board. Unless you have the platform,
+	  you will want to say 'N'.
+
diff --git a/drivers/staging/photonicat-usb-wdt/Makefile b/drivers/staging/photonicat-usb-wdt/Makefile
new file mode 100644
index 000000000000..b61ef615473d
--- /dev/null
+++ b/drivers/staging/photonicat-usb-wdt/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_PHOTONICAT_USB_WDT) += photonicat-usb-wdt.o
diff --git a/drivers/staging/photonicat-usb-wdt/photonicat-usb-wdt.c b/drivers/staging/photonicat-usb-wdt/photonicat-usb-wdt.c
new file mode 100644
index 000000000000..5e3a38a1cdb5
--- /dev/null
+++ b/drivers/staging/photonicat-usb-wdt/photonicat-usb-wdt.c
@@ -0,0 +1,278 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/usb.h>
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/watchdog.h>
+
+#define PCAT_USB_WATCHDOG_TIMEOUT_DEFAULT 15
+#define PCAT_USB_WATCHDOG_TIMEOUT_MIN 1
+#define PCAT_USB_WATCHDOG_TIMEOUT_MAX 120
+#define PCAT_USB_WATCHDOG_RESET_MS_DEFAULT 500
+
+static bool nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, bool, 0);
+MODULE_PARM_DESC(nowayout,
+		 "Watchdog cannot be stopped once started (default="
+		 __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+struct pcat_usb_watchdog_data {
+	struct device *dev;
+	int target_vid;
+	int target_pid;
+	u32 reset_ms;
+	u32 scan_interval_ms;
+	struct gpio_desc *reset_gpio;
+	bool target_live;
+	struct watchdog_device wdd;
+	struct timer_list monitor_timer;
+	struct work_struct gpio_work;
+	struct notifier_block usb_nb;
+};
+
+static void pcat_usb_watchdog_gpio_work(struct work_struct *work)
+{
+	struct pcat_usb_watchdog_data *data = container_of(work,
+							   struct
+							   pcat_usb_watchdog_data,
+							   gpio_work);
+
+	gpiod_set_value(data->reset_gpio, 0);
+	msleep(data->reset_ms);
+	gpiod_set_value(data->reset_gpio, 1);
+}
+
+static int pcat_usb_watchdog_usb_notify(struct notifier_block *self,
+					unsigned long action, void *dev)
+{
+	struct pcat_usb_watchdog_data *data = container_of(self,
+							   struct pcat_usb_watchdog_data,
+							   usb_nb);
+	struct usb_device *udev = (struct usb_device *)dev;
+
+	if (!udev)
+		return NOTIFY_OK;
+
+	if (le16_to_cpu(udev->descriptor.idVendor) == data->target_vid &&
+	    le16_to_cpu(udev->descriptor.idProduct) == data->target_pid) {
+
+		switch (action) {
+		case USB_DEVICE_ADD:
+			data->target_live = true;
+			dev_info(data->dev, "Target device added.\n");
+			break;
+		case USB_DEVICE_REMOVE:
+			data->target_live = false;
+			dev_info(data->dev, "Target device removed!\n");
+			break;
+		}
+	}
+
+	return NOTIFY_OK;
+}
+
+static int pcat_usb_watchdog_ping(struct watchdog_device *wdd)
+{
+	/* Monitoring is handled by internal timer, this is just for userspace pings */
+	return 0;
+}
+
+static void pcat_usb_watchdog_monitor_callback(struct timer_list *timer)
+{
+	struct pcat_usb_watchdog_data *data = container_of(timer,
+							   struct pcat_usb_watchdog_data,
+							   monitor_timer);
+
+	if (!data->target_live) {
+		dev_warn(data->dev, "Target device is not live, triggering reset!\n");
+		schedule_work(&data->gpio_work);
+	}
+
+	mod_timer(&data->monitor_timer,
+		  jiffies + msecs_to_jiffies(data->scan_interval_ms));
+}
+
+static int pcat_usb_watchdog_start(struct watchdog_device *wdd)
+{
+	struct pcat_usb_watchdog_data *data = watchdog_get_drvdata(wdd);
+
+	dev_info(data->dev, "Watchdog started (timeout=%u sec)\n", wdd->timeout);
+
+	return 0;
+}
+
+static int pcat_usb_watchdog_stop(struct watchdog_device *wdd)
+{
+	struct pcat_usb_watchdog_data *data = watchdog_get_drvdata(wdd);
+
+	dev_info(data->dev, "Watchdog stopped\n");
+
+	return 0;
+}
+
+static const struct watchdog_info pcat_usb_watchdog_info = {
+	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
+	.identity = "Photonicat USB Watchdog",
+};
+
+static const struct watchdog_ops pcat_usb_watchdog_ops = {
+	.owner = THIS_MODULE,
+	.start = pcat_usb_watchdog_start,
+	.stop = pcat_usb_watchdog_stop,
+	.ping = pcat_usb_watchdog_ping,
+};
+
+static const struct of_device_id pcat_usb_watchdog_of_match[] = {
+	{.compatible = "pcat-usb-watchdog" },
+	{ /* sentinel */  }
+};
+
+MODULE_DEVICE_TABLE(of, pcat_usb_watchdog_of_match);
+
+static int pcat_usb_watchdog_probe(struct platform_device *pdev)
+{
+	struct pcat_usb_watchdog_data *wdt_data;
+	struct device *dev = &pdev->dev;
+	struct watchdog_device *wdd;
+	u32 vid, pid, timeout_sec;
+	int ret;
+
+	wdt_data = devm_kzalloc(dev, sizeof(*wdt_data), GFP_KERNEL);
+	if (!wdt_data)
+		return -ENOMEM;
+
+	wdt_data->dev = dev;
+	platform_set_drvdata(pdev, wdt_data);
+
+	if (of_property_read_u32(dev->of_node, "target-vid", &vid)) {
+		dev_err(dev, "No valid USB target-vid configured!\n");
+		return -EINVAL;
+	}
+	wdt_data->target_vid = vid;
+
+	if (of_property_read_u32(dev->of_node, "target-pid", &pid)) {
+		dev_err(dev, "No valid USB target-pid configured!\n");
+		return -EINVAL;
+	}
+	wdt_data->target_pid = pid;
+
+	if (of_property_read_u32(dev->of_node, "reset-ms", &wdt_data->reset_ms)) {
+		wdt_data->reset_ms = PCAT_USB_WATCHDOG_RESET_MS_DEFAULT;
+	}
+
+	if (wdt_data->reset_ms < 1 || wdt_data->reset_ms > 10000) {
+		dev_warn(dev, "reset-ms out of range, using default\n");
+		wdt_data->reset_ms = PCAT_USB_WATCHDOG_RESET_MS_DEFAULT;
+	}
+
+	wdt_data->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(wdt_data->reset_gpio)) {
+		ret = PTR_ERR(wdt_data->reset_gpio);
+		dev_err(dev, "Failed to get reset GPIO: %d\n", ret);
+		return ret;
+	}
+
+	INIT_WORK(&wdt_data->gpio_work, pcat_usb_watchdog_gpio_work);
+
+	/* Read scan interval from DT */
+	if (of_property_read_u32(dev->of_node, "scan-interval", &timeout_sec)) {
+		timeout_sec = PCAT_USB_WATCHDOG_TIMEOUT_DEFAULT * 1000;
+	}
+
+	/* Convert to milliseconds if in seconds */
+	if (timeout_sec < 1000) {
+		timeout_sec = timeout_sec * 1000;
+	}
+
+	if (timeout_sec < 1000 || timeout_sec > PCAT_USB_WATCHDOG_TIMEOUT_MAX * 1000) {
+		dev_warn(dev, "scan-interval out of range, using default\n");
+		timeout_sec = PCAT_USB_WATCHDOG_TIMEOUT_DEFAULT * 1000;
+	}
+
+	wdt_data->scan_interval_ms = timeout_sec;
+
+	/* Setup watchdog device */
+	wdd = &wdt_data->wdd;
+	wdd->info = &pcat_usb_watchdog_info;
+	wdd->ops = &pcat_usb_watchdog_ops;
+	wdd->min_timeout = PCAT_USB_WATCHDOG_TIMEOUT_MIN;
+	wdd->max_timeout = PCAT_USB_WATCHDOG_TIMEOUT_MAX;
+	wdd->timeout = timeout_sec / 1000;
+	wdd->parent = dev;
+	watchdog_set_drvdata(wdd, wdt_data);
+	watchdog_set_nowayout(wdd, nowayout);
+	watchdog_stop_on_reboot(wdd);
+
+	/* Register USB notifier */
+	wdt_data->usb_nb.notifier_call = pcat_usb_watchdog_usb_notify;
+	usb_register_notify(&wdt_data->usb_nb);
+
+	/* Setup and start monitor timer */
+	timer_setup(&wdt_data->monitor_timer, pcat_usb_watchdog_monitor_callback, 0);
+	mod_timer(&wdt_data->monitor_timer, jiffies + msecs_to_jiffies(30000)); /* 30s grace */
+
+	/* Register watchdog device */
+	ret = devm_watchdog_register_device(dev, wdd);
+	if (ret) {
+		dev_err(dev, "Failed to register watchdog device: %d\n", ret);
+		timer_delete_sync(&wdt_data->monitor_timer);
+		usb_unregister_notify(&wdt_data->usb_nb);
+		return ret;
+	}
+
+	dev_info(dev, "Photonicat USB watchdog initialized (VID:0x%04x PID:0x%04x, scan=%ums)\n",
+		 wdt_data->target_vid, wdt_data->target_pid, wdt_data->scan_interval_ms);
+
+	return 0;
+}
+
+static void pcat_usb_watchdog_remove(struct platform_device *pdev)
+{
+	struct pcat_usb_watchdog_data *wdt_data = platform_get_drvdata(pdev);
+
+	/* Unregister USB notifier */
+	usb_unregister_notify(&wdt_data->usb_nb);
+
+	/* Stop monitor timer */
+	timer_delete_sync(&wdt_data->monitor_timer);
+
+	/* Cancel any pending work */
+	cancel_work_sync(&wdt_data->gpio_work);
+
+	/* Watchdog device is automatically unregistered by devm */
+	dev_info(wdt_data->dev, "Photonicat USB watchdog removed\n");
+}
+
+static struct platform_driver pcat_usb_watchdog_driver = {
+	.probe = pcat_usb_watchdog_probe,
+	.remove = pcat_usb_watchdog_remove,
+	.driver = {
+		   .name = "pcat-usb-watchdog",
+		   .of_match_table = pcat_usb_watchdog_of_match,
+		    },
+};
+
+static int __init pcat_usb_watchdog_init(void)
+{
+	printk(KERN_INFO "usb_watchdog: Loading USB watchdog driver\n");
+	return platform_driver_register(&pcat_usb_watchdog_driver);
+}
+
+static void __exit pcat_usb_watchdog_exit(void)
+{
+	platform_driver_unregister(&pcat_usb_watchdog_driver);
+}
+
+module_init(pcat_usb_watchdog_init);
+module_exit(pcat_usb_watchdog_exit);
+
+MODULE_AUTHOR("Kyosuke Nekoyashiki <supercatexpert@gmail.com>");
+MODULE_AUTHOR("HackingGate <i@hackinggate.com>");
+MODULE_DESCRIPTION("photonicat USB device watchdog");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0");
-- 
2.47.3

