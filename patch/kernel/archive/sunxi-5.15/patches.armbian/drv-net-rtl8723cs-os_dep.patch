From 66df5df0e146d3762f504faedd1e09f162e7cce3 Mon Sep 17 00:00:00 2001
From: The-going <48602507+The-going@users.noreply.github.com>
Date: Tue, 8 Feb 2022 19:16:46 +0300
Subject: [PATCH] drv:net:rtl8723cs: os_dep

---
 .../os_dep/linux/custom_gpio_linux.c          |   356 +
 .../rtl8723cs/os_dep/linux/ioctl_cfg80211.c   |  6940 ++++++++
 .../rtl8723cs/os_dep/linux/ioctl_cfg80211.h   |   212 +
 .../rtl8723cs/os_dep/linux/ioctl_linux.c      | 13919 ++++++++++++++++
 .../realtek/rtl8723cs/os_dep/linux/ioctl_mp.c |  2147 +++
 .../rtl8723cs/os_dep/linux/mlme_linux.c       |   582 +
 .../realtek/rtl8723cs/os_dep/linux/os_intfs.c |  4471 +++++
 .../rtl8723cs/os_dep/linux/recv_linux.c       |   807 +
 .../rtl8723cs/os_dep/linux/rtw_android.c      |  1293 ++
 .../rtl8723cs/os_dep/linux/rtw_cfgvendor.c    |  1385 ++
 .../rtl8723cs/os_dep/linux/rtw_cfgvendor.h    |   246 +
 .../realtek/rtl8723cs/os_dep/linux/rtw_proc.c |  2072 +++
 .../realtek/rtl8723cs/os_dep/linux/rtw_proc.h |    52 +
 .../rtl8723cs/os_dep/linux/sdio_intf.c        |  1048 ++
 .../rtl8723cs/os_dep/linux/sdio_ops_linux.c   |   910 +
 .../rtl8723cs/os_dep/linux/wifi_regd.c        |   529 +
 .../rtl8723cs/os_dep/linux/xmit_linux.c       |   546 +
 .../realtek/rtl8723cs/os_dep/osdep_service.c  |  2491 +++
 18 files changed, 40006 insertions(+)
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/custom_gpio_linux.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_cfg80211.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_cfg80211.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_linux.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_mp.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/mlme_linux.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/os_intfs.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/recv_linux.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_android.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_cfgvendor.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_cfgvendor.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_proc.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_proc.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/sdio_intf.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/sdio_ops_linux.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/wifi_regd.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/xmit_linux.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/os_dep/osdep_service.c

diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/custom_gpio_linux.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/custom_gpio_linux.c
new file mode 100644
index 000000000..418d7932e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/custom_gpio_linux.c
@@ -0,0 +1,356 @@
+/******************************************************************************
+ * Customer code to add GPIO control during WLAN start/stop
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#include "drv_types.h"
+
+#ifdef CONFIG_PLATFORM_SPRD
+
+//gspi func & GPIO define
+#include <mach/gpio.h>//0915
+#include <mach/board.h>
+
+#if !(defined ANDROID_2X)
+
+#ifdef CONFIG_RTL8188E
+#include <mach/regulator.h>
+#include <linux/regulator/consumer.h>
+#endif // CONFIG_RTL8188E
+
+#ifndef GPIO_WIFI_POWER
+#define GPIO_WIFI_POWER -1
+#endif // !GPIO_WIFI_POWER
+
+#ifndef GPIO_WIFI_RESET
+#define GPIO_WIFI_RESET -1
+#endif // !GPIO_WIFI_RESET
+
+#ifndef GPIO_WIFI_PWDN
+#define GPIO_WIFI_PWDN -1
+#endif // !GPIO_WIFI_RESET
+#ifdef CONFIG_GSPI_HCI
+extern unsigned int oob_irq;
+#endif // CONFIG_GSPI_HCI
+
+#ifdef CONFIG_SDIO_HCI
+extern int rtw_mp_mode;
+#else // !CONFIG_SDIO_HCI
+#endif // !CONFIG_SDIO_HCI
+
+int rtw_wifi_gpio_init(void)
+{
+#ifdef CONFIG_GSPI_HCI
+	if (GPIO_WIFI_IRQ > 0) {
+		gpio_request(GPIO_WIFI_IRQ, "oob_irq");
+		gpio_direction_input(GPIO_WIFI_IRQ);
+
+		oob_irq = gpio_to_irq(GPIO_WIFI_IRQ);
+
+		DBG_8192C("%s oob_irq:%d\n", __func__, oob_irq);
+	}
+#endif
+	if (GPIO_WIFI_RESET > 0)
+		gpio_request(GPIO_WIFI_RESET , "wifi_rst");
+	if (GPIO_WIFI_POWER > 0)
+		gpio_request(GPIO_WIFI_POWER, "wifi_power");
+
+#ifdef CONFIG_SDIO_HCI
+#if (defined(CONFIG_RTL8723B)) && (MP_DRIVER == 1) 
+	if(rtw_mp_mode==1){
+		DBG_871X("%s GPIO_BT_RESET pin special for mp_test\n", __func__);	
+		if (GPIO_BT_RESET > 0)
+			gpio_request(GPIO_BT_RESET , "bt_rst");
+	}
+#endif
+#endif
+	return 0;
+}
+
+int rtw_wifi_gpio_deinit(void)
+{
+#ifdef CONFIG_GSPI_HCI
+	if (GPIO_WIFI_IRQ > 0)
+		gpio_free(GPIO_WIFI_IRQ);
+#endif
+	if (GPIO_WIFI_RESET > 0)
+		gpio_free(GPIO_WIFI_RESET );
+	if (GPIO_WIFI_POWER > 0)
+		gpio_free(GPIO_WIFI_POWER);
+
+#ifdef CONFIG_SDIO_HCI
+#if ( defined(CONFIG_RTL8723B)) && (MP_DRIVER == 1) 
+	if(rtw_mp_mode==1){
+		DBG_871X("%s GPIO_BT_RESET pin special for mp_test\n", __func__);
+		if (GPIO_BT_RESET > 0)
+			gpio_free(GPIO_BT_RESET);
+	}
+#endif
+#endif
+	return 0;
+}
+
+/* Customer function to control hw specific wlan gpios */
+void rtw_wifi_gpio_wlan_ctrl(int onoff)
+{
+	switch (onoff)
+	{
+		case WLAN_PWDN_OFF:
+			DBG_8192C("%s: call customer specific GPIO(%d) to set wifi power down pin to 0\n",
+				__FUNCTION__, GPIO_WIFI_RESET);
+
+#ifndef CONFIG_DONT_BUS_SCAN
+			if (GPIO_WIFI_RESET > 0)
+				gpio_direction_output(GPIO_WIFI_RESET , 0);
+#endif
+		break;
+
+		case WLAN_PWDN_ON:
+			DBG_8192C("%s: callc customer specific GPIO(%d) to set wifi power down pin to 1\n",
+				__FUNCTION__, GPIO_WIFI_RESET);
+
+			if (GPIO_WIFI_RESET > 0)
+				gpio_direction_output(GPIO_WIFI_RESET , 1);
+		break;
+
+		case WLAN_POWER_OFF:
+		break;
+
+		case WLAN_POWER_ON:
+		break;
+#ifdef CONFIG_SDIO_HCI
+#if ( defined(CONFIG_RTL8723B)) && (MP_DRIVER == 1) 
+		case WLAN_BT_PWDN_OFF:
+		if(rtw_mp_mode==1)
+		{
+			DBG_871X("%s: call customer specific GPIO to set wifi power down pin to 0\n",
+				       	__FUNCTION__);
+			if (GPIO_BT_RESET > 0)
+				gpio_direction_output(GPIO_BT_RESET , 0);
+		}
+		break;
+
+		case WLAN_BT_PWDN_ON:
+		if(rtw_mp_mode==1)
+		{
+			DBG_871X("%s: callc customer specific GPIO to set wifi power down pin to 1 %x\n",
+					__FUNCTION__, GPIO_BT_RESET);
+
+			if (GPIO_BT_RESET > 0)
+				gpio_direction_output(GPIO_BT_RESET , 1);
+		}
+		break;
+#endif
+#endif
+	}
+}
+
+#else //ANDROID_2X
+
+#include <mach/ldo.h>
+
+#ifdef CONFIG_RTL8188E
+extern int sprd_3rdparty_gpio_wifi_power;
+#endif
+extern int sprd_3rdparty_gpio_wifi_pwd;
+#if  defined(CONFIG_RTL8723B)
+extern int sprd_3rdparty_gpio_bt_reset;
+#endif
+
+int rtw_wifi_gpio_init(void)
+{
+#if defined(CONFIG_RTL8723B)
+	if (sprd_3rdparty_gpio_bt_reset > 0)
+		gpio_direction_output(sprd_3rdparty_gpio_bt_reset, 1);
+#endif
+
+	return 0;
+}
+
+int rtw_wifi_gpio_deinit(void)
+{
+	return 0;
+}
+
+/* Customer function to control hw specific wlan gpios */
+void rtw_wifi_gpio_wlan_ctrl(int onoff)
+{
+	switch (onoff)
+	{
+		case WLAN_PWDN_OFF:
+			DBG_8192C("%s: call customer specific GPIO to set wifi power down pin to 0\n",
+				__FUNCTION__);
+			if (sprd_3rdparty_gpio_wifi_pwd > 0)
+			{
+				gpio_set_value(sprd_3rdparty_gpio_wifi_pwd, 0);
+			}
+
+			if (sprd_3rdparty_gpio_wifi_pwd == 60) {
+				DBG_8192C("%s: turn off VSIM2 2.8V\n", __func__);
+				LDO_TurnOffLDO(LDO_LDO_SIM2);
+			}
+		break;
+
+		case WLAN_PWDN_ON:
+			DBG_8192C("%s: callc customer specific GPIO to set wifi power down pin to 1\n",
+				__FUNCTION__);
+			if (sprd_3rdparty_gpio_wifi_pwd == 60) {
+				DBG_8192C("%s: turn on VSIM2 2.8V\n", __func__);
+				LDO_SetVoltLevel(LDO_LDO_SIM2, LDO_VOLT_LEVEL0);
+				LDO_TurnOnLDO(LDO_LDO_SIM2);
+			}
+			if (sprd_3rdparty_gpio_wifi_pwd > 0)
+			{
+				gpio_set_value(sprd_3rdparty_gpio_wifi_pwd, 1);
+			}
+		break;
+
+		case WLAN_POWER_OFF:
+#ifdef CONFIG_RTL8188E
+#ifdef CONFIG_WIF1_LDO
+			DBG_8192C("%s: turn off VDD-WIFI0 1.2V\n", __FUNCTION__);
+			LDO_TurnOffLDO(LDO_LDO_WIF1);
+#endif //CONFIG_WIF1_LDO
+
+			DBG_8192C("%s: turn off VDD-WIFI0 3.3V\n", __FUNCTION__);
+			LDO_TurnOffLDO(LDO_LDO_WIF0);
+
+			DBG_8192C("%s: call customer specific GPIO(%d) to turn off wifi power\n",
+				__FUNCTION__, sprd_3rdparty_gpio_wifi_power);
+			if (sprd_3rdparty_gpio_wifi_power != 65535)
+				gpio_set_value(sprd_3rdparty_gpio_wifi_power, 0);
+#endif
+		break;
+
+		case WLAN_POWER_ON:
+#ifdef CONFIG_RTL8188E
+			DBG_8192C("%s: call customer specific GPIO(%d) to turn on wifi power\n",
+				__FUNCTION__, sprd_3rdparty_gpio_wifi_power);
+			if (sprd_3rdparty_gpio_wifi_power != 65535)
+				gpio_set_value(sprd_3rdparty_gpio_wifi_power, 1);
+
+			DBG_8192C("%s: turn on VDD-WIFI0 3.3V\n", __FUNCTION__);
+			LDO_TurnOnLDO(LDO_LDO_WIF0);
+			LDO_SetVoltLevel(LDO_LDO_WIF0,LDO_VOLT_LEVEL1);
+
+#ifdef CONFIG_WIF1_LDO
+			DBG_8192C("%s: turn on VDD-WIFI1 1.2V\n", __func__);
+			LDO_TurnOnLDO(LDO_LDO_WIF1);
+			LDO_SetVoltLevel(LDO_LDO_WIF1,LDO_VOLT_LEVEL3);
+#endif //CONFIG_WIF1_LDO
+#endif
+		break;
+
+		case WLAN_BT_PWDN_OFF:
+			DBG_8192C("%s: call customer specific GPIO to set bt power down pin to 0\n",
+				__FUNCTION__);
+#if defined(CONFIG_RTL8723B)
+			if (sprd_3rdparty_gpio_bt_reset > 0)
+				gpio_set_value(sprd_3rdparty_gpio_bt_reset, 0);
+#endif
+		break;
+
+		case WLAN_BT_PWDN_ON:
+			DBG_8192C("%s: callc customer specific GPIO to set bt power down pin to 1\n",
+				__FUNCTION__);
+#if defined(CONFIG_RTL8723B)
+			if (sprd_3rdparty_gpio_bt_reset > 0)
+				gpio_set_value(sprd_3rdparty_gpio_bt_reset, 1);
+#endif
+		break;
+	}
+}
+#endif //ANDROID_2X
+
+#elif defined(CONFIG_PLATFORM_ARM_RK3066) 
+#include <mach/iomux.h>
+
+#define GPIO_WIFI_IRQ		RK30_PIN2_PC2
+extern unsigned int oob_irq;
+int rtw_wifi_gpio_init(void)
+{
+#ifdef CONFIG_GSPI_HCI
+	if (GPIO_WIFI_IRQ > 0) {
+		rk30_mux_api_set(GPIO2C2_LCDC1DATA18_SMCBLSN1_HSADCDATA5_NAME, GPIO2C_GPIO2C2);//jacky_test
+		gpio_request(GPIO_WIFI_IRQ, "oob_irq");
+		gpio_direction_input(GPIO_WIFI_IRQ);
+
+		oob_irq = gpio_to_irq(GPIO_WIFI_IRQ);
+
+		DBG_8192C("%s oob_irq:%d\n", __func__, oob_irq);
+	}
+#endif
+	return 0;
+}
+
+
+int rtw_wifi_gpio_deinit(void)
+{
+#ifdef CONFIG_GSPI_HCI
+	if (GPIO_WIFI_IRQ > 0)
+		gpio_free(GPIO_WIFI_IRQ);
+#endif
+	return 0;
+}
+
+void rtw_wifi_gpio_wlan_ctrl(int onoff)
+{
+}
+
+#ifdef CONFIG_GPIO_API
+//this is a demo for extending GPIO pin[7] as interrupt mode
+struct net_device * rtl_net;
+extern int rtw_register_gpio_interrupt(struct net_device *netdev, int gpio_num, void(*callback)(u8 level));
+extern int rtw_disable_gpio_interrupt(struct net_device *netdev, int gpio_num);
+void gpio_int(u8 is_high)
+{
+	DBG_8192C("%s level=%d\n",__func__, is_high);
+}
+int register_net_gpio_init(void)
+{
+	rtl_net = dev_get_by_name(&init_net,"wlan0");
+	if(!rtl_net)
+	{
+		DBG_871X_LEVEL(_drv_always_, "rtl_net init fail!\n");
+		return -1;
+	}
+	return rtw_register_gpio_interrupt(rtl_net,7, gpio_int);
+}
+int unregister_net_gpio_init(void)
+{
+	rtl_net = dev_get_by_name(&init_net,"wlan0");
+	if(!rtl_net)
+	{
+		DBG_871X_LEVEL(_drv_always_, "rtl_net init fail!\n");
+		return -1;
+	}
+	return rtw_disable_gpio_interrupt(rtl_net,7);
+}
+#endif
+
+#else
+
+int rtw_wifi_gpio_init(void)
+{
+	return 0;
+}
+
+void rtw_wifi_gpio_wlan_ctrl(int onoff)
+{
+}
+#endif //CONFIG_PLATFORM_SPRD
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_cfg80211.c
new file mode 100644
index 000000000..3607d755b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_cfg80211.c
@@ -0,0 +1,6940 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define  _IOCTL_CFG80211_C_
+
+#include <drv_types.h>
+
+#ifdef CONFIG_IOCTL_CFG80211
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0))
+#define STATION_INFO_SIGNAL		BIT(NL80211_STA_INFO_SIGNAL)
+#define STATION_INFO_TX_BITRATE		BIT(NL80211_STA_INFO_TX_BITRATE)
+#define STATION_INFO_RX_PACKETS		BIT(NL80211_STA_INFO_RX_PACKETS)
+#define STATION_INFO_TX_PACKETS		BIT(NL80211_STA_INFO_TX_PACKETS)
+#define STATION_INFO_ASSOC_REQ_IES	0
+#endif /* Linux kernel >= 4.0.0 */
+
+#include <rtw_wifi_regd.h>
+
+#define RTW_MAX_MGMT_TX_CNT (8)
+#define RTW_MAX_MGMT_TX_MS_GAS (500)
+
+#define RTW_SCAN_IE_LEN_MAX      2304
+#define RTW_MAX_REMAIN_ON_CHANNEL_DURATION 5000 //ms
+#define RTW_MAX_NUM_PMKIDS 4
+
+#define RTW_CH_MAX_2G_CHANNEL               14      /* Max channel in 2G band */
+
+#ifdef CONFIG_WAPI_SUPPORT
+
+#ifndef WLAN_CIPHER_SUITE_SMS4
+#define WLAN_CIPHER_SUITE_SMS4          0x00147201
+#endif
+
+#ifndef WLAN_AKM_SUITE_WAPI_PSK
+#define WLAN_AKM_SUITE_WAPI_PSK         0x000FAC04
+#endif
+
+#ifndef WLAN_AKM_SUITE_WAPI_CERT
+#define WLAN_AKM_SUITE_WAPI_CERT        0x000FAC12
+#endif
+
+#ifndef NL80211_WAPI_VERSION_1
+#define NL80211_WAPI_VERSION_1          (1 << 2)
+#endif
+
+#endif
+
+#ifdef CONFIG_PLATFORM_ARM_SUN8I
+#define BUSY_TRAFFIC_SCAN_DENY_PERIOD	8000
+#else
+#define BUSY_TRAFFIC_SCAN_DENY_PERIOD	12000
+#endif
+
+static const u32 rtw_cipher_suites[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_CCMP,
+#ifdef CONFIG_WAPI_SUPPORT
+	WLAN_CIPHER_SUITE_SMS4,
+#endif // CONFIG_WAPI_SUPPORT
+#ifdef CONFIG_IEEE80211W
+	WLAN_CIPHER_SUITE_AES_CMAC,
+#endif //CONFIG_IEEE80211W
+};
+
+#define RATETAB_ENT(_rate, _rateid, _flags) \
+	{								\
+		.bitrate	= (_rate),				\
+		.hw_value	= (_rateid),				\
+		.flags		= (_flags),				\
+	}
+
+#define CHAN2G(_channel, _freq, _flags) {			\
+	.band			= NL80211_BAND_2GHZ,		\
+	.center_freq		= (_freq),			\
+	.hw_value		= (_channel),			\
+	.flags			= (_flags),			\
+	.max_antenna_gain	= 0,				\
+	.max_power		= 30,				\
+}
+
+#define CHAN5G(_channel, _flags) {				\
+	.band			= NL80211_BAND_5GHZ,		\
+	.center_freq		= 5000 + (5 * (_channel)),	\
+	.hw_value		= (_channel),			\
+	.flags			= (_flags),			\
+	.max_antenna_gain	= 0,				\
+	.max_power		= 30,				\
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+/* if wowlan is not supported, kernel generate a disconnect at each suspend
+ * cf: /net/wireless/sysfs.c, so register a stub wowlan.
+ * Moreover wowlan has to be enabled via a the nl80211_set_wowlan callback.
+ * (from user space, e.g. iw phy0 wowlan enable)
+ */
+static const struct wiphy_wowlan_support wowlan_stub = {
+	.flags = WIPHY_WOWLAN_ANY,
+	.n_patterns = 0,
+	.pattern_max_len = 0,
+	.pattern_min_len = 0,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
+	.max_pkt_offset = 0,
+#endif
+};
+#endif
+
+static struct ieee80211_rate rtw_rates[] = {
+	RATETAB_ENT(10,  0x1,   0),
+	RATETAB_ENT(20,  0x2,   0),
+	RATETAB_ENT(55,  0x4,   0),
+	RATETAB_ENT(110, 0x8,   0),
+	RATETAB_ENT(60,  0x10,  0),
+	RATETAB_ENT(90,  0x20,  0),
+	RATETAB_ENT(120, 0x40,  0),
+	RATETAB_ENT(180, 0x80,  0),
+	RATETAB_ENT(240, 0x100, 0),
+	RATETAB_ENT(360, 0x200, 0),
+	RATETAB_ENT(480, 0x400, 0),
+	RATETAB_ENT(540, 0x800, 0),
+};
+
+#define rtw_a_rates		(rtw_rates + 4)
+#define RTW_A_RATES_NUM	8
+#define rtw_g_rates		(rtw_rates + 0)
+#define RTW_G_RATES_NUM	12
+
+#define RTW_2G_CHANNELS_NUM 14
+#define RTW_5G_CHANNELS_NUM 37
+
+static struct ieee80211_channel rtw_2ghz_channels[] = {
+	CHAN2G(1, 2412, 0),
+	CHAN2G(2, 2417, 0),
+	CHAN2G(3, 2422, 0),
+	CHAN2G(4, 2427, 0),
+	CHAN2G(5, 2432, 0),
+	CHAN2G(6, 2437, 0),
+	CHAN2G(7, 2442, 0),
+	CHAN2G(8, 2447, 0),
+	CHAN2G(9, 2452, 0),
+	CHAN2G(10, 2457, 0),
+	CHAN2G(11, 2462, 0),
+	CHAN2G(12, 2467, 0),
+	CHAN2G(13, 2472, 0),
+	CHAN2G(14, 2484, 0),
+};
+
+static struct ieee80211_channel rtw_5ghz_a_channels[] = {
+	CHAN5G(34, 0),		CHAN5G(36, 0),
+	CHAN5G(38, 0),		CHAN5G(40, 0),
+	CHAN5G(42, 0),		CHAN5G(44, 0),
+	CHAN5G(46, 0),		CHAN5G(48, 0),
+	CHAN5G(52, 0),		CHAN5G(56, 0),
+	CHAN5G(60, 0),		CHAN5G(64, 0),
+	CHAN5G(100, 0),		CHAN5G(104, 0),
+	CHAN5G(108, 0),		CHAN5G(112, 0),
+	CHAN5G(116, 0),		CHAN5G(120, 0),
+	CHAN5G(124, 0),		CHAN5G(128, 0),
+	CHAN5G(132, 0),		CHAN5G(136, 0),
+	CHAN5G(140, 0),		CHAN5G(149, 0),
+	CHAN5G(153, 0),		CHAN5G(157, 0),
+	CHAN5G(161, 0),		CHAN5G(165, 0),
+	CHAN5G(184, 0),		CHAN5G(188, 0),
+	CHAN5G(192, 0),		CHAN5G(196, 0),
+	CHAN5G(200, 0),		CHAN5G(204, 0),
+	CHAN5G(208, 0),		CHAN5G(212, 0),
+	CHAN5G(216, 0),
+};
+
+
+void rtw_2g_channels_init(struct ieee80211_channel *channels)
+{
+	_rtw_memcpy((void*)channels, (void*)rtw_2ghz_channels,
+		sizeof(struct ieee80211_channel)*RTW_2G_CHANNELS_NUM
+	);
+}
+
+void rtw_5g_channels_init(struct ieee80211_channel *channels)
+{
+	_rtw_memcpy((void*)channels, (void*)rtw_5ghz_a_channels,
+		sizeof(struct ieee80211_channel)*RTW_5G_CHANNELS_NUM
+	);
+}
+
+void rtw_2g_rates_init(struct ieee80211_rate *rates)
+{
+	_rtw_memcpy(rates, rtw_g_rates,
+		sizeof(struct ieee80211_rate)*RTW_G_RATES_NUM
+	);
+}
+
+void rtw_5g_rates_init(struct ieee80211_rate *rates)
+{
+	_rtw_memcpy(rates, rtw_a_rates,
+		sizeof(struct ieee80211_rate)*RTW_A_RATES_NUM
+	);
+}
+
+struct ieee80211_supported_band *rtw_spt_band_alloc(
+	int band
+	)
+{
+	struct ieee80211_supported_band *spt_band = NULL;
+	int n_channels, n_bitrates;
+
+	if(band == NL80211_BAND_2GHZ)
+	{
+		n_channels = RTW_2G_CHANNELS_NUM;
+		n_bitrates = RTW_G_RATES_NUM;
+	}
+	else if(band == NL80211_BAND_5GHZ)
+	{
+		n_channels = RTW_5G_CHANNELS_NUM;
+		n_bitrates = RTW_A_RATES_NUM;
+	}
+	else
+	{
+		goto exit;
+	}
+
+	spt_band = (struct ieee80211_supported_band *)rtw_zmalloc(
+		sizeof(struct ieee80211_supported_band)
+		+ sizeof(struct ieee80211_channel)*n_channels
+		+ sizeof(struct ieee80211_rate)*n_bitrates
+	);
+	if(!spt_band)
+		goto exit;
+
+	spt_band->channels = (struct ieee80211_channel*)(((u8*)spt_band)+sizeof(struct ieee80211_supported_band));
+	spt_band->bitrates= (struct ieee80211_rate*)(((u8*)spt_band->channels)+sizeof(struct ieee80211_channel)*n_channels);
+	spt_band->band = band;
+	spt_band->n_channels = n_channels;
+	spt_band->n_bitrates = n_bitrates;
+
+	if(band == NL80211_BAND_2GHZ)
+	{
+		rtw_2g_channels_init(spt_band->channels);
+		rtw_2g_rates_init(spt_band->bitrates);
+	}
+	else if(band == NL80211_BAND_5GHZ)
+	{
+		rtw_5g_channels_init(spt_band->channels);
+		rtw_5g_rates_init(spt_band->bitrates);
+	}
+
+	//spt_band.ht_cap
+	
+exit:
+
+	return spt_band;
+}
+
+void rtw_spt_band_free(struct ieee80211_supported_band *spt_band)
+{
+	u32 size = 0;
+
+	if(!spt_band)
+		return;
+	
+	if(spt_band->band == NL80211_BAND_2GHZ)
+	{
+		size = sizeof(struct ieee80211_supported_band)
+			+ sizeof(struct ieee80211_channel)*RTW_2G_CHANNELS_NUM
+			+ sizeof(struct ieee80211_rate)*RTW_G_RATES_NUM;
+	}
+	else if(spt_band->band == NL80211_BAND_5GHZ)
+	{
+		size = sizeof(struct ieee80211_supported_band)
+			+ sizeof(struct ieee80211_channel)*RTW_5G_CHANNELS_NUM
+			+ sizeof(struct ieee80211_rate)*RTW_A_RATES_NUM;		
+	}
+	else
+	{
+		
+	}
+	rtw_mfree((u8*)spt_band, size);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+static const struct ieee80211_txrx_stypes
+rtw_cfg80211_default_mgmt_stypes[NUM_NL80211_IFTYPES] = {
+	[NL80211_IFTYPE_ADHOC] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+	[NL80211_IFTYPE_STATION] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	},
+	[NL80211_IFTYPE_AP] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+		BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+		BIT(IEEE80211_STYPE_AUTH >> 4) |
+		BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+		BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+	[NL80211_IFTYPE_AP_VLAN] = {
+		/* copy AP */
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+		BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+		BIT(IEEE80211_STYPE_AUTH >> 4) |
+		BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+		BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+	[NL80211_IFTYPE_P2P_CLIENT] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	},
+	[NL80211_IFTYPE_P2P_GO] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+		BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+		BIT(IEEE80211_STYPE_AUTH >> 4) |
+		BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+		BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+};
+#endif
+
+static u64 rtw_get_systime_us(void)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39) && LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0))
+	struct timespec ts;
+	get_monotonic_boottime(&ts);
+	return ((u64)ts.tv_sec*1000000) + ts.tv_nsec / 1000;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0))
+	return ktime_to_us(ktime_get_boottime());
+#else
+	struct timeval tv;
+	do_gettimeofday(&tv);
+	return ((u64)tv.tv_sec*1000000) + tv.tv_usec;
+#endif
+}
+
+#define MAX_BSSINFO_LEN 1000
+struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnetwork)
+{
+	struct ieee80211_channel *notify_channel;
+	struct cfg80211_bss *bss = NULL;
+	//struct ieee80211_supported_band *band;       
+	u16 channel;
+	u32 freq;
+	u64 notify_timestamp;
+	u16 notify_capability;
+	u16 notify_interval;
+	u8 *notify_ie;
+	size_t notify_ielen;
+	s32 notify_signal;
+	//u8 buf[MAX_BSSINFO_LEN];
+
+	u8 *pbuf;
+	size_t buf_size = MAX_BSSINFO_LEN;
+	size_t len,bssinf_len=0;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	unsigned short *fctrl;
+	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+		
+	struct wireless_dev *wdev = padapter->rtw_wdev;
+	struct wiphy *wiphy = wdev->wiphy;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	pbuf = rtw_zmalloc(buf_size);
+	if(pbuf == NULL){
+		DBG_871X("%s pbuf allocate failed  !! \n",__FUNCTION__);
+		return bss;
+	}
+		
+	//DBG_8192C("%s\n", __func__);
+
+	bssinf_len = pnetwork->network.IELength+sizeof (struct rtw_ieee80211_hdr_3addr);
+	if(bssinf_len > buf_size){
+		DBG_871X("%s IE Length too long > %zu byte \n",__FUNCTION__,buf_size);
+		goto exit;
+	}
+
+#ifndef CONFIG_WAPI_SUPPORT
+	{
+		u16 wapi_len = 0;
+	
+		if(rtw_get_wapi_ie(pnetwork->network.IEs, pnetwork->network.IELength, NULL, &wapi_len)>0)
+		{
+			if(wapi_len > 0)
+			{
+				DBG_871X("%s, no support wapi!\n",__FUNCTION__);
+				goto exit;
+			}	
+		}		
+	}	
+#endif //!CONFIG_WAPI_SUPPORT
+
+	//To reduce PBC Overlap rate
+	//_enter_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	if(adapter_wdev_data(padapter)->scan_request != NULL)
+	{
+		u8 *psr=NULL, sr = 0;
+		NDIS_802_11_SSID *pssid = &pnetwork->network.Ssid;
+		struct cfg80211_scan_request *request = adapter_wdev_data(padapter)->scan_request;
+		struct cfg80211_ssid *ssids = request->ssids;
+		u32 wpsielen=0;
+		u8 *wpsie=NULL;	
+		
+		wpsie = rtw_get_wps_ie(pnetwork->network.IEs+_FIXED_IE_LENGTH_, pnetwork->network.IELength-_FIXED_IE_LENGTH_, NULL, &wpsielen);
+		
+		if(wpsie && wpsielen>0)
+			psr = rtw_get_wps_attr_content(wpsie,  wpsielen, WPS_ATTR_SELECTED_REGISTRAR, (u8*)(&sr), NULL);
+		
+		if (sr != 0)
+		{			
+			if(request->n_ssids == 1 && request->n_channels == 1) // it means under processing WPS
+			{
+				DBG_8192C("ssid=%s, len=%d\n", pssid->Ssid, pssid->SsidLength);
+
+				if (ssids[0].ssid_len == 0) {
+				}
+				else if(pssid->SsidLength == ssids[0].ssid_len &&
+					_rtw_memcmp(pssid->Ssid, ssids[0].ssid, ssids[0].ssid_len))
+				{
+					DBG_871X("%s, got sr and ssid match!\n", __func__);
+				}
+				else
+				{
+					if(psr !=NULL)
+						*psr = 0; //clear sr
+				
+#if 0			
+					WLAN_BSSID_EX  *pselect_network = &pnetwork->network;
+					struct cfg80211_bss *pselect_bss = NULL;
+					struct ieee80211_channel *notify_channel = NULL;
+					u32 freq;
+
+					DBG_871X("%s, got sr, but ssid mismatch, to remove this bss\n", __func__);
+
+					freq = rtw_ch2freq(pselect_network->Configuration.DSConfig);
+					notify_channel = ieee80211_get_channel(wiphy, freq);
+					pselect_bss = cfg80211_get_bss(wiphy, NULL/*notify_channel*/,
+								pselect_network->MacAddress, pselect_network->Ssid.Ssid,
+								pselect_network->Ssid.SsidLength, 0/*WLAN_CAPABILITY_ESS*/, 
+								0/*WLAN_CAPABILITY_ESS*/);
+
+					if(pselect_bss)
+					{
+						DBG_871X("%s, got bss for cfg80211 for unlinking bss\n", __func__);
+
+						cfg80211_unlink_bss(wiphy, pselect_bss);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+						cfg80211_put_bss(wiphy, pselect_bss);
+#else
+						cfg80211_put_bss(pselect_bss);
+#endif
+						
+					}
+					
+					goto exit;
+#endif 					
+				}			
+			}			
+		}		
+	}
+	//_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	
+
+	channel = pnetwork->network.Configuration.DSConfig;
+	freq = rtw_ch2freq(channel);
+	notify_channel = ieee80211_get_channel(wiphy, freq);
+
+	if (0)
+		notify_timestamp = le64_to_cpu(*(u64*)rtw_get_timestampe_from_ie(pnetwork->network.IEs));
+	else
+		notify_timestamp = rtw_get_systime_us();
+
+	notify_interval = le16_to_cpu(*(u16*)rtw_get_beacon_interval_from_ie(pnetwork->network.IEs));
+	notify_capability = le16_to_cpu(*(u16*)rtw_get_capability_from_ie(pnetwork->network.IEs));		
+
+	notify_ie = pnetwork->network.IEs+_FIXED_IE_LENGTH_;
+	notify_ielen = pnetwork->network.IELength-_FIXED_IE_LENGTH_;
+
+	//We've set wiphy's signal_type as CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm)
+	if ( check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE &&
+		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network, 0)) {
+		notify_signal = 100*translate_percentage_to_dbm(padapter->recvpriv.signal_strength);//dbm
+	} else {
+		notify_signal = 100*translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength);//dbm
+	}
+		
+	#if 0
+	DBG_8192C("bssid: "MAC_FMT"\n", MAC_ARG(pnetwork->network.MacAddress));
+	DBG_8192C("Channel: %d(%d)\n", channel, freq);
+	DBG_8192C("Capability: %X\n", notify_capability);
+	DBG_8192C("Beacon interval: %d\n", notify_interval);
+	DBG_8192C("Signal: %d\n", notify_signal);
+	DBG_8192C("notify_timestamp: %llu\n", notify_timestamp);
+	#endif
+
+	//pbuf = buf;
+	
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pbuf;	
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;	
+
+	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
+	//pmlmeext->mgnt_seq++;
+
+	if (pnetwork->network.Reserved[0] == 1) { // WIFI_BEACON
+		_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);		
+		SetFrameSubType(pbuf, WIFI_BEACON);
+	} else {
+		_rtw_memcpy(pwlanhdr->addr1, adapter_mac_addr(padapter), ETH_ALEN);
+		SetFrameSubType(pbuf, WIFI_PROBERSP);
+	}
+
+	_rtw_memcpy(pwlanhdr->addr2, pnetwork->network.MacAddress, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, pnetwork->network.MacAddress, ETH_ALEN);
+
+
+	//pbuf += sizeof(struct rtw_ieee80211_hdr_3addr);
+	len = sizeof (struct rtw_ieee80211_hdr_3addr);
+	_rtw_memcpy((pbuf+len), pnetwork->network.IEs, pnetwork->network.IELength);
+	*((u64*)(pbuf+len)) = cpu_to_le64(notify_timestamp);
+	
+	len += pnetwork->network.IELength;	
+
+	//#ifdef CONFIG_P2P
+	//if(rtw_get_p2p_ie(pnetwork->network.IEs+12, pnetwork->network.IELength-12, NULL, NULL))
+	//{
+	//	DBG_8192C("%s, got p2p_ie\n", __func__);
+	//}
+	//#endif
+
+#if 1	
+	bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)pbuf,
+		len, notify_signal, GFP_ATOMIC);
+#else			 
+			
+	bss = cfg80211_inform_bss(wiphy, notify_channel, (const u8 *)pnetwork->network.MacAddress,
+                notify_timestamp, notify_capability, notify_interval, notify_ie,
+                notify_ielen, notify_signal, GFP_ATOMIC/*GFP_KERNEL*/);
+#endif
+
+	if (unlikely(!bss)) {
+		DBG_8192C(FUNC_ADPT_FMT" bss NULL\n", FUNC_ADPT_ARG(padapter));
+		goto exit;
+	}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38))
+#ifndef COMPAT_KERNEL_RELEASE
+	//patch for cfg80211, update beacon ies to information_elements
+	if (pnetwork->network.Reserved[0] == 1) { // WIFI_BEACON
+	
+		 if(bss->len_information_elements != bss->len_beacon_ies)
+		 {
+			bss->information_elements = bss->beacon_ies;			
+			bss->len_information_elements =  bss->len_beacon_ies;
+		 }		
+	}
+#endif //COMPAT_KERNEL_RELEASE
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+
+/*	
+	{
+		if( bss->information_elements == bss->proberesp_ies) 
+		{
+			if( bss->len_information_elements !=  bss->len_proberesp_ies)
+			{
+				DBG_8192C("error!, len_information_elements !=  bss->len_proberesp_ies\n");
+			}
+							
+		}
+		else if(bss->len_information_elements <  bss->len_beacon_ies)
+		{
+			bss->information_elements = bss->beacon_ies;			
+			bss->len_information_elements =  bss->len_beacon_ies;
+		}
+	}
+*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+	cfg80211_put_bss(wiphy, bss);
+#else
+	cfg80211_put_bss(bss);
+#endif
+	
+exit:
+	if(pbuf)
+		rtw_mfree(pbuf, buf_size);	
+	return bss;
+	
+}
+
+/*
+	Check the given bss is valid by kernel API cfg80211_get_bss()
+	@padapter : the given adapter
+	
+	return _TRUE if bss is valid,  _FALSE for not found.
+*/
+int rtw_cfg80211_check_bss(_adapter *padapter)
+{
+	WLAN_BSSID_EX  *pnetwork = &(padapter->mlmeextpriv.mlmext_info.network);
+	struct cfg80211_bss *bss = NULL;
+	struct ieee80211_channel *notify_channel = NULL;
+	u32 freq;
+
+	if (!(pnetwork) || !(padapter->rtw_wdev))
+		return _FALSE;
+
+	freq = rtw_ch2freq(pnetwork->Configuration.DSConfig);
+	notify_channel = ieee80211_get_channel(padapter->rtw_wdev->wiphy, freq);
+	bss = cfg80211_get_bss(padapter->rtw_wdev->wiphy, notify_channel,
+			pnetwork->MacAddress, pnetwork->Ssid.Ssid,
+			pnetwork->Ssid.SsidLength,
+			WLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+	cfg80211_put_bss(padapter->rtw_wdev->wiphy, bss);
+#else
+	cfg80211_put_bss(bss);
+#endif
+
+	return 	(bss!=NULL);
+}
+
+void rtw_cfg80211_ibss_indicate_connect(_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+	struct cfg80211_bss *bss = NULL;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
+	struct wiphy *wiphy = pwdev->wiphy;
+	int freq = 2412;
+	struct ieee80211_channel *notify_channel;
+#endif
+
+	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))	
+	freq = rtw_ch2freq(cur_network->network.Configuration.DSConfig);
+
+	if (0)
+		DBG_871X("chan: %d, freq: %d\n", cur_network->network.Configuration.DSConfig, freq);
+#endif
+
+	if (pwdev->iftype != NL80211_IFTYPE_ADHOC) 
+	{
+		return;
+	}
+
+	if (!rtw_cfg80211_check_bss(padapter)) {
+		WLAN_BSSID_EX  *pnetwork = &(padapter->mlmeextpriv.mlmext_info.network);
+		struct wlan_network *scanned = pmlmepriv->cur_network_scanned;
+
+		if(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_TRUE)
+		{
+			
+			_rtw_memcpy(&cur_network->network, pnetwork, sizeof(WLAN_BSSID_EX));
+			if(cur_network)
+			{
+				if (!rtw_cfg80211_inform_bss(padapter,cur_network))
+					DBG_871X(FUNC_ADPT_FMT" inform fail !!\n", FUNC_ADPT_ARG(padapter));
+				else
+					DBG_871X(FUNC_ADPT_FMT" inform success !!\n", FUNC_ADPT_ARG(padapter));
+			}
+			else
+			{
+				DBG_871X("cur_network is not exist!!!\n");
+				return ;
+			}
+		}
+		else
+		{
+			if(scanned == NULL)
+				rtw_warn_on(1);
+
+			if (_rtw_memcmp(&(scanned->network.Ssid), &(pnetwork->Ssid), sizeof(NDIS_802_11_SSID)) == _TRUE
+				&& _rtw_memcmp(scanned->network.MacAddress, pnetwork->MacAddress, sizeof(NDIS_802_11_MAC_ADDRESS)) == _TRUE
+			) {
+				if (!rtw_cfg80211_inform_bss(padapter,scanned)) {
+					DBG_871X(FUNC_ADPT_FMT" inform fail !!\n", FUNC_ADPT_ARG(padapter));
+				} else {
+					//DBG_871X(FUNC_ADPT_FMT" inform success !!\n", FUNC_ADPT_ARG(padapter));
+				}
+			} else {
+				DBG_871X("scanned & pnetwork compare fail\n");
+				rtw_warn_on(1);
+			}
+		}
+
+		if (!rtw_cfg80211_check_bss(padapter))
+			DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" BSS not found !!\n", FUNC_ADPT_ARG(padapter));
+	}
+	//notify cfg80211 that device joined an IBSS
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
+	notify_channel = ieee80211_get_channel(wiphy, freq);
+	cfg80211_ibss_joined(padapter->pnetdev, cur_network->network.MacAddress, notify_channel, GFP_ATOMIC);
+#else
+	cfg80211_ibss_joined(padapter->pnetdev, cur_network->network.MacAddress, GFP_ATOMIC);
+#endif
+}
+
+void rtw_cfg80211_indicate_connect(_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+#ifdef CONFIG_P2P
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+#endif
+	struct cfg80211_bss *bss = NULL;
+
+	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
+	if (pwdev->iftype != NL80211_IFTYPE_STATION
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+		&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT
+		#endif
+	) {
+		return;
+	}
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+		return;
+
+#ifdef CONFIG_P2P
+	if(pwdinfo->driver_interface == DRIVER_CFG80211 )
+	{
+		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		{
+			rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
+			rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
+			rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
+			DBG_8192C("%s, role=%d, p2p_state=%d, pre_p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo), rtw_p2p_pre_state(pwdinfo));
+		}
+	}
+#endif //CONFIG_P2P
+
+	if (check_fwstate(pmlmepriv, WIFI_MONITOR_STATE) != _TRUE) {
+		WLAN_BSSID_EX  *pnetwork = &(padapter->mlmeextpriv.mlmext_info.network);
+		struct wlan_network *scanned = pmlmepriv->cur_network_scanned;
+
+		//DBG_871X(FUNC_ADPT_FMT" BSS not found\n", FUNC_ADPT_ARG(padapter));
+
+		if(scanned == NULL) {
+			rtw_warn_on(1);
+			goto check_bss;
+		}
+
+		if (_rtw_memcmp(scanned->network.MacAddress, pnetwork->MacAddress, sizeof(NDIS_802_11_MAC_ADDRESS)) == _TRUE
+			&& _rtw_memcmp(&(scanned->network.Ssid), &(pnetwork->Ssid), sizeof(NDIS_802_11_SSID)) == _TRUE
+		) {
+			if (!rtw_cfg80211_inform_bss(padapter,scanned)) {
+				DBG_871X(FUNC_ADPT_FMT" inform fail !!\n", FUNC_ADPT_ARG(padapter));
+			} else {
+				//DBG_871X(FUNC_ADPT_FMT" inform success !!\n", FUNC_ADPT_ARG(padapter));
+			}
+		} else {
+			DBG_871X("scanned: %s("MAC_FMT"), cur: %s("MAC_FMT")\n",
+				scanned->network.Ssid.Ssid, MAC_ARG(scanned->network.MacAddress),
+				pnetwork->Ssid.Ssid, MAC_ARG(pnetwork->MacAddress)
+			);
+			rtw_warn_on(1);
+		}
+	}
+
+check_bss:
+	if (!rtw_cfg80211_check_bss(padapter))
+		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" BSS not found !!\n", FUNC_ADPT_ARG(padapter));
+
+	if (rtw_to_roam(padapter) > 0) {
+		#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39) || defined(COMPAT_KERNEL_RELEASE)
+		struct wiphy *wiphy = pwdev->wiphy;
+		struct ieee80211_channel *notify_channel;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+		struct cfg80211_roam_info roam_info = {};
+#endif
+		u32 freq;
+		u16 channel = cur_network->network.Configuration.DSConfig;
+
+		freq = rtw_ch2freq(channel);
+		notify_channel = ieee80211_get_channel(wiphy, freq);
+		#endif
+
+		DBG_871X(FUNC_ADPT_FMT" call cfg80211_roamed\n", FUNC_ADPT_ARG(padapter));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+		roam_info.channel = notify_channel;
+		roam_info.bssid = cur_network->network.MacAddress;
+		roam_info.req_ie =
+			pmlmepriv->assoc_req+sizeof(struct ieee80211_hdr_3addr)+2;
+		roam_info.req_ie_len =
+			pmlmepriv->assoc_req_len-sizeof(struct ieee80211_hdr_3addr)-2;
+		roam_info.resp_ie =
+			pmlmepriv->assoc_rsp+sizeof(struct ieee80211_hdr_3addr)+6;
+		roam_info.resp_ie_len =
+			pmlmepriv->assoc_rsp_len-sizeof(struct ieee80211_hdr_3addr)-6;
+		cfg80211_roamed(padapter->pnetdev, &roam_info, GFP_ATOMIC);
+#else
+		cfg80211_roamed(padapter->pnetdev
+			#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39) || defined(COMPAT_KERNEL_RELEASE)
+			, notify_channel
+			#endif
+			, cur_network->network.MacAddress
+			, pmlmepriv->assoc_req+sizeof(struct rtw_ieee80211_hdr_3addr)+2
+			, pmlmepriv->assoc_req_len-sizeof(struct rtw_ieee80211_hdr_3addr)-2
+			, pmlmepriv->assoc_rsp+sizeof(struct rtw_ieee80211_hdr_3addr)+6
+			, pmlmepriv->assoc_rsp_len-sizeof(struct rtw_ieee80211_hdr_3addr)-6
+			, GFP_ATOMIC);
+#endif
+	}
+	else
+	{
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0) || defined(COMPAT_KERNEL_RELEASE)	
+		DBG_8192C("pwdev->sme_state(b)=%d\n", pwdev->sme_state);
+	#endif
+		cfg80211_connect_result(padapter->pnetdev, cur_network->network.MacAddress
+			, pmlmepriv->assoc_req+sizeof(struct rtw_ieee80211_hdr_3addr)+2
+			, pmlmepriv->assoc_req_len-sizeof(struct rtw_ieee80211_hdr_3addr)-2
+			, pmlmepriv->assoc_rsp+sizeof(struct rtw_ieee80211_hdr_3addr)+6
+			, pmlmepriv->assoc_rsp_len-sizeof(struct rtw_ieee80211_hdr_3addr)-6
+			, WLAN_STATUS_SUCCESS, GFP_ATOMIC);
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0) || defined(COMPAT_KERNEL_RELEASE)	
+		DBG_8192C("pwdev->sme_state(a)=%d\n", pwdev->sme_state);
+	#endif
+	}
+}
+
+void rtw_cfg80211_indicate_disconnect(_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+#ifdef CONFIG_P2P
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+#endif
+
+	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
+
+	if (pwdev->iftype != NL80211_IFTYPE_STATION 
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+		&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT
+		#endif
+	) {
+		return;
+	}
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+		return;
+
+#ifdef CONFIG_P2P	
+	if( pwdinfo->driver_interface == DRIVER_CFG80211 )
+	{
+		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		{
+			rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
+
+			#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE)
+			if (pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT)
+			#endif
+				rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
+
+			DBG_8192C("%s, role=%d, p2p_state=%d, pre_p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo), rtw_p2p_pre_state(pwdinfo));
+		}
+	}
+#endif //CONFIG_P2P
+
+	if (!padapter->mlmepriv.not_indic_disco || padapter->ndev_unregistering) {
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0) || defined(COMPAT_KERNEL_RELEASE)			
+		DBG_8192C("pwdev->sme_state(b)=%d\n", pwdev->sme_state);
+
+		if(pwdev->sme_state==CFG80211_SME_CONNECTING)
+			cfg80211_connect_result(padapter->pnetdev, NULL, NULL, 0, NULL, 0, 
+				WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC/*GFP_KERNEL*/);
+		else if(pwdev->sme_state==CFG80211_SME_CONNECTED)
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
+			cfg80211_disconnected(padapter->pnetdev, 0, NULL, 0, GFP_ATOMIC);
+		#else
+			cfg80211_disconnected(padapter->pnetdev, 0, NULL, 0, false, GFP_ATOMIC);
+		#endif
+		//else
+			//DBG_8192C("pwdev->sme_state=%d\n", pwdev->sme_state);
+
+		DBG_8192C("pwdev->sme_state(a)=%d\n", pwdev->sme_state);
+		#else
+
+		if (check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {
+			DBG_871X(FUNC_ADPT_FMT" call cfg80211_disconnected\n", FUNC_ADPT_ARG(padapter));
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
+			cfg80211_disconnected(padapter->pnetdev, 0, NULL, 0, GFP_ATOMIC);
+		#else
+			cfg80211_disconnected(padapter->pnetdev, 0, NULL, 0, false, GFP_ATOMIC);
+		#endif
+		} else {
+			DBG_871X(FUNC_ADPT_FMT" call cfg80211_connect_result\n", FUNC_ADPT_ARG(padapter));
+			cfg80211_connect_result(padapter->pnetdev, NULL, NULL, 0, NULL, 0, 
+				WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC);
+		}
+		#endif
+	}
+}
+ 	
+
+#ifdef CONFIG_AP_MODE
+static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len,wep_total_len;
+	struct sta_info *psta = NULL, *pbcmc_sta = NULL;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;
+	struct security_priv* psecuritypriv=&(padapter->securitypriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	DBG_8192C("%s\n", __FUNCTION__);
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	//sizeof(struct ieee_param) = 64 bytes;
+	//if (param_len !=  (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
+	if (param_len !=  sizeof(struct ieee_param) + param->u.crypt.key_len)
+	{
+		ret =  -EINVAL;
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		if (param->u.crypt.idx >= WEP_KEYS
+#ifdef CONFIG_IEEE80211W
+			&& param->u.crypt.idx > BIP_MAX_KEYID
+#endif /* CONFIG_IEEE80211W */
+		)
+		{
+			ret = -EINVAL;
+			goto exit;
+		}	
+	}
+	else 
+	{		
+		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+		if(!psta)
+		{
+			//ret = -EINVAL;
+			DBG_8192C("rtw_set_encryption(), sta has already been removed or never been added\n");
+			goto exit;
+		}			
+	}
+
+	if (strcmp(param->u.crypt.alg, "none") == 0 && (psta==NULL))
+	{
+		//todo:clear default encryption keys
+
+		DBG_8192C("clear default encryption keys, keyid=%d\n", param->u.crypt.idx);
+		
+		goto exit;
+	}
+
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta==NULL))
+	{		
+		DBG_8192C("r871x_set_encryption, crypt.alg = WEP\n");
+		
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+					
+		DBG_8192C("r871x_set_encryption, wep_key_idx=%d, len=%d\n", wep_key_idx, wep_key_len);
+
+		if((wep_key_idx >= WEP_KEYS) || (wep_key_len<=0))
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+			
+		if (wep_key_len > 0) 
+		{			
+		 	wep_key_len = wep_key_len <= 5 ? 5 : 13;
+		}
+		
+		if (psecuritypriv->bWepDefaultKeyIdxSet == 0)
+		{
+			//wep default key has not been set, so use this key index as default key.
+
+			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+			psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			psecuritypriv->dot11PrivacyAlgrthm=_WEP40_;
+			psecuritypriv->dot118021XGrpPrivacy=_WEP40_;
+			
+			if(wep_key_len == 13)
+			{
+				psecuritypriv->dot11PrivacyAlgrthm=_WEP104_;
+				psecuritypriv->dot118021XGrpPrivacy=_WEP104_;
+			}
+
+			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
+		}
+			
+		_rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), param->u.crypt.key, wep_key_len);
+					
+		psecuritypriv->dot11DefKeylen[wep_key_idx] = wep_key_len;
+
+		rtw_ap_set_wep_key(padapter, param->u.crypt.key, wep_key_len, wep_key_idx, 1);
+
+		goto exit;
+		
+	}
+
+	
+	if(!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) // //group key
+	{
+		if(param->u.crypt.set_tx == 0) //group key
+		{
+			if(strcmp(param->u.crypt.alg, "WEP") == 0)
+			{
+				DBG_8192C("%s, set group_key, WEP\n", __FUNCTION__);
+				
+				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					
+				psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+				if(param->u.crypt.key_len==13)
+				{						
+						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+				}
+				
+			}
+			else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+			{						
+				DBG_8192C("%s, set group_key, TKIP\n", __FUNCTION__);
+				
+				psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
+
+				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				
+				//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
+				//set mic key
+				_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
+				_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
+
+				psecuritypriv->busetkipkey = _TRUE;
+											
+			}
+			else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+			{
+				DBG_8192C("%s, set group_key, CCMP\n", __FUNCTION__);
+			
+				psecuritypriv->dot118021XGrpPrivacy = _AES_;
+
+				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+			}
+#ifdef CONFIG_IEEE80211W
+			else if (strcmp(param->u.crypt.alg, "BIP") == 0) {
+				int no;
+				
+				DBG_871X("BIP key_len=%d , index=%d\n", param->u.crypt.key_len, param->u.crypt.idx);
+				/* save the IGTK key, length 16 bytes */
+				_rtw_memcpy(padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16:param->u.crypt.key_len));
+				/* DBG_871X("IGTK key below:\n");
+				for(no=0;no<16;no++)
+					printk(" %02x ", padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey[no]);
+				DBG_871X("\n"); */
+				padapter->securitypriv.dot11wBIPKeyid = param->u.crypt.idx;
+				padapter->securitypriv.binstallBIPkey = _TRUE;
+				DBG_871X(" ~~~~set sta key:IGKT\n");
+				goto exit;
+			}
+#endif /* CONFIG_IEEE80211W */
+			else
+			{
+				DBG_8192C("%s, set group_key, none\n", __FUNCTION__);
+				
+				psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+			}
+
+			psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
+
+			psecuritypriv->binstallGrpkey = _TRUE;
+
+			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
+								
+			rtw_ap_set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
+			
+			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
+			if(pbcmc_sta)
+			{
+				pbcmc_sta->ieee8021x_blocked = _FALSE;
+				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy			
+			}	
+						
+		}
+
+		goto exit;
+		
+	}	
+
+	if(psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) // psk/802_1x
+	{
+		if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
+		{
+			if(param->u.crypt.set_tx ==1) //pairwise key
+			{ 
+				_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				
+				if(strcmp(param->u.crypt.alg, "WEP") == 0)
+				{
+					DBG_8192C("%s, set pairwise key, WEP\n", __FUNCTION__);
+					
+					psta->dot118021XPrivacy = _WEP40_;
+					if(param->u.crypt.key_len==13)
+					{						
+						psta->dot118021XPrivacy = _WEP104_;
+					}
+				}
+				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+				{						
+					DBG_8192C("%s, set pairwise key, TKIP\n", __FUNCTION__);
+					
+					psta->dot118021XPrivacy = _TKIP_;
+				
+					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
+					//set mic key
+					_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+					_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+					psecuritypriv->busetkipkey = _TRUE;
+											
+				}
+				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+				{
+
+					DBG_8192C("%s, set pairwise key, CCMP\n", __FUNCTION__);
+					
+					psta->dot118021XPrivacy = _AES_;
+				}
+				else
+				{
+					DBG_8192C("%s, set pairwise key, none\n", __FUNCTION__);
+					
+					psta->dot118021XPrivacy = _NO_PRIVACY_;
+				}
+						
+				rtw_ap_set_pairwise_key(padapter, psta);
+					
+				psta->ieee8021x_blocked = _FALSE;
+					
+				psta->bpairwise_key_installed = _TRUE;
+					
+			}			
+			else//group key???
+			{ 
+				if(strcmp(param->u.crypt.alg, "WEP") == 0)
+				{
+					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					
+					psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+					if(param->u.crypt.key_len==13)
+					{						
+						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+					}
+				}
+				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+				{						
+					psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
+
+					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				
+					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
+					//set mic key
+					_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
+					_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
+
+					psecuritypriv->busetkipkey = _TRUE;
+											
+				}
+				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+				{
+					psecuritypriv->dot118021XGrpPrivacy = _AES_;
+
+					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				}
+				else
+				{
+					psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+				}
+
+				psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
+
+				psecuritypriv->binstallGrpkey = _TRUE;	
+								
+				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
+								
+				rtw_ap_set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
+			
+				pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
+				if(pbcmc_sta)
+				{
+					pbcmc_sta->ieee8021x_blocked = _FALSE;
+					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy			
+				}					
+
+			}
+			
+		}
+				
+	}
+
+exit:
+
+	return ret;
+	
+}
+#endif
+
+static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len,wep_total_len;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;		
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+#ifdef CONFIG_P2P
+	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
+#endif //CONFIG_P2P
+
+_func_enter_;
+
+	DBG_8192C("%s\n", __func__);
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	if (param_len < (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
+	{
+		ret =  -EINVAL;		
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		if (param->u.crypt.idx >= WEP_KEYS
+#ifdef CONFIG_IEEE80211W
+			&& param->u.crypt.idx > BIP_MAX_KEYID
+#endif //CONFIG_IEEE80211W
+		)
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+	} else {
+#ifdef CONFIG_WAPI_SUPPORT
+		if (strcmp(param->u.crypt.alg, "SMS4"))
+#endif
+		{
+		ret = -EINVAL;
+		goto exit;
+	}
+	}
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("wpa_set_encryption, crypt.alg = WEP\n"));
+		DBG_8192C("wpa_set_encryption, crypt.alg = WEP\n");
+
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+
+		if ((wep_key_idx > WEP_KEYS) || (wep_key_len <= 0))
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		if (psecuritypriv->bWepDefaultKeyIdxSet == 0)
+		{
+			//wep default key has not been set, so use this key index as default key.
+
+			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+
+              	psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			psecuritypriv->dot11PrivacyAlgrthm = _WEP40_;
+			psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+
+			if(wep_key_len==13)
+			{
+				psecuritypriv->dot11PrivacyAlgrthm = _WEP104_;
+				psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+			}
+
+			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
+		}
+			
+		_rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), param->u.crypt.key, wep_key_len);
+			
+		psecuritypriv->dot11DefKeylen[wep_key_idx] = wep_key_len;
+			
+		rtw_set_key(padapter, psecuritypriv, wep_key_idx, 0, _TRUE);
+
+		goto exit;		
+	}
+
+	if(padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) // 802_1x
+	{
+		struct sta_info * psta,*pbcmc_sta;
+		struct sta_priv * pstapriv = &padapter->stapriv;
+
+		//DBG_8192C("%s, : dot11AuthAlgrthm == dot11AuthAlgrthm_8021X \n", __func__);
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == _TRUE) //sta mode
+		{
+			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));			
+			if (psta == NULL) {
+				//DEBUG_ERR( ("Set wpa_set_encryption: Obtain Sta_info fail \n"));
+				DBG_8192C("%s, : Obtain Sta_info fail \n", __func__);
+			}
+			else
+			{
+				//Jeff: don't disable ieee8021x_blocked while clearing key
+				if (strcmp(param->u.crypt.alg, "none") != 0) 
+					psta->ieee8021x_blocked = _FALSE;
+
+				
+				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
+				{
+					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+				}		
+
+				if(param->u.crypt.set_tx ==1)//pairwise key
+				{ 
+
+					DBG_8192C("%s, : param->u.crypt.set_tx ==1 \n", __func__);
+					
+					_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					
+					if(strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
+					{						
+						//DEBUG_ERR(("\nset key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
+						_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+						_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+						padapter->securitypriv.busetkipkey=_FALSE;
+						//_set_timer(&padapter->securitypriv.tkip_timer, 50);						
+					}
+					psta->bpairwise_key_installed = _TRUE;
+					//DEBUG_ERR((" param->u.crypt.key_len=%d\n",param->u.crypt.key_len));
+					DBG_871X(" ~~~~set sta key:unicastkey\n");
+					
+					rtw_setstakey_cmd(padapter, psta, UNICAST_KEY, _TRUE);
+				}
+				else//group key
+				{
+					if(strcmp(param->u.crypt.alg, "TKIP") == 0 || strcmp(param->u.crypt.alg, "CCMP") == 0)
+					{
+						_rtw_memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+						_rtw_memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[16]),8);
+						_rtw_memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[24]),8);
+	                                        padapter->securitypriv.binstallGrpkey = _TRUE;	
+						//DEBUG_ERR((" param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
+						DBG_871X(" ~~~~set sta key:groupkey\n");
+	
+						padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
+						rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1, _TRUE);
+					}
+#ifdef CONFIG_IEEE80211W
+					else if(strcmp(param->u.crypt.alg, "BIP") == 0)
+					{
+						int no;
+						//DBG_871X("BIP key_len=%d , index=%d @@@@@@@@@@@@@@@@@@\n", param->u.crypt.key_len, param->u.crypt.idx);
+						//save the IGTK key, length 16 bytes
+						_rtw_memcpy(padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+						/*DBG_871X("IGTK key below:\n");
+						for(no=0;no<16;no++)
+							printk(" %02x ", padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey[no]);
+						DBG_871X("\n");*/
+						padapter->securitypriv.dot11wBIPKeyid = param->u.crypt.idx;
+						padapter->securitypriv.binstallBIPkey = _TRUE;
+						DBG_871X(" ~~~~set sta key:IGKT\n");
+					}
+#endif //CONFIG_IEEE80211W
+					
+#ifdef CONFIG_P2P
+					if(pwdinfo->driver_interface == DRIVER_CFG80211 )
+					{
+						if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
+						{
+							rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_DONE);
+						}
+					}
+#endif //CONFIG_P2P
+					
+				}						
+			}
+
+			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
+			if(pbcmc_sta==NULL)
+			{
+				//DEBUG_ERR( ("Set OID_802_11_ADD_KEY: bcmc stainfo is null \n"));
+			}
+			else
+			{
+				//Jeff: don't disable ieee8021x_blocked while clearing key
+				if (strcmp(param->u.crypt.alg, "none") != 0) 
+					pbcmc_sta->ieee8021x_blocked = _FALSE;
+				
+				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
+				{							
+					pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+				}					
+			}				
+		}
+		else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
+		{		
+		}			
+	}
+
+#ifdef CONFIG_WAPI_SUPPORT
+	if (strcmp(param->u.crypt.alg, "SMS4") == 0)
+	{
+		PRT_WAPI_T			pWapiInfo = &padapter->wapiInfo;
+		PRT_WAPI_STA_INFO	pWapiSta;
+		u8					WapiASUEPNInitialValueSrc[16] = {0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
+		u8					WapiAEPNInitialValueSrc[16] = {0x37,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
+		u8 					WapiAEMultiCastPNInitialValueSrc[16] = {0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
+
+		if(param->u.crypt.set_tx == 1)
+		{
+			list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list) {
+				if(_rtw_memcmp(pWapiSta->PeerMacAddr,param->sta_addr,6))
+				{
+					_rtw_memcpy(pWapiSta->lastTxUnicastPN,WapiASUEPNInitialValueSrc,16);
+
+					pWapiSta->wapiUsk.bSet = true;
+					_rtw_memcpy(pWapiSta->wapiUsk.dataKey,param->u.crypt.key,16);
+					_rtw_memcpy(pWapiSta->wapiUsk.micKey,param->u.crypt.key+16,16);
+					pWapiSta->wapiUsk.keyId = param->u.crypt.idx ;
+					pWapiSta->wapiUsk.bTxEnable = true;
+
+					_rtw_memcpy(pWapiSta->lastRxUnicastPNBEQueue,WapiAEPNInitialValueSrc,16);
+					_rtw_memcpy(pWapiSta->lastRxUnicastPNBKQueue,WapiAEPNInitialValueSrc,16);
+					_rtw_memcpy(pWapiSta->lastRxUnicastPNVIQueue,WapiAEPNInitialValueSrc,16);
+					_rtw_memcpy(pWapiSta->lastRxUnicastPNVOQueue,WapiAEPNInitialValueSrc,16);
+					_rtw_memcpy(pWapiSta->lastRxUnicastPN,WapiAEPNInitialValueSrc,16);
+					pWapiSta->wapiUskUpdate.bTxEnable = false;
+					pWapiSta->wapiUskUpdate.bSet = false;
+
+					if (psecuritypriv->sw_encrypt== false || psecuritypriv->sw_decrypt == false)
+					{
+						//set unicast key for ASUE
+						rtw_wapi_set_key(padapter, &pWapiSta->wapiUsk, pWapiSta, false, false);
+					}
+				}
+			}
+		}
+		else
+		{
+			list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list) {
+				if(_rtw_memcmp(pWapiSta->PeerMacAddr,get_bssid(pmlmepriv),6))
+				{
+					pWapiSta->wapiMsk.bSet = true;
+					_rtw_memcpy(pWapiSta->wapiMsk.dataKey,param->u.crypt.key,16);
+					_rtw_memcpy(pWapiSta->wapiMsk.micKey,param->u.crypt.key+16,16);
+					pWapiSta->wapiMsk.keyId = param->u.crypt.idx ;
+					pWapiSta->wapiMsk.bTxEnable = false;
+					if(!pWapiSta->bSetkeyOk)
+						pWapiSta->bSetkeyOk = true;
+					pWapiSta->bAuthenticateInProgress = false;
+
+					_rtw_memcpy(pWapiSta->lastRxMulticastPN, WapiAEMultiCastPNInitialValueSrc, 16);
+
+					if (psecuritypriv->sw_decrypt == false)
+					{
+						//set rx broadcast key for ASUE
+						rtw_wapi_set_key(padapter, &pWapiSta->wapiMsk, pWapiSta, true, false);
+					}
+				}
+
+			}
+		}
+	}
+#endif
+
+
+exit:
+
+	DBG_8192C("%s, ret=%d\n", __func__, ret);
+	
+	_func_exit_;
+	
+	return ret;	
+}
+
+static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+				u8 key_index, bool pairwise, const u8 *mac_addr,
+#else	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				u8 key_index, const u8 *mac_addr,
+#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				struct key_params *params)
+{
+	char *alg_name;
+	u32 param_len;
+	struct ieee_param *param = NULL;	
+	int ret=0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct wireless_dev *rtw_wdev = padapter->rtw_wdev;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+#ifdef CONFIG_TDLS
+	struct sta_info *ptdls_sta;
+#endif /* CONFIG_TDLS */
+	
+	DBG_871X(FUNC_NDEV_FMT" adding key for %pM\n", FUNC_NDEV_ARG(ndev), mac_addr);
+	DBG_871X("cipher=0x%x\n", params->cipher);
+	DBG_871X("key_len=0x%x\n", params->key_len);
+	DBG_871X("seq_len=0x%x\n", params->seq_len);
+	DBG_871X("key_index=%d\n", key_index);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+	DBG_871X("pairwise=%d\n", pairwise);
+#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+
+	param_len = sizeof(struct ieee_param) + params->key_len;
+	param = (struct ieee_param *)rtw_malloc(param_len);
+	if (param == NULL)
+		return -1;
+	
+	_rtw_memset(param, 0, param_len);
+
+	param->cmd = IEEE_CMD_SET_ENCRYPTION;
+	_rtw_memset(param->sta_addr, 0xff, ETH_ALEN);
+
+	switch (params->cipher) {
+	case IW_AUTH_CIPHER_NONE:
+		//todo: remove key 
+		//remove = 1;	
+		alg_name = "none";
+		break;
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		alg_name = "WEP";
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		alg_name = "TKIP";
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		alg_name = "CCMP";
+		break;
+#ifdef CONFIG_IEEE80211W
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		alg_name = "BIP";
+		break;
+#endif //CONFIG_IEEE80211W
+#ifdef CONFIG_WAPI_SUPPORT
+	case WLAN_CIPHER_SUITE_SMS4:
+		alg_name= "SMS4";
+		if(pairwise == NL80211_KEYTYPE_PAIRWISE) {
+			if (key_index != 0 && key_index != 1) {
+				ret = -ENOTSUPP;
+				goto addkey_end;
+			}
+			_rtw_memcpy((void*)param->sta_addr, (void*)mac_addr, ETH_ALEN);
+		} else {
+			DBG_871X("mac_addr is null \n");
+		}
+		DBG_871X("rtw_wx_set_enc_ext: SMS4 case \n");
+		break;
+#endif
+
+	default:	
+		ret = -ENOTSUPP;
+		goto addkey_end;
+	}
+	
+	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
+	
+
+	if (!mac_addr || is_broadcast_ether_addr(mac_addr))
+	{
+		param->u.crypt.set_tx = 0; //for wpa/wpa2 group key
+	} else {
+		param->u.crypt.set_tx = 1; //for wpa/wpa2 pairwise key
+	}
+	
+	
+	//param->u.crypt.idx = key_index - 1;
+	param->u.crypt.idx = key_index;
+	
+	if (params->seq_len && params->seq) 
+	{	
+		_rtw_memcpy(param->u.crypt.seq, (u8 *)params->seq, params->seq_len);
+	}
+
+	if(params->key_len && params->key)
+	{
+		param->u.crypt.key_len = params->key_len;		
+		_rtw_memcpy(param->u.crypt.key, (u8 *)params->key, params->key_len);
+	}	
+
+	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+	{
+#ifdef CONFIG_TDLS
+		if (rtw_tdls_is_driver_setup(padapter) == _FALSE && mac_addr) {
+			ptdls_sta = rtw_get_stainfo(&padapter->stapriv, (void *)mac_addr);
+			if (ptdls_sta != NULL && ptdls_sta->tdls_sta_state) {
+				_rtw_memcpy(ptdls_sta->tpk.tk, params->key, params->key_len);
+				rtw_tdls_set_key(padapter, ptdls_sta);
+				goto addkey_end;
+			}
+		}
+#endif /* CONFIG_TDLS */
+
+		ret =  rtw_cfg80211_set_encryption(ndev, param, param_len);	
+	}
+	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	{
+#ifdef CONFIG_AP_MODE
+		if(mac_addr)
+			_rtw_memcpy(param->sta_addr, (void*)mac_addr, ETH_ALEN);
+	
+		ret = rtw_cfg80211_ap_set_encryption(ndev, param, param_len);
+#endif
+	}
+        else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE
+                || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)
+        {
+                //DBG_8192C("@@@@@@@@@@ fw_state=0x%x, iftype=%d\n", pmlmepriv->fw_state, rtw_wdev->iftype);
+                ret =  rtw_cfg80211_set_encryption(ndev, param, param_len);
+        }
+	else
+	{
+		DBG_8192C("error! fw_state=0x%x, iftype=%d\n", pmlmepriv->fw_state, rtw_wdev->iftype);
+		
+	}
+
+addkey_end:
+	if(param)
+	{
+		rtw_mfree((u8*)param, param_len);
+	}
+
+	return ret;
+
+}
+
+static int cfg80211_rtw_get_key(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+				u8 key_index, bool pairwise, const u8 *mac_addr,
+#else	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				u8 key_index, const u8 *mac_addr,
+#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				void *cookie,
+				void (*callback)(void *cookie,
+						 struct key_params*))
+{
+#if 0
+	struct iwm_priv *iwm = ndev_to_iwm(ndev);
+	struct iwm_key *key = &iwm->keys[key_index];
+	struct key_params params;
+
+	IWM_DBG_WEXT(iwm, DBG, "Getting key %d\n", key_index);
+
+	memset(&params, 0, sizeof(params));
+
+	params.cipher = key->cipher;
+	params.key_len = key->key_len;
+	params.seq_len = key->seq_len;
+	params.seq = key->seq;
+	params.key = key->key;
+
+	callback(cookie, &params);
+
+	return key->key_len ? 0 : -ENOENT;
+#endif
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	return 0;
+}
+
+static int cfg80211_rtw_del_key(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+				u8 key_index, bool pairwise, const u8 *mac_addr)
+#else	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				u8 key_index, const u8 *mac_addr)
+#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);		
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	DBG_871X(FUNC_NDEV_FMT" key_index=%d\n", FUNC_NDEV_ARG(ndev), key_index);
+
+	if (key_index == psecuritypriv->dot11PrivacyKeyIndex)
+	{
+		//clear the flag of wep default key set.
+		psecuritypriv->bWepDefaultKeyIdxSet = 0;
+	}
+
+	return 0;
+}
+
+static int cfg80211_rtw_set_default_key(struct wiphy *wiphy,
+	struct net_device *ndev, u8 key_index
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
+	, bool unicast, bool multicast
+	#endif
+	)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);		
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+#define SET_DEF_KEY_PARAM_FMT " key_index=%d"
+#define SET_DEF_KEY_PARAM_ARG , key_index
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)) || defined(COMPAT_KERNEL_RELEASE)
+	#define SET_DEF_KEY_PARAM_FMT_2_6_38 ", unicast=%d, multicast=%d"
+	#define SET_DEF_KEY_PARAM_ARG_2_6_38 , unicast, multicast
+#else
+	#define SET_DEF_KEY_PARAM_FMT_2_6_38 ""
+	#define SET_DEF_KEY_PARAM_ARG_2_6_38
+#endif
+
+	DBG_871X(FUNC_NDEV_FMT
+		SET_DEF_KEY_PARAM_FMT
+		SET_DEF_KEY_PARAM_FMT_2_6_38
+		"\n", FUNC_NDEV_ARG(ndev)
+		SET_DEF_KEY_PARAM_ARG
+		SET_DEF_KEY_PARAM_ARG_2_6_38
+	);
+
+	if ((key_index < WEP_KEYS) && ((psecuritypriv->dot11PrivacyAlgrthm == _WEP40_) || (psecuritypriv->dot11PrivacyAlgrthm == _WEP104_))) //set wep default key
+	{
+		psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
+
+		psecuritypriv->dot11PrivacyKeyIndex = key_index;
+
+		psecuritypriv->dot11PrivacyAlgrthm = _WEP40_;
+		psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+		if (psecuritypriv->dot11DefKeylen[key_index] == 13)
+		{
+			psecuritypriv->dot11PrivacyAlgrthm = _WEP104_;
+			psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+		}
+
+		psecuritypriv->bWepDefaultKeyIdxSet = 1; //set the flag to represent that wep default key has been set
+	}
+
+	return 0;
+
+}
+#if defined(CONFIG_GTK_OL) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0))
+static int cfg80211_rtw_set_rekey_data(struct wiphy *wiphy,
+	struct net_device *ndev,
+	struct cfg80211_gtk_rekey_data *data)
+{
+	/*int i;*/
+	struct sta_info *psta;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct mlme_priv   *pmlmepriv = &padapter->mlmepriv;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct security_priv *psecuritypriv = &(padapter->securitypriv);
+
+	psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
+	if (psta == NULL) {
+		DBG_871X("%s, : Obtain Sta_info fail\n", __func__);
+		return -1;
+	}
+
+	_rtw_memcpy(psta->kek, data->kek, NL80211_KEK_LEN);
+	/*printk("\ncfg80211_rtw_set_rekey_data KEK:");
+	for(i=0;i<NL80211_KEK_LEN; i++)
+		printk(" %02x ", psta->kek[i]);*/
+	_rtw_memcpy(psta->kck, data->kck, NL80211_KCK_LEN);
+	/*printk("\ncfg80211_rtw_set_rekey_data KCK:");
+	for(i=0;i<NL80211_KCK_LEN; i++)
+		printk(" %02x ", psta->kck[i]);*/
+	_rtw_memcpy(psta->replay_ctr, data->replay_ctr, NL80211_REPLAY_CTR_LEN);
+	psecuritypriv->binstallKCK_KEK = _TRUE;
+	/*printk("\nREPLAY_CTR: ");
+	for(i=0;i<RTW_REPLAY_CTR_LEN; i++)
+		printk(" %02x ", psta->replay_ctr[i]);*/
+
+	return 0;
+}
+#endif /*CONFIG_GTK_OL*/
+static int cfg80211_rtw_get_station(struct wiphy *wiphy,
+				struct net_device *ndev,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0))
+				u8 *mac, 
+#else
+				const u8 *mac,
+#endif
+				struct station_info *sinfo)
+{
+	int ret = 0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	sinfo->filled = 0;
+
+	if (!mac) {
+		DBG_871X(FUNC_NDEV_FMT" mac==%p\n", FUNC_NDEV_ARG(ndev), mac);
+		ret = -ENOENT;
+		goto exit;
+	}
+
+	psta = rtw_get_stainfo(pstapriv, (u8 *)mac);
+	if (psta == NULL) {
+		DBG_8192C("%s, sta_info is null\n", __func__);
+		ret = -ENOENT;
+		goto exit;
+	}
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_871X(FUNC_NDEV_FMT" mac="MAC_FMT"\n", FUNC_NDEV_ARG(ndev), MAC_ARG(mac));
+#endif
+
+	//for infra./P2PClient mode
+	if(	check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+		&& check_fwstate(pmlmepriv, _FW_LINKED)
+	)
+	{
+		struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
+
+		if (_rtw_memcmp((u8 *)mac, cur_network->network.MacAddress, ETH_ALEN) == _FALSE) {
+			DBG_871X("%s, mismatch bssid="MAC_FMT"\n", __func__, MAC_ARG(cur_network->network.MacAddress));
+			ret = -ENOENT;
+			goto exit;
+		}
+
+		sinfo->filled |= STATION_INFO_SIGNAL;
+		sinfo->signal = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);
+
+		sinfo->filled |= STATION_INFO_TX_BITRATE;
+		sinfo->txrate.legacy = rtw_get_cur_max_rate(padapter);
+
+		sinfo->filled |= STATION_INFO_RX_PACKETS;
+		sinfo->rx_packets = sta_rx_data_pkts(psta);
+
+		sinfo->filled |= STATION_INFO_TX_PACKETS;
+		sinfo->tx_packets = psta->sta_stats.tx_pkts;
+
+	}
+
+	//for Ad-Hoc/AP mode
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)
+			||check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)
+			||check_fwstate(pmlmepriv, WIFI_AP_STATE))
+		&& check_fwstate(pmlmepriv, _FW_LINKED)
+	)
+	{
+		//TODO: should acquire station info...
+	}
+
+exit:
+	return ret;
+}
+
+extern int netdev_open(struct net_device *pnetdev);
+#ifdef CONFIG_CONCURRENT_MODE
+extern int netdev_if2_open(struct net_device *pnetdev);
+#endif
+
+/*
+enum nl80211_iftype {
+	NL80211_IFTYPE_UNSPECIFIED,
+       NL80211_IFTYPE_ADHOC, //1
+       NL80211_IFTYPE_STATION, //2
+       NL80211_IFTYPE_AP, //3
+       NL80211_IFTYPE_AP_VLAN,
+       NL80211_IFTYPE_WDS,
+       NL80211_IFTYPE_MONITOR, //6
+       NL80211_IFTYPE_MESH_POINT,
+       NL80211_IFTYPE_P2P_CLIENT, //8
+	NL80211_IFTYPE_P2P_GO, //9
+       //keep last 
+       NUM_NL80211_IFTYPES,
+       NL80211_IFTYPE_MAX = NUM_NL80211_IFTYPES - 1
+};
+*/
+static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
+				     struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+				     enum nl80211_iftype type,
+#else
+				     enum nl80211_iftype type, u32 *flags,
+#endif
+				     struct vif_params *params)
+{
+	enum nl80211_iftype old_type;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct wireless_dev *rtw_wdev = padapter->rtw_wdev;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+#ifdef CONFIG_P2P
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+#endif
+	int ret = 0;
+	u8 change = _FALSE;
+
+	DBG_871X(FUNC_NDEV_FMT" type=%d\n", FUNC_NDEV_ARG(ndev), type);
+
+	if(adapter_to_dvobj(padapter)->processing_dev_remove == _TRUE)
+	{
+		ret= -EPERM;
+		goto exit;
+	}		
+	
+#ifdef CONFIG_CONCURRENT_MODE
+	if(padapter->adapter_type == SECONDARY_ADAPTER)
+	{
+		DBG_871X(FUNC_NDEV_FMT" call netdev_if2_open\n", FUNC_NDEV_ARG(ndev));
+		if(netdev_if2_open(ndev) != 0) {
+			DBG_871X(FUNC_NDEV_FMT" call netdev_if2_open fail\n", FUNC_NDEV_ARG(ndev));
+			ret= -EPERM;
+			goto exit;
+		}
+	}
+	else if(padapter->adapter_type == PRIMARY_ADAPTER)
+#endif //CONFIG_CONCURRENT_MODE
+	{
+		DBG_871X(FUNC_NDEV_FMT" call netdev_open\n", FUNC_NDEV_ARG(ndev));
+		if(netdev_open(ndev) != 0) {
+			DBG_871X(FUNC_NDEV_FMT" call netdev_open fail\n", FUNC_NDEV_ARG(ndev));
+			ret= -EPERM;
+			goto exit;
+		}
+	}
+
+	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+		DBG_871X(FUNC_NDEV_FMT" call rtw_pwr_wakeup fail\n", FUNC_NDEV_ARG(ndev));
+		ret= -EPERM;
+		goto exit;
+	}
+
+	old_type = rtw_wdev->iftype;
+	DBG_871X(FUNC_NDEV_FMT" old_iftype=%d, new_iftype=%d\n",
+		FUNC_NDEV_ARG(ndev), old_type, type);
+
+	if(old_type != type)
+	{
+		change = _TRUE;
+		pmlmeext->action_public_rxseq = 0xffff;
+		pmlmeext->action_public_dialog_token = 0xff;
+	}	
+
+	/* initial default type */
+	ndev->type = ARPHRD_ETHER;
+
+	switch (type) {
+	case NL80211_IFTYPE_ADHOC:
+		networkType = Ndis802_11IBSS;
+		break;
+#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE))
+	case NL80211_IFTYPE_P2P_CLIENT:
+#endif
+	case NL80211_IFTYPE_STATION:
+		networkType = Ndis802_11Infrastructure;
+		#ifdef CONFIG_P2P
+		if(pwdinfo->driver_interface == DRIVER_CFG80211 )
+		{
+			if(change && rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+			{
+				//it means remove GO and change mode from AP(GO) to station(P2P DEVICE)
+				rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
+				rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
+
+				DBG_8192C("%s, role=%d, p2p_state=%d, pre_p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo), rtw_p2p_pre_state(pwdinfo));
+			}
+			#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
+			if (type == NL80211_IFTYPE_P2P_CLIENT)
+				rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
+			else {
+				/* NL80211_IFTYPE_STATION */
+				if (rtw_p2p_role(pwdinfo) == P2P_ROLE_CLIENT)
+					rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
+			}
+			#endif
+		}
+		#endif //CONFIG_P2P
+		break;
+#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE))
+	case NL80211_IFTYPE_P2P_GO:
+#endif
+	case NL80211_IFTYPE_AP:
+		networkType = Ndis802_11APMode;
+		#ifdef CONFIG_P2P
+		if(pwdinfo->driver_interface == DRIVER_CFG80211 )
+		{
+			if(change && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+			{
+				//it means P2P Group created, we will be GO and change mode from  P2P DEVICE to AP(GO)
+				rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
+			}
+		}
+		#endif //CONFIG_P2P
+		break;
+	case NL80211_IFTYPE_MONITOR:
+		networkType = Ndis802_11Monitor;
+#if 0
+		ndev->type = ARPHRD_IEEE80211; /* IEEE 802.11 : 801 */
+#endif
+		ndev->type = ARPHRD_IEEE80211_RADIOTAP; /* IEEE 802.11 + radiotap header : 803 */
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		goto exit;
+	}
+
+	rtw_wdev->iftype = type;
+	
+	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==_FALSE)
+	{
+		rtw_wdev->iftype = old_type;
+		ret = -EPERM;
+		goto exit;
+	}
+
+	rtw_setopmode_cmd(padapter, networkType, _TRUE);
+	
+exit:
+
+	DBG_871X(FUNC_NDEV_FMT" ret:%d\n", FUNC_NDEV_ARG(ndev), ret);
+	return ret;
+}
+
+void rtw_cfg80211_indicate_scan_done(_adapter *adapter, bool aborted)
+{
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(adapter);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 7, 0)
+	struct cfg80211_scan_info scan_info;
+#endif
+	_irqL	irqL;
+
+	_enter_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	if (pwdev_priv->scan_request != NULL) {
+		#ifdef CONFIG_DEBUG_CFG80211
+		DBG_871X("%s with scan req\n", __FUNCTION__);
+		#endif
+
+		/* avoid WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req); */
+		if(pwdev_priv->scan_request->wiphy != pwdev_priv->rtw_wdev->wiphy)
+		{
+			DBG_8192C("error wiphy compare\n");
+		}
+		else
+		{
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(4, 7, 0)
+			cfg80211_scan_done(pwdev_priv->scan_request, aborted);
+#else
+			memset(&scan_info, 0, sizeof(scan_info));
+			scan_info.aborted = aborted;
+			cfg80211_scan_done(pwdev_priv->scan_request, &scan_info);
+#endif
+		}
+
+		pwdev_priv->scan_request = NULL;
+	} else {
+		#ifdef CONFIG_DEBUG_CFG80211
+		DBG_871X("%s without scan req\n", __FUNCTION__);
+		#endif
+	}
+	_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+}
+
+u32 rtw_cfg80211_wait_scan_req_empty(_adapter *adapter, u32 timeout_ms)
+{
+	struct rtw_wdev_priv *wdev_priv = adapter_wdev_data(adapter);
+	u8 empty = _FALSE;
+	u32 start;
+	u32 pass_ms;
+
+	start = rtw_get_current_time();
+
+	while (rtw_get_passing_time_ms(start) <= timeout_ms) {
+
+		if (RTW_CANNOT_RUN(adapter))
+			break;
+
+		if (!wdev_priv->scan_request) {
+			empty = _TRUE;
+			break;
+		}
+
+		rtw_msleep_os(10);
+	}
+
+	pass_ms = rtw_get_passing_time_ms(start);
+
+	if (empty == _FALSE && pass_ms > timeout_ms)
+		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" pass_ms:%u, timeout\n"
+			, FUNC_ADPT_ARG(adapter), pass_ms);
+
+	return pass_ms;
+}
+
+void rtw_cfg80211_unlink_bss(_adapter *padapter, struct wlan_network *pnetwork)
+{
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+	struct wiphy *wiphy = pwdev->wiphy;
+	struct cfg80211_bss *bss = NULL;
+	WLAN_BSSID_EX select_network = pnetwork->network;
+	
+	bss = cfg80211_get_bss(wiphy, NULL/*notify_channel*/,
+		select_network.MacAddress, select_network.Ssid.Ssid,
+		select_network.Ssid.SsidLength, 0/*WLAN_CAPABILITY_ESS*/, 
+		0/*WLAN_CAPABILITY_ESS*/);
+	
+	if (bss) {
+		cfg80211_unlink_bss(wiphy, bss);
+		DBG_8192C("%s(): cfg80211_unlink %s!! () ",__func__,select_network.Ssid.Ssid );
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+		cfg80211_put_bss(padapter->rtw_wdev->wiphy, bss);
+#else
+		cfg80211_put_bss(bss);
+#endif
+	}
+	return;
+}
+
+void rtw_cfg80211_surveydone_event_callback(_adapter *padapter)
+{
+	_irqL	irqL;
+	_list					*plist, *phead;	
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+	_queue				*queue	= &(pmlmepriv->scanned_queue);	
+	struct	wlan_network	*pnetwork = NULL;
+	u32 cnt=0;
+	u32 wait_for_surveydone;
+	sint wait_status;
+#ifdef CONFIG_P2P
+	struct	wifidirect_info*	pwdinfo = &padapter->wdinfo;
+#endif //CONFIG_P2P
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(padapter);
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192C("%s\n", __func__);
+#endif
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+       
+	while(1)
+	{
+		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		//report network only if the current channel set contains the channel to which this network belongs
+		if(rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
+			&& rtw_mlme_band_check(padapter, pnetwork->network.Configuration.DSConfig) == _TRUE
+			&& _TRUE == rtw_validate_ssid(&(pnetwork->network.Ssid))
+		)
+		{		
+			//ev=translate_scan(padapter, a, pnetwork, ev, stop);
+			rtw_cfg80211_inform_bss(padapter, pnetwork);		
+		}
+		/* //check ralink testbed RSN IE length
+		{
+			if(_rtw_memcmp(pnetwork->network.Ssid.Ssid, "Ralink_11n_AP",13))
+			{
+				uint ie_len=0;
+				u8 *p=NULL;
+				p = rtw_get_ie(pnetwork->network.IEs + _BEACON_IE_OFFSET_, _RSN_IE_2_, &ie_len, (pnetwork->network.IELength - _BEACON_IE_OFFSET_));
+				DBG_871X("ie_len=%d\n", ie_len);
+			}
+		}*/
+		plist = get_next(plist);
+	
+	}
+	
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+}
+
+static int rtw_cfg80211_set_probe_req_wpsp2pie(_adapter *padapter, char *buf, int len)
+{
+	int ret = 0;
+	uint wps_ielen = 0;
+	u8 *wps_ie;
+	u32	p2p_ielen = 0;	
+	u8 *p2p_ie;
+	u32	wfd_ielen = 0;	
+	u8 *wfd_ie;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192C("%s, ielen=%d\n", __func__, len);
+#endif
+	
+	if(len>0)
+	{
+		if((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
+		{
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192C("probe_req_wps_ielen=%d\n", wps_ielen);
+			#endif
+			
+			if(pmlmepriv->wps_probe_req_ie)
+			{
+				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
+				pmlmepriv->wps_probe_req_ie_len = 0;
+				rtw_mfree(pmlmepriv->wps_probe_req_ie, free_len);
+				pmlmepriv->wps_probe_req_ie = NULL;			
+			}	
+
+			pmlmepriv->wps_probe_req_ie = rtw_malloc(wps_ielen);
+			if ( pmlmepriv->wps_probe_req_ie == NULL) {
+				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+				return -EINVAL;
+			
+			}
+			_rtw_memcpy(pmlmepriv->wps_probe_req_ie, wps_ie, wps_ielen);
+			pmlmepriv->wps_probe_req_ie_len = wps_ielen;
+		}
+
+		//buf += wps_ielen;
+		//len -= wps_ielen;
+
+		#ifdef CONFIG_P2P
+		if((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen))) 
+		{
+			struct wifidirect_info *wdinfo = &padapter->wdinfo;
+			u32 attr_contentlen = 0;
+			u8 listen_ch_attr[5];
+
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192C("probe_req_p2p_ielen=%d\n", p2p_ielen);
+			#endif
+			
+			if(pmlmepriv->p2p_probe_req_ie)
+			{
+				u32 free_len = pmlmepriv->p2p_probe_req_ie_len;
+				pmlmepriv->p2p_probe_req_ie_len = 0;
+				rtw_mfree(pmlmepriv->p2p_probe_req_ie, free_len);
+				pmlmepriv->p2p_probe_req_ie = NULL;
+			}	
+
+			pmlmepriv->p2p_probe_req_ie = rtw_malloc(p2p_ielen);
+			if ( pmlmepriv->p2p_probe_req_ie == NULL) {
+				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+				return -EINVAL;
+			
+			}
+			_rtw_memcpy(pmlmepriv->p2p_probe_req_ie, p2p_ie, p2p_ielen);
+			pmlmepriv->p2p_probe_req_ie_len = p2p_ielen;
+
+			if(rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_LISTEN_CH, (u8*)listen_ch_attr, (uint*) &attr_contentlen)
+				&& attr_contentlen == 5)
+			{
+				if (wdinfo->listen_channel !=  listen_ch_attr[4]) {
+					DBG_871X(FUNC_ADPT_FMT" listen channel - country:%c%c%c, class:%u, ch:%u\n",
+						FUNC_ADPT_ARG(padapter), listen_ch_attr[0], listen_ch_attr[1], listen_ch_attr[2],
+						listen_ch_attr[3], listen_ch_attr[4]);
+					wdinfo->listen_channel = listen_ch_attr[4];
+				}
+			}
+		}
+		#endif //CONFIG_P2P
+
+		#ifdef CONFIG_WFD
+		wfd_ie = rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen);
+		if (wfd_ie) {
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192C("probe_req_wfd_ielen=%d\n", wfd_ielen);
+			#endif
+
+			if (rtw_mlme_update_wfd_ie_data(pmlmepriv, MLME_PROBE_REQ_IE, wfd_ie, wfd_ielen) != _SUCCESS)
+				return -EINVAL;
+		}
+		#endif /* CONFIG_WFD */
+	}
+
+	return ret;
+	
+}
+
+static int cfg80211_rtw_scan(struct wiphy *wiphy
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+	, struct net_device *ndev
+	#endif
+	, struct cfg80211_scan_request *request)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct net_device *ndev = wdev_to_ndev(request->wdev);
+#endif
+	int i;
+	u8 _status = _FALSE;
+	int ret = 0;	
+	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
+	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
+	_irqL	irqL;
+	u8 *wps_ie=NULL;
+	uint wps_ielen=0;	
+	u8 *p2p_ie=NULL;
+	uint p2p_ielen=0;
+	u8 survey_times=3;
+	u8 survey_times_for_one_ch=6;
+	struct cfg80211_ssid *ssids = request->ssids;
+	int social_channel = 0, j = 0;
+	bool need_indicate_scan_done = _FALSE;
+	bool ps_denied = _FALSE;
+
+	_adapter *padapter;
+	struct rtw_wdev_priv *pwdev_priv;
+	struct mlme_priv *pmlmepriv;
+#ifdef CONFIG_P2P
+	struct wifidirect_info *pwdinfo;
+#endif //CONFIG_P2P
+#ifdef CONFIG_CONCURRENT_MODE	
+	PADAPTER pbuddy_adapter = NULL;
+	struct mlme_priv *pbuddy_mlmepriv = NULL;
+#endif //CONFIG_CONCURRENT_MODE
+
+	if (ndev == NULL) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	padapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(padapter);
+	pmlmepriv= &padapter->mlmepriv;
+#ifdef CONFIG_P2P
+	pwdinfo= &(padapter->wdinfo);	
+#endif //CONFIG_P2P
+
+//#ifdef CONFIG_DEBUG_CFG80211
+	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
+//#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->pbuddy_adapter) {
+		pbuddy_adapter = padapter->pbuddy_adapter;
+		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);	
+	}
+#endif //CONFIG_CONCURRENT_MODE
+
+#ifdef CONFIG_MP_INCLUDED
+if (padapter->registrypriv.mp_mode == 1)
+{
+		DBG_871X(FUNC_ADPT_FMT ": MP mode block Scan request\n", FUNC_ADPT_ARG(padapter));  
+		ret = -EPERM;
+		goto exit;
+}
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->pbuddy_adapter) {
+		if (padapter->pbuddy_adapter->registrypriv.mp_mode == 1)
+		{
+			DBG_871X(FUNC_ADPT_FMT ": MP mode block Scan request\n", FUNC_ADPT_ARG(padapter->pbuddy_adapter));
+			ret = -EPERM;
+			goto exit;
+		}
+	}
+#endif //CONFIG_CONCURRENT_MODE
+#endif
+
+	_enter_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	pwdev_priv->scan_request = request;
+	_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+
+	if (adapter_wdev_data(padapter)->block_scan == _TRUE) {
+		DBG_871X(FUNC_ADPT_FMT" wdev_priv.block_scan is set\n", FUNC_ADPT_ARG(padapter));
+		need_indicate_scan_done = _TRUE;
+		goto check_need_indicate_scan_done;
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	{
+#ifdef CONFIG_DEBUG_CFG80211
+		DBG_871X("%s under WIFI_AP_STATE\n", __FUNCTION__);
+#endif
+
+		if (check_fwstate(pmlmepriv, WIFI_UNDER_WPS|_FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+		{
+			DBG_8192C("%s, fwstate=0x%x\n", __func__, pmlmepriv->fw_state);
+
+			if(check_fwstate(pmlmepriv, WIFI_UNDER_WPS))
+			{
+				DBG_8192C("AP mode process WPS \n");
+			}
+			
+			need_indicate_scan_done = _TRUE;
+			goto check_need_indicate_scan_done;
+		} 
+	}
+
+	rtw_ps_deny(padapter, PS_DENY_SCAN);
+	ps_denied = _TRUE;
+	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+		need_indicate_scan_done = _TRUE;
+		goto check_need_indicate_scan_done;
+	}
+
+	#ifdef CONFIG_P2P
+	if( pwdinfo->driver_interface == DRIVER_CFG80211 )
+	{
+		if(ssids->ssid != NULL
+			&& _rtw_memcmp(ssids->ssid, "DIRECT-", 7)
+			&& rtw_get_p2p_ie((u8 *)request->ie, request->ie_len, NULL, NULL)
+		)
+		{
+			if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+			{
+				rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
+				adapter_wdev_data(padapter)->p2p_enabled = _TRUE;
+			}
+			else
+			{
+				rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
+				#ifdef CONFIG_DEBUG_CFG80211
+				DBG_8192C("%s, role=%d, p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo));
+				#endif
+			}
+			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
+		
+			if(request->n_channels == 3 &&
+				request->channels[0]->hw_value == 1 &&
+				request->channels[1]->hw_value == 6 &&
+				request->channels[2]->hw_value == 11
+			)
+			{
+				social_channel = 1;
+			}
+		}
+	}
+	#endif //CONFIG_P2P
+
+	if(request->ie && request->ie_len>0)
+	{
+		rtw_cfg80211_set_probe_req_wpsp2pie(padapter, (u8 *)request->ie, request->ie_len );
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
+		DBG_8192C("%s, fwstate=0x%x\n", __func__, pmlmepriv->fw_state);
+		need_indicate_scan_done = _TRUE;
+		goto check_need_indicate_scan_done;
+	} else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE) {
+		DBG_8192C("%s, fwstate=0x%x\n", __func__, pmlmepriv->fw_state);
+		ret = -EBUSY;
+		goto check_need_indicate_scan_done;
+	}
+
+	if (pmlmepriv->LinkDetectInfo.bBusyTraffic == _TRUE)
+	{
+#if 1 // Miracast can't do AP scan
+		static u32 lastscantime = 0;
+		u32 passtime;
+
+		passtime = rtw_get_passing_time_ms(lastscantime);
+		lastscantime = rtw_get_current_time();
+		if (passtime > BUSY_TRAFFIC_SCAN_DENY_PERIOD)
+#endif
+		{
+			DBG_871X("%s: bBusyTraffic == _TRUE\n", __FUNCTION__);
+			need_indicate_scan_done = _TRUE;
+			goto check_need_indicate_scan_done;
+		}
+	}
+
+	if (rtw_is_scan_deny(padapter)){
+		DBG_871X(FUNC_ADPT_FMT  ": scan deny\n", FUNC_ADPT_ARG(padapter));
+		need_indicate_scan_done = _TRUE;
+		goto check_need_indicate_scan_done;
+	}
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if(pbuddy_mlmepriv && (pbuddy_mlmepriv->LinkDetectInfo.bBusyTraffic == _TRUE))	
+	{
+#if 1 // Miracast can't do AP scan
+		static u32 buddylastscantime = 0;
+		u32 passtime;
+
+		passtime = rtw_get_passing_time_ms(buddylastscantime);
+		buddylastscantime = rtw_get_current_time();
+		if ((passtime > BUSY_TRAFFIC_SCAN_DENY_PERIOD)
+//#ifdef CONFIG_P2P
+//			||(!rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE))
+//#endif //CONFIG_P2P
+		)
+#endif
+		{
+			DBG_871X("%s: bBusyTraffic == _TRUE at buddy_intf\n", __FUNCTION__);
+			need_indicate_scan_done = _TRUE;
+			goto check_need_indicate_scan_done;
+		}
+	}
+
+	if (check_buddy_fwstate(padapter, _FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE) {
+		DBG_871X("buddy_intf's mlme state:0x%x\n", pbuddy_mlmepriv->fw_state);
+		need_indicate_scan_done = _TRUE;
+		goto check_need_indicate_scan_done;
+
+	} else if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY)) {
+		bool scan_via_buddy = _FALSE;
+		struct rtw_wdev_priv *buddy_wdev_priv = adapter_wdev_data(pbuddy_adapter);
+
+		_enter_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+		_enter_critical_bh(&buddy_wdev_priv->scan_req_lock, &irqL);
+		if (buddy_wdev_priv->scan_request) {
+			DBG_871X("scan via buddy\n");
+			pmlmepriv->scanning_via_buddy_intf = _TRUE;
+			_enter_critical_bh(&pmlmepriv->lock, &irqL);
+			set_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+			_exit_critical_bh(&pmlmepriv->lock, &irqL);
+			scan_via_buddy = _TRUE;
+		}
+		_exit_critical_bh(&buddy_wdev_priv->scan_req_lock, &irqL);
+		_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+
+		if (scan_via_buddy == _FALSE)
+			need_indicate_scan_done = _TRUE;
+
+		goto check_need_indicate_scan_done;
+	}
+#endif /* CONFIG_CONCURRENT_MODE */
+
+#ifdef CONFIG_P2P
+	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
+	{
+		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
+		rtw_free_network_queue(padapter, _TRUE);
+
+		if(social_channel == 0)
+			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
+		else
+			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_SOCIAL_LAST);
+	}
+#endif //CONFIG_P2P
+
+
+	_rtw_memset(ssid, 0, sizeof(NDIS_802_11_SSID)*RTW_SSID_SCAN_AMOUNT);
+	//parsing request ssids, n_ssids
+	for (i = 0; i < request->n_ssids && i < RTW_SSID_SCAN_AMOUNT; i++) {
+		#ifdef CONFIG_DEBUG_CFG80211
+		DBG_8192C("ssid=%s, len=%d\n", ssids[i].ssid, ssids[i].ssid_len);
+		#endif
+		_rtw_memcpy(ssid[i].Ssid, ssids[i].ssid, ssids[i].ssid_len);
+		ssid[i].SsidLength = ssids[i].ssid_len;	
+	}
+
+	/* parsing channels, n_channels */
+	_rtw_memset(ch, 0, sizeof(struct rtw_ieee80211_channel)*RTW_CHANNEL_SCAN_AMOUNT);
+	for (i=0;i<request->n_channels && i<RTW_CHANNEL_SCAN_AMOUNT;i++) {
+		#ifdef CONFIG_DEBUG_CFG80211
+		DBG_871X(FUNC_ADPT_FMT CHAN_FMT"\n", FUNC_ADPT_ARG(padapter), CHAN_ARG(request->channels[i]));
+		#endif
+		ch[i].hw_value = request->channels[i]->hw_value;
+		ch[i].flags = request->channels[i]->flags;
+	}
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	if (request->n_channels == 1) {
+		for(i=1;i<survey_times_for_one_ch;i++)
+			_rtw_memcpy(&ch[i], &ch[0], sizeof(struct rtw_ieee80211_channel));
+		_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, ch, survey_times_for_one_ch);
+	} else if (request->n_channels <= 4) {
+		for(j=request->n_channels-1;j>=0;j--)
+			for(i=0;i<survey_times;i++)
+		{
+			_rtw_memcpy(&ch[j*survey_times+i], &ch[j], sizeof(struct rtw_ieee80211_channel));
+		}
+		_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, ch, survey_times * request->n_channels);
+	} else {
+		_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, NULL, 0);
+	}
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+
+
+	if(_status == _FALSE)
+	{
+		ret = -1;
+	}
+
+check_need_indicate_scan_done:
+	if (_TRUE == need_indicate_scan_done)
+	{
+		rtw_cfg80211_surveydone_event_callback(padapter);
+		rtw_cfg80211_indicate_scan_done(padapter, _FALSE);
+	}
+
+cancel_ps_deny:
+	if (ps_denied == _TRUE)
+		rtw_ps_deny_cancel(padapter, PS_DENY_SCAN);
+
+exit:
+	return ret;
+	
+}
+
+static int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy, u32 changed)
+{
+#if 0
+	struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
+
+	if (changed & WIPHY_PARAM_RTS_THRESHOLD &&
+	    (iwm->conf.rts_threshold != wiphy->rts_threshold)) {
+		int ret;
+
+		iwm->conf.rts_threshold = wiphy->rts_threshold;
+
+		ret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,
+					     CFG_RTS_THRESHOLD,
+					     iwm->conf.rts_threshold);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (changed & WIPHY_PARAM_FRAG_THRESHOLD &&
+	    (iwm->conf.frag_threshold != wiphy->frag_threshold)) {
+		int ret;
+
+		iwm->conf.frag_threshold = wiphy->frag_threshold;
+
+		ret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_FA_CFG_FIX,
+					     CFG_FRAG_THRESHOLD,
+					     iwm->conf.frag_threshold);
+		if (ret < 0)
+			return ret;
+	}
+#endif
+	DBG_8192C("%s\n", __func__);
+	return 0;
+}
+
+
+
+static int rtw_cfg80211_set_wpa_version(struct security_priv *psecuritypriv, u32 wpa_version)
+{	
+	DBG_8192C("%s, wpa_version=%d\n", __func__, wpa_version);
+	
+	if (!wpa_version) {		
+		psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;		
+		return 0;
+	}
+
+
+	if (wpa_version & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))
+	{		
+		psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPAPSK;		
+	}
+
+/*
+	if (wpa_version & NL80211_WPA_VERSION_2)
+	{		
+		psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPA2PSK;
+	}
+*/
+
+	#ifdef CONFIG_WAPI_SUPPORT
+	if (wpa_version & NL80211_WAPI_VERSION_1)
+	{
+		psecuritypriv->ndisauthtype = Ndis802_11AuthModeWAPI;
+	}
+	#endif
+
+	return 0;
+
+}
+
+static int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv,
+			     enum nl80211_auth_type sme_auth_type)
+{
+	DBG_8192C("%s, nl80211_auth_type=%d\n", __func__, sme_auth_type);
+
+
+	switch (sme_auth_type) {
+	case NL80211_AUTHTYPE_AUTOMATIC:
+
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+
+		break;
+	case NL80211_AUTHTYPE_OPEN_SYSTEM:
+	
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+
+		if(psecuritypriv->ndisauthtype>Ndis802_11AuthModeWPA)
+			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+		
+#ifdef CONFIG_WAPI_SUPPORT
+		if(psecuritypriv->ndisauthtype == Ndis802_11AuthModeWAPI)
+			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_WAPI;
+#endif
+
+		break;
+	case NL80211_AUTHTYPE_SHARED_KEY:
+
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;
+
+		psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
+
+
+		break;
+	default:		
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+		//return -ENOTSUPP;
+	}
+
+	return 0;
+
+}
+
+static int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv, u32 cipher, bool ucast)
+{
+	u32 ndisencryptstatus = Ndis802_11EncryptionDisabled;
+
+	u32 *profile_cipher = ucast ? &psecuritypriv->dot11PrivacyAlgrthm :
+		&psecuritypriv->dot118021XGrpPrivacy;
+
+	DBG_8192C("%s, ucast=%d, cipher=0x%x\n", __func__, ucast, cipher);
+
+
+	if (!cipher) {
+		*profile_cipher = _NO_PRIVACY_;
+		psecuritypriv->ndisencryptstatus = ndisencryptstatus;
+		return 0;
+	}
+	
+	switch (cipher) {
+	case IW_AUTH_CIPHER_NONE:
+		*profile_cipher = _NO_PRIVACY_;
+		ndisencryptstatus = Ndis802_11EncryptionDisabled;
+#ifdef CONFIG_WAPI_SUPPORT
+		if(psecuritypriv->dot11PrivacyAlgrthm ==_SMS4_ )
+		{
+			*profile_cipher = _SMS4_;
+		}
+#endif
+		break;
+	case WLAN_CIPHER_SUITE_WEP40:
+		*profile_cipher = _WEP40_;
+		ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		break;
+	case WLAN_CIPHER_SUITE_WEP104:
+		*profile_cipher = _WEP104_;
+		ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		*profile_cipher = _TKIP_;
+		ndisencryptstatus = Ndis802_11Encryption2Enabled;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		*profile_cipher = _AES_;
+		ndisencryptstatus = Ndis802_11Encryption3Enabled;
+		break;
+#ifdef CONFIG_WAPI_SUPPORT
+	case WLAN_CIPHER_SUITE_SMS4:
+		*profile_cipher = _SMS4_;
+		ndisencryptstatus = Ndis802_11_EncrypteionWAPI;
+		break;
+#endif
+	default:
+		DBG_8192C("Unsupported cipher: 0x%x\n", cipher);
+		return -ENOTSUPP;
+	}
+
+	if(ucast)
+	{
+		psecuritypriv->ndisencryptstatus = ndisencryptstatus;
+		
+		//if(psecuritypriv->dot11PrivacyAlgrthm >= _AES_)
+		//	psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPA2PSK;
+	}	
+
+	return 0;
+}
+
+static int rtw_cfg80211_set_key_mgt(struct security_priv *psecuritypriv, u32 key_mgt)
+{
+	DBG_8192C("%s, key_mgt=0x%x\n", __func__, key_mgt);
+
+	if (key_mgt == WLAN_AKM_SUITE_8021X)
+		//*auth_type = UMAC_AUTH_TYPE_8021X;
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+	else if (key_mgt == WLAN_AKM_SUITE_PSK) {
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+	}
+#ifdef CONFIG_WAPI_SUPPORT
+	else if(key_mgt ==WLAN_AKM_SUITE_WAPI_PSK){
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_WAPI;
+	}
+	else if(key_mgt ==WLAN_AKM_SUITE_WAPI_CERT){
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_WAPI;
+	}
+#endif
+
+
+	else {
+		DBG_8192C("Invalid key mgt: 0x%x\n", key_mgt);
+		//return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rtw_cfg80211_set_wpa_ie(_adapter *padapter, u8 *pie, size_t ielen)
+{
+	u8 *buf=NULL, *pos=NULL;	
+	u32 left; 	
+	int group_cipher = 0, pairwise_cipher = 0;
+	int ret = 0;
+	int wpa_ielen=0;
+	int wpa2_ielen=0;
+	u8 *pwpa, *pwpa2;
+	u8 null_addr[]= {0,0,0,0,0,0};
+
+	if (pie == NULL || !ielen) {
+		/* Treat this as normal case, but need to clear WIFI_UNDER_WPS */
+		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
+		goto exit;
+	}
+
+	if (ielen > MAX_WPA_IE_LEN+MAX_WPS_IE_LEN+MAX_P2P_IE_LEN) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	buf = rtw_zmalloc(ielen);
+	if (buf == NULL){
+		ret =  -ENOMEM;
+		goto exit;
+	}
+
+	_rtw_memcpy(buf, pie , ielen);
+
+	//dump
+	{
+		int i;
+		DBG_8192C("set wpa_ie(length:%zu):\n", ielen);
+		for(i=0;i<ielen;i=i+8)
+			DBG_8192C("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x \n",buf[i],buf[i+1],buf[i+2],buf[i+3],buf[i+4],buf[i+5],buf[i+6],buf[i+7]);
+	}
+
+	pos = buf;
+	if(ielen < RSN_HEADER_LEN){
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie len too short %d\n", ielen));
+		ret  = -1;
+		goto exit;
+	}
+
+	pwpa = rtw_get_wpa_ie(buf, &wpa_ielen, ielen);
+	if(pwpa && wpa_ielen>0)
+	{
+		if(rtw_parse_wpa_ie(pwpa, wpa_ielen+2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS)
+		{
+			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPAPSK;
+			_rtw_memcpy(padapter->securitypriv.supplicant_ie, &pwpa[0], wpa_ielen+2);
+			
+			DBG_8192C("got wpa_ie, wpa_ielen:%u\n", wpa_ielen);
+		}
+	}
+
+	pwpa2 = rtw_get_wpa2_ie(buf, &wpa2_ielen, ielen);
+	if(pwpa2 && wpa2_ielen>0)
+	{
+		if(rtw_parse_wpa2_ie(pwpa2, wpa2_ielen+2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS)
+		{
+			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPA2PSK;	
+			_rtw_memcpy(padapter->securitypriv.supplicant_ie, &pwpa2[0], wpa2_ielen+2);
+
+			DBG_8192C("got wpa2_ie, wpa2_ielen:%u\n", wpa2_ielen);
+		}
+	}
+
+	if (group_cipher == 0)
+	{
+		group_cipher = WPA_CIPHER_NONE;
+	}
+	if (pairwise_cipher == 0)
+	{
+		pairwise_cipher = WPA_CIPHER_NONE;
+	}
+	
+	switch(group_cipher)
+	{
+		case WPA_CIPHER_NONE:
+			padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+			padapter->securitypriv.ndisencryptstatus=Ndis802_11EncryptionDisabled;
+			break;
+		case WPA_CIPHER_WEP40:
+			padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;
+			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			break;
+		case WPA_CIPHER_TKIP:
+			padapter->securitypriv.dot118021XGrpPrivacy=_TKIP_;
+			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+			break;
+		case WPA_CIPHER_CCMP:
+			padapter->securitypriv.dot118021XGrpPrivacy=_AES_;
+			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+			break;
+		case WPA_CIPHER_WEP104:	
+			padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			break;
+	}
+
+	switch(pairwise_cipher)
+	{
+		case WPA_CIPHER_NONE:
+			padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+			padapter->securitypriv.ndisencryptstatus=Ndis802_11EncryptionDisabled;
+			break;
+		case WPA_CIPHER_WEP40:
+			padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			break;
+		case WPA_CIPHER_TKIP:
+			padapter->securitypriv.dot11PrivacyAlgrthm=_TKIP_;
+			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+			break;
+		case WPA_CIPHER_CCMP:
+			padapter->securitypriv.dot11PrivacyAlgrthm=_AES_;
+			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+			break;
+		case WPA_CIPHER_WEP104:	
+			padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			break;
+	}
+	
+	{/* handle wps_ie */
+		uint wps_ielen;	
+		u8 *wps_ie;
+
+		wps_ie = rtw_get_wps_ie(buf, ielen, NULL, &wps_ielen);
+		if (wps_ie && wps_ielen > 0) {
+			DBG_8192C("got wps_ie, wps_ielen:%u\n", wps_ielen);
+			padapter->securitypriv.wps_ie_len = wps_ielen<MAX_WPS_IE_LEN?wps_ielen:MAX_WPS_IE_LEN;
+			_rtw_memcpy(padapter->securitypriv.wps_ie, wps_ie, padapter->securitypriv.wps_ie_len);
+			set_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS);
+		} else {
+			_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
+		}
+	}
+
+	#ifdef CONFIG_P2P
+	{//check p2p_ie for assoc req; 
+		uint p2p_ielen=0;
+		u8 *p2p_ie;
+		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+		if((p2p_ie=rtw_get_p2p_ie(buf, ielen, NULL, &p2p_ielen)))
+		{
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192C("%s p2p_assoc_req_ielen=%d\n", __FUNCTION__, p2p_ielen);
+			#endif
+
+			if(pmlmepriv->p2p_assoc_req_ie)
+			{
+				u32 free_len = pmlmepriv->p2p_assoc_req_ie_len;
+				pmlmepriv->p2p_assoc_req_ie_len = 0;
+				rtw_mfree(pmlmepriv->p2p_assoc_req_ie, free_len);
+				pmlmepriv->p2p_assoc_req_ie = NULL;
+			}
+
+			pmlmepriv->p2p_assoc_req_ie = rtw_malloc(p2p_ielen);
+			if ( pmlmepriv->p2p_assoc_req_ie == NULL) {
+				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+				goto exit;
+			}
+			_rtw_memcpy(pmlmepriv->p2p_assoc_req_ie, p2p_ie, p2p_ielen);
+			pmlmepriv->p2p_assoc_req_ie_len = p2p_ielen;
+		}
+	}
+	#endif //CONFIG_P2P
+
+	#ifdef CONFIG_WFD
+	{
+		uint wfd_ielen=0;
+		u8 *wfd_ie;
+		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+		wfd_ie = rtw_get_wfd_ie(buf, ielen, NULL, &wfd_ielen);
+		if (wfd_ie) {
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192C("%s wfd_assoc_req_ielen=%d\n", __FUNCTION__, wfd_ielen);
+			#endif
+
+			if (rtw_mlme_update_wfd_ie_data(pmlmepriv, MLME_ASSOC_REQ_IE, wfd_ie, wfd_ielen) != _SUCCESS)
+				goto exit;
+		}
+	}
+	#endif /* CONFIG_WFD */
+
+	//TKIP and AES disallow multicast packets until installing group key
+	if(padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_
+		|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_
+		|| padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
+		//WPS open need to enable multicast
+		//|| check_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS) == _TRUE)
+		rtw_hal_set_hwreg(padapter, HW_VAR_OFF_RCR_AM, null_addr);
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		("rtw_set_wpa_ie: pairwise_cipher=0x%08x padapter->securitypriv.ndisencryptstatus=%d padapter->securitypriv.ndisauthtype=%d\n",
+		pairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype));
+
+exit:
+	if (buf)
+		rtw_mfree(buf, ielen);
+	if (ret)
+		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
+	return ret;
+}
+
+static int cfg80211_rtw_join_ibss(struct wiphy *wiphy, struct net_device *ndev,
+				  struct cfg80211_ibss_params *params)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	NDIS_802_11_SSID ndis_ssid;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX *pnetwork = (WLAN_BSSID_EX *)(&(pmlmeinfo->network));
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
+	struct cfg80211_chan_def *pch_def;
+#endif
+	struct ieee80211_channel *pch;
+	int ret=0;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
+	pch_def = (struct cfg80211_chan_def *)(&params->chandef); 
+	pch = (struct ieee80211_channel *) pch_def->chan;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31))
+	pch = (struct ieee80211_channel *)(params->channel); 
+#endif
+	
+	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+		ret= -EPERM;
+		goto exit;
+	}
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		ret = -EPERM;
+		goto exit;
+	}
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_UNDER_LINKING) == _TRUE) {
+		DBG_8192C("%s, but buddy_intf is under linking\n", __FUNCTION__);
+		ret = -EINVAL;
+		goto exit;
+	}
+	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY) == _TRUE) {
+		rtw_scan_abort(padapter->pbuddy_adapter);
+	}
+#endif //CONFIG_CONCURRENT_MODE
+	
+	if (!params->ssid || !params->ssid_len)
+	{
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (params->ssid_len > IW_ESSID_MAX_SIZE){
+
+		ret= -E2BIG;
+		goto exit;
+	}
+	
+	_rtw_memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));			
+	ndis_ssid.SsidLength = params->ssid_len;
+	_rtw_memcpy(ndis_ssid.Ssid, (u8 *)params->ssid, params->ssid_len);
+
+	//DBG_8192C("ssid=%s, len=%zu\n", ndis_ssid.Ssid, params->ssid_len);
+	
+	psecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;
+	psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+	psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; //open system
+	psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;
+	
+	ret = rtw_cfg80211_set_auth_type(psecuritypriv, NL80211_AUTHTYPE_OPEN_SYSTEM);
+	rtw_set_802_11_authentication_mode(padapter, psecuritypriv->ndisauthtype);
+
+	DBG_871X("%s: center_freq = %d\n", __func__, pch->center_freq);
+	pmlmeext->cur_channel = rtw_freq2ch(pch->center_freq);
+	
+	if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == _FALSE) 
+	{
+		ret = -1;
+		goto exit;
+	}	
+	
+exit:
+	return ret;
+}
+
+static int cfg80211_rtw_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct wireless_dev *rtw_wdev = padapter->rtw_wdev;
+	enum nl80211_iftype old_type;
+	int ret = 0;
+
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	padapter->mlmepriv.not_indic_disco = _TRUE;
+	
+	old_type = rtw_wdev->iftype;
+	
+	rtw_set_to_roam(padapter, 0);
+
+	if(check_fwstate(&padapter->mlmepriv, _FW_LINKED)) 
+	{
+		rtw_scan_abort(padapter);
+		LeaveAllPowerSaveMode(padapter);
+		
+		rtw_wdev->iftype = NL80211_IFTYPE_STATION;
+		
+		if (rtw_set_802_11_infrastructure_mode(padapter, Ndis802_11Infrastructure) ==_FALSE)
+		{
+			rtw_wdev->iftype = old_type;
+			ret = -EPERM;
+			goto leave_ibss;
+		}
+		rtw_setopmode_cmd(padapter, Ndis802_11Infrastructure,_TRUE);	
+	}
+
+leave_ibss:
+	padapter->mlmepriv.not_indic_disco = _FALSE;
+
+	return 0;
+}
+
+static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
+				 struct cfg80211_connect_params *sme)
+{
+	int ret=0;
+	_irqL irqL;	
+	_list *phead;	
+	struct wlan_network *pnetwork = NULL;
+	NDIS_802_11_AUTHENTICATION_MODE authmode;	
+	NDIS_802_11_SSID ndis_ssid;	
+	u8 *dst_ssid, *src_ssid;
+	u8 *dst_bssid, *src_bssid;
+	//u8 matched_by_bssid=_FALSE;
+	//u8 matched_by_ssid=_FALSE;
+	u8 matched=_FALSE;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;	
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	_queue *queue = &pmlmepriv->scanned_queue;	
+
+	padapter->mlmepriv.not_indic_disco = _TRUE;
+	
+	DBG_871X("=>"FUNC_NDEV_FMT" - Start to Connection\n", FUNC_NDEV_ARG(ndev));
+	DBG_871X("privacy=%d, key=%p, key_len=%d, key_idx=%d\n",
+		sme->privacy, sme->key, sme->key_len, sme->key_idx);
+
+
+	if(adapter_wdev_data(padapter)->block == _TRUE)
+	{
+		ret = -EBUSY;
+		DBG_871X("%s wdev_priv.block is set\n", __FUNCTION__);
+		goto exit;
+	}
+
+#ifdef CONFIG_PLATFORM_MSTAR_SCAN_BEFORE_CONNECT
+	printk("MStar Android!\n");
+	if(adapter_wdev_data(padapter)->bandroid_scan == _FALSE)
+	{
+#ifdef CONFIG_P2P
+		struct wifidirect_info *pwdinfo= &(padapter->wdinfo);	
+		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+#endif //CONFIG_P2P
+		{
+			ret = -EBUSY;
+			printk("Android hasn't attached yet!\n");
+			goto exit;
+		}	
+	}
+#endif
+
+	rtw_ps_deny(padapter, PS_DENY_JOIN);
+	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+		ret= -EPERM;
+		goto exit;
+	}
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		ret = -EPERM;
+		goto exit;
+	}
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_UNDER_LINKING) == _TRUE) {
+		DBG_8192C("%s, but buddy_intf is under linking\n", __FUNCTION__);
+		ret = -EINVAL;
+		goto exit;
+	}
+	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY) == _TRUE) {
+		rtw_scan_abort(padapter->pbuddy_adapter);
+	}
+#endif
+
+	if (!sme->ssid || !sme->ssid_len)
+	{
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (sme->ssid_len > IW_ESSID_MAX_SIZE){
+
+		ret= -E2BIG;
+		goto exit;
+	}
+	
+	_rtw_memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));			
+	ndis_ssid.SsidLength = sme->ssid_len;
+	_rtw_memcpy(ndis_ssid.Ssid, (u8 *)sme->ssid, sme->ssid_len);
+
+	DBG_8192C("ssid=%s, len=%zu\n", ndis_ssid.Ssid, sme->ssid_len);
+	
+
+	if (sme->bssid)
+		DBG_8192C("bssid="MAC_FMT"\n", MAC_ARG(sme->bssid));
+
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE) {
+		ret = -EBUSY;
+		DBG_8192C("%s, fw_state=0x%x, goto exit\n", __FUNCTION__, pmlmepriv->fw_state);
+		goto exit;		
+	}
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
+		rtw_scan_abort(padapter);
+	}
+
+	psecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;
+	psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+	psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; //open system
+	psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;
+
+#ifdef CONFIG_WAPI_SUPPORT
+	 padapter->wapiInfo.bWapiEnable = false;
+#endif
+
+	ret = rtw_cfg80211_set_wpa_version(psecuritypriv, sme->crypto.wpa_versions);
+	if (ret < 0)
+		goto exit;
+
+#ifdef CONFIG_WAPI_SUPPORT
+	if(sme->crypto.wpa_versions & NL80211_WAPI_VERSION_1)
+	{
+		padapter->wapiInfo.bWapiEnable = true;
+		padapter->wapiInfo.extra_prefix_len = WAPI_EXT_LEN;
+		padapter->wapiInfo.extra_postfix_len = SMS4_MIC_LEN;
+	}
+#endif
+
+	ret = rtw_cfg80211_set_auth_type(psecuritypriv, sme->auth_type);
+
+#ifdef CONFIG_WAPI_SUPPORT
+	if(psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_WAPI)
+		padapter->mlmeextpriv.mlmext_info.auth_algo = psecuritypriv->dot11AuthAlgrthm;
+#endif
+
+
+	if (ret < 0)
+		goto exit;
+
+	DBG_8192C("%s, ie_len=%zu\n", __func__, sme->ie_len);
+			
+	ret = rtw_cfg80211_set_wpa_ie(padapter, (u8 *)sme->ie, sme->ie_len);
+	if (ret < 0)
+		goto exit;
+
+	if (sme->crypto.n_ciphers_pairwise) {		
+		ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.ciphers_pairwise[0], _TRUE);
+		if (ret < 0)
+			goto exit;
+	}
+
+	//For WEP Shared auth
+	if((psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Shared
+		|| psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Auto) && sme->key
+	)
+	{
+		u32 wep_key_idx, wep_key_len,wep_total_len;
+		NDIS_802_11_WEP	 *pwep = NULL;
+		DBG_871X("%s(): Shared/Auto WEP\n",__FUNCTION__);
+
+		wep_key_idx = sme->key_idx;
+		wep_key_len = sme->key_len;
+
+		if (sme->key_idx > WEP_KEYS) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		if (wep_key_len > 0) 
+		{
+		 	wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+		 	pwep =(NDIS_802_11_WEP	 *) rtw_malloc(wep_total_len);
+			if(pwep == NULL){
+				DBG_871X(" wpa_set_encryption: pwep allocate fail !!!\n");
+				ret = -ENOMEM;
+				goto exit;
+			}
+
+		 	_rtw_memset(pwep, 0, wep_total_len);
+
+		 	pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_total_len;
+
+			if(wep_key_len==13)
+			{
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+			}
+		}
+		else {		
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		pwep->KeyIndex = wep_key_idx;
+		pwep->KeyIndex |= 0x80000000;
+
+		_rtw_memcpy(pwep->KeyMaterial,  (void *)sme->key, pwep->KeyLength);
+
+		if(rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
+		{
+			ret = -EOPNOTSUPP ;
+		}
+
+		if (pwep) {
+			rtw_mfree((u8 *)pwep,wep_total_len);		
+		}
+
+		if(ret < 0)
+			goto exit;
+	}
+
+	ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.cipher_group, _FALSE);
+	if (ret < 0)
+		return ret;
+
+	if (sme->crypto.n_akm_suites) {
+		ret = rtw_cfg80211_set_key_mgt(psecuritypriv, sme->crypto.akm_suites[0]);
+		if (ret < 0)
+			goto exit;
+	}
+
+#ifdef CONFIG_WAPI_SUPPORT
+      if(sme->crypto.akm_suites[0] ==WLAN_AKM_SUITE_WAPI_PSK){
+		padapter->wapiInfo.bWapiPSK = true;
+	}
+	else if(sme->crypto.akm_suites[0] ==WLAN_AKM_SUITE_WAPI_CERT){
+	      padapter->wapiInfo.bWapiPSK = false;
+	}
+#endif
+
+	authmode = psecuritypriv->ndisauthtype;
+	rtw_set_802_11_authentication_mode(padapter, authmode);
+
+	//rtw_set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
+
+	if (rtw_set_802_11_connect(padapter, (u8 *)sme->bssid, &ndis_ssid) == _FALSE) {
+		ret = -1;
+		goto exit;
+	}
+
+	DBG_8192C("set ssid:dot11AuthAlgrthm=%d, dot11PrivacyAlgrthm=%d, dot118021XGrpPrivacy=%d\n", psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm, psecuritypriv->dot118021XGrpPrivacy);
+	
+exit:
+
+	rtw_ps_deny_cancel(padapter, PS_DENY_JOIN);
+
+	DBG_8192C("<=%s, ret %d\n",__FUNCTION__, ret);
+
+	padapter->mlmepriv.not_indic_disco = _FALSE;
+
+	return ret;
+}
+
+static int cfg80211_rtw_disconnect(struct wiphy *wiphy, struct net_device *ndev,
+				   u16 reason_code)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+
+	DBG_871X(FUNC_NDEV_FMT" - Start to Disconnect\n", FUNC_NDEV_ARG(ndev));
+
+	padapter->mlmepriv.not_indic_disco = _TRUE;
+
+	rtw_set_to_roam(padapter, 0);
+
+	//if(check_fwstate(&padapter->mlmepriv, _FW_LINKED))
+	{
+		rtw_scan_abort(padapter);
+		LeaveAllPowerSaveMode(padapter);
+		rtw_disassoc_cmd(padapter, 500, _FALSE);
+		
+		DBG_871X("%s...call rtw_indicate_disconnect\n", __FUNCTION__);
+		
+		rtw_indicate_disconnect(padapter);
+		
+		rtw_free_assoc_resources(padapter, 1);
+		rtw_pwr_wakeup(padapter);		
+	}
+
+	padapter->mlmepriv.not_indic_disco = _FALSE;
+
+	DBG_871X(FUNC_NDEV_FMT" return 0\n", FUNC_NDEV_ARG(ndev));
+	return 0;
+}
+
+static int cfg80211_rtw_set_txpower(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0))
+	struct wireless_dev *wdev,
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)) || defined(COMPAT_KERNEL_RELEASE)
+	enum nl80211_tx_power_setting type, int mbm)
+#else
+	enum tx_power_setting type, int dbm)
+#endif
+{
+#if 0
+	struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
+	int ret;
+
+	switch (type) {
+	case NL80211_TX_POWER_AUTOMATIC:
+		return 0;
+	case NL80211_TX_POWER_FIXED:
+		if (mbm < 0 || (mbm % 100))
+			return -EOPNOTSUPP;
+
+		if (!test_bit(IWM_STATUS_READY, &iwm->status))
+			return 0;
+
+		ret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,
+					      CFG_TX_PWR_LIMIT_USR,
+					      MBM_TO_DBM(mbm) * 2);
+		if (ret < 0)
+			return ret;
+
+		return iwm_tx_power_trigger(iwm);
+	default:
+		IWM_ERR(iwm, "Unsupported power type: %d\n", type);
+		return -EOPNOTSUPP;
+	}
+#endif
+	DBG_8192C("%s\n", __func__);
+	return 0;
+}
+
+static int cfg80211_rtw_get_txpower(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0))
+	struct wireless_dev *wdev,
+#endif
+	int *dbm)
+{
+	DBG_8192C("%s\n", __func__);
+
+	*dbm = (12);
+	
+	return 0;
+}
+
+inline bool rtw_cfg80211_pwr_mgmt(_adapter *adapter)
+{
+	struct rtw_wdev_priv *rtw_wdev_priv = adapter_wdev_data(adapter);
+	return rtw_wdev_priv->power_mgmt;
+}
+
+static int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy,
+				       struct net_device *ndev,
+				       bool enabled, int timeout)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct rtw_wdev_priv *rtw_wdev_priv = adapter_wdev_data(padapter);
+	
+	DBG_871X(FUNC_NDEV_FMT" enabled:%u, timeout:%d\n", FUNC_NDEV_ARG(ndev),
+		enabled, timeout);
+
+	rtw_wdev_priv->power_mgmt = enabled;
+
+	#ifdef CONFIG_LPS
+	if (!enabled)
+		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_LEAVE_CFG80211_PWRMGMT, 1);
+	#endif
+
+	return 0;
+}
+
+static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
+				  struct net_device *ndev,
+				  struct cfg80211_pmksa *pmksa)
+{
+	u8	index,blInserted = _FALSE;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct mlme_priv *mlme = &padapter->mlmepriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	u8	strZeroMacAddress[ ETH_ALEN ] = { 0x00 };
+
+	DBG_871X(FUNC_NDEV_FMT" "MAC_FMT" "KEY_FMT"\n", FUNC_NDEV_ARG(ndev)
+		, MAC_ARG(pmksa->bssid), KEY_ARG(pmksa->pmkid));
+
+	if ( _rtw_memcmp((u8 *)pmksa->bssid, strZeroMacAddress, ETH_ALEN ) == _TRUE )
+	{
+		return -EINVAL;
+	}
+
+	if (check_fwstate(mlme, _FW_LINKED) == _FALSE) {
+		DBG_871X(FUNC_NDEV_FMT" not set pmksa cause not in linked state\n", FUNC_NDEV_ARG(ndev));
+		return -EINVAL;
+	}
+
+	blInserted = _FALSE;
+	
+	//overwrite PMKID
+	for(index=0 ; index<NUM_PMKID_CACHE; index++)
+	{
+		if( _rtw_memcmp(psecuritypriv->PMKIDList[index].Bssid, (u8 *)pmksa->bssid, ETH_ALEN) ==_TRUE )
+		{ // BSSID is matched, the same AP => rewrite with new PMKID.
+			DBG_871X(FUNC_NDEV_FMT" BSSID exists in the PMKList.\n", FUNC_NDEV_ARG(ndev));
+
+			_rtw_memcpy( psecuritypriv->PMKIDList[index].PMKID, (u8 *)pmksa->pmkid, WLAN_PMKID_LEN);
+			psecuritypriv->PMKIDList[index].bUsed = _TRUE;
+			psecuritypriv->PMKIDIndex = index+1;
+			blInserted = _TRUE;
+			break;
+		}	
+	}
+
+	if(!blInserted)
+	{
+		// Find a new entry
+		DBG_871X(FUNC_NDEV_FMT" Use the new entry index = %d for this PMKID.\n",
+			FUNC_NDEV_ARG(ndev), psecuritypriv->PMKIDIndex );
+
+		_rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, (u8 *)pmksa->bssid, ETH_ALEN);
+		_rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, (u8 *)pmksa->pmkid, WLAN_PMKID_LEN);
+
+		psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = _TRUE;
+		psecuritypriv->PMKIDIndex++ ;
+		if(psecuritypriv->PMKIDIndex==16)
+		{
+			psecuritypriv->PMKIDIndex =0;
+		} 
+	} 
+
+	return 0;
+}
+
+static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,
+				  struct net_device *ndev,
+				  struct cfg80211_pmksa *pmksa)
+{
+	u8	index, bMatched = _FALSE;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+
+	DBG_871X(FUNC_NDEV_FMT" "MAC_FMT" "KEY_FMT"\n", FUNC_NDEV_ARG(ndev)
+		, MAC_ARG(pmksa->bssid), KEY_ARG(pmksa->pmkid));
+
+	for(index=0 ; index<NUM_PMKID_CACHE; index++)
+	{
+		if( _rtw_memcmp(psecuritypriv->PMKIDList[index].Bssid, (u8 *)pmksa->bssid, ETH_ALEN) ==_TRUE )
+		{ // BSSID is matched, the same AP => Remove this PMKID information and reset it. 
+			_rtw_memset(psecuritypriv->PMKIDList[index].Bssid, 0x00, ETH_ALEN );
+			_rtw_memset(psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN );
+			psecuritypriv->PMKIDList[index].bUsed = _FALSE;
+			bMatched = _TRUE;
+			DBG_871X(FUNC_NDEV_FMT" clear id:%hhu\n", FUNC_NDEV_ARG(ndev), index);		
+			break;
+		}	
+	}
+
+	if(_FALSE == bMatched)
+	{
+		DBG_871X(FUNC_NDEV_FMT" do not have matched BSSID\n"
+			, FUNC_NDEV_ARG(ndev));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cfg80211_rtw_flush_pmksa(struct wiphy *wiphy,
+				    struct net_device *ndev)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	_rtw_memset( &psecuritypriv->PMKIDList[ 0 ], 0x00, sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+	psecuritypriv->PMKIDIndex = 0;
+
+	return 0;
+}
+
+#ifdef CONFIG_AP_MODE
+void rtw_cfg80211_indicate_sta_assoc(_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
+{
+	s32 freq;
+	int channel;
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);	
+	struct net_device *ndev = padapter->pnetdev;
+
+	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
+
+#if defined(RTW_USE_CFG80211_STA_EVENT) || defined(COMPAT_KERNEL_RELEASE)
+	{
+		struct station_info sinfo;
+		u8 ie_offset;
+		if (GetFrameSubType(pmgmt_frame) == WIFI_ASSOCREQ)
+			ie_offset = _ASOCREQ_IE_OFFSET_;
+		else // WIFI_REASSOCREQ
+			ie_offset = _REASOCREQ_IE_OFFSET_;
+	
+		sinfo.filled = 0;
+		sinfo.pertid = 0;
+		sinfo.filled = STATION_INFO_ASSOC_REQ_IES;
+		sinfo.assoc_req_ies = pmgmt_frame + WLAN_HDR_A3_LEN + ie_offset;
+		sinfo.assoc_req_ies_len = frame_len - WLAN_HDR_A3_LEN - ie_offset;
+		cfg80211_new_sta(ndev, GetAddr2Ptr(pmgmt_frame), &sinfo, GFP_ATOMIC);
+	}
+#else /* defined(RTW_USE_CFG80211_STA_EVENT) */
+	channel = pmlmeext->cur_channel;
+	freq = rtw_ch2freq(channel);
+
+	#ifdef COMPAT_KERNEL_RELEASE
+	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
+	#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
+	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
+	#else //COMPAT_KERNEL_RELEASE
+	{
+		//to avoid WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION)  when calling cfg80211_send_rx_assoc()
+		#ifndef CONFIG_PLATFORM_MSTAR
+		pwdev->iftype = NL80211_IFTYPE_STATION;
+		#endif //CONFIG_PLATFORM_MSTAR
+		DBG_8192C("iftype=%d before call cfg80211_send_rx_assoc()\n", pwdev->iftype);
+		rtw_cfg80211_send_rx_assoc(padapter, NULL, pmgmt_frame, frame_len);
+		DBG_8192C("iftype=%d after call cfg80211_send_rx_assoc()\n", pwdev->iftype);
+		pwdev->iftype = NL80211_IFTYPE_AP;
+		//cfg80211_rx_action(padapter->pnetdev, freq, pmgmt_frame, frame_len, GFP_ATOMIC);
+	}
+	#endif //COMPAT_KERNEL_RELEASE
+#endif /* defined(RTW_USE_CFG80211_STA_EVENT) */
+
+}
+
+void rtw_cfg80211_indicate_sta_disassoc(_adapter *padapter, unsigned char *da, unsigned short reason)
+{
+	s32 freq;
+	int channel;
+	u8 *pmgmt_frame;
+	uint frame_len;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	unsigned short *fctrl;	
+	u8 mgmt_buf[128] = {0};
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct net_device *ndev = padapter->pnetdev;
+	
+	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
+
+#if defined(RTW_USE_CFG80211_STA_EVENT) || defined(COMPAT_KERNEL_RELEASE)
+	cfg80211_del_sta(ndev, da, GFP_ATOMIC);
+#else /* defined(RTW_USE_CFG80211_STA_EVENT) */
+	channel = pmlmeext->cur_channel;
+	freq = rtw_ch2freq(channel);
+
+	pmgmt_frame = mgmt_buf;	
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pmgmt_frame;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	_rtw_memcpy(pwlanhdr->addr1, adapter_mac_addr(padapter), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, da, ETH_ALEN);	
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pmgmt_frame, WIFI_DEAUTH);
+
+	pmgmt_frame += sizeof(struct rtw_ieee80211_hdr_3addr);
+	frame_len = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	reason = cpu_to_le16(reason);
+	pmgmt_frame = rtw_set_fixed_ie(pmgmt_frame, _RSON_CODE_ , (unsigned char *)&reason, &frame_len);
+
+	#ifdef COMPAT_KERNEL_RELEASE
+	rtw_cfg80211_rx_mgmt(padapter, freq, 0, mgmt_buf, frame_len, GFP_ATOMIC);
+	#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
+	rtw_cfg80211_rx_mgmt(padapter, freq, 0, mgmt_buf, frame_len, GFP_ATOMIC);
+	#else //COMPAT_KERNEL_RELEASE
+	cfg80211_send_disassoc(padapter->pnetdev, mgmt_buf, frame_len);	
+	//cfg80211_rx_action(padapter->pnetdev, freq, mgmt_buf, frame_len, GFP_ATOMIC);
+	#endif //COMPAT_KERNEL_RELEASE
+#endif /* defined(RTW_USE_CFG80211_STA_EVENT) */
+}
+
+static int rtw_cfg80211_monitor_if_open(struct net_device *ndev)
+{
+	int ret = 0;
+
+	DBG_8192C("%s\n", __func__);
+	
+	return ret;
+}
+
+static int rtw_cfg80211_monitor_if_close(struct net_device *ndev)
+{
+	int ret = 0;
+
+	DBG_8192C("%s\n", __func__);
+	
+	return ret;
+}
+
+static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
+{	
+	int ret = 0;
+	int rtap_len;
+	int qos_len = 0;
+	int dot11_hdr_len = 24;
+	int snap_len = 6;
+	unsigned char *pdata;
+	u16 frame_ctl;
+	unsigned char src_mac_addr[6];
+	unsigned char dst_mac_addr[6];
+	struct rtw_ieee80211_hdr *dot11_hdr;
+	struct ieee80211_radiotap_header *rtap_hdr;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	if (skb)
+		rtw_mstat_update(MSTAT_TYPE_SKB, MSTAT_ALLOC_SUCCESS, skb->truesize);
+
+	if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))
+		goto fail;
+
+	rtap_hdr = (struct ieee80211_radiotap_header *)skb->data;
+	if (unlikely(rtap_hdr->it_version))
+		goto fail;
+
+	rtap_len = ieee80211_get_radiotap_len(skb->data);
+	if (unlikely(skb->len < rtap_len))
+		goto fail;
+
+	if(rtap_len != 14)
+	{
+		DBG_8192C("radiotap len (should be 14): %d\n", rtap_len);
+		goto fail;
+	}	
+
+	/* Skip the ratio tap header */
+	skb_pull(skb, rtap_len);
+
+	dot11_hdr = (struct rtw_ieee80211_hdr *)skb->data;
+	frame_ctl = le16_to_cpu(dot11_hdr->frame_ctl);
+	/* Check if the QoS bit is set */
+	if ((frame_ctl & RTW_IEEE80211_FCTL_FTYPE) == RTW_IEEE80211_FTYPE_DATA) {
+		/* Check if this ia a Wireless Distribution System (WDS) frame
+		 * which has 4 MAC addresses
+		 */
+		if (dot11_hdr->frame_ctl & 0x0080)
+			qos_len = 2;
+		if ((dot11_hdr->frame_ctl & 0x0300) == 0x0300)
+			dot11_hdr_len += 6;
+
+		memcpy(dst_mac_addr, dot11_hdr->addr1, sizeof(dst_mac_addr));
+		memcpy(src_mac_addr, dot11_hdr->addr2, sizeof(src_mac_addr));
+
+		/* Skip the 802.11 header, QoS (if any) and SNAP, but leave spaces for
+		 * for two MAC addresses
+		 */
+		skb_pull(skb, dot11_hdr_len + qos_len + snap_len - sizeof(src_mac_addr) * 2);
+		pdata = (unsigned char*)skb->data;
+		memcpy(pdata, dst_mac_addr, sizeof(dst_mac_addr));
+		memcpy(pdata + sizeof(dst_mac_addr), src_mac_addr, sizeof(src_mac_addr));
+
+		DBG_8192C("should be eapol packet\n");
+
+		/* Use the real net device to transmit the packet */
+		ret = _rtw_xmit_entry(skb, padapter->pnetdev);
+
+		return ret;
+
+	}
+	else if ((frame_ctl & (RTW_IEEE80211_FCTL_FTYPE|RTW_IEEE80211_FCTL_STYPE))
+		== (RTW_IEEE80211_FTYPE_MGMT|RTW_IEEE80211_STYPE_ACTION)
+	) 
+	{
+		//only for action frames
+		struct xmit_frame		*pmgntframe;
+		struct pkt_attrib	*pattrib;
+		unsigned char	*pframe;	
+		//u8 category, action, OUI_Subtype, dialogToken=0;
+		//unsigned char	*frame_body;
+		struct rtw_ieee80211_hdr *pwlanhdr;	
+		struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+		struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+		u8 *buf = skb->data;
+		u32 len = skb->len;
+		u8 category, action;
+		int type = -1;
+
+		if (rtw_action_frame_parse(buf, len, &category, &action) == _FALSE) {
+			DBG_8192C(FUNC_NDEV_FMT" frame_control:0x%x\n", FUNC_NDEV_ARG(ndev),
+				le16_to_cpu(((struct rtw_ieee80211_hdr_3addr *)buf)->frame_ctl));
+			goto fail;
+		}
+		
+		DBG_8192C("RTW_Tx:da="MAC_FMT" via "FUNC_NDEV_FMT"\n",
+			MAC_ARG(GetAddr1Ptr(buf)), FUNC_NDEV_ARG(ndev));
+		#ifdef CONFIG_P2P
+		if((type = rtw_p2p_check_frames(padapter, buf, len, _TRUE)) >= 0)
+			goto dump;
+		#endif
+		if (category == RTW_WLAN_CATEGORY_PUBLIC)
+			DBG_871X("RTW_Tx:%s\n", action_public_str(action));
+		else
+			DBG_871X("RTW_Tx:category(%u), action(%u)\n", category, action);
+
+dump:
+		//starting alloc mgmt frame to dump it
+		if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+		{			
+			goto fail;
+		}
+
+		//update attribute
+		pattrib = &pmgntframe->attrib;
+		update_mgntframe_attrib(padapter, pattrib);
+		pattrib->retry_ctrl = _FALSE;
+
+		_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+		pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+
+		_rtw_memcpy(pframe, (void*)buf, len);
+		pattrib->pktlen = len;
+
+		if (type >= 0)
+			rtw_xframe_chk_wfd_ie(pmgntframe);
+	
+		pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+		//update seq number
+		pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
+		pattrib->seqnum = pmlmeext->mgnt_seq;
+		pmlmeext->mgnt_seq++;
+
+	
+		pattrib->last_txcmdsz = pattrib->pktlen;
+	
+		dump_mgntframe(padapter, pmgntframe);
+		
+	}
+	else
+	{
+		DBG_8192C("frame_ctl=0x%x\n", frame_ctl & (RTW_IEEE80211_FCTL_FTYPE|RTW_IEEE80211_FCTL_STYPE));
+	}
+
+	
+fail:
+	
+	rtw_skb_free(skb);
+
+	return 0;
+	
+}
+
+static void rtw_cfg80211_monitor_if_set_multicast_list(struct net_device *ndev)
+{
+	DBG_8192C("%s\n", __func__);
+}
+
+static int rtw_cfg80211_monitor_if_set_mac_address(struct net_device *ndev, void *addr)
+{
+	int ret = 0;
+	
+	DBG_8192C("%s\n", __func__);
+	
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+static const struct net_device_ops rtw_cfg80211_monitor_if_ops = {
+	.ndo_open = rtw_cfg80211_monitor_if_open,
+       .ndo_stop = rtw_cfg80211_monitor_if_close,
+       .ndo_start_xmit = rtw_cfg80211_monitor_if_xmit_entry,
+       #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0))
+       .ndo_set_multicast_list = rtw_cfg80211_monitor_if_set_multicast_list,
+       #endif
+       .ndo_set_mac_address = rtw_cfg80211_monitor_if_set_mac_address,       
+};
+#endif
+
+static int rtw_cfg80211_add_monitor_if(_adapter *padapter, char *name, struct net_device **ndev)
+{
+	int ret = 0;
+	struct net_device* mon_ndev = NULL;
+	struct wireless_dev* mon_wdev = NULL;
+	struct rtw_netdev_priv_indicator *pnpi;
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(padapter);
+		
+	if (!name) {
+		DBG_871X(FUNC_ADPT_FMT" without specific name\n", FUNC_ADPT_ARG(padapter));
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (pwdev_priv->pmon_ndev) {
+		DBG_871X(FUNC_ADPT_FMT" monitor interface exist: "NDEV_FMT"\n",
+			FUNC_ADPT_ARG(padapter), NDEV_ARG(pwdev_priv->pmon_ndev));
+		ret = -EBUSY;
+		goto out;
+	}
+
+	mon_ndev = alloc_etherdev(sizeof(struct rtw_netdev_priv_indicator));
+	if (!mon_ndev) {
+		DBG_871X(FUNC_ADPT_FMT" allocate ndev fail\n", FUNC_ADPT_ARG(padapter));
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	mon_ndev->type = ARPHRD_IEEE80211_RADIOTAP;
+	strncpy(mon_ndev->name, name, IFNAMSIZ);
+	mon_ndev->name[IFNAMSIZ - 1] = 0;
+	mon_ndev->priv_destructor = rtw_ndev_destructor;
+	mon_ndev->needs_free_netdev = true;
+	
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+	mon_ndev->netdev_ops = &rtw_cfg80211_monitor_if_ops;
+#else
+	mon_ndev->open = rtw_cfg80211_monitor_if_open;
+	mon_ndev->stop = rtw_cfg80211_monitor_if_close;
+	mon_ndev->hard_start_xmit = rtw_cfg80211_monitor_if_xmit_entry;
+	mon_ndev->set_mac_address = rtw_cfg80211_monitor_if_set_mac_address;
+#endif
+
+	pnpi = netdev_priv(mon_ndev);
+	pnpi->priv = padapter;
+	pnpi->sizeof_priv = sizeof(_adapter);
+
+	/*  wdev */
+	mon_wdev = (struct wireless_dev *)rtw_zmalloc(sizeof(struct wireless_dev));
+	if (!mon_wdev) {
+		DBG_871X(FUNC_ADPT_FMT" allocate mon_wdev fail\n", FUNC_ADPT_ARG(padapter));
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	mon_wdev->wiphy = padapter->rtw_wdev->wiphy;
+	mon_wdev->netdev = mon_ndev;
+	mon_wdev->iftype = NL80211_IFTYPE_MONITOR;
+	mon_ndev->ieee80211_ptr = mon_wdev;
+
+	ret = register_netdevice(mon_ndev);
+	if (ret) {
+		goto out;
+	}
+
+	*ndev = pwdev_priv->pmon_ndev = mon_ndev;
+	_rtw_memcpy(pwdev_priv->ifname_mon, name, IFNAMSIZ+1);
+
+out:
+	if (ret && mon_wdev) {
+		rtw_mfree((u8*)mon_wdev, sizeof(struct wireless_dev));
+		mon_wdev = NULL;
+	}
+
+	if (ret && mon_ndev) {
+		free_netdev(mon_ndev);
+		*ndev = mon_ndev = NULL;
+	}
+
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+static struct wireless_dev *
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
+static struct net_device *
+#else
+static int
+#endif
+	cfg80211_rtw_add_virtual_intf(
+		struct wiphy *wiphy,
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0))
+		const char *name,
+	#else
+		char *name,
+	#endif
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
+		unsigned char name_assign_type,
+	#endif
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
+		enum nl80211_iftype type, struct vif_params *params
+	#else
+		enum nl80211_iftype type, u32 *flags, struct vif_params *params
+	#endif
+	)
+{
+	int ret = 0;
+	struct net_device* ndev = NULL;
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+
+	DBG_871X("%s wiphy:%s, name:%s, type:%d\n",
+		__func__, wiphy_name(wiphy), name, type);
+
+	switch (type) {
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_WDS:
+	case NL80211_IFTYPE_MESH_POINT:
+		ret = -ENODEV;
+		break;
+	case NL80211_IFTYPE_MONITOR:
+		ret = rtw_cfg80211_add_monitor_if(padapter, (char *)name, &ndev);
+		break;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+	case NL80211_IFTYPE_P2P_CLIENT:
+#endif
+	case NL80211_IFTYPE_STATION:
+		ret = -ENODEV;
+		break;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+	case NL80211_IFTYPE_P2P_GO:
+#endif
+	case NL80211_IFTYPE_AP:
+		ret = -ENODEV;
+		break;
+	default:
+		ret = -ENODEV;
+		DBG_871X("Unsupported interface type\n");
+		break;
+	}
+
+	DBG_871X("%s ndev:%p, ret:%d\n", __func__, ndev, ret);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	return ndev ? ndev->ieee80211_ptr : ERR_PTR(ret);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
+	return ndev ? ndev : ERR_PTR(ret);
+#else
+	return ret;
+#endif
+}
+
+static int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct wireless_dev *wdev
+#else
+	struct net_device *ndev
+#endif
+)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct net_device *ndev = wdev_to_ndev(wdev);
+#endif
+	int ret = 0;
+	_adapter *adapter;
+	struct rtw_wdev_priv *pwdev_priv;
+
+	if (!ndev) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	adapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(adapter);
+
+	unregister_netdevice(ndev);
+
+	if (ndev == pwdev_priv->pmon_ndev) {
+		pwdev_priv->pmon_ndev = NULL;
+		pwdev_priv->ifname_mon[0] = '\0';
+		DBG_871X(FUNC_NDEV_FMT" remove monitor interface\n", FUNC_NDEV_ARG(ndev));
+	}
+
+exit:
+	return ret;
+}
+
+static int rtw_add_beacon(_adapter *adapter, const u8 *head, size_t head_len, const u8 *tail, size_t tail_len)
+{
+	int ret=0;
+	u8 *pbuf = NULL;
+	uint len, wps_ielen=0;	
+	uint p2p_ielen=0;
+	u8 *p2p_ie;
+	u8 got_p2p_ie = _FALSE;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	//struct sta_priv *pstapriv = &padapter->stapriv;
+	
+
+	DBG_8192C("%s beacon_head_len=%zu, beacon_tail_len=%zu\n", __FUNCTION__, head_len, tail_len);
+
+	
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+		return -EINVAL;
+
+	if(head_len<24)
+		return -EINVAL;
+	
+
+	pbuf = rtw_zmalloc(head_len+tail_len);
+	if(!pbuf)
+		return -ENOMEM;
+	
+
+	//_rtw_memcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);
+
+	//if((pstapriv->max_num_sta>NUM_STA) || (pstapriv->max_num_sta<=0))
+	//	pstapriv->max_num_sta = NUM_STA;
+
+	
+	_rtw_memcpy(pbuf, (void *)head+24, head_len-24);// 24=beacon header len.
+	_rtw_memcpy(pbuf+head_len-24, (void *)tail, tail_len);
+
+	len = head_len+tail_len-24;
+
+	//check wps ie if inclued
+	if(rtw_get_wps_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &wps_ielen))
+		DBG_8192C("add bcn, wps_ielen=%d\n", wps_ielen);
+
+#ifdef CONFIG_P2P
+	if( adapter->wdinfo.driver_interface == DRIVER_CFG80211 )
+	{
+		//check p2p if enable
+		if(rtw_get_p2p_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &p2p_ielen))
+		{		
+			struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
+			struct wifidirect_info *pwdinfo= &(adapter->wdinfo);
+
+			DBG_8192C("got p2p_ie, len=%d\n", p2p_ielen);
+			
+			got_p2p_ie = _TRUE;	
+		
+			if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+			{			
+				DBG_8192C("Enable P2P function for the first time\n");
+				rtw_p2p_enable(adapter, P2P_ROLE_GO);
+				adapter_wdev_data(adapter)->p2p_enabled = _TRUE;
+				
+				adapter->stapriv.expire_to = 3; // 3x2 = 6 sec in p2p mode
+			}
+			else
+			{
+				DBG_8192C("enter GO Mode, p2p_ielen=%d\n", p2p_ielen);
+
+				rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
+				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
+				pwdinfo->intent = 15;		
+			}
+		}
+	}
+#endif // CONFIG_P2P
+
+	/* pbss_network->IEs will not include p2p_ie, wfd ie */
+	rtw_ies_remove_ie(pbuf, &len, _BEACON_IE_OFFSET_, _VENDOR_SPECIFIC_IE_, P2P_OUI, 4);
+	rtw_ies_remove_ie(pbuf, &len, _BEACON_IE_OFFSET_, _VENDOR_SPECIFIC_IE_, WFD_OUI, 4);
+
+	if (rtw_check_beacon_data(adapter, pbuf,  len) == _SUCCESS) 
+	{
+#ifdef  CONFIG_P2P		
+		//check p2p if enable
+		if(got_p2p_ie == _TRUE)
+		{
+			struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
+			struct wifidirect_info *pwdinfo= &(adapter->wdinfo);
+			pwdinfo->operating_channel = pmlmeext->cur_channel;			
+		}
+#endif //CONFIG_P2P
+		ret = 0;
+	}	
+	else
+	{
+		ret = -EINVAL;
+	}	
+	
+
+	rtw_mfree(pbuf, head_len+tail_len);	
+	
+	return ret;	
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)) && !defined(COMPAT_KERNEL_RELEASE)
+static int cfg80211_rtw_add_beacon(struct wiphy *wiphy, struct net_device *ndev,
+			      struct beacon_parameters *info)
+{
+	int ret=0;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(ndev);
+
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	ret = rtw_add_beacon(adapter, info->head, info->head_len, info->tail, info->tail_len);
+
+	return ret;
+}
+
+static int cfg80211_rtw_set_beacon(struct wiphy *wiphy, struct net_device *ndev,
+			      struct beacon_parameters *info)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);
+	
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	pmlmeext->bstart_bss = _TRUE;
+
+	cfg80211_rtw_add_beacon(wiphy, ndev, info);
+	
+	return 0;
+}
+
+static int	cfg80211_rtw_del_beacon(struct wiphy *wiphy, struct net_device *ndev)
+{
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	
+	return 0;
+}
+#else
+static int cfg80211_rtw_start_ap(struct wiphy *wiphy, struct net_device *ndev,
+								struct cfg80211_ap_settings *settings)
+{
+	int ret = 0;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(ndev);
+	
+	DBG_871X(FUNC_NDEV_FMT" hidden_ssid:%d, auth_type:%d\n", FUNC_NDEV_ARG(ndev),
+		settings->hidden_ssid, settings->auth_type);
+
+	ret = rtw_add_beacon(adapter, settings->beacon.head, settings->beacon.head_len,
+		settings->beacon.tail, settings->beacon.tail_len);
+
+	adapter->mlmeextpriv.mlmext_info.hidden_ssid_mode = settings->hidden_ssid;
+	
+	if (settings->ssid && settings->ssid_len) {
+		WLAN_BSSID_EX *pbss_network = &adapter->mlmepriv.cur_network.network;
+		WLAN_BSSID_EX *pbss_network_ext = &adapter->mlmeextpriv.mlmext_info.network;
+
+		if(0)
+			DBG_871X(FUNC_ADPT_FMT" ssid:(%s,%zu), from ie:(%s,%d)\n", FUNC_ADPT_ARG(adapter),
+				settings->ssid, settings->ssid_len,
+				pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength);
+
+		_rtw_memcpy(pbss_network->Ssid.Ssid, (void *)settings->ssid, settings->ssid_len);
+		pbss_network->Ssid.SsidLength = settings->ssid_len;
+		_rtw_memcpy(pbss_network_ext->Ssid.Ssid, (void *)settings->ssid, settings->ssid_len);
+		pbss_network_ext->Ssid.SsidLength = settings->ssid_len;
+
+		if(0)
+			DBG_871X(FUNC_ADPT_FMT" after ssid:(%s,%d), (%s,%d)\n", FUNC_ADPT_ARG(adapter),
+				pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength,
+				pbss_network_ext->Ssid.Ssid, pbss_network_ext->Ssid.SsidLength);
+	}
+
+	return ret;
+}
+
+static int cfg80211_rtw_change_beacon(struct wiphy *wiphy, struct net_device *ndev,
+                                struct cfg80211_beacon_data *info)
+{
+	int ret = 0;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(ndev);
+
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	ret = rtw_add_beacon(adapter, info->head, info->head_len, info->tail, info->tail_len);
+
+	return ret;
+}
+
+static int cfg80211_rtw_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
+{
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	return 0;
+}
+
+#endif //(LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))
+
+static int	cfg80211_rtw_add_station(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0))
+				u8 *mac, 
+#else
+				const u8 *mac,
+#endif
+			       struct station_parameters *params)
+{
+	int ret = 0;
+#ifdef CONFIG_TDLS
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+   	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_info *psta;
+#endif /* CONFIG_TDLS */
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	
+#ifdef CONFIG_TDLS
+	psta = rtw_get_stainfo(pstapriv, mac);
+	if (psta == NULL) {
+		psta = rtw_alloc_stainfo(pstapriv, mac);
+		if (psta ==NULL) {
+			DBG_871X("[%s] Alloc station for "MAC_FMT" fail\n", __FUNCTION__, MAC_ARG(mac));
+			ret =-EOPNOTSUPP;
+			goto exit;
+		}
+	}
+#endif /* CONFIG_TDLS */
+
+exit:
+	return ret;
+}
+
+static int	cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0))
+				u8 *mac
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0))
+				const u8 *mac
+#else
+				struct station_del_parameters *params
+#endif
+			       )
+{
+	int ret=0;	
+	_irqL irqL;
+	_list	*phead, *plist;
+	u8 updated = _FALSE;
+	const u8 *target_mac;
+	struct sta_info *psta = NULL;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	DBG_871X("+"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0))
+	target_mac = mac;
+#else
+	target_mac = params->mac;
+#endif
+
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)		
+	{
+		DBG_8192C("%s, fw_state != FW_LINKED|WIFI_AP_STATE\n", __func__);
+		return -EINVAL;		
+	}
+
+
+	if (!target_mac)
+	{
+		DBG_8192C("flush all sta, and cam_entry\n");
+
+		flush_all_cam_entry(padapter);	//clear CAM
+
+		ret = rtw_sta_flush(padapter, _TRUE);
+		
+		return ret;
+	}	
+
+
+	DBG_8192C("free sta macaddr =" MAC_FMT "\n", MAC_ARG(target_mac));
+
+	if (target_mac[0] == 0xff && target_mac[1] == 0xff &&
+	    target_mac[2] == 0xff && target_mac[3] == 0xff &&
+	    target_mac[4] == 0xff && target_mac[5] == 0xff) 
+	{
+		return -EINVAL;	
+	}
+
+
+	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	
+	phead = &pstapriv->asoc_list;
+	plist = get_next(phead);
+
+	//check asoc_queue
+	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)	
+	{
+		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
+		
+		plist = get_next(plist);	
+	
+		if (_rtw_memcmp((u8 *)target_mac, psta->hwaddr, ETH_ALEN))		
+		{
+			if(psta->dot8021xalg == 1 && psta->bpairwise_key_installed == _FALSE)
+			{
+				DBG_8192C("%s, sta's dot8021xalg = 1 and key_installed = _FALSE\n", __func__);
+			}
+			else
+			{
+				DBG_8192C("free psta=%p, aid=%d\n", psta, psta->aid);
+
+				rtw_list_delete(&psta->asoc_list);
+				pstapriv->asoc_list_cnt--;
+
+				//_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+				if (check_fwstate(pmlmepriv, (WIFI_AP_STATE)) == _TRUE)
+					updated = ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_PREV_AUTH_NOT_VALID, _TRUE);
+				else
+					updated = ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_DEAUTH_LEAVING, _TRUE);
+				//_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+
+				psta = NULL;
+
+				break;
+			}		
+					
+		}
+		
+	}
+
+	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+
+	associated_clients_update(padapter, updated, STA_INFO_UPDATE_ALL);
+
+	DBG_871X("-"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	
+	return ret;	
+
+}
+
+static int	cfg80211_rtw_change_station(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0))
+				u8 *mac, 
+#else
+				const u8 *mac,
+#endif
+				struct station_parameters *params)
+{
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	
+	return 0;
+}
+
+struct sta_info *rtw_sta_info_get_by_idx(const int idx, struct sta_priv *pstapriv)
+
+{
+	_list	*phead, *plist;
+	struct sta_info *psta = NULL;
+	int i = 0;
+	
+	phead = &pstapriv->asoc_list;
+	plist = get_next(phead);
+
+	//check asoc_queue
+	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)	
+	{
+		if(idx == i) psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
+		plist = get_next(plist);	
+		i++;
+	}
+	return psta;
+}
+
+static int	cfg80211_rtw_dump_station(struct wiphy *wiphy, struct net_device *ndev,
+			       int idx, u8 *mac, struct station_info *sinfo)
+{
+
+	int ret = 0;
+	_irqL irqL;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
+	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	if(NULL == psta)
+	{
+		DBG_871X("Station is not found\n");
+		ret = -ENOENT;
+		goto exit;
+	}
+	_rtw_memcpy(mac, psta->hwaddr, ETH_ALEN);
+	sinfo->filled = 0;
+	sinfo->filled |= STATION_INFO_SIGNAL;
+	sinfo->signal = psta->rssi;
+	
+exit:
+	return ret;
+}
+
+static int	cfg80211_rtw_change_bss(struct wiphy *wiphy, struct net_device *ndev,
+			      struct bss_parameters *params)
+{
+	u8 i;
+
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+/*
+	DBG_8192C("use_cts_prot=%d\n", params->use_cts_prot);
+	DBG_8192C("use_short_preamble=%d\n", params->use_short_preamble);
+	DBG_8192C("use_short_slot_time=%d\n", params->use_short_slot_time);
+	DBG_8192C("ap_isolate=%d\n", params->ap_isolate);
+
+	DBG_8192C("basic_rates_len=%d\n", params->basic_rates_len);
+	for(i=0; i<params->basic_rates_len; i++)
+	{		
+		DBG_8192C("basic_rates=%d\n", params->basic_rates[i]);
+		
+	}	
+*/	
+	return 0;
+	
+}
+
+static int	cfg80211_rtw_set_channel(struct wiphy *wiphy
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	, struct net_device *ndev
+	#endif
+	, struct ieee80211_channel *chan, enum nl80211_channel_type channel_type)
+{
+	int chan_target = (u8) ieee80211_frequency_to_channel(chan->center_freq);
+	int chan_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	int chan_width = CHANNEL_WIDTH_20;
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	#endif
+
+	switch (channel_type) {
+	case NL80211_CHAN_NO_HT:
+	case NL80211_CHAN_HT20:
+		chan_width = CHANNEL_WIDTH_20;
+		chan_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		break;
+	case NL80211_CHAN_HT40MINUS:
+		chan_width = CHANNEL_WIDTH_40;
+		chan_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+		break;
+	case NL80211_CHAN_HT40PLUS:
+		chan_width = CHANNEL_WIDTH_40;
+		chan_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+		break;
+	default:
+		chan_width = CHANNEL_WIDTH_20;
+		chan_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		break;
+	}
+
+	set_channel_bwmode(padapter, chan_target, chan_offset, chan_width);
+
+	return 0;
+}
+
+static int cfg80211_rtw_set_monitor_channel(struct wiphy *wiphy
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
+											, struct cfg80211_chan_def *chandef
+#else
+											, struct ieee80211_channel *chan
+											, enum nl80211_channel_type channel_type
+#endif
+										   )
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
+	struct ieee80211_channel *chan = chandef->chan;
+#endif
+
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	int target_channal = chan->hw_value;
+	int target_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	int target_width = CHANNEL_WIDTH_20;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192C("center_freq %u Mhz ch %u width %u freq1 %u freq2 %u\n"
+			  , chan->center_freq
+			  , chan->hw_value
+			  , chandef->width
+			  , chandef->center_freq1
+			  , chandef->center_freq2);
+#endif /* CONFIG_DEBUG_CFG80211 */
+
+	switch (chandef->width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+	case NL80211_CHAN_WIDTH_20:
+		target_width = CHANNEL_WIDTH_20;
+		target_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		break;
+	case NL80211_CHAN_WIDTH_40:
+		target_width = CHANNEL_WIDTH_40;
+		if (chandef->center_freq1 > chan->center_freq)
+			target_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+		else
+			target_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+		break;
+	case NL80211_CHAN_WIDTH_80:
+		target_width = CHANNEL_WIDTH_80;
+		target_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		break;
+	case NL80211_CHAN_WIDTH_80P80:
+		target_width = CHANNEL_WIDTH_80_80;
+		target_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		break;
+	case NL80211_CHAN_WIDTH_160:
+		target_width = CHANNEL_WIDTH_160;
+		target_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		break;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0))
+	case NL80211_CHAN_WIDTH_5:
+	case NL80211_CHAN_WIDTH_10:
+#endif
+	default:
+		target_width = CHANNEL_WIDTH_20;
+		target_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		break;
+	}
+#else
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192C("center_freq %u Mhz ch %u channel_type %u\n"
+			  , chan->center_freq
+			  , chan->hw_value
+			  , channel_type);
+#endif /* CONFIG_DEBUG_CFG80211 */
+
+	switch (channel_type) {
+	case NL80211_CHAN_NO_HT:
+	case NL80211_CHAN_HT20:
+		target_width = CHANNEL_WIDTH_20;
+		target_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		break;
+	case NL80211_CHAN_HT40MINUS:
+		target_width = CHANNEL_WIDTH_40;
+		target_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+		break;
+	case NL80211_CHAN_HT40PLUS:
+		target_width = CHANNEL_WIDTH_40;
+		target_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+		break;
+	default:
+		target_width = CHANNEL_WIDTH_20;
+		target_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		break;
+	}
+#endif
+
+	set_channel_bwmode(padapter, target_channal, target_offset, target_width);
+
+	return 0;
+}
+
+static int	cfg80211_rtw_auth(struct wiphy *wiphy, struct net_device *ndev,
+			struct cfg80211_auth_request *req)
+{
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	
+	return 0;
+}
+
+static int	cfg80211_rtw_assoc(struct wiphy *wiphy, struct net_device *ndev,
+			 struct cfg80211_assoc_request *req)
+{
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	
+	return 0;
+}
+#endif //CONFIG_AP_MODE
+
+void rtw_cfg80211_rx_probe_request(_adapter *adapter, u8 *frame, uint frame_len)
+{
+	s32 freq;
+	int channel;
+	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);	
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(adapter);
+	u8 category, action;
+
+	channel = rtw_get_oper_ch(adapter);
+	freq = rtw_ch2freq(channel);
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192C("RTW_Rx: probe request, cur_ch=%d\n", channel);
+#endif /* CONFIG_DEBUG_CFG80211 */
+	rtw_cfg80211_rx_mgmt(adapter, freq, 0, frame, frame_len, GFP_ATOMIC);
+}
+
+void rtw_cfg80211_rx_action_p2p(_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
+{
+	int type;
+	s32 freq;
+	int channel;
+	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+	u8 category, action;
+
+	channel = rtw_get_oper_ch(padapter);
+
+	DBG_8192C("RTW_Rx:cur_ch=%d\n", channel);
+	#ifdef CONFIG_P2P
+	type = rtw_p2p_check_frames(padapter, pmgmt_frame, frame_len, _FALSE);
+	if (type >= 0)
+		goto indicate;
+	#endif
+	rtw_action_frame_parse(pmgmt_frame, frame_len, &category, &action);
+	DBG_871X("RTW_Rx:category(%u), action(%u)\n", category, action);
+
+indicate:
+	freq = rtw_ch2freq(channel);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
+#else
+	cfg80211_rx_action(padapter->pnetdev, freq, pmgmt_frame, frame_len, GFP_ATOMIC);
+#endif
+}
+
+void rtw_cfg80211_rx_p2p_action_public(_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
+{
+	int type;
+	s32 freq;
+	int channel;
+	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+	u8 category, action;
+
+	channel = rtw_get_oper_ch(padapter);
+
+	DBG_8192C("RTW_Rx:cur_ch=%d\n", channel);
+	#ifdef CONFIG_P2P
+	type = rtw_p2p_check_frames(padapter, pmgmt_frame, frame_len, _FALSE);
+	if (type >= 0) {
+		switch (type) {
+		case P2P_GO_NEGO_CONF:
+		case P2P_PROVISION_DISC_RESP:
+		case P2P_INVIT_RESP:
+			rtw_set_scan_deny(padapter, 2000);			
+			rtw_clear_scan_deny(padapter);
+		}
+		goto indicate;
+	}
+	#endif
+	rtw_action_frame_parse(pmgmt_frame, frame_len, &category, &action);
+	DBG_871X("RTW_Rx:category(%u), action(%u)\n", category, action);
+
+indicate:
+	freq = rtw_ch2freq(channel);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
+#else
+	cfg80211_rx_action(padapter->pnetdev, freq, pmgmt_frame, frame_len, GFP_ATOMIC);
+#endif
+}
+
+void rtw_cfg80211_rx_action(_adapter *adapter, u8 *frame, uint frame_len, const char*msg)
+{
+	s32 freq;
+	int channel;
+	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);	
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(adapter);
+	u8 category, action;
+
+	channel = rtw_get_oper_ch(adapter);
+
+	rtw_action_frame_parse(frame, frame_len, &category, &action);
+
+	if (action == ACT_PUBLIC_GAS_INITIAL_REQ) {
+		rtw_set_scan_deny(adapter, 200);
+		rtw_scan_abort_no_wait(adapter);
+		#ifdef CONFIG_CONCURRENT_MODE
+		if (rtw_buddy_adapter_up(adapter))
+			rtw_scan_abort_no_wait(adapter->pbuddy_adapter);
+		#endif
+	}
+
+	freq = rtw_ch2freq(channel);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+	rtw_cfg80211_rx_mgmt(adapter, freq, 0, frame, frame_len, GFP_ATOMIC);
+#else
+	cfg80211_rx_action(adapter->pnetdev, freq, frame, frame_len, GFP_ATOMIC);
+#endif
+
+	DBG_8192C("RTW_Rx:cur_ch=%d\n", channel);
+	if (msg)
+		DBG_871X("RTW_Rx:%s\n", msg);
+	else
+		DBG_871X("RTW_Rx:category(%u), action(%u)\n", category, action);
+}
+
+#ifdef CONFIG_P2P
+void rtw_cfg80211_issue_p2p_provision_request(_adapter *padapter, const u8 *buf, size_t len)
+{
+	u16	wps_devicepassword_id = 0x0000;
+	uint	wps_devicepassword_id_len = 0;
+	u8			wpsie[ 255 ] = { 0x00 }, p2p_ie[ 255 ] = { 0x00 };
+	uint			p2p_ielen = 0;
+	uint			wpsielen = 0;
+	u32	devinfo_contentlen = 0;
+	u8	devinfo_content[64] = { 0x00 };
+	u16	capability = 0;
+	uint capability_len = 0;
+	
+	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
+	u8			action = P2P_PUB_ACTION_ACTION;
+	u8			dialogToken = 1;
+	u32			p2poui = cpu_to_be32(P2POUI);
+	u8			oui_subtype = P2P_PROVISION_DISC_REQ;	
+	u32			p2pielen = 0;
+#ifdef CONFIG_WFD
+	u32					wfdielen = 0;
+#endif
+	
+	struct xmit_frame			*pmgntframe;
+	struct pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
+	u8 *frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));
+	size_t frame_body_len = len - sizeof(struct rtw_ieee80211_hdr_3addr);
+
+
+	DBG_871X( "[%s] In\n", __FUNCTION__ );
+
+	//prepare for building provision_request frame	
+	_rtw_memcpy(pwdinfo->tx_prov_disc_info.peerIFAddr, GetAddr1Ptr(buf), ETH_ALEN);
+	_rtw_memcpy(pwdinfo->tx_prov_disc_info.peerDevAddr, GetAddr1Ptr(buf), ETH_ALEN);
+	
+	pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_PUSH_BUTTON;
+		
+	rtw_get_wps_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, wpsie, &wpsielen);
+	rtw_get_wps_attr_content( wpsie, wpsielen, WPS_ATTR_DEVICE_PWID, (u8*) &wps_devicepassword_id, &wps_devicepassword_id_len);
+	wps_devicepassword_id = be16_to_cpu( wps_devicepassword_id );
+
+	switch(wps_devicepassword_id) 
+	{
+		case WPS_DPID_PIN:
+			pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_LABEL;
+			break;
+		case WPS_DPID_USER_SPEC:
+			pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_DISPLYA;
+			break;
+		case WPS_DPID_MACHINE_SPEC:
+			break;
+		case WPS_DPID_REKEY:
+			break;
+		case WPS_DPID_PBC:
+			pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_PUSH_BUTTON;
+			break;
+		case WPS_DPID_REGISTRAR_SPEC:
+			pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_KEYPAD;
+			break;
+		default:
+			break;
+	}
+
+
+	if ( rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, p2p_ie, &p2p_ielen ) )
+	{	
+
+		rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, devinfo_content, &devinfo_contentlen);					
+		rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&capability, &capability_len);
+						
+	}
+
+
+	//start to build provision_request frame	
+	_rtw_memset(wpsie, 0, sizeof(wpsie));
+	_rtw_memset(p2p_ie, 0, sizeof(p2p_ie));
+	p2p_ielen = 0;	
+	
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	_rtw_memcpy(pwlanhdr->addr1, pwdinfo->tx_prov_disc_info.peerDevAddr, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, adapter_mac_addr(padapter), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, pwdinfo->tx_prov_disc_info.peerDevAddr, ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));	
+	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));		
+
+
+	//build_prov_disc_request_p2p_ie	
+	//	P2P OUI
+	p2pielen = 0;
+	p2p_ie[ p2pielen++ ] = 0x50;
+	p2p_ie[ p2pielen++ ] = 0x6F;
+	p2p_ie[ p2pielen++ ] = 0x9A;
+	p2p_ie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+
+	//	Commented by Albert 20110301
+	//	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes
+	//	1. P2P Capability
+	//	2. Device Info
+	//	3. Group ID ( When joining an operating P2P Group )
+
+	//	P2P Capability ATTR
+	//	Type:	
+	p2p_ie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
+
+	//	Length:
+	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	RTW_PUT_LE16(p2p_ie + p2pielen, 0x0002);
+	p2pielen += 2;
+
+	//	Value:
+	//	Device Capability Bitmap, 1 byte
+	//	Group Capability Bitmap, 1 byte
+	_rtw_memcpy(p2p_ie + p2pielen, &capability, 2);
+	p2pielen += 2;
+	
+
+	//	Device Info ATTR
+	//	Type:
+	p2p_ie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
+
+	//	Length:
+	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
+	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
+	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
+	RTW_PUT_LE16(p2p_ie + p2pielen, devinfo_contentlen);
+	p2pielen += 2;
+
+	//	Value:
+	_rtw_memcpy(p2p_ie + p2pielen, devinfo_content, devinfo_contentlen);
+	p2pielen += devinfo_contentlen;
+
+
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2p_ie, &p2p_ielen);			
+	//p2pielen = build_prov_disc_request_p2p_ie( pwdinfo, pframe, NULL, 0, pwdinfo->tx_prov_disc_info.peerDevAddr);
+	//pframe += p2pielen;
+	pattrib->pktlen += p2p_ielen;
+
+	wpsielen = 0;
+	//	WPS OUI
+	*(u32*) ( wpsie ) = cpu_to_be32( WPSOUI );
+	wpsielen += 4;
+
+	//	WPS version
+	//	Type:
+	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_VER1 );
+	wpsielen += 2;
+
+	//	Length:
+	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+	wpsielen += 2;
+
+	//	Value:
+	wpsie[wpsielen++] = WPS_VERSION_1;	//	Version 1.0
+
+	//	Config Method
+	//	Type:
+	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_CONF_METHOD );
+	wpsielen += 2;
+
+	//	Length:
+	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0002 );
+	wpsielen += 2;
+
+	//	Value:
+	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( pwdinfo->tx_prov_disc_info.wps_config_method_request );
+	wpsielen += 2;
+
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen );
+
+
+#ifdef CONFIG_WFD
+	wfdielen = build_provdisc_req_wfd_ie(pwdinfo, pframe);
+	pframe += wfdielen;
+	pattrib->pktlen += wfdielen;
+#endif
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	//dump_mgntframe(padapter, pmgntframe);
+	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS)
+		DBG_8192C("%s, ack to\n", __func__);
+
+	//if(wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC)
+	//{
+	//	DBG_8192C("waiting for p2p peer key-in PIN CODE\n");
+	//	rtw_msleep_os(15000); // 15 sec for key in PIN CODE, workaround for GS2 before issuing Nego Req.
+	//}	
+
+}
+
+static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct wireless_dev *wdev,
+#else
+	struct net_device *ndev,
+#endif
+	struct ieee80211_channel * channel,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
+	enum nl80211_channel_type channel_type,
+#endif
+	unsigned int duration, u64 *cookie)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct net_device *ndev = wdev_to_ndev(wdev);
+#endif
+	s32 err = 0;
+	u8 remain_ch = (u8) ieee80211_frequency_to_channel(channel->center_freq);
+	u8 ready_on_channel = _FALSE;
+	_adapter *padapter;
+	struct rtw_wdev_priv *pwdev_priv;
+	struct mlme_ext_priv *pmlmeext;
+	struct wifidirect_info *pwdinfo;
+	struct cfg80211_wifidirect_info *pcfg80211_wdinfo;
+	u8 is_p2p_find = _FALSE;
+
+#ifndef CONFIG_RADIO_WORK
+	#define RTW_ROCH_DURATION_ENLARGE
+	#define RTW_ROCH_BACK_OP
+#endif
+
+	if (ndev == NULL) {
+		return  -EINVAL;
+	}
+
+	padapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(padapter);
+	pmlmeext = &padapter->mlmeextpriv;
+	pwdinfo = &padapter->wdinfo;
+	pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
+	#ifdef CONFIG_CONCURRENT_MODE
+	is_p2p_find=(duration < (pwdinfo->ext_listen_interval))? _TRUE : _FALSE;
+	#endif
+
+	*cookie = ATOMIC_INC_RETURN(&pcfg80211_wdinfo->ro_ch_cookie_gen);
+	
+	DBG_871X(FUNC_ADPT_FMT" ch:%u duration:%d, cookie:0x%llx\n", FUNC_ADPT_ARG(padapter), remain_ch, duration, *cookie);
+
+#ifdef CONFIG_MP_INCLUDED
+	if (padapter->registrypriv.mp_mode == 1) {
+			DBG_871X(FUNC_ADPT_FMT ": MP mode block remain_on_channel request\n", FUNC_ADPT_ARG(padapter)); 
+			err = -EFAULT;
+			goto exit;
+	}
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->pbuddy_adapter) {
+		if (padapter->pbuddy_adapter->registrypriv.mp_mode == 1) {
+			DBG_871X(FUNC_ADPT_FMT ": MP mode block remain_on_channel request\n", FUNC_ADPT_ARG(padapter->pbuddy_adapter));
+			err = -EFAULT;
+			goto exit;
+		}
+	}
+#endif
+#endif
+
+	if(pcfg80211_wdinfo->is_ro_ch == _TRUE)
+	{
+		DBG_8192C("%s, cancel ro ch timer\n", __func__);
+		_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
+		#ifdef CONFIG_CONCURRENT_MODE
+		ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
+		#endif //CONFIG_CONCURRENT_MODE
+		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
+	}
+
+	pcfg80211_wdinfo->is_ro_ch = _TRUE;
+	pcfg80211_wdinfo->last_ro_ch_time = rtw_get_current_time();
+
+	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+	_rtw_memcpy(&pcfg80211_wdinfo->remain_on_ch_channel, channel, sizeof(struct ieee80211_channel));
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
+	pcfg80211_wdinfo->remain_on_ch_type= channel_type;
+	#endif
+	pcfg80211_wdinfo->remain_on_ch_cookie= *cookie;
+
+	rtw_scan_abort(padapter);
+#ifdef CONFIG_CONCURRENT_MODE		
+	if ((rtw_buddy_adapter_up(padapter)) && is_p2p_find)		//don't scan_abort during p2p_listen.
+		rtw_scan_abort(padapter->pbuddy_adapter);			
+#endif //CONFIG_CONCURRENT_MODE
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE)
+	{
+		DBG_871X("mlme state:0x%x\n", get_fwstate(&padapter->mlmepriv));
+		remain_ch = padapter->mlmeextpriv.cur_channel;
+	}
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE)
+	{
+		DBG_871X("buddy_intf's mlme state:0x%x\n", get_fwstate(&(padapter->pbuddy_adapter->mlmepriv)));
+		remain_ch = padapter->pbuddy_adapter->mlmeextpriv.cur_channel;
+	}
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	//if(!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) && !rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	{
+		rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
+		adapter_wdev_data(padapter)->p2p_enabled = _TRUE;
+		padapter->wdinfo.listen_channel = remain_ch;
+	} else if (rtw_p2p_chk_state(pwdinfo , P2P_STATE_LISTEN)) {
+		padapter->wdinfo.listen_channel = remain_ch;
+	} else {
+		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
+#ifdef CONFIG_DEBUG_CFG80211		
+		DBG_8192C("%s, role=%d, p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo));
+#endif
+	}
+
+
+	rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
+
+	#ifdef RTW_ROCH_DURATION_ENLARGE
+	if (duration < 400)
+		duration = duration * 3; /* extend from exper */
+	#endif
+
+#ifdef RTW_ROCH_BACK_OP
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_LINKED)) {
+		if (is_p2p_find) /* p2p_find , duration<1000 */
+			duration = duration + pwdinfo->ext_listen_interval;
+		else /* p2p_listen, duration=5000 */
+			duration = pwdinfo->ext_listen_interval + (pwdinfo->ext_listen_interval / 4);
+	}
+#endif
+#endif /* RTW_ROCH_BACK_OP */
+
+	pcfg80211_wdinfo->restore_channel = rtw_get_oper_ch(padapter);
+
+	if(rtw_ch_set_search_ch(pmlmeext->channel_set, remain_ch) >= 0) {
+#ifdef	CONFIG_CONCURRENT_MODE
+		if ( check_buddy_fwstate(padapter, _FW_LINKED) )
+		{
+			PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;			
+			struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;	
+
+			if((remain_ch != pbuddy_mlmeext->cur_channel) && !check_fwstate(&padapter->mlmepriv, _FW_LINKED))
+			{	
+				if(ATOMIC_READ(&pwdev_priv->switch_ch_to)==1 ||
+					(remain_ch != pmlmeext->cur_channel))
+				{
+					if (check_buddy_fwstate(padapter, WIFI_FW_STATION_STATE)) {
+						DBG_8192C("%s, issue nulldata pwrbit=1\n", __func__);
+						issue_nulldata(padapter->pbuddy_adapter, NULL, 1, 3, 500);
+					}
+
+					ATOMIC_SET(&pwdev_priv->switch_ch_to, 0);
+
+					#ifdef RTW_ROCH_BACK_OP
+					DBG_8192C("%s, set switch ch timer, duration=%d\n", __func__, duration-pwdinfo->ext_listen_interval);
+					_set_timer(&pwdinfo->ap_p2p_switch_timer, duration-pwdinfo->ext_listen_interval);
+					#endif
+				}			
+			}
+		
+			ready_on_channel = _TRUE;
+			//pmlmeext->cur_channel = remain_ch;			
+			//set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+		}else 
+#endif //CONFIG_CONCURRENT_MODE
+		if(remain_ch != rtw_get_oper_ch(padapter) )
+		{
+			ready_on_channel = _TRUE;
+			//pmlmeext->cur_channel = remain_ch;			
+			//set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+		}
+	} else {
+		DBG_871X("%s remain_ch:%u not in channel plan!!!!\n", __FUNCTION__, remain_ch);
+	}
+	
+
+	//call this after other things have been done
+#ifdef	CONFIG_CONCURRENT_MODE	
+	if(ATOMIC_READ(&pwdev_priv->ro_ch_to)==1 ||
+		(remain_ch != rtw_get_oper_ch(padapter)))
+	{
+		u8 co_channel = 0xff;
+		ATOMIC_SET(&pwdev_priv->ro_ch_to, 0);
+#endif
+
+		if(ready_on_channel == _TRUE)
+		{			
+			if ( !check_fwstate(&padapter->mlmepriv, _FW_LINKED ) )
+			{
+				pmlmeext->cur_channel = remain_ch;
+			
+#ifdef	CONFIG_CONCURRENT_MODE
+				co_channel = rtw_get_oper_ch(padapter);
+
+				if(co_channel !=remain_ch)
+#endif
+				{
+					//if (!padapter->mlmepriv.LinkDetectInfo.bBusyTraffic)
+					set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+				}
+			}
+		}
+		DBG_8192C("%s, set ro ch timer, duration=%d\n", __func__, duration);
+		_set_timer( &pcfg80211_wdinfo->remain_on_ch_timer, duration);
+
+#ifdef	CONFIG_CONCURRENT_MODE
+	}
+#endif
+
+	rtw_cfg80211_ready_on_channel(padapter, *cookie, channel, channel_type, duration, GFP_KERNEL);
+
+exit:
+	if (err) {
+		pcfg80211_wdinfo->is_ro_ch = _FALSE;
+		pcfg80211_wdinfo->last_ro_ch_time = rtw_get_current_time();
+	}
+
+	return err;
+}
+
+static s32 cfg80211_rtw_cancel_remain_on_channel(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct wireless_dev *wdev,
+#else
+	struct net_device *ndev,
+#endif
+	u64 cookie)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct net_device *ndev = wdev_to_ndev(wdev);
+#endif
+	s32 err = 0;
+	_adapter *padapter;
+	struct rtw_wdev_priv *pwdev_priv;
+	struct wifidirect_info *pwdinfo;
+	struct cfg80211_wifidirect_info *pcfg80211_wdinfo;
+
+	if (ndev == NULL) {
+		err = -EINVAL;
+		goto exit;
+	}
+
+	padapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(padapter);
+	pwdinfo = &padapter->wdinfo;
+	pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
+
+	DBG_871X(FUNC_ADPT_FMT" cookie:0x%llx\n", FUNC_ADPT_ARG(padapter), cookie);
+
+	if (pcfg80211_wdinfo->is_ro_ch == _TRUE) {
+		DBG_8192C("%s, cancel ro ch timer\n", __func__);
+		_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
+		#ifdef CONFIG_CONCURRENT_MODE
+		ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
+		#endif
+		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
+	}
+
+	#if 0
+	//	Disable P2P Listen State
+	if(!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) && !rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+	{
+		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		{
+			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
+			_rtw_memset(pwdinfo, 0x00, sizeof(struct wifidirect_info));
+		}
+	}
+	else
+	#endif
+	{
+		rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
+#ifdef CONFIG_DEBUG_CFG80211		 
+		DBG_8192C("%s, role=%d, p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo));
+#endif
+	}
+
+	pcfg80211_wdinfo->is_ro_ch = _FALSE;
+	pcfg80211_wdinfo->last_ro_ch_time = rtw_get_current_time();
+
+exit:
+	return err;
+}
+
+#endif //CONFIG_P2P
+
+static int _cfg80211_rtw_mgmt_tx(_adapter *padapter, u8 tx_ch, const u8 *buf, size_t len, int wait_ack)
+{
+	struct xmit_frame	*pmgntframe;
+	struct pkt_attrib	*pattrib;
+	unsigned char	*pframe;
+	int ret = _FAIL;
+	bool ack = _TRUE;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(padapter);
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+#ifdef 	CONFIG_P2P
+	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
+#endif //CONFIG_P2P
+	//struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
+
+	rtw_set_scan_deny(padapter, 1000);
+
+	rtw_scan_abort(padapter);
+	#ifdef CONFIG_CONCURRENT_MODE		
+	if(rtw_buddy_adapter_up(padapter))	
+		rtw_scan_abort(padapter->pbuddy_adapter);
+	#endif /* CONFIG_CONCURRENT_MODE */
+#ifdef CONFIG_P2P
+	if (padapter->cfg80211_wdinfo.is_ro_ch == _TRUE) {
+		//DBG_8192C("%s, cancel ro ch timer\n", __func__);
+		//_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
+		//padapter->cfg80211_wdinfo.is_ro_ch = _FALSE;
+		#ifdef CONFIG_CONCURRENT_MODE			
+		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED ))
+		{
+			DBG_8192C("%s, extend ro ch time\n", __func__);
+			_set_timer( &padapter->cfg80211_wdinfo.remain_on_ch_timer, pwdinfo->ext_listen_period);
+		}	
+		#endif //CONFIG_CONCURRENT_MODE			
+	}
+#endif //CONFIG_P2P
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_LINKED )) {
+		u8 co_channel=0xff;
+		PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;			
+		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;	
+
+		co_channel = rtw_get_oper_ch(padapter);
+
+		if (tx_ch != pbuddy_mlmeext->cur_channel) {
+
+			u16 ext_listen_period;
+			
+			if (ATOMIC_READ(&pwdev_priv->switch_ch_to)==1) {
+				if (check_buddy_fwstate(padapter, WIFI_FW_STATION_STATE)) {
+					DBG_8192C("%s, issue nulldata pwrbit=1\n", __func__);
+					issue_nulldata(padapter->pbuddy_adapter, NULL, 1, 3, 500);
+				}
+
+				ATOMIC_SET(&pwdev_priv->switch_ch_to, 0);
+
+				//DBG_8192C("%s, set switch ch timer, period=%d\n", __func__, pwdinfo->ext_listen_period);
+				//_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_period);
+			}
+
+			if (check_fwstate(&padapter->mlmepriv, _FW_LINKED ))
+			{
+				ext_listen_period = 500;// 500ms
+			}	
+			else
+			{				
+				ext_listen_period = pwdinfo->ext_listen_period;
+			}
+
+			DBG_8192C("%s, set switch ch timer, period=%d\n", __func__, ext_listen_period);
+			_set_timer(&pwdinfo->ap_p2p_switch_timer, ext_listen_period);	
+			
+		}
+
+		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED ))
+			pmlmeext->cur_channel = tx_ch;
+
+		if (tx_ch != co_channel)
+			set_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+	}else 
+#endif //CONFIG_CONCURRENT_MODE
+	//if (tx_ch != pmlmeext->cur_channel) {
+	if(tx_ch != rtw_get_oper_ch(padapter)) {
+		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED ))
+			pmlmeext->cur_channel = tx_ch;
+		set_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+	}
+
+	//starting alloc mgmt frame to dump it
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		//ret = -ENOMEM;
+		ret = _FAIL;
+		goto exit;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+	pattrib->retry_ctrl = _FALSE;
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+
+	_rtw_memcpy(pframe, (void*)buf, len);
+	pattrib->pktlen = len;	
+	
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+	//update seq number
+	pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
+	pattrib->seqnum = pmlmeext->mgnt_seq;
+	pmlmeext->mgnt_seq++;
+
+	rtw_xframe_chk_wfd_ie(pmgntframe);
+	
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	if (wait_ack) {
+		if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS) {
+			ack = _FALSE;
+			ret = _FAIL;
+
+#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192C("%s, ack == _FAIL\n", __func__);
+#endif
+		} else {
+
+#ifdef CONFIG_XMIT_ACK
+			rtw_msleep_os(50);
+#endif
+#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192C("%s, ack=%d, ok!\n", __func__, ack);
+#endif
+			ret = _SUCCESS;
+		}
+	} else {
+		dump_mgntframe(padapter, pmgntframe);
+		ret = _SUCCESS;
+	}
+exit:
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192C("%s, ret=%d\n", __func__, ret);
+	#endif
+	
+	return ret;		
+	
+}
+
+static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct wireless_dev *wdev,
+#else
+	struct net_device *ndev,
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)) || defined(COMPAT_KERNEL_RELEASE)
+	struct ieee80211_channel *chan,
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
+	bool offchan,
+	#endif
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
+	enum nl80211_channel_type channel_type,
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+	bool channel_type_valid,
+	#endif
+	#endif
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
+	unsigned int wait,
+	#endif
+	const u8 *buf, size_t len,
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+	bool no_cck,
+	#endif
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
+	bool dont_wait_for_ack,
+	#endif
+#else
+	struct cfg80211_mgmt_tx_params *params,
+#endif
+	u64 *cookie)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct net_device *ndev = wdev_to_ndev(wdev);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)) || defined(COMPAT_KERNEL_RELEASE)
+	struct ieee80211_channel *chan = params->chan;
+	bool offchan = params->offchan;
+	unsigned int wait = params->wait;
+	const u8 *buf = params->buf;
+	size_t len = params->len;
+	bool no_cck = params->no_cck;
+	bool dont_wait_for_ack = params->dont_wait_for_ack;
+#endif
+	int ret = 0;
+	int tx_ret;
+	int wait_ack = 1;
+	u32 dump_limit = RTW_MAX_MGMT_TX_CNT;
+	u32 dump_cnt = 0;
+	bool ack = _TRUE;
+	u8 tx_ch;
+	u8 category, action;
+	u8 frame_styp;
+	int type = (-1);
+	u32 start = rtw_get_current_time();
+	_adapter *padapter;
+	struct rtw_wdev_priv *pwdev_priv;
+
+	if ((ndev == NULL) || (chan == NULL)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	tx_ch = (u8)ieee80211_frequency_to_channel(chan->center_freq);
+
+	padapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(padapter);
+
+	/* cookie generation */
+	*cookie = (unsigned long) buf;
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_871X(FUNC_ADPT_FMT" len=%zu, ch=%d"
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
+		", ch_type=%d"
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)	
+		", channel_type_valid=%d"
+		#endif
+	#endif
+		"\n", FUNC_ADPT_ARG(padapter),
+		len, tx_ch
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
+		, channel_type
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)	
+		, channel_type_valid
+		#endif
+	#endif
+	);
+#endif /* CONFIG_DEBUG_CFG80211 */
+
+	/* indicate ack before issue frame to avoid racing with rsp frame */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+	rtw_cfg80211_mgmt_tx_status(padapter, *cookie, buf, len, ack, GFP_KERNEL);
+#elif  (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,34) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,35))
+	cfg80211_action_tx_status(ndev, *cookie, buf, len, ack, GFP_KERNEL);
+#endif
+
+	frame_styp = le16_to_cpu(((struct rtw_ieee80211_hdr_3addr *)buf)->frame_ctl) & IEEE80211_FCTL_STYPE;
+	if (IEEE80211_STYPE_PROBE_RESP == frame_styp) {
+#ifdef CONFIG_DEBUG_CFG80211
+		DBG_8192C("RTW_Tx: probe_resp tx_ch=%d, da="MAC_FMT"\n", tx_ch, MAC_ARG(GetAddr1Ptr(buf)));
+#endif /* CONFIG_DEBUG_CFG80211 */
+		wait_ack = 0;
+		goto dump;
+	}
+
+	if (rtw_action_frame_parse(buf, len, &category, &action) == _FALSE) {
+		DBG_8192C(FUNC_ADPT_FMT" frame_control:0x%x\n", FUNC_ADPT_ARG(padapter),
+			le16_to_cpu(((struct rtw_ieee80211_hdr_3addr *)buf)->frame_ctl));
+		goto exit;
+	}
+
+	DBG_8192C("RTW_Tx:tx_ch=%d, da="MAC_FMT"\n", tx_ch, MAC_ARG(GetAddr1Ptr(buf)));
+	#ifdef CONFIG_P2P
+	if((type = rtw_p2p_check_frames(padapter, buf, len, _TRUE)) >= 0) {
+		goto dump;
+	}
+	#endif
+	if (category == RTW_WLAN_CATEGORY_PUBLIC)
+		DBG_871X("RTW_Tx:%s\n", action_public_str(action));
+	else
+		DBG_871X("RTW_Tx:category(%u), action(%u)\n", category, action);
+
+dump:
+
+	rtw_ps_deny(padapter, PS_DENY_MGNT_TX);
+	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+		ret = -EFAULT;
+		goto cancel_ps_deny;
+	}
+
+	while (1) {
+		u32 sleep_ms = 0;
+		u32 retry_guarantee_ms = 0;
+
+		dump_cnt++;
+		tx_ret = _cfg80211_rtw_mgmt_tx(padapter, tx_ch, buf, len, wait_ack);
+
+		switch (action) {
+		case ACT_PUBLIC_GAS_INITIAL_REQ:
+		case ACT_PUBLIC_GAS_INITIAL_RSP:
+			sleep_ms = 50;
+			retry_guarantee_ms = RTW_MAX_MGMT_TX_MS_GAS;
+		}
+
+		if (tx_ret == _SUCCESS
+			|| (dump_cnt >= dump_limit && rtw_get_passing_time_ms(start) >= retry_guarantee_ms))
+				break;
+
+		if (sleep_ms > 0)
+			rtw_msleep_os(sleep_ms);
+	}
+
+	if (tx_ret != _SUCCESS || dump_cnt > 1) {
+		DBG_871X(FUNC_ADPT_FMT" %s (%d/%d) in %d ms\n", FUNC_ADPT_ARG(padapter),
+			tx_ret==_SUCCESS?"OK":"FAIL", dump_cnt, dump_limit, rtw_get_passing_time_ms(start));
+	}
+
+	switch (type) {
+	case P2P_GO_NEGO_CONF:
+		rtw_clear_scan_deny(padapter);
+		break;
+	case P2P_INVIT_RESP:
+		if (pwdev_priv->invit_info.flags & BIT(0)
+			&& pwdev_priv->invit_info.status == 0) 
+		{
+			DBG_871X(FUNC_ADPT_FMT" agree with invitation of persistent group\n",
+				FUNC_ADPT_ARG(padapter));
+			rtw_set_scan_deny(padapter, 5000);
+			rtw_pwr_wakeup_ex(padapter, 5000);
+			rtw_clear_scan_deny(padapter);
+		}
+		break;
+	}	
+
+cancel_ps_deny:
+	rtw_ps_deny_cancel(padapter, PS_DENY_MGNT_TX);
+exit:
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
+
+static void
+cfg80211_rtw_update_mgmt_frame_registrations(struct wiphy *wiphy,
+                                            struct wireless_dev *wdev,
+                                            struct mgmt_frame_regs *upd)
+{
+       struct net_device *ndev = wdev_to_ndev(wdev);
+       struct rtw_wdev_priv *pwdev_priv;
+       _adapter *adapter;
+
+       if (ndev == NULL)
+               return;
+
+       adapter = (_adapter *)rtw_netdev_priv(ndev);
+       pwdev_priv = adapter_wdev_data(adapter);
+
+#ifdef CONFIG_DEBUG_CFG80211
+       RTW_INFO(FUNC_ADPT_FMT" stypes:%x\n", FUNC_ADPT_ARG(adapter),
+                upd->interface_stypes);
+#endif
+
+       /* not implemented, see bellow */
+}
+
+#else
+
+static void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+	struct wireless_dev *wdev,
+#else
+	struct net_device *ndev,
+#endif
+	u16 frame_type, bool reg)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct net_device *ndev = wdev_to_ndev(wdev);
+#endif
+	_adapter *adapter;
+
+	struct rtw_wdev_priv *pwdev_priv;
+
+	if (ndev == NULL)
+		goto exit;
+
+	adapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(adapter);
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_871X(FUNC_ADPT_FMT" frame_type:%x, reg:%d\n", FUNC_ADPT_ARG(adapter),
+		frame_type, reg);
+#endif
+
+	/* Wait QC Verify */
+	return;
+
+	switch (frame_type) {
+	case IEEE80211_STYPE_PROBE_REQ: /* 0x0040 */
+		SET_CFG80211_REPORT_MGMT(pwdev_priv, IEEE80211_STYPE_PROBE_REQ, reg);
+		break;
+	case IEEE80211_STYPE_ACTION: /* 0x00D0 */
+		SET_CFG80211_REPORT_MGMT(pwdev_priv, IEEE80211_STYPE_ACTION, reg);
+		break;
+	default:
+		break;
+	}
+
+exit:
+	return;
+}
+
+#endif
+
+#if defined(CONFIG_TDLS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+static int cfg80211_rtw_tdls_mgmt(struct wiphy *wiphy,
+	struct net_device *ndev,
+	u8 *peer,
+	u8 action_code,
+	u8 dialog_token,
+	u16 status_code,
+	const u8 *buf,
+	size_t len)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &pmlmeext->mlmext_info;
+	int ret = 0;
+	struct tdls_txmgmt txmgmt;
+
+	if (hal_chk_wl_func(padapter, WL_FUNC_TDLS) == _FALSE) {
+		DBG_871X("Discard tdls action:%d, since hal doesn't support tdls\n", action_code);
+		goto discard;
+	}
+
+	if (rtw_tdls_is_driver_setup(padapter)) {
+		DBG_871X("Discard tdls action:%d, let driver to set up direct link\n", action_code);
+		goto discard;
+	}
+
+	_rtw_memset(&txmgmt, 0x00, sizeof(struct tdls_txmgmt));
+	_rtw_memcpy(txmgmt.peer, peer, ETH_ALEN);
+	txmgmt.action_code = action_code;
+	txmgmt.dialog_token= dialog_token;
+	txmgmt.status_code = status_code;
+	txmgmt.len = len;
+	txmgmt.buf = (u8 *)rtw_malloc(txmgmt.len);
+	if (txmgmt.buf == NULL) {
+		ret = -ENOMEM;
+		goto bad;
+	}
+	_rtw_memcpy(txmgmt.buf, (void*)buf, txmgmt.len);
+
+/* Debug purpose */
+#if 1
+	DBG_871X("%s %d\n", __FUNCTION__, __LINE__);
+	DBG_871X("peer:"MAC_FMT", action code:%d, dialog:%d, status code:%d\n",
+				MAC_ARG(txmgmt.peer), txmgmt.action_code, 
+				txmgmt.dialog_token, txmgmt.status_code);
+	if (txmgmt.len > 0) {
+		int i=0;
+		for(;i < len; i++)
+			printk("%02x ", *(txmgmt.buf+i));
+			DBG_871X("len:%d\n", txmgmt.len);
+	}
+#endif
+
+	switch (txmgmt.action_code) {
+	case TDLS_SETUP_REQUEST:
+		issue_tdls_setup_req(padapter, &txmgmt, _TRUE);
+		break;
+	case TDLS_SETUP_RESPONSE:
+		issue_tdls_setup_rsp(padapter, &txmgmt);
+		break;
+	case TDLS_SETUP_CONFIRM:
+		issue_tdls_setup_cfm(padapter, &txmgmt);
+		break;
+	case TDLS_TEARDOWN:
+		issue_tdls_teardown(padapter, &txmgmt, _TRUE);
+		break;
+	case TDLS_DISCOVERY_REQUEST:
+		issue_tdls_dis_req(padapter, &txmgmt);
+		break;
+	case TDLS_DISCOVERY_RESPONSE:
+		issue_tdls_dis_rsp(padapter, &txmgmt, pmlmeinfo->enc_algo? _TRUE : _FALSE);
+		break;
+	}
+
+bad:
+	if (txmgmt.buf)
+		rtw_mfree(txmgmt.buf, txmgmt.len);
+
+discard:
+	return ret;
+}
+
+static int cfg80211_rtw_tdls_oper(struct wiphy *wiphy,
+	struct net_device *ndev,
+	u8 *peer,
+	enum nl80211_tdls_operation oper)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
+	struct tdls_txmgmt	txmgmt;
+	struct sta_info *ptdls_sta = NULL;
+
+	DBG_871X(FUNC_NDEV_FMT", nl80211_tdls_operation:%d\n", FUNC_NDEV_ARG(ndev), oper);
+
+	if (hal_chk_wl_func(padapter, WL_FUNC_TDLS) == _FALSE) {
+		DBG_871X("Discard tdls oper:%d, since hal doesn't support tdls\n", oper);
+		return 0;
+	}
+
+#ifdef CONFIG_LPS
+	rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_LEAVE, 1);
+#endif //CONFIG_LPS
+
+	_rtw_memset(&txmgmt, 0x00, sizeof(struct tdls_txmgmt));
+	if (peer)
+		_rtw_memcpy(txmgmt.peer, peer, ETH_ALEN);
+
+	if (rtw_tdls_is_driver_setup(padapter)) {
+		/* these two cases are done by driver itself */
+		if (oper == NL80211_TDLS_ENABLE_LINK || oper == NL80211_TDLS_DISABLE_LINK)
+			return 0;
+	}
+
+	switch (oper) {
+	case NL80211_TDLS_DISCOVERY_REQ:
+		issue_tdls_dis_req(padapter, &txmgmt);
+		break;
+	case NL80211_TDLS_SETUP:
+#ifdef CONFIG_WFD
+		if ( _AES_ != padapter->securitypriv.dot11PrivacyAlgrthm ) {
+			if ( padapter->wdinfo.wfd_tdls_weaksec == _TRUE)
+				issue_tdls_setup_req(padapter, &txmgmt, _TRUE);
+			else
+				DBG_871X( "[%s] Current link is not AES, SKIP sending the tdls setup request!!\n", __FUNCTION__ );
+		} else
+#endif // CONFIG_WFD
+		{
+			issue_tdls_setup_req(padapter, &txmgmt, _TRUE);
+		}
+		break;
+	case NL80211_TDLS_TEARDOWN:
+		ptdls_sta = rtw_get_stainfo( &(padapter->stapriv), txmgmt.peer);
+		if (ptdls_sta != NULL) {
+			txmgmt.status_code = _RSON_TDLS_TEAR_UN_RSN_;
+			issue_tdls_teardown(padapter, &txmgmt, _TRUE);
+		}else {
+			DBG_871X( "TDLS peer not found\n");
+		}
+		break;
+	case NL80211_TDLS_ENABLE_LINK:
+		DBG_871X(FUNC_NDEV_FMT", NL80211_TDLS_ENABLE_LINK;mac:"MAC_FMT"\n", FUNC_NDEV_ARG(ndev), MAC_ARG(peer));
+		ptdls_sta = rtw_get_stainfo(&(padapter->stapriv), peer);
+		if (ptdls_sta != NULL) {
+			ptdlsinfo->link_established = _TRUE;
+			ptdls_sta->tdls_sta_state |= TDLS_LINKED_STATE;
+			ptdls_sta->state |= _FW_LINKED;
+			rtw_tdls_cmd(padapter, txmgmt.peer, TDLS_ESTABLISHED);
+		}
+		break;
+	case NL80211_TDLS_DISABLE_LINK:
+		DBG_871X(FUNC_NDEV_FMT", NL80211_TDLS_DISABLE_LINK;mac:"MAC_FMT"\n", FUNC_NDEV_ARG(ndev), MAC_ARG(peer));
+		ptdls_sta = rtw_get_stainfo(&(padapter->stapriv), peer);
+		if (ptdls_sta != NULL) {
+			rtw_tdls_cmd(padapter, peer, TDLS_TEAR_STA );
+		}
+		break;
+	}
+	return 0;
+}
+#endif /* CONFIG_TDLS */
+
+#if defined(CONFIG_PNO_SUPPORT) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+static int cfg80211_rtw_sched_scan_start(struct wiphy *wiphy,
+		struct net_device *dev,
+		struct cfg80211_sched_scan_request *request) {
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	u8 ret;
+
+	if (padapter->bup == _FALSE) {
+		DBG_871X("%s: net device is down.\n", __func__);
+		return -EIO;
+	}
+
+	if(check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE ||
+		check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE  ||
+		check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE) {
+		DBG_871X("%s: device is busy.\n", __func__);
+		rtw_scan_abort(padapter);
+	}
+
+	if (request == NULL) {
+		DBG_871X("%s: invalid cfg80211_requests parameters.\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = rtw_android_cfg80211_pno_setup(dev, request->ssids,
+			request->n_ssids, request->interval);
+
+	if (ret < 0) {
+		DBG_871X("%s ret: %d\n", __func__, ret);
+		goto exit;
+	}
+
+	ret = rtw_android_pno_enable(dev, _TRUE);
+	if (ret < 0) {
+		DBG_871X("%s ret: %d\n", __func__, ret);
+		goto exit;
+	}
+exit:
+	return ret;
+}
+
+static int cfg80211_rtw_sched_scan_stop(struct wiphy *wiphy,
+		struct net_device *dev) {
+	return rtw_android_pno_enable(dev, _FALSE);
+}
+#endif /* CONFIG_PNO_SUPPORT */
+
+static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
+{	
+	int ret = 0;
+	uint wps_ielen = 0;
+	u8 *wps_ie;
+	u32	p2p_ielen = 0;
+	u8 wps_oui[8]={0x0,0x50,0xf2,0x04};	
+	u8 *p2p_ie;
+	u32	wfd_ielen = 0;	
+	u8 *wfd_ie;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+
+	DBG_871X(FUNC_NDEV_FMT" ielen=%d\n", FUNC_NDEV_ARG(ndev), len);
+	
+	if(len>0)
+	{
+		if((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
+		{	
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192C("bcn_wps_ielen=%d\n", wps_ielen);
+			#endif
+		
+			if(pmlmepriv->wps_beacon_ie)
+			{
+				u32 free_len = pmlmepriv->wps_beacon_ie_len;
+				pmlmepriv->wps_beacon_ie_len = 0;
+				rtw_mfree(pmlmepriv->wps_beacon_ie, free_len);
+				pmlmepriv->wps_beacon_ie = NULL;			
+			}	
+
+			pmlmepriv->wps_beacon_ie = rtw_malloc(wps_ielen);
+			if ( pmlmepriv->wps_beacon_ie == NULL) {
+				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+				return -EINVAL;
+			
+			}
+			
+			_rtw_memcpy(pmlmepriv->wps_beacon_ie, wps_ie, wps_ielen);
+			pmlmepriv->wps_beacon_ie_len = wps_ielen;
+	
+			update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, _TRUE);
+
+		}
+
+		//buf += wps_ielen;
+		//len -= wps_ielen;
+
+		#ifdef CONFIG_P2P
+		if((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
+		{
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192C("bcn_p2p_ielen=%d\n", p2p_ielen);
+			#endif
+		
+			if(pmlmepriv->p2p_beacon_ie)
+			{
+				u32 free_len = pmlmepriv->p2p_beacon_ie_len;
+				pmlmepriv->p2p_beacon_ie_len = 0;
+				rtw_mfree(pmlmepriv->p2p_beacon_ie, free_len);
+				pmlmepriv->p2p_beacon_ie = NULL;			
+			}	
+
+			pmlmepriv->p2p_beacon_ie = rtw_malloc(p2p_ielen);
+			if ( pmlmepriv->p2p_beacon_ie == NULL) {
+				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+				return -EINVAL;
+			
+			}
+			
+			_rtw_memcpy(pmlmepriv->p2p_beacon_ie, p2p_ie, p2p_ielen);
+			pmlmepriv->p2p_beacon_ie_len = p2p_ielen;
+			
+		}
+		#endif //CONFIG_P2P
+
+
+		#ifdef CONFIG_WFD
+		wfd_ie = rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen);
+		if (wfd_ie) {
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192C("bcn_wfd_ielen=%d\n", wfd_ielen);
+			#endif
+
+			if (rtw_mlme_update_wfd_ie_data(pmlmepriv, MLME_BEACON_IE, wfd_ie, wfd_ielen) != _SUCCESS)
+				return -EINVAL;
+		}
+		#endif /* CONFIG_WFD */
+		
+		pmlmeext->bstart_bss = _TRUE;
+		
+	}
+
+	return ret;
+	
+}
+
+static int rtw_cfg80211_set_probe_resp_wpsp2pie(struct net_device *net, char *buf, int len)
+{
+	int ret = 0;
+	uint wps_ielen = 0;
+	u8 *wps_ie;
+	u32	p2p_ielen = 0;	
+	u8 *p2p_ie;
+	u32	wfd_ielen = 0;	
+	u8 *wfd_ie;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192C("%s, ielen=%d\n", __func__, len);
+#endif
+	
+	if(len>0)
+	{
+		if((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
+		{	
+			uint	attr_contentlen = 0;
+			u16	uconfig_method, *puconfig_method = NULL;
+
+			#ifdef CONFIG_DEBUG_CFG80211			
+			DBG_8192C("probe_resp_wps_ielen=%d\n", wps_ielen);
+			#endif
+		
+			if(check_fwstate(pmlmepriv, WIFI_UNDER_WPS))
+			{
+				u8 sr = 0;
+				rtw_get_wps_attr_content(wps_ie,  wps_ielen, WPS_ATTR_SELECTED_REGISTRAR, (u8*)(&sr), NULL);
+
+				if (sr != 0)
+				{
+					DBG_871X("%s, got sr\n", __func__);
+				}	
+				else
+				{				
+					DBG_8192C("GO mode process WPS under site-survey,  sr no set\n");
+					return ret;
+				}	
+			}			
+		
+			if(pmlmepriv->wps_probe_resp_ie)
+			{
+				u32 free_len = pmlmepriv->wps_probe_resp_ie_len;
+				pmlmepriv->wps_probe_resp_ie_len = 0;
+				rtw_mfree(pmlmepriv->wps_probe_resp_ie, free_len);
+				pmlmepriv->wps_probe_resp_ie = NULL;			
+			}	
+
+			pmlmepriv->wps_probe_resp_ie = rtw_malloc(wps_ielen);
+			if ( pmlmepriv->wps_probe_resp_ie == NULL) {
+				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+				return -EINVAL;
+			
+			}
+			
+			//add PUSH_BUTTON config_method by driver self in wpsie of probe_resp at GO Mode 
+			if ( (puconfig_method = (u16*)rtw_get_wps_attr_content( wps_ie, wps_ielen, WPS_ATTR_CONF_METHOD , NULL, &attr_contentlen)) != NULL )
+			{
+				//struct registry_priv *pregistrypriv = &padapter->registrypriv;
+				struct wireless_dev *wdev = padapter->rtw_wdev;
+				
+				#ifdef CONFIG_DEBUG_CFG80211		
+				//printk("config_method in wpsie of probe_resp = 0x%x\n", be16_to_cpu(*puconfig_method));
+				#endif
+				
+				//if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+				#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+				if(wdev->iftype != NL80211_IFTYPE_P2P_GO) //for WIFI-DIRECT LOGO 4.2.2, AUTO GO can't set PUSH_BUTTON flags
+				{
+					uconfig_method = WPS_CM_PUSH_BUTTON;
+					uconfig_method = cpu_to_be16( uconfig_method );
+			
+					*puconfig_method |= uconfig_method;			
+				}	
+				#endif
+			}
+			
+			_rtw_memcpy(pmlmepriv->wps_probe_resp_ie, wps_ie, wps_ielen);
+			pmlmepriv->wps_probe_resp_ie_len = wps_ielen;
+			
+		}
+
+		//buf += wps_ielen;
+		//len -= wps_ielen;
+
+		#ifdef CONFIG_P2P
+		if((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen))) 
+		{
+			u8 is_GO = _FALSE;			
+			u32 attr_contentlen = 0;
+			u16 cap_attr=0;
+
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192C("probe_resp_p2p_ielen=%d\n", p2p_ielen);
+			#endif			
+
+			//Check P2P Capability ATTR
+			if( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*) &attr_contentlen) )
+			{
+				u8 grp_cap=0;
+				//DBG_8192C( "[%s] Got P2P Capability Attr!!\n", __FUNCTION__ );
+				cap_attr = le16_to_cpu(cap_attr);
+				grp_cap = (u8)((cap_attr >> 8)&0xff);
+				
+				is_GO = (grp_cap&BIT(0)) ? _TRUE:_FALSE;
+
+				if(is_GO)
+					DBG_8192C("Got P2P Capability Attr, grp_cap=0x%x, is_GO\n", grp_cap);
+			}
+
+
+			if(is_GO == _FALSE)
+			{
+				if(pmlmepriv->p2p_probe_resp_ie)
+				{
+					u32 free_len = pmlmepriv->p2p_probe_resp_ie_len;
+					pmlmepriv->p2p_probe_resp_ie_len = 0;
+					rtw_mfree(pmlmepriv->p2p_probe_resp_ie, free_len);
+					pmlmepriv->p2p_probe_resp_ie = NULL;		
+				}	
+
+				pmlmepriv->p2p_probe_resp_ie = rtw_malloc(p2p_ielen);
+				if ( pmlmepriv->p2p_probe_resp_ie == NULL) {
+					DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+					return -EINVAL;
+				
+				}
+				_rtw_memcpy(pmlmepriv->p2p_probe_resp_ie, p2p_ie, p2p_ielen);
+				pmlmepriv->p2p_probe_resp_ie_len = p2p_ielen;
+			}		
+			else
+			{
+				if(pmlmepriv->p2p_go_probe_resp_ie)
+				{
+					u32 free_len = pmlmepriv->p2p_go_probe_resp_ie_len;
+					pmlmepriv->p2p_go_probe_resp_ie_len = 0;
+					rtw_mfree(pmlmepriv->p2p_go_probe_resp_ie, free_len);
+					pmlmepriv->p2p_go_probe_resp_ie = NULL;			
+				}	
+
+				pmlmepriv->p2p_go_probe_resp_ie = rtw_malloc(p2p_ielen);
+				if ( pmlmepriv->p2p_go_probe_resp_ie == NULL) {
+					DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+					return -EINVAL;
+			
+				}
+				_rtw_memcpy(pmlmepriv->p2p_go_probe_resp_ie, p2p_ie, p2p_ielen);
+				pmlmepriv->p2p_go_probe_resp_ie_len = p2p_ielen;
+			}
+			
+		}
+		#endif //CONFIG_P2P
+
+
+		#ifdef CONFIG_WFD
+		wfd_ie = rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen);
+		if (wfd_ie) {
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192C("probe_resp_wfd_ielen=%d\n", wfd_ielen);
+			#endif
+
+			if (rtw_mlme_update_wfd_ie_data(pmlmepriv, MLME_PROBE_RESP_IE, wfd_ie, wfd_ielen) != _SUCCESS)
+				return -EINVAL;
+		}
+		#endif /* CONFIG_WFD */
+		
+	}
+
+	return ret;
+	
+}
+
+static int rtw_cfg80211_set_assoc_resp_wpsp2pie(struct net_device *net, char *buf, int len)
+{
+	int ret = 0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	u8 *ie;
+	u32 ie_len;
+
+	DBG_8192C("%s, ielen=%d\n", __func__, len);
+
+	if (len <= 0)
+		goto exit;
+
+	ie = rtw_get_wps_ie(buf, len, NULL, &ie_len);
+	if (ie && ie_len) {
+		if (pmlmepriv->wps_assoc_resp_ie) {
+			u32 free_len = pmlmepriv->wps_assoc_resp_ie_len;
+
+			pmlmepriv->wps_assoc_resp_ie_len = 0;
+			rtw_mfree(pmlmepriv->wps_assoc_resp_ie, free_len);
+			pmlmepriv->wps_assoc_resp_ie = NULL;
+		}
+
+		pmlmepriv->wps_assoc_resp_ie = rtw_malloc(ie_len);
+		if (pmlmepriv->wps_assoc_resp_ie == NULL) {
+			DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+			return -EINVAL;
+		}
+		_rtw_memcpy(pmlmepriv->wps_assoc_resp_ie, ie, ie_len);
+		pmlmepriv->wps_assoc_resp_ie_len = ie_len;
+	}
+
+	ie = rtw_get_p2p_ie(buf, len, NULL, &ie_len);
+	if (ie && ie_len) {
+		if (pmlmepriv->p2p_assoc_resp_ie) {
+			u32 free_len = pmlmepriv->p2p_assoc_resp_ie_len;
+
+			pmlmepriv->p2p_assoc_resp_ie_len = 0;
+			rtw_mfree(pmlmepriv->p2p_assoc_resp_ie, free_len);
+			pmlmepriv->p2p_assoc_resp_ie = NULL;
+		}
+
+		pmlmepriv->p2p_assoc_resp_ie = rtw_malloc(ie_len);
+		if (pmlmepriv->p2p_assoc_resp_ie == NULL) {
+			DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+			return -EINVAL;
+		}
+		_rtw_memcpy(pmlmepriv->p2p_assoc_resp_ie, ie, ie_len);
+		pmlmepriv->p2p_assoc_resp_ie_len = ie_len;
+	}
+
+#ifdef CONFIG_WFD
+	ie = rtw_get_wfd_ie(buf, len, NULL, &ie_len);
+	if (rtw_mlme_update_wfd_ie_data(pmlmepriv, MLME_ASSOC_RESP_IE, ie, ie_len) != _SUCCESS)
+		return -EINVAL;
+#endif
+
+exit:
+	return ret;
+}
+
+int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len,
+	int type)
+{
+	int ret = 0;
+	uint wps_ielen = 0;
+	u32	p2p_ielen = 0;
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192C("%s, ielen=%d\n", __func__, len);
+#endif
+
+	if(	(rtw_get_wps_ie(buf, len, NULL, &wps_ielen) && (wps_ielen>0))
+		#ifdef CONFIG_P2P
+		|| (rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen) && (p2p_ielen>0))
+		#endif
+	)		
+	{	
+		if (net != NULL) 
+		{
+			switch (type) 
+			{
+				case 0x1: //BEACON
+				ret = rtw_cfg80211_set_beacon_wpsp2pie(net, buf, len);
+				break;
+				case 0x2: //PROBE_RESP
+				ret = rtw_cfg80211_set_probe_resp_wpsp2pie(net, buf, len);
+				break;
+				case 0x4: //ASSOC_RESP
+				ret = rtw_cfg80211_set_assoc_resp_wpsp2pie(net, buf, len);
+				break;
+			}		
+		}
+	}	
+
+	return ret;
+	
+}
+
+static void rtw_cfg80211_init_ht_capab_ex(_adapter *padapter, struct ieee80211_sta_ht_cap *ht_cap, int band, u8 rf_type)
+{
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+	u8 stbc_rx_enable = _FALSE;
+
+	rtw_ht_use_default_setting(padapter);
+
+	/* RX LDPC */
+	if (TEST_FLAG(phtpriv->ldpc_cap, LDPC_HT_ENABLE_RX))
+		ht_cap->cap |= IEEE80211_HT_CAP_LDPC_CODING;
+
+	/* TX STBC */
+	if (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_TX))
+		ht_cap->cap |= IEEE80211_HT_CAP_TX_STBC;
+
+	/* RX STBC */
+	if (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_RX)) {
+		/*rtw_rx_stbc 0: disable, bit(0):enable 2.4g, bit(1):enable 5g*/
+		if (NL80211_BAND_2GHZ == band)
+			stbc_rx_enable = (pregistrypriv->rx_stbc & BIT(0))?_TRUE:_FALSE;
+		if (NL80211_BAND_5GHZ == band)
+			stbc_rx_enable = (pregistrypriv->rx_stbc & BIT(1))?_TRUE:_FALSE;
+
+		if (stbc_rx_enable) {
+			switch (rf_type) {
+			case RF_1T1R:
+				ht_cap->cap |= IEEE80211_HT_CAP_RX_STBC_1R;/*RX STBC One spatial stream*/
+				break;
+
+			case RF_2T2R:
+			case RF_1T2R:
+				ht_cap->cap |= IEEE80211_HT_CAP_RX_STBC_1R;/* Only one spatial-stream STBC RX is supported */
+				break;
+			case RF_3T3R:
+			case RF_3T4R:
+			case RF_4T4R:
+				ht_cap->cap |= IEEE80211_HT_CAP_RX_STBC_1R;/* Only one spatial-stream STBC RX is supported */
+				break;
+			default:
+				DBG_871X("[warning] rf_type %d is not expected\n", rf_type);
+				break;
+			}
+		}
+	}
+}
+
+static void rtw_cfg80211_init_ht_capab(_adapter *padapter, struct ieee80211_sta_ht_cap *ht_cap, int band, u8 rf_type)
+{
+#define MAX_BIT_RATE_40MHZ_MCS23	450	/* Mbps */
+#define MAX_BIT_RATE_40MHZ_MCS15	300	/* Mbps */
+#define MAX_BIT_RATE_40MHZ_MCS7	150	/* Mbps */
+
+	ht_cap->ht_supported = _TRUE;
+
+	ht_cap->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
+	    				IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20 |
+	    				IEEE80211_HT_CAP_DSSSCCK40 | IEEE80211_HT_CAP_MAX_AMSDU;
+	rtw_cfg80211_init_ht_capab_ex(padapter, ht_cap, band, rf_type);
+
+	/*
+	 *Maximum length of AMPDU that the STA can receive.
+	 *Length = 2 ^ (13 + max_ampdu_length_exp) - 1 (octets)
+	 */
+	ht_cap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;
+
+	/*Minimum MPDU start spacing , */
+	ht_cap->ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;
+
+	ht_cap->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
+
+	/*
+	 *hw->wiphy->bands[NL80211_BAND_2GHZ]
+	 *base on ant_num
+	 *rx_mask: RX mask
+	 *if rx_ant =1 rx_mask[0]=0xff;==>MCS0-MCS7
+	 *if rx_ant =2 rx_mask[1]=0xff;==>MCS8-MCS15
+	 *if rx_ant >=3 rx_mask[2]=0xff;
+	 *if BW_40 rx_mask[4]=0x01;
+	 *highest supported RX rate
+	 */
+	if (rf_type == RF_1T1R) {
+		ht_cap->mcs.rx_mask[0] = 0xFF;
+
+		ht_cap->mcs.rx_highest = MAX_BIT_RATE_40MHZ_MCS7;
+	} else if ((rf_type == RF_1T2R) || (rf_type == RF_2T2R) || (rf_type == RF_2T2R_GREEN)) {
+		ht_cap->mcs.rx_mask[0] = 0xFF;
+		ht_cap->mcs.rx_mask[1] = 0xFF;
+
+		ht_cap->mcs.rx_highest = MAX_BIT_RATE_40MHZ_MCS15;
+	} else if ((rf_type == RF_2T3R) || (rf_type == RF_3T3R)) {
+		ht_cap->mcs.rx_mask[0] = 0xFF;
+		ht_cap->mcs.rx_mask[1] = 0xFF;
+		ht_cap->mcs.rx_mask[2] = 0xFF;
+
+		ht_cap->mcs.rx_highest = MAX_BIT_RATE_40MHZ_MCS23;
+	} else {
+		rtw_warn_on(1);
+		DBG_8192C("%s, error rf_type=%d\n", __func__, rf_type);
+	}	
+	
+}
+
+void rtw_cfg80211_init_wiphy(_adapter *padapter)
+{
+	u8 rf_type;
+	struct ieee80211_supported_band *bands;
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+	struct wiphy *wiphy = pwdev->wiphy;
+	
+	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+
+	DBG_8192C("%s:rf_type=%d\n", __func__, rf_type);
+
+	if (IsSupported24G(padapter->registrypriv.wireless_mode)) {	
+		bands = wiphy->bands[NL80211_BAND_2GHZ];
+		if(bands)
+			rtw_cfg80211_init_ht_capab(padapter, &bands->ht_cap, NL80211_BAND_2GHZ, rf_type);
+	}
+#ifdef CONFIG_NL80211_BAND_5GHZ
+	if (IsSupported5G(padapter->registrypriv.wireless_mode)) {	
+		bands = wiphy->bands[NL80211_BAND_5GHZ];
+		if(bands)
+			rtw_cfg80211_init_ht_capab(padapter, &bands->ht_cap, NL80211_BAND_5GHZ, rf_type);
+	}
+#endif
+
+	/* copy mac_addr to wiphy */
+	_rtw_memcpy(wiphy->perm_addr, adapter_mac_addr(padapter), ETH_ALEN);
+
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+struct ieee80211_iface_limit rtw_limits[] = {
+	{	.max = 2,
+		.types = BIT(NL80211_IFTYPE_STATION)
+			#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
+			| BIT(NL80211_IFTYPE_P2P_CLIENT)
+			#endif
+	},
+	#ifdef CONFIG_AP_MODE
+	{	.max = 1,
+		.types = BIT(NL80211_IFTYPE_AP)
+			#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) || defined(COMPAT_KERNEL_RELEASE))
+			| BIT(NL80211_IFTYPE_P2P_GO)
+			#endif
+	},
+	#endif
+};
+
+struct ieee80211_iface_combination rtw_combinations[] = {
+	{	.limits = rtw_limits,
+		.n_limits = ARRAY_SIZE(rtw_limits),
+		.max_interfaces = 2,
+		.num_different_channels = 1,
+	},
+};
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)) */
+
+static void rtw_cfg80211_preinit_wiphy(_adapter *adapter, struct wiphy *wiphy)
+{
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct registry_priv *regsty = dvobj_to_regsty(dvobj);
+
+	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+
+	wiphy->max_scan_ssids = RTW_SSID_SCAN_AMOUNT;
+	wiphy->max_scan_ie_len = RTW_SCAN_IE_LEN_MAX;	
+	wiphy->max_num_pmkids = RTW_MAX_NUM_PMKIDS;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)	 
+	wiphy->max_remain_on_channel_duration = RTW_MAX_REMAIN_ON_CHANNEL_DURATION;
+#endif
+	
+	wiphy->interface_modes =	BIT(NL80211_IFTYPE_STATION)
+								| BIT(NL80211_IFTYPE_ADHOC)
+#ifdef CONFIG_AP_MODE
+								| BIT(NL80211_IFTYPE_AP)
+								#ifdef CONFIG_WIFI_MONITOR
+								| BIT(NL80211_IFTYPE_MONITOR)
+								#endif
+#endif
+#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE))
+								| BIT(NL80211_IFTYPE_P2P_CLIENT)
+								| BIT(NL80211_IFTYPE_P2P_GO)
+#endif
+								;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)	
+#ifdef CONFIG_AP_MODE
+	wiphy->mgmt_stypes = rtw_cfg80211_default_mgmt_stypes;
+#endif //CONFIG_AP_MODE	
+#endif		
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+	#ifdef CONFIG_WIFI_MONITOR
+	wiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);
+	#endif
+#endif
+
+	#if defined(RTW_SINGLE_WIPHY) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+	wiphy->iface_combinations = rtw_combinations;
+	wiphy->n_iface_combinations = ARRAY_SIZE(rtw_combinations);
+	#endif
+
+	wiphy->cipher_suites = rtw_cipher_suites;
+	wiphy->n_cipher_suites = ARRAY_SIZE(rtw_cipher_suites);
+
+	if (IsSupported24G(adapter->registrypriv.wireless_mode))
+		wiphy->bands[NL80211_BAND_2GHZ] = rtw_spt_band_alloc(NL80211_BAND_2GHZ);
+
+#ifdef CONFIG_NL80211_BAND_5GHZ
+	if (IsSupported5G(adapter->registrypriv.wireless_mode))
+		wiphy->bands[NL80211_BAND_5GHZ] = rtw_spt_band_alloc(NL80211_BAND_5GHZ);
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38) && LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+	wiphy->flags |= WIPHY_FLAG_SUPPORTS_SEPARATE_DEFAULT_KEYS;
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
+	wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+	wiphy->flags |= WIPHY_FLAG_HAVE_AP_SME;
+	/* remove WIPHY_FLAG_OFFCHAN_TX, because we not support this feature */
+	/* wiphy->flags |= WIPHY_FLAG_OFFCHAN_TX | WIPHY_FLAG_HAVE_AP_SME; */
+#endif
+
+#if defined(CONFIG_PM) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+	wiphy->max_sched_scan_reqs = 1;
+#else
+	wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+#endif
+#ifdef CONFIG_PNO_SUPPORT
+	wiphy->max_sched_scan_ssids = MAX_PNO_LIST_COUNT;
+#endif
+#endif
+
+#if defined(CONFIG_PM) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0))
+	wiphy->wowlan = wowlan_stub;
+#else
+	wiphy->wowlan = &wowlan_stub;
+#endif
+#endif
+
+#if defined(CONFIG_TDLS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+	wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;
+#ifndef CONFIG_TDLS_DRIVER_SETUP
+	wiphy->flags |= WIPHY_FLAG_TDLS_EXTERNAL_SETUP;	//Driver handles key exchange
+	wiphy->flags |= NL80211_ATTR_HT_CAPABILITY;
+#endif //CONFIG_TDLS_DRIVER_SETUP
+#endif /* CONFIG_TDLS */
+
+	if (regsty->power_mgnt != PS_MODE_ACTIVE)
+		wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
+	else
+		wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+	//wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
+#endif
+}
+
+static struct cfg80211_ops rtw_cfg80211_ops = {
+	.change_virtual_intf = cfg80211_rtw_change_iface,
+	.add_key = cfg80211_rtw_add_key,
+	.get_key = cfg80211_rtw_get_key,
+	.del_key = cfg80211_rtw_del_key,
+	.set_default_key = cfg80211_rtw_set_default_key,
+#if defined(CONFIG_GTK_OL) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0))
+	.set_rekey_data = cfg80211_rtw_set_rekey_data,
+#endif /*CONFIG_GTK_OL*/
+	.get_station = cfg80211_rtw_get_station,
+	.scan = cfg80211_rtw_scan,
+	.set_wiphy_params = cfg80211_rtw_set_wiphy_params,
+	.connect = cfg80211_rtw_connect,
+	.disconnect = cfg80211_rtw_disconnect,
+	.join_ibss = cfg80211_rtw_join_ibss,
+	.leave_ibss = cfg80211_rtw_leave_ibss,
+	.set_tx_power = cfg80211_rtw_set_txpower,
+	.get_tx_power = cfg80211_rtw_get_txpower,
+	.set_power_mgmt = cfg80211_rtw_set_power_mgmt,
+	.set_pmksa = cfg80211_rtw_set_pmksa,
+	.del_pmksa = cfg80211_rtw_del_pmksa,
+	.flush_pmksa = cfg80211_rtw_flush_pmksa,
+	
+#ifdef CONFIG_AP_MODE
+	.add_virtual_intf = cfg80211_rtw_add_virtual_intf,
+	.del_virtual_intf = cfg80211_rtw_del_virtual_intf,
+
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)) && !defined(COMPAT_KERNEL_RELEASE)
+	.add_beacon = cfg80211_rtw_add_beacon,
+	.set_beacon = cfg80211_rtw_set_beacon,
+	.del_beacon = cfg80211_rtw_del_beacon,
+	#else
+	.start_ap = cfg80211_rtw_start_ap,
+	.change_beacon = cfg80211_rtw_change_beacon,
+	.stop_ap = cfg80211_rtw_stop_ap,
+	#endif
+	
+	.add_station = cfg80211_rtw_add_station,
+	.del_station = cfg80211_rtw_del_station,
+	.change_station = cfg80211_rtw_change_station,
+	.dump_station = cfg80211_rtw_dump_station,
+	.change_bss = cfg80211_rtw_change_bss,
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+	.set_channel = cfg80211_rtw_set_channel,
+	#endif
+	//.auth = cfg80211_rtw_auth,
+	//.assoc = cfg80211_rtw_assoc,	
+#endif //CONFIG_AP_MODE
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+	.set_monitor_channel = cfg80211_rtw_set_monitor_channel,
+#endif
+
+#ifdef CONFIG_P2P
+	.remain_on_channel = cfg80211_rtw_remain_on_channel,
+	.cancel_remain_on_channel = cfg80211_rtw_cancel_remain_on_channel,
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)	 
+	.mgmt_tx = cfg80211_rtw_mgmt_tx,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
+	.update_mgmt_frame_registrations = cfg80211_rtw_update_mgmt_frame_registrations,
+#else
+	.mgmt_frame_register = cfg80211_rtw_mgmt_frame_register,
+#endif
+#elif  (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,34) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,35))
+	.action = cfg80211_rtw_mgmt_tx,
+#endif
+
+#if defined(CONFIG_TDLS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+	.tdls_mgmt = cfg80211_rtw_tdls_mgmt,
+	.tdls_oper = cfg80211_rtw_tdls_oper,
+#endif /* CONFIG_TDLS */
+
+#if defined(CONFIG_PNO_SUPPORT) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+	.sched_scan_start = cfg80211_rtw_sched_scan_start,
+	.sched_scan_stop = cfg80211_rtw_sched_scan_stop,
+#endif /* CONFIG_PNO_SUPPORT */
+};
+
+struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev)
+{
+	struct wiphy *wiphy;
+	struct rtw_wiphy_data *wiphy_data;
+
+	/* wiphy */
+	wiphy = wiphy_new(&rtw_cfg80211_ops, sizeof(_adapter*));
+	if (!wiphy) {
+		DBG_8192C("Couldn't allocate wiphy device\n");
+		goto exit;
+	}
+	set_wiphy_dev(wiphy, dev);
+	*((_adapter**)wiphy_priv(wiphy)) = padapter;
+
+	rtw_cfg80211_preinit_wiphy(padapter, wiphy);
+	/* init regulary domain */
+	rtw_regd_init(wiphy);
+
+	DBG_871X(FUNC_WIPHY_FMT"\n", FUNC_WIPHY_ARG(wiphy));
+
+exit:
+	return wiphy;
+}
+
+void rtw_wiphy_free(struct wiphy *wiphy)
+{
+	if (!wiphy)
+		return;
+
+	DBG_871X(FUNC_WIPHY_FMT"\n", FUNC_WIPHY_ARG(wiphy));
+
+	if (wiphy->bands[NL80211_BAND_2GHZ]) {
+		rtw_spt_band_free(wiphy->bands[NL80211_BAND_2GHZ]);
+		wiphy->bands[NL80211_BAND_2GHZ] = NULL;
+	}
+	if (wiphy->bands[NL80211_BAND_5GHZ]) {
+		rtw_spt_band_free(wiphy->bands[NL80211_BAND_5GHZ]);
+		wiphy->bands[NL80211_BAND_5GHZ] = NULL;
+	}
+
+	wiphy_free(wiphy);
+}
+
+int rtw_wiphy_register(struct wiphy *wiphy)
+{
+	DBG_871X(FUNC_WIPHY_FMT"\n", FUNC_WIPHY_ARG(wiphy));
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT)
+	rtw_cfgvendor_attach(wiphy);
+#endif
+
+	return wiphy_register(wiphy);
+}
+
+void rtw_wiphy_unregister(struct wiphy *wiphy)
+{
+	DBG_871X(FUNC_WIPHY_FMT"\n", FUNC_WIPHY_ARG(wiphy));
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT)
+	rtw_cfgvendor_detach(wiphy);
+#endif
+
+	return wiphy_unregister(wiphy);
+}
+
+int rtw_wdev_alloc(_adapter *padapter, struct wiphy *wiphy)
+{
+	int ret = 0;
+	struct net_device *pnetdev = padapter->pnetdev;
+	struct wireless_dev *wdev;
+	struct rtw_wdev_priv *pwdev_priv;
+	
+	DBG_8192C("%s(padapter=%p)\n", __func__, padapter);
+
+	/*  wdev */
+	wdev = (struct wireless_dev *)rtw_zmalloc(sizeof(struct wireless_dev));
+	if (!wdev) {
+		DBG_8192C("Couldn't allocate wireless device\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+	wdev->wiphy = wiphy;
+	wdev->netdev = pnetdev;
+
+	wdev->iftype = NL80211_IFTYPE_STATION; // will be init in rtw_hal_init()
+	                                       // Must sync with _rtw_init_mlme_priv() 
+										   // pmlmepriv->fw_state = WIFI_STATION_STATE
+	//wdev->iftype = NL80211_IFTYPE_MONITOR; // for rtw_setopmode_cmd() in cfg80211_rtw_change_iface()
+	padapter->rtw_wdev = wdev;
+	pnetdev->ieee80211_ptr = wdev;
+
+	//init pwdev_priv
+	pwdev_priv = adapter_wdev_data(padapter);
+	pwdev_priv->rtw_wdev = wdev;
+	pwdev_priv->pmon_ndev = NULL;
+	pwdev_priv->ifname_mon[0] = '\0';
+	pwdev_priv->padapter = padapter;
+	pwdev_priv->scan_request = NULL;
+	_rtw_spinlock_init(&pwdev_priv->scan_req_lock);
+		
+	pwdev_priv->p2p_enabled = _FALSE;
+	pwdev_priv->provdisc_req_issued = _FALSE;
+	rtw_wdev_invit_info_init(&pwdev_priv->invit_info);
+	rtw_wdev_nego_info_init(&pwdev_priv->nego_info);
+		
+	pwdev_priv->bandroid_scan = _FALSE;
+
+	if(padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
+		pwdev_priv->power_mgmt = _TRUE;
+	else
+		pwdev_priv->power_mgmt = _FALSE;
+	
+#ifdef CONFIG_CONCURRENT_MODE
+	ATOMIC_SET(&pwdev_priv->switch_ch_to, 1);	
+	ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);	
+#endif
+
+exit:
+	return ret;
+}
+
+void rtw_wdev_free(struct wireless_dev *wdev)
+{
+	DBG_8192C("%s(wdev=%p)\n", __func__, wdev);
+
+	if (!wdev)
+		return;
+
+	rtw_mfree((u8*)wdev, sizeof(struct wireless_dev));
+}
+
+void rtw_wdev_unregister(struct wireless_dev *wdev)
+{
+	struct net_device *ndev;
+	_adapter *adapter;
+	struct rtw_wdev_priv *pwdev_priv;
+
+	DBG_8192C("%s(wdev=%p)\n", __func__, wdev);
+
+	if (!wdev)
+		return;
+
+	if(!(ndev = wdev_to_ndev(wdev)))
+		return;
+
+	adapter = (_adapter *)rtw_netdev_priv(ndev);
+	pwdev_priv = adapter_wdev_data(adapter);
+
+	rtw_cfg80211_indicate_scan_done(adapter, _TRUE);
+
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)) || defined(COMPAT_KERNEL_RELEASE)	
+	if (wdev->current_bss) {
+		DBG_871X(FUNC_ADPT_FMT" clear current_bss by cfg80211_disconnected\n", FUNC_ADPT_ARG(adapter));
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
+		cfg80211_disconnected(adapter->pnetdev, 0, NULL, 0, GFP_ATOMIC);
+	#else
+		cfg80211_disconnected(adapter->pnetdev, 0, NULL, 0, false, GFP_ATOMIC);
+	#endif
+	}
+	#endif
+
+	if (pwdev_priv->pmon_ndev) {
+		DBG_8192C("%s, unregister monitor interface\n", __func__);
+		unregister_netdev(pwdev_priv->pmon_ndev);
+	}
+}
+
+int rtw_cfg80211_ndev_res_alloc(_adapter *adapter)
+{
+	int ret = _FAIL;
+
+#if !defined(RTW_SINGLE_WIPHY)
+	struct wiphy *wiphy;
+	struct device *dev = dvobj_to_dev(adapter_to_dvobj(adapter));
+
+	wiphy = rtw_wiphy_alloc(adapter, dev);
+	if (wiphy == NULL)
+		goto exit;
+
+	adapter->wiphy = wiphy;
+#endif
+
+	if (rtw_wdev_alloc(adapter, adapter_to_wiphy(adapter)) == 0)
+		ret = _SUCCESS;
+
+#if !defined(RTW_SINGLE_WIPHY)
+	if (ret != _SUCCESS) {
+		rtw_wiphy_free(wiphy);
+		adapter->wiphy = NULL;
+	}
+#endif
+
+exit:
+	return ret;
+}
+
+void rtw_cfg80211_ndev_res_free(_adapter *adapter)
+{
+	rtw_wdev_free(adapter->rtw_wdev);
+#if !defined(RTW_SINGLE_WIPHY)
+	rtw_wiphy_free(adapter_to_wiphy(adapter));
+	adapter->wiphy = NULL;
+#endif
+}
+
+int rtw_cfg80211_ndev_res_register(_adapter *adapter)
+{
+	int ret = _FAIL;
+
+#if !defined(RTW_SINGLE_WIPHY)
+	if (rtw_wiphy_register(adapter_to_wiphy(adapter)) < 0) {
+		DBG_871X("%s rtw_wiphy_register fail for if%d\n", __func__, (adapter->iface_id+1));
+		goto exit;
+	}
+#endif
+
+	ret = _SUCCESS;
+
+exit:
+	return ret;
+}
+
+void rtw_cfg80211_ndev_res_unregister(_adapter *adapter)
+{
+	rtw_wdev_unregister(adapter->rtw_wdev);
+}
+
+int rtw_cfg80211_dev_res_alloc(struct dvobj_priv *dvobj)
+{
+	int ret = _FAIL;
+
+#if defined(RTW_SINGLE_WIPHY)
+	struct wiphy *wiphy;
+	struct device *dev = dvobj_to_dev(dvobj);
+
+	wiphy = rtw_wiphy_alloc(dvobj->padapters[IFACE_ID0], dev);
+	if (wiphy == NULL)
+		goto exit;
+
+	dvobj->wiphy = wiphy;
+#endif
+
+	ret = _SUCCESS;
+
+exit:
+	return ret;
+}
+
+void rtw_cfg80211_dev_res_free(struct dvobj_priv *dvobj)
+{
+#if defined(RTW_SINGLE_WIPHY)
+	rtw_wiphy_free(dvobj_to_wiphy(dvobj));
+	dvobj->wiphy = NULL;
+#endif
+}
+
+int rtw_cfg80211_dev_res_register(struct dvobj_priv *dvobj)
+{
+	int ret = _FAIL;
+
+#if defined(RTW_SINGLE_WIPHY)
+	if (rtw_wiphy_register(dvobj_to_wiphy(dvobj)) != 0)
+		goto exit;
+#endif
+
+	ret = _SUCCESS;
+
+exit:
+	return ret;
+}
+
+void rtw_cfg80211_dev_res_unregister(struct dvobj_priv *dvobj)
+{
+#if defined(RTW_SINGLE_WIPHY)
+	rtw_wiphy_unregister(dvobj_to_wiphy(dvobj));
+#endif
+}
+
+#endif /* CONFIG_IOCTL_CFG80211 */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_cfg80211.h b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_cfg80211.h
new file mode 100644
index 000000000..70fecd565
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_cfg80211.h
@@ -0,0 +1,212 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __IOCTL_CFG80211_H__
+#define __IOCTL_CFG80211_H__ 
+
+
+#if defined(RTW_USE_CFG80211_STA_EVENT)
+	#undef CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
+#endif
+
+struct rtw_wdev_invit_info {
+	u8 state; /* 0: req, 1:rep */
+	u8 peer_mac[ETH_ALEN];
+	u8 active;
+	u8 token;
+	u8 flags;
+	u8 status;
+	u8 req_op_ch;
+	u8 rsp_op_ch;
+};
+
+#define rtw_wdev_invit_info_init(invit_info) \
+	do { \
+		(invit_info)->state = 0xff; \
+		_rtw_memset((invit_info)->peer_mac, 0, ETH_ALEN); \
+		(invit_info)->active = 0xff; \
+		(invit_info)->token = 0; \
+		(invit_info)->flags = 0x00; \
+		(invit_info)->status = 0xff; \
+		(invit_info)->req_op_ch = 0; \
+		(invit_info)->rsp_op_ch = 0; \
+	} while (0)
+
+struct rtw_wdev_nego_info {
+	u8 state; /* 0: req, 1:rep, 2:conf */
+	u8 peer_mac[ETH_ALEN];
+	u8 active;
+	u8 token;
+	u8 status;
+	u8 req_intent;
+	u8 req_op_ch;
+	u8 req_listen_ch;
+	u8 rsp_intent;
+	u8 rsp_op_ch;
+	u8 conf_op_ch;
+};
+
+#define rtw_wdev_nego_info_init(nego_info) \
+	do { \
+		(nego_info)->state = 0xff; \
+		_rtw_memset((nego_info)->peer_mac, 0, ETH_ALEN); \
+		(nego_info)->active = 0xff; \
+		(nego_info)->token = 0; \
+		(nego_info)->status = 0xff; \
+		(nego_info)->req_intent = 0xff; \
+		(nego_info)->req_op_ch = 0; \
+		(nego_info)->req_listen_ch = 0; \
+		(nego_info)->rsp_intent = 0xff; \
+		(nego_info)->rsp_op_ch = 0; \
+		(nego_info)->conf_op_ch = 0; \
+	} while (0)
+
+struct rtw_wdev_priv
+{	
+	struct wireless_dev *rtw_wdev;
+	
+	_adapter *padapter;
+
+	struct cfg80211_scan_request *scan_request;
+	_lock scan_req_lock;
+
+	struct net_device *pmon_ndev;//for monitor interface
+	char ifname_mon[IFNAMSIZ + 1]; //interface name for monitor interface
+
+	u8 p2p_enabled;
+
+	u8 provdisc_req_issued;
+
+	struct rtw_wdev_invit_info invit_info;
+	struct rtw_wdev_nego_info nego_info;
+
+	u8 bandroid_scan;
+	bool block;
+	bool block_scan;
+	bool power_mgmt;
+
+	/* report mgmt_frame registered */
+	u16 report_mgmt;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	ATOMIC_T ro_ch_to;
+	ATOMIC_T switch_ch_to;	
+#endif	
+	
+};
+
+#define wiphy_to_adapter(x) (*((_adapter**)wiphy_priv(x)))
+
+#define wdev_to_ndev(w) ((w)->netdev)
+#define wdev_to_wiphy(w) ((w)->wiphy)
+#define ndev_to_wdev(n) ((n)->ieee80211_ptr)
+
+#define WIPHY_FMT "%s"
+#define WIPHY_ARG(wiphy) wiphy_name(wiphy)
+#define FUNC_WIPHY_FMT "%s("WIPHY_FMT")"
+#define FUNC_WIPHY_ARG(wiphy) __func__, WIPHY_ARG(wiphy)
+
+#define SET_CFG80211_REPORT_MGMT(w, t, v) (w->report_mgmt |= (v?BIT(t >> 4):0))
+#define GET_CFG80211_REPORT_MGMT(w, t) ((w->report_mgmt & BIT(t >> 4)) > 0)
+
+struct wiphy *rtw_wiphy_alloc(_adapter *padapter, struct device *dev);
+void rtw_wiphy_free(struct wiphy *wiphy);
+int rtw_wiphy_register(struct wiphy *wiphy);
+void rtw_wiphy_unregister(struct wiphy *wiphy);
+
+int rtw_wdev_alloc(_adapter *padapter, struct wiphy *wiphy);
+void rtw_wdev_free(struct wireless_dev *wdev);
+void rtw_wdev_unregister(struct wireless_dev *wdev);
+
+int rtw_cfg80211_ndev_res_alloc(_adapter *adapter);
+void rtw_cfg80211_ndev_res_free(_adapter *adapter);
+int rtw_cfg80211_ndev_res_register(_adapter *adapter);
+void rtw_cfg80211_ndev_res_unregister(_adapter *adapter);
+
+int rtw_cfg80211_dev_res_alloc(struct dvobj_priv *dvobj);
+void rtw_cfg80211_dev_res_free(struct dvobj_priv *dvobj);
+int rtw_cfg80211_dev_res_register(struct dvobj_priv *dvobj);
+void rtw_cfg80211_dev_res_unregister(struct dvobj_priv *dvobj);
+
+void rtw_cfg80211_init_wiphy(_adapter *padapter);
+
+void rtw_cfg80211_unlink_bss(_adapter *padapter, struct wlan_network *pnetwork);
+void rtw_cfg80211_surveydone_event_callback(_adapter *padapter);
+struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnetwork);
+int rtw_cfg80211_check_bss(_adapter *padapter);
+void rtw_cfg80211_ibss_indicate_connect(_adapter *padapter);
+void rtw_cfg80211_indicate_connect(_adapter *padapter);
+void rtw_cfg80211_indicate_disconnect(_adapter *padapter);
+void rtw_cfg80211_indicate_scan_done(_adapter *adapter, bool aborted);
+u32 rtw_cfg80211_wait_scan_req_empty(_adapter *adapter, u32 timeout_ms);
+
+#ifdef CONFIG_AP_MODE
+void rtw_cfg80211_indicate_sta_assoc(_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
+void rtw_cfg80211_indicate_sta_disassoc(_adapter *padapter, unsigned char *da, unsigned short reason);
+#endif //CONFIG_AP_MODE
+
+void rtw_cfg80211_issue_p2p_provision_request(_adapter *padapter, const u8 *buf, size_t len);
+void rtw_cfg80211_rx_p2p_action_public(_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
+void rtw_cfg80211_rx_action_p2p(_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
+void rtw_cfg80211_rx_action(_adapter *adapter, u8 *frame, uint frame_len, const char*msg);
+void rtw_cfg80211_rx_probe_request(_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
+
+int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len, int type);
+
+bool rtw_cfg80211_pwr_mgmt(_adapter *adapter);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))  && !defined(COMPAT_KERNEL_RELEASE)
+#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->pnetdev, freq, buf, len, gfp)
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
+#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->pnetdev, freq, sig_dbm, buf, len, gfp)
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, gfp)
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3 , 18 , 0))
+#define rtw_cfg80211_rx_mgmt(adapter , freq , sig_dbm , buf , len , gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev , freq , sig_dbm , buf , len , 0 , gfp)
+#else
+#define rtw_cfg80211_rx_mgmt(adapter , freq , sig_dbm , buf , len , gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev , freq , sig_dbm , buf , len , 0)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))  && !defined(COMPAT_KERNEL_RELEASE)
+#define rtw_cfg80211_send_rx_assoc(adapter, bss, buf, len) cfg80211_send_rx_assoc((adapter)->pnetdev, buf, len)
+#else
+#define rtw_cfg80211_send_rx_assoc(adapter, bss, buf, len) cfg80211_send_rx_assoc((adapter)->pnetdev, bss, buf, len)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
+#define rtw_cfg80211_mgmt_tx_status(adapter, cookie, buf, len, ack, gfp) cfg80211_mgmt_tx_status((adapter)->pnetdev, cookie, buf, len, ack, gfp)
+#else
+#define rtw_cfg80211_mgmt_tx_status(adapter, cookie, buf, len, ack, gfp) cfg80211_mgmt_tx_status((adapter)->rtw_wdev, cookie, buf, len, ack, gfp)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
+#define rtw_cfg80211_ready_on_channel(adapter, cookie, chan, channel_type, duration, gfp)  cfg80211_ready_on_channel((adapter)->pnetdev, cookie, chan, channel_type, duration, gfp)
+#define rtw_cfg80211_remain_on_channel_expired(adapter, cookie, chan, chan_type, gfp) cfg80211_remain_on_channel_expired((adapter)->pnetdev, cookie, chan, chan_type, gfp)
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
+#define rtw_cfg80211_ready_on_channel(adapter, cookie, chan, channel_type, duration, gfp)  cfg80211_ready_on_channel((adapter)->rtw_wdev, cookie, chan, channel_type, duration, gfp)
+#define rtw_cfg80211_remain_on_channel_expired(adapter, cookie, chan, chan_type, gfp) cfg80211_remain_on_channel_expired((adapter)->rtw_wdev, cookie, chan, chan_type, gfp)
+#else
+#define rtw_cfg80211_ready_on_channel(adapter, cookie, chan, channel_type, duration, gfp)  cfg80211_ready_on_channel((adapter)->rtw_wdev, cookie, chan, duration, gfp)
+#define rtw_cfg80211_remain_on_channel_expired(adapter, cookie, chan, chan_type, gfp) cfg80211_remain_on_channel_expired((adapter)->rtw_wdev, cookie, chan, gfp)
+#endif
+
+#include "rtw_cfgvendor.h"
+
+#endif //__IOCTL_CFG80211_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_linux.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_linux.c
new file mode 100644
index 000000000..6f4d04592
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_linux.c
@@ -0,0 +1,13919 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _IOCTL_LINUX_C_
+
+#include <drv_types.h>
+#include <rtw_mp.h>
+#include <rtw_mp_ioctl.h>
+#include "../../hal/phydm/phydm_precomp.h"
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+#define  iwe_stream_add_event(a, b, c, d, e)  iwe_stream_add_event(b, c, d, e)
+#define  iwe_stream_add_point(a, b, c, d, e)  iwe_stream_add_point(b, c, d, e)
+#endif
+
+#ifdef CONFIG_80211N_HT
+extern int rtw_ht_enable;
+#endif
+
+
+#define RTL_IOCTL_WPA_SUPPLICANT	SIOCIWFIRSTPRIV+30
+
+#define SCAN_ITEM_SIZE 768
+#define MAX_CUSTOM_LEN 64
+#define RATE_COUNT 4
+
+#ifdef CONFIG_GLOBAL_UI_PID
+extern int ui_pid[3];
+#endif
+
+// combo scan
+#define WEXT_CSCAN_AMOUNT 9
+#define WEXT_CSCAN_BUF_LEN		360
+#define WEXT_CSCAN_HEADER		"CSCAN S\x01\x00\x00S\x00"
+#define WEXT_CSCAN_HEADER_SIZE		12
+#define WEXT_CSCAN_SSID_SECTION		'S'
+#define WEXT_CSCAN_CHANNEL_SECTION	'C'
+#define WEXT_CSCAN_NPROBE_SECTION	'N'
+#define WEXT_CSCAN_ACTV_DWELL_SECTION	'A'
+#define WEXT_CSCAN_PASV_DWELL_SECTION	'P'
+#define WEXT_CSCAN_HOME_DWELL_SECTION	'H'
+#define WEXT_CSCAN_TYPE_SECTION		'T'
+
+
+extern u8 key_2char2num(u8 hch, u8 lch);
+extern u8 str_2char2num(u8 hch, u8 lch);
+extern void macstr2num(u8 *dst, u8 *src);
+extern u8 convert_ip_addr(u8 hch, u8 mch, u8 lch);
+
+u32 rtw_rates[] = {1000000,2000000,5500000,11000000,
+	6000000,9000000,12000000,18000000,24000000,36000000,48000000,54000000};
+
+static const char * const iw_operation_mode[] = 
+{ 
+	"Auto", "Ad-Hoc", "Managed",  "Master", "Repeater", "Secondary", "Monitor" 
+};
+
+static int hex2num_i(char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if (c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return -1;
+}
+
+static int hex2byte_i(const char *hex)
+{
+	int a, b;
+	a = hex2num_i(*hex++);
+	if (a < 0)
+		return -1;
+	b = hex2num_i(*hex++);
+	if (b < 0)
+		return -1;
+	return (a << 4) | b;
+}
+
+/**
+ * hwaddr_aton - Convert ASCII string to MAC address
+ * @txt: MAC address as a string (e.g., "00:11:22:33:44:55")
+ * @addr: Buffer for the MAC address (ETH_ALEN = 6 bytes)
+ * Returns: 0 on success, -1 on failure (e.g., string not a MAC address)
+ */
+static int hwaddr_aton_i(const char *txt, u8 *addr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		int a, b;
+
+		a = hex2num_i(*txt++);
+		if (a < 0)
+			return -1;
+		b = hex2num_i(*txt++);
+		if (b < 0)
+			return -1;
+		*addr++ = (a << 4) | b;
+		if (i < 5 && *txt++ != ':')
+			return -1;
+	}
+
+	return 0;
+}
+
+static void indicate_wx_custom_event(_adapter *padapter, char *msg)
+{
+	u8 *buff, *p;
+	union iwreq_data wrqu;
+
+	if (strlen(msg) > IW_CUSTOM_MAX) {
+		DBG_871X("%s strlen(msg):%zu > IW_CUSTOM_MAX:%u\n", __FUNCTION__ , strlen(msg), IW_CUSTOM_MAX);
+		return;
+	}
+
+	buff = rtw_zmalloc(IW_CUSTOM_MAX+1);
+	if(!buff)
+		return;
+
+	_rtw_memcpy(buff, msg, strlen(msg));
+		
+	_rtw_memset(&wrqu,0,sizeof(wrqu));
+	wrqu.data.length = strlen(msg);
+
+	DBG_871X("%s %s\n", __FUNCTION__, buff);	
+#ifndef CONFIG_IOCTL_CFG80211
+	wireless_send_event(padapter->pnetdev, IWEVCUSTOM, &wrqu, buff);
+#endif
+
+	rtw_mfree(buff, IW_CUSTOM_MAX+1);
+
+}
+
+
+static void request_wps_pbc_event(_adapter *padapter)
+{
+	u8 *buff, *p;
+	union iwreq_data wrqu;
+
+
+	buff = rtw_malloc(IW_CUSTOM_MAX);
+	if(!buff)
+		return;
+		
+	_rtw_memset(buff, 0, IW_CUSTOM_MAX);
+		
+	p=buff;
+		
+	p+=sprintf(p, "WPS_PBC_START.request=TRUE");
+		
+	_rtw_memset(&wrqu,0,sizeof(wrqu));
+		
+	wrqu.data.length = p-buff;
+		
+	wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
+
+	DBG_871X("%s\n", __FUNCTION__);
+		
+#ifndef CONFIG_IOCTL_CFG80211
+	wireless_send_event(padapter->pnetdev, IWEVCUSTOM, &wrqu, buff);
+#endif
+
+	if(buff)
+	{
+		rtw_mfree(buff, IW_CUSTOM_MAX);
+	}
+
+}
+
+#ifdef CONFIG_SUPPORT_HW_WPS_PBC
+void rtw_request_wps_pbc_event(_adapter *padapter)
+{
+#ifdef RTK_DMP_PLATFORM
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12))
+	kobject_uevent(&padapter->pnetdev->dev.kobj, KOBJ_NET_PBC);
+#else
+	kobject_hotplug(&padapter->pnetdev->class_dev.kobj, KOBJ_NET_PBC);
+#endif
+#else
+
+	if ( padapter->pid[0] == 0 )
+	{	//	0 is the default value and it means the application monitors the HW PBC doesn't privde its pid to driver.
+		return;
+	}
+
+	rtw_signal_process(padapter->pid[0], SIGUSR1);
+
+#endif
+
+	rtw_led_control(padapter, LED_CTL_START_WPS_BOTTON);
+}
+#endif//#ifdef CONFIG_SUPPORT_HW_WPS_PBC
+
+void indicate_wx_scan_complete_event(_adapter *padapter)
+{	
+	union iwreq_data wrqu;
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;	
+
+	_rtw_memset(&wrqu, 0, sizeof(union iwreq_data));
+
+	//DBG_871X("+rtw_indicate_wx_scan_complete_event\n");
+#ifndef CONFIG_IOCTL_CFG80211
+	wireless_send_event(padapter->pnetdev, SIOCGIWSCAN, &wrqu, NULL);
+#endif
+}
+
+
+void rtw_indicate_wx_assoc_event(_adapter *padapter)
+{	
+	union iwreq_data wrqu;
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+
+	_rtw_memset(&wrqu, 0, sizeof(union iwreq_data));
+	
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;	
+	
+	if(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_TRUE )
+		_rtw_memcpy(wrqu.ap_addr.sa_data, pnetwork->MacAddress, ETH_ALEN);
+	else
+		_rtw_memcpy(wrqu.ap_addr.sa_data, pmlmepriv->cur_network.network.MacAddress, ETH_ALEN);
+
+	DBG_871X_LEVEL(_drv_always_, "assoc success\n");
+#ifndef CONFIG_IOCTL_CFG80211
+	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
+#endif
+}
+
+void rtw_indicate_wx_disassoc_event(_adapter *padapter)
+{	
+	union iwreq_data wrqu;
+
+	_rtw_memset(&wrqu, 0, sizeof(union iwreq_data));
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	_rtw_memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
+
+#ifndef CONFIG_IOCTL_CFG80211
+	DBG_871X_LEVEL(_drv_always_, "indicate disassoc\n");
+	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
+#endif
+}
+
+/*
+uint	rtw_is_cckrates_included(u8 *rate)
+{	
+		u32	i = 0;			
+
+		while(rate[i]!=0)
+		{		
+			if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||		
+			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )		
+			return _TRUE;	
+			i++;
+		}
+		
+		return _FALSE;
+}
+
+uint	rtw_is_cckratesonly_included(u8 *rate)
+{
+	u32 i = 0;
+
+	while(rate[i]!=0)
+	{
+			if  (  (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+				(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
+			return _FALSE;		
+			i++;
+	}
+	
+	return _TRUE;
+}
+*/
+
+static int search_p2p_wfd_ie(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop)
+{
+#ifdef CONFIG_P2P
+	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
+#ifdef CONFIG_WFD
+	if ( SCAN_RESULT_ALL == pwdinfo->wfd_info->scan_result_type )
+	{
+
+	}
+	else if ( ( SCAN_RESULT_P2P_ONLY == pwdinfo->wfd_info->scan_result_type ) || 
+		      ( SCAN_RESULT_WFD_TYPE == pwdinfo->wfd_info->scan_result_type ) )
+#endif // CONFIG_WFD
+	{
+		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		{
+			u32	blnGotP2PIE = _FALSE;
+			
+			//	User is doing the P2P device discovery
+			//	The prefix of SSID should be "DIRECT-" and the IE should contains the P2P IE.
+			//	If not, the driver should ignore this AP and go to the next AP.
+
+			//	Verifying the SSID
+			if ( _rtw_memcmp( pnetwork->network.Ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN ) )
+			{
+				u32	p2pielen = 0;
+
+				//	Verifying the P2P IE
+				if (rtw_bss_ex_get_p2p_ie(&pnetwork->network, NULL, &p2pielen))
+					blnGotP2PIE = _TRUE;
+			}
+
+			if ( blnGotP2PIE == _FALSE )
+			{
+				return _FALSE;
+			}
+			
+		}
+	}
+
+#ifdef CONFIG_WFD
+	if ( SCAN_RESULT_WFD_TYPE == pwdinfo->wfd_info->scan_result_type )
+	{
+		u32	blnGotWFD = _FALSE;
+		u8 *wfd_ie;
+		uint wfd_ielen = 0;
+
+		wfd_ie = rtw_bss_ex_get_wfd_ie(&pnetwork->network, NULL, &wfd_ielen);
+		if (wfd_ie) {
+			u8 *wfd_devinfo;
+			uint wfd_devlen;
+
+			wfd_devinfo = rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, NULL, &wfd_devlen);
+			if (wfd_devinfo) {
+				if ( pwdinfo->wfd_info->wfd_device_type == WFD_DEVINFO_PSINK )
+				{
+					//	the first two bits will indicate the WFD device type
+					if ( ( wfd_devinfo[ 1 ] & 0x03 ) == WFD_DEVINFO_SOURCE )
+					{
+						//	If this device is Miracast PSink device, the scan reuslt should just provide the Miracast source.
+						blnGotWFD = _TRUE;
+					}
+				}
+				else if ( pwdinfo->wfd_info->wfd_device_type == WFD_DEVINFO_SOURCE )
+				{
+					//	the first two bits will indicate the WFD device type
+					if ( ( wfd_devinfo[ 1 ] & 0x03 ) == WFD_DEVINFO_PSINK )
+					{
+						//	If this device is Miracast source device, the scan reuslt should just provide the Miracast PSink.
+						//	Todo: How about the SSink?!
+						blnGotWFD = _TRUE;
+					}
+				}
+			}
+		}
+		
+		if ( blnGotWFD == _FALSE )
+		{
+			return _FALSE;
+		}
+	}
+#endif // CONFIG_WFD
+
+#endif //CONFIG_P2P
+	return _TRUE;
+}
+ static inline char *iwe_stream_mac_addr_proess(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{	
+	/*  AP MAC address  */
+	iwe->cmd = SIOCGIWAP;
+	iwe->u.ap_addr.sa_family = ARPHRD_ETHER;
+
+	_rtw_memcpy(iwe->u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);
+	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_ADDR_LEN);	
+	return start;
+}
+ static inline char * iwe_stream_essid_proess(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	
+	/* Add the ESSID */
+	iwe->cmd = SIOCGIWESSID;
+	iwe->u.data.flags = 1;	
+	iwe->u.data.length = min((u16)pnetwork->network.Ssid.SsidLength, (u16)32);
+	start = iwe_stream_add_point(info, start, stop, iwe, pnetwork->network.Ssid.Ssid);		
+	return start;
+}
+
+ static inline char * iwe_stream_chan_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	if(pnetwork->network.Configuration.DSConfig<1 /*|| pnetwork->network.Configuration.DSConfig>14*/)
+		pnetwork->network.Configuration.DSConfig = 1;
+
+	 /* Add frequency/channel */
+	iwe->cmd = SIOCGIWFREQ;
+	iwe->u.freq.m = rtw_ch2freq(pnetwork->network.Configuration.DSConfig) * 100000;
+	iwe->u.freq.e = 1;
+	iwe->u.freq.i = pnetwork->network.Configuration.DSConfig;
+	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_FREQ_LEN);
+	return start;
+}
+ static inline char * iwe_stream_mode_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe,u16 cap)
+{
+	/* Add mode */
+	if(cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)){
+		iwe->cmd = SIOCGIWMODE;
+		if (cap & WLAN_CAPABILITY_BSS)
+			iwe->u.mode = IW_MODE_MASTER;
+		else
+			iwe->u.mode = IW_MODE_ADHOC;
+
+		start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_UINT_LEN);
+	}
+	return start;
+ }
+ static inline char * iwe_stream_encryption_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe,u16 cap)
+{	
+
+	/* Add encryption capability */
+	iwe->cmd = SIOCGIWENCODE;
+	if (cap & WLAN_CAPABILITY_PRIVACY)
+		iwe->u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe->u.data.flags = IW_ENCODE_DISABLED;
+	iwe->u.data.length = 0;
+	start = iwe_stream_add_point(info, start, stop, iwe, pnetwork->network.Ssid.Ssid);
+	return start;
+
+}	
+
+ static inline char * iwe_stream_protocol_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+ {
+ 	u16 ht_cap=_FALSE,vht_cap = _FALSE;
+	u32 ht_ielen = 0, vht_ielen = 0;
+	char *p;
+	u8 ie_offset = (pnetwork->network.Reserved[0] == 2? 0:12);// Probe Request	
+		
+	//parsing HT_CAP_IE	
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-ie_offset);	
+	if(p && ht_ielen>0)		
+		ht_cap = _TRUE;			
+
+	#ifdef CONFIG_80211AC_VHT
+	//parsing VHT_CAP_IE
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], EID_VHTCapability, &vht_ielen, pnetwork->network.IELength-ie_offset);
+	if(p && vht_ielen>0)
+		vht_cap = _TRUE;	
+	#endif
+	 /* Add the protocol name */
+	iwe->cmd = SIOCGIWNAME;
+	if ((rtw_is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)		
+	{
+		if(ht_cap == _TRUE)
+			snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11bn");
+		else
+			snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11b");
+	}	
+	else if ((rtw_is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)	
+	{
+		if(ht_cap == _TRUE)
+			snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11bgn");
+		else
+			snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11bg");
+	}	
+	else
+	{
+		if(pnetwork->network.Configuration.DSConfig > 14)
+		{
+			#ifdef CONFIG_80211AC_VHT
+			if(vht_cap == _TRUE){
+				snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11AC");
+			}
+			else 
+			#endif	
+			{
+				if(ht_cap == _TRUE)
+					snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11an");
+				else
+					snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11a");
+			}
+		}
+		else
+		{
+			if(ht_cap == _TRUE)
+				snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11gn");
+			else
+				snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11g");
+		}
+	}
+	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_CHAR_LEN);
+	return start;
+ }
+				
+ static inline char * iwe_stream_rate_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	u32 ht_ielen = 0, vht_ielen = 0;
+	char *p;
+	u16 max_rate=0, rate, ht_cap=_FALSE, vht_cap = _FALSE;
+	u32 i = 0;		
+	u8 bw_40MHz=0, short_GI=0, bw_160MHz=0, vht_highest_rate = 0;
+	u16 mcs_rate=0, vht_data_rate=0;
+	char custom[MAX_CUSTOM_LEN]={0};
+	u8 ie_offset = (pnetwork->network.Reserved[0] == 2? 0:12);// Probe Request	
+ 	
+	//parsing HT_CAP_IE	
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-ie_offset);	
+	if(p && ht_ielen>0)
+	{
+		struct rtw_ieee80211_ht_cap *pht_capie;
+		ht_cap = _TRUE;			
+		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);		
+		_rtw_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
+		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
+	}
+
+#ifdef CONFIG_80211AC_VHT
+	//parsing VHT_CAP_IE
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], EID_VHTCapability, &vht_ielen, pnetwork->network.IELength-ie_offset);
+	if(p && vht_ielen>0)
+	{
+		u8	mcs_map[2];
+
+		vht_cap = _TRUE;		
+		bw_160MHz = GET_VHT_CAPABILITY_ELE_CHL_WIDTH(p+2);
+		if(bw_160MHz)
+			short_GI = GET_VHT_CAPABILITY_ELE_SHORT_GI160M(p+2);
+		else
+			short_GI = GET_VHT_CAPABILITY_ELE_SHORT_GI80M(p+2);
+
+		_rtw_memcpy(mcs_map, GET_VHT_CAPABILITY_ELE_TX_MCS(p+2), 2);
+
+		vht_highest_rate = rtw_get_vht_highest_rate(mcs_map);
+		vht_data_rate = rtw_vht_mcs_to_data_rate(CHANNEL_WIDTH_80, short_GI, vht_highest_rate);
+	}
+#endif	
+	
+	/*Add basic and extended rates */	
+	p = custom;
+	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
+	while(pnetwork->network.SupportedRates[i]!=0)
+	{
+		rate = pnetwork->network.SupportedRates[i]&0x7F; 
+		if (rate > max_rate)
+			max_rate = rate;
+		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
+			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
+		i++;
+	}
+#ifdef CONFIG_80211AC_VHT
+	if(vht_cap == _TRUE) {
+		max_rate = vht_data_rate;
+	}
+	else
+#endif		
+	if(ht_cap == _TRUE)
+	{
+		if(mcs_rate&0x8000)//MCS15
+		{
+			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
+			
+		}
+		else if(mcs_rate&0x0080)//MCS7
+		{
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		}
+		else//default MCS7
+		{
+			//DBG_871X("wx_get_scan, mcs_rate_bitmap=0x%x\n", mcs_rate);
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		}
+
+		max_rate = max_rate*2;//Mbps/2;		
+	}
+
+	iwe->cmd = SIOCGIWRATE;
+	iwe->u.bitrate.fixed = iwe->u.bitrate.disabled = 0;
+	iwe->u.bitrate.value = max_rate * 500000;
+	start =iwe_stream_add_event(info, start, stop, iwe, IW_EV_PARAM_LEN);
+	return start ;
+}
+
+static inline char * iwe_stream_wpa_wpa2_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	int buf_size = MAX_WPA_IE_LEN*2;
+	//u8 pbuf[buf_size]={0};	
+	u8 *pbuf = rtw_zmalloc(buf_size);
+
+	u8 wpa_ie[255]={0},rsn_ie[255]={0};
+	u16 i, wpa_len=0,rsn_len=0;
+	u8 *p;
+	sint out_len=0;
+		
+	
+	if(pbuf){
+		p=pbuf;	
+	
+		//parsing WPA/WPA2 IE
+		if (pnetwork->network.Reserved[0] != 2) // Probe Request
+		{	
+			out_len=rtw_get_sec_ie(pnetwork->network.IEs ,pnetwork->network.IELength,rsn_ie,&rsn_len,wpa_ie,&wpa_len);
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: ssid=%s\n",pnetwork->network.Ssid.Ssid));
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: wpa_len=%d rsn_len=%d\n",wpa_len,rsn_len));
+
+			if (wpa_len > 0){
+				
+				_rtw_memset(pbuf, 0, buf_size);
+				p += sprintf(p, "wpa_ie=");
+				for (i = 0; i < wpa_len; i++) {
+					p += sprintf(p, "%02x", wpa_ie[i]);
+				}
+
+				if (wpa_len > 100) {
+					printk("-----------------Len %d----------------\n", wpa_len);
+					for (i = 0; i < wpa_len; i++) {
+						printk("%02x ", wpa_ie[i]);
+					}
+					printk("\n");
+					printk("-----------------Len %d----------------\n", wpa_len);
+				}
+		
+				_rtw_memset(iwe, 0, sizeof(*iwe));
+				iwe->cmd = IWEVCUSTOM;
+				iwe->u.data.length = strlen(pbuf);
+				start = iwe_stream_add_point(info, start, stop, iwe,pbuf);
+				
+				_rtw_memset(iwe, 0, sizeof(*iwe));
+				iwe->cmd =IWEVGENIE;
+				iwe->u.data.length = wpa_len;
+				start = iwe_stream_add_point(info, start, stop, iwe, wpa_ie);			
+			}
+			if (rsn_len > 0){
+				
+				_rtw_memset(pbuf, 0, buf_size);
+				p += sprintf(p, "rsn_ie=");
+				for (i = 0; i < rsn_len; i++) {
+					p += sprintf(p, "%02x", rsn_ie[i]);
+				}
+				_rtw_memset(iwe, 0, sizeof(*iwe));
+				iwe->cmd = IWEVCUSTOM;
+				iwe->u.data.length = strlen(pbuf);
+				start = iwe_stream_add_point(info, start, stop, iwe,pbuf);
+			
+				_rtw_memset(iwe, 0, sizeof(*iwe));
+				iwe->cmd =IWEVGENIE;
+				iwe->u.data.length = rsn_len;
+				start = iwe_stream_add_point(info, start, stop, iwe, rsn_ie);		
+			}
+		}
+	
+		rtw_mfree(pbuf, buf_size);	
+	}
+	return start;
+}
+
+static inline char * iwe_stream_wps_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{	
+ 	//parsing WPS IE
+	uint cnt = 0,total_ielen;	
+	u8 *wpsie_ptr=NULL;
+	uint wps_ielen = 0;		
+	u8 ie_offset = (pnetwork->network.Reserved[0] == 2? 0:12);
+	
+	u8 *ie_ptr = pnetwork->network.IEs + ie_offset;
+	total_ielen= pnetwork->network.IELength - ie_offset;
+
+	if (pnetwork->network.Reserved[0] == 2) // Probe Request
+	{
+		ie_ptr = pnetwork->network.IEs;
+		total_ielen = pnetwork->network.IELength;
+	}
+	else     // Beacon or Probe Respones
+	{
+		ie_ptr = pnetwork->network.IEs + _FIXED_IE_LENGTH_;
+		total_ielen = pnetwork->network.IELength - _FIXED_IE_LENGTH_;
+	}    
+	while(cnt < total_ielen)
+	{
+		if(rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2))			
+		{
+			wpsie_ptr = &ie_ptr[cnt];
+			iwe->cmd =IWEVGENIE;
+			iwe->u.data.length = (u16)wps_ielen;
+			start = iwe_stream_add_point(info, start, stop,iwe, wpsie_ptr);						
+		}			
+		cnt+=ie_ptr[cnt+1]+2; //goto next
+	}
+	return start;
+}
+
+static inline char * iwe_stream_wapi_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+#ifdef CONFIG_WAPI_SUPPORT
+	char *p;
+		
+	if (pnetwork->network.Reserved[0] != 2) // Probe Request
+	{		
+		sint out_len_wapi=0;
+		/* here use static for stack size */
+		static u8 buf_wapi[MAX_WAPI_IE_LEN*2]={0};
+		static u8 wapi_ie[MAX_WAPI_IE_LEN]={0};
+		u16 wapi_len=0;
+		u16  i;
+
+		out_len_wapi=rtw_get_wapi_ie(pnetwork->network.IEs ,pnetwork->network.IELength,wapi_ie,&wapi_len);
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: ssid=%s\n",pnetwork->network.Ssid.Ssid));
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: wapi_len=%d \n",wapi_len));
+
+		DBG_871X("rtw_wx_get_scan: %s ",pnetwork->network.Ssid.Ssid);
+		DBG_871X("rtw_wx_get_scan: ssid = %d ",wapi_len);
+
+
+		if (wapi_len > 0)
+		{
+			p=buf_wapi;
+			//_rtw_memset(buf_wapi, 0, MAX_WAPI_IE_LEN*2);
+			p += sprintf(p, "wapi_ie=");
+			for (i = 0; i < wapi_len; i++) {
+				p += sprintf(p, "%02x", wapi_ie[i]);
+			}
+
+			_rtw_memset(iwe, 0, sizeof(*iwe));
+			iwe->cmd = IWEVCUSTOM;
+			iwe->u.data.length = strlen(buf_wapi);
+			start = iwe_stream_add_point(info, start, stop, iwe,buf_wapi);
+
+			_rtw_memset(iwe, 0, sizeof(*iwe));
+			iwe->cmd =IWEVGENIE;
+			iwe->u.data.length = wapi_len;
+			start = iwe_stream_add_point(info, start, stop, iwe, wapi_ie);
+		}
+	}
+#endif//#ifdef CONFIG_WAPI_SUPPORT
+	return start;
+}
+
+static inline char *  iwe_stream_rssi_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	u8 ss, sq;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	
+	/* Add quality statistics */
+	iwe->cmd = IWEVQUAL;
+	iwe->u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED 
+	#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+		| IW_QUAL_NOISE_UPDATED
+	#else
+		| IW_QUAL_NOISE_INVALID
+	#endif
+	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+		| IW_QUAL_DBM
+	#endif
+	;
+
+	if ( check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE &&
+		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network, 0)){
+		ss = padapter->recvpriv.signal_strength;
+		sq = padapter->recvpriv.signal_qual;
+	} else {
+		ss = pnetwork->network.PhyInfo.SignalStrength;
+		sq = pnetwork->network.PhyInfo.SignalQuality;
+	}
+	
+	
+	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+	iwe->u.qual.level = (u8) translate_percentage_to_dbm(ss); /* dbm */
+	#else
+	#ifdef CONFIG_SIGNAL_SCALE_MAPPING
+	iwe->u.qual.level = (u8)ss; /* % */
+	#else
+	{
+		/* Do signal scale mapping when using percentage as the unit of signal strength, since the scale mapping is skipped in odm */
+		
+		HAL_DATA_TYPE *pHal = GET_HAL_DATA(padapter);
+		
+		iwe->u.qual.level = (u8)odm_SignalScaleMapping(&pHal->odmpriv, ss);
+	}	
+	#endif
+	#endif
+	
+	iwe->u.qual.qual = (u8)sq;   // signal quality
+
+	#ifdef CONFIG_PLATFORM_ROCKCHIPS
+	iwe->u.qual.noise = -100; // noise level suggest by zhf@rockchips
+	#else 
+	#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+	{
+		s16 tmp_noise=0;
+		rtw_hal_get_odm_var(padapter, HAL_ODM_NOISE_MONITOR,&(pnetwork->network.Configuration.DSConfig), &(tmp_noise));
+		iwe->u.qual.noise = tmp_noise ;
+	}
+	#else
+	iwe->u.qual.noise = 0; // noise level
+	#endif	
+	#endif //CONFIG_PLATFORM_ROCKCHIPS
+	
+	//DBG_871X("iqual=%d, ilevel=%d, inoise=%d, iupdated=%d\n", iwe.u.qual.qual, iwe.u.qual.level , iwe.u.qual.noise, iwe.u.qual.updated);
+
+	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_QUAL_LEN);
+	return start;
+}
+
+static inline char *  iwe_stream_net_rsv_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{	
+	u8 buf[32] = {0};
+	u8 * p,*pos;
+	int len;
+	p = buf;
+	pos = pnetwork->network.Reserved;
+	
+	p += sprintf(p, "fm=%02X%02X", pos[1], pos[0]);
+	_rtw_memset(iwe, 0, sizeof(*iwe));
+	iwe->cmd = IWEVCUSTOM;
+	iwe->u.data.length = strlen(buf);
+	start = iwe_stream_add_point(info, start, stop,iwe, buf);
+	return start;
+}
+
+#if 1
+static char *translate_scan(_adapter *padapter, 
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop)
+{	
+	struct iw_event iwe;
+	u16 cap = 0;
+	_rtw_memset(&iwe, 0, sizeof(iwe));
+	
+	if(_FALSE == search_p2p_wfd_ie(padapter,info,pnetwork,start,stop))
+		return start;
+
+	start = iwe_stream_mac_addr_proess(padapter,info,pnetwork,start,stop,&iwe);	
+	start = iwe_stream_essid_proess(padapter,info,pnetwork,start,stop,&iwe);	
+	start = iwe_stream_protocol_process(padapter,info,pnetwork,start,stop,&iwe);
+	if (pnetwork->network.Reserved[0] == 2) // Probe Request
+	{
+		cap = 0;
+	}
+	else
+	{
+		_rtw_memcpy((u8 *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
+		cap = le16_to_cpu(cap);
+	}
+
+	start = iwe_stream_mode_process(padapter,info,pnetwork,start,stop,&iwe,cap);	
+	start = iwe_stream_chan_process(padapter,info,pnetwork,start,stop,&iwe);	
+	start = iwe_stream_encryption_process(padapter,info,pnetwork,start,stop,&iwe,cap);	
+	start = iwe_stream_rate_process(padapter,info,pnetwork,start,stop,&iwe);	
+	start = iwe_stream_wpa_wpa2_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_wps_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_wapi_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_rssi_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_net_rsv_process(padapter,info,pnetwork,start,stop,&iwe);	
+	
+	return start;	
+}
+#else
+static char *translate_scan(_adapter *padapter, 
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop)
+{
+	struct iw_event iwe;
+	u16 cap;
+	u32 ht_ielen = 0, vht_ielen = 0;
+	char custom[MAX_CUSTOM_LEN];
+	char *p;
+	u16 max_rate=0, rate, ht_cap=_FALSE, vht_cap = _FALSE;
+	u32 i = 0;	
+	char	*current_val;
+	long rssi;
+	u8 bw_40MHz=0, short_GI=0, bw_160MHz=0, vht_highest_rate = 0;
+	u16 mcs_rate=0, vht_data_rate=0;
+	u8 ie_offset = (pnetwork->network.Reserved[0] == 2? 0:12);
+	struct registry_priv *pregpriv = &padapter->registrypriv;
+	
+	if(_FALSE == search_p2p_wfd_ie(padapter,info,pnetwork,start,stop))
+		return start;
+
+	/*  AP MAC address  */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+
+	_rtw_memcpy(iwe.u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);
+	
+	/* Add the ESSID */
+	iwe.cmd = SIOCGIWESSID;
+	iwe.u.data.flags = 1;	
+	iwe.u.data.length = min((u16)pnetwork->network.Ssid.SsidLength, (u16)32);
+	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
+
+	//parsing HT_CAP_IE
+	if (pnetwork->network.Reserved[0] == 2) // Probe Request
+	{
+		p = rtw_get_ie(&pnetwork->network.IEs[0], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength);
+	}
+	else
+	{
+		p = rtw_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-12);
+	}
+	if(p && ht_ielen>0)
+	{
+		struct rtw_ieee80211_ht_cap *pht_capie;
+		ht_cap = _TRUE;			
+		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);		
+		_rtw_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
+		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
+	}
+
+#ifdef CONFIG_80211AC_VHT
+	//parsing VHT_CAP_IE
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], EID_VHTCapability, &vht_ielen, pnetwork->network.IELength-ie_offset);
+	if(p && vht_ielen>0)
+	{
+		u8	mcs_map[2];
+
+		vht_cap = _TRUE;		
+		bw_160MHz = GET_VHT_CAPABILITY_ELE_CHL_WIDTH(p+2);
+		if(bw_160MHz)
+			short_GI = GET_VHT_CAPABILITY_ELE_SHORT_GI160M(p+2);
+		else
+			short_GI = GET_VHT_CAPABILITY_ELE_SHORT_GI80M(p+2);
+
+		_rtw_memcpy(mcs_map, GET_VHT_CAPABILITY_ELE_TX_MCS(p+2), 2);
+
+		vht_highest_rate = rtw_get_vht_highest_rate(mcs_map);
+		vht_data_rate = rtw_vht_mcs_to_data_rate(CHANNEL_WIDTH_80, short_GI, vht_highest_rate);
+	}
+#endif
+
+	/* Add the protocol name */
+	iwe.cmd = SIOCGIWNAME;
+	if ((rtw_is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)		
+	{
+		if(ht_cap == _TRUE)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");
+		else
+		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
+	}	
+	else if ((rtw_is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)	
+	{
+		if(ht_cap == _TRUE)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
+	}	
+	else
+	{
+		if(pnetwork->network.Configuration.DSConfig > 14)
+		{
+			if(vht_cap == _TRUE)
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11AC");
+			else if(ht_cap == _TRUE)
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11an");
+			else
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11a");
+		}
+		else
+		{
+			if(ht_cap == _TRUE)
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");
+			else
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");
+		}
+	}	
+
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
+
+	  /* Add mode */
+	if (pnetwork->network.Reserved[0] == 2) // Probe Request
+	{
+		cap = 0;
+	}
+	else
+	{
+        iwe.cmd = SIOCGIWMODE;
+		_rtw_memcpy((u8 *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
+		cap = le16_to_cpu(cap);
+	}
+
+	if(cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)){
+		if (cap & WLAN_CAPABILITY_BSS)
+			iwe.u.mode = IW_MODE_MASTER;
+		else
+			iwe.u.mode = IW_MODE_ADHOC;
+
+		start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_UINT_LEN);
+	}
+
+	if(pnetwork->network.Configuration.DSConfig<1 /*|| pnetwork->network.Configuration.DSConfig>14*/)
+		pnetwork->network.Configuration.DSConfig = 1;
+
+	 /* Add frequency/channel */
+	iwe.cmd = SIOCGIWFREQ;
+	iwe.u.freq.m = rtw_ch2freq(pnetwork->network.Configuration.DSConfig) * 100000;
+	iwe.u.freq.e = 1;
+	iwe.u.freq.i = pnetwork->network.Configuration.DSConfig;
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);
+
+	/* Add encryption capability */
+	iwe.cmd = SIOCGIWENCODE;
+	if (cap & WLAN_CAPABILITY_PRIVACY)
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	iwe.u.data.length = 0;
+	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
+
+	/*Add basic and extended rates */
+	max_rate = 0;
+	p = custom;
+	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
+	while(pnetwork->network.SupportedRates[i]!=0)
+	{
+		rate = pnetwork->network.SupportedRates[i]&0x7F; 
+		if (rate > max_rate)
+			max_rate = rate;
+		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
+			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
+		i++;
+	}
+
+	if(vht_cap == _TRUE) {
+		max_rate = vht_data_rate;
+	}
+	else if(ht_cap == _TRUE)
+	{
+		if(mcs_rate&0x8000)//MCS15
+		{
+			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
+			
+		}
+		else if(mcs_rate&0x0080)//MCS7
+		{
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		}
+		else//default MCS7
+		{
+			//DBG_871X("wx_get_scan, mcs_rate_bitmap=0x%x\n", mcs_rate);
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		}
+
+		max_rate = max_rate*2;//Mbps/2;		
+	}
+
+	iwe.cmd = SIOCGIWRATE;
+	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+	iwe.u.bitrate.value = max_rate * 500000;
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_PARAM_LEN);
+
+	//parsing WPA/WPA2 IE
+	if (pnetwork->network.Reserved[0] != 2) // Probe Request
+	{
+		u8 buf[MAX_WPA_IE_LEN*2];
+		u8 wpa_ie[255],rsn_ie[255];
+		u16 wpa_len=0,rsn_len=0;
+		u8 *p;
+		sint out_len=0;
+		out_len=rtw_get_sec_ie(pnetwork->network.IEs ,pnetwork->network.IELength,rsn_ie,&rsn_len,wpa_ie,&wpa_len);
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: ssid=%s\n",pnetwork->network.Ssid.Ssid));
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: wpa_len=%d rsn_len=%d\n",wpa_len,rsn_len));
+
+		if (wpa_len > 0)
+		{
+			p=buf;
+			_rtw_memset(buf, 0, MAX_WPA_IE_LEN*2);
+			p += sprintf(p, "wpa_ie=");
+			for (i = 0; i < wpa_len; i++) {
+				p += sprintf(p, "%02x", wpa_ie[i]);
+			}
+
+			if (wpa_len > 100) {
+				printk("-----------------Len %d----------------\n", wpa_len);
+				for (i = 0; i < wpa_len; i++) {
+					printk("%02x ", wpa_ie[i]);
+				}
+				printk("\n");
+				printk("-----------------Len %d----------------\n", wpa_len);
+			}
+	
+			_rtw_memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf);
+			start = iwe_stream_add_point(info, start, stop, &iwe,buf);
+			
+			_rtw_memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd =IWEVGENIE;
+			iwe.u.data.length = wpa_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe, wpa_ie);			
+		}
+		if (rsn_len > 0)
+		{
+			p = buf;
+			_rtw_memset(buf, 0, MAX_WPA_IE_LEN*2);
+			p += sprintf(p, "rsn_ie=");
+			for (i = 0; i < rsn_len; i++) {
+				p += sprintf(p, "%02x", rsn_ie[i]);
+			}
+			_rtw_memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf);
+			start = iwe_stream_add_point(info, start, stop, &iwe,buf);
+		
+			_rtw_memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd =IWEVGENIE;
+			iwe.u.data.length = rsn_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe, rsn_ie);		
+		}
+	}
+
+	{ //parsing WPS IE
+		uint cnt = 0,total_ielen;	
+		u8 *wpsie_ptr=NULL;
+		uint wps_ielen = 0;		
+
+		u8 *ie_ptr = pnetwork->network.IEs + ie_offset;
+		total_ielen= pnetwork->network.IELength - ie_offset;
+
+		if (pnetwork->network.Reserved[0] == 2) // Probe Request
+		{
+			ie_ptr = pnetwork->network.IEs;
+			total_ielen = pnetwork->network.IELength;
+		}
+		else     // Beacon or Probe Respones
+		{
+			ie_ptr = pnetwork->network.IEs + _FIXED_IE_LENGTH_;
+			total_ielen = pnetwork->network.IELength - _FIXED_IE_LENGTH_;
+		}
+        
+		while(cnt < total_ielen)
+		{
+			if(rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2))			
+			{
+				wpsie_ptr = &ie_ptr[cnt];
+				iwe.cmd =IWEVGENIE;
+				iwe.u.data.length = (u16)wps_ielen;
+				start = iwe_stream_add_point(info, start, stop, &iwe, wpsie_ptr);						
+			}			
+			cnt+=ie_ptr[cnt+1]+2; //goto next
+		}
+	}
+
+#ifdef CONFIG_WAPI_SUPPORT
+	if (pnetwork->network.Reserved[0] != 2) // Probe Request
+	{
+		sint out_len_wapi=0;
+		/* here use static for stack size */
+		static u8 buf_wapi[MAX_WAPI_IE_LEN*2];
+		static u8 wapi_ie[MAX_WAPI_IE_LEN];
+		u16 wapi_len=0;
+		u16  i;
+
+		_rtw_memset(buf_wapi, 0, MAX_WAPI_IE_LEN);
+		_rtw_memset(wapi_ie, 0, MAX_WAPI_IE_LEN);
+
+		out_len_wapi=rtw_get_wapi_ie(pnetwork->network.IEs ,pnetwork->network.IELength,wapi_ie,&wapi_len);
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: ssid=%s\n",pnetwork->network.Ssid.Ssid));
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: wapi_len=%d \n",wapi_len));
+
+		DBG_871X("rtw_wx_get_scan: %s ",pnetwork->network.Ssid.Ssid);
+		DBG_871X("rtw_wx_get_scan: ssid = %d ",wapi_len);
+
+
+		if (wapi_len > 0)
+		{
+			p=buf_wapi;
+			_rtw_memset(buf_wapi, 0, MAX_WAPI_IE_LEN*2);
+			p += sprintf(p, "wapi_ie=");
+			for (i = 0; i < wapi_len; i++) {
+				p += sprintf(p, "%02x", wapi_ie[i]);
+			}
+
+			_rtw_memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf_wapi);
+			start = iwe_stream_add_point(info, start, stop, &iwe,buf_wapi);
+
+			_rtw_memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd =IWEVGENIE;
+			iwe.u.data.length = wapi_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe, wapi_ie);
+		}
+	}
+#endif
+
+{
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	u8 ss, sq;
+	
+	/* Add quality statistics */
+	iwe.cmd = IWEVQUAL;
+	iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED 
+	#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+		| IW_QUAL_NOISE_UPDATED
+	#else
+		| IW_QUAL_NOISE_INVALID
+	#endif
+	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+		| IW_QUAL_DBM
+	#endif
+	;
+
+	if ( check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE &&
+		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network, 0)){
+		ss = padapter->recvpriv.signal_strength;
+		sq = padapter->recvpriv.signal_qual;
+	} else {
+		ss = pnetwork->network.PhyInfo.SignalStrength;
+		sq = pnetwork->network.PhyInfo.SignalQuality;
+	}
+	
+	
+	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+	iwe.u.qual.level = (u8) translate_percentage_to_dbm(ss); /* dbm */
+	#else
+	#ifdef CONFIG_SIGNAL_SCALE_MAPPING
+	iwe.u.qual.level = (u8)ss; /* % */
+	#else
+	{
+		/* Do signal scale mapping when using percentage as the unit of signal strength, since the scale mapping is skipped in odm */
+		
+		HAL_DATA_TYPE *pHal = GET_HAL_DATA(padapter);
+		
+		iwe.u.qual.level = (u8)odm_SignalScaleMapping(&pHal->odmpriv, ss);
+	}
+	#endif
+	#endif
+	
+	iwe.u.qual.qual = (u8)sq;   // signal quality
+
+	#ifdef CONFIG_PLATFORM_ROCKCHIPS
+	iwe.u.qual.noise = -100; // noise level suggest by zhf@rockchips
+	#else 
+	#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+	{
+		s16 tmp_noise=0;
+		rtw_hal_get_odm_var(padapter, HAL_ODM_NOISE_MONITOR,&(pnetwork->network.Configuration.DSConfig), &(tmp_noise));
+		iwe.u.qual.noise = tmp_noise ;
+	}
+	#else
+	iwe.u.qual.noise = 0; // noise level
+	#endif	
+	#endif //CONFIG_PLATFORM_ROCKCHIPS
+	
+	//DBG_871X("iqual=%d, ilevel=%d, inoise=%d, iupdated=%d\n", iwe.u.qual.qual, iwe.u.qual.level , iwe.u.qual.noise, iwe.u.qual.updated);
+
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
+}
+
+	{
+		u8 buf[MAX_WPA_IE_LEN];
+		u8 * p,*pos;
+		int len;
+		p = buf;
+		pos = pnetwork->network.Reserved;
+		_rtw_memset(buf, 0, MAX_WPA_IE_LEN);
+		p += sprintf(p, "fm=%02X%02X", pos[1], pos[0]);
+		_rtw_memset(&iwe, 0, sizeof(iwe));
+		iwe.cmd = IWEVCUSTOM;
+		iwe.u.data.length = strlen(buf);
+		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+	}
+	
+	return start;	
+}
+#endif
+
+static int wpa_set_auth_algs(struct net_device *dev, u32 value)
+{	
+	_adapter *padapter = (_adapter *) rtw_netdev_priv(dev);
+	int ret = 0;
+
+	if ((value & AUTH_ALG_SHARED_KEY)&&(value & AUTH_ALG_OPEN_SYSTEM))
+	{
+		DBG_871X("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY and  AUTH_ALG_OPEN_SYSTEM [value:0x%x]\n",value);
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+	} 
+	else if (value & AUTH_ALG_SHARED_KEY)
+	{
+		DBG_871X("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY  [value:0x%x]\n",value);
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+
+#ifdef CONFIG_PLATFORM_MT53XX
+		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+#else
+		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeShared;
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;
+#endif
+	} 
+	else if(value & AUTH_ALG_OPEN_SYSTEM)
+	{
+		DBG_871X("wpa_set_auth_algs, AUTH_ALG_OPEN_SYSTEM\n");
+		//padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+		if(padapter->securitypriv.ndisauthtype < Ndis802_11AuthModeWPAPSK)
+		{
+#ifdef CONFIG_PLATFORM_MT53XX
+			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;
+			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+#else
+			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
+ 			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+#endif
+		}
+		
+	}
+	else if(value & AUTH_ALG_LEAP)
+	{
+		DBG_871X("wpa_set_auth_algs, AUTH_ALG_LEAP\n");
+	}
+	else
+	{
+		DBG_871X("wpa_set_auth_algs, error!\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+	
+}
+
+static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len,wep_total_len;
+	NDIS_802_11_WEP	 *pwep = NULL;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;		
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+#ifdef CONFIG_P2P
+	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
+#endif //CONFIG_P2P
+
+_func_enter_;
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	if (param_len < (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
+	{
+		ret =  -EINVAL;
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+
+		if (param->u.crypt.idx >= WEP_KEYS
+#ifdef CONFIG_IEEE80211W
+			&& param->u.crypt.idx > BIP_MAX_KEYID
+#endif //CONFIG_IEEE80211W
+			)
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+	} 
+	else 
+	{
+#ifdef CONFIG_WAPI_SUPPORT
+		if (strcmp(param->u.crypt.alg, "SMS4"))
+#endif
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+	}
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("wpa_set_encryption, crypt.alg = WEP\n"));
+		DBG_871X("wpa_set_encryption, crypt.alg = WEP\n");
+
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+		padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;
+
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("(1)wep_key_idx=%d\n", wep_key_idx));
+		DBG_871X("(1)wep_key_idx=%d\n", wep_key_idx);
+
+		if (wep_key_idx > WEP_KEYS)
+			return -EINVAL;
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("(2)wep_key_idx=%d\n", wep_key_idx));
+
+		if (wep_key_len > 0) 
+		{
+		 	wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+		 	pwep =(NDIS_802_11_WEP	 *) rtw_malloc(wep_total_len);
+			if(pwep == NULL){
+				RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,(" wpa_set_encryption: pwep allocate fail !!!\n"));
+				goto exit;
+			}
+
+		 	_rtw_memset(pwep, 0, wep_total_len);
+
+		 	pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_total_len;
+
+			if(wep_key_len==13)
+			{
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+			}
+		}
+		else {		
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		pwep->KeyIndex = wep_key_idx;
+		pwep->KeyIndex |= 0x80000000;
+
+		_rtw_memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
+
+		if(param->u.crypt.set_tx)
+		{
+			DBG_871X("wep, set_tx=1\n");
+
+			if(rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
+			{
+				ret = -EOPNOTSUPP ;
+			}
+		}
+		else
+		{
+			DBG_871X("wep, set_tx=0\n");
+			
+			//don't update "psecuritypriv->dot11PrivacyAlgrthm" and 
+			//"psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to fw/cam
+			
+			if (wep_key_idx >= WEP_KEYS) {
+				ret = -EOPNOTSUPP ;
+				goto exit;
+			}				
+			
+		      _rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+			psecuritypriv->dot11DefKeylen[wep_key_idx]=pwep->KeyLength;	
+			rtw_set_key(padapter, psecuritypriv, wep_key_idx, 0, _TRUE);
+		}
+
+		goto exit;		
+	}
+
+	if(padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) // 802_1x
+	{
+		struct sta_info * psta,*pbcmc_sta;
+		struct sta_priv * pstapriv = &padapter->stapriv;
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == _TRUE) //sta mode
+		{
+			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));				
+			if (psta == NULL) {
+				//DEBUG_ERR( ("Set wpa_set_encryption: Obtain Sta_info fail \n"));
+			}
+			else
+			{
+				//Jeff: don't disable ieee8021x_blocked while clearing key
+				if (strcmp(param->u.crypt.alg, "none") != 0) 
+					psta->ieee8021x_blocked = _FALSE;
+				
+				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
+				{
+					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+				}		
+
+				if(param->u.crypt.set_tx ==1)//pairwise key
+				{ 
+					_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					
+					if(strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
+					{						
+						//DEBUG_ERR(("\nset key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
+						_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+						_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+						padapter->securitypriv.busetkipkey=_FALSE;
+						//_set_timer(&padapter->securitypriv.tkip_timer, 50);						
+					}
+
+					//DEBUG_ERR((" param->u.crypt.key_len=%d\n",param->u.crypt.key_len));
+					DBG_871X(" ~~~~set sta key:unicastkey\n");
+					
+					rtw_setstakey_cmd(padapter, psta, UNICAST_KEY, _TRUE);
+					
+					psta->bpairwise_key_installed = _TRUE;
+					
+				}
+				else//group key
+				{ 					
+					if(strcmp(param->u.crypt.alg, "TKIP") == 0 || strcmp(param->u.crypt.alg, "CCMP") == 0)
+					{
+						_rtw_memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+						//only TKIP group key need to install this
+						if(param->u.crypt.key_len > 16)
+						{
+							_rtw_memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[16]),8);
+							_rtw_memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[24]),8);
+						}
+						padapter->securitypriv.binstallGrpkey = _TRUE;	
+						//DEBUG_ERR((" param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
+						DBG_871X(" ~~~~set sta key:groupkey\n");
+	
+						padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
+	
+						rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1, _TRUE);
+					}
+#ifdef CONFIG_IEEE80211W
+					else if(strcmp(param->u.crypt.alg, "BIP") == 0)
+					{
+						int no;
+						//printk("BIP key_len=%d , index=%d @@@@@@@@@@@@@@@@@@\n", param->u.crypt.key_len, param->u.crypt.idx);
+						//save the IGTK key, length 16 bytes
+						_rtw_memcpy(padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+						/*printk("IGTK key below:\n");
+						for(no=0;no<16;no++)
+							printk(" %02x ", padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey[no]);
+						printk("\n");*/
+						padapter->securitypriv.dot11wBIPKeyid = param->u.crypt.idx;
+						padapter->securitypriv.binstallBIPkey = _TRUE;
+						DBG_871X(" ~~~~set sta key:IGKT\n");
+					}
+#endif //CONFIG_IEEE80211W
+					
+#ifdef CONFIG_P2P
+					if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
+					{
+						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_DONE);
+					}
+#endif //CONFIG_P2P
+					
+				}						
+			}
+
+			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
+			if(pbcmc_sta==NULL)
+			{
+				//DEBUG_ERR( ("Set OID_802_11_ADD_KEY: bcmc stainfo is null \n"));
+			}
+			else
+			{
+				//Jeff: don't disable ieee8021x_blocked while clearing key
+				if (strcmp(param->u.crypt.alg, "none") != 0) 
+					pbcmc_sta->ieee8021x_blocked = _FALSE;
+				
+				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
+				{							
+					pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+				}					
+			}				
+		}
+		else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
+		{		
+		}			
+	}
+
+#ifdef CONFIG_WAPI_SUPPORT
+	if (strcmp(param->u.crypt.alg, "SMS4") == 0)
+	{
+		PRT_WAPI_T			pWapiInfo = &padapter->wapiInfo;
+		PRT_WAPI_STA_INFO	pWapiSta;
+		u8					WapiASUEPNInitialValueSrc[16] = {0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
+		u8					WapiAEPNInitialValueSrc[16] = {0x37,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
+		u8 					WapiAEMultiCastPNInitialValueSrc[16] = {0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
+
+		if(param->u.crypt.set_tx == 1)
+		{
+			list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list) {
+				if(_rtw_memcmp(pWapiSta->PeerMacAddr,param->sta_addr,6))
+				{
+					_rtw_memcpy(pWapiSta->lastTxUnicastPN,WapiASUEPNInitialValueSrc,16);
+
+					pWapiSta->wapiUsk.bSet = true;
+					_rtw_memcpy(pWapiSta->wapiUsk.dataKey,param->u.crypt.key,16);
+					_rtw_memcpy(pWapiSta->wapiUsk.micKey,param->u.crypt.key+16,16);
+					pWapiSta->wapiUsk.keyId = param->u.crypt.idx ;
+					pWapiSta->wapiUsk.bTxEnable = true;
+
+					_rtw_memcpy(pWapiSta->lastRxUnicastPNBEQueue,WapiAEPNInitialValueSrc,16);
+					_rtw_memcpy(pWapiSta->lastRxUnicastPNBKQueue,WapiAEPNInitialValueSrc,16);
+					_rtw_memcpy(pWapiSta->lastRxUnicastPNVIQueue,WapiAEPNInitialValueSrc,16);
+					_rtw_memcpy(pWapiSta->lastRxUnicastPNVOQueue,WapiAEPNInitialValueSrc,16);
+					_rtw_memcpy(pWapiSta->lastRxUnicastPN,WapiAEPNInitialValueSrc,16);
+					pWapiSta->wapiUskUpdate.bTxEnable = false;
+					pWapiSta->wapiUskUpdate.bSet = false;
+
+					if (psecuritypriv->sw_encrypt== false || psecuritypriv->sw_decrypt == false)
+					{
+						//set unicast key for ASUE
+						rtw_wapi_set_key(padapter, &pWapiSta->wapiUsk, pWapiSta, false, false);
+					}
+				}
+			}
+		}
+		else
+		{
+			list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list) {
+				if(_rtw_memcmp(pWapiSta->PeerMacAddr,get_bssid(pmlmepriv),6))
+				{
+					pWapiSta->wapiMsk.bSet = true;
+					_rtw_memcpy(pWapiSta->wapiMsk.dataKey,param->u.crypt.key,16);
+					_rtw_memcpy(pWapiSta->wapiMsk.micKey,param->u.crypt.key+16,16);
+					pWapiSta->wapiMsk.keyId = param->u.crypt.idx ;
+					pWapiSta->wapiMsk.bTxEnable = false;
+					if(!pWapiSta->bSetkeyOk)
+						pWapiSta->bSetkeyOk = true;
+					pWapiSta->bAuthenticateInProgress = false;
+
+					_rtw_memcpy(pWapiSta->lastRxMulticastPN, WapiAEMultiCastPNInitialValueSrc, 16);
+
+					if (psecuritypriv->sw_decrypt == false)
+					{
+						//set rx broadcast key for ASUE
+						rtw_wapi_set_key(padapter, &pWapiSta->wapiMsk, pWapiSta, true, false);
+					}
+				}
+
+			}
+		}
+	}
+#endif
+
+exit:
+	
+	if (pwep) {
+		rtw_mfree((u8 *)pwep, wep_total_len);		
+	}	
+	
+_func_exit_;
+
+	return ret;	
+}
+
+static int rtw_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen)
+{
+	u8 *buf=NULL, *pos=NULL;	
+	u32 left; 	
+	int group_cipher = 0, pairwise_cipher = 0;
+	int ret = 0;
+	u8 null_addr[]= {0,0,0,0,0,0};
+#ifdef CONFIG_P2P
+	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
+#endif //CONFIG_P2P
+
+	if((ielen > MAX_WPA_IE_LEN) || (pie == NULL)){
+		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
+		if(pie == NULL)	
+			return ret;
+		else
+			return -EINVAL;
+	}
+
+	if(ielen)
+	{		
+		buf = rtw_zmalloc(ielen);
+		if (buf == NULL){
+			ret =  -ENOMEM;
+			goto exit;
+		}
+	
+		_rtw_memcpy(buf, pie , ielen);
+
+		//dump
+		{
+			int i;
+			DBG_871X("\n wpa_ie(length:%d):\n", ielen);
+			for(i=0;i<ielen;i=i+8)
+				DBG_871X("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x \n",buf[i],buf[i+1],buf[i+2],buf[i+3],buf[i+4],buf[i+5],buf[i+6],buf[i+7]);
+		}
+	
+		pos = buf;
+		if(ielen < RSN_HEADER_LEN){
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie len too short %d\n", ielen));
+			ret  = -1;
+			goto exit;
+		}
+
+#if 0
+		pos += RSN_HEADER_LEN;
+		left  = ielen - RSN_HEADER_LEN;
+		
+		if (left >= RSN_SELECTOR_LEN){
+			pos += RSN_SELECTOR_LEN;
+			left -= RSN_SELECTOR_LEN;
+		}		
+		else if (left > 0){
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie length mismatch, %u too much \n", left));
+			ret =-1;
+			goto exit;
+		}
+#endif		
+		
+		if(rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS)
+		{
+			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPAPSK;
+			_rtw_memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);	
+		}
+	
+		if(rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS)
+		{
+			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPA2PSK;	
+			_rtw_memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);	
+		}
+			
+		if (group_cipher == 0)
+		{
+			group_cipher = WPA_CIPHER_NONE;
+		}
+		if (pairwise_cipher == 0)
+		{
+			pairwise_cipher = WPA_CIPHER_NONE;
+		}
+			
+		switch(group_cipher)
+		{
+			case WPA_CIPHER_NONE:
+				padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+				padapter->securitypriv.ndisencryptstatus=Ndis802_11EncryptionDisabled;
+				break;
+			case WPA_CIPHER_WEP40:
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+			case WPA_CIPHER_TKIP:
+				padapter->securitypriv.dot118021XGrpPrivacy=_TKIP_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+				break;
+			case WPA_CIPHER_CCMP:
+				padapter->securitypriv.dot118021XGrpPrivacy=_AES_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+				break;
+			case WPA_CIPHER_WEP104:	
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+		}
+
+		switch(pairwise_cipher)
+		{
+			case WPA_CIPHER_NONE:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+				padapter->securitypriv.ndisencryptstatus=Ndis802_11EncryptionDisabled;
+				break;
+			case WPA_CIPHER_WEP40:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+			case WPA_CIPHER_TKIP:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_TKIP_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+				break;
+			case WPA_CIPHER_CCMP:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_AES_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+				break;
+			case WPA_CIPHER_WEP104:	
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+		}
+		
+		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
+		{//set wps_ie	
+			u16 cnt = 0;	
+			u8 eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
+			 
+			while( cnt < ielen )
+			{
+				eid = buf[cnt];
+		
+				if((eid==_VENDOR_SPECIFIC_IE_)&&(_rtw_memcmp(&buf[cnt+2], wps_oui, 4)==_TRUE))
+				{
+					DBG_871X("SET WPS_IE\n");
+
+					padapter->securitypriv.wps_ie_len = ((buf[cnt+1]+2) < MAX_WPS_IE_LEN) ? (buf[cnt+1]+2):MAX_WPS_IE_LEN;
+
+					_rtw_memcpy(padapter->securitypriv.wps_ie, &buf[cnt], padapter->securitypriv.wps_ie_len);
+					
+					set_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS);
+					
+#ifdef CONFIG_P2P
+					if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_OK))
+					{
+						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_ING);
+					}
+#endif //CONFIG_P2P
+					cnt += buf[cnt+1]+2;
+					
+					break;
+				} else {
+					cnt += buf[cnt+1]+2; //goto next	
+				}				
+			}			
+		}		
+	}
+	
+	//TKIP and AES disallow multicast packets until installing group key
+        if(padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_
+                || padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_
+                || padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
+                //WPS open need to enable multicast
+                //|| check_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS) == _TRUE)
+                rtw_hal_set_hwreg(padapter, HW_VAR_OFF_RCR_AM, null_addr);
+	
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		 ("rtw_set_wpa_ie: pairwise_cipher=0x%08x padapter->securitypriv.ndisencryptstatus=%d padapter->securitypriv.ndisauthtype=%d\n",
+		  pairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype));
+ 	
+exit:
+
+	if (buf) rtw_mfree(buf, ielen);
+
+	return ret;
+}
+
+static int rtw_wx_get_name(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u16 cap;
+	u32 ht_ielen = 0;
+	char *p;
+	u8 ht_cap=_FALSE, vht_cap=_FALSE;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+	NDIS_802_11_RATES_EX* prates = NULL;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("cmd_code=%x\n", info->cmd));
+
+	_func_enter_;	
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	{
+		//parsing HT_CAP_IE
+		p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
+		if(p && ht_ielen>0)
+		{
+			ht_cap = _TRUE;
+		}
+
+#ifdef CONFIG_80211AC_VHT
+		if(pmlmepriv->vhtpriv.vht_option == _TRUE)
+			vht_cap = _TRUE;
+#endif
+
+		prates = &pcur_bss->SupportedRates;
+
+		if (rtw_is_cckratesonly_included((u8*)prates) == _TRUE)
+		{
+			if(ht_cap == _TRUE)
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11b");
+		}
+		else if ((rtw_is_cckrates_included((u8*)prates)) == _TRUE)
+		{
+			if(ht_cap == _TRUE)
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bgn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bg");
+		}
+		else
+		{
+			if(pcur_bss->Configuration.DSConfig > 14)
+			{
+			#ifdef CONFIG_80211AC_VHT
+				if(vht_cap == _TRUE){
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11AC");
+				}
+				else
+			#endif
+				{
+					if(ht_cap == _TRUE)
+						snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11an");
+					else
+						snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11a");
+				}
+			}
+			else
+			{
+				if(ht_cap == _TRUE)
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11gn");
+				else
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
+			}
+		}
+	}
+	else
+	{
+		//prates = &padapter->registrypriv.dev_network.SupportedRates;
+		//snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
+		snprintf(wrqu->name, IFNAMSIZ, "unassociated");
+	}
+
+	_func_exit_;
+
+	return 0;
+}
+
+static int rtw_wx_set_freq(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{	
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(padapter);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
+	int exp = 1, freq = 0, div = 0;
+
+	_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+rtw_wx_set_freq\n"));
+
+	if (wrqu->freq.m <= 1000) {
+		if (wrqu->freq.flags == IW_FREQ_AUTO) {
+			if (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, wrqu->freq.m) > 0) {
+				padapter->mlmeextpriv.cur_channel = wrqu->freq.m;
+				DBG_871X("%s: channel is auto, set to channel %d\n", __func__, wrqu->freq.m);
+			} else {
+				padapter->mlmeextpriv.cur_channel = 1;
+				DBG_871X("%s: channel is auto, Channel Plan don't match just set to channel 1\n", __func__);
+			}
+		} else {
+			padapter->mlmeextpriv.cur_channel = wrqu->freq.m;
+			DBG_871X("%s: set to channel %d\n", __func__, padapter->mlmeextpriv.cur_channel);
+		}
+	} else {
+		while (wrqu->freq.e) {
+			exp *= 10;
+			wrqu->freq.e--;
+		}
+
+		freq = wrqu->freq.m;
+
+		while (!(freq%10)) {
+			freq /= 10;
+			exp *= 10;
+		}
+
+		/* freq unit is MHz here */
+		div = 1000000/exp;
+
+		if (div)
+			freq /= div;
+		else {
+			div = exp/1000000;
+			freq *= div;
+		}
+
+		/* If freq is invalid, rtw_freq2ch() will return channel 1 */
+		padapter->mlmeextpriv.cur_channel = rtw_freq2ch(freq);
+		DBG_871X("%s: set to channel %d\n", __func__, padapter->mlmeextpriv.cur_channel);
+	}
+
+	set_channel_bwmode(padapter, padapter->mlmeextpriv.cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+
+	_func_exit_;
+	
+	return 0;
+}
+
+static int rtw_wx_get_freq(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE && check_fwstate(pmlmepriv, WIFI_MONITOR_STATE) != _TRUE) {
+
+		wrqu->freq.m = rtw_ch2freq(pcur_bss->Configuration.DSConfig) * 100000;
+		wrqu->freq.e = 1;
+		wrqu->freq.i = pcur_bss->Configuration.DSConfig;
+
+	} else {
+		wrqu->freq.m = rtw_ch2freq(padapter->mlmeextpriv.cur_channel) * 100000;
+		wrqu->freq.e = 1;
+		wrqu->freq.i = padapter->mlmeextpriv.cur_channel;
+	}
+
+	return 0;
+}
+
+static int rtw_wx_set_mode(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *b)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType ;
+	int ret = 0;
+	
+	_func_enter_;
+	
+	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+		ret= -EPERM;
+		goto exit;
+	}
+
+	if (!rtw_is_hw_init_completed(padapter)) {
+		ret = -EPERM;
+		goto exit;
+	}
+
+	/* initial default type */
+	dev->type = ARPHRD_ETHER;
+
+	switch(wrqu->mode)
+	{
+		case IW_MODE_MONITOR:
+			networkType = Ndis802_11Monitor;
+#if 0
+			dev->type = ARPHRD_IEEE80211; /* IEEE 802.11 : 801 */
+#endif
+			dev->type = ARPHRD_IEEE80211_RADIOTAP; /* IEEE 802.11 + radiotap header : 803 */
+			DBG_871X("set_mode = IW_MODE_MONITOR\n");
+			break;
+
+		case IW_MODE_AUTO:
+			networkType = Ndis802_11AutoUnknown;
+			DBG_871X("set_mode = IW_MODE_AUTO\n");	
+			break;				
+		case IW_MODE_ADHOC:		
+			networkType = Ndis802_11IBSS;
+			DBG_871X("set_mode = IW_MODE_ADHOC\n");			
+			break;
+		case IW_MODE_MASTER:		
+			networkType = Ndis802_11APMode;
+			DBG_871X("set_mode = IW_MODE_MASTER\n");
+                        //rtw_setopmode_cmd(padapter, networkType,_TRUE);	
+			break;				
+		case IW_MODE_INFRA:
+			networkType = Ndis802_11Infrastructure;
+			DBG_871X("set_mode = IW_MODE_INFRA\n");			
+			break;
+	
+		default :
+			ret = -EINVAL;;
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("\n Mode: %s is not supported  \n", iw_operation_mode[wrqu->mode]));
+			goto exit;
+	}
+	
+/*	
+	if(Ndis802_11APMode == networkType)
+	{
+		rtw_setopmode_cmd(padapter, networkType,_TRUE);
+	}	
+	else
+	{
+		rtw_setopmode_cmd(padapter, Ndis802_11AutoUnknown,_TRUE);	
+	}
+*/
+	
+	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==_FALSE){
+
+		ret = -EPERM;
+		goto exit;
+
+	}
+
+	rtw_setopmode_cmd(padapter, networkType,_TRUE);
+
+	if (check_fwstate(pmlmepriv, WIFI_MONITOR_STATE) == _TRUE)
+		rtw_indicate_connect(padapter);
+
+exit:
+	
+	_func_exit_;
+	
+	return ret;
+	
+}
+
+static int rtw_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *b)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,(" rtw_wx_get_mode \n"));
+
+	_func_enter_;
+	
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+	{
+		wrqu->mode = IW_MODE_INFRA;
+	}
+	else if  ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
+		       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
+		
+	{
+		wrqu->mode = IW_MODE_ADHOC;
+	}
+	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	{
+		wrqu->mode = IW_MODE_MASTER;
+	} else if (check_fwstate(pmlmepriv, WIFI_MONITOR_STATE) == _TRUE)
+		wrqu->mode = IW_MODE_MONITOR;
+	else
+		wrqu->mode = IW_MODE_AUTO;
+
+	_func_exit_;
+	
+	return 0;
+	
+}
+
+
+static int rtw_wx_set_pmkid(struct net_device *dev,
+	                     struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u8          j,blInserted = _FALSE;
+	int         intReturn = _FALSE;
+	struct mlme_priv  *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+        struct iw_pmksa*  pPMK = ( struct iw_pmksa* ) extra;
+        u8     strZeroMacAddress[ ETH_ALEN ] = { 0x00 };
+        u8     strIssueBssid[ ETH_ALEN ] = { 0x00 };
+        
+/*
+        struct iw_pmksa
+        {
+            __u32   cmd;
+            struct sockaddr bssid;
+            __u8    pmkid[IW_PMKID_LEN];   //IW_PMKID_LEN=16
+        }
+        There are the BSSID information in the bssid.sa_data array.
+        If cmd is IW_PMKSA_FLUSH, it means the wpa_suppplicant wants to clear all the PMKID information.
+        If cmd is IW_PMKSA_ADD, it means the wpa_supplicant wants to add a PMKID/BSSID to driver.
+        If cmd is IW_PMKSA_REMOVE, it means the wpa_supplicant wants to remove a PMKID/BSSID from driver.
+        */
+
+	_rtw_memcpy( strIssueBssid, pPMK->bssid.sa_data, ETH_ALEN);
+        if ( pPMK->cmd == IW_PMKSA_ADD )
+        {
+                DBG_871X( "[rtw_wx_set_pmkid] IW_PMKSA_ADD!\n" );
+                if ( _rtw_memcmp( strIssueBssid, strZeroMacAddress, ETH_ALEN ) == _TRUE )
+                {
+                    return( intReturn );
+                }
+                else
+                {
+                    intReturn = _TRUE;
+                }
+		blInserted = _FALSE;
+		
+		//overwrite PMKID
+		for(j=0 ; j<NUM_PMKID_CACHE; j++)
+		{
+			if( _rtw_memcmp( psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE )
+			{ // BSSID is matched, the same AP => rewrite with new PMKID.
+                                
+                                DBG_871X( "[rtw_wx_set_pmkid] BSSID exists in the PMKList.\n" );
+
+				_rtw_memcpy( psecuritypriv->PMKIDList[j].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+                                psecuritypriv->PMKIDList[ j ].bUsed = _TRUE;
+				psecuritypriv->PMKIDIndex = j+1;
+				blInserted = _TRUE;
+				break;
+			}	
+	        }
+
+	        if(!blInserted)
+                {
+		    // Find a new entry
+                    DBG_871X( "[rtw_wx_set_pmkid] Use the new entry index = %d for this PMKID.\n",
+                            psecuritypriv->PMKIDIndex );
+
+	            _rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);
+		    _rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+
+                    psecuritypriv->PMKIDList[ psecuritypriv->PMKIDIndex ].bUsed = _TRUE;
+		    psecuritypriv->PMKIDIndex++ ;
+		    if(psecuritypriv->PMKIDIndex==16)
+                    {
+		        psecuritypriv->PMKIDIndex =0;
+                    }
+		}
+        }
+        else if ( pPMK->cmd == IW_PMKSA_REMOVE )
+        {
+                DBG_871X( "[rtw_wx_set_pmkid] IW_PMKSA_REMOVE!\n" );
+                intReturn = _TRUE;
+		for(j=0 ; j<NUM_PMKID_CACHE; j++)
+		{
+			if( _rtw_memcmp( psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE )
+			{ // BSSID is matched, the same AP => Remove this PMKID information and reset it. 
+                                _rtw_memset( psecuritypriv->PMKIDList[ j ].Bssid, 0x00, ETH_ALEN );
+                                psecuritypriv->PMKIDList[ j ].bUsed = _FALSE;
+				break;
+			}	
+	        }
+        }
+        else if ( pPMK->cmd == IW_PMKSA_FLUSH ) 
+        {
+            DBG_871X( "[rtw_wx_set_pmkid] IW_PMKSA_FLUSH!\n" );
+            _rtw_memset( &psecuritypriv->PMKIDList[ 0 ], 0x00, sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+            psecuritypriv->PMKIDIndex = 0;
+            intReturn = _TRUE;
+        }
+    return( intReturn );
+}
+
+static int rtw_wx_get_sens(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	#ifdef CONFIG_PLATFORM_ROCKCHIPS
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv); 
+	
+	/*
+	*  20110311 Commented by Jeff
+	*  For rockchip platform's wpa_driver_wext_get_rssi
+	*/
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+		//wrqu->sens.value=-padapter->recvpriv.signal_strength;
+		wrqu->sens.value=-padapter->recvpriv.rssi;
+		//DBG_871X("%s: %d\n", __FUNCTION__, wrqu->sens.value);
+		wrqu->sens.fixed = 0; /* no auto select */ 
+	} else 
+	#endif
+	{
+		wrqu->sens.value = 0;
+		wrqu->sens.fixed = 0;	/* no auto select */
+		wrqu->sens.disabled = 1;
+	}
+	return 0;
+}
+
+static int rtw_wx_get_range(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	struct iw_range *range = (struct iw_range *)extra;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+
+	u16 val;
+	int i;
+	
+	_func_enter_;
+	
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_range. cmd_code=%x\n", info->cmd));
+
+	wrqu->data.length = sizeof(*range);
+	_rtw_memset(range, 0, sizeof(*range));
+
+	/* Let's try to keep this struct in the same order as in
+	 * linux/include/wireless.h
+	 */
+
+	/* TODO: See what values we can set, and remove the ones we can't
+	 * set, or fill them with some default data.
+	 */
+
+	/* ~5 Mb/s real (802.11b) */
+	range->throughput = 5 * 1000 * 1000;     
+
+	// TODO: Not used in 802.11b?
+//	range->min_nwid;	/* Minimal NWID we are able to set */
+	// TODO: Not used in 802.11b?
+//	range->max_nwid;	/* Maximal NWID we are able to set */
+
+        /* Old Frequency (backward compat - moved lower ) */
+//	range->old_num_channels; 
+//	range->old_num_frequency;
+//	range->old_freq[6]; /* Filler to keep "version" at the same offset */
+
+	/* signal level threshold range */
+
+	/* Quality of link & SNR stuff */
+	/* Quality range (link, level, noise)
+	 * If the quality is absolute, it will be in the range [0 ; max_qual],
+	 * if the quality is dBm, it will be in the range [max_qual ; 0].
+	 * Don't forget that we use 8 bit arithmetics...
+	 *
+	 * If percentage range is 0~100
+	 * Signal strength dbm range logical is -100 ~ 0
+	 * but usually value is -90 ~ -20
+	 * When CONFIG_SIGNAL_SCALE_MAPPING is defined, dbm range is -95 ~ -45
+	 */
+	range->max_qual.qual = 100;
+#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+	range->max_qual.level = (u8)-100;
+	range->max_qual.noise = (u8)-100;
+	range->max_qual.updated = IW_QUAL_ALL_UPDATED; /* Updated all three */
+	range->max_qual.updated |= IW_QUAL_DBM;
+#else /* !CONFIG_SIGNAL_DISPLAY_DBM */
+	//percent values between 0 and 100.
+	range->max_qual.level = 100;
+	range->max_qual.noise = 100;
+	range->max_qual.updated = IW_QUAL_ALL_UPDATED; /* Updated all three */
+#endif /* !CONFIG_SIGNAL_DISPLAY_DBM */
+
+	/* This should contain the average/typical values of the quality
+	 * indicator. This should be the threshold between a "good" and
+	 * a "bad" link (example : monitor going from green to orange).
+	 * Currently, user space apps like quality monitors don't have any
+	 * way to calibrate the measurement. With this, they can split
+	 * the range between 0 and max_qual in different quality level
+	 * (using a geometric subdivision centered on the average).
+	 * I expect that people doing the user space apps will feedback
+	 * us on which value we need to put in each driver... */
+	range->avg_qual.qual = 92; /* > 8% missed beacons is 'bad' */
+#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+	/* TODO: Find real 'good' to 'bad' threshold value for RSSI */
+	range->avg_qual.level = (u8)-70;
+	range->avg_qual.noise = 0;
+	range->avg_qual.updated = IW_QUAL_ALL_UPDATED; /* Updated all three */
+	range->avg_qual.updated |= IW_QUAL_DBM;
+#else /* !CONFIG_SIGNAL_DISPLAY_DBM */
+	/* TODO: Find real 'good' to 'bad' threshol value for RSSI */
+	range->avg_qual.level = 30;
+	range->avg_qual.noise = 100;
+	range->avg_qual.updated = IW_QUAL_ALL_UPDATED; /* Updated all three */
+#endif /* !CONFIG_SIGNAL_DISPLAY_DBM */
+
+	range->num_bitrates = RATE_COUNT;
+
+	for (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++) {
+		range->bitrate[i] = rtw_rates[i];
+	}
+
+	range->min_frag = MIN_FRAG_THRESHOLD;
+	range->max_frag = MAX_FRAG_THRESHOLD;
+
+	range->pm_capa = 0;
+
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 16;
+
+//	range->retry_capa;	/* What retry options are supported */
+//	range->retry_flags;	/* How to decode max/min retry limit */
+//	range->r_time_flags;	/* How to decode max/min retry life */
+//	range->min_retry;	/* Minimal number of retries */
+//	range->max_retry;	/* Maximal number of retries */
+//	range->min_r_time;	/* Minimal retry lifetime */
+//	range->max_r_time;	/* Maximal retry lifetime */
+
+	for (i = 0, val = 0; i < MAX_CHANNEL_NUM; i++) {
+
+		// Include only legal frequencies for some countries
+		if(pmlmeext->channel_set[i].ChannelNum != 0)
+		{
+			range->freq[val].i = pmlmeext->channel_set[i].ChannelNum;
+			range->freq[val].m = rtw_ch2freq(pmlmeext->channel_set[i].ChannelNum) * 100000;
+			range->freq[val].e = 1;
+			val++;
+		}
+
+		if (val == IW_MAX_FREQUENCIES)
+			break;
+	}
+
+	range->num_channels = val;
+	range->num_frequency = val;
+
+// Commented by Albert 2009/10/13
+// The following code will proivde the security capability to network manager.
+// If the driver doesn't provide this capability to network manager,
+// the WPA/WPA2 routers can't be choosen in the network manager.
+
+/*
+#define IW_SCAN_CAPA_NONE		0x00
+#define IW_SCAN_CAPA_ESSID		0x01
+#define IW_SCAN_CAPA_BSSID		0x02
+#define IW_SCAN_CAPA_CHANNEL	0x04
+#define IW_SCAN_CAPA_MODE		0x08
+#define IW_SCAN_CAPA_RATE		0x10
+#define IW_SCAN_CAPA_TYPE		0x20
+#define IW_SCAN_CAPA_TIME		0x40
+*/
+
+#if WIRELESS_EXT > 17
+	range->enc_capa = IW_ENC_CAPA_WPA|IW_ENC_CAPA_WPA2|
+			  IW_ENC_CAPA_CIPHER_TKIP|IW_ENC_CAPA_CIPHER_CCMP;
+#endif
+
+#ifdef IW_SCAN_CAPA_ESSID //WIRELESS_EXT > 21
+	range->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE |IW_SCAN_CAPA_BSSID|
+					IW_SCAN_CAPA_CHANNEL|IW_SCAN_CAPA_MODE|IW_SCAN_CAPA_RATE;
+#endif
+
+
+	_func_exit_;
+
+	return 0;
+
+}
+
+//set bssid flow
+//s1. rtw_set_802_11_infrastructure_mode()
+//s2. rtw_set_802_11_authentication_mode()
+//s3. set_802_11_encryption_mode()
+//s4. rtw_set_802_11_bssid()
+static int rtw_wx_set_wap(struct net_device *dev,
+			 struct iw_request_info *info,
+			 union iwreq_data *awrq,
+			 char *extra)
+{
+	_irqL	irqL;
+	uint ret = 0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct sockaddr *temp = (struct sockaddr *)awrq;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	_list	*phead;
+	u8 *dst_bssid, *src_bssid;
+	_queue	*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	NDIS_802_11_AUTHENTICATION_MODE	authmode;
+
+	_func_enter_;
+/*
+#ifdef CONFIG_CONCURRENT_MODE
+	if(padapter->iface_type > PRIMARY_IFACE)
+	{
+		ret = -EINVAL;
+		goto exit;
+	}
+#endif	
+*/	
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	{
+		DBG_871X("set bssid, but buddy_intf is under scanning or linking\n");
+
+		ret = -EINVAL;
+
+		goto exit;
+	}
+#endif
+
+	rtw_ps_deny(padapter, PS_DENY_JOIN);
+	if(_FAIL == rtw_pwr_wakeup(padapter))
+	{
+		ret= -1;
+		goto exit;
+	}
+	
+	if(!padapter->bup){
+		ret = -1;
+		goto exit;
+	}
+
+	
+	if (temp->sa_family != ARPHRD_ETHER){
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	authmode = padapter->securitypriv.ndisauthtype;
+	_enter_critical_bh(&queue->lock, &irqL);
+       phead = get_list_head(queue);
+       pmlmepriv->pscanned = get_next(phead);
+
+	while (1)
+	 {
+			
+		if ((rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) == _TRUE)
+		{
+#if 0		
+			ret = -EINVAL;
+			goto exit;
+
+			if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+			{
+	            		rtw_set_802_11_bssid(padapter, temp->sa_data);
+	    			goto exit;                    
+			}
+			else
+			{
+				ret = -EINVAL;
+				goto exit;
+			}
+#endif
+
+			break;
+		}
+	
+		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
+
+		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+
+		dst_bssid = pnetwork->network.MacAddress;
+
+		src_bssid = temp->sa_data;
+
+		if ((_rtw_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == _TRUE)
+		{			
+			if(!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode))
+			{
+				ret = -1;
+				_exit_critical_bh(&queue->lock, &irqL);
+				goto exit;
+			}
+
+				break;			
+		}
+
+	}		
+	_exit_critical_bh(&queue->lock, &irqL);
+	
+	rtw_set_802_11_authentication_mode(padapter, authmode);
+	//set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
+	if (rtw_set_802_11_bssid(padapter, temp->sa_data) == _FALSE) {
+		ret = -1;
+		goto exit;		
+	}	
+	
+exit:
+	
+	rtw_ps_deny_cancel(padapter, PS_DENY_JOIN);
+
+	_func_exit_;
+	
+	return ret;	
+}
+
+static int rtw_wx_get_wap(struct net_device *dev, 
+			    struct iw_request_info *info, 
+			    union iwreq_data *wrqu, char *extra)
+{
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;	
+	
+	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
+	
+	_rtw_memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+	
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_wap\n"));
+
+	_func_enter_;
+
+	if  ( ((check_fwstate(pmlmepriv, _FW_LINKED)) == _TRUE) || 
+			((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == _TRUE) ||
+			((check_fwstate(pmlmepriv, WIFI_AP_STATE)) == _TRUE) )
+	{
+
+		_rtw_memcpy(wrqu->ap_addr.sa_data, pcur_bss->MacAddress, ETH_ALEN);
+	}
+	else
+	{
+	 	_rtw_memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+	}		
+
+	_func_exit_;
+	
+	return 0;
+	
+}
+
+static int rtw_wx_set_mlme(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+#if 0
+/* SIOCSIWMLME data */
+struct	iw_mlme
+{
+	__u16		cmd; /* IW_MLME_* */
+	__u16		reason_code;
+	struct sockaddr	addr;
+};
+#endif
+
+	int ret=0;
+	u16 reason;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct iw_mlme *mlme = (struct iw_mlme *) extra;
+
+
+	if(mlme==NULL)
+		return -1;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	reason = cpu_to_le16(mlme->reason_code);
+
+
+	DBG_871X("%s, cmd=%d, reason=%d\n", __FUNCTION__, mlme->cmd, reason);
+	
+
+	switch (mlme->cmd) 
+	{
+		case IW_MLME_DEAUTH:
+				if(!rtw_set_802_11_disassociate(padapter))
+					ret = -1;
+				break;
+
+		case IW_MLME_DISASSOC:
+				if(!rtw_set_802_11_disassociate(padapter))
+					ret = -1;
+
+				break;
+
+		default:
+			return -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	u8 _status = _FALSE;
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
+	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
+	_irqL	irqL;
+#ifdef CONFIG_P2P
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);	
+#endif //CONFIG_P2P
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_set_scan\n"));
+
+_func_enter_;
+
+	#ifdef DBG_IOCTL
+	DBG_871X("DBG_IOCTL %s:%d\n",__FUNCTION__, __LINE__);
+	#endif
+/*
+#ifdef CONFIG_CONCURRENT_MODE
+	if(padapter->iface_type > PRIMARY_IFACE)
+	{
+		ret = -1;
+		goto exit;
+	}
+#endif
+*/
+#ifdef CONFIG_MP_INCLUDED
+		if (padapter->registrypriv.mp_mode == 1)
+		{
+				DBG_871X(FUNC_ADPT_FMT ": MP mode block Scan request\n", FUNC_ADPT_ARG(padapter));	
+				ret = -1;
+				goto exit;
+		}
+#ifdef CONFIG_CONCURRENT_MODE
+		if (padapter->pbuddy_adapter) {
+				if (padapter->pbuddy_adapter->registrypriv.mp_mode == 1)
+				{
+					DBG_871X(FUNC_ADPT_FMT ": MP mode block Scan request\n", FUNC_ADPT_ARG(padapter->pbuddy_adapter));
+					ret = -1;
+					goto exit;
+				}
+		}
+#endif //CONFIG_CONCURRENT_MODE
+#endif
+
+	rtw_ps_deny(padapter, PS_DENY_SCAN);
+	if(_FAIL == rtw_pwr_wakeup(padapter))
+	{
+		ret= -1;
+		goto exit;
+	}
+
+	if (rtw_is_drv_stopped(padapter)) {
+		DBG_871X("%s bDriverStopped=_TRUE\n", __func__);
+		ret= -1;
+		goto exit;
+	}
+	
+	if(!padapter->bup){
+		ret = -1;
+		goto exit;
+	}
+	
+	if (!rtw_is_hw_init_completed(padapter)) {
+		ret = -1;
+		goto exit;
+	}
+
+#ifndef CONFIG_DOSCAN_IN_BUSYTRAFFIC
+	// When Busy Traffic, driver do not site survey. So driver return success.
+	// wpa_supplicant will not issue SIOCSIWSCAN cmd again after scan timeout.
+	// modify by thomas 2011-02-22.
+	if (pmlmepriv->LinkDetectInfo.bBusyTraffic == _TRUE
+#ifdef CONFIG_CONCURRENT_MODE
+	|| rtw_get_buddy_bBusyTraffic(padapter) == _TRUE
+#endif //CONFIG_CONCURRENT_MODE
+	)
+	{
+		indicate_wx_scan_complete_event(padapter);
+		goto exit;
+	}
+#endif
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	{
+		indicate_wx_scan_complete_event(padapter);
+		goto exit;
+	} 
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter,
+		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE)
+	{
+		indicate_wx_scan_complete_event(padapter);
+		goto exit;
+	}
+#endif
+
+#ifdef CONFIG_P2P
+	if ( pwdinfo->p2p_state != P2P_STATE_NONE )
+	{
+		rtw_p2p_set_pre_state( pwdinfo, rtw_p2p_state( pwdinfo ) );
+		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
+		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_FULL);
+		rtw_free_network_queue(padapter, _TRUE);
+	}
+#endif //CONFIG_P2P
+
+	_rtw_memset(ssid, 0, sizeof(NDIS_802_11_SSID)*RTW_SSID_SCAN_AMOUNT);
+
+#if WIRELESS_EXT >= 17
+	if (wrqu->data.length == sizeof(struct iw_scan_req)) 
+	{
+		struct iw_scan_req *req = (struct iw_scan_req *)extra;
+	
+		if (wrqu->data.flags & IW_SCAN_THIS_ESSID)
+		{
+			int len = min((int)req->essid_len, IW_ESSID_MAX_SIZE);
+
+			_rtw_memcpy(ssid[0].Ssid, req->essid, len);
+			ssid[0].SsidLength = len;	
+
+			DBG_871X("IW_SCAN_THIS_ESSID, ssid=%s, len=%d\n", req->essid, req->essid_len);
+		
+			_enter_critical_bh(&pmlmepriv->lock, &irqL);				
+		
+			_status = rtw_sitesurvey_cmd(padapter, ssid, 1, NULL, 0);
+		
+			_exit_critical_bh(&pmlmepriv->lock, &irqL);
+			
+		}
+		else if (req->scan_type == IW_SCAN_TYPE_PASSIVE)
+		{
+			DBG_871X("rtw_wx_set_scan, req->scan_type == IW_SCAN_TYPE_PASSIVE\n");
+		}
+		
+	}
+	else
+#endif
+
+	if(	wrqu->data.length >= WEXT_CSCAN_HEADER_SIZE
+		&& _rtw_memcmp(extra, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == _TRUE
+	)
+	{
+		int len = wrqu->data.length -WEXT_CSCAN_HEADER_SIZE;
+		char *pos = extra+WEXT_CSCAN_HEADER_SIZE;
+		char section;
+		char sec_len;
+		int ssid_index = 0;
+
+		//DBG_871X("%s COMBO_SCAN header is recognized\n", __FUNCTION__);
+		
+		while(len >= 1) {
+			section = *(pos++); len-=1;
+
+			switch(section) {
+				case WEXT_CSCAN_SSID_SECTION:
+					//DBG_871X("WEXT_CSCAN_SSID_SECTION\n");
+					if(len < 1) {
+						len = 0;
+						break;
+					}
+					
+					sec_len = *(pos++); len-=1;
+
+					if(sec_len>0 && sec_len<=len) {
+						ssid[ssid_index].SsidLength = sec_len;
+						_rtw_memcpy(ssid[ssid_index].Ssid, pos, ssid[ssid_index].SsidLength);
+						//DBG_871X("%s COMBO_SCAN with specific ssid:%s, %d\n", __FUNCTION__
+						//	, ssid[ssid_index].Ssid, ssid[ssid_index].SsidLength);
+						ssid_index++;
+					}
+					
+					pos+=sec_len; len-=sec_len;
+					break;
+					
+				
+				case WEXT_CSCAN_CHANNEL_SECTION:
+					//DBG_871X("WEXT_CSCAN_CHANNEL_SECTION\n");
+					pos+=1; len-=1;
+					break;
+				case WEXT_CSCAN_ACTV_DWELL_SECTION:
+					//DBG_871X("WEXT_CSCAN_ACTV_DWELL_SECTION\n");
+					pos+=2; len-=2;
+					break;
+				case WEXT_CSCAN_PASV_DWELL_SECTION:
+					//DBG_871X("WEXT_CSCAN_PASV_DWELL_SECTION\n");
+					pos+=2; len-=2;					
+					break;
+				case WEXT_CSCAN_HOME_DWELL_SECTION:
+					//DBG_871X("WEXT_CSCAN_HOME_DWELL_SECTION\n");
+					pos+=2; len-=2;
+					break;
+				case WEXT_CSCAN_TYPE_SECTION:
+					//DBG_871X("WEXT_CSCAN_TYPE_SECTION\n");
+					pos+=1; len-=1;
+					break;
+				#if 0
+				case WEXT_CSCAN_NPROBE_SECTION:
+					DBG_871X("WEXT_CSCAN_NPROBE_SECTION\n");
+					break;
+				#endif
+				
+				default:
+					//DBG_871X("Unknown CSCAN section %c\n", section);
+					len = 0; // stop parsing
+			}
+			//DBG_871X("len:%d\n", len);
+			
+		}
+		
+		//jeff: it has still some scan paramater to parse, we only do this now...
+		_status = rtw_set_802_11_bssid_list_scan(padapter, ssid, RTW_SSID_SCAN_AMOUNT);
+		
+	} else
+	
+	{
+		_status = rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);
+	}
+
+	if(_status == _FALSE)
+		ret = -1;
+
+exit:
+
+	rtw_ps_deny_cancel(padapter, PS_DENY_SCAN);
+
+	#ifdef DBG_IOCTL
+	DBG_871X("DBG_IOCTL %s:%d return %d\n",__FUNCTION__, __LINE__, ret);
+	#endif
+
+_func_exit_;
+
+	return ret;	
+}
+
+static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	_irqL	irqL;
+	_list					*plist, *phead;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	_queue				*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	char *ev = extra;
+	char *stop = ev + wrqu->data.length;
+	u32 ret = 0;
+	u32 cnt=0;
+	u32 wait_for_surveydone;
+	sint wait_status;
+#ifdef CONFIG_CONCURRENT_MODE
+	//PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
+	//struct mlme_priv *pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);	
+#endif
+#ifdef CONFIG_P2P
+	struct	wifidirect_info*	pwdinfo = &padapter->wdinfo;
+#endif //CONFIG_P2P
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan\n"));
+	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_, (" Start of Query SIOCGIWSCAN .\n"));
+
+	_func_enter_;
+
+	#ifdef DBG_IOCTL
+	DBG_871X("DBG_IOCTL %s:%d\n",__FUNCTION__, __LINE__);
+	#endif
+/*
+#ifdef CONFIG_CONCURRENT_MODE
+	if(padapter->iface_type > PRIMARY_IFACE)
+	{
+		ret = -EINVAL;
+		goto exit;
+	}
+#endif
+*/	
+	if (adapter_to_pwrctl(padapter)->brfoffbyhw && rtw_is_drv_stopped(padapter)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+  
+#ifdef CONFIG_P2P
+	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	{
+		wait_for_surveydone = 200;
+	}
+	else
+	{
+		//	P2P is disabled
+		wait_for_surveydone = 100;
+	}
+#else
+	{
+		wait_for_surveydone = 100;
+	}
+#endif //CONFIG_P2P
+
+#if 1 // Wireless Extension use EAGAIN to try
+	wait_status = _FW_UNDER_SURVEY
+#ifndef CONFIG_ANDROID
+		| _FW_UNDER_LINKING
+#endif
+	;
+
+	while (check_fwstate(pmlmepriv, wait_status) == _TRUE)
+	{
+		return -EAGAIN;
+	}
+#else
+	wait_status = _FW_UNDER_SURVEY
+		#ifndef CONFIG_ANDROID
+		|_FW_UNDER_LINKING
+		#endif
+	;
+
+ 	while(check_fwstate(pmlmepriv, wait_status) == _TRUE)
+	{	
+		rtw_msleep_os(30);
+		cnt++;
+		if(cnt > wait_for_surveydone )
+			break;
+	}
+#endif
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+       
+	while(1)
+	{
+		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+		if((stop - ev) < SCAN_ITEM_SIZE) {
+			ret = -E2BIG;
+			break;
+		}
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		//report network only if the current channel set contains the channel to which this network belongs
+		if(rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
+			&& rtw_mlme_band_check(padapter, pnetwork->network.Configuration.DSConfig) == _TRUE
+			&& _TRUE == rtw_validate_ssid(&(pnetwork->network.Ssid))
+		)
+		{
+			ev=translate_scan(padapter, a, pnetwork, ev, stop);
+		}
+
+		plist = get_next(plist);
+	
+	}        
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+       wrqu->data.length = ev-extra;
+	wrqu->data.flags = 0;
+	
+exit:		
+	
+	_func_exit_;	
+	
+	#ifdef DBG_IOCTL
+	DBG_871X("DBG_IOCTL %s:%d return %d\n",__FUNCTION__, __LINE__, ret);
+	#endif
+	
+	return ret ;
+	
+}
+
+//set ssid flow
+//s1. rtw_set_802_11_infrastructure_mode()
+//s2. set_802_11_authenticaion_mode()
+//s3. set_802_11_encryption_mode()
+//s4. rtw_set_802_11_ssid()
+static int rtw_wx_set_essid(struct net_device *dev, 
+			      struct iw_request_info *a,
+			      union iwreq_data *wrqu, char *extra)
+{
+	_irqL irqL;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_queue *queue = &pmlmepriv->scanned_queue;
+	_list *phead;
+	s8 status = _TRUE;
+	struct wlan_network *pnetwork = NULL;
+	NDIS_802_11_AUTHENTICATION_MODE authmode;	
+	NDIS_802_11_SSID ndis_ssid;	
+	u8 *dst_ssid, *src_ssid;
+
+	uint ret = 0, len;
+
+	_func_enter_;
+	
+	#ifdef DBG_IOCTL
+	DBG_871X("DBG_IOCTL %s:%d\n",__FUNCTION__, __LINE__);
+	#endif
+	#ifdef CONFIG_WEXT_DONT_JOIN_BYSSID
+	DBG_871X("%s: CONFIG_WEXT_DONT_JOIN_BYSSID be defined!! only allow bssid joining\n", __func__);
+	return -EPERM;
+	#endif
+/*
+#ifdef CONFIG_CONCURRENT_MODE
+	if(padapter->iface_type > PRIMARY_IFACE)
+	{
+		ret = -EINVAL;
+		goto exit;
+	}
+#endif
+*/
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	{		
+		DBG_871X("set ssid, but buddy_intf is under scanning or linking\n");
+		
+		ret = -EINVAL;
+		
+		goto exit;
+	}
+#endif
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		 ("+rtw_wx_set_essid: fw_state=0x%08x\n", get_fwstate(pmlmepriv)));
+
+	rtw_ps_deny(padapter, PS_DENY_JOIN);
+	if(_FAIL == rtw_pwr_wakeup(padapter))
+	{		
+		ret = -1;
+		goto exit;
+	}
+
+	if(!padapter->bup){
+		ret = -1;
+		goto exit;
+	}
+
+#if WIRELESS_EXT <= 20
+	if ((wrqu->essid.length-1) > IW_ESSID_MAX_SIZE){
+#else
+	if (wrqu->essid.length > IW_ESSID_MAX_SIZE){
+#endif
+		ret= -E2BIG;
+		goto exit;
+	}
+	
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		ret = -1;
+		goto exit;
+	}		
+	
+	authmode = padapter->securitypriv.ndisauthtype;
+	DBG_871X("=>%s\n",__FUNCTION__);
+	if (wrqu->essid.flags && wrqu->essid.length)
+	{
+		// Commented by Albert 20100519
+		// We got the codes in "set_info" function of iwconfig source code.
+		//	=========================================
+		//	wrq.u.essid.length = strlen(essid) + 1;
+	  	//	if(we_kernel_version > 20)
+		//		wrq.u.essid.length--;
+		//	=========================================
+		//	That means, if the WIRELESS_EXT less than or equal to 20, the correct ssid len should subtract 1.
+#if WIRELESS_EXT <= 20
+		len = ((wrqu->essid.length-1) < IW_ESSID_MAX_SIZE) ? (wrqu->essid.length-1) : IW_ESSID_MAX_SIZE;
+#else
+		len = (wrqu->essid.length < IW_ESSID_MAX_SIZE) ? wrqu->essid.length : IW_ESSID_MAX_SIZE;
+#endif
+
+		if( wrqu->essid.length != 33 )
+			DBG_871X("ssid=%s, len=%d\n", extra, wrqu->essid.length);
+
+		_rtw_memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));
+		ndis_ssid.SsidLength = len;
+		_rtw_memcpy(ndis_ssid.Ssid, extra, len);		
+		src_ssid = ndis_ssid.Ssid;
+		
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("rtw_wx_set_essid: ssid=[%s]\n", src_ssid));
+		_enter_critical_bh(&queue->lock, &irqL);
+	       phead = get_list_head(queue);
+              pmlmepriv->pscanned = get_next(phead);
+
+		while (1)
+		{			
+			if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == _TRUE)
+			{
+#if 0			
+				if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+				{
+	            			rtw_set_802_11_ssid(padapter, &ndis_ssid);
+
+		    			goto exit;                    
+				}
+				else
+				{
+					RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("rtw_wx_set_ssid(): scanned_queue is empty\n"));
+					ret = -EINVAL;
+					goto exit;
+				}
+#endif			
+			        RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_warning_,
+					 ("rtw_wx_set_essid: scan_q is empty, set ssid to check if scanning again!\n"));
+
+				break;
+			}
+	
+			pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
+
+			pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+
+			dst_ssid = pnetwork->network.Ssid.Ssid;
+
+			RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+				 ("rtw_wx_set_essid: dst_ssid=%s\n",
+				  pnetwork->network.Ssid.Ssid));
+
+			if ((_rtw_memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength) == _TRUE) &&
+				(pnetwork->network.Ssid.SsidLength==ndis_ssid.SsidLength))
+			{
+				RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+					 ("rtw_wx_set_essid: find match, set infra mode\n"));
+				
+				if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+				{
+					if(pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
+						continue;
+				}	
+					
+				if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == _FALSE)
+				{
+					ret = -1;
+					_exit_critical_bh(&queue->lock, &irqL);
+					goto exit;
+				}
+
+				break;			
+			}
+		}
+		_exit_critical_bh(&queue->lock, &irqL);
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+			 ("set ssid: set_802_11_auth. mode=%d\n", authmode));
+		rtw_set_802_11_authentication_mode(padapter, authmode);
+		//set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
+		if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == _FALSE) {
+			ret = -1;
+			goto exit;
+		}	
+	}			
+	
+exit:
+
+	rtw_ps_deny_cancel(padapter, PS_DENY_JOIN);
+
+	DBG_871X("<=%s, ret %d\n",__FUNCTION__, ret);
+	
+	#ifdef DBG_IOCTL
+	DBG_871X("DBG_IOCTL %s:%d return %d\n",__FUNCTION__, __LINE__, ret);
+	#endif
+	
+	_func_exit_;
+	
+	return ret;	
+}
+
+static int rtw_wx_get_essid(struct net_device *dev, 
+			      struct iw_request_info *a,
+			      union iwreq_data *wrqu, char *extra)
+{
+	u32 len,ret = 0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_essid\n"));
+
+	_func_enter_;
+
+	if ( (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) ||
+	      (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE))
+	{
+		len = pcur_bss->Ssid.SsidLength;
+
+		wrqu->essid.length = len;
+			
+		_rtw_memcpy(extra, pcur_bss->Ssid.Ssid, len);
+
+		wrqu->essid.flags = 1;
+	}
+	else
+	{
+		ret = -1;
+		goto exit;
+	}
+
+exit:
+
+	_func_exit_;
+	
+	return ret;
+	
+}
+
+static int rtw_wx_set_rate(struct net_device *dev, 
+			      struct iw_request_info *a,
+			      union iwreq_data *wrqu, char *extra)
+{
+	int	i, ret = 0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u8	datarates[NumRates];
+	u32	target_rate = wrqu->bitrate.value;
+	u32	fixed = wrqu->bitrate.fixed;
+	u32	ratevalue = 0;
+	 u8 mpdatarate[NumRates]={11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,(" rtw_wx_set_rate \n"));
+	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("target_rate = %d, fixed = %d\n",target_rate,fixed));
+	
+	if(target_rate == -1){
+		ratevalue = 11;
+		goto set_rate;
+	}
+	target_rate = target_rate/100000;
+
+	switch(target_rate){
+		case 10:
+			ratevalue = 0;
+			break;
+		case 20:
+			ratevalue = 1;
+			break;
+		case 55:
+			ratevalue = 2;
+			break;
+		case 60:
+			ratevalue = 3;
+			break;
+		case 90:
+			ratevalue = 4;
+			break;
+		case 110:
+			ratevalue = 5;
+			break;
+		case 120:
+			ratevalue = 6;
+			break;
+		case 180:
+			ratevalue = 7;
+			break;
+		case 240:
+			ratevalue = 8;
+			break;
+		case 360:
+			ratevalue = 9;
+			break;
+		case 480:
+			ratevalue = 10;
+			break;
+		case 540:
+			ratevalue = 11;
+			break;
+		default:
+			ratevalue = 11;
+			break;
+	}
+
+set_rate:
+
+	for(i=0; i<NumRates; i++)
+	{
+		if(ratevalue==mpdatarate[i])
+		{
+			datarates[i] = mpdatarate[i];
+			if(fixed == 0)
+				break;
+		}
+		else{
+			datarates[i] = 0xff;
+		}
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("datarate_inx=%d\n",datarates[i]));
+	}
+
+	if( rtw_setdatarate_cmd(padapter, datarates) !=_SUCCESS){
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("rtw_wx_set_rate Fail!!!\n"));
+		ret = -1;
+	}
+
+_func_exit_;
+
+	return ret;
+}
+
+static int rtw_wx_get_rate(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{	
+	u16 max_rate = 0;
+
+	max_rate = rtw_get_cur_max_rate((_adapter *)rtw_netdev_priv(dev));
+
+	if(max_rate == 0)
+		return -EPERM;
+	
+	wrqu->bitrate.fixed = 0;	/* no auto select */
+	wrqu->bitrate.value = max_rate * 100000;
+
+	return 0;
+}
+
+static int rtw_wx_set_rts(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	_func_enter_;
+	
+	if (wrqu->rts.disabled)
+		padapter->registrypriv.rts_thresh = 2347;
+	else {
+		if (wrqu->rts.value < 0 ||
+		    wrqu->rts.value > 2347)
+			return -EINVAL;
+		
+		padapter->registrypriv.rts_thresh = wrqu->rts.value;
+	}
+
+	DBG_871X("%s, rts_thresh=%d\n", __func__, padapter->registrypriv.rts_thresh);
+	
+	_func_exit_;
+	
+	return 0;
+
+}
+
+static int rtw_wx_get_rts(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	_func_enter_;
+
+	DBG_871X("%s, rts_thresh=%d\n", __func__, padapter->registrypriv.rts_thresh);	
+	
+	wrqu->rts.value = padapter->registrypriv.rts_thresh;
+	wrqu->rts.fixed = 0;	/* no auto select */
+	//wrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD);
+	
+	_func_exit_;
+	
+	return 0;
+}
+
+static int rtw_wx_set_frag(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	_func_enter_;
+	
+	if (wrqu->frag.disabled)
+		padapter->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;
+	else {
+		if (wrqu->frag.value < MIN_FRAG_THRESHOLD ||
+		    wrqu->frag.value > MAX_FRAG_THRESHOLD)
+			return -EINVAL;
+		
+		padapter->xmitpriv.frag_len = wrqu->frag.value & ~0x1;
+	}
+
+	DBG_871X("%s, frag_len=%d\n", __func__, padapter->xmitpriv.frag_len);
+	
+	_func_exit_;
+	
+	return 0;
+	
+}
+
+static int rtw_wx_get_frag(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	_func_enter_;
+
+	DBG_871X("%s, frag_len=%d\n", __func__, padapter->xmitpriv.frag_len);
+	
+	wrqu->frag.value = padapter->xmitpriv.frag_len;
+	wrqu->frag.fixed = 0;	/* no auto select */
+	//wrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FRAG_THRESHOLD);
+	
+	_func_exit_;
+	
+	return 0;
+}
+
+static int rtw_wx_get_retry(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	//_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	
+	wrqu->retry.value = 7;
+	wrqu->retry.fixed = 0;	/* no auto select */
+	wrqu->retry.disabled = 1;
+	
+	return 0;
+
+}	
+
+#if 0
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
+/*
+iwconfig wlan0 key on -> flags = 0x6001 -> maybe it means auto
+iwconfig wlan0 key off -> flags = 0x8800
+iwconfig wlan0 key open -> flags = 0x2800
+iwconfig wlan0 key open 1234567890 -> flags = 0x2000
+iwconfig wlan0 key restricted -> flags = 0x4800
+iwconfig wlan0 key open [3] 1234567890 -> flags = 0x2003
+iwconfig wlan0 key restricted [2] 1234567890 -> flags = 0x4002
+iwconfig wlan0 key open [3] -> flags = 0x2803
+iwconfig wlan0 key restricted [2] -> flags = 0x4802
+*/
+#endif
+
+static int rtw_wx_set_enc(struct net_device *dev, 
+			    struct iw_request_info *info, 
+			    union iwreq_data *wrqu, char *keybuf)
+{	
+	u32 key, ret = 0;
+	u32 keyindex_provided;
+	NDIS_802_11_WEP	 wep;	
+	NDIS_802_11_AUTHENTICATION_MODE authmode;
+
+	struct iw_point *erq = &(wrqu->encoding);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	DBG_871X("+rtw_wx_set_enc, flags=0x%x\n", erq->flags);
+
+	_rtw_memset(&wep, 0, sizeof(NDIS_802_11_WEP));
+	
+	key = erq->flags & IW_ENCODE_INDEX;
+	
+	_func_enter_;	
+
+	if (erq->flags & IW_ENCODE_DISABLED)
+	{
+		DBG_871X("EncryptionDisabled\n");
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+		padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+		padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; //open system
+  		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype=authmode;
+     		
+		goto exit;
+	}
+
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+		keyindex_provided = 1;
+	} 
+	else
+	{
+		keyindex_provided = 0;
+		key = padapter->securitypriv.dot11PrivacyKeyIndex;
+		DBG_871X("rtw_wx_set_enc, key=%d\n", key);
+	}
+	
+	//set authentication mode	
+	if(erq->flags & IW_ENCODE_OPEN)
+	{
+		DBG_871X("rtw_wx_set_enc():IW_ENCODE_OPEN\n");
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;//Ndis802_11EncryptionDisabled;
+
+#ifdef CONFIG_PLATFORM_MT53XX
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+#else
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open;
+#endif
+
+		padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+		padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+  		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype=authmode;
+	}	
+	else if(erq->flags & IW_ENCODE_RESTRICTED)
+	{		
+		DBG_871X("rtw_wx_set_enc():IW_ENCODE_RESTRICTED\n");
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+
+#ifdef CONFIG_PLATFORM_MT53XX
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+#else
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Shared;
+#endif
+
+		padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+		padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;			
+		authmode = Ndis802_11AuthModeShared;
+		padapter->securitypriv.ndisauthtype=authmode;
+	}
+	else
+	{
+		DBG_871X("rtw_wx_set_enc():erq->flags=0x%x\n", erq->flags);
+
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;//Ndis802_11EncryptionDisabled;
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; //open system
+		padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+		padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+  		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype=authmode;
+	}
+	
+	wep.KeyIndex = key;
+	if (erq->length > 0)
+	{
+		wep.KeyLength = erq->length <= 5 ? 5 : 13;
+
+		wep.Length = wep.KeyLength + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+	}
+	else
+	{
+		wep.KeyLength = 0 ;
+		
+		if(keyindex_provided == 1)// set key_id only, no given KeyMaterial(erq->length==0).
+		{
+			padapter->securitypriv.dot11PrivacyKeyIndex = key;
+
+			DBG_871X("(keyindex_provided == 1), keyid=%d, key_len=%d\n", key, padapter->securitypriv.dot11DefKeylen[key]);
+
+			switch(padapter->securitypriv.dot11DefKeylen[key])
+			{
+				case 5:
+					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;					
+					break;
+				case 13:
+					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;					
+					break;
+				default:
+					padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;					
+					break;
+			}
+				
+			goto exit;
+			
+		}
+		
+	}
+
+	wep.KeyIndex |= 0x80000000;
+
+	_rtw_memcpy(wep.KeyMaterial, keybuf, wep.KeyLength);
+	
+	if (rtw_set_802_11_add_wep(padapter, &wep) == _FALSE) {
+		if(rf_on == pwrpriv->rf_pwrstate )
+			ret = -EOPNOTSUPP;
+		goto exit;
+	}	
+
+exit:
+	
+	_func_exit_;
+	
+	return ret;
+	
+}
+
+static int rtw_wx_get_enc(struct net_device *dev, 
+			    struct iw_request_info *info, 
+			    union iwreq_data *wrqu, char *keybuf)
+{
+	uint key, ret =0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct iw_point *erq = &(wrqu->encoding);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+	_func_enter_;
+	
+	if(check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE)
+	{
+		 if(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != _TRUE)
+		 {
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+		return 0;
+	}	
+	}	
+
+	
+	key = erq->flags & IW_ENCODE_INDEX;
+
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+	} else
+	{
+		key = padapter->securitypriv.dot11PrivacyKeyIndex;
+	}	
+
+	erq->flags = key + 1;
+
+	//if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)
+	//{
+	//      erq->flags |= IW_ENCODE_OPEN;
+	//}	  
+	
+	switch(padapter->securitypriv.ndisencryptstatus)
+	{
+		case Ndis802_11EncryptionNotSupported:
+		case Ndis802_11EncryptionDisabled:
+
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+	
+		break;
+		
+		case Ndis802_11Encryption1Enabled:					
+		
+		erq->length = padapter->securitypriv.dot11DefKeylen[key];		
+
+		if(erq->length)
+		{
+			_rtw_memcpy(keybuf, padapter->securitypriv.dot11DefKey[key].skey, padapter->securitypriv.dot11DefKeylen[key]);
+		
+		erq->flags |= IW_ENCODE_ENABLED;
+
+			if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)
+			{
+	     			erq->flags |= IW_ENCODE_OPEN;
+			}
+			else if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeShared)
+			{
+		erq->flags |= IW_ENCODE_RESTRICTED;
+			}	
+		}	
+		else
+		{
+			erq->length = 0;
+			erq->flags |= IW_ENCODE_DISABLED;
+		}
+
+		break;
+
+		case Ndis802_11Encryption2Enabled:
+		case Ndis802_11Encryption3Enabled:
+
+		erq->length = 16;
+		erq->flags |= (IW_ENCODE_ENABLED | IW_ENCODE_OPEN | IW_ENCODE_NOKEY);
+
+		break;
+	
+		default:
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+
+		break;
+		
+	}
+	
+	_func_exit_;
+	
+	return ret;
+	
+}				     
+
+static int rtw_wx_get_power(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	//_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	wrqu->power.value = 0;
+	wrqu->power.fixed = 0;	/* no auto select */
+	wrqu->power.disabled = 1;
+	
+	return 0;
+
+}
+
+static int rtw_wx_set_gen_ie(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	int ret;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+       ret = rtw_set_wpa_ie(padapter, extra, wrqu->data.length);
+	   
+	return ret;
+}	
+
+static int rtw_wx_set_auth(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct iw_param *param = (struct iw_param*)&(wrqu->param);
+	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u32 value = param->value;
+	int ret = 0;
+	
+	switch (param->flags & IW_AUTH_INDEX) {
+
+	case IW_AUTH_WPA_VERSION:
+#ifdef CONFIG_WAPI_SUPPORT
+#ifndef CONFIG_IOCTL_CFG80211
+		 padapter->wapiInfo.bWapiEnable = false;
+		 if(value == IW_AUTH_WAPI_VERSION_1)
+		 {
+			padapter->wapiInfo.bWapiEnable = true;
+			psecuritypriv->dot11PrivacyAlgrthm = _SMS4_;
+			psecuritypriv->dot118021XGrpPrivacy = _SMS4_;
+			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_WAPI;
+			pmlmeinfo->auth_algo = psecuritypriv->dot11AuthAlgrthm;
+			padapter->wapiInfo.extra_prefix_len = WAPI_EXT_LEN;
+			padapter->wapiInfo.extra_postfix_len = SMS4_MIC_LEN;
+		}
+#endif
+#endif
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE:
+		
+		break;
+	case IW_AUTH_CIPHER_GROUP:
+		
+		break;
+	case IW_AUTH_KEY_MGMT:
+#ifdef CONFIG_WAPI_SUPPORT
+#ifndef CONFIG_IOCTL_CFG80211
+		DBG_871X("rtw_wx_set_auth: IW_AUTH_KEY_MGMT case \n");
+		if(value == IW_AUTH_KEY_MGMT_WAPI_PSK)
+			padapter->wapiInfo.bWapiPSK = true;
+		else
+			padapter->wapiInfo.bWapiPSK = false;
+		DBG_871X("rtw_wx_set_auth: IW_AUTH_KEY_MGMT bwapipsk %d \n",padapter->wapiInfo.bWapiPSK);
+#endif
+#endif
+		/*
+		 *  ??? does not use these parameters
+		 */
+		break;
+
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+        {
+	    if ( param->value )
+            {  // wpa_supplicant is enabling the tkip countermeasure.
+               padapter->securitypriv.btkip_countermeasure = _TRUE; 
+            }
+            else
+            {  // wpa_supplicant is disabling the tkip countermeasure.
+               padapter->securitypriv.btkip_countermeasure = _FALSE; 
+            }
+		break;
+        }
+	case IW_AUTH_DROP_UNENCRYPTED:
+		{
+			/* HACK:
+			 *
+			 * wpa_supplicant calls set_wpa_enabled when the driver
+			 * is loaded and unloaded, regardless of if WPA is being
+			 * used.  No other calls are made which can be used to
+			 * determine if encryption will be used or not prior to
+			 * association being expected.  If encryption is not being
+			 * used, drop_unencrypted is set to false, else true -- we
+			 * can use this to determine if the CAP_PRIVACY_ON bit should
+			 * be set.
+			 */
+
+			if(padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption1Enabled)
+			{
+				break;//it means init value, or using wep, ndisencryptstatus = Ndis802_11Encryption1Enabled, 
+						// then it needn't reset it;
+			}
+			
+			if(param->value){
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+				padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+				padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+				padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; //open system
+				padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeOpen;
+			}
+			
+			break;
+		}
+
+	case IW_AUTH_80211_AUTH_ALG:
+
+		#if defined(CONFIG_ANDROID) || 1
+		/*
+		 *  It's the starting point of a link layer connection using wpa_supplicant
+		*/
+		if(check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {
+			LeaveAllPowerSaveMode(padapter);
+			rtw_disassoc_cmd(padapter, 500, _FALSE);
+			DBG_871X("%s...call rtw_indicate_disconnect\n ",__FUNCTION__);
+			rtw_indicate_disconnect(padapter);
+			rtw_free_assoc_resources(padapter, 1);
+		}
+		#endif
+
+
+		ret = wpa_set_auth_algs(dev, (u32)param->value);		
+	
+		break;
+
+	case IW_AUTH_WPA_ENABLED:
+
+		//if(param->value)
+		//	padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X; //802.1x
+		//else
+		//	padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;//open system
+		
+		//_disassociate(priv);
+		
+		break;
+
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		//ieee->ieee802_1x = param->value;
+		break;
+
+	case IW_AUTH_PRIVACY_INVOKED:
+		//ieee->privacy_invoked = param->value;
+		break;
+
+#ifdef CONFIG_WAPI_SUPPORT
+#ifndef CONFIG_IOCTL_CFG80211
+	case IW_AUTH_WAPI_ENABLED:
+		break;
+#endif
+#endif
+
+	default:
+		return -EOPNOTSUPP;
+		
+	}
+	
+	return ret;
+	
+}
+
+static int rtw_wx_set_enc_ext(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	char *alg_name;
+	u32 param_len;
+	struct ieee_param *param = NULL;
+	struct iw_point *pencoding = &wrqu->encoding;
+ 	struct iw_encode_ext *pext = (struct iw_encode_ext *)extra;
+	int ret=0;
+
+	param_len = sizeof(struct ieee_param) + pext->key_len;
+	param = (struct ieee_param *)rtw_malloc(param_len);
+	if (param == NULL)
+		return -1;
+	
+	_rtw_memset(param, 0, param_len);
+
+	param->cmd = IEEE_CMD_SET_ENCRYPTION;
+	_rtw_memset(param->sta_addr, 0xff, ETH_ALEN);
+
+
+	switch (pext->alg) {
+	case IW_ENCODE_ALG_NONE:
+		//todo: remove key 
+		//remove = 1;	
+		alg_name = "none";
+		break;
+	case IW_ENCODE_ALG_WEP:
+		alg_name = "WEP";
+		break;
+	case IW_ENCODE_ALG_TKIP:
+		alg_name = "TKIP";
+		break;
+	case IW_ENCODE_ALG_CCMP:
+		alg_name = "CCMP";
+		break;
+#ifdef CONFIG_IEEE80211W
+	case IW_ENCODE_ALG_AES_CMAC:
+		alg_name = "BIP";
+		break;
+#endif //CONFIG_IEEE80211W
+#ifdef CONFIG_WAPI_SUPPORT
+#ifndef CONFIG_IOCTL_CFG80211
+	case IW_ENCODE_ALG_SM4:
+		alg_name= "SMS4";
+		_rtw_memcpy(param->sta_addr, pext->addr.sa_data, ETH_ALEN);
+		DBG_871X("rtw_wx_set_enc_ext: SMS4 case \n");
+		break;
+#endif
+#endif
+	default:
+		ret = -1;
+		goto exit;
+	}
+
+	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
+
+	if (pext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)
+	{
+		param->u.crypt.set_tx = 1;
+	}
+
+	/* cliW: WEP does not have group key
+	 * just not checking GROUP key setting 
+	 */
+	if ((pext->alg != IW_ENCODE_ALG_WEP) &&
+		((pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
+#ifdef CONFIG_IEEE80211W
+		|| (pext->ext_flags & IW_ENCODE_ALG_AES_CMAC)
+#endif //CONFIG_IEEE80211W
+	))
+	{
+		param->u.crypt.set_tx = 0;
+	}
+
+	param->u.crypt.idx = (pencoding->flags&0x00FF) -1 ;
+
+	if (pext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)
+	{
+#ifdef CONFIG_WAPI_SUPPORT
+#ifndef CONFIG_IOCTL_CFG80211
+		if(pext->alg == IW_ENCODE_ALG_SM4)
+			_rtw_memcpy(param->u.crypt.seq, pext->rx_seq, 16);
+		else
+#endif //CONFIG_IOCTL_CFG80211
+#endif //CONFIG_WAPI_SUPPORT
+		_rtw_memcpy(param->u.crypt.seq, pext->rx_seq, 8);
+	}
+
+	if(pext->key_len)
+	{
+		param->u.crypt.key_len = pext->key_len;
+		//_rtw_memcpy(param + 1, pext + 1, pext->key_len);
+		_rtw_memcpy(param->u.crypt.key, pext + 1, pext->key_len);
+	}
+
+	if (pencoding->flags & IW_ENCODE_DISABLED)
+	{
+		//todo: remove key 
+		//remove = 1;
+	}
+
+	ret =  wpa_set_encryption(dev, param, param_len);
+
+exit:
+	if(param)
+	{
+		rtw_mfree((u8*)param, param_len);
+	}
+
+	return ret;
+}
+
+
+static int rtw_wx_get_nick(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{	
+	//_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	 //struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	 //struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	if(extra)
+	{
+		wrqu->data.length = 14;
+		wrqu->data.flags = 1;
+		_rtw_memcpy(extra, "<WIFI@REALTEK>", 14);
+	}
+
+	//rtw_signal_process(pid, SIGUSR1); //for test
+
+	//dump debug info here	
+/*
+	u32 dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, and 8021x
+	u32 dot11PrivacyAlgrthm;	// This specify the privacy for shared auth. algorithm.
+	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key 
+	u32 ndisauthtype;
+	u32 ndisencryptstatus;
+*/
+
+	//DBG_871X("auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
+	//		psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
+	//		psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
+	
+	//DBG_871X("enc_alg=0x%x\n", psecuritypriv->dot11PrivacyAlgrthm);
+	//DBG_871X("auth_type=0x%x\n", psecuritypriv->ndisauthtype);
+	//DBG_871X("enc_type=0x%x\n", psecuritypriv->ndisencryptstatus);
+
+#if 0
+	DBG_871X("dbg(0x210)=0x%x\n", rtw_read32(padapter, 0x210));
+	DBG_871X("dbg(0x608)=0x%x\n", rtw_read32(padapter, 0x608));
+	DBG_871X("dbg(0x280)=0x%x\n", rtw_read32(padapter, 0x280));
+	DBG_871X("dbg(0x284)=0x%x\n", rtw_read32(padapter, 0x284));
+	DBG_871X("dbg(0x288)=0x%x\n", rtw_read32(padapter, 0x288));
+	
+	DBG_871X("dbg(0x664)=0x%x\n", rtw_read32(padapter, 0x664));
+
+
+	DBG_871X("\n");
+
+	DBG_871X("dbg(0x430)=0x%x\n", rtw_read32(padapter, 0x430));
+	DBG_871X("dbg(0x438)=0x%x\n", rtw_read32(padapter, 0x438));
+
+	DBG_871X("dbg(0x440)=0x%x\n", rtw_read32(padapter, 0x440));
+	
+	DBG_871X("dbg(0x458)=0x%x\n", rtw_read32(padapter, 0x458));
+	
+	DBG_871X("dbg(0x484)=0x%x\n", rtw_read32(padapter, 0x484));
+	DBG_871X("dbg(0x488)=0x%x\n", rtw_read32(padapter, 0x488));
+	
+	DBG_871X("dbg(0x444)=0x%x\n", rtw_read32(padapter, 0x444));
+	DBG_871X("dbg(0x448)=0x%x\n", rtw_read32(padapter, 0x448));
+	DBG_871X("dbg(0x44c)=0x%x\n", rtw_read32(padapter, 0x44c));
+	DBG_871X("dbg(0x450)=0x%x\n", rtw_read32(padapter, 0x450));
+#endif
+	
+	return 0;
+
+}
+
+static int rtw_wx_read32(struct net_device *dev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *extra)
+{
+	PADAPTER padapter;
+	struct iw_point *p;
+	u16 len;
+	u32 addr;
+	u32 data32;
+	u32 bytes;
+	u8 *ptmp;
+	int ret;
+
+
+	ret = 0;
+	padapter = (PADAPTER)rtw_netdev_priv(dev);
+	p = &wrqu->data;
+	len = p->length;
+	if (0 == len)
+		return -EINVAL;
+
+	ptmp = (u8*)rtw_malloc(len);
+	if (NULL == ptmp)
+		return -ENOMEM;
+
+	if (copy_from_user(ptmp, p->pointer, len)) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	bytes = 0;
+	addr = 0;
+	sscanf(ptmp, "%d,%x", &bytes, &addr);
+
+	switch (bytes) {
+		case 1:
+			data32 = rtw_read8(padapter, addr);
+			sprintf(extra, "0x%02X", data32);
+			break;
+		case 2:
+			data32 = rtw_read16(padapter, addr);
+			sprintf(extra, "0x%04X", data32);
+			break;
+		case 4:
+			data32 = rtw_read32(padapter, addr);
+			sprintf(extra, "0x%08X", data32);
+			break;
+		default:
+			DBG_871X(KERN_INFO "%s: usage> read [bytes],[address(hex)]\n", __func__);
+			ret = -EINVAL;
+			goto exit;
+	}
+	DBG_871X(KERN_INFO "%s: addr=0x%08X data=%s\n", __func__, addr, extra);
+
+exit:
+	rtw_mfree(ptmp, len);
+
+	return 0;
+}
+
+static int rtw_wx_write32(struct net_device *dev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *extra)
+{
+	PADAPTER padapter = (PADAPTER)rtw_netdev_priv(dev);
+
+	u32 addr;
+	u32 data32;
+	u32 bytes;
+
+
+	bytes = 0;
+	addr = 0;
+	data32 = 0;
+	sscanf(extra, "%d,%x,%x", &bytes, &addr, &data32);
+
+	switch (bytes) {
+		case 1:
+			rtw_write8(padapter, addr, (u8)data32);
+			DBG_871X(KERN_INFO "%s: addr=0x%08X data=0x%02X\n", __func__, addr, (u8)data32);
+			break;
+		case 2:
+			rtw_write16(padapter, addr, (u16)data32);
+			DBG_871X(KERN_INFO "%s: addr=0x%08X data=0x%04X\n", __func__, addr, (u16)data32);
+			break;
+		case 4:
+			rtw_write32(padapter, addr, data32);
+			DBG_871X(KERN_INFO "%s: addr=0x%08X data=0x%08X\n", __func__, addr, data32);
+			break;
+		default:
+			DBG_871X(KERN_INFO "%s: usage> write [bytes],[address(hex)],[data(hex)]\n", __func__);
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rtw_wx_read_rf(struct net_device *dev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u32 path, addr, data32;
+
+
+	path = *(u32*)extra;
+	addr = *((u32*)extra + 1);
+	data32 = rtw_hal_read_rfreg(padapter, path, addr, 0xFFFFF);
+//	DBG_871X("%s: path=%d addr=0x%02x data=0x%05x\n", __func__, path, addr, data32);
+	/*
+	 * IMPORTANT!!
+	 * Only when wireless private ioctl is at odd order,
+	 * "extra" would be copied to user space.
+	 */
+	sprintf(extra, "0x%05x", data32);
+
+	return 0;
+}
+
+static int rtw_wx_write_rf(struct net_device *dev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u32 path, addr, data32;
+
+
+	path = *(u32*)extra;
+	addr = *((u32*)extra + 1);
+	data32 = *((u32*)extra + 2);
+//	DBG_871X("%s: path=%d addr=0x%02x data=0x%05x\n", __func__, path, addr, data32);
+	rtw_hal_write_rfreg(padapter, path, addr, 0xFFFFF, data32);
+
+	return 0;
+}
+
+static int rtw_wx_priv_null(struct net_device *dev, struct iw_request_info *a,
+		 union iwreq_data *wrqu, char *b)
+{
+	return -1;
+}
+
+static int dummy(struct net_device *dev, struct iw_request_info *a,
+		 union iwreq_data *wrqu, char *b)
+{
+	//_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	//struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	//DBG_871X("cmd_code=%x, fwstate=0x%x\n", a->cmd, get_fwstate(pmlmepriv));
+	
+	return -1;
+	
+}
+
+static int rtw_wx_set_channel_plan(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	u8 channel_plan_req = (u8) (*((int *)wrqu));
+
+	if (_SUCCESS != rtw_set_channel_plan(padapter, channel_plan_req))
+		return -EPERM;
+
+	return 0;
+}
+
+static int rtw_wx_set_mtk_wps_probe_ie(struct net_device *dev,
+		struct iw_request_info *a,
+		union iwreq_data *wrqu, char *b)
+{
+#ifdef CONFIG_PLATFORM_MT53XX
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+		 ("WLAN IOCTL: cmd_code=%x, fwstate=0x%x\n",
+		  a->cmd, get_fwstate(pmlmepriv)));
+#endif
+	return 0;
+}
+
+static int rtw_wx_get_sensitivity(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *buf)
+{
+#ifdef CONFIG_PLATFORM_MT53XX
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	//	Modified by Albert 20110914
+	//	This is in dbm format for MTK platform.
+	wrqu->qual.level = padapter->recvpriv.rssi;
+	DBG_871X(" level = %u\n",  wrqu->qual.level );
+#endif
+	return 0;
+}
+
+static int rtw_wx_set_mtk_wps_ie(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+#ifdef CONFIG_PLATFORM_MT53XX
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	return rtw_set_wpa_ie(padapter, wrqu->data.pointer, wrqu->data.length);
+#else
+	return 0;
+#endif
+}
+
+/*
+typedef int (*iw_handler)(struct net_device *dev, struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra);
+*/
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+static  int rtw_drvext_hdl(struct net_device *dev, struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
+{
+
+ #if 0
+struct	iw_point
+{
+  void __user	*pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+ #endif
+
+#ifdef CONFIG_DRVEXT_MODULE
+	u8 res;
+	struct drvext_handler *phandler;	
+	struct drvext_oidparam *poidparam;		
+	int ret;
+	u16 len;
+	u8 *pparmbuf, bset;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct iw_point *p = &wrqu->data;
+
+	if( (!p->length) || (!p->pointer)){
+		ret = -EINVAL;
+		goto _rtw_drvext_hdl_exit;
+	}
+	
+	
+	bset = (u8)(p->flags&0xFFFF);
+	len = p->length;
+	pparmbuf = (u8*)rtw_malloc(len);
+	if (pparmbuf == NULL){
+		ret = -ENOMEM;
+		goto _rtw_drvext_hdl_exit;
+	}
+	
+	if(bset)//set info
+	{
+		if (copy_from_user(pparmbuf, p->pointer,len)) {
+			rtw_mfree(pparmbuf, len);
+			ret = -EFAULT;
+			goto _rtw_drvext_hdl_exit;
+		}		
+	}
+	else//query info
+	{
+	
+	}
+
+	
+	//
+	poidparam = (struct drvext_oidparam *)pparmbuf;	
+	
+	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("drvext set oid subcode [%d], len[%d], InformationBufferLength[%d]\r\n",
+        					 poidparam->subcode, poidparam->len, len));
+
+
+	//check subcode	
+	if ( poidparam->subcode >= MAX_DRVEXT_HANDLERS)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext handlers\r\n"));		
+		ret = -EINVAL;
+		goto _rtw_drvext_hdl_exit;
+	}
+
+
+	if ( poidparam->subcode >= MAX_DRVEXT_OID_SUBCODES)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext subcodes\r\n"));		
+		ret = -EINVAL;
+		goto _rtw_drvext_hdl_exit;
+	}
+
+
+	phandler = drvextoidhandlers + poidparam->subcode;
+
+	if (poidparam->len != phandler->parmsize)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext param size %d vs %d\r\n",			
+						poidparam->len , phandler->parmsize));		
+		ret = -EINVAL;		
+		goto _rtw_drvext_hdl_exit;
+	}
+
+
+	res = phandler->handler(&padapter->drvextpriv, bset, poidparam->data);
+
+	if(res==0)
+	{
+		ret = 0;
+			
+		if (bset == 0x00) {//query info
+			//_rtw_memcpy(p->pointer, pparmbuf, len);
+			if (copy_to_user(p->pointer, pparmbuf, len))
+				ret = -EFAULT;
+		}		
+	}		
+	else
+		ret = -EFAULT;
+
+	
+_rtw_drvext_hdl_exit:	
+	
+	return ret;	
+	
+#endif
+
+	return 0;
+
+}
+
+static void rtw_dbg_mode_hdl(_adapter *padapter, u32 id, u8 *pdata, u32 len)
+{
+	pRW_Reg 	RegRWStruct;
+	struct rf_reg_param *prfreg;
+	u8 path;
+	u8 offset;
+	u32 value;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	switch(id)
+	{
+		case GEN_MP_IOCTL_SUBCODE(MP_START):
+			DBG_871X("871x_driver is only for normal mode, can't enter mp mode\n");
+			break;
+		case GEN_MP_IOCTL_SUBCODE(READ_REG):
+			RegRWStruct = (pRW_Reg)pdata;
+			switch (RegRWStruct->width)
+			{
+				case 1:
+					RegRWStruct->value = rtw_read8(padapter, RegRWStruct->offset);
+					break;
+				case 2:
+					RegRWStruct->value = rtw_read16(padapter, RegRWStruct->offset);
+					break;
+				case 4:
+					RegRWStruct->value = rtw_read32(padapter, RegRWStruct->offset);
+					break;
+				default:
+					break;
+			}
+		
+			break;
+		case GEN_MP_IOCTL_SUBCODE(WRITE_REG):
+			RegRWStruct = (pRW_Reg)pdata;
+			switch (RegRWStruct->width)
+			{
+				case 1:
+					rtw_write8(padapter, RegRWStruct->offset, (u8)RegRWStruct->value);
+					break;
+				case 2:
+					rtw_write16(padapter, RegRWStruct->offset, (u16)RegRWStruct->value);
+					break;
+				case 4:
+					rtw_write32(padapter, RegRWStruct->offset, (u32)RegRWStruct->value);
+					break;
+				default:					
+				break;
+			}
+				
+			break;
+		case GEN_MP_IOCTL_SUBCODE(READ_RF_REG):
+
+			prfreg = (struct rf_reg_param *)pdata;
+
+			path = (u8)prfreg->path;		
+			offset = (u8)prfreg->offset;	
+
+			value = rtw_hal_read_rfreg(padapter, path, offset, 0xffffffff);
+
+			prfreg->value = value;
+
+			break;			
+		case GEN_MP_IOCTL_SUBCODE(WRITE_RF_REG):
+
+			prfreg = (struct rf_reg_param *)pdata;
+
+			path = (u8)prfreg->path;
+			offset = (u8)prfreg->offset;	
+			value = prfreg->value;
+
+			rtw_hal_write_rfreg(padapter, path, offset, 0xffffffff, value);
+			
+			break;			
+                case GEN_MP_IOCTL_SUBCODE(TRIGGER_GPIO):
+			DBG_871X("==> trigger gpio 0\n");
+			rtw_hal_set_hwreg(padapter, HW_VAR_TRIGGER_GPIO_0, 0);
+			break;	
+#ifdef CONFIG_BT_COEXIST
+		case GEN_MP_IOCTL_SUBCODE(SET_DM_BT):			
+			DBG_871X("==> set dm_bt_coexist:%x\n",*(u8 *)pdata);
+			rtw_hal_set_hwreg(padapter, HW_VAR_BT_SET_COEXIST, pdata);
+			break;
+		case GEN_MP_IOCTL_SUBCODE(DEL_BA):
+			DBG_871X("==> delete ba:%x\n",*(u8 *)pdata);
+			rtw_hal_set_hwreg(padapter, HW_VAR_BT_ISSUE_DELBA, pdata);
+			break;
+#endif
+#ifdef DBG_CONFIG_ERROR_DETECT
+		case GEN_MP_IOCTL_SUBCODE(GET_WIFI_STATUS):							
+			*pdata = rtw_hal_sreset_get_wifi_status(padapter);                   
+			break;
+#endif
+	
+		default:
+			break;
+	}
+	
+}
+
+static int rtw_mp_ioctl_hdl(struct net_device *dev, struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	u32 BytesRead, BytesWritten, BytesNeeded;
+	struct oid_par_priv	oid_par;
+	struct mp_ioctl_handler	*phandler;
+	struct mp_ioctl_param	*poidparam;
+	uint status=0;
+	u16 len;
+	u8 *pparmbuf = NULL, bset;
+	PADAPTER padapter = (PADAPTER)rtw_netdev_priv(dev);
+	struct iw_point *p = &wrqu->data;
+
+	//DBG_871X("+rtw_mp_ioctl_hdl\n");
+
+	//mutex_lock(&ioctl_mutex);
+
+	if ((!p->length) || (!p->pointer)) {
+		ret = -EINVAL;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	pparmbuf = NULL;
+	bset = (u8)(p->flags & 0xFFFF);
+	len = p->length;
+	pparmbuf = (u8*)rtw_malloc(len);
+	if (pparmbuf == NULL){
+		ret = -ENOMEM;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	if (copy_from_user(pparmbuf, p->pointer, len)) {
+		ret = -EFAULT;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	poidparam = (struct mp_ioctl_param *)pparmbuf;
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		 ("rtw_mp_ioctl_hdl: subcode [%d], len[%d], buffer_len[%d]\r\n",
+		  poidparam->subcode, poidparam->len, len));
+
+	if (poidparam->subcode >= MAX_MP_IOCTL_SUBCODE) {
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("no matching drvext subcodes\r\n"));
+		ret = -EINVAL;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	//DBG_871X("%s: %d\n", __func__, poidparam->subcode);
+#ifdef CONFIG_MP_INCLUDED 
+if (padapter->registrypriv.mp_mode == 1)
+{	
+	phandler = mp_ioctl_hdl + poidparam->subcode;
+
+	if ((phandler->paramsize != 0) && (poidparam->len < phandler->paramsize))
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,
+			 ("no matching drvext param size %d vs %d\r\n",
+			  poidparam->len, phandler->paramsize));
+		ret = -EINVAL;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	if (phandler->handler)
+	{
+		oid_par.adapter_context = padapter;
+		oid_par.oid = phandler->oid;
+		oid_par.information_buf = poidparam->data;
+		oid_par.information_buf_len = poidparam->len;
+		oid_par.dbg = 0;
+
+		BytesWritten = 0;
+		BytesNeeded = 0;
+
+		if (bset) {
+			oid_par.bytes_rw = &BytesRead;
+			oid_par.bytes_needed = &BytesNeeded;
+			oid_par.type_of_oid = SET_OID;
+		} else {
+			oid_par.bytes_rw = &BytesWritten;
+			oid_par.bytes_needed = &BytesNeeded;
+			oid_par.type_of_oid = QUERY_OID;
+		}
+
+		status = phandler->handler(&oid_par);
+
+		//todo:check status, BytesNeeded, etc.
+	}
+	else {
+		DBG_871X("rtw_mp_ioctl_hdl(): err!, subcode=%d, oid=%d, handler=%p\n", 
+			poidparam->subcode, phandler->oid, phandler->handler);
+		ret = -EFAULT;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+}
+else
+#endif
+{
+	rtw_dbg_mode_hdl(padapter, poidparam->subcode, poidparam->data, poidparam->len);
+}
+
+	if (bset == 0x00) {//query info
+		if (copy_to_user(p->pointer, pparmbuf, len))
+			ret = -EFAULT;
+	}
+
+	if (status) {
+		ret = -EFAULT;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+_rtw_mp_ioctl_hdl_exit:
+
+	if (pparmbuf)
+		rtw_mfree(pparmbuf, len);
+
+	//mutex_unlock(&ioctl_mutex);
+
+	return ret;
+}
+
+static int rtw_get_ap_info(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	int bssid_match, ret = 0;
+	u32 cnt=0, wpa_ielen;
+	_irqL	irqL;
+	_list	*plist, *phead;
+	unsigned char *pbuf;
+	u8 bssid[ETH_ALEN];
+	char data[32];
+	struct wlan_network *pnetwork = NULL;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
+	_queue *queue = &(pmlmepriv->scanned_queue);
+	struct iw_point *pdata = &wrqu->data;	
+
+	DBG_871X("+rtw_get_aplist_info\n");
+
+	if (rtw_is_drv_stopped(padapter) || (pdata == NULL)) {
+		ret= -EINVAL;
+		goto exit;
+	}		
+  
+ 	while((check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) == _TRUE)
+	{	
+		rtw_msleep_os(30);
+		cnt++;
+		if(cnt > 100)
+			break;
+	}
+	
+
+	//pdata->length = 0;//?	
+	pdata->flags = 0;
+	if(pdata->length>=32)
+	{
+		if(copy_from_user(data, pdata->pointer, 32))
+		{
+			ret= -EINVAL;
+			goto exit;
+		}
+	}	
+	else
+	{
+		ret= -EINVAL;
+		goto exit;
+	}	
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+       
+	while(1)
+	{
+		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		//if(hwaddr_aton_i(pdata->pointer, bssid)) 
+		if(hwaddr_aton_i(data, bssid)) 
+		{			
+			DBG_871X("Invalid BSSID '%s'.\n", (u8*)data);
+			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			return -EINVAL;
+		}		
+		
+	
+		if(_rtw_memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN) == _TRUE)//BSSID match, then check if supporting wpa/wpa2
+		{
+			DBG_871X("BSSID:" MAC_FMT "\n", MAC_ARG(bssid));
+			
+			pbuf = rtw_get_wpa_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);				
+			if(pbuf && (wpa_ielen>0))
+			{
+				pdata->flags = 1;
+				break;
+			}
+
+			pbuf = rtw_get_wpa2_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
+			if(pbuf && (wpa_ielen>0))
+			{
+				pdata->flags = 2;
+				break;
+			}
+			
+		}
+
+		plist = get_next(plist);		
+	
+	}        
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	if(pdata->length>=34)
+	{
+		if(copy_to_user((u8*)pdata->pointer+32, (u8*)&pdata->flags, 1))
+		{
+			ret= -EINVAL;
+			goto exit;
+		}
+	}	
+	
+exit:
+	
+	return ret;
+		
+}
+
+static int rtw_set_pid(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = rtw_netdev_priv(dev);	
+	int *pdata = (int *)wrqu;
+	int selector;
+
+	if (rtw_is_drv_stopped(padapter) || (pdata == NULL)) {
+		ret= -EINVAL;
+		goto exit;
+	}		
+  
+	selector = *pdata;
+	if(selector < 3 && selector >=0) {
+		padapter->pid[selector] = *(pdata+1);
+		#ifdef CONFIG_GLOBAL_UI_PID
+		ui_pid[selector] = *(pdata+1);
+		#endif
+		DBG_871X("%s set pid[%d]=%d\n", __FUNCTION__, selector ,padapter->pid[selector]);
+	}
+	else
+		DBG_871X("%s selector %d error\n", __FUNCTION__, selector);
+
+exit:
+	
+	return ret;
+		
+}
+
+static int rtw_wps_start(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	u32   u32wps_start = 0;
+        unsigned int uintRet = 0;
+
+	if (RTW_CANNOT_RUN(padapter) || (NULL == pdata)) {
+		ret= -EINVAL;
+		goto exit;
+	}		
+
+	uintRet = copy_from_user( ( void* ) &u32wps_start, pdata->pointer, 4 );
+	if ( u32wps_start == 0 )
+	{
+		u32wps_start = *extra;
+	}
+
+	DBG_871X( "[%s] wps_start = %d\n", __FUNCTION__, u32wps_start );
+
+	if ( u32wps_start == 1 ) // WPS Start
+	{
+		rtw_led_control(padapter, LED_CTL_START_WPS);
+	}
+	else if ( u32wps_start == 2 ) // WPS Stop because of wps success
+	{
+		rtw_led_control(padapter, LED_CTL_STOP_WPS);
+	}
+	else if ( u32wps_start == 3 ) // WPS Stop because of wps fail
+	{
+		rtw_led_control(padapter, LED_CTL_STOP_WPS_FAIL);
+	}
+
+#ifdef CONFIG_INTEL_WIDI
+	process_intel_widi_wps_status(padapter, u32wps_start);
+#endif //CONFIG_INTEL_WIDI
+	
+exit:
+	
+	return ret;
+		
+}
+
+#ifdef CONFIG_P2P
+static int rtw_wext_p2p_enable(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	enum P2P_ROLE init_role = P2P_ROLE_DISABLE;
+
+	if(*extra == '0' )
+		init_role = P2P_ROLE_DISABLE;
+	else if(*extra == '1')
+		init_role = P2P_ROLE_DEVICE;
+	else if(*extra == '2')
+		init_role = P2P_ROLE_CLIENT;
+	else if(*extra == '3')
+		init_role = P2P_ROLE_GO;
+
+	if(_FAIL == rtw_p2p_enable(padapter, init_role))
+	{
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	//set channel/bandwidth
+	if(init_role != P2P_ROLE_DISABLE) 
+	{	
+		u8 channel, ch_offset;
+		u16 bwmode;
+
+		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN))
+		{
+			//	Stay at the listen state and wait for discovery.
+			channel = pwdinfo->listen_channel;
+			pwdinfo->operating_channel = pwdinfo->listen_channel;
+			ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+			bwmode = CHANNEL_WIDTH_20;
+		}
+#ifdef CONFIG_CONCURRENT_MODE
+		else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
+		{
+			_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
+			//struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
+			struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
+			struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+			
+			_set_timer( &pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_interval );
+			if ( check_fwstate( pbuddy_mlmepriv, _FW_LINKED ) )
+			{
+				pwdinfo->operating_channel = pbuddy_mlmeext->cur_channel;
+				//	How about the ch_offset and bwmode ??
+			}
+			else
+			{
+				pwdinfo->operating_channel = pwdinfo->listen_channel;
+			}
+
+			channel = pbuddy_mlmeext->cur_channel;
+			ch_offset = pbuddy_mlmeext->cur_ch_offset;
+			bwmode = pbuddy_mlmeext->cur_bwmode;
+		}
+#endif
+		else
+		{
+			pwdinfo->operating_channel = pmlmeext->cur_channel;
+		
+			channel = pwdinfo->operating_channel;
+			ch_offset = pmlmeext->cur_ch_offset;
+			bwmode = pmlmeext->cur_bwmode;						
+		}
+
+		set_channel_bwmode(padapter, channel, ch_offset, bwmode);
+	}
+
+exit:
+	return ret;
+		
+}
+
+static int rtw_p2p_set_go_nego_ssid(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+
+	DBG_871X( "[%s] ssid = %s, len = %zu\n", __FUNCTION__, extra, strlen( extra ) );
+	_rtw_memcpy( pwdinfo->nego_ssid, extra, strlen( extra ) );
+	pwdinfo->nego_ssidlen = strlen( extra );
+	
+	return ret;
+		
+}
+
+
+static int rtw_p2p_set_intent(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	int 							ret = 0;
+	_adapter 						*padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct wifidirect_info 			*pwdinfo= &(padapter->wdinfo);
+	u8							intent = pwdinfo->intent;
+
+	extra[ wrqu->data.length ] = 0x00;
+
+	intent = rtw_atoi( extra );
+
+	if ( intent <= 15 )
+	{
+		pwdinfo->intent= intent;
+	}
+	else
+	{
+		ret = -1;
+	}
+	
+	DBG_871X( "[%s] intent = %d\n", __FUNCTION__, intent);
+
+	return ret;
+		
+}
+
+static int rtw_p2p_set_listen_ch(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+	u8	listen_ch = pwdinfo->listen_channel;	//	Listen channel number
+
+	extra[ wrqu->data.length ] = 0x00;
+	listen_ch = rtw_atoi( extra );
+
+	if ( ( listen_ch == 1 ) || ( listen_ch == 6 ) || ( listen_ch == 11 ) )
+	{
+		pwdinfo->listen_channel = listen_ch;
+		set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+	}
+	else
+	{
+		ret = -1;
+	}
+	
+	DBG_871X( "[%s] listen_ch = %d\n", __FUNCTION__, pwdinfo->listen_channel );
+	
+	return ret;
+		
+}
+
+static int rtw_p2p_set_op_ch(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+//	Commented by Albert 20110524
+//	This function is used to set the operating channel if the driver will become the group owner
+
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+	u8	op_ch = pwdinfo->operating_channel;	//	Operating channel number
+
+	extra[ wrqu->data.length ] = 0x00;
+
+	op_ch = ( u8 ) rtw_atoi( extra );
+	if ( op_ch > 0 )
+	{
+		pwdinfo->operating_channel = op_ch;
+	}
+	else
+	{
+		ret = -1;
+	}
+	
+	DBG_871X( "[%s] op_ch = %d\n", __FUNCTION__, pwdinfo->operating_channel );
+	
+	return ret;
+
+}
+
+
+static int rtw_p2p_profilefound(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+
+	//	Comment by Albert 2010/10/13
+	//	Input data format:
+	//	Ex:  0
+	//	Ex:  1XX:XX:XX:XX:XX:XXYYSSID
+	//	0 => Reflush the profile record list.
+	//	1 => Add the profile list
+	//	XX:XX:XX:XX:XX:XX => peer's MAC Address ( ex: 00:E0:4C:00:00:01 )
+	//	YY => SSID Length
+	//	SSID => SSID for persistence group
+
+	DBG_871X( "[%s] In value = %s, len = %d \n", __FUNCTION__, extra, wrqu->data.length -1);
+
+	
+	//	The upper application should pass the SSID to driver by using this rtw_p2p_profilefound function.
+	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	{
+		if ( extra[ 0 ] == '0' )
+		{
+			//	Remove all the profile information of wifidirect_info structure.
+			_rtw_memset( &pwdinfo->profileinfo[ 0 ], 0x00, sizeof( struct profile_info ) * P2P_MAX_PERSISTENT_GROUP_NUM );
+			pwdinfo->profileindex = 0;
+		}
+		else
+		{
+			if ( pwdinfo->profileindex >= P2P_MAX_PERSISTENT_GROUP_NUM )
+		{
+				ret = -1;
+		}
+		else
+		{
+				int jj, kk;
+				
+				//	Add this profile information into pwdinfo->profileinfo
+				//	Ex:  1XX:XX:XX:XX:XX:XXYYSSID
+				for( jj = 0, kk = 1; jj < ETH_ALEN; jj++, kk += 3 )
+				{
+					pwdinfo->profileinfo[ pwdinfo->profileindex ].peermac[ jj ] = key_2char2num(extra[ kk ], extra[ kk+ 1 ]);
+				}
+
+				//pwdinfo->profileinfo[ pwdinfo->profileindex ].ssidlen = ( extra[18] - '0' ) * 10 + ( extra[ 19 ] - '0' );
+				//_rtw_memcpy( pwdinfo->profileinfo[ pwdinfo->profileindex ].ssid, &extra[ 20 ], pwdinfo->profileinfo[ pwdinfo->profileindex ].ssidlen );
+				pwdinfo->profileindex++;
+			}
+		}
+	}	
+	
+	return ret;
+		
+}
+
+static int rtw_p2p_setDN(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+
+
+	DBG_871X( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1  );
+	_rtw_memset( pwdinfo->device_name, 0x00, WPS_MAX_DEVICE_NAME_LEN );
+	_rtw_memcpy( pwdinfo->device_name, extra, wrqu->data.length - 1 );
+	pwdinfo->device_name_len = wrqu->data.length - 1;
+
+	return ret;
+		
+}
+
+
+static int rtw_p2p_get_status(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+#ifdef CONFIG_CONCURRENT_MODE
+	_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
+	struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
+	struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
+	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;	
+#endif
+	
+	if ( padapter->bShowGetP2PState )
+	{
+		DBG_871X( "[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
+				pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
+				pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
+	}
+
+	//	Commented by Albert 2010/10/12
+	//	Because of the output size limitation, I had removed the "Role" information.
+	//	About the "Role" information, we will use the new private IOCTL to get the "Role" information.
+	sprintf( extra, "\n\nStatus=%.2d\n", rtw_p2p_state(pwdinfo) );
+	wrqu->data.length = strlen( extra );
+
+	return ret;
+		
+}
+
+//	Commented by Albert 20110520
+//	This function will return the config method description 
+//	This config method description will show us which config method the remote P2P device is intented to use
+//	by sending the provisioning discovery request frame.
+
+static int rtw_p2p_get_req_cm(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+
+	sprintf( extra, "\n\nCM=%s\n", pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req );
+	wrqu->data.length = strlen( extra );
+	return ret;
+		
+}
+
+
+static int rtw_p2p_get_role(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+
+	
+	DBG_871X( "[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
+			pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
+			pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
+
+	sprintf( extra, "\n\nRole=%.2d\n", rtw_p2p_role(pwdinfo) );
+	wrqu->data.length = strlen( extra );
+	return ret;
+		
+}
+
+
+static int rtw_p2p_get_peer_ifaddr(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+
+
+	DBG_871X( "[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
+			pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
+			pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
+
+	sprintf( extra, "\nMAC %.2X:%.2X:%.2X:%.2X:%.2X:%.2X",
+			pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
+			pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
+	wrqu->data.length = strlen( extra );
+	return ret;
+		
+}
+
+static int rtw_p2p_get_peer_devaddr(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+
+	DBG_871X( "[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
+			pwdinfo->rx_prov_disc_info.peerDevAddr[ 0 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 1 ], 
+			pwdinfo->rx_prov_disc_info.peerDevAddr[ 2 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 3 ],
+			pwdinfo->rx_prov_disc_info.peerDevAddr[ 4 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 5 ]);
+	sprintf( extra, "\n%.2X%.2X%.2X%.2X%.2X%.2X",
+			pwdinfo->rx_prov_disc_info.peerDevAddr[ 0 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 1 ], 
+			pwdinfo->rx_prov_disc_info.peerDevAddr[ 2 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 3 ],
+			pwdinfo->rx_prov_disc_info.peerDevAddr[ 4 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 5 ]);
+	wrqu->data.length = strlen( extra );	
+	return ret;
+		
+}
+
+static int rtw_p2p_get_peer_devaddr_by_invitation(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+
+	DBG_871X( "[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
+			pwdinfo->p2p_peer_device_addr[ 0 ], pwdinfo->p2p_peer_device_addr[ 1 ], 
+			pwdinfo->p2p_peer_device_addr[ 2 ], pwdinfo->p2p_peer_device_addr[ 3 ],
+			pwdinfo->p2p_peer_device_addr[ 4 ], pwdinfo->p2p_peer_device_addr[ 5 ]);
+	sprintf( extra, "\nMAC %.2X:%.2X:%.2X:%.2X:%.2X:%.2X",
+			pwdinfo->p2p_peer_device_addr[ 0 ], pwdinfo->p2p_peer_device_addr[ 1 ], 
+			pwdinfo->p2p_peer_device_addr[ 2 ], pwdinfo->p2p_peer_device_addr[ 3 ],
+			pwdinfo->p2p_peer_device_addr[ 4 ], pwdinfo->p2p_peer_device_addr[ 5 ]);
+	wrqu->data.length = strlen( extra );	
+	return ret;
+		
+}
+
+static int rtw_p2p_get_groupid(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+
+	sprintf( extra, "\n%.2X:%.2X:%.2X:%.2X:%.2X:%.2X %s",
+			pwdinfo->groupid_info.go_device_addr[ 0 ], pwdinfo->groupid_info.go_device_addr[ 1 ], 
+			pwdinfo->groupid_info.go_device_addr[ 2 ], pwdinfo->groupid_info.go_device_addr[ 3 ],
+			pwdinfo->groupid_info.go_device_addr[ 4 ], pwdinfo->groupid_info.go_device_addr[ 5 ],
+			pwdinfo->groupid_info.ssid);
+	wrqu->data.length = strlen( extra );	
+	return ret;
+		
+}
+
+static int rtw_p2p_get_op_ch(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+
+	
+	DBG_871X( "[%s] Op_ch = %02x\n", __FUNCTION__, pwdinfo->operating_channel);
+	
+	sprintf( extra, "\n\nOp_ch=%.2d\n", pwdinfo->operating_channel );
+	wrqu->data.length = strlen( extra );
+	return ret;
+		
+}
+
+static int rtw_p2p_get_wps_configmethod(struct net_device *dev,
+										struct iw_request_info *info,
+										union iwreq_data *wrqu, char *extra, char *subcmd)
+{ 
+	
+	int ret = 0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u8 peerMAC[ETH_ALEN] = { 0x00 };
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_irqL irqL;
+	_list * plist,*phead;
+	_queue *queue = &(pmlmepriv->scanned_queue);
+	struct wlan_network *pnetwork = NULL;
+	u8 blnMatch = 0;
+	u16	attr_content = 0;
+	uint attr_contentlen = 0;
+	u8	attr_content_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
+
+	//	Commented by Albert 20110727
+	//	The input data is the MAC address which the application wants to know its WPS config method.
+	//	After knowing its WPS config method, the application can decide the config method for provisioning discovery.
+	//	Format: iwpriv wlanx p2p_get_wpsCM 00:E0:4C:00:00:05
+
+	DBG_871X("[%s] data = %s\n", __FUNCTION__, subcmd);
+
+	macstr2num(peerMAC, subcmd);
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	while (1)
+	{
+		if (rtw_end_of_queue_search(phead, plist) == _TRUE) break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
+		{
+			u8 *wpsie;
+			uint	wpsie_len = 0;
+
+			//	The mac address is matched.
+
+			if ( (wpsie=rtw_get_wps_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &wpsie_len, pnetwork->network.Reserved[0])) )
+			{
+				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_CONF_METHOD, (u8 *)&attr_content, &attr_contentlen);
+				if (attr_contentlen)
+				{
+					attr_content = be16_to_cpu(attr_content);
+					sprintf(attr_content_str, "\n\nM=%.4d", attr_content);
+					blnMatch = 1;
+				}
+			}
+
+			break;
+		}
+
+		plist = get_next(plist);
+
+	}
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	if (!blnMatch)
+	{
+		sprintf(attr_content_str, "\n\nM=0000");
+	}
+
+	wrqu->data.length = strlen(attr_content_str);
+	_rtw_memcpy(extra, attr_content_str, wrqu->data.length);
+
+	return ret; 
+		
+}
+
+#ifdef CONFIG_WFD
+static int rtw_p2p_get_peer_wfd_port(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+
+	DBG_871X( "[%s] p2p_state = %d\n", __FUNCTION__, rtw_p2p_state(pwdinfo) );
+
+	sprintf( extra, "\n\nPort=%d\n", pwdinfo->wfd_info->peer_rtsp_ctrlport );
+	DBG_871X( "[%s] remote port = %d\n", __FUNCTION__, pwdinfo->wfd_info->peer_rtsp_ctrlport );
+	
+	wrqu->data.length = strlen( extra );
+	return ret;
+		
+}
+
+static int rtw_p2p_get_peer_wfd_preferred_connection(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+
+	sprintf( extra, "\n\nwfd_pc=%d\n", pwdinfo->wfd_info->wfd_pc );
+	DBG_871X( "[%s] wfd_pc = %d\n", __FUNCTION__, pwdinfo->wfd_info->wfd_pc );
+
+	wrqu->data.length = strlen( extra );
+	pwdinfo->wfd_info->wfd_pc = _FALSE;	//	Reset the WFD preferred connection to P2P
+	return ret;
+		
+}
+
+static int rtw_p2p_get_peer_wfd_session_available(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+
+	sprintf( extra, "\n\nwfd_sa=%d\n", pwdinfo->wfd_info->peer_session_avail );
+	DBG_871X( "[%s] wfd_sa = %d\n", __FUNCTION__, pwdinfo->wfd_info->peer_session_avail );
+
+	wrqu->data.length = strlen( extra );
+	pwdinfo->wfd_info->peer_session_avail = _TRUE;	//	Reset the WFD session available
+	return ret;
+		
+}
+#endif /* CONFIG_WFD */
+
+static int rtw_p2p_get_go_device_address(struct net_device *dev,
+										 struct iw_request_info *info,
+										 union iwreq_data *wrqu, char *extra, char *subcmd)
+{
+
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u8 peerMAC[ETH_ALEN] = { 0x00 };
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_irqL irqL;
+	_list *plist, *phead;
+	_queue *queue	= &(pmlmepriv->scanned_queue);
+	struct wlan_network *pnetwork = NULL;
+	u8 blnMatch = 0;
+	u8 *p2pie;
+	uint p2pielen = 0, attr_contentlen = 0;
+	u8 attr_content[100] = { 0x00 };
+	u8 go_devadd_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
+
+	//	Commented by Albert 20121209
+	//	The input data is the GO's interface address which the application wants to know its device address.
+	//	Format: iwpriv wlanx p2p_get2 go_devadd=00:E0:4C:00:00:05
+
+	DBG_871X("[%s] data = %s\n", __FUNCTION__, subcmd);
+
+	macstr2num(peerMAC, subcmd);
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	while (1)
+	{
+		if (rtw_end_of_queue_search(phead, plist) == _TRUE) break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
+		{
+			//	Commented by Albert 2011/05/18
+			//	Match the device address located in the P2P IE
+			//	This is for the case that the P2P device address is not the same as the P2P interface address.
+
+			p2pie = rtw_bss_ex_get_p2p_ie(&pnetwork->network, NULL, &p2pielen);
+			if (p2pie) {
+				while (p2pie)
+				{
+					//	The P2P Device ID attribute is included in the Beacon frame.
+					//	The P2P Device Info attribute is included in the probe response frame.
+
+					_rtw_memset(attr_content, 0x00, 100);
+					if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
+					{
+						//	Handle the P2P Device ID attribute of Beacon first
+						blnMatch = 1;
+						break;
+
+					} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
+					{
+						//	Handle the P2P Device Info attribute of probe response
+						blnMatch = 1;
+						break;
+					}
+
+					//Get the next P2P IE
+					p2pie = rtw_get_p2p_ie(p2pie + p2pielen, BSS_EX_TLV_IES_LEN(&pnetwork->network) - (p2pie + p2pielen - BSS_EX_TLV_IES(&pnetwork->network)), NULL, &p2pielen);
+				}
+			}
+		}
+
+		plist = get_next(plist);
+
+	}
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	if (!blnMatch)
+	{
+		sprintf(go_devadd_str, "\n\ndev_add=NULL");
+	} else
+	{
+		sprintf(go_devadd_str, "\n\ndev_add=%.2X:%.2X:%.2X:%.2X:%.2X:%.2X",
+				attr_content[0], attr_content[1], attr_content[2], attr_content[3], attr_content[4], attr_content[5]);
+	}
+
+	wrqu->data.length = strlen(go_devadd_str);
+	_rtw_memcpy(extra, go_devadd_str, wrqu->data.length);
+
+	return ret; 
+		
+}
+
+static int rtw_p2p_get_device_type(struct net_device *dev,
+								   struct iw_request_info *info,
+								   union iwreq_data *wrqu, char *extra, char *subcmd)
+{ 
+	
+	int ret = 0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u8 peerMAC[ETH_ALEN] = { 0x00 };
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_irqL irqL;
+	_list *plist, *phead;
+	_queue *queue = &(pmlmepriv->scanned_queue);
+	struct wlan_network *pnetwork = NULL;
+	u8 blnMatch = 0;
+	u8 dev_type[8] = { 0x00 };
+	uint dev_type_len = 0;
+	u8 dev_type_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };    // +9 is for the str "dev_type=", we have to clear it at wrqu->data.pointer
+
+	//	Commented by Albert 20121209
+	//	The input data is the MAC address which the application wants to know its device type.
+	//	Such user interface could know the device type.
+	//	Format: iwpriv wlanx p2p_get2 dev_type=00:E0:4C:00:00:05
+
+	DBG_871X("[%s] data = %s\n", __FUNCTION__, subcmd);
+
+	macstr2num(peerMAC, subcmd);
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	while (1)
+	{
+		if (rtw_end_of_queue_search(phead, plist) == _TRUE) break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
+		{
+			u8 *wpsie;
+			uint	wpsie_len = 0;
+
+			//	The mac address is matched.
+
+			if ( (wpsie=rtw_get_wps_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &wpsie_len, pnetwork->network.Reserved[0])) )
+			{
+				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_PRIMARY_DEV_TYPE, dev_type, &dev_type_len);
+				if (dev_type_len)
+				{
+					u16	type = 0;
+
+					_rtw_memcpy(&type, dev_type, 2);
+					type = be16_to_cpu(type);
+					sprintf(dev_type_str, "\n\nN=%.2d", type);
+					blnMatch = 1;
+				}
+			}
+			break;
+		}
+
+		plist = get_next(plist);
+
+	}
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	if (!blnMatch)
+	{
+		sprintf(dev_type_str, "\n\nN=00");
+	}
+
+	wrqu->data.length = strlen(dev_type_str);
+	_rtw_memcpy(extra, dev_type_str, wrqu->data.length);
+
+	return ret; 
+		
+}
+
+static int rtw_p2p_get_device_name(struct net_device *dev,
+								   struct iw_request_info *info,
+								   union iwreq_data *wrqu, char *extra, char *subcmd)
+{ 
+	
+	int ret = 0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u8 peerMAC[ETH_ALEN] = { 0x00 };
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_irqL irqL;
+	_list *plist, *phead;
+	_queue *queue = &(pmlmepriv->scanned_queue);
+	struct wlan_network *pnetwork = NULL;
+	u8 blnMatch = 0;
+	u8 dev_name[WPS_MAX_DEVICE_NAME_LEN] = { 0x00 };
+	uint dev_len = 0;
+	u8 dev_name_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
+
+	//	Commented by Albert 20121225
+	//	The input data is the MAC address which the application wants to know its device name.
+	//	Such user interface could show peer device's device name instead of ssid.
+	//	Format: iwpriv wlanx p2p_get2 devN=00:E0:4C:00:00:05
+
+	DBG_871X("[%s] data = %s\n", __FUNCTION__, subcmd);
+
+	macstr2num(peerMAC, subcmd);
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	while (1)
+	{
+		if (rtw_end_of_queue_search(phead, plist) == _TRUE) break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
+		{
+			u8 *wpsie;
+			uint	wpsie_len = 0;
+
+			//	The mac address is matched.
+
+			if ( (wpsie=rtw_get_wps_ie_from_scan_queue( &pnetwork->network.IEs[0], pnetwork->network.IELength, NULL, &wpsie_len, pnetwork->network.Reserved[0])) )
+			{
+				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_DEVICE_NAME, dev_name, &dev_len);
+				if (dev_len)
+				{
+					sprintf(dev_name_str, "\n\nN=%s", dev_name);
+					blnMatch = 1;
+				}
+			}
+			break;
+		}
+
+		plist = get_next(plist);
+
+	}
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	if (!blnMatch)
+	{
+		sprintf(dev_name_str, "\n\nN=0000");
+	}
+
+	wrqu->data.length = strlen(dev_name_str);
+	_rtw_memcpy(extra, dev_name_str, wrqu->data.length);
+
+	return ret; 
+		
+}
+
+static int rtw_p2p_get_invitation_procedure(struct net_device *dev,
+											struct iw_request_info *info,
+											union iwreq_data *wrqu, char *extra, char *subcmd)
+{
+
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u8 peerMAC[ETH_ALEN] = { 0x00 };
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_irqL irqL;
+	_list *plist, *phead;
+	_queue *queue	= &(pmlmepriv->scanned_queue);
+	struct wlan_network *pnetwork = NULL;
+	u8 blnMatch = 0;
+	u8 *p2pie;
+	uint p2pielen = 0, attr_contentlen = 0;
+	u8 attr_content[2] = { 0x00 };
+	u8 inv_proc_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
+
+	//	Commented by Ouden 20121226
+	//	The application wants to know P2P initation procedure is support or not.
+	//	Format: iwpriv wlanx p2p_get2 InvProc=00:E0:4C:00:00:05
+
+	DBG_871X("[%s] data = %s\n", __FUNCTION__, subcmd);
+
+	macstr2num(peerMAC, subcmd);
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	while (1)
+	{
+		if (rtw_end_of_queue_search(phead, plist) == _TRUE) break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
+		{
+			//	Commented by Albert 20121226
+			//	Match the device address located in the P2P IE
+			//	This is for the case that the P2P device address is not the same as the P2P interface address.
+
+			p2pie = rtw_bss_ex_get_p2p_ie(&pnetwork->network, NULL, &p2pielen);
+			if (p2pie) {
+				while (p2pie)
+				{
+					//_rtw_memset( attr_content, 0x00, 2);
+					if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_CAPABILITY, attr_content, &attr_contentlen))
+					{
+						//	Handle the P2P capability attribute
+						blnMatch = 1;
+						break;
+
+					}
+
+					//Get the next P2P IE
+					p2pie = rtw_get_p2p_ie(p2pie + p2pielen, BSS_EX_TLV_IES_LEN(&pnetwork->network) - (p2pie + p2pielen - BSS_EX_TLV_IES(&pnetwork->network)), NULL, &p2pielen);
+				}
+			}
+		}
+
+		plist = get_next(plist);
+
+	}
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	if (!blnMatch)
+	{
+		sprintf(inv_proc_str, "\nIP=-1");
+	} else
+	{
+		if ((attr_content[0] & 0x20) == 0x20)
+			sprintf(inv_proc_str, "\nIP=1");
+		else
+			sprintf(inv_proc_str, "\nIP=0");
+	}
+
+	wrqu->data.length = strlen(inv_proc_str);
+	_rtw_memcpy(extra, inv_proc_str, wrqu->data.length);
+
+	return ret; 
+		
+}
+
+static int rtw_p2p_connect(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter 				*padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+	u8					peerMAC[ ETH_ALEN ] = { 0x00 };
+	int 					jj,kk;
+	u8   					peerMACStr[ ETH_ALEN * 2 ] = { 0x00 };
+	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
+	_irqL				irqL;
+	_list					*plist, *phead;
+	_queue				*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	uint					uintPeerChannel = 0;
+#ifdef CONFIG_CONCURRENT_MODE
+	_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
+	struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
+	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+#endif // CONFIG_CONCURRENT_MODE	
+
+	//	Commented by Albert 20110304
+	//	The input data contains two informations.
+	//	1. First information is the MAC address which wants to formate with
+	//	2. Second information is the WPS PINCode or "pbc" string for push button method
+	//	Format: 00:E0:4C:00:00:05
+	//	Format: 00:E0:4C:00:00:05
+
+	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
+
+	if ( pwdinfo->p2p_state == P2P_STATE_NONE )
+	{
+		DBG_871X( "[%s] WiFi Direct is disable!\n", __FUNCTION__ );
+		return ret;
+	}
+
+#ifdef CONFIG_INTEL_WIDI
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
+		DBG_871X( "[%s] WiFi is under survey!\n", __FUNCTION__ );
+		return ret;
+	}
+#endif //CONFIG_INTEL_WIDI	
+
+	if ( pwdinfo->ui_got_wps_info == P2P_NO_WPSINFO )
+	{
+		return -1;
+	}
+	
+	for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
+	{
+		peerMAC[ jj ] = key_2char2num( extra[kk], extra[kk+ 1] );
+	}
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+       
+	while(1)
+	{
+		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		if ( _rtw_memcmp( pnetwork->network.MacAddress, peerMAC, ETH_ALEN ) )
+		{
+			if (pnetwork->network.Configuration.DSConfig != 0)
+				uintPeerChannel = pnetwork->network.Configuration.DSConfig;
+			else if (pwdinfo->nego_req_info.peer_ch != 0)
+				uintPeerChannel = pnetwork->network.Configuration.DSConfig = pwdinfo->nego_req_info.peer_ch;
+			else{
+				/* Unexpected case */
+				uintPeerChannel = 0;
+				DBG_871X("%s  uintPeerChannel = 0\n", __func__);
+			}
+			break;
+		}
+
+		plist = get_next(plist);
+	
+	}
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	if ( uintPeerChannel )
+	{
+#ifdef CONFIG_CONCURRENT_MODE
+		if ( check_fwstate( pbuddy_mlmepriv, _FW_LINKED ) )
+		{
+			_cancel_timer_ex( &pwdinfo->ap_p2p_switch_timer );
+		}
+#endif // CONFIG_CONCURRENT_MODE
+
+		_rtw_memset( &pwdinfo->nego_req_info, 0x00, sizeof( struct tx_nego_req_info ) );
+		_rtw_memset( &pwdinfo->groupid_info, 0x00, sizeof( struct group_id_info ) );
+		
+		pwdinfo->nego_req_info.peer_channel_num[ 0 ] = uintPeerChannel;
+		_rtw_memcpy( pwdinfo->nego_req_info.peerDevAddr, pnetwork->network.MacAddress, ETH_ALEN );
+		pwdinfo->nego_req_info.benable = _TRUE;
+
+		_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
+		if ( rtw_p2p_state(pwdinfo) != P2P_STATE_GONEGO_OK )
+		{
+			//	Restore to the listen state if the current p2p state is not nego OK
+			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN );
+		}
+
+		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
+		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);
+
+#ifdef CONFIG_CONCURRENT_MODE
+		if ( check_fwstate( pbuddy_mlmepriv, _FW_LINKED ) )
+		{
+			//	Have to enter the power saving with the AP
+			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
+			
+			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
+		}
+#endif // CONFIG_CONCURRENT_MODE
+
+		DBG_871X( "[%s] Start PreTx Procedure!\n", __FUNCTION__ );
+		_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
+#ifdef CONFIG_CONCURRENT_MODE
+		if ( check_fwstate( pbuddy_mlmepriv, _FW_LINKED ) )
+		{
+			_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_GO_NEGO_TIMEOUT );
+		}
+		else
+		{
+			_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_GO_NEGO_TIMEOUT );
+		}
+#else
+		_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_GO_NEGO_TIMEOUT );
+#endif // CONFIG_CONCURRENT_MODE		
+
+	}
+	else
+	{
+		DBG_871X( "[%s] Not Found in Scanning Queue~\n", __FUNCTION__ );
+#ifdef CONFIG_INTEL_WIDI
+		_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
+		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
+		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
+		rtw_free_network_queue(padapter, _TRUE);
+		/** 
+		 * For WiDi, if we can't find candidate device in scanning queue,
+		 * driver will do scanning itself
+		 */
+		_enter_critical_bh(&pmlmepriv->lock, &irqL);
+		rtw_sitesurvey_cmd(padapter, NULL, 0, NULL, 0);
+		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+#endif //CONFIG_INTEL_WIDI 
+		ret = -1;
+	}
+exit:	
+	return ret;
+}
+
+static int rtw_p2p_invite_req(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point 			*pdata = &wrqu->data;
+	struct wifidirect_info		*pwdinfo = &( padapter->wdinfo );
+	int 						jj,kk;
+	u8   						peerMACStr[ ETH_ALEN * 2 ] = { 0x00 };
+	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
+	_list						*plist, *phead;
+	_queue					*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network		*pnetwork = NULL;
+	uint						uintPeerChannel = 0;
+	u8						attr_content[50] = { 0x00 }, _status = 0;
+	u8 						*p2pie;
+	uint						p2pielen = 0, attr_contentlen = 0;
+	_irqL					irqL;
+	struct tx_invite_req_info*	pinvite_req_info = &pwdinfo->invitereq_info;
+#ifdef CONFIG_CONCURRENT_MODE
+	_adapter					*pbuddy_adapter = padapter->pbuddy_adapter;
+	struct mlme_priv			*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
+	struct mlme_ext_priv		*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+#endif // CONFIG_CONCURRENT_MODE
+	
+	//	Commented by Albert 20120321
+	//	The input data contains two informations.
+	//	1. First information is the P2P device address which you want to send to.	
+	//	2. Second information is the group id which combines with GO's mac address, space and GO's ssid.
+	//	Command line sample: iwpriv wlan0 p2p_set invite="00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy"
+	//	Format: 00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy
+
+	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
+
+	if ( wrqu->data.length <=  37 )
+	{
+		DBG_871X( "[%s] Wrong format!\n", __FUNCTION__ );
+		return ret;
+	}
+
+	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	{
+		DBG_871X( "[%s] WiFi Direct is disable!\n", __FUNCTION__ );
+		return ret;
+	}
+	else
+	{
+		//	Reset the content of struct tx_invite_req_info
+		pinvite_req_info->benable = _FALSE;
+		_rtw_memset( pinvite_req_info->go_bssid, 0x00, ETH_ALEN );
+		_rtw_memset( pinvite_req_info->go_ssid, 0x00, WLAN_SSID_MAXLEN );
+		pinvite_req_info->ssidlen = 0x00;
+		pinvite_req_info->operating_ch = pwdinfo->operating_channel;
+		_rtw_memset( pinvite_req_info->peer_macaddr, 0x00, ETH_ALEN );
+		pinvite_req_info->token = 3;
+	}
+	
+	for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
+	{
+		pinvite_req_info->peer_macaddr[ jj ] = key_2char2num( extra[kk], extra[kk+ 1] );
+	}
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+       
+	while(1)
+	{
+		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		//	Commented by Albert 2011/05/18
+		//	Match the device address located in the P2P IE
+		//	This is for the case that the P2P device address is not the same as the P2P interface address.
+
+		p2pie = rtw_bss_ex_get_p2p_ie(&pnetwork->network, NULL, &p2pielen);
+		if (p2pie) {
+			//	The P2P Device ID attribute is included in the Beacon frame.
+			//	The P2P Device Info attribute is included in the probe response frame.
+
+			if ( rtw_get_p2p_attr_content( p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen) )
+			{
+				//	Handle the P2P Device ID attribute of Beacon first
+				if ( _rtw_memcmp( attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN ) )
+				{
+					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
+					break;
+				}
+			}
+			else if ( rtw_get_p2p_attr_content( p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen) )
+			{
+				//	Handle the P2P Device Info attribute of probe response
+				if ( _rtw_memcmp( attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN ) )
+				{
+					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
+					break;
+				}					
+			}
+
+		}
+
+		plist = get_next(plist);
+	
+	}
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+#ifdef CONFIG_WFD
+	if (hal_chk_wl_func(padapter, WL_FUNC_MIRACAST) && uintPeerChannel) {
+		struct wifi_display_info *pwfd_info = pwdinfo->wfd_info;
+		u8 *wfd_ie;
+		uint wfd_ielen = 0;
+
+		wfd_ie = rtw_bss_ex_get_wfd_ie(&pnetwork->network, NULL, &wfd_ielen);
+		if (wfd_ie) {
+			u8 *wfd_devinfo;
+			uint wfd_devlen;
+
+			DBG_871X( "[%s] Found WFD IE!\n", __FUNCTION__ );
+			wfd_devinfo = rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, NULL, &wfd_devlen);
+			if (wfd_devinfo) {
+				u16	wfd_devinfo_field = 0;
+				
+				//	Commented by Albert 20120319
+				//	The first two bytes are the WFD device information field of WFD device information subelement.
+				//	In big endian format.
+				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
+				if ( wfd_devinfo_field & WFD_DEVINFO_SESSION_AVAIL )
+				{
+					pwfd_info->peer_session_avail = _TRUE;
+				}
+				else
+				{
+					pwfd_info->peer_session_avail = _FALSE;
+				}
+			}
+		}
+		
+		if ( _FALSE == pwfd_info->peer_session_avail )
+		{
+			DBG_871X( "[%s] WFD Session not avaiable!\n", __FUNCTION__ );
+			goto exit;
+		}
+	}
+#endif /* CONFIG_WFD */
+
+	if ( uintPeerChannel )
+	{
+#ifdef CONFIG_CONCURRENT_MODE
+		if ( check_fwstate( pbuddy_mlmepriv, _FW_LINKED ) )
+		{
+			_cancel_timer_ex( &pwdinfo->ap_p2p_switch_timer );
+		}
+#endif // CONFIG_CONCURRENT_MODE
+
+		//	Store the GO's bssid
+		for( jj = 0, kk = 18; jj < ETH_ALEN; jj++, kk += 3 )
+		{
+			pinvite_req_info->go_bssid[ jj ] = key_2char2num( extra[kk], extra[kk+ 1] );
+		}
+
+		//	Store the GO's ssid
+		pinvite_req_info->ssidlen = wrqu->data.length - 36;
+		_rtw_memcpy( pinvite_req_info->go_ssid, &extra[ 36 ], (u32) pinvite_req_info->ssidlen );
+		pinvite_req_info->benable = _TRUE;
+		pinvite_req_info->peer_ch = uintPeerChannel;
+
+		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
+		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_INVITE_REQ);
+
+#ifdef CONFIG_CONCURRENT_MODE
+		if ( check_fwstate( pbuddy_mlmepriv, _FW_LINKED ) )
+		{
+			//	Have to enter the power saving with the AP
+			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
+			
+			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
+		}
+		else
+		{
+			set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+		}
+#else
+		set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+#endif
+
+		_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
+		
+#ifdef CONFIG_CONCURRENT_MODE
+		if ( check_fwstate( pbuddy_mlmepriv, _FW_LINKED ) )
+		{
+			_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_INVITE_TIMEOUT );
+		}
+		else
+		{
+			_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT );
+		}
+#else
+		_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT );
+#endif // CONFIG_CONCURRENT_MODE		
+
+		
+	}
+	else
+	{
+		DBG_871X( "[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__ );
+	}
+exit:
+	
+	return ret;
+		
+}
+
+static int rtw_p2p_set_persistent(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point 			*pdata = &wrqu->data;
+	struct wifidirect_info		*pwdinfo = &( padapter->wdinfo );
+	int 						jj,kk;
+	u8   						peerMACStr[ ETH_ALEN * 2 ] = { 0x00 };
+	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
+	_list						*plist, *phead;
+	_queue					*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network		*pnetwork = NULL;
+	uint						uintPeerChannel = 0;
+	u8						attr_content[50] = { 0x00 }, _status = 0;
+	u8 						*p2pie;
+	uint						p2pielen = 0, attr_contentlen = 0;
+	_irqL					irqL;
+	struct tx_invite_req_info*	pinvite_req_info = &pwdinfo->invitereq_info;
+#ifdef CONFIG_CONCURRENT_MODE
+	_adapter					*pbuddy_adapter = padapter->pbuddy_adapter;
+	struct mlme_priv			*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
+	struct mlme_ext_priv		*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+#endif // CONFIG_CONCURRENT_MODE
+	
+	//	Commented by Albert 20120328
+	//	The input data is 0 or 1
+	//	0: disable persistent group functionality
+	//	1: enable persistent group founctionality
+	
+	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
+
+	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	{
+		DBG_871X( "[%s] WiFi Direct is disable!\n", __FUNCTION__ );
+		return ret;
+	}
+	else
+	{
+		if ( extra[ 0 ] == '0' )	//	Disable the persistent group function.
+		{
+			pwdinfo->persistent_supported = _FALSE;
+		}
+		else if ( extra[ 0 ] == '1' )	//	Enable the persistent group function.
+		{
+			pwdinfo->persistent_supported = _TRUE;
+		}
+		else
+		{
+			pwdinfo->persistent_supported = _FALSE;
+		}
+	}
+	printk( "[%s] persistent_supported = %d\n", __FUNCTION__, pwdinfo->persistent_supported );
+	
+exit:
+	
+	return ret;
+		
+}
+
+static int hexstr2bin(const char *hex, u8 *buf, size_t len)
+{
+	size_t i;
+	int a;
+	const char *ipos = hex;
+	u8 *opos = buf;
+
+	for (i = 0; i < len; i++) {
+		a = hex2byte_i(ipos);
+		if (a < 0)
+			return -1;
+		*opos++ = a;
+		ipos += 2;
+	}
+	return 0;
+}
+
+static int uuid_str2bin(const char *str, u8 *bin)
+{
+	const char *pos;
+	u8 *opos;
+
+	pos = str;
+	opos = bin;
+
+	if (hexstr2bin(pos, opos, 4))
+		return -1;
+	pos += 8;
+	opos += 4;
+
+	if (*pos++ != '-' || hexstr2bin(pos, opos, 2))
+		return -1;
+	pos += 4;
+	opos += 2;
+
+	if (*pos++ != '-' || hexstr2bin(pos, opos, 2))
+		return -1;
+	pos += 4;
+	opos += 2;
+
+	if (*pos++ != '-' || hexstr2bin(pos, opos, 2))
+		return -1;
+	pos += 4;
+	opos += 2;
+
+	if (*pos++ != '-' || hexstr2bin(pos, opos, 6))
+		return -1;
+
+	return 0;
+}
+
+static int rtw_p2p_set_wps_uuid(struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu, char *extra)
+{
+
+	int ret = 0;
+	_adapter				*padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct wifidirect_info			*pwdinfo = &(padapter->wdinfo);
+
+	DBG_871X("[%s] data = %s\n", __FUNCTION__, extra);
+
+	if ((36 == strlen(extra)) && (uuid_str2bin(extra, pwdinfo->uuid) == 0)) 
+	{
+		pwdinfo->external_uuid = 1;
+	} else {
+		pwdinfo->external_uuid = 0;
+		ret = -EINVAL;
+	}
+
+	return ret;
+
+}
+#ifdef CONFIG_WFD
+static int rtw_p2p_set_pc(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter 				*padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point 		*pdata = &wrqu->data;
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+	u8					peerMAC[ ETH_ALEN ] = { 0x00 };
+	int 					jj,kk;
+	u8   					peerMACStr[ ETH_ALEN * 2 ] = { 0x00 };
+	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
+	_list					*plist, *phead;
+	_queue				*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	u8					attr_content[50] = { 0x00 }, _status = 0;
+	u8 *p2pie;
+	uint					p2pielen = 0, attr_contentlen = 0;
+	_irqL				irqL;
+	uint					uintPeerChannel = 0;
+#ifdef CONFIG_CONCURRENT_MODE
+	_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
+	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+#endif // CONFIG_CONCURRENT_MODE	
+	
+	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
+	
+	//	Commented by Albert 20120512
+	//	1. Input information is the MAC address which wants to know the Preferred Connection bit (PC bit)
+	//	Format: 00:E0:4C:00:00:05
+
+	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
+
+	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	{
+		DBG_871X( "[%s] WiFi Direct is disable!\n", __FUNCTION__ );
+		return ret;
+	}
+	
+	for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
+	{
+		peerMAC[ jj ] = key_2char2num( extra[kk], extra[kk+ 1] );
+	}
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+       
+	while(1)
+	{
+		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		//	Commented by Albert 2011/05/18
+		//	Match the device address located in the P2P IE
+		//	This is for the case that the P2P device address is not the same as the P2P interface address.
+
+		p2pie = rtw_bss_ex_get_p2p_ie(&pnetwork->network, NULL, &p2pielen);
+		if (p2pie) {
+			//	The P2P Device ID attribute is included in the Beacon frame.
+			//	The P2P Device Info attribute is included in the probe response frame.
+			printk( "[%s] Got P2P IE\n", __FUNCTION__ );
+			if ( rtw_get_p2p_attr_content( p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen) )
+			{
+				//	Handle the P2P Device ID attribute of Beacon first
+				printk( "[%s] P2P_ATTR_DEVICE_ID \n", __FUNCTION__ );
+				if ( _rtw_memcmp( attr_content, peerMAC, ETH_ALEN ) )
+				{
+					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
+					break;
+				}
+			}
+			else if ( rtw_get_p2p_attr_content( p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen) )
+			{
+				//	Handle the P2P Device Info attribute of probe response
+				printk( "[%s] P2P_ATTR_DEVICE_INFO \n", __FUNCTION__ );
+				if ( _rtw_memcmp( attr_content, peerMAC, ETH_ALEN ) )
+				{
+					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
+					break;
+				}					
+			}
+
+		}
+
+		plist = get_next(plist);
+	
+	}
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	printk( "[%s] channel = %d\n", __FUNCTION__, uintPeerChannel );
+
+	if ( uintPeerChannel )
+	{
+		u8 *wfd_ie;
+		uint wfd_ielen = 0;
+
+		wfd_ie = rtw_bss_ex_get_wfd_ie(&pnetwork->network, NULL, &wfd_ielen);
+		if (wfd_ie) {
+			u8 *wfd_devinfo;
+			uint wfd_devlen;
+
+			DBG_871X( "[%s] Found WFD IE!\n", __FUNCTION__ );
+			wfd_devinfo = rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, NULL, &wfd_devlen);
+			if (wfd_devinfo) {
+				u16	wfd_devinfo_field = 0;
+				
+				//	Commented by Albert 20120319
+				//	The first two bytes are the WFD device information field of WFD device information subelement.
+				//	In big endian format.
+				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
+				if ( wfd_devinfo_field & WFD_DEVINFO_PC_TDLS )
+				{
+					pwfd_info->wfd_pc = _TRUE;
+				}
+				else
+				{
+					pwfd_info->wfd_pc = _FALSE;
+				}
+			}
+		}
+	}	
+	else
+	{
+		DBG_871X( "[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__ );
+	}
+
+exit:
+	
+	return ret;
+		
+}
+
+static int rtw_p2p_set_wfd_device_type(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point 			*pdata = &wrqu->data;
+	struct wifidirect_info		*pwdinfo = &( padapter->wdinfo );
+	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
+	
+	//	Commented by Albert 20120328
+	//	The input data is 0 or 1
+	//	0: specify to Miracast source device
+	//	1 or others: specify to Miracast sink device (display device)
+	
+	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
+
+	if ( extra[ 0 ] == '0' )	//	Set to Miracast source device.
+	{
+		pwfd_info->wfd_device_type = WFD_DEVINFO_SOURCE;
+	}
+	else					//	Set to Miracast sink device.
+	{
+		pwfd_info->wfd_device_type = WFD_DEVINFO_PSINK;
+	}
+
+exit:
+	
+	return ret;
+		
+}
+
+static int rtw_p2p_set_wfd_enable(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+//	Commented by Kurt 20121206
+//	This function is used to set wfd enabled
+
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+
+	if (*extra == '0')
+		rtw_wfd_enable(padapter, 0);
+	else if (*extra == '1')
+		rtw_wfd_enable(padapter, 1);
+
+	DBG_871X( "[%s] wfd_enable = %d\n", __FUNCTION__, pwdinfo->wfd_info->wfd_enable );
+	
+	return ret;
+		
+}
+
+static int rtw_p2p_set_driver_iface(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+//	Commented by Kurt 20121206
+//	This function is used to set driver iface is WEXT or CFG80211
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+
+	if(*extra == '1' )
+	{
+		pwdinfo->driver_interface = DRIVER_WEXT;
+		DBG_871X( "[%s] driver_interface = WEXT\n", __FUNCTION__);
+	}
+	else if(*extra == '2')
+	{
+		pwdinfo->driver_interface = DRIVER_CFG80211;
+		DBG_871X( "[%s] driver_interface = CFG80211\n", __FUNCTION__);
+	}
+	
+	return ret;
+		
+}
+
+//	To set the WFD session available to enable or disable
+static int rtw_p2p_set_sa(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct iw_point 			*pdata = &wrqu->data;
+	struct wifidirect_info		*pwdinfo = &( padapter->wdinfo );
+	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
+	
+	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
+
+	if( 0 )
+	{
+		DBG_871X( "[%s] WiFi Direct is disable!\n", __FUNCTION__ );
+		return ret;
+	}
+	else
+	{
+		if ( extra[ 0 ] == '0' )	//	Disable the session available.
+		{
+			pwdinfo->session_available = _FALSE;
+		}
+		else if ( extra[ 0 ] == '1' )	//	Enable the session available.
+		{
+			pwdinfo->session_available = _TRUE;
+		}
+		else
+		{
+			pwdinfo->session_available = _FALSE;
+		}
+	}
+	printk( "[%s] session available = %d\n", __FUNCTION__, pwdinfo->session_available );
+	
+exit:
+	
+	return ret;
+		
+}
+#endif /* CONFIG_WFD */
+
+static int rtw_p2p_prov_disc(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;	
+	_adapter 				*padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+	u8					peerMAC[ ETH_ALEN ] = { 0x00 };
+	int 					jj,kk;
+	u8   					peerMACStr[ ETH_ALEN * 2 ] = { 0x00 };
+	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
+	_list					*plist, *phead;
+	_queue				*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	uint					uintPeerChannel = 0;
+	u8					attr_content[100] = { 0x00 }, _status = 0;
+	u8 *p2pie;
+	uint					p2pielen = 0, attr_contentlen = 0;
+	_irqL				irqL;
+#ifdef CONFIG_CONCURRENT_MODE
+	_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
+	struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
+	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+#endif // CONFIG_CONCURRENT_MODE	
+
+	//	Commented by Albert 20110301
+	//	The input data contains two informations.
+	//	1. First information is the MAC address which wants to issue the provisioning discovery request frame.
+	//	2. Second information is the WPS configuration method which wants to discovery
+	//	Format: 00:E0:4C:00:00:05_display
+	//	Format: 00:E0:4C:00:00:05_keypad
+	//	Format: 00:E0:4C:00:00:05_pbc
+	//	Format: 00:E0:4C:00:00:05_label
+
+	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
+
+	if ( pwdinfo->p2p_state == P2P_STATE_NONE )
+	{
+		DBG_871X( "[%s] WiFi Direct is disable!\n", __FUNCTION__ );
+		return ret;
+	}
+	else
+	{
+#ifdef CONFIG_INTEL_WIDI
+		if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
+			DBG_871X( "[%s] WiFi is under survey!\n", __FUNCTION__ );
+			return ret;
+		}
+#endif //CONFIG_INTEL_WIDI
+
+		//	Reset the content of struct tx_provdisc_req_info excluded the wps_config_method_request.
+		_rtw_memset( pwdinfo->tx_prov_disc_info.peerDevAddr, 0x00, ETH_ALEN );
+		_rtw_memset( pwdinfo->tx_prov_disc_info.peerIFAddr, 0x00, ETH_ALEN );
+		_rtw_memset( &pwdinfo->tx_prov_disc_info.ssid, 0x00, sizeof( NDIS_802_11_SSID ) );		
+		pwdinfo->tx_prov_disc_info.peer_channel_num[ 0 ] = 0;
+		pwdinfo->tx_prov_disc_info.peer_channel_num[ 1 ] = 0;
+		pwdinfo->tx_prov_disc_info.benable = _FALSE;
+	}
+	
+	for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
+	{
+		peerMAC[ jj ] = key_2char2num( extra[kk], extra[kk+ 1] );
+	}
+
+	if ( _rtw_memcmp( &extra[ 18 ], "display", 7 ) )
+	{
+		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_DISPLYA;
+	}
+	else if ( _rtw_memcmp( &extra[ 18 ], "keypad", 7 ) )
+	{
+		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_KEYPAD;
+	}
+	else if ( _rtw_memcmp( &extra[ 18 ], "pbc", 3 ) )
+	{
+		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_PUSH_BUTTON;
+	}
+	else if ( _rtw_memcmp( &extra[ 18 ], "label", 5 ) )
+	{
+		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_LABEL;
+	}
+	else
+	{
+		DBG_871X( "[%s] Unknown WPS config methodn", __FUNCTION__ );
+		return( ret );
+	}
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+       
+	while(1)
+	{
+		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+		if( uintPeerChannel != 0 )
+			break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		//	Commented by Albert 2011/05/18
+		//	Match the device address located in the P2P IE
+		//	This is for the case that the P2P device address is not the same as the P2P interface address.
+
+		p2pie = rtw_bss_ex_get_p2p_ie(&pnetwork->network, NULL, &p2pielen);
+		if (p2pie) {
+			while ( p2pie )
+			{
+				//	The P2P Device ID attribute is included in the Beacon frame.
+				//	The P2P Device Info attribute is included in the probe response frame.
+
+				if ( rtw_get_p2p_attr_content( p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen) )
+				{
+					//	Handle the P2P Device ID attribute of Beacon first
+					if ( _rtw_memcmp( attr_content, peerMAC, ETH_ALEN ) )
+					{
+						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
+						break;
+					}
+				}
+				else if ( rtw_get_p2p_attr_content( p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen) )
+				{
+					//	Handle the P2P Device Info attribute of probe response
+					if ( _rtw_memcmp( attr_content, peerMAC, ETH_ALEN ) )
+					{
+						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
+						break;
+					}					
+				}
+
+				//Get the next P2P IE
+				p2pie = rtw_get_p2p_ie(p2pie + p2pielen, BSS_EX_TLV_IES_LEN(&pnetwork->network) - (p2pie + p2pielen - BSS_EX_TLV_IES(&pnetwork->network)), NULL, &p2pielen);
+			}
+
+		}
+
+#ifdef CONFIG_INTEL_WIDI
+		// Some Intel WiDi source may not provide P2P IE, 
+		// so we could only compare mac addr by 802.11 Source Address
+		if( pmlmepriv->widi_state == INTEL_WIDI_STATE_WFD_CONNECTION 
+			&& uintPeerChannel == 0 )
+		{
+			if ( _rtw_memcmp( pnetwork->network.MacAddress, peerMAC, ETH_ALEN ) )
+			{
+				uintPeerChannel = pnetwork->network.Configuration.DSConfig;
+				break;
+			}
+		}
+#endif //CONFIG_INTEL_WIDI
+
+		plist = get_next(plist);
+	
+	}
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	if ( uintPeerChannel )
+	{
+		#ifdef CONFIG_WFD
+		if (hal_chk_wl_func(padapter, WL_FUNC_MIRACAST)) {
+			struct wifi_display_info *pwfd_info = pwdinfo->wfd_info;
+			u8 *wfd_ie;
+			uint wfd_ielen = 0;
+
+			wfd_ie = rtw_bss_ex_get_wfd_ie(&pnetwork->network, NULL, &wfd_ielen);
+			if (wfd_ie) {
+				u8 *wfd_devinfo;
+				uint wfd_devlen;
+
+				DBG_871X( "[%s] Found WFD IE!\n", __FUNCTION__ );
+				wfd_devinfo = rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, NULL, &wfd_devlen);
+				if (wfd_devinfo) {
+					u16	wfd_devinfo_field = 0;
+					
+					//	Commented by Albert 20120319
+					//	The first two bytes are the WFD device information field of WFD device information subelement.
+					//	In big endian format.
+					wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
+					if ( wfd_devinfo_field & WFD_DEVINFO_SESSION_AVAIL )
+					{
+						pwfd_info->peer_session_avail = _TRUE;
+					}
+					else
+					{
+						pwfd_info->peer_session_avail = _FALSE;
+					}
+				}
+			}
+			
+			if ( _FALSE == pwfd_info->peer_session_avail )
+			{
+				DBG_871X( "[%s] WFD Session not avaiable!\n", __FUNCTION__ );
+				goto exit;
+			}
+		}
+		#endif /* CONFIG_WFD */
+		
+		DBG_871X( "[%s] peer channel: %d!\n", __FUNCTION__, uintPeerChannel );
+#ifdef CONFIG_CONCURRENT_MODE
+		if ( check_fwstate( pbuddy_mlmepriv, _FW_LINKED ) )
+		{
+			_cancel_timer_ex( &pwdinfo->ap_p2p_switch_timer );
+		}
+#endif // CONFIG_CONCURRENT_MODE
+		_rtw_memcpy( pwdinfo->tx_prov_disc_info.peerIFAddr, pnetwork->network.MacAddress, ETH_ALEN );
+		_rtw_memcpy( pwdinfo->tx_prov_disc_info.peerDevAddr, peerMAC, ETH_ALEN );
+		pwdinfo->tx_prov_disc_info.peer_channel_num[0] = ( u16 ) uintPeerChannel;
+		pwdinfo->tx_prov_disc_info.benable = _TRUE;
+		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
+		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ);
+
+		if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
+		{
+			_rtw_memcpy( &pwdinfo->tx_prov_disc_info.ssid, &pnetwork->network.Ssid, sizeof( NDIS_802_11_SSID ) );
+		}
+		else if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+		{
+			_rtw_memcpy( pwdinfo->tx_prov_disc_info.ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN );
+			pwdinfo->tx_prov_disc_info.ssid.SsidLength= P2P_WILDCARD_SSID_LEN;
+		}
+
+#ifdef CONFIG_CONCURRENT_MODE
+		if ( check_fwstate( pbuddy_mlmepriv, _FW_LINKED ) )
+		{
+			//	Have to enter the power saving with the AP
+			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
+			
+			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
+		}
+		else
+		{
+			set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+		}
+#else
+		set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+#endif
+
+		_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
+		
+#ifdef CONFIG_CONCURRENT_MODE
+		if ( check_fwstate( pbuddy_mlmepriv, _FW_LINKED ) )
+		{
+			_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_PROVISION_TIMEOUT );
+		}
+		else
+		{
+			_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT );
+		}
+#else
+		_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT );
+#endif // CONFIG_CONCURRENT_MODE		
+		
+	}
+	else
+	{
+		DBG_871X( "[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__ );
+#ifdef CONFIG_INTEL_WIDI
+		_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
+		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
+		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
+		rtw_free_network_queue(padapter, _TRUE);		
+		_enter_critical_bh(&pmlmepriv->lock, &irqL);				
+		rtw_sitesurvey_cmd(padapter, NULL, 0, NULL, 0);
+		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+#endif //CONFIG_INTEL_WIDI
+	}
+exit:
+	
+	return ret;
+		
+}
+
+//	Added by Albert 20110328
+//	This function is used to inform the driver the user had specified the pin code value or pbc
+//	to application.
+
+static int rtw_p2p_got_wpsinfo(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter 				*padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+	
+
+	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
+	//	Added by Albert 20110328
+	//	if the input data is P2P_NO_WPSINFO -> reset the wpsinfo
+	//	if the input data is P2P_GOT_WPSINFO_PEER_DISPLAY_PIN -> the utility just input the PIN code got from the peer P2P device.
+	//	if the input data is P2P_GOT_WPSINFO_SELF_DISPLAY_PIN -> the utility just got the PIN code from itself.
+	//	if the input data is P2P_GOT_WPSINFO_PBC -> the utility just determine to use the PBC
+	
+	if ( *extra == '0' )
+	{
+		pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
+	}
+	else if ( *extra == '1' )
+	{
+		pwdinfo->ui_got_wps_info = P2P_GOT_WPSINFO_PEER_DISPLAY_PIN;
+	}
+	else if ( *extra == '2' )
+	{
+		pwdinfo->ui_got_wps_info = P2P_GOT_WPSINFO_SELF_DISPLAY_PIN;
+	}
+	else if ( *extra == '3' )
+	{
+		pwdinfo->ui_got_wps_info = P2P_GOT_WPSINFO_PBC;
+	}
+	else
+	{
+		pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
+	}
+	
+	return ret;
+		
+}
+
+#endif //CONFIG_P2P
+
+static int rtw_p2p_set(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;
+#ifdef CONFIG_P2P
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+
+	DBG_871X( "[%s] extra = %s\n", __FUNCTION__, extra );
+
+	if ( _rtw_memcmp( extra, "enable=", 7 ) )
+	{
+		rtw_wext_p2p_enable( dev, info, wrqu, &extra[7] );
+	}
+	else if ( _rtw_memcmp( extra, "setDN=", 6 ) )
+	{
+		wrqu->data.length -= 6;
+		rtw_p2p_setDN( dev, info, wrqu, &extra[6] );
+	}
+	else if ( _rtw_memcmp( extra, "profilefound=", 13 ) )
+	{
+		wrqu->data.length -= 13;
+		rtw_p2p_profilefound( dev, info, wrqu, &extra[13] );
+	}
+	else if ( _rtw_memcmp( extra, "prov_disc=", 10 ) )
+	{
+		wrqu->data.length -= 10;
+		rtw_p2p_prov_disc( dev, info, wrqu, &extra[10] );
+	}
+	else if ( _rtw_memcmp( extra, "nego=", 5 ) )
+	{
+		wrqu->data.length -= 5;
+		rtw_p2p_connect( dev, info, wrqu, &extra[5] );
+	}
+	else if ( _rtw_memcmp( extra, "intent=", 7 ) )
+	{
+		//	Commented by Albert 2011/03/23
+		//	The wrqu->data.length will include the null character
+		//	So, we will decrease 7 + 1
+		wrqu->data.length -= 8;
+		rtw_p2p_set_intent( dev, info, wrqu, &extra[7] );
+	}
+	else if ( _rtw_memcmp( extra, "ssid=", 5 ) )
+	{
+		wrqu->data.length -= 5;
+		rtw_p2p_set_go_nego_ssid( dev, info, wrqu, &extra[5] );
+	}
+	else if ( _rtw_memcmp( extra, "got_wpsinfo=", 12 ) )
+	{
+		wrqu->data.length -= 12;
+		rtw_p2p_got_wpsinfo( dev, info, wrqu, &extra[12] );
+	}
+	else if ( _rtw_memcmp( extra, "listen_ch=", 10 ) )
+	{
+		//	Commented by Albert 2011/05/24
+		//	The wrqu->data.length will include the null character
+		//	So, we will decrease (10 + 1)	
+		wrqu->data.length -= 11;
+		rtw_p2p_set_listen_ch( dev, info, wrqu, &extra[10] );
+	}
+	else if ( _rtw_memcmp( extra, "op_ch=", 6 ) )
+	{
+		//	Commented by Albert 2011/05/24
+		//	The wrqu->data.length will include the null character
+		//	So, we will decrease (6 + 1)	
+		wrqu->data.length -= 7;
+		rtw_p2p_set_op_ch( dev, info, wrqu, &extra[6] );
+	}
+	else if ( _rtw_memcmp( extra, "invite=", 7 ) )
+	{
+		wrqu->data.length -= 8;
+		rtw_p2p_invite_req( dev, info, wrqu, &extra[7] );
+	}
+	else if ( _rtw_memcmp( extra, "persistent=", 11 ) )
+	{
+		wrqu->data.length -= 11;
+		rtw_p2p_set_persistent( dev, info, wrqu, &extra[11] );
+	}
+	else if ( _rtw_memcmp ( extra, "uuid=", 5) )
+	{
+		wrqu->data.length -= 5;
+		ret = rtw_p2p_set_wps_uuid( dev, info, wrqu, &extra[5] );
+	}
+
+#ifdef CONFIG_WFD
+	if (hal_chk_wl_func(padapter, WL_FUNC_MIRACAST)) {
+		if (_rtw_memcmp(extra, "sa=", 3)) {
+			/* sa: WFD Session Available information */
+			wrqu->data.length -= 3;
+			rtw_p2p_set_sa(dev, info, wrqu, &extra[3]);
+		} else if (_rtw_memcmp(extra, "pc=", 3)) {
+			/* pc: WFD Preferred Connection */
+			wrqu->data.length -= 3;
+			rtw_p2p_set_pc(dev, info, wrqu, &extra[3]);
+		} else if (_rtw_memcmp(extra, "wfd_type=", 9)) {
+			wrqu->data.length -= 9;
+			rtw_p2p_set_wfd_device_type(dev, info, wrqu, &extra[9]);
+		} else if (_rtw_memcmp(extra, "wfd_enable=", 11)) {
+			wrqu->data.length -= 11;
+			rtw_p2p_set_wfd_enable(dev, info, wrqu, &extra[11]);
+		} else if (_rtw_memcmp(extra, "driver_iface=", 13)) {
+			wrqu->data.length -= 13;
+			rtw_p2p_set_driver_iface(dev, info, wrqu, &extra[13]);
+		}
+	}
+#endif /* CONFIG_WFD */
+
+#endif //CONFIG_P2P
+
+	return ret;
+		
+}
+
+static int rtw_p2p_get(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	
+#ifdef CONFIG_P2P
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
+	struct iw_point *pdata = &wrqu->data;
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+
+	if ( padapter->bShowGetP2PState )
+	{
+		DBG_871X( "[%s] extra = %s\n", __FUNCTION__, (char*) wrqu->data.pointer );
+	}
+
+	if ( _rtw_memcmp( wrqu->data.pointer, "status", 6 ) )
+	{
+		rtw_p2p_get_status( dev, info, wrqu, extra );
+	}
+	else if ( _rtw_memcmp( wrqu->data.pointer, "role", 4 ) )
+	{
+		rtw_p2p_get_role( dev, info, wrqu, extra);
+	}
+	else if ( _rtw_memcmp( wrqu->data.pointer, "peer_ifa", 8 ) )
+	{
+		rtw_p2p_get_peer_ifaddr( dev, info, wrqu, extra);
+	}
+	else if ( _rtw_memcmp( wrqu->data.pointer, "req_cm", 6 ) )
+	{
+		rtw_p2p_get_req_cm( dev, info, wrqu, extra);
+	}
+	else if ( _rtw_memcmp( wrqu->data.pointer, "peer_deva", 9 ) )
+	{
+		//	Get the P2P device address when receiving the provision discovery request frame.
+		rtw_p2p_get_peer_devaddr( dev, info, wrqu, extra);
+	}
+	else if ( _rtw_memcmp( wrqu->data.pointer, "group_id", 8 ) )
+	{
+		rtw_p2p_get_groupid( dev, info, wrqu, extra);
+	}
+	else if ( _rtw_memcmp( wrqu->data.pointer, "inv_peer_deva", 13 ) )
+	{
+		//	Get the P2P device address when receiving the P2P Invitation request frame.
+		rtw_p2p_get_peer_devaddr_by_invitation( dev, info, wrqu, extra);
+	}
+	else if ( _rtw_memcmp( wrqu->data.pointer, "op_ch", 5 ) )
+	{
+		rtw_p2p_get_op_ch( dev, info, wrqu, extra);
+	}
+
+#ifdef CONFIG_WFD
+	if (hal_chk_wl_func(padapter, WL_FUNC_MIRACAST)) {
+		if (_rtw_memcmp(wrqu->data.pointer, "peer_port", 9))
+			rtw_p2p_get_peer_wfd_port(dev, info, wrqu, extra);
+		else if (_rtw_memcmp(wrqu->data.pointer, "wfd_sa", 6))
+			rtw_p2p_get_peer_wfd_session_available(dev, info, wrqu, extra);
+		else if (_rtw_memcmp(wrqu->data.pointer, "wfd_pc", 6))
+			rtw_p2p_get_peer_wfd_preferred_connection(dev, info, wrqu, extra);
+	}
+#endif /* CONFIG_WFD */
+	
+#endif //CONFIG_P2P
+
+	return ret;
+		
+}
+
+static int rtw_p2p_get2(struct net_device *dev,
+						struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
+{
+
+	int ret = 0;
+
+#ifdef CONFIG_P2P
+
+	int length = wrqu->data.length;
+	char *buffer = (u8 *)rtw_malloc(length);
+
+	if (buffer == NULL)
+	{
+		ret = -ENOMEM;
+		goto bad;
+	}
+
+	if (copy_from_user(buffer, wrqu->data.pointer, wrqu->data.length))
+	{
+		ret = -EFAULT;
+		goto bad;
+	}
+
+	DBG_871X("[%s] buffer = %s\n", __FUNCTION__, buffer);
+
+	if (_rtw_memcmp(buffer, "wpsCM=", 6))
+	{
+		ret = rtw_p2p_get_wps_configmethod(dev, info, wrqu, extra, &buffer[6]);
+	} else if (_rtw_memcmp(buffer, "devN=", 5))
+	{
+		ret = rtw_p2p_get_device_name(dev, info, wrqu, extra, &buffer[5]);
+	} else if (_rtw_memcmp(buffer, "dev_type=", 9))
+	{
+		ret = rtw_p2p_get_device_type(dev, info, wrqu, extra, &buffer[9]);
+	} else if (_rtw_memcmp(buffer, "go_devadd=", 10))
+	{
+		ret = rtw_p2p_get_go_device_address(dev, info, wrqu, extra, &buffer[10]);
+	} else if (_rtw_memcmp(buffer, "InvProc=", 8))
+	{
+		ret = rtw_p2p_get_invitation_procedure(dev, info, wrqu, extra, &buffer[8]);
+	} else
+	{
+		snprintf(extra, sizeof("Command not found."), "Command not found.");
+		wrqu->data.length = strlen(extra);
+	}
+
+bad:
+	if (buffer)
+	{
+		rtw_mfree(buffer, length);
+	}
+
+#endif //CONFIG_P2P
+
+	return ret;
+
+}
+
+static int rtw_cta_test_start(struct net_device *dev,
+							   struct iw_request_info *info,
+							   union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	_adapter	*padapter = (_adapter *)rtw_netdev_priv(dev);
+	DBG_871X("%s %s\n", __func__, extra);
+	if (!strcmp(extra, "1"))
+		padapter->in_cta_test = 1;
+	else
+		padapter->in_cta_test = 0;
+
+	if(padapter->in_cta_test)
+	{
+		u32 v = rtw_read32(padapter, REG_RCR);
+		v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );//| RCR_ADF
+		rtw_write32(padapter, REG_RCR, v);
+		DBG_871X("enable RCR_ADF\n");
+	}
+	else
+	{
+		u32 v = rtw_read32(padapter, REG_RCR);
+		v |= RCR_CBSSID_DATA | RCR_CBSSID_BCN ;//| RCR_ADF
+		rtw_write32(padapter, REG_RCR, v);
+		DBG_871X("disable RCR_ADF\n");
+	}
+	return ret;
+}
+
+
+extern int rtw_change_ifname(_adapter *padapter, const char *ifname);
+static int rtw_rereg_nd_name(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;	
+	_adapter *padapter = rtw_netdev_priv(dev);
+	struct rereg_nd_name_data *rereg_priv = &padapter->rereg_nd_name_priv;
+	char new_ifname[IFNAMSIZ];
+
+	if(rereg_priv->old_ifname[0] == 0) {
+		char *reg_ifname;
+#ifdef CONFIG_CONCURRENT_MODE 
+		if (padapter->isprimary)
+			reg_ifname = padapter->registrypriv.ifname;
+		else
+#endif
+		reg_ifname = padapter->registrypriv.if2name;
+
+		strncpy(rereg_priv->old_ifname, reg_ifname, IFNAMSIZ);
+		rereg_priv->old_ifname[IFNAMSIZ-1] = 0;
+	}
+
+	//DBG_871X("%s wrqu->data.length:%d\n", __FUNCTION__, wrqu->data.length);
+	if(wrqu->data.length > IFNAMSIZ)
+		return -EFAULT;
+
+	if ( copy_from_user(new_ifname, wrqu->data.pointer, IFNAMSIZ) ) {
+		return -EFAULT;
+	}
+
+	if( 0 == strcmp(rereg_priv->old_ifname, new_ifname) ) {
+		return ret;
+	}
+
+	DBG_871X("%s new_ifname:%s\n", __FUNCTION__, new_ifname);
+	if( 0 != (ret = rtw_change_ifname(padapter, new_ifname)) ) {
+		goto exit;
+	}
+
+	if(_rtw_memcmp(rereg_priv->old_ifname, "disable%d", 9) == _TRUE) {
+		padapter->ledpriv.bRegUseLed= rereg_priv->old_bRegUseLed;
+		rtw_hal_sw_led_init(padapter);
+		//rtw_ips_mode_req(&padapter->pwrctrlpriv, rereg_priv->old_ips_mode);
+	}
+
+	strncpy(rereg_priv->old_ifname, new_ifname, IFNAMSIZ);
+	rereg_priv->old_ifname[IFNAMSIZ-1] = 0;
+	
+	if(_rtw_memcmp(new_ifname, "disable%d", 9) == _TRUE) {
+
+		DBG_871X("%s disable\n", __FUNCTION__);
+		// free network queue for Android's timming issue
+		rtw_free_network_queue(padapter, _TRUE);
+		
+		// close led
+		rtw_led_control(padapter, LED_CTL_POWER_OFF);
+		rereg_priv->old_bRegUseLed = padapter->ledpriv.bRegUseLed;
+		padapter->ledpriv.bRegUseLed= _FALSE;
+		rtw_hal_sw_led_deinit(padapter);
+		
+		// the interface is being "disabled", we can do deeper IPS
+		//rereg_priv->old_ips_mode = rtw_get_ips_mode_req(&padapter->pwrctrlpriv);
+		//rtw_ips_mode_req(&padapter->pwrctrlpriv, IPS_NORMAL);
+	}
+exit:
+	return ret;
+
+}
+
+#ifdef CONFIG_IOL
+#include <rtw_iol.h>
+#endif
+
+#ifdef DBG_CMD_QUEUE
+u8 dump_cmd_id=0;
+#endif
+static int rtw_dbg_port(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{	
+	_irqL irqL;
+	int ret = 0;
+	u8 major_cmd, minor_cmd;
+	u16 arg;
+	u32 extra_arg, *pdata, val32;
+	struct sta_info *psta;						
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	
+
+	pdata = (u32*)&wrqu->data;	
+
+	val32 = *pdata;
+	arg = (u16)(val32&0x0000ffff);
+	major_cmd = (u8)(val32>>24);
+	minor_cmd = (u8)((val32>>16)&0x00ff);
+
+	extra_arg = *(pdata+1);
+	
+	switch(major_cmd)
+	{
+		case 0x70://read_reg
+			switch(minor_cmd)
+			{
+				case 1:
+					DBG_871X("rtw_read8(0x%x)=0x%02x\n", arg, rtw_read8(padapter, arg));
+					break;
+				case 2:
+					DBG_871X("rtw_read16(0x%x)=0x%04x\n", arg, rtw_read16(padapter, arg));
+					break;
+				case 4:
+					DBG_871X("rtw_read32(0x%x)=0x%08x\n", arg, rtw_read32(padapter, arg));
+					break;
+			}			
+			break;
+		case 0x71://write_reg
+			switch(minor_cmd)
+			{
+				case 1:
+					rtw_write8(padapter, arg, extra_arg);
+					DBG_871X("rtw_write8(0x%x)=0x%02x\n", arg, rtw_read8(padapter, arg));
+					break;
+				case 2:
+					rtw_write16(padapter, arg, extra_arg);
+					DBG_871X("rtw_write16(0x%x)=0x%04x\n", arg, rtw_read16(padapter, arg));
+					break;
+				case 4:
+					rtw_write32(padapter, arg, extra_arg);
+					DBG_871X("rtw_write32(0x%x)=0x%08x\n", arg, rtw_read32(padapter, arg));
+					break;
+			}			
+			break;
+		case 0x72://read_bb
+			DBG_871X("read_bbreg(0x%x)=0x%x\n", arg, rtw_hal_read_bbreg(padapter, arg, 0xffffffff));
+			break;
+		case 0x73://write_bb
+			rtw_hal_write_bbreg(padapter, arg, 0xffffffff, extra_arg);
+			DBG_871X("write_bbreg(0x%x)=0x%x\n", arg, rtw_hal_read_bbreg(padapter, arg, 0xffffffff));
+			break;
+		case 0x74://read_rf
+			DBG_871X("read RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n",minor_cmd,arg,rtw_hal_read_rfreg(padapter, minor_cmd, arg, 0xffffffff));	
+			break;
+		case 0x75://write_rf
+			rtw_hal_write_rfreg(padapter, minor_cmd, arg, 0xffffffff, extra_arg);
+			DBG_871X("write RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n",minor_cmd,arg, rtw_hal_read_rfreg(padapter, minor_cmd, arg, 0xffffffff));
+			break;	
+
+		case 0x76:
+			switch(minor_cmd)
+			{
+				case 0x00: //normal mode, 
+					padapter->recvpriv.is_signal_dbg = 0;
+					break;
+				case 0x01: //dbg mode
+					padapter->recvpriv.is_signal_dbg = 1;
+					extra_arg = extra_arg>100?100:extra_arg;
+					padapter->recvpriv.signal_strength_dbg=extra_arg;
+					break;
+			}
+			break;
+		case 0x78: //IOL test
+			switch(minor_cmd)
+			{
+				#ifdef CONFIG_IOL
+				case 0x04: //LLT table initialization test
+				{
+					u8 page_boundary = 0xf9;
+					{
+						struct xmit_frame	*xmit_frame;
+
+						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
+							ret = -ENOMEM;	
+							break;
+						}
+						
+						rtw_IOL_append_LLT_cmd(xmit_frame, page_boundary);
+
+
+						if(_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 500,0) )
+							ret = -EPERM;
+					}
+				}
+					break;
+				case 0x05: //blink LED test
+				{
+					u16 reg = 0x4c;
+					u32 blink_num = 50;
+					u32 blink_delay_ms = 200;
+					int i;
+					
+					{
+						struct xmit_frame	*xmit_frame;
+
+						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
+							ret = -ENOMEM;	
+							break;
+						}
+
+						for(i=0;i<blink_num;i++){
+							#ifdef CONFIG_IOL_NEW_GENERATION
+							rtw_IOL_append_WB_cmd(xmit_frame, reg, 0x00,0xff);
+							rtw_IOL_append_DELAY_MS_cmd(xmit_frame, blink_delay_ms);
+							rtw_IOL_append_WB_cmd(xmit_frame, reg, 0x08,0xff);
+							rtw_IOL_append_DELAY_MS_cmd(xmit_frame, blink_delay_ms);
+							#else
+							rtw_IOL_append_WB_cmd(xmit_frame, reg, 0x00);
+							rtw_IOL_append_DELAY_MS_cmd(xmit_frame, blink_delay_ms);
+							rtw_IOL_append_WB_cmd(xmit_frame, reg, 0x08);
+							rtw_IOL_append_DELAY_MS_cmd(xmit_frame, blink_delay_ms);
+							#endif
+						}
+						if(_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, (blink_delay_ms*blink_num*2)+200,0) )
+							ret = -EPERM;
+					}
+				}
+					break;
+					
+				case 0x06: //continuous wirte byte test
+				{
+					u16 reg = arg;
+					u16 start_value = 0;
+					u32 write_num = extra_arg;
+					int i;
+					u8 final;
+					
+					{
+						struct xmit_frame	*xmit_frame;
+
+						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
+							ret = -ENOMEM;	
+							break;
+						}
+
+						for(i=0;i<write_num;i++){
+							#ifdef CONFIG_IOL_NEW_GENERATION
+							rtw_IOL_append_WB_cmd(xmit_frame, reg, i+start_value,0xFF);
+							#else
+							rtw_IOL_append_WB_cmd(xmit_frame, reg, i+start_value);
+							#endif
+						}
+						if(_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000,0))
+							ret = -EPERM;
+					}
+
+					if(start_value+write_num-1 == (final=rtw_read8(padapter, reg)) ) {
+						DBG_871X("continuous IOL_CMD_WB_REG to 0x%x %u times Success, start:%u, final:%u\n", reg, write_num, start_value, final);
+					} else {
+						DBG_871X("continuous IOL_CMD_WB_REG to 0x%x %u times Fail, start:%u, final:%u\n", reg, write_num, start_value, final);
+					}
+				}
+					break;
+					
+				case 0x07: //continuous wirte word test
+				{
+					u16 reg = arg;
+					u16 start_value = 200;
+					u32 write_num = extra_arg;
+				
+					int i;
+					u16 final;
+
+					{
+						struct xmit_frame	*xmit_frame;
+
+						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
+							ret = -ENOMEM;	
+							break;
+						}
+
+						for(i=0;i<write_num;i++){
+							#ifdef CONFIG_IOL_NEW_GENERATION
+							rtw_IOL_append_WW_cmd(xmit_frame, reg, i+start_value,0xFFFF);
+							#else
+							rtw_IOL_append_WW_cmd(xmit_frame, reg, i+start_value);
+							#endif
+						}
+						if(_SUCCESS !=rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000,0))
+							ret = -EPERM;
+					}
+
+					if(start_value+write_num-1 == (final=rtw_read16(padapter, reg)) ) {
+						DBG_871X("continuous IOL_CMD_WW_REG to 0x%x %u times Success, start:%u, final:%u\n", reg, write_num, start_value, final);
+					} else {
+						DBG_871X("continuous IOL_CMD_WW_REG to 0x%x %u times Fail, start:%u, final:%u\n", reg, write_num, start_value, final);
+					}
+				}
+					break;
+					
+				case 0x08: //continuous wirte dword test
+				{
+					u16 reg = arg;
+					u32 start_value = 0x110000c7;
+					u32 write_num = extra_arg;
+				
+					int i;
+					u32 final;
+
+					{
+						struct xmit_frame	*xmit_frame;
+
+						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
+							ret = -ENOMEM;	
+							break;
+						}
+
+						for(i=0;i<write_num;i++){
+							#ifdef CONFIG_IOL_NEW_GENERATION
+							rtw_IOL_append_WD_cmd(xmit_frame, reg, i+start_value,0xFFFFFFFF);
+							#else
+							rtw_IOL_append_WD_cmd(xmit_frame, reg, i+start_value);
+							#endif
+						}
+						if(_SUCCESS !=rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000,0))
+							ret = -EPERM;
+							
+					}
+
+					if(start_value+write_num-1 == (final=rtw_read32(padapter, reg)) ) {
+						DBG_871X("continuous IOL_CMD_WD_REG to 0x%x %u times Success, start:%u, final:%u\n", reg, write_num, start_value, final);
+					} else {
+						DBG_871X("continuous IOL_CMD_WD_REG to 0x%x %u times Fail, start:%u, final:%u\n", reg, write_num, start_value, final);
+					}
+				}
+					break;
+				#endif //CONFIG_IOL
+			}
+			break;
+		case 0x79:
+			{
+				/*
+				* dbg 0x79000000 [value], set RESP_TXAGC to + value, value:0~15
+				* dbg 0x79010000 [value], set RESP_TXAGC to - value, value:0~15
+				*/
+				u8 value =  extra_arg & 0x0f;
+				u8 sign = minor_cmd;
+				u16 write_value = 0;
+
+				DBG_871X("%s set RESP_TXAGC to %s %u\n", __func__, sign?"minus":"plus", value);
+
+				if (sign)
+					value = value | 0x10;
+
+				write_value = value | (value << 5);
+				rtw_write16(padapter, 0x6d9, write_value);
+			}
+			break;
+		case 0x7a:
+			receive_disconnect(padapter, pmlmeinfo->network.MacAddress
+				, WLAN_REASON_EXPIRATION_CHK);
+			break;
+		case 0x7F:
+			switch(minor_cmd)
+			{
+				case 0x0:
+					DBG_871X("fwstate=0x%x\n", get_fwstate(pmlmepriv));
+					break;
+				case 0x01:
+					DBG_871X("auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
+						psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
+						psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
+					break;
+				case 0x02:
+					DBG_871X("pmlmeinfo->state=0x%x\n", pmlmeinfo->state);
+					DBG_871X("DrvBcnEarly=%d\n", pmlmeext->DrvBcnEarly);
+					DBG_871X("DrvBcnTimeOut=%d\n", pmlmeext->DrvBcnTimeOut);
+					break;
+				case 0x03:
+					DBG_871X("qos_option=%d\n", pmlmepriv->qospriv.qos_option);
+#ifdef CONFIG_80211N_HT
+					DBG_871X("ht_option=%d\n", pmlmepriv->htpriv.ht_option);
+#endif //CONFIG_80211N_HT
+					break;
+				case 0x04:
+					DBG_871X("cur_ch=%d\n", pmlmeext->cur_channel);
+					DBG_871X("cur_bw=%d\n", pmlmeext->cur_bwmode);
+					DBG_871X("cur_ch_off=%d\n", pmlmeext->cur_ch_offset);
+
+					DBG_871X("oper_ch=%d\n", rtw_get_oper_ch(padapter));
+					DBG_871X("oper_bw=%d\n", rtw_get_oper_bw(padapter));
+					DBG_871X("oper_ch_offet=%d\n", rtw_get_oper_choffset(padapter));
+				
+					break;
+				case 0x05:
+					psta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
+					if(psta)
+					{
+						DBG_871X("SSID=%s\n", cur_network->network.Ssid.Ssid);
+						DBG_871X("sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
+						DBG_871X("cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+						DBG_871X("rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+						DBG_871X("state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);
+#ifdef CONFIG_80211N_HT
+						DBG_871X("qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);
+						DBG_871X("bwmode=%d, ch_offset=%d, sgi_20m=%d,sgi_40m=%d\n", psta->bw_mode, psta->htpriv.ch_offset, psta->htpriv.sgi_20m, psta->htpriv.sgi_40m);
+						DBG_871X("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);	
+						DBG_871X("agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+#endif //CONFIG_80211N_HT
+
+						sta_rx_reorder_ctl_dump(RTW_DBGDUMP, psta);
+					}
+					else
+					{							
+						DBG_871X("can't get sta's macaddr, cur_network's macaddr:" MAC_FMT "\n", MAC_ARG(cur_network->network.MacAddress));
+					}					
+					break;
+				case 0x06:
+					{						
+					}
+					break;
+				case 0x07:
+					DBG_871X("bSurpriseRemoved=%s, bDriverStopped=%s\n"
+						, rtw_is_surprise_removed(padapter)?"True":"False"
+						, rtw_is_drv_stopped(padapter)?"True":"False");
+					break;
+				case 0x08:
+					{
+						struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+						struct recv_priv  *precvpriv = &padapter->recvpriv;
+						
+						DBG_871X("free_xmitbuf_cnt=%d, free_xmitframe_cnt=%d"
+							", free_xmit_extbuf_cnt=%d, free_xframe_ext_cnt=%d"
+							", free_recvframe_cnt=%d\n",
+							pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt,
+							pxmitpriv->free_xmit_extbuf_cnt, pxmitpriv->free_xframe_ext_cnt,
+							precvpriv->free_recvframe_cnt);
+						#ifdef CONFIG_USB_HCI
+						DBG_871X("rx_urb_pending_cn=%d\n", ATOMIC_READ(&(precvpriv->rx_pending_cnt)));
+						#endif
+					}
+					break;	
+				case 0x09:
+					{
+						int i;
+						_list	*plist, *phead;
+						
+#ifdef CONFIG_AP_MODE
+						DBG_871X("sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
+#endif						
+						_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+						for(i=0; i< NUM_STA; i++)
+						{
+							phead = &(pstapriv->sta_hash[i]);
+							plist = get_next(phead);
+		
+							while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+							{
+								psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
+
+								plist = get_next(plist);
+
+								if(extra_arg == psta->aid)
+								{
+									DBG_871X("sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
+									DBG_871X("rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+									DBG_871X("state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);
+#ifdef CONFIG_80211N_HT
+									DBG_871X("qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+									DBG_871X("bwmode=%d, ch_offset=%d, sgi_20m=%d,sgi_40m=%d\n", psta->bw_mode, psta->htpriv.ch_offset, psta->htpriv.sgi_20m, psta->htpriv.sgi_40m);
+									DBG_871X("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);									
+									DBG_871X("agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+#endif //CONFIG_80211N_HT
+									
+#ifdef CONFIG_AP_MODE
+									DBG_871X("capability=0x%x\n", psta->capability);
+									DBG_871X("flags=0x%x\n", psta->flags);
+									DBG_871X("wpa_psk=0x%x\n", psta->wpa_psk);
+									DBG_871X("wpa2_group_cipher=0x%x\n", psta->wpa2_group_cipher);
+									DBG_871X("wpa2_pairwise_cipher=0x%x\n", psta->wpa2_pairwise_cipher);
+									DBG_871X("qos_info=0x%x\n", psta->qos_info);
+#endif
+									DBG_871X("dot118021XPrivacy=0x%x\n", psta->dot118021XPrivacy);
+
+									sta_rx_reorder_ctl_dump(RTW_DBGDUMP, psta);
+								}							
+			
+							}
+						}
+	
+						_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+					}
+					break;
+
+				case 0x0b: //Enable=1, Disable=0 driver control vrtl_carrier_sense.
+					{
+						//u8 driver_vcs_en; //Enable=1, Disable=0 driver control vrtl_carrier_sense.
+						//u8 driver_vcs_type;//force 0:disable VCS, 1:RTS-CTS, 2:CTS-to-self when vcs_en=1.
+
+						if(arg == 0){
+							DBG_871X("disable driver ctrl vcs\n");						
+							padapter->driver_vcs_en = 0;					
+						}
+						else if(arg == 1){							
+							DBG_871X("enable driver ctrl vcs = %d\n", extra_arg);
+							padapter->driver_vcs_en = 1;
+	
+							if(extra_arg>2)
+								padapter->driver_vcs_type = 1;						
+							else
+								padapter->driver_vcs_type = extra_arg;
+						}
+					}
+					break;
+				case 0x0c://dump rx/tx packet
+					{
+						if(arg == 0){
+							DBG_871X("dump rx packet (%d)\n",extra_arg);						
+							//pHalData->bDumpRxPkt =extra_arg;						
+							rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DUMP_RXPKT, &(extra_arg));
+						}
+						else if(arg==1){
+							DBG_871X("dump tx packet (%d)\n",extra_arg);						
+							rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DUMP_TXPKT, &(extra_arg));
+						}
+					}
+					break;
+				case 0x0e:
+					{
+						if(arg == 0){
+							DBG_871X("disable driver ctrl rx_ampdu_factor\n");						
+							padapter->driver_rx_ampdu_factor = 0xFF;
+						}
+						else if(arg == 1){
+							
+							DBG_871X("enable driver ctrl rx_ampdu_factor = %d\n", extra_arg);	
+	
+							if(extra_arg > 0x03)
+								padapter->driver_rx_ampdu_factor = 0xFF;						
+							else
+								padapter->driver_rx_ampdu_factor = extra_arg;
+						}					
+					}
+					break;
+		#ifdef DBG_CONFIG_ERROR_DETECT
+				case 0x0f:
+						{
+							if(extra_arg == 0){	
+								DBG_871X("###### silent reset test.......#####\n");
+								rtw_hal_sreset_reset(padapter);						
+							} else {
+								HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+								struct sreset_priv *psrtpriv = &pHalData->srestpriv;
+								psrtpriv->dbg_trigger_point = extra_arg;
+							}
+							
+						}
+					break;
+				case 0x15:
+					{
+						struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+						DBG_871X("==>silent resete cnts:%d\n",pwrpriv->ips_enter_cnts);
+					}
+					break;	
+					
+		#endif	
+
+				case 0x10:// driver version display
+					dump_drv_version(RTW_DBGDUMP);
+					break;
+				case 0x11://dump linked status
+					{
+						int pre_mode;
+						pre_mode=padapter->bLinkInfoDump;
+						// linked_info_dump(padapter,extra_arg);
+						 if(extra_arg==1 || (extra_arg==0 && pre_mode==1) ) //not consider pwr_saving 0:
+						{
+							padapter->bLinkInfoDump = extra_arg;	
+		
+						}
+						else if( (extra_arg==2 ) || (extra_arg==0 && pre_mode==2))//consider power_saving
+						{		
+						//DBG_871X("linked_info_dump =%s \n", (padapter->bLinkInfoDump)?"enable":"disable")
+							linked_info_dump(padapter,extra_arg);	
+						}
+
+
+						 
+					}					
+					break;
+#ifdef CONFIG_80211N_HT
+				case 0x12: //set rx_stbc
+				{
+					struct registry_priv	*pregpriv = &padapter->registrypriv;
+					// 0: disable, bit(0):enable 2.4g, bit(1):enable 5g, 0x3: enable both 2.4g and 5g
+					//default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ
+					if( pregpriv && (extra_arg == 0 || extra_arg == 1|| extra_arg == 2 || extra_arg == 3))
+					{
+						pregpriv->rx_stbc= extra_arg;
+						DBG_871X("set rx_stbc=%d\n",pregpriv->rx_stbc);
+					}
+					else
+						DBG_871X("get rx_stbc=%d\n",pregpriv->rx_stbc);
+					
+				}
+				break;
+				case 0x13: //set ampdu_enable
+				{
+					struct registry_priv	*pregpriv = &padapter->registrypriv;
+					// 0: disable, 0x1:enable (but wifi_spec should be 0), 0x2: force enable (don't care wifi_spec)
+					if( pregpriv && extra_arg < 3 )
+					{
+						pregpriv->ampdu_enable= extra_arg;
+						DBG_871X("set ampdu_enable=%d\n",pregpriv->ampdu_enable);
+					}
+					else
+						DBG_871X("get ampdu_enable=%d\n",pregpriv->ampdu_enable);
+					
+				}
+				break;
+#endif
+				case 0x14: //get wifi_spec
+				{
+					struct registry_priv	*pregpriv = &padapter->registrypriv;
+					DBG_871X("get wifi_spec=%d\n",pregpriv->wifi_spec);
+					
+				}
+				break;
+				case 0x16:
+				{
+					if(arg == 0xff){
+						rtw_odm_dbg_comp_msg(RTW_DBGDUMP,padapter);
+					}
+					else{
+						u64 dbg_comp = (u64)extra_arg;
+						rtw_odm_dbg_comp_set(padapter, dbg_comp);
+					}
+				}
+					break;
+#ifdef DBG_FIXED_CHAN
+				case 0x17:
+					{
+						struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);						
+						printk("===>  Fixed channel to %d \n",extra_arg);
+						pmlmeext->fixed_chan = extra_arg;	
+						
+					}
+					break;
+#endif
+				case 0x18:
+					{
+						printk("===>  Switch USB Mode %d \n",extra_arg);
+						rtw_hal_set_hwreg(padapter, HW_VAR_USB_MODE, (u8 *)&extra_arg);
+					}
+					break;
+#ifdef CONFIG_80211N_HT			
+				case 0x19:
+					{
+						struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+						// extra_arg :
+						// BIT0: Enable VHT LDPC Rx, BIT1: Enable VHT LDPC Tx, 
+						// BIT4: Enable HT LDPC Rx, BIT5: Enable HT LDPC Tx
+						if(arg == 0){
+							DBG_871X("driver disable LDPC\n");						
+							pregistrypriv->ldpc_cap = 0x00;
+						}
+						else if(arg == 1){							
+							DBG_871X("driver set LDPC cap = 0x%x\n", extra_arg);
+							pregistrypriv->ldpc_cap = (u8)(extra_arg&0x33);						
+						}						
+					}
+                                        break;
+				case 0x1a:
+					{
+						struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+						// extra_arg :
+						// BIT0: Enable VHT STBC Rx, BIT1: Enable VHT STBC Tx, 
+						// BIT4: Enable HT STBC Rx, BIT5: Enable HT STBC Tx
+						if(arg == 0){
+							DBG_871X("driver disable STBC\n");						
+							pregistrypriv->stbc_cap = 0x00;
+						}
+						else if(arg == 1){							
+							DBG_871X("driver set STBC cap = 0x%x\n", extra_arg);
+							pregistrypriv->stbc_cap = (u8)(extra_arg&0x33);						
+						}						
+					}
+                                        break;
+#endif //CONFIG_80211N_HT
+				case 0x1b:
+					{	
+						struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+						
+						if(arg == 0){
+							DBG_871X("disable driver ctrl max_rx_rate, reset to default_rate_set\n");							
+							init_mlme_default_rate_set(padapter);
+#ifdef CONFIG_80211N_HT						
+							pregistrypriv->ht_enable = (u8)rtw_ht_enable;
+#endif //CONFIG_80211N_HT
+						}
+						else if(arg == 1){
+
+							int i;
+							u8 max_rx_rate;						
+							
+							DBG_871X("enable driver ctrl max_rx_rate = 0x%x\n", extra_arg);	
+
+							max_rx_rate = (u8)extra_arg;
+
+							if(max_rx_rate < 0xc) // max_rx_rate < MSC0 -> B or G -> disable HT
+							{
+#ifdef CONFIG_80211N_HT						
+								pregistrypriv->ht_enable = 0;
+#endif //CONFIG_80211N_HT
+								for(i=0; i<NumRates; i++)
+								{
+									if(pmlmeext->datarate[i] > max_rx_rate)
+										pmlmeext->datarate[i] = 0xff;									
+								}	
+
+							}
+#ifdef CONFIG_80211N_HT	
+							else if(max_rx_rate < 0x1c) // mcs0~mcs15
+							{
+								u32 mcs_bitmap=0x0;
+													
+								for(i=0; i<((max_rx_rate+1)-0xc); i++)
+									mcs_bitmap |= BIT(i);
+								
+								set_mcs_rate_by_mask(pmlmeext->default_supported_mcs_set, mcs_bitmap);
+							}
+#endif //CONFIG_80211N_HT							
+						}											
+					}
+                                        break;
+				case 0x1c: //enable/disable driver control AMPDU Density for peer sta's rx
+					{
+						if(arg == 0){
+							DBG_871X("disable driver ctrl ampdu density\n");						
+							padapter->driver_ampdu_spacing = 0xFF;
+						}
+						else if(arg == 1){
+							
+							DBG_871X("enable driver ctrl ampdu density = %d\n", extra_arg);	
+	
+							if(extra_arg > 0x07)
+								padapter->driver_ampdu_spacing = 0xFF;						
+							else
+								padapter->driver_ampdu_spacing = extra_arg;
+						}
+					}
+					break;
+#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
+				case 0x1e:
+					{
+						HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+						PDM_ODM_T pDM_Odm = &pHalData->odmpriv;
+						u8 chan = rtw_get_oper_ch(padapter);
+						DBG_871X("===========================================\n");
+						ODM_InbandNoise_Monitor(pDM_Odm,_TRUE,0x1e,100);
+						DBG_871X("channel(%d),noise_a = %d, noise_b = %d , noise_all:%d \n", 
+							chan,pDM_Odm->noise_level.noise[ODM_RF_PATH_A], 
+							pDM_Odm->noise_level.noise[ODM_RF_PATH_B],
+							pDM_Odm->noise_level.noise_all);
+						DBG_871X("===========================================\n");
+						
+					}
+					break;
+#endif
+				case 0x23:
+					{
+						DBG_871X("turn %s the bNotifyChannelChange Variable\n",(extra_arg==1)?"on":"off");
+						padapter->bNotifyChannelChange = extra_arg;
+						break;
+					}
+				case 0x24:
+					{
+#ifdef CONFIG_P2P
+						DBG_871X("turn %s the bShowGetP2PState Variable\n",(extra_arg==1)?"on":"off");
+						padapter->bShowGetP2PState = extra_arg;
+#endif // CONFIG_P2P
+						break;						
+					}
+#ifdef CONFIG_GPIO_API              
+		            case 0x25: //Get GPIO register
+		                    {
+			                    /*
+			                    * dbg 0x7f250000 [gpio_num], Get gpio value, gpio_num:0~7
+			                    */                
+                              
+			                    u8 value;
+			                    DBG_871X("Read GPIO Value  extra_arg = %d\n",extra_arg);
+			                    value = rtw_hal_get_gpio(padapter,extra_arg);
+			                    DBG_871X("Read GPIO Value = %d\n",value);                                        
+			                    break;
+		                    }
+		            case 0x26: //Set GPIO direction
+		                    {
+                                       						
+			                    /* dbg 0x7f26000x [y], Set gpio direction, 
+			                    * x: gpio_num,4~7  y: indicate direction, 0~1  
+			                    */ 
+                                        
+			                    int value;
+			                    DBG_871X("Set GPIO Direction! arg = %d ,extra_arg=%d\n",arg ,extra_arg);
+			                    value = rtw_hal_config_gpio(padapter, arg, extra_arg);
+			                    DBG_871X("Set GPIO Direction %s \n",(value==-1)?"Fail!!!":"Success");
+			                    break;
+					}
+				case 0x27: //Set GPIO output direction value
+					{
+						/*
+						* dbg 0x7f27000x [y], Set gpio output direction value, 
+ 						* x: gpio_num,4~7  y: indicate direction, 0~1  
+						*/ 
+                                        
+						int value;
+						DBG_871X("Set GPIO Value! arg = %d ,extra_arg=%d\n",arg ,extra_arg);
+						value = rtw_hal_set_gpio_output_value(padapter,arg,extra_arg);
+						DBG_871X("Set GPIO Value %s \n",(value==-1)?"Fail!!!":"Success");
+						break;
+					}
+#endif          
+#ifdef DBG_CMD_QUEUE
+				case 0x28:
+					{
+						dump_cmd_id = extra_arg;
+						DBG_871X("dump_cmd_id:%d\n",dump_cmd_id);
+					}
+					break;
+#endif //DBG_CMD_QUEUE
+				case 0xaa:
+					{
+						if((extra_arg & 0x7F)> 0x3F) extra_arg = 0xFF;
+						DBG_871X("chang data rate to :0x%02x\n",extra_arg);
+						padapter->fix_rate = extra_arg;
+					}
+					break;	
+				case 0xdd://registers dump , 0 for mac reg,1 for bb reg, 2 for rf reg
+					{
+						if(extra_arg==0){
+							mac_reg_dump(RTW_DBGDUMP, padapter);
+						}
+						else if(extra_arg==1){
+							bb_reg_dump(RTW_DBGDUMP, padapter);
+						}
+						else if(extra_arg==2){
+							rf_reg_dump(RTW_DBGDUMP, padapter);
+						}
+					}
+					break;		
+
+				case 0xee:
+					{
+						DBG_871X(" === please control /proc  to trun on/off PHYDM func === \n");
+					}
+					break;
+
+				case 0xfd:
+					rtw_write8(padapter, 0xc50, arg);
+					DBG_871X("wr(0xc50)=0x%x\n", rtw_read8(padapter, 0xc50));
+					rtw_write8(padapter, 0xc58, arg);
+					DBG_871X("wr(0xc58)=0x%x\n", rtw_read8(padapter, 0xc58));
+					break;
+				case 0xfe:
+					DBG_871X("rd(0xc50)=0x%x\n", rtw_read8(padapter, 0xc50));
+					DBG_871X("rd(0xc58)=0x%x\n", rtw_read8(padapter, 0xc58));
+					break;
+				case 0xff:
+					{
+						DBG_871X("dbg(0x210)=0x%x\n", rtw_read32(padapter, 0x210));
+						DBG_871X("dbg(0x608)=0x%x\n", rtw_read32(padapter, 0x608));
+						DBG_871X("dbg(0x280)=0x%x\n", rtw_read32(padapter, 0x280));
+						DBG_871X("dbg(0x284)=0x%x\n", rtw_read32(padapter, 0x284));
+						DBG_871X("dbg(0x288)=0x%x\n", rtw_read32(padapter, 0x288));
+	
+						DBG_871X("dbg(0x664)=0x%x\n", rtw_read32(padapter, 0x664));
+
+
+						DBG_871X("\n");
+		
+						DBG_871X("dbg(0x430)=0x%x\n", rtw_read32(padapter, 0x430));
+						DBG_871X("dbg(0x438)=0x%x\n", rtw_read32(padapter, 0x438));
+
+						DBG_871X("dbg(0x440)=0x%x\n", rtw_read32(padapter, 0x440));
+	
+						DBG_871X("dbg(0x458)=0x%x\n", rtw_read32(padapter, 0x458));
+	
+						DBG_871X("dbg(0x484)=0x%x\n", rtw_read32(padapter, 0x484));
+						DBG_871X("dbg(0x488)=0x%x\n", rtw_read32(padapter, 0x488));
+	
+						DBG_871X("dbg(0x444)=0x%x\n", rtw_read32(padapter, 0x444));
+						DBG_871X("dbg(0x448)=0x%x\n", rtw_read32(padapter, 0x448));
+						DBG_871X("dbg(0x44c)=0x%x\n", rtw_read32(padapter, 0x44c));
+						DBG_871X("dbg(0x450)=0x%x\n", rtw_read32(padapter, 0x450));
+					}
+					break;
+			}			
+			break;
+		default:
+			DBG_871X("error dbg cmd!\n");
+			break;	
+	}
+	
+
+	return ret;
+
+}
+
+static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
+{
+	uint ret=0;
+	u32 flags;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	switch (name){
+	case IEEE_PARAM_WPA_ENABLED:
+
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X; //802.1x
+		
+		//ret = ieee80211_wpa_enable(ieee, value);
+		
+		switch((value)&0xff)
+		{
+			case 1 : //WPA
+			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPAPSK; //WPA_PSK
+			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+				break;
+			case 2: //WPA2
+			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPA2PSK; //WPA2_PSK
+			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+				break;
+		}
+		
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("wpa_set_param:padapter->securitypriv.ndisauthtype=%d\n", padapter->securitypriv.ndisauthtype));
+		
+		break;
+
+	case IEEE_PARAM_TKIP_COUNTERMEASURES:
+		//ieee->tkip_countermeasures=value;
+		break;
+
+	case IEEE_PARAM_DROP_UNENCRYPTED: 
+	{
+		/* HACK:
+		 *
+		 * wpa_supplicant calls set_wpa_enabled when the driver
+		 * is loaded and unloaded, regardless of if WPA is being
+		 * used.  No other calls are made which can be used to
+		 * determine if encryption will be used or not prior to
+		 * association being expected.  If encryption is not being
+		 * used, drop_unencrypted is set to false, else true -- we
+		 * can use this to determine if the CAP_PRIVACY_ON bit should
+		 * be set.
+		 */
+		 
+#if 0	 
+		struct ieee80211_security sec = {
+			.flags = SEC_ENABLED,
+			.enabled = value,
+		};
+ 		ieee->drop_unencrypted = value;
+		/* We only change SEC_LEVEL for open mode. Others
+		 * are set by ipw_wpa_set_encryption.
+		 */
+		if (!value) {
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_0;
+		}
+		else {
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_1;
+		}
+		if (ieee->set_security)
+			ieee->set_security(ieee->dev, &sec);
+#endif		
+		break;
+
+	}
+	case IEEE_PARAM_PRIVACY_INVOKED:	
+		
+		//ieee->privacy_invoked=value;
+		
+		break;
+
+	case IEEE_PARAM_AUTH_ALGS:
+		
+		ret = wpa_set_auth_algs(dev, value);
+		
+		break;
+
+	case IEEE_PARAM_IEEE_802_1X:
+		
+		//ieee->ieee802_1x=value;		
+		
+		break;
+		
+	case IEEE_PARAM_WPAX_SELECT:
+		
+		// added for WPA2 mixed mode
+		//DBG_871X(KERN_WARNING "------------------------>wpax value = %x\n", value);
+		/*
+		spin_lock_irqsave(&ieee->wpax_suitlist_lock,flags);
+		ieee->wpax_type_set = 1;
+		ieee->wpax_type_notify = value;
+		spin_unlock_irqrestore(&ieee->wpax_suitlist_lock,flags);
+		*/
+		
+		break;
+
+	default:		
+
+
+		
+		ret = -EOPNOTSUPP;
+
+		
+		break;
+	
+	}
+
+	return ret;
+	
+}
+
+static int wpa_mlme(struct net_device *dev, u32 command, u32 reason)
+{	
+	int ret = 0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	switch (command)
+	{
+		case IEEE_MLME_STA_DEAUTH:
+
+			if(!rtw_set_802_11_disassociate(padapter))
+				ret = -1;		
+			
+			break;
+
+		case IEEE_MLME_STA_DISASSOC:
+		
+			if(!rtw_set_802_11_disassociate(padapter))
+				ret = -1;		
+	
+			break;
+
+		default:
+			ret = -EOPNOTSUPP;
+			break;
+	}
+
+	return ret;
+	
+}
+
+static int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)
+{
+	struct ieee_param *param;
+	uint ret=0;
+
+	//down(&ieee->wx_sem);	
+
+	if (p->length < sizeof(struct ieee_param) || !p->pointer){
+		ret = -EINVAL;
+		goto out;
+	}
+	
+	param = (struct ieee_param *)rtw_malloc(p->length);
+	if (param == NULL)
+	{
+		ret = -ENOMEM;
+		goto out;
+	}
+	
+	if (copy_from_user(param, p->pointer, p->length))
+	{
+		rtw_mfree((u8*)param, p->length);
+		ret = -EFAULT;
+		goto out;
+	}
+
+	switch (param->cmd) {
+
+	case IEEE_CMD_SET_WPA_PARAM:
+		ret = wpa_set_param(dev, param->u.wpa_param.name, param->u.wpa_param.value);
+		break;
+
+	case IEEE_CMD_SET_WPA_IE:
+		//ret = wpa_set_wpa_ie(dev, param, p->length);
+		ret =  rtw_set_wpa_ie((_adapter *)rtw_netdev_priv(dev), (char*)param->u.wpa_ie.data, (u16)param->u.wpa_ie.len);
+		break;
+
+	case IEEE_CMD_SET_ENCRYPTION:
+		ret = wpa_set_encryption(dev, param, p->length);
+		break;
+
+	case IEEE_CMD_MLME:
+		ret = wpa_mlme(dev, param->u.mlme.command, param->u.mlme.reason_code);
+		break;
+
+	default:
+		DBG_871X("Unknown WPA supplicant request: %d\n", param->cmd);
+		ret = -EOPNOTSUPP;
+		break;
+		
+	}
+
+	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
+		ret = -EFAULT;
+
+	rtw_mfree((u8 *)param, p->length);
+	
+out:
+	
+	//up(&ieee->wx_sem);
+	
+	return ret;
+	
+}
+
+#ifdef CONFIG_AP_MODE
+static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len,wep_total_len;
+	NDIS_802_11_WEP	 *pwep = NULL;
+	struct sta_info *psta = NULL, *pbcmc_sta = NULL;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;
+	struct security_priv* psecuritypriv=&(padapter->securitypriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	//sizeof(struct ieee_param) = 64 bytes;
+	//if (param_len !=  (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
+	if (param_len !=  sizeof(struct ieee_param) + param->u.crypt.key_len)
+	{
+		ret =  -EINVAL;
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		if (param->u.crypt.idx >= WEP_KEYS
+#ifdef CONFIG_IEEE80211W
+			&& param->u.crypt.idx > BIP_MAX_KEYID
+#endif /* CONFIG_IEEE80211W */
+			)
+		{
+			ret = -EINVAL;
+			goto exit;
+		}	
+	}
+	else 
+	{		
+		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+		if(!psta)
+		{
+			//ret = -EINVAL;
+			DBG_871X("rtw_set_encryption(), sta has already been removed or never been added\n");
+			goto exit;
+		}			
+	}
+
+	if (strcmp(param->u.crypt.alg, "none") == 0 && (psta==NULL))
+	{
+		//todo:clear default encryption keys
+
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+		psecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;
+		psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+		psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+
+		DBG_871X("clear default encryption keys, keyid=%d\n", param->u.crypt.idx);
+		
+		goto exit;
+	}
+
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta==NULL))
+	{		
+		DBG_871X("r871x_set_encryption, crypt.alg = WEP\n");
+		
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+					
+		DBG_871X("r871x_set_encryption, wep_key_idx=%d, len=%d\n", wep_key_idx, wep_key_len);
+
+		if((wep_key_idx >= WEP_KEYS) || (wep_key_len<=0))
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+			
+
+		if (wep_key_len > 0) 
+		{			
+		 	wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+		 	pwep =(NDIS_802_11_WEP *)rtw_malloc(wep_total_len);
+			if(pwep == NULL){
+				DBG_871X(" r871x_set_encryption: pwep allocate fail !!!\n");
+				goto exit;
+			}
+			
+		 	_rtw_memset(pwep, 0, wep_total_len);
+		
+		 	pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_total_len;
+			
+		}
+		
+		pwep->KeyIndex = wep_key_idx;
+
+		_rtw_memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
+
+		if(param->u.crypt.set_tx)
+		{
+			DBG_871X("wep, set_tx=1\n");
+
+			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+			psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			psecuritypriv->dot11PrivacyAlgrthm=_WEP40_;
+			psecuritypriv->dot118021XGrpPrivacy=_WEP40_;
+			
+			if(pwep->KeyLength==13)
+			{
+				psecuritypriv->dot11PrivacyAlgrthm=_WEP104_;
+				psecuritypriv->dot118021XGrpPrivacy=_WEP104_;
+			}
+
+		
+			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
+			
+			_rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+
+			psecuritypriv->dot11DefKeylen[wep_key_idx]=pwep->KeyLength;
+
+			rtw_ap_set_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx, 1);
+		}
+		else
+		{
+			DBG_871X("wep, set_tx=0\n");
+			
+			//don't update "psecuritypriv->dot11PrivacyAlgrthm" and 
+			//"psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to cam
+					
+		      _rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+
+			psecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;			
+
+			rtw_ap_set_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx, 0);
+		}
+
+		goto exit;
+		
+	}
+
+	
+	if(!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) // //group key
+	{
+		if(param->u.crypt.set_tx ==1)
+		{
+			if(strcmp(param->u.crypt.alg, "WEP") == 0)
+			{
+				DBG_871X("%s, set group_key, WEP\n", __FUNCTION__);
+				
+				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					
+				psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+				if(param->u.crypt.key_len==13)
+				{						
+						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+				}
+				
+			}
+			else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+			{						
+				DBG_871X("%s, set group_key, TKIP\n", __FUNCTION__);
+				
+				psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
+
+				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				
+				//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
+				//set mic key
+				_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
+				_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
+
+				psecuritypriv->busetkipkey = _TRUE;
+											
+			}
+			else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+			{
+				DBG_871X("%s, set group_key, CCMP\n", __FUNCTION__);
+			
+				psecuritypriv->dot118021XGrpPrivacy = _AES_;
+
+				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+			}
+#ifdef CONFIG_IEEE80211W
+			else if (strcmp(param->u.crypt.alg, "BIP") == 0) {
+				int no;
+				
+				DBG_871X("BIP key_len=%d , index=%d\n", param->u.crypt.key_len, param->u.crypt.idx);
+				/* save the IGTK key, length 16 bytes */
+				_rtw_memcpy(padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16:param->u.crypt.key_len));
+				/* DBG_871X("IGTK key below:\n");
+				for(no=0;no<16;no++)
+					printk(" %02x ", padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey[no]);
+				DBG_871X("\n"); */
+				padapter->securitypriv.dot11wBIPKeyid = param->u.crypt.idx;
+				padapter->securitypriv.binstallBIPkey = _TRUE;
+				DBG_871X(" ~~~~set sta key:IGKT\n");
+				goto exit;
+			}
+#endif /* CONFIG_IEEE80211W */
+			else
+			{
+				DBG_871X("%s, set group_key, none\n", __FUNCTION__);
+				
+				psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+			}
+
+			psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
+
+			psecuritypriv->binstallGrpkey = _TRUE;
+
+			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
+								
+			rtw_ap_set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
+			
+			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
+			if(pbcmc_sta)
+			{
+				pbcmc_sta->ieee8021x_blocked = _FALSE;
+				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy			
+			}	
+						
+		}
+
+		goto exit;
+		
+	}	
+
+	if(psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) // psk/802_1x
+	{
+		if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
+		{
+			if(param->u.crypt.set_tx ==1)
+			{ 
+				_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				
+				if(strcmp(param->u.crypt.alg, "WEP") == 0)
+				{
+					DBG_871X("%s, set pairwise key, WEP\n", __FUNCTION__);
+					
+					psta->dot118021XPrivacy = _WEP40_;
+					if(param->u.crypt.key_len==13)
+					{						
+						psta->dot118021XPrivacy = _WEP104_;
+					}
+				}
+				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+				{						
+					DBG_871X("%s, set pairwise key, TKIP\n", __FUNCTION__);
+					
+					psta->dot118021XPrivacy = _TKIP_;
+				
+					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
+					//set mic key
+					_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+					_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+					psecuritypriv->busetkipkey = _TRUE;
+											
+				}
+				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+				{
+
+					DBG_871X("%s, set pairwise key, CCMP\n", __FUNCTION__);
+					
+					psta->dot118021XPrivacy = _AES_;
+				}
+				else
+				{
+					DBG_871X("%s, set pairwise key, none\n", __FUNCTION__);
+					
+					psta->dot118021XPrivacy = _NO_PRIVACY_;
+				}
+						
+				rtw_ap_set_pairwise_key(padapter, psta);
+					
+				psta->ieee8021x_blocked = _FALSE;
+				
+				psta->bpairwise_key_installed = _TRUE;
+					
+			}			
+			else//group key???
+			{ 
+				if(strcmp(param->u.crypt.alg, "WEP") == 0)
+				{
+					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					
+					psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+					if(param->u.crypt.key_len==13)
+					{						
+						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+					}
+				}
+				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+				{						
+					psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
+
+					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				
+					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
+					//set mic key
+					_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
+					_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
+
+					psecuritypriv->busetkipkey = _TRUE;
+											
+				}
+				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+				{
+					psecuritypriv->dot118021XGrpPrivacy = _AES_;
+
+					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				}
+				else
+				{
+					psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+				}
+
+				psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
+
+				psecuritypriv->binstallGrpkey = _TRUE;	
+								
+				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
+								
+				rtw_ap_set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
+			
+				pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
+				if(pbcmc_sta)
+				{
+					pbcmc_sta->ieee8021x_blocked = _FALSE;
+					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy			
+				}					
+
+			}
+			
+		}
+				
+	}
+
+exit:
+
+	if(pwep)
+	{
+		rtw_mfree((u8 *)pwep, wep_total_len);		
+	}	
+	
+	return ret;
+	
+}
+
+static int rtw_set_beacon(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret=0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	unsigned char *pbuf = param->u.bcn_ie.buf;
+
+
+	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+		return -EINVAL;
+
+	_rtw_memcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);
+
+	if((pstapriv->max_num_sta>NUM_STA) || (pstapriv->max_num_sta<=0))
+		pstapriv->max_num_sta = NUM_STA;
+
+
+	if(rtw_check_beacon_data(padapter, pbuf,  (len-12-2)) == _SUCCESS)// 12 = param header, 2:no packed
+		ret = 0;
+	else
+		ret = -EINVAL;
+	
+
+	return ret;
+	
+}
+
+static int rtw_hostapd_sta_flush(struct net_device *dev)
+{
+	//_irqL irqL;
+	//_list	*phead, *plist;
+	int ret=0;	
+	//struct sta_info *psta = NULL;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	//struct sta_priv *pstapriv = &padapter->stapriv;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	flush_all_cam_entry(padapter);	//clear CAM
+
+	ret = rtw_sta_flush(padapter, _TRUE);
+
+	return ret;
+
+}
+
+static int rtw_add_sta(struct net_device *dev, struct ieee_param *param)
+{
+	_irqL irqL;
+	int ret=0;	
+	struct sta_info *psta = NULL;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	DBG_871X("rtw_add_sta(aid=%d)=" MAC_FMT "\n", param->u.add_sta.aid, MAC_ARG(param->sta_addr));
+	
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)	
+	{
+		return -EINVAL;		
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		return -EINVAL;	
+	}
+
+/*
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if(psta)
+	{
+		DBG_871X("rtw_add_sta(), free has been added psta=%p\n", psta);
+		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		rtw_free_stainfo(padapter,  psta);		
+		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+
+		psta = NULL;
+	}	
+*/
+	//psta = rtw_alloc_stainfo(pstapriv, param->sta_addr);
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if(psta)
+	{
+		int flags = param->u.add_sta.flags;			
+		
+		//DBG_871X("rtw_add_sta(), init sta's variables, psta=%p\n", psta);
+		
+		psta->aid = param->u.add_sta.aid;//aid=1~2007
+
+		_rtw_memcpy(psta->bssrateset, param->u.add_sta.tx_supp_rates, 16);
+		
+		
+		//check wmm cap.
+		if(WLAN_STA_WME&flags)
+			psta->qos_option = 1;
+		else
+			psta->qos_option = 0;
+
+		if(pmlmepriv->qospriv.qos_option == 0)	
+			psta->qos_option = 0;
+
+		
+#ifdef CONFIG_80211N_HT		
+		//chec 802.11n ht cap.
+		if(WLAN_STA_HT&flags)
+		{
+			psta->htpriv.ht_option = _TRUE;
+			psta->qos_option = 1;
+			_rtw_memcpy((void*)&psta->htpriv.ht_cap, (void*)&param->u.add_sta.ht_cap, sizeof(struct rtw_ieee80211_ht_cap));
+		}
+		else		
+		{
+			psta->htpriv.ht_option = _FALSE;
+		}
+		
+		if(pmlmepriv->htpriv.ht_option == _FALSE)	
+			psta->htpriv.ht_option = _FALSE;
+#endif		
+
+
+		update_sta_info_apmode(padapter, psta);
+		
+		
+	}
+	else
+	{
+		ret = -ENOMEM;
+	}	
+	
+	return ret;
+	
+}
+
+static int rtw_del_sta(struct net_device *dev, struct ieee_param *param)
+{
+	_irqL irqL;
+	int ret=0;	
+	struct sta_info *psta = NULL;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	DBG_871X("rtw_del_sta=" MAC_FMT "\n", MAC_ARG(param->sta_addr));
+		
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)		
+	{
+		return -EINVAL;		
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		return -EINVAL;	
+	}
+
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if(psta)
+	{
+		u8 updated=_FALSE;
+	
+		//DBG_871X("free psta=%p, aid=%d\n", psta, psta->aid);
+
+		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		if(rtw_is_list_empty(&psta->asoc_list)==_FALSE)
+		{			
+			rtw_list_delete(&psta->asoc_list);
+			pstapriv->asoc_list_cnt--;
+			updated = ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_DEAUTH_LEAVING, _TRUE);
+
+		}
+		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		
+		associated_clients_update(padapter, updated, STA_INFO_UPDATE_ALL);
+	
+		psta = NULL;
+		
+	}
+	else
+	{
+		DBG_871X("rtw_del_sta(), sta has already been removed or never been added\n");
+		
+		//ret = -1;
+	}
+	
+	
+	return ret;
+	
+}
+
+static int rtw_ioctl_get_sta_data(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret=0;	
+	struct sta_info *psta = NULL;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct ieee_param_ex *param_ex = (struct ieee_param_ex *)param;
+	struct sta_data *psta_data = (struct sta_data *)param_ex->data;
+
+	DBG_871X("rtw_ioctl_get_sta_info, sta_addr: " MAC_FMT "\n", MAC_ARG(param_ex->sta_addr));
+
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)		
+	{
+		return -EINVAL;		
+	}
+
+	if (param_ex->sta_addr[0] == 0xff && param_ex->sta_addr[1] == 0xff &&
+	    param_ex->sta_addr[2] == 0xff && param_ex->sta_addr[3] == 0xff &&
+	    param_ex->sta_addr[4] == 0xff && param_ex->sta_addr[5] == 0xff) 
+	{
+		return -EINVAL;	
+	}
+
+	psta = rtw_get_stainfo(pstapriv, param_ex->sta_addr);
+	if(psta)
+	{
+#if 0
+		struct {
+			u16 aid;
+			u16 capability;
+			int flags;
+			u32 sta_set;
+			u8 tx_supp_rates[16];	
+			u32 tx_supp_rates_len;
+			struct rtw_ieee80211_ht_cap ht_cap;
+			u64	rx_pkts;
+			u64	rx_bytes;
+			u64	rx_drops;
+			u64	tx_pkts;
+			u64	tx_bytes;
+			u64	tx_drops;
+		} get_sta;		
+#endif
+		psta_data->aid = (u16)psta->aid;
+		psta_data->capability = psta->capability;
+		psta_data->flags = psta->flags;
+
+/*
+		nonerp_set : BIT(0)
+		no_short_slot_time_set : BIT(1)
+		no_short_preamble_set : BIT(2)
+		no_ht_gf_set : BIT(3)
+		no_ht_set : BIT(4)
+		ht_20mhz_set : BIT(5)
+*/
+
+		psta_data->sta_set =((psta->nonerp_set) |
+							(psta->no_short_slot_time_set <<1) |
+							(psta->no_short_preamble_set <<2) |
+							(psta->no_ht_gf_set <<3) |
+							(psta->no_ht_set <<4) |
+							(psta->ht_20mhz_set <<5));
+
+		psta_data->tx_supp_rates_len =  psta->bssratelen;
+		_rtw_memcpy(psta_data->tx_supp_rates, psta->bssrateset, psta->bssratelen);
+#ifdef CONFIG_80211N_HT
+		_rtw_memcpy(&psta_data->ht_cap, &psta->htpriv.ht_cap, sizeof(struct rtw_ieee80211_ht_cap));
+#endif //CONFIG_80211N_HT
+		psta_data->rx_pkts = psta->sta_stats.rx_data_pkts;
+		psta_data->rx_bytes = psta->sta_stats.rx_bytes;
+		psta_data->rx_drops = psta->sta_stats.rx_drops;
+
+		psta_data->tx_pkts = psta->sta_stats.tx_pkts;
+		psta_data->tx_bytes = psta->sta_stats.tx_bytes;
+		psta_data->tx_drops = psta->sta_stats.tx_drops;
+		
+
+	}
+	else
+	{
+		ret = -1;
+	}
+
+	return ret;
+
+}
+
+static int rtw_get_sta_wpaie(struct net_device *dev, struct ieee_param *param)
+{
+	int ret=0;	
+	struct sta_info *psta = NULL;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	DBG_871X("rtw_get_sta_wpaie, sta_addr: " MAC_FMT "\n", MAC_ARG(param->sta_addr));
+
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)		
+	{
+		return -EINVAL;		
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		return -EINVAL;	
+	}
+
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if(psta)
+	{
+		if((psta->wpa_ie[0] == WLAN_EID_RSN) || (psta->wpa_ie[0] == WLAN_EID_GENERIC))
+		{
+			int wpa_ie_len;
+			int copy_len;
+
+			wpa_ie_len = psta->wpa_ie[1];
+			
+			copy_len = ((wpa_ie_len+2) > sizeof(psta->wpa_ie)) ? (sizeof(psta->wpa_ie)):(wpa_ie_len+2);
+				
+			param->u.wpa_ie.len = copy_len;
+
+			_rtw_memcpy(param->u.wpa_ie.reserved, psta->wpa_ie, copy_len);
+		}
+		else
+		{
+			//ret = -1;
+			DBG_871X("sta's wpa_ie is NONE\n");
+		}		
+	}
+	else
+	{
+		ret = -1;
+	}
+
+	return ret;
+
+}
+
+static int rtw_set_wps_beacon(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret=0;
+	unsigned char wps_oui[4]={0x0,0x50,0xf2,0x04};
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	int ie_len;
+
+	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+		return -EINVAL;
+
+	ie_len = len-12-2;// 12 = param header, 2:no packed
+
+
+	if(pmlmepriv->wps_beacon_ie)
+	{
+		rtw_mfree(pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len);
+		pmlmepriv->wps_beacon_ie = NULL;			
+	}	
+
+	if(ie_len>0)
+	{
+		pmlmepriv->wps_beacon_ie = rtw_malloc(ie_len);
+		pmlmepriv->wps_beacon_ie_len = ie_len;
+		if ( pmlmepriv->wps_beacon_ie == NULL) {
+			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+			return -EINVAL;
+		}
+
+		_rtw_memcpy(pmlmepriv->wps_beacon_ie, param->u.bcn_ie.buf, ie_len);
+
+		update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, _TRUE);
+		
+		pmlmeext->bstart_bss = _TRUE;
+		
+	}
+	
+	
+	return ret;		
+
+}
+
+static int rtw_set_wps_probe_resp(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret=0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	int ie_len;
+
+	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+		return -EINVAL;
+
+	ie_len = len-12-2;// 12 = param header, 2:no packed
+
+
+	if(pmlmepriv->wps_probe_resp_ie)
+	{
+		rtw_mfree(pmlmepriv->wps_probe_resp_ie, pmlmepriv->wps_probe_resp_ie_len);
+		pmlmepriv->wps_probe_resp_ie = NULL;			
+	}	
+
+	if(ie_len>0)
+	{
+		pmlmepriv->wps_probe_resp_ie = rtw_malloc(ie_len);
+		pmlmepriv->wps_probe_resp_ie_len = ie_len;
+		if ( pmlmepriv->wps_probe_resp_ie == NULL) {
+			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+			return -EINVAL;
+		}
+		_rtw_memcpy(pmlmepriv->wps_probe_resp_ie, param->u.bcn_ie.buf, ie_len);		
+	}
+	
+	
+	return ret;
+
+}
+
+static int rtw_set_wps_assoc_resp(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret=0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	int ie_len;
+
+	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+		return -EINVAL;
+
+	ie_len = len-12-2;// 12 = param header, 2:no packed
+
+
+	if(pmlmepriv->wps_assoc_resp_ie)
+	{
+		rtw_mfree(pmlmepriv->wps_assoc_resp_ie, pmlmepriv->wps_assoc_resp_ie_len);
+		pmlmepriv->wps_assoc_resp_ie = NULL;			
+	}	
+
+	if(ie_len>0)
+	{
+		pmlmepriv->wps_assoc_resp_ie = rtw_malloc(ie_len);
+		pmlmepriv->wps_assoc_resp_ie_len = ie_len;
+		if ( pmlmepriv->wps_assoc_resp_ie == NULL) {
+			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+			return -EINVAL;
+		}
+		
+		_rtw_memcpy(pmlmepriv->wps_assoc_resp_ie, param->u.bcn_ie.buf, ie_len);		
+	}
+	
+	
+	return ret;
+
+}
+
+static int rtw_set_hidden_ssid(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret=0;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *mlmepriv = &(adapter->mlmepriv);
+	struct mlme_ext_priv	*mlmeext = &(adapter->mlmeextpriv);
+	struct mlme_ext_info	*mlmeinfo = &(mlmeext->mlmext_info);
+	int ie_len;
+	u8 *ssid_ie;
+	char ssid[NDIS_802_11_LENGTH_SSID + 1];
+	sint ssid_len = 0;
+	u8 ignore_broadcast_ssid;
+
+	if(check_fwstate(mlmepriv, WIFI_AP_STATE) != _TRUE)
+		return -EPERM;
+
+	if (param->u.bcn_ie.reserved[0] != 0xea)
+		return -EINVAL;
+
+	mlmeinfo->hidden_ssid_mode = ignore_broadcast_ssid = param->u.bcn_ie.reserved[1];
+
+	ie_len = len-12-2;// 12 = param header, 2:no packed
+	ssid_ie = rtw_get_ie(param->u.bcn_ie.buf,  WLAN_EID_SSID, &ssid_len, ie_len);
+
+	if (ssid_ie && ssid_len > 0 && ssid_len <= NDIS_802_11_LENGTH_SSID) {
+		WLAN_BSSID_EX *pbss_network = &mlmepriv->cur_network.network;
+		WLAN_BSSID_EX *pbss_network_ext = &mlmeinfo->network;
+
+		_rtw_memcpy(ssid, ssid_ie+2, ssid_len);
+		ssid[ssid_len] = 0x0;
+
+		if(0)
+			DBG_871X(FUNC_ADPT_FMT" ssid:(%s,%d), from ie:(%s,%d), (%s,%d)\n", FUNC_ADPT_ARG(adapter),
+				ssid, ssid_len,
+				pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength,
+				pbss_network_ext->Ssid.Ssid, pbss_network_ext->Ssid.SsidLength);
+
+		_rtw_memcpy(pbss_network->Ssid.Ssid, (void *)ssid, ssid_len);
+		pbss_network->Ssid.SsidLength = ssid_len;
+		_rtw_memcpy(pbss_network_ext->Ssid.Ssid, (void *)ssid, ssid_len);
+		pbss_network_ext->Ssid.SsidLength = ssid_len;
+
+		if(0)
+			DBG_871X(FUNC_ADPT_FMT" after ssid:(%s,%d), (%s,%d)\n", FUNC_ADPT_ARG(adapter),
+				pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength,
+				pbss_network_ext->Ssid.Ssid, pbss_network_ext->Ssid.SsidLength);
+	}
+
+	DBG_871X(FUNC_ADPT_FMT" ignore_broadcast_ssid:%d, %s,%d\n", FUNC_ADPT_ARG(adapter),
+		ignore_broadcast_ssid, ssid, ssid_len);
+
+	return ret;
+}
+
+static int rtw_ioctl_acl_remove_sta(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret=0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+		return -EINVAL;
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		return -EINVAL;	
+	}
+
+	ret = rtw_acl_remove_sta(padapter, param->sta_addr);	
+
+	return ret;		
+
+}
+
+static int rtw_ioctl_acl_add_sta(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret=0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+		return -EINVAL;
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		return -EINVAL;	
+	}
+
+	ret = rtw_acl_add_sta(padapter, param->sta_addr);	
+
+	return ret;		
+
+}
+
+static int rtw_ioctl_set_macaddr_acl(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret=0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+		return -EINVAL;	
+	
+	rtw_set_macaddr_acl(padapter, param->u.mlme.command);	
+
+	return ret;
+}
+
+static int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)
+{
+	struct ieee_param *param;
+	int ret=0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	//DBG_871X("%s\n", __FUNCTION__);
+
+	/*
+	* this function is expect to call in master mode, which allows no power saving
+	* so, we just check hw_init_completed
+	*/
+
+	if (!rtw_is_hw_init_completed(padapter)) {
+		ret = -EPERM;
+		goto out;
+	}
+
+
+	//if (p->length < sizeof(struct ieee_param) || !p->pointer){
+	if(!p->pointer){
+		ret = -EINVAL;
+		goto out;
+	}
+	
+	param = (struct ieee_param *)rtw_malloc(p->length);
+	if (param == NULL)
+	{
+		ret = -ENOMEM;
+		goto out;
+	}
+	
+	if (copy_from_user(param, p->pointer, p->length))
+	{
+		rtw_mfree((u8*)param, p->length);
+		ret = -EFAULT;
+		goto out;
+	}
+
+	//DBG_871X("%s, cmd=%d\n", __FUNCTION__, param->cmd);
+
+	switch (param->cmd) 
+	{	
+		case RTL871X_HOSTAPD_FLUSH:
+
+			ret = rtw_hostapd_sta_flush(dev);
+
+			break;
+	
+		case RTL871X_HOSTAPD_ADD_STA:	
+			
+			ret = rtw_add_sta(dev, param);					
+			
+			break;
+
+		case RTL871X_HOSTAPD_REMOVE_STA:
+
+			ret = rtw_del_sta(dev, param);
+
+			break;
+	
+		case RTL871X_HOSTAPD_SET_BEACON:
+
+			ret = rtw_set_beacon(dev, param, p->length);
+
+			break;
+			
+		case RTL871X_SET_ENCRYPTION:
+
+			ret = rtw_set_encryption(dev, param, p->length);
+			
+			break;
+			
+		case RTL871X_HOSTAPD_GET_WPAIE_STA:
+
+			ret = rtw_get_sta_wpaie(dev, param);
+	
+			break;
+			
+		case RTL871X_HOSTAPD_SET_WPS_BEACON:
+
+			ret = rtw_set_wps_beacon(dev, param, p->length);
+
+			break;
+
+		case RTL871X_HOSTAPD_SET_WPS_PROBE_RESP:
+
+			ret = rtw_set_wps_probe_resp(dev, param, p->length);
+			
+	 		break;
+			
+		case RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP:
+
+			ret = rtw_set_wps_assoc_resp(dev, param, p->length);
+			
+	 		break;
+
+		case RTL871X_HOSTAPD_SET_HIDDEN_SSID:
+
+			ret = rtw_set_hidden_ssid(dev, param, p->length);
+
+			break;
+
+		case RTL871X_HOSTAPD_GET_INFO_STA:
+
+			ret = rtw_ioctl_get_sta_data(dev, param, p->length);
+
+			break;
+			
+		case RTL871X_HOSTAPD_SET_MACADDR_ACL:
+
+			ret = rtw_ioctl_set_macaddr_acl(dev, param, p->length);
+
+			break;
+
+		case RTL871X_HOSTAPD_ACL_ADD_STA:
+
+			ret = rtw_ioctl_acl_add_sta(dev, param, p->length);
+
+			break;
+
+		case RTL871X_HOSTAPD_ACL_REMOVE_STA:
+
+			ret = rtw_ioctl_acl_remove_sta(dev, param, p->length);
+
+			break;
+			
+		default:
+			DBG_871X("Unknown hostapd request: %d\n", param->cmd);
+			ret = -EOPNOTSUPP;
+			break;
+		
+	}
+
+	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
+		ret = -EFAULT;
+
+
+	rtw_mfree((u8 *)param, p->length);
+	
+out:
+		
+	return ret;
+	
+}
+#endif
+
+static int rtw_wx_set_priv(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *awrq,
+				char *extra)
+{
+
+#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	char *ext_dbg;
+#endif
+
+	int ret = 0;
+	int len = 0;
+	char *ext;
+	int i;
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct iw_point *dwrq = (struct iw_point*)awrq;
+
+	//RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+rtw_wx_set_priv\n"));
+	if(dwrq->length == 0)
+		return -EFAULT;
+	
+	len = dwrq->length;
+	if (!(ext = rtw_vmalloc(len)))
+		return -ENOMEM;
+
+	if (copy_from_user(ext, dwrq->pointer, len)) {
+		rtw_vmfree(ext, len);
+		return -EFAULT;
+	}
+
+
+	//RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+	//	 ("rtw_wx_set_priv: %s req=%s\n",
+	//	  dev->name, ext));
+
+	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV	
+	if (!(ext_dbg = rtw_vmalloc(len)))
+	{
+		rtw_vmfree(ext, len);
+		return -ENOMEM;
+	}	
+	
+	_rtw_memcpy(ext_dbg, ext, len);
+	#endif
+
+	//added for wps2.0 @20110524
+	if(dwrq->flags == 0x8766 && len > 8)
+	{
+		u32 cp_sz;		
+		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+		u8 *probereq_wpsie = ext;
+		int probereq_wpsie_len = len;
+		u8 wps_oui[4]={0x0,0x50,0xf2,0x04};		
+	
+		if((_VENDOR_SPECIFIC_IE_ == probereq_wpsie[0]) &&
+			(_rtw_memcmp(&probereq_wpsie[2], wps_oui, 4) ==_TRUE))
+		{
+			cp_sz = probereq_wpsie_len>MAX_WPS_IE_LEN ? MAX_WPS_IE_LEN:probereq_wpsie_len;
+
+			if(pmlmepriv->wps_probe_req_ie)
+			{
+				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
+				pmlmepriv->wps_probe_req_ie_len = 0;
+				rtw_mfree(pmlmepriv->wps_probe_req_ie, free_len);
+				pmlmepriv->wps_probe_req_ie = NULL;			
+			}	
+
+			pmlmepriv->wps_probe_req_ie = rtw_malloc(cp_sz);
+			if ( pmlmepriv->wps_probe_req_ie == NULL) {
+				printk("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+				ret =  -EINVAL;
+				goto FREE_EXT;
+			
+			}
+			
+			_rtw_memcpy(pmlmepriv->wps_probe_req_ie, probereq_wpsie, cp_sz);
+			pmlmepriv->wps_probe_req_ie_len = cp_sz;					
+			
+		}	
+		
+		goto FREE_EXT;
+		
+	}
+
+	if(	len >= WEXT_CSCAN_HEADER_SIZE
+		&& _rtw_memcmp(ext, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == _TRUE
+	){
+		ret = rtw_wx_set_scan(dev, info, awrq, ext);
+		goto FREE_EXT;
+	}
+	
+#ifdef CONFIG_ANDROID
+	//DBG_871X("rtw_wx_set_priv: %s req=%s\n", dev->name, ext);
+
+	i = rtw_android_cmdstr_to_num(ext);
+
+	switch(i) {
+		case ANDROID_WIFI_CMD_START :
+			indicate_wx_custom_event(padapter, "START");
+			break;
+		case ANDROID_WIFI_CMD_STOP :
+			indicate_wx_custom_event(padapter, "STOP");
+			break;
+		case ANDROID_WIFI_CMD_RSSI :
+			{
+				struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+				struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
+
+				if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+					sprintf(ext, "%s rssi %d", pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
+				} else {
+					sprintf(ext, "OK");
+				}
+			}
+			break;
+		case ANDROID_WIFI_CMD_LINKSPEED :
+			{
+				u16 mbps = rtw_get_cur_max_rate(padapter)/10;
+				sprintf(ext, "LINKSPEED %d", mbps);
+			}
+			break;
+		case ANDROID_WIFI_CMD_MACADDR :
+			sprintf(ext, "MACADDR = " MAC_FMT, MAC_ARG(dev->dev_addr));
+			break;
+		case ANDROID_WIFI_CMD_SCAN_ACTIVE :
+			{
+				//rtw_set_scan_mode(padapter, SCAN_ACTIVE);
+				sprintf(ext, "OK");
+			}
+			break;
+		case ANDROID_WIFI_CMD_SCAN_PASSIVE :
+			{
+				//rtw_set_scan_mode(padapter, SCAN_PASSIVE);
+				sprintf(ext, "OK");
+			}
+			break;
+
+		case ANDROID_WIFI_CMD_COUNTRY :
+			{
+				char country_code[10];
+				sscanf(ext, "%*s %s", country_code);
+				rtw_set_country(padapter, country_code);
+				sprintf(ext, "OK");
+			}
+			break;
+		default :
+			#ifdef  CONFIG_DEBUG_RTW_WX_SET_PRIV
+			DBG_871X("%s: %s unknowned req=%s\n", __FUNCTION__,
+				dev->name, ext_dbg);
+			#endif
+
+			sprintf(ext, "OK");
+		
+	}
+
+	if (copy_to_user(dwrq->pointer, ext, min(dwrq->length, (u16)(strlen(ext)+1)) ) )
+		ret = -EFAULT;
+
+	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	DBG_871X("%s: %s req=%s rep=%s dwrq->length=%d, strlen(ext)+1=%d\n", __FUNCTION__,
+		dev->name, ext_dbg ,ext, dwrq->length, (u16)(strlen(ext)+1));
+	#endif
+#endif //end of CONFIG_ANDROID
+
+
+FREE_EXT:
+
+	rtw_vmfree(ext, len);
+	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	rtw_vmfree(ext_dbg, len);
+	#endif
+
+	//DBG_871X("rtw_wx_set_priv: (SIOCSIWPRIV) %s ret=%d\n", 
+	//		dev->name, ret);
+
+	return ret;
+	
+}
+#ifdef CONFIG_WOWLAN
+static int rtw_wowlan_ctrl(struct net_device *dev,
+						struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter =  (_adapter *)rtw_netdev_priv(dev);
+	struct wowlan_ioctl_param poidparam;
+	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct net_device *pnetdev = padapter->pnetdev;
+#ifdef CONFIG_CONCURRENT_MODE
+	struct net_device *pbuddy_netdev = padapter->pbuddy_adapter->pnetdev;	
+#endif
+	struct sta_info	*psta = NULL;
+	int ret = 0;
+	u32 start_time = rtw_get_current_time();
+	poidparam.subcode = 0;
+
+	DBG_871X("+rtw_wowlan_ctrl: %s\n", extra);
+	
+	if (!check_fwstate(pmlmepriv, _FW_LINKED) && 
+			check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+#ifdef CONFIG_PNO_SUPPORT
+			pwrctrlpriv->wowlan_pno_enable = _TRUE;
+#else
+			DBG_871X("[%s] WARNING: Please Connect With AP First!!\n", __func__);
+			goto _rtw_wowlan_ctrl_exit_free;
+#endif //CONFIG_PNO_SUPPORT
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))
+		rtw_scan_abort(padapter);
+
+	if (_rtw_memcmp(extra, "enable", 6)) {
+
+		padapter->registrypriv.mp_mode = 1;
+
+		rtw_suspend_common(padapter);
+
+	} else if (_rtw_memcmp(extra, "disable", 7)) {
+#ifdef CONFIG_USB_HCI
+		RTW_ENABLE_FUNC(padapter, DF_RX_BIT);
+		RTW_ENABLE_FUNC(padapter, DF_TX_BIT);
+#endif
+		rtw_resume_common(padapter);
+
+#ifdef CONFIG_PNO_SUPPORT
+		pwrctrlpriv->wowlan_pno_enable = _FALSE;
+#endif //CONFIG_PNO_SUPPORT
+
+		padapter->registrypriv.mp_mode = 0;
+	} else {
+		DBG_871X("[%s] Invalid Parameter.\n", __func__);
+		goto _rtw_wowlan_ctrl_exit_free;
+	}
+	//mutex_lock(&ioctl_mutex);
+_rtw_wowlan_ctrl_exit_free:
+	DBG_871X("-rtw_wowlan_ctrl( subcode = %d)\n", poidparam.subcode);
+	DBG_871X_LEVEL(_drv_always_, "%s in %d ms\n", __func__,
+			rtw_get_passing_time_ms(start_time));
+_rtw_wowlan_ctrl_exit:
+	return ret;
+}
+
+static bool rtw_wowlan_parser_pattern_cmd(u8 *input, char *pattern,
+					  int *pattern_len, char *bit_mask)
+{
+	char *cp = NULL, *end = NULL;
+	size_t len = 0;
+	int pos = 0, temp = 0, mask_pos = 0, res = 0;
+	u8 member[2] = {0};
+
+	cp = strchr(input, '=');
+	if (cp) {
+		*cp = 0;
+		cp++;
+	}
+
+	input = cp;
+
+	while (1) {
+		cp = strchr(input, ':');
+
+		if (cp) {
+			len = strlen(input) - strlen(cp);
+			*cp = 0;
+			cp++;
+		} else {
+			len = 2;
+		}
+
+		if (bit_mask && (strcmp(input, "-") == 0 ||
+				 strcmp(input, "xx") == 0 ||
+				 strcmp(input, "--") == 0)) {
+			/* skip this byte and leave mask bit unset */
+		} else {
+			strncpy(member, input, len);
+			if (!rtw_check_pattern_valid(member, sizeof(member))) {
+				DBG_871X("%s:[ERROR] pattern is invalid!!\n",
+					 __func__);
+				goto error;
+			}
+			res = sscanf(member, "%02x", &temp);
+			if (temp < 0 || temp > 256)
+				goto error;
+			pattern[pos] = temp;
+			mask_pos = pos / 8;
+			if (bit_mask)
+				bit_mask[mask_pos] |= 1 << (pos % 8);
+		}
+
+		pos++;
+		if (!cp)
+			break;
+		input = cp;
+	}
+
+	(*pattern_len) = pos;
+
+	return _TRUE;
+error:
+	return _FALSE;
+}
+
+/*
+ * IP filter This pattern if for a frame containing a ip packet:
+ * AA:AA:AA:AA:AA:AA:BB:BB:BB:BB:BB:BB:CC:CC:DD:-:-:-:-:-:-:-:-:EE:-:-:FF:FF:FF:FF:GG:GG:GG:GG:HH:HH:II:II
+ *
+ * A: Ethernet destination address
+ * B: Ethernet source address
+ * C: Ethernet protocol type
+ * D: IP header VER+Hlen, use: 0x45 (4 is for ver 4, 5 is for len 20)
+ * E: IP protocol
+ * F: IP source address ( 192.168.0.4: C0:A8:00:2C )
+ * G: IP destination address ( 192.168.0.4: C0:A8:00:2C )
+ * H: Source port (1024: 04:00)
+ * I: Destination port (1024: 04:00) 
+ */
+
+static int rtw_wowlan_set_pattern(struct net_device *dev,
+				  struct iw_request_info *info,
+				  union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter =  (_adapter *)rtw_netdev_priv(dev);
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wowlan_ioctl_param poidparam;
+	int ret = 0, len = 0, i = 0;
+	u32 start_time = rtw_get_current_time();
+	u8 input[wrqu->data.length];
+	u8 index = 0;
+
+	poidparam.subcode = 0;
+
+	if (!check_fwstate(pmlmepriv, _FW_LINKED) &&
+			check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+		ret = -EFAULT;
+		DBG_871X("Please Connect With AP First!!\n");
+		goto _rtw_wowlan_set_pattern_exit;
+	}
+
+	if (wrqu->data.length <= 0) {
+		ret = -EFAULT;
+		DBG_871X("ERROR: parameter length <= 0\n");
+		goto _rtw_wowlan_set_pattern_exit;
+	} else {
+		/* set pattern */
+		if (copy_from_user(input,
+				   wrqu->data.pointer, wrqu->data.length))
+			return -EFAULT;
+		/* leave PS first */
+		rtw_ps_deny(padapter, PS_DENY_IOCTL);
+		LeaveAllPowerSaveModeDirect(padapter);
+		if (strncmp(input, "pattern=", 8) == 0) {
+			if (pwrpriv->wowlan_pattern_idx >= MAX_WKFM_NUM) {
+				DBG_871X("WARNING: priv-pattern is full(%d)\n",
+						MAX_WKFM_NUM);
+				DBG_871X("WARNING: please clean priv-pattern first\n");
+				ret = -EINVAL;
+				goto _rtw_wowlan_set_pattern_exit;
+			} else {
+				index = pwrpriv->wowlan_pattern_idx;
+
+				ret = rtw_wowlan_parser_pattern_cmd(input,
+					pwrpriv->patterns[index].content,
+					&pwrpriv->patterns[index].len,
+					pwrpriv->patterns[index].mask);
+
+				if (ret) {
+					pwrpriv->wowlan_pattern_idx++;
+					pwrpriv->wowlan_pattern = _TRUE;
+				} else {
+					goto _rtw_wowlan_set_pattern_exit;
+				}
+			}
+		} else if (strncmp(input, "clean", 5) == 0) {
+			poidparam.subcode = WOWLAN_PATTERN_CLEAN;
+			rtw_hal_set_hwreg(padapter,
+					HW_VAR_WOWLAN, (u8 *)&poidparam);
+			pwrpriv->wowlan_pattern = _FALSE;
+		} else if (strncmp(input, "show", 4) == 0) {
+			for (i = 0 ; i < MAX_WKFM_NUM ; i++) {
+				DBG_871X("=======[%d]=======\n", i);
+				rtw_read_from_frame_mask(padapter, i);
+			}
+
+			DBG_871X("********[RTK priv-patterns]*********\n");
+			for (i = 0 ; i < MAX_WKFM_NUM ; i++)
+				rtw_dump_priv_pattern(padapter, i);
+		} else {
+			DBG_871X("ERROR: incorrect parameter!\n");
+			ret = -EINVAL;
+		}
+		rtw_ps_deny_cancel(padapter, PS_DENY_IOCTL);
+	}
+_rtw_wowlan_set_pattern_exit:
+	return ret;
+}
+#endif //CONFIG_WOWLAN
+
+#ifdef CONFIG_AP_WOWLAN
+static int rtw_ap_wowlan_ctrl(struct net_device *dev,
+						struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter =  (_adapter *)rtw_netdev_priv(dev);
+	struct wowlan_ioctl_param poidparam;
+	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct sta_info	*psta = NULL;
+	int ret = 0;
+	u32 start_time = rtw_get_current_time();
+	poidparam.subcode = 0;
+
+	DBG_871X("+rtw_ap_wowlan_ctrl: %s\n", extra);
+
+#ifndef CONFIG_USB_HCI
+	if(pwrctrlpriv->bSupportRemoteWakeup==_FALSE){
+		ret = -EPERM;
+		DBG_871X("+rtw_wowlan_ctrl: Device didn't support the remote wakeup!!\n");
+		goto _rtw_ap_wowlan_ctrl_exit_free;
+	}
+#endif
+
+	if (!check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		DBG_871X("[%s] It is not AP mode!!\n", __func__);
+		goto _rtw_ap_wowlan_ctrl_exit_free;
+	}
+
+	if (_rtw_memcmp(extra, "enable", 6)) {
+
+		pwrctrlpriv->wowlan_ap_mode = _TRUE;
+
+		rtw_suspend_common(padapter);
+	} else if (_rtw_memcmp(extra, "disable", 7)) {
+#ifdef CONFIG_USB_HCI
+		RTW_ENABLE_FUNC(padapter, DF_RX_BIT);
+		RTW_ENABLE_FUNC(padapter, DF_TX_BIT);
+#endif
+		rtw_resume_common(padapter);
+	} else {
+		DBG_871X("[%s] Invalid Parameter.\n", __func__);
+		goto _rtw_ap_wowlan_ctrl_exit_free;
+	}
+	//mutex_lock(&ioctl_mutex);
+_rtw_ap_wowlan_ctrl_exit_free:
+	DBG_871X("-rtw_ap_wowlan_ctrl( subcode = %d)\n", poidparam.subcode);
+	DBG_871X_LEVEL(_drv_always_, "%s in %d ms\n", __func__,
+			rtw_get_passing_time_ms(start_time));
+_rtw_ap_wowlan_ctrl_exit:
+	return ret;
+}
+#endif //CONFIG_AP_WOWLAN
+
+static int rtw_pm_set(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	unsigned	mode = 0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	DBG_871X( "[%s] extra = %s\n", __FUNCTION__, extra );
+
+	if ( _rtw_memcmp( extra, "lps=", 4 ) )
+	{
+		sscanf(extra+4, "%u", &mode);	
+		ret = rtw_pm_set_lps(padapter,mode);
+	}
+	else if ( _rtw_memcmp( extra, "ips=", 4 ) )
+	{
+		sscanf(extra+4, "%u", &mode);
+		ret = rtw_pm_set_ips(padapter,mode);
+	}
+	else{
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int rtw_mp_efuse_get(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wdata, char *extra)
+{
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	
+	PEFUSE_HAL pEfuseHal;
+	struct iw_point *wrqu;
+	
+	u8	*PROMContent = pHalData->efuse_eeprom_data;
+	u8 ips_mode = IPS_NUM; // init invalid value
+	u8 lps_mode = PS_MODE_NUM; // init invalid value
+	struct pwrctrl_priv *pwrctrlpriv ;
+	u8 *data = NULL;
+	u8 *rawdata = NULL;
+	char *pch, *ptmp, *token, *tmp[3]={0x00,0x00,0x00};
+	u16 i=0, j=0, mapLen=0, addr=0, cnts=0;
+	u16 max_available_len = 0, raw_cursize = 0, raw_maxsize = 0;
+	int err;
+	#ifdef CONFIG_IOL
+	u8 org_fw_iol = padapter->registrypriv.fw_iol;// 0:Disable, 1:enable, 2:by usb speed
+	#endif
+	
+	wrqu = (struct iw_point*)wdata;
+	pwrctrlpriv = adapter_to_pwrctl(padapter);
+	pEfuseHal = &pHalData->EfuseHal;
+
+	err = 0;
+	data = rtw_zmalloc(EFUSE_BT_MAX_MAP_LEN);
+	if (data == NULL)
+	{
+		err = -ENOMEM;
+		goto exit;
+	}
+	rawdata = rtw_zmalloc(EFUSE_BT_MAX_MAP_LEN);
+	if (rawdata == NULL)
+	{
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	if (copy_from_user(extra, wrqu->pointer, wrqu->length))
+	{
+		err = -EFAULT;
+		goto exit;
+	}
+	#ifdef CONFIG_LPS
+	lps_mode = pwrctrlpriv->power_mgnt;//keep org value
+	rtw_pm_set_lps(padapter,PS_MODE_ACTIVE);
+	#endif	
+	
+	#ifdef CONFIG_IPS	
+	ips_mode = pwrctrlpriv->ips_mode;//keep org value
+	rtw_pm_set_ips(padapter,IPS_NONE);
+	#endif	
+	
+	pch = extra;
+	DBG_871X("%s: in=%s\n", __FUNCTION__, extra);
+
+	i = 0;
+	//mac 16 "00e04c871200" rmap,00,2
+	while ((token = strsep(&pch, ",")) != NULL)
+	{
+		if (i > 2) break;
+		tmp[i] = token;
+		i++;
+	}
+	#ifdef CONFIG_IOL
+	padapter->registrypriv.fw_iol = 0;// 0:Disable, 1:enable, 2:by usb speed
+	#endif
+	
+	if(strcmp(tmp[0], "status") == 0){
+		sprintf(extra, "Load File efuse=%s,Load File MAC=%s"
+			, pHalData->efuse_file_status == EFUSE_FILE_FAILED ? "FAIL" : "OK"
+			, pHalData->macaddr_file_status == MACADDR_FILE_FAILED ? "FAIL" : "OK"
+		);
+		  goto exit;
+	}
+	else if (strcmp(tmp[0], "drvmap") == 0)
+	{
+		mapLen = EFUSE_MAP_SIZE;
+		
+		sprintf(extra, "\n");
+		for (i = 0; i < EFUSE_MAP_SIZE; i += 16)
+		{
+//			DBG_871X("0x%02x\t", i);
+			sprintf(extra, "%s0x%02x\t", extra, i);
+			for (j=0; j<8; j++) {
+//				DBG_871X("%02X ", data[i+j]);
+				sprintf(extra, "%s%02X ", extra, PROMContent[i+j]);
+			}
+//			DBG_871X("\t");
+			sprintf(extra, "%s\t", extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", data[i+j]);
+				sprintf(extra, "%s%02X ", extra, PROMContent[i+j]);
+			}
+//			DBG_871X("\n");
+			sprintf(extra,"%s\n",extra);
+		}
+//		DBG_871X("\n");
+	}
+	else if (strcmp(tmp[0], "realmap") == 0)
+	{
+		mapLen = EFUSE_MAP_SIZE;
+		if (rtw_efuse_mask_map_read(padapter, EFUSE_WIFI , mapLen, pEfuseHal->fakeEfuseInitMap) == _FAIL)
+		{
+			DBG_871X("%s: read realmap Fail!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+
+//		DBG_871X("OFFSET\tVALUE(hex)\n");
+		sprintf(extra, "\n");
+		for (i = 0; i < EFUSE_MAP_SIZE; i += 16)
+		{
+//			DBG_871X("0x%02x\t", i);
+			sprintf(extra, "%s0x%02x\t", extra, i);
+			for (j=0; j<8; j++) {
+//				DBG_871X("%02X ", data[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeEfuseInitMap[i+j]);
+			}
+//			DBG_871X("\t");
+			sprintf(extra, "%s\t", extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", data[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeEfuseInitMap[i+j]);
+			}
+//			DBG_871X("\n");
+			sprintf(extra,"%s\n",extra);
+		}
+//		DBG_871X("\n");
+	}
+	else if (strcmp(tmp[0], "rmap") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			DBG_871X("%s: rmap Fail!! Parameters error!\n", __FUNCTION__);
+			err = -EINVAL;
+			goto exit;
+		}
+
+		// rmap addr cnts
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+		DBG_871X("%s: addr=%x\n", __FUNCTION__, addr);
+
+		cnts = simple_strtoul(tmp[2], &ptmp, 10);
+		if (cnts == 0)
+		{
+			DBG_871X("%s: rmap Fail!! cnts error!\n", __FUNCTION__);
+			err = -EINVAL;
+			goto exit;
+		}
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN , (PVOID)&max_available_len, _FALSE);
+		if ((addr + cnts) > max_available_len)
+		{
+			DBG_871X("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EINVAL;
+			goto exit;
+		}
+
+		if (rtw_efuse_mask_map_read(padapter, addr, cnts, data) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_mask_map_read error!\n", __func__);
+			err = -EFAULT;
+			goto exit;
+		}
+
+//		DBG_871X("%s: data={", __FUNCTION__);
+		*extra = 0;
+		for (i=0; i<cnts; i++) {
+//			DBG_871X("0x%02x ", data[i]);
+			sprintf(extra, "%s0x%02X ", extra, data[i]);
+		}
+//		DBG_871X("}\n");
+	}
+	else if (strcmp(tmp[0], "realraw") == 0)
+	{
+		addr = 0;
+		mapLen = EFUSE_MAX_SIZE;
+		DBG_871X("EFUSE_MAX_SIZE = %d\n", EFUSE_MAX_SIZE);
+
+		if (rtw_efuse_access(padapter, _FALSE, addr, mapLen, rawdata) == _FAIL) {
+			DBG_871X("%s: rtw_efuse_access Fail!!\n", __func__);
+			err = -EFAULT;
+			goto exit;
+		}
+
+		if (mapLen >= 512)
+			mapLen = 512;
+
+		_rtw_memset(extra,'\0',strlen(extra));
+
+		sprintf(extra, "\n0x00\t");
+
+		for (i = 0; i < mapLen ; i++) {
+			sprintf(extra, "%s%02X", extra, rawdata[i]);
+			if ((i & 0xF) == 0xF) {
+				sprintf(extra, "%s\n", extra);
+				sprintf(extra, "%s0x%02x\t", extra, i+1);
+			} else if ((i & 0x7) == 0x7) {
+				sprintf(extra, "%s \t", extra);
+			} else {
+				sprintf(extra, "%s ", extra);
+			}
+		}
+
+	} else if (strcmp(tmp[0], "realrawb") == 0) {
+		addr = 0;
+		mapLen = EFUSE_MAX_SIZE;
+		DBG_871X("EFUSE_MAX_SIZE =%d\n", EFUSE_MAX_SIZE);
+		if (rtw_efuse_access(padapter, _FALSE, addr, mapLen, rawdata) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_access Fail!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+		_rtw_memset(extra,'\0',strlen(extra));
+		//		DBG_871X("%s: realraw={\n", __FUNCTION__);
+				sprintf(extra, "\n0x00\t");
+				for (i= 512; i< mapLen; i++)
+				{
+		//			DBG_871X("%02X", rawdata[i]);
+					sprintf(extra, "%s%02X", extra, rawdata[i]);
+					if ((i & 0xF) == 0xF) {
+		//				DBG_871X("\n");
+						sprintf(extra, "%s\n", extra);
+						sprintf(extra, "%s0x%02x\t", extra, i+1);
+					}
+					else if ((i & 0x7) == 0x7){
+		//				DBG_871X("\t");
+						sprintf(extra, "%s \t", extra);
+					} else {
+		//				DBG_871X(" ");
+						sprintf(extra, "%s ", extra);
+					}
+				}
+		//		DBG_871X("}\n");
+	}
+	else if (strcmp(tmp[0], "mac") == 0)
+	{		
+		if (hal_efuse_macaddr_offset(padapter) == -1) {
+			err = -EFAULT;
+			goto exit;
+		}
+
+		addr = hal_efuse_macaddr_offset(padapter);
+		cnts = 6;
+
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (PVOID)&max_available_len, _FALSE);
+		if ((addr + cnts) > max_available_len) {
+			DBG_871X("%s: addr(0x%02x)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
+		}
+
+		if (rtw_efuse_mask_map_read(padapter, addr, cnts, data) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_mask_map_read error!\n", __func__);
+			err = -EFAULT;
+			goto exit;
+		}
+
+//		DBG_871X("%s: MAC address={", __FUNCTION__);
+		*extra = 0;
+		for (i=0; i<cnts; i++)
+		{
+//			DBG_871X("%02X", data[i]);
+			sprintf(extra, "%s%02X", extra, data[i]);
+			if (i != (cnts-1))
+			{
+//				DBG_871X(":");
+				sprintf(extra,"%s:",extra);
+			}
+		}
+//		DBG_871X("}\n");
+	}
+	else if (strcmp(tmp[0], "vidpid") == 0)
+	{
+		#ifdef CONFIG_RTL8188E
+			#ifdef CONFIG_USB_HCI
+			addr = EEPROM_VID_88EU;
+			#endif
+			#ifdef CONFIG_PCI_HCI
+			addr = EEPROM_VID_88EE;
+			#endif
+		#endif // CONFIG_RTL8188E
+
+		#ifdef CONFIG_RTL8192E
+			#ifdef CONFIG_USB_HCI
+			addr = EEPROM_VID_8192EU;
+			#endif
+			#ifdef CONFIG_PCI_HCI
+			addr = EEPROM_VID_8192EE;
+			#endif
+		#endif // CONFIG_RTL8192E
+		#ifdef CONFIG_RTL8723B
+		addr = EEPROM_VID_8723BU;
+		#endif // CONFIG_RTL8192E
+
+		#ifdef CONFIG_RTL8188F
+		addr = EEPROM_VID_8188FU;
+		#endif /* CONFIG_RTL8188F */
+
+		#ifdef CONFIG_RTL8703B
+			#ifdef CONFIG_USB_HCI
+			addr = EEPROM_VID_8703BU;
+			#endif
+		#endif /* CONFIG_RTL8703B */
+
+		cnts = 4;
+
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (PVOID)&max_available_len, _FALSE);
+		if ((addr + cnts) > max_available_len) {
+			DBG_871X("%s: addr(0x%02x)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
+		}
+		if (rtw_efuse_mask_map_read(padapter, addr, cnts, data) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_access error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+
+//		DBG_871X("%s: {VID,PID}={", __FUNCTION__);
+		*extra = 0;
+		for (i=0; i<cnts; i++)
+		{
+//			DBG_871X("0x%02x", data[i]);
+			sprintf(extra, "%s0x%02X", extra, data[i]);
+			if (i != (cnts-1))
+			{
+//				DBG_871X(",");
+				sprintf(extra,"%s,",extra);
+			}
+		}
+//		DBG_871X("}\n");
+	} else if (strcmp(tmp[0], "ableraw") == 0) {
+			efuse_GetCurrentSize(padapter, &raw_cursize);
+			raw_maxsize = efuse_GetMaxSize(padapter);
+			sprintf(extra, "[available raw size]= %d bytes\n", raw_maxsize - raw_cursize);
+	} else if (strcmp(tmp[0], "btableraw") == 0) {
+			efuse_bt_GetCurrentSize(padapter, &raw_cursize);
+			raw_maxsize = efuse_bt_GetMaxSize(padapter);
+			sprintf(extra, "[available raw size]= %d bytes\n", raw_maxsize - raw_cursize);
+	} else if (strcmp(tmp[0], "btfmap") == 0) {
+
+		BTEfuse_PowerSwitch(padapter,1,_TRUE);
+				
+		mapLen = EFUSE_BT_MAX_MAP_LEN;
+		if (rtw_BT_efuse_map_read(padapter, 0, mapLen, pEfuseHal->BTEfuseInitMap) == _FAIL)
+		{
+			DBG_871X("%s: rtw_BT_efuse_map_read Fail!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+
+//		DBG_871X("OFFSET\tVALUE(hex)\n");
+		sprintf(extra, "\n");
+		for (i=0; i<512; i+=16) // set 512 because the iwpriv's extra size have limit 0x7FF
+		{
+//			DBG_871X("0x%03x\t", i);
+			sprintf(extra, "%s0x%03x\t", extra, i);
+			for (j=0; j<8; j++) {
+//				DBG_871X("%02X ", pEfuseHal->BTEfuseInitMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->BTEfuseInitMap[i+j]);
+			}
+//			DBG_871X("\t");
+			sprintf(extra,"%s\t",extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", pEfuseHal->BTEfuseInitMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->BTEfuseInitMap[i+j]);
+			}
+//			DBG_871X("\n");
+			sprintf(extra, "%s\n", extra);
+		}
+//		DBG_871X("\n");
+	}
+	else if (strcmp(tmp[0],"btbmap") == 0)
+	{
+		BTEfuse_PowerSwitch(padapter,1,_TRUE);
+		
+		mapLen = EFUSE_BT_MAX_MAP_LEN;
+		if (rtw_BT_efuse_map_read(padapter, 0, mapLen, pEfuseHal->BTEfuseInitMap) == _FAIL)
+		{
+			DBG_871X("%s: rtw_BT_efuse_map_read Fail!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+
+//		DBG_871X("OFFSET\tVALUE(hex)\n");
+		sprintf(extra, "\n");
+		for (i=512; i<1024 ; i+=16)
+		{
+//			DBG_871X("0x%03x\t", i);
+			sprintf(extra, "%s0x%03x\t", extra, i);
+			for (j=0; j<8; j++)
+			{
+//				DBG_871X("%02X ", data[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->BTEfuseInitMap[i+j]);
+			}
+//			DBG_871X("\t");
+			sprintf(extra,"%s\t",extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", data[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->BTEfuseInitMap[i+j]);
+			}
+//			DBG_871X("\n");
+			sprintf(extra, "%s\n", extra);
+		}
+//		DBG_871X("\n");
+	}
+	else if (strcmp(tmp[0],"btrmap") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		BTEfuse_PowerSwitch(padapter,1,_TRUE);
+		
+		// rmap addr cnts
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+
+		cnts = simple_strtoul(tmp[2], &ptmp, 10);
+		if (cnts == 0)
+		{
+			DBG_871X("%s: btrmap Fail!! cnts error!\n", __FUNCTION__);
+			err = -EINVAL;
+			goto exit;
+		}
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_EFUSE_MAP_LEN, (PVOID)&max_available_len, _FALSE);
+		if ((addr + cnts) > max_available_len) {
+			DBG_871X("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
+		}
+
+		if (rtw_BT_efuse_map_read(padapter, addr, cnts, data) == _FAIL) 
+		{
+			DBG_871X("%s: rtw_BT_efuse_map_read error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+
+		*extra = 0;
+//		DBG_871X("%s: bt efuse data={", __FUNCTION__);
+		for (i=0; i<cnts; i++)
+		{
+//			DBG_871X("0x%02x ", data[i]);
+			sprintf(extra, "%s 0x%02X ", extra, data[i]);
+		}
+//		DBG_871X("}\n");
+		DBG_871X(FUNC_ADPT_FMT ": BT MAC=[%s]\n", FUNC_ADPT_ARG(padapter), extra);
+	}
+	else if (strcmp(tmp[0], "btffake") == 0)
+	{
+//		DBG_871X("OFFSET\tVALUE(hex)\n");
+		sprintf(extra, "\n");
+		for (i=0; i<512; i+=16)
+		{
+//			DBG_871X("0x%03x\t", i);
+			sprintf(extra, "%s0x%03x\t", extra, i);
+			for (j=0; j<8; j++) {
+//				DBG_871X("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+			}
+//			DBG_871X("\t");
+			sprintf(extra, "%s\t", extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+			}
+//			DBG_871X("\n");
+			sprintf(extra, "%s\n", extra);
+		}
+//		DBG_871X("\n");
+	}
+	else if (strcmp(tmp[0],"btbfake") == 0)
+	{
+//		DBG_871X("OFFSET\tVALUE(hex)\n");
+		sprintf(extra, "\n");
+		for (i=512; i<1024; i+=16)
+		{
+//			DBG_871X("0x%03x\t", i);
+			sprintf(extra, "%s0x%03x\t", extra, i);
+			for (j=0; j<8; j++) {
+//				DBG_871X("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+			}
+//			DBG_871X("\t");
+			sprintf(extra, "%s\t", extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+			}
+//			DBG_871X("\n");
+			sprintf(extra, "%s\n", extra);
+		}
+//		DBG_871X("\n");
+	}
+	else if (strcmp(tmp[0],"wlrfkmap")== 0)
+	{
+//		DBG_871X("OFFSET\tVALUE(hex)\n");
+		sprintf(extra, "\n");
+		for (i=0; i<EFUSE_MAP_SIZE; i+=16)
+		{
+//			DBG_871X("\t0x%02x\t", i);
+			sprintf(extra, "%s0x%02x\t", extra, i);
+			for (j=0; j<8; j++) {
+//				DBG_871X("%02X ", pEfuseHal->fakeEfuseModifiedMap[i+j]);
+				sprintf(extra, "%s%02X ", extra, pEfuseHal->fakeEfuseModifiedMap[i+j]);
+			}
+//			DBG_871X("\t");
+			sprintf(extra, "%s\t", extra);
+			for (; j<16; j++) {
+//				DBG_871X("%02X ", pEfuseHal->fakeEfuseModifiedMap[i+j]);
+				sprintf(extra, "%s %02X", extra, pEfuseHal->fakeEfuseModifiedMap[i+j]);
+			}
+//			DBG_871X("\n");
+			sprintf(extra, "%s\n", extra);
+		}
+//		DBG_871X("\n");
+
+	}
+	else if (strcmp(tmp[0],"wlrfkrmap")== 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+				{
+					DBG_871X("%s: rmap Fail!! Parameters error!\n", __FUNCTION__);
+					err = -EINVAL;
+					goto exit;
+				}
+				// rmap addr cnts
+				addr = simple_strtoul(tmp[1], &ptmp, 16);
+				DBG_871X("%s: addr=%x\n", __FUNCTION__, addr);
+		
+				cnts = simple_strtoul(tmp[2], &ptmp, 10);
+				if (cnts == 0)
+				{
+					DBG_871X("%s: rmap Fail!! cnts error!\n", __FUNCTION__);
+					err = -EINVAL;
+					goto exit;
+				}
+				DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		
+		//		DBG_871X("%s: data={", __FUNCTION__);
+			*extra = 0;
+			for (i=0; i<cnts; i++) {
+					DBG_871X("wlrfkrmap = 0x%02x \n", pEfuseHal->fakeEfuseModifiedMap[addr+i]);
+					sprintf(extra, "%s0x%02X ", extra, pEfuseHal->fakeEfuseModifiedMap[addr+i]);
+			}
+	}
+	else if (strcmp(tmp[0],"btrfkrmap")== 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+				{
+					DBG_871X("%s: rmap Fail!! Parameters error!\n", __FUNCTION__);
+					err = -EINVAL;
+					goto exit;
+				}
+				// rmap addr cnts
+				addr = simple_strtoul(tmp[1], &ptmp, 16);
+				DBG_871X("%s: addr=%x\n", __FUNCTION__, addr);
+		
+				cnts = simple_strtoul(tmp[2], &ptmp, 10);
+				if (cnts == 0)
+				{
+					DBG_871X("%s: rmap Fail!! cnts error!\n", __FUNCTION__);
+					err = -EINVAL;
+					goto exit;
+				}
+				DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		
+		//		DBG_871X("%s: data={", __FUNCTION__);
+			*extra = 0;
+			for (i=0; i<cnts; i++) {
+					DBG_871X("wlrfkrmap = 0x%02x \n", pEfuseHal->fakeBTEfuseModifiedMap[addr+i]);
+					sprintf(extra, "%s0x%02X ", extra, pEfuseHal->fakeBTEfuseModifiedMap[addr+i]);
+			}
+	}
+	else
+	{
+		 sprintf(extra, "Command not found!");
+	}
+
+exit:
+	if (data)
+		rtw_mfree(data, EFUSE_BT_MAX_MAP_LEN);
+	if (rawdata)
+		rtw_mfree(rawdata, EFUSE_BT_MAX_MAP_LEN);
+	if (!err)
+		wrqu->length = strlen(extra);
+	
+	if (padapter->registrypriv.mp_mode == 0)
+	{
+	#ifdef CONFIG_IPS		
+	rtw_pm_set_ips(padapter, ips_mode);
+#endif // CONFIG_IPS
+
+	#ifdef CONFIG_LPS	
+	rtw_pm_set_lps(padapter, lps_mode);
+#endif // CONFIG_LPS
+	}
+
+	#ifdef CONFIG_IOL
+	padapter->registrypriv.fw_iol = org_fw_iol;// 0:Disable, 1:enable, 2:by usb speed
+	#endif
+	return err;
+}
+
+static int rtw_mp_efuse_set(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wdata, char *extra)
+{
+	struct iw_point *wrqu;
+	PADAPTER padapter;
+	struct pwrctrl_priv *pwrctrlpriv ;
+	PHAL_DATA_TYPE pHalData;
+	PEFUSE_HAL pEfuseHal;
+
+	u8 ips_mode = IPS_NUM; // init invalid value
+	u8 lps_mode = PS_MODE_NUM; // init invalid value
+	u32 i=0,j=0, jj, kk;
+	u8 *setdata = NULL;
+	u8 *ShadowMapBT = NULL;
+	u8 *ShadowMapWiFi = NULL;
+	u8 *setrawdata = NULL;
+	char *pch, *ptmp, *token, *tmp[3]={0x00,0x00,0x00};
+	u16 addr = 0xFF, cnts = 0, BTStatus = 0 , max_available_len = 0;
+	int err;
+
+	wrqu = (struct iw_point*)wdata;
+	padapter = rtw_netdev_priv(dev);
+	pwrctrlpriv = adapter_to_pwrctl(padapter);
+	pHalData = GET_HAL_DATA(padapter);
+	pEfuseHal = &pHalData->EfuseHal;
+	err = 0;
+	
+	if (copy_from_user(extra, wrqu->pointer, wrqu->length))
+			return -EFAULT;
+			
+	setdata = rtw_zmalloc(1024);
+	if (setdata == NULL)
+	{
+		err = -ENOMEM;
+		goto exit;
+	}
+	ShadowMapBT = rtw_malloc(EFUSE_BT_MAX_MAP_LEN);
+	if (ShadowMapBT == NULL)
+	{
+		err = -ENOMEM;
+		goto exit;
+	}
+	ShadowMapWiFi = rtw_malloc(EFUSE_MAP_SIZE);
+	if (ShadowMapWiFi == NULL)
+	{
+		err = -ENOMEM;
+		goto exit;
+	}
+	setrawdata = rtw_malloc(EFUSE_MAX_SIZE);
+	if (setrawdata == NULL)
+	{
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	#ifdef CONFIG_LPS
+	lps_mode = pwrctrlpriv->power_mgnt;//keep org value
+	rtw_pm_set_lps(padapter,PS_MODE_ACTIVE);
+	#endif	
+	
+	#ifdef CONFIG_IPS	
+	ips_mode = pwrctrlpriv->ips_mode;//keep org value
+	rtw_pm_set_ips(padapter,IPS_NONE);
+	#endif	
+			
+	pch = extra;
+	DBG_871X("%s: in=%s\n", __FUNCTION__, extra);
+	
+	i = 0;
+	while ((token = strsep(&pch, ",")) != NULL)
+	{
+		if (i > 2) break;
+		tmp[i] = token;
+		i++;
+	}
+
+	// tmp[0],[1],[2]
+	// wmap,addr,00e04c871200
+	if (strcmp(tmp[0], "wmap") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+#if 1
+		// unknown bug workaround, need to fix later
+		addr=0x1ff;
+		rtw_write8(padapter, EFUSE_CTRL+1, (addr & 0xff));
+		rtw_msleep_os(10);
+		rtw_write8(padapter, EFUSE_CTRL+2, ((addr >> 8) & 0x03));
+		rtw_msleep_os(10);
+		rtw_write8(padapter, EFUSE_CTRL+3, 0x72);
+		rtw_msleep_os(10);
+		rtw_read8(padapter, EFUSE_CTRL);
+#endif
+
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+		addr &= 0xFFF;
+
+		cnts = strlen(tmp[2]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: map data=%s\n", __FUNCTION__, tmp[2]);
+				
+		for (jj=0, kk=0; jj<cnts; jj++, kk+=2)
+		{
+			setdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+1]);
+		}
+
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (PVOID)&max_available_len, _FALSE);
+
+		if ((addr + cnts) > max_available_len) {
+			DBG_871X("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
+		}
+
+		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_map_write error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+		*extra = 0;
+		DBG_871X("%s: after rtw_efuse_map_write to _rtw_memcmp\n", __func__);
+		if (rtw_efuse_mask_map_read(padapter, addr, cnts, ShadowMapWiFi) == _SUCCESS)
+		{
+			if (_rtw_memcmp((void*)ShadowMapWiFi ,(void*)setdata,cnts))
+			{ 
+				DBG_871X("%s: WiFi write map afterf compare success\n", __FUNCTION__);
+				sprintf(extra, "WiFi write map compare OK\n");
+				err = 0;
+				goto exit;
+			}
+			else
+			{
+				sprintf(extra, "WiFi write map compare FAIL\n");
+				DBG_871X("%s: WiFi write map compare Fail\n", __FUNCTION__);
+				err = 0;
+				goto exit;
+			}
+		}
+	}
+	else if (strcmp(tmp[0], "wraw") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		addr = simple_strtoul( tmp[1], &ptmp, 16 );
+		addr &= 0xFFF;
+
+		cnts = strlen(tmp[2]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: raw data=%s\n", __FUNCTION__, tmp[2]);
+
+		for (jj=0, kk=0; jj<cnts; jj++, kk+=2)
+		{
+			setrawdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+1]);
+		}
+
+		if (rtw_efuse_access(padapter, _TRUE, addr, cnts, setrawdata) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_access error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+	}
+	else if (strcmp(tmp[0], "mac") == 0)
+	{
+		if (tmp[1]==NULL)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		//mac,00e04c871200
+		
+		if (hal_efuse_macaddr_offset(padapter) == -1) {
+			err = -EFAULT;
+			goto exit;
+		}
+
+		addr = hal_efuse_macaddr_offset(padapter);
+		cnts = strlen(tmp[1]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		if (cnts > 6)
+		{
+			DBG_871X("%s: error data for mac addr=\"%s\"\n", __FUNCTION__, tmp[1]);
+			err = -EFAULT;
+			goto exit;
+		}
+
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: MAC address=%s\n", __FUNCTION__, tmp[1]);
+
+		for (jj=0, kk=0; jj<cnts; jj++, kk+=2)
+		{
+			setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk+1]);
+		}
+
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (PVOID)&max_available_len, _FALSE);
+
+		if ((addr + cnts) > max_available_len) {
+			DBG_871X("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
+		}
+
+		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_map_write error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+	}
+	else if (strcmp(tmp[0], "vidpid") == 0)
+	{
+		if (tmp[1]==NULL)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		// pidvid,da0b7881		
+		#ifdef CONFIG_RTL8188E
+			#ifdef CONFIG_USB_HCI
+			addr = EEPROM_VID_88EU;
+			#endif
+			#ifdef CONFIG_PCI_HCI
+			addr = EEPROM_VID_88EE;
+			#endif
+		#endif // CONFIG_RTL8188E
+
+		#ifdef CONFIG_RTL8192E
+			#ifdef CONFIG_USB_HCI
+			addr = EEPROM_VID_8192EU;
+			#endif
+			#ifdef CONFIG_PCI_HCI
+			addr = EEPROM_VID_8192EE;
+			#endif
+		#endif // CONFIG_RTL8188E
+
+		#ifdef CONFIG_RTL8723B
+		addr = EEPROM_VID_8723BU;
+		#endif
+
+		#ifdef CONFIG_RTL8188F
+		addr = EEPROM_VID_8188FU;
+		#endif
+
+		#ifdef CONFIG_RTL8703B
+			#ifdef CONFIG_USB_HCI
+			addr = EEPROM_VID_8703BU;
+			#endif /* CONFIG_USB_HCI */
+		#endif /* CONFIG_RTL8703B */
+
+		cnts = strlen(tmp[1]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: VID/PID=%s\n", __FUNCTION__, tmp[1]);
+
+		for (jj=0, kk=0; jj<cnts; jj++, kk+=2)
+		{
+			setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk+1]);
+		}
+
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (PVOID)&max_available_len, _FALSE);
+		if ((addr + cnts) > max_available_len) {
+			DBG_871X("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
+		}
+
+		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_map_write error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+	}
+        else if (strcmp(tmp[0], "wldumpfake") == 0)
+	{
+		if (rtw_efuse_mask_map_read(padapter, 0, EFUSE_MAP_SIZE, pEfuseHal->fakeEfuseModifiedMap) == _SUCCESS) {
+			DBG_871X("%s: WiFi hw efuse dump to Fake map success\n", __func__);
+		} else {
+			DBG_871X("%s: WiFi hw efuse dump to Fake map Fail\n", __func__);
+			err = -EFAULT;
+		}
+	}
+	else if (strcmp(tmp[0], "btwmap") == 0)
+	{
+		rtw_write8(padapter, 0xa3, 0x05); //For 8723AB ,8821S ?
+		BTStatus=rtw_read8(padapter, 0xa0);
+		DBG_871X("%s: btwmap before read 0xa0 BT Status =0x%x \n", __FUNCTION__,BTStatus);
+		if (BTStatus != 0x04)
+		{
+			sprintf(extra, "BT Status not Active Write FAIL\n");
+			goto exit;
+		}
+
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		BTEfuse_PowerSwitch(padapter,1,_TRUE);
+		
+		addr=0x1ff;
+		rtw_write8(padapter, EFUSE_CTRL+1, (addr & 0xff));
+		rtw_msleep_os(10);
+		rtw_write8(padapter, EFUSE_CTRL+2, ((addr >> 8) & 0x03));
+		rtw_msleep_os(10);
+		rtw_write8(padapter, EFUSE_CTRL+3, 0x72);
+		rtw_msleep_os(10);
+		rtw_read8(padapter, EFUSE_CTRL);
+
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+		addr &= 0xFFF;
+
+		cnts = strlen(tmp[2]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: BT data=%s\n", __FUNCTION__, tmp[2]);
+
+		for (jj=0, kk=0; jj<cnts; jj++, kk+=2)
+		{
+			setdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+1]);
+		}
+#ifdef CONFIG_RTL8703B
+		if (cnts == 1 && addr == 0x189) {
+			setdata[1] = setdata[0];
+			setdata[0] = 0x00;
+			cnts += 1;
+			addr = 0x188;
+			DBG_871X("addr 0x%x ,setdata=0x%X 0x%X\n", addr, setdata[0], setdata[1]);
+		} else if (cnts == 1 && addr == 0x161) {
+			setdata[1] = setdata[0];
+			setdata[0] = 0xFE;
+			cnts += 1;
+			addr = 0x160;
+			DBG_871X("addr 0x%x ,setdata=0x%X 0x%X\n", addr, setdata[0], setdata[1]);
+		}
+#endif
+
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_EFUSE_MAP_LEN, (PVOID)&max_available_len, _FALSE);
+		if ((addr + cnts) > max_available_len) {
+			DBG_871X("%s: addr(0x%X)+cnts(%d) parameter error!\n", __FUNCTION__, addr, cnts);
+			err = -EFAULT;
+			goto exit;
+		}
+
+		if (rtw_BT_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL)
+		{
+			DBG_871X("%s: rtw_BT_efuse_map_write error!!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+		*extra = 0;
+		DBG_871X("%s: after rtw_BT_efuse_map_write to _rtw_memcmp \n", __FUNCTION__);
+		if ( (rtw_BT_efuse_map_read(padapter, addr, cnts, ShadowMapBT ) == _SUCCESS ) )
+		{
+			if (_rtw_memcmp((void*)ShadowMapBT ,(void*)setdata,cnts))
+			{ 
+				DBG_871X("%s: BT write map compare OK BTStatus=0x%x\n", __FUNCTION__,BTStatus);
+				sprintf(extra, "BT write map compare OK");
+				err = 0;
+				goto exit;
+			}
+			else
+			{
+				sprintf(extra, "BT write map compare FAIL");
+				DBG_871X("%s: BT write map compare FAIL BTStatus=0x%x\n", __FUNCTION__,BTStatus);
+				err = 0;
+				goto exit;
+			}
+		}
+	}
+	else if (strcmp(tmp[0], "btwfake") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+		addr &= 0xFFF;
+
+		cnts = strlen(tmp[2]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: BT tmp data=%s\n", __FUNCTION__, tmp[2]);
+				
+		for (jj=0, kk=0; jj<cnts; jj++, kk+=2)
+		{
+			pEfuseHal->fakeBTEfuseModifiedMap[addr+jj] = key_2char2num(tmp[2][kk], tmp[2][kk+1]);
+		}
+	}
+	else if (strcmp(tmp[0], "btdumpfake") == 0)
+	{
+		if (rtw_BT_efuse_map_read(padapter, 0, EFUSE_BT_MAX_MAP_LEN, pEfuseHal->fakeBTEfuseModifiedMap) == _SUCCESS) {
+			DBG_871X("%s: BT read all map success\n", __FUNCTION__);
+		} else {
+			DBG_871X("%s: BT read all map Fail!\n", __FUNCTION__);
+			err = -EFAULT;
+		}
+	}
+	else if (strcmp(tmp[0], "btfk2map") == 0)
+	{
+		rtw_write8(padapter, 0xa3, 0x05);
+		BTStatus=rtw_read8(padapter, 0xa0);
+		DBG_871X("%s: btwmap before read 0xa0 BT Status =0x%x \n", __FUNCTION__,BTStatus);
+		if (BTStatus != 0x04)
+		{
+			sprintf(extra, "BT Status not Active Write FAIL\n");
+			goto exit;
+		}
+		
+		BTEfuse_PowerSwitch(padapter,1,_TRUE);
+
+		addr=0x1ff;
+		rtw_write8(padapter, EFUSE_CTRL+1, (addr & 0xff));
+		rtw_msleep_os(10);
+		rtw_write8(padapter, EFUSE_CTRL+2, ((addr >> 8) & 0x03));
+		rtw_msleep_os(10);
+		rtw_write8(padapter, EFUSE_CTRL+3, 0x72);
+		rtw_msleep_os(10);
+		rtw_read8(padapter, EFUSE_CTRL);
+
+		_rtw_memcpy(pEfuseHal->BTEfuseModifiedMap, pEfuseHal->fakeBTEfuseModifiedMap, EFUSE_BT_MAX_MAP_LEN);
+
+		if (rtw_BT_efuse_map_write(padapter, 0x00, EFUSE_BT_MAX_MAP_LEN, pEfuseHal->fakeBTEfuseModifiedMap) == _FAIL)
+		{
+			DBG_871X("%s: rtw_BT_efuse_map_write error!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+		
+		DBG_871X("pEfuseHal->fakeBTEfuseModifiedMap OFFSET\tVALUE(hex)\n");
+		for (i = 0; i < EFUSE_BT_MAX_MAP_LEN; i += 16)
+		{
+			printk("0x%02x\t", i);
+			for (j=0; j<8; j++) {
+				printk("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+			}
+			printk("\t");
+
+			for (; j<16; j++) {
+				printk("%02X ", pEfuseHal->fakeBTEfuseModifiedMap[i+j]);
+			}
+			printk("\n");
+		}
+		printk("\n");
+#if 1		
+		err = -EFAULT;
+		DBG_871X("%s: rtw_BT_efuse_map_read _rtw_memcmp \n", __FUNCTION__);
+		if ( (rtw_BT_efuse_map_read(padapter, 0x00, EFUSE_BT_MAX_MAP_LEN, pEfuseHal->fakeBTEfuseInitMap) == _SUCCESS ) )
+		{ 
+			if (_rtw_memcmp((void*)pEfuseHal->fakeBTEfuseModifiedMap,(void*)pEfuseHal->fakeBTEfuseInitMap,EFUSE_BT_MAX_MAP_LEN))
+			{ 
+				sprintf(extra, "BT write map compare OK");
+				DBG_871X("%s: BT write map afterf compare success BTStatus=0x%x \n", __FUNCTION__,BTStatus);
+				err = 0;
+				goto exit;
+			}
+			else
+			{
+				sprintf(extra, "BT write map compare FAIL");
+				if (rtw_BT_efuse_map_write(padapter, 0x00, EFUSE_BT_MAX_MAP_LEN, pEfuseHal->fakeBTEfuseModifiedMap) == _FAIL)
+				{
+					DBG_871X("%s: rtw_BT_efuse_map_write compare error,retry = %d!\n", __FUNCTION__,i);
+				}
+
+				if (rtw_BT_efuse_map_read(padapter, EFUSE_BT, EFUSE_BT_MAX_MAP_LEN, pEfuseHal->fakeBTEfuseInitMap) == _SUCCESS)
+				{
+					DBG_871X("pEfuseHal->fakeBTEfuseInitMap OFFSET\tVALUE(hex)\n");
+
+					for (i = 0; i < EFUSE_BT_MAX_MAP_LEN; i += 16)
+					{
+						printk("0x%02x\t", i);
+						for (j=0; j<8; j++) {
+							printk("%02X ", pEfuseHal->fakeBTEfuseInitMap[i+j]);
+						}
+						printk("\t");
+						for (; j<16; j++) {
+							printk("%02X ", pEfuseHal->fakeBTEfuseInitMap[i+j]);
+						}
+						printk("\n");
+					}
+					printk("\n"); 
+				}
+				DBG_871X("%s: BT write map afterf compare not match to write efuse try write Map again , BTStatus=0x%x\n", __FUNCTION__,BTStatus);	
+				goto exit;
+			}
+		}
+#endif
+
+	}
+	else if (strcmp(tmp[0], "wlfk2map") == 0)
+	{
+		if (rtw_efuse_map_write(padapter, 0x00, EFUSE_MAP_SIZE, pEfuseHal->fakeEfuseModifiedMap) == _FAIL)
+		{
+			DBG_871X("%s: rtw_efuse_map_write fakeEfuseModifiedMap error!\n", __FUNCTION__);
+			err = -EFAULT;
+			goto exit;
+		}
+		*extra = 0;
+		DBG_871X("%s: after rtw_BT_efuse_map_write to _rtw_memcmp\n", __func__);
+		if (rtw_efuse_mask_map_read(padapter, 0x00, EFUSE_MAP_SIZE, ShadowMapWiFi) == _SUCCESS)
+		{
+			if (_rtw_memcmp((void*)ShadowMapWiFi ,(void*)setdata,cnts))
+			{
+				DBG_871X("%s: WiFi write map afterf compare OK\n", __FUNCTION__);
+				sprintf(extra, "WiFi write map compare OK\n");
+				err = 0;
+				goto exit;
+			}
+			else
+			{
+				sprintf(extra, "WiFi write map compare FAIL\n");
+				DBG_871X("%s: WiFi write map compare Fail\n", __FUNCTION__);
+				err = 0;
+				goto exit;
+			}
+		}
+	}
+	else if (strcmp(tmp[0], "wlwfake") == 0)
+	{
+		if ((tmp[1]==NULL) || (tmp[2]==NULL))
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+		addr &= 0xFFF;
+
+		cnts = strlen(tmp[2]);
+		if (cnts%2)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+		cnts /= 2;
+		if (cnts == 0)
+		{
+			err = -EINVAL;
+			goto exit;
+		}
+
+		DBG_871X("%s: addr=0x%X\n", __FUNCTION__, addr);
+		DBG_871X("%s: cnts=%d\n", __FUNCTION__, cnts);
+		DBG_871X("%s: map tmp data=%s\n", __FUNCTION__, tmp[2]);
+
+		for (jj=0, kk=0; jj<cnts; jj++, kk+=2)
+		{
+			pEfuseHal->fakeEfuseModifiedMap[addr+jj] = key_2char2num(tmp[2][kk], tmp[2][kk+1]);
+		}
+		_rtw_memset(extra, '\0', strlen(extra));
+		sprintf(extra, "wlwfake OK\n");
+	}
+
+exit:
+	if (setdata)
+		rtw_mfree(setdata, 1024);
+	if (ShadowMapBT)
+		rtw_mfree(ShadowMapBT, EFUSE_BT_MAX_MAP_LEN);
+	if (ShadowMapWiFi)
+		rtw_mfree(ShadowMapWiFi, EFUSE_MAP_SIZE);
+	if (setrawdata)
+		rtw_mfree(setrawdata, EFUSE_MAX_SIZE);
+	
+	wrqu->length = strlen(extra);
+
+	if (padapter->registrypriv.mp_mode == 0)
+	{
+	#ifdef CONFIG_IPS		
+	rtw_pm_set_ips(padapter, ips_mode);
+        #endif // CONFIG_IPS
+
+	#ifdef CONFIG_LPS	
+	rtw_pm_set_lps(padapter, lps_mode);
+        #endif // CONFIG_LPS
+	}
+
+	return err;
+}
+
+
+#ifdef CONFIG_MP_INCLUDED
+
+#ifdef CONFIG_SDIO_INDIRECT_ACCESS
+#define DBG_MP_SDIO_INDIRECT_ACCESS 1
+static int rtw_mp_sd_iread(struct net_device *dev
+	, struct iw_request_info *info
+	, struct iw_point *wrqu
+	, char *extra)
+{
+	char input[16];
+	u8 width;
+	unsigned long addr;
+	u32 ret = 0;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+
+	if (wrqu->length > 16) {
+		DBG_871X(FUNC_ADPT_FMT" wrqu->length:%d\n", FUNC_ADPT_ARG(padapter), wrqu->length);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length)) {
+		DBG_871X(FUNC_ADPT_FMT" copy_from_user fail\n", FUNC_ADPT_ARG(padapter));
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	_rtw_memset(extra, 0, wrqu->length);
+
+	if (sscanf(input, "%hhu,%lx", &width, &addr) != 2) {
+		DBG_871X(FUNC_ADPT_FMT" sscanf fail\n", FUNC_ADPT_ARG(padapter));
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (addr > 0x3FFF) {
+		DBG_871X(FUNC_ADPT_FMT" addr:0x%lx\n", FUNC_ADPT_ARG(padapter), addr);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (DBG_MP_SDIO_INDIRECT_ACCESS)
+		DBG_871X(FUNC_ADPT_FMT" width:%u, addr:0x%lx\n", FUNC_ADPT_ARG(padapter), width, addr);
+
+	switch (width) {
+	case 1:
+		sprintf(extra, "0x%02x", rtw_sd_iread8(padapter, addr));
+		wrqu->length = strlen(extra);
+		break;
+	case 2:
+		sprintf(extra, "0x%04x", rtw_sd_iread16(padapter, addr));
+		wrqu->length = strlen(extra);
+		break;
+	case 4:
+		sprintf(extra, "0x%08x", rtw_sd_iread32(padapter, addr));
+		wrqu->length = strlen(extra);
+		break;
+	default:
+		wrqu->length = 0;
+		ret = -EINVAL;
+		break;
+	}
+
+exit:
+	return ret;
+}
+
+static int rtw_mp_sd_iwrite(struct net_device *dev
+	, struct iw_request_info *info
+	, struct iw_point *wrqu
+	, char *extra)
+{
+	char width;
+	unsigned long addr, data;
+	int ret = 0;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	char input[32];
+
+	if (wrqu->length > 32) {
+		DBG_871X(FUNC_ADPT_FMT" wrqu->length:%d\n", FUNC_ADPT_ARG(padapter), wrqu->length);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length)) {
+		DBG_871X(FUNC_ADPT_FMT" copy_from_user fail\n", FUNC_ADPT_ARG(padapter));
+		ret = -EFAULT;
+		goto exit;
+	}
+				 
+	_rtw_memset(extra, 0, wrqu->length);	
+
+	if (sscanf(input, "%hhu,%lx,%lx", &width, &addr, &data) != 3) {
+		DBG_871X(FUNC_ADPT_FMT" sscanf fail\n", FUNC_ADPT_ARG(padapter));
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (addr > 0x3FFF) {
+		DBG_871X(FUNC_ADPT_FMT" addr:0x%lx\n", FUNC_ADPT_ARG(padapter), addr);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (DBG_MP_SDIO_INDIRECT_ACCESS)
+		DBG_871X(FUNC_ADPT_FMT" width:%u, addr:0x%lx, data:0x%lx\n", FUNC_ADPT_ARG(padapter), width, addr, data);
+
+	switch (width) {
+	case 1:
+		if (data > 0xFF) {
+			ret = -EINVAL;
+			break;
+		}
+		rtw_sd_iwrite8(padapter, addr, data);
+		break;
+	case 2:
+		if (data > 0xFFFF) {
+			ret = -EINVAL;
+			break;
+		}
+		rtw_sd_iwrite16(padapter, addr, data);
+		break;
+	case 4:
+		rtw_sd_iwrite32(padapter, addr, data);
+		break;
+	default:
+		wrqu->length = 0;
+		ret = -EINVAL;
+		break;
+	}
+
+exit:
+	return ret;
+}
+#endif /* CONFIG_SDIO_INDIRECT_ACCESS */
+
+static int rtw_mp_set(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wdata, char *extra)
+{
+	struct iw_point *wrqu = (struct iw_point *)wdata;
+	u32 subcmd = wrqu->flags;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+
+	if (padapter == NULL)
+	{
+		return -ENETDOWN;
+	}
+
+	if((padapter->bup == _FALSE ))
+	{
+		DBG_871X(" %s fail =>(padapter->bup == _FALSE )\n",__FUNCTION__);
+		return -ENETDOWN;
+	}
+
+	if (RTW_CANNOT_RUN(padapter)) {
+		DBG_871X("%s fail =>(bSurpriseRemoved == _TRUE) || ( bDriverStopped == _TRUE)\n", __func__);
+		return -ENETDOWN;
+       }
+
+	
+	//_rtw_memset(extra, 0x00, IW_PRIV_SIZE_MASK);
+
+	if (extra == NULL)
+	{
+		wrqu->length = 0;
+		return -EIO;
+	}
+
+	switch(subcmd)
+	{
+	case MP_START:
+			DBG_871X("set case mp_start \n");
+			rtw_mp_start (dev,info,wrqu,extra);
+			 break; 
+			 
+	case MP_STOP:
+			DBG_871X("set case mp_stop \n");
+			rtw_mp_stop (dev,info,wrqu,extra);
+			 break; 
+			 
+	case MP_BANDWIDTH:
+			DBG_871X("set case mp_bandwidth \n");
+			rtw_mp_bandwidth (dev,info,wrqu,extra);
+			break;
+				
+	case MP_RESET_STATS:
+			DBG_871X("set case MP_RESET_STATS \n");
+			rtw_mp_reset_stats	(dev,info,wrqu,extra);
+			break;
+	case MP_SetRFPathSwh:		
+			DBG_871X("set MP_SetRFPathSwitch \n");
+			rtw_mp_SetRFPath  (dev,info,wdata,extra);
+			break;
+	case CTA_TEST:
+			DBG_871X("set CTA_TEST\n");
+			rtw_cta_test_start (dev, info, wdata, extra);
+			break;
+	case MP_DISABLE_BT_COEXIST:
+			DBG_871X("set case MP_DISABLE_BT_COEXIST \n");
+			rtw_mp_disable_bt_coexist(dev, info, wdata, extra);
+		break;
+#ifdef CONFIG_WOWLAN
+	case MP_WOW_ENABLE:
+			DBG_871X("set case MP_WOW_ENABLE: %s\n", extra);
+			
+			rtw_wowlan_ctrl(dev, info, wdata, extra);
+	break;
+	case MP_WOW_SET_PATTERN:
+			DBG_871X("set case MP_WOW_SET_PATTERN: %s\n", extra);
+			rtw_wowlan_set_pattern(dev, info, wdata, extra);
+	break;
+#endif
+#ifdef CONFIG_AP_WOWLAN
+	case MP_AP_WOW_ENABLE:
+			DBG_871X("set case MP_AP_WOW_ENABLE: %s\n", extra);
+			rtw_ap_wowlan_ctrl(dev, info, wdata, extra);
+	break;
+#endif
+	}
+
+	  
+	return 0;		
+}
+
+
+static int rtw_mp_get(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wdata, char *extra)
+{
+	struct iw_point *wrqu = (struct iw_point *)wdata;
+	u32 subcmd = wrqu->flags;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+
+	//DBG_871X("in mp_get extra= %s \n",extra);
+
+	if (padapter == NULL)
+	{
+		return -ENETDOWN;
+	}
+	if((padapter->bup == _FALSE ))
+	{
+		DBG_871X(" %s fail =>(padapter->bup == _FALSE )\n",__FUNCTION__);
+		return -ENETDOWN;
+	}
+
+	if (RTW_CANNOT_RUN(padapter)) {
+		DBG_871X("%s fail =>(padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE)\n", __func__);
+		return -ENETDOWN;
+       }
+	
+	if (extra == NULL) {
+		wrqu->length = 0;
+		return -EIO;
+	}
+	
+	switch (subcmd) {
+	case WRITE_REG:
+			rtw_mp_write_reg(dev, info, wrqu, extra);
+			 break;
+			 
+	case WRITE_RF:
+			rtw_mp_write_rf(dev, info, wrqu, extra);
+			 break; 
+			 
+	case MP_PHYPARA:
+			DBG_871X("mp_get  MP_PHYPARA\n");
+			rtw_mp_phypara(dev, info, wrqu, extra);
+			break;
+
+	case MP_CHANNEL:
+			DBG_871X("set case mp_channel\n");
+			rtw_mp_channel(dev , info, wrqu, extra);
+			break;
+			
+	case READ_REG:
+			DBG_871X("mp_get  READ_REG\n");
+			rtw_mp_read_reg(dev, info, wrqu, extra);
+			 break; 
+	case READ_RF:
+			DBG_871X("mp_get  READ_RF\n");
+			rtw_mp_read_rf(dev, info, wrqu, extra);
+			break; 
+			
+	case MP_RATE:
+			DBG_871X("set case mp_rate\n");
+			rtw_mp_rate(dev, info, wrqu, extra);
+			break;
+			
+	case MP_TXPOWER:
+			DBG_871X("set case MP_TXPOWER\n");
+			rtw_mp_txpower(dev, info, wrqu, extra);
+			break;
+			
+	case MP_ANT_TX:
+			DBG_871X("set case MP_ANT_TX\n");
+			rtw_mp_ant_tx(dev, info, wrqu, extra);
+			break;
+			
+	case MP_ANT_RX:
+			DBG_871X("set case MP_ANT_RX\n");
+			rtw_mp_ant_rx(dev, info, wrqu, extra);
+			break;
+			
+	case MP_QUERY:
+			rtw_mp_trx_query(dev, info, wrqu, extra);
+			break;
+					
+	case MP_CTX:
+			DBG_871X("set case MP_CTX\n");
+			rtw_mp_ctx(dev, info, wrqu, extra);
+			break;
+					
+	case MP_ARX:
+			DBG_871X("set case MP_ARX\n");
+			rtw_mp_arx(dev, info, wrqu, extra);
+			break;
+			
+	case EFUSE_GET:
+			DBG_871X("efuse get EFUSE_GET\n");
+			rtw_mp_efuse_get(dev, info, wdata, extra);
+		 break; 
+		 
+	case MP_DUMP:
+			DBG_871X("set case MP_DUMP\n");
+			rtw_mp_dump(dev, info, wrqu, extra);
+		 break; 
+	case MP_PSD:
+			DBG_871X("set case MP_PSD\n");
+			rtw_mp_psd(dev, info, wrqu, extra);
+		 break;
+	case MP_THER:
+			DBG_871X("set case MP_THER\n");
+			rtw_mp_thermal(dev, info, wrqu, extra);
+		break;
+	case MP_PwrCtlDM:
+			DBG_871X("set MP_PwrCtlDM\n");
+			rtw_mp_PwrCtlDM(dev, info, wrqu, extra);
+		break;
+	case MP_QueryDrvStats:		
+			DBG_871X("mp_get MP_QueryDrvStats\n");
+			rtw_mp_QueryDrv(dev, info, wdata, extra);
+			break;
+	case MP_PWRTRK:
+			DBG_871X("set case MP_PWRTRK\n");
+			rtw_mp_pwrtrk(dev, info, wrqu, extra);
+			break;			 
+	case EFUSE_SET:
+			DBG_871X("set case efuse set\n");
+			rtw_mp_efuse_set(dev, info, wdata, extra);
+			break;			 
+	case MP_GET_TXPOWER_INX:
+			DBG_871X("mp_get MP_GET_TXPOWER_INX\n");
+			rtw_mp_txpower_index(dev, info, wrqu, extra);
+			break;
+	case MP_GETVER:
+			DBG_871X("mp_get MP_GETVER\n");
+			rtw_mp_getver(dev, info, wdata, extra);
+			break;
+	case MP_MON:
+			DBG_871X("mp_get MP_MON\n");
+			rtw_mp_mon(dev, info, wdata, extra);
+			break;
+	case EFUSE_MASK:
+			DBG_871X("mp_get EFUSE_MASK\n");
+			rtw_efuse_mask_file(dev, info, wdata, extra);
+			break;
+	case  EFUSE_FILE:
+			DBG_871X("mp_get EFUSE_FILE\n");
+			rtw_efuse_file_map(dev, info, wdata, extra);
+			break;
+	case  MP_TX:
+			DBG_871X("mp_get MP_TX\n");
+			rtw_mp_tx(dev, info, wdata, extra);
+			break;
+	case  MP_RX:
+			DBG_871X("mp_get MP_RX\n");
+			rtw_mp_rx(dev, info, wdata, extra);
+			break;
+#if defined(CONFIG_RTL8723B)
+	case MP_SetBT:		
+			DBG_871X("set MP_SetBT\n");
+			rtw_mp_SetBT(dev, info, wdata, extra);
+			break;		 
+#endif
+#ifdef CONFIG_SDIO_INDIRECT_ACCESS
+	case MP_SD_IREAD:
+		rtw_mp_sd_iread(dev, info, wrqu, extra);
+		break;
+	case MP_SD_IWRITE:
+		rtw_mp_sd_iwrite(dev, info, wrqu, extra);
+		break;
+#endif
+	}
+
+	rtw_msleep_os(10); //delay 5ms for sending pkt before exit adb shell operation
+return 0;	
+}
+
+#endif /*#if defined(CONFIG_MP_INCLUDED)*/
+
+static int rtw_wx_tdls_wfd_enable(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+#ifdef CONFIG_WFD
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	DBG_871X( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1  );
+
+	if ( extra[ 0 ] == '0' )
+		rtw_tdls_wfd_enable(padapter, 0);
+	else
+		rtw_tdls_wfd_enable(padapter, 1);
+
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_TDLS */
+	
+	return ret;
+}
+
+static int rtw_tdls_weaksec(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+
+	u8 i, j;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	DBG_871X( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1  );
+
+	if ( extra[ 0 ] == '0' )
+		padapter->wdinfo.wfd_tdls_weaksec = 0;
+	else
+		padapter->wdinfo.wfd_tdls_weaksec = 1;
+
+#endif /* CONFIG_TDLS */
+	
+	return ret;
+}
+
+
+static int rtw_tdls_enable(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_info	*ptdlsinfo = &padapter->tdlsinfo;
+	_irqL	 irqL;
+	_list	*plist, *phead;
+	s32	index;
+	struct sta_info *psta = NULL;
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+	u8 tdls_sta[NUM_STA][ETH_ALEN];
+	u8 empty_hwaddr[ETH_ALEN] = { 0x00 };
+	struct tdls_txmgmt txmgmt;
+
+	DBG_871X( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1  );
+
+	_rtw_memset(tdls_sta, 0x00, sizeof(tdls_sta));
+	_rtw_memset(&txmgmt, 0x00, sizeof(struct tdls_txmgmt));
+
+	if (extra[ 0 ] == '0') {
+		ptdlsinfo->tdls_enable = 0;
+
+		if(pstapriv->asoc_sta_count==1)
+			return ret;
+
+		_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+		for (index=0; index< NUM_STA; index++) {
+			phead = &(pstapriv->sta_hash[index]);
+			plist = get_next(phead);
+			
+			while (rtw_end_of_queue_search(phead, plist) == _FALSE) {
+				psta = LIST_CONTAINOR(plist, struct sta_info ,hash_list);
+
+				plist = get_next(plist);
+
+				if (psta->tdls_sta_state != TDLS_STATE_NONE) {
+					_rtw_memcpy(tdls_sta[index], psta->hwaddr, ETH_ALEN);
+				}
+			}
+		}
+		_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+		for (index=0; index< NUM_STA; index++) {
+			if (!_rtw_memcmp(tdls_sta[index], empty_hwaddr, ETH_ALEN)) {
+				DBG_871X("issue tear down to "MAC_FMT"\n", MAC_ARG(tdls_sta[index]));
+				txmgmt.status_code = _RSON_TDLS_TEAR_UN_RSN_;
+				_rtw_memcpy(txmgmt.peer, tdls_sta[index], ETH_ALEN);
+				issue_tdls_teardown(padapter, &txmgmt, _TRUE);
+			}
+		}
+		rtw_tdls_cmd(padapter, NULL, TDLS_RS_RCR);
+		rtw_reset_tdls_info(padapter);
+	}	else if (extra[0] == '1') {
+		ptdlsinfo->tdls_enable = 1;
+	}
+#endif /* CONFIG_TDLS */
+	
+	return ret;
+}
+
+static int rtw_tdls_setup(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+#ifdef CONFIG_TDLS
+	u8 i, j;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_txmgmt txmgmt;
+#ifdef CONFIG_WFD
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+#endif /* CONFIG_WFD */
+
+	DBG_871X("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1);
+
+	if (wrqu->data.length - 1 != 17) {
+		DBG_871X("[%s] length:%d != 17\n", __FUNCTION__, (wrqu->data.length -1));
+		return ret;
+	}
+
+	_rtw_memset(&txmgmt, 0x00, sizeof(struct tdls_txmgmt));
+	for( i=0, j=0 ; i < ETH_ALEN; i++, j+=3 ){
+		txmgmt.peer[i]=key_2char2num(*(extra+j), *(extra+j+1));
+	}
+
+#ifdef CONFIG_WFD
+	if (_AES_ != padapter->securitypriv.dot11PrivacyAlgrthm) {
+		/* Weak Security situation with AP. */
+		if (0 == pwdinfo->wfd_tdls_weaksec) 	{
+			/* Can't send the tdls setup request out!! */
+			DBG_871X("[%s] Current link is not AES, "
+				"SKIP sending the tdls setup request!!\n", __FUNCTION__);
+		} else {
+			issue_tdls_setup_req(padapter, &txmgmt, _TRUE);
+		}
+	} else
+#endif /* CONFIG_WFD */
+	{
+		issue_tdls_setup_req(padapter, &txmgmt, _TRUE);
+	}
+#endif /* CONFIG_TDLS */
+	
+	return ret;
+}
+
+static int rtw_tdls_teardown(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+
+	u8 i,j;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct sta_info *ptdls_sta = NULL;
+	struct tdls_txmgmt txmgmt;
+
+	DBG_871X( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1  );
+
+	if (wrqu->data.length - 1 != 17 && wrqu->data.length - 1 != 19) {
+		DBG_871X("[%s] length:%d != 17 or 19\n",
+			__FUNCTION__, (wrqu->data.length -1));
+		return ret;
+	}
+
+	_rtw_memset(&txmgmt, 0x00, sizeof(struct tdls_txmgmt));
+	for (i=0, j=0; i < ETH_ALEN; i++, j+=3)
+		txmgmt.peer[i]=key_2char2num(*(extra+j), *(extra+j+1));
+
+	ptdls_sta = rtw_get_stainfo( &(padapter->stapriv), txmgmt.peer);
+	
+	if (ptdls_sta != NULL) {
+		txmgmt.status_code = _RSON_TDLS_TEAR_UN_RSN_;
+		if (wrqu->data.length - 1 == 19)
+			issue_tdls_teardown(padapter, &txmgmt, _FALSE);
+		else 
+			issue_tdls_teardown(padapter, &txmgmt, _TRUE);
+	} else {
+		DBG_871X( "TDLS peer not found\n");
+	}
+#endif /* CONFIG_TDLS */
+	
+	return ret;
+}
+
+static int rtw_tdls_discovery(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_txmgmt	txmgmt;
+	int i = 0, j=0;
+
+	DBG_871X( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1  );
+
+	_rtw_memset(&txmgmt, 0x00, sizeof(struct tdls_txmgmt));
+	for( i=0, j=0 ; i < ETH_ALEN; i++, j+=3 ){
+		txmgmt.peer[i]=key_2char2num(*(extra+j), *(extra+j+1));
+	}
+
+	issue_tdls_dis_req(padapter, &txmgmt);
+
+#endif /* CONFIG_TDLS */
+
+	return ret;
+}
+
+static int rtw_tdls_ch_switch(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+#ifdef CONFIG_TDLS_CH_SW	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_ch_switch *pchsw_info = &padapter->tdlsinfo.chsw_info;
+	u8 i, j;
+	struct sta_info *ptdls_sta = NULL;
+
+	DBG_8192C( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1  );
+
+	if (padapter->tdlsinfo.ch_switch_prohibited == _TRUE)
+	{
+		DBG_871X("Can't do TDLS channel switch since ch_switch_prohibited = _TRUE\n");
+		return ret;
+	}
+
+	for( i=0, j=0 ; i < ETH_ALEN; i++, j+=3 ){
+		pchsw_info->addr[i] = key_2char2num(*(extra+j), *(extra+j+1));
+	}
+
+	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, pchsw_info->addr);
+	if( ptdls_sta == NULL )
+		return ret;
+
+	pchsw_info->ch_sw_state |= TDLS_CH_SW_INITIATOR_STATE;
+
+	if (ptdls_sta != NULL) {
+		if (pchsw_info->off_ch_num == 0)
+			pchsw_info->off_ch_num = 11;
+	}else {
+		DBG_871X( "TDLS peer not found\n");
+	}
+
+	
+	//issue_tdls_ch_switch_req(padapter, ptdls_sta);
+	/* DBG_871X("issue tdls ch switch req\n"); */
+
+#endif /* CONFIG_TDLS_CH_SW */
+#endif /* CONFIG_TDLS */
+
+	return ret;
+}
+
+static int rtw_tdls_ch_switch_off(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+#ifdef CONFIG_TDLS_CH_SW	
+	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_ch_switch *pchsw_info = &padapter->tdlsinfo.chsw_info;
+	u8 i, j, mac_addr[ETH_ALEN];
+	struct sta_info *ptdls_sta = NULL;
+	struct tdls_txmgmt txmgmt;
+
+	_rtw_memset(&txmgmt, 0x00, sizeof(struct tdls_txmgmt));
+	
+	DBG_871X( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1  );
+
+	if (padapter->tdlsinfo.ch_switch_prohibited == _TRUE)
+	{
+		DBG_871X("Can't do TDLS channel switch since ch_switch_prohibited = _TRUE\n");
+		return ret;
+	}
+
+	if (wrqu->data.length >= 17) {
+		for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3)
+		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
+			ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
+	}
+
+	if (padapter->mlmeextpriv.cur_channel != rtw_get_oper_ch(padapter)) {	
+		SelectChannel(padapter, padapter->mlmeextpriv.cur_channel);
+	}
+
+	pchsw_info->ch_sw_state &= ~(TDLS_CH_SW_INITIATOR_STATE |
+								TDLS_CH_SWITCH_ON_STATE |
+								TDLS_PEER_AT_OFF_STATE);
+	ATOMIC_SET(&pchsw_info->chsw_on, _FALSE);
+	_rtw_memset(pchsw_info->addr, 0x00, ETH_ALEN);
+
+	if (ptdls_sta != NULL) {
+		ptdls_sta->ch_switch_time = 0;
+		ptdls_sta->ch_switch_timeout = 0;
+		_cancel_timer_ex(&ptdls_sta->ch_sw_timer);
+		_cancel_timer_ex(&ptdls_sta->delay_timer);
+	}
+
+#endif /* CONFIG_TDLS_CH_SW */
+#endif /* CONFIG_TDLS */
+
+	return ret;
+}
+
+static int rtw_tdls_dump_ch(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+#ifdef CONFIG_TDLS_CH_SW	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
+
+	DBG_8192C("[%s] dump_stack:%s\n", __FUNCTION__, extra);
+
+	extra[ wrqu->data.length ] = 0x00;
+	ptdlsinfo->chsw_info.dump_stack = rtw_atoi( extra );
+
+	return ret;
+
+#endif
+#endif /* CONFIG_TDLS */
+
+	return ret;
+}
+
+static int rtw_tdls_off_ch_num(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+#ifdef CONFIG_TDLS_CH_SW	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
+
+	DBG_8192C("[%s] off_ch_num:%s\n", __FUNCTION__, extra);
+
+	extra[ wrqu->data.length ] = 0x00;
+	ptdlsinfo->chsw_info.off_ch_num = rtw_atoi(extra);
+
+	return ret;
+	
+#endif
+#endif /* CONFIG_TDLS */
+
+	return ret;
+}
+
+static int rtw_tdls_ch_offset(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+#ifdef CONFIG_TDLS_CH_SW	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
+
+	DBG_8192C("[%s] ch_offset:%s\n", __FUNCTION__, extra);
+
+	extra[ wrqu->data.length ] = 0x00;
+	ptdlsinfo->chsw_info.ch_offset = rtw_atoi( extra );
+
+	return ret;
+
+#endif
+#endif /* CONFIG_TDLS */
+
+		return ret;
+}
+	
+static int rtw_tdls_pson(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u8 i, j, mac_addr[ETH_ALEN];
+	struct sta_info *ptdls_sta = NULL;
+
+	DBG_871X( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1  );
+
+	for (i=0, j=0; i < ETH_ALEN; i++, j+=3)
+		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
+
+	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
+
+	issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta->hwaddr, 1, 3, 500);
+
+#endif /* CONFIG_TDLS */
+
+		return ret;
+}
+	
+static int rtw_tdls_psoff(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u8 i, j, mac_addr[ETH_ALEN];
+	struct sta_info *ptdls_sta = NULL;
+	
+	DBG_8192C( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1  );
+
+	for (i=0, j=0; i < ETH_ALEN; i++, j+=3)
+		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
+
+	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
+
+	if(ptdls_sta)
+		issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta->hwaddr, 0, 3, 500);
+
+#endif /* CONFIG_TDLS */
+
+	return ret;
+}
+
+static int rtw_tdls_setip(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+#ifdef CONFIG_WFD
+	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
+	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
+	u8 i=0, j=0, k=0, tag=0;
+
+	DBG_871X("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1);
+
+	while (i < 4) {
+		for (j=0; j < 4; j++) {
+			if (*( extra + j + tag ) == '.' || *( extra + j + tag ) == '\0') {
+				if( j == 1 )
+					pwfd_info->ip_address[i]=convert_ip_addr( '0', '0', *(extra+(j-1)+tag));
+				if( j == 2 )
+					pwfd_info->ip_address[i]=convert_ip_addr( '0', *(extra+(j-2)+tag), *(extra+(j-1)+tag));
+				if( j == 3 )
+					pwfd_info->ip_address[i]=convert_ip_addr( *(extra+(j-3)+tag), *(extra+(j-2)+tag), *(extra+(j-1)+tag));	
+
+				tag += j + 1;
+				break;
+			}
+		}
+		i++;
+	}
+
+	DBG_871X( "[%s] Set IP = %u.%u.%u.%u \n", __FUNCTION__, 
+		ptdlsinfo->wfd_info->ip_address[0],
+		ptdlsinfo->wfd_info->ip_address[1],
+		ptdlsinfo->wfd_info->ip_address[2],
+		ptdlsinfo->wfd_info->ip_address[3]);
+
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_TDLS */
+
+	return ret;
+}
+
+static int rtw_tdls_getip(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+#ifdef CONFIG_WFD
+	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
+	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
+	
+	DBG_871X( "[%s]\n", __FUNCTION__);
+
+	sprintf( extra, "\n\n%u.%u.%u.%u\n", 
+		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1], 
+		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]);
+
+	DBG_871X( "[%s] IP=%u.%u.%u.%u\n", __FUNCTION__,
+		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1], 
+		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]);
+	
+	wrqu->data.length = strlen( extra );
+
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_TDLS */
+
+	return ret;
+}
+
+static int rtw_tdls_getport(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+
+#ifdef CONFIG_TDLS
+#ifdef CONFIG_WFD
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
+	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
+
+	DBG_871X( "[%s]\n", __FUNCTION__);
+
+	sprintf( extra, "\n\n%d\n", pwfd_info->peer_rtsp_ctrlport );
+	DBG_871X( "[%s] remote port = %d\n",
+		__FUNCTION__, pwfd_info->peer_rtsp_ctrlport );
+	
+	wrqu->data.length = strlen( extra );
+
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_TDLS */
+
+	return ret;
+		
+}
+
+/* WFDTDLS, for sigma test */
+static int rtw_tdls_dis_result(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+
+#ifdef CONFIG_TDLS
+#ifdef CONFIG_WFD
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
+
+	DBG_871X( "[%s]\n", __FUNCTION__);
+
+	if (ptdlsinfo->dev_discovered == _TRUE) {
+		sprintf( extra, "\n\nDis=1\n" );
+		ptdlsinfo->dev_discovered = _FALSE;
+	}
+	
+	wrqu->data.length = strlen( extra );
+
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_TDLS */
+
+	return ret;
+		
+}
+
+/* WFDTDLS, for sigma test */
+static int rtw_wfd_tdls_status(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+
+#ifdef CONFIG_TDLS
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
+
+	DBG_871X("[%s]\n", __FUNCTION__);
+
+	sprintf( extra, "\nlink_established:%d \n"
+		"sta_cnt:%d \n"
+		"sta_maximum:%d \n"
+		"cur_channel:%d \n"
+		"tdls_enable:%d"
+#ifdef CONFIG_TDLS_CH_SW
+		"ch_sw_state:%08x\n"
+		"chsw_on:%d\n"
+		"off_ch_num:%d\n"
+		"cur_time:%d\n"
+		"ch_offset:%d\n"
+		"delay_swtich_back:%d"
+#endif
+		,
+		ptdlsinfo->link_established, ptdlsinfo->sta_cnt,
+		ptdlsinfo->sta_maximum, ptdlsinfo->cur_channel, 
+		ptdlsinfo->tdls_enable
+#ifdef CONFIG_TDLS_CH_SW
+,
+		ptdlsinfo->chsw_info.ch_sw_state,
+		ATOMIC_READ(&padapter->tdlsinfo.chsw_info.chsw_on),
+		ptdlsinfo->chsw_info.off_ch_num,
+		ptdlsinfo->chsw_info.cur_time,
+		ptdlsinfo->chsw_info.ch_offset,
+		ptdlsinfo->chsw_info.delay_switch_back
+#endif
+);
+
+	wrqu->data.length = strlen( extra );
+
+#endif /* CONFIG_TDLS */
+
+	return ret;
+		
+	}
+
+static int rtw_tdls_getsta(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+	{
+	
+	int ret = 0;
+#ifdef CONFIG_TDLS
+	u8 i, j;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u8 addr[ETH_ALEN] = {0};
+	char charmac[17];
+	struct sta_info *ptdls_sta = NULL;
+
+	DBG_871X("[%s] %s %d\n", __FUNCTION__,
+		(char *)wrqu->data.pointer, wrqu->data.length -1);
+
+	if(copy_from_user(charmac, wrqu->data.pointer+9, 17)){
+		ret = -EFAULT;
+		goto exit;
+	}
+	
+	DBG_871X("[%s] %d, charmac:%s\n", __FUNCTION__, __LINE__, charmac);
+	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3)
+		addr[i]=key_2char2num(*(charmac+j), *(charmac+j+1));
+
+	DBG_871X("[%s] %d, charmac:%s, addr:"MAC_FMT"\n",
+		__FUNCTION__, __LINE__, charmac, MAC_ARG(addr));
+	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, addr);	
+	if(ptdls_sta) {
+		sprintf(extra, "\n\ntdls_sta_state=0x%08x\n", ptdls_sta->tdls_sta_state);
+		DBG_871X("\n\ntdls_sta_state=%d\n", ptdls_sta->tdls_sta_state);
+	} else {
+		sprintf(extra, "\n\nNot found this sta\n");
+		DBG_871X("\n\nNot found this sta\n");
+	}
+	wrqu->data.length = strlen( extra );
+
+#endif /* CONFIG_TDLS */
+exit:
+	return ret;
+		
+}
+
+static int rtw_tdls_get_best_ch(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+#ifdef CONFIG_FIND_BEST_CHANNEL	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
+
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		if (pmlmeext->channel_set[i].ChannelNum == 1)
+			index_24G = i;
+		if (pmlmeext->channel_set[i].ChannelNum == 36)
+			index_5G = i;
+	}
+	
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		/* 2.4G */
+		if (pmlmeext->channel_set[i].ChannelNum == 6 || pmlmeext->channel_set[i].ChannelNum == 11) {
+			if (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count) {
+				index_24G = i;
+				best_channel_24G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		/* 5G */
+		if (pmlmeext->channel_set[i].ChannelNum >= 36
+			&& pmlmeext->channel_set[i].ChannelNum < 140) {
+			 /* Find primary channel */
+			if (((pmlmeext->channel_set[i].ChannelNum - 36) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count)) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		if (pmlmeext->channel_set[i].ChannelNum >= 149
+			&& pmlmeext->channel_set[i].ChannelNum < 165) {
+			 /* Find primary channel */
+			if (((pmlmeext->channel_set[i].ChannelNum - 149) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count)) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+#if 1 /* debug */
+		DBG_871X("The rx cnt of channel %3d = %d\n", 
+					pmlmeext->channel_set[i].ChannelNum,
+					pmlmeext->channel_set[i].rx_count);
+#endif
+	}
+	
+	sprintf( extra, "\nbest_channel_24G = %d\n", best_channel_24G );
+	DBG_871X("best_channel_24G = %d\n", best_channel_24G);
+
+	if (index_5G != 0) {
+		sprintf(extra, "best_channel_5G = %d\n", best_channel_5G);
+		DBG_871X("best_channel_5G = %d\n", best_channel_5G);
+	}
+
+	wrqu->data.length = strlen( extra );
+
+#endif
+
+	return 0;
+
+}
+
+static int rtw_tdls(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	DBG_871X( "[%s] extra = %s\n", __FUNCTION__, extra );
+
+	if (hal_chk_wl_func(padapter, WL_FUNC_TDLS) == _FALSE) {
+		DBG_871X("Discard tdls oper since hal doesn't support tdls\n");
+		return 0;
+	}
+
+	if (padapter->tdlsinfo.tdls_enable == 0) {
+		DBG_871X("tdls haven't enabled\n");
+		return 0;
+	}
+
+	/* WFD Sigma will use the tdls enable command to let the driver know we want to test the tdls now! */
+
+	if (hal_chk_wl_func(padapter, WL_FUNC_MIRACAST)) {
+		if (_rtw_memcmp(extra, "wfdenable=", 10)) {
+			wrqu->data.length -= 10;
+			rtw_wx_tdls_wfd_enable(dev, info, wrqu, &extra[10]);
+			return ret;
+		}
+	}
+
+	if (_rtw_memcmp(extra, "weaksec=", 8)) {
+		wrqu->data.length -=8;
+		rtw_tdls_weaksec( dev, info, wrqu, &extra[8] );
+		return ret;
+	} else if (_rtw_memcmp( extra, "tdlsenable=", 11)) {
+		wrqu->data.length -=11;
+		rtw_tdls_enable( dev, info, wrqu, &extra[11] );
+		return ret;
+	}
+
+	if (_rtw_memcmp(extra, "setup=", 6)) {
+		wrqu->data.length -=6;
+		rtw_tdls_setup( dev, info, wrqu, &extra[6] );
+	} else if (_rtw_memcmp(extra, "tear=", 5)) {
+		wrqu->data.length -= 5;
+		rtw_tdls_teardown( dev, info, wrqu, &extra[5] );
+	} else if (_rtw_memcmp(extra, "dis=", 4)) {
+		wrqu->data.length -= 4;
+		rtw_tdls_discovery( dev, info, wrqu, &extra[4] );
+	} else if (_rtw_memcmp(extra, "swoff=", 6)) {
+		wrqu->data.length -= 6;
+		rtw_tdls_ch_switch_off(dev, info, wrqu, &extra[6]);
+	} else if (_rtw_memcmp(extra, "sw=", 3)) {
+		wrqu->data.length -= 3;
+		rtw_tdls_ch_switch( dev, info, wrqu, &extra[3] );
+	} else if (_rtw_memcmp(extra, "dumpstack=", 10)) {
+		wrqu->data.length -= 10;
+		rtw_tdls_dump_ch(dev, info, wrqu, &extra[10]);
+	} else if (_rtw_memcmp(extra, "offchnum=", 9)) {
+		wrqu->data.length -= 9;
+		rtw_tdls_off_ch_num(dev, info, wrqu, &extra[9]);
+	} else if (_rtw_memcmp(extra, "choffset=", 9)) {
+		wrqu->data.length -= 9;
+		rtw_tdls_ch_offset(dev, info, wrqu, &extra[9]);
+	} else if (_rtw_memcmp(extra, "pson=", 5)) {
+		wrqu->data.length -= 5;
+		rtw_tdls_pson( dev, info, wrqu, &extra[5] );
+	} else if (_rtw_memcmp(extra, "psoff=", 6)) {
+		wrqu->data.length -= 6;
+		rtw_tdls_psoff( dev, info, wrqu, &extra[6] );
+	}
+
+#ifdef CONFIG_WFD
+	if (hal_chk_wl_func(padapter, WL_FUNC_MIRACAST)) {
+		if (_rtw_memcmp(extra, "setip=", 6)) {
+			wrqu->data.length -= 6;
+			rtw_tdls_setip(dev, info, wrqu, &extra[6]);
+		} else if (_rtw_memcmp(extra, "tprobe=", 6)) {
+			issue_tunneled_probe_req((_adapter *)rtw_netdev_priv(dev));
+		}
+	}
+#endif /* CONFIG_WFD */
+
+#endif /* CONFIG_TDLS */
+	
+	return ret;
+}
+
+
+static int rtw_tdls_get(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TDLS
+
+	DBG_871X( "[%s] extra = %s\n", __FUNCTION__, (char*) wrqu->data.pointer );
+
+	if ( _rtw_memcmp( wrqu->data.pointer, "ip", 2 ) )
+		rtw_tdls_getip( dev, info, wrqu, extra );
+	else if (_rtw_memcmp(wrqu->data.pointer, "port", 4))
+		rtw_tdls_getport( dev, info, wrqu, extra );
+	/* WFDTDLS, for sigma test */
+	else if ( _rtw_memcmp(wrqu->data.pointer, "dis", 3))
+		rtw_tdls_dis_result( dev, info, wrqu, extra );
+	else if ( _rtw_memcmp(wrqu->data.pointer, "status", 6))
+		rtw_wfd_tdls_status( dev, info, wrqu, extra );
+	else if ( _rtw_memcmp(wrqu->data.pointer, "tdls_sta=", 9))
+		rtw_tdls_getsta( dev, info, wrqu, extra );
+	else if (_rtw_memcmp(wrqu->data.pointer, "best_ch", 7))
+		rtw_tdls_get_best_ch(dev, info, wrqu, extra);
+#endif /* CONFIG_TDLS */
+
+	return ret;
+}
+
+
+
+
+
+#ifdef CONFIG_INTEL_WIDI
+static int rtw_widi_set(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	process_intel_widi_cmd(padapter, extra);
+
+	return ret;
+}
+
+static int rtw_widi_set_probe_request(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	int	ret = 0;
+	u8	*pbuf = NULL;
+	_adapter	*padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	pbuf = rtw_malloc(sizeof(l2_msg_t));
+	if(pbuf)
+	{
+		if ( copy_from_user(pbuf, wrqu->data.pointer, wrqu->data.length) )
+			ret = -EFAULT;
+		//_rtw_memcpy(pbuf, wrqu->data.pointer, wrqu->data.length);
+
+		if( wrqu->data.flags == 0 )
+			intel_widi_wk_cmd(padapter, INTEL_WIDI_ISSUE_PROB_WK, pbuf, sizeof(l2_msg_t));
+		else if( wrqu->data.flags == 1 )
+			rtw_set_wfd_rds_sink_info( padapter, (l2_msg_t *)pbuf );
+	}
+	return ret;
+}
+#endif // CONFIG_INTEL_WIDI
+
+#ifdef CONFIG_MAC_LOOPBACK_DRIVER
+
+#if defined(CONFIG_RTL8188E)
+#include <rtl8188e_hal.h>
+extern void rtl8188e_cal_txdesc_chksum(struct tx_desc *ptxdesc);
+#define cal_txdesc_chksum rtl8188e_cal_txdesc_chksum
+#ifdef CONFIG_SDIO_HCI || defined(CONFIG_GSPI_HCI)
+extern void rtl8188es_fill_default_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf);
+#define fill_default_txdesc rtl8188es_fill_default_txdesc
+#endif // CONFIG_SDIO_HCI
+#endif // CONFIG_RTL8188E
+#if defined(CONFIG_RTL8723B)
+extern void rtl8723b_cal_txdesc_chksum(struct tx_desc *ptxdesc);
+#define cal_txdesc_chksum rtl8723b_cal_txdesc_chksum
+extern void rtl8723b_fill_default_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf);
+#define fill_default_txdesc rtl8723b_fill_default_txdesc
+#endif // CONFIG_RTL8723B
+
+#if defined(CONFIG_RTL8703B)
+/* extern void rtl8703b_cal_txdesc_chksum(struct tx_desc *ptxdesc); */
+#define cal_txdesc_chksum rtl8703b_cal_txdesc_chksum
+/* extern void rtl8703b_fill_default_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf); */
+#define fill_default_txdesc rtl8703b_fill_default_txdesc
+#endif /* CONFIG_RTL8703B */
+
+#if defined(CONFIG_RTL8192E)
+extern void rtl8192e_cal_txdesc_chksum(struct tx_desc *ptxdesc);
+#define cal_txdesc_chksum rtl8192e_cal_txdesc_chksum
+#ifdef CONFIG_SDIO_HCI || defined(CONFIG_GSPI_HCI)
+extern void rtl8192es_fill_default_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf);
+#define fill_default_txdesc rtl8192es_fill_default_txdesc
+#endif // CONFIG_SDIO_HCI
+#endif //CONFIG_RTL8192E
+
+static s32 initLoopback(PADAPTER padapter)
+{
+	PLOOPBACKDATA ploopback;
+
+
+	if (padapter->ploopback == NULL) {
+		ploopback = (PLOOPBACKDATA)rtw_zmalloc(sizeof(LOOPBACKDATA));
+		if (ploopback == NULL) return -ENOMEM;
+
+		_rtw_init_sema(&ploopback->sema, 0);
+		ploopback->bstop = _TRUE;
+		ploopback->cnt = 0;
+		ploopback->size = 300;
+		_rtw_memset(ploopback->msg, 0, sizeof(ploopback->msg));
+
+		padapter->ploopback = ploopback;
+	}
+
+	return 0;
+}
+
+static void freeLoopback(PADAPTER padapter)
+{
+	PLOOPBACKDATA ploopback;
+
+
+	ploopback = padapter->ploopback;
+	if (ploopback) {
+		rtw_mfree((u8*)ploopback, sizeof(LOOPBACKDATA));
+		padapter->ploopback = NULL;
+	}
+}
+
+static s32 initpseudoadhoc(PADAPTER padapter)
+{
+	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType;
+	s32 err;
+
+	networkType = Ndis802_11IBSS;
+	err = rtw_set_802_11_infrastructure_mode(padapter, networkType);
+	if (err == _FALSE) return _FAIL;
+
+	err = rtw_setopmode_cmd(padapter, networkType,_TRUE);
+	if (err == _FAIL) return _FAIL;
+
+	return _SUCCESS;
+}
+
+static s32 createpseudoadhoc(PADAPTER padapter)
+{
+	NDIS_802_11_AUTHENTICATION_MODE authmode;
+	struct mlme_priv *pmlmepriv;
+	NDIS_802_11_SSID *passoc_ssid;
+	WLAN_BSSID_EX *pdev_network;
+	u8 *pibss;
+	u8 ssid[] = "pseduo_ad-hoc";
+	s32 err;
+	_irqL irqL;
+
+
+	pmlmepriv = &padapter->mlmepriv;
+
+	authmode = Ndis802_11AuthModeOpen;
+	err = rtw_set_802_11_authentication_mode(padapter, authmode);
+	if (err == _FALSE) return _FAIL;
+
+	passoc_ssid = &pmlmepriv->assoc_ssid;
+	_rtw_memset(passoc_ssid, 0, sizeof(NDIS_802_11_SSID));
+	passoc_ssid->SsidLength = sizeof(ssid) - 1;
+	_rtw_memcpy(passoc_ssid->Ssid, ssid, passoc_ssid->SsidLength);
+
+	pdev_network = &padapter->registrypriv.dev_network;
+	pibss = padapter->registrypriv.dev_network.MacAddress;
+	_rtw_memcpy(&pdev_network->Ssid, passoc_ssid, sizeof(NDIS_802_11_SSID));
+
+	rtw_update_registrypriv_dev_network(padapter);
+	rtw_generate_random_ibss(pibss);
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+
+#if 0
+	err = rtw_create_ibss_cmd(padapter, 0);
+	if (err == _FAIL) return _FAIL;
+#else
+{
+	struct wlan_network *pcur_network;
+	struct sta_info *psta;
+
+	//3  create a new psta
+	pcur_network = &pmlmepriv->cur_network;
+
+	//clear psta in the cur_network, if any
+	psta = rtw_get_stainfo(&padapter->stapriv, pcur_network->network.MacAddress);
+	if (psta) rtw_free_stainfo(padapter, psta);
+
+	psta = rtw_alloc_stainfo(&padapter->stapriv, pibss);
+	if (psta == NULL) return _FAIL;
+
+	//3  join psudo AdHoc
+	pcur_network->join_res = 1;
+	pcur_network->aid = psta->aid = 1;
+	_rtw_memcpy(&pcur_network->network, pdev_network, get_WLAN_BSSID_EX_sz(pdev_network));
+
+	// set msr to WIFI_FW_ADHOC_STATE
+#if 0
+	Set_NETYPE0_MSR(padapter, WIFI_FW_ADHOC_STATE);
+#else
+	{
+		u8 val8;
+
+		val8 = rtw_read8(padapter, MSR);
+		val8 &= 0xFC; // clear NETYPE0
+		val8 |= WIFI_FW_ADHOC_STATE & 0x3;
+		rtw_write8(padapter, MSR, val8);
+	}
+#endif
+}
+#endif
+
+	return _SUCCESS;
+}
+
+static struct xmit_frame* createloopbackpkt(PADAPTER padapter, u32 size)
+{
+	struct xmit_priv *pxmitpriv;
+	struct xmit_frame *pframe;
+	struct xmit_buf *pxmitbuf;
+	struct pkt_attrib *pattrib;
+	struct tx_desc *desc;
+	u8 *pkt_start, *pkt_end, *ptr;
+	struct rtw_ieee80211_hdr *hdr;
+	s32 bmcast;
+	_irqL irqL;
+
+
+	if ((TXDESC_SIZE + WLANHDR_OFFSET + size) > MAX_XMITBUF_SZ) return NULL;
+
+	pxmitpriv = &padapter->xmitpriv;
+	pframe = NULL;
+
+	//2 1. allocate xmit frame
+	pframe = rtw_alloc_xmitframe(pxmitpriv);
+	if (pframe == NULL) return NULL;
+	pframe->padapter = padapter;
+
+	//2 2. allocate xmit buffer
+	_enter_critical_bh(&pxmitpriv->lock, &irqL);
+	pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
+	_exit_critical_bh(&pxmitpriv->lock, &irqL);
+	if (pxmitbuf == NULL) {
+		rtw_free_xmitframe(pxmitpriv, pframe);
+		return NULL;
+	}
+
+	pframe->pxmitbuf = pxmitbuf;
+	pframe->buf_addr = pxmitbuf->pbuf;
+	pxmitbuf->priv_data = pframe;
+
+	//2 3. update_attrib()
+	pattrib = &pframe->attrib;
+
+	// init xmitframe attribute
+	_rtw_memset(pattrib, 0, sizeof(struct pkt_attrib));
+
+	pattrib->ether_type = 0x8723;
+	_rtw_memcpy(pattrib->src, adapter_mac_addr(padapter), ETH_ALEN);
+	_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+	_rtw_memset(pattrib->dst, 0xFF, ETH_ALEN);
+	_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+
+//	pattrib->dhcp_pkt = 0;
+//	pattrib->pktlen = 0;
+	pattrib->ack_policy = 0;
+//	pattrib->pkt_hdrlen = ETH_HLEN;
+	pattrib->hdrlen = WLAN_HDR_A3_LEN;
+	pattrib->subtype = WIFI_DATA;
+	pattrib->priority = 0;
+	pattrib->qsel = pattrib->priority;
+//	do_queue_select(padapter, pattrib);
+	pattrib->nr_frags = 1;
+	pattrib->encrypt = 0;
+	pattrib->bswenc = _FALSE;
+	pattrib->qos_en = _FALSE;
+
+	bmcast = IS_MCAST(pattrib->ra);
+	if (bmcast) {
+		pattrib->mac_id = 1;
+		pattrib->psta = rtw_get_bcmc_stainfo(padapter);
+	} else {
+		pattrib->mac_id = 0;
+		pattrib->psta = rtw_get_stainfo(&padapter->stapriv, get_bssid(&padapter->mlmepriv));
+	}
+
+	pattrib->pktlen = size;
+	pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->pktlen;
+
+	//2 4. fill TX descriptor
+	desc = (struct tx_desc*)pframe->buf_addr;
+	_rtw_memset(desc, 0, TXDESC_SIZE);
+
+	fill_default_txdesc(pframe, (u8*)desc);
+
+	// Hw set sequence number
+	((PTXDESC)desc)->hwseq_en = 0; // HWSEQ_EN, 0:disable, 1:enable
+//	((PTXDESC)desc)->hwseq_sel = 0; // HWSEQ_SEL
+
+	((PTXDESC)desc)->disdatafb = 1;
+
+	// convert to little endian
+	desc->txdw0 = cpu_to_le32(desc->txdw0);
+	desc->txdw1 = cpu_to_le32(desc->txdw1);
+	desc->txdw2 = cpu_to_le32(desc->txdw2);
+	desc->txdw3 = cpu_to_le32(desc->txdw3);
+	desc->txdw4 = cpu_to_le32(desc->txdw4);
+	desc->txdw5 = cpu_to_le32(desc->txdw5);
+	desc->txdw6 = cpu_to_le32(desc->txdw6);
+	desc->txdw7 = cpu_to_le32(desc->txdw7);
+#ifdef CONFIG_PCI_HCI
+	desc->txdw8 = cpu_to_le32(desc->txdw8);
+	desc->txdw9 = cpu_to_le32(desc->txdw9);
+	desc->txdw10 = cpu_to_le32(desc->txdw10);
+	desc->txdw11 = cpu_to_le32(desc->txdw11);
+	desc->txdw12 = cpu_to_le32(desc->txdw12);
+	desc->txdw13 = cpu_to_le32(desc->txdw13);
+	desc->txdw14 = cpu_to_le32(desc->txdw14);
+	desc->txdw15 = cpu_to_le32(desc->txdw15);
+#endif
+
+	cal_txdesc_chksum(desc);
+
+	//2 5. coalesce
+	pkt_start = pframe->buf_addr + TXDESC_SIZE;
+	pkt_end = pkt_start + pattrib->last_txcmdsz;
+
+	//3 5.1. make wlan header, make_wlanhdr()
+	hdr = (struct rtw_ieee80211_hdr *)pkt_start;
+	SetFrameSubType(&hdr->frame_ctl, pattrib->subtype);
+	_rtw_memcpy(hdr->addr1, pattrib->dst, ETH_ALEN); // DA
+	_rtw_memcpy(hdr->addr2, pattrib->src, ETH_ALEN); // SA
+	_rtw_memcpy(hdr->addr3, get_bssid(&padapter->mlmepriv), ETH_ALEN); // RA, BSSID
+
+	//3 5.2. make payload
+	ptr = pkt_start + pattrib->hdrlen;
+	get_random_bytes(ptr, pkt_end - ptr);
+
+	pxmitbuf->len = TXDESC_SIZE + pattrib->last_txcmdsz;
+	pxmitbuf->ptail += pxmitbuf->len;
+
+	return pframe;
+}
+
+static void freeloopbackpkt(PADAPTER padapter, struct xmit_frame *pframe)
+{
+	struct xmit_priv *pxmitpriv;
+	struct xmit_buf *pxmitbuf;
+
+
+	pxmitpriv = &padapter->xmitpriv;
+	pxmitbuf = pframe->pxmitbuf;
+
+	rtw_free_xmitframe(pxmitpriv, pframe);
+	rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+}
+
+static void printdata(u8 *pbuf, u32 len)
+{
+	u32 i, val;
+
+
+	for (i = 0; (i+4) <= len; i+=4) {
+		printk("%08X", *(u32*)(pbuf + i));
+		if ((i+4) & 0x1F) printk(" ");
+		else printk("\n");
+	}
+
+	if (i < len)
+	{
+#ifdef CONFIG_BIG_ENDIAN
+		for (; i < len, i++)
+			printk("%02X", pbuf+i);
+#else // CONFIG_LITTLE_ENDIAN
+#if 0
+		val = 0;
+		_rtw_memcpy(&val, pbuf + i, len - i);
+		printk("%8X", val);
+#else
+		u8 str[9];
+		u8 n;
+		val = 0;
+		n = len - i;
+		_rtw_memcpy(&val, pbuf+i, n);
+		sprintf(str, "%08X", val);
+		n = (4 - n) * 2;
+		printk("%8s", str+n);
+#endif
+#endif // CONFIG_LITTLE_ENDIAN
+	}
+	printk("\n");
+}
+
+static u8 pktcmp(PADAPTER padapter, u8 *txbuf, u32 txsz, u8 *rxbuf, u32 rxsz)
+{
+	PHAL_DATA_TYPE phal;
+	struct recv_stat *prxstat;
+	struct recv_stat report;
+	PRXREPORT prxreport;
+	u32 drvinfosize;
+	u32 rxpktsize;
+	u8 fcssize;
+	u8 ret = _FALSE;
+
+	prxstat = (struct recv_stat*)rxbuf;
+	report.rxdw0 = le32_to_cpu(prxstat->rxdw0);
+	report.rxdw1 = le32_to_cpu(prxstat->rxdw1);
+	report.rxdw2 = le32_to_cpu(prxstat->rxdw2);
+	report.rxdw3 = le32_to_cpu(prxstat->rxdw3);
+	report.rxdw4 = le32_to_cpu(prxstat->rxdw4);
+	report.rxdw5 = le32_to_cpu(prxstat->rxdw5);
+
+	prxreport = (PRXREPORT)&report;
+	drvinfosize = prxreport->drvinfosize << 3;
+	rxpktsize = prxreport->pktlen;
+
+	phal = GET_HAL_DATA(padapter);
+	if (phal->ReceiveConfig & RCR_APPFCS) fcssize = IEEE80211_FCS_LEN;
+	else fcssize = 0;
+
+	if ((txsz - TXDESC_SIZE) != (rxpktsize - fcssize)) {
+		DBG_8192C("%s: ERROR! size not match tx/rx=%d/%d !\n",
+			__func__, txsz - TXDESC_SIZE, rxpktsize - fcssize);
+		ret = _FALSE;
+	} else {
+		ret = _rtw_memcmp(txbuf + TXDESC_SIZE,\
+						  rxbuf + RXDESC_SIZE + drvinfosize,\
+						  txsz - TXDESC_SIZE);
+		if (ret == _FALSE) {
+			DBG_8192C("%s: ERROR! pkt content mismatch!\n", __func__);
+		}
+	}
+
+	if (ret == _FALSE)
+	{
+		DBG_8192C("\n%s: TX PKT total=%d, desc=%d, content=%d\n",
+			__func__, txsz, TXDESC_SIZE, txsz - TXDESC_SIZE);
+		DBG_8192C("%s: TX DESC size=%d\n", __func__, TXDESC_SIZE);
+		printdata(txbuf, TXDESC_SIZE);
+		DBG_8192C("%s: TX content size=%d\n", __func__, txsz - TXDESC_SIZE);
+		printdata(txbuf + TXDESC_SIZE, txsz - TXDESC_SIZE);
+
+		DBG_8192C("\n%s: RX PKT read=%d offset=%d(%d,%d) content=%d\n",
+			__func__, rxsz, RXDESC_SIZE + drvinfosize, RXDESC_SIZE, drvinfosize, rxpktsize);
+		if (rxpktsize != 0)
+		{
+			DBG_8192C("%s: RX DESC size=%d\n", __func__, RXDESC_SIZE);
+			printdata(rxbuf, RXDESC_SIZE);
+			DBG_8192C("%s: RX drvinfo size=%d\n", __func__, drvinfosize);
+			printdata(rxbuf + RXDESC_SIZE, drvinfosize);
+			DBG_8192C("%s: RX content size=%d\n", __func__, rxpktsize);
+			printdata(rxbuf + RXDESC_SIZE + drvinfosize, rxpktsize);
+		} else {
+			DBG_8192C("%s: RX data size=%d\n", __func__, rxsz);
+			printdata(rxbuf, rxsz);
+		}
+	}
+
+	return ret;
+}
+
+thread_return lbk_thread(thread_context context)
+{
+	s32 err;
+	PADAPTER padapter;
+	PLOOPBACKDATA ploopback;
+	struct xmit_frame *pxmitframe;
+	u32 cnt, ok, fail, headerlen;
+	u32 pktsize;
+	u32 ff_hwaddr;
+
+
+	padapter = (PADAPTER)context;
+	ploopback = padapter->ploopback;
+	if (ploopback == NULL) return -1;
+	cnt = 0;
+	ok = 0;
+	fail = 0;
+
+	daemonize("%s", "RTW_LBK_THREAD");
+	allow_signal(SIGTERM);
+
+	do {
+		if (ploopback->size == 0) {
+			get_random_bytes(&pktsize, 4);
+			pktsize = (pktsize % 1535) + 1; // 1~1535
+		} else
+			pktsize = ploopback->size;
+		
+		pxmitframe = createloopbackpkt(padapter, pktsize);
+		if (pxmitframe == NULL) {
+			sprintf(ploopback->msg, "loopback FAIL! 3. create Packet FAIL!");
+			break;
+		}
+
+		ploopback->txsize = TXDESC_SIZE + pxmitframe->attrib.last_txcmdsz;
+		_rtw_memcpy(ploopback->txbuf, pxmitframe->buf_addr, ploopback->txsize);
+		ff_hwaddr = rtw_get_ff_hwaddr(pxmitframe);
+		cnt++;
+		DBG_8192C("%s: wirte port cnt=%d size=%d\n", __func__, cnt, ploopback->txsize);
+		pxmitframe->pxmitbuf->pdata = ploopback->txbuf;
+		rtw_write_port(padapter, ff_hwaddr, ploopback->txsize, (u8 *)pxmitframe->pxmitbuf);
+
+		// wait for rx pkt
+		_rtw_down_sema(&ploopback->sema);
+
+		err = pktcmp(padapter, ploopback->txbuf, ploopback->txsize, ploopback->rxbuf, ploopback->rxsize);
+		if (err == _TRUE)
+			ok++;
+		else
+			fail++;
+
+		ploopback->txsize = 0;
+		_rtw_memset(ploopback->txbuf, 0, 0x8000);
+		ploopback->rxsize = 0;
+		_rtw_memset(ploopback->rxbuf, 0, 0x8000);
+
+		freeloopbackpkt(padapter, pxmitframe);
+		pxmitframe = NULL;
+
+		if (signal_pending(current)) {
+			flush_signals(current);
+		}
+
+		if ((ploopback->bstop == _TRUE) ||
+			((ploopback->cnt != 0) && (ploopback->cnt == cnt)))
+		{
+			u32 ok_rate, fail_rate, all;
+			all = cnt;
+			ok_rate = (ok*100)/all;
+			fail_rate = (fail*100)/all;
+			sprintf(ploopback->msg,\
+					"loopback result: ok=%d%%(%d/%d),error=%d%%(%d/%d)",\
+					ok_rate, ok, all, fail_rate, fail, all);
+			break;
+		}
+	} while (1);
+
+	ploopback->bstop = _TRUE;
+
+	thread_exit();
+}
+
+static void loopbackTest(PADAPTER padapter, u32 cnt, u32 size, u8* pmsg)
+{
+	PLOOPBACKDATA ploopback;
+	u32 len;
+	s32 err;
+
+
+	ploopback = padapter->ploopback;
+
+	if (ploopback)
+	{
+		if (ploopback->bstop == _FALSE) {
+			ploopback->bstop = _TRUE;
+			_rtw_up_sema(&ploopback->sema);
+		}
+		len = 0;
+		do {
+			len = strlen(ploopback->msg);
+			if (len) break;
+			rtw_msleep_os(1);
+		} while (1);
+		_rtw_memcpy(pmsg, ploopback->msg, len+1);
+		freeLoopback(padapter);
+
+		return;
+	}
+
+	// disable dynamic algorithm	
+	rtw_phydm_ability_backup(padapter);
+	rtw_phydm_func_disable_all(padapter);
+
+	// create pseudo ad-hoc connection
+	err = initpseudoadhoc(padapter);
+	if (err == _FAIL) {
+		sprintf(pmsg, "loopback FAIL! 1.1 init ad-hoc FAIL!");
+		return;
+	}
+
+	err = createpseudoadhoc(padapter);
+	if (err == _FAIL) {
+		sprintf(pmsg, "loopback FAIL! 1.2 create ad-hoc master FAIL!");
+		return;
+	}
+
+	err = initLoopback(padapter);
+	if (err) {
+		sprintf(pmsg, "loopback FAIL! 2. init FAIL! error code=%d", err);
+		return;
+	}
+
+	ploopback = padapter->ploopback;
+
+	ploopback->bstop = _FALSE;
+	ploopback->cnt = cnt;
+	ploopback->size = size;
+	ploopback->lbkthread = kthread_run(lbk_thread, padapter, "RTW_LBK_THREAD");
+	if (IS_ERR(padapter->lbkthread))
+	{
+		freeLoopback(padapter);
+		sprintf(pmsg, "loopback start FAIL! cnt=%d", cnt);
+		return;
+	}
+
+	sprintf(pmsg, "loopback start! cnt=%d", cnt);
+}
+#endif // CONFIG_MAC_LOOPBACK_DRIVER
+
+static int rtw_test(
+	struct net_device *dev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu, char *extra)
+{
+	u32 len;
+	u8 *pbuf, *pch;
+	char *ptmp;
+	u8 *delim = ",";
+	PADAPTER padapter = rtw_netdev_priv(dev);
+
+
+	DBG_871X("+%s\n", __func__);
+	len = wrqu->data.length;
+
+	pbuf = (u8*)rtw_zmalloc(len);
+	if (pbuf == NULL) {
+		DBG_871X("%s: no memory!\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(pbuf, wrqu->data.pointer, len)) {
+		rtw_mfree(pbuf, len);
+		DBG_871X("%s: copy from user fail!\n", __func__);
+		return -EFAULT;
+	}
+	DBG_871X("%s: string=\"%s\"\n", __func__, pbuf);
+
+	ptmp = (char*)pbuf;
+	pch = strsep(&ptmp, delim);
+	if ((pch == NULL) || (strlen(pch) == 0)) {
+		rtw_mfree(pbuf, len);
+		DBG_871X("%s: parameter error(level 1)!\n", __func__);
+		return -EFAULT;
+	}
+
+#ifdef CONFIG_MAC_LOOPBACK_DRIVER
+	if (strcmp(pch, "loopback") == 0)
+	{
+		s32 cnt = 0;
+		u32 size = 64;
+
+		pch = strsep(&ptmp, delim);
+		if ((pch == NULL) || (strlen(pch) == 0)) {
+			rtw_mfree(pbuf, len);
+			DBG_871X("%s: parameter error(level 2)!\n", __func__);
+			return -EFAULT;
+		}
+
+		sscanf(pch, "%d", &cnt);
+		DBG_871X("%s: loopback cnt=%d\n", __func__, cnt);
+
+		pch = strsep(&ptmp, delim);
+		if ((pch == NULL) || (strlen(pch) == 0)) {
+			rtw_mfree(pbuf, len);
+			DBG_871X("%s: parameter error(level 2)!\n", __func__);
+			return -EFAULT;
+		}
+
+		sscanf(pch, "%d", &size);
+		DBG_871X("%s: loopback size=%d\n", __func__, size);
+
+		loopbackTest(padapter, cnt, size, extra);
+		wrqu->data.length = strlen(extra) + 1;
+
+		goto free_buf;
+	}
+#endif
+
+
+#ifdef CONFIG_BT_COEXIST
+	if (strcmp(pch, "bton") == 0) {
+		rtw_btcoex_SetManualControl(padapter, _FALSE);
+		goto free_buf;
+	} else if (strcmp(pch, "btoff") == 0) {
+		rtw_btcoex_SetManualControl(padapter, _TRUE);
+		goto free_buf;
+	}
+#endif
+
+	if (strcmp(pch, "h2c") == 0) {
+		u8 param[8];
+		u8 count = 0;
+		u32 tmp;
+		u8 i;
+		u32 pos;
+		s32 ret;
+
+		do {
+			pch = strsep(&ptmp, delim);
+			if ((pch == NULL) || (strlen(pch) == 0))
+				break;
+
+			sscanf(pch, "%x", &tmp);
+			param[count++] = (u8)tmp;
+		} while (count < 8);
+
+		if (count == 0) {
+			rtw_mfree(pbuf, len);
+			DBG_871X("%s: parameter error(level 2)!\n", __func__);
+			return -EFAULT;
+		}
+
+		ret = rtw_hal_fill_h2c_cmd(padapter, param[0], count-1, &param[1]);
+
+		pos = sprintf(extra, "H2C ID=0x%02x content=", param[0]);
+		for (i=1; i<count; i++) {
+			pos += sprintf(extra+pos, "%02x,", param[i]);
+		}
+		extra[pos] = 0;
+		pos--;
+		pos += sprintf(extra+pos, " %s", ret==_FAIL?"FAIL":"OK");
+
+		wrqu->data.length = strlen(extra) + 1;
+
+		goto free_buf;
+	}
+
+free_buf:
+	rtw_mfree(pbuf, len);
+	return 0;
+}
+
+static iw_handler rtw_handlers[] =
+{
+	NULL,					/* SIOCSIWCOMMIT */
+	rtw_wx_get_name,		/* SIOCGIWNAME */
+	dummy,					/* SIOCSIWNWID */
+	dummy,					/* SIOCGIWNWID */
+	rtw_wx_set_freq,		/* SIOCSIWFREQ */
+	rtw_wx_get_freq,		/* SIOCGIWFREQ */
+	rtw_wx_set_mode,		/* SIOCSIWMODE */
+	rtw_wx_get_mode,		/* SIOCGIWMODE */
+	dummy,					/* SIOCSIWSENS */
+	rtw_wx_get_sens,		/* SIOCGIWSENS */
+	NULL,					/* SIOCSIWRANGE */
+	rtw_wx_get_range,		/* SIOCGIWRANGE */
+	rtw_wx_set_priv,		/* SIOCSIWPRIV */
+	NULL,					/* SIOCGIWPRIV */
+	NULL,					/* SIOCSIWSTATS */
+	NULL,					/* SIOCGIWSTATS */
+	dummy,					/* SIOCSIWSPY */
+	dummy,					/* SIOCGIWSPY */
+	NULL,					/* SIOCGIWTHRSPY */
+	NULL,					/* SIOCWIWTHRSPY */
+	rtw_wx_set_wap,		/* SIOCSIWAP */
+	rtw_wx_get_wap,		/* SIOCGIWAP */
+	rtw_wx_set_mlme,		/* request MLME operation; uses struct iw_mlme */
+	dummy,					/* SIOCGIWAPLIST -- depricated */
+	rtw_wx_set_scan,		/* SIOCSIWSCAN */
+	rtw_wx_get_scan,		/* SIOCGIWSCAN */
+	rtw_wx_set_essid,		/* SIOCSIWESSID */
+	rtw_wx_get_essid,		/* SIOCGIWESSID */
+	dummy,					/* SIOCSIWNICKN */
+	rtw_wx_get_nick,		/* SIOCGIWNICKN */
+	NULL,					/* -- hole -- */
+	NULL,					/* -- hole -- */
+	rtw_wx_set_rate,		/* SIOCSIWRATE */
+	rtw_wx_get_rate,		/* SIOCGIWRATE */
+	rtw_wx_set_rts,			/* SIOCSIWRTS */
+	rtw_wx_get_rts,			/* SIOCGIWRTS */
+	rtw_wx_set_frag,		/* SIOCSIWFRAG */
+	rtw_wx_get_frag,		/* SIOCGIWFRAG */
+	dummy,					/* SIOCSIWTXPOW */
+	dummy,					/* SIOCGIWTXPOW */
+	dummy,					/* SIOCSIWRETRY */
+	rtw_wx_get_retry,		/* SIOCGIWRETRY */
+	rtw_wx_set_enc,			/* SIOCSIWENCODE */
+	rtw_wx_get_enc,			/* SIOCGIWENCODE */
+	dummy,					/* SIOCSIWPOWER */
+	rtw_wx_get_power,		/* SIOCGIWPOWER */
+	NULL,					/*---hole---*/
+	NULL,					/*---hole---*/
+	rtw_wx_set_gen_ie,		/* SIOCSIWGENIE */
+	NULL,					/* SIOCGWGENIE */
+	rtw_wx_set_auth,		/* SIOCSIWAUTH */
+	NULL,					/* SIOCGIWAUTH */
+	rtw_wx_set_enc_ext,		/* SIOCSIWENCODEEXT */
+	NULL,					/* SIOCGIWENCODEEXT */
+	rtw_wx_set_pmkid,		/* SIOCSIWPMKSA */
+	NULL,					/*---hole---*/
+}; 
+
+
+static const struct iw_priv_args rtw_private_args[] = {
+	{
+		SIOCIWFIRSTPRIV + 0x0,
+		IW_PRIV_TYPE_CHAR | 0x7FF, 0, "write"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x1,
+		IW_PRIV_TYPE_CHAR | 0x7FF,
+		IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "read"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x2, 0, 0, "driver_ext"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x3, 0, 0, "mp_ioctl"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x4,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "apinfo"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x5,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "setpid"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x6,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_start"
+	},
+//for PLATFORM_MT53XX	
+	{
+		SIOCIWFIRSTPRIV + 0x7,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "get_sensitivity"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x8,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_prob_req_ie"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x9,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_assoc_req_ie"
+	},
+
+//for RTK_DMP_PLATFORM	
+	{
+		SIOCIWFIRSTPRIV + 0xA,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "channel_plan"
+	},
+
+	{
+		SIOCIWFIRSTPRIV + 0xB,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "dbg"
+	},	
+	{
+		SIOCIWFIRSTPRIV + 0xC,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3, 0, "rfw"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0xD,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "rfr"
+	},
+#if 0
+	{
+		SIOCIWFIRSTPRIV + 0xE,0,0, "wowlan_ctrl"
+	},
+#endif
+	{
+		SIOCIWFIRSTPRIV + 0x10,
+		IW_PRIV_TYPE_CHAR | 1024, 0, "p2p_set"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x11,
+		IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , "p2p_get"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x12, 0, 0, "NULL"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x13,
+		IW_PRIV_TYPE_CHAR | 64, IW_PRIV_TYPE_CHAR | 64 , "p2p_get2"
+	},	
+	{
+		SIOCIWFIRSTPRIV + 0x14,
+		IW_PRIV_TYPE_CHAR  | 64, 0, "tdls"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x15,
+		IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024 , "tdls_get"
+	},	
+	{
+		SIOCIWFIRSTPRIV + 0x16,
+		IW_PRIV_TYPE_CHAR | 64, 0, "pm_set"
+	},
+
+	{SIOCIWFIRSTPRIV + 0x18, IW_PRIV_TYPE_CHAR | IFNAMSIZ , 0 , "rereg_nd_name"},
+#ifdef CONFIG_MP_INCLUDED
+	{SIOCIWFIRSTPRIV + 0x1A, IW_PRIV_TYPE_CHAR | 1024, 0,  "NULL"},
+	{SIOCIWFIRSTPRIV + 0x1B, IW_PRIV_TYPE_CHAR | 128, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "NULL"},
+#else
+	{SIOCIWFIRSTPRIV + 0x1A, IW_PRIV_TYPE_CHAR | 1024, 0, "efuse_set"},
+	{SIOCIWFIRSTPRIV + 0x1B, IW_PRIV_TYPE_CHAR | 128, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_get"},
+#endif
+	{
+		SIOCIWFIRSTPRIV + 0x1D,
+		IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 0x7FF, "test"
+	},
+
+#ifdef CONFIG_INTEL_WIDI
+	{
+		SIOCIWFIRSTPRIV + 0x1E,
+		IW_PRIV_TYPE_CHAR | 1024, 0, "widi_set"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x1F,
+		IW_PRIV_TYPE_CHAR | 128, 0, "widi_prob_req"
+	},
+#endif // CONFIG_INTEL_WIDI
+
+#ifdef CONFIG_MP_INCLUDED
+	{ SIOCIWFIRSTPRIV + 0x0E, IW_PRIV_TYPE_CHAR | 1024, 0 , ""},  //set 
+	{ SIOCIWFIRSTPRIV + 0x0F, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , ""},//get
+/* --- sub-ioctls definitions --- */   
+		{ MP_START , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_start" }, //set
+		{ MP_PHYPARA, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_phypara" },//get
+		{ MP_STOP , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_stop" }, //set
+		{ MP_CHANNEL , IW_PRIV_TYPE_CHAR | 1024 , IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_channel" },//get
+		{ MP_BANDWIDTH , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_bandwidth"}, //set
+		{ MP_RATE , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_rate" },//get
+		{ MP_RESET_STATS , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_reset_stats"},
+		{ MP_QUERY , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , "mp_query"}, //get
+		{ READ_REG , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "read_reg" },
+		{ MP_RATE , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_rate" },
+		{ READ_RF , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "read_rf" },
+		{ MP_PSD , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_psd"}, 
+		{ MP_DUMP, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_dump" },
+		{ MP_TXPOWER , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_txpower"},
+		{ MP_ANT_TX , IW_PRIV_TYPE_CHAR | 1024,  IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ant_tx"},
+		{ MP_ANT_RX , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ant_rx"},
+		{ WRITE_REG , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "write_reg" },
+		{ WRITE_RF , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "write_rf" },
+		{ MP_CTX , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ctx"},
+		{ MP_ARX , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_arx"},
+		{ MP_THER , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ther"},
+		{ EFUSE_SET, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_set" },
+		{ EFUSE_GET, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_get" },
+		{ MP_PWRTRK , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_pwrtrk"},
+		{ MP_QueryDrvStats, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_drvquery" },
+		{ MP_IOCTL, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_ioctl"}, // mp_ioctl	
+		{ MP_SetRFPathSwh, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_setrfpath" },		
+		{ MP_PwrCtlDM, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_pwrctldm" },		
+		{ MP_GET_TXPOWER_INX, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_get_txpower" },
+		{ MP_GETVER, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_priv_ver" },
+		{ MP_MON, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_mon" },
+		{ EFUSE_MASK, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_mask" },
+		{ EFUSE_FILE, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_file" },
+		{ MP_TX, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_tx" },
+		{ MP_RX, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_rx" },
+#if defined(CONFIG_RTL8723B)
+		{ MP_SetBT, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_setbt" },
+        { MP_DISABLE_BT_COEXIST, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_disa_btcoex"},
+#endif
+		{ CTA_TEST, IW_PRIV_TYPE_CHAR | 1024, 0, "cta_test"},
+#endif
+#ifdef CONFIG_WOWLAN
+		{ MP_WOW_ENABLE , IW_PRIV_TYPE_CHAR | 1024, 0, "wow_mode" },
+		{ MP_WOW_SET_PATTERN , IW_PRIV_TYPE_CHAR | 1024, 0, "wow_set_pattern" },
+#endif
+#ifdef CONFIG_AP_WOWLAN
+		{ MP_AP_WOW_ENABLE , IW_PRIV_TYPE_CHAR | 1024, 0, "ap_wow_mode" }, //set 
+#endif
+#ifdef CONFIG_SDIO_INDIRECT_ACCESS
+		{ MP_SD_IREAD, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "sd_iread" },
+		{ MP_SD_IWRITE, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "sd_iwrite" },
+#endif
+};
+
+static iw_handler rtw_private_handler[] = 
+{
+	rtw_wx_write32,					//0x00
+	rtw_wx_read32,					//0x01
+	rtw_drvext_hdl,					//0x02
+	rtw_mp_ioctl_hdl,				//0x03
+
+// for MM DTV platform
+	rtw_get_ap_info,					//0x04
+
+	rtw_set_pid,						//0x05
+	rtw_wps_start,					//0x06
+
+// for PLATFORM_MT53XX
+	rtw_wx_get_sensitivity,			//0x07
+	rtw_wx_set_mtk_wps_probe_ie,	//0x08
+	rtw_wx_set_mtk_wps_ie,			//0x09
+
+// for RTK_DMP_PLATFORM
+// Set Channel depend on the country code
+	rtw_wx_set_channel_plan,		//0x0A
+
+	rtw_dbg_port,					//0x0B
+	rtw_wx_write_rf,					//0x0C
+	rtw_wx_read_rf,					//0x0D
+#ifdef CONFIG_MP_INCLUDED
+	rtw_mp_set,					//0x0E
+	rtw_mp_get,					//0x0F
+#else
+	rtw_wx_priv_null,				//0x0E
+	rtw_wx_priv_null,				//0x0F
+#endif
+	rtw_p2p_set,					//0x10
+	rtw_p2p_get,					//0x11
+	NULL,							//0x12
+	rtw_p2p_get2,					//0x13
+
+	rtw_tdls,						//0x14
+	rtw_tdls_get,					//0x15
+
+	rtw_pm_set,						//0x16
+	rtw_wx_priv_null,				//0x17
+	rtw_rereg_nd_name,				//0x18
+	rtw_wx_priv_null,				//0x19
+#ifdef CONFIG_MP_INCLUDED
+	rtw_wx_priv_null,				//0x1A
+	rtw_wx_priv_null,				//0x1B
+#else
+	rtw_mp_efuse_set,				//0x1A
+	rtw_mp_efuse_get,				//0x1B
+#endif
+	NULL,							// 0x1C is reserved for hostapd
+	rtw_test,						// 0x1D
+#ifdef CONFIG_INTEL_WIDI
+	rtw_widi_set,					//0x1E
+	rtw_widi_set_probe_request,		//0x1F
+#endif // CONFIG_INTEL_WIDI
+};
+
+
+#if WIRELESS_EXT >= 17	
+static struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)
+{
+       _adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	   struct iw_statistics *piwstats=&padapter->iwstats;
+	int tmp_level = 0;
+	int tmp_qual = 0;
+	int tmp_noise = 0;
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) != _TRUE)
+	{
+		piwstats->qual.qual = 0;
+		piwstats->qual.level = 0;
+		piwstats->qual.noise = 0;
+		//DBG_871X("No link  level:%d, qual:%d, noise:%d\n", tmp_level, tmp_qual, tmp_noise);
+	}
+	else{
+		#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+		tmp_level = translate_percentage_to_dbm(padapter->recvpriv.signal_strength); 
+		#else
+		#ifdef CONFIG_SIGNAL_SCALE_MAPPING
+		tmp_level = padapter->recvpriv.signal_strength;
+		#else
+		{
+			/* Do signal scale mapping when using percentage as the unit of signal strength, since the scale mapping is skipped in odm */
+			
+			HAL_DATA_TYPE *pHal = GET_HAL_DATA(padapter);
+			
+			tmp_level = (u8)odm_SignalScaleMapping(&pHal->odmpriv, padapter->recvpriv.signal_strength);
+		}
+		#endif
+		#endif
+		
+		tmp_qual = padapter->recvpriv.signal_qual;
+		rtw_get_noise(padapter);
+		tmp_noise = padapter->recvpriv.noise;
+		//DBG_871X("level:%d, qual:%d, noise:%d, rssi (%d)\n", tmp_level, tmp_qual, tmp_noise,padapter->recvpriv.rssi);
+
+		piwstats->qual.level = tmp_level;
+		piwstats->qual.qual = tmp_qual;
+		piwstats->qual.noise = tmp_noise;
+	}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14))
+	piwstats->qual.updated = IW_QUAL_ALL_UPDATED ;//|IW_QUAL_DBM;
+#else
+#ifdef RTK_DMP_PLATFORM
+	//IW_QUAL_DBM= 0x8, if driver use this flag, wireless extension will show value of dbm.
+	//remove this flag for show percentage 0~100
+	piwstats->qual.updated = 0x07;
+#else
+	piwstats->qual.updated = 0x0f;
+#endif
+#endif
+
+	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+	piwstats->qual.updated = piwstats->qual.updated | IW_QUAL_DBM;
+	#endif
+
+	return &padapter->iwstats;
+}
+#endif
+
+#ifdef CONFIG_WIRELESS_EXT
+struct iw_handler_def rtw_handlers_def =
+{
+	.standard = rtw_handlers,
+	.num_standard = sizeof(rtw_handlers) / sizeof(iw_handler),
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)) || defined(CONFIG_WEXT_PRIV)
+	.private = rtw_private_handler,
+	.private_args = (struct iw_priv_args *)rtw_private_args,
+	.num_private = sizeof(rtw_private_handler) / sizeof(iw_handler),
+ 	.num_private_args = sizeof(rtw_private_args) / sizeof(struct iw_priv_args),
+#endif
+#if WIRELESS_EXT >= 17
+	.get_wireless_stats = rtw_get_wireless_stats,
+#endif
+};
+#endif
+
+// copy from net/wireless/wext.c start
+/* ---------------------------------------------------------------- */
+/*
+ * Calculate size of private arguments
+ */
+static const char iw_priv_type_size[] = {
+	0,                              /* IW_PRIV_TYPE_NONE */
+	1,                              /* IW_PRIV_TYPE_BYTE */
+	1,                              /* IW_PRIV_TYPE_CHAR */
+	0,                              /* Not defined */
+	sizeof(__u32),                  /* IW_PRIV_TYPE_INT */
+	sizeof(struct iw_freq),         /* IW_PRIV_TYPE_FLOAT */
+	sizeof(struct sockaddr),        /* IW_PRIV_TYPE_ADDR */
+	0,                              /* Not defined */
+};
+
+static int get_priv_size(__u16 args)
+{
+	int num = args & IW_PRIV_SIZE_MASK;
+	int type = (args & IW_PRIV_TYPE_MASK) >> 12;
+
+	return num * iw_priv_type_size[type];
+}
+// copy from net/wireless/wext.c end
+
+
+static int _rtw_ioctl_wext_private(struct net_device *dev, union iwreq_data *wrq_data)
+{
+	int err = 0;
+	u8 *input = NULL;
+	u32 input_len = 0;
+	const char delim[] = " ";
+	u8 *output = NULL;
+	u32 output_len = 0;
+	u32 count = 0;
+	u8 *buffer= NULL;
+	u32 buffer_len = 0;
+	char *ptr = NULL;
+	u8 cmdname[17] = {0}; // IFNAMSIZ+1
+	u32 cmdlen;
+	s32 len;
+	u8 *extra = NULL;
+	u32 extra_size = 0;
+
+	s32 k;
+	const iw_handler *priv;		/* Private ioctl */
+	const struct iw_priv_args *priv_args;	/* Private ioctl description */
+	u32 num_priv;				/* Number of ioctl */
+	u32 num_priv_args;			/* Number of descriptions */
+	iw_handler handler;
+	int temp;
+	int subcmd = 0;				/* sub-ioctl index */
+	int offset = 0;				/* Space for sub-ioctl index */
+
+	union iwreq_data wdata;
+
+	_rtw_memcpy(&wdata, wrq_data, sizeof(wdata));
+
+	input_len = wdata.data.length;
+	input = rtw_zmalloc(input_len);
+	if (NULL == input || input_len == 0)
+		return -ENOMEM;
+	if (copy_from_user(input, wdata.data.pointer, input_len)) {
+		err = -EFAULT;
+		goto exit;
+	}
+	input[input_len - 1] = '\0';
+	ptr = input;
+	len = input_len;
+
+	if (ptr == NULL) {
+		err = -EOPNOTSUPP;
+		goto exit;
+	}
+
+	sscanf(ptr, "%16s", cmdname);
+	cmdlen = strlen(cmdname);
+	DBG_871X("%s: cmd=%s\n", __func__, cmdname);
+
+	// skip command string
+	if (cmdlen > 0)
+		cmdlen += 1; // skip one space
+	ptr += cmdlen;
+	len -= cmdlen;
+	DBG_871X("%s: parameters=%s\n", __func__, ptr);
+
+	priv = rtw_private_handler;
+	priv_args = rtw_private_args;
+	num_priv = sizeof(rtw_private_handler) / sizeof(iw_handler);
+	num_priv_args = sizeof(rtw_private_args) / sizeof(struct iw_priv_args);
+
+	if (num_priv_args == 0) {
+		err = -EOPNOTSUPP;
+		goto exit;
+	}
+
+	/* Search the correct ioctl */
+	k = -1;
+	while((++k < num_priv_args) && strcmp(priv_args[k].name, cmdname));
+
+	/* If not found... */
+	if (k == num_priv_args) {
+		err = -EOPNOTSUPP;
+		goto exit;
+	}
+
+	/* Watch out for sub-ioctls ! */
+	if (priv_args[k].cmd < SIOCDEVPRIVATE)
+	{
+		int j = -1;
+
+		/* Find the matching *real* ioctl */
+		while ((++j < num_priv_args) && ((priv_args[j].name[0] != '\0') ||
+			(priv_args[j].set_args != priv_args[k].set_args) ||
+			(priv_args[j].get_args != priv_args[k].get_args)));
+
+		/* If not found... */
+		if (j == num_priv_args) {
+			err = -EINVAL;
+			goto exit;
+		}
+
+		/* Save sub-ioctl number */
+		subcmd = priv_args[k].cmd;
+		/* Reserve one int (simplify alignment issues) */
+		offset = sizeof(__u32);
+		/* Use real ioctl definition from now on */
+		k = j;
+	}
+
+	buffer = rtw_zmalloc(4096);
+	if (NULL == buffer) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	/* If we have to set some data */
+	if ((priv_args[k].set_args & IW_PRIV_TYPE_MASK) &&
+		(priv_args[k].set_args & IW_PRIV_SIZE_MASK))
+	{
+		u8 *str;
+
+		switch (priv_args[k].set_args & IW_PRIV_TYPE_MASK)
+		{
+			case IW_PRIV_TYPE_BYTE:
+				/* Fetch args */
+				count = 0;
+				do {
+					str = strsep(&ptr, delim);
+					if (NULL == str) break;
+					sscanf(str, "%i", &temp);
+					buffer[count++] = (u8)temp;
+				} while (1);
+				buffer_len = count;
+
+				/* Number of args to fetch */
+				wdata.data.length = count;
+				if (wdata.data.length > (priv_args[k].set_args & IW_PRIV_SIZE_MASK))
+					wdata.data.length = priv_args[k].set_args & IW_PRIV_SIZE_MASK;
+
+				break;
+
+			case IW_PRIV_TYPE_INT:
+				/* Fetch args */
+				count = 0;
+				do {
+					str = strsep(&ptr, delim);
+					if (NULL == str) break;
+					sscanf(str, "%i", &temp);
+					((s32*)buffer)[count++] = (s32)temp;
+				} while (1);
+				buffer_len = count * sizeof(s32);
+
+				/* Number of args to fetch */
+				wdata.data.length = count;
+				if (wdata.data.length > (priv_args[k].set_args & IW_PRIV_SIZE_MASK))
+					wdata.data.length = priv_args[k].set_args & IW_PRIV_SIZE_MASK;
+
+				break;
+
+			case IW_PRIV_TYPE_CHAR:
+				if (len > 0)
+				{
+					/* Size of the string to fetch */
+					wdata.data.length = len;
+					if (wdata.data.length > (priv_args[k].set_args & IW_PRIV_SIZE_MASK))
+						wdata.data.length = priv_args[k].set_args & IW_PRIV_SIZE_MASK;
+
+					/* Fetch string */
+					_rtw_memcpy(buffer, ptr, wdata.data.length);
+				}
+				else
+				{
+					wdata.data.length = 1;
+					buffer[0] = '\0';
+				}
+				buffer_len = wdata.data.length;
+				break;
+
+			default:
+				DBG_8192C("%s: Not yet implemented...\n", __func__);
+				err = -1;
+				goto exit;
+		}
+
+		if ((priv_args[k].set_args & IW_PRIV_SIZE_FIXED) &&
+			(wdata.data.length != (priv_args[k].set_args & IW_PRIV_SIZE_MASK)))
+		{
+			DBG_8192C("%s: The command %s needs exactly %d argument(s)...\n",
+					__func__, cmdname, priv_args[k].set_args & IW_PRIV_SIZE_MASK);
+			err = -EINVAL;
+			goto exit;
+		}
+	}   /* if args to set */
+	else
+	{
+		wdata.data.length = 0L;
+	}
+
+	/* Those two tests are important. They define how the driver
+	* will have to handle the data */
+	if ((priv_args[k].set_args & IW_PRIV_SIZE_FIXED) &&
+		((get_priv_size(priv_args[k].set_args) + offset) <= IFNAMSIZ))
+	{
+		/* First case : all SET args fit within wrq */
+		if (offset)
+			wdata.mode = subcmd;
+		_rtw_memcpy(wdata.name + offset, buffer, IFNAMSIZ - offset);
+	}
+	else
+	{
+		if ((priv_args[k].set_args == 0) &&
+			(priv_args[k].get_args & IW_PRIV_SIZE_FIXED) &&
+			(get_priv_size(priv_args[k].get_args) <= IFNAMSIZ))
+		{
+			/* Second case : no SET args, GET args fit within wrq */
+			if (offset)
+				wdata.mode = subcmd;
+		}
+		else
+		{
+			/* Third case : args won't fit in wrq, or variable number of args */
+			if (copy_to_user(wdata.data.pointer, buffer, buffer_len)) {
+				err = -EFAULT;
+				goto exit;
+			}
+			wdata.data.flags = subcmd;
+		}
+	}
+
+	rtw_mfree(input, input_len);
+	input = NULL;
+
+	extra_size = 0;
+	if (IW_IS_SET(priv_args[k].cmd))
+	{
+		/* Size of set arguments */
+		extra_size = get_priv_size(priv_args[k].set_args);
+
+		/* Does it fits in iwr ? */
+		if ((priv_args[k].set_args & IW_PRIV_SIZE_FIXED) &&
+			((extra_size + offset) <= IFNAMSIZ))
+			extra_size = 0;
+	} else {
+		/* Size of get arguments */
+		extra_size = get_priv_size(priv_args[k].get_args);
+
+		/* Does it fits in iwr ? */
+		if ((priv_args[k].get_args & IW_PRIV_SIZE_FIXED) &&
+			(extra_size <= IFNAMSIZ))
+			extra_size = 0;
+	}
+
+	if (extra_size == 0) {
+		extra = (u8*)&wdata;
+		rtw_mfree(buffer, 4096);
+		buffer = NULL;
+	} else
+		extra = buffer;
+
+	handler = priv[priv_args[k].cmd - SIOCIWFIRSTPRIV];
+	err = handler(dev, NULL, &wdata, extra);
+
+	/* If we have to get some data */
+	if ((priv_args[k].get_args & IW_PRIV_TYPE_MASK) &&
+		(priv_args[k].get_args & IW_PRIV_SIZE_MASK))
+	{
+		int j;
+		int n = 0;	/* number of args */
+		u8 str[20] = {0};
+
+		/* Check where is the returned data */
+		if ((priv_args[k].get_args & IW_PRIV_SIZE_FIXED) &&
+			(get_priv_size(priv_args[k].get_args) <= IFNAMSIZ))
+			n = priv_args[k].get_args & IW_PRIV_SIZE_MASK;
+		else
+			n = wdata.data.length;
+
+		output = rtw_zmalloc(4096);
+		if (NULL == output) {
+			err =  -ENOMEM;
+			goto exit;
+		}
+
+		switch (priv_args[k].get_args & IW_PRIV_TYPE_MASK)
+		{
+			case IW_PRIV_TYPE_BYTE:
+				/* Display args */
+				for (j = 0; j < n; j++)
+				{
+					sprintf(str, "%d  ", extra[j]);
+					len = strlen(str);
+					output_len = strlen(output);
+					if ((output_len + len + 1) > 4096) {
+						err = -E2BIG;
+						goto exit;
+					}
+					_rtw_memcpy(output+output_len, str, len);
+				}
+				break;
+
+			case IW_PRIV_TYPE_INT:
+				/* Display args */
+				for (j = 0; j < n; j++)
+				{
+					sprintf(str, "%d  ", ((__s32*)extra)[j]);
+					len = strlen(str);
+					output_len = strlen(output);
+					if ((output_len + len + 1) > 4096) {
+						err = -E2BIG;
+						goto exit;
+					}
+					_rtw_memcpy(output+output_len, str, len);
+				}
+				break;
+
+			case IW_PRIV_TYPE_CHAR:
+				/* Display args */
+				_rtw_memcpy(output, extra, n);
+				break;
+
+			default:
+				DBG_8192C("%s: Not yet implemented...\n", __func__);
+				err = -1;
+				goto exit;
+		}
+
+		output_len = strlen(output) + 1;
+		wrq_data->data.length = output_len;
+		if (copy_to_user(wrq_data->data.pointer, output, output_len)) {
+			err = -EFAULT;
+			goto exit;
+		}
+	}   /* if args to set */
+	else
+	{
+		wrq_data->data.length = 0;
+	}
+
+exit:
+	if (input)
+		rtw_mfree(input, input_len);
+	if (buffer)
+		rtw_mfree(buffer, 4096);
+	if (output)
+		rtw_mfree(output, 4096);
+
+	return err;
+}
+
+#ifdef CONFIG_COMPAT
+static int rtw_ioctl_compat_wext_private(struct net_device *dev, struct ifreq *rq)
+{
+	struct compat_iw_point iwp_compat;
+	union iwreq_data wrq_data;
+	int err = 0;
+	DBG_871X("%s:...\n", __func__);
+	if (copy_from_user(&iwp_compat, rq->ifr_ifru.ifru_data, sizeof(struct compat_iw_point)))
+			return -EFAULT;
+	
+	wrq_data.data.pointer = compat_ptr(iwp_compat.pointer);
+	wrq_data.data.length = iwp_compat.length;
+	wrq_data.data.flags = iwp_compat.flags;
+
+	err = _rtw_ioctl_wext_private(dev, &wrq_data);
+
+	iwp_compat.pointer = ptr_to_compat(wrq_data.data.pointer);
+	iwp_compat.length = wrq_data.data.length;
+	iwp_compat.flags = wrq_data.data.flags;
+	if (copy_to_user(rq->ifr_ifru.ifru_data, &iwp_compat, sizeof(struct compat_iw_point)))
+			return -EFAULT;
+
+	return err;
+}
+#endif // CONFIG_COMPAT
+
+static int rtw_ioctl_standard_wext_private(struct net_device *dev, struct ifreq *rq)
+{
+	struct iw_point *iwp;
+	struct ifreq ifrq;
+	union iwreq_data wrq_data;
+	int err = 0;
+	iwp = &wrq_data.data;
+	DBG_871X("%s:...\n", __func__);
+	if (copy_from_user(iwp, rq->ifr_ifru.ifru_data, sizeof(struct iw_point)))
+		return -EFAULT;
+
+	err = _rtw_ioctl_wext_private(dev, &wrq_data);
+
+	if (copy_to_user(rq->ifr_ifru.ifru_data, iwp, sizeof(struct iw_point)))
+		return -EFAULT;
+
+	return err;
+}
+ 
+static int rtw_ioctl_wext_private(struct net_device *dev, struct ifreq *rq)
+{
+#ifdef CONFIG_COMPAT
+	if(is_compat_task())
+		return rtw_ioctl_compat_wext_private( dev, rq );
+	else
+#endif // CONFIG_COMPAT
+		return rtw_ioctl_standard_wext_private( dev, rq );
+}
+
+int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct iwreq *wrq = (struct iwreq *)rq;
+	int ret=0;
+
+	switch (cmd)
+	{
+		case RTL_IOCTL_WPA_SUPPLICANT:
+			ret = wpa_supplicant_ioctl(dev, &wrq->u.data);
+			break;
+#ifdef CONFIG_AP_MODE
+		case RTL_IOCTL_HOSTAPD:
+			ret = rtw_hostapd_ioctl(dev, &wrq->u.data);
+			break;
+#ifdef CONFIG_WIRELESS_EXT
+		case SIOCSIWMODE:
+			ret = rtw_wx_set_mode(dev, NULL, &wrq->u, NULL);
+			break;
+#endif
+#endif // CONFIG_AP_MODE
+		case SIOCDEVPRIVATE:				
+			 ret = rtw_ioctl_wext_private(dev, rq);
+			break;
+		case (SIOCDEVPRIVATE+1):
+			ret = rtw_android_priv_cmd(dev, rq, cmd);
+			break;
+		default:
+			ret = -EOPNOTSUPP;
+			break;
+	}
+
+	return ret;
+}
+
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_mp.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_mp.c
new file mode 100644
index 000000000..2e62bbf4c
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/ioctl_mp.c
@@ -0,0 +1,2147 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#if defined(CONFIG_MP_INCLUDED)
+
+#include <drv_types.h>
+#include <rtw_mp.h>
+#include <rtw_mp_ioctl.h>
+#include "../../hal/phydm/phydm_precomp.h"
+
+
+#if defined(CONFIG_RTL8723B)
+#include <rtw_bt_mp.h>
+#endif
+
+/*
+ * Input Format: %s,%d,%d
+ *	%s is width, could be
+ *		"b" for 1 byte
+ *		"w" for WORD (2 bytes)
+ *		"dw" for DWORD (4 bytes)
+ *	1st %d is address(offset)
+ *	2st %d is data to write
+ */
+int rtw_mp_write_reg(struct net_device *dev,
+					 struct iw_request_info *info,
+					 struct iw_point *wrqu, char *extra)
+{
+	char *pch, *pnext, *ptmp;
+	char *width_str;
+	char width, buf[5];
+	u32 addr, data;
+	int ret;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	char input[wrqu->length];
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	_rtw_memset(extra, 0, wrqu->length);
+
+	pch = input;
+
+	pnext = strpbrk(pch, " ,.-");
+	if (pnext == NULL)
+		return -EINVAL;
+	*pnext = 0;
+	width_str = pch;
+
+	pch = pnext + 1;
+	pnext = strpbrk(pch, " ,.-");
+	if (pnext == NULL)
+		return -EINVAL;
+	*pnext = 0;
+	/*addr = simple_strtoul(pch, &ptmp, 16);
+	_rtw_memset(buf, '\0', sizeof(buf));
+	_rtw_memcpy(buf, pch, pnext-pch);
+	ret = kstrtoul(buf, 16, &addr);*/
+	ret = sscanf(pch, "%x", &addr);
+	if (addr > 0x3FFF)
+		return -EINVAL;
+
+	pch = pnext + 1;
+	pnext = strpbrk(pch, " ,.-");
+	if ((pch - input) >= wrqu->length)
+		return -EINVAL;
+	/*data = simple_strtoul(pch, &ptmp, 16);*/
+	ret = sscanf(pch, "%x", &data);
+	DBG_871X("data=%x,addr=%x\n", (u32)data, (u32)addr);
+	ret = 0;
+	width = width_str[0];
+	switch (width) {
+	case 'b':
+		/* 1 byte*/
+		if (data > 0xFF) {
+			ret = -EINVAL;
+			break;
+		}
+		rtw_write8(padapter, addr, data);
+		break;
+	case 'w':
+		/* 2 bytes*/
+		if (data > 0xFFFF) {
+			ret = -EINVAL;
+			break;
+		}
+		rtw_write16(padapter, addr, data);
+		break;
+	case 'd':
+		/* 4 bytes*/
+		rtw_write32(padapter, addr, data);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+
+/*
+ * Input Format: %s,%d
+ *	%s is width, could be
+ *		"b" for 1 byte
+ *		"w" for WORD (2 bytes)
+ *		"dw" for DWORD (4 bytes)
+ *	%d is address(offset)
+ *
+ * Return:
+ *	%d for data readed
+ */
+int rtw_mp_read_reg(struct net_device *dev,
+					struct iw_request_info *info,
+					struct iw_point *wrqu, char *extra)
+{
+	char input[wrqu->length];
+	char *pch, *pnext, *ptmp;
+	char *width_str;
+	char width;
+	char data[20], tmp[20], buf[3];
+	u32 addr = 0, strtout = 0;
+	u32 i = 0, j = 0, ret = 0, data32 = 0;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+
+
+	if (wrqu->length > 128)
+		return -EFAULT;
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	_rtw_memset(extra, 0, wrqu->length);
+	_rtw_memset(data, '\0', sizeof(data));
+	_rtw_memset(tmp, '\0', sizeof(tmp));
+	pch = input;
+	pnext = strpbrk(pch, " ,.-");
+	if (pnext == NULL)
+		return -EINVAL;
+	*pnext = 0;
+	width_str = pch;
+
+	pch = pnext + 1;
+
+	ret = sscanf(pch, "%x", &addr);
+	if (addr > 0x3FFF)
+		return -EINVAL;
+
+	ret = 0;
+	width = width_str[0];
+
+	switch (width) {
+	case 'b':
+			data32 = rtw_read8(padapter, addr);
+			DBG_871X("%x\n", data32);
+			sprintf(extra, "%d", data32);
+			wrqu->length = strlen(extra);
+			break;
+	case 'w':
+			/* 2 bytes*/
+			sprintf(data, "%04x\n", rtw_read16(padapter, addr));
+
+			for (i = 0 ; i <= strlen(data) ; i++) {
+				if (i % 2 == 0) {
+					tmp[j] = ' ';
+					j++;
+				}
+				if (data[i] != '\0')
+					tmp[j] = data[i];
+
+				j++;
+			}
+			pch = tmp;
+			DBG_871X("pch=%s", pch);
+
+			while (*pch != '\0') {
+				pnext = strpbrk(pch, " ");
+				if (!pnext || ((pnext - tmp) > 4))
+					break;
+					
+				pnext++;
+				if (*pnext != '\0') {
+					/*strtout = simple_strtoul(pnext , &ptmp, 16);*/
+					ret = sscanf(pnext, "%x", &strtout);
+					sprintf(extra, "%s %d" , extra , strtout);
+				} else
+					break;
+				pch = pnext;
+			}
+			wrqu->length = strlen(extra);
+			break;
+	case 'd':
+			/* 4 bytes */
+			sprintf(data, "%08x", rtw_read32(padapter, addr));
+			/*add read data format blank*/
+			for (i = 0 ; i <= strlen(data) ; i++) {
+				if (i % 2 == 0) {
+					tmp[j] = ' ';
+					j++;
+				}
+				if (data[i] != '\0')
+					tmp[j] = data[i];
+
+				j++;
+			}
+			pch = tmp;
+			DBG_871X("pch=%s", pch);
+
+			while (*pch != '\0') {
+				pnext = strpbrk(pch, " ");
+				if (!pnext)
+					break;
+
+				pnext++;
+				if (*pnext != '\0') {
+					ret = sscanf(pnext, "%x", &strtout);
+					sprintf(extra, "%s %d" , extra , strtout);
+				} else
+					break;
+				pch = pnext;
+			}
+			wrqu->length = strlen(extra);
+			break;
+
+	default:
+			wrqu->length = 0;
+			ret = -EINVAL;
+			break;
+		}
+
+	return ret;
+}
+
+
+/*
+ * Input Format: %d,%x,%x
+ *	%d is RF path, should be smaller than MAX_RF_PATH_NUMS
+ *	1st %x is address(offset)
+ *	2st %x is data to write
+ */
+int rtw_mp_write_rf(struct net_device *dev,
+					struct iw_request_info *info,
+					struct iw_point *wrqu, char *extra)
+{
+
+	u32 path, addr, data;
+	int ret;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	char input[wrqu->length];
+
+
+	_rtw_memset(input, 0, wrqu->length);
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+
+	ret = sscanf(input, "%d,%x,%x", &path, &addr, &data);
+	if (ret < 3)
+		return -EINVAL;
+
+	if (path >= GET_HAL_RFPATH_NUM(padapter))
+		return -EINVAL;
+	if (addr > 0xFF)
+		return -EINVAL;
+	if (data > 0xFFFFF)
+		return -EINVAL;
+
+	_rtw_memset(extra, 0, wrqu->length);
+
+	write_rfreg(padapter, path, addr, data);
+
+	sprintf(extra, "write_rf completed\n");
+	wrqu->length = strlen(extra);
+
+	return 0;
+}
+
+
+/*
+ * Input Format: %d,%x
+ *	%d is RF path, should be smaller than MAX_RF_PATH_NUMS
+ *	%x is address(offset)
+ *
+ * Return:
+ *	%d for data readed
+ */
+int rtw_mp_read_rf(struct net_device *dev,
+				   struct iw_request_info *info,
+				   struct iw_point *wrqu, char *extra)
+{
+	char input[wrqu->length];
+	char *pch, *pnext, *ptmp;
+	char data[20], tmp[20], buf[3];
+	u32 path, addr, strtou;
+	u32 ret, i = 0 , j = 0;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	
+	if (wrqu->length > 128)
+		return -EFAULT;
+	_rtw_memset(input, 0, wrqu->length);
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	ret = sscanf(input, "%d,%x", &path, &addr);
+	if (ret < 2)
+		return -EINVAL;
+
+	if (path >= GET_HAL_RFPATH_NUM(padapter))
+		return -EINVAL;
+	if (addr > 0xFF)
+		return -EINVAL;
+
+	_rtw_memset(extra, 0, wrqu->length);
+
+	sprintf(data, "%08x", read_rfreg(padapter, path, addr));
+	/*add read data format blank*/
+	for (i = 0 ; i <= strlen(data) ; i++) {
+		if (i % 2 == 0) {
+			tmp[j] = ' ';
+			j++;
+		}
+		tmp[j] = data[i];
+		j++;
+	}
+	pch = tmp;
+	DBG_871X("pch=%s", pch);
+
+	while (*pch != '\0') {
+		pnext = strpbrk(pch, " ");
+		if (!pnext)
+			break;
+		pnext++;
+		if (*pnext != '\0') {
+			/*strtou =simple_strtoul(pnext , &ptmp, 16);*/
+			ret = sscanf(pnext, "%x", &strtou);
+			sprintf(extra, "%s %d" , extra , strtou);
+		} else
+			break;
+		pch = pnext;
+	}
+	wrqu->length = strlen(extra);
+
+	return 0;
+}
+
+
+int rtw_mp_start(struct net_device *dev,
+				 struct iw_request_info *info,
+				 struct iw_point *wrqu, char *extra)
+{
+	u8 val8;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct hal_ops *pHalFunc = &padapter->HalFunc;
+
+	rtw_pm_set_ips(padapter, IPS_NONE);
+	LeaveAllPowerSaveMode(padapter);
+
+	if (padapter->registrypriv.mp_mode == 0) {
+		rtw_hal_deinit(padapter);
+		padapter->registrypriv.mp_mode = 1;
+		#ifdef CONFIG_RF_GAIN_OFFSET
+		if (!IS_HARDWARE_TYPE_8814A(padapter))
+			padapter->registrypriv.RegRfKFreeEnable = 1;
+		rtw_hal_read_chip_info(padapter);
+		#endif /*CONFIG_RF_GAIN_OFFSET*/
+		rtw_hal_init(padapter);
+	}
+
+	if (padapter->registrypriv.mp_mode == 0)
+		return -EPERM;
+
+	if (padapter->mppriv.mode == MP_OFF) {
+		if (mp_start_test(padapter) == _FAIL)
+			return -EPERM;
+		padapter->mppriv.mode = MP_ON;
+		MPT_PwrCtlDM(padapter, 0);
+	}
+	padapter->mppriv.bmac_filter = _FALSE;
+#ifdef CONFIG_RTL8723B
+#ifdef CONFIG_USB_HCI
+	rtw_write32(padapter, 0x765, 0x0000);
+	rtw_write32(padapter, 0x948, 0x0280);
+#else
+	rtw_write32(padapter, 0x765, 0x0000);
+	rtw_write32(padapter, 0x948, 0x0000);
+#endif
+#ifdef CONFIG_FOR_RTL8723BS_VQ0
+	rtw_write32(padapter, 0x765, 0x0000);
+	rtw_write32(padapter, 0x948, 0x0280);
+#endif
+	rtw_write8(padapter, 0x66, 0x27); /*Open BT uart Log*/
+	rtw_write8(padapter, 0xc50, 0x20); /*for RX init Gain*/
+#endif
+	ODM_Write_DIG(&pHalData->odmpriv, 0x20);
+
+	return 0;
+}
+
+
+
+int rtw_mp_stop(struct net_device *dev,
+				struct iw_request_info *info,
+				struct iw_point *wrqu, char *extra)
+{
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	struct hal_ops *pHalFunc = &padapter->HalFunc;
+
+	if (padapter->registrypriv.mp_mode == 1) {
+
+		MPT_DeInitAdapter(padapter);
+		pHalFunc->hal_deinit(padapter);
+		padapter->registrypriv.mp_mode = 0;
+		pHalFunc->hal_init(padapter);
+	}
+
+	if (padapter->mppriv.mode != MP_OFF) {
+		mp_stop_test(padapter);
+		padapter->mppriv.mode = MP_OFF;
+	}
+
+	return 0;
+}
+
+
+int rtw_mp_rate(struct net_device *dev,
+				struct iw_request_info *info,
+				struct iw_point *wrqu, char *extra)
+{
+	u32 rate = MPT_RATE_1M;
+	u8		input[wrqu->length];
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	PMPT_CONTEXT		pMptCtx = &(padapter->mppriv.MptCtx);
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	rate = rtw_mpRateParseFunc(padapter, input);
+
+	if (rate == 0 && strcmp(input, "1M") != 0) {
+		rate = rtw_atoi(input);
+		if (rate <= 0x7f)
+			rate = wifirate2_ratetbl_inx((u8)rate);
+		else if (rate < 0xC8)
+			rate = (rate - 0x80 + MPT_RATE_MCS0);
+		/*HT  rate 0x80(MCS0)  ~ 0x8F(MCS15) ~ 0x9F(MCS31) 128~159
+		VHT1SS~2SS rate 0xA0 (VHT1SS_MCS0 44) ~ 0xB3 (VHT2SS_MCS9 #63) 160~179
+		VHT rate 0xB4 (VHT3SS_MCS0 64) ~ 0xC7 (VHT2SS_MCS9 #83) 180~199
+		else
+		VHT rate 0x90(VHT1SS_MCS0) ~ 0x99(VHT1SS_MCS9) 144~153
+		rate =(rate - MPT_RATE_VHT1SS_MCS0);
+		*/
+	}
+	_rtw_memset(extra, 0, wrqu->length);
+
+	sprintf(extra, "Set data rate to %s index %d" , input, rate);
+	DBG_871X("%s: %s rate index=%d\n", __func__, input, rate);
+
+	if (rate >= MPT_RATE_LAST)
+		return -EINVAL;
+
+	padapter->mppriv.rateidx = rate;
+	pMptCtx->MptRateIndex = rate;
+	SetDataRate(padapter);
+
+	wrqu->length = strlen(extra);
+	return 0;
+}
+
+
+int rtw_mp_channel(struct net_device *dev,
+				   struct iw_request_info *info,
+				   struct iw_point *wrqu, char *extra)
+{
+
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
+	u8		input[wrqu->length];
+	u32	channel = 1;
+	int cur_ch_offset;
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	channel = rtw_atoi(input);
+	/*DBG_871X("%s: channel=%d\n", __func__, channel);*/
+	_rtw_memset(extra, 0, wrqu->length);
+	sprintf(extra, "Change channel %d to channel %d", padapter->mppriv.channel , channel);
+	padapter->mppriv.channel = channel;
+	SetChannel(padapter);
+	pHalData->CurrentChannel = channel;
+
+	wrqu->length = strlen(extra);
+	return 0;
+}
+
+
+int rtw_mp_bandwidth(struct net_device *dev,
+					 struct iw_request_info *info,
+					 struct iw_point *wrqu, char *extra)
+{
+	u32 bandwidth = 0, sg = 0;
+	int cur_ch_offset;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
+
+	if (sscanf(extra, "40M=%d,shortGI=%d", &bandwidth, &sg) > 0)
+		DBG_871X("%s: bw=%d sg=%d\n", __func__, bandwidth , sg);
+
+	if (bandwidth == 1)
+		bandwidth = CHANNEL_WIDTH_40;
+	else if (bandwidth == 2)
+		bandwidth = CHANNEL_WIDTH_80;
+
+	padapter->mppriv.bandwidth = (u8)bandwidth;
+	padapter->mppriv.preamble = sg;
+
+	SetBandwidth(padapter);
+	pHalData->CurrentChannelBW = bandwidth;
+	/*cur_ch_offset =  rtw_get_offset_by_ch(padapter->mppriv.channel);*/
+	/*set_channel_bwmode(padapter, padapter->mppriv.channel, cur_ch_offset, bandwidth);*/
+
+	return 0;
+}
+
+
+int rtw_mp_txpower_index(struct net_device *dev,
+						 struct iw_request_info *info,
+						 struct iw_point *wrqu, char *extra)
+{
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	char input[wrqu->length];
+	u32 rfpath;
+	u32 txpower_inx;
+
+	if (wrqu->length > 128)
+		return -EFAULT;
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	rfpath = rtw_atoi(input);
+	txpower_inx = mpt_ProQueryCalTxPower(padapter, rfpath);
+	sprintf(extra, " %d", txpower_inx);
+	wrqu->length = strlen(extra);
+
+	return 0;
+}
+
+
+int rtw_mp_txpower(struct net_device *dev,
+				   struct iw_request_info *info,
+				   struct iw_point *wrqu, char *extra)
+{
+	u32 idx_a = 0, idx_b = 0, idx_c = 0, idx_d = 0, status = 0;
+	int MsetPower = 1;
+	u8		input[wrqu->length];
+
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	PMPT_CONTEXT		pMptCtx = &(padapter->mppriv.MptCtx);
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	MsetPower = strncmp(input, "off", 3);
+	if (MsetPower == 0) {
+		padapter->mppriv.bSetTxPower = 0;
+		sprintf(extra, "MP Set power off");
+	} else {
+		if (sscanf(input, "patha=%d,pathb=%d,pathc=%d,pathd=%d", &idx_a, &idx_b, &idx_c, &idx_d) < 3)
+			DBG_871X("Invalid format on line %s ,patha=%d,pathb=%d,pathc=%d,pathd=%d\n", input , idx_a , idx_b , idx_c , idx_d);
+
+		sprintf(extra, "Set power level path_A:%d path_B:%d path_C:%d path_D:%d", idx_a , idx_b , idx_c , idx_d);
+		padapter->mppriv.txpoweridx = (u8)idx_a;
+
+		pMptCtx->TxPwrLevel[ODM_RF_PATH_A] = (u8)idx_a;
+		pMptCtx->TxPwrLevel[ODM_RF_PATH_B] = (u8)idx_b;
+		pMptCtx->TxPwrLevel[ODM_RF_PATH_C] = (u8)idx_c;
+		pMptCtx->TxPwrLevel[ODM_RF_PATH_D]  = (u8)idx_d;
+		padapter->mppriv.bSetTxPower = 1;
+
+		SetTxPower(padapter);
+	}
+
+	wrqu->length = strlen(extra);
+	return 0;
+}
+
+
+int rtw_mp_ant_tx(struct net_device *dev,
+				  struct iw_request_info *info,
+				  struct iw_point *wrqu, char *extra)
+{
+	u8 i;
+	u8		input[wrqu->length];
+	u16 antenna = 0;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	sprintf(extra, "switch Tx antenna to %s", input);
+
+	for (i = 0; i < strlen(input); i++) {
+		switch (input[i]) {
+		case 'a':
+			antenna |= ANTENNA_A;
+			break;
+		case 'b':
+			antenna |= ANTENNA_B;
+			break;
+		case 'c':
+			antenna |= ANTENNA_C;
+			break;
+		case 'd':
+			antenna |= ANTENNA_D;
+			break;
+		}
+	}
+	/*antenna |= BIT(extra[i]-'a');*/
+	DBG_871X("%s: antenna=0x%x\n", __func__, antenna);
+	padapter->mppriv.antenna_tx = antenna;
+	padapter->mppriv.antenna_rx = antenna;
+	/*DBG_871X("%s:mppriv.antenna_rx=%d\n", __func__, padapter->mppriv.antenna_tx);*/
+	pHalData->AntennaTxPath = antenna;
+
+	SetAntenna(padapter);
+
+	wrqu->length = strlen(extra);
+	return 0;
+}
+
+
+int rtw_mp_ant_rx(struct net_device *dev,
+				  struct iw_request_info *info,
+				  struct iw_point *wrqu, char *extra)
+{
+	u8 i;
+	u16 antenna = 0;
+	u8		input[wrqu->length];
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+	/*DBG_871X("%s: input=%s\n", __func__, input);*/
+	_rtw_memset(extra, 0, wrqu->length);
+
+	sprintf(extra, "switch Rx antenna to %s", input);
+
+	for (i = 0; i < strlen(input); i++) {
+		switch (input[i]) {
+		case 'a':
+			antenna |= ANTENNA_A;
+			break;
+		case 'b':
+			antenna |= ANTENNA_B;
+			break;
+		case 'c':
+			antenna |= ANTENNA_C;
+			break;
+		case 'd':
+			antenna |= ANTENNA_D;
+			break;
+		}
+	}
+
+	DBG_871X("%s: antenna=0x%x\n", __func__, antenna);
+	padapter->mppriv.antenna_tx = antenna;
+	padapter->mppriv.antenna_rx = antenna;
+	pHalData->AntennaRxPath = antenna;
+	/*DBG_871X("%s:mppriv.antenna_rx=%d\n", __func__, padapter->mppriv.antenna_rx);*/
+	SetAntenna(padapter);
+	wrqu->length = strlen(extra);
+
+	return 0;
+}
+
+
+int rtw_set_ctx_destAddr(struct net_device *dev,
+						 struct iw_request_info *info,
+						 struct iw_point *wrqu, char *extra)
+{
+	int jj, kk = 0;
+
+	struct pkt_attrib *pattrib;
+	struct mp_priv *pmp_priv;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	
+	pmp_priv = &padapter->mppriv;
+	pattrib = &pmp_priv->tx.attrib;
+
+	if (strlen(extra) < 5)
+		return _FAIL;
+
+	DBG_871X("%s: in=%s\n", __func__, extra);
+	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
+		pattrib->dst[jj] = key_2char2num(extra[kk], extra[kk + 1]);
+
+	DBG_871X("pattrib->dst:%x %x %x %x %x %x\n", pattrib->dst[0], pattrib->dst[1], pattrib->dst[2], pattrib->dst[3], pattrib->dst[4], pattrib->dst[5]);
+	return 0;
+}
+
+
+
+int rtw_mp_ctx(struct net_device *dev,
+			   struct iw_request_info *info,
+			   struct iw_point *wrqu, char *extra)
+{
+	u32 pkTx = 1;
+	int countPkTx = 1, cotuTx = 1, CarrSprTx = 1, scTx = 1, sgleTx = 1, stop = 1;
+	u32 bStartTest = 1;
+	u32 count = 0, pktinterval = 0, pktlen = 0;
+	u8 status;
+	struct mp_priv *pmp_priv;
+	struct pkt_attrib *pattrib;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+
+	pmp_priv = &padapter->mppriv;
+	pattrib = &pmp_priv->tx.attrib;
+
+	if (copy_from_user(extra, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	DBG_871X("%s: in=%s\n", __func__, extra);
+
+	countPkTx = strncmp(extra, "count=", 5); /* strncmp TRUE is 0*/
+	cotuTx = strncmp(extra, "background", 20);
+	CarrSprTx = strncmp(extra, "background,cs", 20);
+	scTx = strncmp(extra, "background,sc", 20);
+	sgleTx = strncmp(extra, "background,stone", 20);
+	pkTx = strncmp(extra, "background,pkt", 20);
+	stop = strncmp(extra, "stop", 4);
+	if (sscanf(extra, "count=%d,pkt", &count) > 0)
+		DBG_871X("count= %d\n", count);
+	if (sscanf(extra, "pktinterval=%d", &pktinterval) > 0)
+		DBG_871X("pktinterval= %d\n", pktinterval);
+
+	if (sscanf(extra, "pktlen=%d", &pktlen) > 0)
+		DBG_871X("pktlen= %d\n", pktlen);
+
+	if (_rtw_memcmp(extra, "destmac=", 8)) {
+		wrqu->length -= 8;
+		rtw_set_ctx_destAddr(dev, info, wrqu, &extra[8]);
+		sprintf(extra, "Set dest mac OK !\n");
+		return 0;
+	}
+
+	/*DBG_871X("%s: count=%d countPkTx=%d cotuTx=%d CarrSprTx=%d scTx=%d sgleTx=%d pkTx=%d stop=%d\n", __func__, count, countPkTx, cotuTx, CarrSprTx, pkTx, sgleTx, scTx, stop);*/
+	_rtw_memset(extra, '\0', strlen(extra));
+
+	if (pktinterval != 0) {
+		sprintf(extra, "Pkt Interval = %d", pktinterval);
+		padapter->mppriv.pktInterval = pktinterval;
+		wrqu->length = strlen(extra);
+		return 0;
+	}
+	if (pktlen != 0) {
+		sprintf(extra, "Pkt len = %d", pktlen);
+		pattrib->pktlen = pktlen;
+		wrqu->length = strlen(extra);
+		return 0;
+	}
+	if (stop == 0) {
+		bStartTest = 0; /* To set Stop*/
+		pmp_priv->tx.stop = 1;
+		sprintf(extra, "Stop continuous Tx");
+	} else {
+		bStartTest = 1;
+		if (pmp_priv->mode != MP_ON) {
+			if (pmp_priv->tx.stop != 1) {
+				DBG_871X("%s: MP_MODE != ON %d\n", __func__, pmp_priv->mode);
+				return	-EFAULT;
+			}
+		}
+	}
+
+	pmp_priv->tx.count = count;
+
+	if (pkTx == 0 || countPkTx == 0)
+		pmp_priv->mode = MP_PACKET_TX;
+	if (sgleTx == 0)
+		pmp_priv->mode = MP_SINGLE_TONE_TX;
+	if (cotuTx == 0)
+		pmp_priv->mode = MP_CONTINUOUS_TX;
+	if (CarrSprTx == 0)
+		pmp_priv->mode = MP_CARRIER_SUPPRISSION_TX;
+	if (scTx == 0)
+		pmp_priv->mode = MP_SINGLE_CARRIER_TX;
+
+	status = rtw_mp_pretx_proc(padapter, bStartTest, extra);
+
+	wrqu->length = strlen(extra);
+	return status;
+}
+
+
+
+int rtw_mp_disable_bt_coexist(struct net_device *dev,
+							  struct iw_request_info *info,
+							  union iwreq_data *wrqu, char *extra)
+{
+	PADAPTER padapter = (PADAPTER)rtw_netdev_priv(dev);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct hal_ops *pHalFunc = &padapter->HalFunc;
+
+	u8 input[wrqu->data.length];
+	u32 bt_coexist;
+
+	if (copy_from_user(input, wrqu->data.pointer, wrqu->data.length))
+		return -EFAULT;
+
+	bt_coexist = rtw_atoi(input);
+
+	if (bt_coexist == 0) {
+		RT_TRACE(_module_mp_, _drv_info_,
+				 ("Set OID_RT_SET_DISABLE_BT_COEXIST: disable BT_COEXIST\n"));
+		DBG_871X("Set OID_RT_SET_DISABLE_BT_COEXIST: disable BT_COEXIST\n");
+#ifdef CONFIG_BT_COEXIST
+		rtw_btcoex_HaltNotify(padapter);
+		rtw_btcoex_SetManualControl(padapter, _TRUE);
+		/* Force to switch Antenna to WiFi*/
+		rtw_write16(padapter, 0x870, 0x300);
+		rtw_write16(padapter, 0x860, 0x110);
+#endif 
+		/* CONFIG_BT_COEXIST */
+	} else {
+		RT_TRACE(_module_mp_, _drv_info_,
+				 ("Set OID_RT_SET_DISABLE_BT_COEXIST: enable BT_COEXIST\n"));
+#ifdef CONFIG_BT_COEXIST
+		rtw_btcoex_SetManualControl(padapter, _FALSE);
+#endif
+	}
+
+	return 0;
+}
+
+
+int rtw_mp_arx(struct net_device *dev,
+			   struct iw_request_info *info,
+			   struct iw_point *wrqu, char *extra)
+{
+	int bStartRx = 0, bStopRx = 0, bQueryPhy = 0, bQueryMac = 0, bSetBssid = 0;
+	int bmac_filter = 0, bfilter_init = 0, bmon = 0, bSmpCfg = 0;
+	u8		input[wrqu->length];
+	char *pch, *ptmp, *token, *tmp[2] = {0x00, 0x00};
+	u32 i = 0, ii = 0, jj = 0, kk = 0, cnts = 0, ret;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct dbg_rx_counter rx_counter;
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	DBG_871X("%s: %s\n", __func__, input);
+
+	bStartRx = (strncmp(input, "start", 5) == 0) ? 1 : 0; /* strncmp TRUE is 0*/
+	bStopRx = (strncmp(input, "stop", 5) == 0) ? 1 : 0; /* strncmp TRUE is 0*/
+	bQueryPhy = (strncmp(input, "phy", 3) == 0) ? 1 : 0; /* strncmp TRUE is 0*/
+	bQueryMac = (strncmp(input, "mac", 3) == 0) ? 1 : 0; /* strncmp TRUE is 0*/
+	bSetBssid = (strncmp(input, "setbssid=", 8) == 0) ? 1 : 0; /* strncmp TRUE is 0*/
+	/*bfilter_init = (strncmp(input, "filter_init",11)==0)?1:0;*/
+	bmac_filter = (strncmp(input, "accept_mac", 10) == 0) ? 1 : 0;
+	bmon = (strncmp(input, "mon=", 4) == 0) ? 1 : 0;
+	bSmpCfg = (strncmp(input , "smpcfg=" , 7) == 0) ? 1 : 0;
+
+	if (bSetBssid == 1) {
+		pch = input;
+		while ((token = strsep(&pch, "=")) != NULL) {
+			if (i > 1)
+				break;
+			tmp[i] = token;
+			i++;
+		}
+		if ((tmp[0] != NULL) && (tmp[1] != NULL)) {
+			cnts = strlen(tmp[1]) / 2;
+			if (cnts < 1)
+				return -EFAULT;
+			DBG_871X("%s: cnts=%d\n", __func__, cnts);
+			DBG_871X("%s: data=%s\n", __func__, tmp[1]);
+			for (jj = 0, kk = 0; jj < cnts ; jj++, kk += 2) {
+				pmppriv->network_macaddr[jj] = key_2char2num(tmp[1][kk], tmp[1][kk + 1]);
+				DBG_871X("network_macaddr[%d]=%x\n", jj, pmppriv->network_macaddr[jj]);
+			} 
+		} else
+			return -EFAULT;
+			
+		pmppriv->bSetRxBssid = _TRUE;
+	}
+
+	if (bmac_filter) {
+		pmppriv->bmac_filter = bmac_filter;
+		pch = input;
+		while ((token = strsep(&pch, "=")) != NULL) {
+			if (i > 1)
+				break;
+			tmp[i] = token;
+			i++;
+		}
+		if ((tmp[0] != NULL) && (tmp[1] != NULL)) {
+			cnts = strlen(tmp[1]) / 2;
+			if (cnts < 1)
+				return -EFAULT;
+			DBG_871X("%s: cnts=%d\n", __func__, cnts);
+			DBG_871X("%s: data=%s\n", __func__, tmp[1]);
+			for (jj = 0, kk = 0; jj < cnts ; jj++, kk += 2) {
+				pmppriv->mac_filter[jj] = key_2char2num(tmp[1][kk], tmp[1][kk + 1]);
+				DBG_871X("%s mac_filter[%d]=%x\n", __func__, jj, pmppriv->mac_filter[jj]);
+			} 
+		} else 
+			return -EFAULT;
+
+	}
+
+	if (bStartRx) {
+		sprintf(extra, "start");
+		SetPacketRx(padapter, bStartRx, _FALSE);
+	} else if (bStopRx) {
+		SetPacketRx(padapter, bStartRx, _FALSE);
+		pmppriv->bmac_filter = _FALSE;
+		sprintf(extra, "Received packet OK:%d CRC error:%d ,Filter out:%d", padapter->mppriv.rx_pktcount, padapter->mppriv.rx_crcerrpktcount, padapter->mppriv.rx_pktcount_filter_out);
+	} else if (bQueryPhy) {
+		_rtw_memset(&rx_counter, 0, sizeof(struct dbg_rx_counter));
+		rtw_dump_phy_rx_counters(padapter, &rx_counter);
+
+		DBG_871X("%s: OFDM_FA =%d\n", __func__, rx_counter.rx_ofdm_fa);
+		DBG_871X("%s: CCK_FA =%d\n", __func__, rx_counter.rx_cck_fa);
+		sprintf(extra, "Phy Received packet OK:%d CRC error:%d FA Counter: %d", rx_counter.rx_pkt_ok, rx_counter.rx_pkt_crc_error, rx_counter.rx_cck_fa + rx_counter.rx_ofdm_fa);
+
+
+	} else if (bQueryMac) {
+		_rtw_memset(&rx_counter, 0, sizeof(struct dbg_rx_counter));
+		rtw_dump_mac_rx_counters(padapter, &rx_counter);
+		sprintf(extra, "Mac Received packet OK: %d , CRC error: %d , Drop Packets: %d\n",
+				rx_counter.rx_pkt_ok, rx_counter.rx_pkt_crc_error, rx_counter.rx_pkt_drop);
+
+	}
+
+	if (bmon == 1) {
+		ret = sscanf(input, "mon=%d", &bmon);
+
+		if (bmon == 1) {
+			pmppriv->rx_bindicatePkt = _TRUE;
+			sprintf(extra, "Indicating Receive Packet to network start\n");
+		} else {
+			pmppriv->rx_bindicatePkt = _FALSE;
+			sprintf(extra, "Indicating Receive Packet to network Stop\n");
+		}
+	}
+	if (bSmpCfg == 1) {
+		ret = sscanf(input, "smpcfg=%d", &bSmpCfg);
+
+		if (bSmpCfg == 1) {
+			pmppriv->bRTWSmbCfg = _TRUE;
+			sprintf(extra , "Indicate By Simple Config Format\n");
+			SetPacketRx(padapter, _TRUE, _TRUE);
+		} else {
+			pmppriv->bRTWSmbCfg = _FALSE;
+			sprintf(extra , "Indicate By Normal Format\n");
+			SetPacketRx(padapter, _TRUE, _FALSE);
+		}
+	}
+
+	wrqu->length = strlen(extra) + 1;
+
+	return 0;
+}
+
+
+int rtw_mp_trx_query(struct net_device *dev,
+					 struct iw_request_info *info,
+					 struct iw_point *wrqu, char *extra)
+{
+	u32 txok, txfail, rxok, rxfail, rxfilterout;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+
+	txok = padapter->mppriv.tx.sended;
+	txfail = 0;
+	rxok = padapter->mppriv.rx_pktcount;
+	rxfail = padapter->mppriv.rx_crcerrpktcount;
+	rxfilterout = padapter->mppriv.rx_pktcount_filter_out;
+
+	_rtw_memset(extra, '\0', 128);
+
+	sprintf(extra, "Tx OK:%d, Tx Fail:%d, Rx OK:%d, CRC error:%d ,Rx Filter out:%d\n", txok, txfail, rxok, rxfail, rxfilterout);
+
+	wrqu->length = strlen(extra) + 1;
+
+	return 0;
+}
+
+
+int rtw_mp_pwrtrk(struct net_device *dev,
+				  struct iw_request_info *info,
+				  struct iw_point *wrqu, char *extra)
+{
+	u8 enable;
+	u32 thermal;
+	s32 ret;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(padapter);
+	u8		input[wrqu->length];
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	_rtw_memset(extra, 0, wrqu->length);
+
+	enable = 1;
+	if (wrqu->length > 1) {
+		/* not empty string*/
+		if (strncmp(input, "stop", 4) == 0) {
+			enable = 0;
+			sprintf(extra, "mp tx power tracking stop");
+		} else if (sscanf(input, "ther=%d", &thermal) == 1) {
+			ret = SetThermalMeter(padapter, (u8)thermal);
+			if (ret == _FAIL)
+				return -EPERM;
+			sprintf(extra, "mp tx power tracking start,target value=%d ok", thermal);
+		} else
+			return -EINVAL;
+	}
+
+	ret = SetPowerTracking(padapter, enable);
+	if (ret == _FAIL)
+		return -EPERM;
+
+	wrqu->length = strlen(extra);
+
+	return 0;
+}
+
+
+
+int rtw_mp_psd(struct net_device *dev,
+			   struct iw_request_info *info,
+			   struct iw_point *wrqu, char *extra)
+{
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	u8		input[wrqu->length];
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	strcpy(extra, input);
+
+	wrqu->length = mp_query_psd(padapter, extra);
+
+	return 0;
+}
+
+
+int rtw_mp_thermal(struct net_device *dev,
+				   struct iw_request_info *info,
+				   struct iw_point *wrqu, char *extra)
+{
+	u8 val;
+	int bwrite = 1;
+
+#ifdef CONFIG_RTL8188E
+	u16 addr = EEPROM_THERMAL_METER_88E;
+#endif
+#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A) || defined(CONFIG_RTL8814A)
+	u16 addr = EEPROM_THERMAL_METER_8812;
+#endif
+#ifdef CONFIG_RTL8192E
+	u16 addr = EEPROM_THERMAL_METER_8192E;
+#endif
+#ifdef CONFIG_RTL8723B
+	u16 addr = EEPROM_THERMAL_METER_8723B;
+#endif
+#ifdef CONFIG_RTL8703B
+	u16 addr = EEPROM_THERMAL_METER_8703B;
+#endif
+#ifdef CONFIG_RTL8188F
+	u16 addr = EEPROM_THERMAL_METER_8188F;
+#endif
+	u16 cnt = 1;
+	u16 max_available_size = 0;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+
+	if (copy_from_user(extra, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	bwrite = strncmp(extra, "write", 6);/* strncmp TRUE is 0*/
+
+	GetThermalMeter(padapter, &val);
+
+	if (bwrite == 0) {
+		/*DBG_871X("to write val:%d",val);*/
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+		if (2 > max_available_size) {
+			DBG_871X("no available efuse!\n");
+			return -EFAULT;
+		}
+		if (rtw_efuse_map_write(padapter, addr, cnt, &val) == _FAIL) {
+			DBG_871X("rtw_efuse_map_write error\n");
+			return -EFAULT;
+		}
+		sprintf(extra, " efuse write ok :%d", val);
+	} else
+		sprintf(extra, "%d", val);
+	wrqu->length = strlen(extra);
+
+	return 0;
+}
+
+
+
+int rtw_mp_reset_stats(struct net_device *dev,
+					   struct iw_request_info *info,
+					   struct iw_point *wrqu, char *extra)
+{
+	struct mp_priv *pmp_priv;
+	struct pkt_attrib *pattrib;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+
+	pmp_priv = &padapter->mppriv;
+
+	pmp_priv->tx.sended = 0;
+	pmp_priv->tx_pktcount = 0;
+	pmp_priv->rx_pktcount = 0;
+	pmp_priv->rx_pktcount_filter_out = 0;
+	pmp_priv->rx_crcerrpktcount = 0;
+
+	rtw_reset_phy_rx_counters(padapter);
+	rtw_reset_mac_rx_counters(padapter);
+
+	return 0;
+}
+
+
+int rtw_mp_dump(struct net_device *dev,
+				struct iw_request_info *info,
+				struct iw_point *wrqu, char *extra)
+{
+	struct mp_priv *pmp_priv;
+	struct pkt_attrib *pattrib;
+	u32 value;
+	u8		input[wrqu->length];
+	u8 rf_type, path_nums = 0;
+	u32 i, j = 1, path;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+
+	pmp_priv = &padapter->mppriv;
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	if (strncmp(input, "all", 4) == 0) {
+		mac_reg_dump(RTW_DBGDUMP, padapter);
+		bb_reg_dump(RTW_DBGDUMP, padapter);
+		rf_reg_dump(RTW_DBGDUMP, padapter);
+	}
+	return 0;
+}
+
+
+int rtw_mp_phypara(struct net_device *dev,
+				   struct iw_request_info *info,
+				   struct iw_point *wrqu, char *extra)
+{
+
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
+	char	input[wrqu->length];
+	u32		valxcap, ret;
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	DBG_871X("%s:iwpriv in=%s\n", __func__, input);
+
+	ret = sscanf(input, "xcap=%d", &valxcap);
+
+	pHalData->CrystalCap = (u8)valxcap;
+	hal_set_crystal_cap(padapter , valxcap);
+
+	sprintf(extra, "Set xcap=%d", valxcap);
+	wrqu->length = strlen(extra) + 1;
+
+	return 0;
+
+}
+
+
+int rtw_mp_SetRFPath(struct net_device *dev,
+					 struct iw_request_info *info,
+					 union iwreq_data *wrqu, char *extra)
+{
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	char	input[wrqu->data.length];
+	int		bMain = 1, bTurnoff = 1;
+
+	if (copy_from_user(input, wrqu->data.pointer, wrqu->data.length))
+		return -EFAULT;
+	DBG_871X("%s:iwpriv in=%s\n", __func__, input);
+
+	bMain = strncmp(input, "1", 2); /* strncmp TRUE is 0*/
+	bTurnoff = strncmp(input, "0", 3); /* strncmp TRUE is 0*/
+
+	if (bMain == 0) {
+		MP_PHY_SetRFPathSwitch(padapter, _TRUE);
+		DBG_871X("%s:PHY_SetRFPathSwitch=TRUE\n", __func__);
+	} else if (bTurnoff == 0) {
+		MP_PHY_SetRFPathSwitch(padapter, _FALSE);
+		DBG_871X("%s:PHY_SetRFPathSwitch=FALSE\n", __func__);
+	}
+
+	return 0;
+}
+
+
+int rtw_mp_QueryDrv(struct net_device *dev,
+					struct iw_request_info *info,
+					union iwreq_data *wrqu, char *extra)
+{
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	char	input[wrqu->data.length];
+	int	qAutoLoad = 1;
+
+	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);
+
+	if (copy_from_user(input, wrqu->data.pointer, wrqu->data.length))
+		return -EFAULT;
+	DBG_871X("%s:iwpriv in=%s\n", __func__, input);
+
+	qAutoLoad = strncmp(input, "autoload", 8); /* strncmp TRUE is 0*/
+
+	if (qAutoLoad == 0) {
+		DBG_871X("%s:qAutoLoad\n", __func__);
+
+		if (pHalData->bautoload_fail_flag)
+			sprintf(extra, "fail");
+		else
+			sprintf(extra, "ok");
+	}
+	wrqu->data.length = strlen(extra) + 1;
+	return 0;
+}
+
+
+int rtw_mp_PwrCtlDM(struct net_device *dev,
+					struct iw_request_info *info,
+					struct iw_point *wrqu, char *extra)
+{
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	u8		input[wrqu->length];
+	int		bstart = 1;
+
+	if (copy_from_user(input, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	bstart = strncmp(input, "start", 5); /* strncmp TRUE is 0*/
+	if (bstart == 0) {
+		sprintf(extra, "PwrCtlDM start\n");
+		MPT_PwrCtlDM(padapter, 1);
+	} else {
+		sprintf(extra, "PwrCtlDM stop\n");
+		MPT_PwrCtlDM(padapter, 0);
+	}
+	wrqu->length = strlen(extra);
+
+	return 0;
+}
+
+
+int rtw_mp_getver(struct net_device *dev,
+				  struct iw_request_info *info,
+				  union iwreq_data *wrqu, char *extra)
+{
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	struct mp_priv *pmp_priv;
+
+	pmp_priv = &padapter->mppriv;
+
+	if (copy_from_user(extra, wrqu->data.pointer, wrqu->data.length))
+		return -EFAULT;
+
+	sprintf(extra, "rtwpriv=%d\n", RTWPRIV_VER_INFO);
+	wrqu->data.length = strlen(extra);
+	return 0;
+}
+
+
+int rtw_mp_mon(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	struct mp_priv *pmp_priv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct hal_ops *pHalFunc = &padapter->HalFunc;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType;
+	int bstart = 1, bstop = 1;
+	
+	networkType = Ndis802_11Infrastructure;
+	if (copy_from_user(extra, wrqu->data.pointer, wrqu->data.length))
+		return -EFAULT;
+
+	rtw_pm_set_ips(padapter, IPS_NONE);
+	LeaveAllPowerSaveMode(padapter);
+
+#ifdef CONFIG_MP_INCLUDED
+	if (init_mp_priv(padapter) == _FAIL)
+		DBG_871X("%s: initialize MP private data Fail!\n", __func__);
+	padapter->mppriv.channel = 6;
+
+	bstart = strncmp(extra, "start", 5); /* strncmp TRUE is 0*/
+	bstop = strncmp(extra, "stop", 4); /* strncmp TRUE is 0*/
+	if (bstart == 0) {
+		mp_join(padapter, WIFI_FW_ADHOC_STATE);
+		SetPacketRx(padapter, _TRUE, _FALSE);
+		SetChannel(padapter);
+		pmp_priv->rx_bindicatePkt = _TRUE;
+		pmp_priv->bRTWSmbCfg = _TRUE;
+		sprintf(extra, "monitor mode start\n");
+	} else if (bstop == 0) {
+		SetPacketRx(padapter, _FALSE, _FALSE);
+		pmp_priv->rx_bindicatePkt = _FALSE;
+		pmp_priv->bRTWSmbCfg = _FALSE;
+		padapter->registrypriv.mp_mode = 1;
+		pHalFunc->hal_deinit(padapter);
+		padapter->registrypriv.mp_mode = 0;
+		pHalFunc->hal_init(padapter);
+		/*rtw_disassoc_cmd(padapter, 0, _TRUE);*/
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+			rtw_disassoc_cmd(padapter, 500, _TRUE);
+			rtw_indicate_disconnect(padapter);
+			/*rtw_free_assoc_resources(padapter, 1);*/
+		}
+		rtw_pm_set_ips(padapter, IPS_NORMAL);
+		sprintf(extra, "monitor mode Stop\n");
+	}
+#endif
+	wrqu->data.length = strlen(extra);
+	return 0;
+}
+
+int rtw_mp_pretx_proc(PADAPTER padapter, u8 bStartTest, char *extra)
+{
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
+	struct mp_priv *pmp_priv = &padapter->mppriv;
+	PMPT_CONTEXT		pMptCtx = &(padapter->mppriv.MptCtx);
+
+		switch (pmp_priv->mode) {
+
+		case MP_PACKET_TX:
+						if (bStartTest == 0) {
+							pmp_priv->tx.stop = 1;
+							pmp_priv->mode = MP_ON;
+							sprintf(extra, "Stop continuous Tx");
+						} else if (pmp_priv->tx.stop == 1) {
+							sprintf(extra, "%s\nStart continuous DA=ffffffffffff len=1500 count=%u\n", extra, pmp_priv->tx.count);
+							pmp_priv->tx.stop = 0;
+							SetPacketTx(padapter);
+						} else {
+							return -EFAULT;
+						}
+						return 0;
+		case MP_SINGLE_TONE_TX:
+						if (bStartTest != 0)
+							sprintf(extra, "%s\nStart continuous DA=ffffffffffff len=1500\n infinite=yes.", extra);
+						SetSingleToneTx(padapter, (u8)bStartTest);
+						break;
+		case MP_CONTINUOUS_TX:
+						if (bStartTest != 0)
+							sprintf(extra, "%s\nStart continuous DA=ffffffffffff len=1500\n infinite=yes.", extra);
+						SetContinuousTx(padapter, (u8)bStartTest);
+						break;
+		case MP_CARRIER_SUPPRISSION_TX:
+						if (bStartTest != 0) {
+							if (pmp_priv->rateidx <= MPT_RATE_11M)
+								sprintf(extra, "%s\nStart continuous DA=ffffffffffff len=1500\n infinite=yes.", extra);
+							else
+								sprintf(extra, "%s\nSpecify carrier suppression but not CCK rate", extra);
+						}
+						SetCarrierSuppressionTx(padapter, (u8)bStartTest);
+						break;
+		case MP_SINGLE_CARRIER_TX:
+					if (bStartTest != 0)
+							sprintf(extra, "%s\nStart continuous DA=ffffffffffff len=1500\n infinite=yes.", extra);
+						SetSingleCarrierTx(padapter, (u8)bStartTest);
+						break;
+
+		default:
+						sprintf(extra, "Error! Continuous-Tx is not on-going.");
+						return -EFAULT;
+		}
+
+		if (bStartTest == 1 && pmp_priv->mode != MP_ON) {
+			struct mp_priv *pmp_priv = &padapter->mppriv;
+
+			if (pmp_priv->tx.stop == 0) {
+				pmp_priv->tx.stop = 1;
+				rtw_msleep_os(5);
+			}
+#ifdef CONFIG_80211N_HT
+			pmp_priv->tx.attrib.ht_en = 1;
+#endif
+			pmp_priv->tx.stop = 0;
+			pmp_priv->tx.count = 1;
+			SetPacketTx(padapter);
+		} else
+			pmp_priv->mode = MP_ON;
+
+#if defined(CONFIG_RTL8812A)
+			if (IS_HARDWARE_TYPE_8812AU(padapter)) {
+				/* <20130425, Kordan> Turn off OFDM Rx to prevent from CCA causing Tx hang.*/
+				if (pmp_priv->mode == MP_PACKET_TX)
+					PHY_SetBBReg(padapter, rCCAonSec_Jaguar, BIT3, 1);
+				else
+					PHY_SetBBReg(padapter, rCCAonSec_Jaguar, BIT3, 0);
+			}
+#endif
+
+	return 0;
+}
+
+
+int rtw_mp_tx(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+		PADAPTER padapter = rtw_netdev_priv(dev);
+		HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
+		struct mp_priv *pmp_priv = &padapter->mppriv;
+		PMPT_CONTEXT		pMptCtx = &(padapter->mppriv.MptCtx);
+
+		u32 bandwidth = 0, sg = 0, channel = 6, txpower = 40, rate = 108, ant = 0, txmode = 1, count = 0;
+		u8 i = 0, j = 0, bStartTest = 1, status = 0;
+		u16 antenna = 0;
+
+		if (copy_from_user(extra, wrqu->data.pointer, wrqu->data.length))
+			return -EFAULT;
+		DBG_871X("extra = %s\n", extra);
+
+		if (strncmp(extra, "stop", 3) == 0) {
+			bStartTest = 0; /* To set Stop*/
+			pmp_priv->tx.stop = 1;
+			sprintf(extra, "Stop continuous Tx");
+			status = rtw_mp_pretx_proc(padapter, bStartTest, extra);
+			wrqu->data.length = strlen(extra);
+			return status;
+		} else if (strncmp(extra, "count", 5) == 0) {
+				if (sscanf(extra, "count=%d", &count) < 1)
+					DBG_871X("Got Count=%d]\n", count);
+				pmp_priv->tx.count = count;
+				return 0;
+		} else if (strncmp(extra, "setting", 5) == 0) {
+				_rtw_memset(extra, 0, wrqu->data.length);
+				sprintf(extra, "Current Setting :\n Channel:%d", pmp_priv->channel);
+				sprintf(extra, "%s\n Bandwidth:%d", extra, pmp_priv->bandwidth);
+				sprintf(extra, "%s\n Rate index:%d", extra, pmp_priv->rateidx);
+				sprintf(extra, "%s\n TxPower index:%d", extra, pmp_priv->txpoweridx);
+				sprintf(extra, "%s\n Antenna TxPath:%d", extra, pmp_priv->antenna_tx);
+				sprintf(extra, "%s\n Antenna RxPath:%d", extra, pmp_priv->antenna_rx);
+				sprintf(extra, "%s\n MP Mode:%d", extra, pmp_priv->mode);
+				wrqu->data.length = strlen(extra);
+				return 0;
+		} else {
+
+			if (sscanf(extra, "ch=%d,bw=%d,rate=%d,pwr=%d,ant=%d,tx=%d", &channel, &bandwidth, &rate, &txpower, &ant, &txmode) < 6) {
+					DBG_871X("Invalid format [ch=%d,bw=%d,rate=%d,pwr=%d,ant=%d,tx=%d]\n", channel, bandwidth, rate, txpower, ant, txmode);
+					_rtw_memset(extra, 0, wrqu->data.length);
+					sprintf(extra, "\n Please input correct format as bleow:\n");
+					sprintf(extra, "%s\t ch=%d,bw=%d,rate=%d,pwr=%d,ant=%d,tx=%d\n", extra, channel, bandwidth, rate, txpower, ant, txmode);
+					sprintf(extra, "%s\n [ ch : BGN = <1~14> , A or AC = <36~165> ]", extra);
+					sprintf(extra, "%s\n [ bw : Bandwidth: 0 = 20M, 1 = 40M, 2 = 80M ]", extra);
+					sprintf(extra, "%s\n [ rate :	CCK: 1 2 5.5 11M X 2 = < 2 4 11 22 >]", extra);
+					sprintf(extra, "%s\n [		OFDM: 6 9 12 18 24 36 48 54M X 2 = < 12 18 24 36 48 72 96 108>", extra);
+					sprintf(extra, "%s\n [		HT 1S2SS MCS0 ~ MCS15 : < [MCS0]=128 ~ [MCS7]=135 ~ [MCS15]=143 >", extra);
+					sprintf(extra, "%s\n [		HT 3SS MCS16 ~ MCS32 : < [MCS16]=144 ~ [MCS23]=151 ~ [MCS32]=159 >", extra);
+					sprintf(extra, "%s\n [		VHT 1SS MCS0 ~ MCS9 : < [MCS0]=160 ~ [MCS9]=169 >", extra);
+					sprintf(extra, "%s\n [ txpower : 1~63 power index", extra);
+					sprintf(extra, "%s\n [ ant : <A = 1, B = 2, C = 4, D = 8> ,2T ex: AB=3 BC=6 CD=12", extra);
+					sprintf(extra, "%s\n [ txmode : < 0 = CONTINUOUS_TX, 1 = PACKET_TX, 2 = SINGLE_TONE_TX, 3 = CARRIER_SUPPRISSION_TX, 4 = SINGLE_CARRIER_TX>\n", extra);
+					wrqu->data.length = strlen(extra);
+					return status;
+
+			} else {
+				DBG_871X("Got format [ch=%d,bw=%d,rate=%d,pwr=%d,ant=%d,tx=%d]\n", channel, bandwidth, rate, txpower, ant, txmode);
+				_rtw_memset(extra, 0, wrqu->data.length);
+				sprintf(extra, "Change Current channel %d to channel %d", padapter->mppriv.channel , channel);
+				padapter->mppriv.channel = channel;
+				SetChannel(padapter);
+				pHalData->CurrentChannel = channel;
+
+				if (bandwidth == 1)
+					bandwidth = CHANNEL_WIDTH_40;
+				else if (bandwidth == 2)
+					bandwidth = CHANNEL_WIDTH_80;
+				sprintf(extra, "%s\nChange Current Bandwidth %d to Bandwidth %d", extra, padapter->mppriv.bandwidth , bandwidth);
+				padapter->mppriv.bandwidth = (u8)bandwidth;
+				padapter->mppriv.preamble = sg;
+				SetBandwidth(padapter);
+				pHalData->CurrentChannelBW = bandwidth;
+
+				sprintf(extra, "%s\nSet power level :%d", extra, txpower);
+				padapter->mppriv.txpoweridx = (u8)txpower;
+				pMptCtx->TxPwrLevel[ODM_RF_PATH_A] = (u8)txpower;
+				pMptCtx->TxPwrLevel[ODM_RF_PATH_B] = (u8)txpower;
+				pMptCtx->TxPwrLevel[ODM_RF_PATH_C] = (u8)txpower;
+				pMptCtx->TxPwrLevel[ODM_RF_PATH_D]  = (u8)txpower;
+
+				DBG_871X("%s: bw=%d sg=%d\n", __func__, bandwidth, sg);
+
+				if (rate <= 0x7f)
+					rate = wifirate2_ratetbl_inx((u8)rate);
+				else if (rate < 0xC8)
+					rate = (rate - 0x80 + MPT_RATE_MCS0);
+					/*HT  rate 0x80(MCS0)  ~ 0x8F(MCS15) ~ 0x9F(MCS31) 128~159
+					VHT1SS~2SS rate 0xA0 (VHT1SS_MCS0 44) ~ 0xB3 (VHT2SS_MCS9 #63) 160~179
+					VHT rate 0xB4 (VHT3SS_MCS0 64) ~ 0xC7 (VHT2SS_MCS9 #83) 180~199
+					else
+					VHT rate 0x90(VHT1SS_MCS0) ~ 0x99(VHT1SS_MCS9) 144~153
+					rate =(rate - MPT_RATE_VHT1SS_MCS0);
+					*/
+				DBG_871X("%s: rate index=%d\n", __func__, rate);
+				if (rate >= MPT_RATE_LAST)
+					return -EINVAL;
+				sprintf(extra, "%s\nSet data rate to %d index %d", extra, padapter->mppriv.rateidx, rate);
+
+				padapter->mppriv.rateidx = rate;
+				pMptCtx->MptRateIndex = rate;
+				SetDataRate(padapter);
+
+				sprintf(extra, "%s\nSet Antenna Path :%d",  extra, ant);
+				switch (ant) {
+				case 1:
+					antenna = ANTENNA_A;
+					break;
+				case 2:
+					antenna = ANTENNA_B;
+					break;
+				case 4:
+					antenna = ANTENNA_C;
+					break;
+				case 8:
+					antenna = ANTENNA_D;
+					break;
+				case 3:
+					antenna = ANTENNA_AB;
+					break;
+				case 5:
+					antenna = ANTENNA_AC;
+					break;
+				case 9:
+					antenna = ANTENNA_AD;
+					break;
+				case 6:
+					antenna = ANTENNA_BC;
+					break;
+				case 10:
+					antenna = ANTENNA_BD;
+					break;
+				case 12:
+					antenna = ANTENNA_CD;
+					break;
+				case 7:
+					antenna = ANTENNA_ABC;
+					break;
+				case 14:
+					antenna = ANTENNA_BCD;
+					break;
+				case 11:
+					antenna = ANTENNA_ABD;
+					break;
+				case 15:
+					antenna = ANTENNA_ABCD;
+					break;
+				}
+				DBG_871X("%s: antenna=0x%x\n", __func__, antenna);
+				padapter->mppriv.antenna_tx = antenna;
+				padapter->mppriv.antenna_rx = antenna;
+				pHalData->AntennaTxPath = antenna;
+				SetAntenna(padapter);
+
+				if (txmode == 0) {
+					pmp_priv->mode = MP_CONTINUOUS_TX;
+				} else if (txmode == 1) {
+					pmp_priv->mode = MP_PACKET_TX;
+					pmp_priv->tx.count = count;
+				} else if (txmode == 2) {
+					pmp_priv->mode = MP_SINGLE_TONE_TX;
+				} else if (txmode == 3) {
+					pmp_priv->mode = MP_CARRIER_SUPPRISSION_TX;
+				} else if (txmode == 4) {
+					pmp_priv->mode = MP_SINGLE_CARRIER_TX;
+				}
+
+			status = rtw_mp_pretx_proc(padapter, bStartTest, extra);
+			}
+
+		}
+
+		wrqu->data.length = strlen(extra);
+		return status;
+}
+
+
+int rtw_mp_rx(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
+	struct mp_priv *pmp_priv = &padapter->mppriv;
+	PMPT_CONTEXT		pMptCtx = &(padapter->mppriv.MptCtx);
+
+	u32 bandwidth = 0, sg = 0, channel = 6, ant = 0;
+	u16 antenna = 0;
+	u8 bStartRx = 0;
+
+	if (copy_from_user(extra, wrqu->data.pointer, wrqu->data.length))
+			return -EFAULT;
+
+	if (strncmp(extra, "stop", 4) == 0) {
+		_rtw_memset(extra, 0, wrqu->data.length);
+		SetPacketRx(padapter, bStartRx, _FALSE);
+		pmp_priv->bmac_filter = _FALSE;
+		sprintf(extra, "Received packet OK:%d CRC error:%d ,Filter out:%d", padapter->mppriv.rx_pktcount, padapter->mppriv.rx_crcerrpktcount, padapter->mppriv.rx_pktcount_filter_out);
+		wrqu->data.length = strlen(extra);
+		return 0;
+
+	} else if (sscanf(extra, "ch=%d,bw=%d,ant=%d", &channel, &bandwidth, &ant) < 3) {
+		DBG_871X("Invalid format [ch=%d,bw=%d,ant=%d]\n", channel, bandwidth, ant);
+		_rtw_memset(extra, 0, wrqu->data.length);
+		sprintf(extra, "\n Please input correct format as bleow:\n");
+		sprintf(extra, "%s\t ch=%d,bw=%d,ant=%d\n", extra, channel, bandwidth, ant);
+		sprintf(extra, "%s\n [ ch : BGN = <1~14> , A or AC = <36~165> ]", extra);
+		sprintf(extra, "%s\n [ bw : Bandwidth: 0 = 20M, 1 = 40M, 2 = 80M ]", extra);
+		sprintf(extra, "%s\n [ ant : <A = 1, B = 2, C = 4, D = 8> ,2T ex: AB=3 BC=6 CD=12", extra);
+		wrqu->data.length = strlen(extra);
+		return 0;
+
+	} else {
+		bStartRx = 1;
+		DBG_871X("Got format [ch=%d,bw=%d,ant=%d]\n", channel, bandwidth, ant);
+		_rtw_memset(extra, 0, wrqu->data.length);
+		sprintf(extra, "Change Current channel %d to channel %d", padapter->mppriv.channel , channel);
+		padapter->mppriv.channel = channel;
+		SetChannel(padapter);
+		pHalData->CurrentChannel = channel;
+
+		if (bandwidth == 1)
+			bandwidth = CHANNEL_WIDTH_40;
+		else if (bandwidth == 2)
+			bandwidth = CHANNEL_WIDTH_80;
+		sprintf(extra, "%s\nChange Current Bandwidth %d to Bandwidth %d", extra, padapter->mppriv.bandwidth , bandwidth);
+		padapter->mppriv.bandwidth = (u8)bandwidth;
+		padapter->mppriv.preamble = sg;
+		SetBandwidth(padapter);
+		pHalData->CurrentChannelBW = bandwidth;
+
+		sprintf(extra, "%s\nSet Antenna Path :%d",  extra, ant);
+		switch (ant) {
+		case 1:
+			antenna = ANTENNA_A;
+			break;
+		case 2:
+			antenna = ANTENNA_B;
+			break;
+		case 4:
+			antenna = ANTENNA_C;
+			break;
+		case 8:
+			antenna = ANTENNA_D;
+			break;
+		case 3:
+			antenna = ANTENNA_AB;
+			break;
+		case 5:
+			antenna = ANTENNA_AC;
+			break;
+		case 9:
+			antenna = ANTENNA_AD;
+			break;
+		case 6:
+			antenna = ANTENNA_BC;
+			break;
+		case 10:
+			antenna = ANTENNA_BD;
+			break;
+		case 12:
+			antenna = ANTENNA_CD;
+			break;
+		case 7:
+			antenna = ANTENNA_ABC;
+			break;
+		case 14:
+			antenna = ANTENNA_BCD;
+			break;
+		case 11:
+			antenna = ANTENNA_ABD;
+			break;
+		case 15:
+			antenna = ANTENNA_ABCD;
+			break;
+		}
+		DBG_871X("%s: antenna=0x%x\n", __func__, antenna);
+		padapter->mppriv.antenna_tx = antenna;
+		padapter->mppriv.antenna_rx = antenna;
+		pHalData->AntennaTxPath = antenna;
+		SetAntenna(padapter);
+
+		sprintf(extra, "%s\nstart Rx", extra);
+		SetPacketRx(padapter, bStartRx, _FALSE);
+	}
+	wrqu->data.length = strlen(extra);
+	return 0;
+}
+
+
+int rtw_efuse_mask_file(struct net_device *dev,
+						struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
+{
+	char *rtw_efuse_mask_file_path;
+	u8 Status;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	
+	_rtw_memset(maskfileBuffer, 0x00, sizeof(maskfileBuffer));
+
+	if (copy_from_user(extra, wrqu->data.pointer, wrqu->data.length))
+		return -EFAULT;
+
+	if (strncmp(extra, "off", 3) == 0 && strlen(extra) < 4) {
+		padapter->registrypriv.boffefusemask = 1;
+		sprintf(extra, "Turn off Efuse Mask\n");
+		wrqu->data.length = strlen(extra);
+		return 0;
+	}
+	if (strncmp(extra, "on", 2) == 0 && strlen(extra) < 3) {
+		padapter->registrypriv.boffefusemask = 0;
+		sprintf(extra, "Turn on Efuse Mask\n");
+		wrqu->data.length = strlen(extra);
+		return 0;
+	}
+	rtw_efuse_mask_file_path = extra;
+
+	if (rtw_is_file_readable(rtw_efuse_mask_file_path) == _TRUE) {
+		DBG_871X("%s do rtw_efuse_mask_file_read = %s! ,sizeof maskfileBuffer %zu\n", __func__, rtw_efuse_mask_file_path, sizeof(maskfileBuffer));
+		Status = rtw_efuse_file_read(padapter, rtw_efuse_mask_file_path, maskfileBuffer, sizeof(maskfileBuffer));
+		if (Status == _TRUE)
+			padapter->registrypriv.bFileMaskEfuse = _TRUE;
+		sprintf(extra, "efuse mask file read OK\n");
+	} else {
+		padapter->registrypriv.bFileMaskEfuse = _FALSE;
+		sprintf(extra, "efuse mask file readable FAIL\n");
+		DBG_871X("%s rtw_is_file_readable fail!\n", __func__);
+	}
+	wrqu->data.length = strlen(extra);
+	return 0;
+}
+
+
+int rtw_efuse_file_map(struct net_device *dev,
+					   struct iw_request_info *info,
+					   union iwreq_data *wrqu, char *extra)
+{
+	char *rtw_efuse_file_map_path;
+	u8 Status;
+	PEFUSE_HAL pEfuseHal;
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	
+	pEfuseHal = &pHalData->EfuseHal;
+	if (copy_from_user(extra, wrqu->data.pointer, wrqu->data.length))
+		return -EFAULT;
+
+	rtw_efuse_file_map_path = extra;
+
+	if (rtw_is_file_readable(rtw_efuse_file_map_path) == _TRUE) {
+		DBG_871X("%s do rtw_efuse_mask_file_read = %s!\n", __func__, rtw_efuse_file_map_path);
+		Status = rtw_efuse_file_read(padapter, rtw_efuse_file_map_path, pEfuseHal->fakeEfuseModifiedMap, sizeof(pEfuseHal->fakeEfuseModifiedMap));
+		if (Status == _TRUE)
+			sprintf(extra, "efuse file file_read OK\n");
+		else
+			sprintf(extra, "efuse file file_read FAIL\n");
+	} else {
+		sprintf(extra, "efuse file readable FAIL\n");
+		DBG_871X("%s rtw_is_file_readable fail!\n", __func__);
+	}
+	wrqu->data.length = strlen(extra);
+	return 0;
+}
+
+#if defined(CONFIG_RTL8723B)
+int rtw_mp_SetBT(struct net_device *dev,
+				 struct iw_request_info *info,
+				 union iwreq_data *wrqu, char *extra)
+{
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	struct hal_ops *pHalFunc = &padapter->HalFunc;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+
+	BT_REQ_CMD	BtReq;
+	PMPT_CONTEXT	pMptCtx = &(padapter->mppriv.MptCtx);
+	PBT_RSP_CMD	pBtRsp = (PBT_RSP_CMD)&pMptCtx->mptOutBuf[0];
+	char	input[128];
+	char *pch, *ptmp, *token, *tmp[2] = {0x00, 0x00};
+	u8 setdata[100];
+	u8 resetbt = 0x00;
+	u8 tempval, BTStatus;
+	u8 H2cSetbtmac[6];
+	u8 u1H2CBtMpOperParm[4] = {0x01};
+	int testmode = 1, ready = 1, trxparam = 1, setgen = 1, getgen = 1, testctrl = 1, testbt = 1, readtherm = 1, setbtmac = 1;
+	u32 i = 0, ii = 0, jj = 0, kk = 0, cnts = 0, status = 0;
+	PRT_MP_FIRMWARE pBTFirmware = NULL;
+
+	if (copy_from_user(extra, wrqu->data.pointer, wrqu->data.length))
+		return -EFAULT;
+	if (strlen(extra) < 1)
+		return -EFAULT;
+
+	DBG_871X("%s:iwpriv in=%s\n", __func__, extra);
+	ready = strncmp(extra, "ready", 5);
+	testmode = strncmp(extra, "testmode", 8); /* strncmp TRUE is 0*/
+	trxparam = strncmp(extra, "trxparam", 8);
+	setgen = strncmp(extra, "setgen", 6);
+	getgen = strncmp(extra, "getgen", 6);
+	testctrl = strncmp(extra, "testctrl", 8);
+	testbt = strncmp(extra, "testbt", 6);
+	readtherm = strncmp(extra, "readtherm", 9);
+	setbtmac = strncmp(extra, "setbtmac", 8);
+
+	if (strncmp(extra, "dlbt", 4) == 0) {
+		pHalData->LastHMEBoxNum = 0;
+		padapter->bBTFWReady = _FALSE;
+		rtw_write8(padapter, 0xa3, 0x05);
+		BTStatus = rtw_read8(padapter, 0xa0);
+		DBG_871X("%s: btwmap before read 0xa0 BT Status =0x%x\n", __func__, BTStatus);
+		if (BTStatus != 0x04) {
+			sprintf(extra, "BT Status not Active DLFW FAIL\n");
+			goto exit;
+		}
+
+		tempval = rtw_read8(padapter, 0x6B);
+		tempval |= BIT7;
+		rtw_write8(padapter, 0x6B, tempval);
+
+		/* Attention!! Between 0x6A[14] and 0x6A[15] setting need 100us delay*/
+		/* So don't write 0x6A[14]=1 and 0x6A[15]=0 together!*/
+		rtw_usleep_os(100);
+		/* disable BT power cut*/
+		/* 0x6A[14] = 0*/
+		tempval = rtw_read8(padapter, 0x6B);
+		tempval &= ~BIT6;
+		rtw_write8(padapter, 0x6B, tempval);
+		rtw_usleep_os(100);
+		MPT_PwrCtlDM(padapter, 0);
+		rtw_write32(padapter, 0xcc, (rtw_read32(padapter, 0xcc) | 0x00000004));
+		rtw_write32(padapter, 0x6b, (rtw_read32(padapter, 0x6b) & 0xFFFFFFEF));
+		rtw_msleep_os(600);
+		rtw_write32(padapter, 0x6b, (rtw_read32(padapter, 0x6b) | 0x00000010));
+		rtw_write32(padapter, 0xcc, (rtw_read32(padapter, 0xcc) & 0xFFFFFFFB));
+		rtw_msleep_os(1200);
+		pBTFirmware = (PRT_MP_FIRMWARE)rtw_zmalloc(sizeof(RT_MP_FIRMWARE));
+		if (pBTFirmware == NULL)
+			goto exit;
+		padapter->bBTFWReady = _FALSE;
+		FirmwareDownloadBT(padapter, pBTFirmware);
+		if (pBTFirmware)
+			rtw_mfree((u8 *)pBTFirmware, sizeof(RT_MP_FIRMWARE));
+
+		DBG_871X("Wait for FirmwareDownloadBT fw boot!\n");
+		rtw_msleep_os(2000);
+		_rtw_memset(extra, '\0', wrqu->data.length);
+		BtReq.opCodeVer = 1;
+		BtReq.OpCode = 0;
+		BtReq.paraLength = 0;
+		mptbt_BtControlProcess(padapter, &BtReq);
+		rtw_msleep_os(100);
+
+		DBG_8192C("FirmwareDownloadBT ready = 0x%x 0x%x", pMptCtx->mptOutBuf[4], pMptCtx->mptOutBuf[5]);
+		if ((pMptCtx->mptOutBuf[4] == 0x00) && (pMptCtx->mptOutBuf[5] == 0x00)) {
+
+			if (padapter->mppriv.bTxBufCkFail == _TRUE)
+				sprintf(extra, "check TxBuf Fail.\n");
+			else
+				sprintf(extra, "download FW Fail.\n");
+		} else {
+			sprintf(extra, "download FW OK.\n");
+			goto exit;
+		}
+		goto exit;
+	}
+	if (strncmp(extra, "dlfw", 4) == 0) {
+		pHalData->LastHMEBoxNum = 0;
+		padapter->bBTFWReady = _FALSE;
+		rtw_write8(padapter, 0xa3, 0x05);
+		BTStatus = rtw_read8(padapter, 0xa0);
+		DBG_871X("%s: btwmap before read 0xa0 BT Status =0x%x\n", __func__, BTStatus);
+		if (BTStatus != 0x04) {
+			sprintf(extra, "BT Status not Active DLFW FAIL\n");
+			goto exit;
+		}
+
+		tempval = rtw_read8(padapter, 0x6B);
+		tempval |= BIT7;
+		rtw_write8(padapter, 0x6B, tempval);
+
+		/* Attention!! Between 0x6A[14] and 0x6A[15] setting need 100us delay*/
+		/* So don't write 0x6A[14]=1 and 0x6A[15]=0 together!*/
+		rtw_usleep_os(100);
+		/* disable BT power cut*/
+		/* 0x6A[14] = 0*/
+		tempval = rtw_read8(padapter, 0x6B);
+		tempval &= ~BIT6;
+		rtw_write8(padapter, 0x6B, tempval);
+		rtw_usleep_os(100);
+
+		MPT_PwrCtlDM(padapter, 0);
+		rtw_write32(padapter, 0xcc, (rtw_read32(padapter, 0xcc) | 0x00000004));
+		rtw_write32(padapter, 0x6b, (rtw_read32(padapter, 0x6b) & 0xFFFFFFEF));
+		rtw_msleep_os(600);
+		rtw_write32(padapter, 0x6b, (rtw_read32(padapter, 0x6b) | 0x00000010));
+		rtw_write32(padapter, 0xcc, (rtw_read32(padapter, 0xcc) & 0xFFFFFFFB));
+		rtw_msleep_os(1200);
+
+#if defined(CONFIG_PLATFORM_SPRD) && (MP_DRIVER == 1)
+		/* Pull up BT reset pin.*/
+		DBG_871X("%s: pull up BT reset pin when bt start mp test\n", __func__);
+		rtw_wifi_gpio_wlan_ctrl(WLAN_BT_PWDN_ON);
+#endif
+		DBG_871X(" FirmwareDownload!\n");
+
+#if defined(CONFIG_RTL8723B)
+		status = rtl8723b_FirmwareDownload(padapter, _FALSE);
+#endif
+		DBG_871X("Wait for FirmwareDownloadBT fw boot!\n");
+		rtw_msleep_os(1000);
+#ifdef CONFIG_BT_COEXIST
+		rtw_btcoex_HaltNotify(padapter);
+		DBG_871X("SetBT btcoex HaltNotify !\n");
+		/*hal_btcoex1ant_SetAntPath(padapter);*/
+		rtw_btcoex_SetManualControl(padapter, _TRUE);
+#endif
+		_rtw_memset(extra, '\0', wrqu->data.length);
+		BtReq.opCodeVer = 1;
+		BtReq.OpCode = 0;
+		BtReq.paraLength = 0;
+		mptbt_BtControlProcess(padapter, &BtReq);
+		rtw_msleep_os(200);
+
+		DBG_8192C("FirmwareDownloadBT ready = 0x%x 0x%x", pMptCtx->mptOutBuf[4], pMptCtx->mptOutBuf[5]);
+		if ((pMptCtx->mptOutBuf[4] == 0x00) && (pMptCtx->mptOutBuf[5] == 0x00)) {
+			if (padapter->mppriv.bTxBufCkFail == _TRUE)
+				sprintf(extra, "check TxBuf Fail.\n");
+			else
+				sprintf(extra, "download FW Fail.\n");
+		} else {
+#ifdef CONFIG_BT_COEXIST
+			rtw_btcoex_SwitchBtTRxMask(padapter);
+#endif
+			rtw_msleep_os(200);
+			sprintf(extra, "download FW OK.\n");
+			goto exit;
+		}
+		goto exit;
+	}
+
+	if (strncmp(extra, "down", 4) == 0) {
+		DBG_871X("SetBT down for to hal_init !\n");
+#ifdef CONFIG_BT_COEXIST
+		rtw_btcoex_SetManualControl(padapter, _FALSE);
+		rtw_btcoex_Initialize(padapter);
+#endif
+		pHalFunc->read_adapter_info(padapter);
+		pHalFunc->hal_deinit(padapter);
+		pHalFunc->hal_init(padapter);
+		rtw_pm_set_ips(padapter, IPS_NONE);
+		LeaveAllPowerSaveMode(padapter);
+		MPT_PwrCtlDM(padapter, 0);
+		rtw_write32(padapter, 0xcc, (rtw_read32(padapter, 0xcc) | 0x00000004));
+		rtw_write32(padapter, 0x6b, (rtw_read32(padapter, 0x6b) & 0xFFFFFFEF));
+		rtw_msleep_os(600);
+		/*rtw_write32(padapter, 0x6a, (rtw_read32(padapter, 0x6a)& 0xFFFFFFFE));*/
+		rtw_write32(padapter, 0x6b, (rtw_read32(padapter, 0x6b) | 0x00000010));
+		rtw_write32(padapter, 0xcc, (rtw_read32(padapter, 0xcc) & 0xFFFFFFFB));
+		rtw_msleep_os(1200);
+		goto exit;
+	}
+	if (strncmp(extra, "disable", 7) == 0) {
+		DBG_871X("SetBT disable !\n");
+		rtw_write32(padapter, 0x6a, (rtw_read32(padapter, 0x6a) & 0xFFFFFFFB));
+		rtw_msleep_os(500);
+		goto exit;
+	}
+	if (strncmp(extra, "enable", 6) == 0) {
+		DBG_871X("SetBT enable !\n");
+		rtw_write32(padapter, 0x6a, (rtw_read32(padapter, 0x6a) | 0x00000004));
+		rtw_msleep_os(500);
+		goto exit;
+	}
+	if (strncmp(extra, "h2c", 3) == 0) {
+		DBG_871X("SetBT h2c !\n");
+		padapter->bBTFWReady = _TRUE;
+		rtw_hal_fill_h2c_cmd(padapter, 0x63, 1, u1H2CBtMpOperParm);
+		goto exit;
+	}
+	if (strncmp(extra, "2ant", 4) == 0) {
+		DBG_871X("Set BT 2ant use!\n");
+		PHY_SetMacReg(padapter, 0x67, BIT5, 0x1);
+		rtw_write32(padapter, 0x948, 0000);
+
+		goto exit;
+	}
+
+	if (ready != 0 && testmode != 0 && trxparam != 0 && setgen != 0 && getgen != 0 && testctrl != 0 && testbt != 0 && readtherm != 0 && setbtmac != 0)
+		return -EFAULT;
+
+	if (testbt == 0) {
+		BtReq.opCodeVer = 1;
+		BtReq.OpCode = 6;
+		BtReq.paraLength = cnts / 2;
+		goto todo;
+	}
+	if (ready == 0) {
+		BtReq.opCodeVer = 1;
+		BtReq.OpCode = 0;
+		BtReq.paraLength = 0;
+		goto todo;
+	}
+
+	pch = extra;
+	i = 0;
+	while ((token = strsep(&pch, ",")) != NULL) {
+		if (i > 1)
+			break;
+		tmp[i] = token;
+		i++;
+	}
+
+	if ((tmp[0] != NULL) && (tmp[1] != NULL)) {
+		cnts = strlen(tmp[1]);
+		if (cnts < 1)
+			return -EFAULT;
+
+		DBG_871X("%s: cnts=%d\n", __func__, cnts);
+		DBG_871X("%s: data=%s\n", __func__, tmp[1]);
+
+		for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2) {
+			BtReq.pParamStart[jj] = key_2char2num(tmp[1][kk], tmp[1][kk + 1]);
+			/*			DBG_871X("BtReq.pParamStart[%d]=0x%02x\n", jj, BtReq.pParamStart[jj]);*/
+		}
+	} else 
+		return -EFAULT;
+		
+	if (testmode == 0) {
+		BtReq.opCodeVer = 1;
+		BtReq.OpCode = 1;
+		BtReq.paraLength = 1;
+	}
+	if (trxparam == 0) {
+		BtReq.opCodeVer = 1;
+		BtReq.OpCode = 2;
+		BtReq.paraLength = cnts / 2;
+	}
+	if (setgen == 0) {
+		DBG_871X("%s: BT_SET_GENERAL\n", __func__);
+		BtReq.opCodeVer = 1;
+		BtReq.OpCode = 3;/*BT_SET_GENERAL	3*/
+		BtReq.paraLength = cnts / 2;
+	}
+	if (getgen == 0) {
+		DBG_871X("%s: BT_GET_GENERAL\n", __func__);
+		BtReq.opCodeVer = 1;
+		BtReq.OpCode = 4;/*BT_GET_GENERAL	4*/
+		BtReq.paraLength = cnts / 2;
+	}
+	if (readtherm == 0) {
+		DBG_871X("%s: BT_GET_GENERAL\n", __func__);
+		BtReq.opCodeVer = 1;
+		BtReq.OpCode = 4;/*BT_GET_GENERAL	4*/
+		BtReq.paraLength = cnts / 2;
+	}
+
+	if (testctrl == 0) {
+		DBG_871X("%s: BT_TEST_CTRL\n", __func__);
+		BtReq.opCodeVer = 1;
+		BtReq.OpCode = 5;/*BT_TEST_CTRL	5*/
+		BtReq.paraLength = cnts / 2;
+	}
+
+	DBG_871X("%s: Req opCodeVer=%d OpCode=%d paraLength=%d\n",
+			 __func__, BtReq.opCodeVer, BtReq.OpCode, BtReq.paraLength);
+
+	if (BtReq.paraLength < 1)
+		goto todo;
+	for (i = 0; i < BtReq.paraLength; i++) {
+		DBG_871X("%s: BtReq.pParamStart[%d] = 0x%02x\n",
+				 __func__, i, BtReq.pParamStart[i]);
+	}
+
+todo:
+	_rtw_memset(extra, '\0', wrqu->data.length);
+
+	if (padapter->bBTFWReady == _FALSE) {
+		sprintf(extra, "BTFWReady = FALSE.\n");
+		goto exit;
+	}
+
+	mptbt_BtControlProcess(padapter, &BtReq);
+
+	if (readtherm == 0) {
+		sprintf(extra, "BT thermal=");
+		for (i = 4; i < pMptCtx->mptOutLen; i++) {
+			if ((pMptCtx->mptOutBuf[i] == 0x00) && (pMptCtx->mptOutBuf[i + 1] == 0x00))
+				goto exit;
+
+			sprintf(extra, "%s %d ", extra, (pMptCtx->mptOutBuf[i] & 0x1f));
+		}
+	} else {
+		for (i = 4; i < pMptCtx->mptOutLen; i++)
+			sprintf(extra, "%s 0x%x ", extra, pMptCtx->mptOutBuf[i]);
+	}
+
+exit:
+	wrqu->data.length = strlen(extra) + 1;
+	DBG_871X("-%s: output len=%d data=%s\n", __func__, wrqu->data.length, extra);
+
+	return status;
+}
+
+#endif /*#ifdef CONFIG_RTL8723B*/
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/mlme_linux.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/mlme_linux.c
new file mode 100644
index 000000000..3d0c8bed1
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/mlme_linux.c
@@ -0,0 +1,582 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#define _MLME_OSDEP_C_
+
+#include <drv_types.h>
+
+
+#ifdef RTK_DMP_PLATFORM
+void Linkup_workitem_callback(struct work_struct *work)
+{
+	struct mlme_priv *pmlmepriv = container_of(work, struct mlme_priv, Linkup_workitem);
+	_adapter *padapter = container_of(pmlmepriv, _adapter, mlmepriv);
+
+_func_enter_;
+
+	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+ Linkup_workitem_callback\n"));
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12))
+	kobject_uevent(&padapter->pnetdev->dev.kobj, KOBJ_LINKUP);
+#else
+	kobject_hotplug(&padapter->pnetdev->class_dev.kobj, KOBJ_LINKUP);
+#endif
+
+_func_exit_;
+}
+
+void Linkdown_workitem_callback(struct work_struct *work)
+{
+	struct mlme_priv *pmlmepriv = container_of(work, struct mlme_priv, Linkdown_workitem);
+	_adapter *padapter = container_of(pmlmepriv, _adapter, mlmepriv);
+
+_func_enter_;
+
+	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+ Linkdown_workitem_callback\n"));
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12))
+	kobject_uevent(&padapter->pnetdev->dev.kobj, KOBJ_LINKDOWN);
+#else
+	kobject_hotplug(&padapter->pnetdev->class_dev.kobj, KOBJ_LINKDOWN);
+#endif
+
+_func_exit_;
+}
+#endif
+
+
+/*
+void sitesurvey_ctrl_handler(void *FunctionContext)
+{
+	_adapter *adapter = (_adapter *)FunctionContext;
+
+	_sitesurvey_ctrl_handler(adapter);
+
+	_set_timer(&adapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer, 3000);
+}
+*/
+
+static void _dynamic_check_timer_handler(struct timer_list *t)
+{
+	_adapter *adapter =
+		from_timer(adapter, t, mlmepriv.dynamic_chk_timer);
+
+#if (MP_DRIVER == 1)
+	if (adapter->registrypriv.mp_mode == 1 && adapter->mppriv.mp_dm ==0) //for MP ODM dynamic Tx power tracking
+	{
+		//DBG_871X("_dynamic_check_timer_handlder mp_dm =0 return \n");
+		_set_timer(&adapter->mlmepriv.dynamic_chk_timer, 2000);
+		return;
+	}
+#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if(adapter->pbuddy_adapter)
+		rtw_dynamic_check_timer_handler(adapter->pbuddy_adapter);
+#endif //CONFIG_CONCURRENT_MODE
+
+	rtw_dynamic_check_timer_handler(adapter);
+	
+	_set_timer(&adapter->mlmepriv.dynamic_chk_timer, 2000);
+}
+
+#ifdef CONFIG_SET_SCAN_DENY_TIMER
+static void _rtw_set_scan_deny_timer_hdl(struct timer_list *t)
+{
+	_adapter *adapter =
+		from_timer(adapter, t, mlmepriv.set_scan_deny_timer);
+	rtw_set_scan_deny_timer_hdl(adapter);
+}
+#endif
+
+
+void rtw_init_mlme_timer(_adapter *padapter)
+{
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	timer_setup(&pmlmepriv->assoc_timer, _rtw_join_timeout_handler, 0);
+	//_init_timer(&(pmlmepriv->sitesurveyctrl.sitesurvey_ctrl_timer), padapter->pnetdev, sitesurvey_ctrl_handler, padapter);
+	timer_setup(&pmlmepriv->scan_to_timer, rtw_scan_timeout_handler, 0);
+
+	#ifdef CONFIG_DFS_MASTER
+	timer_setup(&pmlmepriv->dfs_master_timer,
+		    rtw_dfs_master_timer_hdl, 0);
+	#endif
+
+	timer_setup(&pmlmepriv->dynamic_chk_timer,
+		    _dynamic_check_timer_handler, 0);
+
+	#ifdef CONFIG_SET_SCAN_DENY_TIMER
+	timer_setup(&pmlmepriv->set_scan_deny_timer,
+		    _rtw_set_scan_deny_timer_hdl, 0);
+	#endif
+
+#ifdef RTK_DMP_PLATFORM
+	_init_workitem(&(pmlmepriv->Linkup_workitem), Linkup_workitem_callback, padapter);
+	_init_workitem(&(pmlmepriv->Linkdown_workitem), Linkdown_workitem_callback, padapter);
+#endif
+
+}
+
+extern void rtw_indicate_wx_assoc_event(_adapter *padapter);
+extern void rtw_indicate_wx_disassoc_event(_adapter *padapter);
+
+void rtw_os_indicate_connect(_adapter *adapter)
+{
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+_func_enter_;	
+
+#ifdef CONFIG_IOCTL_CFG80211
+	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_TRUE ) || 
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE ) )
+	{
+		rtw_cfg80211_ibss_indicate_connect(adapter);
+	}
+	else
+		rtw_cfg80211_indicate_connect(adapter);
+#endif //CONFIG_IOCTL_CFG80211
+
+	rtw_indicate_wx_assoc_event(adapter);
+	netif_carrier_on(adapter->pnetdev);
+
+	if(adapter->pid[2] !=0)
+		rtw_signal_process(adapter->pid[2], SIGALRM);
+
+#ifdef RTK_DMP_PLATFORM
+	_set_workitem(&adapter->mlmepriv.Linkup_workitem);
+#endif
+
+_func_exit_;	
+
+}
+
+extern void indicate_wx_scan_complete_event(_adapter *padapter);
+void rtw_os_indicate_scan_done( _adapter *padapter, bool aborted)
+{
+#ifdef CONFIG_IOCTL_CFG80211
+	rtw_cfg80211_indicate_scan_done(padapter, aborted);
+#endif
+	indicate_wx_scan_complete_event(padapter);
+}
+
+static RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
+void rtw_reset_securitypriv( _adapter *adapter )
+{
+	u8	backupPMKIDIndex = 0;
+	u8	backupTKIPCountermeasure = 0x00;
+	u32	backupTKIPcountermeasure_time = 0;
+	// add for CONFIG_IEEE80211W, none 11w also can use
+	_irqL irqL;
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+	
+	_enter_critical_bh(&adapter->security_key_mutex, &irqL);
+	
+	if(adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)//802.1x
+	{		 
+		// Added by Albert 2009/02/18
+		// We have to backup the PMK information for WiFi PMK Caching test item.
+		//
+		// Backup the btkip_countermeasure information.
+		// When the countermeasure is trigger, the driver have to disconnect with AP for 60 seconds.
+
+		_rtw_memset( &backupPMKIDList[ 0 ], 0x00, sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+
+		_rtw_memcpy( &backupPMKIDList[ 0 ], &adapter->securitypriv.PMKIDList[ 0 ], sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+		backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
+		backupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;
+		backupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;		
+#ifdef CONFIG_IEEE80211W
+		//reset RX BIP packet number
+		pmlmeext->mgnt_80211w_IPN_rx = 0;
+#endif //CONFIG_IEEE80211W
+		_rtw_memset((unsigned char *)&adapter->securitypriv, 0, sizeof (struct security_priv));
+		//_init_timer(&(adapter->securitypriv.tkip_timer),adapter->pnetdev, rtw_use_tkipkey_handler, adapter);
+
+		// Added by Albert 2009/02/18
+		// Restore the PMK information to securitypriv structure for the following connection.
+		_rtw_memcpy( &adapter->securitypriv.PMKIDList[ 0 ], &backupPMKIDList[ 0 ], sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+		adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
+		adapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
+		adapter->securitypriv.btkip_countermeasure_time = backupTKIPcountermeasure_time;		
+
+		adapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
+		adapter->securitypriv.ndisencryptstatus = Ndis802_11WEPDisabled;
+
+	}
+	else //reset values in securitypriv 
+	{
+		//if(adapter->mlmepriv.fw_state & WIFI_STATION_STATE)
+		//{
+		struct security_priv *psec_priv=&adapter->securitypriv;
+
+		psec_priv->dot11AuthAlgrthm =dot11AuthAlgrthm_Open;  //open system
+		psec_priv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+		psec_priv->dot11PrivacyKeyIndex = 0;
+
+		psec_priv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+		psec_priv->dot118021XGrpKeyid = 1;
+
+		psec_priv->ndisauthtype = Ndis802_11AuthModeOpen;
+		psec_priv->ndisencryptstatus = Ndis802_11WEPDisabled;
+		//}
+	}
+	// add for CONFIG_IEEE80211W, none 11w also can use
+	_exit_critical_bh(&adapter->security_key_mutex, &irqL);
+
+	DBG_871X(FUNC_ADPT_FMT" - End to Disconnect\n", FUNC_ADPT_ARG(adapter));
+}
+
+void rtw_os_indicate_disconnect( _adapter *adapter )
+{
+	//RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
+
+_func_enter_;
+
+	netif_carrier_off(adapter->pnetdev); // Do it first for tx broadcast pkt after disconnection issue!
+
+#ifdef CONFIG_IOCTL_CFG80211
+	rtw_cfg80211_indicate_disconnect(adapter);
+#endif //CONFIG_IOCTL_CFG80211
+
+	rtw_indicate_wx_disassoc_event(adapter);
+
+#ifdef RTK_DMP_PLATFORM
+	_set_workitem(&adapter->mlmepriv.Linkdown_workitem);
+#endif
+	 //modify for CONFIG_IEEE80211W, none 11w also can use the same command
+	 rtw_reset_securitypriv_cmd(adapter);
+
+_func_exit_;
+
+}
+
+void rtw_report_sec_ie(_adapter *adapter,u8 authmode,u8 *sec_ie)
+{
+	uint	len;
+	u8	*buff,*p,i;
+	union iwreq_data wrqu;
+
+_func_enter_;
+
+	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+rtw_report_sec_ie, authmode=%d\n", authmode));
+
+	buff = NULL;
+	if(authmode==_WPA_IE_ID_)
+	{
+		RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("rtw_report_sec_ie, authmode=%d\n", authmode));
+
+		buff = rtw_zmalloc(IW_CUSTOM_MAX);
+		if (NULL == buff) {
+			DBG_871X(FUNC_ADPT_FMT ": alloc memory FAIL!!\n",
+				FUNC_ADPT_ARG(adapter));
+			return;
+		}
+		p = buff;
+
+		p+=sprintf(p,"ASSOCINFO(ReqIEs=");
+
+		len = sec_ie[1]+2;
+		len = (len < IW_CUSTOM_MAX) ? len:IW_CUSTOM_MAX;
+			
+		for(i=0;i<len;i++){
+			p+=sprintf(p,"%02x",sec_ie[i]);
+		}
+
+		p+=sprintf(p,")");
+
+		_rtw_memset(&wrqu,0,sizeof(wrqu));
+
+		wrqu.data.length=p-buff;
+
+		wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
+
+#ifndef CONFIG_IOCTL_CFG80211
+		wireless_send_event(adapter->pnetdev,IWEVCUSTOM,&wrqu,buff);
+#endif
+
+		rtw_mfree(buff, IW_CUSTOM_MAX);
+	}
+
+exit:
+
+_func_exit_;
+
+}
+
+#ifdef CONFIG_IEEE80211W
+
+void init_dot11w_expire_timer(_adapter *padapter, struct sta_info *psta)
+{
+	timer_setup(&psta->dot11w_expire_timer, sa_query_timer_hdl, 0);
+}
+
+#endif //CONFIG_IEEE80211W
+
+void init_addba_retry_timer(_adapter *padapter, struct sta_info *psta)
+{
+	timer_setup(&psta->addba_retry_timer, addba_timer_hdl, 0);
+}
+
+/*
+void _reauth_timer_hdl(void *FunctionContext)
+{
+	_adapter *padapter = (_adapter *)FunctionContext;
+	reauth_timer_hdl(padapter);
+}
+
+void _reassoc_timer_hdl(void *FunctionContext)
+{
+	_adapter *padapter = (_adapter *)FunctionContext;
+	reassoc_timer_hdl(padapter);
+}
+*/
+
+void init_mlme_ext_timer(_adapter *padapter)
+{	
+	struct	mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	timer_setup(&pmlmeext->survey_timer, survey_timer_hdl, 0);
+	timer_setup(&pmlmeext->link_timer, link_timer_hdl, 0);
+
+	//_init_timer(&pmlmeext->ADDBA_timer, padapter->pnetdev, _addba_timer_hdl, padapter);
+
+	//_init_timer(&pmlmeext->reauth_timer, padapter->pnetdev, _reauth_timer_hdl, padapter);
+	//_init_timer(&pmlmeext->reassoc_timer, padapter->pnetdev, _reassoc_timer_hdl, padapter);
+}
+
+#ifdef CONFIG_AP_MODE
+
+void rtw_indicate_sta_assoc_event(_adapter *padapter, struct sta_info *psta)
+{
+	union iwreq_data wrqu;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	if(psta==NULL)
+		return;
+
+	if(psta->aid > NUM_STA)
+		return;
+
+	if(pstapriv->sta_aid[psta->aid - 1] != psta)
+		return;
+	
+	
+	wrqu.addr.sa_family = ARPHRD_ETHER;	
+	
+	_rtw_memcpy(wrqu.addr.sa_data, psta->hwaddr, ETH_ALEN);
+
+	DBG_871X("+rtw_indicate_sta_assoc_event\n");
+	
+#ifndef CONFIG_IOCTL_CFG80211
+	wireless_send_event(padapter->pnetdev, IWEVREGISTERED, &wrqu, NULL);
+#endif
+
+}
+
+void rtw_indicate_sta_disassoc_event(_adapter *padapter, struct sta_info *psta)
+{
+	union iwreq_data wrqu;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	if(psta==NULL)
+		return;
+
+	if(psta->aid > NUM_STA)
+		return;
+
+	if(pstapriv->sta_aid[psta->aid - 1] != psta)
+		return;
+	
+	
+	wrqu.addr.sa_family = ARPHRD_ETHER;	
+	
+	_rtw_memcpy(wrqu.addr.sa_data, psta->hwaddr, ETH_ALEN);
+
+	DBG_871X("+rtw_indicate_sta_disassoc_event\n");
+	
+#ifndef CONFIG_IOCTL_CFG80211
+	wireless_send_event(padapter->pnetdev, IWEVEXPIRED, &wrqu, NULL);
+#endif
+	
+}
+
+
+#ifdef CONFIG_HOSTAPD_MLME
+
+static int mgnt_xmit_entry(struct sk_buff *skb, struct net_device *pnetdev)
+{
+	struct hostapd_priv *phostapdpriv = rtw_netdev_priv(pnetdev);
+	_adapter *padapter = (_adapter *)phostapdpriv->padapter;
+
+	//DBG_871X("%s\n", __FUNCTION__);
+
+	return rtw_hal_hostap_mgnt_xmit_entry(padapter, skb);
+}
+
+static int mgnt_netdev_open(struct net_device *pnetdev)
+{
+	struct hostapd_priv *phostapdpriv = rtw_netdev_priv(pnetdev);
+
+	DBG_871X("mgnt_netdev_open: MAC Address:" MAC_FMT "\n", MAC_ARG(pnetdev->dev_addr));
+
+
+	init_usb_anchor(&phostapdpriv->anchored);
+	
+	rtw_netif_wake_queue(pnetdev);
+
+	netif_carrier_on(pnetdev);
+		
+	//rtw_write16(phostapdpriv->padapter, 0x0116, 0x0100);//only excluding beacon 
+		
+	return 0;	
+}
+static int mgnt_netdev_close(struct net_device *pnetdev)
+{
+	struct hostapd_priv *phostapdpriv = rtw_netdev_priv(pnetdev);
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	usb_kill_anchored_urbs(&phostapdpriv->anchored);
+
+	netif_carrier_off(pnetdev);
+
+	rtw_netif_stop_queue(pnetdev);
+
+	//rtw_write16(phostapdpriv->padapter, 0x0116, 0x3f3f);
+	
+	return 0;	
+}
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+static const struct net_device_ops rtl871x_mgnt_netdev_ops = {
+	.ndo_open = mgnt_netdev_open,
+       .ndo_stop = mgnt_netdev_close,
+       .ndo_start_xmit = mgnt_xmit_entry,
+       //.ndo_set_mac_address = r871x_net_set_mac_address,
+       //.ndo_get_stats = r871x_net_get_stats,
+       //.ndo_do_ioctl = r871x_mp_ioctl,
+};
+#endif
+
+int hostapd_mode_init(_adapter *padapter)
+{
+	unsigned char mac[ETH_ALEN];
+	struct hostapd_priv *phostapdpriv;
+	struct net_device *pnetdev;
+	
+	pnetdev = rtw_alloc_etherdev(sizeof(struct hostapd_priv));	
+	if (!pnetdev)
+	   return -ENOMEM;
+
+	//SET_MODULE_OWNER(pnetdev);
+       ether_setup(pnetdev);
+
+	//pnetdev->type = ARPHRD_IEEE80211;
+	
+	phostapdpriv = rtw_netdev_priv(pnetdev);
+	phostapdpriv->pmgnt_netdev = pnetdev;
+	phostapdpriv->padapter= padapter;
+	padapter->phostapdpriv = phostapdpriv;
+	
+	//pnetdev->init = NULL;
+	
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+
+	DBG_871X("register rtl871x_mgnt_netdev_ops to netdev_ops\n");
+
+	pnetdev->netdev_ops = &rtl871x_mgnt_netdev_ops;
+	
+#else
+
+	pnetdev->open = mgnt_netdev_open;
+
+	pnetdev->stop = mgnt_netdev_close;	
+	
+	pnetdev->hard_start_xmit = mgnt_xmit_entry;
+	
+	//pnetdev->set_mac_address = r871x_net_set_mac_address;
+	
+	//pnetdev->get_stats = r871x_net_get_stats;
+
+	//pnetdev->do_ioctl = r871x_mp_ioctl;
+	
+#endif
+
+	pnetdev->watchdog_timeo = HZ; /* 1 second timeout */	
+
+	//pnetdev->wireless_handlers = NULL;
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	pnetdev->features |= NETIF_F_IP_CSUM;
+#endif	
+
+	
+	
+	if(dev_alloc_name(pnetdev,"mgnt.wlan%d") < 0)
+	{
+		DBG_871X("hostapd_mode_init(): dev_alloc_name, fail! \n");		
+	}
+
+
+	//SET_NETDEV_DEV(pnetdev, pintfpriv->udev);
+
+
+	mac[0]=0x00;
+	mac[1]=0xe0;
+	mac[2]=0x4c;
+	mac[3]=0x87;
+	mac[4]=0x11;
+	mac[5]=0x12;
+				
+	_rtw_memcpy(pnetdev->dev_addr, mac, ETH_ALEN);
+	
+
+	netif_carrier_off(pnetdev);
+
+
+	/* Tell the network stack we exist */
+	if (register_netdev(pnetdev) != 0)
+	{
+		DBG_871X("hostapd_mode_init(): register_netdev fail!\n");
+		
+		if(pnetdev)
+      		{	 
+			rtw_free_netdev(pnetdev);
+      		}
+	}
+	
+	return 0;
+	
+}
+
+void hostapd_mode_unload(_adapter *padapter)
+{
+	struct hostapd_priv *phostapdpriv = padapter->phostapdpriv;
+	struct net_device *pnetdev = phostapdpriv->pmgnt_netdev;
+
+	unregister_netdev(pnetdev);
+	rtw_free_netdev(pnetdev);
+	
+}
+
+#endif
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/os_intfs.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/os_intfs.c
new file mode 100644
index 000000000..63f3f535a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/os_intfs.c
@@ -0,0 +1,4471 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _OS_INTFS_C_
+
+#include <drv_types.h>
+#include <hal_data.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Realtek Wireless Lan Driver");
+MODULE_AUTHOR("Realtek Semiconductor Corp.");
+MODULE_VERSION(DRIVERVERSION);
+
+/* module param defaults */
+int rtw_chip_version = 0x00;
+int rtw_rfintfs = HWPI;
+int rtw_lbkmode = 0;//RTL8712_AIR_TRX;
+
+
+int rtw_network_mode = Ndis802_11IBSS;//Ndis802_11Infrastructure;//infra, ad-hoc, auto
+//NDIS_802_11_SSID	ssid;
+int rtw_channel = 1;//ad-hoc support requirement
+int rtw_wireless_mode = WIRELESS_MODE_MAX;
+int rtw_vrtl_carrier_sense = AUTO_VCS;
+int rtw_vcs_type = RTS_CTS;//*
+int rtw_rts_thresh = 2347;//*
+int rtw_frag_thresh = 2346;//*
+int rtw_preamble = PREAMBLE_LONG;//long, short, auto
+int rtw_scan_mode = 1;//active, passive
+int rtw_adhoc_tx_pwr = 1;
+int rtw_soft_ap = 0;
+//int smart_ps = 1;
+#ifdef CONFIG_POWER_SAVING
+int rtw_power_mgnt = PS_MODE_MAX;
+#ifdef CONFIG_IPS_LEVEL_2
+int rtw_ips_mode = IPS_LEVEL_2;
+#else
+int rtw_ips_mode = IPS_NORMAL;
+#endif
+#else
+int rtw_power_mgnt = PS_MODE_ACTIVE;
+int rtw_ips_mode = IPS_NONE;
+#endif
+module_param(rtw_ips_mode, int, 0644);
+MODULE_PARM_DESC(rtw_ips_mode,"The default IPS mode");
+
+int rtw_smart_ps = 2;
+
+int rtw_check_fw_ps = 1;
+
+#ifdef CONFIG_TX_EARLY_MODE
+int rtw_early_mode=1;
+#endif
+
+int rtw_usb_rxagg_mode = 2;//USB_RX_AGG_DMA =1,USB_RX_AGG_USB=2
+module_param(rtw_usb_rxagg_mode, int, 0644);
+
+int rtw_radio_enable = 1;
+int rtw_long_retry_lmt = 7;
+int rtw_short_retry_lmt = 7;
+int rtw_busy_thresh = 40;
+//int qos_enable = 0; //*
+int rtw_ack_policy = NORMAL_ACK;
+
+int rtw_mp_mode = 0;
+
+int rtw_software_encrypt = 0;
+int rtw_software_decrypt = 0;
+
+int rtw_acm_method = 0;// 0:By SW 1:By HW.
+
+int rtw_wmm_enable = 1;// default is set to enable the wmm.
+int rtw_uapsd_enable = 0;
+int rtw_uapsd_max_sp = NO_LIMIT;
+int rtw_uapsd_acbk_en = 0;
+int rtw_uapsd_acbe_en = 0;
+int rtw_uapsd_acvi_en = 0;
+int rtw_uapsd_acvo_en = 0;
+#ifdef CONFIG_RTL8814A
+int rtw_rfkfree_enable = 2; /* disable kfree */
+#else
+int rtw_rfkfree_enable = 0; /* Default Enalbe kfree by efuse config */
+#endif
+#ifdef CONFIG_80211N_HT
+int rtw_ht_enable = 1;
+// 0: 20 MHz, 1: 40 MHz, 2: 80 MHz, 3: 160MHz, 4: 80+80MHz
+// 2.4G use bit 0 ~ 3, 5G use bit 4 ~ 7
+// 0x21 means enable 2.4G 40MHz & 5G 80MHz
+int rtw_bw_mode = 0x21;
+int rtw_ampdu_enable = 1;//for enable tx_ampdu ,// 0: disable, 0x1:enable (but wifi_spec should be 0), 0x2: force enable (don't care wifi_spec)
+int rtw_rx_stbc = 1;// 0: disable, bit(0):enable 2.4g, bit(1):enable 5g, default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ
+int rtw_ampdu_amsdu = 0;// 0: disabled, 1:enabled, 2:auto . There is an IOT issu with DLINK DIR-629 when the flag turn on
+// Short GI support Bit Map
+// BIT0 - 20MHz, 0: non-support, 1: support
+// BIT1 - 40MHz, 0: non-support, 1: support
+// BIT2 - 80MHz, 0: non-support, 1: support
+// BIT3 - 160MHz, 0: non-support, 1: support
+int rtw_short_gi = 0xf;
+// BIT0: Enable VHT LDPC Rx, BIT1: Enable VHT LDPC Tx, BIT4: Enable HT LDPC Rx, BIT5: Enable HT LDPC Tx
+int rtw_ldpc_cap = 0x00;
+// BIT0: Enable VHT STBC Rx, BIT1: Enable VHT STBC Tx, BIT4: Enable HT STBC Rx, BIT5: Enable HT STBC Tx
+int rtw_stbc_cap = 0x13;
+// BIT0: Enable VHT Beamformer, BIT1: Enable VHT Beamformee, BIT4: Enable HT Beamformer, BIT5: Enable HT Beamformee
+int rtw_beamform_cap = 0x2;
+int rtw_bfer_rf_number = 0; /*BeamformerCapRfNum Rf path number, 0 for auto, others for manual*/
+int rtw_bfee_rf_number = 0; /*BeamformeeCapRfNum  Rf path number, 0 for auto, others for manual*/
+
+#endif //CONFIG_80211N_HT
+
+#ifdef CONFIG_80211AC_VHT
+int rtw_vht_enable = 1; //0:disable, 1:enable, 2:force auto enable
+int rtw_ampdu_factor = 7;
+int rtw_vht_rate_sel = 0;
+#endif //CONFIG_80211AC_VHT
+
+int rtw_lowrate_two_xmit = 1;//Use 2 path Tx to transmit MCS0~7 and legacy mode
+
+//int rf_config = RF_1T2R;  // 1T2R
+int rtw_rf_config = RF_MAX_TYPE;  //auto
+
+int rtw_low_power = 0;
+#ifdef CONFIG_WIFI_TEST
+int rtw_wifi_spec = 1;//for wifi test
+#else
+int rtw_wifi_spec = 0;
+#endif
+
+int rtw_special_rf_path = 0; //0: 2T2R ,1: only turn on path A 1T1R
+
+int rtw_channel_plan = RTW_CHPLAN_MAX;
+
+#ifdef CONFIG_BT_COEXIST
+int rtw_btcoex_enable = 1;
+module_param(rtw_btcoex_enable, int, 0644);
+MODULE_PARM_DESC(rtw_btcoex_enable, "Enable BT co-existence mechanism");
+int rtw_bt_iso = 2;// 0:Low, 1:High, 2:From Efuse
+int rtw_bt_sco = 3;// 0:Idle, 1:None-SCO, 2:SCO, 3:From Counter, 4.Busy, 5.OtherBusy
+int rtw_bt_ampdu =1 ;// 0:Disable BT control A-MPDU, 1:Enable BT control A-MPDU.
+int rtw_ant_num = -1; // <0: undefined, >0: Antenna number
+module_param(rtw_ant_num, int, 0644);
+MODULE_PARM_DESC(rtw_ant_num, "Antenna number setting");
+#endif
+
+int rtw_AcceptAddbaReq = _TRUE;// 0:Reject AP's Add BA req, 1:Accept AP's Add BA req.
+
+int rtw_antdiv_cfg = 2; // 0:OFF , 1:ON, 2:decide by Efuse config
+int rtw_antdiv_type = 0 ; //0:decide by efuse  1: for 88EE, 1Tx and 1RxCG are diversity.(2 Ant with SPDT), 2:  for 88EE, 1Tx and 2Rx are diversity.( 2 Ant, Tx and RxCG are both on aux port, RxCS is on main port ), 3: for 88EE, 1Tx and 1RxCG are fixed.(1Ant, Tx and RxCG are both on aux port)
+
+int rtw_switch_usb3 = _FALSE; /* _FALSE: doesn't switch, _TRUE: switch from usb2.0 to usb 3.0 */
+
+#ifdef CONFIG_USB_AUTOSUSPEND
+int rtw_enusbss = 1;//0:disable,1:enable
+#else
+int rtw_enusbss = 0;//0:disable,1:enable
+#endif
+
+int rtw_hwpdn_mode=2;//0:disable,1:enable,2: by EFUSE config
+
+#ifdef CONFIG_HW_PWRP_DETECTION
+int rtw_hwpwrp_detect = 1;
+#else
+int rtw_hwpwrp_detect = 0; //HW power  ping detect 0:disable , 1:enable
+#endif
+
+#ifdef CONFIG_USB_HCI
+int rtw_hw_wps_pbc = 1;
+#else
+int rtw_hw_wps_pbc = 0;
+#endif
+
+#ifdef CONFIG_TX_MCAST2UNI
+int rtw_mc2u_disable = 0;
+#endif	// CONFIG_TX_MCAST2UNI
+
+#ifdef CONFIG_80211D
+int rtw_80211d = 0;
+#endif
+
+#ifdef CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV
+int rtw_force_ant = 2;//0 :normal, 1:Main ant, 2:Aux ant
+int rtw_force_igi =0;//0 :normal
+module_param(rtw_force_ant, int, 0644);
+module_param(rtw_force_igi, int, 0644);
+#endif
+
+#ifdef CONFIG_QOS_OPTIMIZATION
+int rtw_qos_opt_enable=1;//0: disable,1:enable
+#else
+int rtw_qos_opt_enable=0;//0: disable,1:enable
+#endif
+module_param(rtw_qos_opt_enable,int,0644);
+
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+int rtw_acs_mode = 1; /*0:disable, 1:enable*/
+module_param(rtw_acs_mode, int, 0644);
+
+int rtw_acs_auto_scan = 0; /*0:disable, 1:enable*/
+module_param(rtw_acs_auto_scan, int, 0644);
+
+#endif
+
+char* ifname = "wlan%d";
+module_param(ifname, charp, 0644);
+MODULE_PARM_DESC(ifname, "The default name to allocate for first interface");
+
+#ifdef CONFIG_PLATFORM_ANDROID
+char* if2name = "p2p%d";
+#else //CONFIG_PLATFORM_ANDROID
+char* if2name = "wlan%d";
+#endif //CONFIG_PLATFORM_ANDROID
+module_param(if2name, charp, 0644);
+MODULE_PARM_DESC(if2name, "The default name to allocate for second interface");
+
+char* rtw_initmac = 0;  // temp mac address if users want to use instead of the mac address in Efuse
+
+#ifdef CONFIG_MULTI_VIR_IFACES
+int rtw_ext_iface_num  = 1;//primary/secondary iface is excluded
+module_param(rtw_ext_iface_num, int, 0644);
+#endif //CONFIG_MULTI_VIR_IFACES
+
+module_param(rtw_rfkfree_enable, int, 0644);
+module_param(rtw_initmac, charp, 0644);
+module_param(rtw_channel_plan, int, 0644);
+module_param(rtw_special_rf_path, int, 0644);
+module_param(rtw_chip_version, int, 0644);
+module_param(rtw_rfintfs, int, 0644);
+module_param(rtw_lbkmode, int, 0644);
+module_param(rtw_network_mode, int, 0644);
+module_param(rtw_channel, int, 0644);
+module_param(rtw_mp_mode, int, 0644);
+module_param(rtw_wmm_enable, int, 0644);
+module_param(rtw_vrtl_carrier_sense, int, 0644);
+module_param(rtw_vcs_type, int, 0644);
+module_param(rtw_busy_thresh, int, 0644);
+
+#ifdef CONFIG_80211N_HT
+module_param(rtw_ht_enable, int, 0644);
+module_param(rtw_bw_mode, int, 0644);
+module_param(rtw_ampdu_enable, int, 0644);
+module_param(rtw_rx_stbc, int, 0644);
+module_param(rtw_ampdu_amsdu, int, 0644);
+#endif //CONFIG_80211N_HT
+#ifdef CONFIG_80211AC_VHT
+module_param(rtw_vht_enable, int, 0644);
+#endif //CONFIG_80211AC_VHT
+#ifdef CONFIG_BEAMFORMING
+module_param(rtw_beamform_cap, int, 0644);
+#endif
+module_param(rtw_lowrate_two_xmit, int, 0644);
+
+module_param(rtw_rf_config, int, 0644);
+module_param(rtw_power_mgnt, int, 0644);
+module_param(rtw_smart_ps, int, 0644);
+module_param(rtw_low_power, int, 0644);
+module_param(rtw_wifi_spec, int, 0644);
+
+module_param(rtw_antdiv_cfg, int, 0644);
+module_param(rtw_antdiv_type, int, 0644);
+
+module_param(rtw_switch_usb3, int, 0644);
+
+module_param(rtw_enusbss, int, 0644);
+module_param(rtw_hwpdn_mode, int, 0644);
+module_param(rtw_hwpwrp_detect, int, 0644);
+
+module_param(rtw_hw_wps_pbc, int, 0644);
+
+#ifdef CONFIG_TX_EARLY_MODE
+module_param(rtw_early_mode, int, 0644);
+#endif
+#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+char *rtw_adaptor_info_caching_file_path= "/data/misc/wifi/rtw_cache";
+module_param(rtw_adaptor_info_caching_file_path, charp, 0644);
+MODULE_PARM_DESC(rtw_adaptor_info_caching_file_path, "The path of adapter info cache file");
+#endif //CONFIG_ADAPTOR_INFO_CACHING_FILE
+
+#ifdef CONFIG_LAYER2_ROAMING
+uint rtw_max_roaming_times=2;
+module_param(rtw_max_roaming_times, uint, 0644);
+MODULE_PARM_DESC(rtw_max_roaming_times,"The max roaming times to try");
+#endif //CONFIG_LAYER2_ROAMING
+
+#ifdef CONFIG_IOL
+int rtw_fw_iol=1;
+module_param(rtw_fw_iol, int, 0644);
+MODULE_PARM_DESC(rtw_fw_iol, "FW IOL. 0:Disable, 1:enable, 2:by usb speed");
+#endif //CONFIG_IOL
+
+#ifdef CONFIG_FILE_FWIMG
+char *rtw_fw_file_path = "/system/etc/firmware/rtlwifi/FW_NIC.BIN";
+module_param(rtw_fw_file_path, charp, 0644);
+MODULE_PARM_DESC(rtw_fw_file_path, "The path of fw image");
+
+char *rtw_fw_wow_file_path = "/system/etc/firmware/rtlwifi/FW_WoWLAN.BIN";
+module_param(rtw_fw_wow_file_path, charp, 0644);
+MODULE_PARM_DESC(rtw_fw_wow_file_path, "The path of fw for Wake on Wireless image");
+
+#ifdef CONFIG_MP_INCLUDED
+char *rtw_fw_mp_bt_file_path = "";
+module_param(rtw_fw_mp_bt_file_path, charp, 0644);
+MODULE_PARM_DESC(rtw_fw_mp_bt_file_path, "The path of fw for MP-BT image");
+#endif // CONFIG_MP_INCLUDED
+#endif // CONFIG_FILE_FWIMG
+
+#ifdef CONFIG_TX_MCAST2UNI
+module_param(rtw_mc2u_disable, int, 0644);
+#endif	// CONFIG_TX_MCAST2UNI
+
+#ifdef CONFIG_80211D
+module_param(rtw_80211d, int, 0644);
+MODULE_PARM_DESC(rtw_80211d, "Enable 802.11d mechanism");
+#endif
+
+uint rtw_notch_filter = RTW_NOTCH_FILTER;
+module_param(rtw_notch_filter, uint, 0644);
+MODULE_PARM_DESC(rtw_notch_filter, "0:Disable, 1:Enable, 2:Enable only for P2P");
+
+uint rtw_hiq_filter = CONFIG_RTW_HIQ_FILTER;
+module_param(rtw_hiq_filter, uint, 0644);
+MODULE_PARM_DESC(rtw_hiq_filter, "0:allow all, 1:allow special, 2:deny all");
+
+uint rtw_adaptivity_en = CONFIG_RTW_ADAPTIVITY_EN;
+module_param(rtw_adaptivity_en, uint, 0644);
+MODULE_PARM_DESC(rtw_adaptivity_en, "0:disable, 1:enable");
+
+uint rtw_adaptivity_mode = CONFIG_RTW_ADAPTIVITY_MODE;
+module_param(rtw_adaptivity_mode, uint, 0644);
+MODULE_PARM_DESC(rtw_adaptivity_mode, "0:normal, 1:carrier sense");
+
+uint rtw_adaptivity_dml = CONFIG_RTW_ADAPTIVITY_DML;
+module_param(rtw_adaptivity_dml, uint, 0644);
+MODULE_PARM_DESC(rtw_adaptivity_dml, "0:disable, 1:enable");
+
+uint rtw_adaptivity_dc_backoff = CONFIG_RTW_ADAPTIVITY_DC_BACKOFF;
+module_param(rtw_adaptivity_dc_backoff, uint, 0644);
+MODULE_PARM_DESC(rtw_adaptivity_dc_backoff, "DC backoff for Adaptivity");
+
+int rtw_adaptivity_th_l2h_ini = CONFIG_RTW_ADAPTIVITY_TH_L2H_INI;
+module_param(rtw_adaptivity_th_l2h_ini, int, 0644);
+MODULE_PARM_DESC(rtw_adaptivity_th_l2h_ini, "TH_L2H_ini for Adaptivity");
+
+int rtw_adaptivity_th_edcca_hl_diff = CONFIG_RTW_ADAPTIVITY_TH_EDCCA_HL_DIFF;
+module_param(rtw_adaptivity_th_edcca_hl_diff, int, 0644);
+MODULE_PARM_DESC(rtw_adaptivity_th_edcca_hl_diff, "TH_EDCCA_HL_diff for Adaptivity");
+
+uint rtw_amplifier_type_2g = CONFIG_RTW_AMPLIFIER_TYPE_2G;
+module_param(rtw_amplifier_type_2g, uint, 0644);
+MODULE_PARM_DESC(rtw_amplifier_type_2g, "BIT3:2G ext-PA, BIT4:2G ext-LNA");
+
+uint rtw_amplifier_type_5g = CONFIG_RTW_AMPLIFIER_TYPE_5G;
+module_param(rtw_amplifier_type_5g, uint, 0644);
+MODULE_PARM_DESC(rtw_amplifier_type_5g, "BIT6:5G ext-PA, BIT7:5G ext-LNA");
+
+uint rtw_RFE_type = CONFIG_RTW_RFE_TYPE;
+module_param(rtw_RFE_type, uint, 0644);
+MODULE_PARM_DESC(rtw_RFE_type, "default init value:64");
+
+uint rtw_GLNA_type = CONFIG_RTW_GLNA_TYPE;
+module_param(rtw_GLNA_type, uint, 0644);
+MODULE_PARM_DESC(rtw_GLNA_type, "default init value:0");
+
+uint rtw_TxBBSwing_2G = 0xFF;
+module_param(rtw_TxBBSwing_2G, uint, 0644);
+MODULE_PARM_DESC(rtw_TxBBSwing_2G, "default init value:0xFF");
+
+uint rtw_TxBBSwing_5G = 0xFF;
+module_param(rtw_TxBBSwing_5G, uint, 0644);
+MODULE_PARM_DESC(rtw_TxBBSwing_5G, "default init value:0xFF");
+
+uint rtw_OffEfuseMask = 0;
+module_param(rtw_OffEfuseMask, uint, 0644);
+MODULE_PARM_DESC(rtw_OffEfuseMask, "default open Efuse Mask value:0");
+
+uint rtw_FileMaskEfuse = 0;
+module_param(rtw_FileMaskEfuse, uint, 0644);
+MODULE_PARM_DESC(rtw_FileMaskEfuse, "default drv Mask Efuse value:0");
+
+uint rtw_kfree = 0;
+module_param(rtw_kfree, uint, 0644);
+MODULE_PARM_DESC(rtw_kfree, "default kfree config value:0");
+
+uint rtw_pll_ref_clk_sel = CONFIG_RTW_PLL_REF_CLK_SEL;
+module_param(rtw_pll_ref_clk_sel, uint, 0644);
+MODULE_PARM_DESC(rtw_pll_ref_clk_sel, "force pll_ref_clk_sel, 0xF:use autoload value");
+
+#if defined(CONFIG_CALIBRATE_TX_POWER_BY_REGULATORY) //eFuse: Regulatory selection=1
+int rtw_tx_pwr_lmt_enable = 1;
+int rtw_tx_pwr_by_rate = 1;
+#elif defined(CONFIG_CALIBRATE_TX_POWER_TO_MAX)//eFuse: Regulatory selection=0
+int rtw_tx_pwr_lmt_enable = 0;
+int rtw_tx_pwr_by_rate = 1;
+#else //eFuse: Regulatory selection=2
+#ifdef CONFIG_PCI_HCI
+int rtw_tx_pwr_lmt_enable = 2; // 2- Depend on efuse
+int rtw_tx_pwr_by_rate = 2;// 2- Depend on efuse
+#else // USB & SDIO
+int rtw_tx_pwr_lmt_enable = 0;
+int rtw_tx_pwr_by_rate = 0;
+#endif 
+#endif
+
+module_param(rtw_tx_pwr_lmt_enable, int, 0644);
+MODULE_PARM_DESC(rtw_tx_pwr_lmt_enable,"0:Disable, 1:Enable, 2: Depend on efuse");
+
+module_param(rtw_tx_pwr_by_rate, int, 0644);
+MODULE_PARM_DESC(rtw_tx_pwr_by_rate,"0:Disable, 1:Enable, 2: Depend on efuse");
+
+static int rtw_target_tx_pwr_2g_a[RATE_SECTION_NUM] = CONFIG_RTW_TARGET_TX_PWR_2G_A;
+static int rtw_target_tx_pwr_2g_a_num = 0;
+module_param_array(rtw_target_tx_pwr_2g_a, int, &rtw_target_tx_pwr_2g_a_num, 0644);
+MODULE_PARM_DESC(rtw_target_tx_pwr_2g_a, "2.4G target tx power (unit:dBm) of RF path A for each rate section, should match the real calibrate power, -1: undefined");
+
+static int rtw_target_tx_pwr_2g_b[RATE_SECTION_NUM] = CONFIG_RTW_TARGET_TX_PWR_2G_B;
+static int rtw_target_tx_pwr_2g_b_num = 0;
+module_param_array(rtw_target_tx_pwr_2g_b, int, &rtw_target_tx_pwr_2g_b_num, 0644);
+MODULE_PARM_DESC(rtw_target_tx_pwr_2g_b, "2.4G target tx power (unit:dBm) of RF path B for each rate section, should match the real calibrate power, -1: undefined");
+
+static int rtw_target_tx_pwr_2g_c[RATE_SECTION_NUM] = CONFIG_RTW_TARGET_TX_PWR_2G_C;
+static int rtw_target_tx_pwr_2g_c_num = 0;
+module_param_array(rtw_target_tx_pwr_2g_c, int, &rtw_target_tx_pwr_2g_c_num, 0644);
+MODULE_PARM_DESC(rtw_target_tx_pwr_2g_c, "2.4G target tx power (unit:dBm) of RF path C for each rate section, should match the real calibrate power, -1: undefined");
+
+static int rtw_target_tx_pwr_2g_d[RATE_SECTION_NUM] = CONFIG_RTW_TARGET_TX_PWR_2G_D;
+static int rtw_target_tx_pwr_2g_d_num = 0;
+module_param_array(rtw_target_tx_pwr_2g_d, int, &rtw_target_tx_pwr_2g_d_num, 0644);
+MODULE_PARM_DESC(rtw_target_tx_pwr_2g_d, "2.4G target tx power (unit:dBm) of RF path D for each rate section, should match the real calibrate power, -1: undefined");
+
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+static int rtw_target_tx_pwr_5g_a[RATE_SECTION_NUM - 1] = CONFIG_RTW_TARGET_TX_PWR_5G_A;
+static int rtw_target_tx_pwr_5g_a_num = 0;
+module_param_array(rtw_target_tx_pwr_5g_a, int, &rtw_target_tx_pwr_5g_a_num, 0644);
+MODULE_PARM_DESC(rtw_target_tx_pwr_5g_a, "5G target tx power (unit:dBm) of RF path A for each rate section, should match the real calibrate power, -1: undefined");
+
+static int rtw_target_tx_pwr_5g_b[RATE_SECTION_NUM - 1] = CONFIG_RTW_TARGET_TX_PWR_5G_B;
+static int rtw_target_tx_pwr_5g_b_num = 0;
+module_param_array(rtw_target_tx_pwr_5g_b, int, &rtw_target_tx_pwr_5g_b_num, 0644);
+MODULE_PARM_DESC(rtw_target_tx_pwr_5g_b, "5G target tx power (unit:dBm) of RF path B for each rate section, should match the real calibrate power, -1: undefined");
+
+static int rtw_target_tx_pwr_5g_c[RATE_SECTION_NUM - 1] = CONFIG_RTW_TARGET_TX_PWR_5G_C;
+static int rtw_target_tx_pwr_5g_c_num = 0;
+module_param_array(rtw_target_tx_pwr_5g_c, int, &rtw_target_tx_pwr_5g_c_num, 0644);
+MODULE_PARM_DESC(rtw_target_tx_pwr_5g_c, "5G target tx power (unit:dBm) of RF path C for each rate section, should match the real calibrate power, -1: undefined");
+
+static int rtw_target_tx_pwr_5g_d[RATE_SECTION_NUM - 1] = CONFIG_RTW_TARGET_TX_PWR_5G_D;
+static int rtw_target_tx_pwr_5g_d_num = 0;
+module_param_array(rtw_target_tx_pwr_5g_d, int, &rtw_target_tx_pwr_5g_d_num, 0644);
+MODULE_PARM_DESC(rtw_target_tx_pwr_5g_d, "5G target tx power (unit:dBm) of RF path D for each rate section, should match the real calibrate power, -1: undefined");
+#endif /* CONFIG_IEEE80211_BAND_5GHZ */
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+char *rtw_phy_file_path = REALTEK_CONFIG_PATH;
+module_param(rtw_phy_file_path, charp, 0644);
+MODULE_PARM_DESC(rtw_phy_file_path, "The path of phy parameter");
+// PHY FILE Bit Map
+// BIT0 - MAC,				0: non-support, 1: support
+// BIT1 - BB,					0: non-support, 1: support
+// BIT2 - BB_PG,				0: non-support, 1: support
+// BIT3 - BB_MP,				0: non-support, 1: support
+// BIT4 - RF,					0: non-support, 1: support
+// BIT5 - RF_TXPWR_TRACK,	0: non-support, 1: support
+// BIT6 - RF_TXPWR_LMT,		0: non-support, 1: support
+int rtw_load_phy_file = (BIT2|BIT6);
+module_param(rtw_load_phy_file, int, 0644);
+MODULE_PARM_DESC(rtw_load_phy_file,"PHY File Bit Map");
+int rtw_decrypt_phy_file = 0;
+module_param(rtw_decrypt_phy_file, int, 0644);
+MODULE_PARM_DESC(rtw_decrypt_phy_file,"Enable Decrypt PHY File");
+#endif
+
+int _netdev_open(struct net_device *pnetdev);
+int netdev_open (struct net_device *pnetdev);
+static int netdev_close (struct net_device *pnetdev);
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+extern int rtw_sdio_set_power(int on);
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
+void rtw_regsty_load_target_tx_power(struct registry_priv *regsty)
+{
+	int path, rs;
+	int *target_tx_pwr;
+
+	for (path = RF_PATH_A; path < RF_PATH_MAX; path++) {
+		if (path == RF_PATH_A)
+			target_tx_pwr = rtw_target_tx_pwr_2g_a;
+		else if (path == RF_PATH_B)
+			target_tx_pwr = rtw_target_tx_pwr_2g_b;
+		else if (path == RF_PATH_C)
+			target_tx_pwr = rtw_target_tx_pwr_2g_c;
+		else if (path == RF_PATH_D)
+			target_tx_pwr = rtw_target_tx_pwr_2g_d;
+
+		for (rs = CCK; rs < RATE_SECTION_NUM; rs++)
+			regsty->target_tx_pwr_2g[path][rs] = target_tx_pwr[rs];
+	}
+
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+	for (path = RF_PATH_A; path < RF_PATH_MAX; path++) {
+		if (path == RF_PATH_A)
+			target_tx_pwr = rtw_target_tx_pwr_5g_a;
+		else if (path == RF_PATH_B)
+			target_tx_pwr = rtw_target_tx_pwr_5g_b;
+		else if (path == RF_PATH_C)
+			target_tx_pwr = rtw_target_tx_pwr_5g_c;
+		else if (path == RF_PATH_D)
+			target_tx_pwr = rtw_target_tx_pwr_5g_d;
+
+		for (rs = OFDM; rs < RATE_SECTION_NUM; rs++)
+			regsty->target_tx_pwr_5g[path][rs - 1] = target_tx_pwr[rs - 1];
+	}
+#endif /* CONFIG_IEEE80211_BAND_5GHZ */
+}
+
+uint loadparam(_adapter *padapter)
+{
+	uint status = _SUCCESS;
+	struct registry_priv  *registry_par = &padapter->registrypriv;
+
+_func_enter_;
+
+	registry_par->chip_version = (u8)rtw_chip_version;
+	registry_par->rfintfs = (u8)rtw_rfintfs;
+	registry_par->lbkmode = (u8)rtw_lbkmode;
+	//registry_par->hci = (u8)hci;
+	registry_par->network_mode  = (u8)rtw_network_mode;
+
+	_rtw_memcpy(registry_par->ssid.Ssid, "ANY", 3);
+	registry_par->ssid.SsidLength = 3;
+
+	registry_par->channel = (u8)rtw_channel;
+	registry_par->wireless_mode = (u8)rtw_wireless_mode;
+
+	if (IsSupported24G(registry_par->wireless_mode) && (!IsSupported5G(registry_par->wireless_mode))
+		&& (registry_par->channel > 14)) {
+		registry_par->channel = 1;
+	}
+	else if (IsSupported5G(registry_par->wireless_mode) && (!IsSupported24G(registry_par->wireless_mode))
+		&& (registry_par->channel <= 14)) {
+		registry_par->channel = 36;
+	}
+	
+	registry_par->vrtl_carrier_sense = (u8)rtw_vrtl_carrier_sense ;
+	registry_par->vcs_type = (u8)rtw_vcs_type;
+	registry_par->rts_thresh=(u16)rtw_rts_thresh;
+	registry_par->frag_thresh=(u16)rtw_frag_thresh;
+	registry_par->preamble = (u8)rtw_preamble;
+	registry_par->scan_mode = (u8)rtw_scan_mode;
+	registry_par->adhoc_tx_pwr = (u8)rtw_adhoc_tx_pwr;
+	registry_par->soft_ap=  (u8)rtw_soft_ap;
+	registry_par->smart_ps =  (u8)rtw_smart_ps;
+	registry_par->check_fw_ps = (u8)rtw_check_fw_ps;
+	registry_par->power_mgnt = (u8)rtw_power_mgnt;
+	registry_par->ips_mode = (u8)rtw_ips_mode;
+	registry_par->radio_enable = (u8)rtw_radio_enable;
+	registry_par->long_retry_lmt = (u8)rtw_long_retry_lmt;
+	registry_par->short_retry_lmt = (u8)rtw_short_retry_lmt;
+  	registry_par->busy_thresh = (u16)rtw_busy_thresh;
+  	//registry_par->qos_enable = (u8)rtw_qos_enable;
+	registry_par->ack_policy = (u8)rtw_ack_policy;
+	registry_par->mp_mode = (u8)rtw_mp_mode;
+	registry_par->software_encrypt = (u8)rtw_software_encrypt;
+	registry_par->software_decrypt = (u8)rtw_software_decrypt;
+
+	registry_par->acm_method = (u8)rtw_acm_method;
+	registry_par->usb_rxagg_mode = (u8)rtw_usb_rxagg_mode;
+
+	 //UAPSD
+	registry_par->wmm_enable = (u8)rtw_wmm_enable;
+	registry_par->uapsd_enable = (u8)rtw_uapsd_enable;
+	registry_par->uapsd_max_sp = (u8)rtw_uapsd_max_sp;
+	registry_par->uapsd_acbk_en = (u8)rtw_uapsd_acbk_en;
+	registry_par->uapsd_acbe_en = (u8)rtw_uapsd_acbe_en;
+	registry_par->uapsd_acvi_en = (u8)rtw_uapsd_acvi_en;
+	registry_par->uapsd_acvo_en = (u8)rtw_uapsd_acvo_en;
+
+	registry_par->RegRfKFreeEnable = (u8)rtw_rfkfree_enable;
+	
+#ifdef CONFIG_80211N_HT
+	registry_par->ht_enable = (u8)rtw_ht_enable;
+	registry_par->bw_mode = (u8)rtw_bw_mode;
+	registry_par->ampdu_enable = (u8)rtw_ampdu_enable;
+	registry_par->rx_stbc = (u8)rtw_rx_stbc;
+	registry_par->ampdu_amsdu = (u8)rtw_ampdu_amsdu;
+	registry_par->short_gi = (u8)rtw_short_gi;
+	registry_par->ldpc_cap = (u8)rtw_ldpc_cap;
+	registry_par->stbc_cap = (u8)rtw_stbc_cap;
+	registry_par->beamform_cap = (u8)rtw_beamform_cap;
+	registry_par->beamformer_rf_num = (u8)rtw_bfer_rf_number;
+	registry_par->beamformee_rf_num = (u8)rtw_bfee_rf_number;
+#endif
+
+#ifdef CONFIG_80211AC_VHT
+	registry_par->vht_enable = (u8)rtw_vht_enable;
+	registry_par->ampdu_factor = (u8)rtw_ampdu_factor;
+	registry_par->vht_rate_sel = (u8)rtw_vht_rate_sel;
+#endif
+
+#ifdef CONFIG_TX_EARLY_MODE
+	registry_par->early_mode = (u8)rtw_early_mode;
+#endif
+	registry_par->lowrate_two_xmit = (u8)rtw_lowrate_two_xmit;
+	registry_par->rf_config = (u8)rtw_rf_config;
+	registry_par->low_power = (u8)rtw_low_power;
+
+
+	registry_par->wifi_spec = (u8)rtw_wifi_spec;
+
+	registry_par->channel_plan = (u8)rtw_channel_plan;
+	registry_par->special_rf_path = (u8)rtw_special_rf_path;
+
+#ifdef CONFIG_BT_COEXIST
+	registry_par->btcoex = (u8)rtw_btcoex_enable;
+	registry_par->bt_iso = (u8)rtw_bt_iso;
+	registry_par->bt_sco = (u8)rtw_bt_sco;
+	registry_par->bt_ampdu = (u8)rtw_bt_ampdu;
+	registry_par->ant_num = (s8)rtw_ant_num;
+#endif
+
+	registry_par->bAcceptAddbaReq = (u8)rtw_AcceptAddbaReq;
+
+	registry_par->antdiv_cfg = (u8)rtw_antdiv_cfg;
+	registry_par->antdiv_type = (u8)rtw_antdiv_type;
+	
+	registry_par->switch_usb3 = (u8)rtw_switch_usb3;
+
+#ifdef CONFIG_AUTOSUSPEND
+	registry_par->usbss_enable = (u8)rtw_enusbss;//0:disable,1:enable
+#endif
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+	registry_par->hwpdn_mode = (u8)rtw_hwpdn_mode;//0:disable,1:enable,2:by EFUSE config
+	registry_par->hwpwrp_detect = (u8)rtw_hwpwrp_detect;//0:disable,1:enable
+#endif
+
+	registry_par->hw_wps_pbc = (u8)rtw_hw_wps_pbc;
+
+#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+	snprintf(registry_par->adaptor_info_caching_file_path, PATH_LENGTH_MAX, "%s", rtw_adaptor_info_caching_file_path);
+	registry_par->adaptor_info_caching_file_path[PATH_LENGTH_MAX-1]=0;
+#endif
+
+#ifdef CONFIG_LAYER2_ROAMING
+	registry_par->max_roaming_times = (u8)rtw_max_roaming_times;
+#ifdef CONFIG_INTEL_WIDI
+	registry_par->max_roaming_times = (u8)rtw_max_roaming_times + 2;
+#endif // CONFIG_INTEL_WIDI
+#endif
+
+#ifdef CONFIG_IOL
+	registry_par->fw_iol = rtw_fw_iol;
+#endif
+
+#ifdef CONFIG_80211D
+	registry_par->enable80211d = (u8)rtw_80211d;
+#endif
+
+	snprintf(registry_par->ifname, 16, "%s", ifname);
+	snprintf(registry_par->if2name, 16, "%s", if2name);
+
+	registry_par->notch_filter = (u8)rtw_notch_filter;
+
+#ifdef CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV
+	registry_par->force_ant = (u8)rtw_force_ant;
+	registry_par->force_igi = (u8)rtw_force_igi;
+#endif
+
+#ifdef CONFIG_MULTI_VIR_IFACES
+	registry_par->ext_iface_num = (u8)rtw_ext_iface_num;
+#endif //CONFIG_MULTI_VIR_IFACES
+
+	registry_par->pll_ref_clk_sel = (u8)rtw_pll_ref_clk_sel;
+
+	registry_par->RegEnableTxPowerLimit = (u8)rtw_tx_pwr_lmt_enable;
+	registry_par->RegEnableTxPowerByRate = (u8)rtw_tx_pwr_by_rate;
+
+	rtw_regsty_load_target_tx_power(registry_par);
+
+	registry_par->RegPowerBase = 14;
+	registry_par->TxBBSwing_2G = (s8)rtw_TxBBSwing_2G;
+	registry_par->TxBBSwing_5G = (s8)rtw_TxBBSwing_5G;
+	registry_par->bEn_RFE = 1;
+	registry_par->RFE_Type = (u8)rtw_RFE_type;
+	registry_par->AmplifierType_2G = (u8)rtw_amplifier_type_2g;
+	registry_par->AmplifierType_5G = (u8)rtw_amplifier_type_5g;
+	registry_par->GLNA_Type = (u8)rtw_GLNA_type;
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+	registry_par->load_phy_file = (u8)rtw_load_phy_file;
+	registry_par->RegDecryptCustomFile = (u8)rtw_decrypt_phy_file;
+#endif
+	registry_par->qos_opt_enable = (u8)rtw_qos_opt_enable;
+
+	registry_par->hiq_filter = (u8)rtw_hiq_filter;
+
+	registry_par->adaptivity_en = (u8)rtw_adaptivity_en;
+	registry_par->adaptivity_mode = (u8)rtw_adaptivity_mode;
+	registry_par->adaptivity_dml = (u8)rtw_adaptivity_dml;
+	registry_par->adaptivity_dc_backoff = (u8)rtw_adaptivity_dc_backoff;
+	registry_par->adaptivity_th_l2h_ini = (s8)rtw_adaptivity_th_l2h_ini;
+	registry_par->adaptivity_th_edcca_hl_diff = (s8)rtw_adaptivity_th_edcca_hl_diff;
+
+	registry_par->boffefusemask = (u8)rtw_OffEfuseMask;
+	registry_par->bFileMaskEfuse = (u8)rtw_FileMaskEfuse;
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+	registry_par->acs_mode = (u8)rtw_acs_mode;
+	registry_par->acs_auto_scan = (u8)rtw_acs_auto_scan;
+#endif
+_func_exit_;
+
+	return status;
+}
+
+/**
+ * rtw_net_set_mac_address
+ * This callback function is used for the Media Access Control address
+ * of each net_device needs to be changed.
+ *
+ * Arguments:
+ * @pnetdev: net_device pointer.
+ * @addr: new MAC address.
+ *
+ * Return:
+ * ret = 0: Permit to change net_device's MAC address.
+ * ret = -1 (Default): Operation not permitted.
+ *
+ * Auther: Arvin Liu
+ * Date: 2015/05/29
+ */
+static int rtw_net_set_mac_address(struct net_device *pnetdev, void *addr)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct sockaddr *sa = (struct sockaddr *)addr;
+	int ret = -1;
+
+	/* only the net_device is in down state to permit modifying mac addr */
+	if ((pnetdev->flags & IFF_UP) == _TRUE) {
+		DBG_871X(FUNC_ADPT_FMT": The net_device's is not in down state\n"
+			, FUNC_ADPT_ARG(padapter));
+
+		return ret;
+	}
+
+	/* if the net_device is linked, it's not permit to modify mac addr */
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) ||
+		check_fwstate(pmlmepriv, _FW_LINKED) ||
+		check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {
+		DBG_871X(FUNC_ADPT_FMT": The net_device's is not idle currently\n"
+			, FUNC_ADPT_ARG(padapter));
+
+		return ret;
+	}
+
+	/* check whether the input mac address is valid to permit modifying mac addr */
+	if (rtw_check_invalid_mac_address(sa->sa_data, _FALSE) == _TRUE) {
+		DBG_871X(FUNC_ADPT_FMT": Invalid Mac Addr for "MAC_FMT"\n"
+			, FUNC_ADPT_ARG(padapter), MAC_ARG(sa->sa_data));
+
+		return ret;
+	}
+
+	_rtw_memcpy(adapter_mac_addr(padapter), sa->sa_data, ETH_ALEN); /* set mac addr to adapter */
+	_rtw_memcpy(pnetdev->dev_addr, sa->sa_data, ETH_ALEN); /* set mac addr to net_device */
+
+	rtw_ps_deny(padapter, PS_DENY_IOCTL);
+	LeaveAllPowerSaveModeDirect(padapter); /* leave PS mode for guaranteeing to access hw register successfully */
+	rtw_hal_set_hwreg(padapter, HW_VAR_MAC_ADDR, sa->sa_data); /* set mac addr to mac register */
+	rtw_ps_deny_cancel(padapter, PS_DENY_IOCTL);
+
+	DBG_871X(FUNC_ADPT_FMT": Set Mac Addr to "MAC_FMT" Successfully\n"
+		, FUNC_ADPT_ARG(padapter), MAC_ARG(sa->sa_data));
+
+	ret = 0;
+
+	return ret;
+}
+
+static struct net_device_stats *rtw_net_get_stats(struct net_device *pnetdev)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+
+	padapter->stats.tx_packets = pxmitpriv->tx_pkts;//pxmitpriv->tx_pkts++;
+	padapter->stats.rx_packets = precvpriv->rx_pkts;//precvpriv->rx_pkts++;
+	padapter->stats.tx_dropped = pxmitpriv->tx_drop;
+	padapter->stats.rx_dropped = precvpriv->rx_drop;
+	padapter->stats.tx_bytes = pxmitpriv->tx_bytes;
+	padapter->stats.rx_bytes = precvpriv->rx_bytes;
+
+	return &padapter->stats;
+}
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+/*
+ * AC to queue mapping
+ *
+ * AC_VO -> queue 0
+ * AC_VI -> queue 1
+ * AC_BE -> queue 2
+ * AC_BK -> queue 3
+ */
+static const u16 rtw_1d_to_queue[8] = { 2, 3, 3, 2, 1, 1, 0, 0 };
+
+/* Given a data frame determine the 802.1p/1d tag to use. */
+unsigned int rtw_classify8021d(struct sk_buff *skb)
+{
+	unsigned int dscp;
+
+	/* skb->priority values from 256->263 are magic values to
+	 * directly indicate a specific 802.1d priority.  This is used
+	 * to allow 802.1d priority to be passed directly in from VLAN
+	 * tags, etc.
+	 */
+	if (skb->priority >= 256 && skb->priority <= 263)
+		return skb->priority - 256;
+
+	switch (skb->protocol) {
+	case htons(ETH_P_IP):
+		dscp = ip_hdr(skb)->tos & 0xfc;
+		break;
+	default:
+		return 0;
+	}
+
+	return dscp >> 5;
+}
+
+ 
+static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0))
+			    ,struct net_device *sb_dev
+//                            ,select_queue_fallback_t fallback
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+				, void *accel_priv
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+				, select_queue_fallback_t fallback
+#endif
+)
+{
+	_adapter	*padapter = rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	skb->priority = rtw_classify8021d(skb);
+
+	if(pmlmepriv->acm_mask != 0)
+	{
+		skb->priority = qos_acm(pmlmepriv->acm_mask, skb->priority);
+	}
+
+	return rtw_1d_to_queue[skb->priority];
+}
+
+u16 rtw_recv_select_queue(struct sk_buff *skb)
+{
+	struct iphdr *piphdr;
+	unsigned int dscp;
+	u16	eth_type;
+	u32 priority;
+	u8 *pdata = skb->data;
+
+	_rtw_memcpy(&eth_type, pdata+(ETH_ALEN<<1), 2);
+
+	switch (eth_type) {
+		case htons(ETH_P_IP):
+
+			piphdr = (struct iphdr *)(pdata+ETH_HLEN);
+
+			dscp = piphdr->tos & 0xfc;
+
+			priority = dscp >> 5;
+
+			break;
+		default:
+			priority = 0;
+	}
+
+	return rtw_1d_to_queue[priority];
+
+}
+
+#endif
+static int rtw_ndev_notifier_call(struct notifier_block * nb, unsigned long state, void *ptr)
+{	
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(3,11,0))
+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+#else
+	struct net_device *dev = ptr;
+#endif
+
+	if (dev == NULL)
+		return NOTIFY_DONE;
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+	if (dev->netdev_ops == NULL)
+		return NOTIFY_DONE;
+
+	if (dev->netdev_ops->ndo_do_ioctl == NULL)
+		return NOTIFY_DONE;
+
+	if (dev->netdev_ops->ndo_do_ioctl != rtw_ioctl)
+#else
+	if (dev->do_ioctl == NULL)
+		return NOTIFY_DONE;
+
+	if (dev->do_ioctl != rtw_ioctl)
+#endif
+		return NOTIFY_DONE;
+
+	DBG_871X_LEVEL(_drv_info_, FUNC_NDEV_FMT" state:%lu\n", FUNC_NDEV_ARG(dev), state);
+
+	switch (state) {
+	case NETDEV_CHANGENAME:
+		rtw_adapter_proc_replace(dev);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block rtw_ndev_notifier = {
+	.notifier_call = rtw_ndev_notifier_call,
+};
+
+int rtw_ndev_notifier_register(void)
+{
+	return register_netdevice_notifier(&rtw_ndev_notifier);
+}
+
+void rtw_ndev_notifier_unregister(void)
+{
+	unregister_netdevice_notifier(&rtw_ndev_notifier);
+}
+
+
+int rtw_ndev_init(struct net_device *dev)
+{
+	_adapter *adapter = rtw_netdev_priv(dev);
+
+	DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" if%d mac_addr="MAC_FMT"\n"
+		, FUNC_ADPT_ARG(adapter), (adapter->iface_id+1), MAC_ARG(dev->dev_addr));
+	strncpy(adapter->old_ifname, dev->name, IFNAMSIZ);
+	adapter->old_ifname[IFNAMSIZ-1] = '\0';
+	rtw_adapter_proc_init(dev);
+
+	return 0;
+}
+
+void rtw_ndev_uninit(struct net_device *dev)
+{
+	_adapter *adapter = rtw_netdev_priv(dev);
+
+	DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" if%d\n"
+		, FUNC_ADPT_ARG(adapter), (adapter->iface_id+1));
+	rtw_adapter_proc_deinit(dev);
+}
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+static const struct net_device_ops rtw_netdev_ops = {
+	.ndo_init = rtw_ndev_init,
+	.ndo_uninit = rtw_ndev_uninit,
+	.ndo_open = netdev_open,
+	.ndo_stop = netdev_close,
+	.ndo_start_xmit = rtw_xmit_entry,
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	.ndo_select_queue	= rtw_select_queue,
+#endif
+	.ndo_set_mac_address = rtw_net_set_mac_address,
+	.ndo_get_stats = rtw_net_get_stats,
+	.ndo_do_ioctl = rtw_ioctl,
+};
+#endif
+
+int rtw_init_netdev_name(struct net_device *pnetdev, const char *ifname)
+{
+	_adapter *padapter = rtw_netdev_priv(pnetdev);
+
+#ifdef CONFIG_EASY_REPLACEMENT
+	struct net_device	*TargetNetdev = NULL;
+	_adapter			*TargetAdapter = NULL;
+	struct net 		*devnet = NULL;
+
+	if(padapter->bDongle == 1)
+	{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+		TargetNetdev = dev_get_by_name("wlan0");
+#else
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+		devnet = pnetdev->nd_net;
+	#else
+		devnet = dev_net(pnetdev);
+	#endif
+		TargetNetdev = dev_get_by_name(devnet, "wlan0");
+#endif
+		if(TargetNetdev) {
+			DBG_871X("Force onboard module driver disappear !!!\n");
+			TargetAdapter = rtw_netdev_priv(TargetNetdev);
+			TargetAdapter->DriverState = DRIVER_DISAPPEAR;
+
+			padapter->pid[0] = TargetAdapter->pid[0];
+			padapter->pid[1] = TargetAdapter->pid[1];
+			padapter->pid[2] = TargetAdapter->pid[2];
+
+			dev_put(TargetNetdev);
+			unregister_netdev(TargetNetdev);
+
+			padapter->DriverState = DRIVER_REPLACE_DONGLE;
+		}
+	}
+#endif //CONFIG_EASY_REPLACEMENT
+
+	if(dev_alloc_name(pnetdev, ifname) < 0)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("dev_alloc_name, fail! \n"));
+	}
+
+	netif_carrier_off(pnetdev);
+	//rtw_netif_stop_queue(pnetdev);
+
+	return 0;
+}
+
+void rtw_hook_if_ops(struct net_device *ndev)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29))
+	ndev->netdev_ops = &rtw_netdev_ops;
+#else
+	ndev->init = rtw_ndev_init;
+	ndev->uninit = rtw_ndev_uninit;
+	ndev->open = netdev_open;
+	ndev->stop = netdev_close;
+	ndev->hard_start_xmit = rtw_xmit_entry;
+	ndev->set_mac_address = rtw_net_set_mac_address;
+	ndev->get_stats = rtw_net_get_stats;
+	ndev->do_ioctl = rtw_ioctl;
+#endif
+}
+
+struct net_device *rtw_init_netdev(_adapter *old_padapter)
+{
+	_adapter *padapter;
+	struct net_device *pnetdev;
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+init_net_dev\n"));
+
+	if(old_padapter != NULL)
+		pnetdev = rtw_alloc_etherdev_with_old_priv(sizeof(_adapter), (void *)old_padapter);
+	else
+		pnetdev = rtw_alloc_etherdev(sizeof(_adapter));
+
+	if (!pnetdev)
+		return NULL;
+
+	padapter = rtw_netdev_priv(pnetdev);
+	padapter->pnetdev = pnetdev;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+	SET_MODULE_OWNER(pnetdev);
+#endif
+
+	rtw_hook_if_ops(pnetdev);
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	pnetdev->features |= NETIF_F_IP_CSUM;
+#endif
+
+	//pnetdev->tx_timeout = NULL;
+	pnetdev->watchdog_timeo = HZ*3; /* 3 second timeout */
+
+#ifdef CONFIG_WIRELESS_EXT
+	pnetdev->wireless_handlers = (struct iw_handler_def *)&rtw_handlers_def;
+#endif
+
+#ifdef WIRELESS_SPY
+	//priv->wireless_data.spy_data = &priv->spy_data;
+	//pnetdev->wireless_data = &priv->wireless_data;
+#endif
+
+	return pnetdev;
+}
+
+int rtw_os_ndev_alloc(_adapter *adapter)
+{
+	int ret = _FAIL;
+	struct net_device *ndev = NULL;
+
+	ndev = rtw_init_netdev(adapter);
+	if (ndev == NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+	#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0)
+	SET_NETDEV_DEV(ndev, dvobj_to_dev(adapter_to_dvobj(adapter)));
+	#endif
+
+	#ifdef CONFIG_PCI_HCI
+	if (adapter_to_dvobj(adapter)->bdma64)
+		ndev->features |= NETIF_F_HIGHDMA;
+	ndev->irq = adapter_to_dvobj(adapter)->irq;
+	#endif
+
+#if defined(CONFIG_IOCTL_CFG80211)
+	if (rtw_cfg80211_ndev_res_alloc(adapter) != _SUCCESS) {
+		rtw_warn_on(1);
+		goto free_ndev;
+	}
+#endif
+
+	ret = _SUCCESS;
+
+free_ndev:
+	if (ret != _SUCCESS && ndev)
+		rtw_free_netdev(ndev);
+exit:
+	return ret;
+}
+
+void rtw_os_ndev_free(_adapter *adapter)
+{
+#if defined(CONFIG_IOCTL_CFG80211)
+	rtw_cfg80211_ndev_res_free(adapter);
+#endif
+
+	if (adapter->pnetdev) {
+		rtw_free_netdev(adapter->pnetdev);
+		adapter->pnetdev = NULL;
+	}
+}
+
+int rtw_os_ndev_register(_adapter *adapter, char *name)
+{
+	int ret = _SUCCESS;
+	struct net_device *ndev = adapter->pnetdev;
+
+#if defined(CONFIG_IOCTL_CFG80211)
+	if (rtw_cfg80211_ndev_res_register(adapter) != _SUCCESS) {
+		rtw_warn_on(1);
+		ret = _FAIL;
+		goto exit;
+	}
+#endif
+
+	/* alloc netdev name */
+	rtw_init_netdev_name(ndev, name);
+
+	_rtw_memcpy(ndev->dev_addr, adapter_mac_addr(adapter), ETH_ALEN);
+
+	/* Tell the network stack we exist */
+	if (register_netdev(ndev) != 0) {
+		DBG_871X(FUNC_NDEV_FMT" if%d Failed!\n", FUNC_NDEV_ARG(ndev), (adapter->iface_id+1));
+		ret = _FAIL;
+	}
+
+#if defined(CONFIG_IOCTL_CFG80211)
+	if (ret != _SUCCESS) {
+		rtw_cfg80211_ndev_res_unregister(adapter);
+		#if !defined(RTW_SINGLE_WIPHY)
+		rtw_wiphy_unregister(adapter_to_wiphy(adapter));
+		#endif
+	}
+#endif
+
+exit:
+	return ret;
+}
+
+void rtw_os_ndev_unregister(_adapter *adapter)
+{
+	struct net_device *netdev = NULL;
+
+	if (adapter == NULL)
+		return;
+
+	adapter->ndev_unregistering = 1;
+
+	netdev = adapter->pnetdev;
+
+#if defined(CONFIG_IOCTL_CFG80211)
+	rtw_cfg80211_ndev_res_unregister(adapter);
+#endif
+
+	if ((adapter->DriverState != DRIVER_DISAPPEAR) && netdev)
+		unregister_netdev(netdev); /* will call netdev_close() */
+
+#if defined(CONFIG_IOCTL_CFG80211) && !defined(RTW_SINGLE_WIPHY)
+	rtw_wiphy_unregister(adapter_to_wiphy(adapter));
+#endif
+
+	adapter->ndev_unregistering = 0;
+}
+
+/**
+ * rtw_os_ndev_init - Allocate and register OS layer net device and relating structures for @adapter
+ * @adapter: the adapter on which this function applies
+ * @name: the requesting net device name
+ *
+ * Returns:
+ * _SUCCESS or _FAIL
+ */
+int rtw_os_ndev_init(_adapter *adapter, char *name)
+{
+	int ret = _FAIL;
+
+	if (rtw_os_ndev_alloc(adapter) != _SUCCESS)
+		goto exit;
+
+	if (rtw_os_ndev_register(adapter, name) != _SUCCESS)
+		goto os_ndev_free;
+
+	ret = _SUCCESS;
+
+os_ndev_free:
+	if (ret != _SUCCESS)
+		rtw_os_ndev_free(adapter);
+exit:
+	return ret;
+}
+
+/**
+ * rtw_os_ndev_deinit - Unregister and free OS layer net device and relating structures for @adapter
+ * @adapter: the adapter on which this function applies
+ */
+void rtw_os_ndev_deinit(_adapter *adapter)
+{
+	rtw_os_ndev_unregister(adapter);
+	rtw_os_ndev_free(adapter);
+}
+
+int rtw_os_ndevs_alloc(struct dvobj_priv *dvobj)
+{
+	int i, status = _SUCCESS;
+	_adapter *adapter;
+
+#if defined(CONFIG_IOCTL_CFG80211)
+	if (rtw_cfg80211_dev_res_alloc(dvobj) != _SUCCESS) {
+		rtw_warn_on(1);
+		status = _FAIL;
+		goto exit;
+	}
+#endif
+
+	for (i = 0; i < dvobj->iface_nums; i++) {
+
+		if (i >= IFACE_ID_MAX) {
+			DBG_871X_LEVEL(_drv_err_, "%s %d >= IFACE_ID_MAX\n", __func__, i);
+			rtw_warn_on(1);
+			continue;
+		}
+
+		adapter = dvobj->padapters[i];
+		if (adapter && !adapter->pnetdev) {
+			status = rtw_os_ndev_alloc(adapter);
+			if (status != _SUCCESS) {
+				rtw_warn_on(1);
+				break;
+			}
+		}
+	}
+
+	if (status != _SUCCESS) {
+		for (; i >= 0; i--) {
+			adapter = dvobj->padapters[i];
+			if (adapter && adapter->pnetdev)
+				rtw_os_ndev_free(adapter);
+		}
+	}
+
+#if defined(CONFIG_IOCTL_CFG80211)
+	if (status != _SUCCESS)
+		rtw_cfg80211_dev_res_free(dvobj);
+#endif
+exit:
+	return status;
+}
+
+void rtw_os_ndevs_free(struct dvobj_priv *dvobj)
+{
+	int i;
+	_adapter *adapter = NULL;
+
+	for (i = 0; i < dvobj->iface_nums; i++) {
+
+		if (i >= IFACE_ID_MAX) {
+			DBG_871X_LEVEL(_drv_err_, "%s %d >= IFACE_ID_MAX\n", __func__, i);
+			rtw_warn_on(1);
+			continue;
+		}
+
+		adapter = dvobj->padapters[i];
+
+		if (adapter == NULL)
+			continue;
+
+		rtw_os_ndev_free(adapter);
+	}
+
+#if defined(CONFIG_IOCTL_CFG80211)
+	rtw_cfg80211_dev_res_free(dvobj);
+#endif
+}
+
+u32 rtw_start_drv_threads(_adapter *padapter)
+{
+	u32 _status = _SUCCESS;
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_start_drv_threads\n"));
+
+#ifdef CONFIG_XMIT_THREAD_MODE
+#if defined(CONFIG_SDIO_HCI)
+	if (is_primary_adapter(padapter))
+#endif		
+	{
+		padapter->xmitThread = kthread_run(rtw_xmit_thread, padapter, "RTW_XMIT_THREAD");
+		if(IS_ERR(padapter->xmitThread))
+			_status = _FAIL;
+	}
+#endif //#ifdef CONFIG_XMIT_THREAD_MODE
+
+#ifdef CONFIG_RECV_THREAD_MODE
+	padapter->recvThread = kthread_run(rtw_recv_thread, padapter, "RTW_RECV_THREAD");
+	if(IS_ERR(padapter->recvThread))
+		_status = _FAIL;
+#endif
+
+	if (is_primary_adapter(padapter)) {
+		padapter->cmdThread = kthread_run(rtw_cmd_thread, padapter, "RTW_CMD_THREAD");
+	        if(IS_ERR(padapter->cmdThread))
+			_status = _FAIL;
+		else
+			_rtw_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema); //wait for cmd_thread to run
+	}
+
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+	padapter->evtThread = kthread_run(event_thread, padapter, "RTW_EVENT_THREAD");
+	if(IS_ERR(padapter->evtThread))
+		_status = _FAIL;
+#endif
+
+	rtw_hal_start_thread(padapter);
+	return _status;
+
+}
+
+void rtw_stop_drv_threads (_adapter *padapter)
+{
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_stop_drv_threads\n"));
+
+	if (is_primary_adapter(padapter))
+		rtw_stop_cmd_thread(padapter);
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+        _rtw_up_sema(&padapter->evtpriv.evt_notify);
+	if(padapter->evtThread){
+		_rtw_down_sema(&padapter->evtpriv.terminate_evtthread_sema);
+	}
+#endif
+
+#ifdef CONFIG_XMIT_THREAD_MODE
+	// Below is to termindate tx_thread...
+#if defined(CONFIG_SDIO_HCI) 
+	// Only wake-up primary adapter
+	if (is_primary_adapter(padapter))
+#endif  /*SDIO_HCI */
+	{
+		_rtw_up_sema(&padapter->xmitpriv.xmit_sema);
+		_rtw_down_sema(&padapter->xmitpriv.terminate_xmitthread_sema);
+	}
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("\n drv_halt: rtw_xmit_thread can be terminated !\n"));
+#endif
+
+#ifdef CONFIG_RECV_THREAD_MODE
+	// Below is to termindate rx_thread...
+	_rtw_up_sema(&padapter->recvpriv.recv_sema);
+	_rtw_down_sema(&padapter->recvpriv.terminate_recvthread_sema);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("\n drv_halt:recv_thread can be terminated! \n"));
+#endif
+
+	rtw_hal_stop_thread(padapter);
+}
+
+u8 rtw_init_default_value(_adapter *padapter);
+u8 rtw_init_default_value(_adapter *padapter)
+{
+	u8 ret  = _SUCCESS;
+	struct registry_priv* pregistrypriv = &padapter->registrypriv;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	//xmit_priv
+	pxmitpriv->vcs_setting = pregistrypriv->vrtl_carrier_sense;
+	pxmitpriv->vcs = pregistrypriv->vcs_type;
+	pxmitpriv->vcs_type = pregistrypriv->vcs_type;
+	//pxmitpriv->rts_thresh = pregistrypriv->rts_thresh;
+	pxmitpriv->frag_len = pregistrypriv->frag_thresh;
+
+	//recv_priv
+
+	//mlme_priv
+	pmlmepriv->scan_mode = SCAN_ACTIVE;
+
+	//qos_priv
+	//pmlmepriv->qospriv.qos_option = pregistrypriv->wmm_enable;
+
+	//ht_priv
+#ifdef CONFIG_80211N_HT
+	pmlmepriv->htpriv.ampdu_enable = _FALSE;//set to disabled
+#endif
+
+	//security_priv
+	//rtw_get_encrypt_decrypt_from_registrypriv(padapter);
+	psecuritypriv->binstallGrpkey = _FAIL;
+#ifdef CONFIG_GTK_OL
+	psecuritypriv->binstallKCK_KEK = _FAIL;
+#endif //CONFIG_GTK_OL
+	psecuritypriv->sw_encrypt=pregistrypriv->software_encrypt;
+	psecuritypriv->sw_decrypt=pregistrypriv->software_decrypt;
+
+	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; //open system
+	psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+
+	psecuritypriv->dot11PrivacyKeyIndex = 0;
+
+	psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+	psecuritypriv->dot118021XGrpKeyid = 1;
+
+	psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;
+	psecuritypriv->ndisencryptstatus = Ndis802_11WEPDisabled;
+
+
+	//pwrctrl_priv
+
+
+	//registry_priv
+	rtw_init_registrypriv_dev_network(padapter);
+	rtw_update_registrypriv_dev_network(padapter);
+
+
+	//hal_priv
+	rtw_hal_def_value_init(padapter);
+
+	//misc.
+	RTW_ENABLE_FUNC(padapter, DF_RX_BIT);
+	RTW_ENABLE_FUNC(padapter, DF_TX_BIT);
+	padapter->bLinkInfoDump = 0;
+	padapter->bNotifyChannelChange = _FALSE;
+#ifdef CONFIG_P2P
+	padapter->bShowGetP2PState = 1;
+#endif
+
+	//for debug purpose
+	padapter->fix_rate = 0xFF;
+	padapter->data_fb = 0;
+	padapter->driver_ampdu_spacing = 0xFF;
+	padapter->driver_rx_ampdu_factor =  0xFF;
+	padapter->driver_rx_ampdu_spacing = 0xFF;
+	padapter->fix_rx_ampdu_accept = RX_AMPDU_ACCEPT_INVALID;
+	padapter->fix_rx_ampdu_size = RX_AMPDU_SIZE_INVALID;
+#ifdef DBG_RX_COUNTER_DUMP
+	padapter->dump_rx_cnt_mode = 0;
+	padapter->drv_rx_cnt_ok = 0;
+	padapter->drv_rx_cnt_crcerror = 0;
+	padapter->drv_rx_cnt_drop = 0;
+#endif	
+	return ret;
+}
+
+struct dvobj_priv *devobj_init(void)
+{
+	struct dvobj_priv *pdvobj = NULL;
+
+	if ((pdvobj = (struct dvobj_priv*)rtw_zmalloc(sizeof(*pdvobj))) == NULL) 
+	{
+		return NULL;
+	}
+
+	_rtw_mutex_init(&pdvobj->hw_init_mutex);
+	_rtw_mutex_init(&pdvobj->h2c_fwcmd_mutex);
+	_rtw_mutex_init(&pdvobj->setch_mutex);
+	_rtw_mutex_init(&pdvobj->setbw_mutex);
+	_rtw_mutex_init(&pdvobj->rf_read_reg_mutex);
+#ifdef CONFIG_SDIO_INDIRECT_ACCESS
+	_rtw_mutex_init(&pdvobj->sd_indirect_access_mutex);
+#endif
+
+	pdvobj->processing_dev_remove = _FALSE;
+
+	ATOMIC_SET(&pdvobj->disable_func, 0);
+
+	rtw_macid_ctl_init(&pdvobj->macid_ctl);
+	_rtw_spinlock_init(&pdvobj->cam_ctl.lock);
+	_rtw_mutex_init(&pdvobj->cam_ctl.sec_cam_access_mutex);
+
+	return pdvobj;
+
+}
+
+void devobj_deinit(struct dvobj_priv *pdvobj)
+{
+	if(!pdvobj)
+		return;
+
+	/* TODO: use rtw_os_ndevs_deinit instead at the first stage of driver's dev deinit function */
+#if defined(CONFIG_IOCTL_CFG80211)
+	rtw_cfg80211_dev_res_free(pdvobj);
+#endif
+
+	_rtw_mutex_free(&pdvobj->hw_init_mutex);
+	_rtw_mutex_free(&pdvobj->h2c_fwcmd_mutex);
+	_rtw_mutex_free(&pdvobj->setch_mutex);
+	_rtw_mutex_free(&pdvobj->setbw_mutex);
+	_rtw_mutex_free(&pdvobj->rf_read_reg_mutex);
+#ifdef CONFIG_SDIO_INDIRECT_ACCESS
+	_rtw_mutex_free(&pdvobj->sd_indirect_access_mutex);
+#endif
+
+	rtw_macid_ctl_deinit(&pdvobj->macid_ctl);
+	_rtw_spinlock_free(&pdvobj->cam_ctl.lock);
+	_rtw_mutex_free(&pdvobj->cam_ctl.sec_cam_access_mutex);
+
+	rtw_mfree((u8*)pdvobj, sizeof(*pdvobj));
+}	
+
+u8 rtw_reset_drv_sw(_adapter *padapter)
+{
+	u8	ret8=_SUCCESS;
+	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
+	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
+
+	//hal_priv
+	if( is_primary_adapter(padapter))
+		rtw_hal_def_value_init(padapter);
+
+	RTW_ENABLE_FUNC(padapter, DF_RX_BIT);
+	RTW_ENABLE_FUNC(padapter, DF_TX_BIT);
+	padapter->bLinkInfoDump = 0;
+
+	padapter->xmitpriv.tx_pkts = 0;
+	padapter->recvpriv.rx_pkts = 0;
+
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = _FALSE;
+
+	//pmlmepriv->LinkDetectInfo.TrafficBusyState = _FALSE;
+	pmlmepriv->LinkDetectInfo.TrafficTransitionCount = 0;
+	pmlmepriv->LinkDetectInfo.LowPowerTransitionCount = 0;
+
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY |_FW_UNDER_LINKING);
+
+#ifdef CONFIG_AUTOSUSPEND
+	#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,34))
+		adapter_to_dvobj(padapter)->pusbdev->autosuspend_disabled = 1;//autosuspend disabled by the user
+	#endif
+#endif
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+	if (is_primary_adapter(padapter))
+		rtw_hal_sreset_reset_value(padapter);
+#endif
+	pwrctrlpriv->pwr_state_check_cnts = 0;
+
+	//mlmeextpriv
+	mlmeext_set_scan_state(&padapter->mlmeextpriv, SCAN_DISABLE);
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	rtw_set_signal_stat_timer(&padapter->recvpriv);
+#endif
+
+	return ret8;
+}
+
+
+u8 rtw_init_drv_sw(_adapter *padapter)
+{
+
+	u8	ret8=_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_init_drv_sw\n"));
+
+	ret8 = rtw_init_default_value(padapter);
+
+	if ((rtw_init_cmd_priv(&padapter->cmdpriv)) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init cmd_priv\n"));
+		ret8=_FAIL;
+		goto exit;
+	}
+
+	padapter->cmdpriv.padapter=padapter;
+
+	if ((rtw_init_evt_priv(&padapter->evtpriv)) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init evt_priv\n"));
+		ret8=_FAIL;
+		goto exit;
+	}
+
+
+	if (rtw_init_mlme_priv(padapter) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init mlme_priv\n"));
+		ret8=_FAIL;
+		goto exit;
+	}
+
+#ifdef CONFIG_P2P
+	rtw_init_wifidirect_timers(padapter);
+	init_wifidirect_info(padapter, P2P_ROLE_DISABLE);
+	reset_global_wifidirect_info(padapter);
+	#ifdef CONFIG_IOCTL_CFG80211
+	rtw_init_cfg80211_wifidirect_info(padapter);
+	#endif
+#ifdef CONFIG_WFD
+	if(rtw_init_wifi_display_info(padapter) == _FAIL)
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init init_wifi_display_info\n"));
+#endif
+#endif /* CONFIG_P2P */
+
+	if(init_mlme_ext_priv(padapter) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init mlme_ext_priv\n"));
+		ret8=_FAIL;
+		goto exit;
+	}
+
+#ifdef CONFIG_TDLS
+	if(rtw_init_tdls_info(padapter) == _FAIL)
+	{
+		DBG_871X("Can't rtw_init_tdls_info\n");
+		ret8=_FAIL;
+		goto exit;
+	}
+#endif //CONFIG_TDLS
+
+	if(_rtw_init_xmit_priv(&padapter->xmitpriv, padapter) == _FAIL)
+	{
+		DBG_871X("Can't _rtw_init_xmit_priv\n");
+		ret8=_FAIL;
+		goto exit;
+	}
+
+	if(_rtw_init_recv_priv(&padapter->recvpriv, padapter) == _FAIL)
+	{
+		DBG_871X("Can't _rtw_init_recv_priv\n");
+		ret8=_FAIL;
+		goto exit;
+	}
+	// add for CONFIG_IEEE80211W, none 11w also can use
+	_rtw_spinlock_init(&padapter->security_key_mutex);
+	
+	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
+	//_rtw_memset((unsigned char *)&padapter->securitypriv, 0, sizeof (struct security_priv));
+
+	//_init_timer(&(padapter->securitypriv.tkip_timer), padapter->pifp, rtw_use_tkipkey_handler, padapter);
+
+	if(_rtw_init_sta_priv(&padapter->stapriv) == _FAIL)
+	{
+		DBG_871X("Can't _rtw_init_sta_priv\n");
+		ret8=_FAIL;
+		goto exit;
+	}
+
+	padapter->stapriv.padapter = padapter;
+	padapter->setband = WIFI_FREQUENCY_BAND_AUTO;
+	padapter->fix_rate = 0xFF;
+	padapter->data_fb = 0;
+	padapter->fix_rx_ampdu_accept = RX_AMPDU_ACCEPT_INVALID;
+	padapter->fix_rx_ampdu_size = RX_AMPDU_SIZE_INVALID;
+#ifdef DBG_RX_COUNTER_DUMP
+	padapter->dump_rx_cnt_mode = 0;
+	padapter->drv_rx_cnt_ok = 0;
+	padapter->drv_rx_cnt_crcerror = 0;
+	padapter->drv_rx_cnt_drop = 0;
+#endif	
+	rtw_init_bcmc_stainfo(padapter);
+
+	rtw_init_pwrctrl_priv(padapter);
+
+	//_rtw_memset((u8 *)&padapter->qospriv, 0, sizeof (struct qos_priv));//move to mlme_priv
+
+#ifdef CONFIG_MP_INCLUDED
+	if (init_mp_priv(padapter) == _FAIL) {
+		DBG_871X("%s: initialize MP private data Fail!\n", __func__);
+	}
+#endif
+
+	rtw_hal_dm_init(padapter);
+	rtw_hal_sw_led_init(padapter);
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+	rtw_hal_sreset_init(padapter);
+#endif
+
+#ifdef CONFIG_INTEL_WIDI
+	if(rtw_init_intel_widi(padapter) == _FAIL)
+	{
+		DBG_871X("Can't rtw_init_intel_widi\n");
+		ret8=_FAIL;
+		goto exit;
+	}
+#endif //CONFIG_INTEL_WIDI
+
+#ifdef CONFIG_WAPI_SUPPORT
+	padapter->WapiSupport = true; //set true temp, will revise according to Efuse or Registry value later.
+	rtw_wapi_init(padapter);
+#endif
+
+#ifdef CONFIG_BR_EXT
+	_rtw_spinlock_init(&padapter->br_ext_lock);
+#endif	// CONFIG_BR_EXT
+
+exit:
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-rtw_init_drv_sw\n"));
+
+	_func_exit_;
+
+	return ret8;
+
+}
+
+#ifdef CONFIG_WOWLAN
+void rtw_cancel_dynamic_chk_timer(_adapter *padapter)
+{
+	_cancel_timer_ex(&padapter->mlmepriv.dynamic_chk_timer);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel dynamic_chk_timer! \n"));
+}
+#endif
+
+void rtw_cancel_all_timer(_adapter *padapter)
+{
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_cancel_all_timer\n"));
+
+	_cancel_timer_ex(&padapter->mlmepriv.assoc_timer);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel association timer complete!\n"));
+
+	#if 0
+	_cancel_timer_ex(&padapter->securitypriv.tkip_timer);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel tkip_timer!\n"));
+	#endif
+
+	_cancel_timer_ex(&padapter->mlmepriv.scan_to_timer);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel scan_to_timer!\n"));
+
+	#ifdef CONFIG_DFS_MASTER
+	_cancel_timer_ex(&padapter->mlmepriv.dfs_master_timer);
+	#endif
+
+	_cancel_timer_ex(&padapter->mlmepriv.dynamic_chk_timer);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel dynamic_chk_timer!\n"));
+
+	// cancel sw led timer
+	rtw_hal_sw_led_deinit(padapter);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel DeInitSwLeds! \n"));
+
+	_cancel_timer_ex(&(adapter_to_pwrctl(padapter)->pwr_state_check_timer));
+
+#ifdef CONFIG_IOCTL_CFG80211
+#ifdef CONFIG_P2P
+	_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
+#endif //CONFIG_P2P
+#endif //CONFIG_IOCTL_CFG80211
+
+#ifdef CONFIG_SET_SCAN_DENY_TIMER
+	_cancel_timer_ex(&padapter->mlmepriv.set_scan_deny_timer);
+	rtw_clear_scan_deny(padapter);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel set_scan_deny_timer! \n"));
+#endif
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	_cancel_timer_ex(&padapter->recvpriv.signal_stat_timer);
+#endif
+	//cancel dm timer
+	rtw_hal_dm_deinit(padapter);
+
+#ifdef CONFIG_PLATFORM_FS_MX61
+	msleep(50);
+#endif
+}
+
+u8 rtw_free_drv_sw(_adapter *padapter)
+{
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("==>rtw_free_drv_sw"));
+
+#ifdef CONFIG_WAPI_SUPPORT
+	rtw_wapi_free(padapter);
+#endif
+
+	//we can call rtw_p2p_enable here, but:
+	// 1. rtw_p2p_enable may have IO operation
+	// 2. rtw_p2p_enable is bundled with wext interface
+	#ifdef CONFIG_P2P
+	{
+		struct wifidirect_info *pwdinfo = &padapter->wdinfo;
+		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		{
+			_cancel_timer_ex( &pwdinfo->find_phase_timer );
+			_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
+			_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
+#ifdef CONFIG_CONCURRENT_MODE
+			_cancel_timer_ex( &pwdinfo->ap_p2p_switch_timer );
+#endif // CONFIG_CONCURRENT_MODE
+			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
+		}
+	}
+	#endif
+	// add for CONFIG_IEEE80211W, none 11w also can use
+	_rtw_spinlock_free(&padapter->security_key_mutex);
+	
+#ifdef CONFIG_BR_EXT
+	_rtw_spinlock_free(&padapter->br_ext_lock);
+#endif	// CONFIG_BR_EXT
+
+#ifdef CONFIG_INTEL_WIDI
+	rtw_free_intel_widi(padapter);
+#endif //CONFIG_INTEL_WIDI
+
+	free_mlme_ext_priv(&padapter->mlmeextpriv);
+
+#ifdef CONFIG_TDLS
+	//rtw_free_tdls_info(&padapter->tdlsinfo);
+#endif //CONFIG_TDLS
+
+	rtw_free_cmd_priv(&padapter->cmdpriv);
+
+	rtw_free_evt_priv(&padapter->evtpriv);
+
+	rtw_free_mlme_priv(&padapter->mlmepriv);
+
+	//free_io_queue(padapter);
+
+	_rtw_free_xmit_priv(&padapter->xmitpriv);
+
+	_rtw_free_sta_priv(&padapter->stapriv); //will free bcmc_stainfo here
+
+	_rtw_free_recv_priv(&padapter->recvpriv);
+
+	rtw_free_pwrctrl_priv(padapter);
+
+	//rtw_mfree((void *)padapter, sizeof (padapter));
+
+#ifdef CONFIG_DRVEXT_MODULE
+	free_drvext(&padapter->drvextpriv);
+#endif
+
+	rtw_hal_free_data(padapter);
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("<==rtw_free_drv_sw\n"));
+
+	//free the old_pnetdev
+	if(padapter->rereg_nd_name_priv.old_pnetdev) {
+		free_netdev(padapter->rereg_nd_name_priv.old_pnetdev);
+		padapter->rereg_nd_name_priv.old_pnetdev = NULL;
+	}
+
+	// clear pbuddy_adapter to avoid access wrong pointer.
+	if(padapter->pbuddy_adapter != NULL) {
+		padapter->pbuddy_adapter->pbuddy_adapter = NULL;
+	}
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-rtw_free_drv_sw\n"));
+
+	return _SUCCESS;
+
+}
+
+#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_MULTI_VIR_IFACES
+int _netdev_vir_if_open(struct net_device *pnetdev)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	_adapter *primary_padapter = GET_PRIMARY_ADAPTER(padapter);
+
+	DBG_871X(FUNC_NDEV_FMT" enter\n", FUNC_NDEV_ARG(pnetdev));
+
+	if(!primary_padapter)
+		goto _netdev_virtual_iface_open_error;
+
+	if (primary_padapter->bup == _FALSE || !rtw_is_hw_init_completed(primary_padapter))
+		_netdev_open(primary_padapter->pnetdev);
+
+	if(padapter->bup == _FALSE && primary_padapter->bup == _TRUE &&
+		rtw_is_hw_init_completed(primary_padapter))
+	{
+		padapter->bFWReady = primary_padapter->bFWReady;
+
+		if(rtw_start_drv_threads(padapter) == _FAIL)
+		{
+			goto _netdev_virtual_iface_open_error;
+		}
+
+#ifdef CONFIG_IOCTL_CFG80211
+		rtw_cfg80211_init_wiphy(padapter);
+#endif
+
+		padapter->bup = _TRUE;
+
+	}
+
+	padapter->net_closed = _FALSE;
+
+	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
+
+	rtw_netif_wake_queue(pnetdev);
+
+	DBG_871X(FUNC_NDEV_FMT" exit\n", FUNC_NDEV_ARG(pnetdev));
+	return 0;
+
+_netdev_virtual_iface_open_error:
+
+	padapter->bup = _FALSE;
+
+	netif_carrier_off(pnetdev);
+	rtw_netif_stop_queue(pnetdev);
+
+	return (-1);
+
+}
+
+int netdev_vir_if_open(struct net_device *pnetdev)
+{
+	int ret;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+
+	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
+	ret = _netdev_vir_if_open(pnetdev);
+	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
+
+#ifdef CONFIG_AUTO_AP_MODE
+	//if(padapter->iface_id == 2)
+	//	rtw_start_auto_ap(padapter);
+#endif
+
+	return ret;
+}
+
+static int netdev_vir_if_close(struct net_device *pnetdev)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+
+	padapter->net_closed = _TRUE;
+
+	if(pnetdev)
+	{
+		rtw_netif_stop_queue(pnetdev);
+	}
+
+#ifdef CONFIG_IOCTL_CFG80211
+	rtw_scan_abort(padapter);
+	rtw_cfg80211_wait_scan_req_empty(padapter, 200);
+	adapter_wdev_data(padapter)->bandroid_scan = _FALSE;
+#endif
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+static const struct net_device_ops rtw_netdev_vir_if_ops = {
+	 .ndo_open = netdev_vir_if_open,
+        .ndo_stop = netdev_vir_if_close,
+        .ndo_start_xmit = rtw_xmit_entry,
+        .ndo_set_mac_address = rtw_net_set_mac_address,
+        .ndo_get_stats = rtw_net_get_stats,
+        .ndo_do_ioctl = rtw_ioctl,
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	.ndo_select_queue	= rtw_select_queue,
+#endif
+};
+#endif
+
+void rtw_hook_vir_if_ops(struct net_device *ndev)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29))
+	ndev->netdev_ops = &rtw_netdev_vir_if_ops;
+#else
+	ndev->open = netdev_vir_if_open;
+	ndev->stop = netdev_vir_if_close;
+	ndev->set_mac_address = rtw_net_set_mac_address;
+#endif
+}
+
+_adapter *rtw_drv_add_vir_if(_adapter *primary_padapter,
+	void (*set_intf_ops)(_adapter *primary_padapter,struct _io_ops *pops))
+{
+	int res = _FAIL;
+	_adapter *padapter = NULL;
+	struct dvobj_priv *pdvobjpriv;
+	u8 mac[ETH_ALEN];
+
+/*
+	if((primary_padapter->bup == _FALSE) ||
+		(rtw_buddy_adapter_up(primary_padapter) == _FALSE))
+		goto exit;
+*/
+
+	/****** init adapter ******/
+	padapter = (_adapter *)rtw_zvmalloc(sizeof(*padapter));
+	if (padapter == NULL)
+		goto exit;
+
+	if (loadparam(padapter) != _SUCCESS)
+		goto free_adapter;
+
+	_rtw_memcpy(padapter, primary_padapter, sizeof(_adapter));
+
+	//
+	padapter->bup = _FALSE;
+	padapter->net_closed = _TRUE;
+	padapter->dir_dev = NULL;
+	padapter->dir_odm = NULL;
+
+
+	//set adapter_type/iface type
+	padapter->isprimary = _FALSE;
+	padapter->adapter_type = MAX_ADAPTER;
+	padapter->pbuddy_adapter = primary_padapter;
+#if 0
+#ifndef CONFIG_HWPORT_SWAP	//Port0 -> Pri , Port1 -> Sec
+	padapter->iface_type = IFACE_PORT1;
+#else
+	padapter->iface_type = IFACE_PORT0;
+#endif  //CONFIG_HWPORT_SWAP
+#else
+	//extended virtual interfaces always are set to port0
+	padapter->iface_type = IFACE_PORT0;
+#endif
+
+	/****** hook vir if into dvobj ******/
+	pdvobjpriv = adapter_to_dvobj(padapter);
+	padapter->iface_id = pdvobjpriv->iface_nums;
+	pdvobjpriv->padapters[pdvobjpriv->iface_nums++] = padapter;
+
+	padapter->intf_start = NULL;
+	padapter->intf_stop = NULL;
+
+	//step init_io_priv
+	if ((rtw_init_io_priv(padapter, set_intf_ops)) == _FAIL) {
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("\n Can't init io_reqs\n"));
+		goto free_adapter;
+	}
+
+	//init drv data
+	if(rtw_init_drv_sw(padapter)!= _SUCCESS)
+		goto free_drv_sw;
+
+
+	//get mac address from primary_padapter
+	_rtw_memcpy(mac, adapter_mac_addr(primary_padapter), ETH_ALEN);
+
+	/*
+	* If the BIT1 is 0, the address is universally administered.
+	* If it is 1, the address is locally administered
+	*/
+#if 1 /* needs enable MBSSID CAM */
+	mac[0] |= BIT(1);
+	mac[0] |= (padapter->iface_id-1)<<4;
+#endif
+
+	_rtw_memcpy(adapter_mac_addr(padapter), mac, ETH_ALEN);
+
+	res = _SUCCESS;
+
+free_drv_sw:
+	if (res != _SUCCESS && padapter)
+		rtw_free_drv_sw(padapter);
+free_adapter:
+	if (res != _SUCCESS && padapter) {
+		rtw_vmfree((u8 *)padapter, sizeof(*padapter));
+		padapter = NULL;
+	}
+exit:
+	return padapter;
+}
+
+void rtw_drv_stop_vir_if(_adapter *padapter)
+{
+	struct net_device *pnetdev=NULL;
+
+	if (padapter == NULL)
+		return;
+
+	pnetdev = padapter->pnetdev;
+
+	rtw_cancel_all_timer(padapter);
+
+	if (padapter->bup == _TRUE)
+	{
+		#ifdef CONFIG_XMIT_ACK
+		if (padapter->xmitpriv.ack_tx)
+			rtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_DRV_STOP);
+		#endif
+
+		if (padapter->intf_stop)
+		{
+			padapter->intf_stop(padapter);
+		}
+
+		rtw_stop_drv_threads(padapter);
+
+		padapter->bup = _FALSE;
+	}
+}
+
+void rtw_drv_free_vir_if(_adapter *padapter)
+{
+	if (padapter == NULL)
+		return;
+
+	padapter->pbuddy_adapter = NULL;
+
+	rtw_free_drv_sw(padapter);
+
+	/* TODO: use rtw_os_ndevs_deinit instead at the first stage of driver's dev deinit function */
+	rtw_os_ndev_free(padapter);
+
+	rtw_vmfree((u8 *)padapter, sizeof(_adapter));
+}
+
+void rtw_drv_stop_vir_ifaces(struct dvobj_priv *dvobj)
+{
+	int i;
+	//struct dvobj_priv *dvobj = primary_padapter->dvobj;
+
+	for(i=2;i<dvobj->iface_nums;i++)
+	{
+		rtw_drv_stop_vir_if(dvobj->padapters[i]);
+	}
+}
+
+void rtw_drv_free_vir_ifaces(struct dvobj_priv *dvobj)
+{
+	int i;
+	//struct dvobj_priv *dvobj = primary_padapter->dvobj;
+
+	for(i=2;i<dvobj->iface_nums;i++)
+	{
+		rtw_drv_free_vir_if(dvobj->padapters[i]);
+	}
+}
+
+void rtw_drv_del_vir_if(_adapter *padapter)
+{
+	rtw_drv_stop_vir_if(padapter);
+	rtw_drv_free_vir_if(padapter);
+}
+
+void rtw_drv_del_vir_ifaces(_adapter *primary_padapter)
+{
+	int i;
+	struct dvobj_priv *dvobj = primary_padapter->dvobj;
+
+	for(i=2;i<dvobj->iface_nums;i++)
+	{
+		rtw_drv_del_vir_if(dvobj->padapters[i]);
+	}
+}
+#endif //CONFIG_MULTI_VIR_IFACES
+
+int _netdev_if2_open(struct net_device *pnetdev)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	_adapter *primary_padapter = padapter->pbuddy_adapter;
+
+	DBG_871X("+871x_drv - if2_open, bup=%d\n", padapter->bup);
+
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+	if (padapter->bup == _FALSE)
+	{
+		u8 mac[ETH_ALEN];
+
+		/* get mac address from primary_padapter */
+		if (primary_padapter->bup == _FALSE)
+			rtw_macaddr_cfg(adapter_mac_addr(primary_padapter), get_hal_mac_addr(primary_padapter));
+
+		_rtw_memcpy(mac, adapter_mac_addr(primary_padapter), ETH_ALEN);
+
+		/*
+		* If the BIT1 is 0, the address is universally administered.
+		* If it is 1, the address is locally administered
+		*/
+		mac[0] |= BIT(1);
+
+		_rtw_memcpy(adapter_mac_addr(padapter), mac, ETH_ALEN);
+		rtw_init_wifidirect_addrs(padapter, adapter_mac_addr(padapter), adapter_mac_addr(padapter));
+		_rtw_memcpy(pnetdev->dev_addr, adapter_mac_addr(padapter), ETH_ALEN);
+	}
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
+	if (primary_padapter->bup == _FALSE || !rtw_is_hw_init_completed(primary_padapter))
+		_netdev_open(primary_padapter->pnetdev);
+
+	if(padapter->bup == _FALSE && primary_padapter->bup == _TRUE &&
+		rtw_is_hw_init_completed(primary_padapter))
+	{
+		padapter->bFWReady = primary_padapter->bFWReady;
+
+		//if (init_mlme_ext_priv(padapter) == _FAIL)
+		//	goto netdev_if2_open_error;
+
+
+		if (rtw_start_drv_threads(padapter) == _FAIL)
+		{
+			goto netdev_if2_open_error;
+		}
+
+
+		if (padapter->intf_start)
+		{
+			padapter->intf_start(padapter);
+		}
+
+#ifdef CONFIG_IOCTL_CFG80211
+		rtw_cfg80211_init_wiphy(padapter);
+#endif
+
+		padapter->bup = _TRUE;
+
+	}
+
+	padapter->net_closed = _FALSE;
+
+	//execute dynamic_chk_timer only on primary interface
+	// secondary interface shares the timer with primary interface.
+	//_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
+
+	rtw_netif_wake_queue(pnetdev);
+
+	DBG_871X("-871x_drv - if2_open, bup=%d\n", padapter->bup);
+	return 0;
+
+netdev_if2_open_error:
+
+	padapter->bup = _FALSE;
+
+	netif_carrier_off(pnetdev);
+	rtw_netif_stop_queue(pnetdev);
+
+	return (-1);
+
+}
+
+int netdev_if2_open(struct net_device *pnetdev)
+{
+	int ret;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
+
+	if (pwrctrlpriv->bInSuspend == _TRUE)
+	{
+		DBG_871X("+871x_drv - netdev_if2_open, bInSuspend=%d\n", pwrctrlpriv->bInSuspend);
+		return 0;
+	}
+
+	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
+	ret = _netdev_if2_open(pnetdev);
+	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
+
+#ifdef CONFIG_AUTO_AP_MODE
+	//if(padapter->iface_id == 2)
+		rtw_start_auto_ap(padapter);
+#endif
+
+	return ret;
+}
+
+static int netdev_if2_close(struct net_device *pnetdev)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+
+	padapter->net_closed = _TRUE;
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = _FALSE;
+
+	if(pnetdev)
+	{
+		rtw_netif_stop_queue(pnetdev);
+	}
+
+#ifdef CONFIG_P2P
+	if (!rtw_p2p_chk_role(&padapter->wdinfo, P2P_ROLE_DISABLE))
+		rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
+#endif
+
+#ifdef CONFIG_IOCTL_CFG80211
+	rtw_scan_abort(padapter);
+	rtw_cfg80211_wait_scan_req_empty(padapter, 200);
+	adapter_wdev_data(padapter)->bandroid_scan = _FALSE;
+#endif
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+static const struct net_device_ops rtw_netdev_if2_ops = {
+	.ndo_init = rtw_ndev_init,
+	.ndo_uninit = rtw_ndev_uninit,
+	.ndo_open = netdev_if2_open,
+	.ndo_stop = netdev_if2_close,
+	.ndo_start_xmit = rtw_xmit_entry,
+	.ndo_set_mac_address = rtw_net_set_mac_address,
+	.ndo_get_stats = rtw_net_get_stats,
+	.ndo_do_ioctl = rtw_ioctl,
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	.ndo_select_queue	= rtw_select_queue,
+#endif
+};
+#endif
+
+void rtw_hook_if2_ops(struct net_device *ndev)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29))
+	ndev->netdev_ops = &rtw_netdev_if2_ops;
+#else
+	ndev->init = rtw_ndev_init;
+	ndev->uninit = rtw_ndev_uninit;
+	ndev->open = netdev_if2_open;
+	ndev->stop = netdev_if2_close;
+	ndev->set_mac_address = rtw_net_set_mac_address;
+#endif
+}
+
+_adapter *rtw_drv_if2_init(_adapter *primary_padapter, 
+	void (*set_intf_ops)(_adapter *primary_padapter,struct _io_ops *pops))
+{
+	int res = _FAIL;
+	_adapter *padapter = NULL;
+	struct dvobj_priv *pdvobjpriv;
+	u8 mac[ETH_ALEN];
+
+	/****** init adapter ******/
+	padapter = (_adapter *)rtw_zvmalloc(sizeof(*padapter));
+	if (padapter == NULL)
+		goto exit;
+
+	if (loadparam(padapter) != _SUCCESS)
+		goto free_adapter;
+
+	_rtw_memcpy(padapter, primary_padapter, sizeof(*padapter));
+
+	//
+	padapter->bup = _FALSE;
+	padapter->net_closed = _TRUE;
+	padapter->dir_dev = NULL;
+	padapter->dir_odm = NULL;
+
+	//set adapter_type/iface type
+	padapter->isprimary = _FALSE;
+	padapter->adapter_type = SECONDARY_ADAPTER;
+	padapter->pbuddy_adapter = primary_padapter;
+	padapter->iface_id = IFACE_ID1;
+#ifndef CONFIG_HWPORT_SWAP			//Port0 -> Pri , Port1 -> Sec
+	padapter->iface_type = IFACE_PORT1;
+#else
+	padapter->iface_type = IFACE_PORT0;
+#endif  //CONFIG_HWPORT_SWAP
+
+	/****** hook if2 into dvobj ******/
+	pdvobjpriv = adapter_to_dvobj(padapter);
+	pdvobjpriv->padapters[pdvobjpriv->iface_nums++] = padapter;
+
+	//
+	padapter->intf_start = primary_padapter->intf_start;
+	padapter->intf_stop = primary_padapter->intf_stop;
+
+	//step init_io_priv
+	if ((rtw_init_io_priv(padapter, set_intf_ops)) == _FAIL) {
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("\n Can't init io_reqs\n"));
+		goto free_adapter;
+	}
+
+	//init drv data
+	if(rtw_init_drv_sw(padapter)!= _SUCCESS)
+		goto free_drv_sw;
+
+
+	/* get mac address from primary_padapter */
+	_rtw_memcpy(mac, adapter_mac_addr(primary_padapter), ETH_ALEN);
+
+	/*
+	* If the BIT1 is 0, the address is universally administered.
+	* If it is 1, the address is locally administered
+	*/
+	mac[0] |= BIT(1);
+
+	_rtw_memcpy(adapter_mac_addr(padapter), mac, ETH_ALEN);
+	rtw_init_wifidirect_addrs(padapter, adapter_mac_addr(padapter), adapter_mac_addr(padapter));
+
+	primary_padapter->pbuddy_adapter = padapter;
+
+	res = _SUCCESS;
+
+free_drv_sw:
+	if (res != _SUCCESS && padapter)
+		rtw_free_drv_sw(padapter);
+free_adapter:
+	if (res != _SUCCESS && padapter) {
+		rtw_vmfree((u8 *)padapter, sizeof(*padapter));
+		padapter = NULL;
+	}
+exit:
+	return padapter;
+}
+
+void rtw_drv_if2_free(_adapter *if2)
+{
+	_adapter *padapter = if2;
+
+	if (padapter == NULL)
+		return;
+
+	rtw_free_drv_sw(padapter);
+
+	/* TODO: use rtw_os_ndevs_deinit instead at the first stage of driver's dev deinit function */
+	rtw_os_ndev_free(padapter);
+
+	rtw_vmfree((u8 *)padapter, sizeof(_adapter));
+}
+
+void rtw_drv_if2_stop(_adapter *if2)
+{
+	_adapter *padapter = if2;
+	struct net_device *pnetdev = NULL;
+
+	if (padapter == NULL)
+		return;
+
+	rtw_cancel_all_timer(padapter);
+
+	if (padapter->bup == _TRUE) {
+		#ifdef CONFIG_XMIT_ACK
+		if (padapter->xmitpriv.ack_tx)
+			rtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_DRV_STOP);
+		#endif
+
+		if (padapter->intf_stop)
+		{
+			padapter->intf_stop(padapter);
+		}
+
+		rtw_stop_drv_threads(padapter);
+
+		padapter->bup = _FALSE;
+	}
+}
+#endif //end of CONFIG_CONCURRENT_MODE
+
+int rtw_os_ndevs_register(struct dvobj_priv *dvobj)
+{
+	int i, status = _SUCCESS;
+	struct registry_priv *regsty = dvobj_to_regsty(dvobj);
+	_adapter *adapter;
+
+#if defined(CONFIG_IOCTL_CFG80211)
+	if (rtw_cfg80211_dev_res_register(dvobj) != _SUCCESS) {
+		rtw_warn_on(1);
+		status = _FAIL;
+		goto exit;
+	}
+#endif
+
+	for (i = 0; i < dvobj->iface_nums; i++) {
+
+		if (i >= IFACE_ID_MAX) {
+			DBG_871X_LEVEL(_drv_err_, "%s %d >= IFACE_ID_MAX\n", __func__, i);
+			rtw_warn_on(1);
+			continue;
+		}
+
+		adapter = dvobj->padapters[i];
+		if (adapter) {
+			char *name;
+
+			if (adapter->iface_id == IFACE_ID0)
+				name = regsty->ifname;
+			else if (adapter->iface_id == IFACE_ID1)
+				name = regsty->if2name;
+			else
+				name = "wlan%d";
+
+			#ifdef CONFIG_CONCURRENT_MODE
+			switch (adapter->adapter_type) {
+			case SECONDARY_ADAPTER:
+				rtw_hook_if2_ops(adapter->pnetdev);
+				break;
+			#ifdef CONFIG_MULTI_VIR_IFACES
+			case MAX_ADAPTER:
+				rtw_hook_vir_if_ops(adapter->pnetdev);
+				break;
+			#endif
+			}
+			#endif /* CONFIG_CONCURRENT_MODE */
+
+			status = rtw_os_ndev_register(adapter, name);
+
+			if (status != _SUCCESS) {
+				rtw_warn_on(1);
+				break;
+			}
+		}
+	}
+
+	if (status != _SUCCESS) {
+		for (; i >= 0; i--) {
+			adapter = dvobj->padapters[i];
+			if (adapter)
+				rtw_os_ndev_unregister(adapter);
+		}
+	}
+
+#if defined(CONFIG_IOCTL_CFG80211)
+	if (status != _SUCCESS)
+		rtw_cfg80211_dev_res_unregister(dvobj);
+#endif
+exit:
+	return status;
+}
+
+void rtw_os_ndevs_unregister(struct dvobj_priv *dvobj)
+{
+	int i;
+	_adapter *adapter = NULL;
+
+	for (i = 0; i < dvobj->iface_nums; i++) {
+		adapter = dvobj->padapters[i];
+
+		if (adapter == NULL)
+			continue;
+
+		rtw_os_ndev_unregister(adapter);
+	}
+
+#if defined(CONFIG_IOCTL_CFG80211)
+	rtw_cfg80211_dev_res_unregister(dvobj);
+#endif
+}
+
+/**
+ * rtw_os_ndevs_init - Allocate and register OS layer net devices and relating structures for @dvobj
+ * @dvobj: the dvobj on which this function applies
+ *
+ * Returns:
+ * _SUCCESS or _FAIL
+ */
+int rtw_os_ndevs_init(struct dvobj_priv *dvobj)
+{
+	int ret = _FAIL;
+
+	if (rtw_os_ndevs_alloc(dvobj) != _SUCCESS)
+		goto exit;
+
+	if (rtw_os_ndevs_register(dvobj) != _SUCCESS)
+		goto os_ndevs_free;
+
+	ret = _SUCCESS;
+
+os_ndevs_free:
+	if (ret != _SUCCESS)
+		rtw_os_ndevs_free(dvobj);
+exit:
+	return ret;
+}
+
+/**
+ * rtw_os_ndevs_deinit - Unregister and free OS layer net devices and relating structures for @dvobj
+ * @dvobj: the dvobj on which this function applies
+ */
+void rtw_os_ndevs_deinit(struct dvobj_priv *dvobj)
+{
+	rtw_os_ndevs_unregister(dvobj);
+	rtw_os_ndevs_free(dvobj);
+}
+
+#ifdef CONFIG_BR_EXT
+void netdev_br_init(struct net_device *netdev)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+	rcu_read_lock();
+#endif	// (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+
+	//if(check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == _TRUE)
+	{
+		//struct net_bridge	*br = netdev->br_port->br;//->dev->dev_addr;
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+		if (netdev->br_port)
+#else   // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+		if (rcu_dereference(adapter->pnetdev->rx_handler_data))
+#endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+		{
+			struct net_device *br_netdev;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+			br_netdev = dev_get_by_name(CONFIG_BR_EXT_BRNAME);
+#else	// (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+			struct net *devnet = NULL;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+			devnet = netdev->nd_net;
+#else	// (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+			devnet = dev_net(netdev);
+#endif	// (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+
+			br_netdev = dev_get_by_name(devnet, CONFIG_BR_EXT_BRNAME);
+#endif	// (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+
+			if (br_netdev) {
+				memcpy(adapter->br_mac, br_netdev->dev_addr, ETH_ALEN);
+				dev_put(br_netdev);
+			} else
+				printk("%s()-%d: dev_get_by_name(%s) failed!", __FUNCTION__, __LINE__, CONFIG_BR_EXT_BRNAME);
+		}
+
+		adapter->ethBrExtInfo.addPPPoETag = 1;
+	}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+	rcu_read_unlock();
+#endif	// (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+}
+#endif //CONFIG_BR_EXT
+
+int _netdev_open(struct net_device *pnetdev)
+{
+	uint status;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);
+#endif //CONFIG_BT_COEXIST_SOCKET_TRX
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+871x_drv - dev_open\n"));
+	DBG_871X("+871x_drv - drv_open, bup=%d\n", padapter->bup);
+
+	padapter->netif_up = _TRUE;
+
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+	rtw_sdio_set_power(1);
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
+	if(pwrctrlpriv->ps_flag == _TRUE){
+		padapter->net_closed = _FALSE;
+		goto netdev_open_normal_process;
+	}
+
+	if(padapter->bup == _FALSE)
+	{
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+		rtw_macaddr_cfg(adapter_mac_addr(padapter),  get_hal_mac_addr(padapter));
+		rtw_init_wifidirect_addrs(padapter, adapter_mac_addr(padapter), adapter_mac_addr(padapter));
+		_rtw_memcpy(pnetdev->dev_addr, adapter_mac_addr(padapter), ETH_ALEN);
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
+		rtw_clr_surprise_removed(padapter);
+		rtw_clr_drv_stopped(padapter);
+
+		status = rtw_hal_init(padapter);
+		if (status ==_FAIL)
+		{
+			RT_TRACE(_module_os_intfs_c_,_drv_err_,("rtl871x_hal_init(): Can't init h/w!\n"));
+			goto netdev_open_error;
+		}
+
+		DBG_871X("MAC Address = "MAC_FMT"\n", MAC_ARG(pnetdev->dev_addr));
+
+		status=rtw_start_drv_threads(padapter);
+		if(status ==_FAIL)
+		{
+			DBG_871X("Initialize driver software resource Failed!\n");
+			goto netdev_open_error;
+		}
+
+#ifdef CONFIG_DRVEXT_MODULE
+		init_drvext(padapter);
+#endif
+
+		if (padapter->intf_start)
+		{
+			padapter->intf_start(padapter);
+		}
+
+#ifdef CONFIG_IOCTL_CFG80211
+		rtw_cfg80211_init_wiphy(padapter);
+#endif
+
+		rtw_led_control(padapter, LED_CTL_NO_LINK);
+
+		padapter->bup = _TRUE;
+		pwrctrlpriv->bips_processing = _FALSE;
+
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+#ifdef CONFIG_BT_COEXIST	
+		rtw_btcoex_IpsNotify(padapter, IPS_NONE);
+#endif // CONFIG_BT_COEXIST
+#endif //CONFIG_PLATFORM_INTEL_BYT		
+	}
+	padapter->net_closed = _FALSE;
+
+	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
+
+#ifndef CONFIG_IPS_CHECK_IN_WD
+	rtw_set_pwr_state_check_timer(pwrctrlpriv);
+#endif 
+
+	//netif_carrier_on(pnetdev);//call this func when rtw_joinbss_event_callback return success
+	rtw_netif_wake_queue(pnetdev);
+
+#ifdef CONFIG_BR_EXT
+	netdev_br_init(pnetdev);
+#endif	// CONFIG_BR_EXT
+
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+	if(is_primary_adapter(padapter) &&  _TRUE == pHalData->EEPROMBluetoothCoexist)
+	{
+		rtw_btcoex_init_socket(padapter);
+		padapter->coex_info.BtMgnt.ExtConfig.HCIExtensionVer = 0x04;
+		rtw_btcoex_SetHciVersion(padapter,0x04);
+	}
+	else
+		DBG_871X("CONFIG_BT_COEXIST: SECONDARY_ADAPTER\n");
+#endif //CONFIG_BT_COEXIST_SOCKET_TRX
+
+
+netdev_open_normal_process:
+
+	#ifdef CONFIG_CONCURRENT_MODE
+	{
+		_adapter *sec_adapter = padapter->pbuddy_adapter;
+		if(sec_adapter && (sec_adapter->bup == _FALSE))
+			_netdev_if2_open(sec_adapter->pnetdev);
+	}
+	#endif
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-871x_drv - dev_open\n"));
+	DBG_871X("-871x_drv - drv_open, bup=%d\n", padapter->bup);
+
+	return 0;
+
+netdev_open_error:
+
+	padapter->bup = _FALSE;
+
+	netif_carrier_off(pnetdev);
+	rtw_netif_stop_queue(pnetdev);
+
+	RT_TRACE(_module_os_intfs_c_,_drv_err_,("-871x_drv - dev_open, fail!\n"));
+	DBG_871X("-871x_drv - drv_open fail, bup=%d\n", padapter->bup);
+
+	return (-1);
+
+}
+
+int netdev_open(struct net_device *pnetdev)
+{
+	int ret;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
+
+	if (pwrctrlpriv->bInSuspend == _TRUE)
+	{
+		DBG_871X("+871x_drv - drv_open, bInSuspend=%d\n", pwrctrlpriv->bInSuspend);
+		return 0;
+	}
+
+	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
+	ret = _netdev_open(pnetdev);
+	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
+
+	return ret;
+}
+
+#ifdef CONFIG_IPS
+int  ips_netdrv_open(_adapter *padapter)
+{
+	int status = _SUCCESS;
+	//struct pwrctrl_priv	*pwrpriv = adapter_to_pwrctl(padapter);
+	
+	padapter->net_closed = _FALSE;
+
+	DBG_871X("===> %s.........\n",__FUNCTION__);
+
+
+	rtw_clr_drv_stopped(padapter);
+	//padapter->bup = _TRUE;
+
+	status = rtw_hal_init(padapter);
+	if (status ==_FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("ips_netdrv_open(): Can't init h/w!\n"));
+		goto netdev_open_error;
+	}
+
+	if (padapter->intf_start)
+	{
+		padapter->intf_start(padapter);
+	}
+
+#ifndef CONFIG_IPS_CHECK_IN_WD
+	rtw_set_pwr_state_check_timer(adapter_to_pwrctl(padapter));
+#endif		
+  	_set_timer(&padapter->mlmepriv.dynamic_chk_timer,2000);
+
+	 return _SUCCESS;
+
+netdev_open_error:
+	//padapter->bup = _FALSE;
+	DBG_871X("-ips_netdrv_open - drv_open failure, bup=%d\n", padapter->bup);
+
+	return _FAIL;
+}
+
+
+int rtw_ips_pwr_up(_adapter *padapter)
+{
+	int result;
+	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);
+#ifdef DBG_CONFIG_ERROR_DETECT
+	struct sreset_priv *psrtpriv = &pHalData->srestpriv;
+#endif//#ifdef DBG_CONFIG_ERROR_DETECT
+	u32 start_time = rtw_get_current_time();
+	DBG_871X("===>  rtw_ips_pwr_up..............\n");
+
+#if defined(CONFIG_SWLPS_IN_IPS) || defined(CONFIG_FWLPS_IN_IPS)
+#ifdef DBG_CONFIG_ERROR_DETECT
+	if (psrtpriv->silent_reset_inprogress == _TRUE)
+#endif//#ifdef DBG_CONFIG_ERROR_DETECT		
+#endif //defined(CONFIG_SWLPS_IN_IPS) || defined(CONFIG_FWLPS_IN_IPS)
+		rtw_reset_drv_sw(padapter);
+
+	result = ips_netdrv_open(padapter);
+
+	rtw_led_control(padapter, LED_CTL_NO_LINK);
+
+ 	DBG_871X("<===  rtw_ips_pwr_up.............. in %dms\n", rtw_get_passing_time_ms(start_time));
+	return result;
+
+}
+
+void rtw_ips_pwr_down(_adapter *padapter)
+{
+	u32 start_time = rtw_get_current_time();
+	DBG_871X("===> rtw_ips_pwr_down...................\n");
+
+	padapter->net_closed = _TRUE;
+
+	rtw_ips_dev_unload(padapter);
+	DBG_871X("<=== rtw_ips_pwr_down..................... in %dms\n", rtw_get_passing_time_ms(start_time));
+}
+#endif
+void rtw_ips_dev_unload(_adapter *padapter)
+{
+	struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(padapter);
+#ifdef DBG_CONFIG_ERROR_DETECT	
+	struct sreset_priv *psrtpriv = &pHalData->srestpriv;
+#endif//#ifdef DBG_CONFIG_ERROR_DETECT
+	DBG_871X("====> %s...\n",__FUNCTION__);
+
+
+#if defined(CONFIG_SWLPS_IN_IPS) || defined(CONFIG_FWLPS_IN_IPS)
+#ifdef DBG_CONFIG_ERROR_DETECT
+	if (psrtpriv->silent_reset_inprogress == _TRUE)
+#endif //#ifdef DBG_CONFIG_ERROR_DETECT		
+#endif //defined(CONFIG_SWLPS_IN_IPS) || defined(CONFIG_FWLPS_IN_IPS)
+	{
+		rtw_hal_set_hwreg(padapter, HW_VAR_FIFO_CLEARN_UP, 0);
+
+		if (padapter->intf_stop)
+		{
+			padapter->intf_stop(padapter);
+		}
+	}
+
+	if (!rtw_is_surprise_removed(padapter))
+		rtw_hal_deinit(padapter);
+
+}
+
+
+int pm_netdev_open(struct net_device *pnetdev,u8 bnormal)
+{
+	int status = 0;
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+
+	if (_TRUE == bnormal)
+	{
+		_enter_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
+		status = _netdev_open(pnetdev);
+		_exit_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
+	}	
+#ifdef CONFIG_IPS
+	else
+		status =  (_SUCCESS == ips_netdrv_open(padapter))?(0):(-1);
+#endif
+
+	return status;
+}
+
+static int netdev_close(struct net_device *pnetdev)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);
+#endif //CONFIG_BT_COEXIST_SOCKET_TRX
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+871x_drv - drv_close\n"));
+
+#ifndef CONFIG_PLATFORM_INTEL_BYT
+	if(pwrctl->bInternalAutoSuspend == _TRUE)
+	{
+		//rtw_pwr_wakeup(padapter);
+		if(pwrctl->rf_pwrstate == rf_off)
+			pwrctl->ps_flag = _TRUE;
+	}
+	padapter->net_closed = _TRUE;
+	padapter->netif_up = _FALSE;
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = _FALSE;
+
+/*	if (!rtw_is_hw_init_completed(padapter)) {
+		DBG_871X("(1)871x_drv - drv_close, bup=%d, hw_init_completed=%s\n", padapter->bup, rtw_is_hw_init_completed(padapter)?"_TRUE":"_FALSE");
+
+		rtw_set_drv_stopped(padapter);
+
+		rtw_dev_unload(padapter);
+	}
+	else*/
+	if(pwrctl->rf_pwrstate == rf_on){
+		DBG_871X("(2)871x_drv - drv_close, bup=%d, hw_init_completed=%s\n", padapter->bup, rtw_is_hw_init_completed(padapter)?"_TRUE":"_FALSE");
+
+		//s1.
+		if(pnetdev)
+		{
+			rtw_netif_stop_queue(pnetdev);
+		}
+
+#ifndef CONFIG_ANDROID
+		//s2.
+		LeaveAllPowerSaveMode(padapter);
+		rtw_disassoc_cmd(padapter, 500, _FALSE);
+		//s2-2.  indicate disconnect to os
+		rtw_indicate_disconnect(padapter);
+		//s2-3.
+		rtw_free_assoc_resources(padapter, 1);
+		//s2-4.
+		rtw_free_network_queue(padapter,_TRUE);
+#endif
+		// Close LED
+		rtw_led_control(padapter, LED_CTL_POWER_OFF);
+	}
+
+#ifdef CONFIG_BR_EXT
+	//if (OPMODE & (WIFI_STATION_STATE | WIFI_ADHOC_STATE))
+	{
+		//void nat25_db_cleanup(_adapter *priv);
+		nat25_db_cleanup(padapter);
+	}
+#endif	// CONFIG_BR_EXT
+
+#ifdef CONFIG_P2P
+	if (!rtw_p2p_chk_role(&padapter->wdinfo, P2P_ROLE_DISABLE))
+		rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
+#endif //CONFIG_P2P
+
+#ifdef CONFIG_IOCTL_CFG80211
+	rtw_scan_abort(padapter);
+	rtw_cfg80211_wait_scan_req_empty(padapter, 200);
+	adapter_wdev_data(padapter)->bandroid_scan = _FALSE;
+	//padapter->rtw_wdev->iftype = NL80211_IFTYPE_MONITOR; //set this at the end
+#endif //CONFIG_IOCTL_CFG80211
+
+#ifdef CONFIG_WAPI_SUPPORT
+	rtw_wapi_disable_tx(padapter);
+#endif
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+	if(is_primary_adapter(padapter) &&  _TRUE == pHalData->EEPROMBluetoothCoexist)
+		rtw_btcoex_close_socket(padapter);
+	else
+		DBG_871X("CONFIG_BT_COEXIST: SECONDARY_ADAPTER\n");
+#endif //CONFIG_BT_COEXIST_SOCKET_TRX
+#else //!CONFIG_PLATFORM_INTEL_BYT
+
+	if (pwrctl->bInSuspend == _TRUE)
+	{
+		DBG_871X("+871x_drv - drv_close, bInSuspend=%d\n", pwrctl->bInSuspend);
+		return 0;
+	}
+
+	rtw_scan_abort(padapter); // stop scanning process before wifi is going to down
+	#ifdef CONFIG_IOCTL_CFG80211
+	rtw_cfg80211_wait_scan_req_empty(padapter, 200);
+	#endif
+
+	DBG_871X("netdev_close, bips_processing=%d\n", pwrctl->bips_processing);
+	while (pwrctl->bips_processing == _TRUE) // waiting for ips_processing done before call rtw_dev_unload()
+		rtw_msleep_os(1);	
+
+	rtw_dev_unload(padapter);
+	rtw_sdio_set_power(0);
+
+#endif //!CONFIG_PLATFORM_INTEL_BYT
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-871x_drv - drv_close\n"));
+	DBG_871X("-871x_drv - drv_close, bup=%d\n", padapter->bup);
+
+	return 0;
+
+}
+
+int pm_netdev_close(struct net_device *pnetdev,u8 bnormal)
+{
+	int status = 0;
+
+	status = netdev_close(pnetdev);
+
+	return status;
+}
+
+void rtw_ndev_destructor(struct net_device *ndev)
+{
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+#ifdef CONFIG_IOCTL_CFG80211
+	if (ndev->ieee80211_ptr)
+		rtw_mfree((u8 *)ndev->ieee80211_ptr, sizeof(struct wireless_dev));
+#endif
+}
+
+#ifdef CONFIG_ARP_KEEP_ALIVE
+struct route_info {
+    struct in_addr dst_addr;
+    struct in_addr src_addr;
+    struct in_addr gateway;
+    unsigned int dev_index;
+};
+
+static void parse_routes(struct nlmsghdr *nl_hdr, struct route_info *rt_info)
+{
+    struct rtmsg *rt_msg;
+    struct rtattr *rt_attr;
+    int rt_len;
+
+    rt_msg = (struct rtmsg *) NLMSG_DATA(nl_hdr);
+    if ((rt_msg->rtm_family != AF_INET) || (rt_msg->rtm_table != RT_TABLE_MAIN))
+        return;
+
+    rt_attr = (struct rtattr *) RTM_RTA(rt_msg);
+    rt_len = RTM_PAYLOAD(nl_hdr);
+
+    for (; RTA_OK(rt_attr, rt_len); rt_attr = RTA_NEXT(rt_attr, rt_len)) 
+	{
+        switch (rt_attr->rta_type) {
+        case RTA_OIF:
+		rt_info->dev_index = *(int *) RTA_DATA(rt_attr);
+            break;
+        case RTA_GATEWAY:
+            rt_info->gateway.s_addr = *(u_int *) RTA_DATA(rt_attr);
+            break;
+        case RTA_PREFSRC:
+            rt_info->src_addr.s_addr = *(u_int *) RTA_DATA(rt_attr);
+            break;
+        case RTA_DST:
+            rt_info->dst_addr.s_addr = *(u_int *) RTA_DATA(rt_attr);
+            break;
+        }
+    }
+}
+
+static int route_dump(u32 *gw_addr ,int* gw_index)
+{
+	int err = 0;
+	struct socket *sock;
+	struct {
+		struct nlmsghdr nlh;
+		struct rtgenmsg g;
+	} req;
+	struct msghdr msg;
+	struct iovec iov;
+	struct sockaddr_nl nladdr;
+	mm_segment_t oldfs;
+	char *pg;
+	int size = 0;
+
+	err = sock_create(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE, &sock);
+	if (err)
+	{
+		printk( ": Could not create a datagram socket, error = %d\n", -ENXIO);
+		return err;
+	}
+	
+	memset(&nladdr, 0, sizeof(nladdr));
+	nladdr.nl_family = AF_NETLINK;
+
+	req.nlh.nlmsg_len = sizeof(req);
+	req.nlh.nlmsg_type = RTM_GETROUTE;
+	req.nlh.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;
+	req.nlh.nlmsg_pid = 0;
+	req.g.rtgen_family = AF_INET;
+
+	iov.iov_base = &req;
+	iov.iov_len = sizeof(req);
+
+	msg.msg_name = &nladdr;
+	msg.msg_namelen = sizeof(nladdr);
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	msg.msg_flags = MSG_DONTWAIT;
+
+	oldfs = get_fs(); set_fs(KERNEL_DS);
+	err = sock_sendmsg(sock, &msg, sizeof(req));
+	set_fs(oldfs);
+
+	if (err < 0)
+		goto out_sock;
+
+	pg = (char *) __get_free_page(GFP_KERNEL);
+	if (pg == NULL) {
+		err = -ENOMEM;
+		goto out_sock;
+	}
+
+#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
+restart:
+#endif
+
+	for (;;) 
+	{
+		struct nlmsghdr *h;
+
+		iov.iov_base = pg;
+		iov.iov_len = PAGE_SIZE;
+
+		oldfs = get_fs(); set_fs(KERNEL_DS);
+		err = sock_recvmsg(sock, &msg, PAGE_SIZE, MSG_DONTWAIT);
+		set_fs(oldfs);
+
+		if (err < 0)
+			goto out_sock_pg;
+
+		if (msg.msg_flags & MSG_TRUNC) {
+			err = -ENOBUFS;
+			goto out_sock_pg;
+		}
+
+		h = (struct nlmsghdr*) pg;
+		
+		while (NLMSG_OK(h, err)) 
+		{
+			struct route_info rt_info;
+			if (h->nlmsg_type == NLMSG_DONE) {
+				err = 0;
+				goto done;
+			}
+
+			if (h->nlmsg_type == NLMSG_ERROR) {
+				struct nlmsgerr *errm = (struct nlmsgerr*) NLMSG_DATA(h);
+				err = errm->error;
+				printk( "NLMSG error: %d\n", errm->error);
+				goto done;
+			}
+
+			if (h->nlmsg_type == RTM_GETROUTE)
+			{
+				printk( "RTM_GETROUTE: NLMSG: %d\n", h->nlmsg_type);
+			}
+			if (h->nlmsg_type != RTM_NEWROUTE) {
+				printk( "NLMSG: %d\n", h->nlmsg_type);
+				err = -EINVAL;
+				goto done;
+			}
+
+			memset(&rt_info, 0, sizeof(struct route_info));
+			parse_routes(h, &rt_info);
+			if(!rt_info.dst_addr.s_addr && rt_info.gateway.s_addr && rt_info.dev_index)
+			{
+				*gw_addr = rt_info.gateway.s_addr;
+				*gw_index = rt_info.dev_index;
+				 	
+			}
+			h = NLMSG_NEXT(h, err);
+		}
+
+		if (err) 
+		{
+			printk( "!!!Remnant of size %d %d %d\n", err, h->nlmsg_len, h->nlmsg_type);
+			err = -EINVAL;
+			break;
+		}
+	}
+
+done:
+#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
+	if (!err && req.g.rtgen_family == AF_INET) {
+		req.g.rtgen_family = AF_INET6;
+
+		iov.iov_base = &req;
+		iov.iov_len = sizeof(req);
+
+		msg.msg_name = &nladdr;
+		msg.msg_namelen = sizeof(nladdr);
+		msg.msg_iov = &iov;
+		msg.msg_iovlen = 1;
+		msg.msg_control = NULL;
+		msg.msg_controllen = 0;
+		msg.msg_flags=MSG_DONTWAIT;
+
+		oldfs = get_fs(); set_fs(KERNEL_DS);
+		err = sock_sendmsg(sock, &msg, sizeof(req));
+		set_fs(oldfs);
+
+		if (err > 0)
+			goto restart;
+	}
+#endif
+
+out_sock_pg:
+	free_page((unsigned long) pg);
+
+out_sock:
+	sock_release(sock);
+	return err;
+}
+
+static int arp_query(unsigned char *haddr, u32 paddr,
+             struct net_device *dev)
+{
+	struct neighbour *neighbor_entry;
+	int	ret = 0;
+
+	neighbor_entry = neigh_lookup(&arp_tbl, &paddr, dev);
+
+	if (neighbor_entry != NULL) {
+		neighbor_entry->used = jiffies;
+		if (neighbor_entry->nud_state & NUD_VALID) {
+			_rtw_memcpy(haddr, neighbor_entry->ha, dev->addr_len);
+			ret = 1;
+		}
+		neigh_release(neighbor_entry);
+	}
+	return ret;
+}
+
+static int get_defaultgw(u32 *ip_addr ,char mac[])
+{
+	int gw_index = 0; // oif device index
+	struct net_device *gw_dev = NULL; //oif device
+	
+	route_dump(ip_addr, &gw_index);
+
+	if( !(*ip_addr) || !gw_index )
+	{
+		//DBG_871X("No default GW \n");
+		return -1;
+	}
+
+	gw_dev = dev_get_by_index(&init_net, gw_index);
+
+	if(gw_dev == NULL)
+	{
+		//DBG_871X("get Oif Device Fail \n");
+		return -1;
+	}
+	
+	if(!arp_query(mac, *ip_addr, gw_dev))
+	{
+		//DBG_871X( "arp query failed\n");
+		dev_put(gw_dev);
+		return -1;
+		
+	}
+	dev_put(gw_dev);
+	
+	return 0;
+}
+
+int	rtw_gw_addr_query(_adapter *padapter)
+{
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
+	u32 gw_addr = 0; // default gw address
+	unsigned char gw_mac[32] = {0}; // default gw mac
+	int i;
+	int res;
+
+	res = get_defaultgw(&gw_addr, gw_mac);
+	if(!res)
+	{
+		pmlmepriv->gw_ip[0] = gw_addr&0xff;
+		pmlmepriv->gw_ip[1] = (gw_addr&0xff00)>>8;
+		pmlmepriv->gw_ip[2] = (gw_addr&0xff0000)>>16;
+		pmlmepriv->gw_ip[3] = (gw_addr&0xff000000)>>24;
+		_rtw_memcpy(pmlmepriv->gw_mac_addr, gw_mac, 6);
+		DBG_871X("%s Gateway Mac:\t" MAC_FMT "\n", __FUNCTION__, MAC_ARG(pmlmepriv->gw_mac_addr));
+		DBG_871X("%s Gateway IP:\t" IP_FMT "\n", __FUNCTION__, IP_ARG(pmlmepriv->gw_ip));
+	}
+	else
+	{
+		DBG_871X("Get Gateway IP/MAC fail!\n");
+	}
+
+	return res;
+}
+#endif
+
+void rtw_dev_unload(PADAPTER padapter)
+{
+	struct net_device *pnetdev = (struct net_device*)padapter->pnetdev;	
+	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
+	struct dvobj_priv *pobjpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &pobjpriv->drv_dbg;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	u8 cnt = 0;
+
+	RT_TRACE(_module_hci_intfs_c_, _drv_notice_, ("+%s\n",__FUNCTION__));
+
+	if (padapter->bup == _TRUE)
+	{
+		DBG_871X("===> %s\n",__FUNCTION__);
+
+		rtw_set_drv_stopped(padapter);
+		#ifdef CONFIG_XMIT_ACK
+		if (padapter->xmitpriv.ack_tx)
+			rtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_DRV_STOP);
+		#endif
+
+		if (padapter->intf_stop)
+			padapter->intf_stop(padapter);
+		
+		RT_TRACE(_module_hci_intfs_c_, _drv_notice_, ("@ rtw_dev_unload: stop intf complete!\n"));
+
+		if (!pwrctl->bInternalAutoSuspend)
+			rtw_stop_drv_threads(padapter);
+
+		while(ATOMIC_READ(&(pcmdpriv->cmdthd_running)) == _TRUE){
+			if (cnt > 5) {
+				DBG_871X("stop cmdthd timeout\n");
+				break;
+			} else {
+				cnt ++;
+				DBG_871X("cmdthd is running(%d)\n", cnt);
+				rtw_msleep_os(10);
+			}
+		}
+
+		RT_TRACE(_module_hci_intfs_c_, _drv_notice_, ("@ %s: stop thread complete!\n",__FUNCTION__));
+
+		//check the status of IPS
+		if(rtw_hal_check_ips_status(padapter) == _TRUE || pwrctl->rf_pwrstate == rf_off) { //check HW status and SW state
+			DBG_871X_LEVEL(_drv_always_, "%s: driver in IPS-FWLPS\n", __func__);
+			pdbgpriv->dbg_dev_unload_inIPS_cnt++;
+		} else {
+			DBG_871X_LEVEL(_drv_always_, "%s: driver not in IPS\n", __func__);
+		}
+
+		if (!rtw_is_surprise_removed(padapter)) {
+#ifdef CONFIG_BT_COEXIST
+			rtw_btcoex_IpsNotify(padapter, pwrctl->ips_mode_req);
+#endif
+#ifdef CONFIG_WOWLAN
+			if (pwrctl->bSupportRemoteWakeup == _TRUE && 
+				pwrctl->wowlan_mode ==_TRUE) {
+				DBG_871X_LEVEL(_drv_always_, "%s bSupportRemoteWakeup==_TRUE  do not run rtw_hal_deinit()\n",__FUNCTION__);
+			}
+			else
+#endif
+			{
+				//amy modify 20120221 for power seq is different between driver open and ips
+				rtw_hal_deinit(padapter);
+			}
+			rtw_set_surprise_removed(padapter);
+		}
+		RT_TRACE(_module_hci_intfs_c_, _drv_notice_, ("@ %s: deinit hal complelt!\n",__FUNCTION__));
+
+		padapter->bup = _FALSE;
+
+		DBG_871X("<=== %s\n",__FUNCTION__);
+	}
+	else {
+		RT_TRACE(_module_hci_intfs_c_, _drv_notice_, ("%s: bup==_FALSE\n",__FUNCTION__));
+		DBG_871X("%s: bup==_FALSE\n",__FUNCTION__);
+	}
+	
+	RT_TRACE(_module_hci_intfs_c_, _drv_notice_, ("-%s\n",__FUNCTION__));
+}
+
+int rtw_suspend_free_assoc_resource(_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct net_device *pnetdev = padapter->pnetdev;
+#ifdef CONFIG_P2P
+	struct wifidirect_info*	pwdinfo = &padapter->wdinfo;
+#endif // CONFIG_P2P
+
+	DBG_871X("==> "FUNC_ADPT_FMT" entry....\n", FUNC_ADPT_ARG(padapter));
+
+	if (rtw_chk_roam_flags(padapter, RTW_ROAM_ON_RESUME)) {
+		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+			&& check_fwstate(pmlmepriv, _FW_LINKED)
+#ifdef CONFIG_P2P
+			&& rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
+#endif // CONFIG_P2P
+			)
+		{
+			DBG_871X("%s %s(" MAC_FMT "), length:%d assoc_ssid.length:%d\n",__FUNCTION__,
+					pmlmepriv->cur_network.network.Ssid.Ssid,
+					MAC_ARG(pmlmepriv->cur_network.network.MacAddress),
+					pmlmepriv->cur_network.network.Ssid.SsidLength,
+					pmlmepriv->assoc_ssid.SsidLength);
+			rtw_set_to_roam(padapter, 1);
+		}
+	}
+
+	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) && check_fwstate(pmlmepriv, _FW_LINKED))
+	{	
+		rtw_disassoc_cmd(padapter, 0, _FALSE);	
+		//s2-2.  indicate disconnect to os
+		rtw_indicate_disconnect(padapter);
+	}
+	#ifdef CONFIG_AP_MODE
+	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE))	
+	{
+		rtw_sta_flush(padapter, _TRUE);
+	}
+	#endif
+		
+	//s2-3.
+	rtw_free_assoc_resources(padapter, 1);
+
+	//s2-4.
+#ifdef CONFIG_AUTOSUSPEND
+	if(is_primary_adapter(padapter) && (!adapter_to_pwrctl(padapter)->bInternalAutoSuspend ))
+#endif
+		rtw_free_network_queue(padapter, _TRUE);
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {
+		DBG_871X_LEVEL(_drv_always_, "%s: fw_under_survey\n", __func__);
+		rtw_indicate_scan_done(padapter, 1);
+		clr_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE)
+	{
+		DBG_871X_LEVEL(_drv_always_, "%s: fw_under_linking\n", __FUNCTION__);
+		rtw_indicate_disconnect(padapter);
+	}
+	
+	DBG_871X("<== "FUNC_ADPT_FMT" exit....\n", FUNC_ADPT_ARG(padapter));
+	return _SUCCESS;
+}
+
+#ifdef CONFIG_WOWLAN
+int rtw_suspend_wow(_adapter *padapter)
+{
+	u8 ch, bw, offset;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct net_device *pnetdev = padapter->pnetdev;
+	#ifdef CONFIG_CONCURRENT_MODE
+	struct net_device *pbuddy_netdev = padapter->pbuddy_adapter->pnetdev;	
+	#endif	
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;	
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	struct wowlan_ioctl_param poidparam;
+	u8 ps_mode;
+	int ret = _SUCCESS;
+
+	DBG_871X("==> "FUNC_ADPT_FMT" entry....\n", FUNC_ADPT_ARG(padapter));
+
+
+	DBG_871X("wowlan_mode: %d\n", pwrpriv->wowlan_mode);
+	DBG_871X("wowlan_pno_enable: %d\n", pwrpriv->wowlan_pno_enable);
+#ifdef CONFIG_P2P_WOWLAN
+	DBG_871X("wowlan_p2p_enable: %d\n", pwrpriv->wowlan_p2p_enable);
+#endif
+	
+	if (pwrpriv->wowlan_mode == _TRUE) {
+		
+		if(pnetdev)
+			rtw_netif_stop_queue(pnetdev);	
+		#ifdef CONFIG_CONCURRENT_MODE
+		if(pbuddy_netdev){
+			netif_carrier_off(pbuddy_netdev);
+			rtw_netif_stop_queue(pbuddy_netdev);
+		}
+		#endif//CONFIG_CONCURRENT_MODE
+		// 0. Power off LED
+		rtw_led_control(padapter, LED_CTL_POWER_OFF);
+		// 1. stop thread
+		rtw_set_drv_stopped(padapter);	/*for stop thread*/
+		rtw_stop_drv_threads(padapter);
+		#ifdef CONFIG_CONCURRENT_MODE	
+		if (rtw_buddy_adapter_up(padapter))
+			rtw_stop_drv_threads(padapter->pbuddy_adapter);
+		#endif /*CONFIG_CONCURRENT_MODE*/
+		rtw_clr_drv_stopped(padapter);	/*for 32k command*/
+
+		//#ifdef CONFIG_LPS
+		//rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0, "WOWLAN");
+		//#endif
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+		// 2. disable interrupt
+		if (padapter->intf_stop) {
+			padapter->intf_stop(padapter);
+		}
+
+
+		#ifdef CONFIG_CONCURRENT_MODE
+		if (rtw_buddy_adapter_up(padapter)) { //free buddy adapter's resource
+			padapter->pbuddy_adapter->intf_stop(padapter->pbuddy_adapter);
+		}
+		#endif
+
+		// 2.1 clean interupt
+		rtw_hal_clear_interrupt(padapter);
+#endif //CONFIG_SDIO_HCI
+
+		// 2.2 free irq
+		//sdio_free_irq(adapter_to_dvobj(padapter));
+		if(padapter->intf_free_irq)
+			padapter->intf_free_irq(adapter_to_dvobj(padapter));
+
+		#ifdef CONFIG_RUNTIME_PORT_SWITCH
+		if (rtw_port_switch_chk(padapter)) {
+			DBG_871X(" ### PORT SWITCH ### \n");
+			rtw_hal_set_hwreg(padapter, HW_VAR_PORT_SWITCH, NULL);
+		}
+		#endif
+
+		poidparam.subcode = WOWLAN_ENABLE;
+		rtw_hal_set_hwreg(padapter,HW_VAR_WOWLAN,(u8 *)&poidparam);
+		if (rtw_chk_roam_flags(padapter, RTW_ROAM_ON_RESUME)) {
+			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+				&& check_fwstate(pmlmepriv, _FW_LINKED))
+			{
+				DBG_871X("%s %s(" MAC_FMT "), length:%d assoc_ssid.length:%d\n",__FUNCTION__,
+						pmlmepriv->cur_network.network.Ssid.Ssid,
+						MAC_ARG(pmlmepriv->cur_network.network.MacAddress),
+						pmlmepriv->cur_network.network.Ssid.SsidLength,
+						pmlmepriv->assoc_ssid.SsidLength);
+
+				rtw_set_to_roam(padapter, 0);
+			}
+		}
+
+		DBG_871X_LEVEL(_drv_always_, "%s: wowmode suspending\n", __func__);
+
+		if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE)
+		{
+			DBG_871X_LEVEL(_drv_always_, "%s: fw_under_survey\n", __func__);
+			rtw_indicate_scan_done(padapter, 1);
+			clr_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+		}
+		
+		if (rtw_get_ch_setting_union(padapter, &ch, &bw, &offset) != 0) {
+			DBG_871X(FUNC_ADPT_FMT" back to linked/linking union - ch:%u, bw:%u, offset:%u\n",
+				FUNC_ADPT_ARG(padapter), ch, bw, offset);
+			set_channel_bwmode(padapter, ch, offset, bw);
+		}
+		#ifdef CONFIG_CONCURRENT_MODE
+		if(rtw_buddy_adapter_up(padapter)){ //free buddy adapter's resource
+			rtw_suspend_free_assoc_resource(padapter->pbuddy_adapter);
+		}
+		#endif	
+
+		if(pwrpriv->wowlan_pno_enable) {
+			DBG_871X_LEVEL(_drv_always_, "%s: pno: %d\n", __func__,
+					pwrpriv->wowlan_pno_enable);
+#ifdef CONFIG_FWLPS_IN_IPS
+			rtw_set_fw_in_ips_mode(padapter, _TRUE);
+#endif
+		}
+		#ifdef CONFIG_LPS
+		else
+			rtw_set_ps_mode(padapter, PS_MODE_MAX, 0, 0, "WOWLAN");
+		#endif //#ifdef CONFIG_LPS
+
+	}
+	else
+	{
+		DBG_871X_LEVEL(_drv_always_, "%s: ### ERROR ### wowlan_mode=%d\n", __FUNCTION__, pwrpriv->wowlan_mode);	
+	}
+	DBG_871X("<== "FUNC_ADPT_FMT" exit....\n", FUNC_ADPT_ARG(padapter));
+	return ret;
+}
+#endif //#ifdef CONFIG_WOWLAN
+
+#ifdef CONFIG_AP_WOWLAN
+int rtw_suspend_ap_wow(_adapter *padapter)
+{
+	u8 ch, bw, offset;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct net_device *pnetdev = padapter->pnetdev;
+	#ifdef CONFIG_CONCURRENT_MODE
+	struct net_device *pbuddy_netdev;
+	#endif
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	struct wowlan_ioctl_param poidparam;
+	u8 ps_mode;
+	int ret = _SUCCESS;
+
+	DBG_871X("==> "FUNC_ADPT_FMT" entry....\n", FUNC_ADPT_ARG(padapter));
+	
+	pwrpriv->wowlan_ap_mode = _TRUE;
+	
+	DBG_871X("wowlan_ap_mode: %d\n", pwrpriv->wowlan_ap_mode);
+	
+	if(pnetdev)
+		rtw_netif_stop_queue(pnetdev);
+	#ifdef CONFIG_CONCURRENT_MODE
+	if (rtw_buddy_adapter_up(padapter)) {
+		pbuddy_netdev = padapter->pbuddy_adapter->pnetdev;
+		if (pbuddy_netdev)
+		rtw_netif_stop_queue(pbuddy_netdev);
+	}
+	#endif//CONFIG_CONCURRENT_MODE
+	// 0. Power off LED
+	rtw_led_control(padapter, LED_CTL_POWER_OFF);
+	// 1. stop thread
+	rtw_set_drv_stopped(padapter);	/*for stop thread*/
+	rtw_stop_drv_threads(padapter);
+	#ifdef CONFIG_CONCURRENT_MODE	
+	if (rtw_buddy_adapter_up(padapter))
+		rtw_stop_drv_threads(padapter->pbuddy_adapter);
+	#endif /* CONFIG_CONCURRENT_MODE */
+	rtw_clr_drv_stopped(padapter);	/*for 32k command*/
+
+#ifdef CONFIG_SDIO_HCI
+	// 2. disable interrupt
+	rtw_hal_disable_interrupt(padapter); // It need wait for leaving 32K.
+
+	#ifdef CONFIG_CONCURRENT_MODE
+	if (rtw_buddy_adapter_up(padapter)) { //free buddy adapter's resource
+		padapter->pbuddy_adapter->intf_stop(padapter->pbuddy_adapter);
+	}
+	#endif
+
+	// 2.1 clean interupt
+	rtw_hal_clear_interrupt(padapter);
+#endif //CONFIG_SDIO_HCI
+
+	// 2.2 free irq
+	if(padapter->intf_free_irq)
+		padapter->intf_free_irq(adapter_to_dvobj(padapter));
+
+	#ifdef CONFIG_RUNTIME_PORT_SWITCH
+	if (rtw_port_switch_chk(padapter)) {
+		DBG_871X(" ### PORT SWITCH ### \n");
+		rtw_hal_set_hwreg(padapter, HW_VAR_PORT_SWITCH, NULL);
+	}
+	#endif
+
+	poidparam.subcode = WOWLAN_AP_ENABLE;
+	rtw_hal_set_hwreg(padapter, HW_VAR_WOWLAN, (u8 *)&poidparam);
+
+	DBG_871X_LEVEL(_drv_always_, "%s: wowmode suspending\n", __func__);
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, WIFI_AP_STATE) == _TRUE) {
+		if (rtw_get_ch_setting_union(padapter->pbuddy_adapter, &ch, &bw, &offset) != 0) {
+			DBG_871X(FUNC_ADPT_FMT" back to linked/linking union - ch:%u, bw:%u, offset:%u\n",
+				FUNC_ADPT_ARG(padapter->pbuddy_adapter), ch, bw, offset);
+			set_channel_bwmode(padapter->pbuddy_adapter, ch, offset, bw);
+		}
+		rtw_suspend_free_assoc_resource(padapter);
+	} else {
+		if (rtw_get_ch_setting_union(padapter, &ch, &bw, &offset) != 0) {
+			DBG_871X(FUNC_ADPT_FMT" back to linked/linking union - ch:%u, bw:%u, offset:%u\n",
+				FUNC_ADPT_ARG(padapter), ch, bw, offset);
+			set_channel_bwmode(padapter, ch, offset, bw);
+		}
+		rtw_suspend_free_assoc_resource(padapter->pbuddy_adapter);
+	}
+#else
+	if (rtw_get_ch_setting_union(padapter, &ch, &bw, &offset) != 0) {
+		DBG_871X(FUNC_ADPT_FMT" back to linked/linking union - ch:%u, bw:%u, offset:%u\n",
+			FUNC_ADPT_ARG(padapter), ch, bw, offset);
+			set_channel_bwmode(padapter, ch, offset, bw);
+	}
+#endif
+
+#ifdef CONFIG_LPS
+	rtw_set_ps_mode(padapter, PS_MODE_MIN, 0, 0, "AP-WOWLAN");
+#endif
+
+	DBG_871X("<== "FUNC_ADPT_FMT" exit....\n", FUNC_ADPT_ARG(padapter));
+	return ret;
+}
+#endif //#ifdef CONFIG_AP_WOWLAN
+
+
+int rtw_suspend_normal(_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct net_device *pnetdev = padapter->pnetdev;
+	#ifdef CONFIG_CONCURRENT_MODE
+	struct net_device *pbuddy_netdev = padapter->pbuddy_adapter->pnetdev;	
+	#endif	
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	int ret = _SUCCESS;	
+
+	DBG_871X("==> "FUNC_ADPT_FMT" entry....\n", FUNC_ADPT_ARG(padapter));			
+	if(pnetdev){
+		netif_carrier_off(pnetdev);
+		rtw_netif_stop_queue(pnetdev);
+	}		
+#ifdef CONFIG_CONCURRENT_MODE
+	if(rtw_buddy_adapter_up(padapter)){
+		pbuddy_netdev = padapter->pbuddy_adapter->pnetdev;
+		netif_carrier_off(pbuddy_netdev);
+		rtw_netif_stop_queue(pbuddy_netdev);
+	}
+#endif	
+
+	rtw_suspend_free_assoc_resource(padapter);
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if(rtw_buddy_adapter_up(padapter)){
+		rtw_suspend_free_assoc_resource(padapter->pbuddy_adapter);
+	}
+#endif
+	rtw_led_control(padapter, LED_CTL_POWER_OFF);
+
+	if ((rtw_hal_check_ips_status(padapter) == _TRUE)
+		|| (adapter_to_pwrctl(padapter)->rf_pwrstate == rf_off))
+	{
+		DBG_871X_LEVEL(_drv_always_, "%s: ### ERROR #### driver in IPS ####ERROR###!!!\n", __FUNCTION__);	
+		
+	}
+	
+#ifdef CONFIG_CONCURRENT_MODE
+	if(rtw_buddy_adapter_up(padapter)){
+		rtw_dev_unload(padapter->pbuddy_adapter);
+	}
+#endif
+	rtw_dev_unload(padapter);
+
+	//sdio_deinit(adapter_to_dvobj(padapter));
+	if(padapter->intf_deinit)
+		padapter->intf_deinit(adapter_to_dvobj(padapter));
+
+	DBG_871X("<== "FUNC_ADPT_FMT" exit....\n", FUNC_ADPT_ARG(padapter));
+	return ret;
+}
+
+int rtw_suspend_common(_adapter *padapter)
+{
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+	struct pwrctrl_priv *pwrpriv = dvobj_to_pwrctl(psdpriv);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	
+	int ret = 0;
+	u32 start_time = rtw_get_current_time();
+
+	DBG_871X_LEVEL(_drv_always_, " suspend start\n");
+	DBG_871X("==> %s (%s:%d)\n",__FUNCTION__, current->comm, current->pid);
+	
+	pdbgpriv->dbg_suspend_cnt++;
+	
+	pwrpriv->bInSuspend = _TRUE;
+	
+	while (pwrpriv->bips_processing == _TRUE)
+		rtw_msleep_os(1);		
+
+#ifdef CONFIG_IOL_READ_EFUSE_MAP
+	if(!padapter->bup){
+		u8 bMacPwrCtrlOn = _FALSE;
+		rtw_hal_get_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);
+		if(bMacPwrCtrlOn)
+			rtw_hal_power_off(padapter);
+	}
+#endif
+
+	if ((!padapter->bup) || RTW_CANNOT_RUN(padapter)) {
+		DBG_871X("%s bup=%d bDriverStopped=%s bSurpriseRemoved = %s\n", __func__
+			, padapter->bup
+			, rtw_is_drv_stopped(padapter)?"True":"False"
+			, rtw_is_surprise_removed(padapter)?"True":"False");
+		pdbgpriv->dbg_suspend_error_cnt++;
+		goto exit;
+	}
+	rtw_ps_deny(padapter, PS_DENY_SUSPEND);
+
+	rtw_cancel_all_timer(padapter);
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->pbuddy_adapter){
+		rtw_cancel_all_timer(padapter->pbuddy_adapter);
+	}
+#endif // CONFIG_CONCURRENT_MODE
+
+	LeaveAllPowerSaveModeDirect(padapter);
+
+	rtw_stop_cmd_thread(padapter);
+	
+#ifdef CONFIG_BT_COEXIST
+	// wait for the latest FW to remove this condition.
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE) {
+		rtw_btcoex_SuspendNotify(padapter, 0);
+		DBG_871X("WIFI_AP_STATE\n");
+#ifdef CONFIG_CONCURRENT_MODE
+	} else if (check_buddy_fwstate(padapter, WIFI_AP_STATE)) {
+		rtw_btcoex_SuspendNotify(padapter, 0);
+		DBG_871X("P2P_ROLE_GO\n");
+#endif //CONFIG_CONCURRENT_MODE
+	} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE) {
+		rtw_btcoex_SuspendNotify(padapter, 1);
+		DBG_871X("STATION\n");
+	}
+#endif // CONFIG_BT_COEXIST
+
+	rtw_ps_deny_cancel(padapter, PS_DENY_SUSPEND);
+
+	if (check_fwstate(pmlmepriv,WIFI_STATION_STATE) == _TRUE
+#ifdef CONFIG_CONCURRENT_MODE
+		&& check_buddy_fwstate(padapter, WIFI_AP_STATE) == _FALSE
+#endif
+	) {
+	#ifdef CONFIG_WOWLAN
+		if (check_fwstate(pmlmepriv, _FW_LINKED)) {
+			pwrpriv->wowlan_mode = _TRUE;
+		} else if (pwrpriv->wowlan_pno_enable == _TRUE) {
+			pwrpriv->wowlan_mode |= pwrpriv->wowlan_pno_enable;
+		}
+
+	#ifdef CONFIG_P2P_WOWLAN
+		if(!rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE) || P2P_ROLE_DISABLE != padapter->wdinfo.role)
+		{
+			pwrpriv->wowlan_p2p_mode = _TRUE;
+		}
+		if(_TRUE == pwrpriv->wowlan_p2p_mode)
+			pwrpriv->wowlan_mode |= pwrpriv->wowlan_p2p_mode;
+	#endif //CONFIG_P2P_WOWLAN
+
+		if (pwrpriv->wowlan_mode == _TRUE)
+			rtw_suspend_wow(padapter);
+		else
+			rtw_suspend_normal(padapter);
+		
+	#else //CONFIG_WOWLAN
+		rtw_suspend_normal(padapter);
+	#endif //CONFIG_WOWLAN
+	} else if (check_fwstate(pmlmepriv,WIFI_AP_STATE) == _TRUE
+#ifdef CONFIG_CONCURRENT_MODE
+		&& check_buddy_fwstate(padapter, WIFI_AP_STATE) == _FALSE
+#endif
+	) {
+	#ifdef CONFIG_AP_WOWLAN
+		rtw_suspend_ap_wow(padapter);
+	#else
+		rtw_suspend_normal(padapter);
+	#endif //CONFIG_AP_WOWLAN
+#ifdef CONFIG_CONCURRENT_MODE
+	} else if (check_fwstate(pmlmepriv,WIFI_STATION_STATE) == _TRUE
+		&& check_buddy_fwstate(padapter, WIFI_AP_STATE) == _TRUE) {
+	#ifdef CONFIG_AP_WOWLAN
+		rtw_suspend_ap_wow(padapter);
+	#else
+		rtw_suspend_normal(padapter);
+	#endif //CONFIG_AP_WOWLAN
+#endif
+	} else {
+		rtw_suspend_normal(padapter);
+	}
+
+
+	DBG_871X_LEVEL(_drv_always_, "rtw suspend success in %d ms\n",
+		rtw_get_passing_time_ms(start_time));
+
+exit:
+	DBG_871X("<===  %s return %d.............. in %dms\n", __FUNCTION__
+		, ret, rtw_get_passing_time_ms(start_time));
+
+	return ret;	
+}
+
+#ifdef CONFIG_WOWLAN
+int rtw_resume_process_wow(_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct net_device *pnetdev = padapter->pnetdev;
+	#ifdef CONFIG_CONCURRENT_MODE
+	struct net_device *pbuddy_netdev;	
+	#endif	
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+	struct wowlan_ioctl_param poidparam;
+	struct sta_info	*psta = NULL;
+	int ret = _SUCCESS;
+_func_enter_;
+
+	DBG_871X("==> "FUNC_ADPT_FMT" entry....\n", FUNC_ADPT_ARG(padapter));
+	
+	if (padapter) {
+		pnetdev = padapter->pnetdev;
+		pwrpriv = adapter_to_pwrctl(padapter);
+	} else {
+		pdbgpriv->dbg_resume_error_cnt++;
+		ret = -1;
+		goto exit;
+	}
+
+	if (RTW_CANNOT_RUN(padapter)) {
+		DBG_871X("%s pdapter %p bDriverStopped %s bSurpriseRemoved %s\n"
+				, __func__, padapter
+				, rtw_is_drv_stopped(padapter)?"True":"False"
+				, rtw_is_surprise_removed(padapter)?"True":"False");
+		goto exit;
+	}
+
+#ifdef CONFIG_PNO_SUPPORT
+	pwrpriv->pno_in_resume = _TRUE;
+#ifdef CONFIG_FWLPS_IN_IPS
+	if(pwrpriv->wowlan_pno_enable)
+		rtw_set_fw_in_ips_mode(padapter, _FALSE);
+#endif //CONFIG_FWLPS_IN_IPS
+#endif//CONFIG_PNO_SUPPORT
+
+	if (pwrpriv->wowlan_mode == _TRUE){
+#ifdef CONFIG_LPS
+		rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0, "WOWLAN");
+#endif //CONFIG_LPS
+
+		pwrpriv->bFwCurrentInPSMode = _FALSE;
+
+#ifdef CONFIG_SDIO_HCI
+		if (padapter->intf_stop) {
+			padapter->intf_stop(padapter);
+		}
+
+		#ifdef CONFIG_CONCURRENT_MODE
+		if (rtw_buddy_adapter_up(padapter)) { //free buddy adapter's resource
+			padapter->pbuddy_adapter->intf_stop(padapter->pbuddy_adapter);
+		}
+		#endif
+
+		rtw_hal_clear_interrupt(padapter);
+#endif //CONFIG_SDIO_HCI
+
+		//if (sdio_alloc_irq(adapter_to_dvobj(padapter)) != _SUCCESS) {		
+		if((padapter->intf_alloc_irq) && (padapter->intf_alloc_irq(adapter_to_dvobj(padapter)) != _SUCCESS)){
+			ret = -1;
+			RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("%s: sdio_alloc_irq Failed!!\n", __FUNCTION__));
+			goto exit;
+		}
+
+		//Disable WOW, set H2C command
+		poidparam.subcode=WOWLAN_DISABLE;
+		rtw_hal_set_hwreg(padapter,HW_VAR_WOWLAN,(u8 *)&poidparam);
+
+		#ifdef CONFIG_CONCURRENT_MODE
+		rtw_reset_drv_sw(padapter->pbuddy_adapter);
+		#endif		
+
+		psta = rtw_get_stainfo(&padapter->stapriv, get_bssid(&padapter->mlmepriv));
+		if (psta) {
+			set_sta_rate(padapter, psta);
+		}
+
+	
+		rtw_clr_drv_stopped(padapter);
+		DBG_871X("%s: wowmode resuming, DriverStopped:%s\n", __func__, rtw_is_drv_stopped(padapter)?"True":"False");
+		rtw_start_drv_threads(padapter);
+
+#ifdef CONFIG_CONCURRENT_MODE
+		if (padapter->pbuddy_adapter)
+			rtw_start_drv_threads(padapter->pbuddy_adapter);
+#endif /* CONFIG_CONCURRENT_MODE*/
+
+		if (padapter->intf_start) {
+			padapter->intf_start(padapter);
+		}
+		#ifdef CONFIG_CONCURRENT_MODE
+		if (rtw_buddy_adapter_up(padapter)) { //free buddy adapter's resource
+			padapter->pbuddy_adapter->intf_start(padapter->pbuddy_adapter);
+		}
+
+		if (rtw_buddy_adapter_up(padapter)) {
+			pbuddy_netdev = padapter->pbuddy_adapter->pnetdev;
+
+			if(pbuddy_netdev){
+				netif_device_attach(pbuddy_netdev);
+				netif_carrier_on(pbuddy_netdev);
+			}
+		}
+		#endif
+
+		// start netif queue
+		if (pnetdev) {
+			rtw_netif_wake_queue(pnetdev);
+		}
+	}
+	else{
+
+		DBG_871X_LEVEL(_drv_always_, "%s: ### ERROR ### wowlan_mode=%d\n", __FUNCTION__, pwrpriv->wowlan_mode);		
+	} 
+
+	if( padapter->pid[1]!=0) {
+		DBG_871X("pid[1]:%d\n",padapter->pid[1]);
+		rtw_signal_process(padapter->pid[1], SIGUSR2);
+	}	
+
+	if (rtw_chk_roam_flags(padapter, RTW_ROAM_ON_RESUME)) {
+		if (pwrpriv->wowlan_wake_reason == FWDecisionDisconnect ||
+			pwrpriv->wowlan_wake_reason == Rx_DisAssoc ||
+			pwrpriv->wowlan_wake_reason == Rx_DeAuth) {
+
+			DBG_871X("%s: disconnect reason: %02x\n", __func__,
+						pwrpriv->wowlan_wake_reason);
+			rtw_indicate_disconnect(padapter);
+
+			rtw_sta_media_status_rpt(padapter,
+				rtw_get_stainfo(&padapter->stapriv,
+					get_bssid(&padapter->mlmepriv)), 0);
+
+			rtw_free_assoc_resources(padapter, 1);
+			pmlmeinfo->state = WIFI_FW_NULL_STATE;
+
+		} else {
+			DBG_871X("%s: do roaming\n", __func__);
+			rtw_roaming(padapter, NULL);
+		}
+	}
+
+	if (pwrpriv->wowlan_wake_reason == FWDecisionDisconnect) {
+		rtw_lock_ext_suspend_timeout(2000);
+	}
+
+	if (pwrpriv->wowlan_wake_reason == Rx_GTK ||
+		pwrpriv->wowlan_wake_reason == Rx_DisAssoc ||
+		pwrpriv->wowlan_wake_reason == Rx_DeAuth) {
+		rtw_lock_ext_suspend_timeout(8000);
+	}
+
+	if (pwrpriv->wowlan_wake_reason == RX_PNOWakeUp) {
+#ifdef CONFIG_IOCTL_CFG80211	
+		cfg80211_disconnected(padapter->pnetdev, 0, NULL, 0,
+				GFP_ATOMIC);
+#endif
+		rtw_lock_ext_suspend_timeout(10000);
+	}
+
+	if (pwrpriv->wowlan_mode == _TRUE) {
+		pwrpriv->bips_processing = _FALSE;
+		_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
+#ifndef CONFIG_IPS_CHECK_IN_WD
+		rtw_set_pwr_state_check_timer(pwrpriv);
+#endif
+	} else {
+		DBG_871X_LEVEL(_drv_always_, "do not reset timer\n");
+	}
+
+	pwrpriv->wowlan_mode =_FALSE;
+
+	// Power On LED
+	rtw_hal_sw_led_init(padapter);
+	if(pwrpriv->wowlan_wake_reason == Rx_DisAssoc ||
+		pwrpriv->wowlan_wake_reason == Rx_DeAuth ||
+		pwrpriv->wowlan_wake_reason == FWDecisionDisconnect)
+		rtw_led_control(padapter, LED_CTL_NO_LINK);
+	else
+		rtw_led_control(padapter, LED_CTL_LINK);
+
+	//clean driver side wake up reason.
+	pwrpriv->wowlan_wake_reason = 0;
+
+exit:
+	DBG_871X("<== "FUNC_ADPT_FMT" exit....\n", FUNC_ADPT_ARG(padapter));
+_func_exit_;
+	return ret;
+}
+#endif //#ifdef CONFIG_WOWLAN
+
+#ifdef CONFIG_AP_WOWLAN
+int rtw_resume_process_ap_wow(_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct net_device *pnetdev = padapter->pnetdev;
+	#ifdef CONFIG_CONCURRENT_MODE
+	struct net_device *pbuddy_netdev;	
+	#endif	
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+	struct wowlan_ioctl_param poidparam;
+	struct sta_info	*psta = NULL;
+	int ret = _SUCCESS;
+	u8 ch, bw, offset;
+_func_enter_;
+
+	DBG_871X("==> "FUNC_ADPT_FMT" entry....\n", FUNC_ADPT_ARG(padapter));
+	
+	if (padapter) {
+		pnetdev = padapter->pnetdev;
+		pwrpriv = adapter_to_pwrctl(padapter);
+	} else {
+		pdbgpriv->dbg_resume_error_cnt++;
+		ret = -1;
+		goto exit;
+	}
+
+
+#ifdef CONFIG_LPS
+	rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0, "AP-WOWLAN");
+#endif //CONFIG_LPS
+
+	pwrpriv->bFwCurrentInPSMode = _FALSE;
+
+	rtw_hal_disable_interrupt(padapter);
+
+	rtw_hal_clear_interrupt(padapter);
+		
+	//if (sdio_alloc_irq(adapter_to_dvobj(padapter)) != _SUCCESS) {		
+	if((padapter->intf_alloc_irq) && (padapter->intf_alloc_irq(adapter_to_dvobj(padapter)) != _SUCCESS)){
+		ret = -1;
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("%s: sdio_alloc_irq Failed!!\n", __FUNCTION__));
+		goto exit;
+	}
+
+	//Disable WOW, set H2C command
+	poidparam.subcode = WOWLAN_AP_DISABLE;
+	rtw_hal_set_hwreg(padapter, HW_VAR_WOWLAN, (u8 *)&poidparam);
+	pwrpriv->wowlan_ap_mode = _FALSE;
+
+	rtw_clr_drv_stopped(padapter);
+	DBG_871X("%s: wowmode resuming, DriverStopped:%s\n", __func__, rtw_is_drv_stopped(padapter)?"True":"False");
+	rtw_start_drv_threads(padapter);
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (rtw_buddy_adapter_up(padapter))
+		rtw_start_drv_threads(padapter->pbuddy_adapter);
+#endif /* CONFIG_CONCURRENT_MODE */
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (rtw_buddy_adapter_up(padapter)) {
+		if (rtw_get_ch_setting_union(padapter->pbuddy_adapter, &ch, &bw, &offset) != 0) {
+			DBG_871X(FUNC_ADPT_FMT" back to linked/linking union - ch:%u, bw:%u, offset:%u\n",
+			FUNC_ADPT_ARG(padapter->pbuddy_adapter), ch, bw, offset);
+			set_channel_bwmode(padapter->pbuddy_adapter, ch, offset, bw);
+		}
+	} else {
+		DBG_871X(FUNC_ADPT_FMT" back to linked/linking union - ch:%u, bw:%u, offset:%u\n",
+			FUNC_ADPT_ARG(padapter), ch, bw, offset);
+		set_channel_bwmode(padapter, ch, offset, bw);
+		rtw_reset_drv_sw(padapter->pbuddy_adapter);
+	}
+#else
+	if (rtw_get_ch_setting_union(padapter, &ch, &bw, &offset) != 0) {
+		DBG_871X(FUNC_ADPT_FMT" back to linked/linking union - ch:%u, bw:%u, offset:%u\n",
+			FUNC_ADPT_ARG(padapter), ch, bw, offset);
+		set_channel_bwmode(padapter, ch, offset, bw);
+	}
+#endif
+
+	if (padapter->intf_start) {
+		padapter->intf_start(padapter);
+	}
+
+	#ifdef CONFIG_CONCURRENT_MODE
+	if (rtw_buddy_adapter_up(padapter)) { //free buddy adapter's resource
+		padapter->pbuddy_adapter->intf_start(padapter->pbuddy_adapter);
+	}
+	#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (rtw_buddy_adapter_up(padapter)) {			
+		pbuddy_netdev = padapter->pbuddy_adapter->pnetdev;			
+		if(pbuddy_netdev){
+			rtw_netif_wake_queue(pbuddy_netdev);
+		}
+	}
+#endif
+	
+	// start netif queue
+	if (pnetdev) {
+		rtw_netif_wake_queue(pnetdev);
+	}
+
+	if( padapter->pid[1]!=0) {
+		DBG_871X("pid[1]:%d\n",padapter->pid[1]);
+		rtw_signal_process(padapter->pid[1], SIGUSR2);
+	}	
+
+	#ifdef CONFIG_RESUME_IN_WORKQUEUE
+	//rtw_unlock_suspend();
+	#endif //CONFIG_RESUME_IN_WORKQUEUE
+
+	if (pwrpriv->wowlan_wake_reason == AP_WakeUp)
+		rtw_lock_ext_suspend_timeout(8000);
+
+	pwrpriv->bips_processing = _FALSE;
+	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
+#ifndef CONFIG_IPS_CHECK_IN_WD
+	rtw_set_pwr_state_check_timer(pwrpriv);
+#endif
+	//clean driver side wake up reason.
+	pwrpriv->wowlan_wake_reason = 0;
+
+	// Power On LED
+	rtw_hal_sw_led_init(padapter);
+	rtw_led_control(padapter, LED_CTL_LINK);
+exit:
+	DBG_871X("<== "FUNC_ADPT_FMT" exit....\n", FUNC_ADPT_ARG(padapter));
+_func_exit_;
+	return ret;
+}
+#endif //#ifdef CONFIG_APWOWLAN
+
+int rtw_resume_process_normal(_adapter *padapter)
+{
+	struct net_device *pnetdev;
+	#ifdef CONFIG_CONCURRENT_MODE
+	struct net_device *pbuddy_netdev;	
+	#endif	
+	struct pwrctrl_priv *pwrpriv;
+	struct mlme_priv *pmlmepriv;
+	struct dvobj_priv *psdpriv;
+	struct debug_priv *pdbgpriv;	
+	
+	int ret = _SUCCESS;
+_func_enter_;
+	
+	if (!padapter) {
+		ret = -1;
+		goto exit;
+	}
+	
+	pnetdev = padapter->pnetdev;
+	pwrpriv = adapter_to_pwrctl(padapter);
+	pmlmepriv = &padapter->mlmepriv;	
+	psdpriv = padapter->dvobj;
+	pdbgpriv = &psdpriv->drv_dbg;
+	
+	DBG_871X("==> "FUNC_ADPT_FMT" entry....\n", FUNC_ADPT_ARG(padapter));
+	// interface init
+	//if (sdio_init(adapter_to_dvobj(padapter)) != _SUCCESS)
+	if((padapter->intf_init)&& (padapter->intf_init(adapter_to_dvobj(padapter)) != _SUCCESS))
+	{
+		ret = -1;
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("%s: initialize SDIO Failed!!\n", __FUNCTION__));
+		goto exit;
+	}
+	rtw_hal_disable_interrupt(padapter);
+	//if (sdio_alloc_irq(adapter_to_dvobj(padapter)) != _SUCCESS)
+	if ((padapter->intf_alloc_irq)&&(padapter->intf_alloc_irq(adapter_to_dvobj(padapter)) != _SUCCESS))
+	{
+		ret = -1;
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("%s: sdio_alloc_irq Failed!!\n", __FUNCTION__));
+		goto exit;
+	}
+
+	rtw_reset_drv_sw(padapter);
+	#ifdef CONFIG_CONCURRENT_MODE
+	rtw_reset_drv_sw(padapter->pbuddy_adapter);
+	#endif
+	
+	pwrpriv->bkeepfwalive = _FALSE;
+
+	DBG_871X("bkeepfwalive(%x)\n",pwrpriv->bkeepfwalive);
+	if(pm_netdev_open(pnetdev,_TRUE) != 0) {
+		ret = -1;
+		pdbgpriv->dbg_resume_error_cnt++;
+		goto exit;
+	}
+
+	netif_device_attach(pnetdev);
+	netif_carrier_on(pnetdev);
+
+	#ifdef CONFIG_CONCURRENT_MODE
+	if(rtw_buddy_adapter_up(padapter)){			
+		pbuddy_netdev = padapter->pbuddy_adapter->pnetdev;				
+		
+		netif_device_attach(pbuddy_netdev);
+		netif_carrier_on(pbuddy_netdev);	
+	}
+	#endif
+	
+
+	if( padapter->pid[1]!=0) {
+		DBG_871X("pid[1]:%d\n",padapter->pid[1]);
+		rtw_signal_process(padapter->pid[1], SIGUSR2);
+	}	
+
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+		DBG_871X(FUNC_ADPT_FMT" fwstate:0x%08x - WIFI_STATION_STATE\n", FUNC_ADPT_ARG(padapter), get_fwstate(pmlmepriv));
+
+		if (rtw_chk_roam_flags(padapter, RTW_ROAM_ON_RESUME))
+			rtw_roaming(padapter, NULL);
+		
+	} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		DBG_871X(FUNC_ADPT_FMT" fwstate:0x%08x - WIFI_AP_STATE\n", FUNC_ADPT_ARG(padapter), get_fwstate(pmlmepriv));
+		rtw_ap_restore_network(padapter);
+	} else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {
+		DBG_871X(FUNC_ADPT_FMT" fwstate:0x%08x - WIFI_ADHOC_STATE\n", FUNC_ADPT_ARG(padapter), get_fwstate(pmlmepriv));
+	} else {
+		DBG_871X(FUNC_ADPT_FMT" fwstate:0x%08x - ???\n", FUNC_ADPT_ARG(padapter), get_fwstate(pmlmepriv));
+	}
+
+	#ifdef CONFIG_CONCURRENT_MODE
+	if(rtw_buddy_adapter_up(padapter))
+	{	
+		_adapter *buddy = padapter->pbuddy_adapter;
+		struct mlme_priv *buddy_mlme = &padapter->pbuddy_adapter->mlmepriv;
+		if (check_fwstate(buddy_mlme, WIFI_STATION_STATE)) {
+			DBG_871X(FUNC_ADPT_FMT" fwstate:0x%08x - WIFI_STATION_STATE\n", FUNC_ADPT_ARG(buddy), get_fwstate(buddy_mlme));
+
+			if (rtw_chk_roam_flags(buddy, RTW_ROAM_ON_RESUME))
+				rtw_roaming(buddy, NULL);
+		
+		} else if (check_fwstate(buddy_mlme, WIFI_AP_STATE)) {
+			DBG_871X(FUNC_ADPT_FMT" fwstate:0x%08x - WIFI_AP_STATE\n", FUNC_ADPT_ARG(buddy), get_fwstate(buddy_mlme));
+			rtw_ap_restore_network(buddy);
+		} else if (check_fwstate(buddy_mlme, WIFI_ADHOC_STATE)) {
+			DBG_871X(FUNC_ADPT_FMT" fwstate:0x%08x - WIFI_ADHOC_STATE\n", FUNC_ADPT_ARG(buddy), get_fwstate(buddy_mlme));
+		} else {
+			DBG_871X(FUNC_ADPT_FMT" fwstate:0x%08x - ???\n", FUNC_ADPT_ARG(buddy), get_fwstate(buddy_mlme));
+		}
+	}
+	#endif
+
+#ifdef CONFIG_RESUME_IN_WORKQUEUE
+	//rtw_unlock_suspend();
+#endif //CONFIG_RESUME_IN_WORKQUEUE
+	DBG_871X("<== "FUNC_ADPT_FMT" exit....\n", FUNC_ADPT_ARG(padapter));
+
+exit:	
+_func_exit_;
+	return ret;	
+}
+
+int rtw_resume_common(_adapter *padapter)
+{
+	int ret = 0;
+	u32 start_time = rtw_get_current_time();
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	
+	_func_enter_;
+
+	if (pwrpriv->bInSuspend == _FALSE)
+		return 0;
+
+	DBG_871X_LEVEL(_drv_always_, "resume start\n");
+	DBG_871X("==> %s (%s:%d)\n",__FUNCTION__, current->comm, current->pid);	
+
+	if (check_fwstate(pmlmepriv,WIFI_STATION_STATE) == _TRUE
+#ifdef CONFIG_CONCURRENT_MODE
+		&& check_buddy_fwstate(padapter, WIFI_AP_STATE) == _FALSE
+#endif
+	) {
+	#ifdef CONFIG_WOWLAN
+		if (pwrpriv->wowlan_mode == _TRUE)
+			rtw_resume_process_wow(padapter);
+		else
+			rtw_resume_process_normal(padapter);
+	#else
+		rtw_resume_process_normal(padapter);
+	#endif
+
+	} else if (check_fwstate(pmlmepriv,WIFI_AP_STATE) == _TRUE
+#ifdef CONFIG_CONCURRENT_MODE
+		&& check_buddy_fwstate(padapter, WIFI_AP_STATE) == _FALSE
+#endif
+	) {
+	#ifdef CONFIG_AP_WOWLAN
+		rtw_resume_process_ap_wow(padapter);
+	#else
+		rtw_resume_process_normal(padapter);
+	#endif //CONFIG_AP_WOWLAN
+#ifdef CONFIG_CONCURRENT_MODE
+	} else if (check_fwstate(pmlmepriv,WIFI_STATION_STATE) == _TRUE
+		&& check_buddy_fwstate(padapter, WIFI_AP_STATE) == _TRUE) {
+	#ifdef CONFIG_AP_WOWLAN
+		rtw_resume_process_ap_wow(padapter);
+	#else
+		rtw_resume_process_normal(padapter);
+	#endif //CONFIG_AP_WOWLAN
+#endif
+	} else {
+		rtw_resume_process_normal(padapter);
+	}
+
+	#ifdef CONFIG_BT_COEXIST
+	rtw_btcoex_SuspendNotify(padapter, 0);
+	#endif // CONFIG_BT_COEXIST
+
+	if (pwrpriv) {
+		pwrpriv->bInSuspend = _FALSE;
+	#ifdef CONFIG_PNO_SUPPORT
+		pwrpriv->pno_in_resume = _FALSE;
+	#endif
+	}
+	DBG_871X_LEVEL(_drv_always_, "%s:%d in %d ms\n", __FUNCTION__ ,ret,
+		rtw_get_passing_time_ms(start_time));
+
+	_func_exit_;
+	
+	return ret;
+}
+
+#ifdef CONFIG_GPIO_API
+u8 rtw_get_gpio(struct net_device *netdev, u8 gpio_num)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);
+	return rtw_hal_get_gpio(adapter, gpio_num);
+}
+EXPORT_SYMBOL(rtw_get_gpio);
+
+int  rtw_set_gpio_output_value(struct net_device *netdev, u8 gpio_num, bool isHigh)
+{
+	u8 direction = 0;
+	u8 res = -1;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);
+	return rtw_hal_set_gpio_output_value(adapter, gpio_num,isHigh);
+}
+EXPORT_SYMBOL(rtw_set_gpio_output_value);
+
+int rtw_config_gpio(struct net_device *netdev, u8 gpio_num, bool isOutput)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);	
+	return rtw_hal_config_gpio(adapter,gpio_num,isOutput);	
+}
+EXPORT_SYMBOL(rtw_config_gpio);
+int rtw_register_gpio_interrupt(struct net_device *netdev, int gpio_num, void(*callback)(u8 level))
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);
+	return rtw_hal_register_gpio_interrupt(adapter,gpio_num,callback);
+}
+EXPORT_SYMBOL(rtw_register_gpio_interrupt);
+
+int rtw_disable_gpio_interrupt(struct net_device *netdev, int gpio_num)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);
+	return rtw_hal_disable_gpio_interrupt(adapter,gpio_num);
+}
+EXPORT_SYMBOL(rtw_disable_gpio_interrupt);
+
+#endif //#ifdef CONFIG_GPIO_API 
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/recv_linux.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/recv_linux.c
new file mode 100644
index 000000000..3d6b97484
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/recv_linux.c
@@ -0,0 +1,807 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RECV_OSDEP_C_
+
+#include <drv_types.h>
+
+int rtw_os_alloc_recvframe(_adapter *padapter, union recv_frame *precvframe, u8 *pdata, _pkt *pskb)
+{
+	int res = _SUCCESS;
+	u8	shift_sz = 0;
+	u32	skb_len, alloc_sz;
+	_pkt	 *pkt_copy = NULL;	
+	struct rx_pkt_attrib *pattrib = &precvframe->u.hdr.attrib;
+
+
+	if(pdata == NULL)
+	{		
+		precvframe->u.hdr.pkt = NULL;
+		res = _FAIL;
+		return res;
+	}	
+
+
+	//	Modified by Albert 20101213
+	//	For 8 bytes IP header alignment.
+	shift_sz = pattrib->qos ? 6:0;//	Qos data, wireless lan header length is 26
+
+	skb_len = pattrib->pkt_len;
+
+	// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
+	// modify alloc_sz for recvive crc error packet by thomas 2011-06-02
+	if((pattrib->mfrag == 1)&&(pattrib->frag_num == 0))
+	{
+		//alloc_sz = 1664;	//1664 is 128 alignment.
+		alloc_sz = (skb_len <= 1650) ? 1664:(skb_len + 14);		
+	}
+	else 
+	{
+		alloc_sz = skb_len;
+		//	6 is for IP header 8 bytes alignment in QoS packet case.
+		//	8 is for skb->data 4 bytes alignment.
+		alloc_sz += 14;
+	}	
+
+	pkt_copy = rtw_skb_alloc(alloc_sz);
+
+	if(pkt_copy)
+	{
+		pkt_copy->dev = padapter->pnetdev;
+		precvframe->u.hdr.pkt = pkt_copy;
+		precvframe->u.hdr.rx_head = pkt_copy->data;
+		precvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;
+		skb_reserve(pkt_copy, 8 - ((SIZE_PTR)( pkt_copy->data) & 7 ));//force pkt_copy->data at 8-byte alignment address
+		skb_reserve(pkt_copy, shift_sz);//force ip_hdr at 8-byte alignment address according to shift_sz.
+		_rtw_memcpy(pkt_copy->data, pdata, skb_len);
+		precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
+	}
+	else
+	{
+#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
+		DBG_871X("%s:can not allocate memory for skb copy\n", __FUNCTION__);
+
+		precvframe->u.hdr.pkt = NULL;
+
+		//rtw_free_recvframe(precvframe, pfree_recv_queue);
+		//goto _exit_recvbuf2recvframe;
+
+		res = _FAIL;	
+#else
+		if((pattrib->mfrag == 1)&&(pattrib->frag_num == 0))
+		{				
+			DBG_871X("%s: alloc_skb fail , drop frag frame \n", __FUNCTION__);
+			//rtw_free_recvframe(precvframe, pfree_recv_queue);
+			res = _FAIL;
+			goto exit_rtw_os_recv_resource_alloc;
+		}
+
+		if(pskb == NULL)
+		{
+			res = _FAIL;
+			goto exit_rtw_os_recv_resource_alloc;
+		}
+			
+		precvframe->u.hdr.pkt = rtw_skb_clone(pskb);
+		if(precvframe->u.hdr.pkt)
+		{
+			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pdata;
+			precvframe->u.hdr.rx_end =  pdata + alloc_sz;
+		}
+		else
+		{
+			DBG_871X("%s: rtw_skb_clone fail\n", __FUNCTION__);
+			//rtw_free_recvframe(precvframe, pfree_recv_queue);
+			//goto _exit_recvbuf2recvframe;
+			res = _FAIL;
+		}
+#endif			
+	}		
+
+exit_rtw_os_recv_resource_alloc:
+
+	return res;
+
+}
+
+void rtw_os_free_recvframe(union recv_frame *precvframe)
+{
+	if(precvframe->u.hdr.pkt)
+	{
+		rtw_skb_free(precvframe->u.hdr.pkt);//free skb by driver
+
+		precvframe->u.hdr.pkt = NULL;
+	}
+}
+
+//init os related resource in struct recv_priv
+int rtw_os_recv_resource_init(struct recv_priv *precvpriv, _adapter *padapter)
+{
+	int	res=_SUCCESS;
+
+	return res;
+}
+
+//alloc os related resource in union recv_frame
+int rtw_os_recv_resource_alloc(_adapter *padapter, union recv_frame *precvframe)
+{
+	int	res=_SUCCESS;
+	
+	precvframe->u.hdr.pkt_newalloc = precvframe->u.hdr.pkt = NULL;
+
+	return res;
+}
+
+//free os related resource in union recv_frame
+void rtw_os_recv_resource_free(struct recv_priv *precvpriv)
+{
+	sint i;
+	union recv_frame *precvframe;
+	precvframe = (union recv_frame*) precvpriv->precv_frame_buf;
+
+	for(i=0; i < NR_RECVFRAME; i++)
+	{
+		if(precvframe->u.hdr.pkt)
+		{
+			rtw_skb_free(precvframe->u.hdr.pkt);//free skb by driver
+			precvframe->u.hdr.pkt = NULL;
+		}
+		precvframe++;
+	}
+}
+
+//alloc os related resource in struct recv_buf
+int rtw_os_recvbuf_resource_alloc(_adapter *padapter, struct recv_buf *precvbuf)
+{
+	int res=_SUCCESS;
+
+#ifdef CONFIG_USB_HCI
+	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
+	struct usb_device	*pusbd = pdvobjpriv->pusbdev;
+
+	precvbuf->irp_pending = _FALSE;
+	precvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);
+	if(precvbuf->purb == NULL){
+		res = _FAIL;
+	}
+
+	precvbuf->pskb = NULL;
+
+	precvbuf->pallocated_buf  = precvbuf->pbuf = NULL;
+
+	precvbuf->pdata = precvbuf->phead = precvbuf->ptail = precvbuf->pend = NULL;
+
+	precvbuf->transfer_len = 0;
+
+	precvbuf->len = 0;
+
+	#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
+	precvbuf->pallocated_buf = rtw_usb_buffer_alloc(pusbd, (size_t)precvbuf->alloc_sz, &precvbuf->dma_transfer_addr);
+	precvbuf->pbuf = precvbuf->pallocated_buf;
+	if(precvbuf->pallocated_buf == NULL)
+		return _FAIL;
+	#endif //CONFIG_USE_USB_BUFFER_ALLOC_RX
+	
+#endif //CONFIG_USB_HCI
+
+	return res;
+}
+
+//free os related resource in struct recv_buf
+int rtw_os_recvbuf_resource_free(_adapter *padapter, struct recv_buf *precvbuf)
+{
+	int ret = _SUCCESS;
+
+#ifdef CONFIG_USB_HCI
+
+#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
+
+	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
+	struct usb_device	*pusbd = pdvobjpriv->pusbdev;
+
+	rtw_usb_buffer_free(pusbd, (size_t)precvbuf->alloc_sz, precvbuf->pallocated_buf, precvbuf->dma_transfer_addr);
+	precvbuf->pallocated_buf =  NULL;
+	precvbuf->dma_transfer_addr = 0;
+
+#endif //CONFIG_USE_USB_BUFFER_ALLOC_RX
+
+	if(precvbuf->purb)
+	{
+		//usb_kill_urb(precvbuf->purb);
+		usb_free_urb(precvbuf->purb);
+	}
+
+#endif //CONFIG_USB_HCI
+
+
+	if(precvbuf->pskb)
+	{
+#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
+		if(rtw_free_skb_premem(precvbuf->pskb)!=0)
+#endif
+		rtw_skb_free(precvbuf->pskb);
+	}
+	return ret;
+
+}
+
+_pkt *rtw_os_alloc_msdu_pkt(union recv_frame *prframe, u16 nSubframe_Length, u8 *pdata)
+{
+	u16	eth_type;
+	u8	*data_ptr;
+	_pkt *sub_skb;
+	struct rx_pkt_attrib *pattrib;
+
+	pattrib = &prframe->u.hdr.attrib;
+
+#ifdef CONFIG_SKB_COPY
+	sub_skb = rtw_skb_alloc(nSubframe_Length + 12);
+	if(sub_skb)
+	{
+		skb_reserve(sub_skb, 12);
+		data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
+		_rtw_memcpy(data_ptr, (pdata + ETH_HLEN), nSubframe_Length);
+	}
+	else
+#endif // CONFIG_SKB_COPY
+	{
+		sub_skb = rtw_skb_clone(prframe->u.hdr.pkt);
+		if(sub_skb)
+		{
+			sub_skb->data = pdata + ETH_HLEN;
+			sub_skb->len = nSubframe_Length;
+			skb_set_tail_pointer(sub_skb, nSubframe_Length);
+		}
+		else
+		{
+			DBG_871X("%s(): rtw_skb_clone() Fail!!!\n",__FUNCTION__);
+			return NULL;
+		}
+	}
+
+	eth_type = RTW_GET_BE16(&sub_skb->data[6]);
+
+	if (sub_skb->len >= 8 &&
+		((_rtw_memcmp(sub_skb->data, rtw_rfc1042_header, SNAP_SIZE) &&
+		  eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
+		 _rtw_memcmp(sub_skb->data, rtw_bridge_tunnel_header, SNAP_SIZE) )) {
+		/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
+		skb_pull(sub_skb, SNAP_SIZE);
+		_rtw_memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src, ETH_ALEN);
+		_rtw_memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst, ETH_ALEN);
+	} else {
+		u16 len;
+		/* Leave Ethernet header part of hdr and full payload */
+		len = htons(sub_skb->len);
+		_rtw_memcpy(skb_push(sub_skb, 2), &len, 2);
+		_rtw_memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src, ETH_ALEN);
+		_rtw_memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst, ETH_ALEN);
+	}
+
+	return sub_skb;
+}
+
+#ifdef DBG_UDP_PKT_LOSE_11AC
+#define PAYLOAD_LEN_LOC_OF_IP_HDR 0x10 /*ethernet payload length location of ip header (DA+SA+eth_type+(version&hdr_len)) */	
+#endif
+
+void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attrib *pattrib)
+{
+	struct mlme_priv*pmlmepriv = &padapter->mlmepriv;
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+#ifdef CONFIG_BR_EXT
+	void *br_port = NULL;
+#endif
+	int ret;
+
+	/* Indicat the packets to upper layer */
+	if (pkt) {
+		if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+		{
+		 	_pkt *pskb2=NULL;
+		 	struct sta_info *psta = NULL;
+		 	struct sta_priv *pstapriv = &padapter->stapriv;
+			int bmcast = IS_MCAST(pattrib->dst);
+
+			//DBG_871X("bmcast=%d\n", bmcast);
+
+			if (_rtw_memcmp(pattrib->dst, adapter_mac_addr(padapter), ETH_ALEN) == _FALSE)
+			{
+				//DBG_871X("not ap psta=%p, addr=%pM\n", psta, pattrib->dst);
+
+				if(bmcast)
+				{
+					psta = rtw_get_bcmc_stainfo(padapter);
+					pskb2 = rtw_skb_clone(pkt);
+				} else {
+					psta = rtw_get_stainfo(pstapriv, pattrib->dst);
+				}
+
+				if(psta)
+				{
+					struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;			
+
+					//DBG_871X("directly forwarding to the rtw_xmit_entry\n");
+
+					//skb->ip_summed = CHECKSUM_NONE;
+					pkt->dev = pnetdev;				
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+					skb_set_queue_mapping(pkt, rtw_recv_select_queue(pkt));
+#endif //LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35)
+
+					_rtw_xmit_entry(pkt, pnetdev);
+
+					if(bmcast && (pskb2 != NULL) ) {
+						pkt = pskb2;
+						DBG_COUNTER(padapter->rx_logs.os_indicate_ap_mcast);
+					} else {
+						DBG_COUNTER(padapter->rx_logs.os_indicate_ap_forward);
+						return;
+					}
+				}
+			}
+			else// to APself
+			{
+				//DBG_871X("to APSelf\n");
+				DBG_COUNTER(padapter->rx_logs.os_indicate_ap_self);
+			}
+		}
+		
+#ifdef CONFIG_BR_EXT
+		// Insert NAT2.5 RX here!
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+		br_port = padapter->pnetdev->br_port;
+#else   // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+		rcu_read_lock();
+		br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
+		rcu_read_unlock();
+#endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+
+
+		if( br_port && (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == _TRUE) )
+		{
+			int nat25_handle_frame(_adapter *priv, struct sk_buff *skb);
+			if (nat25_handle_frame(padapter, pkt) == -1) {
+				//priv->ext_stats.rx_data_drops++;
+				//DEBUG_ERR("RX DROP: nat25_handle_frame fail!\n");
+				//return FAIL;
+				
+#if 1
+				// bypass this frame to upper layer!!
+#else
+				rtw_skb_free(sub_skb);
+				continue;
+#endif
+			}							
+		}
+#endif	// CONFIG_BR_EXT
+		if( precvpriv->sink_udpport > 0)
+			rtw_sink_rtp_seq_dbg(padapter,pkt);
+#ifdef DBG_UDP_PKT_LOSE_11AC
+		/* After eth_type_trans process , pkt->data pointer will move from ethrnet header to ip header ,  
+		*	we have to check ethernet type , so this debug must be print before eth_type_trans
+		*/
+		if (*((unsigned short *)(pkt->data+ETH_ALEN*2)) == htons(ETH_P_ARP)) {
+			/* ARP Payload length will be 42bytes or 42+18(tailer)=60bytes*/
+			if (pkt->len != 42 && pkt->len != 60) 
+				DBG_871X("Error !!%s,ARP Payload length %u not correct\n" , __func__ , pkt->len);
+		} else if (*((unsigned short *)(pkt->data+ETH_ALEN*2)) == htons(ETH_P_IP)) { 
+			if (be16_to_cpu(*((u16 *)(pkt->data+PAYLOAD_LEN_LOC_OF_IP_HDR))) != (pkt->len)-ETH_HLEN) {
+				DBG_871X("Error !!%s,Payload length not correct\n" , __func__);
+				DBG_871X("%s, IP header describe Total length=%u\n" , __func__ , be16_to_cpu(*((u16 *)(pkt->data+PAYLOAD_LEN_LOC_OF_IP_HDR))));
+				DBG_871X("%s, Pkt real length=%u\n" , __func__ , (pkt->len)-ETH_HLEN);
+			} 
+		}
+#endif
+		/* After eth_type_trans process , pkt->data pointer will move from ethrnet header to ip header */
+		pkt->protocol = eth_type_trans(pkt, padapter->pnetdev);
+		pkt->dev = padapter->pnetdev;
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
+		if ( (pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1) ) {
+			pkt->ip_summed = CHECKSUM_UNNECESSARY;
+		} else {
+			pkt->ip_summed = CHECKSUM_NONE;
+		}
+#else /* !CONFIG_TCP_CSUM_OFFLOAD_RX */
+		pkt->ip_summed = CHECKSUM_NONE;
+#endif //CONFIG_TCP_CSUM_OFFLOAD_RX
+
+		ret = rtw_netif_rx(padapter->pnetdev, pkt);
+		if (ret == NET_RX_SUCCESS)
+			DBG_COUNTER(padapter->rx_logs.os_netif_ok);
+		else
+			DBG_COUNTER(padapter->rx_logs.os_netif_err);
+	}
+}
+
+void rtw_handle_tkip_mic_err(_adapter *padapter, struct sta_info *sta, u8 bgroup)
+{
+#ifdef CONFIG_IOCTL_CFG80211
+	enum nl80211_key_type key_type = 0;
+#endif
+	union iwreq_data wrqu;
+	struct iw_michaelmicfailure    ev;
+	struct mlme_priv*              pmlmepriv  = &padapter->mlmepriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;	
+	u32 cur_time = 0;
+
+	if( psecuritypriv->last_mic_err_time == 0 )
+	{
+		psecuritypriv->last_mic_err_time = rtw_get_current_time();
+	}
+	else
+	{
+		cur_time = rtw_get_current_time();
+
+		if( cur_time - psecuritypriv->last_mic_err_time < 60*HZ )
+		{
+			psecuritypriv->btkip_countermeasure = _TRUE;
+			psecuritypriv->last_mic_err_time = 0;
+			psecuritypriv->btkip_countermeasure_time = cur_time;
+		}
+		else
+		{
+			psecuritypriv->last_mic_err_time = rtw_get_current_time();
+		}
+	}
+
+#ifdef CONFIG_IOCTL_CFG80211
+	if ( bgroup )
+	{
+		key_type |= NL80211_KEYTYPE_GROUP;
+	}
+	else
+	{
+		key_type |= NL80211_KEYTYPE_PAIRWISE;
+	}
+
+	cfg80211_michael_mic_failure(padapter->pnetdev, sta->hwaddr, key_type, -1, NULL, GFP_ATOMIC);
+#endif
+
+	_rtw_memset( &ev, 0x00, sizeof( ev ) );
+	if ( bgroup )
+	{
+	    ev.flags |= IW_MICFAILURE_GROUP;
+	}
+	else
+	{
+	    ev.flags |= IW_MICFAILURE_PAIRWISE;
+	}
+
+	ev.src_addr.sa_family = ARPHRD_ETHER;
+	_rtw_memcpy(ev.src_addr.sa_data, sta->hwaddr, ETH_ALEN);
+
+	_rtw_memset( &wrqu, 0x00, sizeof( wrqu ) );
+	wrqu.data.length = sizeof( ev );
+
+#ifndef CONFIG_IOCTL_CFG80211
+	wireless_send_event( padapter->pnetdev, IWEVMICHAELMICFAILURE, &wrqu, (char*) &ev );
+#endif
+}
+
+void rtw_hostapd_mlme_rx(_adapter *padapter, union recv_frame *precv_frame)
+{
+#ifdef CONFIG_HOSTAPD_MLME
+	_pkt *skb;
+	struct hostapd_priv *phostapdpriv  = padapter->phostapdpriv;
+	struct net_device *pmgnt_netdev = phostapdpriv->pmgnt_netdev;
+
+	RT_TRACE(_module_recv_osdep_c_, _drv_info_, ("+rtw_hostapd_mlme_rx\n"));
+
+	skb = precv_frame->u.hdr.pkt;
+
+	if (skb == NULL)
+		return;
+
+	skb->data = precv_frame->u.hdr.rx_data;
+	skb->tail = precv_frame->u.hdr.rx_tail;
+	skb->len = precv_frame->u.hdr.len;
+
+	//pskb_copy = rtw_skb_copy(skb);
+//	if(skb == NULL) goto _exit;
+
+	skb->dev = pmgnt_netdev;
+	skb->ip_summed = CHECKSUM_NONE;
+	skb->pkt_type = PACKET_OTHERHOST;
+	//skb->protocol = __constant_htons(0x0019); /*ETH_P_80211_RAW*/
+	skb->protocol = __constant_htons(0x0003); /*ETH_P_80211_RAW*/
+
+	//DBG_871X("(1)data=0x%x, head=0x%x, tail=0x%x, mac_header=0x%x, len=%d\n", skb->data, skb->head, skb->tail, skb->mac_header, skb->len);
+
+	//skb->mac.raw = skb->data;
+	skb_reset_mac_header(skb);
+
+       //skb_pull(skb, 24);
+       _rtw_memset(skb->cb, 0, sizeof(skb->cb));
+
+	rtw_netif_rx(pmgnt_netdev, skb);
+
+	precv_frame->u.hdr.pkt = NULL; // set pointer to NULL before rtw_free_recvframe() if call rtw_netif_rx()
+#endif
+}
+
+#ifdef CONFIG_AUTO_AP_MODE
+static void rtw_os_ksocket_send(_adapter *padapter, union recv_frame *precv_frame)
+{	
+	_pkt *skb = precv_frame->u.hdr.pkt;	
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+	struct sta_info *psta = precv_frame->u.hdr.psta;
+		
+	DBG_871X("eth rx: got eth_type=0x%x\n", pattrib->eth_type);					
+		
+	if (psta && psta->isrc && psta->pid>0)
+	{
+		u16 rx_pid;
+
+		rx_pid = *(u16*)(skb->data+ETH_HLEN);
+			
+		DBG_871X("eth rx(pid=0x%x): sta("MAC_FMT") pid=0x%x\n", 
+			rx_pid, MAC_ARG(psta->hwaddr), psta->pid);
+
+		if(rx_pid == psta->pid)
+		{
+			int i;
+			u16 len = *(u16*)(skb->data+ETH_HLEN+2);
+			//u16 ctrl_type = *(u16*)(skb->data+ETH_HLEN+4);
+
+			//DBG_871X("eth, RC: len=0x%x, ctrl_type=0x%x\n", len, ctrl_type); 
+			DBG_871X("eth, RC: len=0x%x\n", len);
+
+			for(i=0;i<len;i++)
+				DBG_871X("0x%x\n", *(skb->data+ETH_HLEN+4+i));
+				//DBG_871X("0x%x\n", *(skb->data+ETH_HLEN+6+i));
+
+			DBG_871X("eth, RC-end\n"); 
+
+#if 0
+			//send_sz = ksocket_send(padapter->ksock_send, &padapter->kaddr_send, (skb->data+ETH_HLEN+2), len);				
+			rtw_recv_ksocket_send_cmd(padapter, (skb->data+ETH_HLEN+2), len);
+
+			//DBG_871X("ksocket_send size=%d\n", send_sz); 
+#endif			
+		}
+		
+	}		
+
+}
+#endif //CONFIG_AUTO_AP_MODE
+
+int rtw_recv_monitor(_adapter *padapter, union recv_frame *precv_frame)
+{
+	int ret = _FAIL;
+	struct recv_priv *precvpriv;
+	_queue	*pfree_recv_queue;
+	_pkt *skb;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct rx_pkt_attrib *pattrib;
+
+	if (NULL == precv_frame)
+		goto _recv_drop;
+
+	pattrib = &precv_frame->u.hdr.attrib;
+	precvpriv = &(padapter->recvpriv);
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+
+	skb = precv_frame->u.hdr.pkt;
+	if (skb == NULL) {
+		DBG_871X("%s :skb==NULL something wrong!!!!\n", __func__);
+		goto _recv_drop;
+	}
+
+	skb->data = precv_frame->u.hdr.rx_data;
+	skb_set_tail_pointer(skb, precv_frame->u.hdr.len);
+	skb->len = precv_frame->u.hdr.len;
+	skb->ip_summed = CHECKSUM_NONE;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(0x0019); /* ETH_P_80211_RAW */
+
+	rtw_netif_rx(padapter->pnetdev, skb);
+
+	/* pointers to NULL before rtw_free_recvframe() */
+	precv_frame->u.hdr.pkt = NULL;
+
+	ret = _SUCCESS;
+
+_recv_drop:
+
+	/* enqueue back to free_recv_queue */
+	if (precv_frame)
+		rtw_free_recvframe(precv_frame, pfree_recv_queue);
+
+	return ret;
+
+}
+
+int rtw_recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
+{
+	struct recv_priv *precvpriv;
+	_queue	*pfree_recv_queue;
+	_pkt *skb;
+	struct mlme_priv*pmlmepriv = &padapter->mlmepriv;
+	struct rx_pkt_attrib *pattrib;
+	
+	if(NULL == precv_frame)
+		goto _recv_indicatepkt_drop;
+
+	DBG_COUNTER(padapter->rx_logs.os_indicate);
+	pattrib = &precv_frame->u.hdr.attrib;
+	precvpriv = &(padapter->recvpriv);
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+
+#ifdef CONFIG_DRVEXT_MODULE
+	if (drvext_rx_handler(padapter, precv_frame->u.hdr.rx_data, precv_frame->u.hdr.len) == _SUCCESS)
+	{
+		goto _recv_indicatepkt_drop;
+	}
+#endif
+
+#ifdef CONFIG_WAPI_SUPPORT
+	if (rtw_wapi_check_for_drop(padapter,precv_frame))
+	{
+		WAPI_TRACE(WAPI_ERR, "%s(): Rx Reorder Drop case!!\n", __FUNCTION__);
+		goto _recv_indicatepkt_drop;
+	}
+#endif
+
+	skb = precv_frame->u.hdr.pkt;
+	if(skb == NULL)
+	{
+		RT_TRACE(_module_recv_osdep_c_,_drv_err_,("rtw_recv_indicatepkt():skb==NULL something wrong!!!!\n"));
+		goto _recv_indicatepkt_drop;
+	}
+
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("rtw_recv_indicatepkt():skb != NULL !!!\n"));		
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("rtw_recv_indicatepkt():precv_frame->u.hdr.rx_head=%p  precv_frame->hdr.rx_data=%p\n", precv_frame->u.hdr.rx_head, precv_frame->u.hdr.rx_data));
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("precv_frame->hdr.rx_tail=%p precv_frame->u.hdr.rx_end=%p precv_frame->hdr.len=%d \n", precv_frame->u.hdr.rx_tail, precv_frame->u.hdr.rx_end, precv_frame->u.hdr.len));
+
+	skb->data = precv_frame->u.hdr.rx_data;
+
+	skb_set_tail_pointer(skb, precv_frame->u.hdr.len);
+
+	skb->len = precv_frame->u.hdr.len;
+
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n skb->head=%p skb->data=%p skb->tail=%p skb->end=%p skb->len=%d\n", skb->head, skb->data, skb_tail_pointer(skb), skb_end_pointer(skb), skb->len));
+
+	if (pattrib->eth_type == 0x888e)
+		DBG_871X_LEVEL(_drv_always_, "recv eapol packet\n");
+
+#ifdef CONFIG_AUTO_AP_MODE	
+#if 1 //for testing
+#if 1
+	if (0x8899 == pattrib->eth_type)
+	{
+		rtw_os_ksocket_send(padapter, precv_frame);
+
+		//goto _recv_indicatepkt_drop;
+	}
+#else
+	if (0x8899 == pattrib->eth_type)
+	{
+		rtw_auto_ap_mode_rx(padapter, precv_frame);
+		
+		goto _recv_indicatepkt_end;
+	}
+#endif
+#endif
+#endif //CONFIG_AUTO_AP_MODE
+
+	/* TODO: move to core */
+	{
+		_pkt *pkt = skb;
+		struct ethhdr *etherhdr = (struct ethhdr *)pkt->data;
+		struct sta_info *sta = precv_frame->u.hdr.psta;
+
+		if (!sta)
+			goto bypass_session_tracker;
+
+		if (ntohs(etherhdr->h_proto) == ETH_P_IP) {
+			u8 *ip = pkt->data + 14;
+
+			if (GET_IPV4_PROTOCOL(ip) == 0x06  /* TCP */
+				&& rtw_st_ctl_chk_reg_s_proto(&sta->st_ctl, 0x06) == _TRUE
+			) {
+				u8 *tcp = ip + GET_IPV4_IHL(ip) * 4;
+
+				if (rtw_st_ctl_chk_reg_rule(&sta->st_ctl, padapter, IPV4_DST(ip), TCP_DST(tcp), IPV4_SRC(ip), TCP_SRC(tcp)) == _TRUE) {
+					if (GET_TCP_SYN(tcp) && GET_TCP_ACK(tcp)) {
+						session_tracker_add_cmd(padapter, sta
+							, IPV4_DST(ip), TCP_DST(tcp)
+							, IPV4_SRC(ip), TCP_SRC(tcp));
+						if (DBG_SESSION_TRACKER)
+							DBG_871X(FUNC_ADPT_FMT" local:"IP_FMT":"PORT_FMT", remote:"IP_FMT":"PORT_FMT" SYN-ACK\n"
+								, FUNC_ADPT_ARG(padapter)
+								, IP_ARG(IPV4_DST(ip)), PORT_ARG(TCP_DST(tcp))
+								, IP_ARG(IPV4_SRC(ip)), PORT_ARG(TCP_SRC(tcp)));
+					}
+					if (GET_TCP_FIN(tcp)) {
+						session_tracker_del_cmd(padapter, sta
+							, IPV4_DST(ip), TCP_DST(tcp)
+							, IPV4_SRC(ip), TCP_SRC(tcp));
+						if (DBG_SESSION_TRACKER)
+							DBG_871X(FUNC_ADPT_FMT" local:"IP_FMT":"PORT_FMT", remote:"IP_FMT":"PORT_FMT" FIN\n"
+								, FUNC_ADPT_ARG(padapter)
+								, IP_ARG(IPV4_DST(ip)), PORT_ARG(TCP_DST(tcp))
+								, IP_ARG(IPV4_SRC(ip)), PORT_ARG(TCP_SRC(tcp)));
+					}
+				}
+
+			}
+		}
+bypass_session_tracker:
+		;
+	}
+
+	rtw_os_recv_indicate_pkt(padapter, skb, pattrib);
+
+_recv_indicatepkt_end:
+
+	precv_frame->u.hdr.pkt = NULL; // pointers to NULL before rtw_free_recvframe()
+
+	rtw_free_recvframe(precv_frame, pfree_recv_queue);
+
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n rtw_recv_indicatepkt :after rtw_os_recv_indicate_pkt!!!!\n"));
+
+
+        return _SUCCESS;
+
+_recv_indicatepkt_drop:
+
+	 //enqueue back to free_recv_queue
+	 if(precv_frame)
+		 rtw_free_recvframe(precv_frame, pfree_recv_queue);
+
+	 DBG_COUNTER(padapter->rx_logs.os_indicate_err);
+
+	 return _FAIL;
+
+}
+
+void rtw_os_read_port(_adapter *padapter, struct recv_buf *precvbuf)
+{
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+#ifdef CONFIG_USB_HCI
+
+	precvbuf->ref_cnt--;
+
+	//free skb in recv_buf
+	rtw_skb_free(precvbuf->pskb);
+
+	precvbuf->pskb = NULL;
+
+	if(precvbuf->irp_pending == _FALSE)
+	{
+		rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+	}
+
+
+#endif
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+		precvbuf->pskb = NULL;
+#endif
+
+}
+
+void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)
+{
+	timer_setup(&preorder_ctrl->reordering_ctrl_timer,
+		    rtw_reordering_ctrl_timeout_handler, 0);
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_android.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_android.c
new file mode 100644
index 000000000..51da22644
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_android.c
@@ -0,0 +1,1293 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifdef CONFIG_GPIO_WAKEUP
+#include <linux/gpio.h>
+#endif
+
+#include <drv_types.h>
+
+#if defined(RTW_ENABLE_WIFI_CONTROL_FUNC)
+#include <linux/platform_device.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+#include <linux/wlan_plat.h>
+#else
+#include <linux/wifi_tiwlan.h>
+#endif
+#endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0))
+#define strnicmp	strncasecmp
+#endif /* Linux kernel >= 4.0.0 */
+
+#ifdef CONFIG_GPIO_WAKEUP
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#endif
+
+#include "rtw_version.h"
+
+extern void macstr2num(u8 *dst, u8 *src);
+
+const char *android_wifi_cmd_str[ANDROID_WIFI_CMD_MAX] = {
+	"START",
+	"STOP",
+	"SCAN-ACTIVE",
+	"SCAN-PASSIVE",
+	"RSSI",
+	"LINKSPEED",
+	"RXFILTER-START",
+	"RXFILTER-STOP",
+	"RXFILTER-ADD",
+	"RXFILTER-REMOVE",
+	"BTCOEXSCAN-START",
+	"BTCOEXSCAN-STOP",
+	"BTCOEXMODE",
+	"SETSUSPENDOPT",
+	"P2P_DEV_ADDR",
+	"SETFWPATH",
+	"SETBAND",
+	"GETBAND",
+	"COUNTRY",
+	"P2P_SET_NOA",
+	"P2P_GET_NOA",
+	"P2P_SET_PS",
+	"SET_AP_WPS_P2P_IE",
+
+	"MIRACAST",
+
+#ifdef CONFIG_PNO_SUPPORT
+	"PNOSSIDCLR",
+	"PNOSETUP",
+	"PNOFORCE",
+	"PNODEBUG",
+#endif
+
+	"MACADDR",
+
+	"BLOCK_SCAN",
+	"BLOCK",
+	"WFD-ENABLE",
+	"WFD-DISABLE",
+	"WFD-SET-TCPPORT",
+	"WFD-SET-MAXTPUT",
+	"WFD-SET-DEVTYPE",
+	"SET_DTIM",
+	"HOSTAPD_SET_MACADDR_ACL",
+	"HOSTAPD_ACL_ADD_STA",
+	"HOSTAPD_ACL_REMOVE_STA",
+#if defined(CONFIG_GTK_OL) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0))
+	"GTK_REKEY_OFFLOAD",
+#endif //CONFIG_GTK_OL
+/*	Private command for	P2P disable*/
+	"P2P_DISABLE",
+	"DRIVER_VERSION"
+};
+
+#ifdef CONFIG_PNO_SUPPORT
+#define PNO_TLV_PREFIX			'S'
+#define PNO_TLV_VERSION			'1'
+#define PNO_TLV_SUBVERSION 		'2'
+#define PNO_TLV_RESERVED		'0'
+#define PNO_TLV_TYPE_SSID_IE	'S'
+#define PNO_TLV_TYPE_TIME		'T'
+#define PNO_TLV_FREQ_REPEAT		'R'
+#define PNO_TLV_FREQ_EXPO_MAX	'M'
+
+typedef struct cmd_tlv {
+	char prefix;
+	char version;
+	char subver;
+	char reserved;
+} cmd_tlv_t;
+
+#ifdef CONFIG_PNO_SET_DEBUG
+char pno_in_example[] = {
+		'P', 'N', 'O', 'S', 'E', 'T', 'U', 'P', ' ',
+		'S', '1', '2', '0',
+		'S',	//1
+		0x05,
+		'd', 'l', 'i', 'n', 'k',
+		'S',	//2
+		0x06,
+		'B', 'U', 'F', 'B', 'U','F',
+		'S',	//3
+		0x20,
+		'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '!', '@', '#', '$', '%', '^',
+		'S',	//4
+		0x0a,
+		'!', '@', '#', '$', '%', '^', '&', '*', '(', ')',
+		'T',
+		'0', '5',
+		'R',
+		'2',
+		'M',
+		'2',
+		0x00
+		};
+#endif /* CONFIG_PNO_SET_DEBUG */
+#endif /* PNO_SUPPORT */
+
+typedef struct android_wifi_priv_cmd {
+	char *buf;
+	int used_len;
+	int total_len;
+} android_wifi_priv_cmd;
+
+#ifdef CONFIG_COMPAT
+typedef struct compat_android_wifi_priv_cmd {
+	compat_uptr_t buf;
+	int used_len;
+	int total_len;
+} compat_android_wifi_priv_cmd;
+#endif /* CONFIG_COMPAT */
+
+/**
+ * Local (static) functions and variables
+ */
+
+/* Initialize g_wifi_on to 1 so dhd_bus_start will be called for the first
+ * time (only) in dhd_open, subsequential wifi on will be handled by
+ * wl_android_wifi_on
+ */
+static int g_wifi_on = _TRUE;
+
+unsigned int oob_irq = 0;
+unsigned int oob_gpio = 0;
+
+#ifdef CONFIG_PNO_SUPPORT
+/* 
+ * rtw_android_pno_setup
+ * Description: 
+ * This is used for private command.
+ * 
+ * Parameter:
+ * net: net_device
+ * command: parameters from private command
+ * total_len: the length of the command.
+ *
+ * */
+static int rtw_android_pno_setup(struct net_device *net, char *command, int total_len) {
+	pno_ssid_t pno_ssids_local[MAX_PNO_LIST_COUNT];
+	int res = -1;
+	int nssid = 0;
+	cmd_tlv_t *cmd_tlv_temp;
+	char *str_ptr;
+	int tlv_size_left;
+	int pno_time = 0;
+	int pno_repeat = 0;
+	int pno_freq_expo_max = 0;
+	int cmdlen = strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_PNOSETUP_SET]) + 1; 
+
+#ifdef CONFIG_PNO_SET_DEBUG
+	int i;
+	char *p;
+	p = pno_in_example;
+
+	total_len = sizeof(pno_in_example);
+	str_ptr = p + cmdlen;
+#else
+	str_ptr = command + cmdlen;
+#endif
+
+	if (total_len < (cmdlen + sizeof(cmd_tlv_t))) {
+		DBG_871X("%s argument=%d less min size\n", __func__, total_len);
+		goto exit_proc;
+	}
+
+	tlv_size_left = total_len - cmdlen;
+
+	cmd_tlv_temp = (cmd_tlv_t *)str_ptr;
+	memset(pno_ssids_local, 0, sizeof(pno_ssids_local));
+
+	if ((cmd_tlv_temp->prefix == PNO_TLV_PREFIX) &&
+		(cmd_tlv_temp->version == PNO_TLV_VERSION) &&
+		(cmd_tlv_temp->subver == PNO_TLV_SUBVERSION)) {
+
+		str_ptr += sizeof(cmd_tlv_t);
+		tlv_size_left -= sizeof(cmd_tlv_t);
+
+		if ((nssid = rtw_parse_ssid_list_tlv(&str_ptr, pno_ssids_local,
+			MAX_PNO_LIST_COUNT, &tlv_size_left)) <= 0) {
+			DBG_871X("SSID is not presented or corrupted ret=%d\n", nssid);
+			goto exit_proc;
+		} else {
+			if ((str_ptr[0] != PNO_TLV_TYPE_TIME) || (tlv_size_left <= 1)) {
+				DBG_871X("%s scan duration corrupted field size %d\n",
+					__func__, tlv_size_left);
+				goto exit_proc;
+			}
+			str_ptr++;
+			pno_time = simple_strtoul(str_ptr, &str_ptr, 16);
+			DBG_871X("%s: pno_time=%d\n", __func__, pno_time);
+
+			if (str_ptr[0] != 0) {
+				if ((str_ptr[0] != PNO_TLV_FREQ_REPEAT)) {
+					DBG_871X("%s pno repeat : corrupted field\n",
+						__func__);
+					goto exit_proc;
+				}
+				str_ptr++;
+				pno_repeat = simple_strtoul(str_ptr, &str_ptr, 16);
+				DBG_871X("%s :got pno_repeat=%d\n", __FUNCTION__, pno_repeat);
+				if (str_ptr[0] != PNO_TLV_FREQ_EXPO_MAX) {
+					DBG_871X("%s FREQ_EXPO_MAX corrupted field size\n",
+						__func__);
+					goto exit_proc;
+				}
+				str_ptr++;
+				pno_freq_expo_max = simple_strtoul(str_ptr, &str_ptr, 16);
+				DBG_871X("%s: pno_freq_expo_max=%d\n",
+					__func__, pno_freq_expo_max);
+			}
+		}
+	} else {
+		DBG_871X("%s get wrong TLV command\n", __FUNCTION__);
+		goto exit_proc;
+	}
+
+	res = rtw_dev_pno_set(net, pno_ssids_local, nssid, pno_time, pno_repeat, pno_freq_expo_max);
+
+#ifdef CONFIG_PNO_SET_DEBUG
+	rtw_dev_pno_debug(net);
+#endif
+
+exit_proc:
+	return res;
+}
+
+/* 
+ * rtw_android_cfg80211_pno_setup
+ * Description: 
+ * This is used for cfg80211 sched_scan.
+ * 
+ * Parameter:
+ * net: net_device
+ * request: cfg80211_request
+ * */
+
+int rtw_android_cfg80211_pno_setup(struct net_device *net,
+		struct cfg80211_ssid *ssids, int n_ssids, int interval) {
+	int res = -1;
+	int nssid = 0;
+	int pno_time = 0;
+	int pno_repeat = 0;
+	int pno_freq_expo_max = 0;
+	int index = 0;
+	pno_ssid_t pno_ssids_local[MAX_PNO_LIST_COUNT];
+
+	if (n_ssids > MAX_PNO_LIST_COUNT || n_ssids < 0) {
+		DBG_871X("%s: nssids(%d) is invalid.\n", __func__, n_ssids);
+		return -EINVAL;
+	}
+
+	memset(pno_ssids_local, 0, sizeof(pno_ssids_local));
+
+	nssid = n_ssids;
+
+	for (index = 0 ; index < nssid ; index++) {
+		pno_ssids_local[index].SSID_len = ssids[index].ssid_len;
+		memcpy(pno_ssids_local[index].SSID, ssids[index].ssid,
+				ssids[index].ssid_len);
+	}
+
+	pno_time = (interval / 1000);
+
+	DBG_871X("%s: nssids: %d, pno_time=%d\n", __func__, nssid, pno_time);
+
+	res = rtw_dev_pno_set(net, pno_ssids_local, nssid, pno_time,
+			pno_repeat, pno_freq_expo_max);
+
+exit_proc:
+	return res;
+}
+
+int rtw_android_pno_enable(struct net_device *net, int pno_enable) {
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
+	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
+
+	if (pwrctl) {
+		pwrctl->wowlan_pno_enable = pno_enable;
+		DBG_871X("%s: wowlan_pno_enable: %d\n", __func__, pwrctl->wowlan_pno_enable);
+		if (pwrctl->wowlan_pno_enable == 0) {
+			if (pwrctl->pnlo_info != NULL) {
+				rtw_mfree((u8 *)pwrctl->pnlo_info, sizeof(pno_nlo_info_t));
+				pwrctl->pnlo_info = NULL;
+			}
+			if (pwrctl->pno_ssid_list != NULL) {
+				rtw_mfree((u8 *)pwrctl->pno_ssid_list, sizeof(pno_ssid_list_t));
+				pwrctl->pno_ssid_list = NULL;
+			}
+			if (pwrctl->pscan_info != NULL) {
+				rtw_mfree((u8 *)pwrctl->pscan_info, sizeof(pno_scan_info_t));
+				pwrctl->pscan_info = NULL;
+			}
+		} 
+		return 0;
+	} else {
+		return -1;
+	}
+}
+#endif //CONFIG_PNO_SUPPORT
+
+int rtw_android_cmdstr_to_num(char *cmdstr)
+{
+	int cmd_num;
+	for(cmd_num=0 ; cmd_num<ANDROID_WIFI_CMD_MAX; cmd_num++)
+		if(0 == strnicmp(cmdstr , android_wifi_cmd_str[cmd_num], strlen(android_wifi_cmd_str[cmd_num])) )
+			break;
+
+	return cmd_num;
+}
+
+int rtw_android_get_rssi(struct net_device *net, char *command, int total_len)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+	struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
+	int bytes_written = 0;
+
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {	
+		bytes_written += snprintf(&command[bytes_written], total_len, "%s rssi %d", 
+			pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
+	}
+
+	return bytes_written;
+}
+
+int rtw_android_get_link_speed(struct net_device *net, char *command, int total_len)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+	struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
+	int bytes_written = 0;
+	u16 link_speed = 0;
+
+	link_speed = rtw_get_cur_max_rate(padapter)/10;
+	bytes_written = snprintf(command, total_len, "LinkSpeed %d", link_speed);
+
+	return bytes_written;
+}
+
+int rtw_android_get_macaddr(struct net_device *net, char *command, int total_len)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
+	int bytes_written = 0;
+	
+	bytes_written = snprintf(command, total_len, "Macaddr = "MAC_FMT, MAC_ARG(net->dev_addr));
+	return bytes_written;
+}
+
+int rtw_android_set_country(struct net_device *net, char *command, int total_len)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
+	char *country_code = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_COUNTRY]) + 1;
+	int ret = _FAIL;
+	
+	ret = rtw_set_country(adapter, country_code);
+
+	return (ret==_SUCCESS)?0:-1;
+}
+
+int rtw_android_get_p2p_dev_addr(struct net_device *net, char *command, int total_len)
+{
+	int bytes_written = 0;
+
+	//We use the same address as our HW MAC address
+	_rtw_memcpy(command, net->dev_addr, ETH_ALEN);
+	
+	bytes_written = ETH_ALEN;
+	return bytes_written;
+}
+
+int rtw_android_set_block_scan(struct net_device *net, char *command, int total_len)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
+	char *block_value = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_BLOCK_SCAN]) + 1;
+
+	#ifdef CONFIG_IOCTL_CFG80211
+	adapter_wdev_data(adapter)->block_scan = (*block_value == '0')?_FALSE:_TRUE;
+	#endif
+
+	return 0;
+}
+
+int rtw_android_set_block(struct net_device *net, char *command, int total_len)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
+	char *block_value = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_BLOCK]) + 1;
+
+	#ifdef CONFIG_IOCTL_CFG80211
+	adapter_wdev_data(adapter)->block = (*block_value=='0')?_FALSE:_TRUE;
+	#endif
+	
+	return 0;
+}
+
+int rtw_android_setband(struct net_device *net, char *command, int total_len)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
+	char *arg = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_SETBAND]) + 1;
+	u32 band = WIFI_FREQUENCY_BAND_AUTO;
+	int ret = _FAIL;
+
+	if (sscanf(arg, "%u", &band) >= 1)
+		ret = rtw_set_band(adapter, band);
+
+	return (ret==_SUCCESS)?0:-1;
+}
+
+int rtw_android_getband(struct net_device *net, char *command, int total_len)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
+	int bytes_written = 0;
+
+	bytes_written = snprintf(command, total_len, "%u", adapter->setband);
+
+	return bytes_written;
+}
+
+#ifdef CONFIG_WFD
+int rtw_android_set_miracast_mode(struct net_device *net, char *command, int total_len)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
+	struct wifi_display_info *wfd_info = &adapter->wfd_info;
+	char *arg = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_MIRACAST]) + 1;
+	u8 mode;
+	int num;
+	int ret = _FAIL;
+
+	num = sscanf(arg, "%hhu", &mode);
+
+	if (num < 1)
+		goto exit;
+
+	switch (mode) {
+	case 1: /* soruce */
+		mode = MIRACAST_SOURCE;
+		break;
+	case 2: /* sink */
+		mode = MIRACAST_SINK;
+		break;
+	case 0: /* disabled */
+	default:
+		mode = MIRACAST_DISABLED;
+		break;
+	}
+	wfd_info->stack_wfd_mode = mode;
+	DBG_871X("stack miracast mode: %s\n", get_miracast_mode_str(wfd_info->stack_wfd_mode));
+
+	ret = _SUCCESS;
+
+exit:
+	return (ret == _SUCCESS)?0:-1;
+}
+#endif /* CONFIG_WFD */
+
+int get_int_from_command( char* pcmd )
+{
+	int i = 0;
+
+	for( i = 0; i < strlen( pcmd ); i++ )
+	{
+		if ( pcmd[ i ] == '=' )
+		{
+			//	Skip the '=' and space characters.
+			i += 2;
+			break;
+		}
+	}
+	return ( rtw_atoi( pcmd + i ) );
+}
+
+#if defined(CONFIG_GTK_OL) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0))
+int rtw_gtk_offload(struct net_device *net, u8 *cmd_ptr)
+{
+	int i;
+	//u8 *cmd_ptr = priv_cmd.buf;
+	struct sta_info * psta;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
+	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct security_priv* psecuritypriv=&(padapter->securitypriv);
+	psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
+	
+	
+	if (psta == NULL) 
+	{
+		DBG_8192C("%s, : Obtain Sta_info fail \n", __func__);
+	}
+	else
+	{
+		//string command length of "GTK_REKEY_OFFLOAD"
+		cmd_ptr += 18;
+		
+		_rtw_memcpy(psta->kek, cmd_ptr, RTW_KEK_LEN);
+		cmd_ptr += RTW_KEK_LEN;
+		/*
+		printk("supplicant KEK: ");
+		for(i=0;i<RTW_KEK_LEN; i++)
+			printk(" %02x ", psta->kek[i]);
+		printk("\n supplicant KCK: ");
+		*/
+		_rtw_memcpy(psta->kck, cmd_ptr, RTW_KCK_LEN);
+		cmd_ptr += RTW_KCK_LEN;
+		/*
+		for(i=0;i<RTW_KEK_LEN; i++)
+			printk(" %02x ", psta->kck[i]);
+		*/
+		_rtw_memcpy(psta->replay_ctr, cmd_ptr, RTW_REPLAY_CTR_LEN);
+		psecuritypriv->binstallKCK_KEK = _TRUE;
+		
+		//printk("\nREPLAY_CTR: ");
+		//for(i=0;i<RTW_REPLAY_CTR_LEN; i++)
+			//printk(" %02x ", psta->replay_ctr[i]);
+	}
+
+	return _SUCCESS;
+}
+#endif //CONFIG_GTK_OL
+
+int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
+{
+	int ret = 0;
+	char *command = NULL;
+	int cmd_num;
+	int bytes_written = 0;
+#ifdef CONFIG_PNO_SUPPORT
+	uint cmdlen = 0;
+	uint pno_enable = 0;
+#endif
+	android_wifi_priv_cmd priv_cmd;
+	_adapter*	padapter = ( _adapter * ) rtw_netdev_priv(net);
+#ifdef CONFIG_WFD
+	struct wifi_display_info		*pwfd_info;
+#endif
+
+	rtw_lock_suspend();
+
+	if (!ifr->ifr_data) {
+		ret = -EINVAL;
+		goto exit;
+	}
+	if (padapter->registrypriv.mp_mode == 1) {
+			ret = -EINVAL;
+			goto exit;
+	}
+#ifdef CONFIG_COMPAT
+	if (is_compat_task()) {
+		/* User space is 32-bit, use compat ioctl */
+		compat_android_wifi_priv_cmd compat_priv_cmd;
+
+		if (copy_from_user(&compat_priv_cmd, ifr->ifr_data, sizeof(compat_android_wifi_priv_cmd))) {
+			ret = -EFAULT;
+			goto exit;
+		}
+		priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
+		priv_cmd.used_len = compat_priv_cmd.used_len;
+		priv_cmd.total_len = compat_priv_cmd.total_len;
+	} else
+#endif /* CONFIG_COMPAT */
+	if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
+		ret = -EFAULT;
+		goto exit;
+	}
+	if ( padapter->registrypriv.mp_mode == 1) {
+		ret = -EFAULT;
+		goto exit;
+	}
+	/*DBG_871X("%s priv_cmd.buf=%p priv_cmd.total_len=%d  priv_cmd.used_len=%d\n",__func__,priv_cmd.buf,priv_cmd.total_len,priv_cmd.used_len);*/
+	command = rtw_zmalloc(priv_cmd.total_len);
+	if (!command)
+	{
+		DBG_871X("%s: failed to allocate memory\n", __FUNCTION__);
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	if (!access_ok(priv_cmd.buf, priv_cmd.total_len)){
+	 	DBG_871X("%s: failed to access memory\n", __FUNCTION__);
+		ret = -EFAULT;
+		goto exit;
+	 }
+	if (copy_from_user(command, (void *)priv_cmd.buf, priv_cmd.total_len)) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	DBG_871X("%s: Android private cmd \"%s\" on %s\n"
+		, __FUNCTION__, command, ifr->ifr_name);
+
+	cmd_num = rtw_android_cmdstr_to_num(command);
+	
+	switch(cmd_num) {
+	case ANDROID_WIFI_CMD_START:
+		//bytes_written = wl_android_wifi_on(net);
+		goto response;
+	case ANDROID_WIFI_CMD_SETFWPATH:
+		goto response;
+	}
+
+	if (!g_wifi_on) {
+		DBG_871X("%s: Ignore private cmd \"%s\" - iface %s is down\n"
+			,__FUNCTION__, command, ifr->ifr_name);
+		ret = 0;
+		goto exit;
+	}
+
+	if (!hal_chk_wl_func(padapter, WL_FUNC_MIRACAST)) {
+		switch (cmd_num) {
+		case ANDROID_WIFI_CMD_WFD_ENABLE:
+		case ANDROID_WIFI_CMD_WFD_DISABLE:
+		case ANDROID_WIFI_CMD_WFD_SET_TCPPORT:
+		case ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT:
+		case ANDROID_WIFI_CMD_WFD_SET_DEVTYPE:
+			goto response;
+		}
+	}
+
+	switch(cmd_num) {
+
+	case ANDROID_WIFI_CMD_STOP:
+		//bytes_written = wl_android_wifi_off(net);
+		break;
+		
+	case ANDROID_WIFI_CMD_SCAN_ACTIVE:
+		//rtw_set_scan_mode((_adapter *)rtw_netdev_priv(net), SCAN_ACTIVE);
+#ifdef CONFIG_PLATFORM_MSTAR
+#ifdef CONFIG_IOCTL_CFG80211
+		adapter_wdev_data((_adapter *)rtw_netdev_priv(net))->bandroid_scan = _TRUE;
+#endif //CONFIG_IOCTL_CFG80211
+#endif //CONFIG_PLATFORM_MSTAR
+		break;
+	case ANDROID_WIFI_CMD_SCAN_PASSIVE:
+		//rtw_set_scan_mode((_adapter *)rtw_netdev_priv(net), SCAN_PASSIVE);
+		break;
+		
+	case ANDROID_WIFI_CMD_RSSI:
+		bytes_written = rtw_android_get_rssi(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_LINKSPEED:
+		bytes_written = rtw_android_get_link_speed(net, command, priv_cmd.total_len);
+		break;
+
+	case ANDROID_WIFI_CMD_MACADDR:
+		bytes_written = rtw_android_get_macaddr(net, command, priv_cmd.total_len);
+		break;
+
+	case ANDROID_WIFI_CMD_BLOCK_SCAN:
+		bytes_written = rtw_android_set_block_scan(net, command, priv_cmd.total_len);
+		break;
+
+	case ANDROID_WIFI_CMD_BLOCK:
+		bytes_written = rtw_android_set_block(net, command, priv_cmd.total_len);
+		break;
+		
+	case ANDROID_WIFI_CMD_RXFILTER_START:
+		//bytes_written = net_os_set_packet_filter(net, 1);
+		break;
+	case ANDROID_WIFI_CMD_RXFILTER_STOP:
+		//bytes_written = net_os_set_packet_filter(net, 0);
+		break;
+	case ANDROID_WIFI_CMD_RXFILTER_ADD:
+		//int filter_num = *(command + strlen(CMD_RXFILTER_ADD) + 1) - '0';
+		//bytes_written = net_os_rxfilter_add_remove(net, TRUE, filter_num);
+		break;
+	case ANDROID_WIFI_CMD_RXFILTER_REMOVE:
+		//int filter_num = *(command + strlen(CMD_RXFILTER_REMOVE) + 1) - '0';
+		//bytes_written = net_os_rxfilter_add_remove(net, FALSE, filter_num);
+		break;
+		
+	case ANDROID_WIFI_CMD_BTCOEXSCAN_START:
+		/* TBD: BTCOEXSCAN-START */
+		break;
+	case ANDROID_WIFI_CMD_BTCOEXSCAN_STOP:
+		/* TBD: BTCOEXSCAN-STOP */
+		break;
+	case ANDROID_WIFI_CMD_BTCOEXMODE:
+		#if 0
+		uint mode = *(command + strlen(CMD_BTCOEXMODE) + 1) - '0';
+		if (mode == 1)
+			net_os_set_packet_filter(net, 0); /* DHCP starts */
+		else
+			net_os_set_packet_filter(net, 1); /* DHCP ends */
+#ifdef WL_CFG80211
+		bytes_written = wl_cfg80211_set_btcoex_dhcp(net, command);
+#endif
+		#endif
+		break;
+		
+	case ANDROID_WIFI_CMD_SETSUSPENDOPT:
+		//bytes_written = wl_android_set_suspendopt(net, command, priv_cmd.total_len);
+		break;
+		
+	case ANDROID_WIFI_CMD_SETBAND:
+		bytes_written = rtw_android_setband(net, command, priv_cmd.total_len);
+		break;
+
+	case ANDROID_WIFI_CMD_GETBAND:
+		bytes_written = rtw_android_getband(net, command, priv_cmd.total_len);
+		break;
+
+	case ANDROID_WIFI_CMD_COUNTRY:
+		bytes_written = rtw_android_set_country(net, command, priv_cmd.total_len);
+		break;
+		
+#ifdef CONFIG_PNO_SUPPORT
+	case ANDROID_WIFI_CMD_PNOSSIDCLR_SET:
+		//bytes_written = dhd_dev_pno_reset(net);
+		break;
+	case ANDROID_WIFI_CMD_PNOSETUP_SET:
+		bytes_written = rtw_android_pno_setup(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_PNOENABLE_SET:
+		cmdlen = strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_PNOENABLE_SET]);
+		pno_enable = *(command + cmdlen + 1) - '0';
+		bytes_written = rtw_android_pno_enable(net, pno_enable);
+		break;
+#endif
+
+	case ANDROID_WIFI_CMD_P2P_DEV_ADDR:
+		bytes_written = rtw_android_get_p2p_dev_addr(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_P2P_SET_NOA:
+		//int skip = strlen(CMD_P2P_SET_NOA) + 1;
+		//bytes_written = wl_cfg80211_set_p2p_noa(net, command + skip, priv_cmd.total_len - skip);
+		break;
+	case ANDROID_WIFI_CMD_P2P_GET_NOA:
+		//bytes_written = wl_cfg80211_get_p2p_noa(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_P2P_SET_PS:
+		//int skip = strlen(CMD_P2P_SET_PS) + 1;
+		//bytes_written = wl_cfg80211_set_p2p_ps(net, command + skip, priv_cmd.total_len - skip);
+		break;
+		
+#ifdef CONFIG_IOCTL_CFG80211
+	case ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE:
+	{
+		int skip = strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE]) + 3;
+		bytes_written = rtw_cfg80211_set_mgnt_wpsp2pie(net, command + skip, priv_cmd.total_len - skip, *(command + skip - 2) - '0');
+		break;
+	}
+#endif //CONFIG_IOCTL_CFG80211
+
+#ifdef CONFIG_WFD
+
+	case ANDROID_WIFI_CMD_MIRACAST:
+		bytes_written = rtw_android_set_miracast_mode(net, command, priv_cmd.total_len);
+		break;
+
+	case ANDROID_WIFI_CMD_WFD_ENABLE:
+	{
+		//	Commented by Albert 2012/07/24
+		//	We can enable the WFD function by using the following command:
+		//	wpa_cli driver wfd-enable
+
+		if (padapter->wdinfo.driver_interface == DRIVER_CFG80211)
+			rtw_wfd_enable(padapter, 1);
+		break;
+	}
+
+	case ANDROID_WIFI_CMD_WFD_DISABLE:
+	{
+		//	Commented by Albert 2012/07/24
+		//	We can disable the WFD function by using the following command:
+		//	wpa_cli driver wfd-disable
+
+		if (padapter->wdinfo.driver_interface == DRIVER_CFG80211)
+			rtw_wfd_enable(padapter, 0);
+		break;
+	}
+	case ANDROID_WIFI_CMD_WFD_SET_TCPPORT:
+	{
+		//	Commented by Albert 2012/07/24
+		//	We can set the tcp port number by using the following command:
+		//	wpa_cli driver wfd-set-tcpport = 554
+
+		if (padapter->wdinfo.driver_interface == DRIVER_CFG80211)
+			rtw_wfd_set_ctrl_port(padapter, (u16)get_int_from_command(priv_cmd.buf));
+		break;
+	}
+	case ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT:
+	{
+		break;
+	}
+	case ANDROID_WIFI_CMD_WFD_SET_DEVTYPE:
+	{
+		//	Commented by Albert 2012/08/28
+		//	Specify the WFD device type ( WFD source/primary sink )
+
+		pwfd_info = &padapter->wfd_info;
+		if( padapter->wdinfo.driver_interface == DRIVER_CFG80211 )
+		{
+			pwfd_info->wfd_device_type = ( u8 ) get_int_from_command( priv_cmd.buf );
+			pwfd_info->wfd_device_type &= WFD_DEVINFO_DUAL;
+		}
+		break;
+	}
+#endif
+	case ANDROID_WIFI_CMD_CHANGE_DTIM:
+		{
+#ifdef CONFIG_LPS
+			u8 dtim;
+			u8 *ptr =(u8 *) &priv_cmd.buf;
+			
+			ptr += 9;//string command length of  "SET_DTIM";
+
+			dtim = rtw_atoi(ptr);
+
+			DBG_871X("DTIM=%d\n", dtim);
+
+			rtw_lps_change_dtim_cmd(padapter, dtim);			
+#endif			
+		}		
+		break;
+	case ANDROID_WIFI_CMD_HOSTAPD_SET_MACADDR_ACL:
+	{
+		padapter->stapriv.acl_list.mode = ( u8 ) get_int_from_command(command);
+		DBG_871X("%s ANDROID_WIFI_CMD_HOSTAPD_SET_MACADDR_ACL mode:%d\n", __FUNCTION__, padapter->stapriv.acl_list.mode);
+		break;
+	}
+	case ANDROID_WIFI_CMD_HOSTAPD_ACL_ADD_STA:
+	{
+		u8 addr[ETH_ALEN] = {0x00};
+		macstr2num(addr, command+strlen("HOSTAPD_ACL_ADD_STA")+3);	// 3 is space bar + "=" + space bar these 3 chars
+		rtw_acl_add_sta(padapter, addr);
+		break;
+	}
+	case ANDROID_WIFI_CMD_HOSTAPD_ACL_REMOVE_STA:
+	{
+		u8 addr[ETH_ALEN] = {0x00};
+		macstr2num(addr, command+strlen("HOSTAPD_ACL_REMOVE_STA")+3);	// 3 is space bar + "=" + space bar these 3 chars
+		rtw_acl_remove_sta(padapter, addr);
+		break;
+	}
+#if defined(CONFIG_GTK_OL) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0))
+	case ANDROID_WIFI_CMD_GTK_REKEY_OFFLOAD:
+		rtw_gtk_offload(net, (u8*)command);
+		break;
+#endif //CONFIG_GTK_OL		
+	case ANDROID_WIFI_CMD_P2P_DISABLE:
+	{
+#ifdef CONFIG_P2P
+		struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;	
+		u8 channel, ch_offset;
+		u16 bwmode;
+
+		rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
+#endif // CONFIG_P2P
+		break;
+	}
+	case ANDROID_WIFI_CMD_DRIVERVERSION:
+	{
+		bytes_written = strlen(DRIVERVERSION);
+		snprintf(command, bytes_written+1, DRIVERVERSION);
+		break;
+	}
+	default:
+		DBG_871X("Unknown PRIVATE command %s - ignored\n", command);
+		snprintf(command, 3, "OK");
+		bytes_written = strlen("OK");
+	}
+
+response:
+	if (bytes_written >= 0) {
+		if ((bytes_written == 0) && (priv_cmd.total_len > 0))
+			command[0] = '\0';
+		if (bytes_written >= priv_cmd.total_len) {
+			DBG_871X("%s: bytes_written = %d\n", __FUNCTION__, bytes_written);
+			bytes_written = priv_cmd.total_len;
+		} else {
+			bytes_written++;
+		}
+		priv_cmd.used_len = bytes_written;
+		if (copy_to_user((void *)priv_cmd.buf, command, bytes_written)) {
+			DBG_871X("%s: failed to copy data to user buffer\n", __FUNCTION__);
+			ret = -EFAULT;
+		}
+	}
+	else {
+		ret = bytes_written;
+	}
+
+exit:
+	rtw_unlock_suspend();
+	if (command) {
+		rtw_mfree(command, priv_cmd.total_len);
+	}
+
+	return ret;
+}
+
+
+/**
+ * Functions for Android WiFi card detection
+ */
+#if defined(RTW_ENABLE_WIFI_CONTROL_FUNC)
+
+static int g_wifidev_registered = 0;
+static struct semaphore wifi_control_sem;
+static struct wifi_platform_data *wifi_control_data = NULL;
+static struct resource *wifi_irqres = NULL;
+
+static int wifi_add_dev(void);
+static void wifi_del_dev(void);
+
+int rtw_android_wifictrl_func_add(void)
+{
+	int ret = 0;
+	sema_init(&wifi_control_sem, 0);
+
+	ret = wifi_add_dev();
+	if (ret) {
+		DBG_871X("%s: platform_driver_register failed\n", __FUNCTION__);
+		return ret;
+	}
+	g_wifidev_registered = 1;
+
+	/* Waiting callback after platform_driver_register is done or exit with error */
+	if (down_timeout(&wifi_control_sem,  msecs_to_jiffies(1000)) != 0) {
+		ret = -EINVAL;
+		DBG_871X("%s: platform_driver_register timeout\n", __FUNCTION__);
+	}
+
+	return ret;
+}
+
+void rtw_android_wifictrl_func_del(void)
+{
+	if (g_wifidev_registered)
+	{
+		wifi_del_dev();
+		g_wifidev_registered = 0;
+	}
+}
+
+void *wl_android_prealloc(int section, unsigned long size)
+{
+	void *alloc_ptr = NULL;
+	if (wifi_control_data && wifi_control_data->mem_prealloc) {
+		alloc_ptr = wifi_control_data->mem_prealloc(section, size);
+		if (alloc_ptr) {
+			DBG_871X("success alloc section %d\n", section);
+			if (size != 0L)
+				memset(alloc_ptr, 0, size);
+			return alloc_ptr;
+		}
+	}
+
+	DBG_871X("can't alloc section %d\n", section);
+	return NULL;
+}
+
+int wifi_get_irq_number(unsigned long *irq_flags_ptr)
+{
+	if (wifi_irqres) {
+		*irq_flags_ptr = wifi_irqres->flags & IRQF_TRIGGER_MASK;
+		return (int)wifi_irqres->start;
+	}
+#ifdef CUSTOM_OOB_GPIO_NUM
+	return CUSTOM_OOB_GPIO_NUM;
+#else
+	return -1;
+#endif
+}
+
+int wifi_set_power(int on, unsigned long msec)
+{
+	DBG_871X("%s = %d\n", __FUNCTION__, on);
+	if (wifi_control_data && wifi_control_data->set_power) {
+		wifi_control_data->set_power(on);
+	}
+	if (msec)
+		msleep(msec);
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+int wifi_get_mac_addr(unsigned char *buf)
+{
+	DBG_871X("%s\n", __FUNCTION__);
+	if (!buf)
+		return -EINVAL;
+	if (wifi_control_data && wifi_control_data->get_mac_addr) {
+		return wifi_control_data->get_mac_addr(buf);
+	}
+	return -EOPNOTSUPP;
+}
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)) */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)) || defined(COMPAT_KERNEL_RELEASE)
+void *wifi_get_country_code(char *ccode)
+{
+	DBG_871X("%s\n", __FUNCTION__);
+	if (!ccode)
+		return NULL;
+	if (wifi_control_data && wifi_control_data->get_country_code) {
+		return wifi_control_data->get_country_code(ccode);
+	}
+	return NULL;
+}
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)) */
+
+static int wifi_set_carddetect(int on)
+{
+	DBG_871X("%s = %d\n", __FUNCTION__, on);
+	if (wifi_control_data && wifi_control_data->set_carddetect) {
+		wifi_control_data->set_carddetect(on);
+	}
+	return 0;
+}
+
+static int wifi_probe(struct platform_device *pdev)
+{
+	struct wifi_platform_data *wifi_ctrl =
+		(struct wifi_platform_data *)(pdev->dev.platform_data);
+	int wifi_wake_gpio = 0;
+
+	DBG_871X("## %s\n", __FUNCTION__);
+	wifi_irqres = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "bcmdhd_wlan_irq");
+
+	if (wifi_irqres == NULL)
+		wifi_irqres = platform_get_resource_byname(pdev,
+			IORESOURCE_IRQ, "bcm4329_wlan_irq");
+	else
+		wifi_wake_gpio = wifi_irqres->start;
+
+#ifdef CONFIG_GPIO_WAKEUP
+	printk("%s: gpio:%d wifi_wake_gpio:%d\n", __func__,
+			wifi_irqres->start, wifi_wake_gpio);
+
+	if (wifi_wake_gpio > 0) {
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+		wifi_configure_gpio();
+#else //CONFIG_PLATFORM_INTEL_BYT
+		gpio_request(wifi_wake_gpio, "oob_irq");
+		gpio_direction_input(wifi_wake_gpio);
+		oob_irq = gpio_to_irq(wifi_wake_gpio);
+#endif //CONFIG_PLATFORM_INTEL_BYT
+		printk("%s oob_irq:%d\n", __func__, oob_irq);
+	}
+	else if(wifi_irqres)
+	{
+		oob_irq = wifi_irqres->start;
+		printk("%s oob_irq:%d\n", __func__, oob_irq);
+	}
+#endif
+	wifi_control_data = wifi_ctrl;
+
+	wifi_set_power(1, 0);	/* Power On */
+	wifi_set_carddetect(1);	/* CardDetect (0->1) */
+
+	up(&wifi_control_sem);
+	return 0;
+}
+
+#ifdef RTW_SUPPORT_PLATFORM_SHUTDOWN
+extern PADAPTER g_test_adapter;
+
+static void shutdown_card(void)
+{
+	u32 addr;
+	u8 tmp8, cnt=0;
+
+	if (NULL == g_test_adapter)
+	{
+		DBG_871X("%s: padapter==NULL\n", __FUNCTION__);
+		return;
+	}
+
+#ifdef CONFIG_FWLPS_IN_IPS
+	LeaveAllPowerSaveMode(g_test_adapter);
+#endif // CONFIG_FWLPS_IN_IPS
+
+	// Leave SDIO HCI Suspend
+	addr = 0x10250086;
+	rtw_write8(g_test_adapter, addr, 0);
+	do {
+		tmp8 = rtw_read8(g_test_adapter, addr);
+		cnt++;
+		DBG_871X(FUNC_ADPT_FMT ": polling SDIO_HSUS_CTRL(0x%x)=0x%x, cnt=%d\n",
+			FUNC_ADPT_ARG(g_test_adapter), addr, tmp8, cnt);
+
+		if (tmp8 & BIT(1))
+			break;
+
+		if (cnt >= 100)
+		{
+			DBG_871X(FUNC_ADPT_FMT ": polling 0x%x[1]==1 FAIL!!\n",
+				FUNC_ADPT_ARG(g_test_adapter), addr);
+			break;
+		}
+
+		rtw_mdelay_os(10);
+	} while (1);
+
+	// unlock register I/O
+	rtw_write8(g_test_adapter, 0x1C, 0);
+
+	// enable power down function
+	// 0x04[4] = 1
+	// 0x05[7] = 1
+	addr = 0x04;
+	tmp8 = rtw_read8(g_test_adapter, addr);
+	tmp8 |= BIT(4);
+	rtw_write8(g_test_adapter, addr, tmp8);
+	DBG_871X(FUNC_ADPT_FMT ": read after write 0x%x=0x%x\n",
+		FUNC_ADPT_ARG(g_test_adapter), addr, rtw_read8(g_test_adapter, addr));
+
+	addr = 0x05;
+	tmp8 = rtw_read8(g_test_adapter, addr);
+	tmp8 |= BIT(7);
+	rtw_write8(g_test_adapter, addr, tmp8);
+	DBG_871X(FUNC_ADPT_FMT ": read after write 0x%x=0x%x\n",
+		FUNC_ADPT_ARG(g_test_adapter), addr, rtw_read8(g_test_adapter, addr));
+
+	// lock register page0 0x0~0xB read/write
+	rtw_write8(g_test_adapter, 0x1C, 0x0E);
+
+	rtw_set_surprise_removed(g_test_adapter);
+	DBG_871X(FUNC_ADPT_FMT ": bSurpriseRemoved=%s\n",
+		FUNC_ADPT_ARG(g_test_adapter), rtw_is_surprise_removed(g_test_adapter)?"True":"False");
+}
+#endif // RTW_SUPPORT_PLATFORM_SHUTDOWN
+
+static int wifi_remove(struct platform_device *pdev)
+{
+	struct wifi_platform_data *wifi_ctrl =
+		(struct wifi_platform_data *)(pdev->dev.platform_data);
+
+	DBG_871X("## %s\n", __FUNCTION__);
+	wifi_control_data = wifi_ctrl;
+
+	wifi_set_power(0, 0);	/* Power Off */
+	wifi_set_carddetect(0);	/* CardDetect (1->0) */
+
+	up(&wifi_control_sem);
+	return 0;
+}
+
+#ifdef RTW_SUPPORT_PLATFORM_SHUTDOWN
+static void wifi_shutdown(struct platform_device *pdev)
+{
+	struct wifi_platform_data *wifi_ctrl =
+		(struct wifi_platform_data *)(pdev->dev.platform_data);
+	
+
+	DBG_871X("## %s\n", __FUNCTION__);
+
+	wifi_control_data = wifi_ctrl;
+
+	shutdown_card();
+	wifi_set_power(0, 0);	/* Power Off */
+	wifi_set_carddetect(0);	/* CardDetect (1->0) */
+}
+#endif // RTW_SUPPORT_PLATFORM_SHUTDOWN
+
+static int wifi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	DBG_871X("##> %s\n", __FUNCTION__);
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) && defined(OOB_INTR_ONLY)
+	bcmsdh_oob_intr_set(0);
+#endif
+	return 0;
+}
+
+static int wifi_resume(struct platform_device *pdev)
+{
+	DBG_871X("##> %s\n", __FUNCTION__);
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) && defined(OOB_INTR_ONLY)
+	if (dhd_os_check_if_up(bcmsdh_get_drvdata()))
+		bcmsdh_oob_intr_set(1);
+#endif
+	return 0;
+}
+
+/* temporarily use these two */
+static struct platform_driver wifi_device = {
+	.probe          = wifi_probe,
+	.remove         = wifi_remove,
+	.suspend        = wifi_suspend,
+	.resume         = wifi_resume,
+#ifdef RTW_SUPPORT_PLATFORM_SHUTDOWN
+	.shutdown       = wifi_shutdown,
+#endif // RTW_SUPPORT_PLATFORM_SHUTDOWN
+	.driver         = {
+	.name   = "bcmdhd_wlan",
+	}
+};
+
+static struct platform_driver wifi_device_legacy = {
+	.probe          = wifi_probe,
+	.remove         = wifi_remove,
+	.suspend        = wifi_suspend,
+	.resume         = wifi_resume,
+	.driver         = {
+	.name   = "bcm4329_wlan",
+	}
+};
+
+static int wifi_add_dev(void)
+{
+	DBG_871X("## Calling platform_driver_register\n");
+	platform_driver_register(&wifi_device);
+	platform_driver_register(&wifi_device_legacy);
+	return 0;
+}
+
+static void wifi_del_dev(void)
+{
+	DBG_871X("## Unregister platform_driver_register\n");
+	platform_driver_unregister(&wifi_device);
+	platform_driver_unregister(&wifi_device_legacy);
+}
+#endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
+
+#ifdef CONFIG_GPIO_WAKEUP
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+int wifi_configure_gpio(void)
+{
+	if (gpio_request(oob_gpio, "oob_irq")) {
+		DBG_871X("## %s Cannot request GPIO\n", __FUNCTION__);
+		return -1;
+	}
+	gpio_export(oob_gpio, 0);
+	if (gpio_direction_input(oob_gpio)) {
+		DBG_871X("## %s Cannot set GPIO direction input\n", __FUNCTION__);
+		return -1;
+	}
+	if ((oob_irq = gpio_to_irq(oob_gpio)) < 0) {
+		DBG_871X("## %s Cannot convert GPIO to IRQ\n", __FUNCTION__);
+		return -1;
+	}
+
+	DBG_871X("## %s OOB_IRQ=%d\n", __FUNCTION__, oob_irq);
+
+	return 0;
+}
+#endif //CONFIG_PLATFORM_INTEL_BYT
+void wifi_free_gpio(unsigned int gpio)
+{
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+	if(gpio)
+		gpio_free(gpio);
+#endif //CONFIG_PLATFORM_INTEL_BYT
+}
+#endif //CONFIG_GPIO_WAKEUP
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_cfgvendor.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_cfgvendor.c
new file mode 100644
index 000000000..4dcbad006
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_cfgvendor.c
@@ -0,0 +1,1385 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2014 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#include <drv_types.h>
+
+#ifdef CONFIG_IOCTL_CFG80211
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT)
+
+/*
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+#include <asm/uaccess.h>
+
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/netdevice.h>
+#include <linux/sched.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/wait.h>
+#include <net/cfg80211.h>
+*/
+
+#include <net/rtnetlink.h>
+
+#ifdef DBG_MEM_ALLOC
+extern bool match_mstat_sniff_rules(const enum mstat_f flags, const size_t size);
+struct sk_buff *dbg_rtw_cfg80211_vendor_event_alloc(struct wiphy *wiphy, int len, int event_id, gfp_t gfp
+	, const enum mstat_f flags, const char *func, const int line)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct wireless_dev *wdev = padapter->rtw_wdev;
+
+	struct sk_buff *skb;
+	unsigned int truesize = 0;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0))
+	skb = cfg80211_vendor_event_alloc(wiphy, len, event_id, gfp);
+#else
+	skb = cfg80211_vendor_event_alloc(wiphy, wdev, len, event_id, gfp);
+#endif
+
+	if(skb)
+		truesize = skb->truesize;
+
+	if(!skb || truesize < len || match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d), skb:%p, truesize=%u\n", func, line, __FUNCTION__, len, skb, truesize);
+
+	rtw_mstat_update(
+		flags
+		, skb ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
+		, truesize
+	);
+
+	return skb;
+}
+
+void dbg_rtw_cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp
+	, const enum mstat_f flags, const char *func, const int line)
+{
+	unsigned int truesize = skb->truesize;
+
+	if(match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);
+
+	cfg80211_vendor_event(skb, gfp);
+
+	rtw_mstat_update(
+		flags
+		, MSTAT_FREE
+		, truesize
+	);
+}
+
+struct sk_buff *dbg_rtw_cfg80211_vendor_cmd_alloc_reply_skb(struct wiphy *wiphy, int len
+	, const enum mstat_f flags, const char *func, const int line)
+{
+	struct sk_buff *skb;
+	unsigned int truesize = 0;
+
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len);
+
+	if(skb)
+		truesize = skb->truesize;
+
+	if(!skb || truesize < len || match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d), skb:%p, truesize=%u\n", func, line, __FUNCTION__, len, skb, truesize);
+
+	rtw_mstat_update(
+		flags
+		, skb ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
+		, truesize
+	);
+
+	return skb;
+}
+
+int dbg_rtw_cfg80211_vendor_cmd_reply(struct sk_buff *skb
+	, const enum mstat_f flags, const char *func, const int line)
+{
+	unsigned int truesize = skb->truesize;
+	int ret;
+
+	if(match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);
+
+	ret = cfg80211_vendor_cmd_reply(skb);
+
+	rtw_mstat_update(
+		flags
+		, MSTAT_FREE
+		, truesize
+	);
+
+	return ret;
+}
+
+#define rtw_cfg80211_vendor_event_alloc(wiphy, len, event_id, gfp) \
+	dbg_rtw_cfg80211_vendor_event_alloc(wiphy, len, event_id, gfp, MSTAT_FUNC_CFG_VENDOR|MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+	
+#define rtw_cfg80211_vendor_event(skb, gfp) \
+	dbg_rtw_cfg80211_vendor_event(skb, gfp, MSTAT_FUNC_CFG_VENDOR|MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+	
+#define rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len) \
+	dbg_rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len, MSTAT_FUNC_CFG_VENDOR|MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+
+#define rtw_cfg80211_vendor_cmd_reply(skb) \
+		dbg_rtw_cfg80211_vendor_cmd_reply(skb, MSTAT_FUNC_CFG_VENDOR|MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+#else
+
+struct sk_buff *rtw_cfg80211_vendor_event_alloc(
+		struct wiphy *wiphy, int len, int event_id, gfp_t gfp)
+{
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct wireless_dev *wdev = padapter->rtw_wdev;
+	struct sk_buff *skb;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0))
+	skb = cfg80211_vendor_event_alloc(wiphy, len, event_id, gfp);
+#else
+	skb = cfg80211_vendor_event_alloc(wiphy, wdev, len, event_id, gfp);
+#endif
+	return skb;
+}
+
+#define rtw_cfg80211_vendor_event(skb, gfp) \
+	cfg80211_vendor_event(skb, gfp)
+	
+#define rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len) \
+	cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len)
+
+#define rtw_cfg80211_vendor_cmd_reply(skb) \
+	cfg80211_vendor_cmd_reply(skb)
+#endif /* DBG_MEM_ALLOC */
+
+/*
+ * This API is to be used for asynchronous vendor events. This
+ * shouldn't be used in response to a vendor command from its
+ * do_it handler context (instead rtw_cfgvendor_send_cmd_reply should
+ * be used).
+ */
+int rtw_cfgvendor_send_async_event(struct wiphy *wiphy,
+	struct net_device *dev, int event_id, const void  *data, int len)
+{
+	u16 kflags;
+	struct sk_buff *skb;
+
+	kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+
+	/* Alloc the SKB for vendor_event */
+	skb = rtw_cfg80211_vendor_event_alloc(wiphy, len, event_id, kflags);
+	if (!skb) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" skb alloc failed", FUNC_NDEV_ARG(dev));
+		return -ENOMEM;
+	}
+
+	/* Push the data to the skb */
+	nla_put_nohdr(skb, len, data);
+
+	rtw_cfg80211_vendor_event(skb, kflags);
+
+	return 0;
+}
+
+static int rtw_cfgvendor_send_cmd_reply(struct wiphy *wiphy,
+	struct net_device *dev, const void  *data, int len)
+{
+	struct sk_buff *skb;
+
+	/* Alloc the SKB for vendor_event */
+	skb = rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len);
+	if (unlikely(!skb)) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" skb alloc failed", FUNC_NDEV_ARG(dev));
+		return -ENOMEM;
+	}
+
+	/* Push the data to the skb */
+	nla_put_nohdr(skb, len, data);
+
+	return rtw_cfg80211_vendor_cmd_reply(skb);
+}
+
+#define WIFI_FEATURE_INFRA              0x0001      /* Basic infrastructure mode        */
+#define WIFI_FEATURE_INFRA_5G           0x0002      /* Support for 5 GHz Band           */
+#define WIFI_FEATURE_HOTSPOT            0x0004      /* Support for GAS/ANQP             */
+#define WIFI_FEATURE_P2P                0x0008      /* Wifi-Direct                      */
+#define WIFI_FEATURE_SOFT_AP            0x0010      /* Soft AP                          */
+#define WIFI_FEATURE_GSCAN              0x0020      /* Google-Scan APIs                 */
+#define WIFI_FEATURE_NAN                0x0040      /* Neighbor Awareness Networking    */
+#define WIFI_FEATURE_D2D_RTT            0x0080      /* Device-to-device RTT             */
+#define WIFI_FEATURE_D2AP_RTT           0x0100      /* Device-to-AP RTT                 */
+#define WIFI_FEATURE_BATCH_SCAN         0x0200      /* Batched Scan (legacy)            */
+#define WIFI_FEATURE_PNO                0x0400      /* Preferred network offload        */
+#define WIFI_FEATURE_ADDITIONAL_STA     0x0800      /* Support for two STAs             */
+#define WIFI_FEATURE_TDLS               0x1000      /* Tunnel directed link setup       */
+#define WIFI_FEATURE_TDLS_OFFCHANNEL    0x2000      /* Support for TDLS off channel     */
+#define WIFI_FEATURE_EPR                0x4000      /* Enhanced power reporting         */
+#define WIFI_FEATURE_AP_STA             0x8000      /* Support for AP STA Concurrency   */
+
+#define MAX_FEATURE_SET_CONCURRRENT_GROUPS  3
+
+#include <hal_data.h>
+int rtw_dev_get_feature_set(struct net_device *dev)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	HAL_DATA_TYPE *HalData = GET_HAL_DATA(adapter);
+	HAL_VERSION *hal_ver = &HalData->VersionID;
+
+	int feature_set = 0;
+
+	feature_set |= WIFI_FEATURE_INFRA;
+
+	if (IS_8814A_SERIES(*hal_ver) || IS_8812_SERIES(*hal_ver) ||
+			IS_8821_SERIES(*hal_ver))
+		feature_set |= WIFI_FEATURE_INFRA_5G;
+
+	feature_set |= WIFI_FEATURE_P2P;
+	feature_set |= WIFI_FEATURE_SOFT_AP;
+
+	feature_set |= WIFI_FEATURE_ADDITIONAL_STA;
+
+	return feature_set;
+}
+
+int *rtw_dev_get_feature_set_matrix(struct net_device *dev, int *num)
+{
+	int feature_set_full, mem_needed;
+	int *ret;
+
+	*num = 0;
+	mem_needed = sizeof(int) * MAX_FEATURE_SET_CONCURRRENT_GROUPS;
+	ret = (int *)rtw_malloc(mem_needed);
+
+	if (!ret) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" failed to allocate %d bytes\n"
+			, FUNC_NDEV_ARG(dev), mem_needed);
+		return ret;
+	}
+
+	feature_set_full = rtw_dev_get_feature_set(dev);
+
+	ret[0] = (feature_set_full & WIFI_FEATURE_INFRA) |
+	         (feature_set_full & WIFI_FEATURE_INFRA_5G) |
+	         (feature_set_full & WIFI_FEATURE_NAN) |
+	         (feature_set_full & WIFI_FEATURE_D2D_RTT) |
+	         (feature_set_full & WIFI_FEATURE_D2AP_RTT) |
+	         (feature_set_full & WIFI_FEATURE_PNO) |
+	         (feature_set_full & WIFI_FEATURE_BATCH_SCAN) |
+	         (feature_set_full & WIFI_FEATURE_GSCAN) |
+	         (feature_set_full & WIFI_FEATURE_HOTSPOT) |
+	         (feature_set_full & WIFI_FEATURE_ADDITIONAL_STA) |
+	         (feature_set_full & WIFI_FEATURE_EPR);
+
+	ret[1] = (feature_set_full & WIFI_FEATURE_INFRA) |
+	         (feature_set_full & WIFI_FEATURE_INFRA_5G) |
+	         /* Not yet verified NAN with P2P */
+	         /* (feature_set_full & WIFI_FEATURE_NAN) | */
+	         (feature_set_full & WIFI_FEATURE_P2P) |
+	         (feature_set_full & WIFI_FEATURE_D2AP_RTT) |
+	         (feature_set_full & WIFI_FEATURE_D2D_RTT) |
+	         (feature_set_full & WIFI_FEATURE_EPR);
+
+	ret[2] = (feature_set_full & WIFI_FEATURE_INFRA) |
+	         (feature_set_full & WIFI_FEATURE_INFRA_5G) |
+	         (feature_set_full & WIFI_FEATURE_NAN) |
+	         (feature_set_full & WIFI_FEATURE_D2D_RTT) |
+	         (feature_set_full & WIFI_FEATURE_D2AP_RTT) |
+	         (feature_set_full & WIFI_FEATURE_TDLS) |
+	         (feature_set_full & WIFI_FEATURE_TDLS_OFFCHANNEL) |
+	         (feature_set_full & WIFI_FEATURE_EPR);
+	*num = MAX_FEATURE_SET_CONCURRRENT_GROUPS;
+
+	return ret;
+}
+
+static int rtw_cfgvendor_get_feature_set(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	int reply;
+
+	reply = rtw_dev_get_feature_set(wdev_to_ndev(wdev));
+
+	err =  rtw_cfgvendor_send_cmd_reply(wiphy, wdev_to_ndev(wdev), &reply, sizeof(int));
+
+	if (unlikely(err))
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" Vendor Command reply failed ret:%d \n"
+			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)), err);
+
+	return err;
+}
+
+static int rtw_cfgvendor_get_feature_set_matrix(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct sk_buff *skb;
+	int *reply;
+	int num, mem_needed, i;
+
+	reply = rtw_dev_get_feature_set_matrix(wdev_to_ndev(wdev), &num);
+
+	if (!reply) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" Could not get feature list matrix\n"
+			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)));
+		err = -EINVAL;
+		return err;
+	}
+
+	mem_needed = VENDOR_REPLY_OVERHEAD + (ATTRIBUTE_U32_LEN * num) +
+	             ATTRIBUTE_U32_LEN;
+
+	/* Alloc the SKB for vendor_event */
+	skb = rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, mem_needed);
+	if (unlikely(!skb)) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" skb alloc failed", FUNC_NDEV_ARG(wdev_to_ndev(wdev)));
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	nla_put_u32(skb, ANDR_WIFI_ATTRIBUTE_NUM_FEATURE_SET, num);
+	for (i = 0; i < num; i++) {
+		nla_put_u32(skb, ANDR_WIFI_ATTRIBUTE_FEATURE_SET, reply[i]);
+	}
+
+	err =  rtw_cfg80211_vendor_cmd_reply(skb);
+
+	if (unlikely(err))
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" Vendor Command reply failed ret:%d \n"
+			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)), err);
+exit:
+	rtw_mfree((u8*)reply, sizeof(int)*num);
+	return err;
+}
+
+#if defined(GSCAN_SUPPORT) && 0
+int wl_cfgvendor_send_hotlist_event(struct wiphy *wiphy,
+	struct net_device *dev, void  *data, int len, wl_vendor_event_t event)
+{
+	u16 kflags;
+	const void *ptr;
+	struct sk_buff *skb;
+	int malloc_len, total, iter_cnt_to_send, cnt;
+	gscan_results_cache_t *cache = (gscan_results_cache_t *)data;
+
+	total = len/sizeof(wifi_gscan_result_t);
+	while (total > 0) {
+		malloc_len = (total * sizeof(wifi_gscan_result_t)) + VENDOR_DATA_OVERHEAD;
+		if (malloc_len > NLMSG_DEFAULT_SIZE) {
+			malloc_len = NLMSG_DEFAULT_SIZE;
+		}
+		iter_cnt_to_send =
+		   (malloc_len - VENDOR_DATA_OVERHEAD)/sizeof(wifi_gscan_result_t);
+		total = total - iter_cnt_to_send;
+
+		kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+
+		/* Alloc the SKB for vendor_event */
+		skb = rtw_cfg80211_vendor_event_alloc(wiphy, malloc_len, event, kflags);
+		if (!skb) {
+			WL_ERR(("skb alloc failed"));
+			return -ENOMEM;
+		}
+
+		while (cache && iter_cnt_to_send) {
+			ptr = (const void *) &cache->results[cache->tot_consumed];
+
+			if (iter_cnt_to_send < (cache->tot_count - cache->tot_consumed))
+				cnt = iter_cnt_to_send;
+			else
+				cnt = (cache->tot_count - cache->tot_consumed);
+
+			iter_cnt_to_send -= cnt;
+			cache->tot_consumed += cnt;
+			/* Push the data to the skb */
+			nla_append(skb, cnt * sizeof(wifi_gscan_result_t), ptr);
+			if (cache->tot_consumed == cache->tot_count)
+				cache = cache->next;
+
+		}
+
+		rtw_cfg80211_vendor_event(skb, kflags);
+	}
+
+	return 0;
+}
+
+
+static int wl_cfgvendor_gscan_get_capabilities(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	dhd_pno_gscan_capabilities_t *reply = NULL;
+	uint32 reply_len = 0;
+
+
+	reply = dhd_dev_pno_get_gscan(bcmcfg_to_prmry_ndev(cfg),
+	   DHD_PNO_GET_CAPABILITIES, NULL, &reply_len);
+	if (!reply) {
+		WL_ERR(("Could not get capabilities\n"));
+		err = -EINVAL;
+		return err;
+	}
+
+	err =  rtw_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
+	        reply, reply_len);
+
+	if (unlikely(err))
+		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+
+	kfree(reply);
+	return err;
+}
+
+static int wl_cfgvendor_gscan_get_channel_list(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0, type, band;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	uint16 *reply = NULL;
+	uint32 reply_len = 0, num_channels, mem_needed;
+	struct sk_buff *skb;
+
+	type = nla_type(data);
+
+	if (type == GSCAN_ATTRIBUTE_BAND) {
+		band = nla_get_u32(data);
+	} else {
+		return -1;
+	}
+
+	reply = dhd_dev_pno_get_gscan(bcmcfg_to_prmry_ndev(cfg),
+	   DHD_PNO_GET_CHANNEL_LIST, &band, &reply_len);
+
+	if (!reply) {
+		WL_ERR(("Could not get channel list\n"));
+		err = -EINVAL;
+		return err;
+	}
+	num_channels =  reply_len/ sizeof(uint32);
+	mem_needed = reply_len + VENDOR_REPLY_OVERHEAD + (ATTRIBUTE_U32_LEN * 2);
+
+	/* Alloc the SKB for vendor_event */
+	skb = rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, mem_needed);
+	if (unlikely(!skb)) {
+		WL_ERR(("skb alloc failed"));
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	nla_put_u32(skb, GSCAN_ATTRIBUTE_NUM_CHANNELS, num_channels);
+	nla_put(skb, GSCAN_ATTRIBUTE_CHANNEL_LIST, reply_len, reply);
+
+	err =  rtw_cfg80211_vendor_cmd_reply(skb);
+
+	if (unlikely(err))
+		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+exit:
+	kfree(reply);
+	return err;
+}
+
+static int wl_cfgvendor_gscan_get_batch_results(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	gscan_results_cache_t *results, *iter;
+	uint32 reply_len, complete = 0, num_results_iter;
+	int32 mem_needed;
+	wifi_gscan_result_t *ptr;
+	uint16 num_scan_ids, num_results;
+	struct sk_buff *skb;
+	struct nlattr *scan_hdr;
+
+	dhd_dev_wait_batch_results_complete(bcmcfg_to_prmry_ndev(cfg));
+	dhd_dev_pno_lock_access_batch_results(bcmcfg_to_prmry_ndev(cfg));
+	results = dhd_dev_pno_get_gscan(bcmcfg_to_prmry_ndev(cfg),
+	             DHD_PNO_GET_BATCH_RESULTS, NULL, &reply_len);
+
+	if (!results) {
+		WL_ERR(("No results to send %d\n", err));
+		err =  rtw_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
+		        results, 0);
+
+		if (unlikely(err))
+			WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+		dhd_dev_pno_unlock_access_batch_results(bcmcfg_to_prmry_ndev(cfg));
+		return err;
+	}
+	num_scan_ids = reply_len & 0xFFFF;
+	num_results = (reply_len & 0xFFFF0000) >> 16;
+	mem_needed = (num_results * sizeof(wifi_gscan_result_t)) +
+	             (num_scan_ids * GSCAN_BATCH_RESULT_HDR_LEN) +
+	             VENDOR_REPLY_OVERHEAD + SCAN_RESULTS_COMPLETE_FLAG_LEN;
+
+	if (mem_needed > (int32)NLMSG_DEFAULT_SIZE) {
+		mem_needed = (int32)NLMSG_DEFAULT_SIZE;
+		complete = 0;
+	} else {
+		complete = 1;
+	}
+
+	WL_TRACE(("complete %d mem_needed %d max_mem %d\n", complete, mem_needed,
+		(int)NLMSG_DEFAULT_SIZE));
+	/* Alloc the SKB for vendor_event */
+	skb = rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, mem_needed);
+	if (unlikely(!skb)) {
+		WL_ERR(("skb alloc failed"));
+		dhd_dev_pno_unlock_access_batch_results(bcmcfg_to_prmry_ndev(cfg));
+		return -ENOMEM;
+	}
+	iter = results;
+
+	nla_put_u32(skb, GSCAN_ATTRIBUTE_SCAN_RESULTS_COMPLETE, complete);
+
+	mem_needed = mem_needed - (SCAN_RESULTS_COMPLETE_FLAG_LEN + VENDOR_REPLY_OVERHEAD);
+
+	while (iter && ((mem_needed - GSCAN_BATCH_RESULT_HDR_LEN)  > 0)) {
+		scan_hdr = nla_nest_start(skb, GSCAN_ATTRIBUTE_SCAN_RESULTS);
+		nla_put_u32(skb, GSCAN_ATTRIBUTE_SCAN_ID, iter->scan_id);
+		nla_put_u8(skb, GSCAN_ATTRIBUTE_SCAN_FLAGS, iter->flag);
+		num_results_iter =
+		    (mem_needed - GSCAN_BATCH_RESULT_HDR_LEN)/sizeof(wifi_gscan_result_t);
+
+		if ((iter->tot_count - iter->tot_consumed) < num_results_iter)
+			num_results_iter = iter->tot_count - iter->tot_consumed;
+
+		nla_put_u32(skb, GSCAN_ATTRIBUTE_NUM_OF_RESULTS, num_results_iter);
+		if (num_results_iter) {
+			ptr = &iter->results[iter->tot_consumed];
+			iter->tot_consumed += num_results_iter;
+			nla_put(skb, GSCAN_ATTRIBUTE_SCAN_RESULTS,
+			 num_results_iter * sizeof(wifi_gscan_result_t), ptr);
+		}
+		nla_nest_end(skb, scan_hdr);
+		mem_needed -= GSCAN_BATCH_RESULT_HDR_LEN +
+		    (num_results_iter * sizeof(wifi_gscan_result_t));
+		iter = iter->next;
+	}
+
+	dhd_dev_gscan_batch_cache_cleanup(bcmcfg_to_prmry_ndev(cfg));
+	dhd_dev_pno_unlock_access_batch_results(bcmcfg_to_prmry_ndev(cfg));
+
+	return rtw_cfg80211_vendor_cmd_reply(skb);
+}
+
+static int wl_cfgvendor_initiate_gscan(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	int type, tmp = len;
+	int run = 0xFF;
+	int flush = 0;
+	const struct nlattr *iter;
+
+	nla_for_each_attr(iter, data, len, tmp) {
+		type = nla_type(iter);
+		if (type == GSCAN_ATTRIBUTE_ENABLE_FEATURE)
+			run = nla_get_u32(iter);
+		else if (type == GSCAN_ATTRIBUTE_FLUSH_FEATURE)
+			flush = nla_get_u32(iter);
+	}
+
+	if (run != 0xFF) {
+		err = dhd_dev_pno_run_gscan(bcmcfg_to_prmry_ndev(cfg), run, flush);
+
+		if (unlikely(err))
+			WL_ERR(("Could not run gscan:%d \n", err));
+		return err;
+	} else {
+		return -1;
+	}
+
+
+}
+
+static int wl_cfgvendor_enable_full_scan_result(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	int type;
+	bool real_time = FALSE;
+
+	type = nla_type(data);
+
+	if (type == GSCAN_ATTRIBUTE_ENABLE_FULL_SCAN_RESULTS) {
+		real_time = nla_get_u32(data);
+
+		err = dhd_dev_pno_enable_full_scan_result(bcmcfg_to_prmry_ndev(cfg), real_time);
+
+		if (unlikely(err))
+			WL_ERR(("Could not run gscan:%d \n", err));
+
+	} else {
+		err = -1;
+	}
+
+	return err;
+}
+
+static int wl_cfgvendor_set_scan_cfg(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	gscan_scan_params_t *scan_param;
+	int j = 0;
+	int type, tmp, tmp1, tmp2, k = 0;
+	const struct nlattr *iter, *iter1, *iter2;
+	struct dhd_pno_gscan_channel_bucket  *ch_bucket;
+
+	scan_param = kzalloc(sizeof(gscan_scan_params_t), GFP_KERNEL);
+	if (!scan_param) {
+		WL_ERR(("Could not set GSCAN scan cfg, mem alloc failure\n"));
+		err = -EINVAL;
+		return err;
+
+	}
+
+	scan_param->scan_fr = PNO_SCAN_MIN_FW_SEC;
+	nla_for_each_attr(iter, data, len, tmp) {
+		type = nla_type(iter);
+
+		if (j >= GSCAN_MAX_CH_BUCKETS)
+			break;
+
+		switch (type) {
+			case GSCAN_ATTRIBUTE_BASE_PERIOD:
+				scan_param->scan_fr = nla_get_u32(iter)/1000;
+				break;
+			case GSCAN_ATTRIBUTE_NUM_BUCKETS:
+				scan_param->nchannel_buckets = nla_get_u32(iter);
+				break;
+			case GSCAN_ATTRIBUTE_CH_BUCKET_1:
+			case GSCAN_ATTRIBUTE_CH_BUCKET_2:
+			case GSCAN_ATTRIBUTE_CH_BUCKET_3:
+			case GSCAN_ATTRIBUTE_CH_BUCKET_4:
+			case GSCAN_ATTRIBUTE_CH_BUCKET_5:
+			case GSCAN_ATTRIBUTE_CH_BUCKET_6:
+			case GSCAN_ATTRIBUTE_CH_BUCKET_7:
+				nla_for_each_nested(iter1, iter, tmp1) {
+					type = nla_type(iter1);
+					ch_bucket =
+					scan_param->channel_bucket;
+
+					switch (type) {
+						case GSCAN_ATTRIBUTE_BUCKET_ID:
+						break;
+						case GSCAN_ATTRIBUTE_BUCKET_PERIOD:
+							ch_bucket[j].bucket_freq_multiple =
+							    nla_get_u32(iter1)/1000;
+							break;
+						case GSCAN_ATTRIBUTE_BUCKET_NUM_CHANNELS:
+							ch_bucket[j].num_channels =
+							     nla_get_u32(iter1);
+							break;
+						case GSCAN_ATTRIBUTE_BUCKET_CHANNELS:
+							nla_for_each_nested(iter2, iter1, tmp2) {
+								if (k >= PFN_SWC_RSSI_WINDOW_MAX)
+									break;
+								ch_bucket[j].chan_list[k] =
+								     nla_get_u32(iter2);
+								k++;
+							}
+							k = 0;
+							break;
+						case GSCAN_ATTRIBUTE_BUCKETS_BAND:
+							ch_bucket[j].band = (uint16)
+							     nla_get_u32(iter1);
+							break;
+						case GSCAN_ATTRIBUTE_REPORT_EVENTS:
+							ch_bucket[j].report_flag = (uint8)
+							     nla_get_u32(iter1);
+							break;
+					}
+				}
+				j++;
+				break;
+		}
+	}
+
+	if (dhd_dev_pno_set_cfg_gscan(bcmcfg_to_prmry_ndev(cfg),
+	     DHD_PNO_SCAN_CFG_ID, scan_param, 0) < 0) {
+		WL_ERR(("Could not set GSCAN scan cfg\n"));
+		err = -EINVAL;
+	}
+
+	kfree(scan_param);
+	return err;
+
+}
+
+static int wl_cfgvendor_hotlist_cfg(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	gscan_hotlist_scan_params_t *hotlist_params;
+	int tmp, tmp1, tmp2, type, j = 0, dummy;
+	const struct nlattr *outer, *inner, *iter;
+	uint8 flush = 0;
+	struct bssid_t *pbssid;
+
+	hotlist_params = (gscan_hotlist_scan_params_t *)kzalloc(len, GFP_KERNEL);
+	if (!hotlist_params) {
+		WL_ERR(("Cannot Malloc mem to parse config commands size - %d bytes \n", len));
+		return -1;
+	}
+
+	hotlist_params->lost_ap_window = GSCAN_LOST_AP_WINDOW_DEFAULT;
+
+	nla_for_each_attr(iter, data, len, tmp2) {
+		type = nla_type(iter);
+		switch (type) {
+			case GSCAN_ATTRIBUTE_HOTLIST_BSSIDS:
+				pbssid = hotlist_params->bssid;
+				nla_for_each_nested(outer, iter, tmp) {
+					nla_for_each_nested(inner, outer, tmp1) {
+						type = nla_type(inner);
+
+						switch (type) {
+							case GSCAN_ATTRIBUTE_BSSID:
+								memcpy(&(pbssid[j].macaddr),
+								  nla_data(inner), ETHER_ADDR_LEN);
+								break;
+							case GSCAN_ATTRIBUTE_RSSI_LOW:
+								pbssid[j].rssi_reporting_threshold =
+								         (int8) nla_get_u8(inner);
+								break;
+							case GSCAN_ATTRIBUTE_RSSI_HIGH:
+								dummy = (int8) nla_get_u8(inner);
+								break;
+						}
+					}
+					j++;
+				}
+				hotlist_params->nbssid = j;
+				break;
+			case GSCAN_ATTRIBUTE_HOTLIST_FLUSH:
+				flush = nla_get_u8(iter);
+				break;
+			case GSCAN_ATTRIBUTE_LOST_AP_SAMPLE_SIZE:
+				hotlist_params->lost_ap_window = nla_get_u32(iter);
+				break;
+			}
+
+	}
+
+	if (dhd_dev_pno_set_cfg_gscan(bcmcfg_to_prmry_ndev(cfg),
+	      DHD_PNO_GEOFENCE_SCAN_CFG_ID, hotlist_params, flush) < 0) {
+		WL_ERR(("Could not set GSCAN HOTLIST cfg\n"));
+		err = -EINVAL;
+		goto exit;
+	}
+exit:
+	kfree(hotlist_params);
+	return err;
+}
+static int wl_cfgvendor_set_batch_scan_cfg(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0, tmp, type;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	gscan_batch_params_t batch_param;
+	const struct nlattr *iter;
+
+	batch_param.mscan = batch_param.bestn = 0;
+	batch_param.buffer_threshold = GSCAN_BATCH_NO_THR_SET;
+
+	nla_for_each_attr(iter, data, len, tmp) {
+		type = nla_type(iter);
+
+		switch (type) {
+			case GSCAN_ATTRIBUTE_NUM_AP_PER_SCAN:
+				batch_param.bestn = nla_get_u32(iter);
+				break;
+			case GSCAN_ATTRIBUTE_NUM_SCANS_TO_CACHE:
+				batch_param.mscan = nla_get_u32(iter);
+				break;
+			case GSCAN_ATTRIBUTE_REPORT_THRESHOLD:
+				batch_param.buffer_threshold = nla_get_u32(iter);
+				break;
+		}
+	}
+
+	if (dhd_dev_pno_set_cfg_gscan(bcmcfg_to_prmry_ndev(cfg),
+	       DHD_PNO_BATCH_SCAN_CFG_ID, &batch_param, 0) < 0) {
+		WL_ERR(("Could not set batch cfg\n"));
+		err = -EINVAL;
+		return err;
+	}
+
+	return err;
+}
+
+static int wl_cfgvendor_significant_change_cfg(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	gscan_swc_params_t *significant_params;
+	int tmp, tmp1, tmp2, type, j = 0;
+	const struct nlattr *outer, *inner, *iter;
+	uint8 flush = 0;
+	wl_pfn_significant_bssid_t *pbssid;
+
+	significant_params = (gscan_swc_params_t *) kzalloc(len, GFP_KERNEL);
+	if (!significant_params) {
+		WL_ERR(("Cannot Malloc mem to parse config commands size - %d bytes \n", len));
+		return -1;
+	}
+
+
+	nla_for_each_attr(iter, data, len, tmp2) {
+		type = nla_type(iter);
+
+		switch (type) {
+			case GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_FLUSH:
+			flush = nla_get_u8(iter);
+			break;
+			case GSCAN_ATTRIBUTE_RSSI_SAMPLE_SIZE:
+				significant_params->rssi_window = nla_get_u16(iter);
+				break;
+			case GSCAN_ATTRIBUTE_LOST_AP_SAMPLE_SIZE:
+				significant_params->lost_ap_window = nla_get_u16(iter);
+				break;
+			case GSCAN_ATTRIBUTE_MIN_BREACHING:
+				significant_params->swc_threshold = nla_get_u16(iter);
+				break;
+			case GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_BSSIDS:
+				pbssid = significant_params->bssid_elem_list;
+				nla_for_each_nested(outer, iter, tmp) {
+					nla_for_each_nested(inner, outer, tmp1) {
+							switch (nla_type(inner)) {
+								case GSCAN_ATTRIBUTE_BSSID:
+								memcpy(&(pbssid[j].macaddr),
+								     nla_data(inner),
+								     ETHER_ADDR_LEN);
+								break;
+								case GSCAN_ATTRIBUTE_RSSI_HIGH:
+								pbssid[j].rssi_high_threshold =
+								       (int8) nla_get_u8(inner);
+								break;
+								case GSCAN_ATTRIBUTE_RSSI_LOW:
+								pbssid[j].rssi_low_threshold =
+								      (int8) nla_get_u8(inner);
+								break;
+							}
+						}
+					j++;
+				}
+				break;
+		}
+	}
+	significant_params->nbssid = j;
+
+	if (dhd_dev_pno_set_cfg_gscan(bcmcfg_to_prmry_ndev(cfg),
+	    DHD_PNO_SIGNIFICANT_SCAN_CFG_ID, significant_params, flush) < 0) {
+		WL_ERR(("Could not set GSCAN significant cfg\n"));
+		err = -EINVAL;
+		goto exit;
+	}
+exit:
+	kfree(significant_params);
+	return err;
+}
+#endif /* GSCAN_SUPPORT */
+
+#if defined(RTT_SUPPORT) && 0
+void wl_cfgvendor_rtt_evt(void *ctx, void *rtt_data)
+{
+	struct wireless_dev *wdev = (struct wireless_dev *)ctx;
+	struct wiphy *wiphy;
+	struct sk_buff *skb;
+	uint32 tot_len = NLMSG_DEFAULT_SIZE, entry_len = 0;
+	gfp_t kflags;
+	rtt_report_t *rtt_report = NULL;
+	rtt_result_t *rtt_result = NULL;
+	struct list_head *rtt_list;
+	wiphy = wdev->wiphy;
+
+	WL_DBG(("In\n"));
+	/* Push the data to the skb */
+	if (!rtt_data) {
+		WL_ERR(("rtt_data is NULL\n"));
+		goto exit;
+	}
+	rtt_list = (struct list_head *)rtt_data;
+	kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	/* Alloc the SKB for vendor_event */
+	skb = rtw_cfg80211_vendor_event_alloc(wiphy, tot_len, GOOGLE_RTT_COMPLETE_EVENT, kflags);
+	if (!skb) {
+		WL_ERR(("skb alloc failed"));
+		goto exit;
+	}
+	/* fill in the rtt results on each entry */
+	list_for_each_entry(rtt_result, rtt_list, list) {
+		entry_len = 0;
+		if (rtt_result->TOF_type == TOF_TYPE_ONE_WAY) {
+			entry_len = sizeof(rtt_report_t);
+			rtt_report = kzalloc(entry_len, kflags);
+			if (!rtt_report) {
+				WL_ERR(("rtt_report alloc failed"));
+				goto exit;
+			}
+			rtt_report->addr = rtt_result->peer_mac;
+			rtt_report->num_measurement = 1; /* ONE SHOT */
+			rtt_report->status = rtt_result->err_code;
+			rtt_report->type = (rtt_result->TOF_type == TOF_TYPE_ONE_WAY) ? RTT_ONE_WAY: RTT_TWO_WAY;
+			rtt_report->peer = rtt_result->target_info->peer;
+			rtt_report->channel = rtt_result->target_info->channel;
+			rtt_report->rssi = rtt_result->avg_rssi;
+			/* tx_rate */
+			rtt_report->tx_rate = rtt_result->tx_rate;
+			/* RTT */
+			rtt_report->rtt = rtt_result->meanrtt;
+			rtt_report->rtt_sd = rtt_result->sdrtt;
+			/* convert to centi meter */
+			if (rtt_result->distance != 0xffffffff)
+				rtt_report->distance = (rtt_result->distance >> 2) * 25;
+			else /* invalid distance */
+				rtt_report->distance = -1;
+
+			rtt_report->ts = rtt_result->ts;
+			nla_append(skb, entry_len, rtt_report);
+			kfree(rtt_report);
+		}
+	}
+	rtw_cfg80211_vendor_event(skb, kflags);
+exit:
+	return;
+}
+
+static int wl_cfgvendor_rtt_set_config(struct wiphy *wiphy, struct wireless_dev *wdev,
+					const void *data, int len) {
+	int err = 0, rem, rem1, rem2, type;
+	rtt_config_params_t rtt_param;
+	rtt_target_info_t* rtt_target = NULL;
+	const struct nlattr *iter, *iter1, *iter2;
+	int8 eabuf[ETHER_ADDR_STR_LEN];
+	int8 chanbuf[CHANSPEC_STR_LEN];
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+
+	WL_DBG(("In\n"));
+	err = dhd_dev_rtt_register_noti_callback(wdev->netdev, wdev, wl_cfgvendor_rtt_evt);
+	if (err < 0) {
+		WL_ERR(("failed to register rtt_noti_callback\n"));
+		goto exit;
+	}
+	memset(&rtt_param, 0, sizeof(rtt_param));
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case RTT_ATTRIBUTE_TARGET_CNT:
+			rtt_param.rtt_target_cnt = nla_get_u8(iter);
+			if (rtt_param.rtt_target_cnt > RTT_MAX_TARGET_CNT) {
+				WL_ERR(("exceed max target count : %d\n",
+					rtt_param.rtt_target_cnt));
+				err = BCME_RANGE;
+			}
+			break;
+		case RTT_ATTRIBUTE_TARGET_INFO:
+			rtt_target = rtt_param.target_info;
+			nla_for_each_nested(iter1, iter, rem1) {
+				nla_for_each_nested(iter2, iter1, rem2) {
+					type = nla_type(iter2);
+					switch (type) {
+					case RTT_ATTRIBUTE_TARGET_MAC:
+						memcpy(&rtt_target->addr, nla_data(iter2), ETHER_ADDR_LEN);
+						break;
+					case RTT_ATTRIBUTE_TARGET_TYPE:
+						rtt_target->type = nla_get_u8(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_PEER:
+						rtt_target->peer= nla_get_u8(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_CHAN:
+						memcpy(&rtt_target->channel, nla_data(iter2),
+							sizeof(rtt_target->channel));
+						break;
+					case RTT_ATTRIBUTE_TARGET_MODE:
+						rtt_target->continuous = nla_get_u8(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_INTERVAL:
+						rtt_target->interval = nla_get_u32(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_NUM_MEASUREMENT:
+						rtt_target->measure_cnt = nla_get_u32(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_NUM_PKT:
+						rtt_target->ftm_cnt = nla_get_u32(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_NUM_RETRY:
+						rtt_target->retry_cnt = nla_get_u32(iter2);
+					}
+				}
+				/* convert to chanspec value */
+				rtt_target->chanspec = dhd_rtt_convert_to_chspec(rtt_target->channel);
+				if (rtt_target->chanspec == 0) {
+					WL_ERR(("Channel is not valid \n"));
+					goto exit;
+				}
+				WL_INFORM(("Target addr %s, Channel : %s for RTT \n",
+					bcm_ether_ntoa((const struct ether_addr *)&rtt_target->addr, eabuf),
+					wf_chspec_ntoa(rtt_target->chanspec, chanbuf)));
+				rtt_target++;
+			}
+			break;
+		}
+	}
+	WL_DBG(("leave :target_cnt : %d\n", rtt_param.rtt_target_cnt));
+	if (dhd_dev_rtt_set_cfg(bcmcfg_to_prmry_ndev(cfg), &rtt_param) < 0) {
+		WL_ERR(("Could not set RTT configuration\n"));
+		err = -EINVAL;
+	}
+exit:
+	return err;
+}
+
+static int wl_cfgvendor_rtt_cancel_config(struct wiphy *wiphy, struct wireless_dev *wdev,
+					const void *data, int len)
+{
+	int err = 0, rem, type, target_cnt = 0;
+	const struct nlattr *iter;
+	struct ether_addr *mac_list = NULL, *mac_addr = NULL;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case RTT_ATTRIBUTE_TARGET_CNT:
+			target_cnt = nla_get_u8(iter);
+			mac_list = (struct ether_addr *)kzalloc(target_cnt * ETHER_ADDR_LEN , GFP_KERNEL);
+			if (mac_list == NULL) {
+				WL_ERR(("failed to allocate mem for mac list\n"));
+				goto exit;
+			}
+			mac_addr = &mac_list[0];
+			break;
+		case RTT_ATTRIBUTE_TARGET_MAC:
+			if (mac_addr)
+				memcpy(mac_addr++, nla_data(iter), ETHER_ADDR_LEN);
+			else {
+				WL_ERR(("mac_list is NULL\n"));
+				goto exit;
+			}
+			break;
+		}
+		if (dhd_dev_rtt_cancel_cfg(bcmcfg_to_prmry_ndev(cfg), mac_list, target_cnt) < 0) {
+			WL_ERR(("Could not cancel RTT configuration\n"));
+			err = -EINVAL;
+			goto exit;
+		}
+	}
+exit:
+	if (mac_list)
+		kfree(mac_list);
+	return err;
+}
+static int wl_cfgvendor_rtt_get_capability(struct wiphy *wiphy, struct wireless_dev *wdev,
+					const void *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	rtt_capabilities_t capability;
+
+	err = dhd_dev_rtt_capability(bcmcfg_to_prmry_ndev(cfg), &capability);
+	if (unlikely(err)) {
+		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+		goto exit;
+	}
+	err =  rtw_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
+	        &capability, sizeof(capability));
+
+	if (unlikely(err)) {
+		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+	}
+exit:
+	return err;
+}
+
+#endif /* RTT_SUPPORT */
+static int wl_cfgvendor_priv_string_handler(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	u8 resp[1] = {'\0'};
+
+	DBG_871X_LEVEL(_drv_always_, FUNC_NDEV_FMT" %s\n", FUNC_NDEV_ARG(wdev_to_ndev(wdev)), (char*)data);
+	err =  rtw_cfgvendor_send_cmd_reply(wiphy, wdev_to_ndev(wdev), resp, 1);
+	if (unlikely(err))
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT"Vendor Command reply failed ret:%d \n"
+			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)), err);
+
+	return err;
+#if 0
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	int err = 0;
+	int data_len = 0;
+
+	bzero(cfg->ioctl_buf, WLC_IOCTL_MAXLEN);
+
+	if (strncmp((char *)data, BRCM_VENDOR_SCMD_CAPA, strlen(BRCM_VENDOR_SCMD_CAPA)) == 0) {
+		err = wldev_iovar_getbuf(bcmcfg_to_prmry_ndev(cfg), "cap", NULL, 0,
+			cfg->ioctl_buf, WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
+		if (unlikely(err)) {
+			WL_ERR(("error (%d)\n", err));
+			return err;
+		}
+		data_len = strlen(cfg->ioctl_buf);
+		cfg->ioctl_buf[data_len] = '\0';
+	}
+
+	err =  rtw_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
+		cfg->ioctl_buf, data_len+1);
+	if (unlikely(err))
+		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+	else
+		WL_INFORM(("Vendor Command reply sent successfully!\n"));
+
+	return err;
+#endif
+}
+
+static const struct wiphy_vendor_command rtw_vendor_cmds [] = {
+	{
+		{
+			.vendor_id = OUI_BRCM,
+			.subcmd = BRCM_VENDOR_SCMD_PRIV_STR
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_priv_string_handler,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+#if defined(GSCAN_SUPPORT) && 0
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_GET_CAPABILITIES
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_gscan_get_capabilities,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_SET_CONFIG
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_set_scan_cfg,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_SET_SCAN_CONFIG
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_set_batch_scan_cfg,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_ENABLE_GSCAN
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_initiate_gscan,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_enable_full_scan_result,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_SET_HOTLIST
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_hotlist_cfg,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_significant_change_cfg,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_GET_SCAN_RESULTS
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_gscan_get_batch_results,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_GET_CHANNEL_LIST
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_gscan_get_channel_list,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+#endif /* GSCAN_SUPPORT */
+#if defined(RTT_SUPPORT) && 0
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = RTT_SUBCMD_SET_CONFIG
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_rtt_set_config,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = RTT_SUBCMD_CANCEL_CONFIG
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_rtt_cancel_config,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = RTT_SUBCMD_GETCAPABILITY
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_rtt_get_capability,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+#endif /* RTT_SUPPORT */
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = ANDR_WIFI_SUBCMD_GET_FEATURE_SET
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = rtw_cfgvendor_get_feature_set,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = ANDR_WIFI_SUBCMD_GET_FEATURE_SET_MATRIX
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = rtw_cfgvendor_get_feature_set_matrix,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	}
+};
+
+static const struct  nl80211_vendor_cmd_info rtw_vendor_events [] = {
+		{ OUI_BRCM, BRCM_VENDOR_EVENT_UNSPEC },
+		{ OUI_BRCM, BRCM_VENDOR_EVENT_PRIV_STR },
+#if defined(GSCAN_SUPPORT) && 0
+		{ OUI_GOOGLE, GOOGLE_GSCAN_SIGNIFICANT_EVENT },
+		{ OUI_GOOGLE, GOOGLE_GSCAN_GEOFENCE_FOUND_EVENT },
+		{ OUI_GOOGLE, GOOGLE_GSCAN_BATCH_SCAN_EVENT },
+		{ OUI_GOOGLE, GOOGLE_SCAN_FULL_RESULTS_EVENT },
+#endif /* GSCAN_SUPPORT */
+#if defined(RTT_SUPPORT) && 0
+		{ OUI_GOOGLE, GOOGLE_RTT_COMPLETE_EVENT },
+#endif /* RTT_SUPPORT */
+#if defined(GSCAN_SUPPORT) && 0
+		{ OUI_GOOGLE, GOOGLE_SCAN_COMPLETE_EVENT },
+		{ OUI_GOOGLE, GOOGLE_GSCAN_GEOFENCE_LOST_EVENT }
+#endif /* GSCAN_SUPPORT */
+};
+
+int rtw_cfgvendor_attach(struct wiphy *wiphy)
+{
+
+	DBG_871X("Register RTW cfg80211 vendor cmd(0x%x) interface \n", NL80211_CMD_VENDOR);
+
+	wiphy->vendor_commands	= rtw_vendor_cmds;
+	wiphy->n_vendor_commands = ARRAY_SIZE(rtw_vendor_cmds);
+	wiphy->vendor_events	= rtw_vendor_events;
+	wiphy->n_vendor_events	= ARRAY_SIZE(rtw_vendor_events);
+
+	return 0;
+}
+
+int rtw_cfgvendor_detach(struct wiphy *wiphy)
+{
+	DBG_871X("Vendor: Unregister RTW cfg80211 vendor interface \n");
+
+	wiphy->vendor_commands  = NULL;
+	wiphy->vendor_events    = NULL;
+	wiphy->n_vendor_commands = 0;
+	wiphy->n_vendor_events  = 0;
+
+	return 0;
+}
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT) */
+
+#endif /* CONFIG_IOCTL_CFG80211 */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_cfgvendor.h b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_cfgvendor.h
new file mode 100644
index 000000000..7c349e79d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_cfgvendor.h
@@ -0,0 +1,246 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2014 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef _RTW_CFGVENDOR_H_
+#define _RTW_CFGVENDOR_H_
+
+#define OUI_BRCM    0x001018
+#define OUI_GOOGLE  0x001A11
+#define BRCM_VENDOR_SUBCMD_PRIV_STR	1
+#define ATTRIBUTE_U32_LEN                  (NLA_HDRLEN  + 4)
+#define VENDOR_ID_OVERHEAD                 ATTRIBUTE_U32_LEN
+#define VENDOR_SUBCMD_OVERHEAD             ATTRIBUTE_U32_LEN
+#define VENDOR_DATA_OVERHEAD               (NLA_HDRLEN)
+
+#define SCAN_RESULTS_COMPLETE_FLAG_LEN       ATTRIBUTE_U32_LEN
+#define SCAN_INDEX_HDR_LEN                   (NLA_HDRLEN)
+#define SCAN_ID_HDR_LEN                      ATTRIBUTE_U32_LEN
+#define SCAN_FLAGS_HDR_LEN                   ATTRIBUTE_U32_LEN
+#define GSCAN_NUM_RESULTS_HDR_LEN            ATTRIBUTE_U32_LEN
+#define GSCAN_RESULTS_HDR_LEN                (NLA_HDRLEN)
+#define GSCAN_BATCH_RESULT_HDR_LEN  (SCAN_INDEX_HDR_LEN + SCAN_ID_HDR_LEN + \
+									SCAN_FLAGS_HDR_LEN + \
+							        GSCAN_NUM_RESULTS_HDR_LEN + \
+									GSCAN_RESULTS_HDR_LEN)
+
+#define VENDOR_REPLY_OVERHEAD       (VENDOR_ID_OVERHEAD + \
+									VENDOR_SUBCMD_OVERHEAD + \
+									VENDOR_DATA_OVERHEAD)
+typedef enum {
+	/* don't use 0 as a valid subcommand */
+	VENDOR_NL80211_SUBCMD_UNSPECIFIED,
+
+	/* define all vendor startup commands between 0x0 and 0x0FFF */
+	VENDOR_NL80211_SUBCMD_RANGE_START = 0x0001,
+	VENDOR_NL80211_SUBCMD_RANGE_END   = 0x0FFF,
+
+	/* define all GScan related commands between 0x1000 and 0x10FF */
+	ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START = 0x1000,
+	ANDROID_NL80211_SUBCMD_GSCAN_RANGE_END   = 0x10FF,
+
+	/* define all NearbyDiscovery related commands between 0x1100 and 0x11FF */
+	ANDROID_NL80211_SUBCMD_NBD_RANGE_START = 0x1100,
+	ANDROID_NL80211_SUBCMD_NBD_RANGE_END   = 0x11FF,
+
+	/* define all RTT related commands between 0x1100 and 0x11FF */
+	ANDROID_NL80211_SUBCMD_RTT_RANGE_START = 0x1100,
+	ANDROID_NL80211_SUBCMD_RTT_RANGE_END   = 0x11FF,
+
+	ANDROID_NL80211_SUBCMD_LSTATS_RANGE_START = 0x1200,
+	ANDROID_NL80211_SUBCMD_LSTATS_RANGE_END   = 0x12FF,
+
+	ANDROID_NL80211_SUBCMD_TDLS_RANGE_START = 0x1300,
+	ANDROID_NL80211_SUBCMD_TDLS_RANGE_END	= 0x13FF,
+	/* This is reserved for future usage */
+
+} ANDROID_VENDOR_SUB_COMMAND;
+
+enum wl_vendor_subcmd {
+	BRCM_VENDOR_SCMD_UNSPEC,
+	BRCM_VENDOR_SCMD_PRIV_STR,
+	GSCAN_SUBCMD_GET_CAPABILITIES = ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START,
+	GSCAN_SUBCMD_SET_CONFIG,
+	GSCAN_SUBCMD_SET_SCAN_CONFIG,
+	GSCAN_SUBCMD_ENABLE_GSCAN,
+	GSCAN_SUBCMD_GET_SCAN_RESULTS,
+	GSCAN_SUBCMD_SCAN_RESULTS,
+	GSCAN_SUBCMD_SET_HOTLIST,
+	GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG,
+	GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS,
+	GSCAN_SUBCMD_GET_CHANNEL_LIST,
+	ANDR_WIFI_SUBCMD_GET_FEATURE_SET,
+	ANDR_WIFI_SUBCMD_GET_FEATURE_SET_MATRIX,
+	RTT_SUBCMD_SET_CONFIG = ANDROID_NL80211_SUBCMD_RTT_RANGE_START,
+	RTT_SUBCMD_CANCEL_CONFIG,
+	RTT_SUBCMD_GETCAPABILITY,
+    /* Add more sub commands here */
+    VENDOR_SUBCMD_MAX
+};
+
+enum gscan_attributes {
+    GSCAN_ATTRIBUTE_NUM_BUCKETS = 10,
+    GSCAN_ATTRIBUTE_BASE_PERIOD,
+    GSCAN_ATTRIBUTE_BUCKETS_BAND,
+    GSCAN_ATTRIBUTE_BUCKET_ID,
+    GSCAN_ATTRIBUTE_BUCKET_PERIOD,
+    GSCAN_ATTRIBUTE_BUCKET_NUM_CHANNELS,
+    GSCAN_ATTRIBUTE_BUCKET_CHANNELS,
+    GSCAN_ATTRIBUTE_NUM_AP_PER_SCAN,
+    GSCAN_ATTRIBUTE_REPORT_THRESHOLD,
+    GSCAN_ATTRIBUTE_NUM_SCANS_TO_CACHE,
+    GSCAN_ATTRIBUTE_BAND = GSCAN_ATTRIBUTE_BUCKETS_BAND,
+
+    GSCAN_ATTRIBUTE_ENABLE_FEATURE = 20,
+    GSCAN_ATTRIBUTE_SCAN_RESULTS_COMPLETE,
+    GSCAN_ATTRIBUTE_FLUSH_FEATURE,
+    GSCAN_ATTRIBUTE_ENABLE_FULL_SCAN_RESULTS,
+    GSCAN_ATTRIBUTE_REPORT_EVENTS,
+    /* remaining reserved for additional attributes */
+    GSCAN_ATTRIBUTE_NUM_OF_RESULTS = 30,
+    GSCAN_ATTRIBUTE_FLUSH_RESULTS,
+    GSCAN_ATTRIBUTE_SCAN_RESULTS,                       /* flat array of wifi_scan_result */
+    GSCAN_ATTRIBUTE_SCAN_ID,                            /* indicates scan number */
+    GSCAN_ATTRIBUTE_SCAN_FLAGS,                         /* indicates if scan was aborted */
+    GSCAN_ATTRIBUTE_AP_FLAGS,                           /* flags on significant change event */
+    GSCAN_ATTRIBUTE_NUM_CHANNELS,
+    GSCAN_ATTRIBUTE_CHANNEL_LIST,
+
+	/* remaining reserved for additional attributes */
+
+    GSCAN_ATTRIBUTE_SSID = 40,
+    GSCAN_ATTRIBUTE_BSSID,
+    GSCAN_ATTRIBUTE_CHANNEL,
+    GSCAN_ATTRIBUTE_RSSI,
+    GSCAN_ATTRIBUTE_TIMESTAMP,
+    GSCAN_ATTRIBUTE_RTT,
+    GSCAN_ATTRIBUTE_RTTSD,
+
+    /* remaining reserved for additional attributes */
+
+    GSCAN_ATTRIBUTE_HOTLIST_BSSIDS = 50,
+    GSCAN_ATTRIBUTE_RSSI_LOW,
+    GSCAN_ATTRIBUTE_RSSI_HIGH,
+    GSCAN_ATTRIBUTE_HOSTLIST_BSSID_ELEM,
+    GSCAN_ATTRIBUTE_HOTLIST_FLUSH,
+
+    /* remaining reserved for additional attributes */
+    GSCAN_ATTRIBUTE_RSSI_SAMPLE_SIZE = 60,
+    GSCAN_ATTRIBUTE_LOST_AP_SAMPLE_SIZE,
+    GSCAN_ATTRIBUTE_MIN_BREACHING,
+    GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_BSSIDS,
+    GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_FLUSH,
+    GSCAN_ATTRIBUTE_MAX
+};
+
+enum gscan_bucket_attributes {
+	GSCAN_ATTRIBUTE_CH_BUCKET_1,
+	GSCAN_ATTRIBUTE_CH_BUCKET_2,
+	GSCAN_ATTRIBUTE_CH_BUCKET_3,
+	GSCAN_ATTRIBUTE_CH_BUCKET_4,
+	GSCAN_ATTRIBUTE_CH_BUCKET_5,
+	GSCAN_ATTRIBUTE_CH_BUCKET_6,
+	GSCAN_ATTRIBUTE_CH_BUCKET_7
+};
+
+enum gscan_ch_attributes {
+	GSCAN_ATTRIBUTE_CH_ID_1,
+	GSCAN_ATTRIBUTE_CH_ID_2,
+	GSCAN_ATTRIBUTE_CH_ID_3,
+	GSCAN_ATTRIBUTE_CH_ID_4,
+	GSCAN_ATTRIBUTE_CH_ID_5,
+	GSCAN_ATTRIBUTE_CH_ID_6,
+	GSCAN_ATTRIBUTE_CH_ID_7
+};
+
+enum rtt_attributes {
+	RTT_ATTRIBUTE_TARGET_CNT,
+	RTT_ATTRIBUTE_TARGET_INFO,
+	RTT_ATTRIBUTE_TARGET_MAC,
+	RTT_ATTRIBUTE_TARGET_TYPE,
+	RTT_ATTRIBUTE_TARGET_PEER,
+	RTT_ATTRIBUTE_TARGET_CHAN,
+	RTT_ATTRIBUTE_TARGET_MODE,
+	RTT_ATTRIBUTE_TARGET_INTERVAL,
+	RTT_ATTRIBUTE_TARGET_NUM_MEASUREMENT,
+	RTT_ATTRIBUTE_TARGET_NUM_PKT,
+	RTT_ATTRIBUTE_TARGET_NUM_RETRY
+};
+
+typedef enum wl_vendor_event {
+	BRCM_VENDOR_EVENT_UNSPEC,
+	BRCM_VENDOR_EVENT_PRIV_STR,
+	GOOGLE_GSCAN_SIGNIFICANT_EVENT,
+	GOOGLE_GSCAN_GEOFENCE_FOUND_EVENT,
+	GOOGLE_GSCAN_BATCH_SCAN_EVENT,
+	GOOGLE_SCAN_FULL_RESULTS_EVENT,
+	GOOGLE_RTT_COMPLETE_EVENT,
+	GOOGLE_SCAN_COMPLETE_EVENT,
+	GOOGLE_GSCAN_GEOFENCE_LOST_EVENT
+} wl_vendor_event_t;
+
+enum andr_wifi_feature_set_attr {
+    ANDR_WIFI_ATTRIBUTE_NUM_FEATURE_SET,
+    ANDR_WIFI_ATTRIBUTE_FEATURE_SET
+};
+
+typedef enum wl_vendor_gscan_attribute {
+	ATTR_START_GSCAN,
+	ATTR_STOP_GSCAN,
+	ATTR_SET_SCAN_BATCH_CFG_ID, /* set batch scan params */
+	ATTR_SET_SCAN_GEOFENCE_CFG_ID, /* set list of bssids to track */
+	ATTR_SET_SCAN_SIGNIFICANT_CFG_ID, /* set list of bssids, rssi threshold etc.. */
+	ATTR_SET_SCAN_CFG_ID, /* set common scan config params here */
+	ATTR_GET_GSCAN_CAPABILITIES_ID,
+    /* Add more sub commands here */
+    ATTR_GSCAN_MAX
+} wl_vendor_gscan_attribute_t;
+
+typedef enum gscan_batch_attribute {
+	ATTR_GSCAN_BATCH_BESTN,
+	ATTR_GSCAN_BATCH_MSCAN,
+	ATTR_GSCAN_BATCH_BUFFER_THRESHOLD
+} gscan_batch_attribute_t;
+
+typedef enum gscan_geofence_attribute {
+	ATTR_GSCAN_NUM_HOTLIST_BSSID,
+	ATTR_GSCAN_HOTLIST_BSSID
+} gscan_geofence_attribute_t;
+
+typedef enum gscan_complete_event {
+	WIFI_SCAN_BUFFER_FULL,
+	WIFI_SCAN_COMPLETE
+} gscan_complete_event_t;
+
+/* Capture the BRCM_VENDOR_SUBCMD_PRIV_STRINGS* here */
+#define BRCM_VENDOR_SCMD_CAPA	"cap"
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT)
+extern int rtw_cfgvendor_attach(struct wiphy *wiphy);
+extern int rtw_cfgvendor_detach(struct wiphy *wiphy);
+extern int rtw_cfgvendor_send_async_event(struct wiphy *wiphy,
+                  struct net_device *dev, int event_id, const void  *data, int len);
+#if defined(GSCAN_SUPPORT) && 0
+extern int wl_cfgvendor_send_hotlist_event(struct wiphy *wiphy,
+                struct net_device *dev, void  *data, int len, wl_vendor_event_t event);
+#endif
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT) */
+
+#endif /* _RTW_CFGVENDOR_H_ */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_proc.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_proc.c
new file mode 100644
index 000000000..ca72f43f8
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_proc.c
@@ -0,0 +1,2072 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#include <linux/ctype.h>	/* tolower() */
+#include <drv_types.h>
+#include <hal_data.h>
+#include "rtw_proc.h"
+#ifdef CONFIG_BT_COEXIST
+#include <rtw_btcoex.h>
+#endif
+
+#ifdef CONFIG_PROC_DEBUG
+
+static struct proc_dir_entry *rtw_proc = NULL;
+
+inline struct proc_dir_entry *get_rtw_drv_proc(void)
+{
+	return rtw_proc;
+}
+
+#define RTW_PROC_NAME DRV_NAME
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0))
+#define file_inode(file) ((file)->f_dentry->d_inode)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0))
+#define PDE_DATA(inode) PDE((inode))->data
+#define proc_get_parent_data(inode) PDE((inode))->parent->data
+#endif
+
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#define get_proc_net proc_net
+#else
+#define get_proc_net init_net.proc_net
+#endif
+
+inline struct proc_dir_entry *rtw_proc_create_dir(const char *name, struct proc_dir_entry *parent, void *data)
+{
+	struct proc_dir_entry *entry;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
+	entry = proc_mkdir_data(name, S_IRUGO|S_IXUGO, parent, data);
+#else
+	//entry = proc_mkdir_mode(name, S_IRUGO|S_IXUGO, parent);
+	entry = proc_mkdir(name, parent);
+	if (entry)
+		entry->data = data;
+#endif
+
+	return entry;
+}
+
+inline struct proc_dir_entry *rtw_proc_create_entry(const char *name, struct proc_dir_entry *parent,
+#if 1 //(LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0))
+	#pragma message "Greater or equal 5.6.0" 
+	const struct proc_ops *fops,
+#else
+	#pragma message "Lower than 5.6.0 : " LINUX_VERSION_CODE
+	const struct file_operations *fops,
+#endif
+	void * data)
+{
+	struct proc_dir_entry *entry;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+	entry = proc_create_data(name,  S_IFREG|S_IRUGO|S_IWUGO, parent, fops, data);
+#else
+	entry = create_proc_entry(name, S_IFREG|S_IRUGO|S_IWUGO, parent);
+	if (entry) {
+		entry->data = data;
+		entry->proc_fops = fops;
+	}
+#endif
+
+	return entry;
+}
+
+static int proc_get_dummy(struct seq_file *m, void *v)
+{
+	return 0;
+}
+
+static int proc_get_drv_version(struct seq_file *m, void *v)
+{
+	dump_drv_version(m);
+	return 0;
+}
+
+static int proc_get_log_level(struct seq_file *m, void *v)
+{
+	dump_log_level(m);
+	return 0;
+}
+
+static int proc_get_drv_cfg(struct seq_file *m, void *v)
+{
+	dump_drv_cfg(m);
+	return 0;
+}
+
+static ssize_t proc_set_log_level(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	char tmp[32];
+	int log_level;
+
+	if (count < 1)
+		return -EINVAL;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%d ", &log_level);
+
+		if( log_level >= _drv_always_ && log_level <= _drv_debug_ )
+		{
+			GlobalDebugLevel= log_level;
+			printk("%d\n", GlobalDebugLevel);
+		}
+	} else {
+		return -EFAULT;
+	}
+
+	return count;
+}
+
+#ifdef DBG_MEM_ALLOC
+static int proc_get_mstat(struct seq_file *m, void *v)
+{
+	rtw_mstat_dump(m);
+	return 0;
+}
+#endif /* DBG_MEM_ALLOC */
+
+static int proc_get_chplan_id_list(struct seq_file *m, void *v)
+{
+	dump_chplan_id_list(m);
+	return 0;
+}
+
+static int proc_get_chplan_test(struct seq_file *m, void *v)
+{
+	dump_chplan_test(m);
+	return 0;
+}
+
+/*
+* rtw_drv_proc:
+* init/deinit when register/unregister driver
+*/
+const struct rtw_proc_hdl drv_proc_hdls [] = {
+	{"ver_info", proc_get_drv_version, NULL},
+	{"log_level", proc_get_log_level, proc_set_log_level},
+	{"drv_cfg", proc_get_drv_cfg, NULL},
+#ifdef DBG_MEM_ALLOC
+	{"mstat", proc_get_mstat, NULL},
+#endif /* DBG_MEM_ALLOC */
+	{"chplan_id_list", proc_get_chplan_id_list, NULL},
+	{"chplan_test", proc_get_chplan_test, NULL},
+};
+
+const int drv_proc_hdls_num = sizeof(drv_proc_hdls) / sizeof(struct rtw_proc_hdl);
+
+static int rtw_drv_proc_open(struct inode *inode, struct file *file)
+{
+	//struct net_device *dev = proc_get_parent_data(inode);
+	ssize_t index = (ssize_t)PDE_DATA(inode);
+	const struct rtw_proc_hdl *hdl = drv_proc_hdls+index;
+       return single_open(file, hdl->show, NULL);
+}
+
+static ssize_t rtw_drv_proc_write(struct file *file, const char __user *buffer, size_t count, loff_t *pos)
+{
+	ssize_t index = (ssize_t)PDE_DATA(file_inode(file));
+	const struct rtw_proc_hdl *hdl = drv_proc_hdls+index;
+	ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *, void *) = hdl->write;
+
+	if (write)
+		return write(file, buffer, count, pos, NULL);
+
+	return -EROFS;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0))
+static const struct proc_ops rtw_drv_proc_fops = {
+	.proc_open = rtw_drv_proc_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+	.proc_write = rtw_drv_proc_write,
+};
+#else
+static const struct file_operations rtw_drv_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = rtw_drv_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = rtw_drv_proc_write,
+};
+#endif
+
+int rtw_drv_proc_init(void)
+{
+	int ret = _FAIL;
+	ssize_t i;
+	struct proc_dir_entry *entry = NULL;
+
+	if (rtw_proc != NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	rtw_proc = rtw_proc_create_dir(RTW_PROC_NAME, get_proc_net, NULL);
+
+	if (rtw_proc == NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	for (i=0;i<drv_proc_hdls_num;i++) {
+		entry = rtw_proc_create_entry(drv_proc_hdls[i].name, rtw_proc, &rtw_drv_proc_fops, (void *)i);
+		if (!entry) {
+			rtw_warn_on(1);
+			goto exit;
+		}
+	}
+
+	ret = _SUCCESS;
+
+exit:
+	return ret;
+}
+
+void rtw_drv_proc_deinit(void)
+{
+	int i;
+
+	if (rtw_proc == NULL)
+		return;
+
+	for (i=0;i<drv_proc_hdls_num;i++)
+		remove_proc_entry(drv_proc_hdls[i].name, rtw_proc);
+
+	remove_proc_entry(RTW_PROC_NAME, get_proc_net);
+	rtw_proc = NULL;
+}
+
+#ifdef CONFIG_SDIO_HCI
+static int proc_get_sd_f0_reg_dump(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	sd_f0_reg_dump(m, adapter);
+
+	return 0;
+}
+
+static int proc_get_sdio_local_reg_dump(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	sdio_local_reg_dump(m, adapter);
+
+	return 0;
+}
+#endif /* CONFIG_SDIO_HCI */
+
+static int proc_get_mac_reg_dump(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	mac_reg_dump(m, adapter);
+
+	return 0;
+}
+
+static int proc_get_bb_reg_dump(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	bb_reg_dump(m, adapter);
+
+	return 0;
+}
+
+static int proc_get_rf_reg_dump(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rf_reg_dump(m, adapter);
+
+	return 0;
+}
+
+static int proc_get_dump_adapters_status(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	dump_adapters_status(m, adapter_to_dvobj(adapter));
+
+	return 0;
+}
+
+//gpio setting
+#ifdef CONFIG_GPIO_API
+static ssize_t proc_set_config_gpio(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32]={0};
+	int num=0,gpio_pin=0,gpio_mode=0;//gpio_mode:0 input  1:output;
+
+	if (count < 2)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+		num	=sscanf(tmp, "%d %d",&gpio_pin,&gpio_mode);
+		DBG_871X("num=%d gpio_pin=%d mode=%d\n",num,gpio_pin,gpio_mode);
+		padapter->pre_gpio_pin=gpio_pin;
+		if(gpio_mode==0 || gpio_mode==1  )
+			rtw_hal_config_gpio(padapter, gpio_pin,gpio_mode);
+	}
+	return count;
+}
+
+static ssize_t proc_set_gpio_output_value(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32]={0};
+	int num=0,gpio_pin=0,pin_mode=0;//pin_mode: 1 high         0:low
+
+	if (count < 2)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+		num	=sscanf(tmp, "%d %d",&gpio_pin,&pin_mode);
+		DBG_871X("num=%d gpio_pin=%d pin_high=%d\n",num,gpio_pin,pin_mode);
+		padapter->pre_gpio_pin=gpio_pin;
+		if(pin_mode==0 || pin_mode==1  )
+			rtw_hal_set_gpio_output_value(padapter, gpio_pin,pin_mode);
+	}
+	return count;
+}
+
+static int proc_get_gpio(struct seq_file *m, void *v)
+{
+	u8 gpioreturnvalue=0;
+	struct net_device *dev = m->private;
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	if(!padapter)
+		return -EFAULT;
+	gpioreturnvalue = rtw_hal_get_gpio(padapter, padapter->pre_gpio_pin);
+	DBG_871X_SEL_NL(m, "get_gpio %d:%d \n",padapter->pre_gpio_pin ,gpioreturnvalue);
+
+	return 0;
+}
+
+static ssize_t proc_set_gpio(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32]={0};
+	int num=0,gpio_pin=0;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+		num	=sscanf(tmp, "%d",&gpio_pin);
+		DBG_871X("num=%d gpio_pin=%d\n",num,gpio_pin);
+		padapter->pre_gpio_pin=gpio_pin;
+	}
+	return count;
+}
+
+#endif
+
+
+static int proc_get_linked_info_dump(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	if(padapter)
+		DBG_871X_SEL_NL(m, "linked_info_dump :%s \n", (padapter->bLinkInfoDump)?"enable":"disable");
+	return 0;
+}
+
+static ssize_t proc_set_linked_info_dump(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	char tmp[32]={0};
+	int mode=0,pre_mode=0;
+	int num=0;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	pre_mode=padapter->bLinkInfoDump;
+	DBG_871X("pre_mode=%d\n", pre_mode);
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		num	=sscanf(tmp, "%d ", &mode);
+		DBG_871X("num=%d mode=%d\n",num,mode);
+
+		if(num!=1)
+		{
+			DBG_871X("argument number is wrong\n");
+			return -EFAULT;
+		}
+
+		if(mode==1 || (mode==0 && pre_mode==1) ) //not consider pwr_saving 0:
+		{
+			padapter->bLinkInfoDump = mode;
+		}
+		else if( (mode==2 ) || (mode==0 && pre_mode==2))//consider power_saving
+		{
+			//DBG_871X("linked_info_dump =%s \n", (padapter->bLinkInfoDump)?"enable":"disable")
+			linked_info_dump(padapter,mode);
+		}
+	}
+	return count;
+}
+
+static int proc_get_mac_qinfo(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rtw_hal_get_hwreg(adapter, HW_VAR_DUMP_MAC_QUEUE_INFO, (u8 *)m);
+
+	return 0;
+}
+
+int proc_get_wifi_spec(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+
+	DBG_871X_SEL_NL(m,"wifi_spec=%d\n",pregpriv->wifi_spec);
+	return 0;
+}
+
+static int proc_get_chan_plan(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	dump_cur_chset(m, adapter);
+
+	return 0;
+}
+
+static ssize_t proc_set_chan_plan(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u8 chan_plan = RTW_CHPLAN_MAX;
+
+	if (!padapter)
+		return -EFAULT;
+
+	if (count < 1)
+	{
+		DBG_871X("argument size is less than 1\n");
+		return -EFAULT;
+	}
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%hhx", &chan_plan);
+
+		if (num !=  1) {
+			DBG_871X("invalid read_reg parameter!\n");
+			return count;
+		}
+
+	}
+
+	rtw_set_channel_plan(padapter, chan_plan);
+
+	return count;
+}
+
+#ifdef CONFIG_DFS_MASTER
+ssize_t proc_set_update_non_ocp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *mlme = &adapter->mlmepriv;
+	struct mlme_ext_priv *mlmeext = &adapter->mlmeextpriv;
+	char tmp[32];
+	u8 ch, bw = CHANNEL_WIDTH_20, offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	int ms = -1;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%hhu %hhu %hhu %d", &ch, &bw, &offset, &ms);
+
+		if (num < 1 || (bw != CHANNEL_WIDTH_20 && num < 3))
+			goto exit;
+
+		if (bw == CHANNEL_WIDTH_20)
+			rtw_chset_update_non_ocp_ms(mlmeext->channel_set
+				, ch, bw, HAL_PRIME_CHNL_OFFSET_DONT_CARE, ms);
+		else
+			rtw_chset_update_non_ocp_ms(mlmeext->channel_set
+				, ch, bw, offset, ms);
+	}
+
+exit:
+	return count;
+}
+
+ssize_t proc_set_radar_detect(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct rf_ctl_t *rfctl = adapter_to_rfctl(adapter);
+	char tmp[32];
+	u8 fake_radar_detect_cnt = 0;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%hhu", &fake_radar_detect_cnt);
+
+		if (num < 1)
+			goto exit;
+
+		rfctl->dbg_dfs_master_fake_radar_detect_cnt = fake_radar_detect_cnt;
+	}
+
+exit:
+	return count;
+}
+#endif /* CONFIG_DFS_MASTER */
+
+static int proc_get_udpport(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+
+	DBG_871X_SEL_NL(m,"%d\n",precvpriv->sink_udpport);
+	return 0;
+}
+static ssize_t proc_set_udpport(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+	int sink_udpport = 0;
+	char tmp[32];
+
+
+	if (!padapter)
+		return -EFAULT;
+
+	if (count < 1)
+	{
+		DBG_871X("argument size is less than 1\n");
+		return -EFAULT;
+	}
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%d", &sink_udpport);
+
+		if (num !=  1) {
+			DBG_871X("invalid input parameter number!\n");
+			return count;
+		}
+
+	}
+	precvpriv->sink_udpport = sink_udpport;
+
+	return count;
+
+}
+
+static int proc_get_macid_info(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct macid_ctl_t *macid_ctl = dvobj_to_macidctl(dvobj);
+	u8 i;
+
+	DBG_871X_SEL_NL(m, "max_num:%u\n", macid_ctl->num);
+	DBG_871X_SEL_NL(m, "\n");
+
+	DBG_871X_SEL_NL(m, "used:\n");
+	dump_macid_map(m, &macid_ctl->used, macid_ctl->num);
+	DBG_871X_SEL_NL(m, "\n");
+
+	DBG_871X_SEL_NL(m, "%-3s %-3s %-4s %-4s %s"
+		"\n"
+		, "id", "bmc", "if_g", "ch_g", "status"
+	);
+
+	for (i=0;i<macid_ctl->num;i++) {
+		if (rtw_macid_is_used(macid_ctl, i)
+			|| macid_ctl->h2c_msr[i]
+		) {
+			DBG_871X_SEL_NL(m, "%3u %3u %4d %4d "H2C_MSR_FMT" %s"
+				"\n"
+				, i
+				, rtw_macid_is_bmc(macid_ctl, i)
+				, rtw_macid_get_if_g(macid_ctl, i)
+				, rtw_macid_get_ch_g(macid_ctl, i)
+				, H2C_MSR_ARG(&macid_ctl->h2c_msr[i])
+				, rtw_macid_is_used(macid_ctl, i) ? "" : "[unused]"
+			);
+		}
+	}
+
+	return 0;
+}
+
+static int proc_get_sec_cam(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+
+	DBG_871X_SEL_NL(m, "sec_cap:0x%02x\n", cam_ctl->sec_cap);
+	DBG_871X_SEL_NL(m, "flags:0x%08x\n", cam_ctl->flags);
+	DBG_871X_SEL_NL(m, "\n");
+
+	DBG_871X_SEL_NL(m, "max_num:%u\n", cam_ctl->num);
+	DBG_871X_SEL_NL(m, "used:\n");
+	dump_sec_cam_map(m, &cam_ctl->used, cam_ctl->num);
+	DBG_871X_SEL_NL(m, "\n");
+
+	DBG_871X_SEL_NL(m, "reg_scr:0x%04x\n", rtw_read16(adapter, 0x680));
+	DBG_871X_SEL_NL(m, "\n");
+
+	dump_sec_cam(m, adapter);
+
+	return 0;
+}
+
+static ssize_t proc_set_sec_cam(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+	char tmp[32] = {0};
+	char cmd[4];
+	u8 id;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		/* c <id>: clear specific cam entry */
+		/* wfc <id>: write specific cam entry from cam cache */
+
+		int num = sscanf(tmp, "%s %hhu", cmd, &id);
+
+		if (num < 2)
+			return count;
+
+		if (id >= cam_ctl->num) {
+			DBG_871X_LEVEL(_drv_err_, FUNC_ADPT_FMT" invalid id:%u\n", FUNC_ADPT_ARG(adapter), id);
+			return count;
+		}
+
+		if (strcmp("c", cmd) == 0) {
+			_clear_cam_entry(adapter, id);
+			adapter->securitypriv.hw_decrypted = _FALSE; /* temporarily set this for TX path to use SW enc */
+		} else if (strcmp("wfc", cmd) == 0) {
+			write_cam_from_cache(adapter, id);
+		}
+	}
+
+	return count;
+}
+
+static int proc_get_sec_cam_cache(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
+	u8 i;
+
+	DBG_871X_SEL_NL(m, "SW sec cam cache:\n");
+	dump_sec_cam_ent_title(m, 1);
+	for (i = 0; i < cam_ctl->num; i++) {
+		if (dvobj->cam_cache[i].ctrl != 0)
+			dump_sec_cam_ent(m, &dvobj->cam_cache[i], i);
+	}
+
+	return 0;
+}
+
+static ssize_t proc_set_change_bss_chbw(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *mlme = &(adapter->mlmepriv);
+	struct mlme_ext_priv *mlmeext = &(adapter->mlmeextpriv);
+	char tmp[32];
+	u8 ch, bw = CHANNEL_WIDTH_20, offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%hhu %hhu %hhu", &ch, &bw, &offset);
+
+		if (num < 1 || (bw != CHANNEL_WIDTH_20 && num < 3))
+			goto exit;
+
+		if (check_fwstate(mlme, WIFI_AP_STATE) && check_fwstate(mlme, WIFI_ASOC_STATE))
+			rtw_change_bss_chbw_cmd(adapter, RTW_CMDF_WAIT_ACK, ch, bw, offset);
+	}
+
+exit:
+	return count;
+}
+
+static int proc_get_target_tx_power(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	dump_target_tx_power(m, adapter);
+
+	return 0;
+}
+
+static int proc_get_tx_power_by_rate(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	dump_tx_power_by_rate(m, adapter);
+
+	return 0;
+}
+
+static int proc_get_tx_power_limit(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	dump_tx_power_limit(m, adapter);
+
+	return 0;
+}
+
+static int proc_get_tx_power_ext_info(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	dump_tx_power_ext_info(m, adapter);
+
+	return 0;
+}
+
+static ssize_t proc_set_tx_power_ext_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	char tmp[32] = {0};
+	char cmd[16] = {0};
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%s", cmd);
+
+		if (num < 1)
+			return count;
+
+		phy_free_filebuf_mask(adapter, LOAD_BB_PG_PARA_FILE | LOAD_RF_TXPWR_LMT_PARA_FILE);
+
+		rtw_ps_deny(adapter, PS_DENY_IOCTL);
+		LeaveAllPowerSaveModeDirect(adapter);
+
+		if (strcmp("default", cmd) == 0)
+			rtw_run_in_thread_cmd(adapter, ((void *)(phy_reload_default_tx_power_ext_info)), adapter);
+		else
+			rtw_run_in_thread_cmd(adapter, ((void *)(phy_reload_tx_power_ext_info)), adapter);
+
+		rtw_ps_deny_cancel(adapter, PS_DENY_IOCTL);
+	}
+
+	return count;
+}
+
+#ifdef CONFIG_RF_GAIN_OFFSET
+static int proc_get_kfree_flag(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct kfree_data_t *kfree_data = GET_KFREE_DATA(adapter);
+
+	DBG_871X_SEL_NL(m, "0x%02x\n", kfree_data->flag);
+
+	return 0;
+}
+
+static ssize_t proc_set_kfree_flag(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct kfree_data_t *kfree_data = GET_KFREE_DATA(adapter);
+	char tmp[32] = {0};
+	u8 flag;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%hhx", &flag);
+
+		if (num < 1)
+			return count;
+
+		kfree_data->flag = flag;
+	}
+
+	return count;
+}
+
+static int proc_get_kfree_bb_gain(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	struct kfree_data_t *kfree_data = GET_KFREE_DATA(adapter);
+	u8 i, j;
+
+	 for (i = 0; i < BB_GAIN_NUM; i++) {
+		if (i == 0)
+			DBG_871X_SEL(m, "2G: ");
+		else if (i == 1)
+			DBG_871X_SEL(m, "5GLB1: ");
+		else if (i == 2)
+			DBG_871X_SEL(m, "5GLB2: ");
+		else if (i == 3)
+			DBG_871X_SEL(m, "5GMB1: ");
+		else if (i == 4)
+			DBG_871X_SEL(m, "5GMB2: ");
+		else if (i == 5)
+			DBG_871X_SEL(m, "5GHB: ");
+
+		for (j = 0; j < hal_data->NumTotalRFPath; j++)
+			DBG_871X_SEL(m, "%d ", kfree_data->bb_gain[i][j]);
+		DBG_871X_SEL(m, "\n");
+	}
+
+	return 0;
+}
+
+static ssize_t proc_set_kfree_bb_gain(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	struct kfree_data_t *kfree_data = GET_KFREE_DATA(adapter);
+	char tmp[BB_GAIN_NUM * RF_PATH_MAX] = {0};
+	u8 path, chidx;
+	s8 bb_gain[BB_GAIN_NUM];
+	char ch_band_Group[6];
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+		char *c, *next;
+		int i = 0;
+
+		next = tmp;
+		c = strsep(&next, " \t");
+
+		if (sscanf(c, "%s", ch_band_Group) != 1) {
+			DBG_871X("Error Head Format, channel Group select\n,Please input:\t 2G , 5GLB1 , 5GLB2 , 5GMB1 , 5GMB2 , 5GHB\n");
+			return count;
+		}
+		if (strcmp("2G", ch_band_Group) == 0)
+			chidx = BB_GAIN_2G;
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+		else if (strcmp("5GLB1", ch_band_Group) == 0)
+			chidx = BB_GAIN_5GLB1;
+		else if (strcmp("5GLB2", ch_band_Group) == 0)
+			chidx = BB_GAIN_5GLB2;
+		else if (strcmp("5GMB1", ch_band_Group) == 0)
+			chidx = BB_GAIN_5GMB1;
+		else if (strcmp("5GMB2", ch_band_Group) == 0)
+			chidx = BB_GAIN_5GMB2;
+		else if (strcmp("5GHB", ch_band_Group) == 0)
+			chidx = BB_GAIN_5GHB;
+#endif /*CONFIG_IEEE80211_BAND_5GHZ*/
+		else {
+			DBG_871X("Error Head Format, channel Group select\n,Please input:\t 2G , 5GLB1 , 5GLB2 , 5GMB1 , 5GMB2 , 5GHB\n");
+			return count;
+		}
+		c = strsep(&next, " \t");
+
+		while (c != NULL) {
+			if (sscanf(c, "%hhx", &bb_gain[i]) != 1)
+				break;
+
+			kfree_data->bb_gain[chidx][i] = bb_gain[i];
+			DBG_871X("%s,kfree_data->bb_gain[%d][%d]=%x\n", __func__, chidx, i, kfree_data->bb_gain[chidx][i]);
+
+			c = strsep(&next, " \t");
+			i++;
+		}
+
+	}
+
+	return count;
+
+}
+
+static int proc_get_kfree_thermal(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct kfree_data_t *kfree_data = GET_KFREE_DATA(adapter);
+
+	DBG_871X_SEL(m, "%d\n", kfree_data->thermal);
+
+	return 0;
+}
+
+static ssize_t proc_set_kfree_thermal(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct kfree_data_t *kfree_data = GET_KFREE_DATA(adapter);
+	char tmp[32] = {0};
+	s8 thermal;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%hhd", &thermal);
+
+		if (num < 1)
+			return count;
+
+		kfree_data->thermal = thermal;
+	}
+
+	return count;
+}
+
+static ssize_t proc_set_tx_gain_offset(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter;
+	char tmp[32] = {0};
+	u8 rf_path;
+	s8 offset;
+
+	adapter = (_adapter *)rtw_netdev_priv(dev);
+	if (!adapter)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+		u8 write_value;
+		int num = sscanf(tmp, "%hhu %hhd", &rf_path, &offset);
+
+		if (num < 2)
+			return count;
+
+		DBG_871X("write rf_path:%u tx gain offset:%d\n", rf_path, offset);
+		rtw_rf_set_tx_gain_offset(adapter, rf_path, offset);
+	}
+
+	return count;
+}
+#endif /* CONFIG_RF_GAIN_OFFSET */
+
+#ifdef CONFIG_BT_COEXIST
+ssize_t proc_set_btinfo_evt(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u8 btinfo[8];
+
+	if (count < 6)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+		int num = 0;
+
+		_rtw_memset(btinfo, 0, 8);
+
+		num = sscanf(tmp, "%hhx %hhx %hhx %hhx %hhx %hhx %hhx %hhx"
+			, &btinfo[0], &btinfo[1], &btinfo[2], &btinfo[3]
+			, &btinfo[4], &btinfo[5], &btinfo[6], &btinfo[7]);
+
+		if (num < 6)
+			return -EINVAL;
+
+		btinfo[1] = num-2;
+
+		rtw_btinfo_cmd(padapter, btinfo, btinfo[1]+2);
+	}
+
+	return count;
+}
+
+static u8 btreg_read_type = 0;
+static u16 btreg_read_addr = 0;
+static int btreg_read_error = 0;
+static u8 btreg_write_type = 0;
+static u16 btreg_write_addr = 0;
+static int btreg_write_error = 0;
+
+static u8 *btreg_type[] = {
+	"rf",
+	"modem",
+	"bluewize",
+	"vendor",
+	"le"
+};
+
+static int btreg_parse_str(char *input, u8 *type, u16 *addr, u16 *val)
+{
+	u32 num;
+	u8 str[80] = {0};
+	u8 t = 0;
+	u32 a, v;
+	u8 i, n;
+	u8 *p;
+
+
+	num = sscanf(input, "%s %x %x", str, &a, &v);
+	if (num < 2) {
+		DBG_871X("%s: INVALID input!(%s)\n", __FUNCTION__, input);
+		return -EINVAL;
+	}
+	if ((num < 3) && val) {
+		DBG_871X("%s: INVALID input!(%s)\n", __FUNCTION__, input);
+		return -EINVAL;
+	}
+
+	/* convert to lower case for following type compare */
+	p = str;
+	for ( ; *p; ++p)
+		*p = tolower(*p);
+	n = sizeof(btreg_type)/sizeof(btreg_type[0]);
+	for (i = 0; i < n; i++) {
+		if (!strcmp(str, btreg_type[i])) {
+			t = i;
+			break;
+		}
+	}
+	if (i == n) {
+		DBG_871X("%s: unknown type(%s)!\n", __FUNCTION__, str);
+		return -EINVAL;
+	}
+
+	switch (t) {
+	case 0:
+		/* RF */
+		if (a & 0xFFFFFF80) {
+			DBG_871X("%s: INVALID address(0x%X) for type %s(%d)!\n",
+				__FUNCTION__, a, btreg_type[t], t);
+			return -EINVAL;
+		}
+		break;
+	case 1:
+		/* Modem */
+		if (a & 0xFFFFFE00) {
+			DBG_871X("%s: INVALID address(0x%X) for type %s(%d)!\n",
+				__FUNCTION__, a, btreg_type[t], t);
+			return -EINVAL;
+		}
+		break;
+	default:
+		/* Others(Bluewize, Vendor, LE) */
+		if (a & 0xFFFFF000) {
+			DBG_871X("%s: INVALID address(0x%X) for type %s(%d)!\n",
+				__FUNCTION__, a, btreg_type[t], t);
+			return -EINVAL;
+		}
+		break;
+	}
+
+	if (val) {
+		if (v & 0xFFFF0000) {
+			DBG_871X("%s: INVALID value(0x%x)!\n", __FUNCTION__, v);
+			return -EINVAL;
+		}
+		*val = (u16)v;
+	}
+
+	*type = (u8)t;
+	*addr = (u16)a;
+
+	return 0;
+}
+
+int proc_get_btreg_read(struct seq_file *m, void *v)
+{
+	struct net_device *dev;
+	PADAPTER padapter;
+	u16 ret;
+	u32 data;
+
+
+	if (btreg_read_error)
+		return btreg_read_error;
+
+	dev = m->private;
+	padapter = (PADAPTER)rtw_netdev_priv(dev);
+
+	ret = rtw_btcoex_btreg_read(padapter, btreg_read_type, btreg_read_addr, &data);
+	if (CHECK_STATUS_CODE_FROM_BT_MP_OPER_RET(ret, BT_STATUS_BT_OP_SUCCESS))
+		DBG_871X_SEL_NL(m, "BTREG read: (%s)0x%04X = 0x%08x\n", btreg_type[btreg_read_type], btreg_read_addr, data);
+	else
+		DBG_871X_SEL_NL(m, "BTREG read: (%s)0x%04X read fail. error code = 0x%04x.\n", btreg_type[btreg_read_type], btreg_read_addr, ret);
+
+	return 0;
+}
+
+ssize_t proc_set_btreg_read(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	PADAPTER padapter;
+	u8 tmp[80] = {0};
+	u32 num;
+	int err;
+
+
+	padapter = (PADAPTER)rtw_netdev_priv(dev);
+
+	if (NULL == buffer) {
+		DBG_871X(FUNC_ADPT_FMT ": input buffer is NULL!\n",
+			FUNC_ADPT_ARG(padapter));
+		err = -EFAULT;
+		goto exit;
+	}
+
+	if (count < 1) {
+		DBG_871X(FUNC_ADPT_FMT ": input length is 0!\n",
+			FUNC_ADPT_ARG(padapter));
+		err = -EFAULT;
+		goto exit;
+	}
+
+	num = count;
+	if (num > (sizeof(tmp) - 1))
+		num = (sizeof(tmp) - 1);
+
+	if (copy_from_user(tmp, buffer, num)) {
+		DBG_871X(FUNC_ADPT_FMT ": copy buffer from user space FAIL!\n",
+			FUNC_ADPT_ARG(padapter));
+		err = -EFAULT;
+		goto exit;
+	}
+
+	err = btreg_parse_str(tmp, &btreg_read_type, &btreg_read_addr, NULL);
+	if (err)
+		goto exit;
+
+	DBG_871X(FUNC_ADPT_FMT ": addr=(%s)0x%X\n",
+		FUNC_ADPT_ARG(padapter), btreg_type[btreg_read_type], btreg_read_addr);
+
+exit:
+	btreg_read_error = err;
+
+	return count;
+}
+
+int proc_get_btreg_write(struct seq_file *m, void *v)
+{
+	struct net_device *dev;
+	PADAPTER padapter;
+	u16 ret;
+	u32 data;
+
+
+	if (btreg_write_error < 0)
+		return btreg_write_error;
+	else if (btreg_write_error > 0) {
+		DBG_871X_SEL_NL(m, "BTREG write: (%s)0x%04X write fail. error code = 0x%04x.\n", btreg_type[btreg_write_type], btreg_write_addr, btreg_write_error);
+		return 0;
+	}
+
+	dev = m->private;
+	padapter = (PADAPTER)rtw_netdev_priv(dev);
+
+	ret = rtw_btcoex_btreg_read(padapter, btreg_write_type, btreg_write_addr, &data);
+	if (CHECK_STATUS_CODE_FROM_BT_MP_OPER_RET(ret, BT_STATUS_BT_OP_SUCCESS))
+		DBG_871X_SEL_NL(m, "BTREG read: (%s)0x%04X = 0x%08x\n", btreg_type[btreg_write_type], btreg_write_addr, data);
+	else
+		DBG_871X_SEL_NL(m, "BTREG read: (%s)0x%04X read fail. error code = 0x%04x.\n", btreg_type[btreg_write_type], btreg_write_addr, ret);
+
+	return 0;
+}
+
+ssize_t proc_set_btreg_write(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	PADAPTER padapter;
+	u8 tmp[80] = {0};
+	u32 num;
+	u16 val;
+	u16 ret;
+	int err;
+
+
+	padapter = (PADAPTER)rtw_netdev_priv(dev);
+
+	if (NULL == buffer) {
+		DBG_871X(FUNC_ADPT_FMT ": input buffer is NULL!\n",
+			FUNC_ADPT_ARG(padapter));
+		err = -EFAULT;
+		goto exit;
+	}
+
+	if (count < 1) {
+		DBG_871X(FUNC_ADPT_FMT ": input length is 0!\n",
+			FUNC_ADPT_ARG(padapter));
+		err = -EFAULT;
+		goto exit;
+	}
+
+	num = count;
+	if (num > (sizeof(tmp) - 1))
+		num = (sizeof(tmp) - 1);
+
+	if (copy_from_user(tmp, buffer, num)) {
+		DBG_871X(FUNC_ADPT_FMT ": copy buffer from user space FAIL!\n",
+			FUNC_ADPT_ARG(padapter));
+		err = -EFAULT;
+		goto exit;
+	}
+
+	err = btreg_parse_str(tmp, &btreg_write_type, &btreg_write_addr, &val);
+	if (err)
+		goto exit;
+
+	DBG_871X(FUNC_ADPT_FMT ": Set (%s)0x%X = 0x%x\n",
+		FUNC_ADPT_ARG(padapter), btreg_type[btreg_write_type], btreg_write_addr, val);
+
+	ret = rtw_btcoex_btreg_write(padapter, btreg_write_type, btreg_write_addr, val);
+	if (!CHECK_STATUS_CODE_FROM_BT_MP_OPER_RET(ret, BT_STATUS_BT_OP_SUCCESS))
+		err = ret;
+
+exit:
+	btreg_write_error = err;
+
+	return count;
+}
+#endif /* CONFIG_BT_COEXIST */
+
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+static int proc_get_best_chan(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	u8 best_24g_ch = 0, best_5g_ch = 0;
+
+	rtw_hal_get_odm_var(adapter, HAL_ODM_AUTO_CHNL_SEL, &(best_24g_ch), &(best_5g_ch));
+
+	DBG_871X_SEL_NL(m, "Best 2.4G CH:%u\n", best_24g_ch);
+	DBG_871X_SEL_NL(m, "Best 5G CH:%u\n", best_5g_ch);
+	return 0;
+}
+
+static ssize_t  proc_set_acs(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u8 acs_satae = 0;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%hhu", &acs_satae);
+
+		if (num < 1)
+			return -EINVAL;
+
+		if (1 == acs_satae)
+			rtw_acs_start(padapter, _TRUE);
+		else
+			rtw_acs_start(padapter, _FALSE);
+
+	}
+	return count;
+}
+#endif
+
+static int proc_get_hal_spec(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	dump_hal_spec(m, adapter);
+	return 0;
+}
+
+/*
+* rtw_adapter_proc:
+* init/deinit when register/unregister net_device
+*/
+const struct rtw_proc_hdl adapter_proc_hdls [] = {
+	{"write_reg", proc_get_dummy, proc_set_write_reg},
+	{"read_reg", proc_get_read_reg, proc_set_read_reg},
+	{"adapters_status", proc_get_dump_adapters_status, NULL},
+	{"fwstate", proc_get_fwstate, NULL},
+	{"sec_info", proc_get_sec_info, NULL},
+	{"mlmext_state", proc_get_mlmext_state, NULL},
+	{"qos_option", proc_get_qos_option, NULL},
+	{"ht_option", proc_get_ht_option, NULL},
+	{"rf_info", proc_get_rf_info, NULL},
+	{"scan_param", proc_get_scan_param, proc_set_scan_param},
+	{"scan_abort", proc_get_scan_abort, NULL},
+#ifdef CONFIG_SCAN_BACKOP
+	{"backop_flags_sta", proc_get_backop_flags_sta, proc_set_backop_flags_sta},
+	{"backop_flags_ap", proc_get_backop_flags_ap, proc_set_backop_flags_ap},
+#endif
+	{"survey_info", proc_get_survey_info, proc_set_survey_info},
+	{"ap_info", proc_get_ap_info, NULL},
+	{"trx_info", proc_get_trx_info, proc_reset_trx_info},
+	{"rate_ctl", proc_get_rate_ctl, proc_set_rate_ctl},
+	{"dis_pwt_ctl", proc_get_dis_pwt, proc_set_dis_pwt},
+	{"mac_qinfo", proc_get_mac_qinfo, NULL},
+	{"macid_info", proc_get_macid_info, NULL},
+	{"sec_cam", proc_get_sec_cam, proc_set_sec_cam},
+	{"sec_cam_cache", proc_get_sec_cam_cache, NULL},
+	{"suspend_info", proc_get_suspend_resume_info, NULL},
+	{"wifi_spec",proc_get_wifi_spec,NULL},
+#ifdef CONFIG_LAYER2_ROAMING
+	{"roam_flags", proc_get_roam_flags, proc_set_roam_flags},
+	{"roam_param", proc_get_roam_param, proc_set_roam_param},
+	{"roam_tgt_addr", proc_get_dummy, proc_set_roam_tgt_addr},
+#endif /* CONFIG_LAYER2_ROAMING */
+
+#ifdef CONFIG_SDIO_HCI
+	{"sd_f0_reg_dump", proc_get_sd_f0_reg_dump, NULL},
+	{"sdio_local_reg_dump", proc_get_sdio_local_reg_dump, NULL},
+#endif /* CONFIG_SDIO_HCI */
+
+	{"fwdl_test_case", proc_get_dummy, proc_set_fwdl_test_case},
+	{"del_rx_ampdu_test_case", proc_get_dummy, proc_set_del_rx_ampdu_test_case},
+	{"wait_hiq_empty", proc_get_dummy, proc_set_wait_hiq_empty},
+
+	{"mac_reg_dump", proc_get_mac_reg_dump, NULL},
+	{"bb_reg_dump", proc_get_bb_reg_dump, NULL},
+	{"rf_reg_dump", proc_get_rf_reg_dump, NULL},
+
+#ifdef CONFIG_AP_MODE
+	{"all_sta_info", proc_get_all_sta_info, NULL},
+#endif /* CONFIG_AP_MODE */
+
+#ifdef DBG_MEMORY_LEAK
+	{"_malloc_cnt", proc_get_malloc_cnt, NULL},
+#endif /* DBG_MEMORY_LEAK */
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+	{"best_channel", proc_get_best_channel, proc_set_best_channel},
+#endif
+
+	{"rx_signal", proc_get_rx_signal, proc_set_rx_signal},
+	{"hw_info", proc_get_hw_status, NULL},
+
+#ifdef CONFIG_80211N_HT
+	{"ht_enable", proc_get_ht_enable, proc_set_ht_enable},
+	{"bw_mode", proc_get_bw_mode, proc_set_bw_mode},
+	{"ampdu_enable", proc_get_ampdu_enable, proc_set_ampdu_enable},
+	{"rx_stbc", proc_get_rx_stbc, proc_set_rx_stbc},
+	{"rx_ampdu", proc_get_rx_ampdu, proc_set_rx_ampdu},
+	{"rx_ampdu_factor",proc_get_rx_ampdu_factor,proc_set_rx_ampdu_factor},
+	{"rx_ampdu_density",proc_get_rx_ampdu_density,proc_set_rx_ampdu_density},
+	{"tx_ampdu_density",proc_get_tx_ampdu_density,proc_set_tx_ampdu_density},
+#endif /* CONFIG_80211N_HT */
+
+	{"en_fwps", proc_get_en_fwps, proc_set_en_fwps},
+	{"mac_rptbuf", proc_get_mac_rptbuf, NULL},
+
+	//{"path_rssi", proc_get_two_path_rssi, NULL},
+//	{"rssi_disp",proc_get_rssi_disp, proc_set_rssi_disp},
+
+#ifdef CONFIG_BT_COEXIST
+	{"btcoex_dbg", proc_get_btcoex_dbg, proc_set_btcoex_dbg},
+	{"btcoex", proc_get_btcoex_info, NULL},
+	{"btinfo_evt", proc_get_dummy, proc_set_btinfo_evt},
+	{"btreg_read", proc_get_btreg_read, proc_set_btreg_read},
+	{"btreg_write", proc_get_btreg_write, proc_set_btreg_write},
+#endif /* CONFIG_BT_COEXIST */
+
+#if defined(DBG_CONFIG_ERROR_DETECT)
+	{"sreset", proc_get_sreset, proc_set_sreset},
+#endif /* DBG_CONFIG_ERROR_DETECT */
+	{"linked_info_dump",proc_get_linked_info_dump,proc_set_linked_info_dump},
+
+#ifdef CONFIG_GPIO_API
+	{"gpio_info",proc_get_gpio,proc_set_gpio},
+	{"gpio_set_output_value",proc_get_dummy,proc_set_gpio_output_value},
+	{"gpio_set_direction",proc_get_dummy,proc_set_config_gpio},
+#endif
+
+#ifdef CONFIG_DBG_COUNTER
+	{"rx_logs", proc_get_rx_logs, NULL},
+	{"tx_logs", proc_get_tx_logs, NULL},
+	{"int_logs", proc_get_int_logs, NULL},
+#endif
+
+#ifdef CONFIG_PCI_HCI
+	{"rx_ring", proc_get_rx_ring, NULL},
+	{"tx_ring", proc_get_tx_ring, NULL},
+#endif
+#ifdef CONFIG_GPIO_WAKEUP
+	{"wowlan_gpio_info", proc_get_wowlan_gpio_info,
+		proc_set_wowlan_gpio_info},
+#endif
+#ifdef CONFIG_P2P_WOWLAN
+	{"p2p_wowlan_info", proc_get_p2p_wowlan_info, NULL},
+#endif
+	{"chan_plan",proc_get_chan_plan,proc_set_chan_plan},
+#ifdef CONFIG_DFS_MASTER
+	{"dfs_master_test_case", proc_get_dfs_master_test_case, proc_set_dfs_master_test_case},
+	{"update_non_ocp", proc_get_dummy, proc_set_update_non_ocp},
+	{"radar_detect", proc_get_dummy, proc_set_radar_detect},
+#endif
+	{"new_bcn_max", proc_get_new_bcn_max, proc_set_new_bcn_max},
+	{"sink_udpport",proc_get_udpport,proc_set_udpport},
+#ifdef DBG_RX_COUNTER_DUMP
+	{"dump_rx_cnt_mode",proc_get_rx_cnt_dump,proc_set_rx_cnt_dump},
+#endif
+	{"change_bss_chbw", NULL, proc_set_change_bss_chbw},
+	{"target_tx_power", proc_get_target_tx_power, NULL},
+	{"tx_power_by_rate", proc_get_tx_power_by_rate, NULL},
+	{"tx_power_limit", proc_get_tx_power_limit, NULL},
+	{"tx_power_ext_info", proc_get_tx_power_ext_info, proc_set_tx_power_ext_info},
+#ifdef CONFIG_RF_GAIN_OFFSET
+	{"tx_gain_offset", proc_get_dummy, proc_set_tx_gain_offset},
+	{"kfree_flag", proc_get_kfree_flag, proc_set_kfree_flag},
+	{"kfree_bb_gain", proc_get_kfree_bb_gain, proc_set_kfree_bb_gain},
+	{"kfree_thermal", proc_get_kfree_thermal, proc_set_kfree_thermal},
+#endif
+#ifdef CONFIG_POWER_SAVING
+	{"ps_info",proc_get_ps_info, NULL},
+#endif
+#ifdef CONFIG_TDLS
+	{"tdls_info", proc_get_tdls_info, NULL},
+#endif
+	{"monitor", proc_get_monitor, proc_set_monitor},
+
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+	{"acs", proc_get_best_chan, proc_set_acs},
+#endif
+#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
+	{"rtkm_info", proc_get_rtkm_info, NULL}
+#endif
+	{"efuse_map", proc_get_efuse_map, NULL},
+#ifdef CONFIG_IEEE80211W
+	{"11w_tx_sa_query", proc_get_tx_sa_query, proc_set_tx_sa_query},
+	{"11w_tx_deauth", proc_get_tx_deauth, proc_set_tx_deauth},
+	{"11w_tx_auth", proc_get_tx_auth, proc_set_tx_auth},
+#endif /* CONFIG_IEEE80211W */
+	{"hal_spec", proc_get_hal_spec, NULL},
+};
+
+const int adapter_proc_hdls_num = sizeof(adapter_proc_hdls) / sizeof(struct rtw_proc_hdl);
+
+static int rtw_adapter_proc_open(struct inode *inode, struct file *file)
+{
+	ssize_t index = (ssize_t)PDE_DATA(inode);
+	const struct rtw_proc_hdl *hdl = adapter_proc_hdls+index;
+
+	return single_open(file, hdl->show, proc_get_parent_data(inode));
+}
+
+static ssize_t rtw_adapter_proc_write(struct file *file, const char __user *buffer, size_t count, loff_t *pos)
+{
+	ssize_t index = (ssize_t)PDE_DATA(file_inode(file));
+	const struct rtw_proc_hdl *hdl = adapter_proc_hdls+index;
+	ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *, void *) = hdl->write;
+
+	if (write)
+		return write(file, buffer, count, pos, ((struct seq_file *)file->private_data)->private);
+
+	return -EROFS;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0))
+static const struct proc_ops rtw_adapter_proc_fops = {
+	.proc_open = rtw_adapter_proc_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+	.proc_write = rtw_adapter_proc_write,
+};
+#else
+static const struct file_operations rtw_adapter_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = rtw_adapter_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = rtw_adapter_proc_write,
+};
+#endif
+
+int proc_get_odm_dbg_comp(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rtw_odm_dbg_comp_msg(m, adapter);
+
+	return 0;
+}
+
+ssize_t proc_set_odm_dbg_comp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+
+	u64 dbg_comp;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%llx", &dbg_comp);
+
+		if (num != 1)
+			return count;
+
+		rtw_odm_dbg_comp_set(adapter, dbg_comp);
+	}
+
+	return count;
+}
+
+int proc_get_odm_dbg_level(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rtw_odm_dbg_level_msg(m, adapter);
+
+	return 0;
+}
+
+ssize_t proc_set_odm_dbg_level(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+
+	u32 dbg_level;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%u", &dbg_level);
+
+		if (num != 1)
+			return count;
+
+		rtw_odm_dbg_level_set(adapter, dbg_level);
+	}
+
+	return count;
+}
+
+int proc_get_odm_ability(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rtw_odm_ability_msg(m, adapter);
+
+	return 0;
+}
+
+ssize_t proc_set_odm_ability(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+
+	u32 ability;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%x", &ability);
+
+		if (num != 1)
+			return count;
+
+		rtw_odm_ability_set(adapter, ability);
+	}
+
+	return count;
+}
+
+int proc_get_odm_adaptivity(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rtw_odm_adaptivity_parm_msg(m, padapter);
+
+	return 0;
+}
+
+ssize_t proc_set_odm_adaptivity(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 TH_L2H_ini;
+	u32 TH_L2H_ini_mode2;
+	s8 TH_EDCCA_HL_diff;
+	s8 TH_EDCCA_HL_diff_mode2;
+	u8 EDCCA_enable;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (count > sizeof(tmp)) {
+		rtw_warn_on(1);
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+
+		int num = sscanf(tmp, "%x %hhd %x %hhd %hhu", &TH_L2H_ini, &TH_EDCCA_HL_diff, &TH_L2H_ini_mode2, &TH_EDCCA_HL_diff_mode2, &EDCCA_enable);
+
+		if (num != 5)
+			return count;
+
+		rtw_odm_adaptivity_parm_set(padapter, (s8)TH_L2H_ini, TH_EDCCA_HL_diff, (s8)TH_L2H_ini_mode2, TH_EDCCA_HL_diff_mode2, EDCCA_enable);
+	}
+
+	return count;
+}
+
+static char *phydm_msg = NULL;
+#define PHYDM_MSG_LEN	80*24
+
+int proc_get_phydm_cmd(struct seq_file *m, void *v)
+{
+	struct net_device *netdev;
+	PADAPTER padapter;
+	PHAL_DATA_TYPE pHalData;
+	PDM_ODM_T phydm;
+
+
+	netdev = m->private;
+	padapter = (PADAPTER)rtw_netdev_priv(netdev);
+	pHalData = GET_HAL_DATA(padapter);
+	phydm = &pHalData->odmpriv;
+
+	if (NULL == phydm_msg) {
+		phydm_msg = rtw_zmalloc(PHYDM_MSG_LEN);
+		if (NULL == phydm_msg)
+			return -ENOMEM;
+
+		phydm_cmd(phydm, NULL, 0, 0, phydm_msg, PHYDM_MSG_LEN);
+	}
+
+	DBG_871X_SEL(m, "%s\n", phydm_msg);
+
+	rtw_mfree(phydm_msg, PHYDM_MSG_LEN);
+	phydm_msg = NULL;
+
+	return 0;
+}
+
+ssize_t proc_set_phydm_cmd(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *netdev;
+	PADAPTER padapter;
+	PHAL_DATA_TYPE pHalData;
+	PDM_ODM_T phydm;
+	char tmp[64] = {0};
+
+
+	netdev = (struct net_device*)data;
+	padapter = (PADAPTER)rtw_netdev_priv(netdev);
+	pHalData = GET_HAL_DATA(padapter);
+	phydm = &pHalData->odmpriv;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (count > sizeof(tmp))
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+		if (NULL == phydm_msg) {
+			phydm_msg = rtw_zmalloc(PHYDM_MSG_LEN);
+			if (NULL == phydm_msg)
+				return -ENOMEM;
+		} else {
+			_rtw_memset(phydm_msg, 0, PHYDM_MSG_LEN);
+		}
+
+		phydm_cmd(phydm, tmp, count, 1, phydm_msg, PHYDM_MSG_LEN);
+
+		if (strlen(phydm_msg) == 0) {
+			rtw_mfree(phydm_msg, PHYDM_MSG_LEN);
+			phydm_msg = NULL;
+		}
+	}
+
+	return count;
+}
+
+/*
+* rtw_odm_proc:
+* init/deinit when register/unregister net_device, along with rtw_adapter_proc
+*/
+const struct rtw_proc_hdl odm_proc_hdls [] = {
+	{"dbg_comp", proc_get_odm_dbg_comp, proc_set_odm_dbg_comp},
+	{"dbg_level", proc_get_odm_dbg_level, proc_set_odm_dbg_level},
+	{"ability", proc_get_odm_ability, proc_set_odm_ability},
+	{"adaptivity", proc_get_odm_adaptivity, proc_set_odm_adaptivity},
+	{"cmd", proc_get_phydm_cmd, proc_set_phydm_cmd},
+};
+
+const int odm_proc_hdls_num = sizeof(odm_proc_hdls) / sizeof(struct rtw_proc_hdl);
+
+static int rtw_odm_proc_open(struct inode *inode, struct file *file)
+{
+	ssize_t index = (ssize_t)PDE_DATA(inode);
+	const struct rtw_proc_hdl *hdl = odm_proc_hdls+index;
+
+	return single_open(file, hdl->show, proc_get_parent_data(inode));
+}
+
+static ssize_t rtw_odm_proc_write(struct file *file, const char __user *buffer, size_t count, loff_t *pos)
+{
+	ssize_t index = (ssize_t)PDE_DATA(file_inode(file));
+	const struct rtw_proc_hdl *hdl = odm_proc_hdls+index;
+	ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *, void *) = hdl->write;
+
+	if (write)
+		return write(file, buffer, count, pos, ((struct seq_file *)file->private_data)->private);
+
+	return -EROFS;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0))
+static const struct proc_ops rtw_odm_proc_fops = {
+	.proc_open = rtw_odm_proc_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+	.proc_write = rtw_odm_proc_write,
+};
+#else
+static const struct file_operations rtw_odm_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = rtw_odm_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = rtw_odm_proc_write,
+};
+#endif
+
+struct proc_dir_entry *rtw_odm_proc_init(struct net_device *dev)
+{
+	struct proc_dir_entry *dir_odm = NULL;
+	struct proc_dir_entry *entry = NULL;
+	_adapter	*adapter = rtw_netdev_priv(dev);
+	ssize_t i;
+
+	if (adapter->dir_dev == NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	if (adapter->dir_odm != NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	dir_odm = rtw_proc_create_dir("odm", adapter->dir_dev, dev);
+	if (dir_odm == NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	adapter->dir_odm = dir_odm;
+
+	for (i=0;i<odm_proc_hdls_num;i++) {
+		entry = rtw_proc_create_entry(odm_proc_hdls[i].name, dir_odm, &rtw_odm_proc_fops, (void *)i);
+		if (!entry) {
+			rtw_warn_on(1);
+			goto exit;
+		}
+	}
+
+exit:
+	return dir_odm;
+}
+
+void rtw_odm_proc_deinit(_adapter	*adapter)
+{
+	struct proc_dir_entry *dir_odm = NULL;
+	int i;
+
+	dir_odm = adapter->dir_odm;
+
+	if (dir_odm == NULL) {
+		rtw_warn_on(1);
+		return;
+	}
+
+	for (i=0;i<odm_proc_hdls_num;i++)
+		remove_proc_entry(odm_proc_hdls[i].name, dir_odm);
+
+	remove_proc_entry("odm", adapter->dir_dev);
+
+	adapter->dir_odm = NULL;
+
+	if (phydm_msg) {
+		rtw_mfree(phydm_msg, PHYDM_MSG_LEN);
+		phydm_msg = NULL;
+	}
+}
+
+struct proc_dir_entry *rtw_adapter_proc_init(struct net_device *dev)
+{
+	struct proc_dir_entry *drv_proc = get_rtw_drv_proc();
+	struct proc_dir_entry *dir_dev = NULL;
+	struct proc_dir_entry *entry = NULL;
+	_adapter *adapter = rtw_netdev_priv(dev);
+	u8 rf_type;
+	ssize_t i;
+
+	if (drv_proc == NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	if (adapter->dir_dev != NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	dir_dev = rtw_proc_create_dir(dev->name, drv_proc, dev);
+	if (dir_dev == NULL) {
+		rtw_warn_on(1);
+		goto exit;
+	}
+
+	adapter->dir_dev = dir_dev;
+
+	for (i=0;i<adapter_proc_hdls_num;i++) {
+		entry = rtw_proc_create_entry(adapter_proc_hdls[i].name, dir_dev, &rtw_adapter_proc_fops, (void *)i);
+		if (!entry) {
+			rtw_warn_on(1);
+			goto exit;
+		}
+	}
+
+	rtw_odm_proc_init(dev);
+
+exit:
+	return dir_dev;
+}
+
+void rtw_adapter_proc_deinit(struct net_device *dev)
+{
+	struct proc_dir_entry *drv_proc = get_rtw_drv_proc();
+	struct proc_dir_entry *dir_dev = NULL;
+	_adapter *adapter = rtw_netdev_priv(dev);
+	int i;
+
+	dir_dev = adapter->dir_dev;
+
+	if (dir_dev == NULL) {
+		rtw_warn_on(1);
+		return;
+	}
+
+	for (i=0;i<adapter_proc_hdls_num;i++)
+		remove_proc_entry(adapter_proc_hdls[i].name, dir_dev);
+
+	rtw_odm_proc_deinit(adapter);
+
+	remove_proc_entry(dev->name, drv_proc);
+
+	adapter->dir_dev = NULL;
+}
+
+void rtw_adapter_proc_replace(struct net_device *dev)
+{
+	struct proc_dir_entry *drv_proc = get_rtw_drv_proc();
+	struct proc_dir_entry *dir_dev = NULL;
+	_adapter *adapter = rtw_netdev_priv(dev);
+	int i;
+
+	dir_dev = adapter->dir_dev;
+
+	if (dir_dev == NULL) {
+		rtw_warn_on(1);
+		return;
+	}
+
+	for (i=0;i<adapter_proc_hdls_num;i++)
+		remove_proc_entry(adapter_proc_hdls[i].name, dir_dev);
+
+	rtw_odm_proc_deinit(adapter);
+
+	remove_proc_entry(adapter->old_ifname, drv_proc);
+
+	adapter->dir_dev = NULL;
+
+	rtw_adapter_proc_init(dev);
+
+}
+
+#endif /* CONFIG_PROC_DEBUG */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_proc.h b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_proc.h
new file mode 100644
index 000000000..9aee7bf56
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/rtw_proc.h
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_PROC_H__
+#define __RTW_PROC_H__
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+struct rtw_proc_hdl {
+	char *name;
+	int (*show)(struct seq_file *, void *);
+	ssize_t (*write)(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+};
+
+#ifdef CONFIG_PROC_DEBUG
+
+struct proc_dir_entry *get_rtw_drv_proc(void);
+int rtw_drv_proc_init(void);
+void rtw_drv_proc_deinit(void);
+struct proc_dir_entry *rtw_adapter_proc_init(struct net_device *dev);
+void rtw_adapter_proc_deinit(struct net_device *dev);
+void rtw_adapter_proc_replace(struct net_device *dev);
+
+#else //!CONFIG_PROC_DEBUG
+
+#define get_rtw_drv_proc() NULL
+#define rtw_drv_proc_init() 0
+#define rtw_drv_proc_deinit() do {} while (0)
+#define rtw_adapter_proc_init(dev) NULL
+#define rtw_adapter_proc_deinit(dev) do {} while (0)
+#define rtw_adapter_proc_replace(dev) do {} while (0)
+
+#endif //!CONFIG_PROC_DEBUG
+
+#endif //__RTW_PROC_H__
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/sdio_intf.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/sdio_intf.c
new file mode 100644
index 000000000..f91d27e85
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/sdio_intf.c
@@ -0,0 +1,1048 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _HCI_INTF_C_
+
+#include <drv_types.h>
+#include <hal_data.h>
+#include <platform_ops.h>
+
+#ifndef CONFIG_SDIO_HCI
+#error "CONFIG_SDIO_HCI shall be on!\n"
+#endif
+
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+#ifdef CONFIG_ACPI
+#include <linux/acpi.h>
+#include <linux/acpi_gpio.h>
+#include "rtw_android.h"
+#endif
+static int wlan_en_gpio = -1;
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
+#ifndef dev_to_sdio_func
+#define dev_to_sdio_func(d)     container_of(d, struct sdio_func, dev)
+#endif
+
+#ifdef CONFIG_WOWLAN
+static struct mmc_host *mmc_host = NULL;
+#endif
+
+static const struct sdio_device_id sdio_ids[] =
+{
+#ifdef CONFIG_RTL8723B
+	{ SDIO_DEVICE(0x024c, 0xB723),.driver_data = RTL8723B},
+#endif
+#ifdef CONFIG_RTL8188E
+	{ SDIO_DEVICE(0x024c, 0x8179),.driver_data = RTL8188E},
+#endif //CONFIG_RTL8188E
+
+#ifdef CONFIG_RTL8821A
+	{ SDIO_DEVICE(0x024c, 0x8821),.driver_data = RTL8821},
+#endif //CONFIG_RTL8821A
+
+#ifdef CONFIG_RTL8192E
+	{ SDIO_DEVICE(0x024c, 0x818B),.driver_data = RTL8192E},
+#endif //CONFIG_RTL8192E
+
+#ifdef CONFIG_RTL8703B
+	{ SDIO_DEVICE(0x024c, 0xB703), .driver_data = RTL8703B},
+#endif
+
+#ifdef CONFIG_RTL8188F
+	{SDIO_DEVICE(0x024c, 0xF179), .driver_data = RTL8188F},
+#endif
+
+#if defined(RTW_ENABLE_WIFI_CONTROL_FUNC) /* temporarily add this to accept all sdio wlan id */
+	{ SDIO_DEVICE_CLASS(SDIO_CLASS_WLAN) },
+#endif
+	{ /* end: all zeroes */				},
+};
+
+MODULE_DEVICE_TABLE(sdio, sdio_ids);
+
+static int rtw_drv_init(struct sdio_func *func, const struct sdio_device_id *id);
+static void rtw_dev_remove(struct sdio_func *func);
+static int rtw_sdio_resume(struct device *dev);
+static int rtw_sdio_suspend(struct device *dev);
+extern void rtw_dev_unload(PADAPTER padapter);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)) 
+static const struct dev_pm_ops rtw_sdio_pm_ops = {
+	.suspend	= rtw_sdio_suspend,
+	.resume	= rtw_sdio_resume,
+};
+#endif
+	
+struct sdio_drv_priv {
+	struct sdio_driver r871xs_drv;
+	int drv_registered;
+};
+
+static struct sdio_drv_priv sdio_drvpriv = {
+	.r871xs_drv.probe = rtw_drv_init,
+	.r871xs_drv.remove = rtw_dev_remove,
+	.r871xs_drv.name = (char*)DRV_NAME,
+	.r871xs_drv.id_table = sdio_ids,
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)) 
+	.r871xs_drv.drv = {
+		.pm = &rtw_sdio_pm_ops,
+	}
+	#endif
+};
+
+static void sd_sync_int_hdl(struct sdio_func *func)
+{
+	struct dvobj_priv *psdpriv;
+
+	psdpriv = sdio_get_drvdata(func);
+
+	if (!psdpriv->padapters[IFACE_ID0]) {
+		DBG_871X("%s if1 == NULL\n", __func__);
+		return;
+	}
+
+	rtw_sdio_set_irq_thd(psdpriv, current);
+	sd_int_hdl(psdpriv->padapters[IFACE_ID0]);
+	rtw_sdio_set_irq_thd(psdpriv, NULL);
+}
+
+int sdio_alloc_irq(struct dvobj_priv *dvobj)
+{
+	PSDIO_DATA psdio_data;
+	struct sdio_func *func;
+	int err;
+
+	psdio_data = &dvobj->intf_data;
+	func = psdio_data->func;
+
+	sdio_claim_host(func);
+
+	err = sdio_claim_irq(func, &sd_sync_int_hdl);
+	if (err)
+	{
+		dvobj->drv_dbg.dbg_sdio_alloc_irq_error_cnt++;
+		printk(KERN_CRIT "%s: sdio_claim_irq FAIL(%d)!\n", __func__, err);
+	}
+	else
+	{
+		dvobj->drv_dbg.dbg_sdio_alloc_irq_cnt++;
+		dvobj->irq_alloc = 1;
+	}
+
+	sdio_release_host(func);
+
+	return err?_FAIL:_SUCCESS;
+}
+
+void sdio_free_irq(struct dvobj_priv *dvobj)
+{
+    PSDIO_DATA psdio_data;
+    struct sdio_func *func;
+    int err;
+
+    if (dvobj->irq_alloc) {
+        psdio_data = &dvobj->intf_data;
+        func = psdio_data->func;
+
+        if (func) {
+            sdio_claim_host(func);
+            err = sdio_release_irq(func);
+            if (err)
+            {
+				dvobj->drv_dbg.dbg_sdio_free_irq_error_cnt++;
+				DBG_871X_LEVEL(_drv_err_,"%s: sdio_release_irq FAIL(%d)!\n", __func__, err);
+            }
+            else
+            	dvobj->drv_dbg.dbg_sdio_free_irq_cnt++;
+            sdio_release_host(func);
+        }
+        dvobj->irq_alloc = 0;
+    }
+}
+
+#ifdef CONFIG_GPIO_WAKEUP
+extern unsigned int oob_irq;
+extern unsigned int oob_gpio;
+static irqreturn_t gpio_hostwakeup_irq_thread(int irq, void *data)
+{
+	PADAPTER padapter = (PADAPTER)data;
+	DBG_871X_LEVEL(_drv_always_, "gpio_hostwakeup_irq_thread\n");
+	/* Disable interrupt before calling handler */
+	//disable_irq_nosync(oob_irq);
+	rtw_lock_suspend_timeout(HZ/2);
+#ifdef CONFIG_PLATFORM_ARM_SUN6I
+	return 0;
+#else
+	return IRQ_HANDLED;
+#endif
+}
+
+static u8 gpio_hostwakeup_alloc_irq(PADAPTER padapter)
+{
+	int err;
+	if (oob_irq == 0) {
+		DBG_871X("oob_irq ZERO!\n");
+		return _FAIL;
+	}
+
+	DBG_871X("%s : oob_irq = %d\n", __func__, oob_irq);
+	
+	/* dont set it IRQF_TRIGGER_LOW, or wowlan */
+	/* power is high after suspend */
+	/* and failing can prevent can not sleep issue if */
+	/* wifi gpio12 pin is not linked with CPU */
+	err = request_threaded_irq(oob_irq, gpio_hostwakeup_irq_thread, NULL,
+		//IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+		IRQF_TRIGGER_FALLING | IRQF_NO_SUSPEND,
+		"rtw_wifi_gpio_wakeup", padapter);
+	if (err < 0) {
+		DBG_871X("Oops: can't allocate gpio irq %d err:%d\n", oob_irq, err);
+		return _FALSE;
+	} else {
+		DBG_871X("allocate gpio irq %d ok\n", oob_irq);
+	}
+	
+#ifndef CONFIG_PLATFORM_ARM_SUN8I	
+	enable_irq_wake(oob_irq);
+#endif
+	return _SUCCESS;
+}
+
+static void gpio_hostwakeup_free_irq(PADAPTER padapter)
+{
+	wifi_free_gpio(oob_gpio);
+
+	if (oob_irq == 0)
+		return;
+		
+#ifndef CONFIG_PLATFORM_ARM_SUN8I
+	disable_irq_wake(oob_irq);
+#endif
+	free_irq(oob_irq, padapter);
+}
+#endif
+
+static u32 sdio_init(struct dvobj_priv *dvobj)
+{
+	PSDIO_DATA psdio_data;
+	struct sdio_func *func;
+	int err;
+
+_func_enter_;
+
+	psdio_data = &dvobj->intf_data;
+	func = psdio_data->func;
+
+	//3 1. init SDIO bus
+	sdio_claim_host(func);
+
+	err = sdio_enable_func(func);
+	if (err) {
+		dvobj->drv_dbg.dbg_sdio_init_error_cnt++;
+		DBG_8192C(KERN_CRIT "%s: sdio_enable_func FAIL(%d)!\n", __func__, err);
+		goto release;
+	}
+
+	err = sdio_set_block_size(func, 512);
+	if (err) {
+		dvobj->drv_dbg.dbg_sdio_init_error_cnt++;
+		DBG_8192C(KERN_CRIT "%s: sdio_set_block_size FAIL(%d)!\n", __func__, err);
+		goto release;
+	}
+	psdio_data->block_transfer_len = 512;
+	psdio_data->tx_block_mode = 1;
+	psdio_data->rx_block_mode = 1;
+
+release:
+	sdio_release_host(func);
+
+exit:
+_func_exit_;
+
+	if (err) return _FAIL;
+	return _SUCCESS;
+}
+
+static void sdio_deinit(struct dvobj_priv *dvobj)
+{
+	struct sdio_func *func;
+	int err;
+
+
+	RT_TRACE(_module_hci_intfs_c_, _drv_notice_, ("+sdio_deinit\n"));
+
+	func = dvobj->intf_data.func;
+
+	if (func) {
+		sdio_claim_host(func);
+		err = sdio_disable_func(func);
+		if (err)
+		{
+			dvobj->drv_dbg.dbg_sdio_deinit_error_cnt++;
+			DBG_8192C(KERN_ERR "%s: sdio_disable_func(%d)\n", __func__, err);
+		}
+
+		if (dvobj->irq_alloc) {
+			err = sdio_release_irq(func);
+			if (err)
+			{
+				dvobj->drv_dbg.dbg_sdio_free_irq_error_cnt++;
+				DBG_8192C(KERN_ERR "%s: sdio_release_irq(%d)\n", __func__, err);
+			}
+			else
+				dvobj->drv_dbg.dbg_sdio_free_irq_cnt++;
+		}
+
+		sdio_release_host(func);
+	}
+}
+
+static void rtw_decide_chip_type_by_device_id(struct dvobj_priv *dvobj, const struct sdio_device_id  *pdid)
+{
+	dvobj->chip_type = pdid->driver_data;
+
+#if defined(CONFIG_RTL8188E)
+	if (dvobj->chip_type == RTL8188E) {
+		dvobj->HardwareType = HARDWARE_TYPE_RTL8188ES;
+		DBG_871X("CHIP TYPE: RTL8188E\n");
+	}
+#endif
+
+#if defined(CONFIG_RTL8723B)
+	dvobj->chip_type = RTL8723B;
+	dvobj->HardwareType = HARDWARE_TYPE_RTL8723BS;
+#endif
+
+#if defined(CONFIG_RTL8821A)
+	if (dvobj->chip_type == RTL8821) {
+		dvobj->HardwareType = HARDWARE_TYPE_RTL8821S;
+		DBG_871X("CHIP TYPE: RTL8821A\n");
+	}
+#endif
+
+#if defined(CONFIG_RTL8192E)
+	if (dvobj->chip_type == RTL8192E) {
+		dvobj->HardwareType = HARDWARE_TYPE_RTL8192ES;
+		DBG_871X("CHIP TYPE: RTL8192E\n");
+	}
+#endif
+
+#if defined(CONFIG_RTL8703B)
+	if (dvobj->chip_type == RTL8703B) {
+		dvobj->HardwareType = HARDWARE_TYPE_RTL8703BS;
+		DBG_871X("CHIP TYPE: RTL8703B\n");
+	}
+#endif
+
+#if defined(CONFIG_RTL8188F)
+	if (dvobj->chip_type == RTL8188F) {
+		dvobj->HardwareType = HARDWARE_TYPE_RTL8188FS;
+		DBG_871X("CHIP TYPE: RTL8188F\n");
+	}
+#endif
+}
+
+static struct dvobj_priv *sdio_dvobj_init(struct sdio_func *func, const struct sdio_device_id  *pdid)
+{
+	int status = _FAIL;
+	struct dvobj_priv *dvobj = NULL;
+	PSDIO_DATA psdio;
+_func_enter_;
+
+	if((dvobj = devobj_init()) == NULL) {
+		goto exit;
+	}
+
+	sdio_set_drvdata(func, dvobj);
+
+	psdio = &dvobj->intf_data;
+	psdio->func = func;
+
+	if (sdio_init(dvobj) != _SUCCESS) {
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("%s: initialize SDIO Failed!\n", __FUNCTION__));
+		goto free_dvobj;
+	}
+
+	dvobj->interface_type = RTW_SDIO;
+	rtw_decide_chip_type_by_device_id(dvobj, pdid);
+
+	rtw_reset_continual_io_error(dvobj);
+	status = _SUCCESS;
+
+free_dvobj:
+	if (status != _SUCCESS && dvobj) {
+		sdio_set_drvdata(func, NULL);
+		
+		devobj_deinit(dvobj);
+		
+		dvobj = NULL;
+	}
+exit:
+_func_exit_;
+	return dvobj;
+}
+
+static void sdio_dvobj_deinit(struct sdio_func *func)
+{
+	struct dvobj_priv *dvobj = sdio_get_drvdata(func);
+_func_enter_;
+
+	sdio_set_drvdata(func, NULL);
+	if (dvobj) {
+		sdio_deinit(dvobj);
+		devobj_deinit(dvobj);
+	}
+
+_func_exit_;
+	return;
+}
+
+u8 rtw_set_hal_ops(PADAPTER padapter)
+{
+	//alloc memory for HAL DATA
+	if(rtw_hal_data_init(padapter) == _FAIL)
+		return _FAIL;
+
+#if defined(CONFIG_RTL8188E)
+	if (rtw_get_chip_type(padapter) == RTL8188E)
+		rtl8188es_set_hal_ops(padapter);
+#endif
+
+#if defined(CONFIG_RTL8723B)
+	if (rtw_get_chip_type(padapter) == RTL8723B)
+		rtl8723bs_set_hal_ops(padapter);
+#endif
+
+#if defined(CONFIG_RTL8821A)
+	if (rtw_get_chip_type(padapter) == RTL8821)
+		rtl8821as_set_hal_ops(padapter);
+#endif
+
+#if defined(CONFIG_RTL8192E)
+	if (rtw_get_chip_type(padapter) == RTL8192E)
+		rtl8192es_set_hal_ops(padapter);
+#endif
+
+#if defined(CONFIG_RTL8703B)
+	if (rtw_get_chip_type(padapter) == RTL8703B)
+		rtl8703bs_set_hal_ops(padapter);
+#endif
+
+#if defined(CONFIG_RTL8188F)
+	if (rtw_get_chip_type(padapter) == RTL8188F)
+		rtl8188fs_set_hal_ops(padapter);
+#endif
+
+	if( rtw_hal_ops_check(padapter) == _FAIL)
+		return _FAIL;
+
+	if (hal_spec_init(padapter) == _FAIL)
+		return _FAIL;
+
+	return _SUCCESS;
+}
+
+static void sd_intf_start(PADAPTER padapter)
+{
+	if (padapter == NULL) {
+		DBG_8192C(KERN_ERR "%s: padapter is NULL!\n", __func__);
+		return;
+	}
+
+	// hal dep
+	rtw_hal_enable_interrupt(padapter);
+}
+
+static void sd_intf_stop(PADAPTER padapter)
+{
+	if (padapter == NULL) {
+		DBG_8192C(KERN_ERR "%s: padapter is NULL!\n", __func__);
+		return;
+	}
+
+	// hal dep
+	rtw_hal_disable_interrupt(padapter);
+}
+
+
+#ifdef RTW_SUPPORT_PLATFORM_SHUTDOWN
+PADAPTER g_test_adapter = NULL;
+#endif // RTW_SUPPORT_PLATFORM_SHUTDOWN
+
+_adapter *rtw_sdio_if1_init(struct dvobj_priv *dvobj)
+{
+	int status = _FAIL;
+	PADAPTER padapter = NULL;
+	PSDIO_DATA psdio = &dvobj->intf_data;
+
+	padapter = (_adapter *)rtw_zvmalloc(sizeof(*padapter));
+	if (padapter == NULL)
+		goto exit;
+
+	if (loadparam(padapter) != _SUCCESS)
+		goto free_adapter;
+
+#ifdef RTW_SUPPORT_PLATFORM_SHUTDOWN
+	g_test_adapter = padapter;
+#endif // RTW_SUPPORT_PLATFORM_SHUTDOWN
+	padapter->dvobj = dvobj;
+
+	rtw_set_drv_stopped(padapter);/*init*/
+
+	dvobj->padapters[dvobj->iface_nums++] = padapter;
+	padapter->iface_id = IFACE_ID0;
+
+#if defined(CONFIG_CONCURRENT_MODE)
+	//set adapter_type/iface type for primary padapter
+	padapter->isprimary = _TRUE;
+	padapter->adapter_type = PRIMARY_ADAPTER;	
+	#ifndef CONFIG_HWPORT_SWAP
+	padapter->iface_type = IFACE_PORT0;
+	#else
+	padapter->iface_type = IFACE_PORT1;
+	#endif
+#endif
+
+	//3 3. init driver special setting, interface, OS and hardware relative
+
+	//4 3.1 set hardware operation functions
+	if (rtw_set_hal_ops(padapter)== _FAIL)
+		goto free_hal_data;
+
+	//3 5. initialize Chip version
+	padapter->intf_start = &sd_intf_start;
+	padapter->intf_stop = &sd_intf_stop;
+
+	padapter->intf_init = &sdio_init;
+	padapter->intf_deinit = &sdio_deinit;
+	padapter->intf_alloc_irq = &sdio_alloc_irq;
+	padapter->intf_free_irq = &sdio_free_irq;
+
+	if (rtw_init_io_priv(padapter, sdio_set_intf_ops) == _FAIL)
+	{
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_,
+			("rtw_drv_init: Can't init io_priv\n"));
+		goto free_hal_data;
+	}
+
+	rtw_hal_read_chip_version(padapter);
+
+	rtw_hal_chip_configure(padapter);
+
+#ifdef CONFIG_BT_COEXIST
+	rtw_btcoex_Initialize(padapter);
+#endif // CONFIG_BT_COEXIST
+
+	//3 6. read efuse/eeprom data
+	rtw_hal_read_chip_info(padapter);
+
+	//3 7. init driver common data
+	if (rtw_init_drv_sw(padapter) == _FAIL) {
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_,
+			 ("rtw_drv_init: Initialize driver software resource Failed!\n"));
+		goto free_hal_data;
+	}
+
+	//3 8. get WLan MAC address
+	// set mac addr
+	rtw_macaddr_cfg(&psdio->func->dev, adapter_mac_addr(padapter),  get_hal_mac_addr(padapter));
+	rtw_init_wifidirect_addrs(padapter, adapter_mac_addr(padapter), adapter_mac_addr(padapter));
+
+	rtw_hal_disable_interrupt(padapter);
+
+	DBG_871X("bDriverStopped:%s, bSurpriseRemoved:%s, bup:%d, hw_init_completed:%d\n"
+		, rtw_is_drv_stopped(padapter)?"True":"False"
+		, rtw_is_surprise_removed(padapter)?"True":"False"
+		, padapter->bup
+		, rtw_get_hw_init_completed(padapter)
+	);
+	
+	status = _SUCCESS;
+	
+free_hal_data:
+	if (status != _SUCCESS && padapter->HalData)
+		rtw_hal_free_data(padapter);
+
+free_adapter:
+	if (status != _SUCCESS && padapter) {
+		rtw_vmfree((u8 *)padapter, sizeof(*padapter));
+		padapter = NULL;
+	}
+exit:
+	return padapter;
+}
+
+static void rtw_sdio_if1_deinit(_adapter *if1)
+{
+	struct mlme_priv *pmlmepriv= &if1->mlmepriv;
+
+	if(check_fwstate(pmlmepriv, _FW_LINKED))
+		rtw_disassoc_cmd(if1, 0, _FALSE);
+
+#ifdef CONFIG_AP_MODE
+	free_mlme_ap_info(if1);
+	#ifdef CONFIG_HOSTAPD_MLME
+	hostapd_mode_unload(if1);
+	#endif
+#endif
+
+#ifdef CONFIG_GPIO_WAKEUP
+#ifdef CONFIG_PLATFORM_ARM_SUN6I 
+        sw_gpio_eint_set_enable(gpio_eint_wlan, 0);
+        sw_gpio_irq_free(eint_wlan_handle);
+#else  
+	gpio_hostwakeup_free_irq(if1);
+#endif
+#endif
+
+	rtw_cancel_all_timer(if1);
+
+#ifdef CONFIG_WOWLAN
+	adapter_to_pwrctl(if1)->wowlan_mode=_FALSE;
+	DBG_871X_LEVEL(_drv_always_, "%s wowlan_mode:%d\n", __func__, adapter_to_pwrctl(if1)->wowlan_mode);
+#endif //CONFIG_WOWLAN
+
+	rtw_dev_unload(if1);
+	DBG_871X("+r871xu_dev_remove, hw_init_completed=%d\n", rtw_get_hw_init_completed(if1));
+
+	rtw_free_drv_sw(if1);
+
+	/* TODO: use rtw_os_ndevs_deinit instead at the first stage of driver's dev deinit function */
+	rtw_os_ndev_free(if1);
+
+	rtw_vmfree((u8 *)if1, sizeof(_adapter));
+
+#ifdef CONFIG_PLATFORM_RTD2880B
+	DBG_871X("wlan link down\n");
+	rtd2885_wlan_netlink_sendMsg("linkdown", "8712");
+#endif
+
+#ifdef RTW_SUPPORT_PLATFORM_SHUTDOWN
+	g_test_adapter = NULL;
+#endif // RTW_SUPPORT_PLATFORM_SHUTDOWN
+}
+
+/*
+ * drv_init() - a device potentially for us
+ *
+ * notes: drv_init() is called when the bus driver has located a card for us to support.
+ *        We accept the new device by returning 0.
+ */
+static int rtw_drv_init(
+	struct sdio_func *func,
+	const struct sdio_device_id *id)
+{
+	int status = _FAIL;
+	struct net_device *pnetdev;
+	PADAPTER if1 = NULL, if2 = NULL;
+	struct dvobj_priv *dvobj;
+
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+
+#ifdef CONFIG_ACPI
+        acpi_handle handle;
+        struct acpi_device *adev;
+#endif
+
+#if defined(CONFIG_ACPI) && defined(CONFIG_GPIO_WAKEUP)
+	handle = ACPI_HANDLE(&func->dev);
+
+	if (handle) {
+		/* Dont try to do acpi pm for the wifi module */
+		if (!handle || acpi_bus_get_device(handle, &adev))
+			DBG_871X("Could not get acpi pointer!\n");
+		else {
+			adev->flags.power_manageable = 0;
+			DBG_871X("Disabling ACPI power management support!\n");
+		}
+		oob_gpio = acpi_get_gpio_by_index(&func->dev, 0, NULL);
+		DBG_871X("rtw_drv_init: ACPI_HANDLE found oob_gpio %d!\n", oob_gpio);
+		wifi_configure_gpio();
+	}
+	else
+		DBG_871X("rtw_drv_init: ACPI_HANDLE NOT found!\n");
+#endif
+
+#if defined(CONFIG_ACPI)
+	if (&func->dev && ACPI_HANDLE(&func->dev)) {
+		wlan_en_gpio = acpi_get_gpio_by_index(&func->dev, 1, NULL);
+		DBG_871X("rtw_drv_init: ACPI_HANDLE found wlan_en %d!\n", wlan_en_gpio);
+	}
+	else
+		DBG_871X("rtw_drv_init: ACPI_HANDLE NOT found!\n");
+#endif
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
+
+	RT_TRACE(_module_hci_intfs_c_, _drv_info_,
+		("+rtw_drv_init: vendor=0x%04x device=0x%04x class=0x%02x\n",
+		func->vendor, func->device, func->class));
+
+	if ((dvobj = sdio_dvobj_init(func, id)) == NULL) {
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("initialize device object priv Failed!\n"));
+		goto exit;
+	}
+
+	if ((if1 = rtw_sdio_if1_init(dvobj)) == NULL) {
+		DBG_871X("rtw_init_primary_adapter Failed!\n");
+		goto free_dvobj;
+	}
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if ((if2 = rtw_drv_if2_init(if1, sdio_set_intf_ops)) == NULL) {
+		goto free_if1;
+	}
+#endif
+
+	//dev_alloc_name && register_netdev
+	if (rtw_os_ndevs_init(dvobj) != _SUCCESS)
+		goto free_if2;
+
+#ifdef CONFIG_HOSTAPD_MLME
+	hostapd_mode_init(if1);
+#endif
+
+#ifdef CONFIG_PLATFORM_RTD2880B
+	DBG_871X("wlan link up\n");
+	rtd2885_wlan_netlink_sendMsg("linkup", "8712");
+#endif
+
+	if (sdio_alloc_irq(dvobj) != _SUCCESS)
+		goto os_ndevs_deinit;
+
+#ifdef	CONFIG_GPIO_WAKEUP
+#ifdef CONFIG_PLATFORM_ARM_SUN6I
+        eint_wlan_handle = sw_gpio_irq_request(gpio_eint_wlan, TRIG_EDGE_NEGATIVE,(peint_handle)gpio_hostwakeup_irq_thread, NULL);
+        if (!eint_wlan_handle) {
+               DBG_871X( "%s: request irq failed\n",__func__);
+               return -1;
+  }
+#else
+	gpio_hostwakeup_alloc_irq(if1);
+#endif
+#endif
+
+#ifdef CONFIG_GLOBAL_UI_PID
+	if(ui_pid[1]!=0) {
+		DBG_871X("ui_pid[1]:%d\n",ui_pid[1]);
+		rtw_signal_process(ui_pid[1], SIGUSR2);
+	}
+#endif
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-871x_drv - drv_init, success!\n"));
+
+	status = _SUCCESS;
+
+os_ndevs_deinit:
+	if (status != _SUCCESS)
+		rtw_os_ndevs_deinit(dvobj);
+free_if2:
+	if(status != _SUCCESS && if2) {
+		#ifdef CONFIG_CONCURRENT_MODE
+		rtw_drv_if2_stop(if2);
+		rtw_drv_if2_free(if2);
+		#endif
+	}
+free_if1:
+	if (status != _SUCCESS && if1) {
+		rtw_sdio_if1_deinit(if1);
+	}
+free_dvobj:
+	if (status != _SUCCESS)
+		sdio_dvobj_deinit(func);
+exit:
+	return status == _SUCCESS?0:-ENODEV;
+}
+
+static void rtw_dev_remove(struct sdio_func *func)
+{
+	struct dvobj_priv *dvobj = sdio_get_drvdata(func);
+	struct pwrctrl_priv *pwrctl = dvobj_to_pwrctl(dvobj);
+	PADAPTER padapter = dvobj->padapters[IFACE_ID0];
+
+_func_enter_;
+
+	RT_TRACE(_module_hci_intfs_c_, _drv_notice_, ("+rtw_dev_remove\n"));
+
+	dvobj->processing_dev_remove = _TRUE;
+
+	/* TODO: use rtw_os_ndevs_deinit instead at the first stage of driver's dev deinit function */
+	rtw_os_ndevs_unregister(dvobj);
+
+	if (!rtw_is_surprise_removed(padapter)) {
+		int err;
+
+		/* test surprise remove */
+		sdio_claim_host(func);
+		sdio_readb(func, 0, &err);
+		sdio_release_host(func);
+		if (err == -ENOMEDIUM) {
+			rtw_set_surprise_removed(padapter);
+			DBG_871X(KERN_NOTICE "%s: device had been removed!\n", __func__);
+		}
+	}
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
+	rtw_unregister_early_suspend(pwrctl);
+#endif
+
+	if (padapter->bFWReady == _TRUE) {
+		rtw_ps_deny(padapter, PS_DENY_DRV_REMOVE);
+		rtw_pm_set_ips(padapter, IPS_NONE);
+		rtw_pm_set_lps(padapter, PS_MODE_ACTIVE);
+		LeaveAllPowerSaveMode(padapter);
+	}
+	rtw_set_drv_stopped(padapter);	/*for stop thread*/
+#ifdef CONFIG_CONCURRENT_MODE
+	rtw_drv_if2_stop(dvobj->padapters[IFACE_ID1]);
+#endif
+
+#ifdef CONFIG_BT_COEXIST
+	rtw_btcoex_HaltNotify(padapter);
+#endif
+
+	rtw_sdio_if1_deinit(padapter);
+
+#ifdef CONFIG_CONCURRENT_MODE
+	rtw_drv_if2_free(dvobj->padapters[IFACE_ID1]);
+#endif
+
+	sdio_dvobj_deinit(func);
+
+	RT_TRACE(_module_hci_intfs_c_, _drv_notice_, ("-rtw_dev_remove\n"));
+
+_func_exit_;
+}
+extern int pm_netdev_open(struct net_device *pnetdev,u8 bnormal);
+extern int pm_netdev_close(struct net_device *pnetdev,u8 bnormal);
+
+static int rtw_sdio_suspend(struct device *dev)
+{
+	struct sdio_func *func =dev_to_sdio_func(dev);
+	struct dvobj_priv *psdpriv = sdio_get_drvdata(func);
+	struct pwrctrl_priv *pwrpriv = NULL;
+	_adapter *padapter = NULL;
+	struct debug_priv *pdbgpriv = NULL;
+	int ret = 0;
+	u8 ch, bw, offset;
+
+	if (psdpriv == NULL)
+		goto exit;
+
+	pwrpriv = dvobj_to_pwrctl(psdpriv);
+	padapter = psdpriv->padapters[IFACE_ID0];
+	pdbgpriv = &psdpriv->drv_dbg;
+	if (rtw_is_drv_stopped(padapter)) {
+		DBG_871X("%s bDriverStopped == _TRUE\n", __func__);
+		goto exit;
+	}
+
+	if (pwrpriv->bInSuspend == _TRUE)
+	{
+		DBG_871X("%s bInSuspend = %d\n", __func__, pwrpriv->bInSuspend);
+		pdbgpriv->dbg_suspend_error_cnt++;
+		goto exit;
+	}
+
+	ret = rtw_suspend_common(padapter);		
+
+exit:
+#ifdef CONFIG_RTW_SDIO_PM_KEEP_POWER 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+	//Android 4.0 don't support WIFI close power
+	//or power down or clock will close after wifi resume,
+	//this is sprd's bug in Android 4.0, but sprd don't
+	//want to fix it.
+	//we have test power under 8723as, power consumption is ok
+	if (func) {
+		mmc_pm_flag_t pm_flag = 0;
+		pm_flag = sdio_get_host_pm_caps(func);
+		DBG_871X("cmd: %s: suspend: PM flag = 0x%x\n", sdio_func_id(func), pm_flag);
+		if (!(pm_flag & MMC_PM_KEEP_POWER)) {
+			DBG_871X("%s: cannot remain alive while host is suspended\n", sdio_func_id(func));
+			if (pdbgpriv)
+				pdbgpriv->dbg_suspend_error_cnt++;
+			return -ENOSYS;
+		} else {
+			DBG_871X("cmd: suspend with MMC_PM_KEEP_POWER\n");
+			sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+		}
+	}
+#endif	
+#endif
+	return ret;
+}
+int rtw_resume_process(_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+		
+	if (pwrpriv->bInSuspend == _FALSE)
+	{
+		pdbgpriv->dbg_resume_error_cnt++;
+		DBG_871X("%s bInSuspend = %d\n", __FUNCTION__, pwrpriv->bInSuspend);
+		return -1;
+	}
+	
+	return rtw_resume_common(padapter);
+}
+
+static int rtw_sdio_resume(struct device *dev)
+{
+	struct sdio_func *func =dev_to_sdio_func(dev);
+	struct dvobj_priv *psdpriv = sdio_get_drvdata(func);
+	struct pwrctrl_priv *pwrpriv = dvobj_to_pwrctl(psdpriv);
+	_adapter *padapter = psdpriv->padapters[IFACE_ID0];
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	int ret = 0;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+
+	DBG_871X("==> %s (%s:%d)\n",__FUNCTION__, current->comm, current->pid);
+
+	pdbgpriv->dbg_resume_cnt++;
+
+	if(pwrpriv->bInternalAutoSuspend)
+	{
+ 		ret = rtw_resume_process(padapter);
+	}
+	else
+	{
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+		if(0)
+#else
+		if(pwrpriv->wowlan_mode || pwrpriv->wowlan_ap_mode)
+#endif
+		{
+			rtw_resume_lock_suspend();			
+			ret = rtw_resume_process(padapter);
+			rtw_resume_unlock_suspend();
+		}
+		else
+		{
+#ifdef CONFIG_RESUME_IN_WORKQUEUE
+			rtw_resume_in_workqueue(pwrpriv);
+#else			
+			if (rtw_is_earlysuspend_registered(pwrpriv))
+			{
+				/* jeff: bypass resume here, do in late_resume */
+				rtw_set_do_late_resume(pwrpriv, _TRUE);
+			}	
+			else
+			{
+				rtw_resume_lock_suspend();			
+				ret = rtw_resume_process(padapter);
+				rtw_resume_unlock_suspend();
+			}
+#endif
+		}
+	}
+	pmlmeext->last_scan_time = rtw_get_current_time();
+	DBG_871X("<========  %s return %d\n", __FUNCTION__, ret);
+	return ret;
+
+}
+
+static int __init rtw_drv_entry(void)
+{
+	int ret = 0;
+
+	DBG_871X_LEVEL(_drv_always_, "module init start\n");
+	dump_drv_version(RTW_DBGDUMP);
+#ifdef BTCOEXVERSION
+	DBG_871X_LEVEL(_drv_always_, DRV_NAME" BT-Coex version = %s\n", BTCOEXVERSION);
+#endif // BTCOEXVERSION
+
+	ret = platform_wifi_power_on();
+	if (ret)
+	{
+		DBG_871X("%s: power on failed!!(%d)\n", __FUNCTION__, ret);
+		ret = -1;
+		goto exit;
+	}
+
+	sdio_drvpriv.drv_registered = _TRUE;
+	rtw_suspend_lock_init();
+	rtw_drv_proc_init();
+	rtw_ndev_notifier_register();
+
+	ret = sdio_register_driver(&sdio_drvpriv.r871xs_drv);
+	if (ret != 0)
+	{
+		sdio_drvpriv.drv_registered = _FALSE;
+		rtw_suspend_lock_uninit();
+		rtw_drv_proc_deinit();
+		rtw_ndev_notifier_unregister();
+		DBG_871X("%s: register driver failed!!(%d)\n", __FUNCTION__, ret);
+		goto poweroff;
+	}
+
+#ifndef CONFIG_PLATFORM_INTEL_BYT
+	rtw_android_wifictrl_func_add();
+#endif //!CONFIG_PLATFORM_INTEL_BYT
+	goto exit;
+
+poweroff:
+	platform_wifi_power_off();
+
+exit:
+	DBG_871X_LEVEL(_drv_always_, "module init ret=%d\n", ret);
+	return ret;
+}
+
+static void __exit rtw_drv_halt(void)
+{
+	DBG_871X_LEVEL(_drv_always_, "module exit start\n");
+
+	sdio_drvpriv.drv_registered = _FALSE;
+
+	sdio_unregister_driver(&sdio_drvpriv.r871xs_drv);
+
+	rtw_android_wifictrl_func_del();
+
+	platform_wifi_power_off();
+
+	rtw_suspend_lock_uninit();
+	rtw_drv_proc_deinit();
+	rtw_ndev_notifier_unregister();
+
+	DBG_871X_LEVEL(_drv_always_, "module exit success\n");
+
+	rtw_mstat_dump(RTW_DBGDUMP);
+}
+
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+int rtw_sdio_set_power(int on)
+{
+
+	if(wlan_en_gpio >= 0){
+		if(on)
+			gpio_set_value(wlan_en_gpio,1);
+		else
+			gpio_set_value(wlan_en_gpio,0);
+	}
+
+	return 0;
+}
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
+module_init(rtw_drv_entry);
+module_exit(rtw_drv_halt);
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/sdio_ops_linux.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/sdio_ops_linux.c
new file mode 100644
index 000000000..0ea81f150
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/sdio_ops_linux.c
@@ -0,0 +1,910 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *******************************************************************************/
+#define _SDIO_OPS_LINUX_C_
+
+#include <drv_types.h>
+
+static bool rtw_sdio_claim_host_needed(struct sdio_func *func)
+{
+	struct dvobj_priv *dvobj = sdio_get_drvdata(func);
+	PSDIO_DATA sdio_data = &dvobj->intf_data;
+
+	if (sdio_data->sys_sdio_irq_thd && sdio_data->sys_sdio_irq_thd == current)
+		return _FALSE;
+	return _TRUE;
+}
+
+inline void rtw_sdio_set_irq_thd(struct dvobj_priv *dvobj, _thread_hdl_ thd_hdl)
+{
+	PSDIO_DATA sdio_data = &dvobj->intf_data;
+
+	sdio_data->sys_sdio_irq_thd = thd_hdl;
+}
+
+u8 sd_f0_read8(struct intf_hdl *pintfhdl,u32 addr, s32 *err)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	u8 v=0;
+	struct sdio_func *func;
+	bool claim_needed;
+
+_func_enter_;
+
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return v;
+	}	
+	
+	func = psdio->func;
+	claim_needed = rtw_sdio_claim_host_needed(func);
+
+	if (claim_needed)
+		sdio_claim_host(func);
+	v = sdio_f0_readb(func, addr, err);
+	if (claim_needed)
+		sdio_release_host(func);
+	if (err && *err)
+		DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x\n", __func__, *err, addr);
+
+_func_exit_;
+
+	return v;
+}
+
+void sd_f0_write8(struct intf_hdl *pintfhdl, u32 addr, u8 v, s32 *err)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	struct sdio_func *func;
+	bool claim_needed;
+	
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return;
+	}	
+	
+	func = psdio->func;
+	claim_needed = rtw_sdio_claim_host_needed(func);
+
+	if (claim_needed)
+		sdio_claim_host(func);
+	sdio_f0_writeb(func, v, addr, err);
+	if (claim_needed)
+		sdio_release_host(func);
+	if (err && *err)
+		DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x val=0x%02x\n", __func__, *err, addr, v);
+
+_func_exit_;
+}
+
+/*
+ * Return:
+ *	0		Success
+ *	others	Fail
+ */
+s32 _sd_cmd52_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+
+	int err=0, i;
+	struct sdio_func *func;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return err;
+	}
+	
+	func = psdio->func;
+
+	for (i = 0; i < cnt; i++) {
+		pdata[i] = sdio_readb(func, addr+i, &err);
+		if (err) {
+			DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x\n", __func__, err, addr+i);
+			break;
+		}
+	}
+
+_func_exit_;
+
+	return err;
+}
+
+/*
+ * Return:
+ *	0		Success
+ *	others	Fail
+ */
+s32 sd_cmd52_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	int err=0, i;
+	struct sdio_func *func;
+	bool claim_needed;	
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return err;
+	}	
+	
+	func = psdio->func;
+	claim_needed = rtw_sdio_claim_host_needed(func);
+
+	if (claim_needed)
+		sdio_claim_host(func);
+	err = _sd_cmd52_read(pintfhdl, addr, cnt, pdata);
+	if (claim_needed)
+		sdio_release_host(func);
+
+_func_exit_;
+
+	return err;
+}
+
+/*
+ * Return:
+ *	0		Success
+ *	others	Fail
+ */
+s32 _sd_cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	int err=0, i;
+	struct sdio_func *func;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return err;
+	}
+	
+	func = psdio->func;
+
+	for (i = 0; i < cnt; i++) {
+		sdio_writeb(func, pdata[i], addr+i, &err);
+		if (err) {
+			DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x val=0x%02x\n", __func__, err, addr+i, pdata[i]);
+			break;
+		}
+	}
+
+_func_exit_;
+
+	return err;
+}
+
+/*
+ * Return:
+ *	0		Success
+ *	others	Fail
+ */
+s32 sd_cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	int err=0, i;
+	struct sdio_func *func;
+	bool claim_needed;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return err;
+	}
+	
+	func = psdio->func;
+	claim_needed = rtw_sdio_claim_host_needed(func);
+
+	if (claim_needed)
+		sdio_claim_host(func);
+	err = _sd_cmd52_write(pintfhdl, addr, cnt, pdata);
+	if (claim_needed)
+		sdio_release_host(func);
+
+_func_exit_;
+
+	return err;
+}
+
+u8 _sd_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+
+	u8 v=0;
+	struct sdio_func *func;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return v;
+	}
+	
+	func = psdio->func;
+
+	v = sdio_readb(func, addr, err);
+
+	if (err && *err)
+		DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x\n", __func__, *err, addr);
+
+_func_exit_;
+
+	return v;
+}
+
+u8 sd_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	u8 v=0;
+	struct sdio_func *func;
+	bool claim_needed;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return v;
+	}
+	
+	func = psdio->func;
+	claim_needed = rtw_sdio_claim_host_needed(func);
+
+	if (claim_needed)
+		sdio_claim_host(func);
+	v = sdio_readb(func, addr, err);
+	if (claim_needed)
+		sdio_release_host(func);
+	if (err && *err)
+		DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x\n", __func__, *err, addr);
+
+_func_exit_;
+
+	return v;
+}
+
+u16 sd_read16(struct intf_hdl *pintfhdl, u32 addr, s32 *err)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	u16 v=0;
+	struct sdio_func *func;
+	bool claim_needed;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return v;
+	}
+		
+	func = psdio->func;
+	claim_needed = rtw_sdio_claim_host_needed(func);
+
+	if (claim_needed)
+		sdio_claim_host(func);
+	v = sdio_readw(func, addr, err);
+	if (claim_needed)
+		sdio_release_host(func);
+	if (err && *err)
+		DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x\n", __func__, *err, addr);
+
+_func_exit_;
+
+	return  v;
+}
+
+u32 _sd_read32(struct intf_hdl *pintfhdl, u32 addr, s32 *err)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	u32 v=0;
+	struct sdio_func *func;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return v;
+	}
+		
+	func = psdio->func;
+
+	v = sdio_readl(func, addr, err);
+
+	if (err && *err)
+	{
+		int i;
+
+		DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x, val=0x%x\n", __func__, *err, addr, v);
+
+		*err = 0;
+		for(i=0; i<SD_IO_TRY_CNT; i++)
+		{
+			//sdio_claim_host(func);
+			v = sdio_readl(func, addr, err);
+			//sdio_release_host(func);
+			if (*err == 0){
+				rtw_reset_continual_io_error(psdiodev);
+				break;
+			}
+			else{
+				DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x, val=0x%x, try_cnt=%d\n", __func__, *err, addr, v, i);
+				if(( -ESHUTDOWN == *err ) || ( -ENODEV == *err))
+				{			
+					rtw_set_surprise_removed(padapter);
+				}
+
+				if(rtw_inc_and_chk_continual_io_error(psdiodev) == _TRUE ){
+					rtw_set_surprise_removed(padapter);
+					break;
+				}						
+					
+			}
+		}
+
+		if (i==SD_IO_TRY_CNT)
+			DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x, val=0x%x, try_cnt=%d\n", __func__, *err, addr, v, i);
+		else
+			DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x, val=0x%x, try_cnt=%d\n", __func__, *err, addr, v, i);
+
+	}
+
+_func_exit_;
+
+	return  v;
+}
+
+u32 sd_read32(struct intf_hdl *pintfhdl, u32 addr, s32 *err)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	u32 v=0;
+	struct sdio_func *func;
+	bool claim_needed;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return v;
+	}
+	
+	func = psdio->func;
+	claim_needed = rtw_sdio_claim_host_needed(func);
+
+	if (claim_needed)
+		sdio_claim_host(func);
+	v = sdio_readl(func, addr, err);
+	if (claim_needed)
+		sdio_release_host(func);
+
+	if (err && *err)
+	{
+		int i;
+
+		DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x, val=0x%x\n", __func__, *err, addr, v);
+
+		*err = 0;
+		for(i=0; i<SD_IO_TRY_CNT; i++)
+		{
+			if (claim_needed) sdio_claim_host(func);
+			v = sdio_readl(func, addr, err);
+			if (claim_needed) sdio_release_host(func);
+			
+			if (*err == 0){
+				rtw_reset_continual_io_error(psdiodev);
+				break;
+			}else{				
+				DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x, val=0x%x, try_cnt=%d\n", __func__, *err, addr, v, i);
+				if(( -ESHUTDOWN == *err ) || ( -ENODEV == *err)){			
+					rtw_set_surprise_removed(padapter);
+				}
+
+				if(rtw_inc_and_chk_continual_io_error(psdiodev) == _TRUE ){
+					rtw_set_surprise_removed(padapter);
+					break;
+				}
+			}
+		}
+
+		if (i==SD_IO_TRY_CNT)
+			DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x, val=0x%x, try_cnt=%d\n", __func__, *err, addr, v, i);
+		else
+			DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x, val=0x%x, try_cnt=%d\n", __func__, *err, addr, v, i);
+
+	}
+
+_func_exit_;
+
+	return  v;
+}
+
+void sd_write8(struct intf_hdl *pintfhdl, u32 addr, u8 v, s32 *err)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	struct sdio_func *func;
+	bool claim_needed;
+
+_func_enter_;
+
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return ;
+	}
+	
+	func = psdio->func;
+	claim_needed = rtw_sdio_claim_host_needed(func);
+
+	if (claim_needed)
+		sdio_claim_host(func);
+	sdio_writeb(func, v, addr, err);
+	if (claim_needed)
+		sdio_release_host(func);
+	if (err && *err)
+		DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x val=0x%02x\n", __func__, *err, addr, v);
+
+_func_exit_;
+}
+
+void sd_write16(struct intf_hdl *pintfhdl, u32 addr, u16 v, s32 *err)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	struct sdio_func *func;
+	bool claim_needed;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return ;
+	}
+	
+	func = psdio->func;
+	claim_needed = rtw_sdio_claim_host_needed(func);
+
+	if (claim_needed)
+		sdio_claim_host(func);
+	sdio_writew(func, v, addr, err);
+	if (claim_needed)
+		sdio_release_host(func);
+	if (err && *err)
+		DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x val=0x%04x\n", __func__, *err, addr, v);
+
+_func_exit_;
+}
+
+void _sd_write32(struct intf_hdl *pintfhdl, u32 addr, u32 v, s32 *err)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	struct sdio_func *func;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return ;
+	}
+	
+	func = psdio->func;
+
+	sdio_writel(func, v, addr, err);
+
+	if (err && *err)
+	{
+		int i;
+
+		DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x val=0x%08x\n", __func__, *err, addr, v);
+
+		*err = 0;
+		for(i=0; i<SD_IO_TRY_CNT; i++)
+		{
+			sdio_writel(func, v, addr, err);
+			if (*err == 0){
+				rtw_reset_continual_io_error(psdiodev);
+				break;
+			}else{				
+				DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x, val=0x%x, try_cnt=%d\n", __func__, *err, addr, v, i);
+				if(( -ESHUTDOWN == *err ) || ( -ENODEV == *err)){			
+					rtw_set_surprise_removed(padapter);
+				}
+
+				if(rtw_inc_and_chk_continual_io_error(psdiodev) == _TRUE ){
+					rtw_set_surprise_removed(padapter);
+					break;
+				}
+			}
+		}
+
+		if (i==SD_IO_TRY_CNT)
+			DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x val=0x%08x, try_cnt=%d\n", __func__, *err, addr, v, i);
+		else
+			DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x val=0x%08x, try_cnt=%d\n", __func__, *err, addr, v, i);
+
+	}
+
+_func_exit_;
+}
+
+void sd_write32(struct intf_hdl *pintfhdl, u32 addr, u32 v, s32 *err)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	struct sdio_func *func;
+	bool claim_needed;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return ;
+	}
+	
+	func = psdio->func;
+	claim_needed = rtw_sdio_claim_host_needed(func);
+
+	if (claim_needed)
+		sdio_claim_host(func);
+	sdio_writel(func, v, addr, err);
+	if (claim_needed)
+		sdio_release_host(func);
+
+	if (err && *err)
+	{
+		int i;
+
+		DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x val=0x%08x\n", __func__, *err, addr, v);
+
+		*err = 0;
+		for(i=0; i<SD_IO_TRY_CNT; i++)
+		{
+			if (claim_needed) sdio_claim_host(func);
+			sdio_writel(func, v, addr, err);
+			if (claim_needed) sdio_release_host(func);
+			if (*err == 0){
+				rtw_reset_continual_io_error(psdiodev);
+				break;
+			}else{				
+				DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x, val=0x%x, try_cnt=%d\n", __func__, *err, addr, v, i);
+				if(( -ESHUTDOWN == *err ) || ( -ENODEV == *err)){			
+					rtw_set_surprise_removed(padapter);
+				}
+
+				if(rtw_inc_and_chk_continual_io_error(psdiodev) == _TRUE ){
+					rtw_set_surprise_removed(padapter);
+					break;
+				}
+			}
+		}
+
+		if (i==SD_IO_TRY_CNT)
+			DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x val=0x%08x, try_cnt=%d\n", __func__, *err, addr, v, i);
+		else
+			DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x val=0x%08x, try_cnt=%d\n", __func__, *err, addr, v, i);
+	}
+
+_func_exit_;
+}
+
+/*
+ * Use CMD53 to read data from SDIO device.
+ * This function MUST be called after sdio_claim_host() or
+ * in SDIO ISR(host had been claimed).
+ *
+ * Parameters:
+ *	psdio	pointer of SDIO_DATA
+ *	addr	address to read
+ *	cnt		amount to read
+ *	pdata	pointer to put data, this should be a "DMA:able scratch buffer"!
+ *
+ * Return:
+ *	0		Success
+ *	others	Fail
+ */
+s32 _sd_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	int err= -EPERM;
+	struct sdio_func *func;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+	
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return err;
+	}
+		
+	func = psdio->func;
+
+	if (unlikely((cnt==1) || (cnt==2)))
+	{
+		int i;
+		u8 *pbuf = (u8*)pdata;
+
+		for (i = 0; i < cnt; i++)
+		{
+			*(pbuf+i) = sdio_readb(func, addr+i, &err);
+
+			if (err) {
+				DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x\n", __func__, err, addr);
+				break;
+			}
+		}
+		return err;
+	}
+
+	err = sdio_memcpy_fromio(func, pdata, addr, cnt);
+	if (err) {
+		DBG_871X(KERN_ERR "%s: FAIL(%d)! ADDR=%#x Size=%d\n", __func__, err, addr, cnt);
+	}
+
+_func_exit_;
+
+	return err;
+}
+
+/*
+ * Use CMD53 to read data from SDIO device.
+ *
+ * Parameters:
+ *	psdio	pointer of SDIO_DATA
+ *	addr	address to read
+ *	cnt		amount to read
+ *	pdata	pointer to put data, this should be a "DMA:able scratch buffer"!
+ *
+ * Return:
+ *	0		Success
+ *	others	Fail
+ */
+s32 sd_read(struct intf_hdl * pintfhdl, u32 addr, u32 cnt, void *pdata)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;	
+	
+	struct sdio_func *func;
+	bool claim_needed;
+	s32 err= -EPERM;
+	
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+	
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return err;
+	}
+	func = psdio->func;
+	claim_needed = rtw_sdio_claim_host_needed(func);
+
+	if (claim_needed)
+		sdio_claim_host(func);
+	err = _sd_read(pintfhdl, addr, cnt, pdata);
+	if (claim_needed)
+		sdio_release_host(func);
+_func_exit_;
+	return err;
+}
+
+/*
+ * Use CMD53 to write data to SDIO device.
+ * This function MUST be called after sdio_claim_host() or
+ * in SDIO ISR(host had been claimed).
+ *
+ * Parameters:
+ *	psdio	pointer of SDIO_DATA
+ *	addr	address to write
+ *	cnt		amount to write
+ *	pdata	data pointer, this should be a "DMA:able scratch buffer"!
+ *
+ * Return:
+ *	0		Success
+ *	others	Fail
+ */
+s32 _sd_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+	
+	struct sdio_func *func;
+	u32 size;
+	s32 err=-EPERM;
+
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+	
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return err;
+	}
+	
+	func = psdio->func;
+//	size = sdio_align_size(func, cnt);
+
+	if (unlikely((cnt==1) || (cnt==2)))
+	{
+		int i;
+		u8 *pbuf = (u8*)pdata;
+
+		for (i = 0; i < cnt; i++)
+		{
+			sdio_writeb(func, *(pbuf+i), addr+i, &err);
+			if (err) {
+				DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x val=0x%02x\n", __func__, err, addr, *(pbuf+i));
+				break;
+			}
+		}
+
+		return err;
+	}
+
+	size = cnt;
+	err = sdio_memcpy_toio(func, addr, pdata, size);
+	if (err) {
+		DBG_871X(KERN_ERR "%s: FAIL(%d)! ADDR=%#x Size=%d(%d)\n", __func__, err, addr, cnt, size);
+	}
+
+_func_exit_;
+
+	return err;
+}
+
+/*
+ * Use CMD53 to write data to SDIO device.
+ *
+ * Parameters:
+ *  psdio	pointer of SDIO_DATA
+ *  addr	address to write
+ *  cnt		amount to write
+ *  pdata	data pointer, this should be a "DMA:able scratch buffer"!
+ *
+ * Return:
+ *  0		Success
+ *  others	Fail
+ */
+s32 sd_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata)
+{
+	PADAPTER padapter;
+	struct dvobj_priv *psdiodev;
+	PSDIO_DATA psdio;
+
+	struct sdio_func *func;
+	bool claim_needed;
+	s32 err=-EPERM;
+_func_enter_;
+	padapter = pintfhdl->padapter;
+	psdiodev = pintfhdl->pintf_dev;
+	psdio = &psdiodev->intf_data;
+	
+	if (rtw_is_surprise_removed(padapter)) {
+		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
+		return err;
+	}
+	
+	func = psdio->func;
+	claim_needed = rtw_sdio_claim_host_needed(func);
+
+	if (claim_needed)
+		sdio_claim_host(func);
+	err = _sd_write(pintfhdl, addr, cnt, pdata);
+	if (claim_needed)
+		sdio_release_host(func);
+_func_exit_;
+	return err;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/wifi_regd.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/wifi_regd.c
new file mode 100644
index 000000000..72c1ff1d0
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/wifi_regd.c
@@ -0,0 +1,529 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2010  Realtek Corporation.
+ *
+ *****************************************************************************/
+
+#include <drv_types.h>
+
+#ifdef CONFIG_IOCTL_CFG80211
+
+#include <rtw_wifi_regd.h>
+
+static struct country_code_to_enum_rd allCountries[] = {
+	{COUNTRY_CODE_USER, "RD"},
+};
+
+/* 
+ * REG_RULE(freq start, freq end, bandwidth, max gain, eirp, reg_flags)
+ */
+
+/*
+ *Only these channels all allow active
+ *scan on all world regulatory domains
+ */
+
+/* 2G chan 01 - chan 11 */
+#define RTW_2GHZ_CH01_11	\
+	REG_RULE(2412-10, 2462+10, 40, 0, 20, 0)
+
+/*
+ *We enable active scan on these a case
+ *by case basis by regulatory domain
+ */
+
+/* 2G chan 12 - chan 13, PASSIV SCAN */
+#define RTW_2GHZ_CH12_13	\
+	REG_RULE(2467-10, 2472+10, 40, 0, 20,	\
+	NL80211_RRF_PASSIVE_SCAN)
+
+/* 2G chan 14, PASSIVS SCAN, NO OFDM (B only) */
+#define RTW_2GHZ_CH14	\
+	REG_RULE(2484-10, 2484+10, 40, 0, 20,	\
+	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_OFDM)
+
+/* 5G chan 36 - chan 64 */
+#define RTW_5GHZ_5150_5350	\
+	REG_RULE(5150-10, 5350+10, 40, 0, 30,	\
+	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+
+/* 5G chan 100 - chan 165 */
+#define RTW_5GHZ_5470_5850	\
+	REG_RULE(5470-10, 5850+10, 40, 0, 30, \
+	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+
+/* 5G chan 149 - chan 165 */
+#define RTW_5GHZ_5725_5850	\
+	REG_RULE(5725-10, 5850+10, 40, 0, 30, \
+	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+
+/* 5G chan 36 - chan 165 */
+#define RTW_5GHZ_5150_5850	\
+	REG_RULE(5150-10, 5850+10, 40, 0, 30,	\
+	NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+
+static const struct ieee80211_regdomain rtw_regdom_rd = {
+	.n_reg_rules = 3,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      RTW_2GHZ_CH12_13,
+		      RTW_5GHZ_5150_5850,
+		      }
+};
+
+static const struct ieee80211_regdomain rtw_regdom_11 = {
+	.n_reg_rules = 1,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      }
+};
+
+static const struct ieee80211_regdomain rtw_regdom_12_13 = {
+	.n_reg_rules = 2,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      RTW_2GHZ_CH12_13,
+		      }
+};
+
+static const struct ieee80211_regdomain rtw_regdom_no_midband = {
+	.n_reg_rules = 3,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      RTW_5GHZ_5150_5350,
+		      RTW_5GHZ_5725_5850,
+		      }
+};
+
+static const struct ieee80211_regdomain rtw_regdom_60_64 = {
+	.n_reg_rules = 3,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      RTW_2GHZ_CH12_13,
+		      RTW_5GHZ_5725_5850,
+		      }
+};
+
+static const struct ieee80211_regdomain rtw_regdom_14_60_64 = {
+	.n_reg_rules = 4,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      RTW_2GHZ_CH12_13,
+		      RTW_2GHZ_CH14,
+		      RTW_5GHZ_5725_5850,
+		      }
+};
+
+static const struct ieee80211_regdomain rtw_regdom_14 = {
+	.n_reg_rules = 3,
+	.alpha2 = "99",
+	.reg_rules = {
+		      RTW_2GHZ_CH01_11,
+		      RTW_2GHZ_CH12_13,
+		      RTW_2GHZ_CH14,
+		      }
+};
+
+#if 0
+static struct rtw_regulatory *rtw_regd;
+#endif
+
+static bool _rtw_is_radar_freq(u16 center_freq)
+{
+	return (center_freq >= 5260 && center_freq <= 5700);
+}
+
+#if 0 // not_yet
+static void _rtw_reg_apply_beaconing_flags(struct wiphy *wiphy,
+					   enum nl80211_reg_initiator initiator)
+{
+	enum ieee80211_band band;
+	struct ieee80211_supported_band *sband;
+	const struct ieee80211_reg_rule *reg_rule;
+	struct ieee80211_channel *ch;
+	unsigned int i;
+	u32 bandwidth = 0;
+	int r;
+
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+
+		if (!wiphy->bands[band])
+			continue;
+
+		sband = wiphy->bands[band];
+
+		for (i = 0; i < sband->n_channels; i++) {
+			ch = &sband->channels[i];
+			if (_rtw_is_radar_freq(ch->center_freq) ||
+			    (ch->flags & IEEE80211_CHAN_RADAR))
+				continue;
+			if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {
+				r = freq_reg_info(wiphy, ch->center_freq,
+						  bandwidth, &reg_rule);
+				if (r)
+					continue;
+
+				/*
+				 *If 11d had a rule for this channel ensure
+				 *we enable adhoc/beaconing if it allows us to
+				 *use it. Note that we would have disabled it
+				 *by applying our static world regdomain by
+				 *default during init, prior to calling our
+				 *regulatory_hint().
+				 */
+
+				if (!(reg_rule->flags & NL80211_RRF_NO_IBSS))
+					ch->flags &= ~IEEE80211_CHAN_NO_IBSS;
+				if (!
+				    (reg_rule->flags &
+				     NL80211_RRF_PASSIVE_SCAN))
+					ch->flags &=
+					    ~IEEE80211_CHAN_PASSIVE_SCAN;
+			} else {
+				if (ch->beacon_found)
+					ch->flags &= ~(IEEE80211_CHAN_NO_IBSS |
+						       IEEE80211_CHAN_PASSIVE_SCAN);
+			}
+		}
+	}
+}
+
+/* Allows active scan scan on Ch 12 and 13 */
+static void _rtw_reg_apply_active_scan_flags(struct wiphy *wiphy,
+					     enum nl80211_reg_initiator
+					     initiator)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	const struct ieee80211_reg_rule *reg_rule;
+	u32 bandwidth = 0;
+	int r;
+
+	if (!wiphy->bands[NL80211_BAND_2GHZ])
+		return;
+	sband = wiphy->bands[NL80211_BAND_2GHZ];
+
+	/*
+	 * If no country IE has been received always enable active scan
+	 * on these channels. This is only done for specific regulatory SKUs
+	 */
+	if (initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {
+		ch = &sband->channels[11];	/* CH 12 */
+		if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+			ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+		ch = &sband->channels[12];	/* CH 13 */
+		if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+			ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+		return;
+	}
+
+	/*
+	 * If a country IE has been received check its rule for this
+	 * channel first before enabling active scan. The passive scan
+	 * would have been enforced by the initial processing of our
+	 * custom regulatory domain.
+	 */
+
+	ch = &sband->channels[11];	/* CH 12 */
+	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
+	if (!r) {
+		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
+			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+	}
+
+	ch = &sband->channels[12];	/* CH 13 */
+	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
+	if (!r) {
+		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
+			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+	}
+}
+#endif
+
+/*
+ * Always apply Radar/DFS rules on
+ * freq range 5260 MHz - 5700 MHz
+ */
+static void _rtw_reg_apply_radar_flags(struct wiphy *wiphy)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	unsigned int i;
+
+	if (!wiphy->bands[NL80211_BAND_5GHZ])
+		return;
+
+	sband = wiphy->bands[NL80211_BAND_5GHZ];
+
+	for (i = 0; i < sband->n_channels; i++) {
+		ch = &sband->channels[i];
+		if (!_rtw_is_radar_freq(ch->center_freq))
+			continue;
+#ifdef CONFIG_DFS
+		#if defined(CONFIG_DFS_MASTER) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+		if (!(ch->flags & IEEE80211_CHAN_DISABLED)) {
+			ch->flags |= IEEE80211_CHAN_RADAR;
+			#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0))
+			ch->flags |= (IEEE80211_CHAN_NO_IBSS|IEEE80211_CHAN_PASSIVE_SCAN);
+			#else
+			ch->flags |= IEEE80211_CHAN_NO_IR;
+			#endif
+		}
+		#endif
+#endif //CONFIG_DFS
+
+#if 0
+		/*
+		 * We always enable radar detection/DFS on this
+		 * frequency range. Additionally we also apply on
+		 * this frequency range:
+		 * - If STA mode does not yet have DFS supports disable
+		 *  active scanning
+		 * - If adhoc mode does not support DFS yet then disable
+		 *  adhoc in the frequency.
+		 * - If AP mode does not yet support radar detection/DFS
+		 *  do not allow AP mode
+		 */
+		if (!(ch->flags & IEEE80211_CHAN_DISABLED))
+			ch->flags |= IEEE80211_CHAN_RADAR |
+			    IEEE80211_CHAN_NO_IBSS |
+			    IEEE80211_CHAN_PASSIVE_SCAN;
+#endif
+	}
+}
+
+static void _rtw_reg_apply_flags(struct wiphy *wiphy)
+{
+#if 1				// by channel plan
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+	u8 channel_plan = padapter->mlmepriv.ChannelPlan;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	RT_CHANNEL_INFO *channel_set = pmlmeext->channel_set;
+	u8 max_chan_nums = pmlmeext->max_chan_nums;
+
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	unsigned int i, j;
+	u16 channel;
+	u32 freq;
+
+	// all channels disable
+	for (i = 0; i < NUM_NL80211_BANDS; i++) {
+		sband = wiphy->bands[i];
+
+		if (sband) {
+			for (j = 0; j < sband->n_channels; j++) {
+				ch = &sband->channels[j];
+
+				if (ch)
+					ch->flags = IEEE80211_CHAN_DISABLED;
+			}
+		}
+	}
+
+	// channels apply by channel plans.
+	for (i = 0; i < max_chan_nums; i++) {
+		channel = channel_set[i].ChannelNum;
+		freq = rtw_ch2freq(channel);
+
+		ch = ieee80211_get_channel(wiphy, freq);
+		if (ch) {
+			if (channel_set[i].ScanType == SCAN_PASSIVE) {
+				#if defined(CONFIG_DFS_MASTER) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
+				ch->flags = 0;
+				#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
+				ch->flags = (IEEE80211_CHAN_NO_IBSS|IEEE80211_CHAN_PASSIVE_SCAN);
+				#else
+				ch->flags = IEEE80211_CHAN_NO_IR;
+				#endif
+			}
+			else {
+				ch->flags = 0;
+			}
+		}
+	}
+
+#else
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	unsigned int i, j;
+	u16 channels[37] =
+	    { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 36, 40, 44, 48, 52, 56,
+		60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140,
+		149, 153,
+		157, 161, 165
+	};
+	u16 channel;
+	u32 freq;
+
+	for (i = 0; i < NUM_NL80211_BANDS; i++) {
+		sband = wiphy->bands[i];
+
+		if (sband)
+			for (j = 0; j < sband->n_channels; j++) {
+				ch = &sband->channels[j];
+
+				if (ch)
+					ch->flags = IEEE80211_CHAN_DISABLED;
+			}
+	}
+
+	for (i = 0; i < 37; i++) {
+		channel = channels[i];
+		freq = rtw_ch2freq(channel);
+
+		ch = ieee80211_get_channel(wiphy, freq);
+		if (ch) {
+			if (channel <= 11)
+				ch->flags = 0;
+			else
+				ch->flags = 0;	//IEEE80211_CHAN_PASSIVE_SCAN;
+		}
+		//printk("%s: freq %d(%d) flag 0x%02X \n", __func__, freq, channel, ch->flags);
+	}
+#endif
+}
+
+static void _rtw_reg_apply_world_flags(struct wiphy *wiphy,
+				       enum nl80211_reg_initiator initiator,
+				       struct rtw_regulatory *reg)
+{
+	//_rtw_reg_apply_beaconing_flags(wiphy, initiator);
+	//_rtw_reg_apply_active_scan_flags(wiphy, initiator);
+	return;
+}
+
+static int _rtw_reg_notifier_apply(struct wiphy *wiphy,
+				   struct regulatory_request *request,
+				   struct rtw_regulatory *reg)
+{
+
+	/* Hard code flags */
+	_rtw_reg_apply_flags(wiphy);
+
+	/* We always apply this */
+	_rtw_reg_apply_radar_flags(wiphy);
+
+	switch (request->initiator) {
+	case NL80211_REGDOM_SET_BY_DRIVER:
+		DBG_8192C("%s: %s\n", __func__, "NL80211_REGDOM_SET_BY_DRIVER");
+		_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER,
+					   reg);
+		break;
+	case NL80211_REGDOM_SET_BY_CORE:
+		DBG_8192C("%s: %s\n", __func__,
+			  "NL80211_REGDOM_SET_BY_CORE to DRV");
+		_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER,
+					   reg);
+		break;
+	case NL80211_REGDOM_SET_BY_USER:
+		DBG_8192C("%s: %s\n", __func__,
+			  "NL80211_REGDOM_SET_BY_USER to DRV");
+		_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER,
+					   reg);
+		break;
+	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
+		DBG_8192C("%s: %s\n", __func__,
+			  "NL80211_REGDOM_SET_BY_COUNTRY_IE");
+		_rtw_reg_apply_world_flags(wiphy, request->initiator, reg);
+		break;
+	}
+
+	return 0;
+}
+
+static const struct ieee80211_regdomain *_rtw_regdomain_select(struct
+							       rtw_regulatory
+							       *reg)
+{
+#if 0
+	switch (reg->country_code) {
+	case COUNTRY_CODE_USER:
+	default:
+		return &rtw_regdom_rd;
+	}
+#else
+	return &rtw_regdom_rd;
+#endif
+}
+
+void _rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
+{
+	struct rtw_regulatory *reg = NULL;
+
+	DBG_8192C("%s\n", __func__);
+
+	_rtw_reg_notifier_apply(wiphy, request, reg);
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0))
+int rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
+#else
+void rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
+#endif
+{
+	_rtw_reg_notifier(wiphy, request);
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0))
+	return 0;
+	#endif
+}
+
+void rtw_reg_notify_by_driver(struct wiphy *wiphy)
+{
+	if (wiphy) {
+		struct regulatory_request request;
+		request.initiator = NL80211_REGDOM_SET_BY_DRIVER;
+		rtw_reg_notifier(wiphy, &request);
+	}
+}
+
+static void _rtw_regd_init_wiphy(struct rtw_regulatory *reg, struct wiphy *wiphy)
+{
+	const struct ieee80211_regdomain *regd;
+
+	wiphy->reg_notifier = rtw_reg_notifier;
+
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0))
+	wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
+	wiphy->flags &= ~WIPHY_FLAG_STRICT_REGULATORY;
+	wiphy->flags &= ~WIPHY_FLAG_DISABLE_BEACON_HINTS;
+	#else
+	wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
+	wiphy->regulatory_flags &= ~REGULATORY_STRICT_REG;
+	wiphy->regulatory_flags &= ~REGULATORY_DISABLE_BEACON_HINTS;
+	#endif
+	
+	regd = _rtw_regdomain_select(reg);
+	wiphy_apply_custom_regulatory(wiphy, regd);
+
+	/* Hard code flags */
+	_rtw_reg_apply_flags(wiphy);
+	_rtw_reg_apply_radar_flags(wiphy);
+	_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
+}
+
+static struct country_code_to_enum_rd *_rtw_regd_find_country(u16 countrycode)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(allCountries); i++) {
+		if (allCountries[i].countrycode == countrycode)
+			return &allCountries[i];
+	}
+	return NULL;
+}
+
+void rtw_regd_init(struct wiphy *wiphy)
+{
+	_rtw_regd_init_wiphy(NULL, wiphy);
+}
+#endif //CONFIG_IOCTL_CFG80211
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/xmit_linux.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/xmit_linux.c
new file mode 100644
index 000000000..129269948
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/linux/xmit_linux.c
@@ -0,0 +1,546 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _XMIT_OSDEP_C_
+
+#include <drv_types.h>
+
+#define DBG_DUMP_OS_QUEUE_CTL 0
+
+uint rtw_remainder_len(struct pkt_file *pfile)
+{
+	return (pfile->buf_len - ((SIZE_PTR)(pfile->cur_addr) - (SIZE_PTR)(pfile->buf_start)));
+}
+
+void _rtw_open_pktfile (_pkt *pktptr, struct pkt_file *pfile)
+{
+_func_enter_;
+
+	pfile->pkt = pktptr;
+	pfile->cur_addr = pfile->buf_start = pktptr->data;
+	pfile->pkt_len = pfile->buf_len = pktptr->len;
+
+	pfile->cur_buffer = pfile->buf_start ;
+	
+_func_exit_;
+}
+
+uint _rtw_pktfile_read (struct pkt_file *pfile, u8 *rmem, uint rlen)
+{	
+	uint	len = 0;
+	
+_func_enter_;
+
+       len =  rtw_remainder_len(pfile);
+      	len = (rlen > len)? len: rlen;
+
+       if(rmem)
+	  skb_copy_bits(pfile->pkt, pfile->buf_len-pfile->pkt_len, rmem, len);
+
+       pfile->cur_addr += len;
+       pfile->pkt_len -= len;
+	   
+_func_exit_;	       		
+
+	return len;	
+}
+
+sint rtw_endofpktfile(struct pkt_file *pfile)
+{
+_func_enter_;
+
+	if (pfile->pkt_len == 0) {
+_func_exit_;
+		return _TRUE;
+	}
+
+_func_exit_;
+
+	return _FALSE;
+}
+
+void rtw_set_tx_chksum_offload(_pkt *pkt, struct pkt_attrib *pattrib)
+{
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	struct sk_buff *skb = (struct sk_buff *)pkt;
+	pattrib->hw_tcp_csum = 0;
+	
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		if (skb_shinfo(skb)->nr_frags == 0)
+		{	
+                        const struct iphdr *ip = ip_hdr(skb);
+                        if (ip->protocol == IPPROTO_TCP) {
+                                // TCP checksum offload by HW
+                                DBG_871X("CHECKSUM_PARTIAL TCP\n");
+                                pattrib->hw_tcp_csum = 1;
+                                //skb_checksum_help(skb);
+                        } else if (ip->protocol == IPPROTO_UDP) {
+                                //DBG_871X("CHECKSUM_PARTIAL UDP\n");
+#if 1                       
+                                skb_checksum_help(skb);
+#else
+                                // Set UDP checksum = 0 to skip checksum check
+                                struct udphdr *udp = skb_transport_header(skb);
+                                udp->check = 0;
+#endif
+                        } else {
+				DBG_871X("%s-%d TCP CSUM offload Error!!\n", __FUNCTION__, __LINE__);
+                                WARN_ON(1);     /* we need a WARN() */
+			    }
+		}
+		else { // IP fragmentation case
+			DBG_871X("%s-%d nr_frags != 0, using skb_checksum_help(skb);!!\n", __FUNCTION__, __LINE__);
+                	skb_checksum_help(skb);
+		}		
+	}
+#endif	
+	
+}
+
+int rtw_os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf, u32 alloc_sz, u8 flag)
+{
+	if (alloc_sz > 0) {
+#ifdef CONFIG_USE_USB_BUFFER_ALLOC_TX
+		struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
+		struct usb_device	*pusbd = pdvobjpriv->pusbdev;
+
+		pxmitbuf->pallocated_buf = rtw_usb_buffer_alloc(pusbd, (size_t)alloc_sz, &pxmitbuf->dma_transfer_addr);
+		pxmitbuf->pbuf = pxmitbuf->pallocated_buf;
+		if(pxmitbuf->pallocated_buf == NULL)
+			return _FAIL;
+#else // CONFIG_USE_USB_BUFFER_ALLOC_TX
+		
+		pxmitbuf->pallocated_buf = rtw_zmalloc(alloc_sz);
+		if (pxmitbuf->pallocated_buf == NULL)
+		{
+			return _FAIL;
+		}
+
+		pxmitbuf->pbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitbuf->pallocated_buf), XMITBUF_ALIGN_SZ);
+
+#endif // CONFIG_USE_USB_BUFFER_ALLOC_TX
+	}
+
+	if (flag) {
+#ifdef CONFIG_USB_HCI
+		int i;
+		for(i=0; i<8; i++)
+	      	{
+	      		pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
+	             if(pxmitbuf->pxmit_urb[i] == NULL) 
+	             {
+	             	DBG_871X("pxmitbuf->pxmit_urb[i]==NULL");
+		       	return _FAIL;	 
+	             }
+	      	}
+#endif
+	}
+
+	return _SUCCESS;	
+}
+
+void rtw_os_xmit_resource_free(_adapter *padapter, struct xmit_buf *pxmitbuf,u32 free_sz, u8 flag)
+{
+	if (flag) {
+#ifdef CONFIG_USB_HCI
+		int i;
+
+		for(i=0; i<8; i++)
+		{
+			if(pxmitbuf->pxmit_urb[i])
+			{
+				//usb_kill_urb(pxmitbuf->pxmit_urb[i]);
+				usb_free_urb(pxmitbuf->pxmit_urb[i]);
+			}
+		}
+#endif
+	}
+
+	if (free_sz > 0 ) {
+#ifdef CONFIG_USE_USB_BUFFER_ALLOC_TX
+		struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
+		struct usb_device	*pusbd = pdvobjpriv->pusbdev;
+
+		rtw_usb_buffer_free(pusbd, (size_t)free_sz, pxmitbuf->pallocated_buf, pxmitbuf->dma_transfer_addr);
+		pxmitbuf->pallocated_buf =  NULL;
+		pxmitbuf->dma_transfer_addr = 0;
+#else	// CONFIG_USE_USB_BUFFER_ALLOC_TX
+		if(pxmitbuf->pallocated_buf)
+			rtw_mfree(pxmitbuf->pallocated_buf, free_sz);
+#endif	// CONFIG_USE_USB_BUFFER_ALLOC_TX
+	}
+}
+
+void dump_os_queue(void *sel, _adapter *padapter)
+{
+	struct net_device *ndev = padapter->pnetdev;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	int i;
+
+	for (i=0;i<4;i++) {
+		DBG_871X_SEL_NL(sel, "os_queue[%d]:%s\n"
+			, i, __netif_subqueue_stopped(ndev, i)?"stopped":"waked");
+	}
+#else
+	DBG_871X_SEL_NL(sel, "os_queue:%s\n"
+			, netif_queue_stopped(ndev)?"stopped":"waked");
+#endif
+}
+
+#define WMM_XMIT_THRESHOLD	(NR_XMITFRAME*2/5)
+
+inline static bool rtw_os_need_wake_queue(_adapter *padapter, u16 qidx)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	if (padapter->registrypriv.wifi_spec) {
+		if (pxmitpriv->hwxmits[qidx].accnt < WMM_XMIT_THRESHOLD)
+			return _TRUE;
+	} else {
+		return _TRUE;
+	}
+	return _FALSE;
+#else
+	return _TRUE;
+#endif
+}
+
+inline static bool rtw_os_need_stop_queue(_adapter *padapter, u16 qidx)
+{
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	if (padapter->registrypriv.wifi_spec) {
+		/* No free space for Tx, tx_worker is too slow */
+		if (pxmitpriv->hwxmits[qidx].accnt > WMM_XMIT_THRESHOLD)
+			return _TRUE;
+	} else {
+		if(pxmitpriv->free_xmitframe_cnt<=4)
+			return _TRUE;
+	}
+#else
+	if(pxmitpriv->free_xmitframe_cnt<=4)
+		return _TRUE;
+#endif
+	return _FALSE;
+}
+
+void rtw_os_pkt_complete(_adapter *padapter, _pkt *pkt)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	u16	qidx;
+
+	qidx = skb_get_queue_mapping(pkt);
+	if (rtw_os_need_wake_queue(padapter, qidx)) {
+		if (DBG_DUMP_OS_QUEUE_CTL)
+			DBG_871X(FUNC_ADPT_FMT": netif_wake_subqueue[%d]\n", FUNC_ADPT_ARG(padapter), qidx);
+		netif_wake_subqueue(padapter->pnetdev, qidx);
+	}
+#else
+	if (rtw_os_need_wake_queue(padapter, 0)) {
+		if (DBG_DUMP_OS_QUEUE_CTL)
+			DBG_871X(FUNC_ADPT_FMT": netif_wake_queue\n", FUNC_ADPT_ARG(padapter));
+		netif_wake_queue(padapter->pnetdev);
+	}
+#endif
+
+	rtw_skb_free(pkt);
+}
+
+void rtw_os_xmit_complete(_adapter *padapter, struct xmit_frame *pxframe)
+{
+	if(pxframe->pkt)
+		rtw_os_pkt_complete(padapter, pxframe->pkt);
+
+	pxframe->pkt = NULL;
+}
+
+void rtw_os_xmit_schedule(_adapter *padapter)
+{
+	_adapter *pri_adapter = padapter;
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+	if(!padapter)
+		return;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if(padapter->adapter_type > PRIMARY_ADAPTER)
+		pri_adapter = padapter->pbuddy_adapter;
+#endif
+
+	if (_rtw_queue_empty(&padapter->xmitpriv.pending_xmitbuf_queue) == _FALSE)
+		_rtw_up_sema(&pri_adapter->xmitpriv.xmit_sema);
+
+
+#else
+	_irqL  irqL;
+	struct xmit_priv *pxmitpriv;
+
+	if(!padapter)
+		return;
+
+	pxmitpriv = &padapter->xmitpriv;
+
+	_enter_critical_bh(&pxmitpriv->lock, &irqL);
+
+	if(rtw_txframes_pending(padapter))	
+	{
+		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+	}
+
+	_exit_critical_bh(&pxmitpriv->lock, &irqL);
+#endif
+}
+
+static bool rtw_check_xmit_resource(_adapter *padapter, _pkt *pkt)
+{
+	bool busy = _FALSE;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	u16	qidx;
+
+	qidx = skb_get_queue_mapping(pkt);
+	if (rtw_os_need_stop_queue(padapter, qidx)) {
+		if (DBG_DUMP_OS_QUEUE_CTL)
+			DBG_871X(FUNC_ADPT_FMT": netif_stop_subqueue[%d]\n", FUNC_ADPT_ARG(padapter), qidx);
+		netif_stop_subqueue(padapter->pnetdev, qidx);
+		busy = _TRUE;
+	}
+#else
+	if (rtw_os_need_stop_queue(padapter, 0)) {
+		if (DBG_DUMP_OS_QUEUE_CTL)
+			DBG_871X(FUNC_ADPT_FMT": netif_stop_queue\n", FUNC_ADPT_ARG(padapter));
+		rtw_netif_stop_queue(padapter->pnetdev);
+		busy = _TRUE;
+	}
+#endif
+	return busy;
+}
+
+void rtw_os_wake_queue_at_free_stainfo(_adapter *padapter, int *qcnt_freed)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	int i;
+
+	for (i=0;i<4;i++) {
+		if (qcnt_freed[i] == 0)
+			continue;
+
+		if(rtw_os_need_wake_queue(padapter, i)) {
+			if (DBG_DUMP_OS_QUEUE_CTL)
+				DBG_871X(FUNC_ADPT_FMT": netif_wake_subqueue[%d]\n", FUNC_ADPT_ARG(padapter), i);
+			netif_wake_subqueue(padapter->pnetdev, i);
+		}
+	}
+#else
+	if (qcnt_freed[0] || qcnt_freed[1] || qcnt_freed[2] || qcnt_freed[3]) {
+		if(rtw_os_need_wake_queue(padapter, 0)) {
+			if (DBG_DUMP_OS_QUEUE_CTL)
+				DBG_871X(FUNC_ADPT_FMT": netif_wake_queue\n", FUNC_ADPT_ARG(padapter));
+			netif_wake_queue(padapter->pnetdev);
+		}
+	}
+#endif
+}
+
+#ifdef CONFIG_TX_MCAST2UNI
+int rtw_mlcst2unicst(_adapter *padapter, struct sk_buff *skb)
+{
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	_irqL	irqL;
+	_list	*phead, *plist;
+	struct sk_buff *newskb;
+	struct sta_info *psta = NULL;
+	u8 chk_alive_num = 0;
+	char chk_alive_list[NUM_STA];
+	u8 bc_addr[6]={0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	u8 null_addr[6]={0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	int i;
+	s32	res;
+
+	DBG_COUNTER(padapter->tx_logs.os_tx_m2u);
+
+	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	phead = &pstapriv->asoc_list;
+	plist = get_next(phead);
+	
+	//free sta asoc_queue
+	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE) {
+		int stainfo_offset;
+		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
+		plist = get_next(plist);
+
+		stainfo_offset = rtw_stainfo_offset(pstapriv, psta);
+		if (stainfo_offset_valid(stainfo_offset)) {
+			chk_alive_list[chk_alive_num++] = stainfo_offset;
+		}
+	}
+	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+
+	for (i = 0; i < chk_alive_num; i++) {
+		psta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);
+		if(!(psta->state &_FW_LINKED))
+		{
+			DBG_COUNTER(padapter->tx_logs.os_tx_m2u_ignore_fw_linked);
+			continue;		
+		}
+		
+		/* avoid come from STA1 and send back STA1 */ 
+		if (_rtw_memcmp(psta->hwaddr, &skb->data[6], 6) == _TRUE
+			|| _rtw_memcmp(psta->hwaddr, null_addr, 6) == _TRUE
+			|| _rtw_memcmp(psta->hwaddr, bc_addr, 6) == _TRUE
+		)
+		{
+			DBG_COUNTER(padapter->tx_logs.os_tx_m2u_ignore_self);
+			continue;
+		}
+
+		DBG_COUNTER(padapter->tx_logs.os_tx_m2u_entry);
+
+		newskb = rtw_skb_copy(skb);
+
+		if (newskb) {
+			_rtw_memcpy(newskb->data, psta->hwaddr, 6);
+			res = rtw_xmit(padapter, &newskb);
+			if (res < 0) {
+				DBG_COUNTER(padapter->tx_logs.os_tx_m2u_entry_err_xmit);
+				DBG_871X("%s()-%d: rtw_xmit() return error! res=%d\n", __FUNCTION__, __LINE__, res);
+				pxmitpriv->tx_drop++;
+				rtw_skb_free(newskb);
+			}
+		} else {
+			DBG_COUNTER(padapter->tx_logs.os_tx_m2u_entry_err_skb);
+			DBG_871X("%s-%d: rtw_skb_copy() failed!\n", __FUNCTION__, __LINE__);
+			pxmitpriv->tx_drop++;
+			//rtw_skb_free(skb);
+			return _FALSE;	// Caller shall tx this multicast frame via normal way.
+		}
+	}
+
+	rtw_skb_free(skb);
+	return _TRUE;
+}
+#endif	// CONFIG_TX_MCAST2UNI
+
+
+int _rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+#ifdef CONFIG_TX_MCAST2UNI
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	extern int rtw_mc2u_disable;
+#endif	// CONFIG_TX_MCAST2UNI	
+	s32 res = 0;
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	u16 queue;
+#endif
+
+_func_enter_;
+
+	if(padapter->registrypriv.mp_mode)
+	{
+		DBG_871X("MP_TX_DROP_OS_FRAME\n");
+		goto drop_packet;
+	}
+	DBG_COUNTER(padapter->tx_logs.os_tx);
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("+xmit_enry\n"));
+
+	if (rtw_if_up(padapter) == _FALSE) {
+		DBG_COUNTER(padapter->tx_logs.os_tx_err_up);
+		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit_entry: rtw_if_up fail\n"));
+		#ifdef DBG_TX_DROP_FRAME
+		DBG_871X("DBG_TX_DROP_FRAME %s if_up fail\n", __FUNCTION__);
+		#endif
+		goto drop_packet;
+	}
+
+	rtw_check_xmit_resource(padapter, pkt);
+
+#ifdef CONFIG_TX_MCAST2UNI
+	if ( !rtw_mc2u_disable
+		&& check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE
+		&& ( IP_MCAST_MAC(pkt->data)
+			|| ICMPV6_MCAST_MAC(pkt->data)
+			#ifdef CONFIG_TX_BCAST2UNI
+			|| is_broadcast_mac_addr(pkt->data)
+			#endif
+			)
+		&& (padapter->registrypriv.wifi_spec == 0)
+		)
+	{
+		if ( pxmitpriv->free_xmitframe_cnt > (NR_XMITFRAME/4) ) {
+			res = rtw_mlcst2unicst(padapter, pkt);
+			if (res == _TRUE) {
+				goto exit;
+			}
+		} else {
+			//DBG_871X("Stop M2U(%d, %d)! ", pxmitpriv->free_xmitframe_cnt, pxmitpriv->free_xmitbuf_cnt);
+			//DBG_871X("!m2u );
+			DBG_COUNTER(padapter->tx_logs.os_tx_m2u_stop);
+		}
+	}	
+#endif	// CONFIG_TX_MCAST2UNI	
+
+	res = rtw_xmit(padapter, &pkt);
+	if (res < 0) {
+		#ifdef DBG_TX_DROP_FRAME
+		DBG_871X("DBG_TX_DROP_FRAME %s rtw_xmit fail\n", __FUNCTION__);
+		#endif
+		goto drop_packet;
+	}
+
+	RT_TRACE(_module_xmit_osdep_c_, _drv_info_, ("rtw_xmit_entry: tx_pkts=%d\n", (u32)pxmitpriv->tx_pkts));
+	goto exit;
+
+drop_packet:
+	pxmitpriv->tx_drop++;
+	rtw_os_pkt_complete(padapter, pkt);
+	RT_TRACE(_module_xmit_osdep_c_, _drv_notice_, ("rtw_xmit_entry: drop, tx_drop=%d\n", (u32)pxmitpriv->tx_drop));
+
+exit:
+
+_func_exit_;
+
+	return 0;
+}
+
+int rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev)
+{
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	int ret = 0;
+
+	if (pkt) {
+		if (check_fwstate(pmlmepriv, WIFI_MONITOR_STATE) == _TRUE) {
+			rtw_monitor_xmit_entry((struct sk_buff *)pkt, pnetdev);
+		} else {
+			rtw_mstat_update(MSTAT_TYPE_SKB, MSTAT_ALLOC_SUCCESS, pkt->truesize);
+			ret = _rtw_xmit_entry(pkt, pnetdev);
+		}
+
+	}
+
+	return ret;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/os_dep/osdep_service.c b/drivers/net/wireless/realtek/rtl8723cs/os_dep/osdep_service.c
new file mode 100644
index 000000000..355a836ca
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/os_dep/osdep_service.c
@@ -0,0 +1,2491 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#define _OSDEP_SERVICE_C_
+
+#include <drv_types.h>
+
+#define RT_TAG	'1178'
+
+#ifdef DBG_MEMORY_LEAK
+#ifdef PLATFORM_LINUX
+atomic_t _malloc_cnt = ATOMIC_INIT(0);
+atomic_t _malloc_size = ATOMIC_INIT(0);
+#endif
+#endif /* DBG_MEMORY_LEAK */
+
+
+#if defined(PLATFORM_LINUX)
+/*
+* Translate the OS dependent @param error_code to OS independent RTW_STATUS_CODE
+* @return: one of RTW_STATUS_CODE
+*/
+inline int RTW_STATUS_CODE(int error_code){
+	if(error_code >=0)
+		return _SUCCESS;
+
+	switch(error_code) {
+		//case -ETIMEDOUT:
+		//	return RTW_STATUS_TIMEDOUT;
+		default:
+			return _FAIL;
+	}
+}
+#else
+inline int RTW_STATUS_CODE(int error_code){
+	return error_code;
+}
+#endif
+
+u32 rtw_atoi(u8* s)
+{
+
+	int num=0,flag=0;
+	int i;
+	for(i=0;i<=strlen(s);i++)
+	{
+	  if(s[i] >= '0' && s[i] <= '9')
+		 num = num * 10 + s[i] -'0';
+	  else if(s[0] == '-' && i==0) 
+		 flag =1;
+	  else 
+		  break;
+	 }
+
+	if(flag == 1)
+	   num = num * -1;
+
+	 return(num); 
+
+}
+
+inline u8* _rtw_vmalloc(u32 sz)
+{
+	u8 	*pbuf;
+#ifdef PLATFORM_LINUX	
+	pbuf = vmalloc(sz);
+#endif	
+#ifdef PLATFORM_FREEBSD
+	pbuf = malloc(sz,M_DEVBUF,M_NOWAIT);	
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);	
+#endif
+
+#ifdef DBG_MEMORY_LEAK
+#ifdef PLATFORM_LINUX
+	if ( pbuf != NULL) {
+		atomic_inc(&_malloc_cnt);
+		atomic_add(sz, &_malloc_size);
+	}
+#endif
+#endif /* DBG_MEMORY_LEAK */
+
+	return pbuf;	
+}
+
+inline u8* _rtw_zvmalloc(u32 sz)
+{
+	u8 	*pbuf;
+#ifdef PLATFORM_LINUX
+	pbuf = _rtw_vmalloc(sz);
+	if (pbuf != NULL)
+		memset(pbuf, 0, sz);
+#endif	
+#ifdef PLATFORM_FREEBSD
+	pbuf = malloc(sz,M_DEVBUF,M_ZERO|M_NOWAIT);	
+#endif	
+#ifdef PLATFORM_WINDOWS
+	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);
+	if (pbuf != NULL)
+		NdisFillMemory(pbuf, sz, 0);
+#endif
+
+	return pbuf;	
+}
+
+inline void _rtw_vmfree(u8 *pbuf, u32 sz)
+{
+#ifdef	PLATFORM_LINUX
+	vfree(pbuf);
+#endif	
+#ifdef PLATFORM_FREEBSD
+	free(pbuf,M_DEVBUF);	
+#endif	
+#ifdef PLATFORM_WINDOWS
+	NdisFreeMemory(pbuf,sz, 0);
+#endif
+
+#ifdef DBG_MEMORY_LEAK
+#ifdef PLATFORM_LINUX
+	atomic_dec(&_malloc_cnt);
+	atomic_sub(sz, &_malloc_size);
+#endif
+#endif /* DBG_MEMORY_LEAK */
+}
+
+u8* _rtw_malloc(u32 sz)
+{
+
+	u8 	*pbuf=NULL;
+
+#ifdef PLATFORM_LINUX
+#ifdef RTK_DMP_PLATFORM
+	if(sz > 0x4000)
+		pbuf = (u8 *)dvr_malloc(sz);
+	else
+#endif		
+		pbuf = kmalloc(sz,in_interrupt() ? GFP_ATOMIC : GFP_KERNEL); 		
+
+#endif	
+#ifdef PLATFORM_FREEBSD
+	pbuf = malloc(sz,M_DEVBUF,M_NOWAIT);	
+#endif		
+#ifdef PLATFORM_WINDOWS
+
+	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);
+
+#endif
+
+#ifdef DBG_MEMORY_LEAK
+#ifdef PLATFORM_LINUX
+	if ( pbuf != NULL) {
+		atomic_inc(&_malloc_cnt);
+		atomic_add(sz, &_malloc_size);
+	}
+#endif
+#endif /* DBG_MEMORY_LEAK */
+
+	return pbuf;	
+	
+}
+
+
+u8* _rtw_zmalloc(u32 sz)
+{
+#ifdef PLATFORM_FREEBSD
+	return malloc(sz,M_DEVBUF,M_ZERO|M_NOWAIT);
+#else // PLATFORM_FREEBSD
+	u8 	*pbuf = _rtw_malloc(sz);
+
+	if (pbuf != NULL) {
+
+#ifdef PLATFORM_LINUX
+		memset(pbuf, 0, sz);
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+		NdisFillMemory(pbuf, sz, 0);
+#endif
+
+	}
+
+	return pbuf;	
+#endif // PLATFORM_FREEBSD
+}
+
+void	_rtw_mfree(u8 *pbuf, u32 sz)
+{
+
+#ifdef	PLATFORM_LINUX
+#ifdef RTK_DMP_PLATFORM
+	if(sz > 0x4000)
+		dvr_free(pbuf);
+	else
+#endif
+		kfree(pbuf);
+
+#endif	
+#ifdef PLATFORM_FREEBSD
+	free(pbuf,M_DEVBUF);	
+#endif		
+#ifdef PLATFORM_WINDOWS
+
+	NdisFreeMemory(pbuf,sz, 0);
+
+#endif
+	
+#ifdef DBG_MEMORY_LEAK
+#ifdef PLATFORM_LINUX
+	atomic_dec(&_malloc_cnt);
+	atomic_sub(sz, &_malloc_size);
+#endif
+#endif /* DBG_MEMORY_LEAK */
+	
+}
+
+#ifdef PLATFORM_FREEBSD
+//review again
+struct sk_buff * dev_alloc_skb(unsigned int size)
+{
+	struct sk_buff *skb=NULL;
+    	u8 *data=NULL;
+	
+	//skb = (struct sk_buff *)_rtw_zmalloc(sizeof(struct sk_buff)); // for skb->len, etc.
+	skb = (struct sk_buff *)_rtw_malloc(sizeof(struct sk_buff));
+	if(!skb)
+		goto out;
+	data = _rtw_malloc(size);
+	if(!data)
+		goto nodata;
+
+	skb->head = (unsigned char*)data;
+	skb->data = (unsigned char*)data;
+	skb->tail = (unsigned char*)data;
+	skb->end = (unsigned char*)data + size;
+	skb->len = 0;
+	//printf("%s()-%d: skb=%p, skb->head = %p\n", __FUNCTION__, __LINE__, skb, skb->head);
+
+out:
+	return skb;
+nodata:
+	_rtw_mfree((u8 *)skb, sizeof(struct sk_buff));
+	skb = NULL;
+goto out;
+	
+}
+
+void dev_kfree_skb_any(struct sk_buff *skb)
+{
+	//printf("%s()-%d: skb->head = %p\n", __FUNCTION__, __LINE__, skb->head);
+	if(skb->head)
+		_rtw_mfree(skb->head, 0);
+	//printf("%s()-%d: skb = %p\n", __FUNCTION__, __LINE__, skb);
+	if(skb)
+		_rtw_mfree((u8 *)skb, 0);
+}
+struct sk_buff *skb_clone(const struct sk_buff *skb)
+{
+	return NULL;
+}
+
+#endif /* PLATFORM_FREEBSD */
+
+inline struct sk_buff *_rtw_skb_alloc(u32 sz)
+{
+#ifdef PLATFORM_LINUX
+	return __dev_alloc_skb(sz, in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+#endif /* PLATFORM_LINUX */
+
+#ifdef PLATFORM_FREEBSD
+	return dev_alloc_skb(sz);
+#endif /* PLATFORM_FREEBSD */
+}
+
+inline void _rtw_skb_free(struct sk_buff *skb)
+{
+	dev_kfree_skb_any(skb);
+}
+
+inline struct sk_buff *_rtw_skb_copy(const struct sk_buff *skb)
+{
+#ifdef PLATFORM_LINUX
+	return skb_copy(skb, in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+#endif /* PLATFORM_LINUX */
+
+#ifdef PLATFORM_FREEBSD
+	return NULL;
+#endif /* PLATFORM_FREEBSD */
+}
+
+inline struct sk_buff *_rtw_skb_clone(struct sk_buff *skb)
+{
+#ifdef PLATFORM_LINUX
+	return skb_clone(skb, in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+#endif /* PLATFORM_LINUX */
+
+#ifdef PLATFORM_FREEBSD
+	return skb_clone(skb);
+#endif /* PLATFORM_FREEBSD */
+}
+
+inline int _rtw_netif_rx(_nic_hdl ndev, struct sk_buff *skb)
+{
+#ifdef PLATFORM_LINUX
+	skb->dev = ndev;
+	return netif_rx(skb);
+#endif /* PLATFORM_LINUX */
+
+#ifdef PLATFORM_FREEBSD
+	return (*ndev->if_input)(ndev, skb);
+#endif /* PLATFORM_FREEBSD */
+}
+
+void _rtw_skb_queue_purge(struct sk_buff_head *list)
+{
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(list)) != NULL)
+		_rtw_skb_free(skb);
+}
+
+#ifdef CONFIG_USB_HCI
+inline void *_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_addr_t *dma)
+{
+#ifdef PLATFORM_LINUX
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	return usb_alloc_coherent(dev, size, (in_interrupt() ? GFP_ATOMIC : GFP_KERNEL), dma);
+#else
+	return usb_buffer_alloc(dev, size, (in_interrupt() ? GFP_ATOMIC : GFP_KERNEL), dma);
+#endif
+#endif /* PLATFORM_LINUX */
+	
+#ifdef PLATFORM_FREEBSD
+	return (malloc(size, M_USBDEV, M_NOWAIT | M_ZERO));
+#endif /* PLATFORM_FREEBSD */
+}
+inline void _rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr, dma_addr_t dma)
+{
+#ifdef PLATFORM_LINUX
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	usb_free_coherent(dev, size, addr, dma); 
+#else
+	usb_buffer_free(dev, size, addr, dma);
+#endif
+#endif /* PLATFORM_LINUX */
+
+#ifdef PLATFORM_FREEBSD
+	free(addr, M_USBDEV);
+#endif /* PLATFORM_FREEBSD */
+}
+#endif /* CONFIG_USB_HCI */
+
+#if defined(DBG_MEM_ALLOC)
+
+struct rtw_mem_stat {
+	ATOMIC_T alloc; // the memory bytes we allocate currently
+	ATOMIC_T peak; // the peak memory bytes we allocate 
+	ATOMIC_T alloc_cnt; // the alloc count for alloc currently
+	ATOMIC_T alloc_err_cnt; // the error times we fail to allocate memory
+};
+
+struct rtw_mem_stat rtw_mem_type_stat[mstat_tf_idx(MSTAT_TYPE_MAX)];
+#ifdef RTW_MEM_FUNC_STAT
+struct rtw_mem_stat rtw_mem_func_stat[mstat_ff_idx(MSTAT_FUNC_MAX)];
+#endif
+
+char *MSTAT_TYPE_str[] = {
+	"VIR",
+	"PHY",
+	"SKB",
+	"USB",
+};
+
+#ifdef RTW_MEM_FUNC_STAT
+char *MSTAT_FUNC_str[] = {
+	"UNSP",
+	"IO",
+	"TXIO",
+	"RXIO",
+	"TX",
+	"RX",
+};
+#endif
+
+void rtw_mstat_dump(void *sel)
+{
+	int i;
+	int value_t[4][mstat_tf_idx(MSTAT_TYPE_MAX)];
+#ifdef RTW_MEM_FUNC_STAT
+	int value_f[4][mstat_ff_idx(MSTAT_FUNC_MAX)];
+#endif
+	
+	int vir_alloc, vir_peak, vir_alloc_err, phy_alloc, phy_peak, phy_alloc_err;
+	int tx_alloc, tx_peak, tx_alloc_err, rx_alloc, rx_peak, rx_alloc_err;
+
+	for(i=0;i<mstat_tf_idx(MSTAT_TYPE_MAX);i++) {
+		value_t[0][i] = ATOMIC_READ(&(rtw_mem_type_stat[i].alloc));
+		value_t[1][i] = ATOMIC_READ(&(rtw_mem_type_stat[i].peak));
+		value_t[2][i] = ATOMIC_READ(&(rtw_mem_type_stat[i].alloc_cnt));
+		value_t[3][i] = ATOMIC_READ(&(rtw_mem_type_stat[i].alloc_err_cnt));
+	}
+
+	#ifdef RTW_MEM_FUNC_STAT
+	for(i=0;i<mstat_ff_idx(MSTAT_FUNC_MAX);i++) {
+		value_f[0][i] = ATOMIC_READ(&(rtw_mem_func_stat[i].alloc));
+		value_f[1][i] = ATOMIC_READ(&(rtw_mem_func_stat[i].peak));
+		value_f[2][i] = ATOMIC_READ(&(rtw_mem_func_stat[i].alloc_cnt));
+		value_f[3][i] = ATOMIC_READ(&(rtw_mem_func_stat[i].alloc_err_cnt));
+	}
+	#endif
+
+	DBG_871X_SEL_NL(sel, "===================== MSTAT =====================\n");
+	DBG_871X_SEL_NL(sel, "%4s %10s %10s %10s %10s\n", "TAG", "alloc", "peak", "aloc_cnt", "err_cnt");
+	DBG_871X_SEL_NL(sel, "-------------------------------------------------\n");
+	for(i=0;i<mstat_tf_idx(MSTAT_TYPE_MAX);i++) {
+		DBG_871X_SEL_NL(sel, "%4s %10d %10d %10d %10d\n", MSTAT_TYPE_str[i], value_t[0][i], value_t[1][i], value_t[2][i], value_t[3][i]);
+	}
+	#ifdef RTW_MEM_FUNC_STAT
+	DBG_871X_SEL_NL(sel, "-------------------------------------------------\n");
+	for(i=0;i<mstat_ff_idx(MSTAT_FUNC_MAX);i++) {
+		DBG_871X_SEL_NL(sel, "%4s %10d %10d %10d %10d\n", MSTAT_FUNC_str[i], value_f[0][i], value_f[1][i], value_f[2][i], value_f[3][i]);
+	}
+	#endif
+}
+
+void rtw_mstat_update(const enum mstat_f flags, const MSTAT_STATUS status, u32 sz)
+{
+	static u32 update_time = 0;
+	int peak, alloc;
+	int i;
+
+	/* initialization */
+	if(!update_time) {
+		for(i=0;i<mstat_tf_idx(MSTAT_TYPE_MAX);i++) {
+			ATOMIC_SET(&(rtw_mem_type_stat[i].alloc), 0);
+			ATOMIC_SET(&(rtw_mem_type_stat[i].peak), 0);
+			ATOMIC_SET(&(rtw_mem_type_stat[i].alloc_cnt), 0);
+			ATOMIC_SET(&(rtw_mem_type_stat[i].alloc_err_cnt), 0);
+		}
+		#ifdef RTW_MEM_FUNC_STAT
+		for(i=0;i<mstat_ff_idx(MSTAT_FUNC_MAX);i++) {
+			ATOMIC_SET(&(rtw_mem_func_stat[i].alloc), 0);
+			ATOMIC_SET(&(rtw_mem_func_stat[i].peak), 0);
+			ATOMIC_SET(&(rtw_mem_func_stat[i].alloc_cnt), 0);
+			ATOMIC_SET(&(rtw_mem_func_stat[i].alloc_err_cnt), 0);
+		}
+		#endif
+	}
+
+	switch(status) {
+		case MSTAT_ALLOC_SUCCESS:
+			ATOMIC_INC(&(rtw_mem_type_stat[mstat_tf_idx(flags)].alloc_cnt));
+			alloc = ATOMIC_ADD_RETURN(&(rtw_mem_type_stat[mstat_tf_idx(flags)].alloc), sz);
+			peak=ATOMIC_READ(&(rtw_mem_type_stat[mstat_tf_idx(flags)].peak));
+			if (peak<alloc)
+				ATOMIC_SET(&(rtw_mem_type_stat[mstat_tf_idx(flags)].peak), alloc);
+
+			#ifdef RTW_MEM_FUNC_STAT
+			ATOMIC_INC(&(rtw_mem_func_stat[mstat_ff_idx(flags)].alloc_cnt));
+			alloc = ATOMIC_ADD_RETURN(&(rtw_mem_func_stat[mstat_ff_idx(flags)].alloc), sz);
+			peak=ATOMIC_READ(&(rtw_mem_func_stat[mstat_ff_idx(flags)].peak));
+			if (peak<alloc)
+				ATOMIC_SET(&(rtw_mem_func_stat[mstat_ff_idx(flags)].peak), alloc);
+			#endif
+			break;
+
+		case MSTAT_ALLOC_FAIL:
+			ATOMIC_INC(&(rtw_mem_type_stat[mstat_tf_idx(flags)].alloc_err_cnt));
+			#ifdef RTW_MEM_FUNC_STAT
+			ATOMIC_INC(&(rtw_mem_func_stat[mstat_ff_idx(flags)].alloc_err_cnt));
+			#endif
+			break;
+
+		case MSTAT_FREE:
+			ATOMIC_DEC(&(rtw_mem_type_stat[mstat_tf_idx(flags)].alloc_cnt));
+			ATOMIC_SUB(&(rtw_mem_type_stat[mstat_tf_idx(flags)].alloc), sz);
+			#ifdef RTW_MEM_FUNC_STAT
+			ATOMIC_DEC(&(rtw_mem_func_stat[mstat_ff_idx(flags)].alloc_cnt));
+			ATOMIC_SUB(&(rtw_mem_func_stat[mstat_ff_idx(flags)].alloc), sz);
+			#endif
+			break;
+	};
+
+	//if (rtw_get_passing_time_ms(update_time) > 5000) {
+	//	rtw_mstat_dump(RTW_DBGDUMP);
+		update_time=rtw_get_current_time();
+	//}
+}
+
+#ifndef SIZE_MAX
+	#define SIZE_MAX (~(size_t)0)
+#endif
+
+struct mstat_sniff_rule {
+	enum mstat_f flags;
+	size_t lb;
+	size_t hb;
+};
+
+struct mstat_sniff_rule mstat_sniff_rules[] = {
+	{MSTAT_TYPE_PHY, 4097, SIZE_MAX},
+};
+
+int mstat_sniff_rule_num = sizeof(mstat_sniff_rules)/sizeof(struct mstat_sniff_rule);
+
+bool match_mstat_sniff_rules(const enum mstat_f flags, const size_t size)
+{
+	int i;
+	for (i = 0; i<mstat_sniff_rule_num; i++) {
+		if (mstat_sniff_rules[i].flags == flags
+				&& mstat_sniff_rules[i].lb <= size
+				&& mstat_sniff_rules[i].hb >= size)
+			return _TRUE;
+	}
+
+	return _FALSE;
+}
+
+inline u8* dbg_rtw_vmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line)
+{
+	u8  *p;
+
+	if (match_mstat_sniff_rules(flags, sz))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
+	
+	p=_rtw_vmalloc((sz));
+
+	rtw_mstat_update(
+		flags
+		, p ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
+		, sz
+	);
+	
+	return p;
+}
+
+inline u8* dbg_rtw_zvmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line)
+{
+	u8 *p;
+
+	if (match_mstat_sniff_rules(flags, sz))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
+
+	p=_rtw_zvmalloc((sz)); 
+
+	rtw_mstat_update(
+		flags
+		, p ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
+		, sz
+	);
+
+	return p;
+}
+
+inline void dbg_rtw_vmfree(u8 *pbuf, u32 sz, const enum mstat_f flags, const char *func, const int line)
+{
+
+	if (match_mstat_sniff_rules(flags, sz))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
+
+	_rtw_vmfree((pbuf), (sz)); 
+
+	rtw_mstat_update(
+		flags
+		, MSTAT_FREE
+		, sz
+	);
+}
+
+inline u8* dbg_rtw_malloc(u32 sz, const enum mstat_f flags, const char *func, const int line) 
+{
+	u8 *p;
+
+	if (match_mstat_sniff_rules(flags, sz))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
+
+	p=_rtw_malloc((sz));
+
+	rtw_mstat_update(
+		flags
+		, p ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
+		, sz
+	);
+
+	return p;
+}
+
+inline u8* dbg_rtw_zmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line)
+{
+	u8 *p;
+
+	if (match_mstat_sniff_rules(flags, sz))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
+
+	p = _rtw_zmalloc((sz));
+
+	rtw_mstat_update(
+		flags
+		, p ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
+		, sz
+	);
+
+	return p;
+}
+
+inline void dbg_rtw_mfree(u8 *pbuf, u32 sz, const enum mstat_f flags, const char *func, const int line)
+{
+	if (match_mstat_sniff_rules(flags, sz))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
+
+	_rtw_mfree((pbuf), (sz));
+
+	rtw_mstat_update(
+		flags
+		, MSTAT_FREE
+		, sz
+	);
+}
+
+inline struct sk_buff * dbg_rtw_skb_alloc(unsigned int size, const enum mstat_f flags, const char *func, int line)
+{
+	struct sk_buff *skb;
+	unsigned int truesize = 0;
+
+	skb = _rtw_skb_alloc(size);
+
+	if(skb)
+		truesize = skb->truesize;
+
+	if(!skb || truesize < size || match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d), skb:%p, truesize=%u\n", func, line, __FUNCTION__, size, skb, truesize);
+
+	rtw_mstat_update(
+		flags
+		, skb ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
+		, truesize
+	);
+
+	return skb;
+}
+
+inline void dbg_rtw_skb_free(struct sk_buff *skb, const enum mstat_f flags, const char *func, int line)
+{
+	unsigned int truesize = skb->truesize;
+
+	if(match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);
+
+	_rtw_skb_free(skb);
+
+	rtw_mstat_update(
+		flags
+		, MSTAT_FREE
+		, truesize
+	);
+}
+
+inline struct sk_buff *dbg_rtw_skb_copy(const struct sk_buff *skb, const enum mstat_f flags, const char *func, const int line)
+{
+	struct sk_buff *skb_cp;
+	unsigned int truesize = skb->truesize;
+	unsigned int cp_truesize = 0;
+	
+	skb_cp = _rtw_skb_copy(skb);
+	if(skb_cp)
+		cp_truesize = skb_cp->truesize;
+
+	if(!skb_cp || cp_truesize < truesize || match_mstat_sniff_rules(flags, cp_truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%u), skb_cp:%p, cp_truesize=%u\n", func, line, __FUNCTION__, truesize, skb_cp, cp_truesize);
+
+	rtw_mstat_update(
+		flags
+		, skb_cp ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
+		, truesize
+	);
+
+	return skb_cp;
+}
+
+inline struct sk_buff *dbg_rtw_skb_clone(struct sk_buff *skb, const enum mstat_f flags, const char *func, const int line)
+{
+	struct sk_buff *skb_cl;
+	unsigned int truesize = skb->truesize;
+	unsigned int cl_truesize = 0;
+
+	skb_cl = _rtw_skb_clone(skb);
+	if(skb_cl)
+		cl_truesize = skb_cl->truesize;
+
+	if(!skb_cl || cl_truesize < truesize || match_mstat_sniff_rules(flags, cl_truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%u), skb_cl:%p, cl_truesize=%u\n", func, line, __FUNCTION__, truesize, skb_cl, cl_truesize);
+
+	rtw_mstat_update(
+		flags
+		, skb_cl ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
+		, truesize
+	);
+
+	return skb_cl;
+}
+
+inline int dbg_rtw_netif_rx(_nic_hdl ndev, struct sk_buff *skb, const enum mstat_f flags, const char *func, int line)
+{
+	int ret;
+	unsigned int truesize = skb->truesize;
+
+	if(match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);
+
+	ret = _rtw_netif_rx(ndev, skb);
+	
+	rtw_mstat_update(
+		flags
+		, MSTAT_FREE
+		, truesize
+	);
+
+	return ret;
+}
+
+inline void dbg_rtw_skb_queue_purge(struct sk_buff_head *list, enum mstat_f flags, const char *func, int line)
+{
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(list)) != NULL)
+		dbg_rtw_skb_free(skb, flags, func, line);
+}
+
+#ifdef CONFIG_USB_HCI
+inline void *dbg_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_addr_t *dma, const enum mstat_f flags, const char *func, int line)
+{
+	void *p;
+
+	if(match_mstat_sniff_rules(flags, size))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%zu)\n", func, line, __FUNCTION__, size);
+
+	p = _rtw_usb_buffer_alloc(dev, size, dma);
+	
+	rtw_mstat_update(
+		flags
+		, p ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
+		, size
+	);
+
+	return p;
+}
+
+inline void dbg_rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr, dma_addr_t dma, const enum mstat_f flags, const char *func, int line)
+{
+
+	if(match_mstat_sniff_rules(flags, size))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%zu)\n", func, line, __FUNCTION__, size);
+
+	_rtw_usb_buffer_free(dev, size, addr, dma);
+
+	rtw_mstat_update(
+		flags
+		, MSTAT_FREE
+		, size
+	);
+}
+#endif /* CONFIG_USB_HCI */
+
+#endif /* defined(DBG_MEM_ALLOC) */
+
+void* rtw_malloc2d(int h, int w, size_t size)
+{
+	int j;
+
+	void **a = (void **) rtw_zmalloc( h*sizeof(void *) + h*w*size );
+	if(a == NULL)
+	{
+		DBG_871X("%s: alloc memory fail!\n", __FUNCTION__);
+		return NULL;
+	}
+
+	for( j=0; j<h; j++ )
+		a[j] = ((char *)(a+h)) + j*w*size;
+
+	return a;
+}
+
+void rtw_mfree2d(void *pbuf, int h, int w, int size)
+{
+	rtw_mfree((u8 *)pbuf, h*sizeof(void*) + w*h*size);
+}
+
+void _rtw_memcpy(void *dst, const void *src, u32 sz)
+{
+
+#if defined (PLATFORM_LINUX)|| defined (PLATFORM_FREEBSD)
+
+	memcpy(dst, src, sz);
+
+#endif	
+
+#ifdef PLATFORM_WINDOWS
+
+	NdisMoveMemory(dst, src, sz);
+
+#endif
+
+}
+
+inline void _rtw_memmove(void *dst, const void *src, u32 sz)
+{
+#if defined(PLATFORM_LINUX)
+	memmove(dst, src, sz);
+#else
+	#warning "no implementation\n"
+#endif
+}
+
+int	_rtw_memcmp(void *dst, void *src, u32 sz)
+{
+
+#if defined (PLATFORM_LINUX)|| defined (PLATFORM_FREEBSD)
+//under Linux/GNU/GLibc, the return value of memcmp for two same mem. chunk is 0
+
+	if (!(memcmp(dst, src, sz)))
+		return _TRUE;
+	else
+		return _FALSE;
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+//under Windows, the return value of NdisEqualMemory for two same mem. chunk is 1
+	
+	if (NdisEqualMemory (dst, src, sz))
+		return _TRUE;
+	else
+		return _FALSE;
+
+#endif	
+	
+	
+	
+}
+
+void _rtw_memset(void *pbuf, int c, u32 sz)
+{
+
+#if defined (PLATFORM_LINUX)|| defined (PLATFORM_FREEBSD)
+
+        memset(pbuf, c, sz);
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+#if 0
+	NdisZeroMemory(pbuf, sz);
+	if (c != 0) memset(pbuf, c, sz);
+#else
+	NdisFillMemory(pbuf, sz, c);
+#endif
+#endif
+
+}
+
+#ifdef PLATFORM_FREEBSD
+static inline void __list_add(_list *pnew, _list *pprev, _list *pnext)
+ {
+         pnext->prev = pnew;
+         pnew->next = pnext;
+         pnew->prev = pprev;
+         pprev->next = pnew;
+}
+#endif /* PLATFORM_FREEBSD */
+
+
+void _rtw_init_listhead(_list *list)
+{
+
+#ifdef PLATFORM_LINUX
+
+        INIT_LIST_HEAD(list);
+
+#endif
+
+#ifdef PLATFORM_FREEBSD
+         list->next = list;
+         list->prev = list;
+#endif
+#ifdef PLATFORM_WINDOWS
+
+        NdisInitializeListHead(list);
+
+#endif
+
+}
+
+
+/*
+For the following list_xxx operations, 
+caller must guarantee the atomic context.
+Otherwise, there will be racing condition.
+*/
+u32	rtw_is_list_empty(_list *phead)
+{
+
+#ifdef PLATFORM_LINUX
+
+	if (list_empty(phead))
+		return _TRUE;
+	else
+		return _FALSE;
+
+#endif
+#ifdef PLATFORM_FREEBSD
+
+	if (phead->next == phead)
+		return _TRUE;
+	else
+		return _FALSE;
+
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+
+	if (IsListEmpty(phead))
+		return _TRUE;
+	else
+		return _FALSE;
+
+#endif
+
+	
+}
+
+void rtw_list_insert_head(_list *plist, _list *phead)
+{
+
+#ifdef PLATFORM_LINUX
+	list_add(plist, phead);
+#endif
+
+#ifdef PLATFORM_FREEBSD
+	__list_add(plist, phead, phead->next);
+#endif
+
+#ifdef PLATFORM_WINDOWS
+	InsertHeadList(phead, plist);
+#endif
+}
+
+void rtw_list_insert_tail(_list *plist, _list *phead)
+{
+
+#ifdef PLATFORM_LINUX	
+	
+	list_add_tail(plist, phead);
+	
+#endif
+#ifdef PLATFORM_FREEBSD
+	
+	__list_add(plist, phead->prev, phead);
+	
+#endif	
+#ifdef PLATFORM_WINDOWS
+
+  InsertTailList(phead, plist);
+
+#endif		
+	
+}
+
+/*
+
+Caller must check if the list is empty before calling rtw_list_delete
+
+*/
+
+
+void _rtw_init_sema(_sema	*sema, int init_val)
+{
+
+#ifdef PLATFORM_LINUX
+
+	sema_init(sema, init_val);
+
+#endif
+#ifdef PLATFORM_FREEBSD
+	sema_init(sema, init_val, "rtw_drv");
+#endif
+#ifdef PLATFORM_OS_XP
+
+	KeInitializeSemaphore(sema, init_val,  SEMA_UPBND); // count=0;
+
+#endif
+	
+#ifdef PLATFORM_OS_CE
+	if(*sema == NULL)
+		*sema = CreateSemaphore(NULL, init_val, SEMA_UPBND, NULL);
+#endif
+
+}
+
+void _rtw_free_sema(_sema	*sema)
+{
+#ifdef PLATFORM_FREEBSD
+	sema_destroy(sema);
+#endif
+#ifdef PLATFORM_OS_CE
+	CloseHandle(*sema);
+#endif
+
+}
+
+void _rtw_up_sema(_sema	*sema)
+{
+
+#ifdef PLATFORM_LINUX
+
+	up(sema);
+
+#endif	
+#ifdef PLATFORM_FREEBSD
+	sema_post(sema);
+#endif
+#ifdef PLATFORM_OS_XP
+
+	KeReleaseSemaphore(sema, IO_NETWORK_INCREMENT, 1,  FALSE );
+
+#endif
+
+#ifdef PLATFORM_OS_CE
+	ReleaseSemaphore(*sema,  1,  NULL );
+#endif
+}
+
+u32 _rtw_down_sema(_sema *sema)
+{
+
+#ifdef PLATFORM_LINUX
+	
+	if (down_interruptible(sema))
+		return _FAIL;
+	else
+		return _SUCCESS;
+
+#endif    	
+#ifdef PLATFORM_FREEBSD
+	sema_wait(sema);
+	return  _SUCCESS;
+#endif
+#ifdef PLATFORM_OS_XP
+
+	if(STATUS_SUCCESS == KeWaitForSingleObject(sema, Executive, KernelMode, TRUE, NULL))
+		return  _SUCCESS;
+	else
+		return _FAIL;
+#endif
+
+#ifdef PLATFORM_OS_CE
+	if(WAIT_OBJECT_0 == WaitForSingleObject(*sema, INFINITE ))
+		return _SUCCESS; 
+	else
+		return _FAIL;
+#endif
+}
+
+
+
+void	_rtw_mutex_init(_mutex *pmutex)
+{
+#ifdef PLATFORM_LINUX
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	mutex_init(pmutex);
+#else
+	init_MUTEX(pmutex);
+#endif
+
+#endif
+#ifdef PLATFORM_FREEBSD
+	mtx_init(pmutex, "", NULL, MTX_DEF|MTX_RECURSE);
+#endif
+#ifdef PLATFORM_OS_XP
+
+	KeInitializeMutex(pmutex, 0);
+
+#endif
+
+#ifdef PLATFORM_OS_CE
+	*pmutex =  CreateMutex( NULL, _FALSE, NULL);
+#endif
+}
+
+void	_rtw_mutex_free(_mutex *pmutex);
+void	_rtw_mutex_free(_mutex *pmutex)
+{
+#ifdef PLATFORM_LINUX
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	mutex_destroy(pmutex);
+#else	
+#endif
+
+#ifdef PLATFORM_FREEBSD
+	sema_destroy(pmutex);
+#endif
+
+#endif
+
+#ifdef PLATFORM_OS_XP
+
+#endif
+
+#ifdef PLATFORM_OS_CE
+
+#endif
+}
+
+void	_rtw_spinlock_init(_lock *plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_lock_init(plock);
+
+#endif	
+#ifdef PLATFORM_FREEBSD
+		mtx_init(plock, "", NULL, MTX_DEF|MTX_RECURSE);
+#endif
+#ifdef PLATFORM_WINDOWS
+
+	NdisAllocateSpinLock(plock);
+
+#endif
+	
+}
+
+void	_rtw_spinlock_free(_lock *plock)
+{
+#ifdef PLATFORM_FREEBSD
+	 mtx_destroy(plock);
+#endif
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisFreeSpinLock(plock);
+
+#endif
+	
+}
+#ifdef PLATFORM_FREEBSD
+extern PADAPTER prtw_lock;
+
+void rtw_mtx_lock(_lock *plock){
+	if(prtw_lock){
+		mtx_lock(&prtw_lock->glock);
+	}
+	else{
+		printf("%s prtw_lock==NULL",__FUNCTION__);
+	}
+}
+void rtw_mtx_unlock(_lock *plock){
+	if(prtw_lock){
+		mtx_unlock(&prtw_lock->glock);
+	}
+	else{
+		printf("%s prtw_lock==NULL",__FUNCTION__);
+	}
+	
+}
+#endif //PLATFORM_FREEBSD
+
+
+void	_rtw_spinlock(_lock	*plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_lock(plock);
+
+#endif
+#ifdef PLATFORM_FREEBSD
+	mtx_lock(plock);
+#endif
+#ifdef PLATFORM_WINDOWS
+
+	NdisAcquireSpinLock(plock);
+
+#endif
+	
+}
+
+void	_rtw_spinunlock(_lock *plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_unlock(plock);
+
+#endif
+#ifdef PLATFORM_FREEBSD
+	mtx_unlock(plock);
+#endif	
+#ifdef PLATFORM_WINDOWS
+
+	NdisReleaseSpinLock(plock);
+
+#endif
+}
+
+
+void	_rtw_spinlock_ex(_lock	*plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_lock(plock);
+
+#endif
+#ifdef PLATFORM_FREEBSD
+	mtx_lock(plock);
+#endif	
+#ifdef PLATFORM_WINDOWS
+
+	NdisDprAcquireSpinLock(plock);
+
+#endif
+	
+}
+
+void	_rtw_spinunlock_ex(_lock *plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_unlock(plock);
+
+#endif
+#ifdef PLATFORM_FREEBSD
+	mtx_unlock(plock);
+#endif	
+#ifdef PLATFORM_WINDOWS
+
+	NdisDprReleaseSpinLock(plock);
+
+#endif
+}
+
+
+
+void _rtw_init_queue(_queue *pqueue)
+{
+	_rtw_init_listhead(&(pqueue->queue));
+	_rtw_spinlock_init(&(pqueue->lock));
+}
+
+void _rtw_deinit_queue(_queue *pqueue)
+{
+	_rtw_spinlock_free(&(pqueue->lock));
+}
+
+u32	  _rtw_queue_empty(_queue	*pqueue)
+{
+	return (rtw_is_list_empty(&(pqueue->queue)));
+}
+
+
+u32 rtw_end_of_queue_search(_list *head, _list *plist)
+{
+	if (head == plist)
+		return _TRUE;
+	else
+		return _FALSE;
+}
+
+
+u32	rtw_get_current_time(void)
+{
+	
+#ifdef PLATFORM_LINUX
+	return jiffies;
+#endif	
+#ifdef PLATFORM_FREEBSD
+	struct timeval tvp;
+	getmicrotime(&tvp);
+	return tvp.tv_sec;
+#endif
+#ifdef PLATFORM_WINDOWS
+	LARGE_INTEGER	SystemTime;
+	NdisGetCurrentSystemTime(&SystemTime);
+	return (u32)(SystemTime.LowPart);// count of 100-nanosecond intervals 
+#endif
+}
+
+inline u32 rtw_systime_to_ms(u32 systime)
+{
+#ifdef PLATFORM_LINUX
+	return systime * 1000 / HZ;
+#endif	
+#ifdef PLATFORM_FREEBSD
+	return systime * 1000;
+#endif	
+#ifdef PLATFORM_WINDOWS
+	return systime / 10000 ; 
+#endif
+}
+
+inline u32 rtw_ms_to_systime(u32 ms)
+{
+#ifdef PLATFORM_LINUX
+	return ms * HZ / 1000;
+#endif	
+#ifdef PLATFORM_FREEBSD
+	return ms /1000;
+#endif	
+#ifdef PLATFORM_WINDOWS
+	return ms * 10000 ; 
+#endif
+}
+
+// the input parameter start use the same unit as returned by rtw_get_current_time
+inline s32 rtw_get_passing_time_ms(u32 start)
+{
+#ifdef PLATFORM_LINUX
+	return rtw_systime_to_ms(jiffies-start);
+#endif
+#ifdef PLATFORM_FREEBSD
+	return rtw_systime_to_ms(rtw_get_current_time());
+#endif	
+#ifdef PLATFORM_WINDOWS
+	LARGE_INTEGER	SystemTime;
+	NdisGetCurrentSystemTime(&SystemTime);
+	return rtw_systime_to_ms((u32)(SystemTime.LowPart) - start) ;
+#endif
+}
+
+inline s32 rtw_get_time_interval_ms(u32 start, u32 end)
+{
+#ifdef PLATFORM_LINUX
+	return rtw_systime_to_ms(end-start);
+#endif
+#ifdef PLATFORM_FREEBSD
+	return rtw_systime_to_ms(rtw_get_current_time());
+#endif	
+#ifdef PLATFORM_WINDOWS
+	return rtw_systime_to_ms(end-start);
+#endif
+}
+	
+
+void rtw_sleep_schedulable(int ms)	
+{
+
+#ifdef PLATFORM_LINUX
+
+    u32 delta;
+    
+    delta = (ms * HZ)/1000;//(ms)
+    if (delta == 0) {
+        delta = 1;// 1 ms
+    }
+    set_current_state(TASK_INTERRUPTIBLE);
+    if (schedule_timeout(delta) != 0) {
+        return ;
+    }
+    return;
+
+#endif	
+#ifdef PLATFORM_FREEBSD
+	DELAY(ms*1000);
+	return ;
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisMSleep(ms*1000); //(us)*1000=(ms)
+
+#endif
+
+}
+
+
+void rtw_msleep_os(int ms)
+{
+
+#ifdef PLATFORM_LINUX
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36))
+	if (ms < 20) {
+		unsigned long us = ms * 1000UL;
+		usleep_range(us, us + 1000UL);
+	} else
+	#endif
+  	msleep((unsigned int)ms);
+
+#endif	
+#ifdef PLATFORM_FREEBSD
+       //Delay for delay microseconds 
+	DELAY(ms*1000);
+	return ;
+#endif	
+#ifdef PLATFORM_WINDOWS
+
+	NdisMSleep(ms*1000); //(us)*1000=(ms)
+
+#endif
+
+
+}
+void rtw_usleep_os(int us)
+{
+#ifdef PLATFORM_LINUX
+
+	// msleep((unsigned int)us);
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36))
+	usleep_range(us, us + 1);	
+	#else
+	if ( 1 < (us/1000) )
+      		msleep(1);
+      else
+		msleep( (us/1000) + 1);
+	#endif
+#endif
+
+#ifdef PLATFORM_FREEBSD
+	//Delay for delay microseconds 
+	DELAY(us);
+
+	return ;
+#endif	
+#ifdef PLATFORM_WINDOWS
+
+	NdisMSleep(us); //(us)
+
+#endif
+
+
+}
+
+
+#ifdef DBG_DELAY_OS
+void _rtw_mdelay_os(int ms, const char *func, const int line)
+{
+	#if 0
+	if(ms>10)
+		DBG_871X("%s:%d %s(%d)\n", func, line, __FUNCTION__, ms);
+		rtw_msleep_os(ms);
+	return;
+	#endif
+
+
+	DBG_871X("%s:%d %s(%d)\n", func, line, __FUNCTION__, ms);
+
+#if defined(PLATFORM_LINUX)
+
+   	mdelay((unsigned long)ms); 
+
+#elif defined(PLATFORM_WINDOWS)
+
+	NdisStallExecution(ms*1000); //(us)*1000=(ms)
+
+#endif
+
+
+}
+void _rtw_udelay_os(int us, const char *func, const int line)
+{
+
+	#if 0
+	if(us > 1000) {
+	DBG_871X("%s:%d %s(%d)\n", func, line, __FUNCTION__, us);
+		rtw_usleep_os(us);
+		return;
+	}
+	#endif 
+
+
+	DBG_871X("%s:%d %s(%d)\n", func, line, __FUNCTION__, us);
+	
+	
+#if defined(PLATFORM_LINUX)
+
+      udelay((unsigned long)us); 
+
+#elif defined(PLATFORM_WINDOWS)
+
+	NdisStallExecution(us); //(us)
+
+#endif
+
+}
+#else
+void rtw_mdelay_os(int ms)
+{
+
+#ifdef PLATFORM_LINUX
+
+   	mdelay((unsigned long)ms); 
+
+#endif	
+#ifdef PLATFORM_FREEBSD
+	DELAY(ms*1000);
+	return ;
+#endif	
+#ifdef PLATFORM_WINDOWS
+
+	NdisStallExecution(ms*1000); //(us)*1000=(ms)
+
+#endif
+
+
+}
+void rtw_udelay_os(int us)
+{
+
+#ifdef PLATFORM_LINUX
+
+      udelay((unsigned long)us); 
+
+#endif	
+#ifdef PLATFORM_FREEBSD
+	//Delay for delay microseconds 
+	DELAY(us);
+	return ;
+#endif		
+#ifdef PLATFORM_WINDOWS
+
+	NdisStallExecution(us); //(us)
+
+#endif
+
+}
+#endif
+
+void rtw_yield_os(void)
+{
+#ifdef PLATFORM_LINUX
+	yield();
+#endif
+#ifdef PLATFORM_FREEBSD
+	yield();
+#endif
+#ifdef PLATFORM_WINDOWS
+	SwitchToThread();
+#endif
+}
+
+#define RTW_SUSPEND_LOCK_NAME "rtw_wifi"
+#define RTW_SUSPEND_EXT_LOCK_NAME "rtw_wifi_ext"
+#define RTW_SUSPEND_RX_LOCK_NAME "rtw_wifi_rx"
+#define RTW_SUSPEND_TRAFFIC_LOCK_NAME "rtw_wifi_traffic"
+#define RTW_SUSPEND_RESUME_LOCK_NAME "rtw_wifi_resume"
+#define RTW_RESUME_SCAN_LOCK_NAME "rtw_wifi_scan"
+#ifdef CONFIG_WAKELOCK
+static struct wake_lock rtw_suspend_lock;
+static struct wake_lock rtw_suspend_ext_lock;
+static struct wake_lock rtw_suspend_rx_lock;
+static struct wake_lock rtw_suspend_traffic_lock;
+static struct wake_lock rtw_suspend_resume_lock;
+static struct wake_lock rtw_resume_scan_lock;
+#elif defined(CONFIG_ANDROID_POWER)
+static android_suspend_lock_t rtw_suspend_lock ={
+	.name = RTW_SUSPEND_LOCK_NAME
+};
+static android_suspend_lock_t rtw_suspend_ext_lock ={
+	.name = RTW_SUSPEND_EXT_LOCK_NAME
+};
+static android_suspend_lock_t rtw_suspend_rx_lock ={
+	.name = RTW_SUSPEND_RX_LOCK_NAME
+};
+static android_suspend_lock_t rtw_suspend_traffic_lock ={
+	.name = RTW_SUSPEND_TRAFFIC_LOCK_NAME
+};
+static android_suspend_lock_t rtw_suspend_resume_lock ={
+	.name = RTW_SUSPEND_RESUME_LOCK_NAME
+};
+static android_suspend_lock_t rtw_resume_scan_lock ={
+	.name = RTW_RESUME_SCAN_LOCK_NAME
+};
+#endif
+
+inline void rtw_suspend_lock_init(void)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_lock_init(&rtw_suspend_lock, WAKE_LOCK_SUSPEND, RTW_SUSPEND_LOCK_NAME);
+	wake_lock_init(&rtw_suspend_ext_lock, WAKE_LOCK_SUSPEND, RTW_SUSPEND_EXT_LOCK_NAME);
+	wake_lock_init(&rtw_suspend_rx_lock, WAKE_LOCK_SUSPEND, RTW_SUSPEND_RX_LOCK_NAME);
+	wake_lock_init(&rtw_suspend_traffic_lock, WAKE_LOCK_SUSPEND, RTW_SUSPEND_TRAFFIC_LOCK_NAME);
+	wake_lock_init(&rtw_suspend_resume_lock, WAKE_LOCK_SUSPEND, RTW_SUSPEND_RESUME_LOCK_NAME);
+	wake_lock_init(&rtw_resume_scan_lock, WAKE_LOCK_SUSPEND, RTW_RESUME_SCAN_LOCK_NAME);
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_init_suspend_lock(&rtw_suspend_lock);
+	android_init_suspend_lock(&rtw_suspend_ext_lock);
+	android_init_suspend_lock(&rtw_suspend_rx_lock);
+	android_init_suspend_lock(&rtw_suspend_traffic_lock);
+	android_init_suspend_lock(&rtw_suspend_resume_lock);
+	android_init_suspend_lock(&rtw_resume_scan_lock);
+	#endif
+}
+
+inline void rtw_suspend_lock_uninit(void)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_lock_destroy(&rtw_suspend_lock);
+	wake_lock_destroy(&rtw_suspend_ext_lock);
+	wake_lock_destroy(&rtw_suspend_rx_lock);
+	wake_lock_destroy(&rtw_suspend_traffic_lock);
+	wake_lock_destroy(&rtw_suspend_resume_lock);
+	wake_lock_destroy(&rtw_resume_scan_lock);
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_uninit_suspend_lock(&rtw_suspend_lock);
+	android_uninit_suspend_lock(&rtw_suspend_ext_lock);
+	android_uninit_suspend_lock(&rtw_suspend_rx_lock);
+	android_uninit_suspend_lock(&rtw_suspend_traffic_lock);
+	android_uninit_suspend_lock(&rtw_suspend_resume_lock);
+	android_uninit_suspend_lock(&rtw_resume_scan_lock);
+	#endif
+}
+
+inline void rtw_lock_suspend(void)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_lock(&rtw_suspend_lock);
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_lock_suspend(&rtw_suspend_lock);
+	#endif
+
+	#if  defined(CONFIG_WAKELOCK) || defined(CONFIG_ANDROID_POWER)
+	//DBG_871X("####%s: suspend_lock_count:%d####\n", __FUNCTION__, rtw_suspend_lock.stat.count);
+	#endif
+}
+
+inline void rtw_unlock_suspend(void)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_unlock(&rtw_suspend_lock);
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_unlock_suspend(&rtw_suspend_lock);
+	#endif
+
+	#if  defined(CONFIG_WAKELOCK) || defined(CONFIG_ANDROID_POWER)
+	//DBG_871X("####%s: suspend_lock_count:%d####\n", __FUNCTION__, rtw_suspend_lock.stat.count);
+	#endif
+}
+
+inline void rtw_resume_lock_suspend(void)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_lock(&rtw_suspend_resume_lock);
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_lock_suspend(&rtw_suspend_resume_lock);
+	#endif
+
+	#if  defined(CONFIG_WAKELOCK) || defined(CONFIG_ANDROID_POWER)
+	//DBG_871X("####%s: suspend_lock_count:%d####\n", __FUNCTION__, rtw_suspend_lock.stat.count);
+	#endif
+}
+
+inline void rtw_resume_unlock_suspend(void)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_unlock(&rtw_suspend_resume_lock);
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_unlock_suspend(&rtw_suspend_resume_lock);
+	#endif
+
+	#if  defined(CONFIG_WAKELOCK) || defined(CONFIG_ANDROID_POWER)
+	//DBG_871X("####%s: suspend_lock_count:%d####\n", __FUNCTION__, rtw_suspend_lock.stat.count);
+	#endif
+}
+
+inline void rtw_lock_suspend_timeout(u32 timeout_ms)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_lock_timeout(&rtw_suspend_lock, rtw_ms_to_systime(timeout_ms));
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_lock_suspend_auto_expire(&rtw_suspend_lock, rtw_ms_to_systime(timeout_ms));
+	#endif
+}
+
+inline void rtw_lock_ext_suspend_timeout(u32 timeout_ms)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_lock_timeout(&rtw_suspend_ext_lock, rtw_ms_to_systime(timeout_ms));
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_lock_suspend_auto_expire(&rtw_suspend_ext_lock, rtw_ms_to_systime(timeout_ms));
+	#endif
+	//DBG_871X("EXT lock timeout:%d\n", timeout_ms);
+}
+
+inline void rtw_lock_rx_suspend_timeout(u32 timeout_ms)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_lock_timeout(&rtw_suspend_rx_lock, rtw_ms_to_systime(timeout_ms));
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_lock_suspend_auto_expire(&rtw_suspend_rx_lock, rtw_ms_to_systime(timeout_ms));
+	#endif
+	//DBG_871X("RX lock timeout:%d\n", timeout_ms);
+}
+
+
+inline void rtw_lock_traffic_suspend_timeout(u32 timeout_ms)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_lock_timeout(&rtw_suspend_traffic_lock, rtw_ms_to_systime(timeout_ms));
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_lock_suspend_auto_expire(&rtw_suspend_traffic_lock, rtw_ms_to_systime(timeout_ms));
+	#endif
+	//DBG_871X("traffic lock timeout:%d\n", timeout_ms);
+}
+
+inline void rtw_lock_resume_scan_timeout(u32 timeout_ms)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_lock_timeout(&rtw_resume_scan_lock, rtw_ms_to_systime(timeout_ms));
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_lock_suspend_auto_expire(&rtw_resume_scan_lock, rtw_ms_to_systime(timeout_ms));
+	#endif
+	//DBG_871X("resume scan lock:%d\n", timeout_ms);
+}
+
+inline void ATOMIC_SET(ATOMIC_T *v, int i)
+{
+	#ifdef PLATFORM_LINUX
+	atomic_set(v,i);
+	#elif defined(PLATFORM_WINDOWS)
+	*v=i;// other choice????
+	#elif defined(PLATFORM_FREEBSD)
+	atomic_set_int(v,i);
+	#endif
+}
+
+inline int ATOMIC_READ(ATOMIC_T *v)
+{
+	#ifdef PLATFORM_LINUX
+	return atomic_read(v);
+	#elif defined(PLATFORM_WINDOWS)
+	return *v; // other choice????
+	#elif defined(PLATFORM_FREEBSD)
+	return atomic_load_acq_32(v);
+	#endif
+}
+
+inline void ATOMIC_ADD(ATOMIC_T *v, int i)
+{
+	#ifdef PLATFORM_LINUX
+	atomic_add(i,v);
+	#elif defined(PLATFORM_WINDOWS)
+	InterlockedAdd(v,i);
+	#elif defined(PLATFORM_FREEBSD)
+	atomic_add_int(v,i);
+	#endif
+}
+inline void ATOMIC_SUB(ATOMIC_T *v, int i)
+{
+	#ifdef PLATFORM_LINUX
+	atomic_sub(i,v);
+	#elif defined(PLATFORM_WINDOWS)
+	InterlockedAdd(v,-i);
+	#elif defined(PLATFORM_FREEBSD)
+	atomic_subtract_int(v,i);
+	#endif
+}
+
+inline void ATOMIC_INC(ATOMIC_T *v)
+{
+	#ifdef PLATFORM_LINUX
+	atomic_inc(v);
+	#elif defined(PLATFORM_WINDOWS)
+	InterlockedIncrement(v);
+	#elif defined(PLATFORM_FREEBSD)
+	atomic_add_int(v,1);
+	#endif
+}
+
+inline void ATOMIC_DEC(ATOMIC_T *v)
+{
+	#ifdef PLATFORM_LINUX
+	atomic_dec(v);
+	#elif defined(PLATFORM_WINDOWS)
+	InterlockedDecrement(v);
+	#elif defined(PLATFORM_FREEBSD)
+	atomic_subtract_int(v,1);
+	#endif
+}
+
+inline int ATOMIC_ADD_RETURN(ATOMIC_T *v, int i)
+{
+	#ifdef PLATFORM_LINUX
+	return atomic_add_return(i,v);
+	#elif defined(PLATFORM_WINDOWS)
+	return InterlockedAdd(v,i);
+	#elif defined(PLATFORM_FREEBSD)
+	atomic_add_int(v,i);
+	return atomic_load_acq_32(v);
+	#endif
+}
+
+inline int ATOMIC_SUB_RETURN(ATOMIC_T *v, int i)
+{
+	#ifdef PLATFORM_LINUX
+	return atomic_sub_return(i,v);
+	#elif defined(PLATFORM_WINDOWS)
+	return InterlockedAdd(v,-i);
+	#elif defined(PLATFORM_FREEBSD)
+	atomic_subtract_int(v,i);
+	return atomic_load_acq_32(v);
+	#endif
+}
+
+inline int ATOMIC_INC_RETURN(ATOMIC_T *v)
+{
+	#ifdef PLATFORM_LINUX
+	return atomic_inc_return(v);
+	#elif defined(PLATFORM_WINDOWS)
+	return InterlockedIncrement(v);
+	#elif defined(PLATFORM_FREEBSD)
+	atomic_add_int(v,1);
+	return atomic_load_acq_32(v);
+	#endif
+}
+
+inline int ATOMIC_DEC_RETURN(ATOMIC_T *v)
+{
+	#ifdef PLATFORM_LINUX
+	return atomic_dec_return(v);
+	#elif defined(PLATFORM_WINDOWS)
+	return InterlockedDecrement(v);
+	#elif defined(PLATFORM_FREEBSD)
+	atomic_subtract_int(v,1);
+	return atomic_load_acq_32(v);
+	#endif
+}
+
+
+#ifdef PLATFORM_LINUX
+/*
+* Open a file with the specific @param path, @param flag, @param mode
+* @param fpp the pointer of struct file pointer to get struct file pointer while file opening is success
+* @param path the path of the file to open
+* @param flag file operation flags, please refer to linux document
+* @param mode please refer to linux document
+* @return Linux specific error code
+*/
+static int openFile(struct file **fpp, char *path, int flag, int mode) 
+{ 
+	struct file *fp; 
+ 
+	fp=filp_open(path, flag, mode); 
+	if(IS_ERR(fp)) {
+		*fpp=NULL;
+		return PTR_ERR(fp);
+	}
+	else {
+		*fpp=fp; 
+		return 0;
+	}	
+}
+
+/*
+* Close the file with the specific @param fp
+* @param fp the pointer of struct file to close
+* @return always 0
+*/
+static int closeFile(struct file *fp) 
+{ 
+	filp_close(fp,NULL);
+	return 0; 
+}
+
+static int readFile(struct file *fp,char *buf,int len) 
+{ 
+	int rlen=0, sum=0;
+	
+	if (!fp->f_op || !fp->f_op->read) 
+		return -EPERM;
+
+	while(sum<len) {
+		rlen=fp->f_op->read(fp,buf+sum,len-sum, &fp->f_pos);
+		if(rlen>0)
+			sum+=rlen;
+		else if(0 != rlen)
+			return rlen;
+		else
+			break;
+	}
+	
+	return  sum;
+
+}
+
+static int writeFile(struct file *fp,char *buf,int len) 
+{ 
+	int wlen=0, sum=0;
+	
+	if (!fp->f_op || !fp->f_op->write) 
+		return -EPERM; 
+
+	while(sum<len) {
+		wlen=fp->f_op->write(fp,buf+sum,len-sum, &fp->f_pos);
+		if(wlen>0)
+			sum+=wlen;
+		else if(0 != wlen)
+			return wlen;
+		else
+			break;
+	}
+
+	return sum;
+
+}
+
+/*
+* Test if the specifi @param path is a file and readable
+* @param path the path of the file to test
+* @return Linux specific error code
+*/
+static int isFileReadable(char *path)
+{ 
+	struct file *fp;
+	int ret = 0;
+#ifdef set_fs
+	mm_segment_t oldfs;
+#endif
+	char buf;
+ 
+	fp=filp_open(path, O_RDONLY, 0); 
+	if(IS_ERR(fp)) {
+		ret = PTR_ERR(fp);
+	}
+	else {
+#ifdef set_fs
+		oldfs = get_fs(); set_fs(KERNEL_DS);
+#endif
+		
+		if(1!=readFile(fp, &buf, 1))
+			ret = PTR_ERR(fp);
+		
+#ifdef set_fs
+		set_fs(oldfs);
+#endif
+		filp_close(fp,NULL);
+	}	
+	return ret;
+}
+
+/*
+* Open the file with @param path and retrive the file content into memory starting from @param buf for @param sz at most
+* @param path the path of the file to open and read
+* @param buf the starting address of the buffer to store file content
+* @param sz how many bytes to read at most
+* @return the byte we've read, or Linux specific error code
+*/
+static int retriveFromFile(char *path, u8* buf, u32 sz)
+{
+	int ret =-1;
+#ifdef set_fs
+	mm_segment_t oldfs;
+#endif
+	struct file *fp;
+
+	if(path && buf) {
+		if( 0 == (ret=openFile(&fp,path, O_RDONLY, 0)) ){
+			DBG_871X("%s openFile path:%s fp=%p\n",__FUNCTION__, path ,fp);
+
+#ifdef set_fs
+			oldfs = get_fs(); set_fs(KERNEL_DS);
+			ret=readFile(fp, buf, sz);
+			set_fs(oldfs);
+#else
+			ret=readFile(fp, buf, sz);
+#endif
+			closeFile(fp);
+			
+			DBG_871X("%s readFile, ret:%d\n",__FUNCTION__, ret);
+			
+		} else {
+			DBG_871X("%s openFile path:%s Fail, ret:%d\n",__FUNCTION__, path, ret);
+		}
+	} else {
+		DBG_871X("%s NULL pointer\n",__FUNCTION__);
+		ret =  -EINVAL;
+	}
+	return ret;
+}
+
+/*
+* Open the file with @param path and wirte @param sz byte of data starting from @param buf into the file
+* @param path the path of the file to open and write
+* @param buf the starting address of the data to write into file
+* @param sz how many bytes to write at most
+* @return the byte we've written, or Linux specific error code
+*/
+static int storeToFile(char *path, u8* buf, u32 sz)
+{
+	int ret =0;
+#ifdef set_fs
+	mm_segment_t oldfs;
+#endif
+	struct file *fp;
+	
+	if(path && buf) {
+		if( 0 == (ret=openFile(&fp, path, O_CREAT|O_WRONLY, 0666)) ) {
+			DBG_871X("%s openFile path:%s fp=%p\n",__FUNCTION__, path ,fp);
+
+#ifdef set_fs
+			oldfs = get_fs(); set_fs(KERNEL_DS);
+			ret=writeFile(fp, buf, sz);
+			set_fs(oldfs);
+#else
+			ret=writeFile(fp, buf, sz);
+#endif
+			closeFile(fp);
+
+			DBG_871X("%s writeFile, ret:%d\n",__FUNCTION__, ret);
+			
+		} else {
+			DBG_871X("%s openFile path:%s Fail, ret:%d\n",__FUNCTION__, path, ret);
+		}	
+	} else {
+		DBG_871X("%s NULL pointer\n",__FUNCTION__);
+		ret =  -EINVAL;
+	}
+	return ret;
+}
+#endif //PLATFORM_LINUX
+
+/*
+* Test if the specifi @param path is a file and readable
+* @param path the path of the file to test
+* @return _TRUE or _FALSE
+*/
+int rtw_is_file_readable(char *path)
+{
+#ifdef PLATFORM_LINUX
+	if(isFileReadable(path) == 0)
+		return _TRUE;
+	else
+		return _FALSE;
+#else
+	//Todo...
+	return _FALSE;
+#endif
+}
+
+/*
+* Open the file with @param path and retrive the file content into memory starting from @param buf for @param sz at most
+* @param path the path of the file to open and read
+* @param buf the starting address of the buffer to store file content
+* @param sz how many bytes to read at most
+* @return the byte we've read
+*/
+int rtw_retrieve_from_file(char *path, u8 *buf, u32 sz)
+{
+#ifdef PLATFORM_LINUX
+	int ret =retriveFromFile(path, buf, sz);
+	return ret>=0?ret:0;
+#else
+	//Todo...
+	return 0;
+#endif
+}
+
+/*
+* Open the file with @param path and wirte @param sz byte of data starting from @param buf into the file
+* @param path the path of the file to open and write
+* @param buf the starting address of the data to write into file
+* @param sz how many bytes to write at most
+* @return the byte we've written
+*/
+int rtw_store_to_file(char *path, u8* buf, u32 sz)
+{
+#ifdef PLATFORM_LINUX
+	int ret =storeToFile(path, buf, sz);
+	return ret>=0?ret:0;
+#else
+	//Todo...
+	return 0;
+#endif
+}
+
+#ifdef PLATFORM_LINUX
+struct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv)
+{
+	struct net_device *pnetdev;
+	struct rtw_netdev_priv_indicator *pnpi;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	pnetdev = alloc_etherdev_mq(sizeof(struct rtw_netdev_priv_indicator), 4);
+#else
+	pnetdev = alloc_etherdev(sizeof(struct rtw_netdev_priv_indicator));
+#endif
+	if (!pnetdev)
+		goto RETURN;
+	
+	pnpi = netdev_priv(pnetdev);
+	pnpi->priv=old_priv;
+	pnpi->sizeof_priv=sizeof_priv;
+
+RETURN:
+	return pnetdev;
+}
+
+struct net_device *rtw_alloc_etherdev(int sizeof_priv)
+{
+	struct net_device *pnetdev;
+	struct rtw_netdev_priv_indicator *pnpi;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	pnetdev = alloc_etherdev_mq(sizeof(struct rtw_netdev_priv_indicator), 4);
+#else
+	pnetdev = alloc_etherdev(sizeof(struct rtw_netdev_priv_indicator));
+#endif
+	if (!pnetdev)
+		goto RETURN;
+	
+	pnpi = netdev_priv(pnetdev);
+	
+	pnpi->priv = rtw_zvmalloc(sizeof_priv);
+	if (!pnpi->priv) {
+		free_netdev(pnetdev);
+		pnetdev = NULL;
+		goto RETURN;
+	}
+	
+	pnpi->sizeof_priv=sizeof_priv;
+RETURN:
+	return pnetdev;
+}
+
+void rtw_free_netdev(struct net_device * netdev)
+{
+	struct rtw_netdev_priv_indicator *pnpi;
+	
+	if(!netdev)
+		goto RETURN;
+	
+	pnpi = netdev_priv(netdev);
+
+	if(!pnpi->priv)
+		goto RETURN;
+
+	free_netdev(netdev);
+
+RETURN:
+	return;
+}
+
+/*
+* Jeff: this function should be called under ioctl (rtnl_lock is accquired) while 
+* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+*/
+int rtw_change_ifname(_adapter *padapter, const char *ifname)
+{
+	struct net_device *pnetdev;
+	struct net_device *cur_pnetdev;
+	struct rereg_nd_name_data *rereg_priv;
+	int ret;
+
+	if(!padapter)
+		goto error;
+
+	cur_pnetdev = padapter->pnetdev;
+	rereg_priv = &padapter->rereg_nd_name_priv;
+	
+	//free the old_pnetdev
+	if(rereg_priv->old_pnetdev) {
+		free_netdev(rereg_priv->old_pnetdev);
+		rereg_priv->old_pnetdev = NULL;
+	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+	if(!rtnl_is_locked())
+		unregister_netdev(cur_pnetdev);
+	else
+#endif
+		unregister_netdevice(cur_pnetdev);
+
+	rereg_priv->old_pnetdev=cur_pnetdev;
+
+	pnetdev = rtw_init_netdev(padapter);
+	if (!pnetdev)  {
+		ret = -1;
+		goto error;
+	}
+
+	SET_NETDEV_DEV(pnetdev, dvobj_to_dev(adapter_to_dvobj(padapter)));
+
+	rtw_init_netdev_name(pnetdev, ifname);
+
+	_rtw_memcpy(pnetdev->dev_addr, adapter_mac_addr(padapter), ETH_ALEN);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+	if(!rtnl_is_locked())
+		ret = register_netdev(pnetdev);
+	else
+#endif
+		ret = register_netdevice(pnetdev);
+
+	if ( ret != 0) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("register_netdev() failed\n"));
+		goto error;
+	}
+
+	return 0;
+
+error:
+	
+	return -1;
+	
+}
+#endif
+
+#ifdef PLATFORM_FREEBSD
+/*
+ * Copy a buffer from userspace and write into kernel address 
+ * space.
+ *
+ * This emulation just calls the FreeBSD copyin function (to 
+ * copy data from user space buffer into a kernel space buffer)
+ * and is designed to be used with the above io_write_wrapper.
+ *
+ * This function should return the number of bytes not copied.
+ * I.e. success results in a zero value. 
+ * Negative error values are not returned.
+ */
+unsigned long
+copy_from_user(void *to, const void *from, unsigned long n)
+{      
+        if ( copyin(from, to, n) != 0 ) {
+                /* Any errors will be treated as a failure
+                   to copy any of the requested bytes */
+                return n;
+        }
+
+        return 0;
+}
+
+unsigned long
+copy_to_user(void *to, const void *from, unsigned long n)
+{
+	if ( copyout(from, to, n) != 0 ) {
+		/* Any errors will be treated as a failure
+		   to copy any of the requested bytes */
+		return n;
+	}
+
+	return 0;
+}
+
+
+/*
+ * The usb_register and usb_deregister functions are used to register
+ * usb drivers with the usb subsystem. In this compatibility layer
+ * emulation a list of drivers (struct usb_driver) is maintained
+ * and is used for probing/attaching etc.
+ *
+ * usb_register and usb_deregister simply call these functions.
+ */
+int 
+usb_register(struct usb_driver *driver)
+{
+        rtw_usb_linux_register(driver);
+        return 0;
+}
+
+
+int 
+usb_deregister(struct usb_driver *driver)
+{
+        rtw_usb_linux_deregister(driver);
+        return 0;
+}
+
+void module_init_exit_wrapper(void *arg)
+{
+        int (*func)(void) = arg;
+        func();
+        return;
+}
+
+#endif //PLATFORM_FREEBSD
+
+#ifdef CONFIG_PLATFORM_SPRD
+#ifdef do_div
+#undef do_div
+#endif
+#include <asm-generic/div64.h>
+#endif
+
+u64 rtw_modular64(u64 x, u64 y)
+{
+#ifdef PLATFORM_LINUX
+	return do_div(x, y);
+#elif defined(PLATFORM_WINDOWS)
+	return (x % y);
+#elif defined(PLATFORM_FREEBSD)
+	return (x %y);
+#endif
+}
+
+u64 rtw_division64(u64 x, u64 y)
+{
+#ifdef PLATFORM_LINUX
+	do_div(x, y);
+	return x;
+#elif defined(PLATFORM_WINDOWS)
+	return (x / y);
+#elif defined(PLATFORM_FREEBSD)
+	return (x / y);
+#endif
+}
+
+inline u32 rtw_random32(void)
+{
+#ifdef PLATFORM_LINUX
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0))
+	return prandom_u32();
+	#elif (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18))
+	u32 random_int;
+	get_random_bytes( &random_int , 4 );
+	return random_int;
+	#else
+	return random32();
+	#endif
+#elif defined(PLATFORM_WINDOWS)
+	#error "to be implemented\n"
+#elif defined(PLATFORM_FREEBSD)
+	#error "to be implemented\n"
+#endif
+}
+
+void rtw_buf_free(u8 **buf, u32 *buf_len)
+{
+	u32 ori_len;
+
+	if (!buf || !buf_len)
+		return;
+
+	ori_len = *buf_len;
+
+	if (*buf) {
+		u32 tmp_buf_len = *buf_len;
+		*buf_len = 0;
+		rtw_mfree(*buf, tmp_buf_len);
+		*buf = NULL;
+	}
+}
+
+void rtw_buf_update(u8 **buf, u32 *buf_len, u8 *src, u32 src_len)
+{
+	u32 ori_len = 0, dup_len = 0;
+	u8 *ori = NULL;
+	u8 *dup = NULL;
+
+	if (!buf || !buf_len)
+		return;
+
+	if (!src || !src_len)
+		goto keep_ori;
+
+	/* duplicate src */
+	dup = rtw_malloc(src_len);
+	if (dup) {
+		dup_len = src_len;
+		_rtw_memcpy(dup, src, dup_len);
+	}
+
+keep_ori:
+	ori = *buf;
+	ori_len = *buf_len;
+
+	/* replace buf with dup */
+	*buf_len = 0;
+	*buf = dup;
+	*buf_len = dup_len;
+
+	/* free ori */
+	if (ori && ori_len > 0)
+		rtw_mfree(ori, ori_len);
+}
+
+
+/**
+ * rtw_cbuf_full - test if cbuf is full
+ * @cbuf: pointer of struct rtw_cbuf
+ *
+ * Returns: _TRUE if cbuf is full
+ */
+inline bool rtw_cbuf_full(struct rtw_cbuf *cbuf)
+{
+	return (cbuf->write == cbuf->read-1)? _TRUE : _FALSE;
+}
+
+/**
+ * rtw_cbuf_empty - test if cbuf is empty
+ * @cbuf: pointer of struct rtw_cbuf
+ *
+ * Returns: _TRUE if cbuf is empty
+ */
+inline bool rtw_cbuf_empty(struct rtw_cbuf *cbuf)
+{
+	return (cbuf->write == cbuf->read)? _TRUE : _FALSE;
+}
+
+/**
+ * rtw_cbuf_push - push a pointer into cbuf
+ * @cbuf: pointer of struct rtw_cbuf
+ * @buf: pointer to push in
+ *
+ * Lock free operation, be careful of the use scheme
+ * Returns: _TRUE push success
+ */
+bool rtw_cbuf_push(struct rtw_cbuf *cbuf, void *buf)
+{
+	if (rtw_cbuf_full(cbuf))
+		return _FAIL;
+
+	if (0)
+		DBG_871X("%s on %u\n", __func__, cbuf->write);
+	cbuf->bufs[cbuf->write] = buf;
+	cbuf->write = (cbuf->write+1)%cbuf->size;
+
+	return _SUCCESS;
+}
+
+/**
+ * rtw_cbuf_pop - pop a pointer from cbuf
+ * @cbuf: pointer of struct rtw_cbuf
+ *
+ * Lock free operation, be careful of the use scheme
+ * Returns: pointer popped out
+ */
+void *rtw_cbuf_pop(struct rtw_cbuf *cbuf)
+{
+	void *buf;
+	if (rtw_cbuf_empty(cbuf))
+		return NULL;
+
+	if (0)
+		DBG_871X("%s on %u\n", __func__, cbuf->read);
+	buf = cbuf->bufs[cbuf->read];
+	cbuf->read = (cbuf->read+1)%cbuf->size;
+
+	return buf;
+}
+
+/**
+ * rtw_cbuf_alloc - allocte a rtw_cbuf with given size and do initialization
+ * @size: size of pointer
+ *
+ * Returns: pointer of srtuct rtw_cbuf, NULL for allocation failure
+ */
+struct rtw_cbuf *rtw_cbuf_alloc(u32 size)
+{
+	struct rtw_cbuf *cbuf;
+
+	cbuf = (struct rtw_cbuf *)rtw_malloc(sizeof(*cbuf) + sizeof(void*)*size);
+
+	if (cbuf) {
+		cbuf->write = cbuf->read = 0;
+		cbuf->size = size;
+	}
+
+	return cbuf;
+}
+
+/**
+ * rtw_cbuf_free - free the given rtw_cbuf
+ * @cbuf: pointer of struct rtw_cbuf to free
+ */
+void rtw_cbuf_free(struct rtw_cbuf *cbuf)
+{
+	rtw_mfree((u8*)cbuf, sizeof(*cbuf) + sizeof(void*)*cbuf->size);
+}
+
-- 
2.34.1

