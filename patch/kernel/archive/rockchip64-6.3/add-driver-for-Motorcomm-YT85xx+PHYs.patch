From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: baiywt <baiywt_gj@163.com>
Date: Fri, 18 Feb 2022 16:38:43 +0800
Subject: Add yt8531c support

note: rpardini: rebased on top of v6.3.1. drivers/net/phy/motorcomm.c was an overwrite,
and is now a diff.

Adapted from orangepi-xunlong/openwrt - 600-Add-yt8531c-support.patch by schwar3kat
---
 drivers/net/phy/Kconfig       |    5 +
 drivers/net/phy/motorcomm.c   | 3045 ++++------
 drivers/net/phy/yt8614-phy.h  |  491 ++
 include/linux/motorcomm_phy.h |  119 +
 4 files changed, 1803 insertions(+), 1857 deletions(-)

diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index 54874555c921..e4b1bcd23cf6 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -259,6 +259,11 @@ config MOTORCOMM_PHY
 	  Enables support for Motorcomm network PHYs.
 	  Currently supports YT85xx Gigabit Ethernet PHYs.
 
+config MOTORCOMM_PHY
+        tristate "Motorcomm PHYs"
+        help
+          Supports the YT8010, YT8510, YT8511, YT8512 YT8521 YT8531 PHYs.
+
 config NATIONAL_PHY
 	tristate "National Semiconductor PHYs"
 	help
diff --git a/drivers/net/phy/motorcomm.c b/drivers/net/phy/motorcomm.c
index 2fa5a90e073b..74eef3dfad3e 100644
--- a/drivers/net/phy/motorcomm.c
+++ b/drivers/net/phy/motorcomm.c
@@ -1,2209 +1,1540 @@
-// SPDX-License-Identifier: GPL-2.0+
 /*
- * Motorcomm 8511/8521/8531/8531S PHY driver.
+ * drivers/net/phy/motorcomm.c
  *
- * Author: Peter Geis <pgwipeout@gmail.com>
- * Author: Frank <Frank.Sae@motor-comm.com>
+ * Driver for Motorcomm PHYs
+ *
+ * Author: Leilei Zhao <leilei.zhao@motorcomm.com>
+ *
+ * Copyright (c) 2019 Motorcomm, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Support : Motorcomm Phys:
+ *		Giga phys: yt8511, yt8521
+ *		100/10 Phys : yt8512, yt8512b, yt8510
+ *		Automotive 100Mb Phys : yt8010
+ *		Automotive 100/10 hyper range Phys: yt8510
  */
 
-#include <linux/etherdevice.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/phy.h>
+#include <linux/motorcomm_phy.h>
 #include <linux/of.h>
-
-#define PHY_ID_YT8511		0x0000010a
-#define PHY_ID_YT8521		0x0000011a
-#define PHY_ID_YT8531		0x4f51e91b
-#define PHY_ID_YT8531S		0x4f51e91a
-
-/* YT8521/YT8531S Register Overview
- *	UTP Register space	|	FIBER Register space
- *  ------------------------------------------------------------
- * |	UTP MII			|	FIBER MII		|
- * |	UTP MMD			|				|
- * |	UTP Extended		|	FIBER Extended		|
- *  ------------------------------------------------------------
- * |			Common Extended				|
- *  ------------------------------------------------------------
+#include <linux/clk.h>
+#include <linux/delay.h>
+#ifndef LINUX_VERSION_CODE
+#include <linux/version.h>
+#else
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
+#endif
+/*for wol, 20210604*/
+#include <linux/netdevice.h>
+
+#include "yt8614-phy.h"
+
+/**** configuration section begin ***********/
+
+/* if system depends on ethernet packet to restore from sleep, please define this macro to 1
+ * otherwise, define it to 0.
  */
+#define SYS_WAKEUP_BASED_ON_ETH_PKT 	1
 
-/* 0x10 ~ 0x15 , 0x1E and 0x1F are common MII registers of yt phy */
-
-/* Specific Function Control Register */
-#define YTPHY_SPECIFIC_FUNCTION_CONTROL_REG	0x10
-
-/* 2b00 Manual MDI configuration
- * 2b01 Manual MDIX configuration
- * 2b10 Reserved
- * 2b11 Enable automatic crossover for all modes  *default*
- */
-#define YTPHY_SFCR_MDI_CROSSOVER_MODE_MASK	(BIT(6) | BIT(5))
-#define YTPHY_SFCR_CROSSOVER_EN			BIT(3)
-#define YTPHY_SFCR_SQE_TEST_EN			BIT(2)
-#define YTPHY_SFCR_POLARITY_REVERSAL_EN		BIT(1)
-#define YTPHY_SFCR_JABBER_DIS			BIT(0)
-
-/* Specific Status Register */
-#define YTPHY_SPECIFIC_STATUS_REG		0x11
-#define YTPHY_SSR_SPEED_MODE_OFFSET		14
-
-#define YTPHY_SSR_SPEED_MODE_MASK		(BIT(15) | BIT(14))
-#define YTPHY_SSR_SPEED_10M			0x0
-#define YTPHY_SSR_SPEED_100M			0x1
-#define YTPHY_SSR_SPEED_1000M			0x2
-#define YTPHY_SSR_DUPLEX_OFFSET			13
-#define YTPHY_SSR_DUPLEX			BIT(13)
-#define YTPHY_SSR_PAGE_RECEIVED			BIT(12)
-#define YTPHY_SSR_SPEED_DUPLEX_RESOLVED		BIT(11)
-#define YTPHY_SSR_LINK				BIT(10)
-#define YTPHY_SSR_MDIX_CROSSOVER		BIT(6)
-#define YTPHY_SSR_DOWNGRADE			BIT(5)
-#define YTPHY_SSR_TRANSMIT_PAUSE		BIT(3)
-#define YTPHY_SSR_RECEIVE_PAUSE			BIT(2)
-#define YTPHY_SSR_POLARITY			BIT(1)
-#define YTPHY_SSR_JABBER			BIT(0)
-
-/* Interrupt enable Register */
-#define YTPHY_INTERRUPT_ENABLE_REG		0x12
-#define YTPHY_IER_WOL				BIT(6)
-
-/* Interrupt Status Register */
-#define YTPHY_INTERRUPT_STATUS_REG		0x13
-#define YTPHY_ISR_AUTONEG_ERR			BIT(15)
-#define YTPHY_ISR_SPEED_CHANGED			BIT(14)
-#define YTPHY_ISR_DUPLEX_CHANGED		BIT(13)
-#define YTPHY_ISR_PAGE_RECEIVED			BIT(12)
-#define YTPHY_ISR_LINK_FAILED			BIT(11)
-#define YTPHY_ISR_LINK_SUCCESSED		BIT(10)
-#define YTPHY_ISR_WOL				BIT(6)
-#define YTPHY_ISR_WIRESPEED_DOWNGRADE		BIT(5)
-#define YTPHY_ISR_SERDES_LINK_FAILED		BIT(3)
-#define YTPHY_ISR_SERDES_LINK_SUCCESSED		BIT(2)
-#define YTPHY_ISR_POLARITY_CHANGED		BIT(1)
-#define YTPHY_ISR_JABBER_HAPPENED		BIT(0)
-
-/* Speed Auto Downgrade Control Register */
-#define YTPHY_SPEED_AUTO_DOWNGRADE_CONTROL_REG	0x14
-#define YTPHY_SADCR_SPEED_DOWNGRADE_EN		BIT(5)
-
-/* If these bits are set to 3, the PHY attempts five times ( 3(set value) +
- * additional 2) before downgrading, default 0x3
+/* to enable system WOL of phy, please define this macro to 1
+ * otherwise, define it to 0.
  */
-#define YTPHY_SADCR_SPEED_RETRY_LIMIT		(0x3 << 2)
+#define YTPHY_ENABLE_WOL 		0
 
-/* Rx Error Counter Register */
-#define YTPHY_RX_ERROR_COUNTER_REG		0x15
-
-/* Extended Register's Address Offset Register */
-#define YTPHY_PAGE_SELECT			0x1E
-
-/* Extended Register's Data Register */
-#define YTPHY_PAGE_DATA				0x1F
-
-/* FIBER Auto-Negotiation link partner ability */
-#define YTPHY_FLPA_PAUSE			(0x3 << 7)
-#define YTPHY_FLPA_ASYM_PAUSE			(0x2 << 7)
-
-#define YT8511_PAGE_SELECT	0x1e
-#define YT8511_PAGE		0x1f
-#define YT8511_EXT_CLK_GATE	0x0c
-#define YT8511_EXT_DELAY_DRIVE	0x0d
-#define YT8511_EXT_SLEEP_CTRL	0x27
-
-/* 2b00 25m from pll
- * 2b01 25m from xtl *default*
- * 2b10 62.m from pll
- * 2b11 125m from pll
+/* some GMAC need clock input from PHY, for eg., 125M, please enable this macro
+ * by degault, it is set to 0
+ * NOTE: this macro will need macro SYS_WAKEUP_BASED_ON_ETH_PKT to set to 1
  */
-#define YT8511_CLK_125M		(BIT(2) | BIT(1))
-#define YT8511_PLLON_SLP	BIT(14)
+#define GMAC_CLOCK_INPUT_NEEDED 1
 
-/* RX Delay enabled = 1.8ns 1000T, 8ns 10/100T */
-#define YT8511_DELAY_RX		BIT(0)
 
-/* TX Gig-E Delay is bits 7:4, default 0x5
- * TX Fast-E Delay is bits 15:12, default 0xf
- * Delay = 150ps * N - 250ps
- * On = 2000ps, off = 50ps
- */
-#define YT8511_DELAY_GE_TX_EN	(0xf << 4)
-#define YT8511_DELAY_GE_TX_DIS	(0x2 << 4)
-#define YT8511_DELAY_FE_TX_EN	(0xf << 12)
-#define YT8511_DELAY_FE_TX_DIS	(0x2 << 12)
-
-/* Extended register is different from MMD Register and MII Register.
- * We can use ytphy_read_ext/ytphy_write_ext/ytphy_modify_ext function to
- * operate extended register.
- * Extended Register  start
- */
+#define YT8521_PHY_MODE_FIBER	1 //fiber mode only
+#define YT8521_PHY_MODE_UTP		2 //utp mode only
+#define YT8521_PHY_MODE_POLL	3 //fiber and utp, poll mode
 
-/* Phy gmii clock gating Register */
-#define YT8521_CLOCK_GATING_REG			0xC
-#define YT8521_CGR_RX_CLK_EN			BIT(12)
+/* please make choice according to system design
+ * for Fiber only system, please define YT8521_PHY_MODE_CURR 1
+ * for UTP only system, please define YT8521_PHY_MODE_CURR 2
+ * for combo system, please define YT8521_PHY_MODE_CURR 3 
+ */
+#define YT8521_PHY_MODE_CURR	3
 
-#define YT8521_EXTREG_SLEEP_CONTROL1_REG	0x27
-#define YT8521_ESC1R_SLEEP_SW			BIT(15)
-#define YT8521_ESC1R_PLLON_SLP			BIT(14)
+/**** configuration section end ***********/
 
-/* Phy fiber Link timer cfg2 Register */
-#define YT8521_LINK_TIMER_CFG2_REG		0xA5
-#define YT8521_LTCR_EN_AUTOSEN			BIT(15)
 
-/* 0xA000, 0xA001, 0xA003, 0xA006 ~ 0xA00A and 0xA012 are common ext registers
- * of yt8521 phy. There is no need to switch reg space when operating these
- * registers.
- */
+/* no need to change below */
 
-#define YT8521_REG_SPACE_SELECT_REG		0xA000
-#define YT8521_RSSR_SPACE_MASK			BIT(1)
-#define YT8521_RSSR_FIBER_SPACE			(0x1 << 1)
-#define YT8521_RSSR_UTP_SPACE			(0x0 << 1)
-#define YT8521_RSSR_TO_BE_ARBITRATED		(0xFF)
+#if (YTPHY_ENABLE_WOL)
+#undef SYS_WAKEUP_BASED_ON_ETH_PKT
+#define SYS_WAKEUP_BASED_ON_ETH_PKT 	1
+#endif
 
-#define YT8521_CHIP_CONFIG_REG			0xA001
-#define YT8521_CCR_SW_RST			BIT(15)
-/* 1b0 disable 1.9ns rxc clock delay  *default*
- * 1b1 enable 1.9ns rxc clock delay
- */
-#define YT8521_CCR_RXC_DLY_EN			BIT(8)
-#define YT8521_CCR_RXC_DLY_1_900_NS		1900
-
-#define YT8521_CCR_MODE_SEL_MASK		(BIT(2) | BIT(1) | BIT(0))
-#define YT8521_CCR_MODE_UTP_TO_RGMII		0
-#define YT8521_CCR_MODE_FIBER_TO_RGMII		1
-#define YT8521_CCR_MODE_UTP_FIBER_TO_RGMII	2
-#define YT8521_CCR_MODE_UTP_TO_SGMII		3
-#define YT8521_CCR_MODE_SGPHY_TO_RGMAC		4
-#define YT8521_CCR_MODE_SGMAC_TO_RGPHY		5
-#define YT8521_CCR_MODE_UTP_TO_FIBER_AUTO	6
-#define YT8521_CCR_MODE_UTP_TO_FIBER_FORCE	7
-
-/* 3 phy polling modes,poll mode combines utp and fiber mode*/
-#define YT8521_MODE_FIBER			0x1
-#define YT8521_MODE_UTP				0x2
-#define YT8521_MODE_POLL			0x3
-
-#define YT8521_RGMII_CONFIG1_REG		0xA003
-/* 1b0 use original tx_clk_rgmii  *default*
- * 1b1 use inverted tx_clk_rgmii.
- */
-#define YT8521_RC1R_TX_CLK_SEL_INVERTED		BIT(14)
-#define YT8521_RC1R_RX_DELAY_MASK		GENMASK(13, 10)
-#define YT8521_RC1R_FE_TX_DELAY_MASK		GENMASK(7, 4)
-#define YT8521_RC1R_GE_TX_DELAY_MASK		GENMASK(3, 0)
-#define YT8521_RC1R_RGMII_0_000_NS		0
-#define YT8521_RC1R_RGMII_0_150_NS		1
-#define YT8521_RC1R_RGMII_0_300_NS		2
-#define YT8521_RC1R_RGMII_0_450_NS		3
-#define YT8521_RC1R_RGMII_0_600_NS		4
-#define YT8521_RC1R_RGMII_0_750_NS		5
-#define YT8521_RC1R_RGMII_0_900_NS		6
-#define YT8521_RC1R_RGMII_1_050_NS		7
-#define YT8521_RC1R_RGMII_1_200_NS		8
-#define YT8521_RC1R_RGMII_1_350_NS		9
-#define YT8521_RC1R_RGMII_1_500_NS		10
-#define YT8521_RC1R_RGMII_1_650_NS		11
-#define YT8521_RC1R_RGMII_1_800_NS		12
-#define YT8521_RC1R_RGMII_1_950_NS		13
-#define YT8521_RC1R_RGMII_2_100_NS		14
-#define YT8521_RC1R_RGMII_2_250_NS		15
-
-#define YTPHY_MISC_CONFIG_REG			0xA006
-#define YTPHY_MCR_FIBER_SPEED_MASK		BIT(0)
-#define YTPHY_MCR_FIBER_1000BX			(0x1 << 0)
-#define YTPHY_MCR_FIBER_100FX			(0x0 << 0)
-
-/* WOL MAC ADDR: MACADDR2(highest), MACADDR1(middle), MACADDR0(lowest) */
-#define YTPHY_WOL_MACADDR2_REG			0xA007
-#define YTPHY_WOL_MACADDR1_REG			0xA008
-#define YTPHY_WOL_MACADDR0_REG			0xA009
-
-#define YTPHY_WOL_CONFIG_REG			0xA00A
-#define YTPHY_WCR_INTR_SEL			BIT(6)
-#define YTPHY_WCR_ENABLE			BIT(3)
-
-/* 2b00 84ms
- * 2b01 168ms  *default*
- * 2b10 336ms
- * 2b11 672ms
- */
-#define YTPHY_WCR_PULSE_WIDTH_MASK		(BIT(2) | BIT(1))
-#define YTPHY_WCR_PULSE_WIDTH_672MS		(BIT(2) | BIT(1))
+/* workaround for 8521 fiber 100m mode */
+static int link_mode_8521 = 0; //0: no link; 1: utp; 32: fiber. traced that 1000m fiber uses 32.
+static int link_mode_8614[4] = {0}; //0: no link; 1: utp; 32: fiber. traced that 1000m fiber uses 32.
 
-/* 1b0 Interrupt and WOL events is level triggered and active LOW  *default*
- * 1b1 Interrupt and WOL events is pulse triggered and active LOW
- */
-#define YTPHY_WCR_TYPE_PULSE			BIT(0)
+/* for multiple port phy, base phy address */
+static unsigned int yt_mport_base_phy_addr = 0xff; //0xff: invalid; for 8618
+static unsigned int yt_mport_base_phy_addr_8614 = 0xff; //0xff: invalid;
 
-#define YTPHY_SYNCE_CFG_REG			0xA012
-#define YT8521_SCR_SYNCE_ENABLE			BIT(5)
-/* 1b0 output 25m clock
- * 1b1 output 125m clock  *default*
- */
-#define YT8521_SCR_CLK_FRE_SEL_125M		BIT(3)
-#define YT8521_SCR_CLK_SRC_MASK			GENMASK(2, 1)
-#define YT8521_SCR_CLK_SRC_PLL_125M		0
-#define YT8521_SCR_CLK_SRC_UTP_RX		1
-#define YT8521_SCR_CLK_SRC_SDS_RX		2
-#define YT8521_SCR_CLK_SRC_REF_25M		3
-#define YT8531_SCR_SYNCE_ENABLE			BIT(6)
-/* 1b0 output 25m clock   *default*
- * 1b1 output 125m clock
- */
-#define YT8531_SCR_CLK_FRE_SEL_125M		BIT(4)
-#define YT8531_SCR_CLK_SRC_MASK			GENMASK(3, 1)
-#define YT8531_SCR_CLK_SRC_PLL_125M		0
-#define YT8531_SCR_CLK_SRC_UTP_RX		1
-#define YT8531_SCR_CLK_SRC_SDS_RX		2
-#define YT8531_SCR_CLK_SRC_CLOCK_FROM_DIGITAL	3
-#define YT8531_SCR_CLK_SRC_REF_25M		4
-#define YT8531_SCR_CLK_SRC_SSC_25M		5
-
-/* Extended Register  end */
-
-#define YTPHY_DTS_OUTPUT_CLK_DIS		0
-#define YTPHY_DTS_OUTPUT_CLK_25M		25000000
-#define YTPHY_DTS_OUTPUT_CLK_125M		125000000
-
-struct yt8521_priv {
-	/* combo_advertising is used for case of YT8521 in combo mode,
-	 * this means that yt8521 may work in utp or fiber mode which depends
-	 * on which media is connected (YT8521_RSSR_TO_BE_ARBITRATED).
-	 */
-	__ETHTOOL_DECLARE_LINK_MODE_MASK(combo_advertising);
-
-	/* YT8521_MODE_FIBER / YT8521_MODE_UTP / YT8521_MODE_POLL*/
-	u8 polling_mode;
-	u8 strap_mode; /* 8 working modes  */
-	/* current reg page of yt8521 phy:
-	 * YT8521_RSSR_UTP_SPACE
-	 * YT8521_RSSR_FIBER_SPACE
-	 * YT8521_RSSR_TO_BE_ARBITRATED
-	 */
-	u8 reg_page;
-};
+int phy_yt8531_led_fixup(struct mii_bus *bus, int addr);
+int yt8511_config_out_125m(struct mii_bus *bus, int phy_id);
 
-/**
- * ytphy_read_ext() - read a PHY's extended register
- * @phydev: a pointer to a &struct phy_device
- * @regnum: register number to read
- *
- * NOTE:The caller must have taken the MDIO bus lock.
- *
- * returns the value of regnum reg or negative error code
- */
-static int ytphy_read_ext(struct phy_device *phydev, u16 regnum)
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(5,0,0) )
+int genphy_config_init(struct phy_device *phydev)
 {
 	int ret;
 
-	ret = __phy_write(phydev, YTPHY_PAGE_SELECT, regnum);
-	if (ret < 0)
-		return ret;
+	printk (KERN_INFO "yzhang..read phyaddr=%d, phyid=%08x\n",phydev->mdio.addr, phydev->phy_id);
+
+	if(phydev->phy_id == 0x4f51e91b)
+	{
+		printk (KERN_INFO "yzhang..get YT8511, abt to set 125m clk out, phyaddr=%d, phyid=%08x\n",phydev->mdio.addr, phydev->phy_id);
+		ret = yt8511_config_out_125m(phydev->mdio.bus, phydev->mdio.addr);
+		printk (KERN_INFO "yzhang..8511 set 125m clk out, reg=%#04x\n",phydev->mdio.bus->read(phydev->mdio.bus,phydev->mdio.addr,0x1f)/*double check as delay*/);
+		if (ret<0)
+			printk (KERN_INFO "yzhang..failed to set 125m clk out, ret=%d\n",ret);
 
-	return __phy_read(phydev, YTPHY_PAGE_DATA);
+		phy_yt8531_led_fixup(phydev->mdio.bus, phydev->mdio.addr);
+	}
+	return  genphy_read_abilities(phydev);
 }
+#endif
 
-/**
- * ytphy_read_ext_with_lock() - read a PHY's extended register
- * @phydev: a pointer to a &struct phy_device
- * @regnum: register number to read
- *
- * returns the value of regnum reg or negative error code
- */
-static int ytphy_read_ext_with_lock(struct phy_device *phydev, u16 regnum)
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+static int ytphy_config_init(struct phy_device *phydev)
 {
-	int ret;
-
-	phy_lock_mdio_bus(phydev);
-	ret = ytphy_read_ext(phydev, regnum);
-	phy_unlock_mdio_bus(phydev);
-
-	return ret;
+	return 0;
 }
+#endif
 
-/**
- * ytphy_write_ext() - write a PHY's extended register
- * @phydev: a pointer to a &struct phy_device
- * @regnum: register number to write
- * @val: value to write to @regnum
- *
- * NOTE:The caller must have taken the MDIO bus lock.
- *
- * returns 0 or negative error code
- */
-static int ytphy_write_ext(struct phy_device *phydev, u16 regnum, u16 val)
+static int ytphy_read_ext(struct phy_device *phydev, u32 regnum)
 {
 	int ret;
+	int val;
 
-	ret = __phy_write(phydev, YTPHY_PAGE_SELECT, regnum);
+	ret = phy_write(phydev, REG_DEBUG_ADDR_OFFSET, regnum);
 	if (ret < 0)
 		return ret;
 
-	return __phy_write(phydev, YTPHY_PAGE_DATA, val);
+	val = phy_read(phydev, REG_DEBUG_DATA);
+
+	return val;
 }
 
-/**
- * ytphy_write_ext_with_lock() - write a PHY's extended register
- * @phydev: a pointer to a &struct phy_device
- * @regnum: register number to write
- * @val: value to write to @regnum
- *
- * returns 0 or negative error code
- */
-static int ytphy_write_ext_with_lock(struct phy_device *phydev, u16 regnum,
-				     u16 val)
+static int ytphy_write_ext(struct phy_device *phydev, u32 regnum, u16 val)
 {
 	int ret;
 
-	phy_lock_mdio_bus(phydev);
-	ret = ytphy_write_ext(phydev, regnum, val);
-	phy_unlock_mdio_bus(phydev);
+	ret = phy_write(phydev, REG_DEBUG_ADDR_OFFSET, regnum);
+	if (ret < 0)
+		return ret;
+
+	ret = phy_write(phydev, REG_DEBUG_DATA, val);
 
 	return ret;
 }
 
-/**
- * ytphy_modify_ext() - bits modify a PHY's extended register
- * @phydev: a pointer to a &struct phy_device
- * @regnum: register number to write
- * @mask: bit mask of bits to clear
- * @set: bit mask of bits to set
- *
- * NOTE: Convenience function which allows a PHY's extended register to be
- * modified as new register value = (old register value & ~mask) | set.
- * The caller must have taken the MDIO bus lock.
- *
- * returns 0 or negative error code
- */
-static int ytphy_modify_ext(struct phy_device *phydev, u16 regnum, u16 mask,
-			    u16 set)
+static int yt8010_config_aneg(struct phy_device *phydev)
 {
-	int ret;
-
-	ret = __phy_write(phydev, YTPHY_PAGE_SELECT, regnum);
-	if (ret < 0)
-		return ret;
-
-	return __phy_modify(phydev, YTPHY_PAGE_DATA, mask, set);
+	phydev->speed = SPEED_100;
+	return 0;
 }
 
-/**
- * ytphy_modify_ext_with_lock() - bits modify a PHY's extended register
- * @phydev: a pointer to a &struct phy_device
- * @regnum: register number to write
- * @mask: bit mask of bits to clear
- * @set: bit mask of bits to set
- *
- * NOTE: Convenience function which allows a PHY's extended register to be
- * modified as new register value = (old register value & ~mask) | set.
- *
- * returns 0 or negative error code
- */
-static int ytphy_modify_ext_with_lock(struct phy_device *phydev, u16 regnum,
-				      u16 mask, u16 set)
+static int yt8512_clk_init(struct phy_device *phydev)
 {
 	int ret;
+	int val;
+
+	val = ytphy_read_ext(phydev, YT8512_EXTREG_AFE_PLL);
+	if (val < 0)
+		return val;
 
-	phy_lock_mdio_bus(phydev);
-	ret = ytphy_modify_ext(phydev, regnum, mask, set);
-	phy_unlock_mdio_bus(phydev);
+	val |= YT8512_CONFIG_PLL_REFCLK_SEL_EN;
 
-	return ret;
-}
+	ret = ytphy_write_ext(phydev, YT8512_EXTREG_AFE_PLL, val);
+	if (ret < 0)
+		return ret;
 
-/**
- * ytphy_get_wol() - report whether wake-on-lan is enabled
- * @phydev: a pointer to a &struct phy_device
- * @wol: a pointer to a &struct ethtool_wolinfo
- *
- * NOTE: YTPHY_WOL_CONFIG_REG is common ext reg.
- */
-static void ytphy_get_wol(struct phy_device *phydev,
-			  struct ethtool_wolinfo *wol)
-{
-	int wol_config;
+	val = ytphy_read_ext(phydev, YT8512_EXTREG_EXTEND_COMBO);
+	if (val < 0)
+		return val;
 
-	wol->supported = WAKE_MAGIC;
-	wol->wolopts = 0;
+	val |= YT8512_CONTROL1_RMII_EN;
 
-	wol_config = ytphy_read_ext_with_lock(phydev, YTPHY_WOL_CONFIG_REG);
-	if (wol_config < 0)
-		return;
+	ret = ytphy_write_ext(phydev, YT8512_EXTREG_EXTEND_COMBO, val);
+	if (ret < 0)
+		return ret;
 
-	if (wol_config & YTPHY_WCR_ENABLE)
-		wol->wolopts |= WAKE_MAGIC;
+	val = phy_read(phydev, MII_BMCR);
+	if (val < 0)
+		return val;
+
+	val |= YT_SOFTWARE_RESET;
+	ret = phy_write(phydev, MII_BMCR, val);
+
+	return ret;
 }
 
-/**
- * ytphy_set_wol() - turn wake-on-lan on or off
- * @phydev: a pointer to a &struct phy_device
- * @wol: a pointer to a &struct ethtool_wolinfo
- *
- * NOTE: YTPHY_WOL_CONFIG_REG, YTPHY_WOL_MACADDR2_REG, YTPHY_WOL_MACADDR1_REG
- * and YTPHY_WOL_MACADDR0_REG are common ext reg. The
- * YTPHY_INTERRUPT_ENABLE_REG of UTP is special, fiber also use this register.
- *
- * returns 0 or negative errno code
- */
-static int ytphy_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)
+static int yt8512_led_init(struct phy_device *phydev)
 {
-	struct net_device *p_attached_dev;
-	const u16 mac_addr_reg[] = {
-		YTPHY_WOL_MACADDR2_REG,
-		YTPHY_WOL_MACADDR1_REG,
-		YTPHY_WOL_MACADDR0_REG,
-	};
-	const u8 *mac_addr;
-	int old_page;
-	int ret = 0;
-	u16 mask;
-	u16 val;
-	u8 i;
-
-	if (wol->wolopts & WAKE_MAGIC) {
-		p_attached_dev = phydev->attached_dev;
-		if (!p_attached_dev)
-			return -ENODEV;
+	int ret;
+	int val;
+	int mask;
 
-		mac_addr = (const u8 *)p_attached_dev->dev_addr;
-		if (!is_valid_ether_addr(mac_addr))
-			return -EINVAL;
+	val = ytphy_read_ext(phydev, YT8512_EXTREG_LED0);
+	if (val < 0)
+		return val;
 
-		/* lock mdio bus then switch to utp reg space */
-		old_page = phy_select_page(phydev, YT8521_RSSR_UTP_SPACE);
-		if (old_page < 0)
-			goto err_restore_page;
+	val |= YT8512_LED0_ACT_BLK_IND;
 
-		/* Store the device address for the magic packet */
-		for (i = 0; i < 3; i++) {
-			ret = ytphy_write_ext(phydev, mac_addr_reg[i],
-					      ((mac_addr[i * 2] << 8)) |
-						      (mac_addr[i * 2 + 1]));
-			if (ret < 0)
-				goto err_restore_page;
-		}
+	mask = YT8512_LED0_DIS_LED_AN_TRY | YT8512_LED0_BT_BLK_EN |
+		YT8512_LED0_HT_BLK_EN | YT8512_LED0_COL_BLK_EN |
+		YT8512_LED0_BT_ON_EN;
+	val &= ~mask;
 
-		/* Enable WOL feature */
-		mask = YTPHY_WCR_PULSE_WIDTH_MASK | YTPHY_WCR_INTR_SEL;
-		val = YTPHY_WCR_ENABLE | YTPHY_WCR_INTR_SEL;
-		val |= YTPHY_WCR_TYPE_PULSE | YTPHY_WCR_PULSE_WIDTH_672MS;
-		ret = ytphy_modify_ext(phydev, YTPHY_WOL_CONFIG_REG, mask, val);
-		if (ret < 0)
-			goto err_restore_page;
+	ret = ytphy_write_ext(phydev, YT8512_EXTREG_LED0, val);
+	if (ret < 0)
+		return ret;
 
-		/* Enable WOL interrupt */
-		ret = __phy_modify(phydev, YTPHY_INTERRUPT_ENABLE_REG, 0,
-				   YTPHY_IER_WOL);
-		if (ret < 0)
-			goto err_restore_page;
+	val = ytphy_read_ext(phydev, YT8512_EXTREG_LED1);
+	if (val < 0)
+		return val;
 
-	} else {
-		old_page = phy_select_page(phydev, YT8521_RSSR_UTP_SPACE);
-		if (old_page < 0)
-			goto err_restore_page;
+	val |= YT8512_LED1_BT_ON_EN;
 
-		/* Disable WOL feature */
-		mask = YTPHY_WCR_ENABLE | YTPHY_WCR_INTR_SEL;
-		ret = ytphy_modify_ext(phydev, YTPHY_WOL_CONFIG_REG, mask, 0);
+	mask = YT8512_LED1_TXACT_BLK_EN | YT8512_LED1_RXACT_BLK_EN;
+	val &= ~mask;
 
-		/* Disable WOL interrupt */
-		ret = __phy_modify(phydev, YTPHY_INTERRUPT_ENABLE_REG,
-				   YTPHY_IER_WOL, 0);
-		if (ret < 0)
-			goto err_restore_page;
-	}
+	ret = ytphy_write_ext(phydev, YT8512_LED1_BT_ON_EN, val);
 
-err_restore_page:
-	return phy_restore_page(phydev, old_page, ret);
+	return ret;
 }
 
-static int yt8531_set_wol(struct phy_device *phydev,
-			  struct ethtool_wolinfo *wol)
+static int yt8512_config_init(struct phy_device *phydev)
 {
-	const u16 mac_addr_reg[] = {
-		YTPHY_WOL_MACADDR2_REG,
-		YTPHY_WOL_MACADDR1_REG,
-		YTPHY_WOL_MACADDR0_REG,
-	};
-	const u8 *mac_addr;
-	u16 mask, val;
 	int ret;
-	u8 i;
+	int val;
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	ret = ytphy_config_init(phydev);
+#else
+	ret = genphy_config_init(phydev);
+#endif
+	if (ret < 0)
+		return ret;
 
-	if (wol->wolopts & WAKE_MAGIC) {
-		mac_addr = phydev->attached_dev->dev_addr;
+	ret = yt8512_clk_init(phydev);
+	if (ret < 0)
+		return ret;
 
-		/* Store the device address for the magic packet */
-		for (i = 0; i < 3; i++) {
-			ret = ytphy_write_ext_with_lock(phydev, mac_addr_reg[i],
-							((mac_addr[i * 2] << 8)) |
-							(mac_addr[i * 2 + 1]));
-			if (ret < 0)
-				return ret;
-		}
+	ret = yt8512_led_init(phydev);
 
-		/* Enable WOL feature */
-		mask = YTPHY_WCR_PULSE_WIDTH_MASK | YTPHY_WCR_INTR_SEL;
-		val = YTPHY_WCR_ENABLE | YTPHY_WCR_INTR_SEL;
-		val |= YTPHY_WCR_TYPE_PULSE | YTPHY_WCR_PULSE_WIDTH_672MS;
-		ret = ytphy_modify_ext_with_lock(phydev, YTPHY_WOL_CONFIG_REG,
-						 mask, val);
-		if (ret < 0)
-			return ret;
+	/* disable auto sleep */
+	val = ytphy_read_ext(phydev, YT8512_EXTREG_SLEEP_CONTROL1);
+	if (val < 0)
+		return val;
 
-		/* Enable WOL interrupt */
-		ret = phy_modify(phydev, YTPHY_INTERRUPT_ENABLE_REG, 0,
-				 YTPHY_IER_WOL);
-		if (ret < 0)
-			return ret;
-	} else {
-		/* Disable WOL feature */
-		mask = YTPHY_WCR_ENABLE | YTPHY_WCR_INTR_SEL;
-		ret = ytphy_modify_ext_with_lock(phydev, YTPHY_WOL_CONFIG_REG,
-						 mask, 0);
-
-		/* Disable WOL interrupt */
-		ret = phy_modify(phydev, YTPHY_INTERRUPT_ENABLE_REG,
-				 YTPHY_IER_WOL, 0);
-		if (ret < 0)
-			return ret;
-	}
+	val &= (~BIT(YT8512_EN_SLEEP_SW_BIT));
 
-	return 0;
+	ret = ytphy_write_ext(phydev, YT8512_EXTREG_SLEEP_CONTROL1, val);
+	if (ret < 0)
+		return ret;
+
+	return ret;
 }
 
-static int yt8511_read_page(struct phy_device *phydev)
+static int yt8512_read_status(struct phy_device *phydev)
 {
-	return __phy_read(phydev, YT8511_PAGE_SELECT);
-};
+	int ret;
+	int val;
+	int speed, speed_mode, duplex;
 
-static int yt8511_write_page(struct phy_device *phydev, int page)
-{
-	return __phy_write(phydev, YT8511_PAGE_SELECT, page);
-};
+	ret = genphy_update_link(phydev);
+	if (ret)
+		return ret;
 
-static int yt8511_config_init(struct phy_device *phydev)
-{
-	int oldpage, ret = 0;
-	unsigned int ge, fe;
-
-	oldpage = phy_select_page(phydev, YT8511_EXT_CLK_GATE);
-	if (oldpage < 0)
-		goto err_restore_page;
-
-	/* set rgmii delay mode */
-	switch (phydev->interface) {
-	case PHY_INTERFACE_MODE_RGMII:
-		ge = YT8511_DELAY_GE_TX_DIS;
-		fe = YT8511_DELAY_FE_TX_DIS;
-		break;
-	case PHY_INTERFACE_MODE_RGMII_RXID:
-		ge = YT8511_DELAY_RX | YT8511_DELAY_GE_TX_DIS;
-		fe = YT8511_DELAY_FE_TX_DIS;
+	val = phy_read(phydev, REG_PHY_SPEC_STATUS);
+	if (val < 0)
+		return val;
+
+	duplex = (val & YT8512_DUPLEX) >> YT8512_DUPLEX_BIT;
+	speed_mode = (val & YT8512_SPEED_MODE) >> YT8512_SPEED_MODE_BIT;
+	switch (speed_mode) {
+	case 0:
+		speed = SPEED_10;
 		break;
-	case PHY_INTERFACE_MODE_RGMII_TXID:
-		ge = YT8511_DELAY_GE_TX_EN;
-		fe = YT8511_DELAY_FE_TX_EN;
+	case 1:
+		speed = SPEED_100;
 		break;
-	case PHY_INTERFACE_MODE_RGMII_ID:
-		ge = YT8511_DELAY_RX | YT8511_DELAY_GE_TX_EN;
-		fe = YT8511_DELAY_FE_TX_EN;
+	case 2:
+	case 3:
+	default:
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+		speed = -1;
+#else
+		speed = SPEED_UNKNOWN;
+#endif
 		break;
-	default: /* do not support other modes */
-		ret = -EOPNOTSUPP;
-		goto err_restore_page;
 	}
 
-	ret = __phy_modify(phydev, YT8511_PAGE, (YT8511_DELAY_RX | YT8511_DELAY_GE_TX_EN), ge);
-	if (ret < 0)
-		goto err_restore_page;
+	phydev->speed = speed;
+	phydev->duplex = duplex;
 
-	/* set clock mode to 125mhz */
-	ret = __phy_modify(phydev, YT8511_PAGE, 0, YT8511_CLK_125M);
-	if (ret < 0)
-		goto err_restore_page;
+	return 0;
+}
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#else
+#if 0
+int yt8521_soft_reset(struct phy_device *phydev)
+{
+	int ret;
 
-	/* fast ethernet delay is in a separate page */
-	ret = __phy_write(phydev, YT8511_PAGE_SELECT, YT8511_EXT_DELAY_DRIVE);
+	ytphy_write_ext(phydev, 0xa000, 0);
+	ret = genphy_soft_reset(phydev);
 	if (ret < 0)
-		goto err_restore_page;
+		return ret;
 
-	ret = __phy_modify(phydev, YT8511_PAGE, YT8511_DELAY_FE_TX_EN, fe);
-	if (ret < 0)
-		goto err_restore_page;
+	ytphy_write_ext(phydev, 0xa000, 2);
+	ret = genphy_soft_reset(phydev);
+	if (ret < 0) {
+		ytphy_write_ext(phydev, 0xa000, 0);
+		return ret;
+	}
 
-	/* leave pll enabled in sleep */
-	ret = __phy_write(phydev, YT8511_PAGE_SELECT, YT8511_EXT_SLEEP_CTRL);
-	if (ret < 0)
-		goto err_restore_page;
+	return 0;
+}
+#else
+/* qingsong feedback 2 genphy_soft_reset will cause problem.
+ * and this is the reduction version
+ */
+int yt8521_soft_reset(struct phy_device *phydev)
+{
+	int ret, val;
+
+	val = ytphy_read_ext(phydev, 0xa001);
+	ytphy_write_ext(phydev, 0xa001, (val & ~0x8000));
 
-	ret = __phy_modify(phydev, YT8511_PAGE, 0, YT8511_PLLON_SLP);
+	ret = genphy_soft_reset(phydev);
 	if (ret < 0)
-		goto err_restore_page;
+		return ret;
 
-err_restore_page:
-	return phy_restore_page(phydev, oldpage, ret);
+	return 0;
 }
+#endif
 
-/**
- * yt8521_read_page() - read reg page
- * @phydev: a pointer to a &struct phy_device
- *
- * returns current reg space of yt8521 (YT8521_RSSR_FIBER_SPACE/
- * YT8521_RSSR_UTP_SPACE) or negative errno code
- */
-static int yt8521_read_page(struct phy_device *phydev)
+#endif
+
+#if GMAC_CLOCK_INPUT_NEEDED
+static int ytphy_mii_rd_ext(struct mii_bus *bus, int phy_id, u32 regnum)
 {
-	int old_page;
+	int ret;
+	int val;
 
-	old_page = ytphy_read_ext(phydev, YT8521_REG_SPACE_SELECT_REG);
-	if (old_page < 0)
-		return old_page;
+	ret = bus->write(bus, phy_id, REG_DEBUG_ADDR_OFFSET, regnum);
+	if (ret < 0)
+		return ret;
 
-	if ((old_page & YT8521_RSSR_SPACE_MASK) == YT8521_RSSR_FIBER_SPACE)
-		return YT8521_RSSR_FIBER_SPACE;
+	val = bus->read(bus, phy_id, REG_DEBUG_DATA);
 
-	return YT8521_RSSR_UTP_SPACE;
-};
+	return val;
+}
 
-/**
- * yt8521_write_page() - write reg page
- * @phydev: a pointer to a &struct phy_device
- * @page: The reg page(YT8521_RSSR_FIBER_SPACE/YT8521_RSSR_UTP_SPACE) to write.
- *
- * returns 0 or negative errno code
- */
-static int yt8521_write_page(struct phy_device *phydev, int page)
+static int ytphy_mii_wr_ext(struct mii_bus *bus, int phy_id, u32 regnum, u16 val)
 {
-	int mask = YT8521_RSSR_SPACE_MASK;
-	int set;
-
-	if ((page & YT8521_RSSR_SPACE_MASK) == YT8521_RSSR_FIBER_SPACE)
-		set = YT8521_RSSR_FIBER_SPACE;
-	else
-		set = YT8521_RSSR_UTP_SPACE;
+	int ret;
 
-	return ytphy_modify_ext(phydev, YT8521_REG_SPACE_SELECT_REG, mask, set);
-};
+	ret = bus->write(bus, phy_id, REG_DEBUG_ADDR_OFFSET, regnum);
+	if (ret < 0)
+		return ret;
 
-/**
- * struct ytphy_cfg_reg_map - map a config value to a register value
- * @cfg: value in device configuration
- * @reg: value in the register
- */
-struct ytphy_cfg_reg_map {
-	u32 cfg;
-	u32 reg;
-};
+	ret = bus->write(bus, phy_id, REG_DEBUG_DATA, val);
 
-static const struct ytphy_cfg_reg_map ytphy_rgmii_delays[] = {
-	/* for tx delay / rx delay with YT8521_CCR_RXC_DLY_EN is not set. */
-	{ 0,	YT8521_RC1R_RGMII_0_000_NS },
-	{ 150,	YT8521_RC1R_RGMII_0_150_NS },
-	{ 300,	YT8521_RC1R_RGMII_0_300_NS },
-	{ 450,	YT8521_RC1R_RGMII_0_450_NS },
-	{ 600,	YT8521_RC1R_RGMII_0_600_NS },
-	{ 750,	YT8521_RC1R_RGMII_0_750_NS },
-	{ 900,	YT8521_RC1R_RGMII_0_900_NS },
-	{ 1050,	YT8521_RC1R_RGMII_1_050_NS },
-	{ 1200,	YT8521_RC1R_RGMII_1_200_NS },
-	{ 1350,	YT8521_RC1R_RGMII_1_350_NS },
-	{ 1500,	YT8521_RC1R_RGMII_1_500_NS },
-	{ 1650,	YT8521_RC1R_RGMII_1_650_NS },
-	{ 1800,	YT8521_RC1R_RGMII_1_800_NS },
-	{ 1950,	YT8521_RC1R_RGMII_1_950_NS },	/* default tx/rx delay */
-	{ 2100,	YT8521_RC1R_RGMII_2_100_NS },
-	{ 2250,	YT8521_RC1R_RGMII_2_250_NS },
-
-	/* only for rx delay with YT8521_CCR_RXC_DLY_EN is set. */
-	{ 0    + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_0_000_NS },
-	{ 150  + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_0_150_NS },
-	{ 300  + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_0_300_NS },
-	{ 450  + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_0_450_NS },
-	{ 600  + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_0_600_NS },
-	{ 750  + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_0_750_NS },
-	{ 900  + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_0_900_NS },
-	{ 1050 + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_1_050_NS },
-	{ 1200 + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_1_200_NS },
-	{ 1350 + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_1_350_NS },
-	{ 1500 + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_1_500_NS },
-	{ 1650 + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_1_650_NS },
-	{ 1800 + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_1_800_NS },
-	{ 1950 + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_1_950_NS },
-	{ 2100 + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_2_100_NS },
-	{ 2250 + YT8521_CCR_RXC_DLY_1_900_NS,	YT8521_RC1R_RGMII_2_250_NS }
-};
+	return ret;
+}
 
-static u32 ytphy_get_delay_reg_value(struct phy_device *phydev,
-				     const char *prop_name,
-				     const struct ytphy_cfg_reg_map *tbl,
-				     int tb_size,
-				     u16 *rxc_dly_en,
-				     u32 dflt)
+int yt8511_config_dis_txdelay(struct mii_bus *bus, int phy_id)
 {
-	struct device_node *node = phydev->mdio.dev.of_node;
-	int tb_size_half = tb_size / 2;
-	u32 val;
-	int i;
+    int ret;
+    int val;
 
-	if (of_property_read_u32(node, prop_name, &val))
-		goto err_dts_val;
+    /* disable auto sleep */
+    val = ytphy_mii_rd_ext(bus, phy_id, 0x27);
+    if (val < 0)
+            return val;
 
-	/* when rxc_dly_en is NULL, it is get the delay for tx, only half of
-	 * tb_size is valid.
-	 */
-	if (!rxc_dly_en)
-		tb_size = tb_size_half;
+    val &= (~BIT(15));
 
-	for (i = 0; i < tb_size; i++) {
-		if (tbl[i].cfg == val) {
-			if (rxc_dly_en && i < tb_size_half)
-				*rxc_dly_en = 0;
-			return tbl[i].reg;
-		}
-	}
+    ret = ytphy_mii_wr_ext(bus, phy_id, 0x27, val);
+    if (ret < 0)
+            return ret;
 
-	phydev_warn(phydev, "Unsupported value %d for %s using default (%u)\n",
-		    val, prop_name, dflt);
+    /* enable RXC clock when no wire plug */
+    val = ytphy_mii_rd_ext(bus, phy_id, 0xc);
+    if (val < 0)
+            return val;
 
-err_dts_val:
-	/* when rxc_dly_en is not NULL, it is get the delay for rx.
-	 * The rx default in dts and ytphy_rgmii_clk_delay_config is 1950 ps,
-	 * so YT8521_CCR_RXC_DLY_EN should not be set.
-	 */
-	if (rxc_dly_en)
-		*rxc_dly_en = 0;
+    /* ext reg 0xc b[7:4]
+	Tx Delay time = 150ps * N - 250ps
+    */
+    val &= ~(0xf << 4);
+    ret = ytphy_mii_wr_ext(bus, phy_id, 0xc, val);
+    printk("yt8511_config_dis_txdelay..phy txdelay, val=%#08x\n",val);
 
-	return dflt;
+    return ret;
 }
 
-static int ytphy_rgmii_clk_delay_config(struct phy_device *phydev)
+int phy_yt8531_led_fixup(struct mii_bus *bus, int addr)
+{
+	printk("%s in\n", __func__);
+
+	ytphy_mii_wr_ext(bus, addr, 0xa00d, 0x670);
+	ytphy_mii_wr_ext(bus, addr, 0xa00e, 0x2070);
+	ytphy_mii_wr_ext(bus, addr, 0xa00f, 0x7e);
+
+	return 0;
+}
+
+int yt8511_config_out_125m(struct mii_bus *bus, int addr)
 {
-	int tb_size = ARRAY_SIZE(ytphy_rgmii_delays);
-	u16 rxc_dly_en = YT8521_CCR_RXC_DLY_EN;
-	u32 rx_reg, tx_reg;
-	u16 mask, val = 0;
 	int ret;
+	int val;
 
-	rx_reg = ytphy_get_delay_reg_value(phydev, "rx-internal-delay-ps",
-					   ytphy_rgmii_delays, tb_size,
-					   &rxc_dly_en,
-					   YT8521_RC1R_RGMII_1_950_NS);
-	tx_reg = ytphy_get_delay_reg_value(phydev, "tx-internal-delay-ps",
-					   ytphy_rgmii_delays, tb_size, NULL,
-					   YT8521_RC1R_RGMII_1_950_NS);
-
-	switch (phydev->interface) {
-	case PHY_INTERFACE_MODE_RGMII:
-		rxc_dly_en = 0;
-		break;
-	case PHY_INTERFACE_MODE_RGMII_RXID:
-		val |= FIELD_PREP(YT8521_RC1R_RX_DELAY_MASK, rx_reg);
-		break;
-	case PHY_INTERFACE_MODE_RGMII_TXID:
-		rxc_dly_en = 0;
-		val |= FIELD_PREP(YT8521_RC1R_GE_TX_DELAY_MASK, tx_reg);
-		break;
-	case PHY_INTERFACE_MODE_RGMII_ID:
-		val |= FIELD_PREP(YT8521_RC1R_RX_DELAY_MASK, rx_reg) |
-		       FIELD_PREP(YT8521_RC1R_GE_TX_DELAY_MASK, tx_reg);
-		break;
-	default: /* do not support other modes */
-		return -EOPNOTSUPP;
+	mdelay(50);
+	ret = ytphy_mii_wr_ext(bus, addr, 0xa012, 0xd0);
+
+	mdelay(100);
+	val = ytphy_mii_rd_ext(bus, addr, 0xa012);
+	
+	if(val != 0xd0)
+	{
+		printk("yt8511_config_out_125m error\n");
+		return -1;
 	}
 
-	ret = ytphy_modify_ext(phydev, YT8521_CHIP_CONFIG_REG,
-			       YT8521_CCR_RXC_DLY_EN, rxc_dly_en);
+	/* disable auto sleep */
+	val = ytphy_mii_rd_ext(bus, addr, 0x27);
+	if (val < 0)
+	        return val;
+
+	val &= (~BIT(15));
+
+	ret = ytphy_mii_wr_ext(bus, addr, 0x27, val);
+	if (ret < 0)
+	        return ret;
+
+	/* enable RXC clock when no wire plug */
+	val = ytphy_mii_rd_ext(bus, addr, 0xc);
+	if (val < 0)
+	        return val;
+
+	/* ext reg 0xc.b[2:1]
+	00-----25M from pll;
+	01---- 25M from xtl;(default)
+	10-----62.5M from pll;
+	11----125M from pll(here set to this value)
+	*/
+	val |= (3 << 1);
+	ret = ytphy_mii_wr_ext(bus, addr, 0xc, val);
+	printk("yt8511_config_out_125m, phy clk out, val=%#08x\n",val);
+
+#if 0
+	/* for customer, please enable it based on demand.
+	 * configure to master
+	 */	
+	val = bus->read(bus, phy_id, 0x9/*master/slave config reg*/);
+	val |= (0x3<<11); //to be manual config and force to be master
+	ret = bus->write(bus, phy_id, 0x9, val); //take effect until phy soft reset
 	if (ret < 0)
 		return ret;
 
-	/* Generally, it is not necessary to adjust YT8521_RC1R_FE_TX_DELAY */
-	mask = YT8521_RC1R_RX_DELAY_MASK | YT8521_RC1R_GE_TX_DELAY_MASK;
-	return ytphy_modify_ext(phydev, YT8521_RGMII_CONFIG1_REG, mask, val);
+	printk("yt8511_config_out_125m, phy to be master, val=%#08x\n",val);
+#endif
+
+    return ret;
 }
 
-static int ytphy_rgmii_clk_delay_config_with_lock(struct phy_device *phydev)
+EXPORT_SYMBOL(yt8511_config_out_125m);
+
+static int yt8511_config_init(struct phy_device *phydev)
 {
 	int ret;
 
-	phy_lock_mdio_bus(phydev);
-	ret = ytphy_rgmii_clk_delay_config(phydev);
-	phy_unlock_mdio_bus(phydev);
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	ret = ytphy_config_init(phydev);
+#else
+	ret = genphy_config_init(phydev);
+#endif
 
 	return ret;
 }
+#endif /*GMAC_CLOCK_INPUT_NEEDED*/
 
-/**
- * yt8521_probe() - read chip config then set suitable polling_mode
- * @phydev: a pointer to a &struct phy_device
- *
- * returns 0 or negative errno code
- */
-static int yt8521_probe(struct phy_device *phydev)
+#if (YTPHY_ENABLE_WOL)
+static int ytphy_switch_reg_space(struct phy_device *phydev, int space)
 {
-	struct device_node *node = phydev->mdio.dev.of_node;
-	struct device *dev = &phydev->mdio.dev;
-	struct yt8521_priv *priv;
-	int chip_config;
-	u16 mask, val;
-	u32 freq;
 	int ret;
 
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	phydev->priv = priv;
+	if (space == YTPHY_REG_SPACE_UTP){
+		ret = ytphy_write_ext(phydev, 0xa000, 0);
+	}else{
+		ret = ytphy_write_ext(phydev, 0xa000, 2);
+	}
+	
+	return ret;
+}
 
-	chip_config = ytphy_read_ext_with_lock(phydev, YT8521_CHIP_CONFIG_REG);
-	if (chip_config < 0)
-		return chip_config;
+static int ytphy_wol_en_cfg(struct phy_device *phydev, ytphy_wol_cfg_t wol_cfg)
+{
+	int ret=0;
+	int val=0;
 
-	priv->strap_mode = chip_config & YT8521_CCR_MODE_SEL_MASK;
-	switch (priv->strap_mode) {
-	case YT8521_CCR_MODE_FIBER_TO_RGMII:
-	case YT8521_CCR_MODE_SGPHY_TO_RGMAC:
-	case YT8521_CCR_MODE_SGMAC_TO_RGPHY:
-		priv->polling_mode = YT8521_MODE_FIBER;
-		priv->reg_page = YT8521_RSSR_FIBER_SPACE;
-		phydev->port = PORT_FIBRE;
-		break;
-	case YT8521_CCR_MODE_UTP_FIBER_TO_RGMII:
-	case YT8521_CCR_MODE_UTP_TO_FIBER_AUTO:
-	case YT8521_CCR_MODE_UTP_TO_FIBER_FORCE:
-		priv->polling_mode = YT8521_MODE_POLL;
-		priv->reg_page = YT8521_RSSR_TO_BE_ARBITRATED;
-		phydev->port = PORT_NONE;
-		break;
-	case YT8521_CCR_MODE_UTP_TO_SGMII:
-	case YT8521_CCR_MODE_UTP_TO_RGMII:
-		priv->polling_mode = YT8521_MODE_UTP;
-		priv->reg_page = YT8521_RSSR_UTP_SPACE;
-		phydev->port = PORT_TP;
-		break;
-	}
-	/* set default reg space */
-	if (priv->reg_page != YT8521_RSSR_TO_BE_ARBITRATED) {
-		ret = ytphy_write_ext_with_lock(phydev,
-						YT8521_REG_SPACE_SELECT_REG,
-						priv->reg_page);
-		if (ret < 0)
-			return ret;
-	}
+	val = ytphy_read_ext(phydev, YTPHY_WOL_CFG_REG);
+	if (val < 0)
+		return val;
 
-	if (of_property_read_u32(node, "motorcomm,clk-out-frequency-hz", &freq))
-		freq = YTPHY_DTS_OUTPUT_CLK_DIS;
-
-	if (phydev->drv->phy_id == PHY_ID_YT8521) {
-		switch (freq) {
-		case YTPHY_DTS_OUTPUT_CLK_DIS:
-			mask = YT8521_SCR_SYNCE_ENABLE;
-			val = 0;
-			break;
-		case YTPHY_DTS_OUTPUT_CLK_25M:
-			mask = YT8521_SCR_SYNCE_ENABLE |
-			       YT8521_SCR_CLK_SRC_MASK |
-			       YT8521_SCR_CLK_FRE_SEL_125M;
-			val = YT8521_SCR_SYNCE_ENABLE |
-			      FIELD_PREP(YT8521_SCR_CLK_SRC_MASK,
-					 YT8521_SCR_CLK_SRC_REF_25M);
-			break;
-		case YTPHY_DTS_OUTPUT_CLK_125M:
-			mask = YT8521_SCR_SYNCE_ENABLE |
-			       YT8521_SCR_CLK_SRC_MASK |
-			       YT8521_SCR_CLK_FRE_SEL_125M;
-			val = YT8521_SCR_SYNCE_ENABLE |
-			      YT8521_SCR_CLK_FRE_SEL_125M |
-			      FIELD_PREP(YT8521_SCR_CLK_SRC_MASK,
-					 YT8521_SCR_CLK_SRC_PLL_125M);
-			break;
-		default:
-			phydev_warn(phydev, "Freq err:%u\n", freq);
-			return -EINVAL;
-		}
-	} else if (phydev->drv->phy_id == PHY_ID_YT8531S) {
-		switch (freq) {
-		case YTPHY_DTS_OUTPUT_CLK_DIS:
-			mask = YT8531_SCR_SYNCE_ENABLE;
-			val = 0;
-			break;
-		case YTPHY_DTS_OUTPUT_CLK_25M:
-			mask = YT8531_SCR_SYNCE_ENABLE |
-			       YT8531_SCR_CLK_SRC_MASK |
-			       YT8531_SCR_CLK_FRE_SEL_125M;
-			val = YT8531_SCR_SYNCE_ENABLE |
-			      FIELD_PREP(YT8531_SCR_CLK_SRC_MASK,
-					 YT8531_SCR_CLK_SRC_REF_25M);
-			break;
-		case YTPHY_DTS_OUTPUT_CLK_125M:
-			mask = YT8531_SCR_SYNCE_ENABLE |
-			       YT8531_SCR_CLK_SRC_MASK |
-			       YT8531_SCR_CLK_FRE_SEL_125M;
-			val = YT8531_SCR_SYNCE_ENABLE |
-			      YT8531_SCR_CLK_FRE_SEL_125M |
-			      FIELD_PREP(YT8531_SCR_CLK_SRC_MASK,
-					 YT8531_SCR_CLK_SRC_PLL_125M);
-			break;
-		default:
-			phydev_warn(phydev, "Freq err:%u\n", freq);
-			return -EINVAL;
+	if(wol_cfg.enable) {
+		val |= YTPHY_WOL_CFG_EN;
+
+		if(wol_cfg.type == YTPHY_WOL_TYPE_LEVEL) {
+			val &= ~YTPHY_WOL_CFG_TYPE;
+			val &= ~YTPHY_WOL_CFG_INTR_SEL;
+		} else if(wol_cfg.type == YTPHY_WOL_TYPE_PULSE) {
+			val |= YTPHY_WOL_CFG_TYPE;
+			val |= YTPHY_WOL_CFG_INTR_SEL;
+
+			if(wol_cfg.width == YTPHY_WOL_WIDTH_84MS) {
+				val &= ~YTPHY_WOL_CFG_WIDTH1;
+				val &= ~YTPHY_WOL_CFG_WIDTH2;
+			} else if(wol_cfg.width == YTPHY_WOL_WIDTH_168MS) {
+				val |= YTPHY_WOL_CFG_WIDTH1;
+				val &= ~YTPHY_WOL_CFG_WIDTH2;
+			} else if(wol_cfg.width == YTPHY_WOL_WIDTH_336MS) {
+				val &= ~YTPHY_WOL_CFG_WIDTH1;
+				val |= YTPHY_WOL_CFG_WIDTH2;
+			} else if(wol_cfg.width == YTPHY_WOL_WIDTH_672MS) {
+				val |= YTPHY_WOL_CFG_WIDTH1;
+				val |= YTPHY_WOL_CFG_WIDTH2;
+			}
 		}
 	} else {
-		phydev_warn(phydev, "PHY id err\n");
-		return -EINVAL;
+		val &= ~YTPHY_WOL_CFG_EN;
+		val &= ~YTPHY_WOL_CFG_INTR_SEL;
 	}
 
-	return ytphy_modify_ext_with_lock(phydev, YTPHY_SYNCE_CFG_REG, mask,
-					  val);
+	ret = ytphy_write_ext(phydev, YTPHY_WOL_CFG_REG, val);
+	if (ret < 0)
+		return ret;
+
+	return 0;
 }
 
-static int yt8531_probe(struct phy_device *phydev)
+static void ytphy_get_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)
 {
-	struct device_node *node = phydev->mdio.dev.of_node;
-	u16 mask, val;
-	u32 freq;
+	int val = 0;
 
-	if (of_property_read_u32(node, "motorcomm,clk-out-frequency-hz", &freq))
-		freq = YTPHY_DTS_OUTPUT_CLK_DIS;
+	wol->supported = WAKE_MAGIC;
+	wol->wolopts = 0;
 
-	switch (freq) {
-	case YTPHY_DTS_OUTPUT_CLK_DIS:
-		mask = YT8531_SCR_SYNCE_ENABLE;
-		val = 0;
-		break;
-	case YTPHY_DTS_OUTPUT_CLK_25M:
-		mask = YT8531_SCR_SYNCE_ENABLE | YT8531_SCR_CLK_SRC_MASK |
-		       YT8531_SCR_CLK_FRE_SEL_125M;
-		val = YT8531_SCR_SYNCE_ENABLE |
-		      FIELD_PREP(YT8531_SCR_CLK_SRC_MASK,
-				 YT8531_SCR_CLK_SRC_REF_25M);
-		break;
-	case YTPHY_DTS_OUTPUT_CLK_125M:
-		mask = YT8531_SCR_SYNCE_ENABLE | YT8531_SCR_CLK_SRC_MASK |
-		       YT8531_SCR_CLK_FRE_SEL_125M;
-		val = YT8531_SCR_SYNCE_ENABLE | YT8531_SCR_CLK_FRE_SEL_125M |
-		      FIELD_PREP(YT8531_SCR_CLK_SRC_MASK,
-				 YT8531_SCR_CLK_SRC_PLL_125M);
-		break;
-	default:
-		phydev_warn(phydev, "Freq err:%u\n", freq);
-		return -EINVAL;
-	}
+	val = ytphy_read_ext(phydev, YTPHY_WOL_CFG_REG);
+	if (val < 0)
+		return;
+
+	if (val & YTPHY_WOL_CFG_EN)
+		wol->wolopts |= WAKE_MAGIC;
 
-	return ytphy_modify_ext_with_lock(phydev, YTPHY_SYNCE_CFG_REG, mask,
-					  val);
+	return;
 }
 
-/**
- * ytphy_utp_read_lpa() - read LPA then setup lp_advertising for utp
- * @phydev: a pointer to a &struct phy_device
- *
- * NOTE:The caller must have taken the MDIO bus lock.
- *
- * returns 0 or negative errno code
- */
-static int ytphy_utp_read_lpa(struct phy_device *phydev)
+static int ytphy_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)
 {
-	int lpa, lpagb;
-
-	if (phydev->autoneg == AUTONEG_ENABLE) {
-		if (!phydev->autoneg_complete) {
-			mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising,
-							0);
-			mii_lpa_mod_linkmode_lpa_t(phydev->lp_advertising, 0);
-			return 0;
-		}
-
-		if (phydev->is_gigabit_capable) {
-			lpagb = __phy_read(phydev, MII_STAT1000);
-			if (lpagb < 0)
-				return lpagb;
+	int ret, pre_page, val;
+	ytphy_wol_cfg_t wol_cfg;
+	struct net_device *p_attached_dev = phydev->attached_dev;
 
-			if (lpagb & LPA_1000MSFAIL) {
-				int adv = __phy_read(phydev, MII_CTRL1000);
+	memset(&wol_cfg,0,sizeof(ytphy_wol_cfg_t));
+	pre_page = ytphy_read_ext(phydev, 0xa000);
+	if (pre_page < 0)
+		return pre_page;
 
-				if (adv < 0)
-					return adv;
+	/* Switch to phy UTP page */
+	ret = ytphy_switch_reg_space(phydev, YTPHY_REG_SPACE_UTP);
+	if (ret < 0)
+		return ret;
 
-				if (adv & CTL1000_ENABLE_MASTER)
-					phydev_err(phydev, "Master/Slave resolution failed, maybe conflicting manual settings?\n");
-				else
-					phydev_err(phydev, "Master/Slave resolution failed\n");
-				return -ENOLINK;
-			}
-
-			mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising,
-							lpagb);
-		}
+	if (wol->wolopts & WAKE_MAGIC) {
+		
+		/* Enable the WOL interrupt */
+		val = phy_read(phydev, YTPHY_UTP_INTR_REG);
+		val |= YTPHY_WOL_INTR;
+		ret = phy_write(phydev, YTPHY_UTP_INTR_REG, val);
+		if (ret < 0)
+			return ret;
 
-		lpa = __phy_read(phydev, MII_LPA);
-		if (lpa < 0)
-			return lpa;
+		/* Set the WOL config */
+		wol_cfg.enable = 1; //enable
+		wol_cfg.type= YTPHY_WOL_TYPE_PULSE;
+		wol_cfg.width= YTPHY_WOL_WIDTH_672MS;
+		ret = ytphy_wol_en_cfg(phydev, wol_cfg);
+		if (ret < 0)
+			return ret;
 
-		mii_lpa_mod_linkmode_lpa_t(phydev->lp_advertising, lpa);
+		/* Store the device address for the magic packet */
+		ret = ytphy_write_ext(phydev, YTPHY_MAGIC_PACKET_MAC_ADDR2,
+				((p_attached_dev->dev_addr[0] << 8) |
+				 p_attached_dev->dev_addr[1]));
+		if (ret < 0)
+			return ret;
+		ret = ytphy_write_ext(phydev, YTPHY_MAGIC_PACKET_MAC_ADDR1,
+				((p_attached_dev->dev_addr[2] << 8) |
+				 p_attached_dev->dev_addr[3]));
+		if (ret < 0)
+			return ret;
+		ret = ytphy_write_ext(phydev, YTPHY_MAGIC_PACKET_MAC_ADDR0,
+				((p_attached_dev->dev_addr[4] << 8) |
+				 p_attached_dev->dev_addr[5]));
+		if (ret < 0)
+			return ret;
 	} else {
-		linkmode_zero(phydev->lp_advertising);
+		wol_cfg.enable = 0; //disable
+		wol_cfg.type= YTPHY_WOL_TYPE_MAX;
+		wol_cfg.width= YTPHY_WOL_WIDTH_MAX;
+		ret = ytphy_wol_en_cfg(phydev, wol_cfg);
+		if (ret < 0)
+			return ret;
 	}
 
+	/* Recover to previous register space page */
+	ret = ytphy_switch_reg_space(phydev, pre_page);
+	if (ret < 0)
+		return ret;
+
 	return 0;
 }
 
-/**
- * yt8521_adjust_status() - update speed and duplex to phydev. when in fiber
- * mode, adjust speed and duplex.
- * @phydev: a pointer to a &struct phy_device
- * @status: yt8521 status read from YTPHY_SPECIFIC_STATUS_REG
- * @is_utp: false(yt8521 work in fiber mode) or true(yt8521 work in utp mode)
- *
- * NOTE:The caller must have taken the MDIO bus lock.
- *
- * returns 0
- */
-static int yt8521_adjust_status(struct phy_device *phydev, int status,
-				bool is_utp)
+#endif /*(YTPHY_ENABLE_WOL)*/
+
+static int yt8521_config_init(struct phy_device *phydev)
 {
-	int speed_mode, duplex;
-	int speed;
-	int err;
-	int lpa;
+	int ret;
+	int val;
+
+	phydev->irq = PHY_POLL;
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	ret = ytphy_config_init(phydev);
+#else
+	ret = genphy_config_init(phydev);
+#endif
+	if (ret < 0)
+		return ret;
 
-	if (is_utp)
-		duplex = (status & YTPHY_SSR_DUPLEX) >> YTPHY_SSR_DUPLEX_OFFSET;
-	else
-		duplex = DUPLEX_FULL;	/* for fiber, it always DUPLEX_FULL */
+	/* disable auto sleep */
+	val = ytphy_read_ext(phydev, YT8521_EXTREG_SLEEP_CONTROL1);
+	if (val < 0)
+		return val;
 
-	speed_mode = (status & YTPHY_SSR_SPEED_MODE_MASK) >>
-		     YTPHY_SSR_SPEED_MODE_OFFSET;
+	val &= (~BIT(YT8521_EN_SLEEP_SW_BIT));
 
+	ret = ytphy_write_ext(phydev, YT8521_EXTREG_SLEEP_CONTROL1, val);
+	if (ret < 0)
+		return ret;
+
+	/* enable RXC clock when no wire plug */
+	ret = ytphy_write_ext(phydev, 0xa000, 0);
+	if (ret < 0)
+		return ret;
+
+	val = ytphy_read_ext(phydev, 0xc);
+	if (val < 0)
+		return val;
+	val &= ~(1 << 12);
+	ret = ytphy_write_ext(phydev, 0xc, val);
+	if (ret < 0)
+		return ret;
+
+	printk (KERN_INFO "yt8521_config_init, 8521 init call out.\n");
+	return ret;
+}
+
+/*
+ * for fiber mode, there is no 10M speed mode and 
+ * this function is for this purpose.
+ */
+static int yt8521_adjust_status(struct phy_device *phydev, int val, int is_utp)
+{
+	int speed_mode, duplex;
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	int speed = -1;
+#else
+	int speed = SPEED_UNKNOWN;
+#endif
+
+	duplex = (val & YT8512_DUPLEX) >> YT8521_DUPLEX_BIT;
+	speed_mode = (val & YT8521_SPEED_MODE) >> YT8521_SPEED_MODE_BIT;
 	switch (speed_mode) {
-	case YTPHY_SSR_SPEED_10M:
+	case 0:
 		if (is_utp)
 			speed = SPEED_10;
-		else
-			/* for fiber, it will never run here, default to
-			 * SPEED_UNKNOWN
-			 */
-			speed = SPEED_UNKNOWN;
 		break;
-	case YTPHY_SSR_SPEED_100M:
+	case 1:
 		speed = SPEED_100;
 		break;
-	case YTPHY_SSR_SPEED_1000M:
+	case 2:
 		speed = SPEED_1000;
 		break;
+	case 3:
+		break;
 	default:
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+		speed = -1;
+#else
 		speed = SPEED_UNKNOWN;
+#endif
 		break;
 	}
 
 	phydev->speed = speed;
 	phydev->duplex = duplex;
-
-	if (is_utp) {
-		err = ytphy_utp_read_lpa(phydev);
-		if (err < 0)
-			return err;
-
-		phy_resolve_aneg_pause(phydev);
-	} else {
-		lpa = __phy_read(phydev, MII_LPA);
-		if (lpa < 0)
-			return lpa;
-
-		/* only support 1000baseX Full */
-		linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,
-				 phydev->lp_advertising, lpa & LPA_1000XFULL);
-
-		if (!(lpa & YTPHY_FLPA_PAUSE)) {
-			phydev->pause = 0;
-			phydev->asym_pause = 0;
-		} else if ((lpa & YTPHY_FLPA_ASYM_PAUSE)) {
-			phydev->pause = 1;
-			phydev->asym_pause = 1;
-		} else {
-			phydev->pause = 1;
-			phydev->asym_pause = 0;
-		}
-	}
+	//printk (KERN_INFO "yt8521_adjust_status call out,regval=0x%04x,mode=%s,speed=%dm...\n", val,is_utp?"utp":"fiber", phydev->speed);
 
 	return 0;
 }
 
-/**
- * yt8521_read_status_paged() -  determines the speed and duplex of one page
- * @phydev: a pointer to a &struct phy_device
- * @page: The reg page(YT8521_RSSR_FIBER_SPACE/YT8521_RSSR_UTP_SPACE) to
- * operate.
- *
- * returns 1 (utp or fiber link),0 (no link) or negative errno code
+/*
+ * for fiber mode, when speed is 100M, there is no definition for autonegotiation, and
+ * this function handles this case and return 1 per linux kernel's polling.
  */
-static int yt8521_read_status_paged(struct phy_device *phydev, int page)
+int yt8521_aneg_done (struct phy_device *phydev)
 {
-	int fiber_latch_val;
-	int fiber_curr_val;
-	int old_page;
-	int ret = 0;
-	int status;
-	int link;
-
-	linkmode_zero(phydev->lp_advertising);
-	phydev->duplex = DUPLEX_UNKNOWN;
-	phydev->speed = SPEED_UNKNOWN;
-	phydev->asym_pause = 0;
-	phydev->pause = 0;
-
-	/* YT8521 has two reg space (utp/fiber) for linkup with utp/fiber
-	 * respectively. but for utp/fiber combo mode, reg space should be
-	 * arbitrated based on media priority. by default, utp takes
-	 * priority. reg space should be properly set before read
-	 * YTPHY_SPECIFIC_STATUS_REG.
-	 */
-
-	page &= YT8521_RSSR_SPACE_MASK;
-	old_page = phy_select_page(phydev, page);
-	if (old_page < 0)
-		goto err_restore_page;
-
-	/* Read YTPHY_SPECIFIC_STATUS_REG, which indicates the speed and duplex
-	 * of the PHY is actually using.
-	 */
-	ret = __phy_read(phydev, YTPHY_SPECIFIC_STATUS_REG);
-	if (ret < 0)
-		goto err_restore_page;
-
-	status = ret;
-	link = !!(status & YTPHY_SSR_LINK);
-
-	/* When PHY is in fiber mode, speed transferred from 1000Mbps to
-	 * 100Mbps,there is not link down from YTPHY_SPECIFIC_STATUS_REG, so
-	 * we need check MII_BMSR to identify such case.
-	 */
-	if (page == YT8521_RSSR_FIBER_SPACE) {
-		ret = __phy_read(phydev, MII_BMSR);
-		if (ret < 0)
-			goto err_restore_page;
-
-		fiber_latch_val = ret;
-		ret = __phy_read(phydev, MII_BMSR);
-		if (ret < 0)
-			goto err_restore_page;
-
-		fiber_curr_val = ret;
-		if (link && fiber_latch_val != fiber_curr_val) {
-			link = 0;
-			phydev_info(phydev,
-				    "%s, fiber link down detect, latch = %04x, curr = %04x\n",
-				    __func__, fiber_latch_val, fiber_curr_val);
-		}
-	} else {
-		/* Read autonegotiation status */
-		ret = __phy_read(phydev, MII_BMSR);
-		if (ret < 0)
-			goto err_restore_page;
 
-		phydev->autoneg_complete = ret & BMSR_ANEGCOMPLETE ? 1 : 0;
-	}
+	//printk("yt8521_aneg_done callin,speed=%dm,linkmoded=%d\n", phydev->speed,link_mode_8521);
 
-	if (link) {
-		if (page == YT8521_RSSR_UTP_SPACE)
-			yt8521_adjust_status(phydev, status, true);
-		else
-			yt8521_adjust_status(phydev, status, false);
+	if((32 == link_mode_8521) && (SPEED_100 == phydev->speed))
+	{
+		return 1/*link_mode_8521*/;
 	}
-	return phy_restore_page(phydev, old_page, link);
 
-err_restore_page:
-	return phy_restore_page(phydev, old_page, ret);
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(3,11,0) )
+	return genphy_aneg_done(phydev);
+#else
+	return 1;
+#endif
 }
 
-/**
- * yt8521_read_status() -  determines the negotiated speed and duplex
- * @phydev: a pointer to a &struct phy_device
- *
- * returns 0 or negative errno code
- */
 static int yt8521_read_status(struct phy_device *phydev)
 {
-	struct yt8521_priv *priv = phydev->priv;
-	int link_fiber = 0;
-	int link_utp;
-	int link;
 	int ret;
+	volatile int val, yt8521_fiber_latch_val, yt8521_fiber_curr_val;
+	volatile int link;
+	int link_utp = 0, link_fiber = 0;
 
-	if (priv->reg_page != YT8521_RSSR_TO_BE_ARBITRATED) {
-		link = yt8521_read_status_paged(phydev, priv->reg_page);
-		if (link < 0)
-			return link;
-	} else {
-		/* when page is YT8521_RSSR_TO_BE_ARBITRATED, arbitration is
-		 * needed. by default, utp is higher priority.
-		 */
-
-		link_utp = yt8521_read_status_paged(phydev,
-						    YT8521_RSSR_UTP_SPACE);
-		if (link_utp < 0)
-			return link_utp;
-
-		if (!link_utp) {
-			link_fiber = yt8521_read_status_paged(phydev,
-							      YT8521_RSSR_FIBER_SPACE);
-			if (link_fiber < 0)
-				return link_fiber;
-		}
+#if (YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+	/* reading UTP */
+	ret = ytphy_write_ext(phydev, 0xa000, 0);
+	if (ret < 0)
+		return ret;
 
-		link = link_utp || link_fiber;
-	}
+	val = phy_read(phydev, REG_PHY_SPEC_STATUS);
+	if (val < 0)
+		return val;
 
+	link = val & (BIT(YT8521_LINK_STATUS_BIT));
 	if (link) {
-		if (phydev->link == 0) {
-			/* arbitrate reg space based on linkup media type. */
-			if (priv->polling_mode == YT8521_MODE_POLL &&
-			    priv->reg_page == YT8521_RSSR_TO_BE_ARBITRATED) {
-				if (link_fiber)
-					priv->reg_page =
-						YT8521_RSSR_FIBER_SPACE;
-				else
-					priv->reg_page = YT8521_RSSR_UTP_SPACE;
-
-				ret = ytphy_write_ext_with_lock(phydev,
-								YT8521_REG_SPACE_SELECT_REG,
-								priv->reg_page);
-				if (ret < 0)
-					return ret;
-
-				phydev->port = link_fiber ? PORT_FIBRE : PORT_TP;
-
-				phydev_info(phydev, "%s, link up, media: %s\n",
-					    __func__,
-					    (phydev->port == PORT_TP) ?
-					    "UTP" : "Fiber");
-			}
-		}
-		phydev->link = 1;
+		link_utp = 1;
+		link_mode_8521 = 1;
+		yt8521_adjust_status(phydev, val, 1);
 	} else {
-		if (phydev->link == 1) {
-			phydev_info(phydev, "%s, link down, media: %s\n",
-				    __func__, (phydev->port == PORT_TP) ?
-				    "UTP" : "Fiber");
-
-			/* When in YT8521_MODE_POLL mode, need prepare for next
-			 * arbitration.
-			 */
-			if (priv->polling_mode == YT8521_MODE_POLL) {
-				priv->reg_page = YT8521_RSSR_TO_BE_ARBITRATED;
-				phydev->port = PORT_NONE;
-			}
-		}
-
-		phydev->link = 0;
+		link_utp = 0;
 	}
+#endif //(YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
 
-	return 0;
-}
-
-/**
- * yt8521_modify_bmcr_paged - bits modify a PHY's BMCR register of one page
- * @phydev: the phy_device struct
- * @page: The reg page(YT8521_RSSR_FIBER_SPACE/YT8521_RSSR_UTP_SPACE) to operate
- * @mask: bit mask of bits to clear
- * @set: bit mask of bits to set
- *
- * NOTE: Convenience function which allows a PHY's BMCR register to be
- * modified as new register value = (old register value & ~mask) | set.
- * YT8521 has two space (utp/fiber) and three mode (utp/fiber/poll), each space
- * has MII_BMCR. poll mode combines utp and faber,so need do both.
- * If it is reset, it will wait for completion.
- *
- * returns 0 or negative errno code
- */
-static int yt8521_modify_bmcr_paged(struct phy_device *phydev, int page,
-				    u16 mask, u16 set)
-{
-	int max_cnt = 500; /* the max wait time of reset ~ 500 ms */
-	int old_page;
-	int ret = 0;
-
-	old_page = phy_select_page(phydev, page & YT8521_RSSR_SPACE_MASK);
-	if (old_page < 0)
-		goto err_restore_page;
-
-	ret = __phy_modify(phydev, MII_BMCR, mask, set);
+#if (YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_UTP)
+	/* reading Fiber */
+	ret = ytphy_write_ext(phydev, 0xa000, 2);
 	if (ret < 0)
-		goto err_restore_page;
-
-	/* If it is reset, need to wait for the reset to complete */
-	if (set == BMCR_RESET) {
-		while (max_cnt--) {
-			usleep_range(1000, 1100);
-			ret = __phy_read(phydev, MII_BMCR);
-			if (ret < 0)
-				goto err_restore_page;
-
-			if (!(ret & BMCR_RESET))
-				return phy_restore_page(phydev, old_page, 0);
-		}
+		return ret;
+
+	val = phy_read(phydev, REG_PHY_SPEC_STATUS);
+	if (val < 0)
+		return val;
+	
+	//note: below debug information is used to check multiple PHy ports.
+	//printk (KERN_INFO "yt8521_read_status, fiber status=%04x,macbase=0x%08lx\n", val,(unsigned long)phydev->attached_dev);
+
+	/* for fiber, from 1000m to 100m, there is not link down from 0x11, and check reg 1 to identify such case
+	 * this is important for Linux kernel for that, missing linkdown event will cause problem.
+	 */	
+	yt8521_fiber_latch_val = phy_read(phydev, MII_BMSR);
+	yt8521_fiber_curr_val = phy_read(phydev, MII_BMSR);
+	link = val & (BIT(YT8521_LINK_STATUS_BIT));
+	if((link) && (yt8521_fiber_latch_val != yt8521_fiber_curr_val))
+	{
+		link = 0;
+		printk (KERN_INFO "yt8521_read_status, fiber link down detect,latch=%04x,curr=%04x\n", yt8521_fiber_latch_val,yt8521_fiber_curr_val);
 	}
+	
+	if (link) {
+		link_fiber = 1;
+		yt8521_adjust_status(phydev, val, 0);
+		link_mode_8521 = 32; //fiber mode
 
-err_restore_page:
-	return phy_restore_page(phydev, old_page, ret);
-}
 
-/**
- * yt8521_modify_utp_fiber_bmcr - bits modify a PHY's BMCR register
- * @phydev: the phy_device struct
- * @mask: bit mask of bits to clear
- * @set: bit mask of bits to set
- *
- * NOTE: Convenience function which allows a PHY's BMCR register to be
- * modified as new register value = (old register value & ~mask) | set.
- * YT8521 has two space (utp/fiber) and three mode (utp/fiber/poll), each space
- * has MII_BMCR. poll mode combines utp and faber,so need do both.
- *
- * returns 0 or negative errno code
- */
-static int yt8521_modify_utp_fiber_bmcr(struct phy_device *phydev, u16 mask,
-					u16 set)
-{
-	struct yt8521_priv *priv = phydev->priv;
-	int ret;
+	} else {
+		link_fiber = 0;
+	}
+#endif //(YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_UTP)
 
-	if (priv->reg_page != YT8521_RSSR_TO_BE_ARBITRATED) {
-		ret = yt8521_modify_bmcr_paged(phydev, priv->reg_page, mask,
-					       set);
-		if (ret < 0)
-			return ret;
+	if (link_utp || link_fiber) {
+		phydev->link = 1;
 	} else {
-		ret = yt8521_modify_bmcr_paged(phydev, YT8521_RSSR_UTP_SPACE,
-					       mask, set);
-		if (ret < 0)
-			return ret;
+		phydev->link = 0;
+		link_mode_8521 = 0;
+	}
 
-		ret = yt8521_modify_bmcr_paged(phydev, YT8521_RSSR_FIBER_SPACE,
-					       mask, set);
-		if (ret < 0)
-			return ret;
+#if (YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+	if (link_utp) {
+		ytphy_write_ext(phydev, 0xa000, 0);
 	}
+#endif
+
+	//printk (KERN_INFO "yzhang..8521 read status call out,link=%d,linkmode=%d\n", phydev->link, link_mode_8521 );
 	return 0;
 }
 
-/**
- * yt8521_soft_reset() - called to issue a PHY software reset
- * @phydev: a pointer to a &struct phy_device
- *
- * returns 0 or negative errno code
- */
-static int yt8521_soft_reset(struct phy_device *phydev)
+int yt8521_suspend(struct phy_device *phydev)
 {
-	return yt8521_modify_utp_fiber_bmcr(phydev, 0, BMCR_RESET);
-}
+#if !(SYS_WAKEUP_BASED_ON_ETH_PKT)				
+	int value;
 
-/**
- * yt8521_suspend() - suspend the hardware
- * @phydev: a pointer to a &struct phy_device
- *
- * returns 0 or negative errno code
- */
-static int yt8521_suspend(struct phy_device *phydev)
-{
-	int wol_config;
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_lock(&phydev->lock);
+#else
+	/* no need lock in 4.19 */
+#endif
 
-	/* YTPHY_WOL_CONFIG_REG is common ext reg */
-	wol_config = ytphy_read_ext_with_lock(phydev, YTPHY_WOL_CONFIG_REG);
-	if (wol_config < 0)
-		return wol_config;
+	ytphy_write_ext(phydev, 0xa000, 0);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
 
-	/* if wol enable, do nothing */
-	if (wol_config & YTPHY_WCR_ENABLE)
-		return 0;
+	ytphy_write_ext(phydev, 0xa000, 2);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
 
-	return yt8521_modify_utp_fiber_bmcr(phydev, 0, BMCR_PDOWN);
+	ytphy_write_ext(phydev, 0xa000, 0);
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_unlock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+#endif /*!(SYS_WAKEUP_BASED_ON_ETH_PKT)*/				
+
+	return 0;
 }
 
-/**
- * yt8521_resume() - resume the hardware
- * @phydev: a pointer to a &struct phy_device
- *
- * returns 0 or negative errno code
- */
-static int yt8521_resume(struct phy_device *phydev)
+int yt8521_resume(struct phy_device *phydev)
 {
+#if !(SYS_WAKEUP_BASED_ON_ETH_PKT)				
+	int value;
 	int ret;
-	int wol_config;
+	
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_lock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
 
 	/* disable auto sleep */
-	ret = ytphy_modify_ext_with_lock(phydev,
-					 YT8521_EXTREG_SLEEP_CONTROL1_REG,
-					 YT8521_ESC1R_SLEEP_SW, 0);
+	value = ytphy_read_ext(phydev, YT8521_EXTREG_SLEEP_CONTROL1);
+	if (value < 0)
+		return value;
+
+	value &= (~BIT(YT8521_EN_SLEEP_SW_BIT));
+	ret = ytphy_write_ext(phydev, YT8521_EXTREG_SLEEP_CONTROL1, value);
 	if (ret < 0)
 		return ret;
 
-	wol_config = ytphy_read_ext_with_lock(phydev, YTPHY_WOL_CONFIG_REG);
-	if (wol_config < 0)
-		return wol_config;
-
-	/* if wol enable, do nothing */
-	if (wol_config & YTPHY_WCR_ENABLE)
-		return 0;
-
-	return yt8521_modify_utp_fiber_bmcr(phydev, BMCR_PDOWN, 0);
-}
+	/* enable RXC clock when no wire plug */
+	value = ytphy_read_ext(phydev, 0xc);
+	if (value < 0)
+		return value;
+	value &= ~(1 << 12);
+	ret = ytphy_write_ext(phydev, 0xc, value);
+	if (ret < 0)
+		return ret;
 
-/**
- * yt8521_config_init() - called to initialize the PHY
- * @phydev: a pointer to a &struct phy_device
- *
- * returns 0 or negative errno code
- */
-static int yt8521_config_init(struct phy_device *phydev)
-{
-	struct device_node *node = phydev->mdio.dev.of_node;
-	int old_page;
-	int ret = 0;
+	ytphy_write_ext(phydev, 0xa000, 2);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
 
-	old_page = phy_select_page(phydev, YT8521_RSSR_UTP_SPACE);
-	if (old_page < 0)
-		goto err_restore_page;
+#if (YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+	ytphy_write_ext(phydev, 0xa000, 0);
+#endif
 
-	/* set rgmii delay mode */
-	if (phydev->interface != PHY_INTERFACE_MODE_SGMII) {
-		ret = ytphy_rgmii_clk_delay_config(phydev);
-		if (ret < 0)
-			goto err_restore_page;
-	}
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_unlock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+#endif /*!(SYS_WAKEUP_BASED_ON_ETH_PKT)*/				
 
-	if (of_property_read_bool(node, "motorcomm,auto-sleep-disabled")) {
-		/* disable auto sleep */
-		ret = ytphy_modify_ext(phydev, YT8521_EXTREG_SLEEP_CONTROL1_REG,
-				       YT8521_ESC1R_SLEEP_SW, 0);
-		if (ret < 0)
-			goto err_restore_page;
-	}
-
-	if (of_property_read_bool(node, "motorcomm,keep-pll-enabled")) {
-		/* enable RXC clock when no wire plug */
-		ret = ytphy_modify_ext(phydev, YT8521_CLOCK_GATING_REG,
-				       YT8521_CGR_RX_CLK_EN, 0);
-		if (ret < 0)
-			goto err_restore_page;
-	}
-err_restore_page:
-	return phy_restore_page(phydev, old_page, ret);
+	return 0;
 }
 
-static int yt8531_config_init(struct phy_device *phydev)
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#else
+int yt8618_soft_reset(struct phy_device *phydev)
 {
-	struct device_node *node = phydev->mdio.dev.of_node;
 	int ret;
 
-	ret = ytphy_rgmii_clk_delay_config_with_lock(phydev);
+	ytphy_write_ext(phydev, 0xa000, 0);
+	ret = genphy_soft_reset(phydev);
 	if (ret < 0)
 		return ret;
 
-	if (of_property_read_bool(node, "motorcomm,auto-sleep-disabled")) {
-		/* disable auto sleep */
-		ret = ytphy_modify_ext_with_lock(phydev,
-						 YT8521_EXTREG_SLEEP_CONTROL1_REG,
-						 YT8521_ESC1R_SLEEP_SW, 0);
-		if (ret < 0)
-			return ret;
-	}
-
-	if (of_property_read_bool(node, "motorcomm,keep-pll-enabled")) {
-		/* enable RXC clock when no wire plug */
-		ret = ytphy_modify_ext_with_lock(phydev,
-						 YT8521_CLOCK_GATING_REG,
-						 YT8521_CGR_RX_CLK_EN, 0);
-		if (ret < 0)
-			return ret;
-	}
-
 	return 0;
 }
 
-/**
- * yt8531_link_change_notify() - Adjust the tx clock direction according to
- * the current speed and dts config.
- * @phydev: a pointer to a &struct phy_device
- *
- * NOTE: This function is only used to adapt to VF2 with JH7110 SoC. Please
- * keep "motorcomm,tx-clk-adj-enabled" not exist in dts when the soc is not
- * JH7110.
- */
-static void yt8531_link_change_notify(struct phy_device *phydev)
+int yt8614_soft_reset(struct phy_device *phydev)
 {
-	struct device_node *node = phydev->mdio.dev.of_node;
-	bool tx_clk_1000_inverted = false;
-	bool tx_clk_100_inverted = false;
-	bool tx_clk_10_inverted = false;
-	bool tx_clk_adj_enabled = false;
-	u16 val = 0;
 	int ret;
 
-	if (of_property_read_bool(node, "motorcomm,tx-clk-adj-enabled"))
-		tx_clk_adj_enabled = true;
-
-	if (!tx_clk_adj_enabled)
-		return;
-
-	if (of_property_read_bool(node, "motorcomm,tx-clk-10-inverted"))
-		tx_clk_10_inverted = true;
-	if (of_property_read_bool(node, "motorcomm,tx-clk-100-inverted"))
-		tx_clk_100_inverted = true;
-	if (of_property_read_bool(node, "motorcomm,tx-clk-1000-inverted"))
-		tx_clk_1000_inverted = true;
+	/* utp */
+	ytphy_write_ext(phydev, 0xa000, 0);
+	ret = genphy_soft_reset(phydev);
+	if (ret < 0)
+		return ret;
 
-	if (phydev->speed < 0)
-		return;
+	/* qsgmii */
+	ytphy_write_ext(phydev, 0xa000, 2);
+	ret = genphy_soft_reset(phydev);
+	if (ret < 0) {
+		ytphy_write_ext(phydev, 0xa000, 0); //back to utp mode
+		return ret;
+	}
 
-	switch (phydev->speed) {
-	case SPEED_1000:
-		if (tx_clk_1000_inverted)
-			val = YT8521_RC1R_TX_CLK_SEL_INVERTED;
-		break;
-	case SPEED_100:
-		if (tx_clk_100_inverted)
-			val = YT8521_RC1R_TX_CLK_SEL_INVERTED;
-		break;
-	case SPEED_10:
-		if (tx_clk_10_inverted)
-			val = YT8521_RC1R_TX_CLK_SEL_INVERTED;
-		break;
-	default:
-		return;
+	/* sgmii */
+	ytphy_write_ext(phydev, 0xa000, 3);
+	ret = genphy_soft_reset(phydev);
+	if (ret < 0) {
+		ytphy_write_ext(phydev, 0xa000, 0); //back to utp mode
+		return ret;
 	}
 
-	ret = ytphy_modify_ext_with_lock(phydev, YT8521_RGMII_CONFIG1_REG,
-					 YT8521_RC1R_TX_CLK_SEL_INVERTED, val);
-	if (ret < 0)
-		phydev_warn(phydev, "Modify TX_CLK_SEL err:%d\n", ret);
+	return 0;
 }
 
-/**
- * yt8521_prepare_fiber_features() -  A small helper function that setup
- * fiber's features.
- * @phydev: a pointer to a &struct phy_device
- * @dst: a pointer to store fiber's features
- */
-static void yt8521_prepare_fiber_features(struct phy_device *phydev,
-					  unsigned long *dst)
-{
-	linkmode_set_bit(ETHTOOL_LINK_MODE_100baseFX_Full_BIT, dst);
-	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, dst);
-	linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, dst);
-	linkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT, dst);
-}
+#endif
 
-/**
- * yt8521_fiber_setup_forced - configures/forces speed from @phydev
- * @phydev: target phy_device struct
- *
- * NOTE:The caller must have taken the MDIO bus lock.
- *
- * returns 0 or negative errno code
- */
-static int yt8521_fiber_setup_forced(struct phy_device *phydev)
+static int yt8618_config_init(struct phy_device *phydev)
 {
-	u16 val;
 	int ret;
+	int val;
 
-	if (phydev->speed == SPEED_1000)
-		val = YTPHY_MCR_FIBER_1000BX;
-	else if (phydev->speed == SPEED_100)
-		val = YTPHY_MCR_FIBER_100FX;
-	else
-		return -EINVAL;
+	phydev->irq = PHY_POLL;
 
-	ret =  __phy_modify(phydev, MII_BMCR, BMCR_ANENABLE, 0);
+	if(0xff == yt_mport_base_phy_addr)
+		/* by default, we think the first phy should be the base phy addr. for mul */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	{
+		yt_mport_base_phy_addr = phydev->addr;
+	}else if (yt_mport_base_phy_addr > phydev->addr) { 
+		printk (KERN_INFO "yzhang..8618 init, phy address mismatch, base=%d, cur=%d\n", yt_mport_base_phy_addr, phydev->addr);
+	}
+#else
+	{
+		yt_mport_base_phy_addr = phydev->mdio.addr;
+	}else if (yt_mport_base_phy_addr > phydev->mdio.addr) { 
+		printk (KERN_INFO "yzhang..8618 init, phy address mismatch, base=%d, cur=%d\n", yt_mport_base_phy_addr, phydev->mdio.addr);
+	}
+#endif	
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	ret = ytphy_config_init(phydev);
+#else
+	ret = genphy_config_init(phydev);
+#endif
 	if (ret < 0)
 		return ret;
 
-	/* disable Fiber auto sensing */
-	ret =  ytphy_modify_ext(phydev, YT8521_LINK_TIMER_CFG2_REG,
-				YT8521_LTCR_EN_AUTOSEN, 0);
+	/* for utp to optimize signal */
+	ret = ytphy_write_ext(phydev, 0x41, 0x33);
 	if (ret < 0)
 		return ret;
-
-	ret =  ytphy_modify_ext(phydev, YTPHY_MISC_CONFIG_REG,
-				YTPHY_MCR_FIBER_SPEED_MASK, val);
+	ret = ytphy_write_ext(phydev, 0x42, 0x66);
 	if (ret < 0)
 		return ret;
-
-	return ytphy_modify_ext(phydev, YT8521_CHIP_CONFIG_REG,
-				YT8521_CCR_SW_RST, 0);
-}
-
-/**
- * ytphy_check_and_restart_aneg - Enable and restart auto-negotiation
- * @phydev: target phy_device struct
- * @restart: whether aneg restart is requested
- *
- * NOTE:The caller must have taken the MDIO bus lock.
- *
- * returns 0 or negative errno code
- */
-static int ytphy_check_and_restart_aneg(struct phy_device *phydev, bool restart)
-{
-	int ret;
-
-	if (!restart) {
-		/* Advertisement hasn't changed, but maybe aneg was never on to
-		 * begin with?  Or maybe phy was isolated?
-		 */
-		ret = __phy_read(phydev, MII_BMCR);
+	ret = ytphy_write_ext(phydev, 0x43, 0xaa);
+	if (ret < 0)
+		return ret;
+	ret = ytphy_write_ext(phydev, 0x44, 0xd0d);
+	if (ret < 0)
+		return ret;
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	if((phydev->addr > yt_mport_base_phy_addr) && ((2 == phydev->addr - yt_mport_base_phy_addr) || (5 == phydev->addr - yt_mport_base_phy_addr)))
+#else
+	if((phydev->mdio.addr > yt_mport_base_phy_addr) && ((2 == phydev->mdio.addr - yt_mport_base_phy_addr) || (5 == phydev->mdio.addr - yt_mport_base_phy_addr)))
+#endif
+	{
+		ret = ytphy_write_ext(phydev, 0x44, 0x2929);
 		if (ret < 0)
 			return ret;
-
-		if (!(ret & BMCR_ANENABLE) || (ret & BMCR_ISOLATE))
-			restart = true;
 	}
-	/* Enable and Restart Autonegotiation
-	 * Don't isolate the PHY if we're negotiating
-	 */
-	if (restart)
-		return __phy_modify(phydev, MII_BMCR, BMCR_ISOLATE,
-				    BMCR_ANENABLE | BMCR_ANRESTART);
 
-	return 0;
+	val = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, val | BMCR_RESET);
+
+	printk (KERN_INFO "yt8618_config_init call out.\n");
+	return ret;
 }
 
-/**
- * yt8521_fiber_config_aneg - restart auto-negotiation or write
- * YTPHY_MISC_CONFIG_REG.
- * @phydev: target phy_device struct
- *
- * NOTE:The caller must have taken the MDIO bus lock.
- *
- * returns 0 or negative errno code
- */
-static int yt8521_fiber_config_aneg(struct phy_device *phydev)
+static int yt8614_config_init(struct phy_device *phydev)
 {
-	int err, changed = 0;
-	int bmcr;
-	u16 adv;
-
-	if (phydev->autoneg != AUTONEG_ENABLE)
-		return yt8521_fiber_setup_forced(phydev);
-
-	/* enable Fiber auto sensing */
-	err =  ytphy_modify_ext(phydev, YT8521_LINK_TIMER_CFG2_REG,
-				0, YT8521_LTCR_EN_AUTOSEN);
-	if (err < 0)
-		return err;
-
-	err =  ytphy_modify_ext(phydev, YT8521_CHIP_CONFIG_REG,
-				YT8521_CCR_SW_RST, 0);
-	if (err < 0)
-		return err;
-
-	bmcr = __phy_read(phydev, MII_BMCR);
-	if (bmcr < 0)
-		return bmcr;
-
-	/* When it is coming from fiber forced mode, add bmcr power down
-	 * and power up to let aneg work fine.
-	 */
-	if (!(bmcr & BMCR_ANENABLE)) {
-		__phy_modify(phydev, MII_BMCR, 0, BMCR_PDOWN);
-		usleep_range(1000, 1100);
-		__phy_modify(phydev, MII_BMCR, BMCR_PDOWN, 0);
-	}
-
-	adv = linkmode_adv_to_mii_adv_x(phydev->advertising,
-					ETHTOOL_LINK_MODE_1000baseX_Full_BIT);
-
-	/* Setup fiber advertisement */
-	err = __phy_modify_changed(phydev, MII_ADVERTISE,
-				   ADVERTISE_1000XHALF | ADVERTISE_1000XFULL |
-				   ADVERTISE_1000XPAUSE |
-				   ADVERTISE_1000XPSE_ASYM,
-				   adv);
-	if (err < 0)
-		return err;
+	int ret = 0;
 
-	if (err > 0)
-		changed = 1;
+	phydev->irq = PHY_POLL;
 
-	return ytphy_check_and_restart_aneg(phydev, changed);
+	if(0xff == yt_mport_base_phy_addr_8614)
+		/* by default, we think the first phy should be the base phy addr. for mul */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	{
+		yt_mport_base_phy_addr_8614 = (unsigned int)phydev->addr;
+	}else if (yt_mport_base_phy_addr_8614 > (unsigned int)phydev->addr) { 
+		printk (KERN_INFO "yzhang..8618 init, phy address mismatch, base=%u, cur=%d\n", yt_mport_base_phy_addr_8614, phydev->addr);
+	}
+#else
+	{
+		yt_mport_base_phy_addr_8614 = (unsigned int)phydev->mdio.addr;
+	}else if (yt_mport_base_phy_addr_8614 > (unsigned int)phydev->mdio.addr) { 
+		printk (KERN_INFO "yzhang..8618 init, phy address mismatch, base=%u, cur=%d\n", yt_mport_base_phy_addr_8614, phydev->mdio.addr);
+	}
+#endif	
+	return ret;
 }
 
-/**
- * ytphy_setup_master_slave
- * @phydev: target phy_device struct
- *
- * NOTE: The caller must have taken the MDIO bus lock.
- *
- * returns 0 or negative errno code
- */
-static int ytphy_setup_master_slave(struct phy_device *phydev)
-{
-	u16 ctl = 0;
-
-	if (!phydev->is_gigabit_capable)
-		return 0;
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#define yt8614_get_port_from_phydev(phydev) ((0xff == yt_mport_base_phy_addr_8614) && (yt_mport_base_phy_addr_8614 <= (phydev)->addr) ? 0 : (unsigned int)((phydev)->addr) - yt_mport_base_phy_addr_8614)
+#else
+#define yt8614_get_port_from_phydev(phydev) ((0xff == yt_mport_base_phy_addr_8614) && (yt_mport_base_phy_addr_8614 <= (phydev)->mdio.addr) ? 0 : (unsigned int)((phydev)->mdio.addr) - yt_mport_base_phy_addr_8614)
+#endif
 
-	switch (phydev->master_slave_set) {
-	case MASTER_SLAVE_CFG_MASTER_PREFERRED:
-		ctl |= CTL1000_PREFER_MASTER;
-		break;
-	case MASTER_SLAVE_CFG_SLAVE_PREFERRED:
-		break;
-	case MASTER_SLAVE_CFG_MASTER_FORCE:
-		ctl |= CTL1000_AS_MASTER;
-		fallthrough;
-	case MASTER_SLAVE_CFG_SLAVE_FORCE:
-		ctl |= CTL1000_ENABLE_MASTER;
-		break;
-	case MASTER_SLAVE_CFG_UNKNOWN:
-	case MASTER_SLAVE_CFG_UNSUPPORTED:
-		return 0;
-	default:
-		phydev_warn(phydev, "Unsupported Master/Slave mode\n");
-		return -EOPNOTSUPP;
-	}
+int yt8618_aneg_done (struct phy_device *phydev)
+{
 
-	return __phy_modify_changed(phydev, MII_CTRL1000,
-				    (CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER |
-				    CTL1000_PREFER_MASTER), ctl);
+	return genphy_aneg_done(phydev);
 }
 
-/**
- * ytphy_utp_config_advert - sanitize and advertise auto-negotiation parameters
- * @phydev: target phy_device struct
- *
- * NOTE: Writes MII_ADVERTISE with the appropriate values,
- * after sanitizing the values to make sure we only advertise
- * what is supported.  Returns < 0 on error, 0 if the PHY's advertisement
- * hasn't changed, and > 0 if it has changed.
- * The caller must have taken the MDIO bus lock.
- *
- * returns 0 or negative errno code
- */
-static int ytphy_utp_config_advert(struct phy_device *phydev)
+int yt8614_aneg_done (struct phy_device *phydev)
 {
-	int err, bmsr, changed = 0;
-	u32 adv;
-
-	/* Only allow advertising what this PHY supports */
-	linkmode_and(phydev->advertising, phydev->advertising,
-		     phydev->supported);
-
-	adv = linkmode_adv_to_mii_adv_t(phydev->advertising);
-
-	/* Setup standard advertisement */
-	err = __phy_modify_changed(phydev, MII_ADVERTISE,
-				   ADVERTISE_ALL | ADVERTISE_100BASE4 |
-				   ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM,
-				   adv);
-	if (err < 0)
-		return err;
-	if (err > 0)
-		changed = 1;
-
-	bmsr = __phy_read(phydev, MII_BMSR);
-	if (bmsr < 0)
-		return bmsr;
-
-	/* Per 802.3-2008, Section 22.2.4.2.16 Extended status all
-	 * 1000Mbits/sec capable PHYs shall have the BMSR_ESTATEN bit set to a
-	 * logical 1.
-	 */
-	if (!(bmsr & BMSR_ESTATEN))
-		return changed;
-
-	adv = linkmode_adv_to_mii_ctrl1000_t(phydev->advertising);
-
-	err = __phy_modify_changed(phydev, MII_CTRL1000,
-				   ADVERTISE_1000FULL | ADVERTISE_1000HALF,
-				   adv);
-	if (err < 0)
-		return err;
-	if (err > 0)
-		changed = 1;
-
-	return changed;
+	int port = yt8614_get_port_from_phydev(phydev);
+	
+	/*it should be used for 8614 fiber*/
+	if((32 == link_mode_8614[port]) && (SPEED_100 == phydev->speed))
+	{
+		return 1;
+	}
+
+	return genphy_aneg_done(phydev);
 }
 
-/**
- * ytphy_utp_config_aneg - restart auto-negotiation or write BMCR
- * @phydev: target phy_device struct
- * @changed: whether autoneg is requested
- *
- * NOTE: If auto-negotiation is enabled, we configure the
- * advertising, and then restart auto-negotiation.  If it is not
- * enabled, then we write the BMCR.
- * The caller must have taken the MDIO bus lock.
- *
- * returns 0 or negative errno code
- */
-static int ytphy_utp_config_aneg(struct phy_device *phydev, bool changed)
+static int yt8614_read_status(struct phy_device *phydev)
 {
-	int err;
-	u16 ctl;
+        //int i;
+	int ret;
+	volatile int val, yt8614_fiber_latch_val, yt8614_fiber_curr_val;
+	volatile int link;
+	int link_utp = 0, link_fiber = 0;
+	int port = yt8614_get_port_from_phydev(phydev);
+
+#if (YT8614_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+	/* switch to utp and reading regs  */
+	ret = ytphy_write_ext(phydev, 0xa000, 0);
+	if (ret < 0)
+		return ret;
 
-	err = ytphy_setup_master_slave(phydev);
-	if (err < 0)
-		return err;
-	else if (err)
-		changed = true;
+	val = phy_read(phydev, REG_PHY_SPEC_STATUS);
+	if (val < 0)
+		return val;
 
-	if (phydev->autoneg != AUTONEG_ENABLE) {
-		/* configures/forces speed/duplex from @phydev */
+	link = val & (BIT(YT8521_LINK_STATUS_BIT));
+	if (link) {
+		link_utp = 1;
+		// here is same as 8521 and re-use the function;
+		yt8521_adjust_status(phydev, val, 1);  
+	} else {
+		link_utp = 0;
+	}
+#endif //(YT8614_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
 
-		ctl = mii_bmcr_encode_fixed(phydev->speed, phydev->duplex);
+#if (YT8614_PHY_MODE_CURR != YT8521_PHY_MODE_UTP)
+	/* reading Fiber/sgmii */
+	ret = ytphy_write_ext(phydev, 0xa000, 3);
+	if (ret < 0)
+		return ret;
 
-		return __phy_modify(phydev, MII_BMCR, ~(BMCR_LOOPBACK |
-				    BMCR_ISOLATE | BMCR_PDOWN), ctl);
+	val = phy_read(phydev, REG_PHY_SPEC_STATUS);
+	if (val < 0)
+		return val;
+	
+	//printk (KERN_INFO "yzhang..8614 read fiber status=%04x,macbase=0x%08lx\n", val,(unsigned long)phydev->attached_dev);
+
+	/* for fiber, from 1000m to 100m, there is not link down from 0x11, and check reg 1 to identify such case */	
+	yt8614_fiber_latch_val = phy_read(phydev, MII_BMSR);
+	yt8614_fiber_curr_val = phy_read(phydev, MII_BMSR);
+	link = val & (BIT(YT8521_LINK_STATUS_BIT));
+	if((link) && (yt8614_fiber_latch_val != yt8614_fiber_curr_val))
+	{
+		link = 0;
+		printk (KERN_INFO "yt8614_read_status, fiber link down detect,latch=%04x,curr=%04x\n", yt8614_fiber_latch_val,yt8614_fiber_curr_val);
 	}
+	
+	if (link) {
+		link_fiber = 1;
+		yt8521_adjust_status(phydev, val, 0);
+		link_mode_8614[port] = 32; //fiber mode
 
-	err = ytphy_utp_config_advert(phydev);
-	if (err < 0) /* error */
-		return err;
-	else if (err)
-		changed = true;
-
-	return ytphy_check_and_restart_aneg(phydev, changed);
-}
 
-/**
- * yt8521_config_aneg_paged() - switch reg space then call genphy_config_aneg
- * of one page
- * @phydev: a pointer to a &struct phy_device
- * @page: The reg page(YT8521_RSSR_FIBER_SPACE/YT8521_RSSR_UTP_SPACE) to
- * operate.
- *
- * returns 0 or negative errno code
- */
-static int yt8521_config_aneg_paged(struct phy_device *phydev, int page)
-{
-	__ETHTOOL_DECLARE_LINK_MODE_MASK(fiber_supported);
-	struct yt8521_priv *priv = phydev->priv;
-	int old_page;
-	int ret = 0;
+	} else {
+		link_fiber = 0;
+	}
+#endif //(YT8521_PHY_MODE_CURR != YT8521_PHY_MODE_UTP)
 
-	page &= YT8521_RSSR_SPACE_MASK;
-
-	old_page = phy_select_page(phydev, page);
-	if (old_page < 0)
-		goto err_restore_page;
-
-	/* If reg_page is YT8521_RSSR_TO_BE_ARBITRATED,
-	 * phydev->advertising should be updated.
-	 */
-	if (priv->reg_page == YT8521_RSSR_TO_BE_ARBITRATED) {
-		linkmode_zero(fiber_supported);
-		yt8521_prepare_fiber_features(phydev, fiber_supported);
-
-		/* prepare fiber_supported, then setup advertising. */
-		if (page == YT8521_RSSR_FIBER_SPACE) {
-			linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT,
-					 fiber_supported);
-			linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
-					 fiber_supported);
-			linkmode_and(phydev->advertising,
-				     priv->combo_advertising, fiber_supported);
-		} else {
-			/* ETHTOOL_LINK_MODE_Autoneg_BIT is also used in utp */
-			linkmode_clear_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
-					   fiber_supported);
-			linkmode_andnot(phydev->advertising,
-					priv->combo_advertising,
-					fiber_supported);
-		}
+	if (link_utp || link_fiber) {
+		phydev->link = 1;
+	} else {
+		phydev->link = 0;
+		link_mode_8614[port] = 0;
 	}
 
-	if (page == YT8521_RSSR_FIBER_SPACE)
-		ret = yt8521_fiber_config_aneg(phydev);
-	else
-		ret = ytphy_utp_config_aneg(phydev, false);
+#if (YT8614_PHY_MODE_CURR != YT8521_PHY_MODE_FIBER)
+	if (link_utp) {
+		ytphy_write_ext(phydev, 0xa000, 0);
+	}
+#endif
+	//printk (KERN_INFO "yt8614_read_status call out,link=%d,linkmode=%d\n", phydev->link, link_mode_8614[port] );
 
-err_restore_page:
-	return phy_restore_page(phydev, old_page, ret);
+	return 0;
 }
 
-/**
- * yt8521_config_aneg() - change reg space then call yt8521_config_aneg_paged
- * @phydev: a pointer to a &struct phy_device
- *
- * returns 0 or negative errno code
- */
-static int yt8521_config_aneg(struct phy_device *phydev)
+static int yt8618_read_status(struct phy_device *phydev)
 {
-	struct yt8521_priv *priv = phydev->priv;
 	int ret;
+	volatile int val; //maybe for 8614 yt8521_fiber_latch_val, yt8521_fiber_curr_val;
+	volatile int link;
+	int link_utp = 0, link_fiber = 0;
 
-	if (priv->reg_page != YT8521_RSSR_TO_BE_ARBITRATED) {
-		ret = yt8521_config_aneg_paged(phydev, priv->reg_page);
-		if (ret < 0)
-			return ret;
-	} else {
-		/* If reg_page is YT8521_RSSR_TO_BE_ARBITRATED,
-		 * phydev->advertising need to be saved at first run.
-		 * Because it contains the advertising which supported by both
-		 * mac and yt8521(utp and fiber).
-		 */
-		if (linkmode_empty(priv->combo_advertising)) {
-			linkmode_copy(priv->combo_advertising,
-				      phydev->advertising);
-		}
+	/* switch to utp and reading regs  */
+	ret = ytphy_write_ext(phydev, 0xa000, 0);
+	if (ret < 0)
+		return ret;
 
-		ret = yt8521_config_aneg_paged(phydev, YT8521_RSSR_UTP_SPACE);
-		if (ret < 0)
-			return ret;
+	val = phy_read(phydev, REG_PHY_SPEC_STATUS);
+	if (val < 0)
+		return val;
 
-		ret = yt8521_config_aneg_paged(phydev, YT8521_RSSR_FIBER_SPACE);
-		if (ret < 0)
-			return ret;
+	link = val & (BIT(YT8521_LINK_STATUS_BIT));
+	if (link) {
+		link_utp = 1;
+		yt8521_adjust_status(phydev, val, 1);
+	} else {
+		link_utp = 0;
+	}
 
-		/* we don't known which will be link, so restore
-		 * phydev->advertising as default value.
-		 */
-		linkmode_copy(phydev->advertising, priv->combo_advertising);
+	if (link_utp || link_fiber) {
+		phydev->link = 1;
+	} else {
+		phydev->link = 0;
 	}
+
 	return 0;
 }
 
-/**
- * yt8521_aneg_done_paged() - determines the auto negotiation result of one
- * page.
- * @phydev: a pointer to a &struct phy_device
- * @page: The reg page(YT8521_RSSR_FIBER_SPACE/YT8521_RSSR_UTP_SPACE) to
- * operate.
- *
- * returns 0(no link)or 1(fiber or utp link) or negative errno code
- */
-static int yt8521_aneg_done_paged(struct phy_device *phydev, int page)
+int yt8618_suspend(struct phy_device *phydev)
 {
-	int old_page;
-	int ret = 0;
-	int link;
-
-	old_page = phy_select_page(phydev, page & YT8521_RSSR_SPACE_MASK);
-	if (old_page < 0)
-		goto err_restore_page;
-
-	ret = __phy_read(phydev, YTPHY_SPECIFIC_STATUS_REG);
-	if (ret < 0)
-		goto err_restore_page;
-
-	link = !!(ret & YTPHY_SSR_LINK);
-	ret = link;
+#if !(SYS_WAKEUP_BASED_ON_ETH_PKT)				
+	int value;
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_lock(&phydev->lock);
+#else
+	/* no need lock in 4.19 */
+#endif
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_unlock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+#endif /*!(SYS_WAKEUP_BASED_ON_ETH_PKT)*/				
 
-err_restore_page:
-	return phy_restore_page(phydev, old_page, ret);
+	return 0;
 }
 
-/**
- * yt8521_aneg_done() - determines the auto negotiation result
- * @phydev: a pointer to a &struct phy_device
- *
- * returns 0(no link)or 1(fiber or utp link) or negative errno code
- */
-static int yt8521_aneg_done(struct phy_device *phydev)
+int yt8618_resume(struct phy_device *phydev)
 {
-	struct yt8521_priv *priv = phydev->priv;
-	int link_fiber = 0;
-	int link_utp;
-	int link;
-
-	if (priv->reg_page != YT8521_RSSR_TO_BE_ARBITRATED) {
-		link = yt8521_aneg_done_paged(phydev, priv->reg_page);
-	} else {
-		link_utp = yt8521_aneg_done_paged(phydev,
-						  YT8521_RSSR_UTP_SPACE);
-		if (link_utp < 0)
-			return link_utp;
-
-		if (!link_utp) {
-			link_fiber = yt8521_aneg_done_paged(phydev,
-							    YT8521_RSSR_FIBER_SPACE);
-			if (link_fiber < 0)
-				return link_fiber;
-		}
-		link = link_fiber || link_utp;
-		phydev_info(phydev, "%s, link_fiber: %d, link_utp: %d\n",
-			    __func__, link_fiber, link_utp);
-	}
+#if !(SYS_WAKEUP_BASED_ON_ETH_PKT)				
+	int value;
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_lock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_unlock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+#endif /*!(SYS_WAKEUP_BASED_ON_ETH_PKT)*/				
 
-	return link;
+	return 0;
 }
 
-/**
- * ytphy_utp_read_abilities - read PHY abilities from Clause 22 registers
- * @phydev: target phy_device struct
- *
- * NOTE: Reads the PHY's abilities and populates
- * phydev->supported accordingly.
- * The caller must have taken the MDIO bus lock.
- *
- * returns 0 or negative errno code
- */
-static int ytphy_utp_read_abilities(struct phy_device *phydev)
+int yt8614_suspend(struct phy_device *phydev)
 {
-	int val;
+#if !(SYS_WAKEUP_BASED_ON_ETH_PKT)				
+	int value;
 
-	linkmode_set_bit_array(phy_basic_ports_array,
-			       ARRAY_SIZE(phy_basic_ports_array),
-			       phydev->supported);
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_lock(&phydev->lock);
+#else
+	/* no need lock in 4.19 */
+#endif
 
-	val = __phy_read(phydev, MII_BMSR);
-	if (val < 0)
-		return val;
+	ytphy_write_ext(phydev, 0xa000, 0);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
 
-	linkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, phydev->supported,
-			 val & BMSR_ANEGCAPABLE);
-
-	linkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, phydev->supported,
-			 val & BMSR_100FULL);
-	linkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, phydev->supported,
-			 val & BMSR_100HALF);
-	linkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, phydev->supported,
-			 val & BMSR_10FULL);
-	linkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, phydev->supported,
-			 val & BMSR_10HALF);
-
-	if (val & BMSR_ESTATEN) {
-		val = __phy_read(phydev, MII_ESTATUS);
-		if (val < 0)
-			return val;
-
-		linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
-				 phydev->supported, val & ESTATUS_1000_TFULL);
-		linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
-				 phydev->supported, val & ESTATUS_1000_THALF);
-		linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,
-				 phydev->supported, val & ESTATUS_1000_XFULL);
-	}
+	ytphy_write_ext(phydev, 0xa000, 3);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
+
+	ytphy_write_ext(phydev, 0xa000, 0);
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_unlock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+#endif /*!(SYS_WAKEUP_BASED_ON_ETH_PKT)*/				
 
 	return 0;
 }
 
-/**
- * yt8521_get_features_paged() -  read supported link modes for one page
- * @phydev: a pointer to a &struct phy_device
- * @page: The reg page(YT8521_RSSR_FIBER_SPACE/YT8521_RSSR_UTP_SPACE) to
- * operate.
- *
- * returns 0 or negative errno code
- */
-static int yt8521_get_features_paged(struct phy_device *phydev, int page)
+int yt8614_resume(struct phy_device *phydev)
 {
-	int old_page;
-	int ret = 0;
+#if !(SYS_WAKEUP_BASED_ON_ETH_PKT)				
+	int value;
 
-	page &= YT8521_RSSR_SPACE_MASK;
-	old_page = phy_select_page(phydev, page);
-	if (old_page < 0)
-		goto err_restore_page;
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_lock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
 
-	if (page == YT8521_RSSR_FIBER_SPACE) {
-		linkmode_zero(phydev->supported);
-		yt8521_prepare_fiber_features(phydev, phydev->supported);
-	} else {
-		ret = ytphy_utp_read_abilities(phydev);
-		if (ret < 0)
-			goto err_restore_page;
-	}
+	ytphy_write_ext(phydev, 0xa000, 0);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
 
-err_restore_page:
-	return phy_restore_page(phydev, old_page, ret);
-}
+	ytphy_write_ext(phydev, 0xa000, 3);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
 
-/**
- * yt8521_get_features - switch reg space then call yt8521_get_features_paged
- * @phydev: target phy_device struct
- *
- * returns 0 or negative errno code
- */
-static int yt8521_get_features(struct phy_device *phydev)
-{
-	struct yt8521_priv *priv = phydev->priv;
-	int ret;
+	ytphy_write_ext(phydev, 0xa000, 0);
 
-	if (priv->reg_page != YT8521_RSSR_TO_BE_ARBITRATED) {
-		ret = yt8521_get_features_paged(phydev, priv->reg_page);
-	} else {
-		ret = yt8521_get_features_paged(phydev,
-						YT8521_RSSR_UTP_SPACE);
-		if (ret < 0)
-			return ret;
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+	mutex_unlock(&phydev->lock);
+#else
+	/* no need lock/unlock in 4.19 */
+#endif
+#endif /*!(SYS_WAKEUP_BASED_ON_ETH_PKT)*/				
 
-		/* add fiber's features to phydev->supported */
-		yt8521_prepare_fiber_features(phydev, phydev->supported);
-	}
-	return ret;
+	return 0;
 }
 
-static struct phy_driver motorcomm_phy_drvs[] = {
+
+static struct phy_driver ytphy_drvs[] = {
 	{
-		PHY_ID_MATCH_EXACT(PHY_ID_YT8511),
+		.phy_id         = PHY_ID_YT8010,
+		.name           = "YT8010 Automotive Ethernet",
+		.phy_id_mask    = MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features       = PHY_BASIC_FEATURES,
+		.flags          = PHY_HAS_INTERRUPT,
+#endif		
+		.config_aneg    = yt8010_config_aneg,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+		.config_init	= ytphy_config_init,
+#else
+		.config_init	= genphy_config_init,
+#endif
+		.read_status    = genphy_read_status,
+	}, {
+		.phy_id		= PHY_ID_YT8510,
+		.name		= "YT8510 100/10Mb Ethernet",
+		.phy_id_mask	= MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features	= PHY_BASIC_FEATURES,
+		.flags			= PHY_HAS_INTERRUPT,
+#endif		
+		.config_aneg	= genphy_config_aneg,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+		.config_init	= ytphy_config_init,
+#else
+		.config_init	= genphy_config_init,
+#endif
+		.read_status	= genphy_read_status,
+	}, {
+		.phy_id		= PHY_ID_YT8511,
 		.name		= "YT8511 Gigabit Ethernet",
+		.phy_id_mask	= MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features	= PHY_GBIT_FEATURES,
+		.flags			= PHY_HAS_INTERRUPT,
+#endif		
+		.config_aneg	= genphy_config_aneg,
+#if GMAC_CLOCK_INPUT_NEEDED
 		.config_init	= yt8511_config_init,
+#else
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+		.config_init	= ytphy_config_init,
+#else
+		.config_init	= genphy_config_init,
+#endif
+#endif
+		.read_status	= genphy_read_status,
 		.suspend	= genphy_suspend,
 		.resume		= genphy_resume,
-		.read_page	= yt8511_read_page,
-		.write_page	= yt8511_write_page,
-	},
-	{
-		PHY_ID_MATCH_EXACT(PHY_ID_YT8521),
-		.name		= "YT8521 Gigabit Ethernet",
-		.get_features	= yt8521_get_features,
-		.probe		= yt8521_probe,
-		.read_page	= yt8521_read_page,
-		.write_page	= yt8521_write_page,
-		.get_wol	= ytphy_get_wol,
-		.set_wol	= ytphy_set_wol,
-		.config_aneg	= yt8521_config_aneg,
-		.aneg_done	= yt8521_aneg_done,
-		.config_init	= yt8521_config_init,
-		.read_status	= yt8521_read_status,
+	}, {
+		.phy_id		= PHY_ID_YT8512,
+		.name		= "YT8512 Ethernet",
+		.phy_id_mask	= MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features	= PHY_BASIC_FEATURES,
+		.flags			= PHY_HAS_INTERRUPT,
+#endif		
+		.config_aneg	= genphy_config_aneg,
+		.config_init	= yt8512_config_init,
+		.read_status	= yt8512_read_status,
+		.suspend	= genphy_suspend,
+		.resume		= genphy_resume,
+	}, {
+		.phy_id		= PHY_ID_YT8512B,
+		.name		= "YT8512B Ethernet",
+		.phy_id_mask	= MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features	= PHY_BASIC_FEATURES,
+		.flags			= PHY_HAS_INTERRUPT,
+#endif		
+		.config_aneg	= genphy_config_aneg,
+		.config_init	= yt8512_config_init,
+		.read_status	= yt8512_read_status,
+		.suspend	= genphy_suspend,
+		.resume		= genphy_resume,
+	}, {
+        .phy_id         = PHY_ID_YT8521,
+        .name           = "YT8521 Ethernet",
+        .phy_id_mask    = MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+        .features       = PHY_BASIC_FEATURES | PHY_GBIT_FEATURES,
+#endif
+        .flags          = PHY_POLL,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#else
 		.soft_reset	= yt8521_soft_reset,
-		.suspend	= yt8521_suspend,
-		.resume		= yt8521_resume,
-	},
-	{
-		PHY_ID_MATCH_EXACT(PHY_ID_YT8531),
+#endif
+        .config_aneg    = genphy_config_aneg,
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(3,11,0) )
+        .aneg_done	= yt8521_aneg_done,
+#endif
+        .config_init    = yt8521_config_init,
+        .read_status    = yt8521_read_status,
+        .suspend        = yt8521_suspend,
+        .resume         = yt8521_resume,
+#if (YTPHY_ENABLE_WOL)
+		.get_wol		= &ytphy_get_wol,
+		.set_wol		= &ytphy_set_wol,
+#endif                
+        },{
+		/* same as 8521 */
+        .phy_id         = PHY_ID_YT8531S,
+        .name           = "YT8531S Ethernet",
+        .phy_id_mask    = MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+        .features       = PHY_BASIC_FEATURES | PHY_GBIT_FEATURES,
+#endif
+        .flags          = PHY_POLL,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#else
+		.soft_reset	= yt8521_soft_reset,
+#endif
+        .config_aneg    = genphy_config_aneg,
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(3,11,0) )
+        .aneg_done	= yt8521_aneg_done,
+#endif
+        .config_init    = yt8521_config_init,
+        .read_status    = yt8521_read_status,
+        .suspend        = yt8521_suspend,
+        .resume         = yt8521_resume,
+#if (YTPHY_ENABLE_WOL)
+		.get_wol		= &ytphy_get_wol,
+		.set_wol		= &ytphy_set_wol,
+#endif                
+        }, {
+        /* same as 8511 */
+		.phy_id		= PHY_ID_YT8531,
 		.name		= "YT8531 Gigabit Ethernet",
-		.probe		= yt8531_probe,
-		.config_init	= yt8531_config_init,
+		.phy_id_mask	= MOTORCOMM_PHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features	= PHY_BASIC_FEATURES | PHY_GBIT_FEATURES,
+		.flags			= PHY_HAS_INTERRUPT,
+#endif		
+		.config_aneg	= genphy_config_aneg,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+		.config_init	= ytphy_config_init,
+#else
+		.config_init	= genphy_config_init,
+#endif
+		.read_status	= genphy_read_status,
 		.suspend	= genphy_suspend,
 		.resume		= genphy_resume,
-		.get_wol	= ytphy_get_wol,
-		.set_wol	= yt8531_set_wol,
-		.link_change_notify = yt8531_link_change_notify,
-	},
-	{
-		PHY_ID_MATCH_EXACT(PHY_ID_YT8531S),
-		.name		= "YT8531S Gigabit Ethernet",
-		.get_features	= yt8521_get_features,
-		.probe		= yt8521_probe,
-		.read_page	= yt8521_read_page,
-		.write_page	= yt8521_write_page,
-		.get_wol	= ytphy_get_wol,
-		.set_wol	= ytphy_set_wol,
-		.config_aneg	= yt8521_config_aneg,
-		.aneg_done	= yt8521_aneg_done,
-		.config_init	= yt8521_config_init,
-		.read_status	= yt8521_read_status,
-		.soft_reset	= yt8521_soft_reset,
-		.suspend	= yt8521_suspend,
-		.resume		= yt8521_resume,
-	},
+#if (YTPHY_ENABLE_WOL)
+		.get_wol		= &ytphy_get_wol,
+		.set_wol		= &ytphy_set_wol,
+#endif                
+	}, {
+        .phy_id         = PHY_ID_YT8618,
+        .name           = "YT8618 Ethernet",
+        .phy_id_mask    = MOTORCOMM_MPHY_ID_MASK,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+        .features       = PHY_BASIC_FEATURES | PHY_GBIT_FEATURES,
+#endif
+        .flags          = PHY_POLL,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#else
+		.soft_reset	= yt8618_soft_reset,
+#endif
+        .config_aneg    = genphy_config_aneg,
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(3,11,0) )
+        .aneg_done		= yt8618_aneg_done,
+#endif
+        .config_init    = yt8618_config_init,
+        .read_status    = yt8618_read_status,
+        .suspend        = yt8618_suspend,
+        .resume         = yt8618_resume,
+    }, {
+		.phy_id 		= PHY_ID_YT8614,
+		.name			= "YT8614 Ethernet",
+		.phy_id_mask	= MOTORCOMM_MPHY_ID_MASK_8614,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
+		.features		= PHY_BASIC_FEATURES | PHY_GBIT_FEATURES,
+#endif
+		.flags			= PHY_POLL,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+#else
+		.soft_reset = yt8614_soft_reset,
+#endif
+		.config_aneg	= genphy_config_aneg,
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(3,11,0) )
+		.aneg_done		= yt8614_aneg_done,
+#endif
+		.config_init	= yt8614_config_init,
+		.read_status	= yt8614_read_status,
+		.suspend		= yt8614_suspend,
+		.resume 		= yt8614_resume,
+		}, 
 };
 
-module_phy_driver(motorcomm_phy_drvs);
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+static int ytphy_drivers_register(struct phy_driver* phy_drvs, int size)
+{
+	int i, j;
+	int ret;
+
+	for (i = 0; i < size; i++) {
+		ret = phy_driver_register(&phy_drvs[i]);
+		if (ret)
+			goto err;
+	}
+
+	return 0;
+
+err:
+	for (j = 0; j < i; j++)
+		phy_driver_unregister(&phy_drvs[j]);
+
+	return ret;
+}
+
+static void ytphy_drivers_unregister(struct phy_driver* phy_drvs, int size)
+{
+	int i;
 
-MODULE_DESCRIPTION("Motorcomm 8511/8521/8531/8531S PHY driver");
-MODULE_AUTHOR("Peter Geis");
-MODULE_AUTHOR("Frank");
+	for (i = 0; i < size; i++) {
+		phy_driver_unregister(&phy_drvs[i]);
+	}
+}
+
+static int __init ytphy_init(void)
+{
+	printk("motorcomm phy register\n");
+	return ytphy_drivers_register(ytphy_drvs, ARRAY_SIZE(ytphy_drvs));
+}
+
+static void __exit ytphy_exit(void)
+{
+	printk("motorcomm phy unregister\n");
+	ytphy_drivers_unregister(ytphy_drvs, ARRAY_SIZE(ytphy_drvs));
+}
+
+module_init(ytphy_init);
+module_exit(ytphy_exit);
+#else
+/* for linux 4.x */
+module_phy_driver(ytphy_drvs);
+#endif
+
+MODULE_DESCRIPTION("Motorcomm PHY driver");
+MODULE_AUTHOR("Leilei Zhao");
 MODULE_LICENSE("GPL");
 
-static const struct mdio_device_id __maybe_unused motorcomm_tbl[] = {
-	{ PHY_ID_MATCH_EXACT(PHY_ID_YT8511) },
-	{ PHY_ID_MATCH_EXACT(PHY_ID_YT8521) },
-	{ PHY_ID_MATCH_EXACT(PHY_ID_YT8531) },
-	{ PHY_ID_MATCH_EXACT(PHY_ID_YT8531S) },
-	{ /* sentinel */ }
+static struct mdio_device_id __maybe_unused motorcomm_tbl[] = {
+	{ PHY_ID_YT8010, MOTORCOMM_PHY_ID_MASK },
+	{ PHY_ID_YT8510, MOTORCOMM_PHY_ID_MASK },
+	{ PHY_ID_YT8511, MOTORCOMM_PHY_ID_MASK },
+	{ PHY_ID_YT8512, MOTORCOMM_PHY_ID_MASK },
+	{ PHY_ID_YT8512B, MOTORCOMM_PHY_ID_MASK },
+	{ PHY_ID_YT8521, MOTORCOMM_PHY_ID_MASK },
+	{ PHY_ID_YT8531S, MOTORCOMM_PHY_ID_8531_MASK },
+	{ PHY_ID_YT8531, MOTORCOMM_PHY_ID_8531_MASK },
+	{ PHY_ID_YT8618, MOTORCOMM_MPHY_ID_MASK },
+	{ PHY_ID_YT8614, MOTORCOMM_MPHY_ID_MASK_8614 },
+	{ }
 };
 
 MODULE_DEVICE_TABLE(mdio, motorcomm_tbl);
+
+
diff --git a/drivers/net/phy/yt8614-phy.h b/drivers/net/phy/yt8614-phy.h
new file mode 100644
index 000000000000..56a398338146
--- /dev/null
+++ b/drivers/net/phy/yt8614-phy.h
@@ -0,0 +1,491 @@
+#ifndef _PHY_H_
+#define _PHY_H_
+
+
+/* configuration for driver */
+
+#define YT8614_MAX_LPORT_ID		3
+
+#define YT8614_PHY_MODE_FIBER	1 //fiber mode only
+#define YT8614_PHY_MODE_UTP		2 //utp mode only
+#define YT8614_PHY_MODE_POLL	3 //fiber and utp, poll mode
+
+/* please make choice according to system design
+ * for Fiber only system, please define YT8614_PHY_MODE_CURR 1
+ * for UTP only system, please define YT8614_PHY_MODE_CURR 2
+ * for combo system, please define YT8614_PHY_MODE_CURR 3 
+ */
+#define YT8614_PHY_MODE_CURR	3
+
+
+
+/* pls dont modify below lines */
+
+#define PHY_ID_YT8614  0x4F51E899 //serdes
+#define MOTORCOMM_MPHY_ID_MASK_8614 0xffffffff
+
+#ifndef BOOL
+#define BOOL unsigned int
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef SPEED_1000M
+#define SPEED_1000M     2
+#endif
+#ifndef SPEED_100M
+#define SPEED_100M     	1
+#endif
+#ifndef SPEED_10M
+#define SPEED_10M     	0
+#endif
+
+#ifndef SPEED_UNKNOWN
+#define SPEED_UNKNOWN   0xffff
+#endif
+
+#ifndef DUPLEX_FULL
+#define DUPLEX_FULL		1	
+#endif
+#ifndef DUPLEX_HALF
+#define DUPLEX_HALF		0	
+#endif
+
+#ifndef BIT
+#define BIT(n) (0x1<<(n))
+#endif
+#ifndef s32
+typedef int  s32;
+typedef unsigned int  u32;
+typedef unsigned short  u16;
+typedef unsigned char  u8;
+#endif
+
+#ifndef REG_PHY_SPEC_STATUS
+#define REG_PHY_SPEC_STATUS		0x11
+#define REG_DEBUG_ADDR_OFFSET		0x1e
+#define REG_DEBUG_DATA			0x1f
+#endif
+
+/**********YT8614************************************************/
+
+#define YT8614_SMI_SEL_PHY        0x0
+#define YT8614_SMI_SEL_SDS_QSGMII 0x02
+#define YT8614_SMI_SEL_SDS_SGMII  0x03
+
+/* yt8614 register type */
+#define YT8614_TYPE_COMMON         0x01
+#define YT8614_TYPE_UTP_MII        0x02
+#define YT8614_TYPE_UTP_EXT        0x03
+#define YT8614_TYPE_LDS_MII        0x04
+#define YT8614_TYPE_UTP_MMD        0x05
+#define YT8614_TYPE_SDS_QSGMII_MII 0x06
+#define YT8614_TYPE_SDS_SGMII_MII  0x07
+#define YT8614_TYPE_SDS_QSGMII_EXT 0x08
+#define YT8614_TYPE_SDS_SGMII_EXT  0x09
+
+/* YT8614 extended common register */
+#define YT8614_REG_COM_SMI_MUX        0xA000
+#define YT8614_REG_COM_SLED_CFG0      0xA001
+#define YT8614_REG_COM_PHY_ID         0xA002
+#define YT8614_REG_COM_CHIP_VER       0xA003
+#define YT8614_REG_COM_SLED_CFG       0xA004
+#define YT8614_REG_COM_MODE_CHG_RESET 0xA005
+#define YT8614_REG_COM_SYNCE0_CFG     0xA006
+#define YT8614_REG_COM_CHIP_MODE      0xA007
+
+#define YT8614_REG_COM_HIDE_SPEED     0xA009
+
+#define YT8614_REG_COM_SYNCE1_CFG     0xA00E
+
+#define YT8614_REG_COM_HIDE_FIBER_MODE 0xA019
+
+
+#define YT8614_REG_COM_HIDE_SEL1      0xA054
+#define YT8614_REG_COM_HIDE_LED_CFG2  0xB8
+#define YT8614_REG_COM_HIDE_LED_CFG3  0xB9
+#define YT8614_REG_COM_HIDE_LED_CFG5  0xBB
+
+#define YT8614_REG_COM_HIDE_LED_CFG4  0xBA //not used currently
+
+#if 0
+#define YT8614_REG_COM_HIDE_LED12_CFG 0xA060 //not used currently
+#define YT8614_REG_COM_HIDE_LED13_CFG 0xA061
+#define YT8614_REG_COM_HIDE_LED14_CFG 0xA062
+#define YT8614_REG_COM_HIDE_LED15_CFG 0xA063
+#define YT8614_REG_COM_HIDE_LED16_CFG 0xA064
+#define YT8614_REG_COM_HIDE_LED17_CFG 0xA065
+#define YT8614_REG_COM_HIDE_LED18_CFG 0xA066
+#define YT8614_REG_COM_HIDE_LED19_CFG 0xA067
+#define YT8614_REG_COM_HIDE_LED20_CFG 0xA068
+#define YT8614_REG_COM_HIDE_LED21_CFG 0xA069
+#define YT8614_REG_COM_HIDE_LED22_CFG 0xA06A
+#define YT8614_REG_COM_HIDE_LED23_CFG 0xA06B
+#define YT8614_REG_COM_HIDE_LED24_CFG 0xA06C
+#define YT8614_REG_COM_HIDE_LED25_CFG 0xA06D
+#define YT8614_REG_COM_HIDE_LED26_CFG 0xA06E
+#define YT8614_REG_COM_HIDE_LED27_CFG 0xA06F
+#endif
+
+#define YT8614_REG_COM_HIDE_LED28_CFG 0xA070
+#define YT8614_REG_COM_HIDE_LED29_CFG 0xA071
+#define YT8614_REG_COM_HIDE_LED30_CFG 0xA072
+#define YT8614_REG_COM_HIDE_LED31_CFG 0xA073
+#define YT8614_REG_COM_HIDE_LED32_CFG 0xA074
+#define YT8614_REG_COM_HIDE_LED33_CFG 0xA075
+#define YT8614_REG_COM_HIDE_LED34_CFG 0xA076
+#define YT8614_REG_COM_HIDE_LED35_CFG 0xA077
+
+#define YT8614_REG_COM_PKG_CFG0       0xA0A0
+#define YT8614_REG_COM_PKG_CFG1       0xA0A1
+#define YT8614_REG_COM_PKG_CFG2       0xA0A2
+#define YT8614_REG_COM_PKG_RX_VALID0  0xA0A3
+#define YT8614_REG_COM_PKG_RX_VALID1  0xA0A4
+#define YT8614_REG_COM_PKG_RX_OS0     0xA0A5
+#define YT8614_REG_COM_PKG_RX_OS1     0xA0A6
+#define YT8614_REG_COM_PKG_RX_US0     0xA0A7
+#define YT8614_REG_COM_PKG_RX_US1     0xA0A8
+#define YT8614_REG_COM_PKG_RX_ERR     0xA0A9
+#define YT8614_REG_COM_PKG_RX_OS_BAD  0xA0AA
+#define YT8614_REG_COM_PKG_RX_FRAG    0xA0AB
+#define YT8614_REG_COM_PKG_RX_NOSFD   0xA0AC
+#define YT8614_REG_COM_PKG_TX_VALID0  0xA0AD
+#define YT8614_REG_COM_PKG_TX_VALID1  0xA0AE
+#define YT8614_REG_COM_PKG_TX_OS0     0xA0AF
+
+#define YT8614_REG_COM_PKG_TX_OS1     0xA0B0
+#define YT8614_REG_COM_PKG_TX_US0     0xA0B1
+#define YT8614_REG_COM_PKG_TX_US1     0xA0B2
+#define YT8614_REG_COM_PKG_TX_ERR     0xA0B3
+#define YT8614_REG_COM_PKG_TX_OS_BAD  0xA0B4
+#define YT8614_REG_COM_PKG_TX_FRAG    0xA0B5
+#define YT8614_REG_COM_PKG_TX_NOSFD   0xA0B6
+#define YT8614_REG_COM_PKG_CFG3       0xA0B7
+#define YT8614_REG_COM_PKG_AZ_CFG     0xA0B8
+#define YT8614_REG_COM_PKG_DA_SA_CFG3 0xA0B9
+
+#define YT8614_REG_COM_MANU_HW_RESET  0xA0C0
+
+/* YT8614 UTP MII register: same as generic phy register definitions */
+#define REG_MII_BMCR          0x00    /* Basic mode control register */
+#define REG_MII_BMSR          0x01    /* Basic mode status register  */
+#define REG_MII_PHYSID1       0x02    /* PHYS ID 1                   */
+#define REG_MII_PHYSID2       0x03    /* PHYS ID 2                   */
+#define REG_MII_ADVERTISE     0x04    /* Advertisement control reg   */
+#define REG_MII_LPA           0x05    /* Link partner ability reg    */
+#define REG_MII_EXPANSION     0x06    /* Expansion register          */
+#define REG_MII_NEXT_PAGE     0x07    /* Next page register          */
+#define REG_MII_LPR_NEXT_PAGE 0x08    /* LPR next page register      */
+#define REG_MII_CTRL1000      0x09    /* 1000BASE-T control          */
+#define REG_MII_STAT1000      0x0A    /* 1000BASE-T status           */
+
+#define REG_MII_MMD_CTRL      0x0D    /* MMD access control register */
+#define REG_MII_MMD_DATA      0x0E    /* MMD access data register    */
+
+#define REG_MII_ESTATUS       0x0F    /* Extended Status             */
+#define REG_MII_SPEC_CTRL     0x10    /* PHY specific func control   */
+#define REG_MII_SPEC_STATUS   0x11    /* PHY specific status         */
+#define REG_MII_INT_MASK      0x12    /* Interrupt mask register     */
+#define REG_MII_INT_STATUS    0x13    /* Interrupt status register   */
+#define REG_MII_DOWNG_CTRL    0x14    /* Speed auto downgrade control*/
+#define REG_MII_RERRCOUNTER   0x15    /* Receive error counter       */
+
+#define REG_MII_EXT_ADDR      0x1E    /* Extended reg's address      */
+#define REG_MII_EXT_DATA      0x1F    /* Extended reg's date         */
+
+#ifndef MII_BMSR
+#define MII_BMSR						REG_MII_BMSR
+#endif
+
+#ifndef YT8614_SPEED_MODE_BIT
+#define YT8614_SPEED_MODE		0xc000
+#define YT8614_DUPLEX			0x2000
+#define YT8614_SPEED_MODE_BIT		14
+#define YT8614_DUPLEX_BIT		13
+#define YT8614_LINK_STATUS_BIT		10
+
+#endif
+
+#define YT8614_REG_COM_HIDE_SPEED_CMB_PRI		0x2000
+
+/* YT8614 UTP MMD register  */
+#define YT8614_REG_UTP_MMD_CTRL1           0x00    /* PCS control 1 register     */
+#define YT8614_REG_UTP_MMD_STATUS1         0x01    /* PCS status 1 register      */
+#define YT8614_REG_UTP_MMD_EEE_CTRL        0x14    /* EEE control and capability */
+#define YT8614_REG_UTP_MMD_EEE_WK_ERR_CNT  0x16    /* EEE wake error counter     */
+#define YT8614_REG_UTP_MMD_EEE_LOCAL_ABI   0x3C    /* local device EEE ability   */
+#define YT8614_REG_UTP_MMD_EEE_LP_ABI      0x3D    /* link partner EEE ability   */
+#define YT8614_REG_UTP_MMD_EEE_AUTONEG_RES 0x8000  /* autoneg result of EEE      */
+
+/* YT8614 UTP EXT register  */
+#define YT8614_REG_UTP_EXT_LPBK        0x0A
+#define YT8614_REG_UTP_EXT_SLEEP_CTRL1 0x27
+#define YT8614_REG_UTP_EXT_DEBUG_MON1  0x5A
+#define YT8614_REG_UTP_EXT_DEBUG_MON2  0x5B
+#define YT8614_REG_UTP_EXT_DEBUG_MON3  0x5C
+#define YT8614_REG_UTP_EXT_DEBUG_MON4  0x5D
+
+/* YT8614 SDS(1.25G/5G) MII register: same as YT8521S */
+#define REG_SDS_BMCR          0x00    /* Basic mode control register */
+#define REG_SDS_BMSR          0x01    /* Basic mode status register  */
+#define REG_SDS_PHYSID1       0x02    /* PHYS ID 1                   */
+#define REG_SDS_PHYSID2       0x03    /* PHYS ID 2                   */
+#define REG_SDS_ADVERTISE     0x04    /* Advertisement control reg   */
+#define REG_SDS_LPA           0x05    /* Link partner ability reg    */
+#define REG_SDS_EXPANSION     0x06    /* Expansion register          */
+#define REG_SDS_NEXT_PAGE     0x07    /* Next page register          */
+#define REG_SDS_LPR_NEXT_PAGE 0x08    /* LPR next page register      */
+
+#define REG_SDS_ESTATUS       0x0F    /* Extended Status             */
+#define REG_SDS_SPEC_STATUS   0x11    /* SDS specific status         */
+
+#define REG_SDS_100FX_CFG     0x14    /* 100fx cfg                   */
+#define REG_SDS_RERRCOUNTER   0x15    /* Receive error counter       */
+#define REG_SDS_LINT_FAIL_CNT 0x16    /* Lint fail counter mon       */
+
+/* YT8614 SDS(5G) EXT register */
+#define YT8614_REG_QSGMII_EXT_ANA_DIG_CFG 0x02    /* sds analog digital interface cfg */
+#define YT8614_REG_QSGMII_EXT_PRBS_CFG1   0x05    /* sds prbs cfg1 */
+#define YT8614_REG_QSGMII_EXT_PRBS_CFG2_1 0x06    /* sds prbs cfg2 */
+#define YT8614_REG_QSGMII_EXT_PRBS_CFG2_2 0x07    /* sds prbs cfg2 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON1   0x08    /* sds prbs mon1 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON2   0x09    /* sds prbs mon2 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON3   0x0A    /* sds prbs mon3 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON4   0x0B    /* sds prbs mon4 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON5   0x0C    /* sds prbs mon5 */
+#define YT8614_REG_QSGMII_EXT_ANA_CFG2    0xA1    /* Analog cfg2   */
+
+/* YT8614 SDS(1.25G) EXT register */
+#define YT8614_REG_SGMII_EXT_PRBS_CFG1    0x05    /* sds prbs cfg1 */
+#define YT8614_REG_SGMII_EXT_PRBS_CFG2    0x06    /* sds prbs cfg2 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON1    0x08    /* sds prbs mon1 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON2    0x09    /* sds prbs mon2 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON3    0x0A    /* sds prbs mon3 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON4    0x0B    /* sds prbs mon4 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON5    0x0C    /* sds prbs mon5 */
+#define YT8614_REG_SGMII_EXT_ANA_CFG2     0xA1    /* Analog cfg2   */
+#define YT8614_REG_SGMII_EXT_HIDE_AUTO_SEN 0xA5   /* Fiber auto sensing */
+
+////////////////////////////////////////////////////////////////////
+#define YT8614_MMD_DEV_ADDR1     0x1
+#define YT8614_MMD_DEV_ADDR3     0x3
+#define YT8614_MMD_DEV_ADDR7     0x7
+#define YT8614_MMD_DEV_ADDR_NONE 0xFF
+
+/**********YT8521S************************************************/
+/* Basic mode control register(0x00) */
+#define BMCR_RESV         0x003f  /* Unused...                   */
+#define BMCR_SPEED1000    0x0040  /* MSB of Speed (1000)         */
+#define BMCR_CTST         0x0080  /* Collision test              */
+#define BMCR_FULLDPLX     0x0100  /* Full duplex                 */
+#define BMCR_ANRESTART    0x0200  /* Auto negotiation restart    */
+#define BMCR_ISOLATE      0x0400  /* Disconnect DP83840 from MII */
+#define BMCR_PDOWN        0x0800  /* Powerdown the DP83840       */
+#define BMCR_ANENABLE     0x1000  /* Enable auto negotiation     */
+#define BMCR_SPEED100     0x2000  /* Select 100Mbps              */
+#define BMCR_LOOPBACK     0x4000  /* TXD loopback bits           */
+#define BMCR_RESET        0x8000  /* Reset the DP83840           */
+
+/* Basic mode status register(0x01) */
+#define BMSR_ERCAP        0x0001  /* Ext-reg capability          */
+#define BMSR_JCD          0x0002  /* Jabber detected             */
+#define BMSR_LSTATUS      0x0004  /* Link status                 */
+#define BMSR_ANEGCAPABLE  0x0008  /* Able to do auto-negotiation */
+#define BMSR_RFAULT       0x0010  /* Remote fault detected       */
+#define BMSR_ANEGCOMPLETE 0x0020  /* Auto-negotiation complete   */
+#define BMSR_RESV         0x00c0  /* Unused...                   */
+#define BMSR_ESTATEN      0x0100  /* Extended Status in R15      */
+#define BMSR_100HALF2     0x0200  /* Can do 100BASE-T2 HDX       */
+#define BMSR_100FULL2     0x0400  /* Can do 100BASE-T2 FDX       */
+#define BMSR_10HALF       0x0800  /* Can do 10mbps, half-duplex  */
+#define BMSR_10FULL       0x1000  /* Can do 10mbps, full-duplex  */
+#define BMSR_100HALF      0x2000  /* Can do 100mbps, half-duplex */
+#define BMSR_100FULL      0x4000  /* Can do 100mbps, full-duplex */
+#define BMSR_100BASE4     0x8000  /* Can do 100mbps, 4k packets  */
+
+/* Advertisement control register(0x04) */
+#define ADVERTISE_SLCT          0x001f  /* Selector bits               */
+#define ADVERTISE_CSMA          0x0001  /* Only selector supported     */
+#define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
+#define ADVERTISE_1000XFULL     0x0020  /* Try for 1000BASE-X full-duplex */
+#define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
+#define ADVERTISE_1000XHALF     0x0040  /* Try for 1000BASE-X half-duplex */
+#define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
+#define ADVERTISE_1000XPAUSE    0x0080  /* Try for 1000BASE-X pause    */
+#define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
+#define ADVERTISE_1000XPSE_ASYM 0x0100  /* Try for 1000BASE-X asym pause */
+#define ADVERTISE_100BASE4      0x0200  /* Try for 100mbps 4k packets  */
+#define ADVERTISE_PAUSE_CAP     0x0400  /* Try for pause               */
+#define ADVERTISE_PAUSE_ASYM    0x0800  /* Try for asymetric pause     */
+#define ADVERTISE_RESV          0x1000  /* Unused...                   */
+#define ADVERTISE_RFAULT        0x2000  /* Say we can detect faults    */
+#define ADVERTISE_LPACK         0x4000  /* Ack link partners response  */
+#define ADVERTISE_NPAGE         0x8000  /* Next page bit               */
+
+#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | ADVERTISE_CSMA)
+#define ADVERTISE_ALL  (ADVERTISE_10HALF  | ADVERTISE_10FULL | \
+                        ADVERTISE_100HALF | ADVERTISE_100FULL)
+
+/* Link partner ability register(0x05) */
+#define LPA_SLCT              0x001f  /* Same as advertise selector    */
+#define LPA_10HALF            0x0020  /* Can do 10mbps half-duplex     */
+#define LPA_1000XFULL         0x0020  /* Can do 1000BASE-X full-duplex */
+#define LPA_10FULL            0x0040  /* Can do 10mbps full-duplex     */
+#define LPA_1000XHALF         0x0040  /* Can do 1000BASE-X half-duplex */
+#define LPA_100HALF           0x0080  /* Can do 100mbps half-duplex    */
+#define LPA_1000XPAUSE        0x0080  /* Can do 1000BASE-X pause       */
+#define LPA_100FULL           0x0100  /* Can do 100mbps full-duplex    */
+#define LPA_1000XPAUSE_ASYM   0x0100  /* Can do 1000BASE-X pause asym  */
+#define LPA_100BASE4          0x0200  /* Can do 100mbps 4k packets     */
+#define LPA_PAUSE_CAP         0x0400  /* Can pause                     */
+#define LPA_PAUSE_ASYM        0x0800  /* Can pause asymetrically       */
+#define LPA_RESV              0x1000  /* Unused...                     */
+#define LPA_RFAULT            0x2000  /* Link partner faulted          */
+#define LPA_LPACK             0x4000  /* Link partner acked us         */
+#define LPA_NPAGE             0x8000  /* Next page bit                 */
+
+/* 1000BASE-T Control register(0x09) */
+#define ADVERTISE_1000FULL    0x0200  /* Advertise 1000BASE-T full duplex */
+#define ADVERTISE_1000HALF    0x0100  /* Advertise 1000BASE-T half duplex */
+#define CTL1000_AS_MASTER     0x0800
+#define CTL1000_ENABLE_MASTER 0x1000
+
+/* 1000BASE-T Status register(0x0A) */
+#define LPA_1000LOCALRXOK     0x2000  /* Link partner local receiver status  */
+#define LPA_1000REMRXOK       0x1000  /* Link partner remote receiver status */
+#define LPA_1000FULL          0x0800  /* Link partner 1000BASE-T full duplex */
+#define LPA_1000HALF          0x0400  /* Link partner 1000BASE-T half duplex */
+
+/**********YT8614************************************************/
+/* Basic mode control register(0x00) */
+#define FIBER_BMCR_RESV        0x001f  /* b[4:0] Unused...                      */
+#define FIBER_BMCR_EN_UNIDIR   0x0020  /* b[5]   Valid when bit 0.12 is zero and bit 0.8 is one */
+#define FIBER_BMCR_SPEED1000   0x0040  /* b[6]   MSB of Speed (1000)            */
+#define FIBER_BMCR_CTST        0x0080  /* b[7]   Collision test                 */
+#define FIBER_BMCR_DUPLEX_MODE 0x0100  /* b[8]   Duplex mode                    */
+#define FIBER_BMCR_ANRESTART   0x0200  /* b[9]   Auto negotiation restart       */
+#define FIBER_BMCR_ISOLATE     0x0400  /* b[10]  Isolate phy from RGMII/SGMII/FIBER */
+#define FIBER_BMCR_PDOWN       0x0800  /* b[11]  1: Power down                  */
+#define FIBER_BMCR_ANENABLE    0x1000  /* b[12]  Enable auto negotiation        */
+#define FIBER_BMCR_SPEED100    0x2000  /* b[13]  LSB of Speed (100)             */
+#define FIBER_BMCR_LOOPBACK    0x4000  /* b[14]  Internal loopback control      */
+#define FIBER_BMCR_RESET       0x8000  /* b[15]  PHY Software Reset(self-clear) */
+
+/* Sds specific status register(0x11) */
+#define FIBER_SSR_ERCAP          0x0001  /* b[0]     realtime syncstatus */
+#define FIBER_SSR_XMIT           0x000E  /* b[3:1]   realtime transmit statemachine.
+                                                     001: Xmit Idle;
+                                                     010: Xmit Config; 
+                                                     100: Xmit Data. */
+#define FIBER_SSR_SER_MODE_CFG   0x0030  /* b[5:4]   realtime serdes working mode.
+                                                     00: SG_MAC;
+                                                     01: SG_PHY;
+                                                     10: FIB_1000;
+                                                     11: FIB_100. */
+#define FIBER_SSR_EN_FLOWCTRL_TX 0x0040  /* b[6]     realtime en_flowctrl_tx */
+#define FIBER_SSR_EN_FLOWCTRL_RX 0x0080  /* b[7]     realtime en_flowctrl_rx */
+#define FIBER_SSR_DUPLEX_ERROR   0x0100  /* b[8]     realtime deplex error */
+#define FIBER_SSR_RX_LPI_ACTIVE  0x0200  /* b[9]     rx lpi is active */
+#define FIBER_SSR_LSTATUS        0x0400  /* b[10]    Link status real-time */
+#define FIBER_SSR_PAUSE          0x1800  /* b[12:11] Pause to mac */
+#define FIBER_SSR_DUPLEX         0x2000  /* b[13]    This status bit is valid only when bit10 is 1.
+                                                     1: full duplex 
+                                                     0: half duplex */
+#define FIBER_SSR_SPEED_MODE     0xC000  /* b[15:14] These status bits are valid only when bit10 is 1.
+                                                     10---1000M 
+                                                     01---100M */
+
+/* SLED cfg0 (ext 0xA001) */
+#define FIBER_SLED_CFG0_EN_CTRL  0x00FF  /* b[7:0]   Control to enable the eight ports' SLED */
+#define FIBER_SLED_CFG0_BIT_MASK 0x0700  /* b[10:8]  1: enable the pin output */
+#define FIBER_SLED_CFG0_ACT_LOW  0x0800  /* b[11]    control SLED's polarity. 1: active low; 0: active high */
+#define FIBER_SLED_CFG0_MANU_ST  0x7000  /* b[14:12] SLEDs' manul status, corresponding to each port's 3 SLEDs */
+#define FIBER_SLED_CFG0_MANU_EN  0x8000  /* b[15]    to control serial LEDs status manually */
+
+/**********YT8614************************************************/
+/* Fiber auto sensing(sgmii ext 0xA5) */
+#define FIBER_AUTO_SEN_ENABLE    0x8000  /* b[15]  Enable fiber auto sensing */
+
+/* Fiber force speed(common ext 0xA009) */
+#define FIBER_FORCE_1000M        0x0001  /* b[0]  1:1000BX 0:100FX */
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+/* errno */
+enum ytphy_8614_errno_e
+{
+	SYS_E_NONE,
+	SYS_E_PARAM,
+	SYS_E_MAX
+};
+
+/* errno */
+enum ytphy_8614_combo_speed_e
+{
+	YT8614_COMBO_FIBER_1000M,
+	YT8614_COMBO_FIBER_100M,
+	YT8614_COMBO_UTP_ONLY,
+	YT8614_COMBO_SPEED_MAX
+};
+
+/* definition for porting */
+/* phy registers access */
+typedef struct
+{
+    u16 reg;     /* the offset of the phy internal address */
+    u16 val;     /* the value of the register */
+    u8  regType; /* register type */
+} phy_data_s;
+
+/* for porting use.
+ * pls over-write member function read/write for mdio access
+ */
+typedef struct phy_info_str
+{
+#if 0
+    struct phy_device *phydev;
+	int mdio_base;
+#endif
+	unsigned int lport;
+	unsigned int bus_id;
+	unsigned int phy_addr;
+
+    s32 (*read)(struct phy_info_str *info, phy_data_s *param);
+    s32 (*write)(struct phy_info_str *info, phy_data_s *param);
+}phy_info_s;
+
+/* get phy access method */
+s32 yt8614_read_reg(struct phy_info_str *info, phy_data_s *param);
+s32 yt8614_write_reg(struct phy_info_str *info, phy_data_s *param);
+s32 yt8614_phy_soft_reset(u32 lport);
+s32 yt8614_phy_init(u32 lport);
+s32 yt8614_fiber_enable(u32 lport, BOOL enable);
+s32 yt8614_utp_enable(u32 lport, BOOL enable);
+s32 yt8614_fiber_unidirection_set(u32 lport, int speed, BOOL enable);
+s32 yt8614_fiber_autosensing_set(u32 lport, BOOL enable);
+s32 yt8614_fiber_speed_set(u32 lport, int fiber_speed);
+s32 yt8614_qsgmii_autoneg_set(u32 lport, BOOL enable);
+s32 yt8614_sgmii_autoneg_set(u32 lport, BOOL enable);
+s32 yt8614_qsgmii_sgmii_link_status_get(u32 lport, BOOL *enable, BOOL if_qsgmii);
+int yt8614_combo_media_priority_set (u32 lport, int fiber);
+int yt8614_combo_media_priority_get (u32 lport, int *fiber);
+s32 yt8614_utp_autoneg_set(u32 lport, BOOL enable);
+s32 yt8614_utp_autoneg_get(u32 lport, BOOL *enable);
+s32 yt8614_utp_autoneg_ability_set(u32 lport, unsigned int cap_mask);
+s32 yt8614_utp_autoneg_ability_get(u32 lport, unsigned int *cap_mask);
+s32 yt8614_utp_force_duplex_set(u32 lport, BOOL full);
+s32 yt8614_utp_force_duplex_get(u32 lport, BOOL *full);
+s32 yt8614_utp_force_speed_set(u32 lport, unsigned int speed);
+s32 yt8614_utp_force_speed_get(u32 lport, unsigned int *speed);
+int yt8614_autoneg_done_get (u32 lport, int speed, int *aneg);
+int yt8614_media_status_get(u32 lport, int* speed, int* duplex, int* ret_link, int *media);
+
+#endif
diff --git a/include/linux/motorcomm_phy.h b/include/linux/motorcomm_phy.h
new file mode 100644
index 000000000000..9e01fc205789
--- /dev/null
+++ b/include/linux/motorcomm_phy.h
@@ -0,0 +1,119 @@
+/*
+ * include/linux/motorcomm_phy.h
+ *
+ * Motorcomm PHY IDs
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _MOTORCOMM_PHY_H
+#define _MOTORCOMM_PHY_H
+
+#define MOTORCOMM_PHY_ID_MASK	0x00000fff
+#define MOTORCOMM_PHY_ID_8531_MASK	0xffffffff
+#define MOTORCOMM_MPHY_ID_MASK	0x0000ffff
+
+#define PHY_ID_YT8010		0x00000309
+#define PHY_ID_YT8510		0x00000109
+#define PHY_ID_YT8511		0x0000010a
+#define PHY_ID_YT8512		0x00000118
+#define PHY_ID_YT8512B		0x00000128
+#define PHY_ID_YT8521		0x0000011a
+#define PHY_ID_YT8531S		0x4f51e91a
+#define PHY_ID_YT8531		0x4f51e91b
+//#define PHY_ID_YT8614		0x0000e899
+#define PHY_ID_YT8618		0x0000e889
+
+#define REG_PHY_SPEC_STATUS		0x11
+#define REG_DEBUG_ADDR_OFFSET		0x1e
+#define REG_DEBUG_DATA			0x1f
+
+#define YT8512_EXTREG_AFE_PLL		0x50
+#define YT8512_EXTREG_EXTEND_COMBO	0x4000
+#define YT8512_EXTREG_LED0		0x40c0
+#define YT8512_EXTREG_LED1		0x40c3
+
+#define YT8512_EXTREG_SLEEP_CONTROL1	0x2027
+
+#define YT_SOFTWARE_RESET		0x8000
+
+#define YT8512_CONFIG_PLL_REFCLK_SEL_EN	0x0040
+#define YT8512_CONTROL1_RMII_EN		0x0001
+#define YT8512_LED0_ACT_BLK_IND		0x1000
+#define YT8512_LED0_DIS_LED_AN_TRY	0x0001
+#define YT8512_LED0_BT_BLK_EN		0x0002
+#define YT8512_LED0_HT_BLK_EN		0x0004
+#define YT8512_LED0_COL_BLK_EN		0x0008
+#define YT8512_LED0_BT_ON_EN		0x0010
+#define YT8512_LED1_BT_ON_EN		0x0010
+#define YT8512_LED1_TXACT_BLK_EN	0x0100
+#define YT8512_LED1_RXACT_BLK_EN	0x0200
+#define YT8512_SPEED_MODE		0xc000
+#define YT8512_DUPLEX			0x2000
+
+#define YT8512_SPEED_MODE_BIT		14
+#define YT8512_DUPLEX_BIT		13
+#define YT8512_EN_SLEEP_SW_BIT		15
+
+#define YT8521_EXTREG_SLEEP_CONTROL1	0x27
+#define YT8521_EN_SLEEP_SW_BIT		15
+
+#define YT8521_SPEED_MODE		0xc000
+#define YT8521_DUPLEX			0x2000
+#define YT8521_SPEED_MODE_BIT		14
+#define YT8521_DUPLEX_BIT		13
+#define YT8521_LINK_STATUS_BIT		10
+
+/* based on yt8521 wol config register */
+#define YTPHY_UTP_INTR_REG             0x12
+/* WOL Event Interrupt Enable */
+#define YTPHY_WOL_INTR            BIT(6)
+
+/* Magic Packet MAC address registers */
+#define YTPHY_MAGIC_PACKET_MAC_ADDR2                 0xa007
+#define YTPHY_MAGIC_PACKET_MAC_ADDR1                 0xa008
+#define YTPHY_MAGIC_PACKET_MAC_ADDR0                 0xa009
+
+#define YTPHY_WOL_CFG_REG		0xa00a
+#define YTPHY_WOL_CFG_TYPE		BIT(0)	/* WOL TYPE */
+#define YTPHY_WOL_CFG_EN		BIT(3)	/* WOL Enable */
+#define YTPHY_WOL_CFG_INTR_SEL	BIT(6)	/* WOL Event Interrupt Enable */
+#define YTPHY_WOL_CFG_WIDTH1	BIT(1)	/* WOL Pulse Width */
+#define YTPHY_WOL_CFG_WIDTH2	BIT(2)
+
+#define YTPHY_REG_SPACE_UTP             0
+#define YTPHY_REG_SPACE_FIBER           2
+
+enum ytphy_wol_type_e
+{
+    YTPHY_WOL_TYPE_LEVEL,
+    YTPHY_WOL_TYPE_PULSE,
+    YTPHY_WOL_TYPE_MAX
+};
+typedef enum ytphy_wol_type_e ytphy_wol_type_t;
+
+enum ytphy_wol_width_e
+{
+    YTPHY_WOL_WIDTH_84MS,
+    YTPHY_WOL_WIDTH_168MS,
+    YTPHY_WOL_WIDTH_336MS,
+    YTPHY_WOL_WIDTH_672MS,
+    YTPHY_WOL_WIDTH_MAX
+};
+typedef enum ytphy_wol_width_e ytphy_wol_width_t;
+
+struct ytphy_wol_cfg_s
+{
+    int enable;
+    int type;
+    int width;
+};
+typedef struct ytphy_wol_cfg_s ytphy_wol_cfg_t;
+
+#endif /* _MOTORCOMM_PHY_H */
+
+
-- 
Armbian

