From 9f4a6fdd4ddc4234846946e9b087fc727c508cdc Mon Sep 17 00:00:00 2001
From: Ondrej Jirman <megous@megous.com>
Date: Mon, 30 Nov 2020 06:11:11 +0100
Subject: [PATCH 258/351] usb: typec: anx7688: Update input current limit
 respecting PD SRC_CAPs

Previously the limit was bumped solely based on CC pins, which is not
standards compliant. The device should wait for PD power negotiation
before falling back to using resistors on CC pins to see what it can
sink.

Let's still use auto_pd, but wait for SRC_CAPs. FW will send SRC_CAPs
when PD it generates the RDO for the SOURCE, but before source ACCEPTS
it.

We perform input current update with a timer:

- 3s after connecting the cable if no PD source caps are received
- 0.5s after PD source caps are received

It's still possible that RDO generated by FW will get rejected,
but unlikely. In that situation we would overload the source. That
usually leads to hard reset and restart of the negotiation. This
may lead to infinite loop. I guess it's unlikely.

It's probably better to wait for ACCEPT on the RDO. We can't recover
anyway while using auto_pd mode of the FW.

Signed-off-by: Ondrej Jirman <megous@megous.com>
---
 drivers/usb/typec/anx7688.c | 292 +++++++++++++++++++++++-------------
 1 file changed, 185 insertions(+), 107 deletions(-)

diff --git a/drivers/usb/typec/anx7688.c b/drivers/usb/typec/anx7688.c
index 89ecdc844000..39c817e0235f 100644
--- a/drivers/usb/typec/anx7688.c
+++ b/drivers/usb/typec/anx7688.c
@@ -159,6 +159,7 @@ enum {
 	ANX7688_F_CONNECTED,
 	ANX7688_F_FW_FAILED,
 	ANX7688_F_PWRSUPPLY_CHANGE,
+	ANX7688_F_CURRENT_UPDATE,
 };
 
 struct anx7688 {
@@ -168,7 +169,7 @@ struct anx7688 {
         struct regulator_bulk_data supplies[ANX7688_NUM_SUPPLIES];
 	struct power_supply *vbus_in_supply;
 	struct notifier_block vbus_in_nb;
-	int current_limit;
+	int input_current_limit; // mA
         struct gpio_desc *gpio_enable;
         struct gpio_desc *gpio_reset;
         struct gpio_desc *gpio_cabledet;
@@ -187,6 +188,8 @@ struct anx7688 {
         struct mutex lock;
         bool vbus_on, vconn_on;
 	bool pd_capable;
+	int pd_current_limit; // mA
+	struct timer_list nopd_timer;
 
         struct typec_port *port;
         struct typec_partner *partner;
@@ -521,6 +524,11 @@ static int anx7688_connect(struct anx7688 *anx7688)
 		goto err_vconoff;
 	}
 
+	// after this timer fires we'll check if device is pd_capable and
+	// set up the current limit accordingly
+	mod_timer(&anx7688->nopd_timer, jiffies + msecs_to_jiffies(3000));
+	clear_bit(ANX7688_F_CURRENT_UPDATE, anx7688->flags);
+
 	set_bit(ANX7688_F_CONNECTED, anx7688->flags);
         return 0;
 
@@ -541,6 +549,8 @@ static void anx7688_disconnect(struct anx7688 *anx7688)
 
         dev_dbg(dev, "cable removed\n");
 
+	del_timer_sync(&anx7688->nopd_timer);
+
 	if (anx7688->vconn_on) {
 		regulator_disable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
 		anx7688->vconn_on = false;
@@ -626,6 +636,14 @@ static irqreturn_t anx7688_irq_plug_handler(int irq, void *data)
         return IRQ_HANDLED;
 }
 
+static void anx7688_nopd_timer_fn(struct timer_list *t)
+{
+	struct anx7688 *anx7688 = from_timer(anx7688, t, nopd_timer);
+
+	set_bit(ANX7688_F_CURRENT_UPDATE, anx7688->flags);
+	schedule_delayed_work(&anx7688->work, 0);
+}
+
 enum {
 	CMD_SUCCESS,
 	CMD_REJECT,
@@ -685,21 +703,24 @@ static int anx7688_handle_pd_message_response(struct anx7688* anx7688,
 static int anx7688_handle_pd_message(struct anx7688* anx7688,
 				     u8 cmd, u8* msg, unsigned len)
 {
+	struct device *dev = anx7688->dev;
+	union power_supply_propval psy_val = {0,};
 	uint32_t* pdos = (uint32_t*)msg;
+        int ret, i, rdo_max_v, rdo_max_p;
 	uint32_t pdo, rdo;
-        int ret, i;
 
 	switch (cmd) {
 	case ANX7688_OCM_MSG_PWR_SRC_CAP:
 		dev_info(anx7688->dev, "received SRC_CAP\n");
 
-		anx7688->pd_capable = true;
-
                 if (len % 4 != 0) {
 			dev_warn(anx7688->dev, "received invalid sized PDO array\n");
 			break;
 		}
 
+		/* the partner is PD capable */
+		anx7688->pd_capable = true;
+
 		for (i = 0; i < len / 4; i++) {
 			pdo = le32_to_cpu(pdos[i]);
 
@@ -725,6 +746,30 @@ static int anx7688_handle_pd_message(struct anx7688* anx7688,
 			}
 		}
 
+		/* when auto_pd mode is enabled, the FW has already set
+		 * RDO_MAX_VOLTAGE and RDO_MAX_POWER for the RDO it sent to the
+		 * partner based on the received SOURCE_CAPs. This does not
+		 * mean, the request was acked, but we can't do better here than
+		 * calculate the current_limit to set later and hope for the best.
+		 */
+		rdo_max_v = anx7688_reg_read(anx7688, ANX7688_REG_MAX_VOLTAGE_STATUS);
+		if (rdo_max_v < 0)
+			return rdo_max_v;
+		if (rdo_max_v == 0)
+			return -EINVAL;
+
+		rdo_max_p = anx7688_reg_read(anx7688, ANX7688_REG_MAX_POWER_STATUS);
+		if (rdo_max_p < 0)
+			return rdo_max_p;
+
+		anx7688->pd_current_limit = rdo_max_p * 5000 / rdo_max_v;
+
+		dev_dbg(anx7688->dev, "RDO max voltage = %dmV, max power = %dmW, PD current limit = %dmA\n",
+			rdo_max_v * 100, rdo_max_p * 500, anx7688->pd_current_limit);
+
+		// update current limit sooner, now that we have PD negotiation result
+		mod_timer(&anx7688->nopd_timer, jiffies + msecs_to_jiffies(500));
+
 		//TODO: we should go through PDOs and decide which one
 		//to request, build a RDO with a proper index of the
 		//selected PDO and send it via PWR_OBJ_REQ message to FW
@@ -949,103 +994,6 @@ static const char* anx7688_cc_status_string(unsigned v)
 	}
 }
 
-static int anx7688_cc_status(unsigned v)
-{
-	switch (v) {
-	case 0: return -1;
-	case 1: return -1;
-	case 2: return -1;
-	case 4: return TYPEC_PWR_MODE_USB;
-	case 8: return TYPEC_PWR_MODE_1_5A;
-	case 12: return TYPEC_PWR_MODE_3_0A;
-	default: return -1;
-	}
-}
-
-static int anx7688_update_cc_status(struct anx7688 *anx7688, int cc_status)
-{
-        struct device *dev = anx7688->dev;
-	union power_supply_propval val = {0,};
-	int cc1, cc2, cc = -1, ret;
-
-	cc1 = anx7688_cc_status(cc_status & 0xf);
-	cc2 = anx7688_cc_status((cc_status >> 4) & 0xf);
-	if (cc1 >= 0) {
-		cc = cc1;
-	} else if (cc2 >= 0) {
-		cc = cc2;
-	}
-
-	if (cc < 0)
-		return 0;
-
-	anx7688->current_limit = 0;
-	if (cc == TYPEC_PWR_MODE_1_5A)
-		anx7688->current_limit = 1500 * 1000;
-	else if (cc == TYPEC_PWR_MODE_3_0A)
-		anx7688->current_limit = 3000 * 1000;
-
-	if (anx7688->current_limit) {
-		/*
-		 * Disable BC1.2 detection, because we'll be setting
-		 * a current limit determined by USB-PD
-		 */
-		val.intval = 0;
-		dev_dbg(dev, "disabling USB BC 1.2 detection\n");
-		ret = power_supply_set_property(anx7688->vbus_in_supply,
-						POWER_SUPPLY_PROP_USB_BC_ENABLED,
-						&val);
-		if (ret)
-			dev_err(dev, "failed to disable USB BC1.2 detection\n");
-
-		val.intval = anx7688->current_limit;
-		dev_dbg(dev, "setting vbus_in current limit to %d mA\n", val.intval);
-		ret = power_supply_set_property(anx7688->vbus_in_supply,
-						POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
-						&val);
-		if (ret)
-			dev_err(dev, "failed to set vbus_in current to %d mA\n",
-				val.intval / 1000);
-	} else {
-		/*
-		 * Use the result of BC1.2 detection performed by PMIC.
-		 */
-		ret = power_supply_get_property(anx7688->vbus_in_supply,
-						POWER_SUPPLY_PROP_USB_BC_ENABLED,
-						&val);
-		if (ret)
-			dev_err(dev, "failed to get USB BC1.2 detection status\n");
-
-		if (ret != 0 || val.intval == 0) {
-			/*
-			 * If BC is disabled or we can't get its status,
-			 * set conservative 500mA limit. Otherwise leave
-			 * the limit to BC1.2.
-			 */
-			val.intval = 500 * 1000;
-			dev_dbg(dev, "setting vbus_in current limit to %d mA\n", val.intval);
-			ret = power_supply_set_property(anx7688->vbus_in_supply,
-							POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
-							&val);
-			if (ret)
-				dev_err(dev, "failed to set vbus_in current to %d mA\n",
-					val.intval / 1000);
-		}
-	}
-
-	/* Turn on VBUS power path inside PMIC. */
-	val.intval = 1;
-	dev_dbg(dev, "enabling vbus_in power path\n");
-	ret = power_supply_set_property(anx7688->vbus_in_supply,
-					POWER_SUPPLY_PROP_ONLINE,
-					&val);
-	if (ret)
-		dev_err(anx7688->dev, "failed to offline vbus_in\n");
-
-	typec_set_pwr_opmode(anx7688->port, cc);
-	return 0;
-}
-
 static int anx7688_update_status(struct anx7688 *anx7688)
 {
         struct device *dev = anx7688->dev;
@@ -1074,8 +1022,6 @@ static int anx7688_update_status(struct anx7688 *anx7688)
 		dev_dbg(dev, "cc_status changed to CC1 = %s CC2 = %s\n",
 			anx7688_cc_status_string(cc_status & 0xf),
 			anx7688_cc_status_string((cc_status >> 4) & 0xf));
-
-		anx7688_update_cc_status(anx7688, cc_status);
 	}
 
 	if (anx7688->last_dp_state == -1 || anx7688->last_dp_state != dp_state) {
@@ -1676,6 +1622,9 @@ static int anx7688_status_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(anx7688_status);
 
+/*
+ * This is just a 1s watchdog checking the state if cabledet pin.
+ */
 static void anx7688_cabledet_timer_fn(struct timer_list *t)
 {
 	struct anx7688 *anx7688 = from_timer(anx7688, t, work_timer);
@@ -1691,7 +1640,7 @@ static void anx7688_handle_vbus_in_notify(struct anx7688* anx7688)
 	int ret;
 
 	/* PD charger doesn't like this for some reason, so it's disabled for now */
-	if (anx7688->current_limit && false) {
+	if (anx7688->input_current_limit && false) {
 		ret = power_supply_get_property(anx7688->vbus_in_supply,
 						POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
 						&psy_val);
@@ -1700,11 +1649,12 @@ static void anx7688_handle_vbus_in_notify(struct anx7688* anx7688)
 			return;
 		}
 
-		if (psy_val.intval == anx7688->current_limit)
+		if (psy_val.intval == anx7688->input_current_limit)
 			goto check_type;
 
-		psy_val.intval = anx7688->current_limit;
-		dev_dbg(dev, "setting vbus_in current limit to %d mA\n", psy_val.intval);
+		psy_val.intval = anx7688->input_current_limit * 1000;
+		dev_dbg(dev, "setting vbus_in current limit to %d mA\n",
+			psy_val.intval / 1000);
 		ret = power_supply_set_property(anx7688->vbus_in_supply,
 						POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
 						&psy_val);
@@ -1739,6 +1689,127 @@ static void anx7688_handle_vbus_in_notify(struct anx7688* anx7688)
 	}
 }
 
+static int anx7688_cc_status(unsigned v)
+{
+	switch (v) {
+	case 0: return -1;
+	case 1: return -1;
+	case 2: return -1;
+	case 4: return TYPEC_PWR_MODE_USB;
+	case 8: return TYPEC_PWR_MODE_1_5A;
+	case 12: return TYPEC_PWR_MODE_3_0A;
+	default: return -1;
+	}
+}
+
+static const char* anx7688_get_power_mode_name(enum typec_pwr_opmode mode)
+{
+	switch (mode) {
+		case TYPEC_PWR_MODE_USB: return "USB";
+		case TYPEC_PWR_MODE_1_5A: return "1.5A";
+		case TYPEC_PWR_MODE_3_0A: return "3.0A";
+		case TYPEC_PWR_MODE_PD: return "PD";
+		default: return "Unknown";
+	}
+}
+
+/*
+ * This is called after 500ms after connection when the PD contract should have
+ * been negotiated. We should inspect CC pins or PD status here and decide what
+ * input current limit to set.
+ */
+static void anx7688_handle_current_update(struct anx7688* anx7688)
+{
+	unsigned cc_status = anx7688->last_cc_status;
+	union power_supply_propval val = {0,};
+        struct device *dev = anx7688->dev;
+	int pwr_mode, ret, current_limit = 0;
+
+	if (anx7688->pd_capable) {
+		pwr_mode = TYPEC_PWR_MODE_PD;
+	} else if (cc_status < 0) {
+		pwr_mode = TYPEC_PWR_MODE_USB;
+	} else {
+		pwr_mode = anx7688_cc_status(cc_status & 0xf);
+		if (pwr_mode < 0)
+			pwr_mode = anx7688_cc_status((cc_status >> 4) & 0xf);
+		if (pwr_mode < 0)
+			pwr_mode = TYPEC_PWR_MODE_USB;
+	}
+
+	if (pwr_mode == TYPEC_PWR_MODE_1_5A)
+		current_limit = 1500;
+	else if (pwr_mode == TYPEC_PWR_MODE_3_0A)
+		current_limit = 3000;
+	else if (pwr_mode == TYPEC_PWR_MODE_PD)
+		current_limit = anx7688->pd_current_limit;
+
+	anx7688->input_current_limit = current_limit;
+
+	dev_info(anx7688->dev, "updating power mode to %s, current limit %dmA (0 => BC1.2)\n",
+		 anx7688_get_power_mode_name(pwr_mode), current_limit);
+
+	if (current_limit) {
+		/*
+		 * Disable BC1.2 detection, because we'll be setting
+		 * a current limit determined by USB-PD
+		 */
+		val.intval = 0;
+		dev_dbg(dev, "disabling USB BC 1.2 detection\n");
+		ret = power_supply_set_property(anx7688->vbus_in_supply,
+						POWER_SUPPLY_PROP_USB_BC_ENABLED,
+						&val);
+		if (ret)
+			dev_err(dev, "failed to disable USB BC1.2 detection\n");
+
+		val.intval = current_limit * 1000;
+		dev_dbg(dev, "setting vbus_in current limit to %d mA\n", current_limit);
+		ret = power_supply_set_property(anx7688->vbus_in_supply,
+						POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
+						&val);
+		if (ret)
+			dev_err(dev, "failed to set vbus_in current to %d mA\n",
+				current_limit);
+	} else {
+		/*
+		 * Use the result of BC1.2 detection performed by PMIC.
+		 */
+		ret = power_supply_get_property(anx7688->vbus_in_supply,
+						POWER_SUPPLY_PROP_USB_BC_ENABLED,
+						&val);
+		if (ret)
+			dev_err(dev, "failed to get USB BC1.2 detection status\n");
+
+		if (ret != 0 || val.intval == 0) {
+			/*
+			 * If BC is disabled or we can't get its status,
+			 * set conservative 500mA limit. Otherwise leave
+			 * the limit to BC1.2.
+			 */
+			val.intval = 500 * 1000;
+			dev_dbg(dev, "setting vbus_in current limit to %d mA\n",
+				val.intval / 1000);
+			ret = power_supply_set_property(anx7688->vbus_in_supply,
+							POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
+							&val);
+			if (ret)
+				dev_err(dev, "failed to set vbus_in current to %d mA\n",
+					val.intval / 1000);
+		}
+	}
+
+	/* Turn on VBUS power path inside PMIC. */
+	val.intval = 1;
+	dev_dbg(dev, "enabling vbus_in power path\n");
+	ret = power_supply_set_property(anx7688->vbus_in_supply,
+					POWER_SUPPLY_PROP_ONLINE,
+					&val);
+	if (ret)
+		dev_err(anx7688->dev, "failed to enable vbus_in\n");
+
+	typec_set_pwr_opmode(anx7688->port, pwr_mode);
+}
+
 static int anx7688_vbus_in_notify(struct notifier_block *nb,
 				  unsigned long val, void *v)
 {
@@ -1774,6 +1845,9 @@ static void anx7688_work(struct work_struct *work)
 		 * be sure we didn't miss any status interrupts
 		 */
 		anx7688_update_status(anx7688);
+
+		if (test_and_clear_bit(ANX7688_F_CURRENT_UPDATE, anx7688->flags))
+			anx7688_handle_current_update(anx7688);
 	}
 
 	mutex_unlock(&anx7688->lock);
@@ -1981,6 +2055,8 @@ static int anx7688_i2c_probe(struct i2c_client *client,
 
         schedule_delayed_work(&anx7688->work, msecs_to_jiffies(10));
 
+	timer_setup(&anx7688->nopd_timer, anx7688_nopd_timer_fn, 0);
+
 	timer_setup(&anx7688->work_timer, anx7688_cabledet_timer_fn, 0);
 	mod_timer(&anx7688->work_timer, jiffies + msecs_to_jiffies(1000));
 
@@ -2006,6 +2082,8 @@ static int anx7688_i2c_remove(struct i2c_client *client)
 	power_supply_unreg_notifier(&anx7688->vbus_in_nb);
 
 	del_timer_sync(&anx7688->work_timer);
+	del_timer_sync(&anx7688->nopd_timer);
+
         cancel_delayed_work_sync(&anx7688->work);
 
 	if (test_bit(ANX7688_F_CONNECTED, anx7688->flags))
-- 
2.34.0

