From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Patrick Yavitz <pyavitz@armbian.com>
Date: Fri, 21 Jun 2024 11:54:06 -0400
Subject: add spacemit patch set

source: https://gitee.com/bianbu-linux/linux-6.1

Signed-off-by: Patrick Yavitz <pyavitz@armbian.com>
---
 sound/soc/Kconfig         |   1 +
 sound/soc/Makefile        |   1 +
 sound/soc/codecs/es8326.c | 865 +++++++---
 sound/soc/codecs/es8326.h |  37 +-
 4 files changed, 697 insertions(+), 207 deletions(-)

diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 111111111111..222222222222 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -100,6 +100,7 @@ source "sound/soc/uniphier/Kconfig"
 source "sound/soc/ux500/Kconfig"
 source "sound/soc/xilinx/Kconfig"
 source "sound/soc/xtensa/Kconfig"
+source "sound/soc/spacemit/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 111111111111..222222222222 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -68,3 +68,4 @@ obj-$(CONFIG_SND_SOC)	+= uniphier/
 obj-$(CONFIG_SND_SOC)	+= ux500/
 obj-$(CONFIG_SND_SOC)	+= xilinx/
 obj-$(CONFIG_SND_SOC)	+= xtensa/
+obj-$(CONFIG_SND_SOC)	+= spacemit/
diff --git a/sound/soc/codecs/es8326.c b/sound/soc/codecs/es8326.c
index 111111111111..222222222222 100644
--- a/sound/soc/codecs/es8326.c
+++ b/sound/soc/codecs/es8326.c
@@ -16,6 +16,8 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include <sound/tlv.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
 #include "es8326.h"
 
 struct es8326_priv {
@@ -38,8 +40,92 @@ struct es8326_priv {
 	u8 interrupt_clk;
 	bool jd_inverted;
 	unsigned int sysclk;
+
+	bool calibrated;
+	int version;
+	int hp;
+	int jack_remove_retry;
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+	int spk_ctl_gpio;
+#endif
 };
 
+static int es8326_crosstalk1_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
+	unsigned int crosstalk_h, crosstalk_l;
+	unsigned int crosstalk;
+
+	regmap_read(es8326->regmap, ES8326_DAC_RAMPRATE, &crosstalk_h);
+	regmap_read(es8326->regmap, ES8326_DAC_CROSSTALK, &crosstalk_l);
+	crosstalk_h &= 0x20;
+	crosstalk_l &= 0xf0;
+	crosstalk = crosstalk_h >> 1 | crosstalk_l >> 4;
+	ucontrol->value.integer.value[0] = crosstalk;
+
+	return 0;
+}
+
+static int es8326_crosstalk1_set(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
+	unsigned int crosstalk_h, crosstalk_l;
+	unsigned int crosstalk;
+
+	crosstalk = ucontrol->value.integer.value[0];
+	regmap_read(es8326->regmap, ES8326_DAC_CROSSTALK, &crosstalk_l);
+	crosstalk_h = (crosstalk & 0x10) << 1;
+	crosstalk_l &= 0x0f;
+	crosstalk_l |= (crosstalk & 0x0f) << 4;
+	regmap_update_bits(es8326->regmap, ES8326_DAC_RAMPRATE,
+			0x20, crosstalk_h);
+	regmap_write(es8326->regmap, ES8326_DAC_CROSSTALK, crosstalk_l);
+
+	return 0;
+}
+
+static int es8326_crosstalk2_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
+	unsigned int crosstalk_h, crosstalk_l;
+	unsigned int crosstalk;
+
+	regmap_read(es8326->regmap, ES8326_DAC_RAMPRATE, &crosstalk_h);
+	regmap_read(es8326->regmap, ES8326_DAC_CROSSTALK, &crosstalk_l);
+	crosstalk_h &= 0x10;
+	crosstalk_l &= 0x0f;
+	crosstalk = crosstalk_h  | crosstalk_l;
+	ucontrol->value.integer.value[0] = crosstalk;
+
+	return 0;
+}
+
+static int es8326_crosstalk2_set(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
+	unsigned int crosstalk_h, crosstalk_l;
+	unsigned int crosstalk;
+
+	crosstalk = ucontrol->value.integer.value[0];
+	regmap_read(es8326->regmap, ES8326_DAC_CROSSTALK, &crosstalk_l);
+	crosstalk_h = crosstalk & 0x10;
+	crosstalk_l &= 0xf0;
+	crosstalk_l |= crosstalk & 0x0f;
+	regmap_update_bits(es8326->regmap, ES8326_DAC_RAMPRATE,
+			0x10, crosstalk_h);
+	regmap_write(es8326->regmap, ES8326_DAC_CROSSTALK, crosstalk_l);
+
+	return 0;
+}
+
 static const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(dac_vol_tlv, -9550, 50, 0);
 static const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(adc_vol_tlv, -9550, 50, 0);
 static const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(adc_analog_pga_tlv, 0, 300, 0);
@@ -97,6 +183,10 @@ static const struct snd_kcontrol_new es8326_snd_controls[] = {
 	SOC_SINGLE_TLV("ALC Capture Target Level", ES8326_ALC_LEVEL,
 			0, 0x0f, 0, drc_target_tlv),
 
+	SOC_SINGLE_EXT("CROSSTALK1", SND_SOC_NOPM, 0, 31, 0,
+			es8326_crosstalk1_get, es8326_crosstalk1_set),
+	SOC_SINGLE_EXT("CROSSTALK2", SND_SOC_NOPM, 0, 31, 0,
+			es8326_crosstalk2_get, es8326_crosstalk2_set),
 };
 
 static const struct snd_soc_dapm_widget es8326_dapm_widgets[] = {
@@ -112,106 +202,65 @@ static const struct snd_soc_dapm_widget es8326_dapm_widgets[] = {
 	SND_SOC_DAPM_AIF_OUT("I2S OUT", "I2S1 Capture", 0, SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_AIF_IN("I2S IN", "I2S1 Playback", 0, SND_SOC_NOPM, 0, 0),
 
-	/* ADC Digital Mute */
-	SND_SOC_DAPM_PGA("ADC L1", ES8326_ADC_MUTE, 0, 1, NULL, 0),
-	SND_SOC_DAPM_PGA("ADC R1", ES8326_ADC_MUTE, 1, 1, NULL, 0),
-	SND_SOC_DAPM_PGA("ADC L2", ES8326_ADC_MUTE, 2, 1, NULL, 0),
-	SND_SOC_DAPM_PGA("ADC R2", ES8326_ADC_MUTE, 3, 1, NULL, 0),
-
 	/* Analog Power Supply*/
 	SND_SOC_DAPM_DAC("Right DAC", NULL, ES8326_ANA_PDN, 0, 1),
 	SND_SOC_DAPM_DAC("Left DAC", NULL, ES8326_ANA_PDN, 1, 1),
-	SND_SOC_DAPM_SUPPLY("Analog Power", ES8326_ANA_PDN, 7, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("IBias Power", ES8326_ANA_PDN, 6, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("ADC Vref", ES8326_ANA_PDN, 5, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("DAC Vref", ES8326_ANA_PDN, 4, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("Vref Power", ES8326_ANA_PDN, 3, 1, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("MICBIAS1", ES8326_ANA_MICBIAS, 2, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("MICBIAS2", ES8326_ANA_MICBIAS, 3, 0, NULL, 0),
 
 	SND_SOC_DAPM_PGA("LHPMIX", ES8326_DAC2HPMIX, 7, 0, NULL, 0),
 	SND_SOC_DAPM_PGA("RHPMIX", ES8326_DAC2HPMIX, 3, 0, NULL, 0),
 
-	/* Headphone Charge Pump and Output */
-	SND_SOC_DAPM_SUPPLY("HPOR Cal", ES8326_HP_CAL, 7, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("HPOL Cal", ES8326_HP_CAL, 3, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("Headphone Charge Pump", ES8326_HP_DRIVER,
-			    3, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("Headphone Driver Bias", ES8326_HP_DRIVER,
-			    2, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("Headphone LDO", ES8326_HP_DRIVER,
-			    1, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("Headphone Reference", ES8326_HP_DRIVER,
-			    0, 1, NULL, 0),
 	SND_SOC_DAPM_REG(snd_soc_dapm_supply, "HPOR Supply", ES8326_HP_CAL,
-			 ES8326_HPOR_SHIFT, 7, 7, 0),
+			 4, 7, 0, 0),
 	SND_SOC_DAPM_REG(snd_soc_dapm_supply, "HPOL Supply", ES8326_HP_CAL,
-			 0, 7, 7, 0),
+			 0, 7, 0, 0),
 
 	SND_SOC_DAPM_OUTPUT("HPOL"),
 	SND_SOC_DAPM_OUTPUT("HPOR"),
 };
 
 static const struct snd_soc_dapm_route es8326_dapm_routes[] = {
-	{"ADC L1", NULL, "MIC1"},
-	{"ADC R1", NULL, "MIC2"},
-	{"ADC L2", NULL, "MIC3"},
-	{"ADC R2", NULL, "MIC4"},
-
-	{"ADC L", NULL, "ADC L1"},
-	{"ADC R", NULL, "ADC R1"},
-	{"ADC L", NULL, "ADC L2"},
-	{"ADC R", NULL, "ADC R2"},
+	{"ADC L", NULL, "MIC1"},
+	{"ADC R", NULL, "MIC2"},
+	{"ADC L", NULL, "MIC3"},
+	{"ADC R", NULL, "MIC4"},
 
 	{"I2S OUT", NULL, "ADC L"},
 	{"I2S OUT", NULL, "ADC R"},
 
-	{"I2S OUT", NULL, "Analog Power"},
-	{"I2S OUT", NULL, "ADC Vref"},
-	{"I2S OUT", NULL, "Vref Power"},
-	{"I2S OUT", NULL, "IBias Power"},
-	{"I2S IN", NULL, "Analog Power"},
-	{"I2S IN", NULL, "DAC Vref"},
-	{"I2S IN", NULL, "Vref Power"},
-	{"I2S IN", NULL, "IBias Power"},
-
 	{"Right DAC", NULL, "I2S IN"},
 	{"Left DAC", NULL, "I2S IN"},
 
 	{"LHPMIX", NULL, "Left DAC"},
 	{"RHPMIX", NULL, "Right DAC"},
 
-	{"HPOR", NULL, "HPOR Cal"},
-	{"HPOL", NULL, "HPOL Cal"},
 	{"HPOR", NULL, "HPOR Supply"},
 	{"HPOL", NULL, "HPOL Supply"},
-	{"HPOL", NULL, "Headphone Charge Pump"},
-	{"HPOR", NULL, "Headphone Charge Pump"},
-	{"HPOL", NULL, "Headphone Driver Bias"},
-	{"HPOR", NULL, "Headphone Driver Bias"},
-	{"HPOL", NULL, "Headphone LDO"},
-	{"HPOR", NULL, "Headphone LDO"},
-	{"HPOL", NULL, "Headphone Reference"},
-	{"HPOR", NULL, "Headphone Reference"},
 
 	{"HPOL", NULL, "LHPMIX"},
 	{"HPOR", NULL, "RHPMIX"},
 };
 
-static const struct regmap_range es8326_volatile_ranges[] = {
-	regmap_reg_range(ES8326_HP_DETECT, ES8326_HP_DETECT),
-};
-
-static const struct regmap_access_table es8326_volatile_table = {
-	.yes_ranges = es8326_volatile_ranges,
-	.n_yes_ranges = ARRAY_SIZE(es8326_volatile_ranges),
-};
+static bool es8326_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case ES8326_HPL_OFFSET_INI:
+	case ES8326_HPR_OFFSET_INI:
+	case ES8326_HPDET_STA:
+	case ES8326_CTIA_OMTP_STA:
+	case ES8326_CSM_MUTE_STA:
+		return true;
+	default:
+		return false;
+	}
+}
 
 static const struct regmap_config es8326_regmap_config = {
 	.reg_bits = 8,
 	.val_bits = 8,
 	.max_register = 0xff,
-	.volatile_table = &es8326_volatile_table,
+	.volatile_reg = es8326_volatile_register,
 	.cache_type = REGCACHE_RBTREE,
 };
 
@@ -231,77 +280,111 @@ struct _coeff_div {
 
 /* codec hifi mclk clock divider coefficients */
 /* {ratio, LRCK, MCLK, REG04, REG05, REG06, REG07, REG08, REG09, REG10, REG11} */
-static const struct _coeff_div coeff_div[] = {
-	{32, 8000, 256000, 0x60, 0x00, 0x0F, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},
-	{32, 16000, 512000, 0x20, 0x00, 0x0D, 0x75, 0x0A, 0x1B, 0x1F, 0x3F},
-	{32, 44100, 1411200, 0x00, 0x00, 0x13, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{32, 48000, 1536000, 0x00, 0x00, 0x13, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{36, 8000, 288000, 0x20, 0x00, 0x0D, 0x75, 0x0A, 0x1B, 0x23, 0x47},
-	{36, 16000, 576000, 0x20, 0x00, 0x0D, 0x75, 0x0A, 0x1B, 0x23, 0x47},
-	{48, 8000, 384000, 0x60, 0x02, 0x1F, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},
-	{48, 16000, 768000, 0x20, 0x02, 0x0F, 0x75, 0x0A, 0x1B, 0x1F, 0x3F},
-	{48, 48000, 2304000, 0x00, 0x02, 0x0D, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{64, 8000, 512000, 0x60, 0x00, 0x0D, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},
-	{64, 16000, 1024000, 0x20, 0x00, 0x05, 0x75, 0x0A, 0x1B, 0x1F, 0x3F},
-
-	{64, 44100, 2822400, 0x00, 0x00, 0x11, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{64, 48000, 3072000, 0x00, 0x00, 0x11, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{72, 8000, 576000, 0x20, 0x00, 0x13, 0x35, 0x0A, 0x1B, 0x23, 0x47},
-	{72, 16000, 1152000, 0x20, 0x00, 0x05, 0x75, 0x0A, 0x1B, 0x23, 0x47},
-	{96, 8000, 768000, 0x60, 0x02, 0x1D, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},
-	{96, 16000, 1536000, 0x20, 0x02, 0x0D, 0x75, 0x0A, 0x1B, 0x1F, 0x3F},
-	{100, 48000, 4800000, 0x04, 0x04, 0x3F, 0x6D, 0x38, 0x08, 0x4f, 0x1f},
-	{125, 48000, 6000000, 0x04, 0x04, 0x1F, 0x2D, 0x0A, 0x0A, 0x27, 0x27},
-	{128, 8000, 1024000, 0x60, 0x00, 0x13, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},
-	{128, 16000, 2048000, 0x20, 0x00, 0x11, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},
-
-	{128, 44100, 5644800, 0x00, 0x00, 0x01, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{128, 48000, 6144000, 0x00, 0x00, 0x01, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{144, 8000, 1152000, 0x20, 0x00, 0x03, 0x35, 0x0A, 0x1B, 0x23, 0x47},
-	{144, 16000, 2304000, 0x20, 0x00, 0x11, 0x35, 0x0A, 0x1B, 0x23, 0x47},
-	{192, 8000, 1536000, 0x60, 0x02, 0x0D, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},
-	{192, 16000, 3072000, 0x20, 0x02, 0x05, 0x75, 0x0A, 0x1B, 0x1F, 0x3F},
-	{200, 48000, 9600000, 0x04, 0x04, 0x0F, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{250, 48000, 12000000, 0x04, 0x04, 0x0F, 0x2D, 0x0A, 0x0A, 0x27, 0x27},
-	{256, 8000, 2048000, 0x60, 0x00, 0x11, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},
-	{256, 16000, 4096000, 0x20, 0x00, 0x01, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},
-
-	{256, 44100, 11289600, 0x00, 0x00, 0x10, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{256, 48000, 12288000, 0x00, 0x00, 0x30, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{288, 8000, 2304000, 0x20, 0x00, 0x01, 0x35, 0x0A, 0x1B, 0x23, 0x47},
-	{384, 8000, 3072000, 0x60, 0x02, 0x05, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},
-	{384, 16000, 6144000, 0x20, 0x02, 0x03, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},
-	{384, 48000, 18432000, 0x00, 0x02, 0x01, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{400, 48000, 19200000, 0x09, 0x04, 0x0f, 0x6d, 0x3a, 0x0A, 0x4F, 0x1F},
-	{500, 48000, 24000000, 0x18, 0x04, 0x1F, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{512, 8000, 4096000, 0x60, 0x00, 0x01, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},
-	{512, 16000, 8192000, 0x20, 0x00, 0x10, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},
-
-	{512, 44100, 22579200, 0x00, 0x00, 0x00, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{512, 48000, 24576000, 0x00, 0x00, 0x00, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{768, 8000, 6144000, 0x60, 0x02, 0x11, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},
-	{768, 16000, 12288000, 0x20, 0x02, 0x01, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},
-	{800, 48000, 38400000, 0x00, 0x18, 0x13, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},
-	{1024, 8000, 8192000, 0x60, 0x00, 0x10, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},
+static const struct _coeff_div coeff_div_v0[] = {
+	{64, 8000, 512000, 0x60, 0x01, 0x0F, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},
+	{64, 16000, 1024000, 0x20, 0x00, 0x33, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},
+	{64, 44100, 2822400, 0xE0, 0x00, 0x03, 0x2D, 0x4A, 0x0A, 0x1F, 0x1F},
+	{64, 48000, 3072000, 0xE0, 0x00, 0x03, 0x2D, 0x4A, 0x0A, 0x1F, 0x1F},
+	{128, 8000, 1024000, 0x60, 0x00, 0x33, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},
+	{128, 16000, 2048000, 0x20, 0x00, 0x03, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},
+	{128, 44100, 5644800, 0xE0, 0x01, 0x03, 0x2D, 0x4A, 0x0A, 0x1F, 0x1F},
+	{128, 48000, 6144000, 0xE0, 0x01, 0x03, 0x2D, 0x4A, 0x0A, 0x1F, 0x1F},
+
+	{192, 32000, 6144000, 0xE0, 0x02, 0x03, 0x2D, 0x4A, 0x0A, 0x1F, 0x1F},
+	{256, 8000, 2048000, 0x60, 0x00, 0x03, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},
+	{256, 16000, 4096000, 0x20, 0x01, 0x03, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},
+	{256, 44100, 11289600, 0xE0, 0x00, 0x30, 0x2D, 0x4A, 0x0A, 0x1F, 0x1F},
+	{256, 48000, 12288000, 0xE0, 0x00, 0x30, 0x2D, 0x4A, 0x0A, 0x1F, 0x1F},
+	{384, 32000, 12288000, 0xE0, 0x05, 0x03, 0x2D, 0x4A, 0x0A, 0x1F, 0x1F},
+	{400, 48000, 19200000, 0xE9, 0x04, 0x0F, 0x6d, 0x4A, 0x0A, 0x1F, 0x1F},
+
+	{500, 48000, 24000000, 0xF8, 0x04, 0x3F, 0x6D, 0x4A, 0x0A, 0x1F, 0x1F},
+	{512, 8000, 4096000, 0x60, 0x01, 0x03, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},
+	{512, 16000, 8192000, 0x20, 0x00, 0x30, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},
+	{512, 44100, 22579200, 0xE0, 0x00, 0x00, 0x2D, 0x4A, 0x0A, 0x1F, 0x1F},
+	{512, 48000, 24576000, 0xE0, 0x00, 0x00, 0x2D, 0x4A, 0x0A, 0x1F, 0x1F},
+	{768, 32000, 24576000, 0xE0, 0x02, 0x30, 0x2D, 0x4A, 0x0A, 0x1F, 0x1F},
+	{1024, 8000, 8192000, 0x60, 0x00, 0x30, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},
 	{1024, 16000, 16384000, 0x20, 0x00, 0x00, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},
-	{1152, 16000, 18432000, 0x20, 0x08, 0x11, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},
-	{1536, 8000, 12288000, 0x60, 0x02, 0x01, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},
-
-	{1536, 16000, 24576000, 0x20, 0x02, 0x10, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},
-	{1625, 8000, 13000000, 0x0C, 0x18, 0x1F, 0x2D, 0x0A, 0x0A, 0x27, 0x27},
-	{1625, 16000, 26000000, 0x0C, 0x18, 0x1F, 0x2D, 0x0A, 0x0A, 0x27, 0x27},
-	{2048, 8000, 16384000, 0x60, 0x00, 0x00, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},
-	{2304, 8000, 18432000, 0x40, 0x02, 0x10, 0x35, 0x0A, 0x1B, 0x1F, 0x5F},
-	{3072, 8000, 24576000, 0x60, 0x02, 0x10, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},
-	{3250, 8000, 26000000, 0x0C, 0x18, 0x0F, 0x2D, 0x0A, 0x0A, 0x27, 0x27},
+};
 
+static const struct _coeff_div coeff_div_v3[] = {
+	{32, 8000, 256000, 0x60, 0x00, 0x0F, 0x75, 0x8A, 0x1B, 0x1F, 0x7F},
+	{32, 16000, 512000, 0x20, 0x00, 0x0D, 0x75, 0x8A, 0x1B, 0x1F, 0x3F},
+	{32, 44100, 1411200, 0x00, 0x00, 0x13, 0x2D, 0x8A, 0x0A, 0x1F, 0x1F},
+	{32, 48000, 1536000, 0x00, 0x00, 0x13, 0x2D, 0x8A, 0x0A, 0x1F, 0x1F},
+	{36, 8000, 288000, 0x20, 0x00, 0x0D, 0x75, 0x8A, 0x1B, 0x23, 0x47},
+	{36, 16000, 576000, 0x20, 0x00, 0x0D, 0x75, 0x8A, 0x1B, 0x23, 0x47},
+	{48, 8000, 384000, 0x60, 0x02, 0x1F, 0x75, 0x8A, 0x1B, 0x1F, 0x7F},
+	{48, 16000, 768000, 0x20, 0x02, 0x0F, 0x75, 0x8A, 0x1B, 0x1F, 0x3F},
+	{48, 48000, 2304000, 0x00, 0x02, 0x0D, 0x2D, 0x8A, 0x0A, 0x1F, 0x1F},
+
+	{64, 8000, 512000, 0x60, 0x00, 0x35, 0x75, 0x8A, 0x1B, 0x1F, 0x7F},
+	{64, 16000, 1024000, 0x20, 0x00, 0x05, 0x75, 0x8A, 0x1B, 0x1F, 0x3F},
+	{64, 44100, 2822400, 0xE0, 0x00, 0x31, 0x2D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{64, 48000, 3072000, 0xE0, 0x00, 0x31, 0x2D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{72, 8000, 576000, 0x20, 0x00, 0x13, 0x35, 0x8A, 0x1B, 0x23, 0x47},
+	{72, 16000, 1152000, 0x20, 0x00, 0x05, 0x75, 0x8A, 0x1B, 0x23, 0x47},
+	{96, 8000, 768000, 0x60, 0x02, 0x1D, 0x75, 0x8A, 0x1B, 0x1F, 0x7F},
+	{96, 16000, 1536000, 0x20, 0x02, 0x0D, 0x75, 0x8A, 0x1B, 0x1F, 0x3F},
+	{100, 48000, 4800000, 0x04, 0x04, 0x3F, 0x6D, 0xB8, 0x08, 0x4f, 0x1f},
+	{125, 48000, 6000000, 0x04, 0x04, 0x1F, 0x2D, 0x8A, 0x0A, 0x27, 0x27},
+
+	{128, 8000, 1024000, 0x60, 0x00, 0x05, 0x75, 0x8A, 0x1B, 0x1F, 0x7F},
+	{128, 16000, 2048000, 0x20, 0x00, 0x31, 0x35, 0x8A, 0x1B, 0x1F, 0x3F},
+	{128, 44100, 5644800, 0xE0, 0x00, 0x01, 0x2D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{128, 48000, 6144000, 0xE0, 0x00, 0x01, 0x2D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{144, 8000, 1152000, 0x20, 0x00, 0x03, 0x35, 0x8A, 0x1B, 0x23, 0x47},
+	{144, 16000, 2304000, 0x20, 0x00, 0x11, 0x35, 0x8A, 0x1B, 0x23, 0x47},
+	{192, 8000, 1536000, 0x60, 0x02, 0x0D, 0x75, 0x8A, 0x1B, 0x1F, 0x7F},
+	{192, 32000, 6144000, 0xE0, 0x02, 0x31, 0x2D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{192, 16000, 3072000, 0x20, 0x02, 0x05, 0x75, 0xCA, 0x1B, 0x1F, 0x3F},
+
+	{200, 48000, 9600000, 0x04, 0x04, 0x0F, 0x2D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{250, 48000, 12000000, 0x04, 0x04, 0x0F, 0x2D, 0xCA, 0x0A, 0x27, 0x27},
+	{256, 8000, 2048000, 0x60, 0x00, 0x31, 0x35, 0x8A, 0x1B, 0x1F, 0x7F},
+	{256, 16000, 4096000, 0x20, 0x00, 0x01, 0x35, 0x8A, 0x1B, 0x1F, 0x3F},
+	{256, 44100, 11289600, 0xE0, 0x00, 0x30, 0x2D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{256, 48000, 12288000, 0xE0, 0x00, 0x30, 0x2D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{288, 8000, 2304000, 0x20, 0x00, 0x01, 0x35, 0x8A, 0x1B, 0x23, 0x47},
+	{384, 8000, 3072000, 0x60, 0x02, 0x05, 0x75, 0x8A, 0x1B, 0x1F, 0x7F},
+	{384, 16000, 6144000, 0x20, 0x02, 0x03, 0x35, 0x8A, 0x1B, 0x1F, 0x3F},
+	{384, 32000, 12288000, 0xE0, 0x02, 0x01, 0x2D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{384, 48000, 18432000, 0x00, 0x02, 0x01, 0x2D, 0x8A, 0x0A, 0x1F, 0x1F},
+
+	{400, 48000, 19200000, 0xE4, 0x04, 0x35, 0x6d, 0xCA, 0x0A, 0x1F, 0x1F},
+	{500, 48000, 24000000, 0xF8, 0x04, 0x3F, 0x6D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{512, 8000, 4096000, 0x60, 0x00, 0x01, 0x35, 0x8A, 0x1B, 0x1F, 0x7F},
+	{512, 16000, 8192000, 0x20, 0x00, 0x30, 0x35, 0x8A, 0x1B, 0x1F, 0x3F},
+	{512, 44100, 22579200, 0xE0, 0x00, 0x00, 0x2D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{512, 48000, 24576000, 0xE0, 0x00, 0x00, 0x2D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{768, 8000, 6144000, 0x60, 0x02, 0x11, 0x35, 0x8A, 0x1B, 0x1F, 0x7F},
+	{768, 16000, 12288000, 0x20, 0x02, 0x01, 0x35, 0x8A, 0x1B, 0x1F, 0x3F},
+	{768, 32000, 24576000, 0xE0, 0x02, 0x30, 0x2D, 0xCA, 0x0A, 0x1F, 0x1F},
+	{800, 48000, 38400000, 0x00, 0x18, 0x13, 0x2D, 0x8A, 0x0A, 0x1F, 0x1F},
+
+	{1024, 8000, 8192000, 0x60, 0x00, 0x30, 0x35, 0x8A, 0x1B, 0x1F, 0x7F},
+	{1024, 16000, 16384000, 0x20, 0x00, 0x00, 0x35, 0x8A, 0x1B, 0x1F, 0x3F},
+	{1152, 16000, 18432000, 0x20, 0x08, 0x11, 0x35, 0x8A, 0x1B, 0x1F, 0x3F},
+	{1536, 8000, 12288000, 0x60, 0x02, 0x01, 0x35, 0x8A, 0x1B, 0x1F, 0x7F},
+	{1536, 16000, 24576000, 0x20, 0x02, 0x10, 0x35, 0x8A, 0x1B, 0x1F, 0x3F},
+	{1625, 8000, 13000000, 0x0C, 0x18, 0x1F, 0x2D, 0x8A, 0x0A, 0x27, 0x27},
+	{1625, 16000, 26000000, 0x0C, 0x18, 0x1F, 0x2D, 0x8A, 0x0A, 0x27, 0x27},
+	{2048, 8000, 16384000, 0x60, 0x00, 0x00, 0x35, 0x8A, 0x1B, 0x1F, 0x7F},
+	{2304, 8000, 18432000, 0x40, 0x02, 0x10, 0x35, 0x8A, 0x1B, 0x1F, 0x5F},
+	{3072, 8000, 24576000, 0x60, 0x02, 0x10, 0x35, 0x8A, 0x1B, 0x1F, 0x7F},
+	{3250, 8000, 26000000, 0x0C, 0x18, 0x0F, 0x2D, 0x8A, 0x0A, 0x27, 0x27},
 };
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+static void es8326_enable_spk(struct es8326_priv *es8326, bool enable);
+#endif
 
-static inline int get_coeff(int mclk, int rate)
+static inline int get_coeff(int mclk, int rate, int array,
+				const struct _coeff_div *coeff_div)
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
+	for (i = 0; i < array; i++) {
 		if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
 			return i;
 	}
@@ -332,6 +415,10 @@ static int es8326_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
 		break;
 	case SND_SOC_DAIFMT_CBC_CFC:
 		break;
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+	case SND_SOC_DAIFMT_CBP_CFP:
+		break;
+#endif
 	default:
 		return -EINVAL;
 	}
@@ -366,11 +453,22 @@ static int es8326_pcm_hw_params(struct snd_pcm_substream *substream,
 				struct snd_soc_dai *dai)
 {
 	struct snd_soc_component *component = dai->component;
+	const struct _coeff_div *coeff_div;
 	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
 	u8 srate = 0;
-	int coeff;
+	int coeff, array;
 
-	coeff = get_coeff(es8326->sysclk, params_rate(params));
+	if (es8326->version == 0) {
+		coeff_div =  coeff_div_v0;
+		array = ARRAY_SIZE(coeff_div_v0);
+	} else {
+		coeff_div =  coeff_div_v3;
+		array = ARRAY_SIZE(coeff_div_v3);
+	}
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+	es8326->sysclk = params_rate(params) * 64;
+#endif
+	coeff = get_coeff(es8326->sysclk, params_rate(params), array, coeff_div);
 	/* bit size */
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
@@ -419,6 +517,63 @@ static int es8326_pcm_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+static int es8326_mute(struct snd_soc_dai *dai, int mute, int direction)
+{
+	struct snd_soc_component *component = dai->component;
+	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
+	unsigned int offset_l, offset_r;
+
+	if (mute) {
+		if (direction == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_write(es8326->regmap, ES8326_HP_CAL, ES8326_HP_OFF);
+			regmap_update_bits(es8326->regmap, ES8326_DAC_MUTE,
+					ES8326_MUTE_MASK, ES8326_MUTE);
+			regmap_update_bits(es8326->regmap, ES8326_HP_DRIVER_REF,
+					0x30, 0x00);
+			#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+			if (!es8326->hp)
+				es8326_enable_spk(es8326, false);
+			#endif
+		} else {
+			regmap_update_bits(es8326->regmap,  ES8326_ADC_MUTE,
+					0x0F, 0x0F);
+		}
+	} else {
+		if (!es8326->calibrated) {
+			regmap_write(es8326->regmap, ES8326_HP_CAL, ES8326_HP_FORCE_CAL);
+			msleep(30);
+			regmap_write(es8326->regmap, ES8326_HP_CAL, ES8326_HP_OFF);
+			regmap_read(es8326->regmap, ES8326_HPL_OFFSET_INI, &offset_l);
+			regmap_read(es8326->regmap, ES8326_HPR_OFFSET_INI, &offset_r);
+			regmap_write(es8326->regmap, ES8326_HP_OFFSET_CAL, 0x8c);
+			regmap_write(es8326->regmap, ES8326_HPL_OFFSET_INI, offset_l);
+			regmap_write(es8326->regmap, ES8326_HPR_OFFSET_INI, offset_r);
+			es8326->calibrated = true;
+		}
+		if (direction == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(es8326->regmap, ES8326_DAC_DSM, 0x01, 0x01);
+			usleep_range(1000, 5000);
+			regmap_update_bits(es8326->regmap, ES8326_DAC_DSM, 0x01, 0x00);
+			usleep_range(1000, 5000);
+			regmap_update_bits(es8326->regmap, ES8326_HP_DRIVER_REF, 0x30, 0x20);
+			regmap_update_bits(es8326->regmap, ES8326_HP_DRIVER_REF, 0x30, 0x30);
+			regmap_write(es8326->regmap, ES8326_HP_DRIVER, 0xa1);
+			regmap_write(es8326->regmap, ES8326_HP_CAL, ES8326_HP_ON);
+			regmap_update_bits(es8326->regmap, ES8326_DAC_MUTE,
+					ES8326_MUTE_MASK, ~(ES8326_MUTE));
+			#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+			if (!es8326->hp)
+                                es8326_enable_spk(es8326, true);
+			#endif
+		} else {
+			msleep(300);
+			regmap_update_bits(es8326->regmap,  ES8326_ADC_MUTE,
+					0x0F, 0x00);
+		}
+	}
+	return 0;
+}
+
 static int es8326_set_bias_level(struct snd_soc_component *codec,
 				 enum snd_soc_bias_level level)
 {
@@ -430,32 +585,26 @@ static int es8326_set_bias_level(struct snd_soc_component *codec,
 		ret = clk_prepare_enable(es8326->mclk);
 		if (ret)
 			return ret;
-		regmap_write(es8326->regmap, ES8326_RESET, ES8326_PWRUP_SEQ_EN);
-		regmap_write(es8326->regmap, ES8326_INTOUT_IO, 0x45);
+
+		regmap_update_bits(es8326->regmap, ES8326_RESET, 0x02, 0x02);
+		usleep_range(5000, 10000);
+		regmap_write(es8326->regmap, ES8326_INTOUT_IO, es8326->interrupt_clk);
 		regmap_write(es8326->regmap, ES8326_SDINOUT1_IO,
 			    (ES8326_IO_DMIC_CLK << ES8326_SDINOUT1_SHIFT));
-		regmap_write(es8326->regmap, ES8326_SDINOUT23_IO, ES8326_IO_INPUT);
-		regmap_write(es8326->regmap, ES8326_CLK_RESAMPLE, 0x05);
-		regmap_write(es8326->regmap, ES8326_VMIDSEL, 0x02);
 		regmap_write(es8326->regmap, ES8326_PGA_PDN, 0x40);
-		regmap_write(es8326->regmap, ES8326_DAC2HPMIX, 0xAA);
-		regmap_write(es8326->regmap, ES8326_RESET, ES8326_CSM_ON);
+		regmap_write(es8326->regmap, ES8326_ANA_PDN, 0x00);
+		regmap_update_bits(es8326->regmap,  ES8326_CLK_CTL, 0x20, 0x20);
+		regmap_update_bits(es8326->regmap, ES8326_RESET, 0x02, 0x00);
 		break;
 	case SND_SOC_BIAS_PREPARE:
 		break;
 	case SND_SOC_BIAS_STANDBY:
+		regmap_write(es8326->regmap, ES8326_ANA_PDN, 0x3b);
+		regmap_update_bits(es8326->regmap, ES8326_CLK_CTL, 0x20, 0x00);
+		regmap_write(es8326->regmap, ES8326_SDINOUT1_IO, ES8326_IO_INPUT);
 		break;
 	case SND_SOC_BIAS_OFF:
 		clk_disable_unprepare(es8326->mclk);
-		regmap_write(es8326->regmap, ES8326_DAC2HPMIX, 0x11);
-		regmap_write(es8326->regmap, ES8326_RESET, ES8326_CSM_OFF);
-		regmap_write(es8326->regmap, ES8326_PGA_PDN, 0xF8);
-		regmap_write(es8326->regmap, ES8326_VMIDSEL, 0x00);
-		regmap_write(es8326->regmap, ES8326_INT_SOURCE, 0x08);
-		regmap_write(es8326->regmap, ES8326_SDINOUT1_IO, ES8326_IO_INPUT);
-		regmap_write(es8326->regmap, ES8326_SDINOUT23_IO, ES8326_IO_INPUT);
-		regmap_write(es8326->regmap, ES8326_RESET,
-			     ES8326_CODEC_RESET | ES8326_PWRUP_SEQ_EN);
 		break;
 	}
 
@@ -469,6 +618,8 @@ static const struct snd_soc_dai_ops es8326_ops = {
 	.hw_params = es8326_pcm_hw_params,
 	.set_fmt = es8326_set_dai_fmt,
 	.set_sysclk = es8326_set_dai_sysclk,
+	.mute_stream = es8326_mute,
+	.no_capture_mute = 0,
 };
 
 static struct snd_soc_dai_driver es8326_dai = {
@@ -512,7 +663,14 @@ static void es8326_disable_micbias(struct snd_soc_component *component)
 	snd_soc_dapm_sync_unlocked(dapm);
 	snd_soc_dapm_mutex_unlock(dapm);
 }
-
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+static void es8326_enable_spk(struct es8326_priv *es8326, bool enable)
+{
+	if (es8326->spk_ctl_gpio < 0)
+		return;
+	gpio_set_value(es8326->spk_ctl_gpio, enable);
+}
+#endif
 /*
  *	For button detection, set the following in soundcard
  *	snd_jack_set_key(jack->jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);
@@ -532,21 +690,26 @@ static void es8326_jack_button_handler(struct work_struct *work)
 		return;
 
 	mutex_lock(&es8326->lock);
-	iface = snd_soc_component_read(comp, ES8326_HP_DETECT);
+	iface = snd_soc_component_read(comp, ES8326_HPDET_STA);
 	switch (iface) {
 	case 0x93:
 		/* pause button detected */
 		cur_button = SND_JACK_BTN_0;
+		dev_dbg(comp->dev, "%s 0x%x pause \n", __func__, iface);
 		break;
 	case 0x6f:
+	case 0x4b:
 		/* button volume up */
 		cur_button = SND_JACK_BTN_1;
+		dev_dbg(comp->dev, "%s 0x%x volume+ \n", __func__, iface);
 		break;
 	case 0x27:
 		/* button volume down */
 		cur_button = SND_JACK_BTN_2;
+		dev_dbg(comp->dev, "%s 0x%x volume- \n", __func__, iface);
 		break;
 	case 0x1e:
+	case 0xe2:
 		/* button released or not pressed */
 		cur_button = 0;
 		break;
@@ -556,20 +719,20 @@ static void es8326_jack_button_handler(struct work_struct *work)
 
 	if ((prev_button == cur_button) && (cur_button != 0)) {
 		press_count++;
-		if (press_count > 10) {
-			/* report a press every 500ms */
+		if (press_count > 3) {
+			/* report a press every 120ms */
 			snd_soc_jack_report(es8326->jack, cur_button,
 					SND_JACK_BTN_0 | SND_JACK_BTN_1 | SND_JACK_BTN_2);
 			press_count = 0;
 		}
 		button_to_report = cur_button;
 		queue_delayed_work(system_wq, &es8326->button_press_work,
-				   msecs_to_jiffies(50));
+				   msecs_to_jiffies(35));
 	} else if (prev_button != cur_button) {
 		/* mismatch, detect again */
 		prev_button = cur_button;
 		queue_delayed_work(system_wq, &es8326->button_press_work,
-				   msecs_to_jiffies(50));
+				   msecs_to_jiffies(35));
 	} else {
 		/* released or no pressed */
 		if (button_to_report != 0) {
@@ -591,47 +754,119 @@ static void es8326_jack_detect_handler(struct work_struct *work)
 	unsigned int iface;
 
 	mutex_lock(&es8326->lock);
-	iface = snd_soc_component_read(comp, ES8326_HP_DETECT);
+	iface = snd_soc_component_read(comp, ES8326_HPDET_STA);
 	dev_dbg(comp->dev, "gpio flag %#04x", iface);
+
+	if ((es8326->jack_remove_retry == 1) && (es8326->version != ES8326_VERSION_B)) {
+		if (iface & ES8326_HPINSERT_FLAG)
+			es8326->jack_remove_retry = 2;
+		else
+			es8326->jack_remove_retry = 0;
+
+		dev_dbg(comp->dev, "remove event check, set HPJACK_POL normal, cnt = %d\n",
+				es8326->jack_remove_retry);
+		/*
+		 * Inverted HPJACK_POL bit to trigger one IRQ to double check HP Removal event
+		 */
+		regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE,
+					ES8326_HP_DET_JACK_POL, (es8326->jd_inverted ?
+					~es8326->jack_pol : es8326->jack_pol));
+		goto exit;
+	}
+
 	if ((iface & ES8326_HPINSERT_FLAG) == 0) {
 		/* Jack unplugged or spurious IRQ */
-		dev_dbg(comp->dev, "No headset detected");
+		dev_dbg(comp->dev, "No headset detected\n");
+		es8326_disable_micbias(es8326->component);
 		if (es8326->jack->status & SND_JACK_HEADPHONE) {
+			dev_dbg(comp->dev, "Report hp remove event\n");
+			#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+			es8326_enable_spk(es8326, true);
+			#endif
 			snd_soc_jack_report(es8326->jack, 0, SND_JACK_HEADSET);
-			snd_soc_component_write(comp, ES8326_ADC1_SRC, es8326->mic2_src);
-			es8326_disable_micbias(comp);
+			/* mute adc when mic path switch */
+			regmap_write(es8326->regmap, ES8326_ADC_SCALE, 0x33);
+			regmap_write(es8326->regmap, ES8326_ADC1_SRC, 0x44);
+			regmap_write(es8326->regmap, ES8326_ADC2_SRC, 0x66);
+			es8326->hp = 0;
+		}
+		regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x01);
+		regmap_write(es8326->regmap, ES8326_SYS_BIAS, 0x0a);
+		regmap_update_bits(es8326->regmap, ES8326_HP_DRIVER_REF, 0x0f, 0x03);
+		/*
+		 * Inverted HPJACK_POL bit to trigger one IRQ to double check HP Removal event
+		 */
+		if ((es8326->jack_remove_retry == 0) && (es8326->version != ES8326_VERSION_B)) {
+			es8326->jack_remove_retry = 1;
+			dev_dbg(comp->dev, "remove event check, invert HPJACK_POL, cnt = %d\n",
+					es8326->jack_remove_retry);
+			regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE,
+					ES8326_HP_DET_JACK_POL, (es8326->jd_inverted ?
+					es8326->jack_pol : ~es8326->jack_pol));
+
+		} else {
+			es8326->jack_remove_retry = 0;
 		}
 	} else if ((iface & ES8326_HPINSERT_FLAG) == ES8326_HPINSERT_FLAG) {
+		es8326->jack_remove_retry = 0;
+		if (es8326->hp == 0) {
+			dev_dbg(comp->dev, "First insert, start OMTP/CTIA type check\n");
+			/*
+			 * set auto-check mode, then restart jack_detect_work after 400ms.
+			 * Don't report jack status.
+			 */
+			regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x01);
+			es8326_enable_micbias(es8326->component);
+			usleep_range(50000, 70000);
+			regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x00);
+			regmap_write(es8326->regmap, ES8326_SYS_BIAS, 0x1f);
+			regmap_update_bits(es8326->regmap, ES8326_HP_DRIVER_REF, 0x0f, 0x08);
+			queue_delayed_work(system_wq, &es8326->jack_detect_work,
+					msecs_to_jiffies(400));
+			es8326->hp = 1;
+			#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+			es8326_enable_spk(es8326, false);
+			#endif
+			goto exit;
+		}
 		if (es8326->jack->status & SND_JACK_HEADSET) {
 			/* detect button */
+			dev_dbg(comp->dev, "button pressed\n");
 			queue_delayed_work(system_wq, &es8326->button_press_work, 10);
+			goto exit;
+		}
+		if ((iface & ES8326_HPBUTTON_FLAG) == 0x01) {
+			dev_dbg(comp->dev, "Headphone detected\n");
+			snd_soc_jack_report(es8326->jack,
+					SND_JACK_HEADPHONE, SND_JACK_HEADSET);
 		} else {
-			if ((iface & ES8326_HPBUTTON_FLAG) == 0x00) {
-				dev_dbg(comp->dev, "Headset detected");
-				snd_soc_jack_report(es8326->jack,
-						    SND_JACK_HEADSET, SND_JACK_HEADSET);
-				snd_soc_component_write(comp,
-							ES8326_ADC1_SRC, es8326->mic1_src);
-			} else {
-				dev_dbg(comp->dev, "Headphone detected");
-				snd_soc_jack_report(es8326->jack,
-						    SND_JACK_HEADPHONE, SND_JACK_HEADSET);
-			}
+			dev_dbg(comp->dev, "Headset detected\n");
+			snd_soc_jack_report(es8326->jack,
+					SND_JACK_HEADSET, SND_JACK_HEADSET);
+
+			regmap_write(es8326->regmap, ES8326_ADC_SCALE, 0x33);
+			regmap_update_bits(es8326->regmap, ES8326_PGA_PDN,
+					0x08, 0x08);
+			regmap_update_bits(es8326->regmap, ES8326_PGAGAIN,
+					0x80, 0x80);
+			regmap_write(es8326->regmap, ES8326_ADC1_SRC, 0x00);
+			regmap_write(es8326->regmap, ES8326_ADC2_SRC, 0x00);
+			regmap_update_bits(es8326->regmap, ES8326_PGA_PDN,
+					0x08, 0x00);
+			usleep_range(10000, 15000);
 		}
 	}
+exit:
 	mutex_unlock(&es8326->lock);
 }
 
 static irqreturn_t es8326_irq(int irq, void *dev_id)
 {
 	struct es8326_priv *es8326 = dev_id;
-	struct snd_soc_component *comp = es8326->component;
 
 	if (!es8326->jack)
 		goto out;
 
-	es8326_enable_micbias(comp);
-
 	if (es8326->jack->status & SND_JACK_HEADSET)
 		queue_delayed_work(system_wq, &es8326->jack_detect_work,
 				   msecs_to_jiffies(10));
@@ -643,45 +878,249 @@ static irqreturn_t es8326_irq(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int es8326_resume(struct snd_soc_component *component)
+static int es8326_calibrate(struct snd_soc_component *component)
 {
 	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
 	unsigned int reg;
+	unsigned int offset_l, offset_r;
 
-	regcache_cache_only(es8326->regmap, false);
-	regcache_sync(es8326->regmap);
+	regmap_read(es8326->regmap, ES8326_CHIP_VERSION, &reg);
+	es8326->version = reg;
+
+	if ((es8326->version == ES8326_VERSION_B) && (es8326->calibrated == false)) {
+		dev_dbg(component->dev, "ES8326_VERSION_B, calibrating\n");
+		regmap_write(es8326->regmap, ES8326_CLK_INV, 0xc0);
+		regmap_write(es8326->regmap, ES8326_CLK_DIV1, 0x03);
+		regmap_write(es8326->regmap, ES8326_CLK_DLL, 0x30);
+		regmap_write(es8326->regmap, ES8326_CLK_MUX, 0xed);
+		regmap_write(es8326->regmap, ES8326_CLK_DAC_SEL, 0x08);
+		regmap_write(es8326->regmap, ES8326_CLK_TRI, 0xc1);
+		regmap_write(es8326->regmap, ES8326_DAC_MUTE, 0x03);
+		regmap_write(es8326->regmap, ES8326_ANA_VSEL, 0x7f);
+		regmap_write(es8326->regmap, ES8326_VMIDLOW, 0x23);
+		regmap_write(es8326->regmap, ES8326_DAC2HPMIX, 0x88);
+		usleep_range(15000, 20000);
+		regmap_write(es8326->regmap, ES8326_HP_OFFSET_CAL, 0x8c);
+		usleep_range(15000, 20000);
+		regmap_write(es8326->regmap, ES8326_RESET, 0xc0);
+		usleep_range(15000, 20000);
+
+		regmap_write(es8326->regmap, ES8326_HP_OFFSET_CAL, ES8326_HP_OFF);
+		regmap_read(es8326->regmap, ES8326_CSM_MUTE_STA, &reg);
+		if ((reg & 0xf0) != 0x40)
+			msleep(50);
+
+		regmap_write(es8326->regmap, ES8326_HP_CAL, 0xd4);
+		msleep(200);
+		regmap_write(es8326->regmap, ES8326_HP_CAL, 0x4d);
+		msleep(200);
+		regmap_write(es8326->regmap, ES8326_HP_CAL, ES8326_HP_OFF);
+		regmap_read(es8326->regmap, ES8326_HPL_OFFSET_INI, &offset_l);
+		regmap_read(es8326->regmap, ES8326_HPR_OFFSET_INI, &offset_r);
+		regmap_write(es8326->regmap, ES8326_HP_OFFSET_CAL, 0x8c);
+		regmap_write(es8326->regmap, ES8326_HPL_OFFSET_INI, offset_l);
+		regmap_write(es8326->regmap, ES8326_HPR_OFFSET_INI, offset_r);
+		regmap_write(es8326->regmap, ES8326_CLK_INV, 0x00);
+
+		es8326->calibrated = true;
+	}
+
+	return 0;
+}
+
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+static int es8326_init(struct snd_soc_component *component)
+{
+	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
 
+	/* reset internal clock state */
+	regmap_write(es8326->regmap, ES8326_RESET, 0x1f);
+	regmap_write(es8326->regmap, ES8326_VMIDSEL, 0x0E);
+	regmap_write(es8326->regmap, ES8326_ANA_LP, 0xf0);
+	usleep_range(10000, 15000);
+	regmap_write(es8326->regmap, ES8326_HPJACK_TIMER, 0xe9);
+	regmap_write(es8326->regmap, ES8326_ANA_MICBIAS, 0xcb);
+	/* set headphone default type and detect pin */
+	regmap_write(es8326->regmap, ES8326_HPDET_TYPE, 0x83);
+	regmap_write(es8326->regmap, ES8326_CLK_RESAMPLE, 0x05);
+
+	/* set internal oscillator as clock source of headpone cp */
+	regmap_write(es8326->regmap, ES8326_CLK_DIV_CPC, 0x89);
 	regmap_write(es8326->regmap, ES8326_CLK_CTL, ES8326_CLK_ON);
-	/* Two channel ADC */
-	regmap_write(es8326->regmap, ES8326_PULLUP_CTL, 0x02);
+	/* clock manager reset release */
+	regmap_write(es8326->regmap, ES8326_RESET, 0x17);
+	/* set headphone detection as half scan mode */
+	regmap_write(es8326->regmap, ES8326_HP_MISC, 0x3d);
+	regmap_write(es8326->regmap, ES8326_PULLUP_CTL, 0x00);
+
+	/* enable headphone driver */
+	regmap_write(es8326->regmap, ES8326_HP_VOL, 0xc4);
+	regmap_write(es8326->regmap, ES8326_HP_DRIVER, 0xa7);
+	usleep_range(2000, 5000);
+	regmap_write(es8326->regmap, ES8326_HP_DRIVER_REF, 0x23);
+	regmap_write(es8326->regmap, ES8326_HP_DRIVER_REF, 0x33);
+	regmap_write(es8326->regmap, ES8326_HP_DRIVER, 0xa1);
+
 	regmap_write(es8326->regmap, ES8326_CLK_INV, 0x00);
-	regmap_write(es8326->regmap, ES8326_CLK_DIV_CPC, 0x1F);
-	regmap_write(es8326->regmap, ES8326_CLK_VMIDS1, 0xC8);
-	regmap_write(es8326->regmap, ES8326_CLK_VMIDS2, 0x88);
-	regmap_write(es8326->regmap, ES8326_CLK_CAL_TIME, 0x20);
-	regmap_write(es8326->regmap, ES8326_SYS_BIAS, 0x08);
-	regmap_write(es8326->regmap, ES8326_DAC2HPMIX, 0x22);
+	regmap_write(es8326->regmap, ES8326_CLK_VMIDS1, 0xc4);
+	regmap_write(es8326->regmap, ES8326_CLK_VMIDS2, 0x81);
+	regmap_write(es8326->regmap, ES8326_CLK_CAL_TIME, 0x00);
+	/* calibrate for B version */
+	es8326_calibrate(component);
+	regmap_write(es8326->regmap, ES8326_DAC_CROSSTALK, 0xaa);
+	regmap_write(es8326->regmap, ES8326_DAC_RAMPRATE, 0x00);
+	/* turn off headphone out */
+	regmap_write(es8326->regmap, ES8326_HP_CAL, 0x00);
+	/* set ADC and DAC in low power mode */
+	regmap_write(es8326->regmap, ES8326_ANA_LP, 0xf0);
+
+	regmap_write(es8326->regmap, ES8326_ANA_VSEL, 0x7F);
+	/* select vdda as micbias source */
+	regmap_write(es8326->regmap, ES8326_VMIDLOW, 0x23);
+	/* set dac dsmclip = 1 */
+	regmap_write(es8326->regmap, ES8326_DAC_DSM, 0x08);
+	regmap_write(es8326->regmap, ES8326_DAC_VPPSCALE, 0x15);
+
+	regmap_write(es8326->regmap, ES8326_HPDET_TYPE, 0x80 |
+			((es8326->version == ES8326_VERSION_B) ?
+			(ES8326_HP_DET_SRC_PIN9 | es8326->jack_pol) :
+			(ES8326_HP_DET_SRC_PIN9 | es8326->jack_pol | 0x04)));
+	usleep_range(5000, 10000);
+	es8326_enable_micbias(es8326->component);
+	usleep_range(50000, 70000);
+	regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x00);
+	regmap_write(es8326->regmap, ES8326_INT_SOURCE,
+		    (ES8326_INT_SRC_PIN9 | ES8326_INT_SRC_BUTTON));
+	regmap_write(es8326->regmap, ES8326_INTOUT_IO,
+		     es8326->interrupt_clk);
+	regmap_write(es8326->regmap, ES8326_SDINOUT1_IO,
+		    (ES8326_IO_DMIC_CLK << ES8326_SDINOUT1_SHIFT));
+	regmap_write(es8326->regmap, ES8326_SDINOUT23_IO, ES8326_IO_INPUT);
+
+	regmap_write(es8326->regmap, ES8326_ANA_PDN, 0x00);
+	regmap_write(es8326->regmap, ES8326_RESET, ES8326_CSM_ON);
+	regmap_update_bits(es8326->regmap, ES8326_PGAGAIN, ES8326_MIC_SEL_MASK,
+			   ES8326_MIC1_SEL);
+
+	regmap_update_bits(es8326->regmap, ES8326_DAC_MUTE, ES8326_MUTE_MASK,
+			   ES8326_MUTE);
+
+	regmap_write(es8326->regmap, ES8326_ADC_MUTE, 0x0f);
 	regmap_write(es8326->regmap, ES8326_ADC1_SRC, es8326->mic1_src);
 	regmap_write(es8326->regmap, ES8326_ADC2_SRC, es8326->mic2_src);
-	regmap_write(es8326->regmap, ES8326_HPJACK_TIMER, 0x88);
-	regmap_write(es8326->regmap, ES8326_HP_DET,
-		     ES8326_HP_DET_SRC_PIN9 | es8326->jack_pol);
-	regmap_write(es8326->regmap, ES8326_INT_SOURCE, es8326->interrupt_src);
-	regmap_write(es8326->regmap, ES8326_INTOUT_IO, es8326->interrupt_clk);
+
+	es8326->jack_remove_retry = 0;
+	es8326->hp = 0;
+
+	return 0;
+}
+
+static int es8326_resume(struct snd_soc_component *component)
+{
+	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
+
+	regcache_cache_only(es8326->regmap, false);
+	regcache_sync(es8326->regmap);
+	if (es8326->jack)
+		es8326_irq(es8326->irq, es8326);
+	return 0;
+}
+static int es8326_suspend(struct snd_soc_component *component)
+{
+	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
+
+	cancel_delayed_work_sync(&es8326->jack_detect_work);
+	regcache_cache_only(es8326->regmap, true);
+	regcache_mark_dirty(es8326->regmap);
+
+	return 0;
+}
+#else
+static int es8326_resume(struct snd_soc_component *component)
+{
+	struct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);
+
+	regcache_cache_only(es8326->regmap, false);
+	regcache_sync(es8326->regmap);
+
+	/* reset internal clock state */
+	regmap_write(es8326->regmap, ES8326_RESET, 0x1f);
+	regmap_write(es8326->regmap, ES8326_VMIDSEL, 0x0E);
+	regmap_write(es8326->regmap, ES8326_ANA_LP, 0xf0);
+	usleep_range(10000, 15000);
+	regmap_write(es8326->regmap, ES8326_HPJACK_TIMER, 0xe9);
+	regmap_write(es8326->regmap, ES8326_ANA_MICBIAS, 0xcb);
+	/* set headphone default type and detect pin */
+	regmap_write(es8326->regmap, ES8326_HPDET_TYPE, 0x83);
+	regmap_write(es8326->regmap, ES8326_CLK_RESAMPLE, 0x05);
+
+	/* set internal oscillator as clock source of headpone cp */
+	regmap_write(es8326->regmap, ES8326_CLK_DIV_CPC, 0x89);
+	regmap_write(es8326->regmap, ES8326_CLK_CTL, ES8326_CLK_ON);
+	/* clock manager reset release */
+	regmap_write(es8326->regmap, ES8326_RESET, 0x17);
+	/* set headphone detection as half scan mode */
+	regmap_write(es8326->regmap, ES8326_HP_MISC, 0x3d);
+	regmap_write(es8326->regmap, ES8326_PULLUP_CTL, 0x00);
+
+	/* enable headphone driver */
+	regmap_write(es8326->regmap, ES8326_HP_VOL, 0xc4);
+	regmap_write(es8326->regmap, ES8326_HP_DRIVER, 0xa7);
+	usleep_range(2000, 5000);
+	regmap_write(es8326->regmap, ES8326_HP_DRIVER_REF, 0x23);
+	regmap_write(es8326->regmap, ES8326_HP_DRIVER_REF, 0x33);
+	regmap_write(es8326->regmap, ES8326_HP_DRIVER, 0xa1);
+
+	regmap_write(es8326->regmap, ES8326_CLK_INV, 0x00);
+	regmap_write(es8326->regmap, ES8326_CLK_VMIDS1, 0xc4);
+	regmap_write(es8326->regmap, ES8326_CLK_VMIDS2, 0x81);
+	regmap_write(es8326->regmap, ES8326_CLK_CAL_TIME, 0x00);
+	/* calibrate for B version */
+	es8326_calibrate(component);
+	regmap_write(es8326->regmap, ES8326_DAC_CROSSTALK, 0xaa);
+	regmap_write(es8326->regmap, ES8326_DAC_RAMPRATE, 0x00);
+	/* turn off headphone out */
+	regmap_write(es8326->regmap, ES8326_HP_CAL, 0x00);
+	/* set ADC and DAC in low power mode */
+	regmap_write(es8326->regmap, ES8326_ANA_LP, 0xf0);
+
+	regmap_write(es8326->regmap, ES8326_ANA_VSEL, 0x7F);
+	/* select vdda as micbias source */
+	regmap_write(es8326->regmap, ES8326_VMIDLOW, 0x23);
+	/* set dac dsmclip = 1 */
+	regmap_write(es8326->regmap, ES8326_DAC_DSM, 0x08);
+	regmap_write(es8326->regmap, ES8326_DAC_VPPSCALE, 0x15);
+
+	regmap_write(es8326->regmap, ES8326_HPDET_TYPE, 0x80 |
+			((es8326->version == ES8326_VERSION_B) ?
+			(ES8326_HP_DET_SRC_PIN9 | es8326->jack_pol) :
+			(ES8326_HP_DET_SRC_PIN9 | es8326->jack_pol | 0x04)));
+	usleep_range(5000, 10000);
+	es8326_enable_micbias(es8326->component);
+	usleep_range(50000, 70000);
+	regmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x00);
+	regmap_write(es8326->regmap, ES8326_INT_SOURCE,
+		    (ES8326_INT_SRC_PIN9 | ES8326_INT_SRC_BUTTON));
+	regmap_write(es8326->regmap, ES8326_INTOUT_IO,
+		     es8326->interrupt_clk);
+	regmap_write(es8326->regmap, ES8326_SDINOUT1_IO,
+		    (ES8326_IO_DMIC_CLK << ES8326_SDINOUT1_SHIFT));
+	regmap_write(es8326->regmap, ES8326_SDINOUT23_IO, ES8326_IO_INPUT);
+
+	regmap_write(es8326->regmap, ES8326_ANA_PDN, 0x00);
 	regmap_write(es8326->regmap, ES8326_RESET, ES8326_CSM_ON);
-	snd_soc_component_update_bits(component, ES8326_PGAGAIN,
-				      ES8326_MIC_SEL_MASK, ES8326_MIC1_SEL);
+	regmap_update_bits(es8326->regmap, ES8326_PGAGAIN, ES8326_MIC_SEL_MASK,
+			   ES8326_MIC1_SEL);
 
-	regmap_read(es8326->regmap, ES8326_CHIP_VERSION, &reg);
-	if ((reg & ES8326_VERSION_B) == 1) {
-		regmap_write(es8326->regmap, ES8326_ANA_MICBIAS, 0xDD);
-		regmap_write(es8326->regmap, ES8326_ANA_VSEL, 0x7F);
-		regmap_write(es8326->regmap, ES8326_VMIDLOW, 0x0F);
-		/* enable button detect */
-		regmap_write(es8326->regmap, ES8326_HP_DRIVER, 0xA0);
-	}
+	regmap_update_bits(es8326->regmap, ES8326_DAC_MUTE, ES8326_MUTE_MASK,
+			   ES8326_MUTE);
 
-	es8326_irq(es8326->irq, es8326);
+	regmap_write(es8326->regmap, ES8326_ADC_MUTE, 0x0f);
+	regmap_write(es8326->regmap, ES8326_ADC1_SRC, es8326->mic1_src);
+	regmap_write(es8326->regmap, ES8326_ADC2_SRC, es8326->mic2_src);
+
+	es8326->jack_remove_retry = 0;
+	es8326->hp = 0;
 	return 0;
 }
 
@@ -691,13 +1130,18 @@ static int es8326_suspend(struct snd_soc_component *component)
 
 	cancel_delayed_work_sync(&es8326->jack_detect_work);
 	es8326_disable_micbias(component);
-
+	es8326->calibrated = false;
 	regmap_write(es8326->regmap, ES8326_CLK_CTL, ES8326_CLK_OFF);
 	regcache_cache_only(es8326->regmap, true);
 	regcache_mark_dirty(es8326->regmap);
 
+	/* reset register value to default */
+	regmap_write(es8326->regmap, ES8326_CSM_I2C_STA, 0x01);
+	usleep_range(1000, 3000);
+	regmap_write(es8326->regmap, ES8326_CSM_I2C_STA, 0x00);
 	return 0;
 }
+#endif
 
 static int es8326_probe(struct snd_soc_component *component)
 {
@@ -725,7 +1169,7 @@ static int es8326_probe(struct snd_soc_component *component)
 	ret = device_property_read_u8(component->dev, "everest,jack-pol", &es8326->jack_pol);
 	if (ret != 0) {
 		dev_dbg(component->dev, "jack-pol return %d", ret);
-		es8326->jack_pol = ES8326_HP_DET_BUTTON_POL | ES8326_HP_TYPE_OMTP;
+		es8326->jack_pol = ES8326_HP_TYPE_AUTO;
 	}
 	dev_dbg(component->dev, "jack-pol %x", es8326->jack_pol);
 
@@ -745,7 +1189,11 @@ static int es8326_probe(struct snd_soc_component *component)
 	}
 	dev_dbg(component->dev, "interrupt-clk %x", es8326->interrupt_clk);
 
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+	es8326_init(component);
+#else
 	es8326_resume(component);
+#endif
 	return 0;
 }
 
@@ -756,7 +1204,7 @@ static void es8326_enable_jack_detect(struct snd_soc_component *component,
 
 	mutex_lock(&es8326->lock);
 	if (es8326->jd_inverted)
-		snd_soc_component_update_bits(component, ES8326_HP_DET,
+		snd_soc_component_update_bits(component, ES8326_HPDET_TYPE,
 					      ES8326_HP_DET_JACK_POL, ~es8326->jack_pol);
 	es8326->jack = jack;
 
@@ -817,9 +1265,12 @@ static const struct snd_soc_component_driver soc_component_dev_es8326 = {
 };
 
 static int es8326_i2c_probe(struct i2c_client *i2c,
-			    const struct i2c_device_id *id)
+                           const struct i2c_device_id *id)
 {
 	struct es8326_priv *es8326;
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+	enum of_gpio_flags flags;
+#endif
 	int ret;
 
 	es8326 = devm_kzalloc(&i2c->dev, sizeof(struct es8326_priv), GFP_KERNEL);
@@ -851,6 +1302,24 @@ static int es8326_i2c_probe(struct i2c_client *i2c,
 		es8326->irq = -ENXIO;
 	}
 
+#ifdef SPACEMIT_CONFIG_CODEC_ES8326
+	es8326->spk_ctl_gpio = of_get_named_gpio_flags(i2c->dev.of_node,
+						       "spk-ctl-gpio",
+						       0,
+						       &flags);
+	if (es8326->spk_ctl_gpio < 0) {
+		dev_info(&i2c->dev, "Can not read property spk_ctl_gpio\n");
+		es8326->spk_ctl_gpio = -1;
+	} else {
+		ret = devm_gpio_request_one(&i2c->dev, es8326->spk_ctl_gpio,
+					    GPIOF_DIR_OUT, NULL);
+		if (ret) {
+			dev_err(&i2c->dev, "Failed to request spk_ctl_gpio\n");
+			return ret;
+		}
+		es8326_enable_spk(es8326, false);
+	}
+#endif
 	es8326->mclk = devm_clk_get_optional(&i2c->dev, "mclk");
 	if (IS_ERR(es8326->mclk)) {
 		dev_err(&i2c->dev, "unable to get mclk\n");
diff --git a/sound/soc/codecs/es8326.h b/sound/soc/codecs/es8326.h
index 111111111111..222222222222 100644
--- a/sound/soc/codecs/es8326.h
+++ b/sound/soc/codecs/es8326.h
@@ -9,8 +9,6 @@
 #ifndef _ES8326_H
 #define _ES8326_H
 
-#define CONFIG_HHTECH_MINIPMP	1
-
 /* ES8326 register space */
 #define ES8326_RESET		0x00
 #define ES8326_CLK_CTL		0x01
@@ -74,16 +72,21 @@
 #define ES8326_DAC_VOL		0x50
 #define ES8326_DRC_RECOVERY	0x53
 #define ES8326_DRC_WINSIZE	0x54
+#define ES8326_DAC_CROSSTALK	0x55
 #define ES8326_HPJACK_TIMER	0x56
-#define ES8326_HP_DET		0x57
+#define ES8326_HPDET_TYPE	0x57
 #define ES8326_INT_SOURCE	0x58
 #define ES8326_INTOUT_IO	0x59
 #define ES8326_SDINOUT1_IO	0x5A
 #define ES8326_SDINOUT23_IO	0x5B
 #define ES8326_JACK_PULSE	0x5C
 
+#define ES8326_HP_MISC		0xF7
+#define ES8326_CTIA_OMTP_STA	0xF8
 #define ES8326_PULLUP_CTL	0xF9
-#define ES8326_HP_DETECT	0xFB
+#define ES8326_CSM_I2C_STA	0xFA
+#define ES8326_HPDET_STA	0xFB
+#define ES8326_CSM_MUTE_STA	0xFC
 #define ES8326_CHIP_ID1		0xFD
 #define ES8326_CHIP_ID2		0xFE
 #define ES8326_CHIP_VERSION	0xFF
@@ -94,9 +97,11 @@
 #define	ES8326_PWRUP_SEQ_EN	(1 << 5)
 #define ES8326_CODEC_RESET (0x0f << 0)
 #define ES8326_CSM_OFF (0 << 7)
+#define ES8326_MUTE_MASK (3 << 0)
+#define ES8326_MUTE (3 << 0)
 
 /* ES8326_CLK_CTL */
-#define ES8326_CLK_ON (0x7f << 0)
+#define ES8326_CLK_ON (0x7e << 0)
 #define ES8326_CLK_OFF (0 << 0)
 
 /* ES8326_CLK_INV */
@@ -122,7 +127,9 @@
 #define ES8326_MIC2_SEL (1 << 5)
 
 /* ES8326_HP_CAL */
-#define ES8326_HPOR_SHIFT 4
+#define ES8326_HP_OFF 0
+#define ES8326_HP_FORCE_CAL ((1 << 7) | (1 << 3))
+#define ES8326_HP_ON ((7 << 4) | (7 << 0))
 
 /* ES8326_ADC1_SRC */
 #define ES8326_ADC1_SHIFT 0
@@ -144,7 +151,7 @@
 #define ES8326_ADC3_SHIFT 0
 #define ES8326_ADC4_SHIFT 3
 
-/* ES8326_HP_DET */
+/* ES8326_HPDET_TYPE */
 #define ES8326_HP_DET_SRC_PIN27 (1 << 5)
 #define ES8326_HP_DET_SRC_PIN9 (1 << 4)
 #define ES8326_HP_DET_JACK_POL (1 << 3)
@@ -154,6 +161,13 @@
 #define ES8326_HP_TYPE_AUTO	(1 << 0)
 #define ES8326_HP_TYPE_AUTO_INV	(0 << 0)
 
+/* ES8326_INT_SOURCE */
+#define ES8326_INT_SRC_DAC_MOZ (1 << 0)
+#define ES8326_INT_SRC_ADC_MOZ (1 << 1)
+#define ES8326_INT_SRC_BUTTON (1 << 2)
+#define ES8326_INT_SRC_PIN9 (1 << 3)
+#define ES8326_INT_SRC_PIN27 (1 << 4)
+
 /* ES8326_SDINOUT1_IO */
 #define ES8326_IO_INPUT	(0 << 0)
 #define ES8326_IO_SDIN_SLOT0 (1 << 0)
@@ -172,11 +186,16 @@
 #define ES8326_SDINOUT2_SHIFT 4
 #define ES8326_SDINOUT3_SHIFT 0
 
-/* ES8326_HP_DETECT */
+/* ES8326_HPDET_STA */
 #define ES8326_HPINSERT_FLAG (1 << 1)
 #define ES8326_HPBUTTON_FLAG (1 << 0)
 
 /* ES8326_CHIP_VERSION 0xFF */
-#define ES8326_VERSION_B (1 << 0)
+#define ES8326_VERSION (1 << 0)
+#define ES8326_VERSION_B (3 << 0)
+
+#if IS_ENABLED(CONFIG_SND_SOC_SPACEMIT)
+#define SPACEMIT_CONFIG_CODEC_ES8326 1
+#endif
 
 #endif
-- 
Armbian

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Patrick Yavitz <pyavitz@xxxxx.com>
Date: Sat, 22 Jun 2024 08:20:16 -0400
Subject: sound: soc: dwc: dwc-i2s.c

Signed-off-by: Patrick Yavitz <pyavitz@xxxxx.com>
---
 sound/soc/dwc/dwc-i2s.c                   |  202 +-
 sound/soc/dwc/local.h                     |   18 +
 sound/soc/spacemit/Kconfig                |    7 +
 sound/soc/spacemit/Makefile               |    4 +
 sound/soc/spacemit/spacemit-dummy-codec.c |   73 +
 sound/soc/spacemit/spacemit-snd-card.c    |  378 ++++
 sound/soc/spacemit/spacemit-snd-i2s.c     |  478 +++++
 sound/soc/spacemit/spacemit-snd-i2s.h     |  135 ++
 sound/soc/spacemit/spacemit-snd-pcm-dma.c | 1048 ++++++++++
 sound/soc/spacemit/spacemit-snd-sspa.c    |  301 +++
 sound/soc/spacemit/spacemit-snd-sspa.h    |   86 +
 11 files changed, 2712 insertions(+), 18 deletions(-)

diff --git a/sound/soc/dwc/dwc-i2s.c b/sound/soc/dwc/dwc-i2s.c
index 111111111111..222222222222 100644
--- a/sound/soc/dwc/dwc-i2s.c
+++ b/sound/soc/dwc/dwc-i2s.c
@@ -17,6 +17,7 @@
 #include <linux/io.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/reset.h>
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
 #include <sound/designware_i2s.h>
@@ -149,19 +150,51 @@ static irqreturn_t i2s_irq_handler(int irq, void *dev_id)
 		return IRQ_NONE;
 }
 
+static void i2s_enable_dma(struct dw_i2s_dev *dev, u32 stream)
+{
+	u32 dma_reg = i2s_read_reg(dev->i2s_base, I2S_DMACR);
+
+	/* Enable DMA handshake for stream */
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_reg |= I2S_DMAEN_TXBLOCK;
+	else
+		dma_reg |= I2S_DMAEN_RXBLOCK;
+
+	i2s_write_reg(dev->i2s_base, I2S_DMACR, dma_reg);
+}
+
+static void i2s_disable_dma(struct dw_i2s_dev *dev, u32 stream)
+{
+	u32 dma_reg = i2s_read_reg(dev->i2s_base, I2S_DMACR);
+
+	/* Disable DMA handshake for stream */
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dma_reg &= ~I2S_DMAEN_TXBLOCK;
+		i2s_write_reg(dev->i2s_base, I2S_RTXDMA, 1);
+	} else {
+		dma_reg &= ~I2S_DMAEN_RXBLOCK;
+		i2s_write_reg(dev->i2s_base, I2S_RRXDMA, 1);
+	}
+	i2s_write_reg(dev->i2s_base, I2S_DMACR, dma_reg);
+}
+
 static void i2s_start(struct dw_i2s_dev *dev,
 		      struct snd_pcm_substream *substream)
 {
 	struct i2s_clk_config_data *config = &dev->config;
 
 	i2s_write_reg(dev->i2s_base, IER, 1);
-	i2s_enable_irqs(dev, substream->stream, config->chan_nr);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		i2s_write_reg(dev->i2s_base, ITER, 1);
 	else
 		i2s_write_reg(dev->i2s_base, IRER, 1);
 
+	if (dev->use_pio)
+		i2s_enable_irqs(dev, substream->stream, config->chan_nr);
+	else
+		i2s_enable_dma(dev, substream->stream);
+
 	i2s_write_reg(dev->i2s_base, CER, 1);
 }
 
@@ -175,7 +208,10 @@ static void i2s_stop(struct dw_i2s_dev *dev,
 	else
 		i2s_write_reg(dev->i2s_base, IRER, 0);
 
-	i2s_disable_irqs(dev, substream->stream, 8);
+	if (dev->use_pio)
+		i2s_disable_irqs(dev, substream->stream, 8);
+	else
+		i2s_disable_dma(dev, substream->stream);
 
 	if (!dev->active) {
 		i2s_write_reg(dev->i2s_base, CER, 0);
@@ -215,6 +251,11 @@ static int dw_i2s_hw_params(struct snd_pcm_substream *substream,
 	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
 	struct i2s_clk_config_data *config = &dev->config;
 	int ret;
+#ifdef SPACEMIT_CONFIG_DWC_I2S
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+	dai_link->stop_dma_first = 1;
+#endif
 
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
@@ -267,6 +308,23 @@ static int dw_i2s_hw_params(struct snd_pcm_substream *substream,
 				return ret;
 			}
 		} else {
+#ifdef SPACEMIT_CONFIG_DWC_I2S
+			u32 clk_rate = config->sample_rate * dev->mclk_fs;
+			ret = clk_set_rate(dev->clk_mclk, clk_rate);
+			if (ret) {
+				dev_err(dev->dev, "Can't set I2S mclk rate: %d\n",
+					ret);
+				return ret;
+			}
+
+			clk_rate = config->sample_rate * config->data_width * config->chan_nr;
+			ret = clk_set_rate(dev->clk_bclk, clk_rate);
+			if (ret) {
+				dev_err(dev->dev, "Can't set I2S bclk rate: %d\n",
+					ret);
+				return ret;
+			}
+#else
 			u32 bitclk = config->sample_rate *
 					config->data_width * 2;
 
@@ -276,6 +334,7 @@ static int dw_i2s_hw_params(struct snd_pcm_substream *substream,
 					ret);
 				return ret;
 			}
+#endif
 		}
 	}
 	return 0;
@@ -448,9 +507,9 @@ static const u32 bus_widths[COMP_MAX_DATA_WIDTH] = {
 static const u32 formats[COMP_MAX_WORDSIZE] = {
 	SNDRV_PCM_FMTBIT_S16_LE,
 	SNDRV_PCM_FMTBIT_S16_LE,
-	SNDRV_PCM_FMTBIT_S24_LE,
-	SNDRV_PCM_FMTBIT_S24_LE,
-	SNDRV_PCM_FMTBIT_S32_LE,
+	SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,
 	0,
 	0,
 	0
@@ -485,8 +544,13 @@ static int dw_configure_dai(struct dw_i2s_dev *dev,
 		if (dev->quirks & DW_I2S_QUIRK_16BIT_IDX_OVERRIDE)
 			idx = 1;
 		dw_i2s_dai->playback.channels_min = MIN_CHANNEL_NUM;
+#ifdef SPACEMIT_CONFIG_DWC_I2S
+		dw_i2s_dai->playback.channels_max =
+				(COMP1_TX_CHANNELS(comp1) + 1) << 1;
+#else
 		dw_i2s_dai->playback.channels_max =
 				1 << (COMP1_TX_CHANNELS(comp1) + 1);
+#endif
 		dw_i2s_dai->playback.formats = formats[idx];
 		dw_i2s_dai->playback.rates = rates;
 	}
@@ -499,8 +563,13 @@ static int dw_configure_dai(struct dw_i2s_dev *dev,
 		if (dev->quirks & DW_I2S_QUIRK_16BIT_IDX_OVERRIDE)
 			idx = 1;
 		dw_i2s_dai->capture.channels_min = MIN_CHANNEL_NUM;
+#ifdef SPACEMIT_CONFIG_DWC_I2S
+		dw_i2s_dai->capture.channels_max =
+				(COMP1_RX_CHANNELS(comp1) + 1) << 1;
+#else
 		dw_i2s_dai->capture.channels_max =
 				1 << (COMP1_RX_CHANNELS(comp1) + 1);
+#endif
 		dw_i2s_dai->capture.formats = formats[idx];
 		dw_i2s_dai->capture.rates = rates;
 	}
@@ -513,7 +582,11 @@ static int dw_configure_dai(struct dw_i2s_dev *dev,
 		dev->capability |= DW_I2S_SLAVE;
 	}
 
+#ifdef SPACEMIT_CONFIG_DWC_I2S
+	dev->fifo_th = fifo_depth - dev->fifo_empty_threshold;
+#else
 	dev->fifo_th = fifo_depth / 2;
+#endif
 	return 0;
 }
 
@@ -557,13 +630,9 @@ static int dw_configure_dai_by_dt(struct dw_i2s_dev *dev,
 	u32 comp1 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_1);
 	u32 comp2 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_2);
 	u32 fifo_depth = 1 << (1 + COMP1_FIFO_DEPTH_GLOBAL(comp1));
-	u32 idx = COMP1_APB_DATA_WIDTH(comp1);
 	u32 idx2;
 	int ret;
 
-	if (WARN_ON(idx >= ARRAY_SIZE(bus_widths)))
-		return -EINVAL;
-
 	ret = dw_configure_dai(dev, dw_i2s_dai, SNDRV_PCM_RATE_8000_192000);
 	if (ret < 0)
 		return ret;
@@ -573,7 +642,6 @@ static int dw_configure_dai_by_dt(struct dw_i2s_dev *dev,
 
 		dev->capability |= DWC_I2S_PLAY;
 		dev->play_dma_data.dt.addr = res->start + I2S_TXDMA;
-		dev->play_dma_data.dt.addr_width = bus_widths[idx];
 		dev->play_dma_data.dt.fifo_size = fifo_depth *
 			(fifo_width[idx2]) >> 8;
 		dev->play_dma_data.dt.maxburst = 16;
@@ -583,7 +651,6 @@ static int dw_configure_dai_by_dt(struct dw_i2s_dev *dev,
 
 		dev->capability |= DWC_I2S_RECORD;
 		dev->capture_dma_data.dt.addr = res->start + I2S_RXDMA;
-		dev->capture_dma_data.dt.addr_width = bus_widths[idx];
 		dev->capture_dma_data.dt.fifo_size = fifo_depth *
 			(fifo_width[idx2] >> 8);
 		dev->capture_dma_data.dt.maxburst = 16;
@@ -601,6 +668,77 @@ static int dw_i2s_dai_probe(struct snd_soc_dai *dai)
 	return 0;
 }
 
+static int dw_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_init_dma_data(dai, &dev->play_dma_data, &dev->capture_dma_data);
+	return 0;
+}
+
+#ifdef SPACEMIT_CONFIG_DWC_I2S
+static int dw_i2s_clk_init(struct platform_device *pdev, struct dw_i2s_dev *dev)
+{
+	int ret = 0, value = 0;
+	struct device_node *np = pdev->dev.of_node;
+
+	if (of_device_is_compatible(np, "snps,designware-i2s-master")
+		 || of_device_is_compatible(np, "snps,designware-i2s4x-master"))
+	{
+		dev->clk = devm_clk_get(&pdev->dev, "i2s_en");
+		if (IS_ERR(dev->clk)) {
+			dev_err(&pdev->dev, "failed to get clk en control\n");
+			ret = PTR_ERR(dev->clk);
+			goto exit;
+		}
+		dev->clk_mclk = devm_clk_get(&pdev->dev, "i2s_mclk_div");
+		if (IS_ERR(dev->clk_mclk)) {
+			dev_err(&pdev->dev, "failed to get mclk control\n");
+			ret = PTR_ERR(dev->clk_mclk);
+			goto exit;
+		}
+		dev->clk_bclk = devm_clk_get(&pdev->dev, "i2s_bclk_div");
+		if (IS_ERR(dev->clk_bclk)) {
+			dev_err(&pdev->dev, "failed to get bclk control\n");
+			ret = PTR_ERR(dev->clk_bclk);
+			goto exit;
+		}
+		dev->clk_mclk_out = devm_clk_get(&pdev->dev, "i2s_mclk_out");
+		if (IS_ERR(dev->clk_mclk_out)) {
+			dev_err(&pdev->dev, "failed to get mclk out control\n");
+			ret = PTR_ERR(dev->clk_mclk_out);
+			goto exit;
+		}
+
+		ret = clk_prepare_enable(dev->clk);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to prepare enable clk_i2s_en\n");
+			goto exit;
+		}
+
+		ret = clk_prepare_enable(dev->clk_mclk_out);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to prepare enable clk_i2s_mclk_out\n");
+			goto disable_clk;
+		}
+		if (!of_property_read_u32(np, "mclk-fs", &value)) {
+			dev->mclk_fs = value;
+		}
+		else {
+			dev->mclk_fs = 256;
+		}
+	}
+
+	return 0;
+
+disable_clk:
+	clk_disable_unprepare(dev->clk);
+exit:
+	return ret;
+
+}
+#endif
+
 static int dw_i2s_probe(struct platform_device *pdev)
 {
 	const struct i2s_platform_data *pdata = pdev->dev.platform_data;
@@ -625,6 +763,14 @@ static int dw_i2s_probe(struct platform_device *pdev)
 	if (IS_ERR(dev->i2s_base))
 		return PTR_ERR(dev->i2s_base);
 
+	dev->reset = devm_reset_control_array_get_optional_shared(&pdev->dev);
+	if (IS_ERR(dev->reset))
+		return PTR_ERR(dev->reset);
+
+	ret = reset_control_deassert(dev->reset);
+	if (ret)
+		return ret;
+
 	dev->dev = &pdev->dev;
 
 	irq = platform_get_irq_optional(pdev, 0);
@@ -633,10 +779,15 @@ static int dw_i2s_probe(struct platform_device *pdev)
 				pdev->name, dev);
 		if (ret < 0) {
 			dev_err(&pdev->dev, "failed to request irq\n");
-			return ret;
+			goto err_assert_reset;
 		}
 	}
-
+#ifdef SPACEMIT_CONFIG_DWC_I2S
+	if (of_property_read_u32(pdev->dev.of_node, "fifo-empty-threshold",
+		&dev->fifo_empty_threshold)) {
+		dev->fifo_empty_threshold = 1;
+	}
+#endif
 	dev->i2s_reg_comp1 = I2S_COMP_PARAM_1;
 	dev->i2s_reg_comp2 = I2S_COMP_PARAM_2;
 	if (pdata) {
@@ -653,24 +804,31 @@ static int dw_i2s_probe(struct platform_device *pdev)
 		ret = dw_configure_dai_by_dt(dev, dw_i2s_dai, res);
 	}
 	if (ret < 0)
-		return ret;
+		goto err_assert_reset;
 
 	if (dev->capability & DW_I2S_MASTER) {
 		if (pdata) {
 			dev->i2s_clk_cfg = pdata->i2s_clk_cfg;
 			if (!dev->i2s_clk_cfg) {
 				dev_err(&pdev->dev, "no clock configure method\n");
-				return -ENODEV;
+				ret = -ENODEV;
+				goto err_assert_reset;
 			}
 		}
+#ifdef SPACEMIT_CONFIG_DWC_I2S
+		dw_i2s_clk_init(pdev, dev);
+#else
 		dev->clk = devm_clk_get(&pdev->dev, clk_id);
 
-		if (IS_ERR(dev->clk))
-			return PTR_ERR(dev->clk);
+		if (IS_ERR(dev->clk)) {
+			ret = PTR_ERR(dev->clk);
+			goto err_assert_reset;
+		}
 
 		ret = clk_prepare_enable(dev->clk);
 		if (ret < 0)
-			return ret;
+			goto err_assert_reset;
+#endif
 	}
 
 	dev_set_drvdata(&pdev->dev, dev);
@@ -704,6 +862,8 @@ static int dw_i2s_probe(struct platform_device *pdev)
 err_clk_disable:
 	if (dev->capability & DW_I2S_MASTER)
 		clk_disable_unprepare(dev->clk);
+err_assert_reset:
+	reset_control_assert(dev->reset);
 	return ret;
 }
 
@@ -714,6 +874,7 @@ static int dw_i2s_remove(struct platform_device *pdev)
 	if (dev->capability & DW_I2S_MASTER)
 		clk_disable_unprepare(dev->clk);
 
+	reset_control_assert(dev->reset);
 	pm_runtime_disable(&pdev->dev);
 	return 0;
 }
@@ -721,6 +882,11 @@ static int dw_i2s_remove(struct platform_device *pdev)
 #ifdef CONFIG_OF
 static const struct of_device_id dw_i2s_of_match[] = {
 	{ .compatible = "snps,designware-i2s",	 },
+#ifdef SPACEMIT_CONFIG_DWC_I2S
+	{ .compatible = "snps,designware-i2s-master",	 },
+	{ .compatible = "snps,designware-i2s-slave",	 },
+	{ .compatible = "snps,designware-i2s4x-master",	 },
+#endif
 	{},
 };
 
diff --git a/sound/soc/dwc/local.h b/sound/soc/dwc/local.h
index 111111111111..222222222222 100644
--- a/sound/soc/dwc/local.h
+++ b/sound/soc/dwc/local.h
@@ -16,6 +16,10 @@
 #include <sound/pcm.h>
 #include <sound/designware_i2s.h>
 
+#if IS_ENABLED(CONFIG_SOC_SPACEMIT_K1PRO)
+#define SPACEMIT_CONFIG_DWC_I2S 1
+#endif
+
 /* common register for all channel */
 #define IER		0x000
 #define IRER		0x004
@@ -53,6 +57,12 @@
 #define I2S_COMP_VERSION	0x01F8
 #define I2S_COMP_TYPE		0x01FC
 
+#define I2S_RRXDMA		0x01C4
+#define I2S_RTXDMA		0x01CC
+#define I2S_DMACR		0x0200
+#define I2S_DMAEN_RXBLOCK	(1 << 16)
+#define I2S_DMAEN_TXBLOCK	(1 << 17)
+
 /*
  * Component parameter register fields - define the I2S block's
  * configuration.
@@ -89,6 +99,14 @@ union dw_i2s_snd_dma_data {
 struct dw_i2s_dev {
 	void __iomem *i2s_base;
 	struct clk *clk;
+#ifdef SPACEMIT_CONFIG_DWC_I2S
+	struct clk *clk_mclk;
+	struct clk *clk_bclk;
+	struct clk *clk_mclk_out;
+	int mclk_fs;
+	int fifo_empty_threshold;
+#endif
+	struct reset_control *reset;
 	int active;
 	unsigned int capability;
 	unsigned int quirks;
diff --git a/sound/soc/spacemit/Kconfig b/sound/soc/spacemit/Kconfig
new file mode 100644
index 000000000000..111111111111
--- /dev/null
+++ b/sound/soc/spacemit/Kconfig
@@ -0,0 +1,7 @@
+config SND_SOC_SPACEMIT
+	tristate "SoC Audio for SPACEMIT System-on-Chip"
+	select SND_SOC_COMPRESS
+	select SND_SOC_GENERIC_DMAENGINE_PCM if (SND_SOC && SND)
+	help
+	  Say Y or M here if you want support for audio on SPACEMIT SoC.
+
diff --git a/sound/soc/spacemit/Makefile b/sound/soc/spacemit/Makefile
new file mode 100644
index 000000000000..111111111111
--- /dev/null
+++ b/sound/soc/spacemit/Makefile
@@ -0,0 +1,4 @@
+snd-soc-spacemit-objs := spacemit-snd-sspa.o spacemit-dummy-codec.o \
+			spacemit-snd-i2s.o \
+			spacemit-snd-card.o spacemit-snd-pcm-dma.o
+obj-$(CONFIG_SND_SOC_SPACEMIT) += snd-soc-spacemit.o
diff --git a/sound/soc/spacemit/spacemit-dummy-codec.c b/sound/soc/spacemit/spacemit-dummy-codec.c
new file mode 100644
index 000000000000..111111111111
--- /dev/null
+++ b/sound/soc/spacemit/spacemit-dummy-codec.c
@@ -0,0 +1,73 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 SPACEMIT
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+
+struct snd_soc_dai_driver dummy_dai = {
+	.name = "dummy_codec",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+			    SNDRV_PCM_FMTBIT_S20_3LE |
+			    SNDRV_PCM_FMTBIT_S24_LE |
+			    SNDRV_PCM_FMTBIT_S32_LE),
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+			    SNDRV_PCM_FMTBIT_S20_3LE |
+			    SNDRV_PCM_FMTBIT_S24_LE |
+			    SNDRV_PCM_FMTBIT_S32_LE),
+	},
+};
+
+static const struct snd_soc_component_driver soc_dummy_codec = {
+};
+
+static int dummy_codec_probe(struct platform_device *pdev)
+{
+	return devm_snd_soc_register_component(&pdev->dev, &soc_dummy_codec,
+				      &dummy_dai, 1);
+}
+
+static int dummy_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+
+	return 0;
+}
+
+static const struct of_device_id dummy_codec_of_match[] = {
+	{ .compatible = "spacemit,dummy-codec", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dummy_codec_of_match);
+
+static struct platform_driver dummy_codec_driver = {
+	.driver = {
+		.name = "dummy_codec",
+		.of_match_table = dummy_codec_of_match,
+	},
+	.probe = dummy_codec_probe,
+	.remove = dummy_codec_remove,
+};
+
+module_platform_driver(dummy_codec_driver);
+
+MODULE_DESCRIPTION("SPACEMIT Dummy Codec Driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/spacemit/spacemit-snd-card.c b/sound/soc/spacemit/spacemit-snd-card.c
new file mode 100644
index 000000000000..111111111111
--- /dev/null
+++ b/sound/soc/spacemit/spacemit-snd-card.c
@@ -0,0 +1,378 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 SPACEMIT
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <sound/jack.h>
+#include <sound/simple_card.h>
+#include <sound/soc-dai.h>
+#include <sound/soc.h>
+#include <linux/input.h>
+
+#define DAI	"sound-dai"
+#define CELL	"#sound-dai-cells"
+#define PREFIX	"simple-audio-card,"
+
+static int asoc_simple_parse_dai(struct device_node *node,
+		struct snd_soc_dai_link_component *dlc,
+		int *is_single_link)
+{
+	struct of_phandle_args args;
+	int ret;
+	if (!node)
+		return 0;
+	/*
+	 * Get node via "sound-dai = <&phandle port>"
+	 * it will be used as xxx_of_node on soc_bind_dai_link()
+	 */
+	ret = of_parse_phandle_with_args(node, DAI, CELL, 0, &args);
+	if (ret)
+		return ret;
+	/*
+	 * FIXME
+	 *
+	 * Here, dlc->dai_name is pointer to CPU/Codec DAI name.
+	 * If user unbinded CPU or Codec driver, but not for Sound Card,
+	 * dlc->dai_name is keeping unbinded CPU or Codec
+	 * driver's pointer.
+	 *
+	 * If user re-bind CPU or Codec driver again, ALSA SoC will try
+	 * to rebind Card via snd_soc_try_rebind_card(), but because of
+	 * above reason, it might can't bind Sound Card.
+	 * Because Sound Card is pointing to released dai_name pointer.
+	 *
+	 * To avoid this rebind Card issue,
+	 * 1) It needs to alloc memory to keep dai_name eventhough
+	 *    CPU or Codec driver was unbinded, or
+	 * 2) user need to rebind Sound Card everytime
+	 *    if he unbinded CPU or Codec.
+	 */
+	ret = snd_soc_of_get_dai_name(node, &dlc->dai_name);
+	if (ret < 0)
+		return ret;
+	dlc->of_node = args.np;
+	if (is_single_link)
+		*is_single_link = !args.args_count;
+	return 0;
+}
+
+static int asoc_simple_parse_platform(struct device_node *node,
+				      struct snd_soc_dai_link_component *dlc)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+	/*
+	 * Get node via "sound-dai = <&phandle port>"
+	 * it will be used as xxx_of_node on soc_bind_dai_link()
+	 */
+	ret = of_parse_phandle_with_args(node, DAI, CELL, 0, &args);
+	if (ret)
+		return ret;
+
+	/* dai_name is not required and may not exist for plat component */
+	dlc->of_node = args.np;
+	return 0;
+}
+
+static int asoc_simple_card_jack_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_component *component = asoc_rtd_to_codec(rtd, 0)->component;
+	struct snd_soc_card *card = rtd->card;
+	struct asoc_simple_priv *priv = snd_soc_card_get_drvdata(card);
+	int ret;
+
+	ret = snd_soc_card_jack_new_pins(rtd->card, "Headset Jack",
+			SND_JACK_HEADSET | SND_JACK_BTN_0 |
+			SND_JACK_BTN_1 | SND_JACK_BTN_2, &priv->hp_jack.jack,
+			NULL, 0);
+	if (ret) {
+		dev_err(rtd->dev, "Headset Jack creation failed %d\n", ret);
+		return ret;
+	}
+
+	snd_jack_set_key(priv->hp_jack.jack.jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);
+	snd_jack_set_key(priv->hp_jack.jack.jack, SND_JACK_BTN_1, KEY_VOLUMEUP);
+	snd_jack_set_key(priv->hp_jack.jack.jack, SND_JACK_BTN_2, KEY_VOLUMEDOWN);
+
+	snd_soc_component_set_jack(component, &priv->hp_jack.jack, NULL);
+	return 0;
+}
+
+int asoc_simple_parse_daistream(struct device *dev,
+				struct device_node *node,
+				char *prefix,
+				struct snd_soc_dai_link *dai_link)
+{
+	char prop[128];
+	unsigned int dai_stream = 0;
+	unsigned int playback_only = BIT(0);
+	unsigned int capture_only = BIT(1);
+
+	if (!prefix)
+		prefix = "";
+
+	/* check "[prefix]playback_only" */
+	snprintf(prop, sizeof(prop), "%splayback_only", prefix);
+	if (of_property_read_bool(node, prop))
+		dai_stream |= playback_only;
+
+	/* check "[prefix]capture_only" */
+	snprintf(prop, sizeof(prop), "%scapture_only", prefix);
+	if (of_property_read_bool(node, prop))
+		dai_stream |= capture_only;
+
+	if (dai_stream == (playback_only | capture_only)) {
+		pr_err("unsupport stream\n");
+		dai_link->playback_only = 0;
+		dai_link->capture_only = 0;
+	} else if (dai_stream == playback_only) {
+		dai_link->playback_only = 1;
+	} else if (dai_stream == capture_only) {
+		dai_link->capture_only = 1;
+	} else {
+		dai_link->playback_only = 0;
+		dai_link->capture_only = 0;
+	}
+
+	return 0;
+}
+
+static int asoc_simple_card_dai_link_of(struct device_node *node,
+					struct asoc_simple_priv *priv,
+					int idx,
+					bool is_top_level_node)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, idx);
+	struct device_node *cpu = NULL;
+	struct device_node *plat = NULL;
+	struct device_node *codec = NULL;
+	char prop[128];
+	char *prefix = "";
+	int ret, single_cpu;
+
+	if (is_top_level_node)
+		prefix = PREFIX;
+
+	snprintf(prop, sizeof(prop), "%scpu", prefix);
+	cpu = of_get_child_by_name(node, prop);
+
+	if (!cpu) {
+		ret = -EINVAL;
+		dev_err(dev, "%s: Can't find %s DT node\n", __func__, prop);
+		goto dai_link_of_err;
+	}
+	snprintf(prop, sizeof(prop), "%splat", prefix);
+	plat = of_get_child_by_name(node, prop);
+
+	snprintf(prop, sizeof(prop), "%scodec", prefix);
+	codec = of_get_child_by_name(node, prop);
+	if (!codec) {
+		ret = -EINVAL;
+		dev_err(dev, "%s: Can't find %s DT node\n", __func__, prop);
+		goto dai_link_of_err;
+	}
+
+	ret = asoc_simple_parse_daistream(dev, node, prefix, dai_link);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_parse_daifmt(dev, node, codec,
+				       prefix, &dai_link->dai_fmt);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	//cpu dai
+	ret = asoc_simple_parse_dai(cpu, dai_link->cpus, &single_cpu);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	//codec dai
+	ret = asoc_simple_parse_dai(codec, dai_link->codecs, NULL);
+	if (ret < 0) {
+		goto dai_link_of_err;
+	}
+
+	//platform
+	ret = asoc_simple_parse_platform(plat, dai_link->platforms);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_set_dailink_name(dev, dai_link,
+					   "%s-%s",
+					   dai_link->cpus->dai_name,
+					   dai_link->codecs->dai_name);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	if (of_property_read_bool(node, "spacemit,init-jack")) {
+		dai_link->init = asoc_simple_card_jack_init;
+	}
+
+	asoc_simple_canonicalize_cpu(dai_link->cpus, single_cpu);
+	asoc_simple_canonicalize_platform(dai_link->platforms, dai_link->cpus);
+
+dai_link_of_err:
+	of_node_put(cpu);
+	of_node_put(codec);
+
+	return ret;
+}
+
+static int asoc_simple_card_parse_of(struct device_node *node,
+				     struct asoc_simple_priv *priv)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct device_node *dai_link;
+	int ret;
+
+	if (!node)
+		return -EINVAL;
+
+	/* The off-codec widgets */
+	ret = asoc_simple_parse_widgets(&priv->snd_card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	/* DAPM routes */
+	ret = asoc_simple_parse_routing(&priv->snd_card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_parse_pin_switches(&priv->snd_card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	dai_link = of_get_child_by_name(node, PREFIX "dai-link");
+	/* Single/Muti DAI link(s) & New style of DT node */
+	if (dai_link) {
+		struct device_node *np = NULL;
+		int i = 0;
+		for_each_child_of_node(node, np) {
+			dev_dbg(dev, "\tlink %d:\n", i);
+			ret = asoc_simple_card_dai_link_of(np, priv,
+							   i, false);
+			if (ret < 0) {
+				of_node_put(np);
+				goto card_parse_end;
+			}
+			i++;
+		}
+	} else {
+		/* For single DAI link & old style of DT node */
+		ret = asoc_simple_card_dai_link_of(node, priv, 0, true);
+		if (ret < 0)
+			goto card_parse_end;
+	}
+
+	ret = asoc_simple_parse_card_name(&priv->snd_card, PREFIX);
+
+card_parse_end:
+	of_node_put(dai_link);
+
+	return ret;
+}
+
+static int asoc_simple_card_probe(struct platform_device *pdev)
+{
+	struct asoc_simple_priv *priv;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct snd_soc_card *card;
+	struct link_info *li;
+	int ret;
+
+	/* Allocate the private data and the DAI link array */
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	li = devm_kzalloc(dev, sizeof(*li), GFP_KERNEL);
+	if (!li)
+		return -ENOMEM;
+
+	card = simple_priv_to_card(priv);
+	card->owner		= THIS_MODULE;
+	card->dev		= dev;
+
+	memset(li, 0, sizeof(struct link_info));
+
+	/* Get the number of DAI links */
+	if (np && of_get_child_by_name(np, PREFIX "dai-link")) {
+		li->link = of_get_child_count(np);
+	} else {
+		li->link = 1;
+		li->num[0].cpus		= 1;
+		li->num[0].codecs	= 1;
+		li->num[0].platforms	= 1;
+	}
+
+	ret = asoc_simple_init_priv(priv, li);
+	if (ret < 0)
+		return ret;
+
+	if (np && of_device_is_available(np)) {
+		ret = asoc_simple_card_parse_of(np, priv);
+		if (ret < 0) {
+			if (ret != -EPROBE_DEFER)
+				dev_err(dev, "parse error %d\n", ret);
+			goto err;
+		}
+
+	} else {
+		dev_err(dev, "simple card dts available\n");
+	}
+
+	snd_soc_card_set_drvdata(&priv->snd_card, priv);
+	ret = devm_snd_soc_register_card(&pdev->dev, &priv->snd_card);
+	if (ret >= 0)
+		return ret;
+err:
+	asoc_simple_clean_reference(&priv->snd_card);
+
+	return ret;
+}
+
+static int asoc_simple_card_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	asoc_simple_clean_reference(card);
+	return 0;
+}
+
+static const struct of_device_id asoc_simple_of_match[] = {
+	{ .compatible = "spacemit,simple-audio-card", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, asoc_simple_of_match);
+
+static struct platform_driver asoc_simple_card = {
+	.driver = {
+		.name = "spacemit-audio-card",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = asoc_simple_of_match,
+	},
+	.probe = asoc_simple_card_probe,
+	.remove = asoc_simple_card_remove,
+};
+
+static int spacemit_snd_card_init(void)
+{
+	return platform_driver_register(&asoc_simple_card);
+}
+late_initcall_sync(spacemit_snd_card_init);
+
+MODULE_DESCRIPTION("SPACEMIT ASoC Machine Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/spacemit/spacemit-snd-i2s.c b/sound/soc/spacemit/spacemit-snd-i2s.c
new file mode 100644
index 000000000000..111111111111
--- /dev/null
+++ b/sound/soc/spacemit/spacemit-snd-i2s.c
@@ -0,0 +1,478 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 SPACEMIT
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/dmaengine.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+#include "spacemit-snd-i2s.h"
+
+static int i2s_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt);
+
+//APB Clock/Reset Control Register
+#define APB_CLK_BASE        0xD4015000
+#define APB_SSP0_CLK_RST    0x80
+#define APB_SSP1_CLK_RST    0x84
+#define APB_AIB_CLK_RST     0x3C
+
+#define FNCLKSEL_6p5M       (0x0 << 4)
+#define FNCLKSEL_13M        (0x1 << 4)
+#define FNCLKSEL_26M        (0x2 << 4)
+#define FNCLKSEL_52M        (0x3 << 4)
+#define FNCLKSEL_3p25M      (0x4 << 4)
+#define FNCLKSEL_1p625M     (0x5 << 4)
+#define FNCLKSEL_812p5M     (0x6 << 4)
+#define FNCLKSEL_AUDIO      (0x7 << 4)
+#define CLK_ON_NORST        (0x3 << 0)
+#define CLK_ON_RST          (0x7 << 0)
+#define CLK_ON_26M          (CLK_ON_NORST | FNCLKSEL_26M)
+#define CLK_ON_6p5M         (CLK_ON_NORST | FNCLKSEL_6p5M)
+#define CLK_ON_I2S          ((0x1<<3) | CLK_ON_NORST | FNCLKSEL_AUDIO)
+
+//I2S CLK
+#define  PMUMAIN_BASE       0xD4050000
+#define  ISCCR1             0x44
+#define  SYSCLK_EN          (0x1 << 31)
+#define  BITCLK_EN          (0x1 << 29)
+#define  SYSCLK_BASE_156M   (0x1 << 30)
+#define  SYSCLK_BASE_26M    (0x0 << 30)
+#define  BITCLK_DIV_468     (0x0 << 27)
+#define  FRAME_48K_I2S      (0x4 << 15)
+
+/*
+ * ssp:sspa audio private data
+ */
+ struct ssp_device {
+	struct platform_device *pdev;
+	struct list_head	node;
+
+	struct clk	*clk;
+	void __iomem	*mmio_base;
+	void __iomem	*mmio_ctrl_base;
+	void __iomem	*apb_clk_base;
+	void __iomem	*pmumain;
+	unsigned long	phys_base;
+
+	const char	*label;
+	int		port_id;
+	int		type;
+	int		use_count;
+	int		irq;
+
+	struct device_node	*of_node;
+};
+
+struct sspa_priv {
+	struct ssp_device *sspa;
+	struct snd_dmaengine_dai_dma_data *dma_params;
+	struct reset_control *sspa_rst;
+	int dai_fmt;
+	int dai_id_pre;
+	int running_cnt;
+	struct platform_device *i2splatdev;
+};
+
+static void i2s_sspa_write_reg(struct ssp_device *sspa, u32 reg, u32 val)
+{
+	__raw_writel(val, sspa->mmio_base + reg);
+}
+
+static u32 i2s_sspa_read_reg(struct ssp_device *sspa, u32 reg)
+{
+	return __raw_readl(sspa->mmio_base + reg);
+}
+
+static int i2s_sspa_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(dai);
+	pm_runtime_get_sync(&priv->i2splatdev->dev);
+	i2s_sspa_set_dai_fmt(dai, SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_I2S);
+
+	return 0;
+}
+
+static void i2s_sspa_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(dai);
+	pm_runtime_put_sync(&priv->i2splatdev->dev);
+}
+
+static int i2s_sspa_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+				    int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int i2s_sspa_set_dai_pll(struct snd_soc_dai *cpu_dai, int pll_id,
+				 int source, unsigned int freq_in,
+				 unsigned int freq_out)
+{
+	return 0;
+}
+
+/*
+ * Set up the sspa dai format. The sspa port must be inactive
+ * before calling this function as the physical
+ * interface format is changed.
+ */
+static int i2s_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+				 unsigned int fmt)
+{
+	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct ssp_device *sspa = sspa_priv->sspa;
+	unsigned int ssp_top_cfg=0, ssp_fifo_cfg=0, ssp_int_en_cfg=0,ssp_to_cfg=0, ssp_psp_cfg=0, ssp_net_work_ctrl=0;
+	int dai_id = cpu_dai->id;
+
+	pr_debug("%s, fmt=0x%x, dai_id=0x%x\n", __FUNCTION__, fmt, dai_id);
+
+	if ((sspa_priv->dai_fmt == fmt) & (sspa_priv->dai_id_pre == dai_id) & (i2s_sspa_read_reg(sspa, PSP_CTRL)))
+		return 0;
+
+	ssp_top_cfg  = TOP_TRAIL_DMA | DW_32BYTE | TOP_SFRMDIR_M | TOP_SCLKDIR_M | TOP_FRF_PSP;
+	ssp_fifo_cfg = FIFO_RSRE | FIFO_TSRE | FIFO_RX_THRES_15 | FIFO_TX_THRES_15;
+
+	if ((i2s_sspa_read_reg(sspa, TOP_CTRL) & TOP_SSE)) {
+		pr_debug("no need to change hardware dai format: stream is in use\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		ssp_top_cfg |= TOP_SFRMDIR_M;
+		ssp_top_cfg |= TOP_SCLKDIR_M;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		ssp_top_cfg |= TOP_FRF_PSP;
+		ssp_psp_cfg = (0x10<<12) | (0x1<<3) | PSP_SFRMP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	i2s_sspa_write_reg(sspa, TOP_CTRL, ssp_top_cfg);
+	i2s_sspa_write_reg(sspa, PSP_CTRL, ssp_psp_cfg);
+	i2s_sspa_write_reg(sspa, INT_EN, ssp_int_en_cfg);
+	i2s_sspa_write_reg(sspa, TO, ssp_to_cfg);
+	i2s_sspa_write_reg(sspa, FIFO_CTRL, ssp_fifo_cfg);
+	i2s_sspa_write_reg(sspa, NET_WORK_CTRL, ssp_net_work_ctrl);
+
+	pr_debug("TOP_CTRL=0x%x,\n PSP_CTRL=0x%x,\n INT_EN=0x%x,\n TO=0x%x,\n FIFO_CTRL=0x%x,\n,NET_WORK_CTRL=0x%x",
+				i2s_sspa_read_reg(sspa, TOP_CTRL),
+				i2s_sspa_read_reg(sspa, PSP_CTRL),
+				i2s_sspa_read_reg(sspa, INT_EN),
+				i2s_sspa_read_reg(sspa, TO),
+				i2s_sspa_read_reg(sspa, FIFO_CTRL),
+				i2s_sspa_read_reg(sspa, NET_WORK_CTRL));
+
+	sspa_priv->dai_fmt = fmt;
+	sspa_priv->dai_id_pre = dai_id;
+
+	return 0;
+}
+
+/*
+ * Set the SSPA audio DMA parameters and sample size.
+ * Can be called multiple times.
+ */
+static int i2s_sspa_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, dai->id);
+	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
+	struct ssp_device *sspa = sspa_priv->sspa;
+	struct snd_dmaengine_dai_dma_data *dma_params;
+
+	pr_debug("%s, format=0x%x\n", __FUNCTION__, params_format(params));
+	dma_params = &sspa_priv->dma_params[substream->stream];
+	dma_params->addr = (sspa->phys_base + DATAR);
+	dma_params->maxburst = 32;
+	dma_params->addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	snd_soc_dai_set_dma_data(cpu_dai, substream, dma_params);
+	return 0;
+}
+
+static int i2s_sspa_trigger(struct snd_pcm_substream *substream, int cmd,
+			     struct snd_soc_dai *dai)
+{
+	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
+	struct ssp_device *sspa = sspa_priv->sspa;
+	int ret = 0;
+
+	pr_debug("%s cmd=%d, cnt=%d\n", __FUNCTION__, cmd, sspa_priv->running_cnt);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		unsigned int ssp_top_cfg = i2s_sspa_read_reg(sspa, TOP_CTRL);
+		pr_debug("TOP_CTRL:0x%x", ssp_top_cfg);
+		ssp_top_cfg |= TOP_SSE;
+		i2s_sspa_write_reg(sspa, TOP_CTRL, ssp_top_cfg);   //SSP_enable
+		sspa_priv->running_cnt++;
+		pr_debug("triger::TOP_CTRL=0x%x,\n PSP_CTRL=0x%x,\n INT_EN=0x%x,\n TO=0x%x,\n FIFO_CTRL=0x%x,\n",
+				i2s_sspa_read_reg(sspa, TOP_CTRL), i2s_sspa_read_reg(sspa, PSP_CTRL),
+				i2s_sspa_read_reg(sspa, INT_EN),
+				i2s_sspa_read_reg(sspa, TO),
+				i2s_sspa_read_reg(sspa, FIFO_CTRL));
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	if (sspa_priv->running_cnt > 0)
+		sspa_priv->running_cnt--;
+	if (sspa_priv->running_cnt == 0 ) {
+		ssp_top_cfg = i2s_sspa_read_reg(sspa, TOP_CTRL);
+		ssp_top_cfg &= (~TOP_SSE);
+		i2s_sspa_write_reg(sspa, TOP_CTRL, ssp_top_cfg);
+		pr_debug("TOP_CTRL=0x%x, dai->id=%d \n", i2s_sspa_read_reg(sspa, TOP_CTRL), dai->id);
+	}
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			pr_debug("%s ignore playback tx\n", __FUNCTION__);
+		}
+
+		/* have no capture stream, disable rx port */
+		if (!sspa_priv->running_cnt) {
+			pr_debug("%s sspa_priv->running_cnt=%d\n", __FUNCTION__, sspa_priv->running_cnt);
+		}
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int i2s_sspa_probe(struct snd_soc_dai *dai)
+{
+	struct sspa_priv *priv = dev_get_drvdata(dai->dev);
+	struct ssp_device *sspa = priv->sspa;
+	unsigned int sspa_clk = 0;
+	pr_debug("%s\n", __FUNCTION__);
+	//init clock
+	__raw_writel((SYSCLK_BASE_156M | BITCLK_DIV_468| FRAME_48K_I2S | 200), sspa->pmumain + ISCCR1);
+
+	if (dai->id == 0)
+	{
+		//i2s0
+		sspa_clk = __raw_readl(sspa->apb_clk_base + APB_SSP0_CLK_RST);
+		__raw_writel((1 << 3)|sspa_clk, sspa->apb_clk_base + APB_SSP0_CLK_RST);
+	} else {
+		//i2s1
+		sspa_clk = __raw_readl(sspa->apb_clk_base + APB_SSP1_CLK_RST);
+		__raw_writel((1 << 3)|sspa_clk, sspa->apb_clk_base + APB_SSP1_CLK_RST);
+    }
+	reset_control_deassert(priv->sspa_rst);
+	snd_soc_dai_set_drvdata(dai, priv);
+	return 0;
+
+}
+
+#define I2S_SSPA_RATES SNDRV_PCM_RATE_8000_192000
+#define I2S_SSPA_FORMATS (SNDRV_PCM_FMTBIT_S8 | \
+		SNDRV_PCM_FMTBIT_S16_LE | \
+		SNDRV_PCM_FMTBIT_S24_LE | \
+		SNDRV_PCM_FMTBIT_S32_LE)
+
+static const struct snd_soc_dai_ops i2s_sspa_dai_ops = {
+	.startup	= i2s_sspa_startup,
+	.shutdown	= i2s_sspa_shutdown,
+	.trigger	= i2s_sspa_trigger,
+	.hw_params	= i2s_sspa_hw_params,
+	.set_sysclk	= i2s_sspa_set_dai_sysclk,
+	.set_pll	= i2s_sspa_set_dai_pll,
+	.set_fmt	= i2s_sspa_set_dai_fmt,
+};
+
+static struct snd_soc_dai_driver i2s_sspa_dai[] = {
+	{
+		.name = "i2s-dai0",
+		.probe = i2s_sspa_probe,
+		.id = 0,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 128,
+			.rates = I2S_SSPA_RATES,
+			.formats = I2S_SSPA_FORMATS,
+		},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = I2S_SSPA_RATES,
+			.formats = I2S_SSPA_FORMATS,
+		},
+		.ops = &i2s_sspa_dai_ops,
+	},
+	{
+		.name = "i2s-dai1",
+		.probe = i2s_sspa_probe,
+		.id = 1,
+		.playback = {
+			.channels_min = 1,
+			.channels_max = 128,
+			.rates = I2S_SSPA_RATES,
+			.formats = I2S_SSPA_FORMATS,
+		},
+		.capture = {
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = I2S_SSPA_RATES,
+			.formats = I2S_SSPA_FORMATS,
+		},
+		.ops = &i2s_sspa_dai_ops,
+	}
+};
+
+static int i2s_sspa_suspend(struct snd_soc_component *component)
+{
+	/*to-do */
+	return 0;
+}
+
+static int i2s_sspa_resume(struct snd_soc_component *component)
+{
+	/*to-do */
+	return 0;
+}
+static const struct snd_soc_component_driver i2s_sspa_component = {
+	.name 			= "spacemit-dmasspa-dai",
+	.resume 		= i2s_sspa_resume,
+	.suspend 		= i2s_sspa_suspend,
+};
+
+static int asoc_i2s_sspa_probe(struct platform_device *pdev)
+{
+	struct sspa_priv *priv;
+	struct resource *res;
+	u8 dai_id = 0;
+
+	printk("enter %s\n", __FUNCTION__);
+	priv = devm_kzalloc(&pdev->dev,
+				sizeof(struct sspa_priv), GFP_KERNEL);
+	if (!priv) {
+		pr_err("%s priv alloc failed\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+	priv->sspa = devm_kzalloc(&pdev->dev,
+				sizeof(struct ssp_device), GFP_KERNEL);
+	if (priv->sspa == NULL) {
+		pr_err("%s sspa alloc failed\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	priv->dma_params = devm_kcalloc(&pdev->dev,
+			2, sizeof(struct snd_dmaengine_dai_dma_data),
+			GFP_KERNEL);
+	if (priv->dma_params == NULL) {
+		pr_err("%s dma_params alloc failed\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pr_debug("%s, start=0x%lx, end=0x%lx\n", __FUNCTION__, (unsigned long)res->start, (unsigned long)res->end);
+	priv->sspa->mmio_base = devm_ioremap_resource(&pdev->dev, res);
+
+	if (IS_ERR(priv->sspa->mmio_base)) {
+		pr_err("%s mmio_base alloc failed\n", __FUNCTION__);
+		return PTR_ERR(priv->sspa->mmio_base);
+	}
+
+	if ((priv->sspa->apb_clk_base = ioremap(APB_CLK_BASE, 0x100)) == NULL) {
+		pr_err("sspa ioremap err\n");
+		return -1;
+	}
+	if ((priv->sspa->pmumain = ioremap(PMUMAIN_BASE, 0x100)) == NULL) {
+		pr_err("sspa pmumain ioremap err\n");
+		return -1;
+	}
+	//get reset
+	priv->sspa_rst = devm_reset_control_get(&pdev->dev, "sspa-rst");
+	if (IS_ERR(priv->sspa_rst))
+		return PTR_ERR(priv->sspa_rst);
+
+	pm_runtime_enable(&pdev->dev);
+	priv->i2splatdev = pdev;
+
+	priv->dai_fmt = (unsigned int) -1;
+	platform_set_drvdata(pdev, priv);
+	pr_debug("exit %s\n", __FUNCTION__);
+	if (of_device_is_compatible(pdev->dev.of_node, "spacemit,spacemit-i2s0")) {
+		dai_id = 0;
+	} else {
+		dai_id = 1;
+	}
+	return devm_snd_soc_register_component(&pdev->dev, &i2s_sspa_component,
+					       &i2s_sspa_dai[dai_id], 1);
+}
+
+static int asoc_i2s_sspa_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id spacemit_i2s_ids[] = {
+	{ .compatible = "spacemit,spacemit-i2s0", },
+	{ .compatible = "spacemit,spacemit-i2s1", },
+	{ /* sentinel */ }
+};
+#endif
+
+static struct platform_driver asoc_i2s_sspa_driver = {
+	.driver = {
+		.name = "spacemit-snd-i2s",
+		.of_match_table = of_match_ptr(spacemit_i2s_ids),
+	},
+	.probe = asoc_i2s_sspa_probe,
+	.remove = asoc_i2s_sspa_remove,
+};
+
+#if IS_MODULE(CONFIG_SND_SOC_SPACEMIT)
+int spacemit_snd_register_i2s_pdrv(void)
+{
+	printk("%s\n", __FUNCTION__);
+	return platform_driver_register(&asoc_i2s_sspa_driver);
+}
+
+EXPORT_SYMBOL(spacemit_snd_register_i2s_pdrv);
+
+void spacemit_snd_unregister_i2s_pdrv(void)
+{
+	platform_driver_unregister(&asoc_i2s_sspa_driver);
+}
+EXPORT_SYMBOL(spacemit_snd_unregister_i2s_pdrv);
+
+#else
+
+module_platform_driver(asoc_i2s_sspa_driver);
+
+#endif
+
+MODULE_DESCRIPTION("I2S SSPA SoC driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/spacemit/spacemit-snd-i2s.h b/sound/soc/spacemit/spacemit-snd-i2s.h
new file mode 100644
index 000000000000..111111111111
--- /dev/null
+++ b/sound/soc/spacemit/spacemit-snd-i2s.h
@@ -0,0 +1,135 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2023 SPACEMIT
+ *
+ */
+
+#ifndef _SPI_SPACEMIT_H
+#define _SPI_SPACEMIT_H
+
+/* SPACEMIT AQUILA SPI Registers */
+#define TOP_CTRL		0x00	/* SSP Top Control Register */
+#define FIFO_CTRL		0x04	/* SSP FIFO Control Register */
+#define INT_EN			0x08    /* SSP Interrupt Enable Register */
+#define TO			0x0C    /* SSP Time Out Register */
+#define DATAR			0x10    /* SSP Data Register */
+#define STATUS			0x14    /* SSP Stauts Register */
+#define PSP_CTRL		0x18    /* SSP Programmable Serial Protocal Control Register */
+#define NET_WORK_CTRL		0x1C    /* SSP NET Work Control Register */
+#define NET_WORK_STATUS		0x20    /* SSP Net Work Status Register */
+#define RWOT_CTRL		0x24    /* SSP RWOT Control Register */
+#define RWOT_CCM		0x28    /* SSP RWOT Counter Cycles Match Register */
+#define RWOT_CVWRn		0x2C    /* SSP RWOT Counter Value Write for Read Request Register */
+
+/* 0x00 TOP_CTRL */
+#define TOP_TTELP		(1 << 18)
+#define TOP_TTE			(1 << 17)
+#define TOP_SCFR		(1 << 16)
+#define TOP_IFS			(1 << 15)
+#define TOP_HOLD_FRAME_LOW	(1 << 14)
+#define TOP_TRAIL_PXA	(0 << 13)
+#define TOP_TRAIL_DMA   (1 << 13)
+#define TOP_LBM			(1 << 12)
+#define TOP_SPH1		(1 << 11)
+#define TOP_SPH0		(1 << 11)
+#define TOP_SPO1		(1 << 10)
+#define TOP_SPO0		(0 << 10)
+#define DW_8BYTE        (0x7<<5)   //SSP_TOP_CTRL[9:5]
+#define DW_16BYTE       (0xf<<5)   //SSP_TOP_CTRL[9:5] 
+#define DW_18BYTE       (0x11<<5)  //SSP_TOP_CTRL[9:5]
+#define DW_32BYTE       (0x1f<<5)  //SSP_TOP_CTRL[9:5]
+//#define TOP_DSS(x)		((x - 1) << 5)
+//#define TOP_DSS_MASK		(0x1F << 5)
+#define TOP_SFRMDIR_S		(1 << 4)
+#define TOP_SFRMDIR_M		(0 << 4)
+#define TOP_SCLKDIR_S		(1 << 3)
+#define TOP_SCLKDIR_M		(0 << 3)
+#define TOP_FRF_MASK		(0x3 << 1)
+#define TOP_FRF_Motorola	(0x0 << 1)	/* Motorola's Serial Peripheral Interface (SPI) */
+#define TOP_FRF_TI		(0x1 << 1)	/* Texas Instruments' Synchronous Serial Protocol (SSP) */
+#define TOP_FRF_National	(0x2 << 1)	/* National Microwire */
+#define TOP_FRF_PSP		(0x3 << 1)	/* Programmable Serial Protocol(PSP) */
+#define TOP_SSE			(1 << 0)
+
+/* 0x04 FIFO_CTRL */
+#define FIFO_STRF			(1 << 19)
+#define FIFO_EFWR			(1 << 18)
+#define FIFO_RXFIFO_AUTO_FULL_CTRL	(1 << 17)
+#define FIFO_FPCKE			(1 << 16)
+#define FIFO_UNPACKING      (0 << 16)
+#define FIFO_TXFIFO_WR_ENDIAN_MASK	(0x3 << 14)
+#define FIFO_RXFIFO_RD_ENDIAN_MASK	(0x3 << 12)
+#define FIFO_WR_ENDIAN_16BITS		(1 << 14)	/* Swap first 16 bits and last 16 bits */
+#define FIFO_WR_ENDIAN_8BITS		(2 << 14)	/* Swap all 4 bytes */
+#define FIFO_RD_ENDIAN_16BITS		(1 << 12)	/* Swap first 16 bits and last 16 bits */
+#define FIFO_RD_ENDIAN_8BITS		(2 << 12)	/* Swap all 4 bytes */
+#define FIFO_RSRE			(1 << 11)
+#define FIFO_TSRE			(1 << 10)
+#define FIFO_RX_THRES_15                (0xf<<5)   //SSP_FIFO_CTRL[9:5]
+#define FIFO_RX_THRES_7                 (0x7<<5)   //SSP_FIFO_CTRL[9:5]
+#define FIFO_TX_THRES_15                (0xf<<0)   //SSP_FIFO_CTRL[4:0]
+#define FIFO_TX_THRES_7                 (0x7<<0)   //SSP_FIFO_CTRL[4:0]
+
+/* 0x08 INT_EN */
+#define INT_EN_EBCEI		(1 << 6)
+#define INT_EN_TIM		(1 << 5)
+#define INT_EN_RIM		(1 << 4)
+#define INT_EN_TIE		(1 << 3)
+#define INT_EN_RIE		(1 << 2)
+#define INT_EN_TINTE		(1 << 1)
+#define INT_EN_PINTE		(1 << 0)
+
+/* 0x0C TO */
+#define TIMEOUT(x)	((x) << 0)
+
+/* 0x10 DATAR */
+#define DATA(x)		((x) << 0)
+
+/* 0x14 STATUS */
+#define STATUS_OSS		(1 << 23)
+#define STATUS_TX_OSS		(1 << 22)
+#define STATUS_BCE		(1 << 21)
+#define STATUS_ROR		(1 << 20)
+#define STATUS_RNE		(1 << 14)
+#define STATUS_RFS		(1 << 13)
+#define STATUS_TUR		(1 << 12)
+#define STATUS_TNF		(1 << 6)
+#define STATUS_TFS		(1 << 5)
+#define STATUS_EOC		(1 << 4)
+#define STATUS_TINT		(1 << 3)
+#define STATUS_PINT		(1 << 2)
+#define STATUS_CSS		(1 << 1)
+#define STATUS_BSY		(1 << 0)
+
+/* 0x18 PSP_CTRL */
+#define PSP_EDMYSTOP(x)		((x) << 27)
+#define PSP_EMYSTOP(x)		((x) << 25)
+#define PSP_EDMYSTRT(x)		((x) << 23)
+#define PSP_DMYSTRT(x)		((x) << 21)
+#define PSP_STRTDLY(x)		((x) << 18)
+#define PSP_SFRMWDTH(x)		((x) << 12)
+#define PSP_SFRMDLY(x)		((x) << 5)
+#define PSP_SFRMP		(1 << 4)
+#define PSP_FSRT		(1 << 3)
+#define PSP_ETDS		(1 << 2)
+#define PSP_SCMODE(x)		((x) << 0)
+
+/* 0x1C NET_WORK_CTRL */
+#define RTSA(x)			((x) << 12)
+#define RTSA_MASK		(0xFF << 12)
+#define TTSA(x)			((x) << 4)
+#define TTSA_MASK		(0xFF << 4)
+#define NET_FRDC(x)		((x) << 1)
+#define NET_WORK_MODE		(1 << 0)
+
+/* 0x20 NET_WORK_STATUS */
+#define NET_SATUS_NMBSY		(1 << 3)
+#define NET_STATUS_TSS(x)	((x) << 0)
+
+/* 0x24 RWOT_CTRL */
+#define RWOT_MASK_RWOT_LAST_SAMPLE	(1 << 4)
+#define RWOT_CLR_RWOT_CYCLE		(1 << 3)
+#define RWOT_SET_RWOT_CYCLE		(1 << 2)
+#define RWOT_CYCLE_RWOT_EN		(1 << 1)
+#define RWOT_RWOT			(1 << 0)
+#endif /* _SPI_SPACEMIT_H */
diff --git a/sound/soc/spacemit/spacemit-snd-pcm-dma.c b/sound/soc/spacemit/spacemit-snd-pcm-dma.c
new file mode 100644
index 000000000000..111111111111
--- /dev/null
+++ b/sound/soc/spacemit/spacemit-snd-pcm-dma.c
@@ -0,0 +1,1048 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2023 SPACEMIT
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/genalloc.h>
+
+#define DRV_NAME "spacemit-snd-dma"
+
+#define I2S_PERIOD_SIZE          1024
+#define I2S_PERIOD_COUNT         4
+#define I2S0_REG_BASE            0xD4026000
+#define I2S1_REG_BASE            0xD4026800
+#define DATAR                    0x10    /* SSP Data Register */
+
+#define DMA_I2S0 0
+#define DMA_I2S1 1
+#define DMA_HDMI 2
+
+#define HDMI_REFORMAT_ENABLE
+#define I2S_HDMI_REG_BASE        0xC0883900
+#define HDMI_TXDATA              0x80
+#define HDMI_PERIOD_SIZE         480
+
+#define L_CH                            0
+#define R_CH                            1
+#define SAMPLE_PRESENT_FLAG_OFFSET      31
+#define AUDIO_FRAME_START_BIT_OFFSET    30
+#define SAMPLE_FLAT_BIT_OFFSET          29
+#define NOT_USED_OFFSET                 28
+#define PARITY_BIT_OFFSET               27
+#define CHANNEL_STATUS_OFFSET           26
+#define USER_DATA_OFFSET                25
+#define VALID_OFFSET                    24
+
+#define IEC958_AES0_CONSUMER            (0<<0)	/* 0 = consumer, 1 = professional */
+#define IEC958_AES0_AUDIO               (0<<1)	/* 0 = audio, 1 = non-audio */
+#define IEC958_AES3_CON_FS_48000        (2<<0)	/* 48kHz */
+#define IEC958_AES0_CON_NOT_COPYRIGHT   (1<<2)	/* 0 = copyright, 1 = not copyright */
+#define IEC958_AES0_CON_EMPHASIS_NONE   (0<<3)	/* none emphasis */
+#define IEC958_AES1_CON_GENERAL         (0x00)
+#define IEC958_AES2_CON_SOURCE_UNSPEC   (0<<0)	/* unspecified */
+#define IEC958_AES2_CON_CHANNEL_UNSPEC  (0<<4)	/* unspecified */
+#define IEC958_AES3_CON_CLOCK_1000PPM   (0<<4)	/* 1000 ppm */
+#define IEC958_AES4_CON_WORDLEN_24_20   (5<<1)	/* 24-bit or 20-bit */
+#define IEC958_AES4_CON_MAX_WORDLEN_24  (1<<0)	/* 0 = 20-bit, 1 = 24-bit */
+
+#define CS_CTRL1 ((1 << SAMPLE_PRESENT_FLAG_OFFSET) | (1 << AUDIO_FRAME_START_BIT_OFFSET))
+#define CS_CTRL2 ((1 << SAMPLE_PRESENT_FLAG_OFFSET) | (0 << AUDIO_FRAME_START_BIT_OFFSET))
+
+#define P2(n) n, n^1, n^1, n
+#define P4(n) P2(n), P2(n^1), P2(n^1), P2(n)
+#define P6(n) P4(n), P4(n^1), P4(n^1), P4(n)
+
+struct spacemit_snd_dmadata {
+	struct dma_chan *dma_chan;
+	unsigned int dma_id;
+	dma_cookie_t cookie;
+	spinlock_t dma_lock;
+	void *private_data;
+
+	int stream;
+	/*DOMAIN:config from userspace*/
+	struct snd_pcm_substream *substream;
+	unsigned long pos;
+	bool playback_data;
+};
+
+struct spacemit_snd_soc_device {
+	struct spacemit_snd_dmadata dmadata[2];
+	unsigned long pos;
+	bool playback_en;
+	bool capture_en;
+	spinlock_t lock;
+};
+
+struct hdmi_priv {
+	dma_addr_t phy_addr;
+	void __iomem	*buf_base;
+};
+
+/* HDMI initalization data */
+struct hdmi_codec_priv {
+    uint32_t srate;
+    uint32_t channels;
+    uint8_t iec_offset;
+    uint8_t ch_sn;
+    uint8_t cs[24];
+};
+
+struct hdmi_codec_priv hdmi_ptr = {0};
+static const bool ParityTable256[256] =
+{
+    P6(0), P6(1), P6(1), P6(0)
+};
+static struct hdmi_priv priv;
+static dma_addr_t hdmiraw_dma_addr;
+static dma_addr_t hdmipcm_dma_addr;
+static unsigned char *hdmiraw_dma_area;	/* DMA area */
+#ifdef HDMI_REFORMAT_ENABLE
+static unsigned char *hdmiraw_dma_area_tmp;
+#endif
+
+static int spacemit_snd_dma_init(struct device *paraent, struct spacemit_snd_soc_device *dev,
+			     struct spacemit_snd_dmadata *dmadata);
+
+static const struct snd_pcm_hardware spacemit_snd_pcm_hardware = {
+	.info		  = SNDRV_PCM_INFO_INTERLEAVED |
+			    SNDRV_PCM_INFO_BATCH,
+	.formats          = SNDRV_PCM_FMTBIT_S16_LE,
+	.rates            = SNDRV_PCM_RATE_48000,
+	.rate_min         = SNDRV_PCM_RATE_48000,
+	.rate_max         = SNDRV_PCM_RATE_48000,
+	.channels_min     = 2,
+	.channels_max     = 2,
+	.buffer_bytes_max = I2S_PERIOD_SIZE * I2S_PERIOD_COUNT * 4,
+	.period_bytes_min = I2S_PERIOD_SIZE * 4,
+	.period_bytes_max = I2S_PERIOD_SIZE * 4,
+	.periods_min	  = I2S_PERIOD_COUNT,
+	.periods_max	  = I2S_PERIOD_COUNT,
+};
+
+static const struct snd_pcm_hardware spacemit_snd_pcm_hardware_hdmi = {
+	.info		  = SNDRV_PCM_INFO_INTERLEAVED |
+			    SNDRV_PCM_INFO_BATCH,
+	.formats	  = SNDRV_PCM_FMTBIT_S16_LE,
+	.rates		  = SNDRV_PCM_RATE_48000,
+	.rate_min	  = SNDRV_PCM_RATE_48000,
+	.rate_max	  = SNDRV_PCM_RATE_48000,
+	.channels_min	  = 2,
+	.channels_max	  = 2,
+	.buffer_bytes_max = HDMI_PERIOD_SIZE * 4 * 4,
+	.period_bytes_min = HDMI_PERIOD_SIZE * 4,
+	.period_bytes_max = HDMI_PERIOD_SIZE * 4,
+	.periods_min	  = 4,
+	.periods_max	  = 4,
+};
+static int spacemit_dma_slave_config(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params,
+		struct dma_slave_config *slave_config,
+		int dma_id)
+{
+	int ret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);
+	if (ret)
+		return ret;
+
+	slave_config->dst_maxburst = 32;
+	slave_config->src_maxburst = 32;
+
+	slave_config->src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	slave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	/* for tmda , don't need to config dma controller addr, set to 0*/
+	if (dma_id == DMA_I2S0) {
+		pr_debug("i2s0_datar\n");
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			slave_config->dst_addr = I2S0_REG_BASE + DATAR;
+			slave_config->src_addr = 0;
+		}
+		else {
+			slave_config->src_addr = I2S0_REG_BASE + DATAR;
+			slave_config->dst_addr = 0;
+		}
+	} else if (dma_id == DMA_I2S1) {
+		pr_debug("i2s1_datar\n");
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			slave_config->dst_addr = I2S1_REG_BASE + DATAR;
+			slave_config->src_addr = 0;
+		}
+		else {
+			slave_config->src_addr = I2S1_REG_BASE + DATAR;
+			slave_config->dst_addr = 0;
+		}
+	} else if (dma_id == DMA_HDMI) {
+		pr_debug("i2s_hdmi_datar\n");
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			slave_config->dst_addr = I2S_HDMI_REG_BASE + HDMI_TXDATA;
+			slave_config->src_addr = 0;
+			#ifdef HDMI_REFORMAT_ENABLE
+			slave_config->src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+			slave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+			#else
+			slave_config->src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+			slave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+			#endif
+		}
+		else {
+			slave_config->src_addr = I2S_HDMI_REG_BASE + 0x00;
+			slave_config->dst_addr = 0;
+		}
+	}else {
+		pr_err("unsupport dma platform\n");
+		return -1;
+	}
+
+	pr_debug("leave %s\n", __FUNCTION__);
+
+	return 0;
+}
+
+static bool spacemit_get_stream_is_enable(struct spacemit_snd_soc_device *dev, int stream)
+{
+	bool ret;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		ret = dev->playback_en;
+	else
+		ret = dev->capture_en;
+	return ret;
+}
+
+static void spacemit_update_stream_status(struct spacemit_snd_soc_device *dev, int stream, bool enable)
+{
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dev->playback_en = enable;
+	else
+		dev->capture_en = enable;
+	return;
+}
+
+static int spacemit_snd_pcm_hw_params(struct snd_soc_component *component, struct snd_pcm_substream *substream,
+				  struct snd_pcm_hw_params *params)
+{
+	int ret;
+	struct dma_slave_config slave_config;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct spacemit_snd_dmadata *dmadata = runtime->private_data;
+
+	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
+	struct snd_pcm *pcm = rtd->pcm;
+	struct snd_pcm_substream *substream_tx;
+
+	struct spacemit_snd_soc_device *dev = snd_soc_component_get_drvdata(component);
+	struct spacemit_snd_dmadata *txdma = &dev->dmadata[0];
+	struct dma_slave_config slave_config_tx;
+
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	pr_debug("enter %s!! allocbytes=%d, dmadata=0x%lx\n",
+		__FUNCTION__, params_buffer_bytes(params), (unsigned long)dmadata);
+
+	if (dmadata->stream == SNDRV_PCM_STREAM_PLAYBACK
+			&& spacemit_get_stream_is_enable(dev, SNDRV_PCM_STREAM_CAPTURE)) {
+		ret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+		if (ret < 0)
+			goto unlock;
+	}
+	memset(&slave_config, 0, sizeof(slave_config));
+	memset(&slave_config_tx, 0, sizeof(slave_config_tx));
+
+	if (dmadata->dma_id != DMA_I2S0 && dmadata->dma_id != DMA_I2S1) {
+		pr_err("unsupport dma platform\n");
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	if (dmadata->stream == SNDRV_PCM_STREAM_CAPTURE
+			&& !spacemit_get_stream_is_enable(dev, SNDRV_PCM_STREAM_PLAYBACK)) {
+		substream_tx = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;
+		dmadata = txdma;
+		spacemit_dma_slave_config(substream_tx, params, &slave_config_tx, dmadata->dma_id);
+		slave_config_tx.direction = DMA_MEM_TO_DEV;
+		slave_config_tx.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		slave_config_tx.dst_addr = I2S0_REG_BASE + DATAR;
+		slave_config_tx.src_addr = 0;
+		ret = dmaengine_slave_config(dmadata->dma_chan, &slave_config_tx);
+		if (ret)
+			goto unlock;
+		dmadata->substream = substream_tx;
+		dmadata->pos = 0;
+	}
+
+	dmadata = runtime->private_data;
+	spacemit_dma_slave_config(substream, params, &slave_config, dmadata->dma_id);
+
+	ret = dmaengine_slave_config(dmadata->dma_chan, &slave_config);
+	if (ret)
+		goto unlock;
+
+	ret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+	if (ret < 0)
+		goto unlock;
+
+	dmadata->substream = substream;
+	dmadata->pos = 0;
+
+	pr_debug("leave %s!!\n", __FUNCTION__);
+unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int spacemit_snd_pcm_hw_free(struct snd_soc_component *component, struct snd_pcm_substream *substream)
+{
+	pr_debug("enter %s!!\n", __FUNCTION__);
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int spacemit_snd_pcm_hdmi_hw_params(struct snd_soc_component *component, struct snd_pcm_substream *substream,
+				  struct snd_pcm_hw_params *params)
+{
+	//config hdmi and callback
+	int ret;
+	struct dma_slave_config slave_config;
+
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct spacemit_snd_dmadata *dmadata = runtime->private_data;
+
+	pr_debug("enter %s!! allocbytes=%d, dmadata=0x%lx\n",
+		__FUNCTION__, params_buffer_bytes(params), (unsigned long)dmadata);
+
+	memset(&slave_config, 0, sizeof(slave_config));
+	if (dmadata->dma_id != DMA_HDMI) {
+		pr_err("unsupport adma platform\n");
+		return -1;
+	}
+	spacemit_dma_slave_config(substream, params, &slave_config, dmadata->dma_id);
+
+	ret = dmaengine_slave_config(dmadata->dma_chan, &slave_config);
+	if (ret)
+		return ret;
+
+	ret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+	if (ret < 0)
+		return ret;
+
+	hdmiraw_dma_area = (void *)priv.buf_base;
+	hdmiraw_dma_addr = (dma_addr_t)priv.phy_addr;
+
+	if (hdmiraw_dma_area == NULL) {
+		pr_err("hdmi:raw:get mem failed...\n");
+		return -ENOMEM;
+	}
+#ifdef HDMI_REFORMAT_ENABLE
+	hdmiraw_dma_area_tmp = kzalloc((params_buffer_bytes(params) * 2), GFP_KERNEL);
+	if (hdmiraw_dma_area_tmp == NULL) {
+		pr_err("hdmi:raw:get mem tmp failed...\n");
+		return -ENOMEM;
+	}
+#endif
+
+	hdmipcm_dma_addr = substream->dma_buffer.addr;
+	substream->dma_buffer.addr = (dma_addr_t)hdmiraw_dma_addr;
+
+	dmadata->substream = substream;
+	dmadata->pos = 0;
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	pr_debug("leave %s!!\n", __FUNCTION__);
+	return 0;
+}
+
+static int spacemit_snd_pcm_hdmi_hw_free(struct snd_soc_component *component, struct snd_pcm_substream *substream)
+{
+	pr_debug("enter %s!!\n", __FUNCTION__);
+
+	substream->dma_buffer.addr = hdmipcm_dma_addr;
+	hdmiraw_dma_area = NULL;
+#ifdef HDMI_REFORMAT_ENABLE
+	kfree(hdmiraw_dma_area_tmp);
+#endif
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static void spacemit_snd_hdmi_dma_complete(void *arg)
+{
+	struct spacemit_snd_dmadata *dmadata = arg;
+	struct snd_pcm_substream *substream = dmadata->substream;
+	unsigned int pos = dmadata->pos;
+	struct spacemit_snd_soc_device *dev = (struct spacemit_snd_soc_device *)dmadata->private_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	pos += snd_pcm_lib_period_bytes(substream);
+	pos %= snd_pcm_lib_buffer_bytes(substream);
+	dmadata->pos = pos;
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+	if (snd_pcm_running(substream)) {
+		snd_pcm_period_elapsed(substream);
+	}
+	return;
+}
+
+static void spacemit_snd_dma_complete(void *arg)
+{
+	struct spacemit_snd_dmadata *dmadata = arg;
+	struct snd_pcm_substream *substream = dmadata->substream;
+	struct spacemit_snd_soc_device *dev = (struct spacemit_snd_soc_device *)dmadata->private_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	if (dmadata->stream == SNDRV_PCM_STREAM_PLAYBACK
+		&& spacemit_get_stream_is_enable(dev, SNDRV_PCM_STREAM_CAPTURE)
+		&& !spacemit_get_stream_is_enable(dev, SNDRV_PCM_STREAM_PLAYBACK)) {
+			spin_unlock_irqrestore(&dev->lock, flags);
+			return;
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+	if (snd_pcm_running(substream)) {
+		snd_pcm_period_elapsed(substream);
+	}
+	return;
+}
+
+static int spacemit_snd_dma_submit(struct spacemit_snd_dmadata *dmadata)
+{
+	struct dma_async_tx_descriptor *desc;
+	struct snd_pcm_substream *substream = dmadata->substream;
+	struct dma_chan *chan = dmadata->dma_chan;
+	unsigned long flags = DMA_CTRL_ACK;
+
+	pr_debug("enter %s!!\n", __FUNCTION__);
+
+	if (substream->runtime && !substream->runtime->no_period_wakeup)
+		flags |= DMA_PREP_INTERRUPT;
+
+#ifdef HDMI_REFORMAT_ENABLE
+	if (dmadata->dma_id == DMA_HDMI){
+		desc = dmaengine_prep_dma_cyclic(chan,
+			substream->runtime->dma_addr,
+			snd_pcm_lib_buffer_bytes(substream) * 2,
+			snd_pcm_lib_period_bytes(substream) * 2,
+			snd_pcm_substream_to_dma_direction(substream),
+			flags);
+	} else
+#endif
+	{
+		if (dmadata->stream == SNDRV_PCM_STREAM_PLAYBACK){
+			desc = dmaengine_prep_dma_cyclic(chan,
+				substream->dma_buffer.addr,
+				I2S_PERIOD_SIZE * I2S_PERIOD_COUNT * 4,
+				I2S_PERIOD_SIZE * 4,
+				snd_pcm_substream_to_dma_direction(substream),
+				flags);
+		}
+		else {
+			desc = dmaengine_prep_dma_cyclic(chan,
+			substream->runtime->dma_addr,
+			snd_pcm_lib_buffer_bytes(substream),
+			snd_pcm_lib_period_bytes(substream),
+			snd_pcm_substream_to_dma_direction(substream),
+			flags);
+		}
+	}
+
+	if (!desc)
+		return -ENOMEM;
+
+#ifdef HDMI_REFORMAT_ENABLE
+	if (dmadata->dma_id == DMA_HDMI){
+		desc->callback = spacemit_snd_hdmi_dma_complete;
+	} else
+#endif
+	{
+		desc->callback = spacemit_snd_dma_complete;
+	}
+
+	desc->callback_param = dmadata;
+	dmadata->cookie = dmaengine_submit(desc);
+
+	return 0;
+}
+
+static int spacemit_snd_pcm_trigger(struct snd_soc_component *component, struct snd_pcm_substream *substream, int cmd)
+{
+	struct spacemit_snd_dmadata *dmadata = substream->runtime->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct spacemit_snd_soc_device *dev = snd_soc_component_get_drvdata(component);
+
+	int ret = 0;
+	struct spacemit_snd_dmadata *txdma = &dev->dmadata[0];
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	pr_debug("pcm_trigger: cmd=%d,dma_id=%d,dir=%d,p=%d,c=%d\n", cmd, dmadata->dma_id, substream->stream,
+		dev->playback_en, dev->capture_en);
+	if (dmadata->stream == SNDRV_PCM_STREAM_CAPTURE
+		&& !spacemit_get_stream_is_enable(dev, SNDRV_PCM_STREAM_PLAYBACK)) {
+		dmadata = txdma;
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+			memset(dmadata->substream->dma_buffer.area, 0, I2S_PERIOD_SIZE * I2S_PERIOD_COUNT * 4);
+			ret = spacemit_snd_dma_submit(dmadata);
+			if (ret < 0)
+				goto unlock;
+			dma_async_issue_pending(dmadata->dma_chan);
+			dmadata->pos = 0;
+
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			dmaengine_terminate_async(dmadata->dma_chan);
+			dmadata->pos = 0;
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			dmaengine_pause(dmadata->dma_chan);
+			break;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+			if (runtime->info & SNDRV_PCM_INFO_PAUSE)
+				dmaengine_pause(dmadata->dma_chan);
+			else
+				dmaengine_terminate_async(dmadata->dma_chan);
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		case SNDRV_PCM_TRIGGER_RESUME:
+			dmaengine_resume(dmadata->dma_chan);
+			break;
+		default:
+			ret = -EINVAL;
+			goto unlock;
+		}
+		dmadata = substream->runtime->private_data;
+	}
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if (dmadata->stream == SNDRV_PCM_STREAM_PLAYBACK
+			&& spacemit_get_stream_is_enable(dev, SNDRV_PCM_STREAM_CAPTURE)) {
+				dmadata->playback_data = 0;
+				dmadata->pos = 0;
+
+		} else {
+			ret = spacemit_snd_dma_submit(dmadata);
+			if (ret < 0)
+				goto unlock;
+			dma_async_issue_pending(dmadata->dma_chan);
+			dmadata->playback_data = 0;
+			dmadata->pos = 0;
+		}
+		spacemit_update_stream_status(dev, dmadata->stream, true);
+
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		if (dmadata->stream == SNDRV_PCM_STREAM_PLAYBACK
+			&& spacemit_get_stream_is_enable(dev, SNDRV_PCM_STREAM_CAPTURE)) {
+				dmadata->playback_data = 0;
+				dmadata->pos = 0;
+
+		} else {
+			dmaengine_terminate_async(dmadata->dma_chan);
+			dmadata->playback_data = 0;
+			dmadata->pos = 0;
+		}
+		spacemit_update_stream_status(dev, dmadata->stream, false);
+
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dmaengine_pause(dmadata->dma_chan);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		if (runtime->info & SNDRV_PCM_INFO_PAUSE)
+			dmaengine_pause(dmadata->dma_chan);
+		else
+			dmaengine_terminate_async(dmadata->dma_chan);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		dmaengine_resume(dmadata->dma_chan);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ret;
+}
+
+snd_pcm_uframes_t
+spacemit_snd_pcm_pointer(struct snd_soc_component *component, struct snd_pcm_substream *substream)
+{
+	struct spacemit_snd_dmadata *dmadata = substream->runtime->private_data;
+	struct spacemit_snd_soc_device *dev = snd_soc_component_get_drvdata(component);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct dma_tx_state state;
+	enum dma_status status;
+	unsigned int buf_size;
+	unsigned int pos = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	status = dmaengine_tx_status(dmadata->dma_chan, dmadata->cookie, &state);
+	if (status == DMA_IN_PROGRESS || status == DMA_PAUSED) {
+		buf_size = I2S_PERIOD_SIZE * I2S_PERIOD_COUNT * 4;
+		if (state.residue > 0 && state.residue <= buf_size) {
+			pos = (buf_size - state.residue);
+		}
+		runtime->delay = bytes_to_frames(runtime, state.in_flight_bytes);
+	}
+	if (dmadata->stream == SNDRV_PCM_STREAM_PLAYBACK
+		&& spacemit_get_stream_is_enable(dev, SNDRV_PCM_STREAM_CAPTURE)
+		&& spacemit_get_stream_is_enable(dev, SNDRV_PCM_STREAM_PLAYBACK)) {
+		if (dmadata->playback_data == 0 && pos != 0)
+			pos = 0;
+		else
+			dmadata->playback_data = 1;
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return bytes_to_frames(runtime, pos);
+}
+
+static snd_pcm_uframes_t
+spacemit_snd_pcm_hdmi_pointer(struct snd_soc_component *component, struct snd_pcm_substream *substream)
+{
+	struct spacemit_snd_dmadata *dmadata = substream->runtime->private_data;
+	return bytes_to_frames(substream->runtime, dmadata->pos);
+}
+static void hdmi_create_cs(struct hdmi_codec_priv *hdmi_priv)
+{
+    uint8_t *cs;
+    memset(hdmi_priv->cs, 0, sizeof(hdmi_priv->cs));
+    cs = hdmi_priv->cs;
+    cs[0] = IEC958_AES0_CONSUMER | IEC958_AES0_AUDIO | IEC958_AES0_CON_NOT_COPYRIGHT | IEC958_AES0_CON_EMPHASIS_NONE;
+    cs[1] = IEC958_AES1_CON_GENERAL;
+    cs[2] = IEC958_AES2_CON_SOURCE_UNSPEC | IEC958_AES2_CON_CHANNEL_UNSPEC;
+    cs[3] = IEC958_AES3_CON_CLOCK_1000PPM | IEC958_AES3_CON_FS_48000;
+    cs[4] = IEC958_AES4_CON_WORDLEN_24_20 | IEC958_AES4_CON_MAX_WORDLEN_24;		//24bits
+
+}
+static int spacemit_snd_pcm_open(struct snd_soc_component *component, struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	struct spacemit_snd_soc_device *dev;
+	struct spacemit_snd_dmadata *dmadata;
+	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
+	unsigned long flags;
+
+	pr_debug("%s enter, rtd->dev=%s,dir=%d\n", __FUNCTION__, dev_name(rtd->dev),substream->stream);
+
+	if (!component) {
+		pr_err("%s!! coundn't find component %s\n", __FUNCTION__, DRV_NAME);
+		ret = -1;
+		goto unlock;
+	}
+
+	dev = snd_soc_component_get_drvdata(component);
+	if (!dev) {
+		pr_err("%s!! get dev error\n", __FUNCTION__);
+		return -1;
+	}
+	spin_lock_irqsave(&dev->lock, flags);
+
+	dmadata = &dev->dmadata[substream->stream];
+	if (dmadata->dma_id == DMA_HDMI) {
+		ret = snd_soc_set_runtime_hwparams(substream, &spacemit_snd_pcm_hardware_hdmi);
+	} else {
+		ret = snd_soc_set_runtime_hwparams(substream, &spacemit_snd_pcm_hardware);
+	}
+
+	if (ret) {
+		goto unlock;
+	}
+
+	ret = snd_pcm_hw_constraint_integer(substream->runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0) {
+		pr_err("%s!! got serror\n", __FUNCTION__);
+		goto unlock;
+	}
+	substream->runtime->private_data = dmadata;
+
+	if (dmadata->dma_id == DMA_HDMI) {
+		hdmi_ptr.ch_sn = L_CH;
+        hdmi_ptr.iec_offset = 0;
+        hdmi_ptr.srate = 48000;
+        hdmi_create_cs(&hdmi_ptr);
+	}
+unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	pr_debug("%s exit dma_id=%d\n", __FUNCTION__, dmadata->dma_id);
+
+	return ret;
+}
+
+static int spacemit_snd_pcm_close(struct snd_soc_component *component, struct snd_pcm_substream *substream)
+{
+	struct spacemit_snd_dmadata *dmadata = substream->runtime->private_data;
+	struct dma_chan *chan = dmadata->dma_chan;
+	struct spacemit_snd_soc_device *dev = snd_soc_component_get_drvdata(component);
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	pr_debug("%s debug, dir=%d, dma_id=%d\n", __FUNCTION__,substream->stream, dmadata->dma_id);
+	if (dmadata->stream == SNDRV_PCM_STREAM_PLAYBACK
+		&& spacemit_get_stream_is_enable(dev, SNDRV_PCM_STREAM_CAPTURE)) {
+		goto unlock;
+	}
+	dmaengine_terminate_all(chan);
+	if (dmadata->dma_id == DMA_HDMI) {
+		hdmi_ptr.ch_sn = L_CH;
+		hdmi_ptr.iec_offset = 0;
+	}
+unlock:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return 0;
+}
+
+static int spacemit_snd_pcm_lib_ioctl(struct snd_soc_component *component, struct snd_pcm_substream *substream,
+		      unsigned int cmd, void *arg)
+{
+	return snd_pcm_lib_ioctl(substream, cmd, arg);
+}
+
+static const char * const spacemit_pcm_dma_channel_names[] = {
+	[SNDRV_PCM_STREAM_PLAYBACK] = "tx",
+	[SNDRV_PCM_STREAM_CAPTURE] = "rx",
+};
+
+static int spacemit_snd_pcm_new(struct snd_soc_component *component, struct snd_soc_pcm_runtime *rtd)
+{
+	int i;
+	int ret;
+	int chan_num;
+
+	struct spacemit_snd_soc_device *dev;
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm *pcm = rtd->pcm;
+
+	printk("%s enter, dev=%s\n", __FUNCTION__, dev_name(rtd->dev));
+
+	if (!component) {
+		pr_err("%s: coundn't find component %s\n", __FUNCTION__, DRV_NAME);
+		return -1;
+	}
+
+	dev = snd_soc_component_get_drvdata(component);
+	if (!dev) {
+		pr_err("%s: get dev error\n", __FUNCTION__);
+		return -1;
+	}
+	if (dev->dmadata->dma_id == DMA_HDMI) {
+		chan_num = 1;
+		printk("%s playback_only, dev=%s\n", __FUNCTION__, dev_name(rtd->dev));
+	}else{
+		chan_num = 2;
+	}
+	dev->dmadata[0].stream = SNDRV_PCM_STREAM_PLAYBACK;
+	dev->dmadata[1].stream = SNDRV_PCM_STREAM_CAPTURE;
+
+	for (i = 0; i < chan_num; i++) {
+		ret = spacemit_snd_dma_init(component->dev, dev, &dev->dmadata[i]);
+		if (ret)
+			goto exit;
+	}
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+		card->dev, 64 * 1024 * 32, 4 * 1024 * 1024);
+
+	return 0;
+
+exit:
+	for (i = 0; i < chan_num; i++) {
+		if (dev->dmadata[i].dma_chan)
+			dma_release_channel(dev->dmadata[i].dma_chan);
+		dev->dmadata[i].dma_chan = NULL;
+	}
+
+	return ret;
+}
+
+static int spacemit_snd_dma_init(struct device *paraent, struct spacemit_snd_soc_device *dev,
+			     struct spacemit_snd_dmadata *dmadata)
+{
+	dma_cap_mask_t mask;
+	spin_lock_init(&dmadata->dma_lock);
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+	dma_cap_set(DMA_CYCLIC, mask);
+
+	dmadata->dma_chan = dma_request_slave_channel(paraent, spacemit_pcm_dma_channel_names[dmadata->stream]);
+	if (!dmadata->dma_chan) {
+		pr_err("DMA channel for %s is not available\n",
+			dmadata->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+			"playback" : "capture");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int spacemit_snd_pcm_probe(struct snd_soc_component *component)
+{
+	struct spacemit_snd_soc_device *spacemit_snd_device = snd_soc_component_get_drvdata(component);
+
+	spacemit_snd_device->dmadata[0].private_data = spacemit_snd_device;
+	spacemit_snd_device->dmadata[1].private_data = spacemit_snd_device;
+
+	return 0;
+}
+
+static void spacemit_snd_pcm_remove(struct snd_soc_component *component)
+{
+	int i;
+	int chan_num;
+	struct spacemit_snd_soc_device *dev = snd_soc_component_get_drvdata(component);
+
+	pr_info("%s enter\n", __FUNCTION__);
+
+	if (dev->dmadata->dma_id == DMA_HDMI) {
+		chan_num = 1;
+	}else{
+		chan_num = 2;
+	}
+	for (i = 0; i < chan_num; i++) {
+		struct spacemit_snd_dmadata *dmadata = &dev->dmadata[i];
+		struct dma_chan *chan = dmadata->dma_chan;
+
+		if (chan) {
+			dmaengine_terminate_all(chan);
+			dma_release_channel(chan);
+		}
+		dev->dmadata[i].dma_chan = NULL;
+	}
+}
+static void hdmi_set_cs_channel_sn(struct hdmi_codec_priv *hdmi_priv)
+{
+    hdmi_priv->cs[2] &= 0x0f;
+    if (hdmi_priv->ch_sn == L_CH) {
+        hdmi_priv->cs[2] |= (0x1 << 4);
+        hdmi_priv->ch_sn = R_CH;
+    } else if (hdmi_priv->ch_sn == R_CH)  {
+        hdmi_priv->cs[2] |= (0x2 << 4);
+        hdmi_priv->ch_sn = L_CH;
+    }
+}
+
+static uint32_t get_cs_bit(struct hdmi_codec_priv *hdmi_priv)
+{
+    unsigned long tmp = 0;
+    int cs_idx;
+    int bit_idx;
+    cs_idx = hdmi_priv->iec_offset >> 3;
+    bit_idx = hdmi_priv->iec_offset - (cs_idx << 3);
+
+    tmp = hdmi_priv->cs[cs_idx] >> bit_idx;
+
+    return (uint32_t)tmp&0x1;
+}
+
+static uint32_t parity_even(uint32_t sample)
+{
+	bool parity = 0;
+    sample ^= sample >> 16;
+    sample ^= sample >> 8;
+    parity = ParityTable256[sample & 0xff];
+    if (parity)
+        return 1;
+    else
+        return 0;
+}
+
+static void hdmi_reformat(void *dst, void *src, int len)
+{
+    uint32_t *dst32 = (uint32_t *)dst;
+    uint16_t *src16 = (uint16_t *)src;
+    struct hdmi_codec_priv *dw = &hdmi_ptr;
+    uint16_t frm_cnt = len;
+    uint32_t ctrl;
+    uint32_t sample,parity;
+    dw->channels = 2;
+    while (frm_cnt--) {
+        for (int i = 0; i < dw->channels; i++) {
+            hdmi_set_cs_channel_sn(dw);
+            if (dw->iec_offset == 0) {
+                ctrl = CS_CTRL1 | (get_cs_bit(dw) << CHANNEL_STATUS_OFFSET);
+            }  else {
+                ctrl = CS_CTRL2 | (get_cs_bit(dw) << CHANNEL_STATUS_OFFSET);
+            }
+
+            sample = ((uint32_t)(*src16++) << 8)| ctrl;
+            parity = parity_even(sample);
+            sample = sample | (parity << PARITY_BIT_OFFSET);
+            *dst32++ = sample;
+        }
+
+        dw->iec_offset++;
+        if (dw->iec_offset >= 192){
+            dw->iec_offset = 0;
+		}
+    };
+}
+
+static int spacemit_snd_pcm_copy(struct snd_soc_component *component, struct snd_pcm_substream *substream, int channel, 
+unsigned long hwoff, void __user *buf, unsigned long bytes){
+	int ret = 0;
+	char *hwbuf;
+	char *hdmihw_area;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+#ifdef HDMI_REFORMAT_ENABLE
+		hwbuf = runtime->dma_area + hwoff;
+		if (copy_from_user(hwbuf, buf, bytes))
+			return -EFAULT;
+		hdmihw_area = hdmiraw_dma_area_tmp + 2 * hwoff;
+		hdmi_reformat((int *)hdmihw_area, (short *)hwbuf, bytes_to_frames(substream->runtime, bytes));
+		memcpy((void *)(hdmiraw_dma_area + 2 * hwoff), (void *)hdmihw_area, bytes * 2);
+#else
+		hwbuf = hdmiraw_dma_area + hwoff;
+		if (hwbuf == NULL)
+			pr_err("%s addr null !!!!!!!!!!!!\n", __func__);
+		if (copy_from_user(hwbuf, buf, bytes))
+			return -EFAULT;
+#endif
+
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		hwbuf = runtime->dma_area + hwoff;
+		if (copy_to_user(buf, hwbuf, bytes))
+			return -EFAULT;
+	}
+
+	return ret;
+}
+static const struct snd_soc_component_driver spacemit_snd_dma_component = {
+	.name          = DRV_NAME,
+	.probe		   = spacemit_snd_pcm_probe,
+	.remove		   = spacemit_snd_pcm_remove,
+	.open		   = spacemit_snd_pcm_open,
+	.close		   = spacemit_snd_pcm_close,
+	.ioctl		   = spacemit_snd_pcm_lib_ioctl,
+	.hw_params	   = spacemit_snd_pcm_hw_params,
+	.hw_free	   = spacemit_snd_pcm_hw_free,
+	.trigger	   = spacemit_snd_pcm_trigger,
+	.pointer	   = spacemit_snd_pcm_pointer,
+	.pcm_construct = spacemit_snd_pcm_new,
+};
+
+static const struct snd_soc_component_driver spacemit_snd_dma_component_hdmi = {
+	.name          = DRV_NAME,
+	.probe		   = spacemit_snd_pcm_probe,
+	.remove		   = spacemit_snd_pcm_remove,
+	.open		   = spacemit_snd_pcm_open,
+	.close		   = spacemit_snd_pcm_close,
+	.ioctl		   = spacemit_snd_pcm_lib_ioctl,
+	.hw_params	   = spacemit_snd_pcm_hdmi_hw_params,
+	.hw_free	   = spacemit_snd_pcm_hdmi_hw_free,
+	.trigger	   = spacemit_snd_pcm_trigger,
+	.pointer	   = spacemit_snd_pcm_hdmi_pointer,
+	.pcm_construct = spacemit_snd_pcm_new,
+	.copy_user		= spacemit_snd_pcm_copy,
+};
+
+static int spacemit_snd_dma_pdev_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device_node *np = pdev->dev.of_node;
+	struct resource *res;
+	struct spacemit_snd_soc_device *device;
+
+	device = devm_kzalloc(&pdev->dev, sizeof(*device), GFP_KERNEL);
+	if (!device) {
+		pr_err("%s: alloc memoery failed\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	printk("%s enter: dev name %s\n", __func__, dev_name(&pdev->dev));
+
+	if (of_device_is_compatible(np, "spacemit,spacemit-snd-dma-hdmi")){
+		device->dmadata->dma_id = DMA_HDMI;
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		printk("%s, start=0x%lx, end=0x%lx\n", __FUNCTION__, (unsigned long)res->start, (unsigned long)res->end);
+		priv.phy_addr = res->start;
+		priv.buf_base = devm_ioremap_resource(&pdev->dev, res);
+		if (IS_ERR(priv.buf_base)) {
+			pr_err("%s audio buf alloc failed\n", __FUNCTION__);
+			return PTR_ERR(priv.buf_base);
+		}
+		ret = snd_soc_register_component(&pdev->dev, &spacemit_snd_dma_component_hdmi, NULL, 0);
+	} else {
+		if (of_device_is_compatible(np, "spacemit,spacemit-snd-dma0")){
+			device->dmadata->dma_id = DMA_I2S0;
+		} else if (of_device_is_compatible(np, "spacemit,spacemit-snd-dma1")) {
+			device->dmadata->dma_id = DMA_I2S1;
+		}
+		ret = snd_soc_register_component(&pdev->dev, &spacemit_snd_dma_component, NULL, 0);
+	}
+	spin_lock_init(&device->lock);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "failed to register DAI\n");
+		return ret;
+	}
+	dev_set_drvdata(&pdev->dev, device);
+	return 0;
+}
+
+static int spacemit_snd_dma_pdev_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id spacemit_snd_dma_ids[] = {
+	{ .compatible = "spacemit,spacemit-snd-dma0", },
+	{ .compatible = "spacemit,spacemit-snd-dma1", },
+	{ .compatible = "spacemit,spacemit-snd-dma-hdmi", },
+	{},
+};
+#endif
+
+static struct platform_driver spacemit_snd_dma_pdrv = {
+	.driver = {
+		.name = "spacemit-snd-dma",
+		.of_match_table = of_match_ptr(spacemit_snd_dma_ids),
+	},
+	.probe = spacemit_snd_dma_pdev_probe,
+	.remove = spacemit_snd_dma_pdev_remove,
+};
+
+#if IS_MODULE(CONFIG_SND_SOC_SPACEMIT)
+int spacemit_snd_register_dmaclient_pdrv(void)
+{
+	printk("%s enter\n", __FUNCTION__);
+	return platform_driver_register(&spacemit_snd_dma_pdrv);
+}
+EXPORT_SYMBOL(spacemit_snd_register_dmaclient_pdrv);
+
+void spacemit_snd_unregister_dmaclient_pdrv(void)
+{
+	platform_driver_unregister(&spacemit_snd_dma_pdrv);
+}
+EXPORT_SYMBOL(spacemit_snd_unregister_dmaclient_pdrv);
+#else
+static int spacemit_snd_pcm_init(void)
+{
+	return platform_driver_register(&spacemit_snd_dma_pdrv);
+}
+late_initcall_sync(spacemit_snd_pcm_init);
+#endif
+
+MODULE_DESCRIPTION("SPACEMIT ASoC PCM Platform Driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/spacemit/spacemit-snd-sspa.c b/sound/soc/spacemit/spacemit-snd-sspa.c
new file mode 100644
index 000000000000..111111111111
--- /dev/null
+++ b/sound/soc/spacemit/spacemit-snd-sspa.c
@@ -0,0 +1,301 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 SPACEMIT
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/pxa2xx-lib.h>
+#include <sound/dmaengine_pcm.h>
+#include "spacemit-snd-sspa.h"
+
+struct sspa_priv {
+	struct ssp_device *sspa;
+	struct snd_dmaengine_dai_dma_data *dma_params;
+	struct reset_control *rst;
+	int dai_fmt;
+	int dai_id_pre;
+	int running_cnt;
+	void __iomem	*base;
+	void __iomem	*base_clk;
+	void __iomem	*base_hdmi;
+};
+
+struct platform_device *sspa_platdev;
+
+static int mmp_sspa_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	u32 value = 0;
+	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
+
+	value = readl_relaxed(sspa_priv->base_hdmi);
+	value |= BIT(0);
+	writel(value, sspa_priv->base_hdmi);
+
+	pm_runtime_get_sync(&sspa_platdev->dev);
+	return 0;
+}
+
+static void mmp_sspa_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	u32 value = 0;
+	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
+
+	value = readl_relaxed(sspa_priv->base_hdmi);
+	value &= ~BIT(0);
+	writel(value, sspa_priv->base_hdmi);
+
+	pm_runtime_put_sync(&sspa_platdev->dev);
+}
+
+static int mmp_sspa_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+				    int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int mmp_sspa_set_dai_pll(struct snd_soc_dai *cpu_dai, int pll_id,
+				 int source, unsigned int freq_in,
+				 unsigned int freq_out)
+{
+	return 0;
+}
+
+/*
+ * Set up the sspa dai format. The sspa port must be inactive
+ * before calling this function as the physical
+ * interface format is changed.
+ */
+static int mmp_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+				 unsigned int fmt)
+{
+	return 0;
+}
+
+/*
+ * Set the SSPA audio DMA parameters and sample size.
+ * Can be called multiple times.
+ */
+static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *dai)
+{
+	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
+	struct snd_dmaengine_dai_dma_data *dma_params;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		printk("%s, format=0x%x\n", __FUNCTION__, params_format(params));
+		dma_params = sspa_priv->dma_params;
+		dma_params->maxburst = 32;
+		dma_params->addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		snd_soc_dai_set_dma_data(dai, substream, dma_params);
+	}
+	return 0;
+}
+
+static int mmp_sspa_trigger(struct snd_pcm_substream *substream, int cmd,
+			     struct snd_soc_dai *dai)
+{
+	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	pr_debug("%s cmd=%d, cnt=%d\n", __FUNCTION__, cmd, sspa_priv->running_cnt);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		sspa_priv->running_cnt++;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (sspa_priv->running_cnt > 0)
+			sspa_priv->running_cnt--;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static int mmp_sspa_probe(struct snd_soc_dai *dai)
+{
+	struct sspa_priv *sspa_priv = dev_get_drvdata(dai->dev);
+	pr_debug("%s\n", __FUNCTION__);
+
+	snd_soc_dai_set_drvdata(dai, sspa_priv);
+	return 0;
+}
+
+static const struct snd_soc_dai_ops mmp_sspa_dai_ops = {
+	.startup	= mmp_sspa_startup,
+	.shutdown	= mmp_sspa_shutdown,
+	.trigger	= mmp_sspa_trigger,
+	.hw_params	= mmp_sspa_hw_params,
+	.set_sysclk	= mmp_sspa_set_dai_sysclk,
+	.set_pll	= mmp_sspa_set_dai_pll,
+	.set_fmt	= mmp_sspa_set_dai_fmt,
+};
+
+#define SPACEMIT_SND_SSPA_RATES SNDRV_PCM_RATE_48000
+#define SPACEMIT_SND_SSPA_FORMATS SNDRV_PCM_FMTBIT_S16_LE
+
+static struct snd_soc_dai_driver spacemit_snd_sspa_dai[] = {
+	{
+		.name = "SSPA2",
+		.probe = mmp_sspa_probe,
+		.playback = {
+			.stream_name = "SSPA2 TX",
+			.channels_min = 2,
+			.channels_max = 2,
+			.rates = SPACEMIT_SND_SSPA_RATES,
+			.formats = SPACEMIT_SND_SSPA_FORMATS,
+		},
+		.ops = &mmp_sspa_dai_ops,
+	},
+};
+
+static void spacemit_dma_params_init(struct resource *res, struct snd_dmaengine_dai_dma_data *dma_params)
+{
+	dma_params->addr = res->start + 0x80;
+	dma_params->maxburst = 32;
+	dma_params->addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+}
+
+static int spacemit_sspa_suspend(struct snd_soc_component *component)
+{
+	struct sspa_priv *priv = snd_soc_component_get_drvdata(component);
+	reset_control_assert(priv->rst);
+	return 0;
+}
+
+static int spacemit_sspa_resume(struct snd_soc_component *component)
+{
+	struct sspa_priv *priv = snd_soc_component_get_drvdata(component);
+	u32 value = 0;
+	value = readl_relaxed(priv->base_hdmi);
+	value |= BIT(0);
+	writel(value, priv->base_hdmi);
+	reset_control_deassert(priv->rst);
+	return 0;
+}
+static const struct snd_soc_component_driver spacemit_snd_sspa_component = {
+	.name		= "spacemit-snd-sspa",
+	.suspend	= spacemit_sspa_suspend,
+	.resume		= spacemit_sspa_resume,
+};
+
+static int spacemit_snd_sspa_pdev_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct sspa_priv *priv;
+	struct resource *base_res;
+	struct resource *clk_res;
+
+	pr_info("enter %s\n", __FUNCTION__);
+	priv = devm_kzalloc(&pdev->dev,
+				sizeof(struct sspa_priv), GFP_KERNEL);
+	if (!priv) {
+		pr_err("%s priv alloc failed\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+	base_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->base = devm_ioremap_resource(&pdev->dev, base_res);
+	if (IS_ERR(priv->base)) {
+		pr_err("%s reg base alloc failed\n", __FUNCTION__);
+		return PTR_ERR(priv->base);
+	}
+	clk_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	priv->base_clk = devm_ioremap_resource(&pdev->dev, clk_res);
+	if (IS_ERR(priv->base_clk)) {
+		pr_err("%s reg clk base alloc failed\n", __FUNCTION__);
+		return PTR_ERR(priv->base_clk);
+	}
+	priv->base_hdmi = (void __iomem *)ioremap(0xC0400530, 1);
+	if (IS_ERR(priv->base_hdmi)) {
+		pr_err("%s reg hdmi base alloc failed\n", __FUNCTION__);
+		return PTR_ERR(priv->base_hdmi);
+	}
+	priv->dma_params = devm_kzalloc(&pdev->dev, sizeof(struct snd_dmaengine_dai_dma_data),
+			GFP_KERNEL);
+	if (priv->dma_params == NULL) {
+		pr_err("%s dma_params alloc failed\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+	spacemit_dma_params_init(base_res, priv->dma_params);
+
+	//get reset
+	priv->rst = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR(priv->rst))
+		return PTR_ERR(priv->rst);
+
+	reset_control_deassert(priv->rst);
+
+	pm_runtime_enable(&pdev->dev);
+
+	sspa_platdev = pdev;
+
+	platform_set_drvdata(pdev, priv);
+	ret = devm_snd_soc_register_component(&pdev->dev, &spacemit_snd_sspa_component,
+						   spacemit_snd_sspa_dai, ARRAY_SIZE(spacemit_snd_sspa_dai));
+	if (ret != 0) {
+		dev_err(&pdev->dev, "failed to register DAI\n");
+		return ret;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id spacemit_snd_sspa_ids[] = {
+	{ .compatible = "spacemit,spacemit-snd-sspa", },
+	{ /* sentinel */ }
+};
+#endif
+
+static struct platform_driver spacemit_snd_sspa_pdrv = {
+	.driver = {
+		.name = "spacemit-snd-sspa",
+		.of_match_table = of_match_ptr(spacemit_snd_sspa_ids),
+	},
+	.probe = spacemit_snd_sspa_pdev_probe,
+};
+
+#if IS_MODULE(CONFIG_SND_SOC_SPACEMIT)
+int spacemit_snd_register_sspa_pdrv(void)
+{
+	return platform_driver_register(&spacemit_snd_sspa_pdrv);
+}
+EXPORT_SYMBOL(spacemit_snd_register_sspa_pdrv);
+
+void spacemit_snd_unregister_sspa_pdrv(void)
+{
+	platform_driver_unregister(&spacemit_snd_sspa_pdrv);
+}
+EXPORT_SYMBOL(spacemit_snd_unregister_sspa_pdrv);
+#else
+static int spacemit_snd_sspa_init(void)
+{
+	return platform_driver_register(&spacemit_snd_sspa_pdrv);
+}
+late_initcall_sync(spacemit_snd_sspa_init);
+#endif
+
+MODULE_DESCRIPTION("SPACEMIT ASoC SSPA Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/spacemit/spacemit-snd-sspa.h b/sound/soc/spacemit/spacemit-snd-sspa.h
new file mode 100644
index 000000000000..111111111111
--- /dev/null
+++ b/sound/soc/spacemit/spacemit-snd-sspa.h
@@ -0,0 +1,86 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 SPACEMIT
+ */
+
+#ifndef _SPACEMIT_SND_SSPA_H_
+#define _SPACEMIT_SND_SSPA_H_
+
+/*
+ * SSPA Registers
+ */
+#define SSPA_RXD		(0x00)
+#define SSPA_RXID		(0x04)
+#define SSPA_RXCTL		(0x08)
+#define SSPA_RXSP		(0x0c)
+#define SSPA_RXFIFO_UL		(0x10)
+#define SSPA_RXINT_MASK		(0x14)
+#define SSPA_RXC		(0x18)
+#define SSPA_RXFIFO_NOFS	(0x1c)
+#define SSPA_RXFIFO_SIZE	(0x20)
+
+#define SSPA_TXD		(0x80)
+#define SSPA_TXID		(0x84)
+#define SSPA_TXCTL		(0x88)
+#define SSPA_TXSP		(0x8c)
+#define SSPA_TXFIFO_LL		(0x90)
+#define SSPA_TXINT_MASK		(0x94)
+#define SSPA_TXC		(0x98)
+#define SSPA_TXFIFO_NOFS	(0x9c)
+#define SSPA_TXFIFO_SIZE	(0xa0)
+
+/* SSPA Control Register */
+#define	SSPA_CTL_XPH		(1 << 31)	/* Read Phase */
+#define	SSPA_CTL_XFIG		(1 << 15)	/* Transmit Zeros when FIFO Empty */
+#define	SSPA_CTL_JST		(1 << 3)	/* Audio Sample Justification */
+#define	SSPA_CTL_XFRLEN2_MASK	(7 << 24)
+#define	SSPA_CTL_XFRLEN2(x)	((x) << 24)	/* Transmit Frame Length in Phase 2 */
+#define	SSPA_CTL_XWDLEN2_MASK	(7 << 21)
+#define	SSPA_CTL_XWDLEN2(x)	((x) << 21)	/* Transmit Word Length in Phase 2 */
+#define	SSPA_CTL_XDATDLY(x)	((x) << 19)	/* Tansmit Data Delay */
+#define	SSPA_CTL_XSSZ2_MASK	(7 << 16)
+#define	SSPA_CTL_XSSZ2(x)	((x) << 16)	/* Transmit Sample Audio Size */
+#define	SSPA_CTL_XFRLEN1_MASK	(7 << 8)
+#define	SSPA_CTL_XFRLEN1(x)	((x) << 8)	/* Transmit Frame Length in Phase 1 */
+#define	SSPA_CTL_XWDLEN1_MASK	(7 << 5)
+#define	SSPA_CTL_XWDLEN1(x)	((x) << 5)	/* Transmit Word Length in Phase 1 */
+#define	SSPA_CTL_XSSZ1_MASK	(7 << 0)
+#define	SSPA_CTL_XSSZ1(x)	((x) << 0)	/* XSSZ1 */
+
+#define SSPA_CTL_8_BITS		(0x0)		/* Sample Size */
+#define SSPA_CTL_12_BITS	(0x1)
+#define SSPA_CTL_16_BITS	(0x2)
+#define SSPA_CTL_20_BITS	(0x3)
+#define SSPA_CTL_24_BITS	(0x4)
+#define SSPA_CTL_32_BITS	(0x5)
+
+/* SSPA Serial Port Register */
+#define	SSPA_SP_WEN		(1 << 31)	/* Write Configuration Enable */
+#define	SSPA_SP_MSL		(1 << 18)	/* Master Slave Configuration */
+#define	SSPA_SP_CLKP		(1 << 17)	/* CLKP Polarity Clock Edge Select */
+#define	SSPA_SP_FSP		(1 << 16)	/* FSP Polarity Clock Edge Select */
+#define	SSPA_SP_FIX		(1 << 3)	/* SSPA fsync fix */
+#define	SSPA_SP_FFLUSH		(1 << 2)	/* FIFO Flush */
+#define	SSPA_SP_S_RST		(1 << 1)	/* Active High Reset Signal */
+#define	SSPA_SP_S_EN		(1 << 0)	/* Serial Clock Domain Enable */
+#define	SSPA_SP_FWID(x)		((x) << 20)	/* Frame-Sync Width */
+#define	SSPA_TXSP_FPER(x)	((x) << 4)	/* Frame-Sync Active */
+
+/* sspa clock sources */
+#define MMP_SSPA_CLK_PLL	0
+#define MMP_SSPA_CLK_VCXO	1
+#define MMP_SSPA_CLK_AUDIO	3
+
+/* sspa pll id */
+#define MMP_SYSCLK		0
+#define MMP_SSPA_CLK		1
+
+#endif /* _MMP_SSPA_H */
+
+#define CLK1_24P576MHZ                   (0 << 16)
+
+#define PCLK_ENABLE             (1 << 2)
+#define FCLK_ENABLE             (1 << 1)
+#define MODULE_RESET            (0 << 0)
+#define MODULE_ENABLE           (1 << 0)
+
-- 
Armbian

