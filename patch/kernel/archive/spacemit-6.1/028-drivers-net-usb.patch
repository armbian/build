From b248f2ff8f8206b8c07b9fdae50c2bad8922eedd Mon Sep 17 00:00:00 2001
From: Patrick Yavitz <pyavitz@armbian.com>
Date: Sat, 8 Jun 2024 15:31:23 -0400
Subject: [PATCH] add spacemit patch set

source: https://gitee.com/bianbu-linux/linux-6.1

Signed-off-by: Patrick Yavitz <pyavitz@armbian.com>
---
diff --git a/drivers/net/usb/Kconfig b/drivers/net/usb/Kconfig
index 4402eedb3d1a..249bbb01d691 100644
--- a/drivers/net/usb/Kconfig
+++ b/drivers/net/usb/Kconfig
@@ -645,4 +645,5 @@ config USB_RTL8153_ECM
 	  CONFIG_USB_RTL8152 is not set, or the RTL8153 device is not
 	  supported by r8152 driver.
 
+source "drivers/net/usb/asix_usb/Kconfig"
 endif # USB_NET_DRIVERS
diff --git a/drivers/net/usb/Makefile b/drivers/net/usb/Makefile
index 4964f7b326fb..d6b22ee47ba4 100644
--- a/drivers/net/usb/Makefile
+++ b/drivers/net/usb/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_USB_RTL8150)	+= rtl8150.o
 obj-$(CONFIG_USB_RTL8152)	+= r8152.o
 obj-$(CONFIG_USB_HSO)		+= hso.o
 obj-$(CONFIG_USB_LAN78XX)	+= lan78xx.o
+obj-$(CONFIG_USB_NET_ASIX)	+= asix_usb/
 obj-$(CONFIG_USB_NET_AX8817X)	+= asix.o
 asix-y := asix_devices.o asix_common.o ax88172a.o
 obj-$(CONFIG_USB_NET_AX88179_178A)      += ax88179_178a.o
diff --git a/drivers/net/usb/asix_usb/Kconfig b/drivers/net/usb/asix_usb/Kconfig
new file mode 100644
index 000000000000..9ddc3c404c55
--- /dev/null
+++ b/drivers/net/usb/asix_usb/Kconfig
@@ -0,0 +1,6 @@
+config USB_NET_ASIX
+	tristate "ASIX USB 3.0/2.0 to Gigabit Ethernet"
+	depends on USB_USBNET
+	help
+	  This option adds support for ASIX USB3.0/2.0 Gigabit Ethernet Network
+	  Adapter Driver Compilation & Configuration on Linux
diff --git a/drivers/net/usb/asix_usb/Makefile b/drivers/net/usb/asix_usb/Makefile
new file mode 100644
index 000000000000..bc07ac9c5936
--- /dev/null
+++ b/drivers/net/usb/asix_usb/Makefile
@@ -0,0 +1,103 @@
+TARGET	= ax_usb_nic
+KDIR	:= /lib/modules/$(shell uname -r)/build
+PWD	= $(shell pwd)
+
+ENABLE_IOCTL_DEBUG = n
+ENABLE_AUTODETACH_FUNC = n
+ENABLE_MAC_PASS = n
+ENABLE_INT_AGGRESSIVE = y
+ENABLE_INT_POLLING = n
+ENABLE_AUTOSUSPEND = n
+ENABLE_TX_TASKLET = n
+ENABLE_RX_TASKLET = n
+ENABLE_PTP_FUNC = n
+ENABLE_PTP_DEBUG = n
+ENABLE_QUEUE_PRIORITY = n
+
+obj-m := $(TARGET).o
+$(TARGET)-objs := ax_main.o ax88179_178a.o ax88179a_772d.o
+EXTRA_CFLAGS = -fno-pie
+TOOL_EXTRA_CFLAGS = -Werror
+
+ifeq ($(ENABLE_IOCTL_DEBUG), y)
+	EXTRA_CFLAGS += -DENABLE_IOCTL_DEBUG
+	TOOL_EXTRA_CFLAGS += -DENABLE_IOCTL_DEBUG
+endif
+
+ifeq ($(ENABLE_AUTODETACH_FUNC), y)
+	EXTRA_CFLAGS += -DENABLE_AUTODETACH_FUNC
+endif
+
+ifeq ($(ENABLE_MAC_PASS), y)
+	EXTRA_CFLAGS += -DENABLE_MAC_PASS
+endif
+
+ifeq ($(ENABLE_INT_AGGRESSIVE), y)
+	EXTRA_CFLAGS += -DENABLE_INT_AGGRESSIVE
+endif
+
+ifeq ($(ENABLE_INT_POLLING), y)
+	EXTRA_CFLAGS += -DENABLE_INT_POLLING
+endif
+
+ifeq ($(ENABLE_AUTOSUSPEND), y)
+	EXTRA_CFLAGS += -DENABLE_AUTOSUSPEND
+endif
+
+ifeq ($(ENABLE_TX_TASKLET), y)
+	EXTRA_CFLAGS += -DENABLE_TX_TASKLET
+endif
+ifeq ($(ENABLE_RX_TASKLET), y)
+	EXTRA_CFLAGS += -DENABLE_RX_TASKLET
+endif
+
+ifeq ($(ENABLE_PTP_FUNC), y)
+	$(TARGET)-objs += ax_ptp.o
+	EXTRA_CFLAGS += -DENABLE_PTP_FUNC
+ifeq ($(ENABLE_PTP_DEBUG), y)
+	EXTRA_CFLAGS += -DENABLE_PTP_DEBUG
+endif
+endif
+
+ifeq ($(ENABLE_QUEUE_PRIORITY), y)
+	EXTRA_CFLAGS += -DENABLE_QUEUE_PRIORITY
+endif
+
+	EXTRA_CFLAGS += -DENABLE_AX88279
+ifeq ($(ENABLE_MACSEC_FUNC), y)
+	$(TARGET)-objs += ax_macsec.o
+	EXTRA_CFLAGS += -DENABLE_MACSEC_FUNC
+endif
+	EXTRA_CFLAGS += -DENABLE_AX88279_MINIP_2_5G
+
+
+ifneq (,$(filter $(SUBLEVEL),14 15 16 17 18 19 20 21))
+MDIR	= kernel/drivers/usb/net
+else
+MDIR	= kernel/drivers/net/usb
+endif
+
+all:
+	make -C $(KDIR) M=$(PWD) modules
+	$(CC) $(TOOL_EXTRA_CFLAGS) ax88179_programmer.c -o ax88179_programmer
+	$(CC) $(TOOL_EXTRA_CFLAGS) ax88179a_programmer.c -o ax88179b_179a_772d_programmer
+	$(CC) $(TOOL_EXTRA_CFLAGS) ax88279_programmer.c -o ax88279_programmer
+	$(CC) $(TOOL_EXTRA_CFLAGS) ax88179a_ieee.c -o ax88179b_179a_772d_ieee
+	$(CC) $(TOOL_EXTRA_CFLAGS) axcmd.c -o axcmd
+
+install:
+ifneq (,$(wildcard /lib/modules/$(shell uname -r)/$(MDIR)/ax88179_178a.ko))
+	gzip /lib/modules/$(shell uname -r)/$(MDIR)/ax88179_178a.ko
+endif
+	make -C $(KDIR) M=$(PWD) INSTALL_MOD_DIR=$(MDIR) modules_install
+	depmod -a
+
+uninstall:
+ifneq (,$(wildcard /lib/modules/$(shell uname -r)/$(MDIR)/$(TARGET).ko))
+	rm -f /lib/modules/$(shell uname -r)/$(MDIR)/$(TARGET).ko
+endif
+	depmod -a
+
+clean:
+	make -C $(KDIR) M=$(PWD) clean
+	rm -rf *_programmer *_ieee axcmd .tmp_versions
diff --git a/drivers/net/usb/asix_usb/Readme b/drivers/net/usb/asix_usb/Readme
new file mode 100755
index 000000000000..d3bda757b0da
--- /dev/null
+++ b/drivers/net/usb/asix_usb/Readme
@@ -0,0 +1,255 @@
+===============================================================================
+ASIX USB3.0/2.0 Gigabit Ethernet Network Adapter
+Driver Compilation & Configuration on Linux
+===============================================================================
+
+================
+Prerequisites
+================
+
+Prepare to build the driver, you need the Linux kernel sources installed on the
+build machine, and make sure that the version of the running kernel must match
+the installed kernel sources. If you don't have the kernel sources, you can get
+it from www.kernel.org or contact to your Linux distributor. If you don't know 
+how to do, please refer to KERNEL-HOWTO.
+
+Note: Please make sure the kernel is built with one of the "Support for 
+      Host-side, XHCI, EHCI, OHCI, or UHCI" option support.
+
+================
+Getting Start
+================
+
+1. Extract the compressed driver source file to your temporary directory by the
+following command:
+	$tar -xf DRIVER_SOURCE_PACKAGE.tar.bz2
+
+
+2. Now, the driver source files should be extracted under the current directory.
+Issue the following command to compile the driver:
+	$make
+
+
+3. If the compilation is done, the ax_usb_nic.ko will be created under the
+current directory.
+
+================
+Usage
+================
+
+=== Install driver to your system
+1. If you want to use modprobe command to mount the driver, issue the
+following command to install the driver into your system:
+	$sudo make install
+Note: This command will backup the built-in ax88179_178a driver if it exists.
+
+2. If you want to load the driver by modprobe command, issue the following 
+commands:
+	$sudo modprobe ax_usb_nic
+
+3. If you want to unload the driver by modprobe command, issue the following 
+commands:
+	$sudo modprobe -r ax_usb_nic
+
+4. If you want to check the information of driver, issue the following commands:
+	$modinfo ax_usb_nic 
+
+=== Install driver manually
+1. If you want to load the driver manually, go to the driver directory and
+execute the following commands:
+	$sudo modprobe mii
+	$sudo insmod ax_usb_nic.ko
+
+2. If you want to unload the driver, just executing the following command:
+	$sudo rmmod ax_usb_nic
+
+3. If you want to check the information of driver, issue the following commands:
+	$modinfo ax_usb_nic.ko
+
+
+================
+Programmer & IEEE TEST
+================
+ASIX USB Ethernet Linux Command Line Programming Tool
+
+[Note]: Enable DEBUG message
+* Modify ENABLE_IOCTL_DEBUG to y in Makefile.
+	ENABLE_IOCTL_DEBUG = n
+	->
+	ENABLE_IOCTL_DEBUG = y
+
+1. Extract the compressed driver source file to your temporary directory by the
+following command:
+	$tar -xf DRIVER_SOURCE_PACKAGE.tar.bz2
+
+2. Now, the driver source files should be extracted under the current directory.
+Executing the following command to compile the driver:
+	$make
+
+3. Load the driver manually, go to the driver directory and execute the 
+following commands:
+	$sudo modprobe mii
+	$sudo insmod ax_usb_nic.ko
+
+4. If the compilation is well, the ioctl will be created under the current 
+directory.
+
+Note: The default way to find the interface is to scan the ASIX device using
+ the ethx (x: 0~255).It is defined in the file, command.h.
+	(As follows)
+	...
+	// DEFAULT_SCAN   : scan "eth0" - "eth255"
+	// INTERFACE_SCAN : scan all available network interfaces
+	#define NET_INTERFACE	DEFAULT_SCAN
+	#define	DEFAULT_SCAN	0x00
+	#define	INTERFACE_SCAN	0x01
+	...
+Adjust the contents of #define NET_INTERFACE to select the method you want.
+
+================
+Enable PTP(Precision Time Protocol)
+================
+1. If you want to enable the PTP function, please modify ENABLE_PTP_FUNC to 'y' in the makefile, 
+	and then recompile it.
+	
+	ENABLE_PTP_FUNC = n
+	->
+	ENABLE_PTP_FUNC = y
+
+=== AX88179/178A EEPROM/eFuse Programmer
+1. If you want to read out values of the EEPROM/EFUSE to a file, go to the 
+driver directory and execute the following command:
+	$sudo ./ax88179_programmer reeprom 0 eeprom 512
+	$sudo ./ax88179_programmer reeprom 1 efuse 64
+
+2. If you want to write values of a file to the EEPROM/EFUSE,  go to the driver
+directory and execute the following command:
+	$sudo ./ax88179_programmer weeprom 0 eeprom 512
+	$sudo ./ax88179_programmer weeprom 1 efuse 64
+
+3. If you want to change the MAC address of a dongle, go to the driver directory
+ and execute the following command:
+	$sudo ./ax88179_programmer chgmac 0 mac_addr 512
+	$sudo ./ax88179_programmer chgmac 1 mac_addr 64
+
+4. If you need more information about the instructions, go to the driver 
+directory and execute the following commands:
+	$sudo ./ax88179_programmer reeprom help
+	$sudo ./ax88179_programmer weeprom help
+	$sudo ./ax88179_programmer chgmac help
+
+=== AX88179B/179A/772E/772D Flash/eFuse Programmer
+1. If you want to get help message for specific command, go to the driver 
+directory and execute the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer help [command]
+
+2. If you want to get the version of firmware, go to the driver directory 
+and execute the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer rversion
+
+3. If you want to get the MAC address, go to the driver directory and execute 
+the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer rmacaddr
+
+4. If you want to write values of a file to the flash, go to the driver 
+directory and execute the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer wflash [file]
+
+5. If you want to write the eFuse, go to the driver directory and execute 
+the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer wefuse -m [MAC] -s [SN] -f [File]
+	--led0 [value] --led1 [value] -p [device]
+		-m [MAC]    - MAC address (XX:XX:XX:XX:XX:XX)
+		-s [SN]     - Serial number
+		-f [File]   - eFuse file path
+		--led0 [value]   - value: control_blink (XXXX_XXXX)
+		--led1 [value]   - value: control_blink (XXXX_XXXX)
+		-p [device] - device: "AX88179B" or "AX88179A" or "AX88772E" or "AX88772D" 
+	example: 
+		$sudo ./ax88179b_179a_772e_772d_programmer wefuse -m 00:0E:C6:81:79:01 
+		-s 00000000000001 -f eFuse_Dump.txt
+
+		$sudo ./ax88179b_179a_772e_772d_programmer wefuse -m 00:0E:C6:81:79:01 
+		-s 0000000000179A --led0 8007_0000 --led1 8000_003F -p AX88179A
+
+		$sudo ./ax88179b_179a_772e_772d_programmer wefuse -m 00:0E:C6:87:72:D1
+		-s 0000000000772D -p AX88772D
+
+6. If you want to read the eFuse, go to the driver directory and execute 
+the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer refuse -f [File]
+
+7. If you want to reload the flash or eFuse to check version or MAC address 
+and so, go to the driver directory and execute the following command:
+	$sudo ./ax88179b_179a_772e_772d_programmer reload
+
+=== AX88179B/179A/772E/772D IEEE Test Tool
+1. If you want to execute IEEE test, go to the driver directory and execute the following command:
+
+	$sudo ./ax88179b_179a_772e_772d_ieee ieeetest speed option
+	    -- AX88179B_179A_772E_772D IEEE Test Tool
+		[speed]    - 1000: 1000Mbps,  100: 100Mbps,  10: 10Mbps
+		[option]   - For 1000Mbps
+				M1: Mode 1
+				M2: Mode 2
+				M3: Mode 3
+				M4: Mode 4
+
+			   - For 100Mbps
+				CA: Channel A
+				CB: Channel B
+
+			   - For 10Mbps
+				RP: Random Pattern
+				FF: Fixed Pattern(FF)
+				MDI: MDI
+
+=== AX88279 Linux Flash Programming Tool
+1. If you want to get help message for specific command, go to the driver 
+directory and execute the following command:
+	$sudo ./ax88279_programmer help [command]
+
+2. If you want to get the version of firmware, go to the driver directory 
+and execute the following command:
+	$sudo ./ax88279_programmer rversion
+
+3. If you want to get the MAC address, go to the driver directory and execute 
+the following command:
+	$sudo ./ax88279_programmer rmacaddr
+
+4. If you want to write values of a file to the flash, go to the driver 
+directory and execute the following command:
+	$sudo ./ax88279_programmer wflash [file]
+
+5. If you want to write the parameter in flash, go to the driver directory and execute 
+the following command:
+	$sudo ./ax88279_programmer wpara -m [MAC] -s [SN] -p [PID] -v [VID] -P [PS] -M [MN] -D [dump]
+	-S [SS] -H [HS] -w [wol] -l [led0 value] -e [led1 value] -d [led2 value]
+       -m [MAC]   	 - MAC address (XX:XX:XX:XX:XX:XX) X:'0'-'F'
+       -s [SN]    	 - Serial Number (Characters must be less than 19 bytes) X:'0'-'F'
+       -p [PID]   	 - Product ID (XX:XX) X:'0'-'F'
+       -v [VID]   	 - Vendor ID (XX:XX) X:'0'-'F'
+       -P [PS]    	 - Product String (Characters must be less than 19 bytes)
+       -M [MN]    	 - Manufacture Name (Characters must be less than 19 bytes)
+       -D [dump]	 - The parameter content currently in flash (dump)
+       -S [SS]    	 - SS bus power (XX) X:0-896
+       -H [HS]    	 - HS bus power (XX) X:0-500
+       -w [wol]    	 - wake on LAN (XXXXXXXX) X:digit
+       -l [led0 value]	 - value: control_blink (XXXX_XXXX)
+       -e [led1 value]	 - value: control_blink (XXXX_XXXX)
+	example: 
+		$sudo ./ax88279_programmer wpara -m 00:0e:c6:81:79:01 -s 00000000000001
+
+		$sudo ./ax88279_programmer wpara -p 17:90 -v 0b:95 -P ax88279 -M asix
+
+		$sudo ./ax88279_programmer wpara -S 400 -H 200 -w 21426543
+
+		$sudo ./ax88279_programmer wpara -l C113_0004 -e C002_0C4F
+
+6. If you want to view the current parameter content in flash, go to the driver directory and execute 
+the following command, and you can see the file parameter.txt in driver directory:
+	$sudo ./ax88279_programmer wpara -D dump
+
+7. If you want to reload the flash to check version or MAC address 
+and so, go to the driver directory and execute the following command:
+	$sudo ./ax88279_programmer reload
\ No newline at end of file
diff --git a/drivers/net/usb/asix_usb/ax88179_178a.c b/drivers/net/usb/asix_usb/ax88179_178a.c
new file mode 100644
index 000000000000..fb5485184756
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179_178a.c
@@ -0,0 +1,1238 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include "ax_main.h"
+#include "ax88179_178a.h"
+
+struct _ax_buikin_setting AX88179_BULKIN_SIZE[] = {
+	{7, 0x70, 0,	0x0C, 0x0f},
+	{7, 0x70, 0,	0x0C, 0x0f},
+	{7, 0x20, 3,	0x16, 0xff},
+	{7, 0xae, 7,	0x18, 0xff},
+};
+const struct ethtool_ops ax88179_ethtool_ops = {
+	.get_drvinfo	= ax_get_drvinfo,
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+	.get_settings	= ax_get_settings,
+	.set_settings	= ax_set_settings,
+#else
+	.get_link_ksettings = ax_get_link_ksettings,
+	.set_link_ksettings = ax_set_link_ksettings,
+#endif
+	.get_link	= ethtool_op_get_link,
+	.get_msglevel	= ax_get_msglevel,
+	.set_msglevel	= ax_set_msglevel,
+	.get_wol	= ax_get_wol,
+	.set_wol	= ax_set_wol,
+	.get_ts_info	= ethtool_op_get_ts_info,
+	.get_strings	= ax_get_strings,
+	.get_sset_count = ax_get_sset_count,
+	.get_ethtool_stats = ax_get_ethtool_stats,
+	.get_regs_len	= ax_get_regs_len,
+	.get_regs	= ax_get_regs,
+};
+
+int ax88179_signature(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	strncpy(info->sig, AX88179_SIGNATURE, strlen(AX88179_SIGNATURE));
+	return 0;
+}
+
+int ax88179_read_eeprom(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	u8 i;
+	u16 tmp;
+	u8 value;
+	unsigned short *buf;
+
+	if (info->buf != NULL) {
+		buf = kmalloc_array(info->size, sizeof(unsigned short),
+				    GFP_KERNEL);
+		if (!buf) {
+#if KERNEL_VERSION(2, 6, 34) <= LINUX_VERSION_CODE
+			netdev_err(axdev->netdev,
+				   "Cannot allocate memory for buffer");
+#endif
+			return -ENOMEM;
+		}
+	} else {
+		netdev_info(axdev->netdev,
+			    "The EEPROM buffer cannot be NULL. \r\n");
+		return -EINVAL;
+	}
+
+	if (info->type == 0) {
+		for (i = 0; i < info->size; i++) {
+
+			if (ax_write_cmd(axdev, AX_ACCESS_MAC,
+					      AX_SROM_ADDR, 1, 1, &i) < 0) {
+				kfree(buf);
+				return -EINVAL;
+			}
+
+			value = EEP_RD;
+			if (ax_write_cmd(axdev, AX_ACCESS_MAC,
+					      AX_SROM_CMD, 1, 1, &value) < 0) {
+				kfree(buf);
+				return -EINVAL;
+			}
+
+			do {
+				ax_read_cmd(axdev, AX_ACCESS_MAC,
+						 AX_SROM_CMD, 1, 1, &value, 0);
+			} while (value & EEP_BUSY);
+
+			if (ax_read_cmd(axdev, AX_ACCESS_MAC,
+					     AX_SROM_DATA_LOW, 2, 2,
+					     &tmp, 1) < 0) {
+				kfree(buf);
+				return -EINVAL;
+			}
+
+			*(buf + i) = be16_to_cpu(tmp);
+
+			if (i == (info->size - 1))
+				break;
+		}
+	} else {
+		for (i = 0; i < info->size; i++) {
+			if (ax_read_cmd(axdev, AX_ACCESS_EFUSE, i,
+					     1, 2, &tmp, 1) < 0) {
+				kfree(buf);
+				return -EINVAL;
+			}
+			*(buf + i) = be16_to_cpu(tmp);
+			if (i == (info->size - 1))
+				break;
+		}
+	}
+
+	if (copy_to_user(info->buf, buf, sizeof(unsigned short) * info->size)) {
+		kfree(buf);
+		return -EFAULT;
+	}
+
+	kfree(buf);
+
+	return 0;
+}
+
+int ax88179_write_eeprom(struct ax_device *axdev,
+			 struct _ax_ioctl_command *info)
+{
+	int i;
+	u16 data, csum = 0;
+	unsigned short *buf;
+
+	if (info->buf != NULL) {
+		buf = kmalloc_array(info->size, sizeof(unsigned short),
+				    GFP_KERNEL);
+		if (!buf) {
+#if KERNEL_VERSION(2, 6, 34) <= LINUX_VERSION_CODE
+			netdev_err(axdev->netdev,
+				   "Cannot allocate memory for buffer");
+#endif
+			return -ENOMEM;
+		}
+		if (copy_from_user(buf, info->buf,
+				   sizeof(unsigned short) * info->size)) {
+			kfree(buf);
+			return -EFAULT;
+		}
+	} else {
+		netdev_err(axdev->netdev,
+			   "The EEPROM buffer cannot be NULL. \r\n");
+		return -EINVAL;
+	}
+
+	if (info->type == 0) {
+		if ((*(buf) >> 8) & 0x01) {
+			netdev_info(axdev->netdev,
+				"Cannot be set to muliticast MAC address, ");
+			netdev_info(axdev->netdev,
+				"bit0 of Node ID-0 cannot be set to 1. \r\n");
+			kfree(buf);
+			return -EINVAL;
+		}
+
+		csum = (*(buf + 3) & 0xff) + ((*(buf + 3) >> 8) & 0xff) +
+		       (*(buf + 4) & 0xff) + ((*(buf + 4) >> 8) & 0xff);
+		csum = 0xff - ((csum >> 8) + (csum & 0xff));
+		data = ((*(buf + 5)) & 0xff) | (csum << 8);
+		*(buf + 5) = data;
+
+		for (i = 0; i < info->size; i++) {
+			data = cpu_to_be16(*(buf + i));
+			if (ax_write_cmd(axdev, AX_ACCESS_EEPROM,
+					      i, 1, 2, &data) < 0) {
+				kfree(buf);
+				return -EINVAL;
+			}
+
+			mdelay(info->delay);
+		}
+	} else if (info->type == 1) {
+		if ((*(buf) >> 8) & 0x01) {
+			netdev_info(axdev->netdev,
+				"Cannot be set to muliticast MAC address, ");
+			netdev_info(axdev->netdev,
+				"bit0 of Node ID-0 cannot be set to 1. \r\n");
+			kfree(buf);
+			return -EINVAL;
+		}
+
+		for (i = 0; i < info->size; i++)
+			csum += (*(buf + i)&0xff) + ((*(buf + i) >> 8)&0xff);
+
+		csum -= ((*(buf + 0x19) >> 8) & 0xff);
+		while (csum > 255)
+			csum = (csum & 0x00FF) + ((csum >> 8) & 0x00FF);
+		csum = 0xFF - csum;
+
+		data = ((*(buf + 0x19)) & 0xff) | (csum << 8);
+		*(buf + 0x19) = data;
+
+		if (ax_write_cmd(axdev, AX_WRITE_EFUSE_EN,
+				      0, 0, 0, NULL) < 0) {
+			kfree(buf);
+			return -EINVAL;
+		}
+
+		mdelay(info->delay);
+
+		for (i = 0; i < info->size; i++) {
+			data = cpu_to_be16(*(buf + i));
+			if (ax_write_cmd(axdev, AX_ACCESS_EFUSE,
+					      i, 1, 2, &data) < 0) {
+				kfree(buf);
+				return -EINVAL;
+			}
+
+			mdelay(info->delay);
+		}
+
+		if (ax_write_cmd(axdev, AX_WRITE_EFUSE_DIS,
+				 0, 0, 0, NULL) < 0) {
+			kfree(buf);
+			return -EINVAL;
+		}
+
+		mdelay(info->delay);
+	} else if (info->type == 2) {
+		if (ax_read_cmd(axdev, AX_ACCESS_EFUSE,
+				0, 1, 2, &data, 1) < 0) {
+			kfree(buf);
+			return -EINVAL;
+		}
+
+		if (data == 0xFFFF)
+			info->type = 0;
+		else
+			info->type = 1;
+	} else {
+		kfree(buf);
+		return -EINVAL;
+	}
+
+	kfree(buf);
+	return 0;
+}
+
+IOCTRL_TABLE ax88179_tbl[] = {
+	ax88179_signature,
+	NULL,//ax_usb_command,
+	ax88179_read_eeprom,
+	ax88179_write_eeprom,
+};
+
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+int ax88179_siocdevprivate(struct net_device *netdev, struct ifreq *rq,
+			   void __user *udata, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	struct _ax_ioctl_command info;
+	struct _ax_ioctl_command *uptr =
+				(struct _ax_ioctl_command *) rq->ifr_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case AX_PRIVATE:
+		if (copy_from_user(&info, uptr,
+				   sizeof(struct _ax_ioctl_command)))
+			return -EFAULT;
+
+		if ((*ax88179_tbl[info.ioctl_cmd])(axdev, &info) < 0) {
+			netdev_info(netdev, "ax88179_tbl, return -EFAULT");
+			return -EFAULT;
+		}
+
+		if (copy_to_user(uptr, &info, sizeof(struct _ax_ioctl_command)))
+			return -EFAULT;
+
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+int ax88179_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	return generic_mii_ioctl(&axdev->mii, if_mii(rq), cmd, NULL);
+}
+#else
+int ax88179_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	struct _ax_ioctl_command info;
+	struct _ax_ioctl_command *uptr =
+				(struct _ax_ioctl_command *) rq->ifr_data;
+
+	switch (cmd) {
+	case AX_PRIVATE:
+		if (copy_from_user(&info, uptr,
+				   sizeof(struct _ax_ioctl_command)))
+			return -EFAULT;
+
+		if ((*ax88179_tbl[info.ioctl_cmd])(axdev, &info) < 0) {
+			netdev_info(netdev, "ax88179_tbl, return -EFAULT");
+			return -EFAULT;
+		}
+
+		if (copy_to_user(uptr, &info, sizeof(struct _ax_ioctl_command)))
+			return -EFAULT;
+
+		break;
+	default:
+		return  generic_mii_ioctl(&axdev->mii, if_mii(rq), cmd, NULL);
+	}
+	return 0;
+}
+#endif
+
+void ax88179_set_multicast(struct net_device *net)
+{
+	struct ax_device *axdev = netdev_priv(net);
+	u8 *m_filter = axdev->m_filter;
+	int mc_count = 0;
+
+	if (!test_bit(AX_ENABLE, &axdev->flags))
+		return;
+
+#if KERNEL_VERSION(2, 6, 35) > LINUX_VERSION_CODE
+	mc_count = net->mc_count;
+#else
+	mc_count = netdev_mc_count(net);
+#endif
+
+	axdev->rxctl = (AX_RX_CTL_START | AX_RX_CTL_AB);
+
+	if (net->flags & IFF_PROMISC) {
+		axdev->rxctl |= AX_RX_CTL_PRO;
+	} else if (net->flags & IFF_ALLMULTI
+		   || mc_count > AX_MAX_MCAST) {
+		axdev->rxctl |= AX_RX_CTL_AMALL;
+	} else if (mc_count == 0) {
+	} else {
+		u32 crc_bits;
+#if KERNEL_VERSION(2, 6, 35) > LINUX_VERSION_CODE
+		struct dev_mc_list *mc_list = net->mc_list;
+		int i = 0;
+
+		memset(m_filter, 0, AX_MCAST_FILTER_SIZE);
+
+		for (i = 0; i < net->mc_count; i++) {
+			crc_bits = ether_crc(ETH_ALEN,
+					     mc_list->dmi_addr) >> 26;
+			*(m_filter + (crc_bits >> 3)) |=
+				1 << (crc_bits & 7);
+			mc_list = mc_list->next;
+		}
+#else
+		struct netdev_hw_addr *ha = NULL;
+
+		memset(m_filter, 0, AX_MCAST_FILTER_SIZE);
+		netdev_for_each_mc_addr(ha, net) {
+			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			*(m_filter + (crc_bits >> 3)) |=
+				1 << (crc_bits & 7);
+		}
+#endif
+		ax_write_cmd_async(axdev, AX_ACCESS_MAC,
+					AX_MULTI_FILTER_ARRY,
+					AX_MCAST_FILTER_SIZE,
+					AX_MCAST_FILTER_SIZE, m_filter);
+
+		axdev->rxctl |= AX_RX_CTL_AM;
+	}
+
+	ax_write_cmd_async(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				2, 2, &axdev->rxctl);
+}
+
+int ax88179_set_mac_addr(struct net_device *netdev, void *p)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	struct sockaddr *addr = p;
+	int ret;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+
+	if (netif_running(netdev))
+		return -EBUSY;
+#if KERNEL_VERSION(5, 16, 0) <= LINUX_VERSION_CODE
+	eth_hw_addr_set(netdev, addr->sa_data);
+#else
+	memcpy(netdev->dev_addr, addr->sa_data, ETH_ALEN);	
+#endif
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,
+			   ETH_ALEN, addr->sa_data);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+
+}
+
+static int ax88179_check_eeprom(struct ax_device *axdev)
+{
+	u8 i = 0;
+	u8 buf[2];
+	u8 eeprom[20];
+	u16 csum = 0, delay = HZ / 10;
+
+	for (i = 0 ; i < 6; i++) {
+		buf[0] = i;
+		if (ax_write_cmd(axdev, AX_ACCESS_MAC, AX_SROM_ADDR,
+				      1, 1, buf) < 0)
+			return -EINVAL;
+
+		buf[0] = EEP_RD;
+		if (ax_write_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+				      1, 1, buf) < 0)
+			return -EINVAL;
+
+		do {
+			ax_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+					 1, 1, buf, 0);
+
+			if (time_after(jiffies, (jiffies + delay)))
+				return -EINVAL;
+		} while (buf[0] & EEP_BUSY);
+
+		ax_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,
+				 2, 2, &eeprom[i * 2], 0);
+
+		if ((i == 0) && (eeprom[0] == 0xFF))
+			return -EINVAL;
+	}
+
+	csum = eeprom[6] + eeprom[7] + eeprom[8] + eeprom[9];
+	csum = (csum >> 8) + (csum & 0xff);
+
+	if ((csum + eeprom[10]) == 0xff)
+		return 0;
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int ax88179_check_efuse(struct ax_device *axdev, void *ledmode)
+{
+	u8	i = 0;
+	u16	csum = 0;
+	u8	efuse[64];
+
+	if (ax_read_cmd(axdev, AX_ACCESS_EFUSE, 0, 64, 64, efuse, 0) < 0)
+		return -EINVAL;
+
+	if (efuse[0] == 0xFF)
+		return -EINVAL;
+
+	for (i = 0; i < 64; i++)
+		csum = csum + efuse[i];
+
+	while (csum > 255)
+		csum = (csum & 0x00FF) + ((csum >> 8) & 0x00FF);
+
+	if (csum == 0xFF) {
+		memcpy((u8 *)ledmode, &efuse[51], 2);
+		return 0;
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int ax88179_convert_old_led(struct ax_device *axdev, u8 efuse, void *ledvalue)
+{
+	u8 ledmode = 0;
+	u16 reg16;
+	u16 led = 0;
+
+	/* loaded the old eFuse LED Mode */
+	if (efuse) {
+		if (ax_read_cmd(axdev, AX_ACCESS_EFUSE, 0x18,
+				     1, 2, &reg16, 1) < 0)
+			return -EINVAL;
+		ledmode = (u8)(reg16 & 0xFF);
+	} else { /* loaded the old EEprom LED Mode */
+		if (ax_read_cmd(axdev, AX_ACCESS_EEPROM, 0x3C,
+				     1, 2, &reg16, 1) < 0)
+			return -EINVAL;
+		ledmode = (u8) (reg16 >> 8);
+	}
+	netdev_dbg(axdev->netdev, "Old LED Mode = %02X\n", ledmode);
+
+	switch (ledmode) {
+	case 0xFF:
+		led = LED0_ACTIVE | LED1_LINK_10 | LED1_LINK_100 |
+		      LED1_LINK_1000 | LED2_ACTIVE | LED2_LINK_10 |
+		      LED2_LINK_100 | LED2_LINK_1000 | LED_VALID;
+		break;
+	case 0xFE:
+		led = LED0_ACTIVE | LED1_LINK_1000 | LED2_LINK_100 | LED_VALID;
+		break;
+	case 0xFD:
+		led = LED0_ACTIVE | LED1_LINK_1000 | LED2_LINK_100 |
+		      LED2_LINK_10 | LED_VALID;
+		break;
+	case 0xFC:
+		led = LED0_ACTIVE | LED1_ACTIVE | LED1_LINK_1000 | LED2_ACTIVE |
+		      LED2_LINK_100 | LED2_LINK_10 | LED_VALID;
+		break;
+	default:
+		led = LED0_ACTIVE | LED1_LINK_10 | LED1_LINK_100 |
+		      LED1_LINK_1000 | LED2_ACTIVE | LED2_LINK_10 |
+		      LED2_LINK_100 | LED2_LINK_1000 | LED_VALID;
+		break;
+	}
+
+	memcpy((u8 *)ledvalue, &led, 2);
+
+	return 0;
+}
+
+static void ax88179_Gether_setting(struct ax_device *axdev)
+{
+	u16 reg16;
+
+	reg16 = 0x03;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  31, 2, &reg16);
+	reg16 = 0x3246;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  25, 2, &reg16);
+	reg16 = 0;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  31, 2, &reg16);
+}
+
+static int ax88179_LED_setting(struct ax_device *axdev)
+{
+	u16 ledvalue = 0, delay = HZ / 10;
+	u16 ledact, ledlink;
+	u16 reg16;
+	u8 value;
+
+	ax_read_cmd(axdev, AX_ACCESS_MAC, GENERAL_STATUS, 1, 1, &value, 0);
+
+	if (!(value & AX_SECLD)) {
+		value = AX_GPIO_CTRL_GPIO3EN | AX_GPIO_CTRL_GPIO2EN |
+			AX_GPIO_CTRL_GPIO1EN;
+		if (ax_write_cmd(axdev, AX_ACCESS_MAC, AX_GPIO_CTRL,
+				      1, 1, &value) < 0)
+			return -EINVAL;
+	}
+
+	if (!ax88179_check_eeprom(axdev)) {
+		value = 0x42;
+		if (ax_write_cmd(axdev, AX_ACCESS_MAC, AX_SROM_ADDR,
+				      1, 1, &value) < 0)
+			return -EINVAL;
+
+		value = EEP_RD;
+		if (ax_write_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+				      1, 1, &value) < 0)
+			return -EINVAL;
+
+		do {
+			ax_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+					 1, 1, &value, 0);
+
+			ax_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+					 1, 1, &value, 0);
+
+			if (time_after(jiffies, (jiffies + delay)))
+				return -EINVAL;
+		} while (value & EEP_BUSY);
+
+		ax_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_DATA_HIGH,
+				 1, 1, &value, 0);
+		ledvalue = (value << 8);
+		ax_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,
+				 1, 1, &value, 0);
+		ledvalue |= value;
+
+		if ((ledvalue == 0xFFFF) || ((ledvalue & LED_VALID) == 0))
+			ax88179_convert_old_led(axdev, 0, &ledvalue);
+
+	} else if (!ax88179_check_efuse(axdev, &ledvalue)) {
+		if ((ledvalue == 0xFFFF) || ((ledvalue & LED_VALID) == 0))
+			ax88179_convert_old_led(axdev, 0, &ledvalue);
+	} else {
+		ax88179_convert_old_led(axdev, 0, &ledvalue);
+	}
+
+	reg16 = GMII_PHY_PAGE_SELECT_EXT;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_PHY_PAGE_SELECT, 2, &reg16);
+
+	reg16 = 0x2c;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_PHYPAGE, 2, &reg16);
+
+	ax_read_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			 GMII_LED_ACTIVE, 2, &ledact, 1);
+
+	ax_read_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			 GMII_LED_LINK, 2, &ledlink, 1);
+
+	ledact &= GMII_LED_ACTIVE_MASK;
+	ledlink &= GMII_LED_LINK_MASK;
+
+	if (ledvalue & LED0_ACTIVE)
+		ledact |= GMII_LED0_ACTIVE;
+	if (ledvalue & LED1_ACTIVE)
+		ledact |= GMII_LED1_ACTIVE;
+	if (ledvalue & LED2_ACTIVE)
+		ledact |= GMII_LED2_ACTIVE;
+
+	if (ledvalue & LED0_LINK_10)
+		ledlink |= GMII_LED0_LINK_10;
+	if (ledvalue & LED1_LINK_10)
+		ledlink |= GMII_LED1_LINK_10;
+	if (ledvalue & LED2_LINK_10)
+		ledlink |= GMII_LED2_LINK_10;
+
+	if (ledvalue & LED0_LINK_100)
+		ledlink |= GMII_LED0_LINK_100;
+	if (ledvalue & LED1_LINK_100)
+		ledlink |= GMII_LED1_LINK_100;
+	if (ledvalue & LED2_LINK_100)
+		ledlink |= GMII_LED2_LINK_100;
+
+	if (ledvalue & LED0_LINK_1000)
+		ledlink |= GMII_LED0_LINK_1000;
+	if (ledvalue & LED1_LINK_1000)
+		ledlink |= GMII_LED1_LINK_1000;
+	if (ledvalue & LED2_LINK_1000)
+		ledlink |= GMII_LED2_LINK_1000;
+
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_LED_ACTIVE, 2, &ledact);
+
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_LED_LINK, 2, &ledlink);
+
+	reg16 = GMII_PHY_PAGE_SELECT_PAGE0;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_PHY_PAGE_SELECT, 2, &reg16);
+
+	/* LED full duplex setting */
+	reg16 = 0;
+	if (ledvalue & LED0_FD)
+		reg16 |= 0x01;
+	else if ((ledvalue & LED0_USB3_MASK) == 0)
+		reg16 |= 0x02;
+
+	if (ledvalue & LED1_FD)
+		reg16 |= 0x04;
+	else if ((ledvalue & LED1_USB3_MASK) == 0)
+		reg16 |= 0x08;
+
+	if (ledvalue & LED2_FD) /* LED2_FD */
+		reg16 |= 0x10;
+	else if ((ledvalue & LED2_USB3_MASK) == 0) /* LED2_USB3 */
+		reg16 |= 0x20;
+
+	ax_write_cmd(axdev, AX_ACCESS_MAC, 0x73, 1, 1, &reg16);
+
+	return 0;
+}
+
+static void ax88179_EEE_setting(struct ax_device *axdev)
+{
+	u16 reg16;
+	/* Disable */
+	reg16 = 0x07;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				GMII_PHY_MACR, 2, &reg16);
+	reg16 = 0x3c;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				GMII_PHY_MAADR, 2, &reg16);
+	reg16 = 0x4007;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				GMII_PHY_MACR, 2, &reg16);
+	reg16 = 0x00;
+	ax_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				GMII_PHY_MAADR, 2, &reg16);
+}
+
+static int ax88179_AutoDetach(struct ax_device *axdev, int in_pm)
+{
+	u16 reg16;
+	usb_read_function fnr;
+	usb_write_function fnw;
+
+	if (!in_pm) {
+		fnr = ax_read_cmd;
+		fnw = ax_write_cmd;
+	} else {
+		fnr = ax_read_cmd_nopm;
+		fnw = ax_write_cmd_nopm;
+	}
+
+	if (fnr(axdev, AX_ACCESS_EEPROM, 0x43, 1, 2, &reg16, 1) < 0)
+		return 0;
+
+	if ((reg16 == 0xFFFF) || (!(reg16 & 0x0100)))
+		return 0;
+
+	reg16 = 0;
+	fnr(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg16, 0);
+	reg16 |= AX_CLK_SELECT_ULR;
+	fnw(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg16);
+
+	fnr(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16, 1);
+	reg16 |= AX_PHYPWR_RSTCTL_AUTODETACH;
+	fnw(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+
+	return 0;
+}
+
+static int ax88179_hw_init(struct ax_device *axdev)
+{
+	u32 reg32;
+	u16 reg16;
+	u8 reg8;
+	u8 buf[6] = {0};
+
+	reg32 = 0;
+	ax_write_cmd(axdev, 0x81, 0x310, 0, 4, &reg32);
+
+	reg16 = 0;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+	reg16 = AX_PHYPWR_RSTCTL_IPRL;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+	msleep(200);
+
+	reg8 = AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg8);
+	msleep(100);
+
+	ax88179_AutoDetach(axdev, 0);
+
+	memcpy(buf, &AX88179_BULKIN_SIZE[0], 5);
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, buf);
+
+	reg8 = 0x34;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_LOW,
+			  1, 1, &reg8);
+
+	reg8 = 0x52;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,
+			  1, 1, &reg8);
+
+	ax_write_cmd(axdev, 0x91, 0, 0, 0, NULL);
+
+	reg8 = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
+	       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &reg8);
+
+	reg8 = AX_TXCOE_IP | AX_TXCOE_TCP | AX_TXCOE_UDP |
+	       AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8);
+
+	reg8 = AX_MONITOR_MODE_PMETYPE | AX_MONITOR_MODE_PMEPOL |
+	       AX_MONITOR_MODE_RWLC | AX_MONITOR_MODE_RWMP;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8);
+
+	ax88179_LED_setting(axdev);
+
+	ax88179_EEE_setting(axdev);
+
+	ax88179_Gether_setting(axdev);
+
+	ax_set_tx_qlen(axdev);
+
+	mii_nway_restart(&axdev->mii);
+
+	return 0;
+
+}
+
+static int ax88179_bind(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+
+	PRINT_VERSION(axdev, AX_DRIVER_STRING_179_178A);
+
+	netdev->features    |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+			       NETIF_F_SG | NETIF_F_TSO | NETIF_F_FRAGLIST;
+	netdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+			       NETIF_F_SG | NETIF_F_TSO | NETIF_F_FRAGLIST;
+
+	netdev->max_mtu = (9 * 1024);
+	axdev->tx_casecade_size = TX_CASECADES_SIZE;
+	axdev->gso_max_size = AX_GSO_DEFAULT_SIZE;
+	axdev->mii.supports_gmii = 1;
+	axdev->mii.dev = netdev;
+	axdev->mii.mdio_read = ax_mdio_read;
+	axdev->mii.mdio_write = ax_mdio_write;
+	axdev->mii.phy_id_mask = 0xff;
+	axdev->mii.reg_num_mask = 0xff;
+	axdev->mii.phy_id = AX88179_PHY_ID;
+	axdev->mii.force_media = 0;
+	axdev->mii.advertising = ADVERTISE_10HALF | ADVERTISE_10FULL |
+				 ADVERTISE_100HALF | ADVERTISE_100FULL;
+#if KERNEL_VERSION(5, 19, 0) <= LINUX_VERSION_CODE
+	netif_set_tso_max_size(netdev, axdev->gso_max_size);
+#else
+	netif_set_gso_max_size(netdev, axdev->gso_max_size);
+#endif
+
+	axdev->bin_setting.custom = 1;
+	axdev->tx_align_len = 4;
+
+	netdev->ethtool_ops = &ax88179_ethtool_ops;
+	axdev->netdev->netdev_ops = &ax88179_netdev_ops;
+
+	return 0;
+}
+
+static void ax88179_unbind(struct ax_device *axdev)
+{
+
+}
+
+static int ax88179_stop(struct ax_device *axdev)
+{
+	u16 reg16;
+
+	reg16 = AX_RX_CTL_STOP;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2, &reg16);
+
+	reg16 = 0;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg16);
+
+	reg16 = AX_PHYPWR_RSTCTL_BZ;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+	msleep(200);
+
+	return 0;
+}
+
+static int ax88179_link_reset(struct ax_device *axdev)
+{
+	u8 reg8[5], link_sts;
+	u16 mode, reg16, delay;
+	u32 reg32;
+
+	mode = AX_MEDIUM_TXFLOW_CTRLEN | AX_MEDIUM_RXFLOW_CTRLEN;
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, PHYSICAL_LINK_STATUS,
+			 1, 1, &link_sts, 0);
+	ax_read_cmd_nopm(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			 GMII_PHY_PHYSR, 2, &reg16, 1);
+
+	if (!(reg16 & GMII_PHY_PHYSR_LINK)) {
+		return -1;
+	} else if (GMII_PHY_PHYSR_GIGA == (reg16 & GMII_PHY_PHYSR_SMASK)) {
+		mode |= AX_MEDIUM_GIGAMODE;
+		if (axdev->netdev->mtu > 1500)
+			mode |= AX_MEDIUM_JUMBO_EN;
+
+		if (link_sts & AX_USB_SS)
+			memcpy(reg8, &AX88179_BULKIN_SIZE[0], 5);
+		else if (link_sts & AX_USB_HS)
+			memcpy(reg8, &AX88179_BULKIN_SIZE[1], 5);
+		else
+			memcpy(reg8, &AX88179_BULKIN_SIZE[3], 5);
+	} else if (GMII_PHY_PHYSR_100 == (reg16 & GMII_PHY_PHYSR_SMASK)) {
+		mode |= AX_MEDIUM_PS;
+		if (link_sts & (AX_USB_SS | AX_USB_HS))
+			memcpy(reg8, &AX88179_BULKIN_SIZE[2], 5);
+		else
+			memcpy(reg8, &AX88179_BULKIN_SIZE[3], 5);
+	} else {
+		memcpy(reg8, &AX88179_BULKIN_SIZE[3], 5);
+	}
+
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, reg8);
+
+	if (reg16 & GMII_PHY_PHYSR_FULL)
+		mode |= AX_MEDIUM_FULL_DUPLEX;
+
+	ax_read_cmd_nopm(axdev, 0x81, 0x8c, 0, 4, &reg32, 1);
+	delay = HZ / 2;
+	if (reg32 & 0x40000000) {
+		unsigned long jtimeout;
+		u16 temp16 = 0;
+
+		ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				  2, 2, &temp16);
+		ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				  2, 2, &mode);
+
+		jtimeout = jiffies + delay;
+		while (time_before(jiffies, jtimeout)) {
+			ax_read_cmd_nopm(axdev, 0x81, 0x8c, 0, 4, &reg32, 1);
+
+			if (!(reg32 & 0x40000000))
+				break;
+
+			reg32 = 0x80000000;
+			ax_write_cmd(axdev, 0x81, 0x8c, 0, 4, &reg32);
+		}
+
+		temp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_START |
+			 AX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;
+		ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				  2, 2, &temp16);
+	}
+
+	axdev->rxctl |= AX_RX_CTL_DROPCRCERR | AX_RX_CTL_START | AX_RX_CTL_AB;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+			  2, 2, &axdev->rxctl);
+
+	mode |= AX_MEDIUM_RECEIVE_EN;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			  2, 2, &mode);
+
+	return 0;
+}
+
+
+static int ax88179_tx_fixup(struct ax_device *axdev, struct tx_desc *desc)
+{
+	struct sk_buff_head skb_head, *tx_queue = &axdev->tx_queue[0];
+	struct net_device_stats *stats = &axdev->netdev->stats;
+	int remain, ret;
+	u8 *tx_data;
+
+	__skb_queue_head_init(&skb_head);
+	spin_lock(&tx_queue->lock);
+	skb_queue_splice_init(tx_queue, &skb_head);
+	spin_unlock(&tx_queue->lock);
+
+	tx_data = desc->head;
+	desc->skb_num = 0;
+	desc->skb_len = 0;
+	remain = axdev->tx_casecade_size;
+
+	while (remain >= ETH_ZLEN + 8) {
+		struct sk_buff *skb;
+		u32 *tx_hdr1, *tx_hdr2;
+
+		skb = __skb_dequeue(&skb_head);
+		if (!skb)
+			break;
+
+		if ((skb->len + AX_TX_HEADER_LEN) > remain &&
+		    (skb_shinfo(skb)->gso_size == 0)) {
+			__skb_queue_head(&skb_head, skb);
+			break;
+		}
+
+		memset(tx_data, 0, AX_TX_HEADER_LEN);
+		tx_hdr1 = (u32 *)tx_data;
+		tx_hdr2 = tx_hdr1 + 1;
+		*tx_hdr1 = skb->len;
+		*tx_hdr2 = skb_shinfo(skb)->gso_size;
+		cpu_to_le32s(tx_hdr1);
+		cpu_to_le32s(tx_hdr2);
+		tx_data += 8;
+
+		if (skb_copy_bits(skb, 0, tx_data, skb->len) < 0) {
+			stats->tx_dropped++;
+			dev_kfree_skb_any(skb);
+			continue;
+		}
+
+		tx_data += skb->len;
+		desc->skb_len += skb->len;
+		desc->skb_num += skb_shinfo(skb)->gso_segs ?: 1;
+		dev_kfree_skb_any(skb);
+
+		tx_data = __tx_buf_align(tx_data, axdev->tx_align_len);
+		if (*tx_hdr2 > 0)
+			break;
+		remain = axdev->tx_casecade_size -
+			 (int)((void *)tx_data - desc->head);
+	}
+
+	if (!skb_queue_empty(&skb_head)) {
+		spin_lock(&tx_queue->lock);
+		skb_queue_splice(&skb_head, tx_queue);
+		spin_unlock(&tx_queue->lock);
+	}
+
+	netif_tx_lock(axdev->netdev);
+
+	if (netif_queue_stopped(axdev->netdev) &&
+	    skb_queue_len(tx_queue) < axdev->tx_qlen) {
+		netif_wake_queue(axdev->netdev);
+	}
+
+	netif_tx_unlock(axdev->netdev);
+
+	ret = usb_autopm_get_interface_async(axdev->intf);
+	if (ret < 0)
+		goto out_tx_fill;
+
+	usb_fill_bulk_urb(desc->urb, axdev->udev,
+			  usb_sndbulkpipe(axdev->udev, 3),
+			  desc->head, (int)(tx_data - (u8 *)desc->head),
+			  (usb_complete_t)ax_write_bulk_callback, desc);
+
+	ret = usb_submit_urb(desc->urb, GFP_ATOMIC);
+	if (ret < 0)
+		usb_autopm_put_interface_async(axdev->intf);
+
+out_tx_fill:
+	return ret;
+}
+
+static void ax88179_rx_checksum(struct sk_buff *skb, u32 *pkt_hdr)
+{
+	skb->ip_summed = CHECKSUM_NONE;
+
+	if ((*pkt_hdr & AX_RXHDR_L3CSUM_ERR) ||
+	    (*pkt_hdr & AX_RXHDR_L4CSUM_ERR))
+		return;
+
+	if (((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_TCP) ||
+	    ((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_UDP))
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+}
+
+static void ax88179_rx_fixup(struct ax_device *axdev, struct rx_desc *desc,
+			     int *work_done, int budget)
+{
+	u8 *rx_data;
+	u32 const actual_length = desc->urb->actual_length;
+	u32 rx_hdr = 0, pkt_hdr = 0, pkt_hdr_curr = 0, hdr_off = 0;
+	u32 aa = 0;
+	int pkt_cnt = 0;
+	struct net_device *netdev = axdev->netdev;
+	struct net_device_stats *stats = ax_get_stats(netdev);
+
+	memcpy(&rx_hdr, (((u8 *)desc->head) + actual_length - 4),
+	       sizeof(rx_hdr));
+	le32_to_cpus(&rx_hdr);
+
+	pkt_cnt = rx_hdr & 0xFF;
+	pkt_hdr_curr = hdr_off = rx_hdr >> 16;
+
+	aa = (actual_length - (((pkt_cnt + 2) & 0xFE) * 4));
+	if ((aa != hdr_off) ||
+	    (hdr_off >= desc->urb->actual_length) ||
+	    (pkt_cnt == 0)) {
+		desc->urb->actual_length = 0;
+		stats->rx_length_errors++;
+		return;
+	}
+
+	rx_data = desc->head;
+	while (pkt_cnt--) {
+		u32 pkt_len;
+		struct sk_buff *skb;
+
+		memcpy(&pkt_hdr, (((u8 *)desc->head) + pkt_hdr_curr),
+		       sizeof(pkt_hdr));
+		pkt_hdr_curr += 4;
+
+		le32_to_cpus(&pkt_hdr);
+		pkt_len = (pkt_hdr >> 16) & 0x1FFF;
+
+		if (pkt_hdr & AX_RXHDR_CRC_ERR) {
+			stats->rx_crc_errors++;
+			goto find_next_rx;
+		}
+		if (pkt_hdr & AX_RXHDR_DROP_ERR) {
+			stats->rx_dropped++;
+			goto find_next_rx;
+		}
+
+#ifdef ENABLE_RX_TASKLET
+		skb = netdev_alloc_skb(netdev, pkt_len);
+#else
+		skb = napi_alloc_skb(&axdev->napi, pkt_len);
+#endif
+		if (!skb) {
+			stats->rx_dropped++;
+			goto find_next_rx;
+		}
+
+		memcpy(skb->data, rx_data, pkt_len);
+		skb_put(skb, pkt_len);
+
+		ax88179_rx_checksum(skb, &pkt_hdr);
+
+		skb->protocol = eth_type_trans(skb, netdev);
+
+		if (*work_done < budget) {
+#ifdef ENABLE_RX_TASKLET
+			netif_receive_skb(skb);
+#else
+			napi_gro_receive(&axdev->napi, skb);
+#endif
+			*work_done += 1;
+			stats->rx_packets++;
+			stats->rx_bytes += pkt_len;
+		} else {
+			__skb_queue_tail(&axdev->rx_queue, skb);
+		}
+find_next_rx:
+		rx_data += (pkt_len + 7) & 0xFFF8;
+	}
+}
+
+static int ax88179_system_suspend(struct ax_device *axdev)
+{
+	u16 reg16;
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			 2, 2, &reg16, 1);
+	reg16 &= ~AX_MEDIUM_RECEIVE_EN;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			  2, 2, &reg16);
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
+			 2, 2, &reg16, 1);
+	reg16 |= AX_PHYPWR_RSTCTL_IPRL;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
+			  2, 2, &reg16);
+
+	reg16 = AX_RX_CTL_STOP;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	return 0;
+}
+
+static int ax88179_system_resume(struct ax_device *axdev)
+{
+	u16 reg16;
+	u8 reg8;
+
+	reg16 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+#if KERNEL_VERSION(2, 6, 36) <= LINUX_VERSION_CODE
+	usleep_range(1000, 2000);
+#else
+	msleep(20);
+#endif
+	reg16 = AX_PHYPWR_RSTCTL_IPRL;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+	msleep(200);
+
+	ax88179_AutoDetach(axdev, 1);
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC,  AX_CLK_SELECT, 1, 1, &reg8, 0);
+	reg8 |= AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg8);
+	msleep(100);
+
+	reg16 = AX_RX_CTL_START | AX_RX_CTL_AP |
+		AX_RX_CTL_AMALL | AX_RX_CTL_AB;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	return 0;
+}
+
+static int ax88179_runtime_suspend(struct ax_device *axdev)
+{
+       u16 reg16;
+#if 0
+       ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg16,
+                        1);
+       reg16 &= ~AX_MONITOR_MODE_RWLC;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg16);
+#endif
+       ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+                        &reg16, 1);
+       reg16 &= ~AX_MEDIUM_RECEIVE_EN;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+                         &reg16);
+       ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16,
+                        1);
+       reg16 |= AX_PHYPWR_RSTCTL_IPRL;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+       reg16 = AX_RX_CTL_STOP;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+       return 0;
+}
+
+static int ax88179_runtime_resume(struct ax_device *axdev)
+{
+       u16 reg16;
+       u8 reg8;
+       reg16 = 0;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+#if KERNEL_VERSION(2, 6, 36) <= LINUX_VERSION_CODE
+       usleep_range(1000, 2000);
+#else
+       msleep(20);
+#endif
+       reg16 = AX_PHYPWR_RSTCTL_IPRL;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+       msleep(200);
+       ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg8, 0);
+       reg8 |= AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg8);
+       msleep(100);
+       ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+                        &reg16, 1);
+       reg16 |= AX_MEDIUM_RECEIVE_EN;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+                         &reg16);
+       reg16 = AX_RX_CTL_START | AX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;
+       ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+       return 0;
+}
+
+const struct driver_info ax88179_info = {
+	.bind = ax88179_bind,
+	.unbind = ax88179_unbind,
+	.hw_init = ax88179_hw_init,
+	.stop = ax88179_stop,
+	.link_reset = ax88179_link_reset,
+	.rx_fixup = ax88179_rx_fixup,
+	.tx_fixup = ax88179_tx_fixup,
+	.system_suspend = ax88179_system_suspend,
+	.system_resume = ax88179_system_resume,
+	.runtime_suspend = ax88179_runtime_suspend,
+    .runtime_resume = ax88179_runtime_resume,
+	.napi_weight = AX88179_NAPI_WEIGHT,
+	.buf_rx_size = AX88179_BUF_RX_SIZE,
+};
diff --git a/drivers/net/usb/asix_usb/ax88179_178a.h b/drivers/net/usb/asix_usb/ax88179_178a.h
new file mode 100644
index 000000000000..ecbdf532fd2d
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179_178a.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#ifndef __ASIX_AX88179_178A_H
+#define __ASIX_AX88179_178A_H
+
+#define AX88179_NAPI_WEIGHT		64
+#define AX88179_BUF_RX_SIZE		(48 * 1024)
+#define AX88179_PHY_ID			0x03
+
+extern const struct net_device_ops ax88179_netdev_ops;
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+int ax88179_siocdevprivate(struct net_device *netdev, struct ifreq *rq,
+			   void __user *udata, int cmd);
+#endif
+int ax88179_ioctl(struct net_device *net, struct ifreq *rq, int cmd);
+
+int ax88179_set_mac_addr(struct net_device *net, void *p);
+void ax88179_set_multicast(struct net_device *net);
+
+extern const struct driver_info ax88179_info;
+#endif
diff --git a/drivers/net/usb/asix_usb/ax88179_programmer.c b/drivers/net/usb/asix_usb/ax88179_programmer.c
new file mode 100644
index 000000000000..4990918ef64b
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179_programmer.c
@@ -0,0 +1,629 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#if NET_INTERFACE == INTERFACE_SCAN
+#include <ifaddrs.h>
+#endif
+#include "ax_ioctl.h"
+
+#define AX88179_IOCTL_VERSION \
+"AX88179/AX88178A Linux EEPROM/eFuse Programming Tool v1.5.0"
+
+const char help_str1[] =
+"./ax88179_programmer help [command]\n"
+"    -- command description\n";
+const char help_str2[] =
+"        [command] - Display usage of specified command\n";
+
+const char readeeprom_str1[] =
+"./ax88179_programmer reeprom [type] [file] [size]\n"
+"    -- AX88179_178A EEPROM/eFuse read tool\n";
+const char readeeprom_str2[] =
+"        [type]    - 0: EEPROM,  1: eFuse\n"
+"        [file]    - Output file\n"
+"        [size]    - EEPROM/eFuse SIZE (bytes). EEPROM maximum 512 bytes,\n"
+"                    eFuse maximum 64 bytes.\n";
+
+const char writeeeprom_str1[] =
+"./ax88179_programmer weeeprom [type] [file] [size]\n"
+"    -- AX88179_178A EEPROM/eFuse write tool\n";
+const char writeeeprom_str2[] =
+"        [type]    - 0: EEPROM,  1: eFuse\n"
+"        [file]    - Input file\n"
+"        [size]    - EEPROM/eFuse SIZE (bytes). EEPROM size 12-512 bytes,\n"
+"                    eFuse maximum 64 bytes.\n";
+
+const char chgmac_str1[] =
+"./ax88179_programmer chgmac [type] [mac_addr] [size]\n"
+"    -- AX88179_178A EEPROM/eFuse write tool (specify MAC address)\n";
+const char chgmac_str2[] =
+"        [type]    - 0: EEPROM,  1: eFuse\n"
+"        [mac_addr]- MAC address (xx:xx:xx:xx:xx:xx)\n"
+"        [size]    - EEPROM/eFuse SIZE (bytes). EEPROM size 12-512 bytes,\n"
+"                    eFuse maximum 64 bytes.\n";
+
+static int help_func(struct ax_command_info *info);
+static int readeeprom_func(struct ax_command_info *info);
+static int writeeeprom_func(struct ax_command_info *info);
+static int chgmac_func(struct ax_command_info *info);
+struct _command_list ax88179_cmd_list[] = {
+	{
+		"help",
+		AX_SIGNATURE,
+		help_func,
+		help_str1,
+		help_str2
+	},
+	{
+		"reeprom",
+		AX88179_READ_EEPROM,
+		readeeprom_func,
+		readeeprom_str1,
+		readeeprom_str2
+	},
+	{
+		"weeprom",
+		AX88179_WRITE_EEPROM,
+		writeeeprom_func,
+		writeeeprom_str1,
+		writeeeprom_str2
+	},
+	{
+		"chgmac",
+		AX88179_WRITE_EEPROM,
+		chgmac_func,
+		chgmac_str1,
+		chgmac_str2
+	},
+	{NULL},
+};
+
+static void show_usage(void)
+{
+	int i;
+
+	printf("Usage:\n");
+	for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++)
+		printf("%s\n", ax88179_cmd_list[i].help_ins);
+}
+
+static unsigned long STR_TO_U32(const char *cp, char **endp, unsigned int base)
+{
+	unsigned long result = 0, value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base)
+			base = 8;
+	}
+	if (!base)
+		base = 10;
+
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+
+	return result;
+}
+
+static int help_func(struct ax_command_info *info)
+{
+	int i;
+
+	if (info->argv[2] == NULL) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+			       ax88179_cmd_list[i].help_desc);
+		}
+	}
+
+	for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+			    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+			       ax88179_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	return SUCCESS;
+}
+
+static int compare_file(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	unsigned short *rout_buf;
+	unsigned short *ori_buf;
+	struct _ax_ioctl_command *ioctl_cmd =
+				(struct _ax_ioctl_command *)(ifr->ifr_data);
+	int i;
+
+	rout_buf = malloc(sizeof(unsigned short) * ioctl_cmd->size);
+
+	ori_buf = ioctl_cmd->buf;
+
+	ioctl_cmd->ioctl_cmd = AX88179_READ_EEPROM;
+	ioctl_cmd->buf = rout_buf;
+
+	if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+		perror("ioctl");
+		return -1;
+	}
+
+	for (i = 0; i < ioctl_cmd->size; i++) {
+		if (*(ioctl_cmd->buf + i) != *(ori_buf + i)) {
+			ioctl_cmd->buf = ori_buf;
+			free(rout_buf);
+			return -1;
+		}
+	}
+
+	ioctl_cmd->buf = ori_buf;
+	free(rout_buf);
+	return 0;
+}
+
+static int readeeprom_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	unsigned short *buf;
+	unsigned short wLen;
+	char str_buf[50];
+	unsigned char type;
+	FILE *pFile;
+	int i;
+
+	if (info->argc != 5) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+				    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+				       ax88179_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	type = STR_TO_U32(info->argv[2], NULL, 0);
+	wLen = STR_TO_U32(info->argv[4], NULL, 0) / 2;
+
+	if ((type > 1) ||
+	    ((type == 0) && (wLen > 256)) ||
+	    ((type == 1) && (wLen > 32))) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+				    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+				       ax88179_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	pFile = fopen(info->argv[3], "w");
+	if (pFile == NULL) {
+		printf("fail to open %s file\n", info->argv[3]);
+		return -FAIL_LOAD_FILE;
+	}
+
+	buf = (unsigned short *)malloc(sizeof(unsigned short) * wLen);
+
+	ioctl_cmd.ioctl_cmd = info->ioctl_cmd;
+	ioctl_cmd.size = wLen;
+	ioctl_cmd.buf = buf;
+	ioctl_cmd.type = type;
+	ioctl_cmd.delay = 0;
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+		perror("ioctl");
+		free(buf);
+		fclose(pFile);
+		return -FAIL_IOCTL;
+	}
+
+	for (i = 0; i < wLen / 8; i++) {
+		int j = 8 * i;
+
+		snprintf(str_buf, 50,
+			 "%04x %04x %04x %04x %04x %04x %04x %04x\n",
+			 *(buf + j + 0), *(buf + j + 1),
+			 *(buf + j + 2), *(buf + j + 3),
+			 *(buf + j + 4), *(buf + j + 5),
+			 *(buf + j + 6), *(buf + j + 7));
+
+		fputs(str_buf, pFile);
+	}
+
+	free(buf);
+	fclose(pFile);
+	printf("read completely\n");
+
+	return SUCCESS;
+}
+
+static int writeeeprom_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int i;
+	unsigned short *buf;
+	unsigned short wLen;
+	char c[2] = {'\0'};
+	FILE *pFile;
+	unsigned char retried = 0;
+	unsigned char type;
+
+	if (info->argc != 5) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+				    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+				       ax88179_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	type = STR_TO_U32(info->argv[2], NULL, 0);
+	wLen = STR_TO_U32(info->argv[4], NULL, 0) / 2;
+
+	if ((type > 1) ||
+	    ((type == 0) && (wLen > 256)) ||
+	    ((type == 0) && (wLen < 6)) ||
+	    ((type == 1) && (wLen > 32))) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+				    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+				       ax88179_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	pFile = fopen(info->argv[3], "r");
+	if (pFile == NULL) {
+		printf("fail to open %s file\n", info->argv[3]);
+		return -FAIL_LOAD_FILE;
+	}
+
+	buf = (unsigned short *)malloc(sizeof(unsigned short) * wLen);
+
+	for (i = 0; i < wLen / 8; i++) {
+		int j = 8 * i;
+
+		fscanf(pFile, "%04X %04X %04X %04X %04X %04X %04X %04X%c",
+				(unsigned int *)&buf[j + 0],
+				(unsigned int *)&buf[j + 1],
+				(unsigned int *)&buf[j + 2],
+				(unsigned int *)&buf[j + 3],
+				(unsigned int *)&buf[j + 4],
+				(unsigned int *)&buf[j + 5],
+				(unsigned int *)&buf[j + 6],
+				(unsigned int *)&buf[j + 7], c);
+	}
+
+	ioctl_cmd.ioctl_cmd = info->ioctl_cmd;
+	ioctl_cmd.size = wLen;
+	ioctl_cmd.buf = buf;
+	ioctl_cmd.delay = 5;
+
+	if (type) {
+		ioctl_cmd.type = 2;
+		ifr->ifr_data = (caddr_t)&ioctl_cmd;
+		if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+			free(buf);
+			fclose(pFile);
+			perror("ioctl");
+			return -FAIL_IOCTL;
+		}
+		if (ioctl_cmd.type) {
+			printf("EFuse has been programed.\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	ioctl_cmd.type = type;
+io:
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+		free(buf);
+		fclose(pFile);
+		perror("ioctl");
+		return -FAIL_IOCTL;
+	}
+	if (compare_file(info) && retried < 3) {
+		ioctl_cmd.delay += 5;
+		ioctl_cmd.ioctl_cmd = info->ioctl_cmd;
+		retried++;
+		goto io;
+	}
+	if (retried == 3) {
+		printf("Failure to write\n");
+		free(buf);
+		fclose(pFile);
+		return -FAIL_GENERIAL_ERROR;
+	}
+
+	printf("Write completely\n");
+	free(buf);
+	fclose(pFile);
+
+	return SUCCESS;
+}
+
+static int chgmac_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int i;
+	unsigned short *buf;
+	unsigned short wLen;
+	unsigned char retried = 0;
+	unsigned int MAC[6] = {0};
+	int ret = 0;
+	unsigned char type;
+	char c[2] = {'\0'};
+	FILE *pFile;
+
+	if (info->argc != 5) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+				    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+				       ax88179_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	type = STR_TO_U32(info->argv[2], NULL, 0);
+	wLen = STR_TO_U32(info->argv[4], NULL, 0) / 2;
+
+	if ((type > 1) ||
+	    ((type == 0) && (wLen > 256)) ||
+	    ((type == 0) && (wLen < 6)) ||
+	    ((type == 1) && (wLen > 32))) {
+		for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179_cmd_list[i].cmd,
+				    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179_cmd_list[i].help_ins,
+				       ax88179_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	buf = (unsigned short *)malloc(sizeof(unsigned short) * wLen);
+
+	if (type) {
+		pFile = fopen("efuse", "r");
+		if (pFile == NULL) {
+			printf("fail to open 'efuse' file\n");
+			free(buf);
+			return -FAIL_LOAD_FILE;
+		}
+
+		for (i = 0; i < wLen / 8; i++) {
+			int j = 8 * i;
+
+			fscanf(pFile, "%04X %04X %04X %04X %04X %04X %04X %04X%c",
+					(unsigned int *)&buf[j + 0],
+					(unsigned int *)&buf[j + 1],
+					(unsigned int *)&buf[j + 2],
+					(unsigned int *)&buf[j + 3],
+					(unsigned int *)&buf[j + 4],
+					(unsigned int *)&buf[j + 5],
+					(unsigned int *)&buf[j + 6],
+					(unsigned int *)&buf[j + 7], c);
+		}
+	} else {
+		ioctl_cmd.ioctl_cmd = AX88179_READ_EEPROM;
+		ioctl_cmd.size = wLen;
+		ioctl_cmd.buf = buf;
+		ioctl_cmd.delay = 0;
+		ioctl_cmd.type = type;
+
+		ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+		if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+			perror("ioctl");
+			free(buf);
+			return -FAIL_IOCTL;
+		}
+	}
+
+	ret = sscanf(info->argv[3], "%02X:%02X:%02X:%02X:%02X:%02X",
+					(unsigned int *)&MAC[0],
+					(unsigned int *)&MAC[1],
+					(unsigned int *)&MAC[2],
+					(unsigned int *)&MAC[3],
+					(unsigned int *)&MAC[4],
+					(unsigned int *)&MAC[5]);
+	if (ret != 6) {
+		printf("Invalid MAC address\n");
+		return -FAIL_INVALID_PARAMETER;
+	}
+
+	*(((char *)buf) + 0) = (unsigned char)MAC[1];
+	*(((char *)buf) + 1) = (unsigned char)MAC[0];
+	*(((char *)buf) + 2) = (unsigned char)MAC[3];
+	*(((char *)buf) + 3) = (unsigned char)MAC[2];
+	*(((char *)buf) + 4) = (unsigned char)MAC[5];
+	*(((char *)buf) + 5) = (unsigned char)MAC[4];
+
+	ioctl_cmd.ioctl_cmd = info->ioctl_cmd;
+	ioctl_cmd.size = wLen;
+	ioctl_cmd.buf = buf;
+	ioctl_cmd.delay = 5;
+	ioctl_cmd.type = type;
+
+	if (type) {
+		ioctl_cmd.type = 2;
+		ifr->ifr_data = (caddr_t)&ioctl_cmd;
+		if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+			free(buf);
+			perror("ioctl");
+			return -FAIL_IOCTL;
+		} else if (ioctl_cmd.type) {
+			printf("EFuse has been programed.\n");
+		}
+	}
+io:
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+	if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+		perror("ioctl");
+		free(buf);
+		return -FAIL_IOCTL;
+	}
+	if (compare_file(info) && retried < 3) {
+		ioctl_cmd.delay += 5;
+		ioctl_cmd.ioctl_cmd = info->ioctl_cmd;
+		retried++;
+		goto io;
+	}
+	if (retried == 3) {
+		printf("Failure to write\n");
+		free(buf);
+		return -FAIL_GENERIAL_ERROR;
+	}
+
+	printf("Chgmac completely\n");
+	free(buf);
+
+	return SUCCESS;
+}
+
+int main(int argc, char **argv)
+{
+	int inet_sock;
+	struct ifreq ifr;
+	struct ax_command_info info;
+	unsigned char i;
+	unsigned char count = 0;
+	const unsigned char length = sizeof(char);
+	struct _ax_ioctl_command ioctl_cmd;
+#if NET_INTERFACE == INTERFACE_SCAN
+	struct ifaddrs *addrs, *tmp;
+	unsigned char	dev_exist;
+#endif
+
+	printf("\n%s\n", AX88179_IOCTL_VERSION);
+
+	if (argc < 2) {
+		show_usage();
+		return 0;
+	}
+
+	inet_sock = socket(AF_INET, SOCK_DGRAM, 0);
+#if NET_INTERFACE == INTERFACE_SCAN
+	getifaddrs(&addrs);
+	tmp = addrs;
+	dev_exist = 0;
+
+	while (tmp) {
+		memset(&ioctl_cmd, 0, sizeof(struct _ax_ioctl_command));
+		ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+		sprintf(ifr.ifr_name, "%s", tmp->ifa_name);
+		tmp = tmp->ifa_next;
+
+		ioctl(inet_sock, SIOCGIFFLAGS, &ifr);
+		if (!(ifr.ifr_flags & IFF_UP))
+			continue;
+
+		ifr.ifr_data = (caddr_t)&ioctl_cmd;
+
+		if (ioctl(inet_sock, AX_PRIVATE, &ifr) < 0)
+			continue;
+
+		if (strncmp(ioctl_cmd.sig, AX88179_DRV_NAME,
+			    strlen(AX88179_DRV_NAME)) == 0) {
+			dev_exist = 1;
+			break;
+		}
+	}
+
+	freeifaddrs(addrs);
+
+	if (dev_exist == 0) {
+		printf("No %s found\n", AX88179_SIGNATURE);
+		return 0;
+	}
+#else
+	for (i = 0; i < 255; i++) {
+
+		memset(&ioctl_cmd, 0, sizeof(struct _ax_ioctl_command));
+		ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+		sprintf(ifr.ifr_name, "eth%d", i);
+
+		ioctl(inet_sock, SIOCGIFFLAGS, &ifr);
+		if (!(ifr.ifr_flags & IFF_UP))
+			continue;
+
+		ifr.ifr_data = (caddr_t)&ioctl_cmd;
+
+		if (ioctl(inet_sock, AX_PRIVATE, &ifr) < 0)
+			continue;
+
+		if (strncmp(ioctl_cmd.sig, AX88179_DRV_NAME,
+			    strlen(AX88179_DRV_NAME)) == 0)
+			break;
+	}
+
+	if (i == 255) {
+		printf("No %s found\n", AX88179_SIGNATURE);
+		return 0;
+	}
+#endif
+	for (i = 0; ax88179_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(argv[1], ax88179_cmd_list[i].cmd,
+			    strlen(ax88179_cmd_list[i].cmd)) == 0) {
+			info.help_ins = ax88179_cmd_list[i].help_ins;
+			info.help_desc = ax88179_cmd_list[i].help_desc;
+			info.ifr = &ifr;
+			info.argc = argc;
+			info.argv = argv;
+			info.inet_sock = inet_sock;
+			info.ioctl_cmd = ax88179_cmd_list[i].ioctl_cmd;
+			(ax88179_cmd_list[i].OptFunc)(&info);
+			return 0;
+		}
+	}
+	printf("Wrong command\n");
+
+	return 0;
+}
diff --git a/drivers/net/usb/asix_usb/ax88179a_772d.c b/drivers/net/usb/asix_usb/ax88179a_772d.c
new file mode 100644
index 000000000000..064fc45b46a5
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179a_772d.c
@@ -0,0 +1,2627 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include "ax_main.h"
+#include "ax88179a_772d.h"
+#ifdef ENABLE_PTP_FUNC
+#include "ax_ptp.h"
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+#include "ax_macsec.h"
+#endif
+
+struct _ax_buikin_setting AX88179A_BULKIN_SIZE[] = {
+	{5, 0x7B, 0x00,	0x18, 0x0F},	//1G, SS
+	{5, 0xC0, 0x02,	0x06, 0x0F},	//1G, HS
+	{7, 0xF0, 0x00,	0x0C, 0x0F},	//100M, Full, SS
+	{6, 0x00, 0x00,	0x06, 0x0F},	//100M, Half, SS
+	{5, 0xC0, 0x04,	0x06, 0x0F},	//100M, Full, HS
+	{7, 0xC0, 0x04,	0x06, 0x0F},	//100M, Half, HS
+	{7, 0x00, 0,	0x03, 0x3F},	//FS
+};
+#ifdef ENABLE_AX88279
+struct _ax_buikin_setting AX88279_BULKIN_SIZE[] = {
+	{5, 0x10, 0x01,	0x11, 0x0F},	//2.5G
+	{7, 0xB3, 0x01,	0x11, 0x0F},	//1G, SS
+	{7, 0xC0, 0x02,	0x06, 0x0F},	//1G, HS
+	{7, 0x80, 0x01,	0x03, 0x0F},	//100M, Full, SS
+	{7, 0x80, 0x01,	0x03, 0x0F},	//100M, Half, SS
+	{7, 0x80, 0x01,	0x03, 0x0F},	//100M, Full, HS
+	{7, 0x80, 0x01,	0x03, 0x0F},	//100M, Half, HS
+	{7, 0x00, 0,	0x03, 0x3F},	//FS
+};
+#endif
+
+static int ax88179a_set_phy_power(struct ax_device *axdev, bool on);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+static int ax88179a_chk_eee(struct ax_device *axdev)
+{
+	struct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };
+
+	mii_ethtool_gset(&axdev->mii, &ecmd);
+
+	if (ecmd.speed == SPEED_1000) {
+		int eee_lp, eee_cap, eee_adv;
+		u32 lp, cap, adv;
+
+		eee_cap = ax_mmd_read(axdev->netdev,
+				      MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
+		if (eee_cap < 0)
+			goto exit;
+		eee_cap &= ~MDIO_EEE_100TX;
+
+		cap = mmd_eee_cap_to_ethtool_sup_t(eee_cap);
+		if (!cap)
+			goto exit;
+
+		eee_lp = ax_mmd_read(axdev->netdev,
+				     MDIO_MMD_AN, MDIO_AN_EEE_LPABLE);
+		if (eee_lp < 0)
+			goto exit;
+
+		eee_adv = ax_mmd_read(axdev->netdev,
+				      MDIO_MMD_AN, MDIO_AN_EEE_ADV);
+		if (eee_adv < 0)
+			goto exit;
+
+		adv = mmd_eee_adv_to_ethtool_adv_t(eee_adv);
+		lp = mmd_eee_adv_to_ethtool_adv_t(eee_lp);
+		if (!(lp & adv & SUPPORTED_1000baseT_Full))
+			goto exit;
+
+		axdev->eee_active = 1;
+		return true;
+	}
+exit:
+	axdev->eee_active = 0;
+	return false;
+}
+
+static int ax88179a_ethtool_get_eee(struct ax_device *axdev,
+				    struct ethtool_eee *data)
+{
+	int val;
+
+	val = ax_mmd_read(axdev->netdev, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
+	if (val < 0)
+		return val;
+	val &= ~MDIO_EEE_100TX;
+	data->supported = mmd_eee_cap_to_ethtool_sup_t(val);
+
+	val = ax_mmd_read(axdev->netdev, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
+	if (val < 0)
+		return val;
+	data->advertised = mmd_eee_adv_to_ethtool_adv_t(val);
+
+	val = ax_mmd_read(axdev->netdev, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE);
+	if (val < 0)
+		return val;
+	data->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(val);
+
+	return 0;
+}
+
+static int ax88179a_get_eee(struct net_device *net, struct ethtool_eee *edata)
+{
+	struct ax_device *axdev = netdev_priv(net);
+
+	edata->eee_enabled = axdev->eee_enabled;
+	edata->eee_active = axdev->eee_active;
+
+	return ax88179a_ethtool_get_eee(axdev, edata);
+}
+
+static void ax88179a_eee_setting(struct ax_device *axdev, bool enable)
+{
+	ax_write_cmd(axdev, AX88179_GPHY_CTRL, AX_GPHY_EEE_CTRL,
+		     enable, 0, NULL);
+}
+
+static int ax88179a_set_eee(struct net_device *net, struct ethtool_eee *edata)
+{
+	struct ax_device *axdev = netdev_priv(net);
+
+	if (edata->advertised & MDIO_EEE_100TX)
+		return -EOPNOTSUPP;
+
+	axdev->eee_enabled = edata->eee_enabled;
+	ax88179a_eee_setting(axdev, axdev->eee_enabled);
+	if (axdev->eee_enabled) {
+		axdev->eee_enabled = ax88179a_chk_eee(axdev);
+		if (!axdev->eee_enabled) {
+			ax88179a_eee_setting(axdev, false);
+			return -EOPNOTSUPP;
+		}
+	}
+
+	mii_nway_restart(&axdev->mii);
+
+	return 0;
+}
+#endif
+
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+static int ax88179a_get_coalesce(struct net_device *netdev,
+				 struct ethtool_coalesce *coalesce,
+				 struct kernel_ethtool_coalesce *kernel_coal,
+				 struct netlink_ext_ack *extack)
+#else
+static int ax88179a_get_coalesce(struct net_device *netdev,
+				 struct ethtool_coalesce *coalesce)
+#endif
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	coalesce->rx_coalesce_usecs = axdev->coalesce;
+
+	return 0;
+}
+
+static u16 ax88179a_usec_to_bin_timer(struct ax_device *axdev)
+{
+	u16 speed_multiple;
+
+	switch (axdev->link_info.eth_speed) {
+	case ETHER_LINK_10:
+		speed_multiple = 100;
+		break;
+	case ETHER_LINK_100:
+		speed_multiple = 10;
+		break;
+	case ETHER_LINK_1000:
+	default:
+		speed_multiple = 1;
+		break;
+	};
+
+	return (axdev->coalesce * US_TO_NS * speed_multiple) /
+		AX88179A_BIN_TIMER_UINT;
+}
+
+static u32 ax88179a_bin_timer_to_usec(struct ax_device *axdev, u16 timer)
+{
+	u16 speed_multiple;
+
+	switch (axdev->link_info.eth_speed) {
+	case ETHER_LINK_10:
+		speed_multiple = 100;
+		break;
+	case ETHER_LINK_100:
+		speed_multiple = 10;
+		break;
+	case ETHER_LINK_1000:
+	default:
+		speed_multiple = 1;
+		break;
+	};
+
+	return (AX88179A_BIN_TIMER_UINT * timer) / (US_TO_NS * speed_multiple);
+}
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+static int ax88179a_set_coalesce(struct net_device *netdev,
+				 struct ethtool_coalesce *coalesce,
+				 struct kernel_ethtool_coalesce *kernel_coal,
+				 struct netlink_ext_ack *extack)
+#else
+static int ax88179a_set_coalesce(struct net_device *netdev,
+				 struct ethtool_coalesce *coalesce)
+#endif
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 timer;
+	int ret = 0;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	axdev->coalesce = coalesce->rx_coalesce_usecs;
+
+	timer = ax88179a_usec_to_bin_timer(axdev);
+	if (timer > 0) {
+		timer &= 0x7FFF;
+		ax_write_cmd(axdev, AX_ACCESS_MAC, AX_RX_BULKIN_QTIMR_LOW,
+			     2, 2, &timer);
+	}
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return ret;
+}
+
+#ifdef ENABLE_PTP_FUNC
+static int ax88179a_set_wol_get_ts_info
+(struct net_device *dev, struct ethtool_ts_info *info)
+{
+	struct ax_device *axdev = (struct ax_device *)netdev_priv(dev);
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+
+	info->so_timestamping =
+			SOF_TIMESTAMPING_TX_SOFTWARE |
+			SOF_TIMESTAMPING_RX_SOFTWARE |
+			SOF_TIMESTAMPING_SOFTWARE |
+			SOF_TIMESTAMPING_TX_HARDWARE |
+			SOF_TIMESTAMPING_RX_HARDWARE |
+			SOF_TIMESTAMPING_RAW_HARDWARE;
+
+	info->phc_index = ptp_cfg->phc_index;
+
+	info->tx_types = BIT(HWTSTAMP_TX_OFF) |
+			 BIT(HWTSTAMP_TX_ON) |
+			 BIT(HWTSTAMP_TX_ONESTEP_SYNC) |
+			 BIT(HWTSTAMP_TX_ONESTEP_P2P);
+
+	info->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |
+			   BIT(HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |
+			   BIT(HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |
+			   BIT(HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |
+			   BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |
+			   BIT(HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |
+			   BIT(HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |
+			   BIT(HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |
+			   BIT(HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |
+			   BIT(HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ);
+
+	return 0;
+}
+#endif
+
+const struct ethtool_ops ax88179a_ethtool_ops = {
+#if KERNEL_VERSION(5, 7, 0) < LINUX_VERSION_CODE
+	.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,
+#endif
+	.get_drvinfo	= ax_get_drvinfo,
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+	.get_settings	= ax_get_settings,
+	.set_settings	= ax_set_settings,
+#else
+	.get_link_ksettings = ax_get_link_ksettings,
+	.set_link_ksettings = ax_set_link_ksettings,
+#endif
+	.get_link	= ethtool_op_get_link,
+	.get_msglevel	= ax_get_msglevel,
+	.set_msglevel	= ax_set_msglevel,
+	.get_wol	= ax_get_wol,
+	.set_wol	= ax_set_wol,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+	.get_eee	= ax88179a_get_eee,
+	.set_eee	= ax88179a_set_eee,
+#endif
+	.get_coalesce	= ax88179a_get_coalesce,
+	.set_coalesce	= ax88179a_set_coalesce,
+	.get_strings	= ax_get_strings,
+	.get_sset_count = ax_get_sset_count,
+	.get_ethtool_stats = ax_get_ethtool_stats,
+	.get_pauseparam = ax_get_pauseparam,
+	.set_pauseparam = ax_set_pauseparam,
+	.get_regs_len	= ax_get_regs_len,
+	.get_regs	= ax_get_regs,
+#ifdef ENABLE_PTP_FUNC
+	.get_ts_info	= ax88179a_set_wol_get_ts_info,
+#else
+	.get_ts_info	= ethtool_op_get_ts_info,
+#endif
+};
+
+#ifdef ENABLE_AX88279
+const struct ethtool_ops ax88279_ethtool_ops = {
+#if KERNEL_VERSION(5, 7, 0) < LINUX_VERSION_CODE
+	.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,
+#endif
+	.get_drvinfo	= ax_get_drvinfo,
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+	.get_settings	= ax_get_settings,
+	.set_settings	= ax_set_settings,
+#else
+	.get_link_ksettings = ax_get_link_ksettings,
+	.set_link_ksettings = ax_set_link_ksettings,
+#endif
+	.get_link	= ethtool_op_get_link,
+	.get_msglevel	= ax_get_msglevel,
+	.set_msglevel	= ax_set_msglevel,
+	.get_wol	= ax_get_wol,
+	.set_wol	= ax_set_wol,
+	.get_coalesce	= ax88179a_get_coalesce,
+	.set_coalesce	= ax88179a_set_coalesce,
+	.get_strings	= ax_get_strings,
+	.get_sset_count = ax_get_sset_count,
+	.get_ethtool_stats = ax_get_ethtool_stats,
+	.get_pauseparam = ax_get_pauseparam,
+	.set_pauseparam = ax_set_pauseparam,
+	.get_regs_len	= ax_get_regs_len,
+	.get_regs	= ax_get_regs,
+#ifdef ENABLE_PTP_FUNC
+	.get_ts_info	= ax88179a_set_wol_get_ts_info,
+#else
+	.get_ts_info	= ethtool_op_get_ts_info,
+#endif
+};
+#endif
+
+void ax88179a_get_fw_version(struct ax_device *axdev)
+{
+	int i;
+
+	for (i = 0; i < 3; i++) {
+		if (ax_read_cmd(axdev, AX88179A_ACCESS_BL, (0xFD + i),
+				1, 1, &axdev->fw_version[i], 1) < 0) {
+			axdev->fw_version[i] = ~0;
+		}
+	}
+
+	if (ax_read_cmd(axdev, AX88179A_ACCESS_BL, AX88179A_SW_REVERSION, 1, 1,
+			&axdev->fw_version[3], 0) < 0)
+		axdev->fw_version[3] = ~0;
+	else
+		axdev->fw_version[3] &= 0xF;
+}
+
+int ax88179a_signature(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	strncpy(info->sig, AX88179A_SIGNATURE, strlen(AX88179A_SIGNATURE));
+	return 0;
+}
+
+int ax88179a_read_version(struct ax_device *axdev,
+			  struct _ax_ioctl_command *info)
+{
+	unsigned char temp[16] = {0};
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	sprintf(temp, "v%d.%d.%d.%d",
+		axdev->fw_version[0], axdev->fw_version[1],
+		axdev->fw_version[2], axdev->fw_version[3]);
+
+	memcpy(&info->version.version, temp, 16);
+
+	return 0;
+}
+
+int ax88179a_write_flash(struct ax_device *axdev,
+			 struct _ax_ioctl_command *info)
+{
+	int i, ret;
+	u8 *buf = NULL;
+	u8 *block;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	buf = kzalloc(256, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	block = buf;
+
+	ret = ax_write_cmd(axdev, AX88179A_FLASH_WEN, 0, 0, 0, NULL);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash write enable failed");
+		info->flash.status = -ERR_FALSH_WRITE_EN;
+		goto out;
+	}
+
+	for (i = info->flash.offset;
+	     i < (info->flash.length + info->flash.offset);
+	     i += 256) {
+		if (copy_from_user(block,
+				   (void __user *)&info->flash.buf[i], 256)) {
+			netdev_err(axdev->netdev,
+				   "copy_from_user offset: 0x%x failed", i);
+			ret = -EFAULT;
+			goto out;
+		}
+
+		ret = ax_write_cmd(axdev, AX88179A_FLASH_WRITE,
+					(u16)((i >> 16) & 0xFFFF),
+					(u16)(i & 0xFFFF), 256, block);
+		if (ret < 0) {
+			netdev_err(axdev->netdev,
+				   "Flash write offset: 0x%x failed", i);
+			info->flash.status = -ERR_FALSH_WRITE;
+			goto out;
+		}
+	}
+
+	ret = ax_write_cmd(axdev, AX88179A_FLASH_WDIS, 0, 0, 0, NULL);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash write disable failed");
+		info->flash.status = -ERR_FALSH_WRITE_DIS;
+		return ret;
+	}
+out:
+	kfree(buf);
+
+	return ret;
+}
+
+int ax88179a_read_flash(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	int i, ret = 0;
+	void *buf = NULL;
+	u8 *block;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	buf = kzalloc(256, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	block = buf;
+
+	for (i = info->flash.offset;
+	     i < (info->flash.length + info->flash.offset);
+	     i += 256) {
+		ret = ax_read_cmd(axdev, AX88179A_FLASH_READ,
+				  (u16)((i >> 16) & 0xFFFF),
+				  (u16)(i & 0xFFFF), 256, block, 0);
+		if (ret < 0) {
+			netdev_err(axdev->netdev,
+				   "Flash read offset: 0x%x failed", i);
+			info->flash.status = -ERR_FALSH_READ;
+			break;
+		}
+
+		if (copy_to_user((void __user *)&info->flash.buf[i],
+				 block, 256)) {
+			netdev_err(axdev->netdev,
+				   "copy_to_user offset: 0x%x failed", i);
+			ret = -EFAULT;
+			break;
+		}
+	}
+
+	kfree(buf);
+
+	return ret;
+}
+
+int ax88179a_program_efuse(struct ax_device *axdev,
+			   struct _ax_ioctl_command *info)
+{
+	int ret = 0;
+	u16 offset = (u16)(info->flash.offset * 16);
+	u8 buf[20] = {0};
+
+	DEBUG_PRINTK("%s - Start offset: %d (0x%x)", __func__, offset, offset);
+
+	ret = copy_from_user(buf, (void __user *)info->flash.buf, 20);
+	if (ret) {
+		netdev_err(axdev->netdev,
+			   "copy_from_user efuse offset: 0x%x failed", offset);
+		return ret;
+	}
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_EFUSE, offset, 0, 20, buf);
+	if (ret < 0) {
+		netdev_err(axdev->netdev,
+			   "eFuse write offset: 0x%x failed", offset);
+		info->flash.status = -ERR_EFUSE_WRITE;
+		return ret;
+	}
+
+	return ret;
+}
+
+int ax88179a_dump_efuse(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	int ret = 0;
+	u16 offset = (u16)(info->flash.offset * 16);
+	u8 buf[20] = {0};
+
+	DEBUG_PRINTK("%s - Start offset: %d (0x%x)", __func__, offset, offset);
+
+	ret = ax_read_cmd(axdev, AX_ACCESS_EFUSE, offset, 0, 20, buf, 0);
+	if (ret < 0) {
+		netdev_err(axdev->netdev,
+			   "eFuse read offset: 0x%x failed", offset);
+		info->flash.status = -ERR_EFUSE_READ;
+		return ret;
+	}
+
+	ret = copy_to_user((void __user *)info->flash.buf, buf, 20);
+	if (ret) {
+		netdev_err(axdev->netdev,
+			   "copy_to_user efuse offset: 0x%x failed", offset);
+		return ret;
+	}
+
+	return ret;
+}
+
+int ax88179a_boot_to_rom(struct ax_device *axdev,
+			 struct _ax_ioctl_command *info)
+{
+	int ret;
+	u8 reg8;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8, 1);
+
+	ret = usb_control_msg(axdev->udev, usb_sndctrlpipe(axdev->udev, 0),
+			      AX88179A_BOOT_TO_ROM,
+			      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			      0x5A5A, 0xA5A5, NULL, 0, 1);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Booting to rom failed");
+		info->flash.status = -ERR_BOOT_CODE;
+		return ret;
+	}
+
+	return 0;
+}
+
+int ax88179a_erase_flash(struct ax_device *axdev,
+			 struct _ax_ioctl_command *info)
+{
+	int ret = 0;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	ret = ax_write_cmd(axdev, AX88179A_FLASH_WEN, 0, 0, 0, NULL);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash write enable failed");
+		info->flash.status = -ERR_FALSH_WRITE_EN;
+		return ret;
+	}
+
+	ret = usb_control_msg(axdev->udev, usb_sndctrlpipe(axdev->udev, 0),
+			      AX88179A_FLASH_EARSE_ALL,
+			      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			      0, 0, NULL, 0, 300000);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash erase all failed");
+		info->flash.status = -ERR_FALSH_ERASE_ALL;
+		return ret;
+	}
+
+	ret = ax_write_cmd(axdev, AX88179A_FLASH_WDIS, 0, 0, 0, NULL);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash write disable failed");
+		info->flash.status = -ERR_FALSH_WRITE_DIS;
+		return ret;
+	}
+
+	return 0;
+}
+
+int ax88179a_erase_sector_flash(struct ax_device *axdev,
+			 struct _ax_ioctl_command *info)
+{
+	int ret = 0;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	ret = ax_write_cmd(axdev, AX88179A_FLASH_WEN, 0, 0, 0, NULL);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash write enable failed");
+		info->flash.status = -ERR_FALSH_WRITE_EN;
+		return ret;
+	}
+
+	ret = usb_control_msg(axdev->udev, usb_sndctrlpipe(axdev->udev, 0),
+			      0x28,
+			      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			      (info->flash.offset >> 16) & 0xFFFF, info->flash.offset & 0xFFFF, NULL, 0, 300000);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash erase sector failed");
+		info->flash.status = -ERR_FALSH_ERASE_ALL;
+		return ret;
+	}
+
+	ret = ax_write_cmd(axdev, AX88179A_FLASH_WDIS, 0, 0, 0, NULL);
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Flash write disable failed");
+		info->flash.status = -ERR_FALSH_WRITE_DIS;
+		return ret;
+	}
+
+	return 0;
+}
+
+int ax88179a_sw_reset(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	void *buf = NULL;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	buf = kzalloc(sizeof(u32), GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+/*
+	*((u32 *)buf) = 1;
+
+	usb_control_msg(axdev->udev, usb_sndctrlpipe(axdev->udev, 0), 0x10,
+			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			0x18E8, 0x000F, buf, 4, 10);
+*/
+	*((u8 *)buf) = 0x41;
+
+	ax_write_cmd(axdev, 0x2A, 0xAA00, 0, 1, buf);
+
+	kfree(buf);
+
+	return 0;
+}
+
+#define _MDIO_WRITE(offset, value) \
+	ax_mdio_write(netdev, phy_id, offset, value)
+
+int ax88179a_ieee_test(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	struct net_device *netdev = axdev->netdev;
+	int phy_id = axdev->mii.phy_id;
+	int ret;
+
+	DEBUG_PRINTK("%s - Start", __func__);
+	DEBUG_PRINTK("Stop: %d", info->ieee.stop);
+	DEBUG_PRINTK("Speed: %d", info->ieee.speed);
+	DEBUG_PRINTK("Type: %d", info->ieee.type);
+
+	if (info->ieee.speed == 1000 && axdev->chip_pin == CHIP_32PIN) {
+		netdev_err(axdev->netdev, "Invalid Chip pin");
+		info->ieee.status = -ERR_IEEE_INVALID_CHIP;
+		return -EINVAL;
+	}
+
+	if (info->ieee.stop) {
+		ret = ax88179a_set_phy_power(axdev, false);
+		if (ret < 0)
+			return ret;
+		msleep(500);
+
+		ret = ax88179a_set_phy_power(axdev, true);
+		if (ret < 0)
+			return ret;
+		msleep(500);
+
+		switch (info->ieee.speed) {
+		case 1000:
+		case 100:
+			break;
+		case 10:
+			_MDIO_WRITE(0x00, 0x0100);
+			_MDIO_WRITE(0x0D, 0x001E);
+			_MDIO_WRITE(0x0E, 0x0145);
+			_MDIO_WRITE(0x0D, 0x401E);
+			_MDIO_WRITE(0x0E, 0x5010);
+			_MDIO_WRITE(0x0D, 0x001F);
+			_MDIO_WRITE(0x0E, 0x027B);
+			_MDIO_WRITE(0x0D, 0x401F);
+			_MDIO_WRITE(0x0E, 0x1177);
+			break;
+		default:
+			return -EINVAL;
+		};
+	} else {
+		switch (info->ieee.type) {
+		case IEEE_1000M1:
+			_MDIO_WRITE(0x09, 0x2700);
+			break;
+		case IEEE_1000M2:
+			_MDIO_WRITE(0x09, 0x4700);
+			break;
+		case IEEE_1000M3:
+			_MDIO_WRITE(0x09, 0x6700);
+			break;
+		case IEEE_1000M4:
+			_MDIO_WRITE(0x09, 0x8700);
+			break;
+		case IEEE_100CA:
+			_MDIO_WRITE(0x00, 0x2100);
+			_MDIO_WRITE(0x0D, 0x001E);
+			_MDIO_WRITE(0x0E, 0x0145);
+			_MDIO_WRITE(0x0D, 0x401E);
+			_MDIO_WRITE(0x0E, 0x5010);
+			break;
+		case IEEE_100CB:
+			_MDIO_WRITE(0x00, 0x2100);
+			_MDIO_WRITE(0x0D, 0x001E);
+			_MDIO_WRITE(0x0E, 0x0145);
+			_MDIO_WRITE(0x0D, 0x401E);
+			_MDIO_WRITE(0x0E, 0x5018);
+			break;
+		case IEEE_10R:
+			ret = ax88179a_set_phy_power(axdev, false);
+			if (ret < 0)
+				return ret;
+			msleep(100);
+
+			ret = ax88179a_set_phy_power(axdev, true);
+			if (ret < 0)
+				return ret;
+			_MDIO_WRITE(0x00, 0x0100);
+			_MDIO_WRITE(0x0D, 0x001E);
+			_MDIO_WRITE(0x0E, 0x0145);
+			_MDIO_WRITE(0x0D, 0x401E);
+			_MDIO_WRITE(0x0E, 0x5010);
+			_MDIO_WRITE(0x0D, 0x001F);
+			_MDIO_WRITE(0x0E, 0x027B);
+			_MDIO_WRITE(0x0D, 0x401F);
+			_MDIO_WRITE(0x0E, 0x1177);
+			_MDIO_WRITE(0x00, 0x0800);
+			_MDIO_WRITE(0x1F, 0x0001);
+			_MDIO_WRITE(0x1D, 0xF842);
+			ax_mmd_write(axdev->netdev, 0x1E, 0x01A3, 0x2);
+			ax_mmd_write(axdev->netdev, 0x1E, 0x01A4, 0x110e);
+			_MDIO_WRITE(0x1F, 0x0000);
+			_MDIO_WRITE(0x00, 0x0100);
+			break;
+		case IEEE_10FF:
+			ret = ax88179a_set_phy_power(axdev, false);
+			if (ret < 0)
+				return ret;
+			msleep(100);
+
+			ret = ax88179a_set_phy_power(axdev, true);
+			if (ret < 0)
+				return ret;
+			_MDIO_WRITE(0x00, 0x0100);
+			_MDIO_WRITE(0x0D, 0x001E);
+			_MDIO_WRITE(0x0E, 0x0145);
+			_MDIO_WRITE(0x0D, 0x401E);
+			_MDIO_WRITE(0x0E, 0x5010);
+			_MDIO_WRITE(0x0D, 0x001F);
+			_MDIO_WRITE(0x0E, 0x027B);
+			_MDIO_WRITE(0x0D, 0x401F);
+			_MDIO_WRITE(0x0E, 0x1177);
+			_MDIO_WRITE(0x00, 0x0800);
+			_MDIO_WRITE(0x1F, 0x0001);
+			_MDIO_WRITE(0x1D, 0xF840);
+			ax_mmd_write(axdev->netdev, 0x1E, 0x01A3, 0x0000);
+			_MDIO_WRITE(0x1F, 0x0000);
+			_MDIO_WRITE(0x00, 0x0100);
+			break;
+		case IEEE_10MDI:
+			_MDIO_WRITE(0x00, 0x0100);
+			_MDIO_WRITE(0x0D, 0x001E);
+			_MDIO_WRITE(0x0E, 0x0145);
+			_MDIO_WRITE(0x0D, 0x401E);
+			_MDIO_WRITE(0x0E, 0x5010);
+			_MDIO_WRITE(0x0D, 0x001F);
+			_MDIO_WRITE(0x0E, 0x027B);
+			_MDIO_WRITE(0x0D, 0x401F);
+			_MDIO_WRITE(0x0E, 0x1177);
+			break;
+		default:
+			return -EINVAL;
+		};
+	}
+
+	return 0;
+}
+
+int ax88179a_autosuspend_en(struct ax_device *axdev,
+			    struct _ax_ioctl_command *info)
+{
+	DEBUG_PRINTK("%s - Start", __func__);
+
+	if (axdev->autosuspend_is_supported) {
+		if (info->autosuspend.enable)
+			usb_enable_autosuspend(axdev->udev);
+		else
+			usb_disable_autosuspend(axdev->udev);
+	}
+
+	return 0;
+}
+
+IOCTRL_TABLE ax88179a_tbl[] = {
+	ax88179a_signature,
+	ax_usb_command,
+	ax88179a_read_version,
+	ax88179a_write_flash,
+	ax88179a_boot_to_rom,
+	ax88179a_erase_flash,
+	ax88179a_sw_reset,
+	ax88179a_read_flash,
+	ax88179a_program_efuse,
+	ax88179a_dump_efuse,
+	ax88179a_ieee_test,
+	ax88179a_autosuspend_en,
+	ax88179a_erase_sector_flash,
+};
+
+#ifdef ENABLE_PTP_FUNC
+static int ax88179a_hwtstamp_ioctl
+(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct hwtstamp_config config;
+
+	if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+		return -EFAULT;
+
+	if (config.flags)
+		return -EINVAL;
+
+	switch (config.rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		break;
+	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+	case HWTSTAMP_FILTER_ALL:
+	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+		config.rx_filter = HWTSTAMP_FILTER_ALL;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
+		-EFAULT : 0;
+}
+#endif
+
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+int ax88179a_siocdevprivate(struct net_device *netdev, struct ifreq *rq,
+			    void __user *udata, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	struct _ax_ioctl_command info;
+	void __user *uptr = (void __user *) rq->ifr_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case AX_PRIVATE:
+		if (copy_from_user(&info, uptr,
+				   sizeof(struct _ax_ioctl_command))) {
+			netdev_err(netdev, "copy_from_user, return -EFAULT");
+			return -EFAULT;
+		}
+		DEBUG_PRINTK("ioctl_cmd: %d", info.ioctl_cmd);
+		ret = (*ax88179a_tbl[info.ioctl_cmd])(axdev, &info);
+		if (ret < 0)
+			netdev_err(netdev, "ax88179a_tbl, return %d", ret);
+
+		if (copy_to_user(uptr, &info,
+				 sizeof(struct _ax_ioctl_command))) {
+			netdev_err(netdev, "copy_to_user failed");
+			return ret;
+		}
+
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+int ax88179a_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	switch (cmd) {
+#ifdef ENABLE_PTP_FUNC
+	case SIOCSHWTSTAMP:
+		return ax88179a_hwtstamp_ioctl(netdev, rq, cmd);
+#endif
+	}
+	return generic_mii_ioctl(&axdev->mii, if_mii(rq), cmd, NULL);
+}
+#else
+int ax88179a_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	struct _ax_ioctl_command info;
+	void __user *uptr = (void __user *) rq->ifr_data;
+	int ret;
+
+	switch (cmd) {
+	case AX_PRIVATE:
+		if (copy_from_user(&info, uptr,
+				   sizeof(struct _ax_ioctl_command))) {
+			netdev_err(netdev, "copy_from_user, return -EFAULT");
+			return -EFAULT;
+		}
+		DEBUG_PRINTK("ioctl_cmd: %d", info.ioctl_cmd);
+		ret = (*ax88179a_tbl[info.ioctl_cmd])(axdev, &info);
+		if (ret < 0) {
+			netdev_err(netdev, "ax88179a_tbl, return %d", ret);
+			return ret;
+		}
+
+		if (copy_to_user(uptr, &info,
+				 sizeof(struct _ax_ioctl_command))) {
+			netdev_err(netdev, "copy_to_user, return -EFAULT");
+			return -EFAULT;
+		}
+
+		break;
+#ifdef ENABLE_PTP_FUNC
+	case SIOCSHWTSTAMP:
+		return ax88179a_hwtstamp_ioctl(netdev, rq, cmd);
+#endif
+	default:
+		return generic_mii_ioctl(&axdev->mii, if_mii(rq), cmd, NULL);
+	}
+	return 0;
+}
+#endif
+
+static int ax88179a_autodetach(struct ax_device *axdev)
+{
+	u16 value = ((axdev->autodetach) ? 1 : 0) | AX88179A_AUTODETACH_DELAY;
+
+	return ax_write_cmd(axdev, AX88179A_AUTODETACH, value, 0, 0, NULL);
+}
+
+static bool ax88179a_check_phy_power(struct ax_device *axdev)
+{
+	u8 reg8 = 0;
+	int ret = 0;
+
+	ret = ax_read_cmd_nopm(axdev, AX88179A_PHY_POWER, 0, 0, 1, &reg8, 1);
+	if (ret < 0)
+		return false;
+
+	return (reg8 & AX_PHY_POWER);
+}
+
+static int ax88179a_set_phy_power(struct ax_device *axdev, bool on)
+{
+	u8 reg8;
+	int ret;
+
+	reg8 = (on)?AX_PHY_POWER:0;
+	ret = ax_write_cmd_nopm(axdev, AX88179A_PHY_POWER, 0, 0, 1, &reg8);
+	if (ret < 0)
+		return ret;
+	msleep(250);
+#ifdef ENABLE_INT_AGGRESSIVE
+	if (on) {
+		u16 reg16;
+		printk("ENABLE_INT_AGGRESSIVE");
+		ax_write_cmd(axdev, 0x32, 0x3, 0, 0, &reg16);
+	}
+#endif
+	return 0;
+}
+
+static int ax88179a_bind(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+	u16 wvalue = 0;
+	int ret;
+
+	ax88179a_get_fw_version(axdev);
+#ifdef ENABLE_AX88279
+	if (axdev->chip_version == AX_VERSION_AX88279)
+		PRINT_VERSION(axdev, AX_DRIVER_STRING_279);
+	else
+		PRINT_VERSION(axdev, AX_DRIVER_STRING_179A_772D);
+#else
+	PRINT_VERSION(axdev, AX_DRIVER_STRING_179A_772D);
+#endif
+
+#ifdef ENABLE_QUEUE_PRIORITY
+	wvalue |= AX_USB_EP5_EN;
+#endif
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_PTP_FUNC
+	wvalue |= AX_USB_EP4_EN;
+#endif
+#endif
+	ret = ax_write_cmd(axdev, AX_FW_MODE, AX_FW_MODE_179A, wvalue, 0, NULL);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_write_cmd(axdev, AX_RELOAD_FLASH_EFUSE, 0, 0, 0, NULL);
+	if (ret < 0)
+		return ret;
+
+	netdev->features    |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+			       NETIF_F_SG | NETIF_F_TSO | NETIF_F_FRAGLIST |
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+					NETIF_F_HW_VLAN_CTAG_RX |
+					NETIF_F_HW_VLAN_CTAG_TX;
+#else
+					NETIF_F_HW_VLAN_RX |
+					NETIF_F_HW_VLAN_TX;
+#endif
+	netdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+			       NETIF_F_SG | NETIF_F_TSO | NETIF_F_FRAGLIST |
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+					NETIF_F_HW_VLAN_CTAG_RX |
+					NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_RXALL;
+#else
+					NETIF_F_HW_VLAN_RX |
+					NETIF_F_HW_VLAN_TX | NETIF_F_RXALL;
+#endif
+
+		netdev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
+				NETIF_F_HIGHDMA | NETIF_F_FRAGLIST |
+				NETIF_F_IPV6_CSUM;
+
+	netdev->max_mtu = (9 * 1024);
+	axdev->tx_casecade_size = TX_CASECADES_SIZE;
+	axdev->gso_max_size = AX_GSO_DEFAULT_SIZE;
+	axdev->mii.supports_gmii = true;
+	axdev->mii.dev = netdev;
+	axdev->mii.mdio_read = ax_mdio_read;
+	axdev->mii.mdio_write = ax_mdio_write;
+	axdev->mii.phy_id_mask = 0x3F;
+	axdev->mii.reg_num_mask = 0x1F;
+	axdev->mii.phy_id = AX88179A_PHY_ID;
+#if KERNEL_VERSION(5, 19, 0) <= LINUX_VERSION_CODE
+	netif_set_tso_max_size(netdev, axdev->gso_max_size);
+#else
+	netif_set_gso_max_size(netdev, axdev->gso_max_size);
+#endif
+	axdev->bin_setting.custom = false;
+	axdev->tx_align_len = 8;
+	axdev->coalesce = 0;
+#ifdef ENABLE_AX88279
+	if (axdev->chip_version == AX_VERSION_AX88279) {
+		netdev->ethtool_ops = &ax88279_ethtool_ops;
+	} else {
+		netdev->ethtool_ops = &ax88179a_ethtool_ops;
+	}
+#else
+	netdev->ethtool_ops = &ax88179a_ethtool_ops;
+#endif
+	
+	axdev->netdev->netdev_ops = &ax88179a_netdev_ops;
+
+#ifdef ENABLE_PTP_FUNC
+	ret = ax_ptp_register(axdev);
+	if (ret < 0)
+		netdev_warn(netdev,
+			    "Failed to register PHC device. (%d)\n", ret);
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+	ret = ax_macsec_register(axdev);
+	if (ret < 0)
+		netdev_warn(netdev,
+			    "Failed to register MACsec feature. (%d)\n", ret);
+#endif
+
+#ifdef ENABLE_AUTOSUSPEND
+	axdev->autosuspend_is_supported = true;
+	usb_enable_autosuspend(axdev->udev);
+#else
+	axdev->autosuspend_is_supported = false;
+	usb_disable_autosuspend(axdev->udev);
+#endif
+
+	return ret;
+}
+
+static void ax88179a_unbind(struct ax_device *axdev)
+{
+#ifdef ENABLE_PTP_FUNC
+	ax_ptp_unregister(axdev);
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+	ax_macsec_unregister(axdev);
+#endif
+}
+
+static int ax88179a_stop(struct ax_device *axdev)
+{
+	u16 reg16;
+
+	reg16 = AX_RX_CTL_STOP;
+	ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2, &reg16);
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_PTP_FUNC
+	ax88279_stop_get_ts(axdev);
+#endif
+#endif
+
+	ax88179a_set_phy_power(axdev, false);
+
+	return 0;
+}
+
+void ax88179a_set_multicast(struct net_device *netdev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u8 *m_filter = axdev->m_filter;
+	int mc_count = 0;
+
+	if (!test_bit(AX_ENABLE, &axdev->flags))
+		return;
+
+#if KERNEL_VERSION(2, 6, 35) > LINUX_VERSION_CODE
+	mc_count = net->mc_count;
+#else
+	mc_count = netdev_mc_count(netdev);
+#endif
+
+	axdev->rxctl = (AX_RX_CTL_START | AX_RX_CTL_AB);
+#ifdef ENABLE_AX88279
+	if (axdev->chip_version == AX_VERSION_AX88279)
+		axdev->rxctl |= AX_RX_CTL_DROPCRCERR;
+#endif
+
+	if (netdev->flags & IFF_PROMISC) {
+		axdev->rxctl |= AX_RX_CTL_PRO;
+	} else if (netdev->flags & IFF_ALLMULTI || mc_count > AX_MAX_MCAST) {
+		axdev->rxctl |= AX_RX_CTL_AMALL;
+	} else if (netdev_mc_empty(netdev)) {
+	} else {
+		u32 crc_bits;
+#if KERNEL_VERSION(2, 6, 35) > LINUX_VERSION_CODE
+		struct dev_mc_list *mc_list = netdev->mc_list;
+		int i = 0;
+
+		memset(m_filter, 0, AX_MCAST_FILTER_SIZE);
+		for (i = 0; i < netdev->mc_count; i++) {
+			crc_bits =
+			    ether_crc(ETH_ALEN,
+				      mc_list->dmi_addr) >> 26;
+			*(m_filter + (crc_bits >> 3)) |=
+				1 << (crc_bits & 7);
+			mc_list = mc_list->next;
+		}
+#else
+		struct netdev_hw_addr *ha = NULL;
+
+		memset(m_filter, 0, AX_MCAST_FILTER_SIZE);
+		netdev_for_each_mc_addr(ha, netdev) {
+			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			*(m_filter + (crc_bits >> 3)) |= 1 << (crc_bits & 7);
+		}
+#endif
+		ax_write_cmd_async(axdev, AX_ACCESS_MAC, AX_MULTI_FILTER_ARRY,
+				   AX_MCAST_FILTER_SIZE, AX_MCAST_FILTER_SIZE,
+				   m_filter);
+
+		axdev->rxctl |= AX_RX_CTL_AM;
+	}
+
+	ax_write_cmd_async(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+			   2, 2, &axdev->rxctl);
+}
+
+static int ax88179a_hw_init(struct ax_device *axdev)
+{
+	u16 reg16;
+	u8 reg8;
+	int ret;
+
+#ifdef ENABLE_AX88279
+	if (axdev->chip_version != AX_VERSION_AX88279) {
+		u32 reg32 = 0;
+		ret = ax_read_cmd(axdev, AX88179A_PBUS_REG,0x18C8, 0, 4,
+				  &reg32, 1);
+		if (ret < 0)
+			return ret;
+		axdev->chip_pin = reg32 & 0x03;
+	}
+#endif
+	ret = ax88179a_set_phy_power(axdev, true);
+	if (ret < 0)
+		return ret;
+	msleep(250);
+
+#ifdef ENABLE_AX88279
+	if (axdev->chip_version == AX_VERSION_AX88279) {
+#ifdef ENABLE_AX88279_MINIP_2_5G
+		do {
+			int i;
+
+			ax_mmd_write(axdev->netdev, 0x07, 0, 0x2000);
+			for (i = 0; i < 1000; i++) {
+				reg16 = ax_mmd_read(axdev->netdev, 0x07, 0x10);
+				ax_mmd_write(axdev->netdev, 0x07, 0x10,
+						(reg16 | 0x0C00));
+				reg16 = ax_mmd_read(axdev->netdev, 0x07, 0x10);
+				if (reg16 & 0x0C00)
+					break;
+			}
+			ax_mmd_write(axdev->netdev, 0x07, 0xC400, 0x1453);
+			ax_mmd_write(axdev->netdev, 0x07, 0x20, 0x1);
+			ax_mmd_write(axdev->netdev, 0x07, 0, 0x3200);
+		} while (0);
+#else
+		reg16 = ax_mdio_read(axdev->netdev, axdev->mii.phy_id,
+				     MII_ADVERTISE);
+		reg16 &= ~(ADVERTISE_10FULL | ADVERTISE_10HALF);
+		ax_mdio_write(axdev->netdev, axdev->mii.phy_id, MII_ADVERTISE,
+			      (reg16 | ADVERTISE_RESV));
+		reg16 = ax_mdio_read(axdev->netdev, axdev->mii.phy_id,
+				     MII_CTRL1000);
+		ax_mdio_write(axdev->netdev, axdev->mii.phy_id, MII_CTRL1000,
+			      (reg16 | CTL1000_AS_MASTER));
+		ax_mdio_write(axdev->netdev, axdev->mii.phy_id, 0,
+			      (BMCR_ANRESTART | BMCR_ANENABLE));
+#endif
+	}
+#endif
+	ret = ax88179a_autodetach(axdev);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_TXCOE_IP | AX_TXCOE_TCP | AX_TXCOE_UDP |
+	       AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
+	       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_MAC_EFF_EN;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_BULK_OUT_CTRL,
+			    1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg16 = 0;
+	ret = ax_write_cmd_async(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0x04;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_LOW,
+			   1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0x10;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,
+			   1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		if (axdev->netdev->features & NETIF_F_HW_VLAN_CTAG_FILTER)
+#else
+		if (axdev->netdev->features & NETIF_F_HW_VLAN_FILTER)
+#endif		
+		reg8 |= AX_VLAN_CONTROL_VFE;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		if (axdev->netdev->features & NETIF_F_HW_VLAN_CTAG_RX)
+#else
+		if (axdev->netdev->features & NETIF_F_HW_VLAN_RX)
+#endif		
+	reg8 |= AX_VLAN_CONTROL_VSO;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_VLAN_ID_CONTROL,
+			   1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0xff;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_BM_INT_MASK,
+			    1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_BM_RX_DMA_CTL,
+			    1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_BM_TX_DMA_CTL,
+			    1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_ARC_CTRL,
+			    1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_SWP_CTRL,
+			    1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+
+	reg8 = AX_TXHDR_CKSUM_EN;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_TX_HDR_CKSUM,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg16 = AX_RX_CTL_START | AX_RX_CTL_AP | AX_RX_CTL_AMALL |
+		AX_RX_CTL_AB | AX_RX_CTL_DROPCRCERR;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_RX_CTL, 1, 1, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8, 1);
+	if (ret < 0)
+		return ret;
+	reg8 &= 0xE0;
+	reg8 |= AX_MONITOR_MODE_RWMP;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+
+	ret = ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				 2, 2, &reg16, 2);
+	if (ret < 0)
+		return ret;
+
+	reg16 &= ~AX_MEDIUM_GIGAMODE;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			    2, 2, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg16 |= AX_MEDIUM_GIGAMODE;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			    2, 2, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_BFM_DATA, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_CDC_ECM_CTRL,
+			   1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	ax_set_tx_qlen(axdev);
+
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_PTP_FUNC
+	ax88279_start_get_ts(axdev);
+#endif
+#endif
+
+	return ret;
+}
+
+static int ax88179a_get_ether_link(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+	struct ethtool_cmd cmd;
+
+	mii_ethtool_gset(&axdev->mii, &cmd);
+	switch (ethtool_cmd_speed(&cmd)) {
+	case SPEED_1000:
+		link_info->eth_speed = ETHER_LINK_1000;
+		break;
+	case SPEED_100:
+		link_info->eth_speed = ETHER_LINK_100;
+		break;
+	case SPEED_10:
+	default:
+		link_info->eth_speed = ETHER_LINK_10;
+		break;
+	};
+
+	link_info->full_duplex = cmd.duplex;
+#else
+	struct ethtool_link_ksettings cmd;
+
+	mii_ethtool_get_link_ksettings(&axdev->mii, &cmd);
+	switch (cmd.base.speed) {
+	case SPEED_1000:
+		link_info->eth_speed = ETHER_LINK_1000;
+		break;
+	case SPEED_100:
+		link_info->eth_speed = ETHER_LINK_100;
+		break;
+	case SPEED_10:
+	default:
+		link_info->eth_speed = ETHER_LINK_10;
+		break;
+	};
+
+	link_info->full_duplex = cmd.base.duplex;
+#endif
+	return 0;
+}
+
+static int ax88179a_set_bulkin_setting(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u8 link_sts;
+	int index = 0, ret;
+
+	ret = ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, PHYSICAL_LINK_STATUS,
+			       1, 1, &link_sts, 0);
+	if (ret < 0)
+		return ret;
+
+	switch (link_info->eth_speed) {
+	case ETHER_LINK_1000:
+		if (link_sts & AX_USB_SS)
+			index = 0;
+		else if (link_sts & AX_USB_HS)
+			index = 1;
+		break;
+	case ETHER_LINK_100:
+		if (link_sts & AX_USB_SS)
+			index = 2;
+		else if (link_sts & AX_USB_HS)
+			index = 4;
+
+		if (!link_info->full_duplex)
+			index++;
+		break;
+	case ETHER_LINK_10:
+		index = 6;
+		break;
+	case ETHER_LINK_NONE:
+	default:
+		index = 0;
+		break;
+	};
+
+	if (axdev->coalesce == 0) {
+		u16 timer = *((u16 *)&AX88179A_BULKIN_SIZE[index].timer_l);
+
+		axdev->coalesce = ax88179a_bin_timer_to_usec(axdev, timer);
+	} else {
+		u16 timer = ax88179a_usec_to_bin_timer(axdev);
+
+		AX88179A_BULKIN_SIZE[index].timer_l = timer & 0xFF;
+		AX88179A_BULKIN_SIZE[index].timer_h = (timer >> 8) & 0xFF;
+	}
+
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL,
+				5, 5, &AX88179A_BULKIN_SIZE[index]);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ax88179a_link_setting(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u16 medium_mode, reg16;
+	u8 reg8[3];
+	int ret;
+
+	reg16 = AX_RX_CTL_STOP;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH,
+				1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0xA5;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_CDC_DELAY_TX,
+				 1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0x10;
+	reg8[1] = 0x04;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,
+				2, 2, reg8);
+	if (ret < 0)
+		return ret;
+
+	medium_mode = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_RXFLOW_CTRLEN |
+		      AX_MEDIUM_TXFLOW_CTRLEN;
+	reg8[0] = 0x28 | AX_NEW_PAUSE_EN;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_NEW_PAUSE_CTRL,
+			   1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	switch (link_info->eth_speed) {
+	case ETHER_LINK_1000:
+	case ETHER_LINK_100:
+		reg8[0] = 0x78;
+		reg8[1] = (AX_LSOFC_WCNT_7_ACCESS << 5) | AX_GMII_CRC_APPEND;
+		reg8[2] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_STATUS_CDC, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x40;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_DATA_CDC_CNT,
+					1, 1, reg8);
+		if (ret < 0)
+			return ret;
+		if (link_info->eth_speed == ETHER_LINK_1000)
+			medium_mode |= AX_MEDIUM_GIGAMODE;
+		break;
+	case ETHER_LINK_10:
+		reg8[0] = 0xFA;
+		reg8[1] = (AX_LSOFC_WCNT_7_ACCESS << 5) | AX_GMII_CRC_APPEND;
+		reg8[2] = 0xFF;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_STATUS_CDC, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0xFA;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_DATA_CDC_CNT,
+					1, 1, reg8);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		break;
+	};
+
+	reg8[0] = 0;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_BFM_DATA,
+				1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	ret = ax88179a_set_bulkin_setting(axdev);
+	if (ret < 0)
+		return ret;
+
+	if (link_info->full_duplex)
+		medium_mode |= AX_MEDIUM_FULL_DUPLEX;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				2, 2, &medium_mode);
+	if (ret < 0)
+		return ret;
+
+	axdev->rxctl |= AX_RX_CTL_START | AX_RX_CTL_AB;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				2, 2, &axdev->rxctl);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = AX_MAC_RX_PATH_READY | AX_MAC_TX_PATH_READY;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH,
+				1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+#ifdef ENABLE_QUEUE_PRIORITY
+static int ax88179a_queue_priority(struct ax_device *axdev)
+{
+	u8 reg8;
+	int ret;
+
+	reg8 = AX_RX_CTL_STOP;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_MAC_PATH, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	axdev->rxctl |= AX_RX_CTL_START | AX_RX_CTL_AB;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				2, 2, &axdev->rxctl);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX88179A_HIGH_QUEUE_POINT;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_MAC_QUEUE_POINT, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_TX_QUEUE_CFG | AX_TX_QUEUE_SET;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_BFM_DATA,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_TX_Q1_AHB_FC_EN | AX_TX_QUEUE_CFG;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_BFM_DATA,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_MAC_STOP_EP5_ACCESS;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_BFM_CTRL,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_MAC_RX_PATH_READY | AX_MAC_TX_PATH_READY;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+#endif
+
+static int ax88179a_link_reset(struct ax_device *axdev)
+{
+	int ret;
+
+	ret = ax88179a_get_ether_link(axdev);
+	if (ret < 0)
+		return ret;
+
+	ret = ax88179a_link_setting(axdev);
+	if (ret < 0)
+		return ret;
+
+#ifdef ENABLE_QUEUE_PRIORITY
+	ret = axdev->driver_info->queue_priority(axdev);
+	if (ret < 0)
+		return ret;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+	axdev->eee_enabled = ax88179a_chk_eee(axdev);
+	ax88179a_eee_setting(axdev, axdev->eee_enabled);
+#endif
+
+#ifdef ENABLE_PTP_FUNC
+	if (axdev->driver_info->ptp_init)
+		axdev->driver_info->ptp_init(axdev);
+#endif
+
+#ifdef ENABLE_MACSEC_FUNC
+	if (axdev->driver_info->macsec_init)
+		axdev->driver_info->macsec_init(axdev);
+#endif
+
+	return 0;
+}
+#ifdef ENABLE_AX88279
+static int ax88279_get_ether_link(struct ax_device *axdev)
+{
+	ax88179a_get_ether_link(axdev);
+
+	if (axdev->chip_version >= AX_VERSION_AX88279) {
+		if (axdev->intr_link_info.eth_speed == ETHER_LINK_2500) {
+			axdev->link_info.eth_speed = ETHER_LINK_2500;
+			axdev->link_info.full_duplex = true;
+		}
+	}
+
+	return 0;
+}
+
+static int ax88279_set_bulkin_setting(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u8 link_sts;
+	int index, ret;
+
+	ret = ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, PHYSICAL_LINK_STATUS,
+			       1, 1, &link_sts, 0);
+	if (ret < 0)
+		return ret;
+
+	if (link_sts & AX_USB_FS) {
+		index = 7;
+	} else {
+		switch (link_info->eth_speed) {
+		case ETHER_LINK_2500:
+			index = 0;
+			break;
+		case ETHER_LINK_1000:
+			if (link_sts & AX_USB_SS)
+				index = 1;
+			else if (link_sts & AX_USB_HS)
+				index = 2;
+			break;
+		case ETHER_LINK_100:
+			if (link_sts & AX_USB_SS)
+				index = 3;
+			else if (link_sts & AX_USB_HS)
+				index = 5;
+
+			if (!link_info->full_duplex)
+				index++;
+			break;
+		case ETHER_LINK_10:
+			break;
+		default:
+			return -1;
+		};
+	}
+
+	if (axdev->coalesce == 0) {
+		u16 timer = *((u16 *)&AX88279_BULKIN_SIZE[index].timer_l);
+
+		axdev->coalesce = ax88179a_bin_timer_to_usec(axdev, timer);
+	} else {
+		u16 timer = ax88179a_usec_to_bin_timer(axdev);
+
+		AX88179A_BULKIN_SIZE[index].timer_l = timer & 0xFF;
+		AX88179A_BULKIN_SIZE[index].timer_h = (timer >> 8) & 0xFF;
+	}
+
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL,
+				5, 5, &AX88279_BULKIN_SIZE[index]);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ax88279_link_setting(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u16 medium_mode, reg16;
+	u8 reg8[3];
+	int ret;
+
+	reg16 = AX_RX_CTL_STOP;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg16 = 0;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH,
+				1, 1, &reg16);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0xA5;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_MAC_CDC_DELAY_TX, 1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0x10;
+	reg8[1] = 0x04;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX_PAUSE_WATERLVL_HIGH, 2, 2, reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_ETH_TX_GAP, 1, 1, reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8[0] = 0x07;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_EP5_EHR, 1, 1,
+				&reg8);
+	if (ret < 0)
+		return ret;
+
+	medium_mode = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_RXFLOW_CTRLEN |
+		      AX_MEDIUM_TXFLOW_CTRLEN;
+	reg8[0] = 0x28 | AX_NEW_PAUSE_EN;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX88179A_NEW_PAUSE_CTRL,
+			   1, 1, reg8);
+	if (ret < 0)
+		return ret;
+	switch (link_info->eth_speed) {
+	case ETHER_LINK_2500:
+		reg8[0] = 0x00;
+		reg8[1] = 0xF8;
+		reg8[2] = 0x07;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_TX_PAUSE_0, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x78;
+		reg8[1] = (AX_LSOFC_WCNT_7_ACCESS << 5);
+		reg8[2] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_STATUS_CDC, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x40;
+		reg8[1] = AX_MAC_MIQFFCTRL_FORMAT | AX_MAC_MIQFFCTRL_DROP_CRC |
+			  AX_MAC_LSO_ERR_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_DATA_CDC_CNT,
+					2, 2, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = AX_XGMII_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					 AX88179A_BFM_DATA, 1, 1, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = (0x1C) | AX_LSO_ENHANCE_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_LSO_ENHANCE_CTRL, 1, 1,
+					&reg8);
+		if (ret < 0)
+			return ret;
+
+		medium_mode |= AX_MEDIUM_GIGAMODE;
+		break;
+	case ETHER_LINK_1000:
+		reg8[0] = 0x48;
+		reg8[1] = 0xF1;
+		reg8[2] = 0x3E;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					 AX88179A_MAC_TX_PAUSE_0, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x78;
+		reg8[1] = (AX_LSOFC_WCNT_7_ACCESS << 5);
+		reg8[2] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_STATUS_CDC, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x40;
+		reg8[1] = AX_MAC_MIQFFCTRL_FORMAT | AX_MAC_MIQFFCTRL_DROP_CRC |
+			  AX_MAC_LSO_ERR_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_DATA_CDC_CNT,
+					2, 2, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					 AX88179A_BFM_DATA, 1, 1, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_LSO_ENHANCE_CTRL, 1, 1,
+					&reg8);
+		if (ret < 0)
+			return ret;
+
+
+		medium_mode |= AX_MEDIUM_GIGAMODE;
+		break;
+	case ETHER_LINK_100:
+		reg8[0] = 0x90;
+		reg8[1] = 0xE2;
+		reg8[2] = 0x7D;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					 AX88179A_MAC_TX_PAUSE_0, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x78;
+		reg8[1] = (AX_LSOFC_WCNT_7_ACCESS << 5);
+		reg8[2] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_STATUS_CDC, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0x40;
+		reg8[1] = AX_MAC_MIQFFCTRL_FORMAT | AX_MAC_MIQFFCTRL_DROP_CRC |
+			  AX_MAC_LSO_ERR_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_DATA_CDC_CNT,
+					2, 2, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_BFM_DATA, 1, 1, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_LSO_ENHANCE_CTRL, 1, 1,
+					&reg8);
+		if (ret < 0)
+			return ret;
+		break;
+	case ETHER_LINK_10:
+		reg8[0] = 0x90;
+		reg8[1] = 0xE2;
+		reg8[2] = 0x7D;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_TX_PAUSE_0, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0xFA;
+		reg8[1] = (AX_LSOFC_WCNT_7_ACCESS << 5);
+		reg8[2] = 0xFF;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_STATUS_CDC, 3, 3, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0xFA;
+		reg8[1] = AX_MAC_MIQFFCTRL_FORMAT | AX_MAC_MIQFFCTRL_DROP_CRC |
+			  AX_MAC_LSO_ERR_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_RX_DATA_CDC_CNT,
+					2, 2, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_BFM_DATA, 1, 1, reg8);
+		if (ret < 0)
+			return ret;
+
+		reg8[0] = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_LSO_ENHANCE_CTRL, 1, 1,
+					&reg8);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		break;
+	};
+
+	ret = ax88279_set_bulkin_setting(axdev);
+	if (ret < 0)
+		return ret;
+
+	if (link_info->full_duplex)
+		medium_mode |= AX_MEDIUM_FULL_DUPLEX;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				2, 2, &medium_mode);
+	if (ret < 0)
+		return ret;
+
+	axdev->rxctl |= AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_CTL_DROPCRCERR;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				2, 2, &axdev->rxctl);
+	if (ret < 0)
+		return ret;
+
+	reg16 = AX_MAC_RX_PATH_READY | AX_MAC_TX_PATH_READY;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH,
+				1, 1, &reg16);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+#ifdef ENABLE_QUEUE_PRIORITY
+static int ax88279_queue_setting(struct ax_device *axdev)
+{
+	u8 reg8;
+	int ret;
+
+	reg8 = AX_RX_CTL_STOP;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = 0;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_MAC_PATH, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	axdev->rxctl |= AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_CTL_DROPCRCERR;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				2, 2, &axdev->rxctl);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX88279_HIGH_QUEUE_POINT;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_MAC_QUEUE_POINT, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_TX_QUEUE_SET | AX_TX_QUEUE_CFG;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_BFM_DATA,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_MAC_MIQFFCTRL_FORMAT | AX_MAC_MIQFFCTRL_DROP_CRC |
+	       AX_MAC_STOP_EP5_ACCESS | AX_MAC_STOP_EP3_ACCESS |
+	       AX_MAC_LSO_ERR_EN;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				AX88179A_MAC_BFM_CTRL, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_EP5_DAT_ERROR_HANDLE;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_EP5_EHR,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	switch (axdev->link_info.eth_speed) {
+	case ETHER_LINK_2500:
+		reg8 = AX_TX_QUEUE_CFG | AX_TX_Q1_AHB_FC_EN |
+		       AX_XGMII_EN | AX_TX_Q2_AHB_FC_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_BFM_DATA, 1, 1, &reg8);
+		if (ret < 0)
+			return ret;
+		break;
+	case ETHER_LINK_1000:
+	case ETHER_LINK_100:
+		reg8 = AX_TX_QUEUE_CFG | AX_TX_Q1_AHB_FC_EN |
+		       AX_TX_Q2_AHB_FC_EN;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_BFM_DATA, 1, 1, &reg8);
+		if (ret < 0)
+			return ret;
+		break;
+	case ETHER_LINK_10:
+		reg8 = 0;
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_MAC_QUEUE_POINT, 1, 1, &reg8);
+		if (ret < 0)
+			return ret;
+
+		ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+					AX88179A_BFM_DATA, 1, 1, &reg8);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		break;
+	};
+
+	reg8 = AX_MAC_RX_PATH_READY | AX_MAC_TX_PATH_READY;
+	ret = ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH,
+				1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+#endif
+
+static int ax88279_link_reset(struct ax_device *axdev)
+{
+	int ret;
+
+	ret = ax88279_get_ether_link(axdev);
+	if (ret < 0)
+		return ret;
+
+	ret = ax88279_link_setting(axdev);
+	if (ret < 0)
+		return ret;
+
+#ifdef ENABLE_QUEUE_PRIORITY
+	ret = axdev->driver_info->queue_priority(axdev);
+	if (ret < 0)
+		return ret;
+#endif
+
+#ifdef ENABLE_PTP_FUNC
+	if (axdev->driver_info->ptp_init)
+		axdev->driver_info->ptp_init(axdev);
+#endif
+
+#ifdef ENABLE_MACSEC_FUNC
+	if (axdev->driver_info->macsec_init)
+		axdev->driver_info->macsec_init(axdev);
+#endif
+
+	return 0;
+}
+#endif
+inline void ax88179a_rx_checksum(struct sk_buff *skb, void *pkt_hdr)
+{
+	struct _179a_rx_pkt_header *hdr = (struct _179a_rx_pkt_header *)pkt_hdr;
+
+	skb->ip_summed = CHECKSUM_NONE;
+
+	if ((hdr->L4_err) ||
+	    (hdr->L3_err))
+		return;
+
+	if ((hdr->L4_pkt_type == AX_RXHDR_L4_TYPE_TCP) ||
+	    (hdr->L4_pkt_type == AX_RXHDR_L4_TYPE_UDP))
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+}
+
+static void ax88179a_rx_fixup(struct ax_device *axdev, struct rx_desc *desc,
+			      int *work_done, int budget)
+{
+#ifndef ENABLE_RX_TASKLET
+	struct napi_struct *napi = &axdev->napi;
+#endif
+	struct net_device *netdev = axdev->netdev;
+	struct net_device_stats *stats = ax_get_stats(netdev);
+	struct _179a_rx_pkt_header *pkt_hdr;
+	struct _179a_rx_header *rx_header;
+	const u32 actual_length = desc->urb->actual_length;
+	u8 *rx_data;
+	u32 aa = 0, rx_hdroffset = 0;
+	u16 pkt_count = 0;
+
+	rx_header = (struct _179a_rx_header *)
+		(((u8 *)desc->head) + actual_length - AX88179A_RX_HEADER_SIZE);
+	le64_to_cpus((u64 *)rx_header);
+
+	rx_hdroffset = rx_header->hdr_off;
+	pkt_count = rx_header->pkt_cnt;
+	aa = (actual_length - ((pkt_count + 1) * 8));
+	if (((aa != rx_hdroffset) && ((aa - rx_hdroffset) % 16) != 0) ||
+	    (rx_hdroffset >= desc->urb->actual_length) ||
+	    (pkt_count == 0)) {
+		desc->urb->actual_length = 0;
+		stats->rx_length_errors++;
+		return;
+	}
+
+	pkt_hdr = (struct _179a_rx_pkt_header *)
+			(((u8 *)desc->head) + rx_header->hdr_off);
+
+	rx_data = desc->head;
+	while (pkt_count--) {
+		struct sk_buff *skb;
+		u32 pkt_len = 0;
+
+		le64_to_cpus((u64 *)pkt_hdr);
+
+		if (!pkt_hdr->RxOk) {
+			stats->rx_crc_errors++;
+			if (!(netdev->features & NETIF_F_RXALL))
+				goto find_next_rx;
+		}
+
+		if (pkt_hdr->drop) {
+			stats->rx_dropped++;
+			if (!(netdev->features & NETIF_F_RXALL))
+				goto find_next_rx;
+		}
+
+		pkt_len = (u32)(pkt_hdr->length & 0x7FFF);
+
+#ifdef ENABLE_RX_TASKLET
+		skb = netdev_alloc_skb(netdev, pkt_len);
+#else
+		skb = napi_alloc_skb(napi, pkt_len);
+#endif
+		if (!skb) {
+			stats->rx_dropped++;
+			goto find_next_rx;
+		}
+
+		skb_put(skb, pkt_len);
+		memcpy(skb->data, rx_data, pkt_len);
+		ax88179a_rx_checksum(skb, pkt_hdr);
+
+		skb->truesize = skb->len + sizeof(struct sk_buff);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		if (pkt_hdr->vlan_ind) {
+				__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
+						     pkt_hdr->vlan_tag & VLAN_VID_MASK);
+		}
+#else
+		if (pkt_hdr->vlan_ind) {
+			__vlan_hwaccel_put_tag(skb, pkt_hdr->vlan_tag & VLAN_VID_MASK);
+		}
+#endif
+#ifdef ENABLE_PTP_FUNC
+		if (pkt_hdr->PTP_ind) {
+			ax_rx_get_timestamp(skb, (u64 *)pkt_hdr);
+			pkt_hdr += 2;
+		}
+#endif
+		skb->protocol = eth_type_trans(skb, netdev);
+		if (*work_done < budget) {
+#ifdef ENABLE_RX_TASKLET
+			netif_receive_skb(skb);
+#else
+			napi_gro_receive(napi, skb);
+#endif
+
+			*work_done += 1;
+			stats->rx_packets++;
+			stats->rx_bytes += pkt_len;
+		} else {
+			__skb_queue_tail(&axdev->rx_queue, skb);
+		}
+find_next_rx:
+		rx_data += (pkt_len + 7) & 0x7FFF8;
+		pkt_hdr++;
+	}
+}
+
+static int ax88179a_tx_fixup(struct ax_device *axdev, struct tx_desc *desc)
+{
+	struct sk_buff_head skb_head, *tx_queue;
+	struct net_device_stats *stats = &axdev->netdev->stats;
+	int remain, ret;
+#ifdef ENABLE_QUEUE_PRIORITY
+	int endpoint = (desc->q_index == 1)?5:3;
+#else
+	int endpoint = 3;
+#endif
+	u8 *tx_data;
+
+#ifdef ENABLE_QUEUE_PRIORITY
+	tx_queue = &axdev->tx_queue[desc->q_index];
+#else
+	tx_queue = axdev->tx_queue;
+#endif
+
+	__skb_queue_head_init(&skb_head);
+	spin_lock(&tx_queue->lock);
+	skb_queue_splice_init(tx_queue, &skb_head);
+	spin_unlock(&tx_queue->lock);
+
+	tx_data = desc->head;
+	desc->skb_num = 0;
+	desc->skb_len = 0;
+	remain = axdev->tx_casecade_size;
+
+	while (remain >= (ETH_ZLEN + AX88179A_TX_HEADER_SIZE)) {
+		struct sk_buff *skb;
+		struct _179a_tx_pkt_header *tx_hdr;
+		u16 tci = 0;
+
+		skb = __skb_dequeue(&skb_head);
+		if (!skb)
+			break;
+
+		if ((skb->len + AX88179A_TX_HEADER_SIZE) > remain &&
+		    (skb_shinfo(skb)->gso_size == 0)) {
+			__skb_queue_head(&skb_head, skb);
+			break;
+		}
+
+		tx_hdr = (struct _179a_tx_pkt_header *)tx_data;
+		memset(tx_hdr, 0, AX88179A_TX_HEADER_SIZE);
+		tx_hdr->length = (skb->len & 0x1FFFFF);
+		tx_hdr->checksum = AX88179A_TX_HERDER_CHKSUM(tx_hdr->length);
+		tx_hdr->max_seg_size = skb_shinfo(skb)->gso_size;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+		if ((axdev->netdev->features & NETIF_F_HW_VLAN_CTAG_TX) &&
+#else
+		if ((axdev->netdev->features & NETIF_F_HW_VLAN_TX) &&
+#endif		   
+			(vlan_get_tag(skb, &tci) >= 0)) {
+			tx_hdr->vlan_tag = 1;
+			tx_hdr->vlan_info = tci;
+		}
+
+		cpu_to_le64s((u64 *)tx_data);
+		tx_data += AX88179A_TX_HEADER_SIZE;
+
+		if (skb_copy_bits(skb, 0, tx_data, skb->len) < 0) {
+			stats->tx_dropped += skb_shinfo(skb)->gso_segs ?: 1;
+			dev_kfree_skb_any(skb);
+			continue;
+		}
+
+		tx_data = __tx_buf_align((void *)(tx_data + skb->len),
+					 axdev->tx_align_len);
+		desc->skb_len += skb->len;
+		desc->skb_num += skb_shinfo(skb)->gso_segs ?: 1;
+#ifdef ENABLE_PTP_FUNC
+		if (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {
+			skb_queue_tail(&axdev->tx_timestamp, skb);
+			set_bit(AX_TX_TIMESTAMPS, &desc->flags);
+		} else {
+			dev_kfree_skb_any(skb);
+		}
+#else
+		dev_kfree_skb_any(skb);
+#endif
+
+		if (tx_hdr->max_seg_size)
+			break;
+
+		remain = axdev->tx_casecade_size -
+			 (int)((void *)tx_data - desc->head);
+	}
+
+	if (!skb_queue_empty(&skb_head)) {
+		spin_lock(&tx_queue->lock);
+		skb_queue_splice(&skb_head, tx_queue);
+		spin_unlock(&tx_queue->lock);
+	}
+
+	netif_tx_lock(axdev->netdev);
+	if (netif_queue_stopped(axdev->netdev) &&
+	    skb_queue_len(tx_queue) < axdev->tx_qlen) {
+		netif_wake_queue(axdev->netdev);
+	}
+	netif_tx_unlock(axdev->netdev);
+
+	ret = usb_autopm_get_interface_async(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	usb_fill_bulk_urb(desc->urb, axdev->udev,
+			  usb_sndbulkpipe(axdev->udev, endpoint),
+			  desc->head, (int)(tx_data - (u8 *)desc->head),
+			  (usb_complete_t)ax_write_bulk_callback, desc);
+
+	ret = usb_submit_urb(desc->urb, GFP_ATOMIC);
+	if (ret < 0)
+		usb_autopm_put_interface_async(axdev->intf);
+
+#ifdef ENABLE_QUEUE_PRIORITY
+	if (endpoint == 5)
+		axdev->ep5_count++;
+	else
+		axdev->ep3_count++;
+#endif
+
+	return 0;
+}
+
+static int ax88179a_system_suspend(struct ax_device *axdev)
+{
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_PTP_FUNC
+	ax88279_stop_get_ts(axdev);
+#endif
+#endif
+
+	return 0;
+}
+
+static int ax88179a_system_resume(struct ax_device *axdev)
+{
+	int ret;
+
+	if (!ax88179a_check_phy_power(axdev))
+		ax88179a_set_phy_power(axdev, true);
+
+	ret = ax_write_cmd_nopm(axdev, AX_FW_MODE, AX_FW_MODE_179A, 0, 0, NULL);
+	if (ret < 0)
+		return ret;
+
+	axdev->driver_info->hw_init(axdev);
+
+	return 0;
+}
+
+static int ax88179a_runtime_suspend(struct ax_device *axdev)
+{
+	u16 reg16, medium_mode;
+	u8 reg8, loop = 100;
+
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_PTP_FUNC
+	ax88279_stop_get_ts(axdev);
+#endif
+#endif
+	while(loop--) {
+		ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, 0x57, 2, 2, &reg16, 0);
+		if (reg16 >= 0x11FF)
+			break;
+		mdelay(10);
+	};
+	loop = 100;
+	while(loop--) {
+		u8 reg[4];
+		ax_read_cmd_nopm(axdev, AX88179A_USB_DC, 0x1230, 4, 4, reg, 0);
+		if (reg[2] & 0x02)
+			break;
+		mdelay(10);
+	};
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+			 &medium_mode, 0);
+	medium_mode &= ~AX_MEDIUM_RECEIVE_EN;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+			  &medium_mode);
+
+	reg16 = AX_RX_CTL_STOP;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	reg8 = 0x10;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, 0x53, 1, 1, &reg8);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, 0x53, 1, 1, &reg8);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH, 1, 1, &reg8);
+
+	reg16 = AX_RX_CTL_START | AX_RX_CTL_AB;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	ax_write_cmd_nopm(axdev, AX8179A_WAKEUP_SETTING, 0, 0, 0, NULL);
+
+	reg16 = AX_RX_CTL_AB;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	reg16 = AX_RX_CTL_START | AX_RX_CTL_AB ;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8, 0);
+	reg8 &= 0xE0;
+	reg8 |= AX_MONITOR_MODE_RWLC | AX_MONITOR_MODE_RWMP |
+		AX_MONITOR_MODE_PMETYPE;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8);
+
+	medium_mode |= AX_MEDIUM_RECEIVE_EN;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+			  &medium_mode);
+
+	return 0;
+}
+
+static int ax88179a_runtime_resume(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u16 reg16, medium_mode;
+	u8 reg8;
+
+	if (!ax88179a_check_phy_power(axdev))
+		ax88179a_set_phy_power(axdev, true);
+
+	ax_write_cmd_nopm(axdev, AX_FW_MODE, AX_FW_MODE_179A, 0, 0, NULL);
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+			 &medium_mode, 0);
+	medium_mode &= ~AX_MEDIUM_RECEIVE_EN;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+			  &medium_mode);
+
+	reg8 = 0xFF;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_BM_INT_MASK,
+			  1, 1, &reg8);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_BM_RX_DMA_CTL,
+			  1, 1, &reg8);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_BM_TX_DMA_CTL,
+			  1, 1, &reg8);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_ARC_CTRL,
+			  1, 1, &reg8);
+
+	reg16 = AX_RX_CTL_STOP;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH, 1, 1, &reg8);
+
+	reg8 = 0;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_SWP_CTRL,
+			  1, 1, &reg8);
+
+	reg16 = AX_RX_CTL_START | AX_RX_CTL_AB;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+	reg8 = AX_MAC_RX_PATH_READY | AX_MAC_TX_PATH_READY;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX88179A_MAC_PATH, 1, 1, &reg8);
+
+	if (link_info->eth_speed == ETHER_LINK_1000)
+		medium_mode |= AX_MEDIUM_GIGAMODE;
+	if (link_info->full_duplex)
+		medium_mode |= AX_MEDIUM_FULL_DUPLEX;
+
+	medium_mode |= AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_RXFLOW_CTRLEN |
+		       AX_MEDIUM_TXFLOW_CTRLEN;
+	ax_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE, 2, 2,
+			  &medium_mode);
+
+	return 0;
+}
+
+#ifdef ENABLE_AX88279
+const struct driver_info ax88279_info = {
+	.bind		= ax88179a_bind,
+	.unbind		= ax88179a_unbind,
+	.hw_init	= ax88179a_hw_init,
+	.stop		= ax88179a_stop,
+#ifdef ENABLE_QUEUE_PRIORITY
+	.queue_priority	= ax88279_queue_setting,
+#endif
+	.link_reset	= ax88279_link_reset,
+	.link_setting	= ax88279_link_setting,
+	.rx_fixup	= ax88179a_rx_fixup,
+	.tx_fixup	= ax88179a_tx_fixup,
+	.system_suspend = ax88179a_system_suspend,
+	.system_resume	= ax88179a_system_resume,
+	.runtime_suspend = ax88179a_runtime_suspend,
+	.runtime_resume	= ax88179a_runtime_resume,
+#ifdef ENABLE_PTP_FUNC
+	.ptp_pps_ctrl = ax88279_ptp_pps_ctrl,
+	.ptp_init	= ax88279_ptp_init,
+	.ptp_remove	= ax88279_ptp_remove,
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+	.macsec_init	= ax_macsec_init,
+#endif
+	.napi_weight	= AX88279_NAPI_WEIGHT,
+	.buf_rx_size	= AX88279_BUF_RX_SIZE,
+};
+#endif
+const struct driver_info ax88179a_info = {
+	.bind		= ax88179a_bind,
+	.unbind		= ax88179a_unbind,
+	.hw_init	= ax88179a_hw_init,
+	.stop		= ax88179a_stop,
+#ifdef ENABLE_QUEUE_PRIORITY
+	.queue_priority	= ax88179a_queue_priority,
+#endif
+	.link_reset	= ax88179a_link_reset,
+	.link_setting	= ax88179a_link_setting,
+	.rx_fixup	= ax88179a_rx_fixup,
+	.tx_fixup	= ax88179a_tx_fixup,
+	.system_suspend = ax88179a_system_suspend,
+	.system_resume	= ax88179a_system_resume,
+	.runtime_suspend = ax88179a_runtime_suspend,
+	.runtime_resume	= ax88179a_runtime_resume,
+#ifdef ENABLE_PTP_FUNC
+	.ptp_pps_ctrl = ax88179a_ptp_pps_ctrl,
+	.ptp_init	= ax88179a_ptp_init,
+	.ptp_remove	= ax88179a_ptp_remove,
+#endif
+	.napi_weight	= AX88179A_NAPI_WEIGHT,
+	.buf_rx_size	= AX88179A_BUF_RX_SIZE,
+};
+
+const struct driver_info ax88772d_info = {
+	.bind		= ax88179a_bind,
+	.unbind		= ax88179a_unbind,
+	.hw_init	= ax88179a_hw_init,
+	.stop		= ax88179a_stop,
+#ifdef ENABLE_QUEUE_PRIORITY
+	.queue_priority	= ax88179a_queue_priority,
+#endif
+	.link_reset	= ax88179a_link_reset,
+	.link_setting	= ax88179a_link_setting,
+	.rx_fixup	= ax88179a_rx_fixup,
+	.tx_fixup	= ax88179a_tx_fixup,
+	.system_suspend = ax88179a_system_suspend,
+	.system_resume	= ax88179a_system_resume,
+	.runtime_suspend = ax88179a_runtime_suspend,
+	.runtime_resume	= ax88179a_runtime_resume,
+#ifdef ENABLE_PTP_FUNC
+	.ptp_pps_ctrl = ax88179a_ptp_pps_ctrl,
+	.ptp_init	= ax88179a_ptp_init,
+	.ptp_remove	= ax88179a_ptp_remove,
+#endif
+	.napi_weight	= AX88179A_NAPI_WEIGHT,
+	.buf_rx_size	= AX88179A_BUF_RX_SIZE,
+};
diff --git a/drivers/net/usb/asix_usb/ax88179a_772d.h b/drivers/net/usb/asix_usb/ax88179a_772d.h
new file mode 100644
index 000000000000..992a04493b85
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179a_772d.h
@@ -0,0 +1,246 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#ifndef __ASIX_AX88179A_772D_H
+#define __ASIX_AX88179A_772D_H
+
+#define AX88179A_BIN_TIMER_UINT		800		//ns
+
+#define AX88179A_NAPI_WEIGHT		64
+#ifdef ENABLE_AX88279
+#define AX88279_NAPI_WEIGHT		256
+#endif
+#define AX88179A_BUF_RX_SIZE		(48 * 1024)
+#ifdef ENABLE_AX88279
+#define AX88279_BUF_RX_SIZE		(48 * 1024)
+#endif
+#define AX88179A_PHY_ID			0x03
+#define AX88179_GPHY_CTRL		0x0F
+	#define AX_GPHY_EEE_CTRL		0x01
+#define AX88179A_HIGH_QUEUE_POINT	0x60
+#ifdef ENABLE_AX88279
+#define AX88279_HIGH_QUEUE_POINT	0x70
+#endif
+#define AX88179A_AUTODETACH_DELAY	(5UL << 8)
+
+#define AX8179A_WAKEUP_SETTING		0x07
+#define AX88179A_PBUS_REG		0x10
+#define AX88179A_ACCESS_BL		0x2A
+#define AX88179A_PHY_CLAUSE45		0x27
+#define AX88179A_PHY_POWER		0x31
+	#define AX_PHY_POWER			0x02
+#define AX88179A_USB_DC			0x81
+#define AX88179A_BOOT_TO_ROM		0x9F
+#define AX88179A_AUTODETACH		0xC0
+
+#define AX88179A_BFM_DATA		0x0E
+	#define AX_TX_QUEUE_CFG			0x02
+	#define AX_TX_QUEUE_SET			0x08
+	#define AX_TX_Q1_AHB_FC_EN		0x10
+	#define AX_TX_Q2_AHB_FC_EN		0x20
+	#define AX_XGMII_EN			0x80
+#define AX88179A_ETH_TX_GAP		0x0D
+#define AX88179A_FLASH_READ		0x21
+#define AX88179A_FLASH_WEN		0x22
+#define AX88179A_FLASH_WDIS		0x23
+#define AX88179A_FLASH_WRITE		0x24
+#define AX88179A_FLASH_EARSE_ALL	0x25
+#define AX88179A_VLAN_ID_CONTROL	0x2B
+	#define AX_VLAN_CONTROL_WE		0x0001
+	#define AX_VLAN_CONTROL_RD		0x0002
+	#define AX_VLAN_CONTROL_VSO		0x0010
+	#define AX_VLAN_CONTROL_VFE		0x0020
+#define AX88179A_MAC_BM_INT_MASK	0x41
+#define AX88179A_MAC_BM_RX_DMA_CTL	0x43
+#define AX88179A_MAC_BM_TX_DMA_CTL	0x46
+#define AX88179A_CLK_EN_ARRAY_1		0x4B
+	#define AX_MAC_MII_TX_25M_EN		0x02
+	#define AX_MAC_RX_25M_EN		0x08
+#define AX88179A_MAC_CLK_SELECT_1	0x4D
+	#define AX_MAC_PCSCLK_MII_TX		0x01
+#define AX88179A_MAC_RX_STATUS_CDC	0x6D
+#define AX88179A_MAC_LSOFC_GMIIPF	0x6E
+	#define AX_GMII_CRC_APPEND		0x10
+	#define AX_LSOFC_WCNT_1_ACCESS		0x00
+	#define AX_LSOFC_WCNT_2_ACCESS		0x01
+	#define AX_LSOFC_WCNT_5_ACCESS		0x02
+	#define AX_LSOFC_WCNT_7_ACCESS		0x03
+#define AX88179A_MAC_RX_FILTER_CTRL	0x6F
+	#define AX_MAC_RX_FILTER_OFT_EN	0x80
+#define AX88179A_MAC_QUEUE_POINT	0x7F
+#define AX88179A_MAC_ARC_CTRL		0x9E
+#define AX88179A_CDC_ECM_CTRL		0xB0
+#define AX88179A_MAC_SWP_CTRL		0xB1
+#define AX88179A_MAC_TX_PAUSE_0		0xB2
+#define AX88179A_MAC_TX_PAUSE_1		0xB3
+#define AX88179A_MAC_TX_PAUSE_2		0xB4
+#define AX88179A_MAC_CDC_DELAY_TX	0xB5
+#define AX88179A_MAC_PATH		0xB7
+	#define AX_MAC_RX_PATH_READY		0x01
+	#define AX_MAC_TX_PATH_READY		0x02
+#define AX88179A_NEW_PAUSE_CTRL		0xB8
+	#define AX_NEW_PAUSE_EN			0x01
+#define AX88179A_MAC_BULK_OUT_CTRL	0xB9
+	#define AX_MAC_EFF_EN			0x02
+#define AX88179A_MAC_RX_DATA_CDC_CNT	0xC0
+#define AX88179A_MAC_BFM_CTRL		0xC1
+	#define AX_MAC_STOP_EP5_ACCESS		0x01
+	#define AX_MAC_STOP_EP3_ACCESS		0x02
+	#define AX_MAC_LSO_ERR_EN		0x04
+	#define AX_MAC_MIQFFCTRL_FORMAT		0x10
+	#define AX_MAC_MIQFFCTRL_DROP_CRC	0x20
+#define AX88179A_MAC_LSO_ENHANCE_CTRL	0xC3
+	#define AX_LSO_ENHANCE_EN		0x01
+#define AX88179A_MAC_TX_HDR_CKSUM	0xCC
+	#define AX_TXHDR_CKSUM_EN		0x01
+	#define AX_TXRX_INDV_RESET_EN		0x02
+#define AX88179A_MAC_CPU_CTRL_MAC_1	0xCE
+	#define AX_RX_INDV_RESET		0x01
+	#define AX_TX_INDV_RESET		0x02
+#define AX88179A_EP5_EHR		0xF9
+	#define AX_EP5_DAT_ERROR_HANDLE		0x80
+#define AX88179A_HW_EC_VERSION		0xFB
+#define AX88179A_SW_REVERSION		0xFC
+	#define AX88179A_FLASH_MODE		0x80
+
+#define PHY_1000M_STS			0x11
+	#define LINK_1000M_OK		0x1000
+#define PHY_100M_STS			0x10
+	#define LINK_100M_OK		0x1000
+#define PHY_10M_STS			0x16
+	#define LINK_10M_OK		0x40
+
+#ifdef ENABLE_AX88279
+#define AX_PBUS_A32			0x11
+
+#define AX_PBUS_REG_BASE_ADDR_HI	0x0013
+#define AX_TX_READY_CTRL		0x1008
+	#define AX_IPG_COUNTER_100M		0x28
+	#define AX_IPG_COUNTER_1G		0x22
+	#define AX_SOF_DELAY_COUNTER_100M	0x1C
+	#define AX_SOF_DELAY_COUNTER_1G		0x06
+	#define AX_VAILD_DELAY_COUNTER_100M	0x0F
+	#define AX_VAILD_DELAY_COUNTER_1G	0x07
+#define AX_MAC_CLK_CTRL			0x3004
+	#define AX_DIVIDE_PTP_CLK_SHIFT		0
+	#define AX_DIVIDE_AES_CLK_SHIFT		8
+	#define AX_PTP_CLK_EN			0x010000
+	#define AX_AES_CLK_EN			0x020000
+	#define AX_PTP_CLK_SELECT_DIVIDE	0x040000
+	#define AX_AES_CLK_SELECT_DIVIDE	0x080000
+	#define AX_XGMAC_TX_CLK_EN		0x100000
+	#define AX_XGMAC_RX_CLK_EN		0x200000
+#endif
+
+struct _179a_rx_pkt_header {
+#ifdef __BIG_ENDIAN
+	u64	reserved	:7,
+		PTP_ind		:1,
+		WUF_ind		:6,
+		WUF_wake	:1,
+		WUF_detect	:1,
+		vlan_tag	:16,
+		drop		:1,
+		length		:15,
+		BMC		:1,
+		reserved2	:3,
+		RxOk		:1,
+		vlan_ind	:1,
+		node_ID_match	:1,
+		TCO_match	:1,
+		CE		:1,
+		L3_pkt_type	:2,
+		L4_pkt_type	:3,
+		L3_err		:1,
+		L4_err		:1;
+#else
+	u64	L4_err		:1,
+		L3_err		:1,
+		L4_pkt_type	:3,
+		L3_pkt_type	:2,
+		CE		:1,
+		TCO_match	:1,
+		node_ID_match	:1,
+		vlan_ind	:1,
+		RxOk		:1,
+		reserved2	:3,
+		BMC		:1,
+		length		:15,
+		drop		:1,
+		vlan_tag	:16,
+		WUF_detect	:1,
+		WUF_wake	:1,
+		WUF_ind		:6,
+		PTP_ind		:1,
+		reserved	:7;
+#endif
+} __packed;
+
+struct _179a_rx_header {
+#ifdef __BIG_ENDIAN
+	u64	rxThroughput: 32,
+		hdr_off	:19,
+		pkt_cnt	:13;
+#else
+	u64	pkt_cnt	:13,
+		hdr_off	:19,
+		rxThroughput: 32;
+#endif
+} __packed;
+#define AX88179A_RX_HEADER_SIZE	sizeof(struct _179a_rx_header)
+
+struct _179a_tx_pkt_header {
+#ifdef __BIG_ENDIAN
+	u64	vlan_info	:16,
+		reserved	:1,
+		max_seg_size	:15,
+		DICF		:1,
+		CPHI		:1,
+		vlan_tag	:1,
+		padding		:1,
+		checksum	:7,
+		length		:21;
+#else
+	u64	length		:21,
+		checksum	:7,
+		padding		:1,
+		vlan_tag	:1,
+		CPHI		:1,
+		DICF		:1,
+		max_seg_size	:15,
+		reserved	:1,
+		vlan_info	:16;
+#endif
+} __packed;
+#define AX88179A_TX_HEADER_SIZE	sizeof(struct _179a_tx_pkt_header)
+
+#define AX88179A_TX_HERDER_CHKSUM(len)  ((tx_hdr->length + \
+					(tx_hdr->length >> 8) + \
+					((tx_hdr->length >> 16) & 0x1F)) & 0x7F)
+
+extern const struct net_device_ops ax88179a_netdev_ops;
+#ifdef ENABLE_AX88279
+extern const struct driver_info ax88279_info;
+#endif
+extern const struct driver_info ax88179a_info;
+extern const struct driver_info ax88772d_info;
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+int ax88179a_siocdevprivate(struct net_device *netdev, struct ifreq *rq,
+			    void __user *udata, int cmd);
+#endif
+int ax88179a_ioctl(struct net_device *net, struct ifreq *rq, int cmd);
+void ax88179a_set_multicast(struct net_device *net);
+#endif /* End of __ASIX_AX88179A_772D_H */
diff --git a/drivers/net/usb/asix_usb/ax88179a_ieee.c b/drivers/net/usb/asix_usb/ax88179a_ieee.c
new file mode 100644
index 000000000000..8d0464b7f0bc
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179a_ieee.c
@@ -0,0 +1,369 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#if NET_INTERFACE == INTERFACE_SCAN
+#include <ifaddrs.h>
+#endif
+#include "ax_ioctl.h"
+
+#define PRINT_IOCTL_FAIL(ret) \
+fprintf(stderr, "%s: ioctl failed. (err: %d)\n", __func__, ret)
+
+#define AX88179A_IOCTL_VERSION \
+"AX88179A/AX88772D Linux IEEE Test Tool v1.0.0"
+
+const char help_str1[] =
+"./ax88179a_772d_ieee help [command]\n"
+"    -- command description\n";
+const char help_str2[] =
+"        [command] - Display usage of specified command\n";
+
+const char ieeetest_str1[] =
+"./ax88179a_772d_ieee ieeetest [speed] [option]\n"
+"    -- AX88179A_772D IEEE Test Tool\n";
+const char ieeetest_str2[] =
+"        [speed]    - 1000: 1000Mbps,  100: 100Mbps,  10: 10Mbps\n"
+"        [option]   - For 1000Mbps\n"
+"			M1: Mode 1\n"
+"			M2: Mode 2\n"
+"			M3: Mode 3\n"
+"			M4: Mode 4\n\n"
+"		    - For 100Mbps\n"
+"			CA: Channel A\n"
+"			CB: Channel B\n\n"
+"		    - For 10Mbps\n"
+"			RP: Random Pattern\n"
+"			FF: Fixed Pattern(FF)\n"
+"			MDI: MDI\n\n";
+
+static int help_func(struct ax_command_info *info);
+static int ieeetest_func(struct ax_command_info *info);
+static int scan_ax_device(struct ifreq *ifr, int inet_sock);
+
+struct _command_list ax88179a_cmd_list[] = {
+	{
+		"help",
+		AX_SIGNATURE,
+		help_func,
+		help_str1,
+		help_str2
+	},
+	{
+		"ieeetest",
+		AX88179A_READ_VERSION,
+		ieeetest_func,
+		ieeetest_str1,
+		ieeetest_str2
+	},
+	{NULL},
+};
+
+#pragma pack(push)
+#pragma pack(1)
+#pragma pack(pop)
+
+static void show_usage(void)
+{
+	int i;
+
+	printf("Usage:\n");
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++)
+		printf("%s\n", ax88179a_cmd_list[i].help_ins);
+}
+
+static unsigned long STR_TO_U32(const char *cp, char **endp, unsigned int base)
+{
+	unsigned long result = 0, value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base)
+			base = 8;
+	}
+	if (!base)
+		base = 10;
+
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+
+	return result;
+}
+
+static int help_func(struct ax_command_info *info)
+{
+	int i;
+
+	if (info->argv[2] == NULL)
+		return -FAIL_INVALID_PARAMETER;
+
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(info->argv[2],
+			    ax88179a_cmd_list[i].cmd,
+			    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+			       ax88179a_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	return SUCCESS;
+}
+
+static int ieeetest_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	if (info->argc != 4) {
+		int i;
+
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	if (!strcmp(info->argv[2], "1000") && strlen(info->argv[2]) == 4) {
+		ioctl_cmd.ieee.speed = 1000;
+		if (!strcmp(info->argv[3], "M1")) {
+			printf("Test item: 1000M M1\n");
+			ioctl_cmd.ieee.type = IEEE_1000M1;
+		} else if (!strcmp(info->argv[3], "M2")) {
+			printf("Test item: 1000M M2\n");
+			ioctl_cmd.ieee.type = IEEE_1000M2;
+		} else if (!strcmp(info->argv[3], "M3")) {
+			printf("Test item: 1000M M3\n");
+			ioctl_cmd.ieee.type = IEEE_1000M3;
+		} else if (!strcmp(info->argv[3], "M4")) {
+			printf("Test item: 1000M M4\n");
+			ioctl_cmd.ieee.type = IEEE_1000M4;
+		} else {
+			printf("Invalid option\n");
+			return -FAIL_IVALID_VALUE;
+		}
+	} else if (!strcmp(info->argv[2], "100") &&
+		   strlen(info->argv[2]) == 3) {
+		ioctl_cmd.ieee.speed = 100;
+		if (!strcmp(info->argv[3], "CA")) {
+			printf("Test item: 100M Channel A\n");
+			ioctl_cmd.ieee.type = IEEE_100CA;
+		} else if (!strcmp(info->argv[3], "CB")) {
+			printf("Test item: 100M Channel B\n");
+			ioctl_cmd.ieee.type = IEEE_100CB;
+		} else {
+			printf("Invalid option\n");
+			return -FAIL_IVALID_VALUE;
+		}
+	} else if (!strcmp(info->argv[2], "10") &&
+		   strlen(info->argv[2]) == 2) {
+		ioctl_cmd.ieee.speed = 10;
+		if (!strcmp(info->argv[3], "RP")) {
+			printf("Test item: 10M Random Pattern\n");
+			ioctl_cmd.ieee.type = IEEE_10R;
+		} else if (!strcmp(info->argv[3], "FF")) {
+			printf("Test item: 10M Fixed Pattern(FF)\n");
+			ioctl_cmd.ieee.type = IEEE_10FF;
+		} else if (!strcmp(info->argv[3], "MDI")) {
+			printf("Test item: 10M MDI\n");
+			ioctl_cmd.ieee.type = IEEE_10MDI;
+		} else {
+			printf("Invalid option\n");
+			return -FAIL_IVALID_VALUE;
+		}
+	} else {
+		int i;
+
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	ioctl_cmd.ieee.stop = 0;
+
+	ioctl_cmd.ioctl_cmd = AX88179A_IEEE_TEST;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	printf("Press Enter to stop testing...");
+	getchar();
+
+	ioctl_cmd.ieee.stop = 1;
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		if (ioctl_cmd.ieee.status == -ERR_IEEE_INVALID_CHIP)
+			printf("Invalid speed and chip\n");
+		return -FAIL_IOCTL;
+	}
+
+	printf("Test completely\n");
+	return SUCCESS;
+}
+
+static int scan_ax_device(struct ifreq *ifr, int inet_sock)
+{
+	unsigned int retry;
+
+	for (retry = 0; retry < SCAN_DEV_MAX_RETRY; retry++) {
+		unsigned int i;
+		struct _ax_ioctl_command ioctl_cmd;
+#if NET_INTERFACE == INTERFACE_SCAN
+		struct ifaddrs *addrs, *tmp;
+		unsigned char	dev_exist;
+
+		getifaddrs(&addrs);
+		tmp = addrs;
+		dev_exist = 0;
+
+		while (tmp) {
+			memset(&ioctl_cmd, 0,
+			       sizeof(struct _ax_ioctl_command));
+			ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+			sprintf(ifr->ifr_name, "%s", tmp->ifa_name);
+
+			ifr->ifr_data = (caddr_t)&ioctl_cmd;
+			tmp = tmp->ifa_next;
+
+
+			if (ioctl(inet_sock, AX_PRIVATE, ifr) < 0)
+				continue;
+
+			if (strncmp(ioctl_cmd.sig,
+				    AX88179A_DRV_NAME,
+				    strlen(AX88179A_DRV_NAME)) == 0) {
+				dev_exist = 1;
+				break;
+			}
+		}
+
+		freeifaddrs(addrs);
+
+		if (dev_exist)
+			break;
+#else
+		for (i = 0; i < 255; i++) {
+
+			memset(&ioctl_cmd, 0,
+			       sizeof(struct _ax_ioctl_command));
+			ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+			sprintf(ifr->ifr_name, "eth%u", i);
+
+			ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+			if (ioctl(inet_sock, AX_PRIVATE, ifr) < 0)
+				continue;
+
+			if (strncmp(ioctl_cmd.sig,
+				    AX88179A_DRV_NAME,
+				    strlen(AX88179A_DRV_NAME)) == 0)
+				break;
+
+		}
+
+		if (i < 255)
+			break;
+#endif
+		usleep(500000);
+	}
+
+	if (retry >= SCAN_DEV_MAX_RETRY)
+		return -FAIL_SCAN_DEV;
+
+	return SUCCESS;
+}
+
+int main(int argc, char **argv)
+{
+	struct ifreq ifr;
+	struct ax_command_info info;
+	unsigned int i;
+	int inet_sock, ret;
+
+	printf("%s\n", AX88179A_IOCTL_VERSION);
+
+	if (argc < 2) {
+		show_usage();
+		return SUCCESS;
+	}
+
+	inet_sock = socket(AF_INET, SOCK_DGRAM, 0);
+
+	if (scan_ax_device(&ifr, inet_sock)) {
+		printf("No %s found\n", AX88179A_SIGNATURE);
+		return FAIL_SCAN_DEV;
+	}
+
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(argv[1],
+			    ax88179a_cmd_list[i].cmd,
+			    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+			info.help_ins = ax88179a_cmd_list[i].help_ins;
+			info.help_desc = ax88179a_cmd_list[i].help_desc;
+			info.ifr = &ifr;
+			info.argc = argc;
+			info.argv = argv;
+			info.inet_sock = inet_sock;
+			info.ioctl_cmd = ax88179a_cmd_list[i].ioctl_cmd;
+			ret = (ax88179a_cmd_list[i].OptFunc)(&info);
+			goto out;
+		}
+	}
+
+	if (ax88179a_cmd_list[i].cmd == NULL) {
+		printf("%u\n", i);
+		show_usage();
+		return SUCCESS;
+	}
+out:
+	if (ret == SUCCESS)
+		printf("SUCCESS\n");
+	else if (ret != -FAIL_INVALID_PARAMETER)
+		printf("FAIL\n");
+
+	return ret;
+}
diff --git a/drivers/net/usb/asix_usb/ax88179a_programmer.c b/drivers/net/usb/asix_usb/ax88179a_programmer.c
new file mode 100644
index 000000000000..368224ac28fb
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88179a_programmer.c
@@ -0,0 +1,1532 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <getopt.h>
+#include <endian.h>
+#if NET_INTERFACE == INTERFACE_SCAN
+#include <ifaddrs.h>
+#endif
+#include "ax_ioctl.h"
+#ifdef ENABLE_IOCTL_DEBUG
+#define NOT_PROGRAM
+#endif
+#define RELOAD_DELAY_TIME	10	// sec
+
+#define PRINT_IOCTL_FAIL(ret) \
+fprintf(stderr, "%s: ioctl failed. (err: %d)\n", __func__, ret)
+#define PRINT_SCAN_DEV_FAIL \
+fprintf(stderr, "%s: Scaning device failed.\n", __func__)
+#define PRINT_ALLCATE_MEM_FAIL \
+fprintf(stderr, "%s: Fail to allocate memory.\n", __func__)
+#define PRINT_LOAD_FILE_FAIL \
+fprintf(stderr, "%s: Read file failed.\n", __func__)
+
+#define AX88179A_IOCTL_VERSION \
+"AX88179B/AX88179A/AX88772E/AX88772D Linux Flash/eFuse Programming Tool v2.0.0"
+
+const char help_str1[] =
+"./ax88179b_179a_772e_772d_programmer help [command]\n"
+"    -- command description\n";
+const char help_str2[] =
+"        [command] - Display usage of specified command\n";
+
+const char readverion_str1[] =
+"./ax88179b_179a_772e_772d_programmer rversion\n"
+"    -- AX88179B_179A_772E_772D Read Firmware Verion\n";
+static const char readverion_str2[] = "";
+
+const char readmac_str1[] =
+"./ax88179b_179a_772e_772d_programmer rmacaddr\n"
+"    -- AX88179B_179A_772E_772D Read MAC Address\n";
+static const char readmac_str2[] = "";
+
+const char writeflash_str1[] =
+"./ax88179b_179a_772e_772d_programmer wflash [file]\n"
+"    -- AX88179B_179A_772E_772D Write Flash\n";
+const char writeflash_str2[] =
+"        [file]    - Flash file path\n";
+
+const char writeefuse_str1[] =
+"./ax88179b_179a_772e_772d_programmer wefuse -m [MAC] -s [SN] -f [File] --led0 [value]"
+" --led1 [value] -p [device]\n"
+"    -- AX88179B_179A_772E_772D Write eFuse\n";
+const char writeefuse_str2[] =
+"        -m [MAC]    - MAC address (XX:XX:XX:XX:XX:XX)\n"
+"        -s [SN]     - Serial number\n"
+"        -f [File]   - eFuse file path\n"
+"        --led0 [value]   - value: control_blink (XXXX_XXXX)\n"
+"        --led1 [value]   - value: control_blink (XXXX_XXXX)\n"
+"        -p [device] - device: \"AX88179B\" or \"AX88179A\" or \"AX88772E\" or \"AX88772D\"\n";
+
+const char readefuse_str1[] =
+"./ax88179b_179a_772e_772d_programmer refuse -f [File]\n"
+"    -- AX88179B_179A_772E_772D Read eFuse\n";
+const char readefuse_str2[] =
+"        -f [File]   - eFuse file path\n";
+
+const char reload_str1[] =
+"./ax88179b_179a_772e_772d_programmer reload\n"
+"    -- AX88179B_179A_772E_772D Reload\n";
+static const char reload_str2[] = "";
+
+static int help_func(struct ax_command_info *info);
+static int readversion_func(struct ax_command_info *info);
+static int readmac_func(struct ax_command_info *info);
+static int writeflash_func(struct ax_command_info *info);
+static int writeefuse_func(struct ax_command_info *info);
+static int readefuse_func(struct ax_command_info *info);
+static int reload_func(struct ax_command_info *info);
+static int scan_ax_device(struct ifreq *ifr, int inet_sock);
+
+struct _command_list ax88179a_cmd_list[] = {
+	{
+		"help",
+		AX_SIGNATURE,
+		help_func,
+		help_str1,
+		help_str2
+	},
+	{
+		"rversion",
+		AX88179A_READ_VERSION,
+		readversion_func,
+		readverion_str1,
+		readverion_str2
+	},
+	{
+		"rmacaddr",
+		~0,
+		readmac_func,
+		readmac_str1,
+		readmac_str2
+	},
+	{
+		"wflash",
+		AX88179A_WRITE_FLASH,
+		writeflash_func,
+		writeflash_str1,
+		writeflash_str2
+	},
+	{
+		"wefuse",
+		AX88179A_PROGRAM_EFUSE,
+		writeefuse_func,
+		writeefuse_str1,
+		writeefuse_str2
+	},
+	{
+		"refuse",
+		AX88179A_DUMP_EFUSE,
+		readefuse_func,
+		readefuse_str1,
+		readefuse_str2
+	},
+	{
+		"reload",
+		~0,
+		reload_func,
+		reload_str1,
+		reload_str2
+	},
+	{
+		NULL,
+		0,
+		NULL,
+		NULL,
+		NULL
+	}
+};
+
+static unsigned char sample_type1[] = {
+ 0x01, 0x0B, 0x95, 0x17,
+ 0x90, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x02,
+ 0x00, 0x0A, 0x07, 0xFF,
+ 0x17, 0x32, 0x20, 0x00
+};
+
+static unsigned char sample_type4[] = {
+ 0x04, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00
+};
+
+static unsigned char sample_type11[] = {
+ 0x0B, 0x1F, 0x00, 0x00,
+ 0x00, 0x00, 0x1F, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x45, 0x00
+};
+
+#pragma pack(push)
+#pragma pack(1)
+enum _ef_Type_Def {
+	EF_TYPE_REV = 0x00,
+	EF_TYPE_01 = 0x01,
+	EF_TYPE_04 = 0x04,
+	EF_TYPE_11 = 0x0B,
+};
+struct _ef_type {
+#if __BYTE_ORDER == __BIG_ENDIAN
+	unsigned char	checksum: 4;
+	unsigned char	type	: 4;
+#else
+	unsigned char	type	: 4;
+	unsigned char	checksum: 4;
+#endif
+};
+
+struct _ef_type01 {
+	struct _ef_type	type;
+	unsigned short	vid;
+	unsigned short	pid;
+	unsigned char	mac[6];
+	unsigned short	bcdDevice;
+	unsigned char	bU1DevExitLat;
+	unsigned short	wU2DevExitLat;
+	unsigned char	SS_Max_Bus_Pw;
+	unsigned char	HS_Max_Bus_Pw;
+	unsigned char	IPSleep_Polling_Count;
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_01	sizeof(struct _ef_type01)
+
+struct _ef_type04 {
+	struct _ef_type	type;
+	unsigned char	serial[18];
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_04	sizeof(struct _ef_type04)
+
+struct _ef_type11 {
+	struct _ef_type	type;
+	unsigned char	dev_type0;
+	unsigned short	reg0;
+	unsigned short	value0;
+	unsigned char	dev_type1;
+	unsigned short	reg1;
+	unsigned short	value1;
+	unsigned char	dev_type2;
+	unsigned short	reg2;
+	unsigned short	value2;
+	unsigned char	reserved1[2];
+	unsigned char	subtype;
+	unsigned char	reserved2;
+};
+#define EF_TYPE_STRUCT_SIZE_11	sizeof(struct _ef_type11)
+
+struct _ef_data_struct {
+	union {
+		struct _ef_type01 type01;
+		struct _ef_type04 type04;
+		struct _ef_type11 type11;
+	} ef_data;
+};
+#define EF_DATA_STRUCT_SIZE	sizeof(struct _ef_data_struct)
+#pragma pack(pop)
+
+static void show_usage(void)
+{
+	int i;
+
+	printf("Usage:\n");
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++)
+		printf("%s\n", ax88179a_cmd_list[i].help_ins);
+}
+
+static unsigned long STR_TO_U32(const char *cp, char **endp, unsigned int base)
+{
+	unsigned long result = 0, value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base)
+			base = 8;
+	}
+	if (!base)
+		base = 10;
+
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+
+	return result;
+}
+
+static int help_func(struct ax_command_info *info)
+{
+	int i;
+
+	if (info->argv[2] == NULL)
+		return -FAIL_INVALID_PARAMETER;
+
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(info->argv[2],
+			    ax88179a_cmd_list[i].cmd,
+			    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+			       ax88179a_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	return SUCCESS;
+}
+
+static int autosuspend_enable(struct ax_command_info *info,
+			      unsigned char enable)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_AUTOSUSPEND_EN;
+
+	ioctl_cmd.autosuspend.enable = enable;
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int read_version(struct ax_command_info *info, char *version)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_READ_VERSION;
+
+	memset(ioctl_cmd.version.version, 0, 16);
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	memcpy(version, ioctl_cmd.version.version, 16);
+
+	return SUCCESS;
+}
+
+static int read_mac_address(struct ax_command_info *info, unsigned char *mac)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ret = scan_ax_device(ifr, info->inet_sock);
+	if (ret < 0) {
+		PRINT_SCAN_DEV_FAIL;
+		return ret;
+	}
+
+	ifr->ifr_flags &= 0;
+	ret = ioctl(info->inet_sock, SIOCSIFFLAGS, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	usleep(20000);
+
+	ifr->ifr_flags = IFF_UP | IFF_BROADCAST | IFF_MULTICAST;
+	ret = ioctl(info->inet_sock, SIOCSIFFLAGS, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	usleep(20000);
+
+	ret = ioctl(info->inet_sock, SIOCGIFHWADDR, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	memcpy(mac, ifr->ifr_hwaddr.sa_data, 6);
+
+	return SUCCESS;
+}
+
+static int readversion_func(struct ax_command_info *info)
+{
+	char version[16] = {0};
+	int i, ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 2) {
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	autosuspend_enable(info, 0);
+
+	ret = read_version(info, version);
+	if (ret == SUCCESS)
+		printf("Firmware Version: %s\n", version);
+
+	usleep(20000);
+
+	autosuspend_enable(info, 1);
+
+	return ret;
+}
+
+static int readmac_func(struct ax_command_info *info)
+{
+	unsigned char mac[6] = {0};
+	int i, ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 2) {
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	ret = read_mac_address(info, mac);
+	if (ret == SUCCESS)
+		printf("MAC address: %02X:%02X:%02X:%02X:%02X:%02X\n",
+			mac[0],
+			mac[1],
+			mac[2],
+			mac[3],
+			mac[4],
+			mac[5]);
+
+	return ret;
+}
+
+static int write_flash(struct ax_command_info *info, unsigned char *data,
+		       unsigned long offset, unsigned long len)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_WRITE_FLASH;
+	ioctl_cmd.flash.status = 0;
+	ioctl_cmd.flash.offset = offset;
+	ioctl_cmd.flash.length = len;
+	ioctl_cmd.flash.buf = data;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		if (ioctl_cmd.flash.status)
+			fprintf(stderr, "FLASH WRITE status: %d",
+				ioctl_cmd.flash.status);
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	return SUCCESS;
+}
+
+static int read_flash(struct ax_command_info *info, unsigned char *data,
+		      unsigned long offset, unsigned long len)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_READ_FLASH;
+	ioctl_cmd.flash.status = 0;
+	ioctl_cmd.flash.offset = offset;
+	ioctl_cmd.flash.length = len;
+	ioctl_cmd.flash.buf = data;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		if (ioctl_cmd.flash.status)
+			fprintf(stderr, "FLASH READ status: %d",
+				ioctl_cmd.flash.status);
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int erase_flash(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_ERASE_FLASH;
+	ioctl_cmd.flash.status = 0;
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int boot_to_rom(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_ROOT_2_ROM;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+	ioctl(info->inet_sock, AX_PRIVATE, ifr);
+
+	return SUCCESS;
+}
+
+static int sw_reset(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_SW_RESET;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+	ioctl(info->inet_sock, AX_PRIVATE, ifr);
+
+	usleep(RELOAD_DELAY_TIME * 1000000);
+
+	return SUCCESS;
+}
+
+static int writeflash_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	unsigned char *wbuf = NULL, *rbuf = NULL;
+	FILE *pFile = NULL;
+	size_t result;
+	int length = 0;
+	int i, offset, len, ret;
+	char fw_version[16] = {0};
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 3) {
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	autosuspend_enable(info, 0);
+
+	boot_to_rom(info);
+
+	usleep(1000000);
+
+	ret = scan_ax_device(ifr, info->inet_sock);
+	if (ret < 0) {
+		PRINT_SCAN_DEV_FAIL;
+		return ret;
+	}
+
+	ret = erase_flash(info);
+	if (ret < 0) 
+		return ret;
+
+	pFile = fopen(info->argv[2], "rb");
+	if (pFile == NULL) {
+		fprintf(stderr, "%s: Fail to open %s file.\n",
+			__func__, info->argv[2]);
+		ret = -FAIL_LOAD_FILE;
+		goto fail;
+	}
+
+	fseek(pFile, 0, SEEK_END);
+	length = ftell(pFile);
+	fseek(pFile, 0, SEEK_SET);
+
+	wbuf = (unsigned char *)malloc((length + 256) & ~(0xFF));
+	if (!wbuf) {
+		PRINT_ALLCATE_MEM_FAIL;
+		ret = -FAIL_ALLCATE_MEM;
+		goto fail;
+	}
+	memset(wbuf, 0, (length + 256) & ~(0xFF));
+	rbuf = (unsigned char *)malloc((length + 256) & ~(0xFF));
+	if (!rbuf) {
+		PRINT_ALLCATE_MEM_FAIL;
+		ret = -FAIL_ALLCATE_MEM;
+		goto fail;
+	}
+	memset(rbuf, 0, (length + 256) & ~(0xFF));
+
+	result = fread(wbuf, 1, length, pFile);
+	if (result != length) {
+		PRINT_LOAD_FILE_FAIL;
+		ret = -PRINT_LOAD_FILE_FAIL;
+		goto fail;
+	}
+
+	offset = SWAP_32(*(unsigned long *)&wbuf[4]);
+	len = (SWAP_32(*(unsigned long *)&wbuf[8]) + 256) & ~(0xFF);
+
+	sprintf(fw_version, "v%d.%d.%d",
+		wbuf[offset + 0x1000],
+		wbuf[offset + 0x1001],
+		wbuf[offset + 0x1002]);
+	printf("File FW Version: %s\n", fw_version);
+
+	ret = write_flash(info, wbuf, offset, len);
+	if (ret < 0)
+		goto fail;
+
+	ret = read_flash(info, rbuf, offset, len);
+	if (ret < 0)
+		goto fail;
+
+	if (memcmp(&wbuf[offset], &rbuf[offset], len) != 0) {
+		fprintf(stderr, "%s: Program the FW failed.\n", __func__);
+		ret = -FAIL_FLASH_WRITE;
+		goto fail;
+	}
+
+	len = SWAP_32(*(unsigned long *)&wbuf[4]);
+
+	ret = write_flash(info, wbuf, 0, len);
+	if (ret < 0)
+		goto fail;
+
+	ret = read_flash(info, rbuf, 0, (length + 256) & ~(0xFF));
+	if (ret < 0)
+		goto fail;
+
+	if (memcmp(wbuf, rbuf,
+		   (SWAP_32(*(unsigned long *)&wbuf[8]) +
+		    SWAP_32(*(unsigned long *)&wbuf[4]))) != 0) {
+		fprintf(stderr, "%s: Program the Flash failed.\n", __func__);
+		ret = -FAIL_FLASH_WRITE;
+		goto fail;
+	}
+
+	ret = SUCCESS;
+	goto out;
+fail:
+	erase_flash(info);
+out:
+	if (rbuf)
+		free(rbuf);
+	if (wbuf)
+		free(wbuf);
+	if (pFile)
+		fclose(pFile);
+
+	autosuspend_enable(info, 1);
+
+	return ret;
+}
+
+#define EFUSE_NUM_BLOCK	32
+
+static void checksum_efuse_block(unsigned char *block)
+{
+	unsigned int Sum = 0;
+	int j;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (j = 0; j < 4; j++) {
+		if (j == 0)
+			Sum += block[j] & 0xF;
+		else
+			Sum += block[j];
+	}
+
+	while (Sum > 0xF)
+		Sum = (Sum & 0xF) + (Sum >> 4);
+
+	Sum = 0xF - Sum;
+
+	block[0] = (block[0] & 0xF) | ((Sum << 4) & 0xF0);
+}
+
+static int __find_efuse_index(struct _ef_data_struct *efuse,
+			      enum _ef_Type_Def type)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 5; i < EFUSE_NUM_BLOCK; i++) {
+		if (efuse[i].ef_data.type01.type.type == type)
+			return i;
+	}
+
+	return -FAIL_GENERIAL_ERROR;
+}
+
+static int change_mac_address(struct _ef_data_struct *efuse, unsigned int *mac)
+{
+	int index, i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	index = __find_efuse_index(efuse, EF_TYPE_01);
+	if (index == -FAIL_GENERIAL_ERROR) {
+		fprintf(stderr, "%s: Not found type 1 from eFuese file\n",
+			__func__);
+		return -FAIL_GENERIAL_ERROR;
+	}
+
+	for (i = 0; i < 6; i++)
+		efuse[index].ef_data.type01.mac[i] = (unsigned char)mac[i];
+	checksum_efuse_block((unsigned char *)&efuse[index]);
+
+	return SUCCESS;
+}
+
+static int change_serial_number(struct _ef_data_struct *efuse, char *serial)
+{
+	int index;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	index = __find_efuse_index(efuse, EF_TYPE_04);
+	if (index == -FAIL_GENERIAL_ERROR) {
+		fprintf(stderr, "%s: Not found type 4 from eFuese file\n",
+			__func__);
+		return -FAIL_GENERIAL_ERROR;
+	}
+
+	memset(efuse[index].ef_data.type04.serial, 0, 18);
+	memcpy(efuse[index].ef_data.type04.serial, serial, strlen(serial));
+	checksum_efuse_block((unsigned char *)&efuse[index]);
+
+	return SUCCESS;
+}
+
+static void set_led(struct _ef_data_struct *efuse, char *led, int led_num)
+{
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	memcpy(efuse, sample_type11, EF_TYPE_STRUCT_SIZE_11);
+
+	efuse->ef_data.type11.reg0 = htobe16(0x0024 + (led_num << 1));
+	efuse->ef_data.type11.reg1 = htobe16(0x0025 + (led_num << 1));
+
+	led[4] = '\0';
+	efuse->ef_data.type11.value0 = htobe16(strtol(led, NULL, 16));
+	efuse->ef_data.type11.value1 = htobe16(strtol(&led[5], NULL, 16));
+
+	checksum_efuse_block((unsigned char *)efuse);
+}
+
+static int load_efuse_from_file(char *file_path, unsigned char *data)
+{
+	FILE *pFile = NULL;
+	int i, j;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (!file_path)
+		return -FAIL_LOAD_FILE;
+
+	pFile = fopen(file_path, "rb");
+	if (pFile == NULL) {
+		fprintf(stderr, "%s: Fail to open %s file.\n",
+			__func__, file_path);
+		return -FAIL_LOAD_FILE;
+	}
+
+	for (i = 0; i < (20 * EFUSE_NUM_BLOCK); i += 4) {
+		unsigned int size = 0;
+
+		for (j = 3; j >= 0; j--) {
+			unsigned int tmp;
+
+			size = fscanf(pFile, "%02X ", &tmp);
+			if (size == ~0)
+				break;
+			data[i + j] = tmp & 0xFF;
+		}
+		if (size == ~0)
+			break;
+	}
+
+	if (pFile)
+		fclose(pFile);
+
+	return SUCCESS;
+}
+
+static int __dump_efuse(struct ax_command_info *info,
+			struct _ef_data_struct *efuse,
+			int block_offset, int block_num)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	int i, limit = (block_offset + block_num);
+	struct _ax_ioctl_command ioctl_cmd;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (limit > EFUSE_NUM_BLOCK) {
+		fprintf(stderr, "%s: Invalid dump block size\n", __func__);
+		return -FAIL_IVALID_VALUE;
+	}
+
+	if (scan_ax_device(ifr, info->inet_sock)) {
+		PRINT_SCAN_DEV_FAIL;
+		return -FAIL_SCAN_DEV;
+	}
+
+	ioctl_cmd.ioctl_cmd = AX88179A_DUMP_EFUSE;
+	ioctl_cmd.flash.length = 20;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	for (i = block_offset; i < limit; i++) {
+		int ret;
+
+		ioctl_cmd.flash.status = 0;
+		ioctl_cmd.flash.offset = i;
+		ioctl_cmd.flash.buf = (unsigned char *)&efuse[i];
+
+		ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+		if (ret < 0) {
+			if (ioctl_cmd.flash.status)
+				fprintf(stderr, "FLASH READ status: %d",
+					ioctl_cmd.flash.status);
+			PRINT_IOCTL_FAIL(ret);
+			return -FAIL_IOCTL;
+		}
+		usleep(200000);
+	}
+
+	return SUCCESS;
+}
+
+static int dump_efuse_from_chip(struct ax_command_info *info,
+				struct _ef_data_struct *efuse)
+{
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	return __dump_efuse(info, efuse, 0, 32);
+}
+
+static int find_empty_block_index(struct _ef_data_struct *efuse)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 5; i < EFUSE_NUM_BLOCK; i++) {
+		if (efuse[i].ef_data.type01.type.type == EF_TYPE_REV)
+			break;
+	}
+
+	return (i == EFUSE_NUM_BLOCK) ? -1 : i;
+}
+
+#ifdef ENABLE_IOCTL_DEBUG
+static void dump_efuse_data(struct _ef_data_struct *efuse)
+{
+	int i;
+	unsigned char *data = (unsigned char *)efuse;
+
+	for (i = 0; i < (20 * EFUSE_NUM_BLOCK); i += 4) {
+		printf("%02X %02X %02X %02X",
+			data[i + 3], data[i + 2], data[i + 1], data[i]);
+		if (i % 20 == 0)
+			printf(" == %d", i / 20);
+		printf("\n");
+	}
+
+}
+#define DUMP_EFUSE_DATA(efuse) dump_efuse_data(efuse)
+#else
+#define DUMP_EFUSE_DATA(efuse) while(0){}
+#endif
+
+static int check_efuse_block_valid(unsigned char *data)
+{
+	unsigned int sum = 0;
+	unsigned int tmp;
+	int j = 0;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if ((data[0] & 0xF) == EF_TYPE_REV)
+		return -FAIL_IVALID_VALUE;
+
+	for (j = 0; j < 4; j++) {
+		if (j == 0)
+			sum += data[j] & 0xF;
+		else
+			sum += data[j];
+	}
+
+	while (sum > 0xF)
+		sum = (sum & 0xF) + (sum >> 4);
+
+	sum = 0xF - sum;
+
+	tmp = (data[0] & 0xF) | ((sum << 4) & 0xF0);
+
+	if (tmp != data[0])
+		return -FAIL_IVALID_CHKSUM;
+
+	return SUCCESS;
+}
+
+static int merge_efuse(struct _ef_data_struct *dump_efuse,
+		       struct _ef_data_struct *file_efuse,
+		       unsigned int *program_block, unsigned int *program_index)
+{
+	int dump_empty_index, i, j;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	dump_empty_index = find_empty_block_index(dump_efuse);
+	if (dump_empty_index < 0) {
+		fprintf(stderr, "%s: Non empty block.\n", __func__);
+		return -FAIL_NON_EMPTY_RFUSE_BLOCK;
+	}
+
+	*program_block = 0;
+	*program_index = -1;
+	for (i = 5, j = dump_empty_index; i < EFUSE_NUM_BLOCK; i++, j++) {
+		unsigned char *block = (unsigned char *)&file_efuse[i];
+		int ret;
+
+		if (file_efuse[i].ef_data.type01.type.type == EF_TYPE_REV)
+			break;
+
+		ret = check_efuse_block_valid(block);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: ERROR eFuse block in file.\n", __func__);
+			return ret;
+		}
+		memcpy(&dump_efuse[j], &file_efuse[i], EF_DATA_STRUCT_SIZE);
+		*program_block += 1;
+	}
+
+	*program_index = dump_empty_index;
+	return SUCCESS;
+}
+
+static int __program_efuse_block(struct ax_command_info *info,
+				 struct _ef_data_struct *efuse,
+				 unsigned int block_offset,
+				 unsigned int block_num)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	int i, limit = (block_offset + block_num);
+	struct _ax_ioctl_command ioctl_cmd;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (limit > EFUSE_NUM_BLOCK) {
+		fprintf(stderr, "%s: eFuse block not enough\n", __func__);
+		return -FAIL_IVALID_VALUE;
+	}
+
+	if (scan_ax_device(ifr, info->inet_sock)) {
+		PRINT_SCAN_DEV_FAIL;
+		return -FAIL_SCAN_DEV;
+	}
+
+	ioctl_cmd.ioctl_cmd = AX88179A_PROGRAM_EFUSE;
+	ioctl_cmd.flash.length = 20;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	for (i = block_offset; i < limit; i++) {
+		int ret;
+
+		ioctl_cmd.flash.status = 0;
+		ioctl_cmd.flash.offset = i;
+		ioctl_cmd.flash.buf = (unsigned char *)&efuse[i];
+
+		ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+		if (ret < 0) {
+			if (ioctl_cmd.flash.status)
+				fprintf(stderr, "FLASH PROGRAM status: %d",
+					ioctl_cmd.flash.status);
+			PRINT_IOCTL_FAIL(ret);
+			return -FAIL_IOCTL;
+		}
+	}
+
+	return SUCCESS;
+}
+
+static struct option const long_options[] =
+{
+  {"file", required_argument, NULL, 'f'},
+  {"mac", required_argument, NULL, 'm'},
+  {"serial", required_argument, NULL, 's'},
+  {"device", required_argument, NULL, 'p'},
+  {"led0", required_argument, NULL, 'l'},
+  {"led1", required_argument, NULL, 'e'},
+  {NULL, 0, NULL, 0}
+};
+
+struct __wefuse {
+	char *mac_address;
+	char *serial_num;
+	char *file_path;
+	char *led0;
+	char *led1;
+	char *device;
+	unsigned int MAC[6];
+};
+
+static void creat_sample_efuse(struct _ef_data_struct *efuse,
+			       struct __wefuse *par)
+{
+	int index = 5;
+
+	if (par->mac_address) {
+		memcpy(&efuse[index], sample_type1, EF_TYPE_STRUCT_SIZE_01);
+		if (!strcasecmp(par->device , "AX88179A"))
+			efuse[index].ef_data.type01.bcdDevice = htobe16(0x0200);
+		if (!strcasecmp(par->device , "AX88772D"))
+			efuse[index].ef_data.type01.bcdDevice = htobe16(0x0300);
+		index++;
+	}
+
+	if (par->serial_num)
+		memcpy(&efuse[index++], sample_type4, EF_TYPE_STRUCT_SIZE_04);
+
+	if (par->led0)
+		set_led(&efuse[index++], par->led0, 0);
+
+	if (par->led1)
+		set_led(&efuse[index++], par->led1, 1);
+}
+
+static int print_msg(char *cmd)
+{
+	int i;
+
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(cmd, ax88179a_cmd_list[i].cmd,
+				strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				ax88179a_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+}
+
+static int __check_led_parameter(char *led)
+{
+	if (!led)
+		return 1;
+
+	if (strlen(led) != 9 || led[4] != '_')
+		return 1;
+	do {
+		if (*led++ == '_')
+			continue;
+		if (!isxdigit(*led++))
+			return 1;
+	} while (*led);
+	return 0;
+}
+
+static int __check_wefuse_parameter(struct __wefuse *par)
+{
+	if (par->mac_address)
+		if (!par->device && !par->file_path)
+			return 1;
+
+	if (!par->led0 ^ !par->led1)
+		return 1;
+
+	return 0;
+}
+
+static int writeefuse_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ef_data_struct *file_efuse = NULL;
+	struct _ef_data_struct *dump_efuse = NULL;
+	int i, c, ret;
+	struct __wefuse argument = {0};
+	void *buf = NULL;
+	int oi = -1;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	while ((c = getopt_long(info->argc, info->argv,
+				"m:s:f:p:l:e:",
+				long_options, &oi)) != -1) {
+		switch (c) {
+		case 'm':
+			argument.mac_address = optarg;
+			DEBUG_PRINT("%s \r\n", argument.mac_address);
+			i = sscanf(argument.mac_address,
+				   "%02X:%02X:%02X:%02X:%02X:%02X",
+				   (unsigned int *)&argument.MAC[0],
+				   (unsigned int *)&argument.MAC[1],
+				   (unsigned int *)&argument.MAC[2],
+				   (unsigned int *)&argument.MAC[3],
+				   (unsigned int *)&argument.MAC[4],
+				   (unsigned int *)&argument.MAC[5]);
+			if (i != 6)
+				return print_msg("wefuse");
+			break;
+		case 's':
+			argument.serial_num = optarg;
+			DEBUG_PRINT("%s \r\n", argument.serial_num);
+			if (strlen(argument.serial_num) > 18)
+				return print_msg("wefuse");
+			break;
+		case 'f':
+			argument.file_path = optarg;
+			DEBUG_PRINT("%s \r\n", argument.file_path);
+			break;
+		case 'l':
+			argument.led0 = optarg;
+			DEBUG_PRINT("%s \r\n", argument.led0);
+			if (__check_led_parameter(argument.led0))
+				return print_msg("wefuse");
+			break;
+		case 'e':
+			argument.led1 = optarg;
+			DEBUG_PRINT("%s \r\n", argument.led1);
+			if (__check_led_parameter(argument.led1))
+				return print_msg("wefuse");			
+			break;
+		case 'p':
+			argument.device = optarg;
+			DEBUG_PRINT("%s \r\n", argument.device);
+			if (strcasecmp(argument.device , "AX88179B") &&
+			    strcasecmp(argument.device , "AX88179A") &&
+				strcasecmp(argument.device , "AX88772E") &&
+			    strcasecmp(argument.device , "AX88772D"))
+				return print_msg("wefuse");
+			break;	
+		case '?':
+		default:
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	if (__check_wefuse_parameter(&argument))
+		return print_msg("wefuse");
+
+	buf = calloc(128, EF_DATA_STRUCT_SIZE);
+	if (!buf) {
+		PRINT_ALLCATE_MEM_FAIL;
+		return -FAIL_ALLCATE_MEM;
+	}
+
+	file_efuse = (struct _ef_data_struct *)buf;
+	dump_efuse = (struct _ef_data_struct *)&file_efuse[64];
+
+	if (argument.file_path) {
+		if (load_efuse_from_file(argument.file_path,
+					 (unsigned char *)file_efuse)) {
+			PRINT_LOAD_FILE_FAIL;
+			ret = -PRINT_LOAD_FILE_FAIL;
+			goto fail;
+		}
+	} else {
+		creat_sample_efuse(file_efuse, &argument);
+	}
+
+	DUMP_EFUSE_DATA(file_efuse);
+
+	if (argument.mac_address) {
+		ret = change_mac_address(file_efuse, argument.MAC);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing MAC address failed.\n",
+				__func__);
+			goto fail;
+		}
+	}
+
+	if (argument.serial_num) {
+		ret = change_serial_number(file_efuse, argument.serial_num);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing serial number failed.\n",
+				__func__);
+			goto fail;
+		}
+	}
+
+	autosuspend_enable(info, 0);
+
+	DUMP_EFUSE_DATA(file_efuse);
+
+	ret = dump_efuse_from_chip(info, dump_efuse);
+	if (ret < 0)
+		goto fail;
+
+	DUMP_EFUSE_DATA(dump_efuse);
+
+	do {
+		unsigned int program_block;
+		unsigned int program_index;
+
+		ret = merge_efuse(dump_efuse, file_efuse,
+				  &program_block, &program_index);
+		if (ret < 0)
+			goto fail;
+
+		DUMP_EFUSE_DATA(dump_efuse);
+#ifndef NOT_PROGRAM
+		ret = __program_efuse_block(info, dump_efuse,
+					    program_index, program_block);
+		if (ret < 0)
+			goto fail;
+#endif
+	} while (0);
+#ifndef NOT_PROGRAM
+	usleep(100000);
+
+	ret = dump_efuse_from_chip(info, file_efuse);
+	if (ret < 0)
+		goto fail;
+
+	if (memcmp(file_efuse, dump_efuse, (EF_DATA_STRUCT_SIZE * 32))) {
+		fprintf(stderr, "%s: Comparing efuse failed.\n", __func__);
+		ret = -FAIL_EFUSE_WRITE;
+		goto fail;
+	}
+#endif
+	ret = SUCCESS;
+fail:
+	if (buf)
+		free(buf);
+
+	autosuspend_enable(info, 1);
+
+	return ret;
+}
+
+static int readefuse_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ef_data_struct *dump_efuse = NULL;
+	FILE *pFile = NULL;
+	char str_buf[50];
+	int i, j, c, ret, oi = -1;
+	char *file_path = NULL;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	while ((c = getopt_long(info->argc, info->argv,
+				"f",
+				long_options, &oi)) != -1) {
+		switch (c) {
+		case 'f':
+			file_path = info->argv[optind];
+			break;
+		case '?':
+		default:
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	if (file_path == NULL) {
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp("refuse", ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	dump_efuse = (struct _ef_data_struct *)malloc(EF_DATA_STRUCT_SIZE * 32);
+	if (!dump_efuse) {
+		PRINT_ALLCATE_MEM_FAIL;
+		return -FAIL_ALLCATE_MEM;
+	}
+	memset(dump_efuse, 0, EF_DATA_STRUCT_SIZE * 32);
+
+	autosuspend_enable(info, 0);
+
+	ret = dump_efuse_from_chip(info, dump_efuse);
+	if (ret < 0)
+		goto fail;
+
+	pFile = fopen(file_path, "w");
+	if (pFile == NULL) {
+		fprintf(stderr, "%s: Fail to open %s file.\n",
+			__func__, file_path);
+		ret = -FAIL_LOAD_FILE;
+		goto fail;
+	}
+
+	DUMP_EFUSE_DATA(dump_efuse);
+
+	for (i = 0; i < 32; i++) {
+		unsigned char *buf = (unsigned char *)&dump_efuse[i];
+
+		for (j = 0; j < 5; j++) {
+			snprintf(str_buf, 50, "%02x %02x %02x %02x\n",
+				 buf[(j * 4) + 3],
+				 buf[(j * 4) + 2],
+				 buf[(j * 4) + 1],
+				 buf[(j * 4)]);
+			fputs(str_buf, pFile);
+		}
+	}
+
+	ret = SUCCESS;
+fail:
+	if (dump_efuse)
+		free(dump_efuse);
+	if (pFile)
+		fclose(pFile);
+
+	autosuspend_enable(info, 1);
+	
+	return ret;
+}
+
+static int reload_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	char fw_version[16] = {0};
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 2) {
+		int i;
+
+		for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88179a_cmd_list[i].cmd,
+				    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88179a_cmd_list[i].help_ins,
+				       ax88179a_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	if (scan_ax_device(ifr, info->inet_sock)) {
+		PRINT_SCAN_DEV_FAIL;
+		return -FAIL_SCAN_DEV;
+	}
+
+	autosuspend_enable(info, 0);
+
+	sw_reset(info);
+
+	if (scan_ax_device(ifr, info->inet_sock)) {
+		PRINT_SCAN_DEV_FAIL;
+		return -FAIL_SCAN_DEV;
+	}
+
+	return SUCCESS;
+}
+
+static int scan_ax_device(struct ifreq *ifr, int inet_sock)
+{
+	unsigned int retry;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (retry = 0; retry < SCAN_DEV_MAX_RETRY; retry++) {
+		unsigned int i;
+		struct _ax_ioctl_command ioctl_cmd;
+#if NET_INTERFACE == INTERFACE_SCAN
+		struct ifaddrs *addrs, *tmp;
+		unsigned char	dev_exist;
+
+		getifaddrs(&addrs);
+		tmp = addrs;
+		dev_exist = 0;
+
+		while (tmp) {
+			memset(&ioctl_cmd, 0,
+			       sizeof(struct _ax_ioctl_command));
+			ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+			sprintf(ifr->ifr_name, "%s", tmp->ifa_name);
+			tmp = tmp->ifa_next;
+
+			ioctl(inet_sock, SIOCGIFFLAGS, ifr);
+			if (!(ifr->ifr_flags & IFF_UP))
+				continue;
+
+			ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+			if (ioctl(inet_sock, AX_PRIVATE, ifr) < 0)
+				continue;
+
+			if (strncmp(ioctl_cmd.sig,
+				    AX88179A_DRV_NAME,
+				    strlen(AX88179A_DRV_NAME)) == 0) {
+				dev_exist = 1;
+				break;
+			}
+		}
+
+		freeifaddrs(addrs);
+
+		if (dev_exist)
+			break;
+#else
+		for (i = 0; i < 255; i++) {
+
+			memset(&ioctl_cmd, 0,
+			       sizeof(struct _ax_ioctl_command));
+			ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+			sprintf(ifr->ifr_name, "eth%u", i);
+
+			ioctl(inet_sock, SIOCGIFFLAGS, ifr);
+			if (!(ifr->ifr_flags & IFF_UP))
+				continue;
+
+			ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+			if (ioctl(inet_sock, AX_PRIVATE, ifr) < 0)
+				continue;
+
+			if (strncmp(ioctl_cmd.sig,
+				    AX88179A_DRV_NAME,
+				    strlen(AX88179A_DRV_NAME)) == 0)
+				break;
+
+		}
+
+		if (i < 255)
+			break;
+#endif
+		usleep(500000);
+	}
+
+	if (retry >= SCAN_DEV_MAX_RETRY)
+		return -FAIL_SCAN_DEV;
+
+	return SUCCESS;
+}
+
+int main(int argc, char **argv)
+{
+	struct ifreq ifr;
+	struct ax_command_info info;
+	unsigned int i;
+	int inet_sock, ret = -FAIL_GENERIAL_ERROR;
+
+	printf("%s\n", AX88179A_IOCTL_VERSION);
+
+	if (argc < 2) {
+		show_usage();
+		return SUCCESS;
+	}
+
+	inet_sock = socket(AF_INET, SOCK_DGRAM, 0);
+#ifndef NOT_PROGRAM 
+	if (scan_ax_device(&ifr, inet_sock)) {
+		printf("No %s found\n", AX88179A_SIGNATURE);
+		return FAIL_SCAN_DEV;
+	}
+#endif
+	for (i = 0; ax88179a_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(argv[1],
+			    ax88179a_cmd_list[i].cmd,
+			    strlen(ax88179a_cmd_list[i].cmd)) == 0) {
+			info.help_ins = ax88179a_cmd_list[i].help_ins;
+			info.help_desc = ax88179a_cmd_list[i].help_desc;
+			info.ifr = &ifr;
+			info.argc = argc;
+			info.argv = argv;
+			info.inet_sock = inet_sock;
+			info.ioctl_cmd = ax88179a_cmd_list[i].ioctl_cmd;
+			ret = (ax88179a_cmd_list[i].OptFunc)(&info);
+			goto out;
+		}
+	}
+
+	if (ax88179a_cmd_list[i].cmd == NULL) {
+		show_usage();
+		return SUCCESS;
+	}
+out:
+	if (ret == SUCCESS)
+		printf("SUCCESS\n");
+	else if (ret != -FAIL_INVALID_PARAMETER)
+		printf("FAIL\n");
+
+	return ret;
+}
diff --git a/drivers/net/usb/asix_usb/ax88279_programmer.c b/drivers/net/usb/asix_usb/ax88279_programmer.c
new file mode 100644
index 000000000000..875298361c5c
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax88279_programmer.c
@@ -0,0 +1,1813 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <getopt.h>
+#include <endian.h>
+#if NET_INTERFACE == INTERFACE_SCAN
+#include <ifaddrs.h>
+#endif
+#include "ax_ioctl.h"
+#ifdef ENABLE_IOCTL_DEBUG
+#define NOT_PROGRAM
+#endif
+#define RELOAD_DELAY_TIME	10	// sec
+
+#define PRINT_IOCTL_FAIL(ret) \
+fprintf(stderr, "%s: ioctl failed. (err: %d)\n", __func__, ret)
+#define PRINT_SCAN_DEV_FAIL \
+fprintf(stderr, "%s: Scaning device failed.\n", __func__)
+#define PRINT_ALLCATE_MEM_FAIL \
+fprintf(stderr, "%s: Fail to allocate memory.\n", __func__)
+#define PRINT_LOAD_FILE_FAIL \
+fprintf(stderr, "%s: Read file failed.\n", __func__)
+
+#define AX88179A_IOCTL_VERSION \
+"AX88279 Linux Flash Programming Tool v1.0.0 beat1"
+
+const char help_str1[] =
+"./ax88279_programmer help [command]\n"
+"    -- command description\n";
+const char help_str2[] =
+"        [command] - Display usage of specified command\n";
+
+const char readverion_str1[] =
+"./ax88279_programmer rversion\n"
+"    -- AX88279 Read Firmware Verion\n";
+static const char readverion_str2[] = "";
+
+const char readmac_str1[] =
+"./ax88279_programmer rmacaddr\n"
+"    -- AX88279 Read MAC Address\n";
+static const char readmac_str2[] = "";
+
+const char writeflash_str1[] =
+"./ax88279_programmer wflash [file]\n"
+"    -- AX88279 Write Flash\n";
+const char writeflash_str2[] =
+"        [file]    - Flash file path\n";
+
+const char writeparameter_str1[] =
+"./ax88279_programmer wpara -m [MAC] -s [SN] -p [PID] -v [VID] -P [PS] -M [MN] -D [dump]\n"
+"                           -S [SS] -H [HS] -w [wol] -l [led0 value] -e [led1 value] -d [led2 value]\n"
+"    -- AX88279 Write Parameter\n";
+const char writeparameter_str2[] =
+"        -m [MAC]   	 - MAC address (XX:XX:XX:XX:XX:XX) X:'0'-'F'\n"
+"        -s [SN]    	 - Serial Number (Characters must be less than 19 bytes) X:'0'-'F'\n"
+"        -p [PID]   	 - Product ID (XX:XX) X:'0'-'F'\n"
+"        -v [VID]   	 - Vendor ID (XX:XX) X:'0'-'F'\n"
+"        -P [PS]    	 - Product String (Characters must be less than 19 bytes)\n"
+"        -M [MN]    	 - Manufacture Name (Characters must be less than 19 bytes)\n"
+"        -D [dump]	 - The parameter content currently in flash (dump)\n"
+"        -S [SS]    	 - SS bus power (XX) X:0-896\n"
+"        -H [HS]    	 - HS bus power (XX) X:0-500\n"
+"        -w [wol]    	 - wake on LAN (XXXXXXXX) X:digit\n"
+"        -l [led0 value]	 - value: control_blink (XXXX_XXXX)\n"
+"        -e [led1 value]	 - value: control_blink (XXXX_XXXX)\n";
+
+const char reload_str1[] =
+"./ax88279_programmer reload\n"
+"    -- AX88279 Reload\n";
+static const char reload_str2[] = "";
+
+static int help_func(struct ax_command_info *info);
+static int readversion_func(struct ax_command_info *info);
+static int readmac_func(struct ax_command_info *info);
+static int writeflash_func(struct ax_command_info *info);
+static int writeparameter_func(struct ax_command_info *info);
+static int reload_func(struct ax_command_info *info);
+static int scan_ax_device(struct ifreq *ifr, int inet_sock);
+
+struct _command_list ax88279_cmd_list[] = {
+	{
+		"help",
+		AX_SIGNATURE,
+		help_func,
+		help_str1,
+		help_str2
+	},
+	{
+		"rversion",
+		AX88179A_READ_VERSION,
+		readversion_func,
+		readverion_str1,
+		readverion_str2
+	},
+	{
+		"rmacaddr",
+		~0,
+		readmac_func,
+		readmac_str1,
+		readmac_str2
+	},
+	{
+		"wflash",
+		AX88179A_WRITE_FLASH,
+		writeflash_func,
+		writeflash_str1,
+		writeflash_str2
+	},
+	{
+		"wpara",
+		AX88179A_PROGRAM_EFUSE,
+		writeparameter_func,
+		writeparameter_str1,
+		writeparameter_str2
+	},
+	{
+		"reload",
+		~0,
+		reload_func,
+		reload_str1,
+		reload_str2
+	},
+	{
+		NULL,
+		0,
+		NULL,
+		NULL,
+		NULL
+	}
+};
+
+static struct option const long_options[] =
+{
+  {"mac", required_argument, NULL, 'm'},
+  {"serial", required_argument, NULL, 's'},
+  {"pid", required_argument, NULL, 'p'},
+  {"vid", required_argument, NULL, 'v'},
+  {"Product", required_argument, NULL, 'P'},
+  {"Manufacture", required_argument, NULL, 'M'},
+  {"dump", required_argument, NULL, 'D'},
+  {"ssbus", required_argument, NULL, 'S'},
+  {"hsbus", required_argument, NULL, 'H'},
+  {"wol", required_argument, NULL, 'w'},
+  {"led0", required_argument, NULL, 'l'},
+  {"led1", required_argument, NULL, 'e'},
+  {NULL, 0, NULL, 0}
+};
+
+struct __wpara {
+	char *mac_address;
+	char *serial_num;
+	char *PID;
+	char *VID;
+	char *product_string;
+	char *manufacture;
+	char *dump;
+	char *ss_bus;
+	char *hs_bus;
+	char *wol;
+	char *led0;
+	char *led1;
+	unsigned int iss_bus;
+	unsigned int ihs_bus;	
+	unsigned int MAC[6];
+	unsigned int LED0[9];
+	unsigned int LED1[9];
+	unsigned int pid[2];
+	unsigned int vid[2];
+	unsigned int ssbus[1];
+	unsigned int hsbus[1];
+};
+
+static unsigned char sample_type1[] = {
+ 0x01, 0x0B, 0x95, 0x17,
+ 0x90, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x01, 0x04,
+ 0x00, 0x0A, 0x07, 0xFF,
+ 0x39, 0xE1, 0x20, 0x00
+};
+
+static unsigned char sample_type2[] = {
+ 0x02, 0x41, 0x53, 0x49,
+ 0x58, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00
+};
+
+static unsigned char sample_type3[] = {
+ 0x03, 0x41, 0x58, 0x38,
+ 0x38, 0x32, 0x37, 0x39,
+ 0x41, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00
+};
+
+static unsigned char sample_type4[] = {
+ 0x04, 0x30, 0x30, 0x30,
+ 0x30, 0x30, 0x30, 0x30,
+ 0x31, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00
+};
+
+static unsigned char sample_type11[] = {
+ 0x0B, 0x1F, 0x00, 0x00,
+ 0x00, 0x00, 0x1F, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x45, 0x0B
+};
+
+static unsigned char sample_type15[] = {
+ 0x0F, 0x7D, 0x01, 0x63,
+ 0x81, 0x7F, 0x7F, 0x5F,
+ 0x5D, 0x2F, 0x07, 0xE8,
+ 0x04, 0x7D, 0x00, 0xC8,
+ 0x08, 0x01, 0x04, 0x00
+};
+
+#pragma pack(push)
+#pragma pack(1)
+enum Para_Type_Def {
+	TYPE_REV = 0x00,
+	TYPE_01 = 0x01,
+	TYPE_02 = 0x02,
+	TYPE_03 = 0x03,
+	TYPE_04 = 0x04,
+	TYPE_11 = 0x0B,
+	TYPE_15 = 0x0F,
+};
+struct _ef_type {
+#if __BYTE_ORDER == __BIG_ENDIAN
+	unsigned char	checksum: 4;
+	unsigned char	type	: 4;
+#else
+	unsigned char	type	: 4;
+	unsigned char	checksum: 4;
+#endif
+};
+
+struct _ef_type01 {
+	struct _ef_type	type;
+	unsigned short	vid;
+	unsigned short	pid;
+	unsigned char	mac[6];
+	unsigned short	bcdDevice;
+	unsigned char	bU1DevExitLat;
+	unsigned short	wU2DevExitLat;
+	unsigned char	SS_Max_Bus_Pw;
+	unsigned char	HS_Max_Bus_Pw;
+	unsigned char	IPSleep_Polling_Count;
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_01	sizeof(struct _ef_type01)
+
+struct _ef_type02 {
+	struct _ef_type	type;
+	unsigned char	m_string[18];
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_02	sizeof(struct _ef_type02)
+
+struct _ef_type03 {
+	struct _ef_type	type;
+	unsigned char	p_string[18];
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_03	sizeof(struct _ef_type03)
+
+struct _ef_type04 {
+	struct _ef_type	type;
+	unsigned char	serial[18];
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_04	sizeof(struct _ef_type04)
+
+struct _ef_type11 {
+	struct _ef_type	type;
+	unsigned char	dev_type0;
+	unsigned short	reg0;
+	unsigned short	value0;
+
+	unsigned char	dev_type1;
+	unsigned short	reg1;
+	unsigned short	value1;
+
+	unsigned char	dev_type2;
+	unsigned short	reg2;
+	unsigned short	value2;
+
+	unsigned char	reserved1[2];
+	unsigned char	subtype;
+	unsigned char	endofs;
+};
+#define EF_TYPE_STRUCT_SIZE_11	sizeof(struct _ef_type11)
+
+struct _ef_type15 {
+	struct _ef_type	type;
+	unsigned char	flag1;
+	unsigned char	flag2;
+	unsigned char	flag3;
+	unsigned char	flag4;
+	unsigned char	U1_inact_timer;
+	unsigned char	U2_inact_timer;
+	unsigned char	Lpm_besl_u3;
+	unsigned char	Lpm_besl;
+	unsigned char	Lpm_besld;
+	unsigned short	Ltm_belt_down;
+	unsigned short	Ltm_belt_up;
+	unsigned short	Ephy_poll_timer;
+
+	unsigned char	Pme_gpio_sel;
+	unsigned char	Pme_pulse_width;
+	unsigned char	Wol_mask_timer;
+
+	unsigned char	reserve;
+};
+#define EF_TYPE_STRUCT_SIZE_15	sizeof(struct _ef_type15)
+
+struct _ef_data_struct {
+	union {
+		struct _ef_type01 type01;
+		struct _ef_type02 type02;
+		struct _ef_type03 type03;
+		struct _ef_type04 type04;
+		struct _ef_type11 type11;
+		struct _ef_type15 type15;
+	} ef_data;
+};
+#define EF_DATA_STRUCT_SIZE	sizeof(struct _ef_data_struct)
+#pragma pack(pop)
+
+static void show_usage(void)
+{
+	int i;
+
+	printf("Usage:\n");
+	for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++)
+		printf("%s\n", ax88279_cmd_list[i].help_ins);
+}
+
+static int help_func(struct ax_command_info *info)
+{
+	int i;
+
+	if (info->argv[2] == NULL)
+		return -FAIL_INVALID_PARAMETER;
+
+	for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(info->argv[2],
+			    ax88279_cmd_list[i].cmd,
+			    strlen(ax88279_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n", ax88279_cmd_list[i].help_ins,
+			       ax88279_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	return SUCCESS;
+}
+
+static int autosuspend_enable(struct ax_command_info *info,
+			      unsigned char enable)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_AUTOSUSPEND_EN;
+
+	ioctl_cmd.autosuspend.enable = enable;
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int read_version(struct ax_command_info *info, char *version)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_READ_VERSION;
+
+	memset(ioctl_cmd.version.version, 0, 16);
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	memcpy(version, ioctl_cmd.version.version, 16);
+
+	return SUCCESS;
+}
+
+static int read_mac_address(struct ax_command_info *info, unsigned char *mac)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ret = scan_ax_device(ifr, info->inet_sock);
+	if (ret < 0) {
+		PRINT_SCAN_DEV_FAIL;
+		return ret;
+	}
+
+	ifr->ifr_flags &= 0;
+	ret = ioctl(info->inet_sock, SIOCSIFFLAGS, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	usleep(20000);
+
+	ifr->ifr_flags = IFF_UP | IFF_BROADCAST | IFF_MULTICAST;
+	ret = ioctl(info->inet_sock, SIOCSIFFLAGS, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	usleep(20000);
+
+	ret = ioctl(info->inet_sock, SIOCGIFHWADDR, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	memcpy(mac, ifr->ifr_hwaddr.sa_data, 6);
+
+	return SUCCESS;
+}
+
+static int readversion_func(struct ax_command_info *info)
+{
+	char version[16] = {0};
+	int i, ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 2) {
+		for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88279_cmd_list[i].cmd,
+				    strlen(ax88279_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88279_cmd_list[i].help_ins,
+				       ax88279_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	ret = scan_ax_device(info->ifr, info->inet_sock);
+    if (ret < 0) {
+            PRINT_SCAN_DEV_FAIL;
+            return ret;
+    }
+
+	autosuspend_enable(info, 0);
+
+	ret = read_version(info, version);
+	if (ret == SUCCESS)
+		printf("Firmware Version: %s\n", version);
+
+	usleep(20000);
+
+	autosuspend_enable(info, 1);
+
+	return ret;
+}
+
+static int readmac_func(struct ax_command_info *info)
+{
+	unsigned char mac[6] = {0};
+	int i, ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 2) {
+		for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88279_cmd_list[i].cmd,
+				    strlen(ax88279_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88279_cmd_list[i].help_ins,
+				       ax88279_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	ret = read_mac_address(info, mac);
+	if (ret == SUCCESS)
+		printf("MAC address: %02X:%02X:%02X:%02X:%02X:%02X\n",
+			mac[0],
+			mac[1],
+			mac[2],
+			mac[3],
+			mac[4],
+			mac[5]);
+
+	return ret;
+}
+
+static int write_flash(struct ax_command_info *info, unsigned char *data,
+		       unsigned long offset, unsigned long len)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_WRITE_FLASH;
+	ioctl_cmd.flash.status = 0;
+	ioctl_cmd.flash.offset = offset;
+	ioctl_cmd.flash.length = len;
+	ioctl_cmd.flash.buf = data;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		if (ioctl_cmd.flash.status)
+			fprintf(stderr, "FLASH WRITE status: %d",
+				ioctl_cmd.flash.status);
+		PRINT_IOCTL_FAIL(ret);
+		return ret;
+	}
+
+	return SUCCESS;
+}
+
+static int read_flash(struct ax_command_info *info, unsigned char *data,
+		      unsigned long offset, unsigned long len)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_READ_FLASH;
+	ioctl_cmd.flash.status = 0;
+	ioctl_cmd.flash.offset = offset;
+	ioctl_cmd.flash.length = len;
+	ioctl_cmd.flash.buf = data;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		if (ioctl_cmd.flash.status)
+			fprintf(stderr, "FLASH READ status: %d",
+				ioctl_cmd.flash.status);
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int erase_flash(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_ERASE_FLASH;
+	ioctl_cmd.flash.status = 0;
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int erase_sector_flash(struct ax_command_info *info, int offset)
+{
+
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	int ret;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_ERASE_SECTOR_FLASH;
+	ioctl_cmd.flash.status = 0;
+	ioctl_cmd.flash.offset = offset;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	ret = ioctl(info->inet_sock, AX_PRIVATE, ifr);
+	if (ret < 0) {
+		PRINT_IOCTL_FAIL(ret);
+		return -FAIL_IOCTL;
+	}
+
+	return SUCCESS;
+}
+
+static int boot_to_rom(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_ROOT_2_ROM;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+	ioctl(info->inet_sock, AX_PRIVATE, ifr);
+
+	return SUCCESS;
+}
+
+static int sw_reset(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	ioctl_cmd.ioctl_cmd = AX88179A_SW_RESET;
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+	ioctl(info->inet_sock, AX_PRIVATE, ifr);
+
+	usleep(RELOAD_DELAY_TIME * 100000);
+
+	return SUCCESS;
+}
+
+static int find_offest_min_index(int *offset_arr, int size)
+{
+	int i = 0;
+	int min = offset_arr[0];
+
+	for (i = 1; i < size; i++) {
+        if (offset_arr[i] < min) {
+            min = offset_arr[i];
+        }
+    }
+
+	return min;
+}
+
+static int find_offest_max_index(int *offset_arr, int size)
+{
+	int i = 0;
+	int max = offset_arr[0];
+
+	for (i = 1; i < size; i++) {
+		if (offset_arr[i] >= max) {
+				max = i;
+		}
+	}
+
+	return max;
+}
+
+static int writeflash_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	unsigned char *wbuf = NULL, *rbuf = NULL;
+	FILE *pFile = NULL;
+	size_t result;
+	int file_length = 0;
+	int i, offset, ret;
+	char fw_version[16] = {0};
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 3) {
+		for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88279_cmd_list[i].cmd,
+				    strlen(ax88279_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88279_cmd_list[i].help_ins,
+				       ax88279_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	autosuspend_enable(info, 0);
+
+	ret = scan_ax_device(ifr, info->inet_sock);
+	if (ret < 0) {
+		PRINT_SCAN_DEV_FAIL;
+		return ret;
+	}
+
+	ret = erase_flash(info);
+	if (ret < 0) 
+		return ret;
+
+	pFile = fopen(info->argv[2], "rb");
+	if (pFile == NULL) {
+		fprintf(stderr, "%s: Fail to open %s file.\n",
+			__func__, info->argv[2]);
+		ret = -FAIL_LOAD_FILE;
+		goto fail;
+	}
+
+	fseek(pFile, 0, SEEK_END);
+	file_length = ftell(pFile);
+	fseek(pFile, 0, SEEK_SET);
+
+	wbuf = (unsigned char *)malloc((file_length + 256) & ~(0xFF));
+	if (!wbuf) {
+		PRINT_ALLCATE_MEM_FAIL;
+		ret = -FAIL_ALLCATE_MEM;
+		goto fail;
+	}
+	memset(wbuf, 0, (file_length + 256) & ~(0xFF));
+
+	result = fread(wbuf, 1, file_length, pFile);
+	if (result != file_length) {
+		PRINT_LOAD_FILE_FAIL;
+		ret = -PRINT_LOAD_FILE_FAIL;
+		goto fail;
+	}
+
+	ret = write_flash(info, wbuf, FLASH_PARA_OFFSET, result);
+	if (ret < 0)
+		goto fail;
+
+	ret = write_flash(info, wbuf, 0, FLASH_PARA_OFFSET);
+	if (ret < 0)
+		goto fail;
+
+	offset = SWAP_32(*(unsigned long *)&wbuf[0]);
+	sprintf(fw_version, "v%d.%d.%d",
+		wbuf[offset + 0x1000],
+		wbuf[offset + 0x1001],
+		wbuf[offset + 0x1002]);
+	printf("File FW Version: %s\n", fw_version);
+	
+	ret = SUCCESS;
+	goto out;
+
+fail:
+	erase_flash(info);
+out:
+	if (wbuf)
+		free(wbuf);
+	if (pFile)
+		fclose(pFile);
+
+	autosuspend_enable(info, 1);
+
+	return ret;
+}
+
+static int print_msg(char *cmd)
+{
+	int i;
+
+	printf("\n");
+	for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(cmd, ax88279_cmd_list[i].cmd,
+				strlen(ax88279_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n", ax88279_cmd_list[i].help_ins,
+				ax88279_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+}
+
+static int find_block_index(unsigned char *rpara_databuf, int para_size
+							, enum Para_Type_Def type)
+{
+	int i = 0;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < para_size; i += 20) {
+		if ((rpara_databuf[i] & 0x0F) == type)
+			return i / 20;
+	}
+
+	return -FAIL_GENERIAL_ERROR;
+}
+
+static int change_para_macaddr(unsigned char *rpara_databuf, int block_index, unsigned int *mac)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 6; i++)
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 5 + i] = (unsigned char)mac[i];
+
+	return SUCCESS;
+}
+
+static int change_para_serialnum(unsigned char *rpara_databuf, int block_index, char *serial)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 18; i++) {
+		if (serial[i] == '-')
+			break;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1 + i] = serial[i];
+	}
+
+	return SUCCESS;
+}
+
+static int change_para_pid(unsigned char *rpara_databuf, int block_index, unsigned int *pid)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 2; i++)
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 3 + i] = (unsigned char)pid[i];
+
+	return SUCCESS;
+}
+
+static int change_para_vid(unsigned char *rpara_databuf, int block_index, unsigned int *vid)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 2; i++)
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1 + i] = (unsigned char)vid[i];
+
+	return SUCCESS;
+}
+
+static int change_para_productstr(unsigned char *rpara_databuf, int block_index, char *productstr)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 18; i++) {
+		if (productstr[i] == '-')
+			break;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1 + i] = productstr[i];
+	}
+
+	return SUCCESS;
+}
+
+static int change_para_manufacture(unsigned char *rpara_databuf, int block_index, char *manufac)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 18; i++) {
+		if (manufac[i] == '-')
+			break;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1 + i] = manufac[i];
+	}
+
+	return SUCCESS;
+}
+
+static int change_para_ssbus(unsigned char *rpara_databuf, int block_index, int issbus)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 1; i++) 
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 16 + i] = (issbus / 8);
+
+	return SUCCESS;
+}
+
+static int change_para_hsbus(unsigned char *rpara_databuf, int block_index, int ihsbus)
+{
+	int i;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 1; i++) 
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 17 + i] = (ihsbus / 2);
+
+	return SUCCESS;
+}
+
+static int change_para_wol(unsigned char *rpara_databuf, int block_index, char *wol)
+{
+	int i = 0;
+	unsigned int dwolEn = 0;
+	unsigned int s5wolEn = 0;
+	unsigned int pmeEn = 0;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (i = 0; i < 8; i++) {
+		unsigned char bit_value = 0;
+		bit_value = wol[i] & 1;
+
+		if (i == 0 && bit_value == 1) {
+			dwolEn = 1;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] &= ~0x01;
+			break; 
+		}
+		if (i == 1 && bit_value == 1) {
+			pmeEn = 1;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x10;
+		}
+		if (i == 2 && bit_value == 1) {
+			dwolEn = 1;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] |= 0x02;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x1C;
+		}
+		if (i == 3 && bit_value == 1) {
+			dwolEn = 1;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] |= 0x02;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x1A;
+		}
+		if (i == 4 && bit_value == 1) {
+			s5wolEn = 1;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] |= 0x02;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x18;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 4] |= 0x28;
+		}
+		if (i == 5 && bit_value == 1) {
+			s5wolEn = 1;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] |= 0x02;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x18;
+			rpara_databuf[block_index * FLASH_BLOCK_SIZE + 4] |= 0x18;
+		}
+
+		if (dwolEn || s5wolEn || pmeEn) {
+			if (i == 6 && bit_value == 1) {
+				rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x80;
+			}
+			if (i == 7 && bit_value == 1) {
+				rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] |= 0x40;
+			}
+
+		}
+	}
+
+	return SUCCESS;
+}
+
+static void set_para_led0(unsigned char *rpara_databuf, int block_index,  unsigned int *led)
+{
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] = 0x1F;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] = 0x00;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 3] = 0x24;
+
+	if (led) {
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 4] = led[0];
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 5] = led[1];
+
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 9] = led[2];
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 10] = led[3];
+	} else {
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 4] = 0xC1;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 5] = 0x03;
+
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 9] = 0x00;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 10] = 0x00;
+	}
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 6] = 0x1F;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 7] = 0x00;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 8] = 0x25;
+
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 18] = 0x45;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 19] = 0x0B;
+
+}
+
+static void set_para_led1(unsigned char *rpara_databuf, int block_index,  unsigned int *led)
+{
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 1] = 0x1F;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 2] = 0x00;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 3] = 0x26;
+
+	if (led) {
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 4] = led[0];
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 5] = led[1];
+
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 9] = led[2];
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 10] = led[3];
+	} else {
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 4] = 0xC0;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 5] = 0x00;
+
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 9] = 0x0C;
+		rpara_databuf[block_index * FLASH_BLOCK_SIZE + 10] = 0x0F;
+	}
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 6] = 0x1F;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 7] = 0x00;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 8] = 0x27;
+
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 18] = 0x45;
+	rpara_databuf[block_index * FLASH_BLOCK_SIZE + 19] = 0x0B;
+}
+
+static int program_para_block(struct ax_command_info *info, unsigned char *rpara_databuf, int para_size)
+{
+	int ret;
+
+	ret = write_flash(info, rpara_databuf, 0, para_size);
+	if (ret < 0)
+		return -1;
+	
+	return 0;
+}
+
+static int calculate_para_offset(void *buf)
+{
+	unsigned char *data = (unsigned char *)buf;
+	int offset[8];
+	int len[8];
+	int max;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	offset[0] = SWAP_32(*(unsigned int *)&data[PRAM_PRI_FW1_OFFSET]);
+	len[0] = SWAP_32(*(unsigned int *)&data[PRAM_PRI_FW1_LENGTH]);
+	offset[1] = SWAP_32(*(unsigned int *)&data[MD32_PRI_FW1_OFFSET]);
+	len[1] = SWAP_32(*(unsigned int *)&data[MD32_PRI_FW1_LENGTH]);
+	offset[2] = SWAP_32(*(unsigned int *)&data[PRAM_SEC_FW1_OFFSET]);
+	len[2] = SWAP_32(*(unsigned int *)&data[PRAM_SEC_FW1_LENGTH]);
+	offset[3] = SWAP_32(*(unsigned int *)&data[MD32_SEC_FW1_OFFSET]);
+	len[3] = SWAP_32(*(unsigned int *)&data[MD32_SEC_FW1_LENGTH]);
+	offset[4] = SWAP_32(*(unsigned int *)&data[PRAM_PRI_FW2_OFFSET]);
+	len[4] = SWAP_32(*(unsigned int *)&data[PRAM_PRI_FW2_LENGTH]);
+	offset[5] = SWAP_32(*(unsigned int *)&data[MD32_PRI_FW2_OFFSET]);
+	len[5] = SWAP_32(*(unsigned int *)&data[MD32_PRI_FW2_LENGTH]);
+	offset[6] = SWAP_32(*(unsigned int *)&data[PRAM_SEC_FW2_OFFSET]);
+	len[6] = SWAP_32(*(unsigned int *)&data[PRAM_SEC_FW2_LENGTH]);
+	offset[7] = SWAP_32(*(unsigned int *)&data[MD32_SEC_FW2_OFFSET]);
+	len[7] = SWAP_32(*(unsigned int *)&data[MD32_SEC_FW2_LENGTH]);
+
+	max = find_offest_max_index(offset, 8);
+
+	return (offset[max] + len[max] + 0x10000) & ~(0xFFFF);
+}
+
+void dump(unsigned char *buf, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		printf("%02X ", buf[i]);
+		if (i % 4 == 3)
+			printf("\n");
+	}
+	printf("\n");
+}
+
+static void checksum_efuse_block(unsigned char *block)
+{
+	unsigned int Sum = 0;
+	int j;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (j = 0; j < 4; j++) {
+		if (j == 0)
+			Sum += block[j] & 0xF;
+		else
+			Sum += block[j];
+	}
+
+	while (Sum > 0xF)
+		Sum = (Sum & 0xF) + (Sum >> 4);
+
+	Sum = 0xF - Sum;
+
+	block[0] = (block[0] & 0xF) | ((Sum << 4) & 0xF0);
+}
+
+static void checksum_para_header(unsigned short *header)
+{
+	unsigned int Sum = 0;
+	unsigned short j;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (j = 0; j < 5; j++)
+		Sum += header[j];
+
+	while (Sum > 0xFFFF)
+		Sum = (Sum & 0xFFFF) + (Sum >> 16);
+
+	Sum = 0xFFFF - Sum;
+
+	header[5] = (Sum);
+}
+
+static int check_hex(char *temp, int size)
+{
+	int i = 0;
+	unsigned char *ptemp = temp;
+
+	for (i = 0; i < size; i++) {
+		if (ptemp[i] == ':') {
+			i++;
+			continue;
+		}
+		
+		if(!(isxdigit(ptemp[i])))
+			return -FAIL_INVALID_PARAMETER;
+	}
+
+	return 0;
+}
+
+static int check_led_parameter(char *led)
+{
+	if (!led)
+		return 1;
+
+	if (strlen(led) != 9 || led[4] != '_')
+		return 1;
+	do {
+		if (*led++ == '_')
+			continue;
+		if (!isxdigit(*led++))
+			return 1;
+	} while (*led);
+
+	return 0;
+}
+
+static int writeparameter_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	unsigned char *rpara_buf = NULL;
+	int para_offset, block_count, para_size, ret, block_index, c, i;
+	int oi = -1;
+	struct __wpara argument = {0};
+	int temp_para_offset = 0;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	while ((c = getopt_long(info->argc, info->argv,
+				"m:s:p:v:P:M:D:S:H:w:l:e:d:",
+				long_options, &oi)) != -1) {
+		switch (c) {
+		case 'm':
+			argument.mac_address = optarg;
+			DEBUG_PRINT("%s \r\n", argument.mac_address);
+			i = sscanf(argument.mac_address,
+				   "%02X:%02X:%02X:%02X:%02X:%02X",
+				   (unsigned int *)&argument.MAC[0],
+				   (unsigned int *)&argument.MAC[1],
+				   (unsigned int *)&argument.MAC[2],
+				   (unsigned int *)&argument.MAC[3],
+				   (unsigned int *)&argument.MAC[4],
+				   (unsigned int *)&argument.MAC[5]);
+			if (i != 6)
+				return print_msg("wpara");
+			break;
+		case 's':
+			argument.serial_num = optarg;
+			DEBUG_PRINT("%s \r\n", argument.serial_num);
+			if (strlen(argument.serial_num) > 18) {
+				printf("characters must be less than 19 bytes\n");
+				return print_msg("wpara");
+			}
+			break;
+		case 'p':
+			argument.PID = optarg;
+			DEBUG_PRINT("%s \r\n", argument.PID);
+			i = sscanf(argument.PID,
+				   "%02X:%02X",
+				   (unsigned int *)&argument.pid[0],
+				   (unsigned int *)&argument.pid[1]);
+			if (i != 2)
+				return print_msg("wpara");
+			break;
+		case 'v':
+			argument.VID = optarg;
+			DEBUG_PRINT("%s \r\n", argument.VID);
+			i = sscanf(argument.VID,
+				   "%02X:%02X",
+				   (unsigned int *)&argument.vid[0],
+				   (unsigned int *)&argument.vid[1]);
+			if (i != 2)
+				return print_msg("wpara");
+			break;
+		case 'P':
+			argument.product_string = optarg;
+			DEBUG_PRINT("%s \r\n", argument.product_string);
+			if (strlen(argument.product_string) > 18)
+				return print_msg("wpara");
+			break;
+		case 'D':
+			argument.dump = optarg;
+			DEBUG_PRINT("%s \r\n", argument.dump);
+			if (strcasecmp(argument.dump , "dump"))
+				return print_msg("wpara");
+			break;
+		case 'M':
+			argument.manufacture = optarg;
+			DEBUG_PRINT("%s \r\n", argument.manufacture);
+			if (strlen(argument.manufacture) > 18)
+				return print_msg("wpara");
+			break;
+		case 'S':
+			argument.ss_bus = optarg;
+			argument.iss_bus = atoi(argument.ss_bus);
+			DEBUG_PRINT("%s \r\n", argument.ss_bus);
+			break;
+		case 'H':
+			argument.hs_bus = optarg;
+			argument.ihs_bus = atoi(argument.hs_bus);
+			DEBUG_PRINT("%s \r\n", argument.hs_bus);
+			break;
+		case 'w':
+			argument.wol = optarg;
+			DEBUG_PRINT("%s \r\n", argument.wol);
+			break;
+		case 'l':
+			argument.led0 = optarg;
+			DEBUG_PRINT("%s \r\n", argument.led0);
+			i = sscanf(argument.led0,
+				   "%02X%02X_%02X%02X",
+				   (unsigned int *)&argument.LED0[0],
+				   (unsigned int *)&argument.LED0[1],
+				   (unsigned int *)&argument.LED0[2],
+				   (unsigned int *)&argument.LED0[3]);
+			break;
+		case 'e':
+			argument.led1 = optarg;
+			DEBUG_PRINT("%s \r\n", argument.led1);
+			i = sscanf(argument.led1,
+				   "%02X%02X_%02X%02X",
+				   (unsigned int *)&argument.LED1[0],
+				   (unsigned int *)&argument.LED1[1],
+				   (unsigned int *)&argument.LED1[2],
+				   (unsigned int *)&argument.LED1[3]);
+			break;
+		case '?':
+		default:
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+	ret = scan_ax_device(ifr, info->inet_sock);
+	if (ret < 0) {
+		PRINT_SCAN_DEV_FAIL;
+		return ret;
+	}
+
+	rpara_buf = (unsigned char *)malloc((FLASH_SIZE + 256) & ~(0xFF));
+	if (!rpara_buf) {
+		PRINT_ALLCATE_MEM_FAIL;
+		ret = -FAIL_ALLCATE_MEM;
+		goto fail;
+	}
+	memset(rpara_buf, 0xFF, (FLASH_SIZE + 256) & ~(0xFF));
+
+	ret = read_flash(info, rpara_buf, 0, 0x3000);
+	if (ret < 0)
+		goto fail;
+
+	//temp_para_offset = calculate_para_offset(rpara_buf);
+
+	if (*(unsigned short *)&rpara_buf[PARAMETER_PRI_HEADER_OFFSET] != 0xA55A) {
+		//printf("Not 0xA55A, use sample\n");
+		para_offset = 0x3000;
+		block_count = 0;
+	} else {
+		para_offset = SWAP_32(*(unsigned long *)&rpara_buf[PARAMETER_PRI_OFFSET]);
+		block_count = SWAP_16(*(unsigned short *)&rpara_buf[PARAMETER_PRI_BLOCK_COUNT]);
+	}
+
+	para_size = 0;
+	if (block_count) {
+		para_size = block_count * FLASH_BLOCK_SIZE;
+		ret = read_flash(info, rpara_buf, para_offset, para_size);
+		if (ret < 0)
+			goto fail;
+	}
+
+	block_index = -FAIL_GENERIAL_ERROR;
+	if (argument.mac_address) {
+		if(check_hex(argument.mac_address, 17) == -FAIL_INVALID_PARAMETER) {
+			printf("\nFAIL: Char should be '0'-'9' & 'A(a)'-'F(f)'\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if(strlen(argument.mac_address) != 17) {
+			printf("FAIL: MAC address should be 6 bytes\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_01);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type1, 20);
+			para_size += 20;
+		}
+
+		ret = change_para_macaddr(&rpara_buf[para_offset], block_index, argument.MAC);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing MAC address failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.serial_num) {
+		if(check_hex(argument.serial_num, strlen(argument.serial_num)) == -FAIL_INVALID_PARAMETER) {
+			printf("\nFAIL: Char should be '0'-'9' & 'A(a)'-'F(f)'\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_04);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type4, 20);
+			para_size += 20;
+		}
+
+		ret = change_para_serialnum(&rpara_buf[para_offset], block_index, argument.serial_num);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing serial number failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.PID) {
+		if(check_hex(argument.PID, 5) == -FAIL_INVALID_PARAMETER) {
+			printf("\nFAIL: Char should be '0'-'9' & 'A(a)'-'F(f)'\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if(strlen(argument.PID) != 5) {
+			printf("FAIL: PID be 2 bytes\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_01);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type1, 20);
+			para_size += 20;
+		}
+
+		ret = change_para_pid(&rpara_buf[para_offset], block_index, argument.pid);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing PID failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.VID) {
+		if(check_hex(argument.VID, 5) == -FAIL_INVALID_PARAMETER) {
+			printf("\nFAIL: Char should be '0'-'9' & 'A(a)'-'F(f)'\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if(strlen(argument.VID) != 5) {
+			printf("FAIL: VID be 2 bytes\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_01);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type1, 20);
+			para_size += 20;
+		}
+
+		ret = change_para_vid(&rpara_buf[para_offset], block_index, argument.vid);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing VID failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.product_string) {
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_03);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type3, 20);
+			para_size += 20;
+		}
+
+		ret = change_para_productstr(&rpara_buf[para_offset], block_index, argument.product_string);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing Product String failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.manufacture) {
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_02);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type2, 20);
+			para_size += 20;
+		}
+
+		ret = change_para_manufacture(&rpara_buf[para_offset], block_index, argument.manufacture);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing manufacture failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.ss_bus) {
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_01);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type1, 20);
+			para_size += 20;
+		}
+
+		if (argument.iss_bus > 896)	{
+			printf("FAIL: The value is between 0-896\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		ret = change_para_ssbus(&rpara_buf[para_offset], block_index, argument.iss_bus);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing SS_MAX_BUS_PW failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.hs_bus) {
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_01);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type1, 20);
+			para_size += 20;
+		}
+
+		if (argument.ihs_bus > 500)	{
+			printf("FAIL: The value is between 0-500\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		ret = change_para_hsbus(&rpara_buf[para_offset], block_index, argument.ihs_bus);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing HS_MAX_BUS_PW failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.wol) {
+		if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_15);
+		if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type15, 20);
+			para_size += 20;
+		}
+
+		if (strlen(argument.wol) > 8)	{
+			printf("FAIL: The value must be 8 digit\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		ret = change_para_wol(&rpara_buf[para_offset], block_index, argument.wol);
+		if (ret < 0) {
+			fprintf(stderr,
+				"%s: Changing HS_MAX_BUS_PW failed.\n",
+				__func__);
+			goto fail;
+		}
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.led0) {
+	/*	if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_11);*/
+	//	if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type11, 20);
+			para_size += 20;
+	//	}
+		if (check_led_parameter(argument.led0)) {
+			printf("FAIL: The value invaild.\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		set_para_led0(&rpara_buf[para_offset], block_index, argument.LED0);
+
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.led1) {
+	/*	if (para_size)
+			block_index = find_block_index(&rpara_buf[para_offset], para_size, TYPE_11);*/
+		//if (block_index == -FAIL_GENERIAL_ERROR) {
+			block_index = para_size / 20;
+			memcpy(&rpara_buf[para_offset + block_index * 20], sample_type11, 20);
+			para_size += 20;
+		//}
+		if (check_led_parameter(argument.led1)) {
+			printf("FAIL: The value invaild.\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		set_para_led1(&rpara_buf[para_offset], block_index, argument.LED1);
+		
+		checksum_efuse_block(&rpara_buf[para_offset + block_index * 20]);
+	}
+
+	if (argument.dump) {
+		int i = 0;
+		unsigned char buf[32 * 20];
+		if (para_size == 0) {
+			printf("\nThe parameter content currently in flash has no data\n");
+			return -FAIL_INVALID_PARAMETER;
+		}
+		printf("\nDump the parameter content currently in flash as parameter.txt file\n");
+
+		FILE *file = fopen("parameter.txt", "w");
+		if (file == NULL) {
+			perror("Error opening file");
+			return -FAIL_INVALID_PARAMETER;
+		}
+
+		for (i = 0; i < para_size; i++) {
+			buf[i] = rpara_buf[para_offset + i];
+		}
+
+		for (i = 0; i < para_size; i++) {
+			fprintf(file, "%02X", buf[i]);
+
+			if(((i + 1) % 4 == 0))
+				fprintf(file, "\n");
+			else
+				fprintf(file, " ");
+		}
+
+		fclose(file);
+
+		dump(&rpara_buf[para_offset], para_size);
+	}
+
+	erase_sector_flash(info, PARAMETER_PRI_HEADER_OFFSET);
+	erase_sector_flash(info, para_offset);
+
+
+	if (*(unsigned short *)&rpara_buf[PARAMETER_PRI_HEADER_OFFSET] != 0xA55A) {
+		//printf("Not 0xA55A, create header\n");
+		rpara_buf[PARAMETER_PRI_HEADER_OFFSET] = 0x5A;
+		rpara_buf[PARAMETER_PRI_HEADER_OFFSET + 1] = 0xA5;
+		rpara_buf[PARAMETER_PRI_HEADER_OFFSET + 2] = 0x04;
+		rpara_buf[PARAMETER_PRI_HEADER_OFFSET + 3] = 0;
+	}
+	*(unsigned int *)&rpara_buf[PARAMETER_PRI_OFFSET] = SWAP_32(para_offset);
+	*(unsigned short *)&rpara_buf[PARAMETER_PRI_BLOCK_COUNT] = SWAP_16(para_size / 20);
+	checksum_para_header((unsigned short *)&rpara_buf[PARAMETER_PRI_HEADER_OFFSET]);
+
+	write_flash(info, rpara_buf, PARAMETER_PRI_HEADER_OFFSET, 256);
+	write_flash(info, rpara_buf, para_offset, para_size);
+
+	sw_reset(info);
+fail:
+	if (rpara_buf)
+		free(rpara_buf);
+
+	return 0;
+}
+
+static int reload_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	char fw_version[16] = {0};
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	if (info->argc != 2) {
+		int i;
+
+		for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], ax88279_cmd_list[i].cmd,
+				    strlen(ax88279_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", ax88279_cmd_list[i].help_ins,
+				       ax88279_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	if (scan_ax_device(ifr, info->inet_sock)) {
+		PRINT_SCAN_DEV_FAIL;
+		return -FAIL_SCAN_DEV;
+	}
+
+	autosuspend_enable(info, 0);
+
+	sw_reset(info);
+
+	if (scan_ax_device(ifr, info->inet_sock)) {
+		PRINT_SCAN_DEV_FAIL;
+		return -FAIL_SCAN_DEV;
+	}
+
+	return SUCCESS;
+}
+
+static int scan_ax_device(struct ifreq *ifr, int inet_sock)
+{
+	unsigned int retry;
+
+	DEBUG_PRINT("=== %s - Start\n", __func__);
+
+	for (retry = 0; retry < SCAN_DEV_MAX_RETRY; retry++) {
+		unsigned int i;
+		struct _ax_ioctl_command ioctl_cmd;
+#if NET_INTERFACE == INTERFACE_SCAN
+		struct ifaddrs *addrs, *tmp;
+		unsigned char	dev_exist;
+
+		getifaddrs(&addrs);
+		tmp = addrs;
+		dev_exist = 0;
+
+		while (tmp) {
+			memset(&ioctl_cmd, 0,
+			       sizeof(struct _ax_ioctl_command));
+			ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+			sprintf(ifr->ifr_name, "%s", tmp->ifa_name);
+			tmp = tmp->ifa_next;
+
+			ioctl(inet_sock, SIOCGIFFLAGS, ifr);
+			if (!(ifr->ifr_flags & IFF_UP))
+				continue;
+
+			ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+			if (ioctl(inet_sock, AX_PRIVATE, ifr) < 0)
+				continue;
+
+			if (strncmp(ioctl_cmd.sig,
+				    AX88179A_DRV_NAME,
+				    strlen(AX88179A_DRV_NAME)) == 0) {
+				dev_exist = 1;
+				break;
+			}
+		}
+
+		freeifaddrs(addrs);
+
+		if (dev_exist)
+			break;
+#else
+		for (i = 0; i < 255; i++) {
+
+			memset(&ioctl_cmd, 0,
+			       sizeof(struct _ax_ioctl_command));
+			ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+			sprintf(ifr->ifr_name, "eth%u", i);
+
+			ioctl(inet_sock, SIOCGIFFLAGS, ifr);
+			if (!(ifr->ifr_flags & IFF_UP))
+				continue;
+
+			ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+			if (ioctl(inet_sock, AX_PRIVATE, ifr) < 0)
+				continue;
+
+			if (strncmp(ioctl_cmd.sig,
+				    AX88179A_DRV_NAME,
+				    strlen(AX88179A_DRV_NAME)) == 0)
+				break;
+
+		}
+
+		if (i < 255)
+			break;
+#endif
+		usleep(500000);
+	}
+
+	if (retry >= SCAN_DEV_MAX_RETRY)
+		return -FAIL_SCAN_DEV;
+
+	return SUCCESS;
+}
+
+int main(int argc, char **argv)
+{
+	struct ifreq ifr;
+	struct ax_command_info info;
+	unsigned int i;
+	int inet_sock, ret = -FAIL_GENERIAL_ERROR;
+
+	//printf("%s\n", AX88179A_IOCTL_VERSION);
+
+	if (argc < 2) {
+		show_usage();
+		return SUCCESS;
+	}
+
+	inet_sock = socket(AF_INET, SOCK_DGRAM, 0);
+#ifndef NOT_PROGRAM 
+	if (scan_ax_device(&ifr, inet_sock)) {
+		printf("No %s found\n", AX88179A_SIGNATURE);
+		return FAIL_SCAN_DEV;
+	}
+#endif
+	for (i = 0; ax88279_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(argv[1],
+			    ax88279_cmd_list[i].cmd,
+			    strlen(ax88279_cmd_list[i].cmd)) == 0) {
+			info.help_ins = ax88279_cmd_list[i].help_ins;
+			info.help_desc = ax88279_cmd_list[i].help_desc;
+			info.ifr = &ifr;
+			info.argc = argc;
+			info.argv = argv;
+			info.inet_sock = inet_sock;
+			info.ioctl_cmd = ax88279_cmd_list[i].ioctl_cmd;
+			ret = (ax88279_cmd_list[i].OptFunc)(&info);
+			goto out;
+		}
+	}
+
+	if (ax88279_cmd_list[i].cmd == NULL) {
+		show_usage();
+		return SUCCESS;
+	}
+out:
+	if (ret == SUCCESS)
+		printf("SUCCESS\n");
+	else if (ret != -FAIL_INVALID_PARAMETER)
+		printf("FAIL\n");
+
+	return ret;
+}
diff --git a/drivers/net/usb/asix_usb/ax_ioctl.h b/drivers/net/usb/asix_usb/ax_ioctl.h
new file mode 100644
index 000000000000..f8321ddaf5a6
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax_ioctl.h
@@ -0,0 +1,212 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#ifndef __ASIX_IOCTL_H
+#define __ASIX_IOCTL_H
+
+#ifdef ENABLE_IOCTL_DEBUG
+#define DEBUG_PRINT(fmt, args...) printf(fmt, ## args)
+#define DEBUG_PRINTK(fmt, args...) printk(fmt, ## args)
+#else
+#define DEBUG_PRINT(fmt, args...)
+#define DEBUG_PRINTK(fmt, args...)
+#endif
+
+// CHANGE NETWORK INTERFACE WAY
+// DEFAULT_SCAN   : scan "eth0" - "eth255"
+// INTERFACE_SCAN : scan all available network interfaces
+#define NET_INTERFACE	INTERFACE_SCAN
+#define DEFAULT_SCAN	0x00
+#define INTERFACE_SCAN	0x01
+
+#define AX88179_SIGNATURE	"AX88179_178A"
+#define AX88179_DRV_NAME	"AX88179_178A"
+#define AX88179A_SIGNATURE	"AX88179B_179A_772E_772D"
+#define AX88179A_DRV_NAME	"AX88179B_179A_772E_772D"
+
+#define AX_PRIVATE		SIOCDEVPRIVATE
+
+#define AX_SIGNATURE			0
+#define AX_USB_COMMAND			1
+#define AX88179_READ_EEPROM		2
+#define AX88179_WRITE_EEPROM		3
+#define AX88179A_READ_VERSION		2
+#define AX88179A_WRITE_FLASH		3
+#define AX88179A_ROOT_2_ROM		4
+#define AX88179A_ERASE_FLASH		5
+#define AX88179A_SW_RESET		6
+#define AX88179A_READ_FLASH		7
+#define AX88179A_PROGRAM_EFUSE		8
+#define AX88179A_DUMP_EFUSE		9
+#define AX88179A_IEEE_TEST		10
+#define AX88179A_AUTOSUSPEND_EN		11
+#define AX88179A_ERASE_SECTOR_FLASH	12
+
+#define IEEE_1000M1			0
+#define IEEE_1000M2			1
+#define IEEE_1000M3			2
+#define IEEE_1000M4			3
+#define IEEE_100CA			4
+#define IEEE_100CB			5
+#define IEEE_10R			6
+#define IEEE_10FF			7
+#define IEEE_10MDI			8
+
+#define ERR_FALSH_WRITE_EN		1
+#define ERR_FALSH_WRITE_DIS		2
+#define ERR_FALSH_ERASE_ALL		3
+#define ERR_FALSH_WRITE			4
+#define ERR_FALSH_READ			5
+#define ERR_EFUSE_READ			6
+#define ERR_EFUSE_WRITE			7
+#define ERR_IEEE_INVALID_CHIP		8
+#define ERR_BOOT_CODE			9
+#define ERR_FALSH_ERASE_SECTOR	10
+
+#define USB_READ_OPS			0
+#define USB_WRITE_OPS			1
+
+#define SCAN_DEV_MAX_RETRY		10
+
+#define FLASH_BLOCK_SIZE	20 //bytes
+#define WRITE_PARA_HEADER 0x2100
+#define FLASH_SIZE (16*1024*1024)
+#define FLASH_PARA_OFFSET 8448
+
+#define PRAM_PRI_FW1_OFFSET 0x0
+#define PRAM_PRI_FW1_LENGTH 0x4
+#define MD32_PRI_FW1_OFFSET 0x14
+#define MD32_PRI_FW1_LENGTH 0x18
+
+#define PRAM_SEC_FW1_OFFSET 0x28
+#define PRAM_SEC_FW1_LENGTH 0x2C
+#define MD32_SEC_FW1_OFFSET 0x3C
+#define MD32_SEC_FW1_LENGTH 0x40
+
+#define PRAM_PRI_FW2_OFFSET 0x1000
+#define PRAM_PRI_FW2_LENGTH 0x1004
+#define MD32_PRI_FW2_OFFSET 0x1014
+#define MD32_PRI_FW2_LENGTH 0x1018
+
+#define PRAM_SEC_FW2_OFFSET 0x1028
+#define PRAM_SEC_FW2_LENGTH 0x102C
+#define MD32_SEC_FW2_OFFSET 0x103C
+#define MD32_SEC_FW2_LENGTH 0x1040
+
+#define PARAMETER_PRI_HEADER_OFFSET 0x2000
+#define PARAMETER_SEC_HEADER_OFFSET 0x200C
+
+#define PARAMETER_PRI_OFFSET 0x2004
+#define PARAMETER_PRI_BLOCK_COUNT 0x2008
+#define PARAMETER_SEC_OFFSET 0x2010
+#define PARAMETER_SEC_BLOCK_COUNT 0x2014
+
+
+enum _exit_code {
+	SUCCESS			= 0,
+	FAIL_INVALID_PARAMETER	= 1,
+	FAIL_IOCTL,
+	FAIL_SCAN_DEV,
+	FAIL_ALLCATE_MEM,
+	FAIL_LOAD_FILE,
+	FAIL_FLASH_WRITE,
+	FAIL_IVALID_VALUE,
+	FAIL_IVALID_CHKSUM,
+	FAIL_NON_EMPTY_RFUSE_BLOCK,
+	FAIL_EFUSE_WRITE,
+	FAIL_GENERIAL_ERROR,
+};
+
+struct _ax_usb_command {
+	unsigned char	ops;
+	unsigned char	cmd;
+	unsigned short	value;
+	unsigned short	index;
+	unsigned short	size;
+	unsigned char	*data;
+	unsigned long	cmd_data;
+};
+
+struct _ax88179a_flash {
+	int status;
+	int length;
+	int offset;
+	unsigned char *buf;
+};
+
+struct _ax88179a_version {
+	unsigned char version[16];
+};
+
+struct _ax88179a_ieee {
+	unsigned int type;
+	unsigned int speed;
+	unsigned int stop;
+	int status;
+};
+
+struct _ax88179a_autosuspend {
+	unsigned int enable;
+};
+
+struct _ax_ioctl_command {
+	unsigned short	ioctl_cmd;
+	unsigned char	sig[32];
+	unsigned char	type;
+	unsigned short *buf;
+	unsigned short size;
+	unsigned char delay;
+	union {
+		struct _ax88179a_flash		flash;
+		struct _ax88179a_version	version;
+		struct _ax88179a_ieee		ieee;
+		struct _ax_usb_command		usb_cmd;
+		struct _ax88179a_autosuspend	autosuspend;
+	};
+};
+
+#define SWAP_32(val)	(((val >> 24) & 0x000000FF) | \
+			 ((val >>  8) & 0x0000FF00) | \
+			 ((val <<  8) & 0x00FF0000) | \
+			 ((val << 24) & 0xFF000000))
+#define SWAP_16(val)    ((val >> 8) & 0x00FF) | \
+                         ((val <<  8) & 0xFF00)
+
+struct ax_device;
+typedef int (*IOCTRL_TABLE)(struct ax_device *axdev,
+			    struct _ax_ioctl_command *info);
+
+struct ax_command_info {
+	int inet_sock;
+	struct ifreq *ifr;
+	int argc;
+	char **argv;
+	unsigned short ioctl_cmd;
+	const char *help_ins;
+	const char *help_desc;
+};
+
+typedef int (*MENU_FUNC)(struct ax_command_info *info);
+
+struct _command_list {
+	char *cmd;
+	unsigned short ioctl_cmd;
+	MENU_FUNC OptFunc;
+	const char *help_ins;
+	const char *help_desc;
+};
+
+#endif /* __ASIX_IOCTL_H */
diff --git a/drivers/net/usb/asix_usb/ax_main.c b/drivers/net/usb/asix_usb/ax_main.c
new file mode 100644
index 000000000000..93253f0e144f
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax_main.c
@@ -0,0 +1,2620 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include "ax_main.h"
+#include "ax88179_178a.h"
+#include "ax88179a_772d.h"
+#ifdef ENABLE_PTP_FUNC
+#include "ax_ptp.h"
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+#include "ax_macsec.h"
+#endif
+
+#ifdef ENABLE_AUTODETACH_FUNC
+static int autodetach = -1;
+module_param(autodetach, int, 0);
+MODULE_PARM_DESC(autodetach, "Autodetach configuration");
+#endif
+
+static int bctrl = -1;
+module_param(bctrl, int, 0);
+MODULE_PARM_DESC(bctrl, "RX Bulk Control");
+
+static int blwt = -1;
+module_param(blwt, int, 0);
+MODULE_PARM_DESC(blwt, "RX Bulk Timer Low");
+
+static int bhit = -1;
+module_param(bhit, int, 0);
+MODULE_PARM_DESC(bhit, "RX Bulk Timer High");
+
+static int bsize = -1;
+module_param(bsize, int, 0);
+MODULE_PARM_DESC(bsize, "RX Bulk Queue Size");
+
+static int bifg = -1;
+module_param(bifg, int, 0);
+MODULE_PARM_DESC(bifg, "RX Bulk Inter Frame Gap");
+
+static int
+ax_submit_rx(struct ax_device *netdev, struct rx_desc *desc, gfp_t mem_flags);
+static void ax_set_carrier(struct ax_device *axdev);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+void ax_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
+{
+	struct ax_device *axdev = netdev_priv(net);
+
+	strscpy(info->driver, MODULENAME, sizeof(info->driver));
+	strscpy(info->version, DRIVER_VERSION, sizeof(info->version));
+	usb_make_path(axdev->udev, info->bus_info, sizeof(info->bus_info));
+
+	sprintf(info->fw_version, "v%d.%d.%d.%d",
+		axdev->fw_version[0], axdev->fw_version[1],
+		axdev->fw_version[2], axdev->fw_version[3]);
+}
+#else
+static size_t ax_strscpy(char *dest, const char *src, size_t size)
+{
+	size_t len = strnlen(src, size) + 1;
+	if(len > size) {
+		if (size)
+			dest[0] = '\0';
+		return 0;
+	}
+	memcpy(dest, src, len);
+	return len;
+}
+
+void ax_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
+{
+	struct ax_device *axdev = netdev_priv(net);
+
+	ax_strscpy(info->driver, MODULENAME, sizeof(info->driver));
+	ax_strscpy(info->version, DRIVER_VERSION, sizeof(info->version));
+	usb_make_path(axdev->udev, info->bus_info, sizeof(info->bus_info));
+
+	sprintf(info->fw_version, "v%d.%d.%d.%d",
+		axdev->fw_version[0], axdev->fw_version[1],
+		axdev->fw_version[2], axdev->fw_version[3]);
+}	
+#endif
+
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+int ax_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int ret;
+
+	if (!axdev->mii.mdio_read)
+		return -EOPNOTSUPP;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&axdev->control);
+
+	mii_ethtool_gset(&axdev->mii, cmd);
+
+	mutex_unlock(&axdev->control);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return 0;
+}
+
+int ax_set_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int ret;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&axdev->control);
+
+	mii_ethtool_sset(&axdev->mii, cmd);
+
+	mutex_unlock(&axdev->control);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return 0;
+}
+#else
+int ax_get_link_ksettings(struct net_device *netdev,
+			  struct ethtool_link_ksettings *cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int ret;
+
+	if (!axdev->mii.mdio_read)
+		return -EOPNOTSUPP;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&axdev->control);
+
+	mii_ethtool_get_link_ksettings(&axdev->mii, cmd);
+
+#ifdef ENABLE_AX88279
+	printk("============AX88279==========");
+	if (axdev->chip_version == AX_VERSION_AX88279) {
+#if KERNEL_VERSION(5, 0, 0) <= LINUX_VERSION_CODE
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+			 cmd->link_modes.supported, 1);
+
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+				 cmd->link_modes.advertising,
+				 1);
+
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+				 cmd->link_modes.lp_advertising,
+				 1);
+#else
+		__set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+			 cmd->link_modes.supported);
+
+		__set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+				 cmd->link_modes.advertising);
+
+		__set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+				 cmd->link_modes.lp_advertising);
+#endif
+		if (axdev->intr_link_info.eth_speed == ETHER_LINK_2500)
+			cmd->base.speed = SPEED_2500;
+	}
+#endif
+
+	mutex_unlock(&axdev->control);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return 0;
+}
+
+int ax_set_link_ksettings(struct net_device *netdev,
+			  const struct ethtool_link_ksettings *cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int ret;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&axdev->control);
+
+	mii_ethtool_set_link_ksettings(&axdev->mii, cmd);
+
+	mutex_unlock(&axdev->control);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return 0;
+}
+#endif
+u32 ax_get_msglevel(struct net_device *netdev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	return axdev->msg_enable;
+}
+
+void ax_set_msglevel(struct net_device *netdev, u32 value)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	axdev->msg_enable = value;
+}
+
+void ax_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wolinfo)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u8 reg8;
+	int ret;
+
+	ret = ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE,
+			  1, 1, &reg8, 0);
+	if (ret < 0) {
+		wolinfo->supported = 0;
+		wolinfo->wolopts = 0;
+		return;
+	}
+
+	wolinfo->supported = WAKE_PHY | WAKE_MAGIC;
+
+	if (reg8 & AX_MONITOR_MODE_RWLC)
+		wolinfo->wolopts |= WAKE_PHY;
+	if (reg8 & AX_MONITOR_MODE_RWMP)
+		wolinfo->wolopts |= WAKE_MAGIC;
+}
+
+int ax_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wolinfo)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u8 reg8 = 0;
+	int ret;
+
+	if (wolinfo->wolopts & WAKE_PHY)
+		reg8 |= AX_MONITOR_MODE_RWLC;
+	else
+		reg8 &= ~AX_MONITOR_MODE_RWLC;
+
+	if (wolinfo->wolopts & WAKE_MAGIC)
+		reg8 |= AX_MONITOR_MODE_RWMP;
+	else
+		reg8 &= ~AX_MONITOR_MODE_RWMP;
+
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static const char ax_gstrings[][ETH_GSTRING_LEN] = {
+	"tx_packets",
+	"rx_packets",
+	"tx_bytes",
+	"rx_bytes",
+	"tx_dropped",
+	"rx_length_errors",
+	"rx_crc_errors",
+	"rx_dropped",
+	"buikin_complete",
+	"bulkin_error",
+	"bulkout_complete",
+	"bulkout_error",
+	"bulkint_complete",
+	"bulkint_error",
+#ifdef ENABLE_QUEUE_PRIORITY
+	"ep5_count",
+	"ep3_count",
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+	"macsec_rx_in_pkts",
+	"macsec_rx_out_pkts",
+	"macsec_rx_ain_dec_pkts",
+	"macsec_rx_ain_byp_pkts",
+	"macsec_rx_ain_drp_pkts",
+	"macsec_rx_icv_fail_pkts",
+	"macsec_rx_icv_pass_pkts",
+	"macsec_rx_ctl",
+	"macsec_rx_untag",
+	"macsec_rx_sc",
+	"macsec_rx_nosc",
+	"macsec_rx_sc_null",
+	"macsec_rx_sc_untag",
+	"macsec_rx_sc_invalid_tag",
+	"macsec_rx_sc_nosc",
+	"macsec_rx_sc_dis",
+	"macsec_rx_sc_dec",
+	"macsec_tx_in_pkts",
+	"macsec_tx_out_pkts",
+	"macsec_tx_untag_pkts",
+	"macsec_tx_too_long_pkts",
+	"macsec_tx_enc_pkts",
+	"macsec_tx_byp_pkts",
+	"macsec_tx_drp_pkts",
+	"macsec_tx_ctl",
+	"macsec_tx_sc",
+	"macsec_tx_nosc",
+#endif
+};
+
+int ax_get_sset_count(struct net_device *netdev, int sset)
+{
+#ifdef ENABLE_MACSEC_FUNC
+	struct ax_device *axdev = netdev_priv(netdev);
+#endif
+	switch (sset) {
+	case ETH_SS_STATS:
+#ifdef ENABLE_MACSEC_FUNC
+		if (axdev->chip_version >= AX_VERSION_AX88279)
+			return ARRAY_SIZE(ax_gstrings);
+		else
+			return ARRAY_SIZE(ax_gstrings) - 27;
+#else
+		return ARRAY_SIZE(ax_gstrings);
+#endif
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+void ax_get_strings(struct net_device *netdev, u32 stringset, u8 *data)
+{
+
+	switch (stringset) {
+	case ETH_SS_STATS:
+		memcpy(data, ax_gstrings, sizeof(ax_gstrings));
+		break;
+	}
+}
+
+void ax_get_ethtool_stats(struct net_device *netdev,
+			  struct ethtool_stats *stats, u64 *data)
+{
+	struct net_device_stats *net_stats = ax_get_stats(netdev);
+	struct ax_device *axdev = netdev_priv(netdev);
+	u64 *temp = data;
+
+	*temp++ = net_stats->tx_packets;
+	*temp++ = net_stats->rx_packets;
+	*temp++ = net_stats->tx_bytes;
+	*temp++ = net_stats->rx_bytes;
+	*temp++ = net_stats->tx_dropped;
+	*temp++ = net_stats->rx_length_errors;
+	*temp++ = net_stats->rx_crc_errors;
+	*temp++ = net_stats->rx_dropped;
+	*temp++ = axdev->bulkin_complete;
+	*temp++ = axdev->bulkin_error;
+	*temp++ = axdev->bulkout_complete;
+	*temp++ = axdev->bulkout_error;
+	*temp++ = axdev->bulkint_complete;
+	*temp++ = axdev->bulkint_error;
+#ifdef ENABLE_QUEUE_PRIORITY
+	*temp++ = axdev->ep5_count;
+	*temp++ = axdev->ep3_count;
+#endif
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_MACSEC_FUNC
+	if (axdev->chip_version >= AX_VERSION_AX88279) {
+		u32 *macsec_dbg_count;
+		int i;
+
+		ax_get_rx_dbg_count(axdev);
+		ax_get_tx_dbg_count(axdev);
+		macsec_dbg_count = (u32 *)&axdev->macsec_cfg->rx_dbg_count;
+		for (i = 0; i < (AX_MACSEC_RX_DBG_CNT_SIZE / sizeof(u32)); i++)
+			*temp++ = macsec_dbg_count[i];
+		macsec_dbg_count = (u32 *)&axdev->macsec_cfg->tx_dbg_count;
+		for (i = 0; i < (AX_MACSEC_TX_DBG_CNT_SIZE / sizeof(u32)); i++)
+			*temp++ = macsec_dbg_count[i];
+	}
+#endif
+#endif
+}
+
+void ax_get_pauseparam(struct net_device *netdev,
+		       struct ethtool_pauseparam *pause)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 bmcr, lcladv, rmtadv;
+	u8 cap;
+
+	if (usb_autopm_get_interface(axdev->intf) < 0)
+		return;
+
+	bmcr = ax_mdio_read(netdev, axdev->mii.phy_id, MII_BMCR);
+	lcladv = ax_mdio_read(netdev, axdev->mii.phy_id, MII_ADVERTISE);
+	rmtadv = ax_mdio_read(netdev, axdev->mii.phy_id, MII_LPA);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	if (!(bmcr & BMCR_ANENABLE)) {
+		pause->autoneg = 0;
+		pause->rx_pause = 0;
+		pause->tx_pause = 0;
+		return;
+	}
+
+	pause->autoneg = 1;
+
+	cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);
+
+	if (cap & FLOW_CTRL_RX)
+		pause->rx_pause = 1;
+
+	if (cap & FLOW_CTRL_TX)
+		pause->tx_pause = 1;
+}
+
+int ax_set_pauseparam(struct net_device *netdev,
+		      struct ethtool_pauseparam *pause)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 old, new1, bmcr;
+	u8 cap = 0;
+	int ret;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&axdev->control);
+
+	bmcr = ax_mdio_read(netdev, axdev->mii.phy_id, MII_BMCR);
+	if (pause->autoneg && !(bmcr & BMCR_ANENABLE)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (pause->rx_pause)
+		cap |= FLOW_CTRL_RX;
+
+	if (pause->tx_pause)
+		cap |= FLOW_CTRL_TX;
+
+	old = ax_mdio_read(netdev, axdev->mii.phy_id, MII_ADVERTISE);
+	new1 = (old & ~(ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM)) |
+		mii_advertise_flowctrl(cap);
+	if (old != new1)
+		ax_mdio_write(netdev, axdev->mii.phy_id, MII_ADVERTISE, new1);
+
+	mii_nway_restart(&axdev->mii);
+out:
+	mutex_unlock(&axdev->control);
+	usb_autopm_put_interface(axdev->intf);
+
+	return ret;
+}
+
+int ax_get_regs_len(struct net_device *netdev)
+{
+	return 256;
+}
+
+void ax_get_regs(struct net_device *netdev,
+		 struct ethtool_regs *regs, void *buf)
+{
+	u8 *data = (u8 *)buf;
+	int i;
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	for (i = 0; i < 256; i++)
+		ax_read_cmd(axdev, AX_ACCESS_MAC, i, 1, 1, &data[i], 0);
+}
+
+static int __ax_usb_read_cmd(struct ax_device *axdev, u8 cmd, u8 reqtype,
+			     u16 value, u16 index, void *data, u16 size)
+{
+	void *buf = NULL;
+	int err = -ENOMEM;
+
+	if (size) {
+		buf = kzalloc(size, GFP_KERNEL);
+		if (!buf)
+			goto out;
+	}
+
+	err = usb_control_msg(axdev->udev, usb_rcvctrlpipe(axdev->udev, 0),
+			      cmd, reqtype, value, index, buf, size,
+			      USB_CTRL_GET_TIMEOUT);
+	if (err > 0 && err <= size) {
+		if (data)
+			memcpy(data, buf, err);
+		else
+			netdev_dbg(axdev->netdev,
+				   "Huh? Data requested but thrown away.\n");
+	}
+
+	kfree(buf);
+out:
+	return err;
+}
+
+static int __ax_usb_write_cmd(struct ax_device *axdev, u8 cmd, u8 reqtype,
+			      u16 value, u16 index, const void *data, u16 size)
+{
+	void *buf = NULL;
+	int err = -ENOMEM;
+
+	if (data) {
+		buf = kmemdup(data, size, GFP_KERNEL);
+		if (!buf)
+			goto out;
+	} else {
+		if (size) {
+			WARN_ON_ONCE(1);
+			err = -EINVAL;
+			goto out;
+		}
+	}
+
+	err = usb_control_msg(axdev->udev, usb_sndctrlpipe(axdev->udev, 0),
+			      cmd, reqtype, value, index, buf, size,
+			      USB_CTRL_SET_TIMEOUT);
+	kfree(buf);
+
+out:
+	return err;
+}
+
+static int __ax_read_cmd(struct ax_device *axdev, u8 cmd, u8 reqtype,
+			 u16 value, u16 index, void *data, u16 size)
+{
+	int ret;
+
+	if (usb_autopm_get_interface(axdev->intf) < 0)
+		return -ENODEV;
+
+	ret = __ax_usb_read_cmd(axdev, cmd, reqtype, value, index,
+				data, size);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return ret;
+}
+
+static int __ax_write_cmd(struct ax_device *axdev, u8 cmd, u8 reqtype,
+			  u16 value, u16 index, const void *data, u16 size)
+{
+	int ret;
+
+	if (usb_autopm_get_interface(axdev->intf) < 0)
+		return -ENODEV;
+
+	ret = __ax_usb_write_cmd(axdev, cmd, reqtype, value, index,
+				 data, size);
+
+	usb_autopm_put_interface(axdev->intf);
+
+	return ret;
+}
+
+static int __ax_read_cmd_nopm(struct ax_device *axdev, u8 cmd, u8 reqtype,
+			      u16 value, u16 index, void *data, u16 size)
+{
+	return __ax_usb_read_cmd(axdev, cmd, reqtype, value, index,
+				 data, size);
+}
+
+static int __ax_write_cmd_nopm(struct ax_device *axdev, u8 cmd, u8 reqtype,
+			       u16 value, u16 index, const void *data,
+			       u16 size)
+{
+	return __ax_usb_write_cmd(axdev, cmd, reqtype, value, index,
+				  data, size);
+}
+
+static int __asix_read_cmd(struct ax_device *axdev, u8 cmd, u16 value,
+			   u16 index, u16 size, void *data, int in_pm)
+{
+	int ret;
+	_usb_read_function fn;
+
+	if (!in_pm)
+		fn = __ax_read_cmd;
+	else
+		fn = __ax_read_cmd_nopm;
+
+	ret = fn(axdev, cmd, USB_DIR_IN | USB_TYPE_VENDOR |
+		 USB_RECIP_DEVICE, value, index, data, size);
+
+	if (unlikely(ret < 0))
+		dev_warn(&axdev->intf->dev,
+			 "Failed to read reg %04X_%04X_%04X_%04X (err %d)",
+			 cmd, value, index, size, ret);
+
+	return ret;
+}
+
+static int __asix_write_cmd(struct ax_device *axdev, u8 cmd, u16 value,
+			    u16 index, u16 size, void *data, int in_pm)
+{
+	int ret;
+	_usb_write_function fn;
+
+	if (!in_pm)
+		fn = __ax_write_cmd;
+	else
+		fn = __ax_write_cmd_nopm;
+
+	ret = fn(axdev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |
+		 USB_RECIP_DEVICE, value, index, data, size);
+
+	if (unlikely(ret < 0))
+		dev_warn(&axdev->intf->dev,
+			 "Failed to write reg %04X_%04X_%04X_%04X (err %d)",
+			 cmd, value, index, size, ret);
+
+	return ret;
+}
+
+int ax_read_cmd_nopm(struct ax_device *dev, u8 cmd, u16 value,
+		     u16 index, u16 size, void *data, int eflag)
+{
+	int ret;
+
+	if (eflag && (size == 2)) {
+		u16 buf = 0;
+
+		ret = __asix_read_cmd(dev, cmd, value, index, size, &buf, 1);
+		le16_to_cpus(&buf);
+		*((u16 *)data) = buf;
+	} else if (eflag && (size == 4)) {
+		u32 buf = 0;
+
+		ret = __asix_read_cmd(dev, cmd, value, index, size, &buf, 1);
+		le32_to_cpus(&buf);
+		*((u32 *)data) = buf;
+	} else {
+		ret = __asix_read_cmd(dev, cmd, value, index, size, data, 1);
+	}
+
+	return ret;
+}
+
+int ax_write_cmd_nopm(struct ax_device *dev, u8 cmd, u16 value,
+		      u16 index, u16 size, void *data)
+{
+	int ret;
+
+	if (size == 2) {
+		u16 buf = 0;
+
+		buf = *((u16 *)data);
+		cpu_to_le16s(&buf);
+		ret = __asix_write_cmd(dev, cmd, value, index,
+					  size, &buf, 1);
+	} else {
+		ret = __asix_write_cmd(dev, cmd, value, index,
+					  size, data, 1);
+	}
+
+	return ret;
+}
+
+int ax_read_cmd(struct ax_device *dev, u8 cmd, u16 value, u16 index, u16 size,
+		void *data, int eflag)
+{
+	int ret;
+
+	if (eflag && (size == 2)) {
+		u16 buf = 0;
+
+		ret = __asix_read_cmd(dev, cmd, value, index, size, &buf, 0);
+		le16_to_cpus(&buf);
+		*((u16 *)data) = buf;
+	} else if (eflag && (size == 4)) {
+		u32 buf = 0;
+
+		ret = __asix_read_cmd(dev, cmd, value, index, size, &buf, 0);
+		le32_to_cpus(&buf);
+		*((u32 *)data) = buf;
+	} else {
+		ret = __asix_read_cmd(dev, cmd, value, index, size, data, 0);
+	}
+
+	return ret;
+}
+
+int ax_write_cmd(struct ax_device *dev, u8 cmd, u16 value, u16 index, u16 size,
+		 void *data)
+{
+	int ret;
+
+	if (size == 2) {
+		u16 buf = 0;
+
+		buf = *((u16 *)data);
+		cpu_to_le16s(&buf);
+		ret = __asix_write_cmd(dev, cmd, value, index,
+					size, &buf, 0);
+	} else {
+		ret = __asix_write_cmd(dev, cmd, value, index,
+					size, data, 0);
+	}
+
+	return ret;
+}
+
+#if KERNEL_VERSION(2, 6, 20) > LINUX_VERSION_CODE
+static void ax_async_write_callback(struct urb *urb, struct pt_regs *regs)
+#else
+static void ax_async_write_callback(struct urb *urb)
+#endif
+{
+	struct _async_cmd_handle *asyncdata = (typeof(asyncdata))urb->context;
+
+	if (urb->status < 0)
+		dev_err(&asyncdata->axdev->intf->dev,
+			"ax_async_write_callback() failed with %d",
+			urb->status);
+
+	kfree(asyncdata->req);
+	kfree(asyncdata);
+	usb_free_urb(urb);
+}
+
+int ax_write_cmd_async(struct ax_device *axdev, u8 cmd, u16 value, u16 index,
+		       u16 size, void *data)
+{
+	struct usb_ctrlrequest *req = NULL;
+	int status = 0;
+	struct urb *urb = NULL;
+	void *buf = NULL;
+	struct _async_cmd_handle *asyncdata = NULL;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (urb == NULL) {
+		netdev_err(axdev->netdev,
+			   "Error allocating URB in %s!", __func__);
+		return -ENOMEM;
+	}
+
+	req = kzalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);
+	if (!req) {
+		usb_free_urb(urb);
+		return -ENOMEM;
+	}
+
+	asyncdata = kzalloc(sizeof(struct _async_cmd_handle), GFP_ATOMIC);
+	if (asyncdata == NULL) {
+		kfree(req);
+		usb_free_urb(urb);
+		return -ENOMEM;
+	}
+
+	asyncdata->req = req;
+	asyncdata->axdev = axdev;
+
+	if (size == 2) {
+		asyncdata->rxctl = *((u16 *)data);
+		cpu_to_le16s(&asyncdata->rxctl);
+		buf = &asyncdata->rxctl;
+	} else {
+		memcpy(asyncdata->m_filter, data, size);
+		buf = asyncdata->m_filter;
+	}
+
+	req->bRequestType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+	req->bRequest = cmd;
+	req->wValue = cpu_to_le16(value);
+	req->wIndex = cpu_to_le16(index);
+	req->wLength = cpu_to_le16(size);
+
+	usb_fill_control_urb(urb, axdev->udev, usb_sndctrlpipe(axdev->udev, 0),
+			     (void *)req, buf, size, ax_async_write_callback,
+			     asyncdata);
+
+	status = usb_submit_urb(urb, GFP_ATOMIC);
+	if (status < 0) {
+		netdev_err(axdev->netdev,
+			   "Error submitting the control message: status=%d",
+			   status);
+		kfree(req);
+		kfree(asyncdata);
+		usb_free_urb(urb);
+	}
+
+	return status;
+}
+
+int ax_mmd_read(struct net_device *netdev, int dev_addr, int reg)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 res = 0;
+
+	ax_read_cmd(axdev, AX88179A_PHY_CLAUSE45, (__u16)dev_addr,
+		    (__u16)reg, 2, &res, 1);
+
+	return res;
+}
+
+void ax_mmd_write(struct net_device *netdev, int dev_addr, int reg, int val)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 res = (u16)val;
+
+	ax_write_cmd(axdev, AX88179A_PHY_CLAUSE45, (__u16)dev_addr,
+		     (__u16)reg, 2, &res);
+}
+
+int ax_mdio_read(struct net_device *netdev, int phy_id, int reg)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 res;
+
+	ax_read_cmd_nopm(axdev, AX_ACCESS_PHY, phy_id, (__u16)reg, 2, &res, 1);
+
+	return res;
+}
+
+void ax_mdio_write(struct net_device *netdev, int phy_id, int reg, int val)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 res = (u16)val;
+
+	ax_write_cmd_nopm(axdev, AX_ACCESS_PHY, phy_id, (__u16)reg, 2, &res);
+}
+
+static void ax_set_unplug(struct ax_device *axdev)
+{
+	if (axdev->udev->state == USB_STATE_NOTATTACHED)
+		set_bit(AX_UNPLUG, &axdev->flags);
+}
+
+static int ax_check_tx_queue_not_empty(struct ax_device *axdev)
+{
+	int i;
+
+	for (i = (AX_TX_QUEUE_SIZE - 1); i >= 0; i--)
+		if (!skb_queue_empty(&axdev->tx_queue[i]))
+			return i;
+
+	return -1;
+}
+
+static bool ax_check_tx_queue_len(struct ax_device *axdev)
+{
+	int i;
+
+	for (i = 0; i < AX_TX_QUEUE_SIZE; i++)
+		if (skb_queue_len(&axdev->tx_queue[i]) > axdev->tx_qlen)
+			return true;
+
+	return false;
+}
+
+static void ax_read_bulk_callback(struct urb *urb)
+{
+	struct net_device *netdev;
+	int status = urb->status;
+	struct rx_desc *desc;
+	struct ax_device *axdev;
+
+	desc = urb->context;
+	if (!desc)
+		return;
+
+	axdev = desc->context;
+	if (!axdev)
+		return;
+
+	if (test_bit(AX_UNPLUG, &axdev->flags) ||
+	    !test_bit(AX_ENABLE, &axdev->flags))
+		return;
+
+	netdev = axdev->netdev;
+
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	usb_mark_last_busy(axdev->udev);
+
+	if (status)
+		axdev->bulkin_error++;
+	else
+		axdev->bulkin_complete++;
+
+	switch (status) {
+	case 0:
+		if (urb->actual_length < ETH_ZLEN)
+			break;
+
+		spin_lock(&axdev->rx_lock);
+		list_add_tail(&desc->list, &axdev->rx_done);
+		spin_unlock(&axdev->rx_lock);
+#ifdef ENABLE_RX_TASKLET
+		tasklet_schedule(&axdev->rx_tl);
+#else
+		napi_schedule(&axdev->napi);
+#endif
+		return;
+	case -ESHUTDOWN:
+		ax_set_unplug(axdev);
+		netif_device_detach(axdev->netdev);
+		return;
+	case -ENOENT:
+		return;
+	case -ETIME:
+		if (net_ratelimit())
+			netif_err(axdev, rx_err, netdev,
+				  "maybe reset is needed?\n");
+		break;
+	default:
+		if (net_ratelimit())
+			netif_err(axdev, rx_err, netdev,
+				  "RX status %d\n", status);
+		break;
+	}
+
+	ax_submit_rx(axdev, desc, GFP_ATOMIC);
+}
+
+void ax_write_bulk_callback(struct urb *urb)
+{
+	struct net_device_stats *stats;
+	struct net_device *netdev;
+	struct tx_desc *desc;
+	struct ax_device *axdev;
+	int status = urb->status;
+
+	desc = urb->context;
+	if (!desc)
+		return;
+
+	axdev = desc->context;
+	if (!axdev)
+		return;
+
+#ifdef ENABLE_PTP_FUNC
+	if (test_and_clear_bit(AX_TX_TIMESTAMPS, &desc->flags))
+		ax_ptp_ts_read_cmd_async(axdev);
+#endif
+	netdev = axdev->netdev;
+	stats = ax_get_stats(netdev);
+
+	if (status)
+		axdev->bulkout_error++;
+	else
+		axdev->bulkout_complete++;
+
+	if (status) {
+		if (net_ratelimit())
+			netif_warn(axdev, tx_err, netdev,
+				   "TX status %d\n", status);
+		stats->tx_errors += desc->skb_num;
+	} else {
+		stats->tx_packets += desc->skb_num;
+		stats->tx_bytes += desc->skb_len;
+	}
+
+	spin_lock(&axdev->tx_lock);
+	list_add_tail(&desc->list, &axdev->tx_free);
+	spin_unlock(&axdev->tx_lock);
+
+	usb_autopm_put_interface_async(axdev->intf);
+
+	if (!netif_carrier_ok(netdev))
+		return;
+	if (!test_bit(AX_ENABLE, &axdev->flags))
+		return;
+	if (test_bit(AX_UNPLUG, &axdev->flags))
+		return;
+
+	if (ax_check_tx_queue_not_empty(axdev) >= 0)
+#ifdef ENABLE_TX_TASKLET
+		tasklet_schedule(&axdev->tx_tl);
+#else
+		napi_schedule(&axdev->napi);
+#endif
+}
+
+static void ax_intr_callback(struct urb *urb)
+{
+	struct ax_device *axdev;
+	struct ax_device_int_data *event = NULL;
+	int status = urb->status;
+	int res;
+
+	axdev = urb->context;
+	if (!axdev)
+		return;
+
+	if (!test_bit(AX_ENABLE, &axdev->flags) ||
+	    test_bit(AX_UNPLUG, &axdev->flags))
+		return;
+
+	if (status)
+		axdev->bulkint_error++;
+	else
+		axdev->bulkint_complete++;
+
+	switch (status) {
+	case 0:
+		break;
+	case -ECONNRESET:
+	case -ESHUTDOWN:
+		netif_device_detach(axdev->netdev);
+		netif_err(axdev, intr, axdev->netdev,
+			  "Stop submitting intr, status %d\n", status);
+		return;
+	case -ENOENT:
+		netif_err(axdev, intr, axdev->netdev,
+			  "Stop submitting intr, status %d\n", status);
+		return;
+	case -EPROTO:
+		netif_err(axdev, intr, axdev->netdev,
+			  "Stop submitting intr, status %d\n", status);
+		return;
+	case -EOVERFLOW:
+		netif_err(axdev, intr, axdev->netdev,
+			  "intr status -EOVERFLOW\n");
+		goto resubmit;
+	default:
+		netif_err(axdev, intr, axdev->netdev,
+			  "intr status %d\n", status);
+		goto resubmit;
+	}
+
+	event = urb->transfer_buffer;
+	le64_to_cpus((u64 *)event);
+
+#ifndef ENABLE_INT_POLLING
+	axdev->link = event->link & AX_INT_PPLS_LINK;
+
+	if (axdev->link) {
+		if (!netif_carrier_ok(axdev->netdev)) {
+			axdev->intr_link_info = event->link_info;
+			set_bit(AX_LINK_CHG, &axdev->flags);
+			schedule_delayed_work(&axdev->schedule, 0);
+		}
+	} else {
+		if (netif_carrier_ok(axdev->netdev)) {
+			netif_stop_queue(axdev->netdev);
+			set_bit(AX_LINK_CHG, &axdev->flags);
+			schedule_delayed_work(&axdev->schedule, 0);
+		}
+	}
+#endif
+
+resubmit:
+	res = usb_submit_urb(urb, GFP_ATOMIC);
+	if (res == -ENODEV) {
+		ax_set_unplug(axdev);
+		netif_device_detach(axdev->netdev);
+	} else if (res) {
+		netif_err(axdev, intr, axdev->netdev,
+			  "can't resubmit intr, status %d\n", res);
+	}
+}
+
+#ifdef ENABLE_INT_POLLING
+static void __int_polling_work(struct work_struct *work)
+{
+	struct ax_device *axdev = container_of(work,
+				     struct ax_device, int_polling_work.work);
+	struct ax_link_info *link_info = &axdev->link_info;
+	u16 bmsr;
+	u16 speed;
+	
+	if (test_bit(AX_UNPLUG, &axdev->flags) ||
+	    !test_bit(AX_ENABLE, &axdev->flags))
+		return;
+
+	if (!mutex_trylock(&axdev->control)) {
+		schedule_delayed_work(&axdev->int_polling_work, 0);
+		return;
+	}
+
+	bmsr = ax_mdio_read(axdev->netdev, axdev->mii.phy_id, MII_BMSR);
+	axdev->link = bmsr & BMSR_LSTATUS;
+	
+	if (axdev->link) {
+		if (!netif_carrier_ok(axdev->netdev)) {
+			ax_set_carrier(axdev);
+			switch (link_info->eth_speed) {
+			case ETHER_LINK_10:
+				speed = 10;
+				break;
+			case ETHER_LINK_100:
+				speed = 100;
+				break;
+			case ETHER_LINK_1000:
+				speed = 1000;
+				break;
+			case ETHER_LINK_2500:
+				speed = 2500;
+				break;
+			}
+			netdev_info(axdev->netdev, "link up, %uMbps, %s-duplex\n",
+			    speed, link_info->full_duplex ? "full" : "half");
+		}
+	} else {
+		if (netif_carrier_ok(axdev->netdev)) {
+			netif_stop_queue(axdev->netdev);
+			ax_set_carrier(axdev);
+			netdev_info(axdev->netdev, "link down\n");
+		}
+	}
+
+	mutex_unlock(&axdev->control);
+
+	schedule_delayed_work(&axdev->int_polling_work,
+			      msecs_to_jiffies(INT_POLLING_TIMER));
+}
+#endif
+static void ax_free_buffer(struct ax_device *axdev)
+{
+	int i;
+
+	for (i = 0; i < AX88179_MAX_RX; i++) {
+		usb_free_urb(axdev->rx_list[i].urb);
+		axdev->rx_list[i].urb = NULL;
+
+		kfree(axdev->rx_list[i].buffer);
+		axdev->rx_list[i].buffer = NULL;
+		axdev->rx_list[i].head = NULL;
+	}
+
+	for (i = 0; i < AX88179_MAX_TX; i++) {
+		usb_free_urb(axdev->tx_list[i].urb);
+		axdev->tx_list[i].urb = NULL;
+
+		kfree(axdev->tx_list[i].buffer);
+		axdev->tx_list[i].buffer = NULL;
+		axdev->tx_list[i].head = NULL;
+	}
+
+	usb_free_urb(axdev->intr_urb);
+	axdev->intr_urb = NULL;
+
+	kfree(axdev->intr_buff);
+	axdev->intr_buff = NULL;
+}
+
+static int ax_alloc_buffer(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+	struct usb_interface *intf = axdev->intf;
+	struct usb_host_interface *alt = intf->cur_altsetting;
+	struct usb_host_endpoint *ep_intr = alt->endpoint;
+	struct urb *urb;
+	int node, i;
+	u8 *buf;
+
+	node = netdev->dev.parent ? dev_to_node(netdev->dev.parent) : -1;
+
+	spin_lock_init(&axdev->rx_lock);
+	spin_lock_init(&axdev->tx_lock);
+	INIT_LIST_HEAD(&axdev->tx_free);
+	INIT_LIST_HEAD(&axdev->rx_done);
+	for (i = 0; i < AX_TX_QUEUE_SIZE; i++)
+		skb_queue_head_init(&axdev->tx_queue[i]);
+	skb_queue_head_init(&axdev->rx_queue);
+
+	for (i = 0; i < AX88179_MAX_RX; i++) {
+		buf = kmalloc_node(axdev->driver_info->buf_rx_size,
+				   GFP_KERNEL, node);
+		if (!buf)
+			goto err1;
+
+		if (buf != __rx_buf_align(buf)) {
+			kfree(buf);
+			buf = kmalloc_node(
+				axdev->driver_info->buf_rx_size + RX_ALIGN,
+				GFP_KERNEL,
+				node);
+			if (!buf)
+				goto err1;
+		}
+
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			kfree(buf);
+			goto err1;
+		}
+
+		INIT_LIST_HEAD(&axdev->rx_list[i].list);
+		axdev->rx_list[i].context = axdev;
+		axdev->rx_list[i].urb = urb;
+		axdev->rx_list[i].buffer = buf;
+		axdev->rx_list[i].head = __rx_buf_align(buf);
+	}
+
+	for (i = 0; i < AX88179_MAX_TX; i++) {
+		buf = kmalloc_node(AX88179_BUF_TX_SIZE, GFP_KERNEL, node);
+		if (!buf)
+			goto err1;
+
+		if (buf != __tx_buf_align(buf, axdev->tx_align_len)) {
+			kfree(buf);
+			buf = kmalloc_node(
+				AX88179_BUF_TX_SIZE + axdev->tx_align_len,
+				GFP_KERNEL, node);
+			if (!buf)
+				goto err1;
+		}
+
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			kfree(buf);
+			goto err1;
+		}
+
+		INIT_LIST_HEAD(&axdev->tx_list[i].list);
+		axdev->tx_list[i].context = axdev;
+		axdev->tx_list[i].urb = urb;
+		axdev->tx_list[i].buffer = buf;
+		axdev->tx_list[i].head = __tx_buf_align(buf,
+							axdev->tx_align_len);
+
+		list_add_tail(&axdev->tx_list[i].list, &axdev->tx_free);
+	}
+
+	axdev->intr_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!axdev->intr_urb)
+		goto err1;
+
+	axdev->intr_buff = kzalloc(INTBUFSIZE, GFP_KERNEL);
+	if (!axdev->intr_buff)
+		goto err1;
+
+	axdev->intr_interval = (int)ep_intr->desc.bInterval;
+	usb_fill_int_urb(axdev->intr_urb, axdev->udev,
+			 usb_rcvintpipe(axdev->udev, 1), axdev->intr_buff,
+			 INTBUFSIZE, ax_intr_callback, axdev,
+			 axdev->intr_interval);
+
+	return 0;
+err1:
+	ax_free_buffer(axdev);
+	return -ENOMEM;
+}
+
+static struct tx_desc *ax_get_tx_desc(struct ax_device *dev)
+{
+	struct tx_desc *desc = NULL;
+	unsigned long flags;
+
+	if (list_empty(&dev->tx_free))
+		return NULL;
+
+	spin_lock_irqsave(&dev->tx_lock, flags);
+	if (!list_empty(&dev->tx_free)) {
+		struct list_head *cursor;
+
+		cursor = dev->tx_free.next;
+		list_del_init(cursor);
+		desc = list_entry(cursor, struct tx_desc, list);
+	}
+	spin_unlock_irqrestore(&dev->tx_lock, flags);
+
+	return desc;
+}
+
+static void ax_tx_bottom(struct ax_device *axdev)
+{
+	const struct driver_info *info = axdev->driver_info;
+	int ret;
+
+	do {
+		struct tx_desc *desc;
+		int index = -1;
+
+		index = ax_check_tx_queue_not_empty(axdev);
+		if (index < 0)
+			break;
+
+		desc = ax_get_tx_desc(axdev);
+		if (!desc)
+			break;
+#ifdef ENABLE_QUEUE_PRIORITY
+		desc->q_index = index;
+#else
+		desc->q_index = 0;
+#endif
+		ret = info->tx_fixup(axdev, desc);
+		if (ret) {
+			struct net_device *netdev = axdev->netdev;
+
+			if (ret == -ENODEV) {
+				ax_set_unplug(axdev);
+				netif_device_detach(netdev);
+			} else {
+				struct net_device_stats *stats;
+				unsigned long flags;
+
+				stats = ax_get_stats(netdev);
+				stats->tx_dropped += desc->skb_num;
+
+				spin_lock_irqsave(&axdev->tx_lock, flags);
+				list_add_tail(&desc->list, &axdev->tx_free);
+				spin_unlock_irqrestore(&axdev->tx_lock, flags);
+			}
+		}
+	} while (ret == 0);
+}
+#ifdef ENABLE_TX_TASKLET
+#if KERNEL_VERSION(5,10,0) > LINUX_VERSION_CODE
+static void ax_bottom_half(unsigned long t)
+{
+	struct ax_device *axdev = (struct ax_device *)t;
+#else
+static void ax_bottom_half(struct tasklet_struct *t)
+{
+	struct ax_device *axdev = from_tasklet(axdev, t, tx_tl);
+#endif
+
+#else
+static void ax_bottom_half(struct ax_device *axdev)
+{
+#endif
+	if (test_bit(AX_UNPLUG, &axdev->flags) ||
+	    !test_bit(AX_ENABLE, &axdev->flags) ||
+	    !netif_carrier_ok(axdev->netdev))
+		return;
+#ifdef ENABLE_TX_TASKLET
+	clear_bit(AX_SCHEDULE_TASKLET_TX, &axdev->flags);
+#else
+	clear_bit(AX_SCHEDULE_NAPI, &axdev->flags);
+#endif
+
+	ax_tx_bottom(axdev);
+}
+
+static int ax_rx_bottom(struct ax_device *axdev, int budget)
+{
+	unsigned long flags;
+	struct list_head *cursor, *next, rx_queue;
+	int ret = 0, work_done = 0;
+#ifndef ENABLE_RX_TASKLET
+	struct napi_struct *napi = &axdev->napi;
+#endif
+	struct net_device *netdev = axdev->netdev;
+	struct net_device_stats *stats = ax_get_stats(netdev);
+
+	if (!skb_queue_empty(&axdev->rx_queue)) {
+		while (work_done < budget) {
+			struct sk_buff *skb = __skb_dequeue(&axdev->rx_queue);
+			unsigned int pkt_len;
+
+			if (!skb)
+				break;
+
+			pkt_len = skb->len;
+#ifdef ENABLE_RX_TASKLET
+			netif_receive_skb(skb);
+#else
+			napi_gro_receive(napi, skb);
+#endif
+			work_done++;
+			stats->rx_packets++;
+			stats->rx_bytes += pkt_len;
+		}
+	}
+
+	if (list_empty(&axdev->rx_done))
+		return work_done;
+
+	INIT_LIST_HEAD(&rx_queue);
+	spin_lock_irqsave(&axdev->rx_lock, flags);
+	list_splice_init(&axdev->rx_done, &rx_queue);
+	spin_unlock_irqrestore(&axdev->rx_lock, flags);
+
+	list_for_each_safe(cursor, next, &rx_queue) {
+		struct rx_desc *desc;
+
+		list_del_init(cursor);
+
+		desc = list_entry(cursor, struct rx_desc, list);
+
+		if (desc->urb->actual_length < ETH_ZLEN)
+			goto submit;
+
+		if (unlikely(skb_queue_len(&axdev->rx_queue) >= 1000))
+			goto submit;
+
+		axdev->driver_info->rx_fixup(axdev, desc, &work_done, budget);
+submit:
+		if (!ret) {
+			ret = ax_submit_rx(axdev, desc, GFP_ATOMIC);
+		} else {
+			desc->urb->actual_length = 0;
+			list_add_tail(&desc->list, next);
+		}
+	}
+
+	if (!list_empty(&rx_queue)) {
+		spin_lock_irqsave(&axdev->rx_lock, flags);
+		list_splice_tail(&rx_queue, &axdev->rx_done);
+		spin_unlock_irqrestore(&axdev->rx_lock, flags);
+	}
+
+	return work_done;
+}
+
+static
+int ax_submit_rx(struct ax_device *dev, struct rx_desc *desc, gfp_t mem_flags)
+{
+	int ret;
+
+	if (test_bit(AX_UNPLUG, &dev->flags) ||
+	    !test_bit(AX_ENABLE, &dev->flags) ||
+	    !netif_carrier_ok(dev->netdev))
+		return 0;
+
+	usb_fill_bulk_urb(desc->urb, dev->udev, usb_rcvbulkpipe(dev->udev, 2),
+			  desc->head, dev->driver_info->buf_rx_size,
+			  (usb_complete_t)ax_read_bulk_callback, desc);
+
+	ret = usb_submit_urb(desc->urb, mem_flags);
+	if (ret == -ENODEV) {
+		ax_set_unplug(dev);
+		netif_device_detach(dev->netdev);
+	} else if (ret) {
+		struct urb *urb = desc->urb;
+		unsigned long flags;
+
+		urb->actual_length = 0;
+		spin_lock_irqsave(&dev->rx_lock, flags);
+		list_add_tail(&desc->list, &dev->rx_done);
+		spin_unlock_irqrestore(&dev->rx_lock, flags);
+
+		netif_err(dev, rx_err, dev->netdev,
+			  "Couldn't submit rx[%p], ret = %d\n", desc, ret);
+#ifdef ENABLE_RX_TASKLET
+		tasklet_schedule(&dev->rx_tl);
+#else
+		napi_schedule(&dev->napi);
+#endif
+	}
+
+	return ret;
+}
+
+static inline int __ax_poll(struct ax_device *axdev, int budget)
+{
+#ifndef ENABLE_RX_TASKLET
+	struct napi_struct *napi = &axdev->napi;
+#endif
+	int work_done;
+
+	work_done = ax_rx_bottom(axdev, budget);
+#ifndef ENABLE_TX_TASKLET
+	ax_bottom_half(axdev);
+#endif
+
+	if (work_done < budget) {
+#ifndef ENABLE_RX_TASKLET
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+		napi_complete_done(napi, work_done);
+#else
+		if (!napi_complete_done(napi, work_done))
+			return work_done;
+#endif
+#endif
+		if (!list_empty(&axdev->rx_done))
+#ifdef ENABLE_RX_TASKLET
+			tasklet_schedule(&axdev->rx_tl);
+#else
+			napi_schedule(napi);
+#endif
+
+#ifndef ENABLE_TX_TASKLET
+		else if (ax_check_tx_queue_not_empty(axdev) >= 0 &&
+			 !list_empty(&axdev->tx_free))
+			napi_schedule(napi);
+#endif
+	}
+
+	return work_done;
+}
+
+#ifdef ENABLE_RX_TASKLET
+#if KERNEL_VERSION(5,10,0) > LINUX_VERSION_CODE
+static void ax_poll(unsigned long t)
+{
+	struct ax_device *axdev = (struct ax_device *)t;
+#else
+static void ax_poll(struct tasklet_struct *t)
+{
+	struct ax_device *axdev = from_tasklet(axdev, t, rx_tl);
+#endif
+	__ax_poll(axdev, 256);
+}
+
+#else
+
+static int ax_poll(struct napi_struct *napi, int budget)
+{
+	struct ax_device *axdev = container_of(napi, struct ax_device, napi);
+
+	return __ax_poll(axdev, budget);
+}
+#endif
+
+static void ax_drop_queued_tx(struct ax_device *axdev)
+{
+	struct net_device_stats *stats = ax_get_stats(axdev->netdev);
+	struct sk_buff_head skb_head, *tx_queue = axdev->tx_queue;
+	struct sk_buff *skb;
+	int i;
+
+	for (i = 0; i < AX_TX_QUEUE_SIZE; i++) {
+		if (skb_queue_empty(&tx_queue[i]))
+			continue;
+
+		__skb_queue_head_init(&skb_head);
+		spin_lock_bh(&tx_queue[i].lock);
+		skb_queue_splice_init(&tx_queue[i], &skb_head);
+		spin_unlock_bh(&tx_queue[i].lock);
+
+		while ((skb = __skb_dequeue(&skb_head))) {
+			dev_kfree_skb(skb);
+			stats->tx_dropped++;
+		}
+	}
+}
+
+#if KERNEL_VERSION(5, 6, 0) <= LINUX_VERSION_CODE
+static void ax_tx_timeout(struct net_device *netdev, unsigned int txqueue)
+#else
+static void ax_tx_timeout(struct net_device *netdev)
+#endif
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	netif_warn(axdev, tx_err, netdev, "Tx timeout\n");
+
+	usb_queue_reset_device(axdev->intf);
+
+}
+
+#ifdef ENABLE_QUEUE_PRIORITY
+static u16 ax_select_queue(struct net_device *netdev, struct sk_buff *skb,
+			   struct net_device *sb_dev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	struct ax_link_info *link_info = &axdev->link_info;
+
+	if (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {
+#ifdef ENABLE_AX88279
+		if (axdev->chip_version >= AX_VERSION_AX88279)
+			return 1;
+#endif
+		if (link_info->eth_speed == ETHER_LINK_1000)
+			return 1;
+	}
+	return 0;
+}
+#endif
+
+static netdev_tx_t ax_start_xmit(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+#ifdef ENABLE_QUEUE_PRIORITY
+	u32 index = ax_select_queue(netdev, skb, NULL);
+#endif
+	skb_tx_timestamp(skb);
+#ifdef ENABLE_QUEUE_PRIORITY
+	skb_queue_tail(&axdev->tx_queue[index], skb);
+#else
+	skb_queue_tail(&axdev->tx_queue[0], skb);
+#endif
+	if (!list_empty(&axdev->tx_free)) {
+		if (test_bit(AX_SELECTIVE_SUSPEND, &axdev->flags)) {
+#ifdef ENABLE_TX_TASKLET
+			set_bit(AX_SCHEDULE_TASKLET_TX, &axdev->flags);
+#else
+			set_bit(AX_SCHEDULE_NAPI, &axdev->flags);
+#endif
+			schedule_delayed_work(&axdev->schedule, 0);
+		} else {
+			usb_mark_last_busy(axdev->udev);
+#ifdef ENABLE_TX_TASKLET
+			tasklet_schedule(&axdev->tx_tl);
+#else
+			napi_schedule(&axdev->napi);
+#endif
+		}
+	} else if (ax_check_tx_queue_len(axdev)) {
+		netif_stop_queue(netdev);
+	}
+
+	return NETDEV_TX_OK;
+}
+
+void ax_set_tx_qlen(struct ax_device *dev)
+{
+	struct net_device *netdev = dev->netdev;
+
+	dev->tx_qlen = AX88179_BUF_TX_SIZE / (netdev->mtu + ETH_FCS_LEN + 8);
+}
+
+static int ax_start_rx(struct ax_device *axdev)
+{
+	int i, ret = 0;
+
+	INIT_LIST_HEAD(&axdev->rx_done);
+	for (i = 0; i < AX88179_MAX_RX; i++) {
+		INIT_LIST_HEAD(&axdev->rx_list[i].list);
+		ret = ax_submit_rx(axdev, &axdev->rx_list[i], GFP_KERNEL);
+		if (ret)
+			break;
+	}
+
+	if (ret && ++i < AX88179_MAX_RX) {
+		struct list_head rx_queue;
+		unsigned long flags;
+
+		INIT_LIST_HEAD(&rx_queue);
+
+		do {
+			struct rx_desc *desc = &axdev->rx_list[i++];
+			struct urb *urb = desc->urb;
+
+			urb->actual_length = 0;
+			list_add_tail(&desc->list, &rx_queue);
+		} while (i < AX88179_MAX_RX);
+
+		spin_lock_irqsave(&axdev->rx_lock, flags);
+		list_splice_tail(&rx_queue, &axdev->rx_done);
+		spin_unlock_irqrestore(&axdev->rx_lock, flags);
+	}
+
+	return ret;
+}
+
+static int ax_stop_rx(struct ax_device *axdev)
+{
+	int i;
+
+	for (i = 0; i < AX88179_MAX_RX; i++)
+		usb_kill_urb(axdev->rx_list[i].urb);
+
+	while (!skb_queue_empty(&axdev->rx_queue))
+		dev_kfree_skb(__skb_dequeue(&axdev->rx_queue));
+
+	return 0;
+}
+
+static void ax_disable(struct ax_device *axdev)
+{
+	int i;
+
+	if (test_bit(AX_UNPLUG, &axdev->flags)) {
+		ax_drop_queued_tx(axdev);
+		return;
+	}
+
+	for (i = 0; i < AX88179_MAX_TX; i++)
+		usb_kill_urb(axdev->tx_list[i].urb);
+
+	ax_stop_rx(axdev);
+}
+
+#if KERNEL_VERSION(2, 6, 39) <= LINUX_VERSION_CODE
+static int
+#if KERNEL_VERSION(3, 3, 0) <= LINUX_VERSION_CODE
+ax88179_set_features(struct net_device *net, netdev_features_t features)
+#else
+ax88179_set_features(struct net_device *net, u32 features)
+#endif
+{
+	struct ax_device *dev = netdev_priv(net);
+	u8 reg8;
+
+#if KERNEL_VERSION(3, 3, 0) <= LINUX_VERSION_CODE
+	netdev_features_t changed = net->features ^ features;
+#else
+	u32 changed = net->features ^ features;
+#endif
+
+	if (changed & NETIF_F_IP_CSUM) {
+		ax_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8, 0);
+		reg8 ^= AX_TXCOE_TCP | AX_TXCOE_UDP;
+		ax_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8);
+	}
+
+	if (changed & NETIF_F_IPV6_CSUM) {
+		ax_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8, 0);
+		reg8 ^= AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
+		ax_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8);
+	}
+
+	if (changed & NETIF_F_RXCSUM) {
+		ax_read_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &reg8, 0);
+		reg8 ^= AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
+			AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
+		ax_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &reg8);
+	}
+
+	return 0;
+}
+#endif
+
+static void ax_set_carrier(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+#ifndef ENABLE_RX_TASKLET
+	struct napi_struct *napi = &axdev->napi;
+#endif
+
+	if (axdev->link) {
+#ifdef ENABLE_PTP_FUNC
+		axdev->driver_info->ptp_pps_ctrl(axdev, 1);
+#endif
+		if (!netif_carrier_ok(netdev)) {
+			if (axdev->driver_info->link_reset(axdev))
+				return;
+			netif_stop_queue(netdev);
+#ifdef ENABLE_RX_TASKLET
+			tasklet_disable(&axdev->rx_tl);
+#else
+			napi_disable(napi);
+#endif	
+			netif_carrier_on(netdev);
+			ax_start_rx(axdev);
+#ifdef ENABLE_RX_TASKLET
+			tasklet_enable(&axdev->rx_tl);
+#else
+			napi_enable(napi);
+#endif
+			netif_wake_queue(netdev);
+		} else if (netif_queue_stopped(netdev) &&
+			   ax_check_tx_queue_len(axdev)) {
+			netif_wake_queue(netdev);
+		}
+	} else {
+#ifdef ENABLE_PTP_FUNC
+		axdev->driver_info->ptp_pps_ctrl(axdev, 0);
+#endif
+		if (netif_carrier_ok(netdev)) {
+			netif_carrier_off(netdev);
+#ifdef ENABLE_TX_TASKLET
+			tasklet_disable(&axdev->tx_tl);
+#endif
+#ifdef ENABLE_RX_TASKLET
+			tasklet_disable(&axdev->rx_tl);
+#else
+			napi_disable(napi);
+#endif			
+			ax_disable(axdev);
+#ifdef ENABLE_RX_TASKLET
+			tasklet_enable(&axdev->rx_tl);
+#else
+			napi_enable(napi);
+#endif	
+#ifdef ENABLE_TX_TASKLET
+			tasklet_enable(&axdev->tx_tl);
+#endif
+		}
+	}
+#ifdef ENABLE_AX88279
+	if (axdev->intr_link_info.eth_speed == ETHER_LINK_2500) {
+		netdev_info(axdev->netdev,
+			    "link up, 2500Mbps, full-duplex\n");
+	}
+#endif
+}
+
+static inline void __ax_work_func(struct ax_device *axdev)
+{
+	if (test_bit(AX_UNPLUG, &axdev->flags) || !netif_running(axdev->netdev))
+		return;
+
+	if (usb_autopm_get_interface(axdev->intf) < 0)
+		return;
+
+	if (!test_bit(AX_ENABLE, &axdev->flags))
+		goto out;
+
+	if (!mutex_trylock(&axdev->control)) {
+		schedule_delayed_work(&axdev->schedule, 0);
+		goto out;
+	}
+
+	if (test_and_clear_bit(AX_LINK_CHG, &axdev->flags))
+		ax_set_carrier(axdev);
+
+#ifdef ENABLE_RX_TASKLET
+	if (test_and_clear_bit(AX_SCHEDULE_TASKLET_RX, &axdev->flags) &&
+	    netif_carrier_ok(axdev->netdev))
+		tasklet_schedule(&axdev->rx_tl);
+#else
+	if (test_and_clear_bit(AX_SCHEDULE_NAPI, &axdev->flags) &&
+	    netif_carrier_ok(axdev->netdev))
+		napi_schedule(&axdev->napi);
+#endif
+#ifdef ENABLE_TX_TASKLET
+	if (test_and_clear_bit(AX_SCHEDULE_TASKLET_TX, &axdev->flags) &&
+	    netif_carrier_ok(axdev->netdev))
+		tasklet_schedule(&axdev->tx_tl);
+#endif
+
+	mutex_unlock(&axdev->control);
+
+out:
+	usb_autopm_put_interface(axdev->intf);
+}
+
+static void ax_work_func_t(struct work_struct *work)
+{
+	struct ax_device *axdev = container_of(work,
+					       struct ax_device, schedule.work);
+
+	__ax_work_func(axdev);
+}
+
+int ax_usb_command(struct ax_device *axdev, struct _ax_ioctl_command *info)
+{
+	struct _ax_usb_command *usb_cmd = &info->usb_cmd;
+	void *buf;
+	int err, timeout;
+	u16 size = usb_cmd->size;
+	u8 reqtype;
+
+	buf = kmemdup(&usb_cmd->cmd_data, size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (usb_cmd->ops == USB_READ_OPS) {
+		reqtype = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+		timeout = USB_CTRL_GET_TIMEOUT;
+	} else {
+		reqtype = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+		timeout = USB_CTRL_SET_TIMEOUT;
+	}
+
+	err = usb_control_msg(axdev->udev, usb_rcvctrlpipe(axdev->udev, 0),
+			      usb_cmd->cmd, reqtype, usb_cmd->value,
+			      usb_cmd->index, buf, size, timeout);
+	if (err > 0 && err <= size)
+		memcpy(&usb_cmd->cmd_data, buf, size);
+
+	kfree(buf);
+
+	return 0;
+}
+
+static int ax_open(struct net_device *netdev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int res = 0;
+
+	res = ax_alloc_buffer(axdev);
+	if (res)
+		return res;
+
+	res = usb_autopm_get_interface(axdev->intf);
+	if (res < 0)
+		goto out_free;
+
+	mutex_lock(&axdev->control);
+
+	set_bit(AX_ENABLE, &axdev->flags);
+
+	res = axdev->driver_info->hw_init(axdev);
+	if (res < 0)
+		goto out_unlock;
+
+	res = usb_submit_urb(axdev->intr_urb, GFP_KERNEL);
+	if (res) {
+		if (res == -ENODEV)
+			netif_device_detach(netdev);
+		netif_warn(axdev, ifup, netdev,
+			   "intr_urb submit failed: %d\n", res);
+		goto out_unlock;
+	}
+#ifdef ENABLE_INT_POLLING
+	schedule_delayed_work(&axdev->int_polling_work,
+			      msecs_to_jiffies(INT_POLLING_TIMER));
+#endif
+#ifdef ENABLE_RX_TASKLET
+	tasklet_enable(&axdev->rx_tl);
+#else
+	napi_enable(&axdev->napi);
+#endif
+#ifdef ENABLE_TX_TASKLET
+	tasklet_enable(&axdev->tx_tl);
+#endif
+
+	netif_carrier_off(netdev);
+	netif_start_queue(netdev);
+	mutex_unlock(&axdev->control);
+	usb_autopm_put_interface(axdev->intf);
+
+	return 0;
+
+out_unlock:
+	mutex_unlock(&axdev->control);
+	usb_autopm_put_interface(axdev->intf);
+out_free:
+	ax_free_buffer(axdev);
+	return res;
+}
+
+static int ax_close(struct net_device *netdev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int ret = 0;
+
+	if (axdev->driver_info->stop)
+		axdev->driver_info->stop(axdev);
+
+#ifdef ENABLE_TX_TASKLET
+	tasklet_disable(&axdev->tx_tl);
+#endif
+	clear_bit(AX_ENABLE, &axdev->flags);
+	usb_kill_urb(axdev->intr_urb);
+#ifdef ENABLE_INT_POLLING
+	cancel_delayed_work_sync(&axdev->int_polling_work);
+#endif
+	cancel_delayed_work_sync(&axdev->schedule);
+#ifdef ENABLE_RX_TASKLET
+	tasklet_disable(&axdev->rx_tl);
+#else
+	napi_disable(&axdev->napi);
+#endif
+	netif_stop_queue(axdev->netdev);
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0 || test_bit(AX_UNPLUG, &axdev->flags)) {
+		ax_drop_queued_tx(axdev);
+		ax_stop_rx(axdev);
+	} else {
+		ax_disable(axdev);
+	}
+
+	if (!ret)
+		usb_autopm_put_interface(axdev->intf);
+
+	ax_free_buffer(axdev);
+
+	return ret;
+}
+
+static int ax88179_change_mtu(struct net_device *net, int new_mtu)
+{
+	struct ax_device *axdev = netdev_priv(net);
+	u16 reg16;
+
+	if (new_mtu <= 0 || new_mtu > net->max_mtu)
+		return -EINVAL;
+
+	net->mtu = new_mtu;
+
+	if (net->mtu > 1500) {
+		ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			    2, 2, &reg16, 1);
+		reg16 |= AX_MEDIUM_JUMBO_EN;
+		ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			     2, 2, &reg16);
+	} else {
+		ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			    2, 2, &reg16, 1);
+		reg16 &= ~AX_MEDIUM_JUMBO_EN;
+		ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			     2, 2, &reg16);
+	}
+
+	return 0;
+}
+
+int ax_get_mac_pass(struct ax_device *axdev, u8 *mac)
+{
+#ifdef ENABLE_MAC_PASS
+	efi_char16_t name[] = L"MacAddressPassTemp";
+	efi_guid_t guid = EFI_GUID(0xe2a741d8, 0xedf5, 0x47a1,
+				   0x8f, 0x94, 0xb0, 0xee,
+				   0x36, 0x8a, 0x3d, 0xe0);
+	u32 attr;
+	unsigned long data_size = sizeof(struct mac_pass);
+	struct mac_pass macpass;
+	efi_status_t status;
+#if KERNEL_VERSION(5, 7, 0) <= LINUX_VERSION_CODE
+	if (!efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE))
+		return -EOPNOTSUPP;
+#else
+	if (!efi_enabled(EFI_RUNTIME_SERVICES))
+		return -EOPNOTSUPP;
+#endif
+	status = efi.get_variable(name, &guid, &attr, &data_size, &macpass);
+	if (status != EFI_SUCCESS) {
+		netdev_err(axdev->netdev, "Getting variable failed.(%ld)",
+			   status);
+		return status;
+	}
+
+	if (macpass.control == MAC_PASS_ENABLE_0)
+		memcpy(mac, macpass.mac0, 6);
+	else if (macpass.control == MAC_PASS_ENABLE_1)
+		memcpy(mac, macpass.mac1, 6);
+	else
+		return -1;
+#endif
+	return 0;
+}
+
+int ax_check_ether_addr(struct ax_device *axdev)
+{
+	u8 *addr = (u8 *)axdev->netdev->dev_addr;
+	u8 default_mac[6] = {0, 0x0e, 0xc6, 0x81, 0x79, 0x01};
+	u8 default_mac_178a[6] = {0, 0x0e, 0xc6, 0x81, 0x78, 0x01};
+
+	if (((addr[0] == 0) && (addr[1] == 0) && (addr[2] == 0)) ||
+	    !is_valid_ether_addr(addr) ||
+	    !memcmp(axdev->netdev->dev_addr, default_mac, ETH_ALEN) ||
+	    !memcmp(axdev->netdev->dev_addr, default_mac_178a, ETH_ALEN)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+		eth_random_addr(addr);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	eth_hw_addr_random(axdev->netdev);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+	axdev->netdev->addr_assign_type |= NET_ADDR_RANDOM;
+#endif
+random_ether_addr(axdev->netdev->dev_addr);
+#endif		
+#endif
+
+		addr[0] = 0;
+		addr[1] = 0x0E;
+		addr[2] = 0xC6;
+
+		return -EADDRNOTAVAIL;
+	}
+
+	return 0;
+}
+
+static int ax_get_chip_version(struct ax_device *axdev)
+{
+	int ret = 0;
+
+	axdev->chip_version = AX_VERSION_INVALID;
+	ret = ax_read_cmd(axdev, AX_ACCESS_MAC, AX_CHIP_STATUS,
+			  1, 1, &axdev->chip_version, 0);
+	if (ret < 0)
+		return ret;
+	axdev->chip_version = CHIP_CODE(axdev->chip_version);
+
+	return 0;
+}
+
+static void ax_get_chip_subversion(struct ax_device *axdev)
+{
+	if (axdev->chip_version < AX_VERSION_AX88179A_772D) {
+		axdev->sub_version = 0;
+		return;
+	}
+
+	if (ax_read_cmd(axdev, AX88179A_ACCESS_BL, AX88179A_HW_EC_VERSION,
+			1, 1, &axdev->sub_version, 0) < 0)
+		axdev->sub_version = 0;
+}
+
+static int ax_get_chip_feature(struct ax_device *axdev)
+{
+	if (ax_get_chip_version(axdev))
+		return -ENODEV;
+
+	if (axdev->chip_version < AX_VERSION_AX88179)
+		return -ENODEV;
+
+	ax_get_chip_subversion(axdev);
+
+	return 0;
+}
+
+static int ax_get_mac_address(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+
+	if (ax_read_cmd(axdev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,
+			ETH_ALEN, (void *)netdev->dev_addr, 0) < 0) {
+		dev_err(&axdev->intf->dev, "Failed to read MAC address");
+		return -ENODEV;
+	}
+
+	if (ax_check_ether_addr(axdev))
+		dev_warn(&axdev->intf->dev, "Found invalid MAC address value");
+
+	ax_get_mac_pass(axdev, (void *)netdev->dev_addr);
+
+
+	memcpy(netdev->perm_addr, (void *)netdev->dev_addr, ETH_ALEN);
+
+	if (ax_write_cmd(axdev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,
+			ETH_ALEN, (void *)netdev->dev_addr) < 0) {
+		dev_err(&axdev->intf->dev, "Failed to write MAC address");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+
+static bool ax_can_wakeup(struct ax_device *axdev)
+{
+	struct usb_device *udev = axdev->udev;
+
+	return (udev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_WAKEUP);
+}
+
+static int ax_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+	//struct usb_driver *driver = to_usb_driver(intf->dev.driver);
+	const struct driver_info *info;
+	struct net_device *netdev;
+	struct ax_device *axdev;
+	int ret;
+
+	if (udev->actconfig->desc.bConfigurationValue != 1) {
+		usb_driver_set_configuration(udev, 1);
+		return -ENODEV;
+	}
+
+	info = (const struct driver_info *)id->driver_info;
+	if (!info || !info->bind || !info->unbind) {
+		dev_err(&intf->dev, "Driver method not registered\n");
+		return -ENODEV;
+	}
+
+	netdev = alloc_etherdev(sizeof(struct ax_device));
+	if (!netdev) {
+		dev_err(&intf->dev, "Out of memory\n");
+		return -ENOMEM;
+	}
+
+	axdev = netdev_priv(netdev);
+	axdev->driver_info = info;
+
+	netdev->watchdog_timeo = AX_TX_TIMEOUT;
+
+	axdev->udev = udev;
+	axdev->netdev = netdev;
+	axdev->intf = intf;
+	intf->needs_remote_wakeup = true;
+#ifdef ENABLE_AUTODETACH_FUNC
+	axdev->autodetach = (autodetach == -1) ? false : true;
+#else
+	axdev->autodetach = false;
+#endif
+	mutex_init(&axdev->control);
+	INIT_DELAYED_WORK(&axdev->schedule, ax_work_func_t);
+#ifdef ENABLE_TX_TASKLET
+#if KERNEL_VERSION(5,10,0) > LINUX_VERSION_CODE
+	tasklet_init(&axdev->tx_tl, ax_bottom_half, (unsigned long) axdev);
+#else
+	tasklet_setup(&axdev->tx_tl, ax_bottom_half);
+#endif
+	tasklet_disable(&axdev->tx_tl);
+#endif
+
+	ret = ax_get_chip_feature(axdev);
+	if (ret) {
+		dev_err(&intf->dev, "Failed to get Device feature\n");
+		goto out;
+	}
+
+	ret = info->bind(axdev);
+	if (ret) {
+		dev_err(&intf->dev, "Device initialization failed\n");
+		goto out;
+	}
+
+	usb_set_intfdata(intf, axdev);
+#ifdef ENABLE_RX_TASKLET
+#if KERNEL_VERSION(5,10,0) > LINUX_VERSION_CODE
+	tasklet_init(&axdev->rx_tl, ax_poll, (unsigned long) axdev);
+#else
+	tasklet_setup(&axdev->rx_tl, ax_poll);
+#endif
+	tasklet_disable(&axdev->rx_tl);
+#else
+#if KERNEL_VERSION(5, 19, 0) <= LINUX_VERSION_CODE
+	netif_napi_add_weight(netdev, &axdev->napi, ax_poll, AX88179_NAPI_WEIGHT);
+#else
+	netif_napi_add(netdev, &axdev->napi, ax_poll, AX88179_NAPI_WEIGHT);
+#endif
+#endif
+	ret = ax_get_mac_address(axdev);
+	if (ret < 0)
+		goto out;
+
+	SET_NETDEV_DEV(netdev, &intf->dev);
+	ret = register_netdev(netdev);
+	if (ret != 0) {
+		netif_err(axdev, probe, netdev,
+			  "couldn't register the device\n");
+		goto out1;
+	}
+
+	device_set_wakeup_enable(&udev->dev, ax_can_wakeup(axdev));
+#ifdef ENABLE_INT_POLLING
+	INIT_DELAYED_WORK(&axdev->int_polling_work, __int_polling_work);
+#endif
+
+	return 0;
+out1:
+#ifdef ENABLE_RX_TASKLET
+	tasklet_kill(&axdev->rx_tl);
+#else
+	netif_napi_del(&axdev->napi);
+#endif
+#ifdef ENABLE_TX_TASKLET
+	tasklet_kill(&axdev->tx_tl);
+#endif
+	usb_set_intfdata(intf, NULL);
+out:
+	free_netdev(netdev);
+	return ret;
+}
+
+static void ax_disconnect(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+
+	usb_set_intfdata(intf, NULL);
+	if (axdev) {
+		axdev->driver_info->unbind(axdev);
+		ax_set_unplug(axdev);
+#ifdef ENABLE_RX_TASKLET
+		tasklet_kill(&axdev->rx_tl);
+#else
+		netif_napi_del(&axdev->napi);
+#endif
+#ifdef ENABLE_TX_TASKLET
+		tasklet_kill(&axdev->tx_tl);
+#endif
+		unregister_netdev(axdev->netdev);
+		free_netdev(axdev->netdev);
+	}
+}
+
+static int ax_pre_reset(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+	struct net_device *netdev;
+
+	if (!axdev)
+		return 0;
+
+	netdev = axdev->netdev;
+	if (!netif_running(netdev))
+		return 0;
+
+	netif_stop_queue(netdev);
+#ifdef ENABLE_TX_TASKLET
+	tasklet_disable(&axdev->tx_tl);
+#endif
+	clear_bit(AX_ENABLE, &axdev->flags);
+	usb_kill_urb(axdev->intr_urb);
+#ifdef ENABLE_INT_POLLING
+	cancel_delayed_work_sync(&axdev->int_polling_work);
+#endif
+	cancel_delayed_work_sync(&axdev->schedule);
+#ifdef ENABLE_RX_TASKLET
+	tasklet_disable(&axdev->rx_tl);
+#else
+	napi_disable(&axdev->napi);
+#endif
+	return 0;
+}
+
+static int ax_post_reset(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+	struct net_device *netdev;
+
+	if (!axdev)
+		return 0;
+
+	netdev = axdev->netdev;
+	if (!netif_running(netdev))
+		return 0;
+
+	set_bit(AX_ENABLE, &axdev->flags);
+	if (netif_carrier_ok(netdev)) {
+		mutex_lock(&axdev->control);
+		ax_start_rx(axdev);
+		mutex_unlock(&axdev->control);
+	}
+
+#ifdef ENABLE_RX_TASKLET
+	tasklet_enable(&axdev->rx_tl);
+#else
+	napi_enable(&axdev->napi);
+#endif
+#ifdef ENABLE_TX_TASKLET
+	tasklet_enable(&axdev->tx_tl);
+#endif
+	netif_wake_queue(netdev);
+	usb_submit_urb(axdev->intr_urb, GFP_KERNEL);
+#ifdef ENABLE_INT_POLLING
+	schedule_delayed_work(&axdev->int_polling_work,
+			      msecs_to_jiffies(INT_POLLING_TIMER));
+#endif
+
+	if (!list_empty(&axdev->rx_done))
+#ifdef ENABLE_RX_TASKLET
+		tasklet_schedule(&axdev->rx_tl);
+#else
+		napi_schedule(&axdev->napi);
+#endif
+
+	return 0;
+}
+
+static int ax_system_resume(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+
+	netif_device_attach(netdev);
+
+	if (netif_running(netdev) && (netdev->flags & IFF_UP)) {
+		netif_carrier_off(netdev);
+
+		axdev->driver_info->system_resume(axdev);
+		set_bit(AX_ENABLE, &axdev->flags);
+		usb_submit_urb(axdev->intr_urb, GFP_NOIO);
+#ifdef ENABLE_INT_POLLING
+		schedule_delayed_work(&axdev->int_polling_work,
+				      msecs_to_jiffies(INT_POLLING_TIMER));
+#endif
+	}
+
+	return 0;
+}
+
+static int ax_runtime_resume(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+
+	if (netif_running(netdev) && (netdev->flags & IFF_UP)) {
+#ifdef ENABLE_RX_TASKLET
+		tasklet_disable(&axdev->rx_tl);
+#else
+		struct napi_struct *napi = &axdev->napi;
+
+		napi_disable(napi);
+#endif
+		set_bit(AX_ENABLE, &axdev->flags);
+
+		if (netif_carrier_ok(netdev)) {
+			if (axdev->link) {
+				ax_start_rx(axdev);
+			} else {
+				netif_carrier_off(netdev);
+				if (axdev->driver_info->stop)
+					axdev->driver_info->stop(axdev);
+			}
+		}
+
+		axdev->driver_info->runtime_resume(axdev);
+
+#ifdef ENABLE_RX_TASKLET
+		tasklet_enable(&axdev->rx_tl);
+#else
+		napi_enable(napi);
+#endif	
+		clear_bit(AX_SELECTIVE_SUSPEND, &axdev->flags);
+		if (!list_empty(&axdev->rx_done)) {
+			local_bh_disable();
+#ifdef ENABLE_RX_TASKLET
+			tasklet_schedule(&axdev->rx_tl);
+#else
+			napi_schedule(&axdev->napi);
+#endif	
+			local_bh_enable();
+		}
+		usb_submit_urb(axdev->intr_urb, GFP_NOIO);
+	} else {
+		clear_bit(AX_SELECTIVE_SUSPEND, &axdev->flags);
+	}
+
+	return 0;
+}
+
+static int ax_system_suspend(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+	int ret = 0;
+
+	netif_device_detach(netdev);
+
+	
+
+	if (netif_running(netdev) && test_bit(AX_ENABLE, &axdev->flags)) {
+#ifndef ENABLE_RX_TASKLET
+		struct napi_struct *napi = &axdev->napi;
+#endif
+
+		clear_bit(AX_ENABLE, &axdev->flags);
+		usb_kill_urb(axdev->intr_urb);
+#ifdef ENABLE_TX_TASKLET
+		tasklet_disable(&axdev->tx_tl);
+#endif
+#ifdef ENABLE_INT_POLLING
+		cancel_delayed_work_sync(&axdev->int_polling_work);
+#endif
+
+		ax_disable(axdev);
+
+		axdev->driver_info->system_suspend(axdev);
+#ifdef ENABLE_RX_TASKLET
+		tasklet_disable(&axdev->rx_tl);
+#else
+		napi_disable(napi);
+#endif
+		cancel_delayed_work_sync(&axdev->schedule);
+#ifdef ENABLE_RX_TASKLET
+		tasklet_enable(&axdev->rx_tl);
+#else
+		napi_enable(napi);
+#endif
+		
+#ifdef ENABLE_TX_TASKLET
+		tasklet_enable(&axdev->tx_tl);
+#endif
+	}
+
+	return ret;
+}
+
+static int ax_runtime_suspend(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+
+	set_bit(AX_SELECTIVE_SUSPEND, &axdev->flags);
+
+	if (netif_running(netdev) && test_bit(AX_ENABLE, &axdev->flags)) {
+		clear_bit(AX_ENABLE, &axdev->flags);
+		usb_kill_urb(axdev->intr_urb);
+#ifdef ENABLE_INT_POLLING
+		cancel_delayed_work_sync(&axdev->int_polling_work);
+#endif
+
+		if (netif_carrier_ok(netdev)) {
+#ifdef ENABLE_RX_TASKLET
+			tasklet_disable(&axdev->rx_tl);
+#else
+			struct napi_struct *napi = &axdev->napi;
+
+			napi_disable(napi);
+#endif
+			
+			ax_stop_rx(axdev);
+#ifdef ENABLE_RX_TASKLET
+			tasklet_enable(&axdev->rx_tl);
+#else
+			napi_enable(napi);
+#endif
+		}
+
+		axdev->driver_info->runtime_suspend(axdev);
+	}
+
+	return 0;
+}
+
+static int ax_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+	int ret;
+
+	mutex_lock(&axdev->control);
+
+	if (PMSG_IS_AUTO(message))
+		ret = ax_runtime_suspend(axdev);
+	else
+		ret = ax_system_suspend(axdev);
+
+	mutex_unlock(&axdev->control);
+
+	return ret;
+}
+
+static int ax_resume(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+	int ret;
+
+	mutex_lock(&axdev->control);
+
+	if (test_bit(AX_SELECTIVE_SUSPEND, &axdev->flags))
+		ret = ax_runtime_resume(axdev);
+	else
+		ret = ax_system_resume(axdev);
+
+	mutex_unlock(&axdev->control);
+
+	return ret;
+}
+
+static int ax_reset_resume(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+
+	clear_bit(AX_SELECTIVE_SUSPEND, &axdev->flags);
+
+	return ax_resume(intf);
+}
+
+const struct net_device_ops ax88179_netdev_ops = {
+	.ndo_open		= ax_open,
+	.ndo_stop		= ax_close,
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+	.ndo_siocdevprivate	= ax88179_siocdevprivate,
+	.ndo_eth_ioctl		= ax88179_ioctl,
+#endif
+	.ndo_do_ioctl		= ax88179_ioctl,
+	.ndo_start_xmit		= ax_start_xmit,
+	.ndo_tx_timeout		= ax_tx_timeout,
+	.ndo_set_features	= ax88179_set_features,
+	.ndo_set_rx_mode	= ax88179_set_multicast,
+	.ndo_set_mac_address	= ax88179_set_mac_addr,
+	.ndo_change_mtu		= ax88179_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
+const struct net_device_ops ax88179a_netdev_ops = {
+	.ndo_open		= ax_open,
+	.ndo_stop		= ax_close,
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE
+	.ndo_siocdevprivate	= ax88179a_siocdevprivate,
+	.ndo_eth_ioctl		= ax88179a_ioctl,
+#endif
+	.ndo_do_ioctl		= ax88179a_ioctl,
+	.ndo_start_xmit		= ax_start_xmit,
+	.ndo_tx_timeout		= ax_tx_timeout,
+	.ndo_set_features	= ax88179_set_features,
+	.ndo_set_rx_mode	= ax88179a_set_multicast,
+	.ndo_set_mac_address	= ax88179_set_mac_addr,
+	.ndo_change_mtu		= ax88179_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
+#define ASIX_USB_DEVICE(vend, prod, lo, hi, info) { \
+	USB_DEVICE_VER(vend, prod, lo, hi), \
+	.driver_info = (unsigned long)&info \
+}
+
+static const struct usb_device_id ax_usb_table[] = {
+	ASIX_USB_DEVICE(USB_VENDOR_ID_ASIX, AX_DEVICE_ID_179X, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_ASIX, AX_DEVICE_ID_178A, 0,
+			AX_BCDDEVICE_ID_178A, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_SITECOM, 0x0072, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_LENOVO, 0x304b, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_TOSHIBA, 0x0a13, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, 0xa100, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_DLINK, 0x4a00, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_MAGIC_CONTROL, 0x0179, 0,
+			AX_BCDDEVICE_ID_179, ax88179_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_ASIX, AX_DEVICE_ID_179X, 0,
+			AX_BCDDEVICE_ID_772D, ax88179a_info),
+	ASIX_USB_DEVICE(USB_VENDOR_ID_ASIX, AX_DEVICE_ID_179X, 0,
+			AX_BCDDEVICE_ID_179A, ax88179a_info),
+#ifdef ENABLE_AX88279
+	ASIX_USB_DEVICE(USB_VENDOR_ID_ASIX, AX_DEVICE_ID_179X, 0,
+			AX_BCDDEVICE_ID_279, ax88279_info),
+#endif
+	{/*END*/}
+};
+
+MODULE_DEVICE_TABLE(usb, ax_usb_table);
+
+static struct usb_driver ax_usb_driver = {
+	.name		= MODULENAME,
+	.id_table	= ax_usb_table,
+	.probe		= ax_probe,
+	.disconnect	= ax_disconnect,
+	.suspend	= ax_suspend,
+	.resume		= ax_resume,
+	.reset_resume	= ax_reset_resume,
+	.pre_reset	= ax_pre_reset,
+	.post_reset	= ax_post_reset,
+	.supports_autosuspend = 1,
+#if KERNEL_VERSION(3, 5, 0) <= LINUX_VERSION_CODE
+	.disable_hub_initiated_lpm = 1,
+#endif
+};
+
+module_usb_driver(ax_usb_driver);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
diff --git a/drivers/net/usb/asix_usb/ax_main.h b/drivers/net/usb/asix_usb/ax_main.h
new file mode 100644
index 000000000000..016ac446d4d2
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax_main.h
@@ -0,0 +1,674 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#ifndef __ASIX_MAIN_H
+#define __ASIX_MAIN_H
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <uapi/linux/mdio.h>
+#include <linux/mdio.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/usb.h>
+#include <linux/if_vlan.h>
+#include <linux/usb/cdc.h>
+#include <linux/suspend.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <linux/efi.h>
+#include <linux/crc32.h>
+#include <linux/time.h>
+#include "ax_ioctl.h"
+
+#define napi_alloc_skb(napi, length) netdev_alloc_skb_ip_align(netdev, length)
+#define napi_complete_done(n, d) napi_complete(n)
+
+typedef int (*_usb_read_function)(struct ax_device *dev, u8 cmd, u8 reqtype,
+				  u16 value, u16 index, void *data, u16 size);
+typedef int (*_usb_write_function)(struct ax_device *dev, u8 cmd, u8 reqtype,
+				   u16 value, u16 index, const void *data,
+				   u16 size);
+typedef int (*usb_read_function)(struct ax_device *axdev, u8 cmd, u16 value,
+				 u16 index, u16 size, void *data, int eflag);
+typedef int (*usb_write_function)(struct ax_device *axdev, u8 cmd, u16 value,
+				  u16 index, u16 size, void *data);
+
+#define USB_VENDOR_ID_ASIX		0x0B95
+#define USB_VENDOR_ID_SITECOM		0x0DF6
+#define USB_VENDOR_ID_LENOVO		0x17EF
+#define USB_VENDOR_ID_TOSHIBA		0x0930
+#define USB_VENDOR_ID_SAMSUNG		0x04E8
+#define USB_VENDOR_ID_DLINK		0x2001
+#define USB_VENDOR_ID_MAGIC_CONTROL	0x0711
+
+#define AX_DEVICE_ID_179X	0x1790
+#define AX_BCDDEVICE_ID_179	0x0100
+#define AX_BCDDEVICE_ID_179A	0x0200
+#define AX_DEVICE_ID_178A	0x178A
+#define AX_BCDDEVICE_ID_178A	0x0100
+#define AX_DEVICE_ID_772D	AX_DEVICE_ID_179X
+#define AX_BCDDEVICE_ID_772D	0x0300
+#ifdef ENABLE_AX88279
+#define AX_BCDDEVICE_ID_279	0x0400
+#endif
+
+#define AX_DRIVER_STRING_179_178A \
+				"ASIX AX88179_178A USB Ethernet Controller"
+#define AX_DRIVER_STRING_179A_772D \
+				"ASIX AX88179B_179A_772E_772D USB Ethernet Controller"
+#ifdef ENABLE_AX88279
+#define AX_DRIVER_STRING_279 \
+				"ASIX AX88279 USB Ethernet Controller"
+#endif
+
+#define DRIVER_VERSION		"3.1.0"
+#define DRIVER_AUTHOR		"ASIX"
+#define DRIVER_DESC		"ASIX USB Ethernet Controller"
+#define MODULENAME		"ax_usb_nic"
+
+#define PRINT_VERSION(axdev, str) \
+	dev_info(&axdev->intf->dev, \
+		"%s %s (%d.%d.%d.%d_%d.%d)", \
+		str, DRIVER_VERSION, \
+		axdev->fw_version[0], \
+		axdev->fw_version[1], \
+		axdev->fw_version[2], \
+		axdev->fw_version[3], \
+		axdev->chip_version, \
+		axdev->sub_version)
+
+#define AX88179_MAX_TX		4
+#define AX88179_MAX_RX		10
+#define AX88179_BUF_TX_SIZE	(81 * 1024)
+#define AX_GSO_DEFAULT_SIZE	(16 * 1024)
+#define INTBUFSIZE		8
+#define TX_ALIGN		4
+#define RX_ALIGN		8
+#define TX_CASECADES_SIZE	AX_GSO_DEFAULT_SIZE
+
+#define AX_TX_HEADER_LEN	8
+#define AX_TX_TIMEOUT		(5 * HZ)
+#define AX_MCAST_FILTER_SIZE	8
+#define AX_MAX_MCAST		64
+#ifdef ENABLE_QUEUE_PRIORITY
+#define AX_TX_QUEUE_SIZE	2
+#else
+#define AX_TX_QUEUE_SIZE	1
+#endif
+
+#define US_TO_NS		1000
+
+#define AX_ACCESS_MAC			0x01
+#define AX_ACCESS_PHY			0x02
+#define AX_ACCESS_WAKEUP		0x03
+#define AX_ACCESS_EEPROM		0x04
+#define AX_ACCESS_EFUSE			0x05
+#define AX_RELOAD_EEPROM_EFUSE		0x06
+#define AX_RELOAD_FLASH_EFUSE		0x06
+#define AX_FW_MODE			0x08
+	#define AX_FW_MODE_179A			0x0001
+	#define AX_USB_EP5_EN			0x0001
+#ifdef ENABLE_AX88279
+#ifdef ENABLE_PTP_FUNC
+	#define AX_USB_EP4_EN			0x0002
+#endif
+#endif
+#define AX_WRITE_EFUSE_EN		0x09
+#define AX_WRITE_EFUSE_DIS		0x0A
+#define AX_ACCESS_MFAB			0x10
+#define AX_PHY_POLLING			0x90
+
+#define PHYSICAL_LINK_STATUS		0x02
+	#define	AX_USB_SS			0x04
+	#define	AX_USB_HS			0x02
+	#define	AX_USB_FS			0x01
+#define GENERAL_STATUS			0x03
+	#define	AX_SECLD			0x04
+#define AX_CHIP_STATUS			0x05
+	#define AX_CHIP_CODE_MASK		0x70
+	#define CHIP_CODE(x)		((x & AX_CHIP_CODE_MASK) >> 4)
+#define AX_SROM_ADDR			0x07
+#define AX_SROM_CMD			0x0a
+	#define EEP_RD				0x04
+	#define EEP_WR				0x08
+	#define EEP_BUSY			0x10
+#define AX_SROM_DATA_LOW		0x08
+#define AX_SROM_DATA_HIGH		0x09
+#define AX_RX_CTL			0x0b
+#define AX_RX_CTL_HI			0x0c
+	#define AX_RX_CTL_DROPCRCERR_HI		0x01
+	#define AX_RX_CTL_DROPCRCERR		0x0100
+	#define AX_RX_CTL_IPE			0x0200
+	#define AX_RX_CTL_TXPADCRC		0x0400
+	#define AX_RX_CTL_START			0x0080
+	#define AX_RX_CTL_AP			0x0020
+	#define AX_RX_CTL_AM			0x0010
+	#define AX_RX_CTL_AB			0x0008
+	#define AX_RX_CTL_HA8B			0x0004
+	#define AX_RX_CTL_AMALL			0x0002
+	#define AX_RX_CTL_PRO			0x0001
+	#define AX_RX_CTL_STOP			0x0000
+#define AX_NODE_ID			0x10
+#define AX_MULTI_FILTER_ARRY		0x16
+#define AX_MEDIUM_STATUS_MODE		0x22
+	#define AX_MEDIUM_GIGAMODE		0x0001
+	#define AX_MEDIUM_FULL_DUPLEX		0x0002
+	#define AX_MEDIUM_RXFLOW_CTRLEN		0x0010
+	#define AX_MEDIUM_TXFLOW_CTRLEN		0x0020
+	#define AX_MEDIUM_RECEIVE_EN		0x0100
+	#define AX_MEDIUM_PS			0x0200
+	#define AX_MEDIUM_JUMBO_EN		0x8040
+#define AX_MONITOR_MODE			0x24
+	#define AX_MONITOR_MODE_RWLC		0x02
+	#define AX_MONITOR_MODE_RWMP		0x04
+	#define AX_MONITOR_MODE_RWWF		0x08
+	#define AX_MONITOR_MODE_RW_FLAG		0x10
+	#define AX_MONITOR_MODE_PMEPOL		0x20
+	#define AX_MONITOR_MODE_PMETYPE		0x40
+#define AX_GPIO_CTRL			0x25
+	#define AX_GPIO_CTRL_GPIO3EN		0x80
+	#define AX_GPIO_CTRL_GPIO2EN		0x40
+	#define AX_GPIO_CTRL_GPIO1EN		0x20
+#define AX_PHYPWR_RSTCTL		0x26
+	#define AX_PHYPWR_RSTCTL_BZ		0x0010
+	#define AX_PHYPWR_RSTCTL_IPRL		0x0020
+	#define AX_PHYPWR_RSTCTL_AUTODETACH	0x1000
+#define AX_RX_BULKIN_QCTRL		0x2e
+	#define AX_RX_BULKIN_QCTRL_TIME		0x01
+	#define AX_RX_BULKIN_QCTRL_IFG		0x02
+	#define AX_RX_BULKIN_QCTRL_SIZE		0x04
+#define AX_RX_BULKIN_QTIMR_LOW		0x2f
+#define AX_RX_BULKIN_QTIMR_HIGH			0x30
+#define AX_RX_BULKIN_QSIZE			0x31
+#define AX_RX_BULKIN_QIFG			0x32
+#define AX_CLK_SELECT			0x33
+	#define AX_CLK_SELECT_BCS		0x01
+	#define AX_CLK_SELECT_ACS		0x02
+	#define AX_CLK_SELECT_ACSREQ		0x10
+	#define AX_CLK_SELECT_ULR		0x08
+#define AX_RXCOE_CTL			0x34
+	#define AX_RXCOE_IP			0x01
+	#define AX_RXCOE_TCP			0x02
+	#define AX_RXCOE_UDP			0x04
+	#define AX_RXCOE_ICMP			0x08
+	#define AX_RXCOE_IGMP			0x10
+	#define AX_RXCOE_TCPV6			0x20
+	#define AX_RXCOE_UDPV6			0x40
+	#define AX_RXCOE_ICMV6			0x80
+
+#if KERNEL_VERSION(2, 6, 22) < LINUX_VERSION_CODE
+	#define AX_RXCOE_DEF_CSUM	(AX_RXCOE_IP	| AX_RXCOE_TCP  | \
+					 AX_RXCOE_UDP	| AX_RXCOE_ICMV6 | \
+					 AX_RXCOE_TCPV6	| AX_RXCOE_UDPV6)
+#else
+	#define AX_RXCOE_DEF_CSUM	(AX_RXCOE_IP	| AX_RXCOE_TCP | \
+					 AX_RXCOE_UDP)
+#endif
+
+#define AX_TXCOE_CTL			0x35
+	#define AX_TXCOE_IP			0x01
+	#define AX_TXCOE_TCP			0x02
+	#define AX_TXCOE_UDP			0x04
+	#define AX_TXCOE_ICMP			0x08
+	#define AX_TXCOE_IGMP			0x10
+	#define AX_TXCOE_TCPV6			0x20
+	#define AX_TXCOE_UDPV6			0x40
+	#define AX_TXCOE_ICMV6			0x80
+#if KERNEL_VERSION(2, 6, 22) < LINUX_VERSION_CODE
+	#define AX_TXCOE_DEF_CSUM	(AX_TXCOE_TCP   | AX_TXCOE_UDP | \
+					 AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6)
+#else
+	#define AX_TXCOE_DEF_CSUM	(AX_TXCOE_TCP	| AX_TXCOE_UDP)
+#endif
+#define AX_PAUSE_WATERLVL_HIGH		0x54
+#define AX_PAUSE_WATERLVL_LOW		0x55
+#define AX_RX_FREE_BUF_LOW		0x57
+
+#define GMII_PHY_CONTROL		0x00
+	#define GMII_CONTROL_RESET		0x8000
+	#define GMII_CONTROL_LOOPBACK		0x4000
+	#define GMII_CONTROL_10MB		0x0000
+	#define GMII_CONTROL_100MB		0x2000
+	#define GMII_CONTROL_1000MB		0x0040
+	#define GMII_CONTROL_SPEED_BITS		0x2040
+	#define GMII_CONTROL_ENABLE_AUTO	0x1000
+	#define GMII_CONTROL_POWER_DOWN		0x0800
+	#define GMII_CONTROL_ISOLATE		0x0400
+	#define GMII_CONTROL_START_AUTO		0x0200
+	#define GMII_CONTROL_FULL_DUPLEX	0x0100
+#define GMII_PHY_STATUS			0x01
+	#define GMII_STATUS_100MB_MASK		0xE000
+	#define GMII_STATUS_10MB_MASK		0x1800
+	#define GMII_STATUS_AUTO_DONE		0x0020
+	#define GMII_STATUS_AUTO		0x0008
+	#define GMII_STATUS_LINK_UP		0x0004
+	#define GMII_STATUS_EXTENDED		0x0001
+	#define GMII_STATUS_100T4		0x8000
+	#define GMII_STATUS_100TXFD		0x4000
+	#define GMII_STATUS_100TX		0x2000
+	#define GMII_STATUS_10TFD		0x1000
+	#define GMII_STATUS_10T			0x0800
+#define GMII_PHY_OUI			0x02
+#define GMII_PHY_MODEL			0x03
+#define GMII_PHY_ANAR			0x04
+	#define GMII_ANAR_ASYM_PAUSE		0x0800
+	#define GMII_ANAR_PAUSE			0x0400
+	#define GMII_ANAR_100T4			0x0200
+	#define GMII_ANAR_100TXFD		0x0100
+	#define GMII_ANAR_100TX			0x0080
+	#define GMII_ANAR_10TFD			0x0040
+	#define GMII_ANAR_10T			0x0020
+	#define GMII_SELECTOR_FIELD		0x001F
+
+#define GMII_PHY_ANLPAR			0x05
+	#define GMII_ANLPAR_100T4		0x0200
+	#define GMII_ANLPAR_100TXFD		0x0100
+	#define GMII_ANLPAR_100TX		0x0080
+	#define GMII_ANLPAR_10TFD		0x0040
+	#define GMII_ANLPAR_10T			0x0020
+	#define GMII_ANLPAR_PAUSE		0x0400
+	#define GMII_ANLPAR_ASYM_PAUSE		0x0800
+	#define GMII_ANLPAR_ACK			0x4000
+	#define GMII_SELECTOR_8023		0x0001
+#define GMII_PHY_ANER			0x06
+#define GMII_PHY_1000BT_CONTROL		0x09
+#define GMII_PHY_1000BT_STATUS		0x0A
+#define GMII_PHY_MACR			0x0D
+#define GMII_PHY_MAADR			0x0E
+#define GMII_PHY_PHYSR			0x11
+	#define GMII_PHY_PHYSR_SMASK		0xc000
+	#define GMII_PHY_PHYSR_GIGA		0x8000
+	#define GMII_PHY_PHYSR_100		0x4000
+	#define GMII_PHY_PHYSR_FULL		0x2000
+	#define GMII_PHY_PHYSR_LINK		0x400
+
+#define GMII_1000_AUX_CTRL_MASTER_SLAVE		0x1000
+#define GMII_1000_AUX_CTRL_FD_CAPABLE		0x0200
+#define GMII_1000_AUX_CTRL_HD_CAPABLE		0x0100
+#define GMII_1000_AUX_STATUS_FD_CAPABLE		0x0800
+#define GMII_1000_AUX_STATUS_HD_CAPABLE		0x0400
+#define GMII_AUX_CTRL_STATUS		0x1C
+#define GMII_AUX_ANEG_CPLT			0x8000
+#define GMII_AUX_FDX				0x0020
+#define GMII_AUX_SPEED_1000			0x0010
+#define GMII_AUX_SPEED_100			0x0008
+#define GMII_LED_ACTIVE			0x1a
+	#define GMII_LED_ACTIVE_MASK		0xff8f
+	#define GMII_LED0_ACTIVE		(1 << 4)
+	#define GMII_LED1_ACTIVE		(1 << 5)
+	#define GMII_LED2_ACTIVE		(1 << 6)
+#define GMII_LED_LINK			0x1c
+	#define GMII_LED_LINK_MASK		0xf888
+	#define GMII_LED0_LINK_10		(1 << 0)
+	#define GMII_LED0_LINK_100		(1 << 1)
+	#define GMII_LED0_LINK_1000		(1 << 2)
+	#define GMII_LED1_LINK_10		(1 << 4)
+	#define GMII_LED1_LINK_100		(1 << 5)
+	#define GMII_LED1_LINK_1000		(1 << 6)
+	#define GMII_LED2_LINK_10		(1 << 8)
+	#define GMII_LED2_LINK_100		(1 << 9)
+	#define GMII_LED2_LINK_1000		(1 << 10)
+	#define	LED_VALID			(1 << 15)
+	#define	LED0_ACTIVE			(1 << 0)
+	#define	LED0_LINK_10			(1 << 1)
+	#define	LED0_LINK_100			(1 << 2)
+	#define	LED0_LINK_1000			(1 << 3)
+	#define	LED0_FD				(1 << 4)
+	#define LED0_USB3_MASK			0x001f
+	#define	LED1_ACTIVE			(1 << 5)
+	#define	LED1_LINK_10			(1 << 6)
+	#define	LED1_LINK_100			(1 << 7)
+	#define	LED1_LINK_1000			(1 << 8)
+	#define	LED1_FD				(1 << 9)
+	#define LED1_USB3_MASK			0x03e0
+	#define	LED2_ACTIVE			(1 << 10)
+	#define	LED2_LINK_1000			(1 << 13)
+	#define	LED2_LINK_100			(1 << 12)
+	#define	LED2_LINK_10			(1 << 11)
+	#define	LED2_FD				(1 << 14)
+	#define LED2_USB3_MASK			0x7c00
+#define GMII_PHYPAGE			0x1e
+#define GMII_PHY_PAGE_SELECT		0x1f
+	#define GMII_PHY_PAGE_SELECT_EXT	0x0007
+	#define GMII_PHY_PAGE_SELECT_PAGE0	0X0000
+	#define GMII_PHY_PAGE_SELECT_PAGE1	0X0001
+	#define GMII_PHY_PAGE_SELECT_PAGE2	0X0002
+	#define GMII_PHY_PAGE_SELECT_PAGE3	0X0003
+	#define GMII_PHY_PAGE_SELECT_PAGE4	0X0004
+	#define GMII_PHY_PAGE_SELECT_PAGE5	0X0005
+	#define GMII_PHY_PAGE_SELECT_PAGE6	0X0006
+
+enum ax_driver_flags {
+	AX_UNPLUG = 0,
+	AX_ENABLE,
+	AX_LINK_CHG,
+	AX_SELECTIVE_SUSPEND,
+	AX_SCHEDULE_NAPI,
+	AX_EN_RX,
+	AX_SCHEDULE_TASKLET_TX,
+	AX_SCHEDULE_TASKLET_RX,
+};
+
+enum ax_chip_version {
+	AX_VERSION_INVALID		= 0,
+	AX_VERSION_AX88179		= 4,
+	AX_VERSION_AX88179A_772D	= 6,
+#ifdef ENABLE_AX88279
+	AX_VERSION_AX88279		= 7,
+#endif
+};
+
+struct ax_device;
+
+struct rx_desc {
+	struct list_head list;
+	struct urb *urb;
+	struct ax_device *context;
+	void *buffer;
+	void *head;
+};
+
+enum __ax_tx_flags {
+	AX_TX_NONE		= 0,
+	AX_TX_TIMESTAMPS	= 1,
+};
+
+enum __mac_pass_ctrl {
+	MAC_PASS_DISABLED	= 0,
+	MAC_PASS_ENABLE_0	= 1,
+	MAC_PASS_ENABLE_1	= 2,
+};
+
+struct mac_pass {
+	u8	control;
+	u8	mac0[8];
+	u8	mac1[8];
+} __packed;
+
+struct tx_desc {
+	struct list_head list;
+	struct urb *urb;
+	struct ax_device *context;
+	void *buffer;
+	void *head;
+	u32 skb_num;
+	u32 skb_len;
+	unsigned long flags;
+	int q_index;
+};
+
+struct ax_bulkin_setting {
+	u8 custom;
+	u8 bulkin_setting[5];
+};
+
+enum ax_ether_link_speed {
+	ETHER_LINK_NONE	= 0,
+	ETHER_LINK_10	= 1,
+	ETHER_LINK_100	= 2,
+	ETHER_LINK_1000	= 3,
+	ETHER_LINK_2500	= 4,
+};
+
+struct ax_link_info {
+	u8 eth_speed	: 3,
+	   full_duplex	: 1,
+	   usb_speed	: 4;
+} __packed;
+
+struct ax_device {
+	unsigned long flags;
+	struct usb_device *udev;
+	struct usb_interface *intf;
+	struct net_device *netdev;
+	const struct driver_info *driver_info;
+#ifndef ENABLE_RX_TASKLET
+	struct napi_struct napi;
+#endif
+	struct urb *intr_urb;
+	struct tx_desc tx_list[32];
+	struct rx_desc rx_list[32];
+	struct list_head rx_done, tx_free;
+	struct sk_buff_head tx_queue[AX_TX_QUEUE_SIZE];
+	struct sk_buff_head rx_queue;
+	spinlock_t rx_lock, tx_lock;
+	struct delayed_work schedule;
+	struct mii_if_info mii;
+	struct mutex control;
+#ifdef ENABLE_TX_TASKLET
+	struct tasklet_struct tx_tl;
+#endif
+#ifdef ENABLE_RX_TASKLET
+	struct tasklet_struct rx_tl;
+#endif
+
+	int intr_interval;
+	u32 saved_wolopts;
+	u32 msg_enable;
+	u32 tx_qlen;
+	u32 coalesce;
+	u16 speed;
+	u8 *intr_buff;
+	u8 tx_align_len;
+	u8 link;
+	u16 rxctl;
+	u8 m_filter[8];
+	u32 tx_casecade_size;
+	u32 gso_max_size;
+	u8 fw_version[4];
+
+	struct ax_link_info link_info;
+	struct ax_link_info intr_link_info;
+	u8  eee_enabled;
+	u8  eee_active;
+	int autodetach;
+
+	struct ax_bulkin_setting bin_setting;
+	bool tx_header_cksum;
+	unsigned char chip_version;
+	unsigned char sub_version;
+#define AX_ETH_SPEED_MASK	0xF
+#define AX_ETH_DUPLEX_FULL	0x10
+	u8 int_link_info;
+	u8 int_link_chg;
+
+#ifdef ENABLE_PTP_FUNC
+	struct ax_ptp_cfg *ptp_cfg;
+	struct sk_buff_head tx_timestamp;
+#endif
+#ifdef ENABLE_MACSEC_FUNC
+	struct ax_macsec_cfg *macsec_cfg;
+#endif
+	u64 bulkin_complete;
+	u64 bulkin_error;
+	u64 bulkout_complete;
+	u64 bulkout_error;
+	u64 bulkint_complete;
+	u64 bulkint_error;
+#ifdef ENABLE_QUEUE_PRIORITY
+	u64 ep5_count;
+	u64 ep3_count;
+#endif
+#define CHIP_40PIN	0x03
+#define CHIP_32PIN	0x02
+	u8 chip_pin;
+#ifdef ENABLE_INT_POLLING
+#define INT_POLLING_TIMER	128	/* in milliseconds */
+	struct delayed_work int_polling_work;
+#endif
+	unsigned autosuspend_is_supported:1;
+};
+
+struct driver_info {
+	int	(*bind)(struct ax_device *axdev);
+	void	(*unbind)(struct ax_device *axdev);
+	int	(*hw_init)(struct ax_device *axdev);
+	int	(*stop)(struct ax_device *axdev);
+#ifdef ENABLE_QUEUE_PRIORITY
+	int	(*queue_priority)(struct ax_device *axdev);
+#endif
+	void	(*rx_fixup)(struct ax_device *axdev, struct rx_desc *desc,
+			    int *work_done, int budget);
+	int	(*tx_fixup)(struct ax_device *axdev, struct tx_desc *desc);
+	int	(*link_reset)(struct ax_device *axdev);
+	int	(*link_setting)(struct ax_device *axdev);
+	int	(*system_suspend)(struct ax_device *axdev);
+	int	(*system_resume)(struct ax_device *axdev);
+	int	(*runtime_suspend)(struct ax_device *axdev);
+	int	(*runtime_resume)(struct ax_device *axdev);
+
+#ifdef ENABLE_PTP_FUNC
+	int (*ptp_pps_ctrl)(struct ax_device *axdev, u8 enable);
+	int	(*ptp_init)(struct ax_device *axdev);
+	void	(*ptp_remove)(struct ax_device *axdev);
+#endif
+
+	unsigned long napi_weight;
+	size_t	buf_rx_size;
+};
+
+struct _async_cmd_handle {
+	struct ax_device *axdev;
+	struct usb_ctrlrequest *req;
+	u8 m_filter[8];
+	u16 rxctl;
+} __packed;
+
+#define AX_INT_PPLS_LINK	(1 << 0)
+#define AX_INT_SPLS_LINK	(1 << 1)
+#define AX_INT_CABOFF_UNPLUG	(1 << 7)
+struct ax_device_int_data {
+#ifdef __BIG_ENDIAN
+	u16 res3;
+	u8 status;
+	u16 res2;
+	u8 link;
+	union {
+		struct ax_link_info link_info;
+		u8 link_info_u8;
+	};
+	u8 res1;
+#else
+	u8 res1;
+	union {
+		struct ax_link_info link_info;
+		u8 link_info_u8;
+	};
+	u8 link;
+	u16 res2;
+	u8 status;
+	u16 res3;
+#endif
+} __packed;
+
+struct _ax_buikin_setting {
+	u8 ctrl;
+	u8 timer_l;
+	u8 timer_h;
+	u8 size;
+	u8 ifg;
+} __packed;
+
+#define AX_RXHDR_L4_ERR		(1 << 8)
+#define AX_RXHDR_L3_ERR		(1 << 9)
+
+#define AX_RXHDR_L4_TYPE_ICMP	2
+#define AX_RXHDR_L4_TYPE_IGMP	3
+#define AX_RXHDR_L4_TYPE_TCMPV6	5
+
+#define AX_RXHDR_L3_TYPE_IP	1
+#define AX_RXHDR_L3_TYPE_IPV6	2
+
+#define AX_RXHDR_L4_TYPE_MASK	0x1c
+#define AX_RXHDR_L4_TYPE_UDP	4
+#define AX_RXHDR_L4_TYPE_TCP	16
+#define AX_RXHDR_L3CSUM_ERR	2
+#define AX_RXHDR_L4CSUM_ERR	1
+#define AX_RXHDR_CRC_ERR	0x20000000
+#define AX_RXHDR_MII_ERR	0x40000000
+#define AX_RXHDR_DROP_ERR	0x80000000
+
+static inline void *__rx_buf_align(void *data)
+{
+	return (void *)ALIGN((uintptr_t)data, RX_ALIGN);
+}
+static inline void *__tx_buf_align(void *data, u8 tx_align_len)
+{
+	return (void *)ALIGN((uintptr_t)data, tx_align_len);
+}
+static inline struct net_device_stats *ax_get_stats(struct net_device *netdev)
+{
+	return &netdev->stats;
+}
+
+int ax_get_mac_pass(struct ax_device *axdev, u8 *mac);
+void ax_set_tx_qlen(struct ax_device *dev);
+void ax_write_bulk_callback(struct urb *urb);
+
+void ax_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info);
+#if KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
+int ax_get_settings(struct net_device *net, struct ethtool_cmd *cmd);
+int ax_set_settings(struct net_device *net, struct ethtool_cmd *cmd);
+#else
+int ax_get_link_ksettings(struct net_device *netdev,
+			  struct ethtool_link_ksettings *cmd);
+int ax_set_link_ksettings(struct net_device *netdev,
+			  const struct ethtool_link_ksettings *cmd);
+#endif
+u32 ax_get_msglevel(struct net_device *netdev);
+void ax_set_msglevel(struct net_device *netdev, u32 value);
+void ax_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo);
+int ax_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo);
+int ax_get_sset_count(struct net_device *dev, int sset);
+void ax_get_ethtool_stats
+(struct net_device *dev, struct ethtool_stats *stats, u64 *data);
+void ax_get_strings(struct net_device *netdev, u32 stringset, u8 *data);
+void ax_get_pauseparam
+(struct net_device *netdev, struct ethtool_pauseparam *pause);
+int ax_set_pauseparam
+(struct net_device *netdev, struct ethtool_pauseparam *pause);
+int ax_get_regs_len(struct net_device *netdev);
+void ax_get_regs
+(struct net_device *netdev, struct ethtool_regs *regs, void *buf);
+
+int ax_read_cmd
+(struct ax_device *axdev, u8 cmd, u16 value, u16 index, u16 size, void *data,
+int eflag);
+
+int ax_write_cmd
+(struct ax_device *axdev, u8 cmd, u16 value, u16 index, u16 size, void *data);
+
+int ax_read_cmd_nopm
+(struct ax_device *axdev, u8 cmd, u16 value, u16 index, u16 size, void *data,
+int eflag);
+
+int ax_write_cmd_nopm
+(struct ax_device *axdev, u8 cmd, u16 value, u16 index, u16 size, void *data);
+
+int ax_write_cmd_async
+(struct ax_device *axdev, u8 cmd, u16 value, u16 index, u16 size, void *data);
+
+int ax_mmd_read(struct net_device *netdev, int dev_addr, int reg);
+void ax_mmd_write(struct net_device *netdev, int dev_addr, int reg, int val);
+
+int ax_mdio_read(struct net_device *netdev, int phy_id, int reg);
+void ax_mdio_write(struct net_device *netdev, int phy_id, int reg, int val);
+
+
+int ax_usb_command(struct ax_device *axdev, struct _ax_ioctl_command *info);
+#endif /* __ASIX_MAIN_H */
diff --git a/drivers/net/usb/asix_usb/ax_ptp.c b/drivers/net/usb/asix_usb/ax_ptp.c
new file mode 100644
index 000000000000..e46373493a08
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax_ptp.c
@@ -0,0 +1,1167 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include "ax_main.h"
+#include "ax_ptp.h"
+#include "ax88179a_772d.h"
+
+#define ptp_to_dev(ptp) container_of(ptp, struct ax_ptp_cfg, ptp_caps)
+
+static void ax_reset_ptp_queue(struct ax_device *axdev)
+{
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+
+	if (!ptp_cfg)
+		return;
+
+	ptp_cfg->ptp_head = 0;
+	ptp_cfg->ptp_tail = 0;
+	ptp_cfg->num_items = 0;
+	ptp_cfg->get_timestamp_retry = 0;
+
+	memset(ptp_cfg->tx_ptp_info, 0, AX_PTP_INFO_SIZE * AX_PTP_QUEUE_SIZE);
+}
+
+static int ax88179a_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u32 remainder = 0;
+	u64 high_timer = 0;
+	s64 sec = 0, rnsec = 0;
+	s64 nsec = 0;
+	u8 timestamp[10] = {0};
+	int ret;
+
+	ret = ax_read_cmd(axdev, AX_PTP_OP, AX_GET_LOCAL_CLOCK, 0,
+			  AX_GET_LOCAL_CLOCK_SIZE, &timestamp, 0);
+	if (ret < 0)
+		return ret;
+	memcpy(&nsec, timestamp, 4);
+	memcpy(&sec, &timestamp[4], 6);
+	sec *= NSEC_PER_SEC;
+	rnsec = (nsec + sec + delta);
+
+	high_timer = div_u64_rem(rnsec, NSEC_PER_SEC, &remainder);
+	memcpy(timestamp, &remainder, 4);
+	memcpy(&timestamp[4], &high_timer, 6);
+
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_LOCAL_CLOCK, 0,
+			    AX_SET_LOCAL_CLOCK_SIZE, &timestamp);
+	if (ret < 0)
+		return ret;
+
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+static int
+ax88179a_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
+#else
+static int
+ax88179a_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+	long ppb = scaled_ppm_to_ppb(scaled_ppm);
+#endif
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u32 new_addend_val;
+	u64 adjust_val;
+	int neg_adj = 0, ret;
+
+	if (ppb < 0) {
+		neg_adj = 1;
+		ppb = -ppb;
+	}
+
+	adjust_val = AX_BASE_ADDEND;
+	adjust_val *= ppb;
+	adjust_val = div_u64(adjust_val, NSEC_PER_SEC);
+
+	if (neg_adj)
+		new_addend_val = (u32)(AX_BASE_ADDEND - adjust_val);
+	else
+		new_addend_val = (u32)(AX_BASE_ADDEND + adjust_val);
+
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_ADDEND, 0,
+			   AX_SET_ADDEND_SIZE, &new_addend_val);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ax88179a_ptp_gettime64
+(struct ptp_clock_info *ptp, struct timespec64 *ts)
+{
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u64 sec = 0;
+	u32 nsec = 0;
+	u8 timestamp[10] = {0};
+	int ret;
+
+	ret = ax_read_cmd(axdev, AX_PTP_OP, AX_GET_LOCAL_CLOCK, 0,
+			  AX_GET_LOCAL_CLOCK_SIZE, &timestamp, 0);
+	if (ret < 0)
+		return ret;
+
+	memcpy(&nsec, timestamp, 4);
+	memcpy(&sec, &timestamp[4], 6);
+	ts->tv_nsec = nsec;
+	ts->tv_sec = sec;
+
+	return 0;
+}
+
+static int ax88179a_ptp_settime64
+(struct ptp_clock_info *ptp, const struct timespec64 *ts)
+{
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u64 sec;
+	u32 nsec;
+	u8 timestamp[10] = {0};
+	int ret;
+
+	nsec = (u32)ts->tv_nsec;
+	memcpy(timestamp, &nsec, 4);
+	sec = (u64)ts->tv_sec;
+	memcpy(&timestamp[4], &sec, 6);
+
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_LOCAL_CLOCK, 0,
+			    AX_SET_LOCAL_CLOCK_SIZE, &timestamp);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ax_ptp_enable(struct ptp_clock_info *ptp,
+			 struct ptp_clock_request *rq, int on)
+{
+	return -EOPNOTSUPP;
+}
+
+static struct ptp_clock_info ax88179a_772d_ptp_clock = {
+	.owner		= THIS_MODULE,
+	.name		= "asix ptp",
+	.max_adj	= 100000000,
+	.n_ext_ts	= 0,
+	.pps		= 0,
+#if KERNEL_VERSION(4, 10, 0) <= LINUX_VERSION_CODE
+	.adjfine	= NULL,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+	.adjfine	= ax88179a_ptp_adjfine,
+#else
+	.adjfreq	= ax88179a_ptp_adjfreq,
+#endif
+	.adjtime	= ax88179a_ptp_adjtime,
+	.gettime64	= ax88179a_ptp_gettime64,
+	.settime64	= ax88179a_ptp_settime64,
+	.n_per_out	= 0,
+	.enable		= ax_ptp_enable,
+	.n_pins		= 0,
+	.verify		= NULL,
+	.pin_config	= NULL,
+};
+
+int ax88179a_ptp_init(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u32 new_addend_val = AX_BASE_ADDEND;
+	u8 reg8;
+	u8 ptpset;
+	u8 ptp_tx_delay[5] = { 0 };
+	u8 ptp_rx_delay[5] = { 0 };
+	u32 reg32;
+	u32 timeout = 0;
+	int ret;
+#ifdef ENABLE_PTP_FUNC
+	axdev->driver_info->ptp_pps_ctrl(axdev, 1);
+#endif
+	if (axdev->sub_version < 3)
+		return 0;
+
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_ADDEND, 0,
+			   AX_SET_ADDEND_SIZE, &new_addend_val);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_PTP_PERIOD;
+	ret = ax_write_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_TIMER_PERIOD,
+			    0, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_read_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_CTRL_2,
+			   0, 1, &reg8, 0);
+	if (ret < 0)
+		return ret;
+	reg8 |= AX_PTP_CTRL_SET_PERIOD;
+	ret = ax_write_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_CTRL_2, 0, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_read_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_CTRL_1,
+			   0, 1, &ptpset, 0);
+	if (ret < 0)
+		return ret;
+	ptpset |= AX_PTP_CTRL_L3_EN | AX_PTP_CTRL_EN | AX_PTP_TX_PLUS_DELAY |
+		  AX_PTP_TX_FILTER_GENERAL_MSG | AX_PTP_RX_FILTER_GENERAL_MSG;
+	ret = ax_write_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_CTRL_1,
+			    0, 1, &ptpset);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_179A_PTP_INFO_SEG_SIZE * AX_PTP_HW_QUEUE_SIZE;
+	ret = ax_write_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_MEM_SEG_SIZE,
+			   0, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	do {
+		reg8 = 0;
+		ret = ax_write_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_MEM_SEG_SET,
+				   0, 1, &reg8);
+		if (ret < 0)
+			return ret;
+
+		ret = ax_read_cmd(axdev, AX_PTP_CMD,
+				  AX88179A_PTP_MEM_SEG_STATUS, 0, 1, &reg8, 0);
+		if (ret < 0)
+			return ret;
+		reg8 &= AX_PTP_MEM_SEG_MASK;
+
+		if (timeout++ > 5)
+			break;
+	} while (reg8 != AX_PTP_MEM_SEG_0);
+
+	reg32 = AX_PPS_ACTIVE_DEFAULT_TIME;
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_ACTIVE_TIME, 0,
+			   AX_SET_ACTIVE_TIME_SIZE, &reg32);
+	if (ret < 0)
+		return ret;
+
+	switch (link_info->eth_speed) {
+	case ETHER_LINK_100:
+		ptp_tx_delay[0] = 0x64;
+		ptp_tx_delay[4] = ptpset;
+		ptp_rx_delay[0] = 0x22;
+		ptp_rx_delay[1] = 0x01;
+		ptp_rx_delay[4] = ptpset;
+		break;
+	case ETHER_LINK_10:
+		ptp_tx_delay[0] = 0xB7;
+		ptp_tx_delay[1] = 0x0F;
+		ptp_tx_delay[4] = ptpset;
+		ptp_rx_delay[0] = 0xAC;
+		ptp_rx_delay[1] = 0x0A;
+		ptp_rx_delay[4] = ptpset;
+		break;
+	case ETHER_LINK_1000:
+	default:
+		ptp_tx_delay[0] = 0x6E;
+		ptp_tx_delay[4] = ptpset;
+		ptp_rx_delay[0] = 0xE4;
+		ptp_rx_delay[4] = ptpset;
+		break;
+	}
+
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_TX_PHY_DELAY, 0,
+			   AX_SET_TX_PHY_DELAY_SIZE, ptp_tx_delay);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_write_cmd(axdev, AX_PTP_OP, AX_SET_RX_PHY_DELAY, 0,
+			   AX_SET_RX_PHY_DELAY_SIZE, ptp_rx_delay);
+	if (ret < 0)
+		return ret;
+
+	axdev->netdev->features &= ~(NETIF_F_SG | NETIF_F_TSO);
+	axdev->netdev->hw_features &= ~(NETIF_F_SG | NETIF_F_TSO);
+	axdev->netdev->vlan_features &= ~(NETIF_F_SG | NETIF_F_TSO);
+
+	return 0;
+}
+
+int ax88179a_ptp_pps_ctrl(struct ax_device *axdev, u8 enable)
+{
+	u32 reg32 = 0;
+	int ret;
+	
+	ret = ax_read_cmd(axdev, AX88179A_PBUS_REG, 0x1894, 0x000F, 4, &reg32, 1);
+	if (ret < 0)
+		return ret;
+
+	reg32 &= ~0x01000000;
+
+	if (enable) 
+		reg32 |= 0x01000000;
+
+	ret = ax_write_cmd(axdev, AX88179A_PBUS_REG, 0x1894, 0x000F, 4, &reg32);
+	if (ret < 0)
+		return ret;
+	
+	return 0;
+}
+
+int ax88279_ptp_pps_ctrl(struct ax_device *axdev, u8 enable)
+{
+	u32 reg32 = 0;
+	int ret;
+
+	ret = ax_read_cmd(axdev, AX_PBUS_A32, 0xF8C8, 0x000C, 4, &reg32, 1);
+	if (ret < 0)
+		return ret;
+
+	reg32 &= ~0x00004000;
+	
+	if (enable) 
+		reg32 |= 0x00004000;
+
+	ret = ax_write_cmd(axdev, AX_PBUS_A32, 0xF8C8, 0x000C, 4, &reg32);
+
+	return 0;
+}
+
+void ax88179a_ptp_remove(struct ax_device *axdev)
+{
+	u8 reg8;
+#ifdef ENABLE_PTP_FUNC
+	axdev->driver_info->ptp_pps_ctrl(axdev, 0);
+#endif
+	if (axdev->sub_version < 3)
+		return;
+
+	ax_read_cmd(axdev, AX_PTP_CMD,  AX88179A_PTP_CTRL_1, 0, 1, &reg8, 0);
+	reg8 &= ~(AX_PTP_CTRL_L3_EN | AX_PTP_CTRL_EN);
+	ax_write_cmd(axdev, AX_PTP_CMD, AX88179A_PTP_CTRL_1, 0, 1, &reg8);
+}
+
+void ax_ptp_unregister(struct ax_device *axdev)
+{
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+
+	if (axdev->driver_info->ptp_remove)
+		axdev->driver_info->ptp_remove(axdev);
+
+	if (ptp_cfg) {
+		if (ptp_cfg->ptp_clock)
+			ptp_clock_unregister(ptp_cfg->ptp_clock);
+	}
+}
+
+static u8 ax_find_ptp_item(struct ax_device *axdev, struct _ptp_header *ptp,
+			   struct sk_buff *skb)
+{
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+	struct _ax_ptp_info *temp_ptp_info = ptp_cfg->tx_ptp_info;
+	u16 sequence_id;
+	u8 message_type = ptp->message_type;
+	int i, read_ptr;
+
+	read_ptr = ptp_cfg->ptp_head;
+#ifdef ENABLE_PTP_DEBUG
+	printk("%s - ptp_head: %d", __func__, read_ptr);
+#endif
+
+	if (axdev->chip_version == AX_VERSION_AX88179A_772D)
+		sequence_id = ntohs(ptp->sequence_id) & 0xFF;
+	else
+		sequence_id = ntohs(ptp->sequence_id) & 0xFFFF;
+
+	for (i = 0; i < ptp_cfg->num_items; i++) {
+		if ((temp_ptp_info[read_ptr].sequence_id == sequence_id) &&
+		    (temp_ptp_info[read_ptr].msg_type == message_type)) {
+			struct skb_shared_hwtstamps shhwtstamps;
+			u64 timestamp_h, timestamp_l, temp;
+			u64 time64;
+
+			ptp_cfg->num_items--;
+			ptp_cfg->ptp_head++;
+			if (ptp_cfg->ptp_head == AX_PTP_QUEUE_SIZE)
+				ptp_cfg->ptp_head = 0;
+			timestamp_l = temp_ptp_info[read_ptr].nsec;
+			timestamp_h = temp_ptp_info[read_ptr].sec_l;
+			temp = temp_ptp_info[read_ptr].sec_h;
+			timestamp_h |= (temp << 32);
+			time64 = timestamp_h * NSEC_PER_SEC;
+			time64 += timestamp_l & 0xFFFFFFFF;
+			memset(&shhwtstamps, 0, sizeof(shhwtstamps));
+			shhwtstamps.hwtstamp = ns_to_ktime(time64);
+			if (ptp->flags & 0x2 ||
+			    (ptp->message_type != 0 && ptp->message_type != 3))
+				skb_tstamp_tx(skb, &shhwtstamps);
+#ifdef ENABLE_PTP_DEBUG
+			printk("%s - skb_tstamp_tx return", __func__);
+#endif
+			dev_kfree_skb_any(skb);
+			return 0;
+		}
+		read_ptr++;
+		if (read_ptr == AX_PTP_QUEUE_SIZE)
+			read_ptr = 0;
+	}
+	return AX_PTP_QUEUE_SIZE;
+}
+
+static void ax_tx_check_timestamp(struct ax_device *axdev, struct sk_buff *skb)
+{
+	if (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {
+		struct _ptp_header ptp;
+		unsigned int ptp_msg_offset;
+		u16 tmp, tx_ethertype, vlan_id = 0;
+		u8 vlan_size = 0, ptp_item = AX_PTP_QUEUE_SIZE;
+
+		skb_copy_from_linear_data_offset(skb, AX_ETHTYPE_OFFSET,
+						 &tmp, 2);
+		tx_ethertype = ntohs(tmp);
+		if (tx_ethertype == ETH_P_8021Q) {
+			skb_copy_from_linear_data_offset(skb,
+							 AX_ETHTYPE_OFFSET + 2,
+							 &tmp, 2);
+			vlan_id = ntohs(tmp) & 0xFFF;
+			vlan_size = 4;
+			skb_copy_from_linear_data_offset(skb,
+							 AX_ETHTYPE_OFFSET + 4,
+							 &tmp, 2);
+			tx_ethertype = ntohs(tmp);
+			if (tx_ethertype == ETH_P_8021Q) {
+				vlan_size = 8;
+				skb_copy_from_linear_data_offset(skb,
+							 AX_ETHTYPE_OFFSET + 4,
+							 &tmp, 2);
+				tx_ethertype = ntohs(tmp);
+			}
+		}
+		ptp_msg_offset = vlan_size;
+		if (tx_ethertype == ETH_P_1588)
+			ptp_msg_offset += AX_TX_PTPHDR_OFFSET_L2;
+		else if (tx_ethertype == ETH_P_IP)
+			ptp_msg_offset += AX_TX_PTPHDR_OFFSET_L3_IP;
+		else if (tx_ethertype == ETH_P_IPV6)
+			ptp_msg_offset += AX_TX_PTPHDR_OFFSET_L3_IPV6;
+		else
+			return;
+
+		skb_copy_from_linear_data_offset(skb, ptp_msg_offset,
+						 &ptp, PTP_HDR_SIZE);
+
+		ptp_item = ax_find_ptp_item(axdev, &ptp, skb);
+		if (ptp_item == AX_PTP_QUEUE_SIZE) {
+			dev_err(&axdev->intf->dev,
+				"Not found item from PTP queue");
+			return;
+		}
+	}
+}
+
+static void ax_tx_timestamp(struct ax_device *axdev)
+{
+	struct sk_buff_head *tx_timestamp = &axdev->tx_timestamp;
+
+	while (!skb_queue_empty(tx_timestamp)) {
+		struct sk_buff *skb;
+
+		skb = __skb_dequeue(tx_timestamp);
+		if (!skb)
+			return;
+
+		ax_tx_check_timestamp(axdev, skb);
+	}
+}
+
+static struct _ax_ptp_info *ax_ptp_info_transform(struct ax_device *axdev,
+						  void *data)
+{
+	struct _ax_ptp_info temp[AX_PTP_HW_QUEUE_SIZE] = {0};
+	int i;
+
+	switch (axdev->chip_version) {
+	case AX_VERSION_AX88179A_772D:
+	{
+		struct _179a_ptp_info *_179a_ptp = (typeof(_179a_ptp))data;
+
+		for (i = 0; i < AX_PTP_HW_QUEUE_SIZE; i++) {
+			memcpy(&temp[i], &_179a_ptp[i], 2);
+			temp[i].sequence_id &= 0xFF;
+			memcpy(&temp[i].nsec, &_179a_ptp[i].nsec, 10);
+		}
+		memcpy(data, temp, AX_PTP_INFO_SIZE);
+		break;
+	}
+	};
+
+	return (struct _ax_ptp_info *)data;
+}
+
+
+#if KERNEL_VERSION(2, 6, 20) > LINUX_VERSION_CODE
+static void ax_ptp_ts_callback(struct urb *urb, struct pt_regs *regs)
+#else
+static void ax_ptp_ts_callback(struct urb *urb)
+#endif
+{
+	struct _ax_ptp_usb_info *ptp_info = (typeof(ptp_info))urb->context;
+	struct ax_device *axdev = (struct ax_device *)ptp_info->axdev;
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+	struct _ax_ptp_info *temp_ptp_info = ptp_info->ax_ptp_info;
+	int i, count = 0;
+#ifdef ENABLE_PTP_DEBUG
+	printk("%s - Start urb->actual_length: %d",
+		__func__, urb->actual_length);
+#endif
+	if (urb->status < 0) {
+		printk(KERN_ERR "failed get ts (%d)", urb->status);
+		goto free;
+	}
+
+	temp_ptp_info = ax_ptp_info_transform(axdev, ptp_info->ax_ptp_info);
+	if (temp_ptp_info == NULL) {
+		printk(KERN_ERR "Failed to transform ptp info.");
+		goto free;
+	}
+
+	for (i = 0; i < AX_PTP_HW_QUEUE_SIZE; i++) {
+		if (temp_ptp_info[i].status) {
+			ptp_cfg->tx_ptp_info[ptp_cfg->ptp_tail++] = temp_ptp_info[i];
+			if (ptp_cfg->ptp_tail == AX_PTP_QUEUE_SIZE)
+				ptp_cfg->ptp_tail = 0;
+			ptp_cfg->num_items++;
+#ifdef ENABLE_PTP_DEBUG
+printk("### ptp_tail: %ld, ptp_head: %ld, num_items: %ld",
+	ptp_cfg->ptp_tail, ptp_cfg->ptp_head, ptp_cfg->num_items);
+printk("### (%s) - DATA %d -------------###", __func__, i);
+printk("### status: %d", temp_ptp_info[i].status);
+printk("### type: 0x%02x", temp_ptp_info[i].msg_type);
+printk("### s_id: 0x%04x", temp_ptp_info[i].sequence_id);
+printk("### nsec: 0x%08x", temp_ptp_info[i].nsec);
+printk("###  sec: 0x%04x%08x", temp_ptp_info[i].sec_h, temp_ptp_info[i].sec_l);
+printk("### ----------------------------###\n");
+#endif
+			count++;
+			ptp_cfg->get_timestamp_retry = 0;
+		}
+	}
+	if (count == 0 &&
+	    ptp_cfg->get_timestamp_retry < EP0_GET_TIMESTAMP_RETRY) {
+		ax_ptp_ts_read_cmd_async(axdev);
+		ptp_cfg->get_timestamp_retry++;
+		goto free;
+	}
+
+	if (ptp_cfg->get_timestamp_retry == EP0_GET_TIMESTAMP_RETRY)
+		dev_err(&axdev->intf->dev, "Get timestamp failed.");
+
+	ax_tx_timestamp(axdev);
+free:
+	kfree(temp_ptp_info);
+	usb_free_urb(urb);
+}
+
+int ax_ptp_ts_read_cmd_async(struct ax_device *axdev)
+{
+	struct usb_ctrlrequest *req;
+	int status = 0;
+	struct urb *urb;
+	struct _ax_ptp_usb_info *info;
+	u16 size = AX_PTP_INFO_SIZE * AX_PTP_HW_QUEUE_SIZE;
+
+	if (axdev->chip_version > AX_VERSION_AX88179A_772D)
+		return 0;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (urb == NULL) {
+		dev_err(&axdev->intf->dev,
+			   "Error allocating URB in write_cmd_async!");
+		return -ENOMEM;
+	}
+
+	info = kzalloc(sizeof(struct _ax_ptp_usb_info), GFP_ATOMIC);
+	if (!info) {
+		usb_free_urb(urb);
+		return -ENOMEM;
+	}
+
+	info->axdev = axdev;
+	req = &info->req;
+
+	req->bRequestType = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+	req->bRequest = AX_PTP_TIMESTAMP;
+	req->wValue = cpu_to_le16(0);
+	req->wIndex = cpu_to_le16(0);
+	req->wLength = cpu_to_le16(size);
+
+	memset(info->ax_ptp_info, 0, AX_PTP_INFO_SIZE * AX_PTP_QUEUE_SIZE);
+
+	usb_fill_control_urb(urb, axdev->udev,
+			     usb_sndctrlpipe(axdev->udev, 0),
+			     (void *)req, info->ax_ptp_info, size,
+			     ax_ptp_ts_callback, info);
+
+	status = usb_submit_urb(urb, GFP_ATOMIC);
+	if (status < 0) {
+		dev_err(&axdev->intf->dev,
+			   "Error submitting the control message: status=%d",
+			   status);
+		kfree(info);
+		usb_free_urb(urb);
+	}
+
+	return 0;
+}
+
+void ax_rx_get_timestamp(struct sk_buff *skb, u64 *pkt_hdr)
+{
+	struct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);
+	u64 timestamp_h, timestamp_l;
+	u64 time64;
+
+	timestamp_l = *((u64 *)(++pkt_hdr));
+	timestamp_h = *((u64 *)(++pkt_hdr));
+#ifdef ENABLE_PTP_DEBUG
+	printk("### (%s) h: 0x%llx, l: 0x%llx %lld###", __func__,
+		timestamp_h, timestamp_l, timestamp_l);
+#endif
+	timestamp_h <<= 32;
+	timestamp_h |= (timestamp_l >> 32) & 0xFFFFFFFF;
+	time64 = (timestamp_h * NSEC_PER_SEC);
+	time64 += (timestamp_l & 0xFFFFFFFF);
+#ifdef ENABLE_PTP_DEBUG
+	printk("### (%s) h: %lld, time64: %lld ###", __func__,
+		timestamp_h, time64);
+#endif
+	memset(shhwtstamps, 0, sizeof(struct skb_shared_hwtstamps));
+	shhwtstamps->hwtstamp = ns_to_ktime(time64);
+}
+
+#ifdef ENABLE_AX88279
+static int ax_ptp_pbus_write(struct ax_device *axdev, u16 offset, u16 len,
+			     void *data)
+{
+	int ret = 0;
+
+	ret = ax_write_cmd(axdev,
+			    AX_PBUS_A32,
+			    offset,
+			    AX_PTP_REG_BASE_ADDR_HI,
+			    len,
+			    data);
+
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int ax_ptp_clk_write(struct ax_device *axdev, u16 offset, u16 len,
+			    void *data)
+{
+	int ret = 0;
+
+	ret = ax_write_cmd(axdev,
+			    AX_PBUS_A32,
+			    offset,
+			    AX_PTP_REG_BASE_ADDR_HI,
+			    len,
+			    data);
+
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int ax_ptp_clk_read(struct ax_device *axdev, u16 offset, u16 len,
+			   void *data)
+{
+	int ret = 0;
+
+	ret = ax_read_cmd(axdev,
+			   AX_PTP_CLK,
+			   0x0002,
+			   offset,
+			   len,
+			   data,
+			   0);
+
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+static int ax88279_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
+#else
+static int ax88279_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+	long ppb = scaled_ppm_to_ppb(scaled_ppm);
+#endif
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u32 new_addend_val;
+	u64 adjust_val;
+	int neg_adj = 0, ret;
+
+	if (ppb < 0) {
+		neg_adj = 1;
+		ppb = -ppb;
+	}
+
+	adjust_val = AX_BASE_ADDEND;
+	adjust_val *= ppb;
+	adjust_val = div_u64(adjust_val, NSEC_PER_SEC);
+
+	if (neg_adj)
+		new_addend_val = (u32)(AX_BASE_ADDEND - adjust_val);
+	else
+		new_addend_val = (u32)(AX_BASE_ADDEND + adjust_val);
+
+	ret = ax_ptp_pbus_write(axdev,
+			   AX_PTP_TIMER_ADDEND,
+			   sizeof(new_addend_val),
+			   &new_addend_val);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ax88279_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u32 remainder = 0;
+	u64 high_timer = 0;
+	s64 sec = 0;
+	s64 nsec = 0;
+	u8 timestamp[12] = {0};
+	int ret;
+
+	ret = ax_ptp_clk_read(axdev, AX_PTP_GET_80B_LCK_VAL0, 10, timestamp);
+	if (ret < 0)
+		return ret;
+
+	memcpy(&nsec, timestamp, 4);
+	memcpy(&sec, &timestamp[4], 6);
+	sec *= NSEC_PER_SEC;
+	nsec = (sec + delta);
+
+	high_timer = div_u64_rem(nsec, NSEC_PER_SEC, &remainder);
+	memcpy(timestamp, &remainder, 4);
+	memcpy(&timestamp[4], &high_timer, 6);
+
+	ret = ax_ptp_clk_write(axdev, AX_PTP_SET_80B_LCK_VAL0, 12, timestamp);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ax88279_ptp_gettime64(struct ptp_clock_info *ptp,
+				struct timespec64 *ts)
+{
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u64 sec = 0;
+	u32 nsec = 0;
+	u8 timestamp[12] = {0};
+	int ret;
+
+	ret = ax_ptp_clk_read(axdev, AX_PTP_GET_80B_LCK_VAL0, 10, timestamp);
+	if (ret < 0)
+		return ret;
+
+	memcpy(&nsec, timestamp, 4);
+	memcpy(&sec, &timestamp[4], 6);
+	ts->tv_nsec = nsec;
+	ts->tv_sec = sec;
+
+	return 0;
+}
+
+static int ax88279_ptp_settime64(struct ptp_clock_info *ptp,
+				const struct timespec64 *ts)
+{
+	struct ax_ptp_cfg *ptp_cfg = ptp_to_dev(ptp);
+	struct ax_device *axdev = (struct ax_device *)ptp_cfg->axdev;
+	u64 sec;
+	u32 nsec;
+	u8 timestamp[10] = {0};
+	int ret;
+
+	nsec = (u32)ts->tv_nsec;
+	memcpy(timestamp, &nsec, 4);
+	sec = (u64)ts->tv_sec;
+	memcpy(&timestamp[4], &sec, 6);
+
+	ret = ax_ptp_clk_write(axdev, AX_PTP_SET_80B_LCK_VAL0, 10, timestamp);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct ptp_clock_info ax88279_ptp_clock = {
+	.owner		= THIS_MODULE,
+	.name		= "asix ptp",
+	.max_adj	= 100000000,
+	.n_ext_ts	= 0,
+	.pps		= 0,
+#if KERNEL_VERSION(4, 10, 0) <= LINUX_VERSION_CODE
+	.adjfine	= NULL,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,2,0)
+	.adjfine	= ax88279_ptp_adjfine,
+#else
+	.adjfreq	= ax88279_ptp_adjfreq,
+#endif
+	.adjtime	= ax88279_ptp_adjtime,
+	.gettime64	= ax88279_ptp_gettime64,
+	.settime64	= ax88279_ptp_settime64,
+	.n_per_out	= 0,
+	.enable		= ax_ptp_enable,
+	.n_pins		= 0,
+	.verify		= NULL,
+	.pin_config	= NULL,
+};
+
+int ax88279_ptp_init(struct ax_device *axdev)
+{
+	struct ax_link_info *link_info = &axdev->link_info;
+	u32 reg32;
+	u8 reg8;
+	int ret;
+
+	ax_reset_ptp_queue(axdev);
+
+#ifdef ENABLE_PTP_FUNC
+	axdev->driver_info->ptp_pps_ctrl(axdev, 1);
+#endif
+
+	reg32 = (AX_PTP_MEM_SEG_SIZE_279_5 << 24) |
+		(AX_PTP_MEM_START_ADDR << 8) | AX_PTP_PTP_CPU_EN;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_TX_MEM_SETTING, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg32 = AX_PPS_ACTIVE_DEFAULT_TIME;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_PPS_ACTIVE_TIME, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg32 = AX_PTP_LCK_CTRL0_EN | AX_PTP_LCK_CTRL0_80B_NS_EN |
+		AX_PTP_LCK_CTRL0_80B_S_EN | AX_PTP_LCK_CTRL0_48B_EN |
+		AX_PTP_LCK_CTRL0_PPS_EN | AX_PTP_LCK_CTRL0_TX_DEL_VEC;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_LCK_CTRL0, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg32 = AX_BASE_ADDEND;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_TIMER_ADDEND, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg32 = AX_PTP_PERIOD;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_TIMER_PERIOD, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	ret = ax_read_cmd(axdev, AX_ACCESS_MAC, AX_MAC_BFM_CTRL, 1, 1, &reg8, 0);
+	if (ret < 0)
+		return ret;
+	reg8 |= AX_CS_TRAIL_UDPV4_EN | AX_CS_TRAIL_UDPV6_EN;
+	ret = ax_write_cmd(axdev, AX_ACCESS_MAC, AX_MAC_BFM_CTRL, 1, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	switch (link_info->eth_speed) {
+	case ETHER_LINK_100:
+		reg32 = (AX_IPG_COUNTER_100M) |
+			(AX_SOF_DELAY_COUNTER_100M << 8) |
+			(AX_VAILD_DELAY_COUNTER_100M << 16);
+		ret = ax_write_cmd(axdev, AX_PBUS_A32, AX_TX_READY_CTRL,
+				   AX_PBUS_REG_BASE_ADDR_HI, 4, &reg32);
+		if (ret < 0)
+			return ret;
+
+		reg32 = AX_PTP_RX_CTRL0_DEFAULT;
+		ret = ax_ptp_pbus_write(axdev, AX_PTP_RX_CTRL0, 4, &reg32);
+		if (ret < 0)
+			return ret;
+
+		reg32 = AX_PTP_TX_CTRL0_DEFAULT |
+			(0x10 << AX_TXC0_VAL_DELAY_CNT_SHIFT);
+		ret = ax_ptp_pbus_write(axdev, AX_PTP_TX_CTRL0, 4, &reg32);
+		if (ret < 0)
+			return ret;
+		break;
+	case ETHER_LINK_1000:
+		reg32 = (AX_IPG_COUNTER_1G) |
+			(AX_SOF_DELAY_COUNTER_1G << 8) |
+			(AX_VAILD_DELAY_COUNTER_1G << 16);
+		ret = ax_write_cmd(axdev, AX_PBUS_A32, AX_TX_READY_CTRL,
+				   AX_PBUS_REG_BASE_ADDR_HI, 4, &reg32);
+		if (ret < 0)
+			return ret;
+
+		reg32 = AX_PTP_RX_CTRL0_DEFAULT;
+		ret = ax_ptp_pbus_write(axdev, AX_PTP_RX_CTRL0, 4, &reg32);
+		if (ret < 0)
+			return ret;
+
+		reg32 = AX_PTP_TX_CTRL0_DEFAULT |
+			(0x8 << AX_TXC0_VAL_DELAY_CNT_SHIFT);
+		ret = ax_ptp_pbus_write(axdev, AX_PTP_TX_CTRL0, 4, &reg32);
+		if (ret < 0)
+			return ret;
+		break;
+	case ETHER_LINK_2500:
+		reg32 = AX_PTP_RX_CTRL0_DEFAULT | AX_PTP_RXC0_XGMII_EN;
+		ret = ax_ptp_pbus_write(axdev, AX_PTP_RX_CTRL0, 4, &reg32);
+		if (ret < 0)
+			return ret;
+
+		reg32 = AX_PTP_TX_CTRL0_DEFAULT | AX_PTP_TXC0_XGMII_EN |
+			(0x8 << AX_TXC0_VAL_DELAY_CNT_SHIFT);
+		ret = ax_ptp_pbus_write(axdev, AX_PTP_TX_CTRL0, 4, &reg32);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		break;
+	}
+
+	reg32 = 0;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_TX_DELAY, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg32 = 0;
+	ret = ax_ptp_pbus_write(axdev, AX_PTP_RX_DELAY, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg8 = AX_EXT_INT_ON | AX_PTP_TX_TX_INT_EN;
+	ret = ax_write_cmd(axdev, AX_PTP_TOD_CTRL,
+			   (AX_PTP_TS_INT | AX_EXT_INT), 0, 1, &reg8);
+	if (ret < 0)
+		return ret;
+
+	reg32 = 0;
+	ret = ax_write_cmd(axdev, AX_PBUS_A32, AX_MAC_CLK_CTRL,
+			   AX_PBUS_REG_BASE_ADDR_HI, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	reg32 = (0 << AX_DIVIDE_PTP_CLK_SHIFT) |
+		(1 << AX_DIVIDE_AES_CLK_SHIFT) |
+		AX_PTP_CLK_EN | AX_AES_CLK_EN |
+		AX_PTP_CLK_SELECT_DIVIDE | AX_AES_CLK_SELECT_DIVIDE |
+		AX_XGMAC_TX_CLK_EN | AX_XGMAC_RX_CLK_EN;
+	ret = ax_write_cmd(axdev, AX_PBUS_A32, AX_MAC_CLK_CTRL,
+			   AX_PBUS_REG_BASE_ADDR_HI, 4, &reg32);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+void ax88279_ptp_remove(struct ax_device *axdev)
+{
+	u32 reg32 = 0;
+#ifdef ENABLE_PTP_FUNC
+	axdev->driver_info->ptp_pps_ctrl(axdev, 0);
+#endif
+	ax_ptp_pbus_write(axdev, AX_PTP_LCK_CTRL0, 4, &reg32);
+	ax_ptp_pbus_write(axdev, AX_PTP_RX_CTRL0, 4, &reg32);
+	ax_ptp_pbus_write(axdev, AX_PTP_TX_CTRL0, 4, &reg32);
+}
+
+static int ax88279_submit_ts(struct ax_device *axdev);
+static void ax88279_read_ts_callback(struct urb *urb)
+{
+	struct net_device *netdev;
+	struct ax_device *axdev;
+	struct ax_ptp_cfg *ptp_cfg;
+	struct _ax_ptp_info *temp_ptp_info;
+	int i, index;
+
+	axdev = urb->context;
+	if (!axdev)
+		return;
+
+	if (test_bit(AX_UNPLUG, &axdev->flags) ||
+	    !test_bit(AX_ENABLE, &axdev->flags))
+		return;
+
+	netdev = axdev->netdev;
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	usb_mark_last_busy(axdev->udev);
+
+	ptp_cfg = axdev->ptp_cfg;
+
+	if (urb->status < 0) {
+		dev_err(&axdev->intf->dev,
+			"failed get ts (%d)", urb->status);
+		goto out;
+	}
+#ifdef ENABLE_PTP_DEBUG
+	printk("EP4 Valid: 0x%x", ptp_cfg->ep4_buf[AX_PTP_EP4_SIZE - 1]);
+#endif
+	index = (ptp_cfg->ep4_buf[AX_PTP_EP4_SIZE - 1] & AX_TS_SEG_1) ?
+		0 : (AX_PTP_INFO_SIZE * AX_PTP_HW_QUEUE_SIZE);
+#ifdef ENABLE_PTP_DEBUG
+	printk("index: %d", index);
+#endif
+	temp_ptp_info = (struct _ax_ptp_info *)&ptp_cfg->ep4_buf[index];
+	for (i = 0; i < AX_PTP_HW_QUEUE_SIZE; i++) {
+		if (temp_ptp_info[i].status) {
+			ptp_cfg->tx_ptp_info[ptp_cfg->ptp_tail++] =
+							temp_ptp_info[i];
+			if (ptp_cfg->ptp_tail == AX_PTP_QUEUE_SIZE)
+				ptp_cfg->ptp_tail = 0;
+			ptp_cfg->num_items++;
+#ifdef ENABLE_PTP_DEBUG
+printk("### ptp_tail: %ld, ptp_head: %ld, num_items: %ld",
+	ptp_cfg->ptp_tail, ptp_cfg->ptp_head, ptp_cfg->num_items);
+printk("### (%s) - DATA %d -------------###", __func__, i);
+printk("### status: %d", temp_ptp_info[i].status);
+printk("### type: 0x%02x", temp_ptp_info[i].msg_type);
+printk("### s_id: 0x%04x", temp_ptp_info[i].sequence_id);
+printk("### nsec: 0x%08x", temp_ptp_info[i].nsec);
+printk("###  sec: 0x%04x%08x", temp_ptp_info[i].sec_h, temp_ptp_info[i].sec_l);
+printk("### ----------------------------###\n");
+#endif
+		}
+	}
+
+	ax_tx_timestamp(axdev);
+out:
+	ax88279_submit_ts(axdev);
+}
+
+static int ax88279_submit_ts(struct ax_device *axdev)
+{
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+	struct urb *urb = ptp_cfg->urb;
+	int ret;
+
+	if (test_bit(AX_UNPLUG, &axdev->flags) ||
+	    !test_bit(AX_ENABLE, &axdev->flags))
+		return 0;
+
+	memset(ptp_cfg->ep4_buf, 0, AX_PTP_EP4_SIZE);
+
+	usb_fill_bulk_urb(urb, axdev->udev,
+			   usb_rcvbulkpipe(axdev->udev, 4),
+			   (void *)ptp_cfg->ep4_buf, AX_PTP_EP4_SIZE,
+			   (usb_complete_t)ax88279_read_ts_callback, axdev);
+
+	ret = usb_submit_urb(urb, GFP_KERNEL);
+	if (ret == -ENODEV)
+		netif_device_detach(axdev->netdev);
+
+	urb->actual_length = 0;
+
+	return ret;
+}
+
+int ax88279_start_get_ts(struct ax_device *axdev)
+{
+	int ret;
+
+	if (axdev->chip_version <= AX_VERSION_AX88179A_772D)
+		return 0;
+
+	ret = ax88279_submit_ts(axdev);
+	if (ret < 0)
+		dev_err(&axdev->intf->dev, "Failed to submit EP4 for TS\n");
+
+	return ret;
+}
+
+void ax88279_stop_get_ts(struct ax_device *axdev)
+{
+	struct ax_ptp_cfg *ptp_cfg = axdev->ptp_cfg;
+
+	if (axdev->chip_version <= AX_VERSION_AX88179A_772D)
+		return;
+
+	if (ptp_cfg->urb)
+		usb_kill_urb(ptp_cfg->urb);
+}
+#endif
+
+int ax_ptp_register(struct ax_device *axdev)
+{
+	struct ax_ptp_cfg *ptp_cfg;
+	int ret;
+
+	ptp_cfg = kzalloc(sizeof(struct ax_ptp_cfg), GFP_KERNEL);
+	if (!ptp_cfg)
+		return -ENOMEM;
+	axdev->ptp_cfg = ptp_cfg;
+
+	switch (axdev->chip_version) {
+#ifdef ENABLE_AX88279
+	case AX_VERSION_AX88279:
+		ptp_cfg->urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!ptp_cfg->urb)
+			goto fail;
+
+		ptp_cfg->ptp_caps = ax88279_ptp_clock;
+		break;
+#endif
+	case AX_VERSION_AX88179A_772D:
+		if (axdev->sub_version < 3)
+			return 0;
+		ptp_cfg->ptp_caps = ax88179a_772d_ptp_clock;
+		break;
+	default:
+		return 0;
+	};
+
+	ptp_cfg->ptp_clock = ptp_clock_register(&ptp_cfg->ptp_caps,
+						&axdev->udev->dev);
+	if (IS_ERR(ptp_cfg->ptp_clock)) {
+		dev_err(&axdev->intf->dev, "ptp_clock_register failed\n");
+		ret = PTR_ERR(ptp_cfg->ptp_clock);
+		goto fail;
+	}
+
+	ptp_cfg->phc_index = ptp_clock_index(ptp_cfg->ptp_clock);
+	skb_queue_head_init(&axdev->tx_timestamp);
+
+	ptp_cfg->axdev = axdev;
+
+	return 0;
+fail:
+#ifdef ENABLE_AX88279
+	if (ptp_cfg->urb)
+		usb_free_urb(axdev->intr_urb);
+#endif
+	kfree(axdev->ptp_cfg);
+
+	return ret;
+}
diff --git a/drivers/net/usb/asix_usb/ax_ptp.h b/drivers/net/usb/asix_usb/ax_ptp.h
new file mode 100644
index 000000000000..719344f4bfe0
--- /dev/null
+++ b/drivers/net/usb/asix_usb/ax_ptp.h
@@ -0,0 +1,242 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#ifndef __ASIX_PTP_H
+#define __ASIX_PTP_H
+
+#include <linux/ptp_clock_kernel.h>
+#include <linux/net_tstamp.h>
+
+#define AX_MAC_BFM_CTRL		0xC1
+	#define AX_CS_TRAIL_UDPV4_EN		0x40
+	#define AX_CS_TRAIL_UDPV6_EN		0x80
+
+#define EP0_GET_TIMESTAMP_RETRY	10
+
+#define AX_PTP_CMD		0x09
+#define AX_PTP_OP		0x0E
+	#define AX_SET_LOCAL_CLOCK	0x01
+	#define AX_SET_LOCAL_CLOCK_SIZE		0x0A
+	#define AX_GET_LOCAL_CLOCK	0x02
+	#define AX_GET_LOCAL_CLOCK_SIZE		0x0A
+	#define AX_SET_ADDEND		0x03
+	#define AX_SET_ADDEND_SIZE		0x04
+	#define AX_SET_ACTIVE_TIME	0x06
+	#define AX_SET_ACTIVE_TIME_SIZE	0x04
+	#define AX_SET_TX_PHY_DELAY	0x07
+	#define AX_SET_TX_PHY_DELAY_SIZE	0x05
+	#define AX_SET_RX_PHY_DELAY	0x08
+	#define AX_SET_RX_PHY_DELAY_SIZE	AX_SET_TX_PHY_DELAY_SIZE
+#define AX_PTP_TIMESTAMP	0x0A
+#define AX_PTP_CLK		0x13
+#define AX_PTP_TOD_CTRL	0x15
+	#define AX_PTP_TS_INT		0x02
+	#define AX_EXT_INT		0x04
+	#define AX_EXT_INT_ON		0x10
+	#define AX_PTP_TX_TX_INT_EN	0x40
+
+// Ethernet: 14B, IPv4: 20B, UDP: 8B
+#define AX_TX_PTPHDR_OFFSET_L3_IP	42
+// Ethernet: 14B, IPv6: 40B, UDP: 8B
+#define AX_TX_PTPHDR_OFFSET_L3_IPV6	62
+// Ethernet: 14B
+#define AX_TX_PTPHDR_OFFSET_L2	14
+#define AX_ETHTYPE_OFFSET		12
+#define AX_IP_PROTO_OFFSET		9
+#define AX_UDP_PORT_OFFSET		22
+#define AX_PTP_EVENT_PORT_NUM		0x13F
+#define PTP_HDR_SIZE			34
+
+#define AX_PPS_ACTIVE_DEFAULT_TIME	0x1DCD6500
+#define AX_BASE_ADDEND			0xCCCCCCCC
+#define AX_PTP_PERIOD			0xA
+
+#define AX88179A_PTP_CTRL_1		0x00
+	#define AX_PTP_TX_PLUS_DELAY		0x20
+	#define AX_PTP_RX_FILTER_GENERAL_MSG	0x10
+	#define AX_PTP_TX_FILTER_GENERAL_MSG	0x08
+	#define AX_PTP_CTRL_L3_EN		0x02
+	#define AX_PTP_CTRL_EN			0x01
+#define AX88179A_PTP_CTRL_2		0x01
+	#define AX_PTP_CTRL_SET_PERIOD		0x08
+	#define AX_PTP_CTRL_SET_ADDEND		0x04
+	#define AX_PTP_CTRL_GET_CLK		0x02
+	#define AX_PTP_CTRL_SET_CLK		0x01
+#define AX88179A_PTP_TIMER_PERIOD	0x0A
+#define AX88179A_PTP_MEM_SEG_SIZE	0x21
+#define AX88179A_PTP_MEM_SEG_SET	0x22
+#define AX88179A_PTP_MEM_SEG_STATUS	0x23
+	#define AX_PTP_MEM_SEG_MASK		0x01
+	#define AX_PTP_MEM_SEG_0		0
+
+#ifdef ENABLE_AX88279
+#define AX_PTP_REG_BASE_ADDR_HI		0x0012
+#define AX_PTP_TX_MEM_SETTING		0x0000
+	#define AX_PTP_PTP_CPU_EN		0x0001
+	/* TODO:: Change to Product code */
+	#define AX_PTP_MEM_SEG_SIZE_279_4	0x34	// USB 2.0
+	#define AX_PTP_MEM_SEG_SIZE_279_5	0x41
+	#define AX_PTP_MEM_START_ADDR		0x800
+#define AX_PTP_LCK_CTRL0		0x1000
+	#define AX_PTP_LCK_CTRL0_EN		0x0001
+	#define AX_PTP_LCK_CTRL0_80B_NS_EN	0x0002
+	#define AX_PTP_LCK_CTRL0_80B_S_EN	0x0004
+	#define AX_PTP_LCK_CTRL0_48B_EN		0x0008
+	#define AX_PTP_LCK_CTRL0_PPS_EN		0x0010
+	#define AX_PTP_LCK_CTRL0_TX_DEL_VEC	0x0040
+#define AX_PTP_LCK_CTRL1			0x1004
+#define AX_PTP_SET_80B_LCK_VAL0		0x1008
+#define AX_PTP_GET_80B_LCK_VAL0		0x1014
+#define AX_PTP_GET_80B_LCK_VAL1		0x1018
+#define AX_PTP_GET_80B_LCK_VAL2		0x101C
+#define AX_PTP_TIMER_ADDEND			0x1030
+#define AX_PTP_TIMER_PERIOD			0x1034
+#define AX_PTP_TX_DELAY			0x1038
+#define AX_PTP_RX_DELAY			0x103C
+#define AX_PTP_PPS_ACTIVE_TIME		0x1040
+
+#define AX_PTP_RX_CTRL0			0x2000
+	#define AX_PTP_RXC0_EN			0x0001
+	#define AX_PTP_RXC0_XGMII_EN		0x0002
+	#define AX_RXC0_PARSER_L2_EN		0x0010
+	#define AX_RXC0_PARSER_L2_PTP_EN	0x0020
+	#define AX_RXC0_PARSER_IPV4_EN	0x0040
+	#define AX_RXC0_PARSER_IPV6_EN	0x0080
+	#define AX_RXC0_PARSER_VLAN_EN	0x0100
+	#define AX_RXC0_PARSER_PPPOE_EN	0x0200
+	#define AX_RXC0_PARSER_SNAP_EN	0x0400
+	#define AX_RXC0_PARSER_UDP_EN		0x0800
+	#define AX_RXC0_PARSER_UDPV6_EN	0x1000
+	#define AX_RXC0_PARSER_UDP_PTP_EN	0x2000
+	#define AX_RXC0_PARSER_UDPV6_PTP_EN	0x4000
+	#define AX_RXC0_PARSER_EVENT_PORT_EN	0x00010000
+	#define AX_RXC0_VAL_DELAY_CNT_SHIFT	24
+
+#define AX_PTP_RX_CTRL0_DEFAULT	\
+	(AX_PTP_RXC0_EN | AX_RXC0_PARSER_L2_EN | AX_RXC0_PARSER_L2_PTP_EN | \
+	AX_RXC0_PARSER_IPV4_EN | AX_RXC0_PARSER_IPV6_EN | \
+	AX_RXC0_PARSER_VLAN_EN | AX_RXC0_PARSER_PPPOE_EN | \
+	AX_RXC0_PARSER_SNAP_EN | AX_RXC0_PARSER_UDP_EN | \
+	AX_RXC0_PARSER_UDPV6_EN | AX_RXC0_PARSER_UDP_PTP_EN | \
+	AX_RXC0_PARSER_UDPV6_PTP_EN | AX_RXC0_PARSER_EVENT_PORT_EN)
+
+#define AX_PTP_TX_CTRL0			0x3000
+	#define AX_PTP_TXC0_EN			0x0001
+	#define AX_PTP_TXC0_XGMII_EN		0x0002
+	#define AX_TXC0_PARSER_L2_EN		0x0010
+	#define AX_TXC0_PARSER_L2_PTP_EN	0x0020
+	#define AX_TXC0_PARSER_IPV4_EN	0x0040
+	#define AX_TXC0_PARSER_IPV6_EN	0x0080
+	#define AX_TXC0_PARSER_VLAN_EN	0x0100
+	#define AX_TXC0_PARSER_PPPOE_EN	0x0200
+	#define AX_TXC0_PARSER_SNAP_EN	0x0400
+	#define AX_TXC0_PARSER_UDP_EN		0x0800
+	#define AX_TXC0_PARSER_UDPV6_EN	0x1000
+	#define AX_TXC0_PARSER_UDP_PTP_EN	0x2000
+	#define AX_TXC0_PARSER_UDPV6_PTP_EN	0x4000
+	#define AX_TXC0_PARSER_EVENT_PORT_EN	0x00010000
+	#define AX_TXC0_VAL_DELAY_CNT_SHIFT	24
+
+#define AX_PTP_TX_CTRL0_DEFAULT	\
+	(AX_PTP_TXC0_EN | AX_TXC0_PARSER_L2_EN | AX_TXC0_PARSER_L2_PTP_EN | \
+	AX_TXC0_PARSER_IPV4_EN | AX_TXC0_PARSER_IPV6_EN | \
+	AX_TXC0_PARSER_VLAN_EN | AX_TXC0_PARSER_PPPOE_EN | \
+	AX_TXC0_PARSER_SNAP_EN | AX_TXC0_PARSER_UDP_EN | \
+	AX_TXC0_PARSER_UDPV6_EN | AX_TXC0_PARSER_UDP_PTP_EN | \
+	AX_TXC0_PARSER_UDPV6_PTP_EN | AX_TXC0_PARSER_EVENT_PORT_EN)
+#endif
+
+
+struct _ptp_header {
+	u16	message_type		:4,
+		transport_specific	:4,
+		reserved		:4,
+		version_ptp		:4;
+	u16	message_len;
+	u8	domain_num;
+	u8	reserved1;
+	u16	flags;
+	u64	correction_field;
+	u32	reserved2;
+	u8	source_port_id[10];
+	u16	sequence_id;
+	u8	ctrl_field;
+	u8	log_msg_interval;
+} __packed;
+
+struct _179a_ptp_info {
+	u8	reserved	:3,
+		status		:1,
+		msg_type	:4;
+	u8	sequence_id;
+	u32	nsec;
+	u32	sec_l;
+	u16	sec_h;
+} __packed;
+#define AX_179A_PTP_INFO_SEG_SIZE sizeof(struct _179a_ptp_info)
+
+struct _ax_ptp_info {
+	u8	reserved	:3,
+		status		:1,
+		msg_type	:4;
+	u16	sequence_id;
+	u32	nsec;
+	u32	sec_l;
+	u16	sec_h;
+} __packed;
+#define AX_PTP_HW_QUEUE_SIZE	5
+#define AX_PTP_QUEUE_SIZE	AX_PTP_HW_QUEUE_SIZE
+#define AX_PTP_INFO_SIZE	sizeof(struct _ax_ptp_info)
+
+struct _ax_ptp_usb_info {
+	struct _ax_ptp_info ax_ptp_info[AX_PTP_HW_QUEUE_SIZE];
+	struct usb_ctrlrequest req;
+	void *axdev;
+};
+
+struct ax_ptp_cfg {
+	void *axdev;
+	struct ptp_clock_info ptp_caps;
+	struct ptp_clock *ptp_clock;
+	unsigned int phc_index;
+	struct _ax_ptp_info tx_ptp_info[AX_PTP_QUEUE_SIZE];
+	unsigned long ptp_head, ptp_tail, num_items;
+	int get_timestamp_retry;
+#ifdef ENABLE_AX88279
+#define AX_PTP_EP4_SIZE	((2 * AX_PTP_INFO_SIZE * AX_PTP_HW_QUEUE_SIZE) + 1)
+#define AX_TS_SEG_1		1
+#define AX_EP4_INFO_SIZE (AX_PTP_QUEUE_SIZE * AX_PTP_EP4_SIZE)
+	struct urb *urb;
+	unsigned char ep4_buf[AX_PTP_EP4_SIZE];
+	struct _ax_ptp_info ep4_ptp_info[AX_EP4_INFO_SIZE];
+#endif
+};
+
+int ax_ptp_register(struct ax_device *axdev);
+void ax_ptp_unregister(struct ax_device *axdev);
+int ax88179a_ptp_pps_ctrl(struct ax_device *axdev, u8 enable);
+int ax88179a_ptp_init(struct ax_device *axdev);
+void ax88179a_ptp_remove(struct ax_device *axdev);
+#ifdef ENABLE_AX88279
+int ax88279_ptp_pps_ctrl(struct ax_device *axdev, u8 enable);
+int ax88279_ptp_init(struct ax_device *axdev);
+void ax88279_ptp_remove(struct ax_device *axdev);
+int ax88279_start_get_ts(struct ax_device *axdev);
+void ax88279_stop_get_ts(struct ax_device *axdev);
+#endif
+int ax_ptp_ts_read_cmd_async(struct ax_device *axdev);
+void ax_rx_get_timestamp(struct sk_buff *skb, u64 *pkt_hdr);
+#endif /* End of __ASIX_PTP_H */
diff --git a/drivers/net/usb/asix_usb/axcmd.c b/drivers/net/usb/asix_usb/axcmd.c
new file mode 100644
index 000000000000..c40c1901efcd
--- /dev/null
+++ b/drivers/net/usb/asix_usb/axcmd.c
@@ -0,0 +1,295 @@
+// SPDX-License-Identifier: GPL-2.0
+/*******************************************************************************
+ *     Copyright (c) 2022    ASIX Electronic Corporation    All rights reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <https://www.gnu.org/licenses/>.
+ ******************************************************************************/
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#if NET_INTERFACE == INTERFACE_SCAN
+#include <ifaddrs.h>
+#endif
+#include "ax_ioctl.h"
+
+#define ASIX_IOCTL_VERSION "ASIX Linux Command Tool v1.0.0"
+
+const char help_str1[] =
+"./ioctl help [command]\n"
+"    -- command description\n";
+const char help_str2[] =
+"        [command] - Display usage of specified command\n";
+
+const char usbcommand_str1[] =
+"./axcmd usb [ops] [cmd] [value] [index] [size] [data]\n"
+"    -- ASIX USB Command\n";
+const char usbcommand_str2[] =
+"        [ops]     - 0: Read,  1: Write\n"
+"        [cmd]     - USB Command (0 - 0xFF)\n"
+"        [value]   - USB wvalue (0 - 0xFFFF)\n"
+"        [index]   - USB windex (0 - 0xFFFF)\n"
+"        [size]    - USB wlength (0 - 0xFFFF)\n"
+"        [data]    - Data (0 - 0xFFFFFFFF)\n";
+
+static int help_func(struct ax_command_info *info);
+static int usbcommand_func(struct ax_command_info *info);
+
+struct _command_list asix_cmd_list[] = {
+	{	"help",
+		AX_SIGNATURE,
+		help_func,
+		help_str1,
+		help_str2
+	},
+	{	"usb",
+		AX_USB_COMMAND,
+		usbcommand_func,
+		usbcommand_str1,
+		usbcommand_str2
+	},
+	{NULL},
+};
+
+static void show_usage(void)
+{
+	int i;
+
+	printf("Usage:\n");
+	for (i = 0; asix_cmd_list[i].cmd != NULL; i++)
+		printf("%s\n", asix_cmd_list[i].help_ins);
+}
+
+static unsigned long STR_TO_U32(const char *cp, char **endp,
+				unsigned int base)
+{
+	unsigned long result = 0, value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base)
+			base = 8;
+	}
+
+	if (!base)
+		base = 10;
+
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+
+	if (endp)
+		*endp = (char *)cp;
+
+	return result;
+}
+
+static int help_func(struct ax_command_info *info)
+{
+	int i;
+
+	if (info->argv[2] == NULL) {
+		for (i = 0; asix_cmd_list[i].cmd != NULL; i++) {
+			printf("%s%s\n",
+				asix_cmd_list[i].help_ins,
+				asix_cmd_list[i].help_desc);
+		}
+	}
+
+	for (i = 0; asix_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(info->argv[1],
+			    asix_cmd_list[i].cmd,
+			    strlen(asix_cmd_list[i].cmd)) == 0) {
+			printf("%s%s\n",
+				asix_cmd_list[i].help_ins,
+				asix_cmd_list[i].help_desc);
+			return -FAIL_INVALID_PARAMETER;
+		}
+	}
+
+}
+
+static int usbcommand_func(struct ax_command_info *info)
+{
+	struct ifreq *ifr = (struct ifreq *)info->ifr;
+	struct _ax_ioctl_command ioctl_cmd;
+	struct _ax_usb_command *usb_cmd;
+	int i;
+
+	if (info->argc > 8 || info->argc < 7) {
+		for (i = 0; asix_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], asix_cmd_list[i].cmd,
+				    strlen(asix_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", asix_cmd_list[i].help_ins,
+						 asix_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	usb_cmd = &ioctl_cmd.usb_cmd;
+	memset(usb_cmd, 0, sizeof(*usb_cmd));
+
+	usb_cmd->ops = STR_TO_U32(info->argv[2], NULL, 16);
+	usb_cmd->cmd = STR_TO_U32(info->argv[3], NULL, 16);
+	usb_cmd->value = STR_TO_U32(info->argv[4], NULL, 16);
+	usb_cmd->index = STR_TO_U32(info->argv[5], NULL, 16);
+	usb_cmd->size = STR_TO_U32(info->argv[6], NULL, 16);
+
+	if (usb_cmd->ops > USB_WRITE_OPS) {
+		for (i = 0; asix_cmd_list[i].cmd != NULL; i++) {
+			if (strncmp(info->argv[1], asix_cmd_list[i].cmd,
+				    strlen(asix_cmd_list[i].cmd)) == 0) {
+				printf("%s%s\n", asix_cmd_list[i].help_ins,
+						 asix_cmd_list[i].help_desc);
+				return -FAIL_INVALID_PARAMETER;
+			}
+		}
+	}
+
+	if (usb_cmd->ops == USB_WRITE_OPS)
+		usb_cmd->cmd_data = STR_TO_U32(info->argv[7], NULL, 16);
+
+	ioctl_cmd.ioctl_cmd = info->ioctl_cmd;
+	ioctl_cmd.size = usb_cmd->size;
+	ioctl_cmd.buf = NULL;
+	ioctl_cmd.type = 0;
+	ioctl_cmd.delay = 0;
+
+	ifr->ifr_data = (caddr_t)&ioctl_cmd;
+
+	if (ioctl(info->inet_sock, AX_PRIVATE, ifr) < 0) {
+		perror("ioctl");
+		return -FAIL_IOCTL;
+	}
+
+	if (usb_cmd->ops == USB_READ_OPS) {
+		printf("Read Command: CMD: 0x%02X\n", usb_cmd->cmd);
+		printf("wValue: 0x%04X, wIndex: 0x%04X, wLength: 0x%04X",
+			usb_cmd->value, usb_cmd->index, usb_cmd->size);
+		printf("\nData: 0x%08lX\n", usb_cmd->cmd_data);
+	}
+
+	printf("Command completely\n");
+
+	return SUCCESS;
+}
+
+int main(int argc, char **argv)
+{
+	int inet_sock;
+	struct ifreq ifr;
+	struct ax_command_info info;
+	unsigned char i;
+	unsigned char count = 0;
+	struct _ax_ioctl_command ioctl_cmd;
+#if NET_INTERFACE == INTERFACE_SCAN
+	struct ifaddrs *addrs, *tmp;
+	unsigned char	dev_exist;
+#endif
+
+	if (argc < 2) {
+		show_usage();
+		return 0;
+	}
+
+	inet_sock = socket(AF_INET, SOCK_DGRAM, 0);
+#if NET_INTERFACE == INTERFACE_SCAN
+	getifaddrs(&addrs);
+	tmp = addrs;
+	dev_exist = 0;
+
+	while (tmp) {
+		memset(&ioctl_cmd, 0, sizeof(ioctl_cmd));
+		ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+		sprintf(ifr.ifr_name, "%s", tmp->ifa_name);
+		ifr.ifr_data = (caddr_t)&ioctl_cmd;
+		tmp = tmp->ifa_next;
+
+		if (ioctl(inet_sock, AX_PRIVATE, &ifr) < 0)
+			continue;
+
+		if (strncmp(ioctl_cmd.sig, AX88179_DRV_NAME,
+			    strlen(AX88179_DRV_NAME)) == 0) {
+			dev_exist = 1;
+			break;
+		}
+
+		if (strncmp(ioctl_cmd.sig, AX88179A_DRV_NAME,
+			    strlen(AX88179A_DRV_NAME)) == 0) {
+			dev_exist = 1;
+			break;
+		}
+	}
+
+	freeifaddrs(addrs);
+
+	if (dev_exist == 0) {
+		printf("No ASIX device found\n");
+		return 0;
+	}
+#else
+	for (i = 0; i < 255; i++) {
+
+		memset(&ioctl_cmd, 0, sizeof(ioctl_cmd));
+		ioctl_cmd.ioctl_cmd = AX_SIGNATURE;
+
+		sprintf(ifr.ifr_name, "eth%d", i);
+
+		ifr.ifr_data = (caddr_t)&ioctl_cmd;
+
+		if (ioctl(inet_sock, AX_PRIVATE, &ifr) < 0)
+			continue;
+
+		if (strncmp(ioctl_cmd.sig, AX88179_DRV_NAME,
+			    strlen(AX88179_DRV_NAME)) == 0)
+			break;
+
+		if (strncmp(ioctl_cmd.sig, AX88179A_DRV_NAME,
+			    strlen(AX88179A_DRV_NAME)) == 0)
+			break;
+	}
+
+	if (i == 255) {
+		printf("No ASIX device found\n");
+		return 0;
+	}
+#endif
+	for (i = 0; asix_cmd_list[i].cmd != NULL; i++) {
+		if (strncmp(argv[1], asix_cmd_list[i].cmd,
+			    strlen(asix_cmd_list[i].cmd)) == 0) {
+			info.help_ins = asix_cmd_list[i].help_ins;
+			info.help_desc = asix_cmd_list[i].help_desc;
+			info.ifr = &ifr;
+			info.argc = argc;
+			info.argv = argv;
+			info.inet_sock = inet_sock;
+			info.ioctl_cmd = asix_cmd_list[i].ioctl_cmd;
+			(asix_cmd_list[i].OptFunc)(&info);
+			return 0;
+		}
+	}
+
+	printf("Wrong command\n");
+
+	return 0;
+}
diff --git a/drivers/net/usb/compatibility.h b/drivers/net/usb/compatibility.h
new file mode 100644
index 000000000000..d1e044d0be40
--- /dev/null
+++ b/drivers/net/usb/compatibility.h
@@ -0,0 +1,663 @@
+#ifndef LINUX_COMPATIBILITY_H
+#define LINUX_COMPATIBILITY_H
+
+/*
+ * Definition and macro
+ */
+
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/in.h>
+#include <linux/acpi.h>
+
+#if defined(RTL8152_S5_WOL) && defined(CONFIG_PM)
+#include <linux/reboot.h>
+#endif /* defined(RTL8152_S5_WOL) && defined(CONFIG_PM) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+	#include <linux/mdio.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0)
+	#include <uapi/linux/mdio.h>
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0) */
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,19,0)
+	#define TSO_LEGACY_MAX_SIZE		65536
+	#define netif_napi_add_weight		netif_napi_add
+	#define netif_set_tso_max_size		netif_set_gso_max_size
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,12,0)
+	#define PHY_MAC_INTERRUPT		PHY_IGNORE_INTERRUPT
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
+	#ifdef CONFIG_PM
+	#define pm_ptr(_ptr) (_ptr)
+	#else
+	#define pm_ptr(_ptr) NULL
+	#endif
+
+	#define from_tasklet(var, callback_tasklet, tasklet_fieldname)	\
+		container_of((struct tasklet_struct *)callback_tasklet, typeof(*var), tasklet_fieldname)
+
+	#define tasklet_setup(t, fun)	tasklet_init(t, fun, (unsigned long)t)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
+	/* Iterate through singly-linked GSO fragments of an skb. */
+	#define skb_list_walk_safe(first, skb, next_skb)                               \
+		for ((skb) = (first), (next_skb) = (skb) ? (skb)->next : NULL; (skb);  \
+		     (skb) = (next_skb), (next_skb) = (skb) ? (skb)->next : NULL)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+	#ifndef __has_attribute
+	# define __has_attribute(x)         0
+	#endif
+
+	#if __has_attribute(__fallthrough__)
+	# define fallthrough                    __attribute__((__fallthrough__))
+	#else
+	# define fallthrough                    do {} while (0)  /* fallthrough */
+	#endif
+
+	#define MDIO_EEE_2_5GT         0x0001  /* 2.5GT EEE cap */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,2,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,1,0)
+	#define MDIO_AN_10GBT_CTRL_ADV2_5G     0x0080  /* Advertise 2.5GBASE-T */
+	#define MDIO_AN_10GBT_STAT_LP2_5G      0x0020  /* LP is 2.5GBT capable */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+	#define SPEED_2500				2500
+	#define SPEED_25000				25000
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+	#ifndef ETHTOOL_LINK_MODE_2500baseT_Full_BIT
+	#define ETHTOOL_LINK_MODE_2500baseT_Full_BIT	ETHTOOL_LINK_MODE_2500baseX_Full_BIT
+	#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0)
+	#define BMCR_SPEED10				0x0000
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+	#define NETIF_F_CSUM_MASK			NETIF_F_ALL_CSUM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,1,0)
+	#define IS_REACHABLE(option)			(defined(option) || \
+							 (defined(option##_MODULE) && defined(MODULE)))
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+	#define skb_vlan_tag_present(__skb)		vlan_tx_tag_present(__skb)
+	#define skb_vlan_tag_get(__skb)			vlan_tx_tag_get(__skb)
+	#define skb_vlan_tag_get_id(__skb)		vlan_tx_tag_get_id(__skb)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0)
+	#define napi_alloc_skb(napi, length)		netdev_alloc_skb_ip_align(netdev,length)
+	#define napi_complete_done(n, d)		napi_complete(n)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0)
+	#ifndef smp_mb__before_atomic
+	#define smp_mb__before_atomic()			smp_mb()
+	#endif
+
+	#ifndef smp_mb__after_atomic
+	#define smp_mb__after_atomic()			smp_mb()
+	#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+	#define IS_ERR_OR_NULL(ptr)			(!ptr)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+	#define ether_addr_copy(dst, src)		memcpy(dst, src, ETH_ALEN)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
+	#define BIT(nr)					(1UL << (nr))
+	#define BIT_ULL(nr)				(1ULL << (nr))
+	#define BITS_PER_BYTE				8
+	#define reinit_completion(x)			((x)->done = 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
+	#define DEVICE_ATTR_RW(_name) \
+		struct device_attribute dev_attr_##_name = __ATTR(_name, 0644, _name##_show, _name##_store)
+	#define DEVICE_ATTR_RO(_name) \
+		struct device_attribute dev_attr_##_name = __ATTR_RO(_name)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+	#define NETIF_F_HW_VLAN_CTAG_RX			NETIF_F_HW_VLAN_RX
+	#define NETIF_F_HW_VLAN_CTAG_TX			NETIF_F_HW_VLAN_TX
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0)
+	#define USB_DEVICE_INTERFACE_CLASS(vend, prod, cl) \
+		.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \
+			       USB_DEVICE_ID_MATCH_INT_CLASS, \
+		.idVendor = (vend), \
+		.idProduct = (prod), \
+		.bInterfaceClass = (cl)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+	#ifndef SPEED_UNKNOWN
+		#define SPEED_UNKNOWN		0
+	#endif
+
+	#ifndef DUPLEX_UNKNOWN
+		#define DUPLEX_UNKNOWN		0xff
+	#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+	#define eth_random_addr(addr)			random_ether_addr(addr)
+	#define usb_enable_lpm(udev)
+	#define MDIO_EEE_100TX				MDIO_AN_EEE_ADV_100TX	/* 100TX EEE cap */
+	#define MDIO_EEE_1000T				MDIO_AN_EEE_ADV_1000T	/* 1000T EEE cap */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+	#define ETH_MDIO_SUPPORTS_C22			MDIO_SUPPORTS_C22
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+	#define module_usb_driver(__driver) \
+	static int __init __driver##_init(void) \
+	{ \
+		return usb_register(&(__driver)); \
+	} \
+	module_init(__driver##_init); \
+	static void __exit __driver##_exit(void) \
+	{ \
+		usb_deregister(&(__driver)); \
+	} \
+	module_exit(__driver##_exit);
+
+	#define netdev_features_t			u32
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0)
+	#define PMSG_IS_AUTO(msg)	(((msg).event & PM_EVENT_AUTO) != 0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0)
+	#define ndo_set_rx_mode				ndo_set_multicast_list
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+	#define NETIF_F_RXCSUM				(1 << 29) /* Receive checksumming offload */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	#define MDIO_AN_EEE_ADV				60	/* EEE advertisement */
+	#define MDIO_AN_EEE_ADV_100TX			0x0002	/* Advertise 100TX EEE cap */
+	#define MDIO_AN_EEE_ADV_1000T			0x0004	/* Advertise 1000T EEE cap */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+	#define skb_checksum_none_assert(skb_ptr)	(skb_ptr)->ip_summed = CHECKSUM_NONE
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+	#define skb_tx_timestamp(skb)
+
+	#define queue_delayed_work(long_wq, work, delay)	schedule_delayed_work(work, delay)
+
+	#define work_busy(x)				0
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
+	#define netdev_mc_count(netdev)			((netdev)->mc_count)
+	#define netdev_mc_empty(netdev)			(netdev_mc_count(netdev) == 0)
+
+	#define netif_printk(priv, type, level, netdev, fmt, args...)	\
+	do {								\
+		if (netif_msg_##type(priv))				\
+			printk(level "%s: " fmt,(netdev)->name , ##args); \
+	} while (0)
+
+	#define netif_emerg(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_EMERG, netdev, fmt, ##args)
+	#define netif_alert(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ALERT, netdev, fmt, ##args)
+	#define netif_crit(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_CRIT, netdev, fmt, ##args)
+	#define netif_err(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ERR, netdev, fmt, ##args)
+	#define netif_warn(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_WARNING, netdev, fmt, ##args)
+	#define netif_notice(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_NOTICE, netdev, fmt, ##args)
+	#define netif_info(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_INFO, (netdev), fmt, ##args)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	#define get_sset_count				get_stats_count
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	#define pm_request_resume(para)
+	#define pm_runtime_set_suspended(para)
+	#define pm_schedule_suspend(para1, para2)
+	#define pm_runtime_get_sync(para)
+	#define pm_runtime_put_sync(para)
+	#define pm_runtime_put_noidle(para)
+	#define pm_runtime_idle(para)
+	#define pm_runtime_set_active(para)
+	#define pm_runtime_enable(para)
+	#define pm_runtime_disable(para)
+	typedef int netdev_tx_t;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+	#define USB_SPEED_SUPER				(USB_SPEED_VARIABLE + 1)
+	#define MDIO_MMD_AN				7	/* Auto-Negotiation */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	#define napi_gro_receive(napi, skb)		netif_receive_skb(skb)
+	#define vlan_gro_receive(napi, grp, vlan_tci, skb) \
+		vlan_hwaccel_receive_skb(skb, grp, vlan_tci)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+	#define PM_EVENT_AUTO		0x0400
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+	struct napi_struct {
+		struct list_head	poll_list;
+		unsigned long		state;
+		int			weight;
+		int			(*poll)(struct napi_struct *, int);
+	#ifdef CONFIG_NETPOLL
+		spinlock_t		poll_lock;
+		int			poll_owner;
+		struct net_device	*dev;
+		struct list_head	dev_list;
+	#endif
+	};
+
+	#define napi_enable(napi_ptr)			netif_poll_enable(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define napi_disable(napi_ptr)			netif_poll_disable(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define napi_schedule(napi_ptr)			netif_rx_schedule(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define napi_complete(napi_ptr)			netif_rx_complete(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define netif_napi_add(ndev, napi_ptr, function, weight_t) \
+		ndev->poll = function; \
+		ndev->weight = weight_t;
+	typedef unsigned long				uintptr_t;
+	#define DMA_BIT_MASK(value) \
+		(value < 64 ? ((1ULL << value) - 1) : 0xFFFFFFFFFFFFFFFFULL)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	#define NETIF_F_IPV6_CSUM			16
+	#define cancel_delayed_work_sync		cancel_delayed_work
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	#define ip_hdr(skb_ptr)				(skb_ptr)->nh.iph
+	#define ipv6hdr(skb_ptr)			(skb_ptr)->nh.ipv6h
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+	#define vlan_group_set_device(vlgrp, vid, value) \
+		if (vlgrp) \
+			(vlgrp)->vlan_devices[vid] = value;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+	#define delayed_work				work_struct
+	#define INIT_DELAYED_WORK(a,b)			INIT_WORK(a,b,tp)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	#define CHECKSUM_PARTIAL			CHECKSUM_HW
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	#define skb_is_gso(skb_ptr)			skb_shinfo(skb_ptr)->tso_size
+	#define netdev_alloc_skb(dev, len)		dev_alloc_skb(len)
+	#define IRQF_SHARED				SA_SHIRQ
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+	#ifndef __LINUX_MUTEX_H
+	#define mutex					semaphore
+	#define mutex_lock				down
+	#define mutex_unlock				up
+	#define mutex_trylock				down_trylock
+	#define mutex_lock_interruptible		down_interruptible
+	#define mutex_init				init_MUTEX
+	#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+	#define ADVERTISED_Pause			(1 << 13)
+	#define ADVERTISED_Asym_Pause			(1 << 14)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
+	#define skb_header_cloned(skb)			skb_cloned(skb)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16) */
+	static inline struct sk_buff *skb_gso_segment(struct sk_buff *skb, int features)
+	{
+		return NULL;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18) */
+	static inline void *kmemdup(const void *src, size_t len, gfp_t gfp)
+	{
+		void *p;
+
+		p = kmalloc_track_caller(len, gfp);
+		if (p)
+			memcpy(p, src, len);
+		return p;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21) */
+	static inline void skb_copy_from_linear_data(const struct sk_buff *skb,
+						     void *to,
+						     const unsigned int len)
+	{
+		memcpy(to, skb->data, len);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) */
+	static inline int skb_cow_head(struct sk_buff *skb, unsigned int headroom)
+	{
+		int delta = 0;
+
+		if (headroom > skb_headroom(skb))
+			delta = headroom - skb_headroom(skb);
+
+		if (delta || skb_header_cloned(skb))
+			return pskb_expand_head(skb, ALIGN(delta, NET_SKB_PAD),
+						0, GFP_ATOMIC);
+		return 0;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24) */
+	static inline void __list_splice2(const struct list_head *list,
+					  struct list_head *prev,
+					  struct list_head *next)
+	{
+		struct list_head *first = list->next;
+		struct list_head *last = list->prev;
+
+		first->prev = prev;
+		prev->next = first;
+
+		last->next = next;
+		next->prev = last;
+	}
+
+	static inline void list_splice_tail(struct list_head *list,
+					    struct list_head *head)
+	{
+		if (!list_empty(list))
+			__list_splice2(list, head->prev, head);
+	}
+
+	static inline void netif_napi_del(struct napi_struct *napi)
+	{
+	#ifdef CONFIG_NETPOLL
+	        list_del(&napi->dev_list);
+	#endif
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27) */
+	static inline void __skb_queue_splice(const struct sk_buff_head *list,
+					      struct sk_buff *prev,
+					      struct sk_buff *next)
+	{
+		struct sk_buff *first = list->next;
+		struct sk_buff *last = list->prev;
+
+		first->prev = prev;
+		prev->next = first;
+
+		last->next = next;
+		next->prev = last;
+	}
+
+	static inline void skb_queue_splice(const struct sk_buff_head *list,
+					    struct sk_buff_head *head)
+	{
+		if (!skb_queue_empty(list)) {
+			__skb_queue_splice(list, (struct sk_buff *) head, head->next);
+			head->qlen += list->qlen;
+		}
+	}
+
+	static inline void __skb_queue_head_init(struct sk_buff_head *list)
+	{
+		list->prev = list->next = (struct sk_buff *)list;
+		list->qlen = 0;
+	}
+
+	static inline void skb_queue_splice_init(struct sk_buff_head *list,
+						 struct sk_buff_head *head)
+	{
+		if (!skb_queue_empty(list)) {
+			__skb_queue_splice(list, (struct sk_buff *) head, head->next);
+			head->qlen += list->qlen;
+			__skb_queue_head_init(list);
+		}
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28) */
+	static inline void usb_autopm_put_interface_async(struct usb_interface *intf)
+	{
+		struct usb_device *udev = interface_to_usbdev(intf);
+		int status = 0;
+
+		if (intf->condition == USB_INTERFACE_UNBOUND) {
+			status = -ENODEV;
+		} else {
+			udev->last_busy = jiffies;
+			--intf->pm_usage_cnt;
+			if (udev->autosuspend_disabled || udev->autosuspend_delay < 0)
+				status = -EPERM;
+		}
+	}
+
+	static inline int usb_autopm_get_interface_async(struct usb_interface *intf)
+	{
+		struct usb_device *udev = interface_to_usbdev(intf);
+		int status = 0;
+
+		if (intf->condition == USB_INTERFACE_UNBOUND)
+			status = -ENODEV;
+		else if (udev->autoresume_disabled)
+			status = -EPERM;
+		else
+			++intf->pm_usage_cnt;
+		return status;
+	}
+
+	static inline int eth_change_mtu(struct net_device *dev, int new_mtu)
+	{
+		if (new_mtu < 68 || new_mtu > ETH_DATA_LEN)
+			return -EINVAL;
+		dev->mtu = new_mtu;
+		return 0;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32) */
+	static inline
+	struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev,
+						  unsigned int length)
+	{
+		struct sk_buff *skb = netdev_alloc_skb(dev, length + NET_IP_ALIGN);
+
+		if (NET_IP_ALIGN && skb)
+			skb_reserve(skb, NET_IP_ALIGN);
+		return skb;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33) */
+	static inline int usb_enable_autosuspend(struct usb_device *udev)
+	{ return 0; }
+	static inline int usb_disable_autosuspend(struct usb_device *udev)
+	{ return 0; }
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34) */
+	static inline bool pci_dev_run_wake(struct pci_dev *dev)
+	{
+		return 1;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35) */
+	static inline void usleep_range(unsigned long min, unsigned long max)
+	{
+		unsigned long ms = min / 1000;
+
+		if (ms)
+			mdelay(ms);
+
+		udelay(min % 1000);
+	}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36) */
+	static inline __be16 vlan_get_protocol(const struct sk_buff *skb)
+	{
+	       __be16 protocol = 0;
+
+	       if (vlan_tx_tag_present(skb) ||
+	            skb->protocol != cpu_to_be16(ETH_P_8021Q))
+	               protocol = skb->protocol;
+	       else {
+	               __be16 proto, *protop;
+	               protop = skb_header_pointer(skb, offsetof(struct vlan_ethhdr,
+	                                               h_vlan_encapsulated_proto),
+	                                               sizeof(proto), &proto);
+	               if (likely(protop))
+	                       protocol = *protop;
+	       }
+
+	       return protocol;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0) */
+	static inline struct page *skb_frag_page(const skb_frag_t *frag)
+	{
+		return frag->page;
+	}
+
+	static inline void *skb_frag_address(const skb_frag_t *frag)
+	{
+		return page_address(skb_frag_page(frag)) + frag->page_offset;
+	}
+
+	static inline unsigned int skb_frag_size(const skb_frag_t *frag)
+	{
+		return frag->size;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0) */
+	static inline void eth_hw_addr_random(struct net_device *dev)
+	{
+		random_ether_addr(dev->dev_addr);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0) */
+	static inline __sum16 tcp_v6_check(int len,
+					   const struct in6_addr *saddr,
+					   const struct in6_addr *daddr,
+					   __wsum base)
+	{
+		return csum_ipv6_magic(saddr, daddr, len, IPPROTO_TCP, base);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0) */
+	static inline bool usb_device_no_sg_constraint(struct usb_device *udev)
+	{
+		return 0;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0) */
+	static inline int skb_to_sgvec_nomark(struct sk_buff *skb,
+					      struct scatterlist *sg,
+					      int offset, int len)
+	{
+		int nsg = skb_to_sgvec(skb, sg, offset, len);
+
+		if (nsg <= 0)
+			return nsg;
+
+		sg_unmark_end(&sg[nsg - 1]);
+
+		return nsg;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,1,0) */
+	static inline int eth_platform_get_mac_address(struct device *dev, u8 *mac_addr)
+	{
+		return -EOPNOTSUPP;
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0) */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,19,10) && \
+    !(LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,217) && LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0))
+	static inline void skb_mark_not_on_list(struct sk_buff *skb)
+	{
+		skb->next = NULL;
+	}
+#endif
+	static inline void linkmode_set_bit(int nr, volatile unsigned long *addr)
+	{
+		__set_bit(nr, addr);
+	}
+
+	static inline void linkmode_clear_bit(int nr, volatile unsigned long *addr)
+	{
+		__clear_bit(nr, addr);
+	}
+
+	static inline int linkmode_test_bit(int nr, volatile unsigned long *addr)
+	{
+		return test_bit(nr, addr);
+	}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0) */
+	static inline void linkmode_mod_bit(int nr, volatile unsigned long *addr,
+					    int set)
+	{
+		if (set)
+			linkmode_set_bit(nr, addr);
+		else
+			linkmode_clear_bit(nr, addr);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,1,0) */
+//	static inline u16 pci_dev_id(struct pci_dev *dev)
+//	{
+//		return PCI_DEVID(dev->bus->number, dev->devfn);
+//	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,2,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0) */
+	static inline void tcp_v6_gso_csum_prep(struct sk_buff *skb)
+	{
+		struct ipv6hdr *ipv6h = ipv6_hdr(skb);
+		struct tcphdr *th = tcp_hdr(skb);
+
+		ipv6h->payload_len = 0;
+		th->check = ~tcp_v6_check(0, &ipv6h->saddr, &ipv6h->daddr, 0);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0) */
+	static inline void fsleep(unsigned long usecs)
+	{
+		if (usecs <= 10)
+			udelay(usecs);
+		else if (usecs <= 20000)
+			usleep_range(usecs, 2 * usecs);
+		else
+			msleep(DIV_ROUND_UP(usecs, 1000));
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,12,0) */
+	static inline void eth_hw_addr_set(struct net_device *dev, const u8 *addr)
+	{
+		memcpy(dev->dev_addr, addr, 6);
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,19,0) */
+
+#ifndef FALSE
+	#define TRUE	1
+	#define FALSE	0
+#endif
+
+enum rtl_cmd {
+	RTLTOOL_PLA_OCP_READ_DWORD = 0,
+	RTLTOOL_PLA_OCP_WRITE_DWORD,
+	RTLTOOL_USB_OCP_READ_DWORD,
+	RTLTOOL_USB_OCP_WRITE_DWORD,
+	RTLTOOL_PLA_OCP_READ,
+	RTLTOOL_PLA_OCP_WRITE,
+	RTLTOOL_USB_OCP_READ,
+	RTLTOOL_USB_OCP_WRITE,
+	RTLTOOL_USB_INFO,
+	RTL_ENABLE_USB_DIAG,
+	RTL_DISABLE_USB_DIAG,
+
+	RTLTOOL_INVALID
+};
+
+struct usb_device_info {
+	__u16		idVendor;
+	__u16		idProduct;
+	__u16		bcdDevice;
+	__u8		dev_addr[8];
+	char		devpath[16];
+};
+
+struct rtltool_cmd {
+	__u32	cmd;
+	__u32	offset;
+	__u32	byteen;
+	__u32	data;
+	void	*buf;
+	struct usb_device_info nic_info;
+	struct sockaddr ifru_addr;
+	struct sockaddr ifru_netmask;
+	struct sockaddr ifru_hwaddr;
+};
+
+#endif /* LINUX_COMPATIBILITY_H */
diff --git a/drivers/net/usb/r8152.c b/drivers/net/usb/r8152.c
index 23da1d9dafd1..5d6df581e53b 100644
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@ -1,6 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- *  Copyright (c) 2014 Realtek Semiconductor Corp. All rights reserved.
+ *  Copyright (c) 2023 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
  */
 
 #include <linux/signal.h>
@@ -18,27 +25,22 @@
 #include <linux/ip.h>
 #include <linux/ipv6.h>
 #include <net/ip6_checksum.h>
-#include <uapi/linux/mdio.h>
-#include <linux/mdio.h>
 #include <linux/usb/cdc.h>
 #include <linux/suspend.h>
 #include <linux/atomic.h>
 #include <linux/acpi.h>
-#include <linux/firmware.h>
-#include <crypto/hash.h>
-#include <linux/usb/r8152.h>
+#include "compatibility.h"
 
-/* Information for net-next */
-#define NETNEXT_VERSION		"12"
-
-/* Information for net */
-#define NET_VERSION		"13"
-
-#define DRIVER_VERSION		"v1." NETNEXT_VERSION "." NET_VERSION
-#define DRIVER_AUTHOR "Realtek linux nic maintainers <nic_swsd@realtek.com>"
+/* Version Information */
+#define DRIVER_VERSION "v2.17.1 (2023/06/13)"
+#define DRIVER_AUTHOR "Realtek nic sw <nic_swsd@realtek.com>"
 #define DRIVER_DESC "Realtek RTL8152/RTL8153 Based USB Ethernet Adapters"
 #define MODULENAME "r8152"
 
+#define PATENTS		"This product is covered by one or more of the " \
+			"following patents:\n" \
+			"\t\tUS6,570,884, US6,115,776, and US6,327,625.\n"
+
 #define R8152_PHY_ID		32
 
 #define PLA_IDR			0xc000
@@ -118,6 +120,15 @@
 #define PLA_BP_6		0xfc34
 #define PLA_BP_7		0xfc36
 #define PLA_BP_EN		0xfc38
+#define PLA_BP_8		0xfc38		/* RTL8153C */
+#define PLA_BP_9		0xfc3a
+#define PLA_BP_10		0xfc3c
+#define PLA_BP_11		0xfc3e
+#define PLA_BP_12		0xfc40
+#define PLA_BP_13		0xfc42
+#define PLA_BP_14		0xfc44
+#define PLA_BP_15		0xfc46
+#define PLA_BP2_EN		0xfc48
 
 #define USB_USB2PHY		0xb41e
 #define USB_SSPHYLINK1		0xb426
@@ -129,10 +140,14 @@
 #define USB_DEV_STAT		0xb808
 #define USB_CONNECT_TIMER	0xcbf8
 #define USB_MSC_TIMER		0xcbfc
+#define USB_OUTER_FW_VER	0xcd54
 #define USB_BURST_SIZE		0xcfc0
 #define USB_FW_FIX_EN0		0xcfca
 #define USB_FW_FIX_EN1		0xcfcc
+#define USB_FW_PLA_VER		0xcfd6
+#define USB_FW_USB_VER		0xcfd7
 #define USB_LPM_CONFIG		0xcfd8
+#define USB_EFUSE		0xcfdb
 #define USB_ECM_OPTION		0xcfee
 #define USB_CSTMR		0xcfef	/* RTL8153A */
 #define USB_MISC_2		0xcfff
@@ -141,6 +156,7 @@
 #define USB_SPEED_OPTION	0xd32a
 #define USB_FW_CTRL		0xd334	/* RTL8153B */
 #define USB_FC_TIMER		0xd340
+#define USB_OUTSIDE_FW_VER	0xd3cc
 #define USB_USB_CTRL		0xd406
 #define USB_PHY_CTRL		0xd408
 #define USB_TX_AGG		0xd40a
@@ -199,6 +215,7 @@
 #define OCP_EEE_AR		0xa41a
 #define OCP_EEE_DATA		0xa41c
 #define OCP_PHY_STATUS		0xa420
+#define OCP_INTR_EN		0xa424
 #define OCP_NCTL_CFG		0xa42c
 #define OCP_POWER_CFG		0xa430
 #define OCP_EEE_CFG		0xa432
@@ -351,6 +368,7 @@
 #define BWF_EN			0x0040
 #define MWF_EN			0x0020
 #define UWF_EN			0x0010
+#define SPI_EN			BIT(3)
 #define LAN_WAKE_EN		0x0002
 
 /* PLA_LED_FEATURE */
@@ -462,6 +480,9 @@
 /* USB_LPM_CONFIG */
 #define LPM_U1U2_EN		BIT(0)
 
+/* USB_EFUSE */
+#define PASS_THRU_MASK		BIT(0)
+
 /* USB_TX_AGG */
 #define TX_AGG_MAX_THRESHOLD	0x03
 
@@ -505,6 +526,7 @@
 #define FORCE_SUPER		BIT(0)
 
 /* USB_MISC_2 */
+#define UPS_NO_UPS		BIT(7)
 #define UPS_FORCE_PWR_DOWN	BIT(0)
 
 /* USB_ECM_OP */
@@ -544,6 +566,12 @@
 
 /* USB_MISC_0 */
 #define PCUT_STATUS		0x0001
+#define AD_MASK			0xfee0
+
+/* USB_MISC_1 */
+#define BD_MASK			BIT(0)
+#define BND_MASK		BIT(2)
+#define BL_MASK			BIT(3)
 
 /* USB_RX_EARLY_TIMEOUT */
 #define COALESCE_SUPER		 85000U
@@ -620,6 +648,9 @@ enum spd_duplex {
 #define PHY_STAT_LAN_ON		3
 #define PHY_STAT_PWRDN		5
 
+/* OCP_INTR_EN */
+#define INTR_SPEED_FORCE	BIT(3)
+
 /* OCP_NCTL_CFG */
 #define PGA_RETURN_EN		BIT(1)
 
@@ -714,15 +745,6 @@ enum spd_duplex {
 /* SRAM_PHY_LOCK */
 #define PHY_PATCH_LOCK		0x0001
 
-/* MAC PASSTHRU */
-#define AD_MASK			0xfee0
-#define BND_MASK		0x0004
-#define BD_MASK			0x0001
-#define EFUSE			0xcfdb
-#define PASS_THRU_MASK		0x1
-
-#define BP4_SUPER_ONLY		0x1578	/* RTL_VER_04 only */
-
 enum rtl_register_content {
 	_2500bps	= BIT(10),
 	_1250bps	= BIT(9),
@@ -750,6 +772,18 @@ enum rtl_register_content {
 
 #define INTR_LINK		0x0004
 
+#define RTL8152_REQT_READ	0xc0
+#define RTL8152_REQT_WRITE	0x40
+#define RTL8152_REQ_GET_REGS	0x05
+#define RTL8152_REQ_SET_REGS	0x05
+
+#define BYTE_EN_DWORD		0xff
+#define BYTE_EN_WORD		0x33
+#define BYTE_EN_BYTE		0x11
+#define BYTE_EN_SIX_BYTES	0x3f
+#define BYTE_EN_START_MASK	0x0f
+#define BYTE_EN_END_MASK	0xf0
+
 #define RTL8152_RMS		(VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)
 #define RTL8153_RMS		RTL8153_MAX_PACKET
 #define RTL8152_TX_TIMEOUT	(5 * HZ)
@@ -757,6 +791,8 @@ enum rtl_register_content {
 #define size_to_mtu(s)		((s) - VLAN_ETH_HLEN - ETH_FCS_LEN)
 #define rx_reserved_size(x)	(mtu_to_size(x) + sizeof(struct rx_desc) + RX_ALIGN)
 
+#define RTL_MAX_SG_NUM		64
+
 /* rtl8152 flags */
 enum rtl8152_flags {
 	RTL8152_UNPLUG = 0,
@@ -768,8 +804,21 @@ enum rtl8152_flags {
 	SCHEDULE_TASKLET,
 	GREEN_ETHERNET,
 	RX_EPROTO,
+	RECOVER_SPEED,
 };
 
+/* Define these values to match your device */
+#define VENDOR_ID_REALTEK		0x0bda
+#define VENDOR_ID_MICROSOFT		0x045e
+#define VENDOR_ID_SAMSUNG		0x04e8
+#define VENDOR_ID_LENOVO		0x17ef
+#define VENDOR_ID_LINKSYS		0x13b1
+#define VENDOR_ID_NVIDIA		0x0955
+#define VENDOR_ID_TPLINK		0x2357
+
+#define MCU_TYPE_PLA			0x0100
+#define MCU_TYPE_USB			0x0000
+
 #define DEVICE_ID_LENOVO_USB_C_TRAVEL_HUB		0x721e
 #define DEVICE_ID_THINKPAD_ONELINK_PLUS_DOCK		0x3054
 #define DEVICE_ID_THINKPAD_THUNDERBOLT3_DOCK_GEN2	0x3082
@@ -795,6 +844,7 @@ struct tally_counter {
 
 struct rx_desc {
 	__le32 opts1;
+#define RD_CRC				BIT(15)
 #define RX_LEN_MASK			0x7fff
 
 	__le32 opts2;
@@ -818,6 +868,7 @@ struct tx_desc {
 	__le32 opts1;
 #define TX_FS			BIT(31) /* First segment of a packet */
 #define TX_LS			BIT(30) /* Final segment of a packet */
+#define LGSEND			BIT(29)
 #define GTSENDV4		BIT(28)
 #define GTSENDV6		BIT(27)
 #define GTTCPHO_SHIFT		18
@@ -850,6 +901,7 @@ struct tx_agg {
 	struct list_head list;
 	struct urb *urb;
 	struct r8152 *context;
+	struct sk_buff_head tx_skb;
 	void *buffer;
 	void *head;
 	u32 skb_num;
@@ -871,9 +923,18 @@ struct r8152 {
 	struct delayed_work schedule, hw_phy_work;
 	struct mii_if_info mii;
 	struct mutex control;	/* use for hw setting */
-#ifdef CONFIG_PM_SLEEP
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+	struct vlan_group *vlgrp;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	struct net_device_stats stats;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP)
 	struct notifier_block pm_notifier;
 #endif
+#if defined(RTL8152_S5_WOL) && defined(CONFIG_PM)
+	struct notifier_block reboot_notifier;
+#endif /* defined(RTL8152_S5_WOL) && defined(CONFIG_PM) */
 	struct tasklet_struct tx_tl;
 
 	struct rtl_ops {
@@ -883,8 +944,10 @@ struct r8152 {
 		void (*up)(struct r8152 *tp);
 		void (*down)(struct r8152 *tp);
 		void (*unload)(struct r8152 *tp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
 		int (*eee_get)(struct r8152 *tp, struct ethtool_eee *eee);
 		int (*eee_set)(struct r8152 *tp, struct ethtool_eee *eee);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
 		bool (*in_nway)(struct r8152 *tp);
 		void (*hw_phy_cfg)(struct r8152 *tp);
 		void (*autosuspend_en)(struct r8152 *tp, bool enable);
@@ -909,19 +972,6 @@ struct r8152 {
 		u32 ctap_short_off:1;
 	} ups_info;
 
-#define RTL_VER_SIZE		32
-
-	struct rtl_fw {
-		const char *fw_name;
-		const struct firmware *fw;
-
-		char version[RTL_VER_SIZE];
-		int (*pre_fw)(struct r8152 *tp);
-		int (*post_fw)(struct r8152 *tp);
-
-		bool retry;
-	} rtl_fw;
-
 	atomic_t rx_count;
 
 	bool eee_en;
@@ -935,221 +985,26 @@ struct r8152 {
 	u32 rx_copybreak;
 	u32 rx_pending;
 	u32 fc_pause_on, fc_pause_off;
+	u32 rx_agg_free_ref;
 
 	unsigned int pipe_in, pipe_out, pipe_intr, pipe_ctrl_in, pipe_ctrl_out;
 
 	u32 support_2500full:1;
+	u32 sg_use:1;
+//	u32 dash_mode:1;
 	u32 lenovo_macpassthru:1;
-	u32 dell_tb_rx_agg_bug:1;
+	u32 dell_macpassthru:1;
+
 	u16 ocp_base;
 	u16 speed;
 	u16 eee_adv;
 	u8 *intr_buff;
 	u8 version;
+	u8 rtk_enable_diag;
 	u8 duplex;
 	u8 autoneg;
 };
 
-/**
- * struct fw_block - block type and total length
- * @type: type of the current block, such as RTL_FW_END, RTL_FW_PLA,
- *	RTL_FW_USB and so on.
- * @length: total length of the current block.
- */
-struct fw_block {
-	__le32 type;
-	__le32 length;
-} __packed;
-
-/**
- * struct fw_header - header of the firmware file
- * @checksum: checksum of sha256 which is calculated from the whole file
- *	except the checksum field of the file. That is, calculate sha256
- *	from the version field to the end of the file.
- * @version: version of this firmware.
- * @blocks: the first firmware block of the file
- */
-struct fw_header {
-	u8 checksum[32];
-	char version[RTL_VER_SIZE];
-	struct fw_block blocks[];
-} __packed;
-
-enum rtl8152_fw_flags {
-	FW_FLAGS_USB = 0,
-	FW_FLAGS_PLA,
-	FW_FLAGS_START,
-	FW_FLAGS_STOP,
-	FW_FLAGS_NC,
-	FW_FLAGS_NC1,
-	FW_FLAGS_NC2,
-	FW_FLAGS_UC2,
-	FW_FLAGS_UC,
-	FW_FLAGS_SPEED_UP,
-	FW_FLAGS_VER,
-};
-
-enum rtl8152_fw_fixup_cmd {
-	FW_FIXUP_AND = 0,
-	FW_FIXUP_OR,
-	FW_FIXUP_NOT,
-	FW_FIXUP_XOR,
-};
-
-struct fw_phy_set {
-	__le16 addr;
-	__le16 data;
-} __packed;
-
-struct fw_phy_speed_up {
-	struct fw_block blk_hdr;
-	__le16 fw_offset;
-	__le16 version;
-	__le16 fw_reg;
-	__le16 reserved;
-	char info[];
-} __packed;
-
-struct fw_phy_ver {
-	struct fw_block blk_hdr;
-	struct fw_phy_set ver;
-	__le32 reserved;
-} __packed;
-
-struct fw_phy_fixup {
-	struct fw_block blk_hdr;
-	struct fw_phy_set setting;
-	__le16 bit_cmd;
-	__le16 reserved;
-} __packed;
-
-struct fw_phy_union {
-	struct fw_block blk_hdr;
-	__le16 fw_offset;
-	__le16 fw_reg;
-	struct fw_phy_set pre_set[2];
-	struct fw_phy_set bp[8];
-	struct fw_phy_set bp_en;
-	u8 pre_num;
-	u8 bp_num;
-	char info[];
-} __packed;
-
-/**
- * struct fw_mac - a firmware block used by RTL_FW_PLA and RTL_FW_USB.
- *	The layout of the firmware block is:
- *	<struct fw_mac> + <info> + <firmware data>.
- * @blk_hdr: firmware descriptor (type, length)
- * @fw_offset: offset of the firmware binary data. The start address of
- *	the data would be the address of struct fw_mac + @fw_offset.
- * @fw_reg: the register to load the firmware. Depends on chip.
- * @bp_ba_addr: the register to write break point base address. Depends on
- *	chip.
- * @bp_ba_value: break point base address. Depends on chip.
- * @bp_en_addr: the register to write break point enabled mask. Depends
- *	on chip.
- * @bp_en_value: break point enabled mask. Depends on the firmware.
- * @bp_start: the start register of break points. Depends on chip.
- * @bp_num: the break point number which needs to be set for this firmware.
- *	Depends on the firmware.
- * @bp: break points. Depends on firmware.
- * @reserved: reserved space (unused)
- * @fw_ver_reg: the register to store the fw version.
- * @fw_ver_data: the firmware version of the current type.
- * @info: additional information for debugging, and is followed by the
- *	binary data of firmware.
- */
-struct fw_mac {
-	struct fw_block blk_hdr;
-	__le16 fw_offset;
-	__le16 fw_reg;
-	__le16 bp_ba_addr;
-	__le16 bp_ba_value;
-	__le16 bp_en_addr;
-	__le16 bp_en_value;
-	__le16 bp_start;
-	__le16 bp_num;
-	__le16 bp[16]; /* any value determined by firmware */
-	__le32 reserved;
-	__le16 fw_ver_reg;
-	u8 fw_ver_data;
-	char info[];
-} __packed;
-
-/**
- * struct fw_phy_patch_key - a firmware block used by RTL_FW_PHY_START.
- *	This is used to set patch key when loading the firmware of PHY.
- * @blk_hdr: firmware descriptor (type, length)
- * @key_reg: the register to write the patch key.
- * @key_data: patch key.
- * @reserved: reserved space (unused)
- */
-struct fw_phy_patch_key {
-	struct fw_block blk_hdr;
-	__le16 key_reg;
-	__le16 key_data;
-	__le32 reserved;
-} __packed;
-
-/**
- * struct fw_phy_nc - a firmware block used by RTL_FW_PHY_NC.
- *	The layout of the firmware block is:
- *	<struct fw_phy_nc> + <info> + <firmware data>.
- * @blk_hdr: firmware descriptor (type, length)
- * @fw_offset: offset of the firmware binary data. The start address of
- *	the data would be the address of struct fw_phy_nc + @fw_offset.
- * @fw_reg: the register to load the firmware. Depends on chip.
- * @ba_reg: the register to write the base address. Depends on chip.
- * @ba_data: base address. Depends on chip.
- * @patch_en_addr: the register of enabling patch mode. Depends on chip.
- * @patch_en_value: patch mode enabled mask. Depends on the firmware.
- * @mode_reg: the regitster of switching the mode.
- * @mode_pre: the mode needing to be set before loading the firmware.
- * @mode_post: the mode to be set when finishing to load the firmware.
- * @reserved: reserved space (unused)
- * @bp_start: the start register of break points. Depends on chip.
- * @bp_num: the break point number which needs to be set for this firmware.
- *	Depends on the firmware.
- * @bp: break points. Depends on firmware.
- * @info: additional information for debugging, and is followed by the
- *	binary data of firmware.
- */
-struct fw_phy_nc {
-	struct fw_block blk_hdr;
-	__le16 fw_offset;
-	__le16 fw_reg;
-	__le16 ba_reg;
-	__le16 ba_data;
-	__le16 patch_en_addr;
-	__le16 patch_en_value;
-	__le16 mode_reg;
-	__le16 mode_pre;
-	__le16 mode_post;
-	__le16 reserved;
-	__le16 bp_start;
-	__le16 bp_num;
-	__le16 bp[4];
-	char info[];
-} __packed;
-
-enum rtl_fw_type {
-	RTL_FW_END = 0,
-	RTL_FW_PLA,
-	RTL_FW_USB,
-	RTL_FW_PHY_START,
-	RTL_FW_PHY_STOP,
-	RTL_FW_PHY_NC,
-	RTL_FW_PHY_FIXUP,
-	RTL_FW_PHY_UNION_NC,
-	RTL_FW_PHY_UNION_NC1,
-	RTL_FW_PHY_UNION_NC2,
-	RTL_FW_PHY_UNION_UC2,
-	RTL_FW_PHY_UNION_UC,
-	RTL_FW_PHY_UNION_MISC,
-	RTL_FW_PHY_SPEED_UP,
-	RTL_FW_PHY_VER,
-};
-
 enum rtl_version {
 	RTL_VER_UNKNOWN = 0,
 	RTL_VER_01,
@@ -1215,6 +1070,9 @@ int get_registers(struct r8152 *tp, u16 value, u16 index, u16 size, void *data)
 
 	kfree(tmp);
 
+	if (ret < 0)
+		netif_err(tp, drv, tp->netdev, "get_registers %d\n", ret);
+
 	return ret;
 }
 
@@ -1234,6 +1092,9 @@ int set_registers(struct r8152 *tp, u16 value, u16 index, u16 size, void *data)
 
 	kfree(tmp);
 
+	if (ret < 0)
+		netif_err(tp, drv, tp->netdev, "set_registers %d\n", ret);
+
 	return ret;
 }
 
@@ -1309,16 +1170,24 @@ static int generic_ocp_write(struct r8152 *tp, u16 index, u16 byteen,
 	byteen_end = byteen & BYTE_EN_END_MASK;
 
 	byen = byteen_start | (byteen_start << 4);
-	ret = set_registers(tp, index, type | byen, 4, data);
-	if (ret < 0)
-		goto error1;
 
-	index += 4;
-	data += 4;
-	size -= 4;
+	/* Split the first DWORD if the byte_en is not 0xff */
+	if (byen != BYTE_EN_DWORD) {
+		ret = set_registers(tp, index, type | byen, 4, data);
+		if (ret < 0)
+			goto error1;
+
+		index += 4;
+		data += 4;
+		size -= 4;
+	}
 
 	if (size) {
-		size -= 4;
+		byen = byteen_end | (byteen_end >> 4);
+
+		/* Split the last DWORD if the byte_en is not 0xff */
+		if (byen != BYTE_EN_DWORD)
+			size -= 4;
 
 		while (size) {
 			if (size > limit) {
@@ -1345,10 +1214,9 @@ static int generic_ocp_write(struct r8152 *tp, u16 index, u16 byteen,
 			}
 		}
 
-		byen = byteen_end | (byteen_end >> 4);
-		ret = set_registers(tp, index, type | byen, 4, data);
-		if (ret < 0)
-			goto error1;
+		/* Set the last DWORD */
+		if (byen != BYTE_EN_DWORD)
+			ret = set_registers(tp, index, type | byen, 4, data);
 	}
 
 error1:
@@ -1370,6 +1238,12 @@ int pla_ocp_write(struct r8152 *tp, u16 index, u16 byteen, u16 size, void *data)
 	return generic_ocp_write(tp, index, byteen, size, data, MCU_TYPE_PLA);
 }
 
+static inline
+int usb_ocp_read(struct r8152 *tp, u16 index, u16 size, void *data)
+{
+	return generic_ocp_read(tp, index, size, data, MCU_TYPE_USB);
+}
+
 static inline
 int usb_ocp_write(struct r8152 *tp, u16 index, u16 byteen, u16 size, void *data)
 {
@@ -1523,7 +1397,7 @@ static u16 sram_read(struct r8152 *tp, u16 addr)
 static int read_mii_word(struct net_device *netdev, int phy_id, int reg)
 {
 	struct r8152 *tp = netdev_priv(netdev);
-	int ret;
+	int ret, lock;
 
 	if (test_bit(RTL8152_UNPLUG, &tp->flags))
 		return -ENODEV;
@@ -1531,8 +1405,15 @@ static int read_mii_word(struct net_device *netdev, int phy_id, int reg)
 	if (phy_id != R8152_PHY_ID)
 		return -EINVAL;
 
+	lock = mutex_trylock(&tp->control);
+
 	ret = r8152_mdio_read(tp, reg);
 
+	if (lock) {
+		mutex_unlock(&tp->control);
+		netif_warn(tp, drv, netdev, "miss mutex for read_mii_word?\n");
+	}
+
 	return ret;
 }
 
@@ -1540,6 +1421,7 @@ static
 void write_mii_word(struct net_device *netdev, int phy_id, int reg, int val)
 {
 	struct r8152 *tp = netdev_priv(netdev);
+	int lock;
 
 	if (test_bit(RTL8152_UNPLUG, &tp->flags))
 		return;
@@ -1547,7 +1429,14 @@ void write_mii_word(struct net_device *netdev, int phy_id, int reg, int val)
 	if (phy_id != R8152_PHY_ID)
 		return;
 
+	lock = mutex_trylock(&tp->control);
+
 	r8152_mdio_write(tp, reg, val);
+
+	if (lock) {
+		mutex_unlock(&tp->control);
+		netif_warn(tp, drv, netdev, "miss mutex for write_mii_word?\n");
+	}
 }
 
 static int
@@ -1564,6 +1453,9 @@ static int __rtl8152_set_mac_address(struct net_device *netdev, void *p,
 	struct sockaddr *addr = p;
 	int ret = -EADDRNOTAVAIL;
 
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
 	if (!is_valid_ether_addr(addr->sa_data))
 		goto out1;
 
@@ -1594,51 +1486,15 @@ static int rtl8152_set_mac_address(struct net_device *netdev, void *p)
 	return __rtl8152_set_mac_address(netdev, p, false);
 }
 
-/* Devices containing proper chips can support a persistent
- * host system provided MAC address.
- * Examples of this are Dell TB15 and Dell WD15 docks
- */
-static int vendor_mac_passthru_addr_read(struct r8152 *tp, struct sockaddr *sa)
+static int rtl_mapt_read(struct r8152 *tp, char *mac_obj_name,
+			 acpi_object_type mac_obj_type, int mac_strlen,
+			 struct sockaddr *sa)
 {
-	acpi_status status;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *obj;
-	int ret = -EINVAL;
-	u32 ocp_data;
 	unsigned char buf[6];
-	char *mac_obj_name;
-	acpi_object_type mac_obj_type;
-	int mac_strlen;
-
-	if (tp->lenovo_macpassthru) {
-		mac_obj_name = "\\MACA";
-		mac_obj_type = ACPI_TYPE_STRING;
-		mac_strlen = 0x16;
-	} else {
-		/* test for -AD variant of RTL8153 */
-		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);
-		if ((ocp_data & AD_MASK) == 0x1000) {
-			/* test for MAC address pass-through bit */
-			ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, EFUSE);
-			if ((ocp_data & PASS_THRU_MASK) != 1) {
-				netif_dbg(tp, probe, tp->netdev,
-						"No efuse for RTL8153-AD MAC pass through\n");
-				return -ENODEV;
-			}
-		} else {
-			/* test for RTL8153-BND and RTL8153-BD */
-			ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_1);
-			if ((ocp_data & BND_MASK) == 0 && (ocp_data & BD_MASK) == 0) {
-				netif_dbg(tp, probe, tp->netdev,
-						"Invalid variant for MAC pass through\n");
-				return -ENODEV;
-			}
-		}
-
-		mac_obj_name = "\\_SB.AMAC";
-		mac_obj_type = ACPI_TYPE_BUFFER;
-		mac_strlen = 0x17;
-	}
+	acpi_status status;
+	int ret = -EINVAL;
 
 	/* returns _AUXMAC_#AABBCCDDEEFF# */
 	status = acpi_evaluate_object(NULL, mac_obj_name, NULL, &buffer);
@@ -1658,7 +1514,8 @@ static int vendor_mac_passthru_addr_read(struct r8152 *tp, struct sockaddr *sa)
 			   "Invalid header when reading pass-thru MAC addr\n");
 		goto amacout;
 	}
-	ret = hex2bin(buf, obj->string.pointer + 9, 6);
+
+	ret = hex2bin(buf, obj->string.pointer + 9, sizeof(buf));
 	if (!(ret == 0 && is_valid_ether_addr(buf))) {
 		netif_warn(tp, probe, tp->netdev,
 			   "Invalid MAC for pass-thru MAC addr: %d, %pM\n",
@@ -1666,7 +1523,8 @@ static int vendor_mac_passthru_addr_read(struct r8152 *tp, struct sockaddr *sa)
 		ret = -EINVAL;
 		goto amacout;
 	}
-	memcpy(sa->sa_data, buf, 6);
+
+	memcpy(sa->sa_data, buf, sizeof(buf));
 	netif_info(tp, probe, tp->netdev,
 		   "Using pass-thru MAC addr %pM\n", sa->sa_data);
 
@@ -1675,6 +1533,59 @@ static int vendor_mac_passthru_addr_read(struct r8152 *tp, struct sockaddr *sa)
 	return ret;
 }
 
+/* Devices containing proper chips can support a persistent
+ * host system provided MAC address.
+ * Examples of this are Dell TB15 and Dell WD15 docks
+ */
+static int vendor_mac_passthru_addr_read(struct r8152 *tp, struct sockaddr *sa)
+{
+	int ret = -EOPNOTSUPP;
+
+	if (tp->dell_macpassthru)
+		ret = rtl_mapt_read(tp, "\\_SB.AMAC", ACPI_TYPE_BUFFER, 0x17,
+				    sa);
+	else if (tp->lenovo_macpassthru)
+		ret = rtl_mapt_read(tp, "\\MACA", ACPI_TYPE_STRING, 0x16, sa);
+
+	return ret;
+}
+
+static int rtl_hw_ether_addr(struct r8152 *tp, struct sockaddr *sa)
+{
+	u32 ocp_data = 0;
+	int ret;
+
+	if (tp->version == RTL_VER_05) {
+		/* Determine the hardware default ethernet address.
+		 * Check USB 0xcf0e bit 0
+		 *  1: read from USB 0xcf08
+		 *  0: read from PLA_BACKUP
+		 */
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, 0xcf0e);
+
+		if (ocp_data & BIT(0))
+			return usb_ocp_read(tp, 0xcf08, 8, sa->sa_data);
+
+		ocp_data |= BIT(0);
+	}
+
+	ret = pla_ocp_read(tp, PLA_BACKUP, 8, sa->sa_data);
+	if (ret < 0)
+		goto out;
+
+	if (tp->version == RTL_VER_05) {
+		/* Backup default ethernet address to USB 0xcf08.
+		 * Set USB 0xcf0e bit 0 to 1. Then, next time, read the default
+		 * ethernet address from USB 0xcf08 rather than PLA_BACKUP.
+		 */
+		usb_ocp_write(tp, 0xcf08, BYTE_EN_SIX_BYTES, 8, sa->sa_data);
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xcf0e, ocp_data);
+	}
+
+out:
+	return ret;
+}
+
 static int determine_ethernet_addr(struct r8152 *tp, struct sockaddr *sa)
 {
 	struct net_device *dev = tp->netdev;
@@ -1692,8 +1603,7 @@ static int determine_ethernet_addr(struct r8152 *tp, struct sockaddr *sa)
 			 */
 			ret = vendor_mac_passthru_addr_read(tp, sa);
 			if (ret < 0)
-				ret = pla_ocp_read(tp, PLA_BACKUP, 8,
-						   sa->sa_data);
+				ret = rtl_hw_ether_addr(tp, sa);
 		}
 	}
 
@@ -1730,6 +1640,17 @@ static int set_ethernet_addr(struct r8152 *tp, bool in_resume)
 	return ret;
 }
 
+static inline struct net_device_stats *rtl8152_get_stats(struct net_device *dev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	struct rtl8152 *tp = netdev_priv(dev);
+
+	return (struct net_device_stats *)&tp->stats;
+#else
+	return &dev->stats;
+#endif
+}
+
 static void read_bulk_callback(struct urb *urb)
 {
 	struct net_device *netdev;
@@ -1787,11 +1708,13 @@ static void read_bulk_callback(struct urb *urb)
 		return;	/* the urb is in unlink state */
 	case -ETIME:
 		if (net_ratelimit())
-			netdev_warn(netdev, "maybe reset is needed?\n");
+			netif_warn(tp, rx_err, netdev,
+				   "maybe reset is needed?\n");
 		break;
 	default:
 		if (net_ratelimit())
-			netdev_warn(netdev, "Rx status %d\n", status);
+			netif_warn(tp, rx_err, netdev,
+				   "Rx status %d\n", status);
 		break;
 	}
 
@@ -1816,10 +1739,11 @@ static void write_bulk_callback(struct urb *urb)
 		return;
 
 	netdev = tp->netdev;
-	stats = &netdev->stats;
+	stats = rtl8152_get_stats(netdev);
 	if (status) {
 		if (net_ratelimit())
-			netdev_warn(netdev, "Tx status %d\n", status);
+			netif_warn(tp, tx_err, netdev,
+				   "Tx status %d\n", status);
 		stats->tx_errors += agg->skb_num;
 	} else {
 		stats->tx_packets += agg->skb_num;
@@ -1845,6 +1769,59 @@ static void write_bulk_callback(struct urb *urb)
 		tasklet_schedule(&tp->tx_tl);
 }
 
+static void write_bulk_sg_callback(struct urb *urb)
+{
+	struct net_device *netdev;
+	struct tx_agg *agg;
+	struct r8152 *tp;
+	unsigned long flags;
+	int status = urb->status;
+
+	agg = urb->context;
+	if (!agg)
+		return;
+
+	tp = agg->context;
+	if (!tp)
+		return;
+
+	netdev = tp->netdev;
+	if (status && net_ratelimit())
+		netif_warn(tp, tx_err, netdev, "Tx status %d\n", status);
+
+	while (!skb_queue_empty(&agg->tx_skb)) {
+		struct sk_buff *skb = __skb_dequeue(&agg->tx_skb);
+		struct net_device_stats *stats = rtl8152_get_stats(netdev);
+
+		if (status) {
+			stats->tx_errors += skb_shinfo(skb)->gso_segs ?: 1;
+			dev_kfree_skb_any(skb);
+		} else {
+			stats->tx_packets += skb_shinfo(skb)->gso_segs ?: 1;
+			stats->tx_bytes += skb->len - skb->cb[0];
+			dev_consume_skb_any(skb);
+		}
+	}
+
+	spin_lock_irqsave(&tp->tx_lock, flags);
+	list_add_tail(&agg->list, &tp->tx_free);
+	spin_unlock_irqrestore(&tp->tx_lock, flags);
+
+	usb_autopm_put_interface_async(tp->intf);
+
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		return;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (!skb_queue_empty(&tp->tx_queue))
+		tasklet_schedule(&tp->tx_tl);
+}
+
 static void intr_callback(struct urb *urb)
 {
 	struct r8152 *tp;
@@ -1943,7 +1920,7 @@ static struct rx_agg *alloc_rx_agg(struct r8152 *tp, gfp_t mflags)
 	if (!rx_agg)
 		return NULL;
 
-	rx_agg->page = alloc_pages(mflags | __GFP_COMP, order);
+	rx_agg->page = alloc_pages(mflags | __GFP_COMP | __GFP_NOWARN, order);
 	if (!rx_agg->page)
 		goto free_rx;
 
@@ -2056,6 +2033,7 @@ static int alloc_all_mem(struct r8152 *tp)
 		tp->tx_info[i].head = tx_agg_align(buf);
 
 		list_add_tail(&tp->tx_info[i].list, &tp->tx_free);
+		skb_queue_head_init(&tp->tx_info[i].tx_skb);
 	}
 
 	tp->intr_urb = usb_alloc_urb(0, GFP_KERNEL);
@@ -2134,7 +2112,7 @@ static void r8152_csum_workaround(struct r8152 *tp, struct sk_buff *skb,
 		struct net_device_stats *stats;
 
 drop:
-		stats = &tp->netdev->stats;
+		stats = rtl8152_get_stats(tp->netdev);
 		stats->tx_dropped++;
 		dev_kfree_skb(skb);
 	}
@@ -2150,15 +2128,62 @@ static inline void rtl_tx_vlan_tag(struct tx_desc *desc, struct sk_buff *skb)
 	}
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+static inline bool
+rtl_rx_vlan_tag(struct r8152 *tp, struct rx_desc *desc, struct sk_buff *skb)
+{
+	u32 opts2 = le32_to_cpu(desc->opts2);
+
+	if (tp->vlgrp && (opts2 & RX_VLAN_TAG)) {
+		vlan_gro_receive(&tp->napi, tp->vlgrp, swab16(opts2 & 0xffff),
+				 skb);
+		return true;
+	}
+
+	return false;
+}
+
+static inline void
+rtl_vlan_put_tag(struct r8152 *tp, struct rx_desc *desc, struct sk_buff *skb)
+{
+	u32 opts2 = le32_to_cpu(desc->opts2);
+
+	if (tp->vlgrp && (opts2 & RX_VLAN_TAG))
+		__vlan_hwaccel_put_tag(skb, swab16(opts2 & 0xffff));
+}
+
+static inline __u16
+rtl_vlan_get_tag(struct sk_buff *skb)
+{
+	__u16 tag;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+	__vlan_hwaccel_get_tag(skb, &tag);
+#else
+	tag = skb->vlan_tci;
+#endif
+
+	return tag;
+}
+
+#else
+
 static inline void rtl_rx_vlan_tag(struct rx_desc *desc, struct sk_buff *skb)
 {
 	u32 opts2 = le32_to_cpu(desc->opts2);
 
 	if (opts2 & RX_VLAN_TAG)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+		__vlan_hwaccel_put_tag(skb, swab16(opts2 & 0xffff));
+#else
 		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
 				       swab16(opts2 & 0xffff));
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) */
 }
 
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
+
 static int r8152_tx_csum(struct r8152 *tp, struct tx_desc *desc,
 			 struct sk_buff *skb, u32 len)
 {
@@ -2305,12 +2330,9 @@ static int r8152_tx_agg_fill(struct r8152 *tp, struct tx_agg *agg)
 		agg->skb_len += len;
 		agg->skb_num += skb_shinfo(skb)->gso_segs ?: 1;
 
-		dev_kfree_skb_any(skb);
+		dev_consume_skb_any(skb);
 
 		remain = agg_buf_sz - (int)(tx_agg_align(tx_data) - agg->head);
-
-		if (tp->dell_tb_rx_agg_bug)
-			break;
 	}
 
 	if (!skb_queue_empty(&skb_head)) {
@@ -2335,6 +2357,9 @@ static int r8152_tx_agg_fill(struct r8152 *tp, struct tx_agg *agg)
 			  agg->head, (int)(tx_data - (u8 *)agg->head),
 			  (usb_complete_t)write_bulk_callback, agg);
 
+	agg->urb->sg = NULL;
+	agg->urb->num_sgs = 0;
+
 	ret = usb_submit_urb(agg->urb, GFP_ATOMIC);
 	if (ret < 0)
 		usb_autopm_put_interface_async(tp->intf);
@@ -2343,71 +2368,216 @@ static int r8152_tx_agg_fill(struct r8152 *tp, struct tx_agg *agg)
 	return ret;
 }
 
-static u8 r8152_rx_csum(struct r8152 *tp, struct rx_desc *rx_desc)
+static int r8152_tx_agg_sg_fill(struct r8152 *tp, struct tx_agg *agg)
 {
-	u8 checksum = CHECKSUM_NONE;
-	u32 opts2, opts3;
-
-	if (!(tp->netdev->features & NETIF_F_RXCSUM))
-		goto return_result;
+	struct sk_buff_head skb_head, *tx_queue = &tp->tx_queue;
+	int max_sg_num, ret, sg_num;
+	struct scatterlist *sg;
+	int padding = 0;
 
-	opts2 = le32_to_cpu(rx_desc->opts2);
-	opts3 = le32_to_cpu(rx_desc->opts3);
+	__skb_queue_head_init(&skb_head);
+	spin_lock(&tx_queue->lock);
+	skb_queue_splice_init(tx_queue, &skb_head);
+	spin_unlock(&tx_queue->lock);
 
-	if (opts2 & RD_IPV4_CS) {
-		if (opts3 & IPF)
-			checksum = CHECKSUM_NONE;
-		else if ((opts2 & RD_UDP_CS) && !(opts3 & UDPF))
-			checksum = CHECKSUM_UNNECESSARY;
-		else if ((opts2 & RD_TCP_CS) && !(opts3 & TCPF))
-			checksum = CHECKSUM_UNNECESSARY;
-	} else if (opts2 & RD_IPV6_CS) {
-		if ((opts2 & RD_UDP_CS) && !(opts3 & UDPF))
-			checksum = CHECKSUM_UNNECESSARY;
-		else if ((opts2 & RD_TCP_CS) && !(opts3 & TCPF))
-			checksum = CHECKSUM_UNNECESSARY;
-	}
+	sg = agg->head;
+	max_sg_num = (agg_buf_sz / sizeof(*sg)) - 1;
+	max_sg_num = min_t(int, RTL_MAX_SG_NUM, max_sg_num);
+	sg_init_table(sg, max_sg_num + 1);
+	agg->skb_num = 0;
+	agg->skb_len = 0;
 
-return_result:
-	return checksum;
-}
+	for (sg_num = 0; sg_num < max_sg_num;) {
+		struct tx_desc tx_desc;
+		struct sk_buff *skb;
+		int num_sgs, headroom;
+		unsigned int len;
 
-static inline bool rx_count_exceed(struct r8152 *tp)
-{
-	return atomic_read(&tp->rx_count) > RTL8152_MAX_RX;
-}
+		skb = __skb_dequeue(&skb_head);
+		if (!skb)
+			break;
 
-static inline int agg_offset(struct rx_agg *agg, void *addr)
-{
-	return (int)(addr - agg->buffer);
-}
+		headroom = skb_headroom(skb) - padding - sizeof(tx_desc);
 
-static struct rx_agg *rtl_get_free_rx(struct r8152 *tp, gfp_t mflags)
-{
-	struct rx_agg *agg, *agg_next, *agg_free = NULL;
-	unsigned long flags;
+		if (skb_header_cloned(skb) || headroom < 0) {
+			struct sk_buff *tx_skb;
 
-	spin_lock_irqsave(&tp->rx_lock, flags);
+			headroom = padding + sizeof(tx_desc);
+			tx_skb = skb_copy_expand(skb, headroom, 0, GFP_ATOMIC);
+			dev_kfree_skb_any(skb);
+			if (!tx_skb) {
+				struct net_device_stats *stats;
 
-	list_for_each_entry_safe(agg, agg_next, &tp->rx_used, list) {
-		if (page_count(agg->page) == 1) {
-			if (!agg_free) {
-				list_del_init(&agg->list);
-				agg_free = agg;
-				continue;
-			}
-			if (rx_count_exceed(tp)) {
-				list_del_init(&agg->list);
-				free_rx_agg(tp, agg);
+				stats = rtl8152_get_stats(tp->netdev);
+				stats->tx_dropped++;
+				netif_wake_queue(tp->netdev);
+				return NETDEV_TX_OK;
 			}
-			break;
+			skb = tx_skb;
+			headroom = skb_headroom(skb) - headroom;
 		}
-	}
 
-	spin_unlock_irqrestore(&tp->rx_lock, flags);
-
-	if (!agg_free && atomic_read(&tp->rx_count) < tp->rx_pending)
-		agg_free = alloc_rx_agg(tp, mflags);
+		 /* calculate the fragment numbers for skb */
+		num_sgs = 1 + skb_shinfo(skb)->nr_frags;
+		len = skb->len;
+
+		if ((num_sgs + sg_num) > max_sg_num) {
+			__skb_queue_head(&skb_head, skb);
+			break;
+		}
+
+		if (r8152_tx_csum(tp, &tx_desc, skb, len)) {
+			r8152_csum_workaround(tp, skb, &skb_head);
+			continue;
+		}
+
+		rtl_tx_vlan_tag(&tx_desc, skb);
+
+		WARN_ON(padding < 0);
+
+		/* use skb_headroom for tx desc */
+		skb->cb[0] = padding + sizeof(tx_desc);
+		memcpy(skb_push(skb, sizeof(tx_desc)), &tx_desc,
+		       sizeof(tx_desc));
+		if (padding)
+			memset(skb_push(skb, padding), 0, padding);
+
+		num_sgs = skb_to_sgvec_nomark(skb, sg, 0, skb->len);
+		if (num_sgs < 0) {
+			netif_err(tp, tx_err, tp->netdev,
+				  "skb_to_sgvec fail %d\n", num_sgs);
+			__skb_queue_head(&skb_head, skb);
+			break;
+		}
+
+		sg += num_sgs;
+
+		__skb_queue_tail(&agg->tx_skb, skb);
+
+		sg_num += num_sgs;
+		agg->skb_len += skb->len;
+		padding = len + sizeof(tx_desc);
+
+		agg->skb_num++;
+
+		padding = ALIGN(padding, TX_ALIGN) - padding;
+	}
+
+	sg_mark_end(sg);
+
+	if (!skb_queue_empty(&skb_head)) {
+		spin_lock(&tx_queue->lock);
+		skb_queue_splice(&skb_head, tx_queue);
+		spin_unlock(&tx_queue->lock);
+	}
+
+	netif_tx_lock(tp->netdev);
+
+	if (netif_queue_stopped(tp->netdev) &&
+	    skb_queue_len(&tp->tx_queue) < tp->tx_qlen)
+		netif_wake_queue(tp->netdev);
+
+	netif_tx_unlock(tp->netdev);
+
+	if (sg_num == 0) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&tp->tx_lock, flags);
+		list_add_tail(&agg->list, &tp->tx_free);
+		spin_unlock_irqrestore(&tp->tx_lock, flags);
+
+		ret = 0;
+		goto out_tx_fill;
+	}
+
+	ret = usb_autopm_get_interface_async(tp->intf);
+	if (ret < 0)
+		goto out_tx_fill;
+
+	usb_fill_bulk_urb(agg->urb, tp->udev, tp->pipe_out,
+			  NULL, (int)agg->skb_len,
+			  (usb_complete_t)write_bulk_sg_callback, agg);
+
+	agg->urb->sg = agg->head;
+	agg->urb->num_sgs = sg_num;
+
+	ret = usb_submit_urb(agg->urb, GFP_ATOMIC);
+	if (ret < 0)
+		usb_autopm_put_interface_async(tp->intf);
+
+out_tx_fill:
+	return ret;
+}
+
+static u8 r8152_rx_csum(struct r8152 *tp, struct rx_desc *rx_desc)
+{
+	u8 checksum = CHECKSUM_NONE;
+	u32 opts2, opts3;
+
+	if (!(tp->netdev->features & NETIF_F_RXCSUM))
+		goto return_result;
+
+	opts2 = le32_to_cpu(rx_desc->opts2);
+	opts3 = le32_to_cpu(rx_desc->opts3);
+
+	if (opts2 & RD_IPV4_CS) {
+		if (opts3 & IPF)
+			checksum = CHECKSUM_NONE;
+		else if ((opts2 & RD_UDP_CS) && !(opts3 & UDPF))
+			checksum = CHECKSUM_UNNECESSARY;
+		else if ((opts2 & RD_TCP_CS) && !(opts3 & TCPF))
+			checksum = CHECKSUM_UNNECESSARY;
+	} else if (opts2 & RD_IPV6_CS) {
+		if ((opts2 & RD_UDP_CS) && !(opts3 & UDPF))
+			checksum = CHECKSUM_UNNECESSARY;
+		else if ((opts2 & RD_TCP_CS) && !(opts3 & TCPF))
+			checksum = CHECKSUM_UNNECESSARY;
+	}
+
+return_result:
+	return checksum;
+}
+
+static inline bool rx_count_exceed(struct r8152 *tp)
+{
+	return atomic_read(&tp->rx_count) > RTL8152_MAX_RX;
+}
+
+static inline int agg_offset(struct rx_agg *agg, void *addr)
+{
+	return (int)(addr - agg->buffer);
+}
+
+static struct rx_agg *rtl_get_free_rx(struct r8152 *tp, gfp_t mflags)
+{
+	struct rx_agg *agg, *agg_next, *agg_free = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&tp->rx_lock, flags);
+
+	list_for_each_entry_safe(agg, agg_next, &tp->rx_used, list) {
+		if (page_count(agg->page) == 1) {
+			if (!agg_free) {
+				list_del_init(&agg->list);
+				agg_free = agg;
+				continue;
+			}
+			if (tp->rx_agg_free_ref) {
+				tp->rx_agg_free_ref--;
+			} else if (rx_count_exceed(tp)) {
+				list_del_init(&agg->list);
+				free_rx_agg(tp, agg);
+			}
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&tp->rx_lock, flags);
+
+	if (!agg_free && atomic_read(&tp->rx_count) < tp->rx_pending) {
+		agg_free = alloc_rx_agg(tp, mflags);
+		tp->rx_agg_free_ref += RTL8152_MAX_RX;
+	}
 
 	return agg_free;
 }
@@ -2423,15 +2593,34 @@ static int rx_bottom(struct r8152 *tp, int budget)
 		while (work_done < budget) {
 			struct sk_buff *skb = __skb_dequeue(&tp->rx_queue);
 			struct net_device *netdev = tp->netdev;
-			struct net_device_stats *stats = &netdev->stats;
+			struct net_device_stats *stats;
 			unsigned int pkt_len;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+			u16 vlan_tci;
+#endif
 
 			if (!skb)
 				break;
 
 			pkt_len = skb->len;
+			stats = rtl8152_get_stats(netdev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+			vlan_tci = rtl_vlan_get_tag(skb);
+
+			if (vlan_tci)
+				vlan_gro_receive(napi, tp->vlgrp, vlan_tci,
+						 skb);
+			else
+				napi_gro_receive(napi, skb);
+#else
 			napi_gro_receive(napi, skb);
+#endif
+
 			work_done++;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+			netdev->last_rx = jiffies;
+#endif
 			stats->rx_packets++;
 			stats->rx_bytes += pkt_len;
 		}
@@ -2468,7 +2657,7 @@ static int rx_bottom(struct r8152 *tp, int budget)
 
 		while (urb->actual_length > len_used) {
 			struct net_device *netdev = tp->netdev;
-			struct net_device_stats *stats = &netdev->stats;
+			struct net_device_stats *stats;
 			unsigned int pkt_len, rx_frag_head_sz;
 			struct sk_buff *skb;
 
@@ -2484,6 +2673,8 @@ static int rx_bottom(struct r8152 *tp, int budget)
 			if (urb->actual_length < len_used)
 				break;
 
+			stats = rtl8152_get_stats(netdev);
+
 			pkt_len -= ETH_FCS_LEN;
 			rx_data += sizeof(struct rx_desc);
 
@@ -2511,7 +2702,26 @@ static int rx_bottom(struct r8152 *tp, int budget)
 				get_page(agg->page);
 			}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+			skb->dev = netdev;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) */
 			skb->protocol = eth_type_trans(skb, netdev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+			if (work_done < budget) {
+				if (!rtl_rx_vlan_tag(tp, rx_desc, skb))
+					napi_gro_receive(napi, skb);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+				netdev->last_rx = jiffies;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29) */
+				work_done++;
+				stats->rx_packets++;
+				stats->rx_bytes += skb->len;
+			} else {
+				rtl_vlan_put_tag(tp, rx_desc, skb);
+				__skb_queue_tail(&tp->rx_queue, skb);
+			}
+#else
 			rtl_rx_vlan_tag(rx_desc, skb);
 			if (work_done < budget) {
 				work_done++;
@@ -2521,6 +2731,7 @@ static int rx_bottom(struct r8152 *tp, int budget)
 			} else {
 				__skb_queue_tail(&tp->rx_queue, skb);
 			}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
 
 find_next_rx:
 			rx_data = rx_agg_align(rx_data + pkt_len + ETH_FCS_LEN);
@@ -2577,7 +2788,11 @@ static void tx_bottom(struct r8152 *tp)
 		if (!agg)
 			break;
 
-		res = r8152_tx_agg_fill(tp, agg);
+		if (tp->sg_use)
+			res = r8152_tx_agg_sg_fill(tp, agg);
+		else
+			res = r8152_tx_agg_fill(tp, agg);
+
 		if (!res)
 			continue;
 
@@ -2599,7 +2814,11 @@ static void tx_bottom(struct r8152 *tp)
 	} while (res == 0);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
+static void bottom_half(unsigned long t)
+#else
 static void bottom_half(struct tasklet_struct *t)
+#endif
 {
 	struct r8152 *tp = from_tasklet(tp, t, tx_tl);
 
@@ -2619,24 +2838,57 @@ static void bottom_half(struct tasklet_struct *t)
 	tx_bottom(tp);
 }
 
-static int r8152_poll(struct napi_struct *napi, int budget)
+static inline int __r8152_poll(struct r8152 *tp, int budget)
 {
-	struct r8152 *tp = container_of(napi, struct r8152, napi);
+	struct napi_struct *napi = &tp->napi;
 	int work_done;
 
 	work_done = rx_bottom(tp, budget);
 
 	if (work_done < budget) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+		napi_complete_done(napi, work_done);
+#else
 		if (!napi_complete_done(napi, work_done))
 			goto out;
+#endif
 		if (!list_empty(&tp->rx_done))
 			napi_schedule(napi);
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
 out:
+#endif
 	return work_done;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+
+static int r8152_poll(struct net_device *dev, int *budget)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	int quota = min(dev->quota, *budget);
+	int work_done;
+
+	work_done = __r8152_poll(tp, quota);
+
+	*budget -= work_done;
+	dev->quota -= work_done;
+
+	return (work_done >= quota);
+}
+
+#else
+
+static int r8152_poll(struct napi_struct *napi, int budget)
+{
+	struct r8152 *tp = container_of(napi, struct r8152, napi);
+
+	return __r8152_poll(tp, budget);
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24) */
+
 static
 int r8152_submit_rx(struct r8152 *tp, struct rx_agg *agg, gfp_t mem_flags)
 {
@@ -2675,7 +2927,7 @@ int r8152_submit_rx(struct r8152 *tp, struct rx_agg *agg, gfp_t mem_flags)
 
 static void rtl_drop_queued_tx(struct r8152 *tp)
 {
-	struct net_device_stats *stats = &tp->netdev->stats;
+	struct net_device_stats *stats = rtl8152_get_stats(tp->netdev);
 	struct sk_buff_head skb_head, *tx_queue = &tp->tx_queue;
 	struct sk_buff *skb;
 
@@ -2693,32 +2945,47 @@ static void rtl_drop_queued_tx(struct r8152 *tp)
 	}
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0)
+static void rtl8152_tx_timeout(struct net_device *netdev)
+#else
 static void rtl8152_tx_timeout(struct net_device *netdev, unsigned int txqueue)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0) */
 {
 	struct r8152 *tp = netdev_priv(netdev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	int i;
+#endif
 
 	netif_warn(tp, tx_err, netdev, "Tx timeout\n");
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	for (i = 0; i < RTL8152_MAX_TX; i++)
+		usb_unlink_urb(tp->tx_info[i].urb);
+#else
 	usb_queue_reset_device(tp->intf);
+#endif
 }
 
 static void rtl8152_set_rx_mode(struct net_device *netdev)
-{
-	struct r8152 *tp = netdev_priv(netdev);
-
-	if (netif_carrier_ok(netdev)) {
-		set_bit(RTL8152_SET_RX_MODE, &tp->flags);
-		schedule_delayed_work(&tp->schedule, 0);
-	}
-}
-
-static void _rtl8152_set_rx_mode(struct net_device *netdev)
 {
 	struct r8152 *tp = netdev_priv(netdev);
 	u32 mc_filter[2];	/* Multicast hash filter */
 	__le32 tmp[2];
 	u32 ocp_data;
 
+	if (in_atomic()) {
+		if (netif_carrier_ok(netdev)) {
+			set_bit(RTL8152_SET_RX_MODE, &tp->flags);
+			schedule_delayed_work(&tp->schedule, 0);
+		}
+		return;
+	}
+
+	clear_bit(RTL8152_SET_RX_MODE, &tp->flags);
+
+	if (!netif_carrier_ok(netdev))
+		return;
+
 	netif_stop_queue(netdev);
 	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
 	ocp_data &= ~RCR_ACPT_ALL;
@@ -2738,6 +3005,21 @@ static void _rtl8152_set_rx_mode(struct net_device *netdev)
 		mc_filter[1] = 0xffffffff;
 		mc_filter[0] = 0xffffffff;
 	} else {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+		struct dev_mc_list *mclist;
+		unsigned int i;
+
+		mc_filter[1] = mc_filter[0] = 0;
+		for (i = 0, mclist = netdev->mc_list;
+		     mclist && i < netdev->mc_count;
+		     i++, mclist = mclist->next) {
+			int bit_nr;
+
+			bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+			ocp_data |= RCR_AM;
+		}
+#else
 		mc_filter[1] = 0;
 		mc_filter[0] = 0;
 
@@ -2751,6 +3033,7 @@ static void _rtl8152_set_rx_mode(struct net_device *netdev)
 				ocp_data |= RCR_AM;
 			}
 		}
+#endif
 	}
 
 	tmp[0] = __cpu_to_le32(swab32(mc_filter[1]));
@@ -2761,6 +3044,20 @@ static void _rtl8152_set_rx_mode(struct net_device *netdev)
 	netif_wake_queue(netdev);
 }
 
+static inline bool rtl_gso_check(struct net_device *dev, struct sk_buff *skb)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	if (tp->sg_use)
+		return true;
+	else if ((skb->len + sizeof(struct tx_desc)) <= agg_buf_sz)
+		return true;
+	else
+		return false;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,4)
+
 static netdev_features_t
 rtl8152_features_check(struct sk_buff *skb, struct net_device *dev,
 		       netdev_features_t features)
@@ -2771,17 +3068,45 @@ rtl8152_features_check(struct sk_buff *skb, struct net_device *dev,
 	if ((mss || skb->ip_summed == CHECKSUM_PARTIAL) &&
 	    skb_transport_offset(skb) > max_offset)
 		features &= ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);
-	else if ((skb->len + sizeof(struct tx_desc)) > agg_buf_sz)
+	else if (!rtl_gso_check(dev, skb))
 		features &= ~NETIF_F_GSO_MASK;
 
 	return features;
 }
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,4) */
 
 static netdev_tx_t rtl8152_start_xmit(struct sk_buff *skb,
 				      struct net_device *netdev)
 {
 	struct r8152 *tp = netdev_priv(netdev);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,18,4)
+	if (unlikely(!rtl_gso_check(netdev, skb))) {
+		netdev_features_t features = netdev->features;
+		struct sk_buff *segs, *nskb;
+
+		features &= ~(NETIF_F_TSO | NETIF_F_TSO6);
+		segs = skb_gso_segment(skb, features);
+		if (IS_ERR(segs) || !segs)
+			goto free_skb;
+
+		do {
+			nskb = segs;
+			segs = segs->next;
+			nskb->next = NULL;
+			rtl8152_start_xmit(nskb, netdev);
+		} while (segs);
+
+free_skb:
+		dev_kfree_skb_any(skb);
+
+		return NETDEV_TX_OK;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+	netdev->trans_start = jiffies
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,18,4) */
+
 	skb_tx_timestamp(skb);
 
 	skb_queue_tail(&tp->tx_queue, skb);
@@ -2860,7 +3185,10 @@ static void rtl8152_nic_reset(struct r8152 *tp)
 
 static void set_tx_qlen(struct r8152 *tp)
 {
-	tp->tx_qlen = agg_buf_sz / (mtu_to_size(tp->netdev->mtu) + sizeof(struct tx_desc));
+	if (tp->sg_use)
+		tp->tx_qlen = RTL_MAX_SG_NUM;
+	else
+		tp->tx_qlen = agg_buf_sz / (mtu_to_size(tp->netdev->mtu) + sizeof(struct tx_desc));
 }
 
 static inline u16 rtl8152_get_speed(struct r8152 *tp)
@@ -3023,12 +3351,16 @@ static int rtl_enable(struct r8152 *tp)
 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, ocp_data);
 
 	switch (tp->version) {
-	case RTL_VER_08:
-	case RTL_VER_09:
-	case RTL_VER_14:
-		r8153b_rx_agg_chg_indicate(tp);
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_07:
 		break;
 	default:
+		r8153b_rx_agg_chg_indicate(tp);
 		break;
 	}
 
@@ -3065,10 +3397,10 @@ static void r8153_set_rx_early_timeout(struct r8152 *tp)
 	case RTL_VER_09:
 	case RTL_VER_14:
 		/* The RTL8153B uses USB_RX_EXTRA_AGGR_TMR for rx timeout
-		 * primarily. For USB_RX_EARLY_TIMEOUT, we fix it to 128ns.
+		 * primarily. For USB_RX_EARLY_TIMEOUT, we fix it to 1264ns.
 		 */
 		ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_TIMEOUT,
-			       128 / 8);
+			       1264 / 8);
 		ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EXTRA_AGGR_TMR,
 			       ocp_data);
 		break;
@@ -3082,7 +3414,6 @@ static void r8153_set_rx_early_timeout(struct r8152 *tp)
 			       640 / 8);
 		ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EXTRA_AGGR_TMR,
 			       ocp_data);
-		r8153b_rx_agg_chg_indicate(tp);
 		break;
 
 	default:
@@ -3116,7 +3447,6 @@ static void r8153_set_rx_early_size(struct r8152 *tp)
 	case RTL_VER_15:
 		ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_SIZE,
 			       ocp_data / 8);
-		r8153b_rx_agg_chg_indicate(tp);
 		break;
 	default:
 		WARN_ON_ONCE(1);
@@ -3139,7 +3469,6 @@ static int rtl8153_enable(struct r8152 *tp)
 	rtl_set_ifg(tp, rtl8152_get_speed(tp));
 
 	switch (tp->version) {
-	case RTL_VER_09:
 	case RTL_VER_14:
 		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);
 		ocp_data &= ~FC_PATCH_TASK;
@@ -3250,6 +3579,43 @@ static void rtl_rx_vlan_en(struct r8152 *tp, bool enable)
 	}
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+static void
+rtl8152_vlan_rx_register(struct net_device *dev, struct vlan_group *grp)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	if (unlikely(tp->rtk_enable_diag))
+		return;
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	mutex_lock(&tp->control);
+
+	tp->vlgrp = grp;
+	if (tp->vlgrp)
+		rtl_rx_vlan_en(tp, true);
+	else
+		rtl_rx_vlan_en(tp, false);
+
+	mutex_unlock(&tp->control);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+
+static void rtl8152_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	vlan_group_set_device(tp->vlgrp, vid, NULL);
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) */
+
+#else
+
 static int rtl8152_set_features(struct net_device *dev,
 				netdev_features_t features)
 {
@@ -3257,6 +3623,9 @@ static int rtl8152_set_features(struct net_device *dev,
 	struct r8152 *tp = netdev_priv(dev);
 	int ret;
 
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
 	ret = usb_autopm_get_interface(tp->intf);
 	if (ret < 0)
 		goto out;
@@ -3278,6 +3647,8 @@ static int rtl8152_set_features(struct net_device *dev,
 	return ret;
 }
 
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
+
 #define WAKE_ANY (WAKE_PHY | WAKE_MAGIC | WAKE_UCAST | WAKE_BCAST | WAKE_MCAST)
 
 static u32 __rtl_get_wol(struct r8152 *tp)
@@ -3411,11 +3782,20 @@ static void r8153_u2p3en(struct r8152 *tp, bool enable)
 	ocp_write_word(tp, MCU_TYPE_USB, USB_U2P3_CTRL, ocp_data);
 }
 
-static void r8153b_ups_flags(struct r8152 *tp)
+static bool r8156b_flash_used(struct r8152 *tp)
 {
-	u32 ups_flags = 0;
-
-	if (tp->ups_info.green)
+	if ((ocp_read_word(tp, MCU_TYPE_PLA, PLA_GPHY_CTRL) & GPHY_FLASH) &&
+	    !(ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL) & BYPASS_FLASH))
+		return true;
+	else
+		return false;
+}
+
+static void r8153b_ups_flags(struct r8152 *tp)
+{
+	u32 ups_flags = 0;
+
+	if (tp->ups_info.green)
 		ups_flags |= UPS_FLAGS_EN_GREEN;
 
 	if (tp->ups_info.aldps)
@@ -3639,7 +4019,7 @@ static void r8153b_ups_en(struct r8152 *tp, bool enable)
 		ocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);
 
 		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);
-		ocp_data &= ~UPS_FORCE_PWR_DOWN;
+		ocp_data &= ~(UPS_FORCE_PWR_DOWN | UPS_NO_UPS);
 		ocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);
 
 		if (ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0) & PCUT_STATUS) {
@@ -3679,7 +4059,7 @@ static void r8153c_ups_en(struct r8152 *tp, bool enable)
 		ocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);
 
 		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);
-		ocp_data &= ~UPS_FORCE_PWR_DOWN;
+		ocp_data &= ~(UPS_FORCE_PWR_DOWN | UPS_NO_UPS);
 		ocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);
 
 		if (ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0) & PCUT_STATUS) {
@@ -3710,11 +4090,12 @@ static void r8153c_ups_en(struct r8152 *tp, bool enable)
 
 static void r8156_ups_en(struct r8152 *tp, bool enable)
 {
-	u32 ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_POWER_CUT);
-
 	if (enable) {
+		u32 ocp_data;
+
 		r8156_ups_flags(tp);
 
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_POWER_CUT);
 		ocp_data |= UPS_EN | USP_PREWAKE | PHASE2_EN;
 		ocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);
 
@@ -3728,16 +4109,27 @@ static void r8156_ups_en(struct r8152 *tp, bool enable)
 			ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_UPHY_XTAL);
 			ocp_data &= ~OOBS_POLLING;
 			ocp_write_byte(tp, MCU_TYPE_USB, USB_UPHY_XTAL, ocp_data);
+
+			if (r8156b_flash_used(tp)) {
+				ocp_data = ocp_read_word(tp, MCU_TYPE_USB,
+							 USB_GPHY_CTRL);
+				ocp_data &= ~GPHY_PATCH_DONE;
+				ocp_write_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL,
+					       ocp_data);
+			}
 			break;
 		default:
 			break;
 		}
 	} else {
+		u32 ocp_data;
+
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_POWER_CUT);
 		ocp_data &= ~(UPS_EN | USP_PREWAKE);
 		ocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);
 
 		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);
-		ocp_data &= ~UPS_FORCE_PWR_DOWN;
+		ocp_data &= ~(UPS_FORCE_PWR_DOWN | UPS_NO_UPS);
 		ocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);
 
 		if (ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0) & PCUT_STATUS) {
@@ -3745,6 +4137,23 @@ static void r8156_ups_en(struct r8152 *tp, bool enable)
 
 			rtl8152_set_speed(tp, tp->autoneg, tp->speed,
 					  tp->duplex, tp->advertising);
+		} else {
+			switch (tp->version) {
+			case RTL_VER_13:
+			case RTL_VER_15:
+				if (r8156b_flash_used(tp)) {
+					ocp_data = ocp_read_word(tp,
+								 MCU_TYPE_USB,
+								 USB_GPHY_CTRL);
+					ocp_data |= GPHY_PATCH_DONE;
+					ocp_write_word(tp, MCU_TYPE_USB,
+						       USB_GPHY_CTRL,
+						       ocp_data);
+				}
+				break;
+			default:
+				break;
+			}
 		}
 	}
 }
@@ -3840,10 +4249,14 @@ static void rtl_runtime_suspend_enable(struct r8152 *tp, bool enable)
 static void rtl8153_runtime_enable(struct r8152 *tp, bool enable)
 {
 	if (enable) {
+		if (tp->version == RTL_VER_06)
+			r8153_queue_wake(tp, true);
 		r8153_u1u2en(tp, false);
 		r8153_u2p3en(tp, false);
 		rtl_runtime_suspend_enable(tp, true);
 	} else {
+		if (tp->version == RTL_VER_06)
+			r8153_queue_wake(tp, false);
 		rtl_runtime_suspend_enable(tp, false);
 
 		switch (tp->version) {
@@ -3873,6 +4286,7 @@ static void rtl8153b_runtime_enable(struct r8152 *tp, bool enable)
 		r8153b_ups_en(tp, false);
 		r8153_queue_wake(tp, false);
 		rtl_runtime_suspend_enable(tp, false);
+//		r8153_u2p3en(tp, true);
 		if (tp->udev->speed >= USB_SPEED_SUPER)
 			r8153b_u1u2en(tp, true);
 	}
@@ -3890,6 +4304,7 @@ static void rtl8153c_runtime_enable(struct r8152 *tp, bool enable)
 		r8153c_ups_en(tp, false);
 		r8153_queue_wake(tp, false);
 		rtl_runtime_suspend_enable(tp, false);
+//		r8153_u2p3en(tp, true);
 		r8153b_u1u2en(tp, true);
 	}
 }
@@ -3901,7 +4316,11 @@ static void rtl8156_runtime_enable(struct r8152 *tp, bool enable)
 		r8153b_u1u2en(tp, false);
 		r8153_u2p3en(tp, false);
 		rtl_runtime_suspend_enable(tp, true);
+//		if (tp->version != RTL_VER_10 ||
+//		    tp->udev->speed == USB_SPEED_HIGH)
+//			r8156_ups_en(tp, true);
 	} else {
+//		r8156_ups_en(tp, false);
 		r8153_queue_wake(tp, false);
 		rtl_runtime_suspend_enable(tp, false);
 		r8153_u2p3en(tp, true);
@@ -3910,6 +4329,23 @@ static void rtl8156_runtime_enable(struct r8152 *tp, bool enable)
 	}
 }
 
+static int rtl_nway_restart(struct r8152 *tp)
+{
+	int r = -EINVAL;
+	int bmcr;
+
+	/* if autoneg is off, it's an error */
+	bmcr = r8152_mdio_read(tp, MII_BMCR);
+
+	if (bmcr & BMCR_ANENABLE) {
+		bmcr |= BMCR_ANRESTART;
+		r8152_mdio_write(tp, MII_BMCR, bmcr);
+		r = 0;
+	}
+
+	return r;
+}
+
 static void r8153_teredo_off(struct r8152 *tp)
 {
 	u32 ocp_data;
@@ -3964,29 +4400,10 @@ static void rtl_reset_bmu(struct r8152 *tp)
 /* Clear the bp to stop the firmware before loading a new one */
 static void rtl_clear_bp(struct r8152 *tp, u16 type)
 {
-	switch (tp->version) {
-	case RTL_VER_01:
-	case RTL_VER_02:
-	case RTL_VER_07:
-		break;
-	case RTL_VER_03:
-	case RTL_VER_04:
-	case RTL_VER_05:
-	case RTL_VER_06:
-		ocp_write_byte(tp, type, PLA_BP_EN, 0);
-		break;
-	case RTL_VER_14:
-		ocp_write_word(tp, type, USB_BP2_EN, 0);
+	u16 bp[16] = {0};
+	u16 bp_num;
 
-		ocp_write_word(tp, type, USB_BP_8, 0);
-		ocp_write_word(tp, type, USB_BP_9, 0);
-		ocp_write_word(tp, type, USB_BP_10, 0);
-		ocp_write_word(tp, type, USB_BP_11, 0);
-		ocp_write_word(tp, type, USB_BP_12, 0);
-		ocp_write_word(tp, type, USB_BP_13, 0);
-		ocp_write_word(tp, type, USB_BP_14, 0);
-		ocp_write_word(tp, type, USB_BP_15, 0);
-		break;
+	switch (tp->version) {
 	case RTL_VER_08:
 	case RTL_VER_09:
 	case RTL_VER_10:
@@ -3994,38 +4411,45 @@ static void rtl_clear_bp(struct r8152 *tp, u16 type)
 	case RTL_VER_12:
 	case RTL_VER_13:
 	case RTL_VER_15:
-	default:
 		if (type == MCU_TYPE_USB) {
 			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0);
-
-			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0);
-			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0);
-			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0);
-			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0);
-			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0);
-			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0);
-			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0);
-			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0);
-		} else {
-			ocp_write_byte(tp, MCU_TYPE_PLA, PLA_BP_EN, 0);
+			bp_num = 16;
+			break;
 		}
+		fallthrough;
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+		ocp_write_byte(tp, type, PLA_BP_EN, 0);
+		fallthrough;
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+		bp_num = 8;
+		break;
+	case RTL_VER_14:
+	default:
+		ocp_write_word(tp, type, USB_BP2_EN, 0);
+		bp_num = 16;
 		break;
 	}
 
-	ocp_write_word(tp, type, PLA_BP_0, 0);
-	ocp_write_word(tp, type, PLA_BP_1, 0);
-	ocp_write_word(tp, type, PLA_BP_2, 0);
-	ocp_write_word(tp, type, PLA_BP_3, 0);
-	ocp_write_word(tp, type, PLA_BP_4, 0);
-	ocp_write_word(tp, type, PLA_BP_5, 0);
-	ocp_write_word(tp, type, PLA_BP_6, 0);
-	ocp_write_word(tp, type, PLA_BP_7, 0);
+	generic_ocp_write(tp, PLA_BP_0, BYTE_EN_DWORD, bp_num << 1, bp, type);
 
 	/* wait 3 ms to make sure the firmware is stopped */
 	usleep_range(3000, 6000);
 	ocp_write_word(tp, type, PLA_BP_BA, 0);
 }
 
+static bool rtl_check_fw_ver_ok(struct r8152 *tp, u16 index, u8 new_ver)
+{
+	if (!index || new_ver > ocp_read_byte(tp, MCU_TYPE_USB, index))
+		return true;
+	else
+		return false;
+}
+
 static inline void rtl_reset_ocp_base(struct r8152 *tp)
 {
 	tp->ocp_base = -1;
@@ -4105,1299 +4529,4635 @@ static int rtl_post_ram_code(struct r8152 *tp, u16 key_addr, bool wait)
 	return 0;
 }
 
-static bool rtl8152_is_fw_phy_speed_up_ok(struct r8152 *tp, struct fw_phy_speed_up *phy)
+static void patch4(struct r8152 *tp)
 {
-	u16 fw_offset;
-	u32 length;
-	bool rc = false;
+	u8 data;
+
+	data = ocp_read_byte(tp, MCU_TYPE_USB, 0xd429);
+	data |= 0x80;
+	ocp_write_byte(tp, MCU_TYPE_USB, 0xd429, data);
+	ocp_write_word(tp, MCU_TYPE_USB, 0xc0ce, 0x0210);
+	data = ocp_read_byte(tp, MCU_TYPE_USB, 0xd429);
+	data &= ~0x80;
+	ocp_write_byte(tp, MCU_TYPE_USB, 0xd429, data);
+}
 
-	switch (tp->version) {
-	case RTL_VER_01:
-	case RTL_VER_02:
-	case RTL_VER_03:
-	case RTL_VER_04:
-	case RTL_VER_05:
-	case RTL_VER_06:
-	case RTL_VER_07:
-	case RTL_VER_08:
-	case RTL_VER_09:
-	case RTL_VER_10:
-	case RTL_VER_11:
-	case RTL_VER_12:
-	case RTL_VER_14:
-		goto out;
-	case RTL_VER_13:
-	case RTL_VER_15:
-	default:
-		break;
-	}
+static void r8152b_firmware(struct r8152 *tp)
+{
+	if (tp->version == RTL_VER_01) {
+		int i;
+		static u8 pla_patch_a[] = {
+			0x08, 0xe0, 0x40, 0xe0,
+			0x78, 0xe0, 0x85, 0xe0,
+			0x5d, 0xe1, 0xa1, 0xe1,
+			0xa3, 0xe1, 0xab, 0xe1,
+			0x31, 0xc3, 0x60, 0x72,
+			0xa0, 0x49, 0x10, 0xf0,
+			0xa4, 0x49, 0x0e, 0xf0,
+			0x2c, 0xc3, 0x62, 0x72,
+			0x26, 0x70, 0x80, 0x49,
+			0x05, 0xf0, 0x2f, 0x48,
+			0x62, 0x9a, 0x24, 0x70,
+			0x60, 0x98, 0x24, 0xc3,
+			0x60, 0x99, 0x23, 0xc3,
+			0x00, 0xbb, 0x2c, 0x75,
+			0xdc, 0x21, 0xbc, 0x25,
+			0x04, 0x13, 0x0a, 0xf0,
+			0x03, 0x13, 0x08, 0xf0,
+			0x02, 0x13, 0x06, 0xf0,
+			0x01, 0x13, 0x04, 0xf0,
+			0x08, 0x13, 0x02, 0xf0,
+			0x03, 0xe0, 0xd4, 0x49,
+			0x04, 0xf1, 0x14, 0xc2,
+			0x12, 0xc3, 0x00, 0xbb,
+			0x12, 0xc3, 0x60, 0x75,
+			0xd0, 0x49, 0x05, 0xf1,
+			0x50, 0x48, 0x60, 0x9d,
+			0x09, 0xc6, 0x00, 0xbe,
+			0xd0, 0x48, 0x60, 0x9d,
+			0xf3, 0xe7, 0xc2, 0xc0,
+			0x38, 0xd2, 0xc6, 0xd2,
+			0x84, 0x17, 0xa2, 0x13,
+			0x0c, 0x17, 0xbc, 0xc0,
+			0xa2, 0xd1, 0x33, 0xc5,
+			0xa0, 0x74, 0xc0, 0x49,
+			0x1f, 0xf0, 0x30, 0xc5,
+			0xa0, 0x73, 0x00, 0x13,
+			0x04, 0xf1, 0xa2, 0x73,
+			0x00, 0x13, 0x14, 0xf0,
+			0x28, 0xc5, 0xa0, 0x74,
+			0xc8, 0x49, 0x1b, 0xf1,
+			0x26, 0xc5, 0xa0, 0x76,
+			0xa2, 0x74, 0x01, 0x06,
+			0x20, 0x37, 0xa0, 0x9e,
+			0xa2, 0x9c, 0x1e, 0xc5,
+			0xa2, 0x73, 0x23, 0x40,
+			0x10, 0xf8, 0x04, 0xf3,
+			0xa0, 0x73, 0x33, 0x40,
+			0x0c, 0xf8, 0x15, 0xc5,
+			0xa0, 0x74, 0x41, 0x48,
+			0xa0, 0x9c, 0x14, 0xc5,
+			0xa0, 0x76, 0x62, 0x48,
+			0xe0, 0x48, 0xa0, 0x9e,
+			0x10, 0xc6, 0x00, 0xbe,
+			0x0a, 0xc5, 0xa0, 0x74,
+			0x48, 0x48, 0xa0, 0x9c,
+			0x0b, 0xc5, 0x20, 0x1e,
+			0xa0, 0x9e, 0xe5, 0x48,
+			0xa0, 0x9e, 0xf0, 0xe7,
+			0xbc, 0xc0, 0xc8, 0xd2,
+			0xcc, 0xd2, 0x28, 0xe4,
+			0x22, 0x02, 0xf0, 0xc0,
+			0x0b, 0xc0, 0x00, 0x71,
+			0x0a, 0xc0, 0x00, 0x72,
+			0xa0, 0x49, 0x04, 0xf0,
+			0xa4, 0x49, 0x02, 0xf0,
+			0x93, 0x48, 0x04, 0xc0,
+			0x00, 0xb8, 0x00, 0xe4,
+			0xc2, 0xc0, 0x8c, 0x09,
+			0x14, 0xc2, 0x40, 0x73,
+			0xba, 0x48, 0x40, 0x9b,
+			0x11, 0xc2, 0x40, 0x73,
+			0xb0, 0x49, 0x17, 0xf0,
+			0xbf, 0x49, 0x03, 0xf1,
+			0x09, 0xc5, 0x00, 0xbd,
+			0xb1, 0x49, 0x11, 0xf0,
+			0xb1, 0x48, 0x40, 0x9b,
+			0x02, 0xc2, 0x00, 0xba,
+			0x82, 0x18, 0x00, 0xa0,
+			0x1e, 0xfc, 0xbc, 0xc0,
+			0xf0, 0xc0, 0xde, 0xe8,
+			0x00, 0x80, 0x00, 0x60,
+			0x2c, 0x75, 0xd4, 0x49,
+			0x12, 0xf1, 0x29, 0xe0,
+			0xf8, 0xc2, 0x46, 0x71,
+			0xf7, 0xc2, 0x40, 0x73,
+			0xbe, 0x49, 0x03, 0xf1,
+			0xf5, 0xc7, 0x02, 0xe0,
+			0xf2, 0xc7, 0x4f, 0x30,
+			0x26, 0x62, 0xa1, 0x49,
+			0xf0, 0xf1, 0x22, 0x72,
+			0xa0, 0x49, 0xed, 0xf1,
+			0x25, 0x25, 0x18, 0x1f,
+			0x97, 0x30, 0x91, 0x30,
+			0x36, 0x9a, 0x2c, 0x75,
+			0x32, 0xc3, 0x60, 0x73,
+			0xb1, 0x49, 0x0d, 0xf1,
+			0xdc, 0x21, 0xbc, 0x25,
+			0x27, 0xc6, 0xc0, 0x77,
+			0x04, 0x13, 0x18, 0xf0,
+			0x03, 0x13, 0x19, 0xf0,
+			0x02, 0x13, 0x1a, 0xf0,
+			0x01, 0x13, 0x1b, 0xf0,
+			0xd4, 0x49, 0x03, 0xf1,
+			0x1c, 0xc5, 0x00, 0xbd,
+			0xcd, 0xc6, 0xc6, 0x67,
+			0x2e, 0x75, 0xd7, 0x22,
+			0xdd, 0x26, 0x05, 0x15,
+			0x1a, 0xf0, 0x14, 0xc6,
+			0x00, 0xbe, 0x13, 0xc5,
+			0x00, 0xbd, 0x12, 0xc5,
+			0x00, 0xbd, 0xf1, 0x49,
+			0xfb, 0xf1, 0xef, 0xe7,
+			0xf4, 0x49, 0xfa, 0xf1,
+			0xec, 0xe7, 0xf3, 0x49,
+			0xf7, 0xf1, 0xe9, 0xe7,
+			0xf2, 0x49, 0xf4, 0xf1,
+			0xe6, 0xe7, 0xb6, 0xc0,
+			0x6a, 0x14, 0xac, 0x13,
+			0xd6, 0x13, 0xfa, 0x14,
+			0xa0, 0xd1, 0x00, 0x00,
+			0xc0, 0x75, 0xd0, 0x49,
+			0x46, 0xf0, 0x26, 0x72,
+			0xa7, 0x49, 0x43, 0xf0,
+			0x22, 0x72, 0x25, 0x25,
+			0x20, 0x1f, 0x97, 0x30,
+			0x91, 0x30, 0x40, 0x73,
+			0xf3, 0xc4, 0x1c, 0x40,
+			0x04, 0xf0, 0xd7, 0x49,
+			0x05, 0xf1, 0x37, 0xe0,
+			0x53, 0x48, 0xc0, 0x9d,
+			0x08, 0x02, 0x40, 0x66,
+			0x64, 0x27, 0x06, 0x16,
+			0x30, 0xf1, 0x46, 0x63,
+			0x3b, 0x13, 0x2d, 0xf1,
+			0x34, 0x9b, 0x18, 0x1b,
+			0x93, 0x30, 0x2b, 0xc3,
+			0x10, 0x1c, 0x2b, 0xe8,
+			0x01, 0x14, 0x25, 0xf1,
+			0x00, 0x1d, 0x26, 0x1a,
+			0x8a, 0x30, 0x22, 0x73,
+			0xb5, 0x25, 0x0e, 0x0b,
+			0x00, 0x1c, 0x2c, 0xe8,
+			0x1f, 0xc7, 0x27, 0x40,
+			0x1a, 0xf1, 0x38, 0xe8,
+			0x32, 0x1f, 0x8f, 0x30,
+			0x08, 0x1b, 0x24, 0xe8,
+			0x36, 0x72, 0x46, 0x77,
+			0x00, 0x17, 0x0d, 0xf0,
+			0x13, 0xc3, 0x1f, 0x40,
+			0x03, 0xf1, 0x00, 0x1f,
+			0x46, 0x9f, 0x44, 0x77,
+			0x9f, 0x44, 0x5f, 0x44,
+			0x17, 0xe8, 0x0a, 0xc7,
+			0x27, 0x40, 0x05, 0xf1,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x50, 0x1a, 0x06, 0x1a,
+			0xff, 0xc7, 0x00, 0xbf,
+			0xb8, 0xcd, 0xff, 0xff,
+			0x02, 0x0c, 0x54, 0xa5,
+			0xdc, 0xa5, 0x2f, 0x40,
+			0x05, 0xf1, 0x00, 0x14,
+			0xfa, 0xf1, 0x01, 0x1c,
+			0x02, 0xe0, 0x00, 0x1c,
+			0x80, 0xff, 0xb0, 0x49,
+			0x04, 0xf0, 0x01, 0x0b,
+			0xd3, 0xa1, 0x03, 0xe0,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x00, 0x13, 0xfb, 0xf1,
+			0x80, 0xff, 0x22, 0x73,
+			0xb5, 0x25, 0x18, 0x1e,
+			0xde, 0x30, 0xd9, 0x30,
+			0x64, 0x72, 0x11, 0x1e,
+			0x68, 0x23, 0x16, 0x31,
+			0x80, 0xff, 0xd4, 0x49,
+			0x28, 0xf0, 0x02, 0xb4,
+			0x2a, 0xc4, 0x00, 0x1d,
+			0x2e, 0xe8, 0xe0, 0x73,
+			0xb9, 0x21, 0xbd, 0x25,
+			0x04, 0x13, 0x02, 0xf0,
+			0x1a, 0xe0, 0x22, 0xc4,
+			0x23, 0xc3, 0x2f, 0xe8,
+			0x23, 0xc3, 0x2d, 0xe8,
+			0x00, 0x1d, 0x21, 0xe8,
+			0xe2, 0x73, 0xbb, 0x49,
+			0xfc, 0xf0, 0xe0, 0x73,
+			0xb7, 0x48, 0x03, 0xb4,
+			0x81, 0x1d, 0x19, 0xe8,
+			0x40, 0x1a, 0x84, 0x1d,
+			0x16, 0xe8, 0x12, 0xc3,
+			0x1e, 0xe8, 0x03, 0xb0,
+			0x81, 0x1d, 0x11, 0xe8,
+			0x0e, 0xc3, 0x19, 0xe8,
+			0x02, 0xb0, 0x06, 0xc7,
+			0x04, 0x1e, 0xe0, 0x9e,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x22, 0x02, 0x20, 0xe4,
+			0x04, 0xb8, 0x34, 0xb0,
+			0x00, 0x02, 0x00, 0x03,
+			0x00, 0x0e, 0x00, 0x0c,
+			0x09, 0xc7, 0xe0, 0x9b,
+			0xe2, 0x9a, 0xe4, 0x9c,
+			0xe6, 0x8d, 0xe6, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x80, 0xff, 0x08, 0xea,
+			0x82, 0x1d, 0xf5, 0xef,
+			0x00, 0x1a, 0x88, 0x1d,
+			0xf2, 0xef, 0xed, 0xc2,
+			0xf0, 0xef, 0x80, 0xff,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x46, 0x06, 0x08, 0xc2,
+			0x40, 0x73, 0x3a, 0x48,
+			0x40, 0x9b, 0x06, 0xff,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x86, 0x17, 0x1e, 0xfc,
+			0x36, 0xf0, 0x08, 0x1c,
+			0xea, 0x8c, 0xe3, 0x64,
+			0xc7, 0x49, 0x25, 0xf1,
+			0xe0, 0x75, 0xff, 0x1b,
+			0xeb, 0x47, 0xff, 0x1b,
+			0x6b, 0x47, 0xe0, 0x9d,
+			0x15, 0xc3, 0x60, 0x75,
+			0xd8, 0x49, 0x04, 0xf0,
+			0x81, 0x1d, 0xe2, 0x8d,
+			0x05, 0xe0, 0xe2, 0x63,
+			0x81, 0x1d, 0xdd, 0x47,
+			0xe2, 0x8b, 0x0b, 0xc3,
+			0x00, 0x1d, 0x61, 0x8d,
+			0x3c, 0x03, 0x60, 0x75,
+			0xd8, 0x49, 0x06, 0xf1,
+			0xdf, 0x48, 0x61, 0x95,
+			0x16, 0xe0, 0x4e, 0xe8,
+			0x12, 0xe8, 0x21, 0xc5,
+			0xa0, 0x73, 0xb0, 0x49,
+			0x03, 0xf0, 0x31, 0x48,
+			0xa0, 0x9b, 0x0d, 0xe0,
+			0xc0, 0x49, 0x0b, 0xf1,
+			0xe2, 0x63, 0x7e, 0x1d,
+			0xdd, 0x46, 0xe2, 0x8b,
+			0xe0, 0x75, 0x83, 0x1b,
+			0xeb, 0x46, 0xfe, 0x1b,
+			0x6b, 0x46, 0xe0, 0x9d,
+			0xe4, 0x49, 0x11, 0xf0,
+			0x10, 0x1d, 0xea, 0x8d,
+			0xe3, 0x64, 0xc6, 0x49,
+			0x09, 0xf1, 0x07, 0xc5,
+			0xa0, 0x73, 0xb1, 0x48,
+			0xa0, 0x9b, 0x02, 0xc5,
+			0x00, 0xbd, 0xe6, 0x04,
+			0xa0, 0xd1, 0x02, 0xc5,
+			0x00, 0xbd, 0xfe, 0x04,
+			0x02, 0xc5, 0x00, 0xbd,
+			0x30, 0x05, 0x00, 0x00 };
+		static u16 ram_code1[] = {
+			0x9700, 0x7fe0, 0x4c00, 0x4007,
+			0x4400, 0x4800, 0x7c1f, 0x4c00,
+			0x5310, 0x6000, 0x7c07, 0x6800,
+			0x673e, 0x0000, 0x0000, 0x571f,
+			0x5ffb, 0xaa05, 0x5b58, 0x7d80,
+			0x6100, 0x3019, 0x5b64, 0x7d80,
+			0x6080, 0xa6f8, 0xdcdb, 0x0015,
+			0xb915, 0xb511, 0xd16b, 0x000f,
+			0xb40f, 0xd06b, 0x000d, 0xb206,
+			0x7c01, 0x5800, 0x7c04, 0x5c00,
+			0x3011, 0x7c01, 0x5801, 0x7c04,
+			0x5c04, 0x3019, 0x30a5, 0x3127,
+			0x31d5, 0x7fe0, 0x4c60, 0x7c07,
+			0x6803, 0x7d00, 0x6900, 0x65a0,
+			0x0000, 0x0000, 0xaf03, 0x6015,
+			0x303e, 0x6017, 0x57e0, 0x580c,
+			0x588c, 0x7fdd, 0x5fa2, 0x4827,
+			0x7c1f, 0x4c00, 0x7c1f, 0x4c10,
+			0x8400, 0x7c30, 0x6020, 0x48bf,
+			0x7c1f, 0x4c00, 0x7c1f, 0x4c01,
+			0x7c07, 0x6803, 0xb806, 0x7c08,
+			0x6800, 0x0000, 0x0000, 0x305c,
+			0x7c08, 0x6808, 0x0000, 0x0000,
+			0xae06, 0x7c02, 0x5c02, 0x0000,
+			0x0000, 0x3067, 0x8e05, 0x7c02,
+			0x5c00, 0x0000, 0x0000, 0xad06,
+			0x7c20, 0x5c20, 0x0000, 0x0000,
+			0x3072, 0x8d05, 0x7c20, 0x5c00,
+			0x0000, 0x0000, 0xa008, 0x7c07,
+			0x6800, 0xb8db, 0x7c07, 0x6803,
+			0xd9b3, 0x00d7, 0x7fe0, 0x4c80,
+			0x7c08, 0x6800, 0x0000, 0x0000,
+			0x7c23, 0x5c23, 0x481d, 0x7c1f,
+			0x4c00, 0x7c1f, 0x4c02, 0x5310,
+			0x81ff, 0x30f5, 0x7fe0, 0x4d00,
+			0x4832, 0x7c1f, 0x4c00, 0x7c1f,
+			0x4c10, 0x7c08, 0x6000, 0xa49e,
+			0x7c07, 0x6800, 0xb89b, 0x7c07,
+			0x6803, 0xd9b3, 0x00f9, 0x7fe0,
+			0x4d20, 0x7e00, 0x6200, 0x3001,
+			0x7fe0, 0x4dc0, 0xd09d, 0x0002,
+			0xb4fe, 0x7fe0, 0x4d80, 0x7c04,
+			0x6004, 0x7c07, 0x6802, 0x6728,
+			0x0000, 0x0000, 0x7c08, 0x6000,
+			0x486c, 0x7c1f, 0x4c00, 0x7c1f,
+			0x4c01, 0x9503, 0x7e00, 0x6200,
+			0x571f, 0x5fbb, 0xaa05, 0x5b58,
+			0x7d80, 0x6100, 0x30c2, 0x5b64,
+			0x7d80, 0x6080, 0xcdab, 0x0063,
+			0xcd8d, 0x0061, 0xd96b, 0x005f,
+			0xd0a0, 0x00d7, 0xcba0, 0x0003,
+			0x80ec, 0x30cf, 0x30dc, 0x7fe0,
+			0x4ce0, 0x4832, 0x7c1f, 0x4c00,
+			0x7c1f, 0x4c08, 0x7c08, 0x6008,
+			0x8300, 0xb902, 0x30a5, 0x308a,
+			0x7fe0, 0x4da0, 0x65a8, 0x0000,
+			0x0000, 0x56a0, 0x590c, 0x7ffd,
+			0x5fa2, 0xae06, 0x7c02, 0x5c02,
+			0x0000, 0x0000, 0x30f0, 0x8e05,
+			0x7c02, 0x5c00, 0x0000, 0x0000,
+			0xcba4, 0x0004, 0xcd8d, 0x0002,
+			0x80f1, 0x7fe0, 0x4ca0, 0x7c08,
+			0x6408, 0x0000, 0x0000, 0x7d00,
+			0x6800, 0xb603, 0x7c10, 0x6010,
+			0x7d1f, 0x551f, 0x5fb3, 0xaa07,
+			0x7c80, 0x5800, 0x5b58, 0x7d80,
+			0x6100, 0x310f, 0x7c80, 0x5800,
+			0x5b64, 0x7d80, 0x6080, 0x4827,
+			0x7c1f, 0x4c00, 0x7c1f, 0x4c10,
+			0x8400, 0x7c10, 0x6000, 0x7fe0,
+			0x4cc0, 0x5fbb, 0x4824, 0x7c1f,
+			0x4c00, 0x7c1f, 0x4c04, 0x8200,
+			0x7ce0, 0x5400, 0x6728, 0x0000,
+			0x0000, 0x30cf, 0x3001, 0x7fe0,
+			0x4e00, 0x4007, 0x4400, 0x5310,
+			0x7c07, 0x6800, 0x673e, 0x0000,
+			0x0000, 0x570f, 0x5fff, 0xaa05,
+			0x585b, 0x7d80, 0x6100, 0x313b,
+			0x5867, 0x7d80, 0x6080, 0x9403,
+			0x7e00, 0x6200, 0xcda3, 0x00e7,
+			0xcd85, 0x00e5, 0xd96b, 0x00e3,
+			0x96e3, 0x7c07, 0x6800, 0x673e,
+			0x0000, 0x0000, 0x7fe0, 0x4e20,
+			0x96db, 0x8b04, 0x7c08, 0x5008,
+			0xab03, 0x7c08, 0x5000, 0x7c07,
+			0x6801, 0x677e, 0x0000, 0x0000,
+			0xdb7c, 0x00ec, 0x0000, 0x7fe1,
+			0x4f40, 0x4837, 0x4418, 0x41c7,
+			0x7fe0, 0x4e40, 0x7c40, 0x5400,
+			0x7c1f, 0x4c01, 0x7c1f, 0x4c01,
+			0x8fbf, 0xd2a0, 0x004b, 0x9204,
+			0xa042, 0x3168, 0x3127, 0x7fe1,
+			0x4f60, 0x489c, 0x4628, 0x7fe0,
+			0x4e60, 0x7e28, 0x4628, 0x7c40,
+			0x5400, 0x7c01, 0x5800, 0x7c04,
+			0x5c00, 0x41e8, 0x7c1f, 0x4c01,
+			0x7c1f, 0x4c01, 0x8fa5, 0xb241,
+			0xa02a, 0x3182, 0x7fe0, 0x4ea0,
+			0x7c02, 0x4402, 0x4448, 0x4894,
+			0x7c1f, 0x4c01, 0x7c1f, 0x4c03,
+			0x4824, 0x7c1f, 0x4c07, 0x41ef,
+			0x41ff, 0x4891, 0x7c1f, 0x4c07,
+			0x7c1f, 0x4c17, 0x8400, 0x8ef8,
+			0x41c7, 0x8f8a, 0x92d5, 0xa10f,
+			0xd480, 0x0008, 0xd580, 0x00b8,
+			0xa202, 0x319d, 0x7c04, 0x4404,
+			0x319d, 0xd484, 0x00f3, 0xd484,
+			0x00f1, 0x3127, 0x7fe0, 0x4ee0,
+			0x7c40, 0x5400, 0x4488, 0x41cf,
+			0x3127, 0x7fe0, 0x4ec0, 0x48f3,
+			0x7c1f, 0x4c01, 0x7c1f, 0x4c09,
+			0x4508, 0x41c7, 0x8fb0, 0xd218,
+			0x00ae, 0xd2a4, 0x009e, 0x31be,
+			0x7fe0, 0x4e80, 0x4832, 0x7c1f,
+			0x4c01, 0x7c1f, 0x4c11, 0x4428,
+			0x7c40, 0x5440, 0x7c01, 0x5801,
+			0x7c04, 0x5c04, 0x41e8, 0xa4b3,
+			0x31d3, 0x7fe0, 0x4f20, 0x7c07,
+			0x6800, 0x673e, 0x0000, 0x0000,
+			0x570f, 0x5fff, 0xaa04, 0x585b,
+			0x6100, 0x31e4, 0x5867, 0x6080,
+			0xbcf1, 0x3001 };
+
+		patch4(tp);
+		rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+		generic_ocp_write(tp, 0xf800, 0x3f, sizeof(pla_patch_a),
+				  pla_patch_a, MCU_TYPE_PLA);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x170b);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x01e1);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x0989);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x1349);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc30, 0x01b7);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc32, 0x061d);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xe422, 0x0020);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xe420, 0x0018);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc34, 0x1785);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc36, 0x047b);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, 0x2000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb092, 0x7070);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb098, 0x0600);
+		for (i = 0; i < ARRAY_SIZE(ram_code1); i++)
+			ocp_write_word(tp, MCU_TYPE_PLA, 0xb09a, ram_code1[i]);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb098, 0x0200);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb092, 0x7030);
+
+		rtl_reset_ocp_base(tp);
+	} else if (tp->version == RTL_VER_02) {
+		static u8 pla_patch_a2[] = {
+			0x08, 0xe0, 0x1a, 0xe0,
+			0xf2, 0xe0, 0xfa, 0xe0,
+			0x32, 0xe1, 0x34, 0xe1,
+			0x36, 0xe1, 0x38, 0xe1,
+			0x2c, 0x75, 0xdc, 0x21,
+			0xbc, 0x25, 0x04, 0x13,
+			0x0b, 0xf0, 0x03, 0x13,
+			0x09, 0xf0, 0x02, 0x13,
+			0x07, 0xf0, 0x01, 0x13,
+			0x05, 0xf0, 0x08, 0x13,
+			0x03, 0xf0, 0x04, 0xc3,
+			0x00, 0xbb, 0x03, 0xc3,
+			0x00, 0xbb, 0xd2, 0x17,
+			0xbc, 0x17, 0x14, 0xc2,
+			0x40, 0x73, 0xba, 0x48,
+			0x40, 0x9b, 0x11, 0xc2,
+			0x40, 0x73, 0xb0, 0x49,
+			0x17, 0xf0, 0xbf, 0x49,
+			0x03, 0xf1, 0x09, 0xc5,
+			0x00, 0xbd, 0xb1, 0x49,
+			0x11, 0xf0, 0xb1, 0x48,
+			0x40, 0x9b, 0x02, 0xc2,
+			0x00, 0xba, 0x4e, 0x19,
+			0x00, 0xa0, 0x1e, 0xfc,
+			0xbc, 0xc0, 0xf0, 0xc0,
+			0xde, 0xe8, 0x00, 0x80,
+			0x00, 0x60, 0x2c, 0x75,
+			0xd4, 0x49, 0x12, 0xf1,
+			0x29, 0xe0, 0xf8, 0xc2,
+			0x46, 0x71, 0xf7, 0xc2,
+			0x40, 0x73, 0xbe, 0x49,
+			0x03, 0xf1, 0xf5, 0xc7,
+			0x02, 0xe0, 0xf2, 0xc7,
+			0x4f, 0x30, 0x26, 0x62,
+			0xa1, 0x49, 0xf0, 0xf1,
+			0x22, 0x72, 0xa0, 0x49,
+			0xed, 0xf1, 0x25, 0x25,
+			0x18, 0x1f, 0x97, 0x30,
+			0x91, 0x30, 0x36, 0x9a,
+			0x2c, 0x75, 0x32, 0xc3,
+			0x60, 0x73, 0xb1, 0x49,
+			0x0d, 0xf1, 0xdc, 0x21,
+			0xbc, 0x25, 0x27, 0xc6,
+			0xc0, 0x77, 0x04, 0x13,
+			0x18, 0xf0, 0x03, 0x13,
+			0x19, 0xf0, 0x02, 0x13,
+			0x1a, 0xf0, 0x01, 0x13,
+			0x1b, 0xf0, 0xd4, 0x49,
+			0x03, 0xf1, 0x1c, 0xc5,
+			0x00, 0xbd, 0xcd, 0xc6,
+			0xc6, 0x67, 0x2e, 0x75,
+			0xd7, 0x22, 0xdd, 0x26,
+			0x05, 0x15, 0x1a, 0xf0,
+			0x14, 0xc6, 0x00, 0xbe,
+			0x13, 0xc5, 0x00, 0xbd,
+			0x12, 0xc5, 0x00, 0xbd,
+			0xf1, 0x49, 0xfb, 0xf1,
+			0xef, 0xe7, 0xf4, 0x49,
+			0xfa, 0xf1, 0xec, 0xe7,
+			0xf3, 0x49, 0xf7, 0xf1,
+			0xe9, 0xe7, 0xf2, 0x49,
+			0xf4, 0xf1, 0xe6, 0xe7,
+			0xb6, 0xc0, 0xf6, 0x14,
+			0x36, 0x14, 0x62, 0x14,
+			0x86, 0x15, 0xa0, 0xd1,
+			0x00, 0x00, 0xc0, 0x75,
+			0xd0, 0x49, 0x46, 0xf0,
+			0x26, 0x72, 0xa7, 0x49,
+			0x43, 0xf0, 0x22, 0x72,
+			0x25, 0x25, 0x20, 0x1f,
+			0x97, 0x30, 0x91, 0x30,
+			0x40, 0x73, 0xf3, 0xc4,
+			0x1c, 0x40, 0x04, 0xf0,
+			0xd7, 0x49, 0x05, 0xf1,
+			0x37, 0xe0, 0x53, 0x48,
+			0xc0, 0x9d, 0x08, 0x02,
+			0x40, 0x66, 0x64, 0x27,
+			0x06, 0x16, 0x30, 0xf1,
+			0x46, 0x63, 0x3b, 0x13,
+			0x2d, 0xf1, 0x34, 0x9b,
+			0x18, 0x1b, 0x93, 0x30,
+			0x2b, 0xc3, 0x10, 0x1c,
+			0x2b, 0xe8, 0x01, 0x14,
+			0x25, 0xf1, 0x00, 0x1d,
+			0x26, 0x1a, 0x8a, 0x30,
+			0x22, 0x73, 0xb5, 0x25,
+			0x0e, 0x0b, 0x00, 0x1c,
+			0x2c, 0xe8, 0x1f, 0xc7,
+			0x27, 0x40, 0x1a, 0xf1,
+			0x38, 0xe8, 0x32, 0x1f,
+			0x8f, 0x30, 0x08, 0x1b,
+			0x24, 0xe8, 0x36, 0x72,
+			0x46, 0x77, 0x00, 0x17,
+			0x0d, 0xf0, 0x13, 0xc3,
+			0x1f, 0x40, 0x03, 0xf1,
+			0x00, 0x1f, 0x46, 0x9f,
+			0x44, 0x77, 0x9f, 0x44,
+			0x5f, 0x44, 0x17, 0xe8,
+			0x0a, 0xc7, 0x27, 0x40,
+			0x05, 0xf1, 0x02, 0xc3,
+			0x00, 0xbb, 0x1c, 0x1b,
+			0xd2, 0x1a, 0xff, 0xc7,
+			0x00, 0xbf, 0xb8, 0xcd,
+			0xff, 0xff, 0x02, 0x0c,
+			0x54, 0xa5, 0xdc, 0xa5,
+			0x2f, 0x40, 0x05, 0xf1,
+			0x00, 0x14, 0xfa, 0xf1,
+			0x01, 0x1c, 0x02, 0xe0,
+			0x00, 0x1c, 0x80, 0xff,
+			0xb0, 0x49, 0x04, 0xf0,
+			0x01, 0x0b, 0xd3, 0xa1,
+			0x03, 0xe0, 0x02, 0x0b,
+			0xd3, 0xa5, 0x27, 0x31,
+			0x20, 0x37, 0x02, 0x0b,
+			0xd3, 0xa5, 0x27, 0x31,
+			0x20, 0x37, 0x00, 0x13,
+			0xfb, 0xf1, 0x80, 0xff,
+			0x22, 0x73, 0xb5, 0x25,
+			0x18, 0x1e, 0xde, 0x30,
+			0xd9, 0x30, 0x64, 0x72,
+			0x11, 0x1e, 0x68, 0x23,
+			0x16, 0x31, 0x80, 0xff,
+			0x08, 0xc2, 0x40, 0x73,
+			0x3a, 0x48, 0x40, 0x9b,
+			0x06, 0xff, 0x02, 0xc6,
+			0x00, 0xbe, 0x4e, 0x18,
+			0x1e, 0xfc, 0x33, 0xc5,
+			0xa0, 0x74, 0xc0, 0x49,
+			0x1f, 0xf0, 0x30, 0xc5,
+			0xa0, 0x73, 0x00, 0x13,
+			0x04, 0xf1, 0xa2, 0x73,
+			0x00, 0x13, 0x14, 0xf0,
+			0x28, 0xc5, 0xa0, 0x74,
+			0xc8, 0x49, 0x1b, 0xf1,
+			0x26, 0xc5, 0xa0, 0x76,
+			0xa2, 0x74, 0x01, 0x06,
+			0x20, 0x37, 0xa0, 0x9e,
+			0xa2, 0x9c, 0x1e, 0xc5,
+			0xa2, 0x73, 0x23, 0x40,
+			0x10, 0xf8, 0x04, 0xf3,
+			0xa0, 0x73, 0x33, 0x40,
+			0x0c, 0xf8, 0x15, 0xc5,
+			0xa0, 0x74, 0x41, 0x48,
+			0xa0, 0x9c, 0x14, 0xc5,
+			0xa0, 0x76, 0x62, 0x48,
+			0xe0, 0x48, 0xa0, 0x9e,
+			0x10, 0xc6, 0x00, 0xbe,
+			0x0a, 0xc5, 0xa0, 0x74,
+			0x48, 0x48, 0xa0, 0x9c,
+			0x0b, 0xc5, 0x20, 0x1e,
+			0xa0, 0x9e, 0xe5, 0x48,
+			0xa0, 0x9e, 0xf0, 0xe7,
+			0xbc, 0xc0, 0xc8, 0xd2,
+			0xcc, 0xd2, 0x28, 0xe4,
+			0x22, 0x02, 0xf0, 0xc0,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00 };
+		static u8 usb_patch_a2[] = {
+			0x08, 0xe0, 0x25, 0xe0,
+			0x8e, 0xe0, 0xb8, 0xe0,
+			0xba, 0xe0, 0xbc, 0xe0,
+			0xbe, 0xe0, 0xc0, 0xe0,
+			0x1c, 0xc2, 0x40, 0x71,
+			0x9f, 0x48, 0x40, 0x99,
+			0x1f, 0x48, 0x40, 0x99,
+			0x15, 0xc2, 0x40, 0x61,
+			0x90, 0x49, 0x0a, 0xf0,
+			0x42, 0x70, 0x80, 0x49,
+			0x07, 0xf0, 0x80, 0x48,
+			0x42, 0x98, 0x0b, 0xc2,
+			0x40, 0x60, 0x03, 0x48,
+			0x40, 0x88, 0x0a, 0xc2,
+			0x08, 0x18, 0x55, 0x60,
+			0x55, 0x88, 0x02, 0xc0,
+			0x00, 0xb8, 0xc2, 0x09,
+			0x28, 0xd4, 0xd4, 0xc4,
+			0x06, 0xd4, 0x00, 0xb0,
+			0x69, 0xc7, 0x62, 0xc6,
+			0xe4, 0x9e, 0x0f, 0x1e,
+			0xe6, 0x8e, 0xe6, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xe0, 0x73, 0xe2, 0x74,
+			0xb8, 0x26, 0xb8, 0x21,
+			0xb8, 0x25, 0x48, 0x23,
+			0x68, 0x27, 0x04, 0xb4,
+			0x05, 0xb4, 0x06, 0xb4,
+			0x52, 0xc6, 0xe3, 0x23,
+			0xfe, 0x39, 0x00, 0x1c,
+			0x00, 0x1d, 0x00, 0x13,
+			0x0c, 0xf0, 0xb0, 0x49,
+			0x04, 0xf1, 0x01, 0x05,
+			0xb1, 0x25, 0xfa, 0xe7,
+			0xb8, 0x33, 0x35, 0x43,
+			0x26, 0x31, 0x01, 0x05,
+			0xb1, 0x25, 0xf4, 0xe7,
+			0x06, 0xb0, 0x05, 0xb0,
+			0xae, 0x41, 0x25, 0x31,
+			0x3d, 0xc5, 0x6c, 0x41,
+			0x04, 0xb0, 0x48, 0x26,
+			0x05, 0xb4, 0x3c, 0xc7,
+			0x35, 0xc6, 0x04, 0x06,
+			0xe4, 0x9e, 0x0f, 0x1e,
+			0xe6, 0x8e, 0xe6, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xe0, 0x76, 0xe8, 0x25,
+			0xe8, 0x23, 0xf8, 0x27,
+			0x2a, 0xc5, 0x6c, 0x41,
+			0x33, 0x22, 0x23, 0x39,
+			0x7c, 0x41, 0xfd, 0x31,
+			0x25, 0xc6, 0x7e, 0x41,
+			0xf2, 0x21, 0xdf, 0x30,
+			0xdf, 0x30, 0x05, 0xb0,
+			0x53, 0x22, 0x25, 0x31,
+			0xa3, 0x31, 0x1b, 0xc7,
+			0xb7, 0x31, 0x1b, 0xc7,
+			0x77, 0x41, 0x1b, 0xc7,
+			0x1b, 0xc4, 0x84, 0x9f,
+			0x80, 0x9e, 0x16, 0xc3,
+			0xde, 0x30, 0x60, 0x65,
+			0x82, 0x9d, 0x8f, 0x1e,
+			0x8f, 0x1e, 0x8f, 0x1e,
+			0x86, 0x8e, 0x86, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x06, 0xc7, 0x04, 0x1e,
+			0xe0, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0xb6, 0x02,
+			0x34, 0xe4, 0x00, 0xc0,
+			0x25, 0x00, 0xff, 0x00,
+			0x7f, 0x00, 0x00, 0xf8,
+			0x88, 0xd3, 0x08, 0xdc,
+			0x1f, 0xc0, 0x1f, 0xc1,
+			0x00, 0x1c, 0x00, 0x99,
+			0x1d, 0xc1, 0x02, 0x99,
+			0x1c, 0xc1, 0x04, 0x99,
+			0x06, 0x9c, 0x1a, 0xc1,
+			0x08, 0x99, 0x0a, 0x9c,
+			0x18, 0xc1, 0x0c, 0x99,
+			0x17, 0xc1, 0x0e, 0x99,
+			0x10, 0x9c, 0x15, 0xc1,
+			0x12, 0x99, 0x14, 0xc1,
+			0x14, 0x99, 0x13, 0xc1,
+			0x16, 0x99, 0x12, 0xc1,
+			0x18, 0x99, 0x08, 0xc1,
+			0x1a, 0x9c, 0x0f, 0xc4,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x04, 0x33, 0x10, 0xc3,
+			0x02, 0x00, 0x08, 0x00,
+			0x38, 0x00, 0x48, 0x00,
+			0x08, 0x00, 0x40, 0x00,
+			0x00, 0x03, 0x80, 0x01,
+			0x12, 0x7a, 0x01, 0x01,
+			0xe0, 0xcb, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e };
+		u32 ocp_data;
 
-	fw_offset = __le16_to_cpu(phy->fw_offset);
-	length = __le32_to_cpu(phy->blk_hdr.length);
-	if (fw_offset < sizeof(*phy) || length <= fw_offset) {
-		dev_err(&tp->intf->dev, "invalid fw_offset\n");
-		goto out;
-	}
+		rtl_clear_bp(tp, MCU_TYPE_PLA);
 
-	length -= fw_offset;
-	if (length & 3) {
-		dev_err(&tp->intf->dev, "invalid block length\n");
-		goto out;
-	}
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch_a2),
+				  pla_patch_a2, MCU_TYPE_PLA);
 
-	if (__le16_to_cpu(phy->fw_reg) != 0x9A00) {
-		dev_err(&tp->intf->dev, "invalid register to load firmware\n");
-		goto out;
-	}
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
 
-	rc = true;
-out:
-	return rc;
-}
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x17a5);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x13ad);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x184d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x01e1);
 
-static bool rtl8152_is_fw_phy_ver_ok(struct r8152 *tp, struct fw_phy_ver *ver)
-{
-	bool rc = false;
+		rtl_clear_bp(tp, MCU_TYPE_USB);
 
-	switch (tp->version) {
-	case RTL_VER_10:
-	case RTL_VER_11:
-	case RTL_VER_12:
-	case RTL_VER_13:
-	case RTL_VER_15:
-		break;
-	default:
-		goto out;
-	}
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(usb_patch_a2),
+				  usb_patch_a2, MCU_TYPE_USB);
 
-	if (__le32_to_cpu(ver->blk_hdr.length) != sizeof(*ver)) {
-		dev_err(&tp->intf->dev, "invalid block length\n");
-		goto out;
-	}
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc26, 0xA000);
 
-	if (__le16_to_cpu(ver->ver.addr) != SRAM_GPHY_FW_VER) {
-		dev_err(&tp->intf->dev, "invalid phy ver addr\n");
-		goto out;
-	}
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc28, 0x0c87);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2a, 0x024f);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2c, 0x3303);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2e, 0x0000);
 
-	rc = true;
-out:
-	return rc;
-}
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xd428);
+		ocp_data |= BIT(15);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xd428, ocp_data);
 
-static bool rtl8152_is_fw_phy_fixup_ok(struct r8152 *tp, struct fw_phy_fixup *fix)
-{
-	bool rc = false;
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xc4d4);
+		ocp_data |= BIT(0);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xc4d4, ocp_data);
 
-	switch (tp->version) {
-	case RTL_VER_10:
-	case RTL_VER_11:
-	case RTL_VER_12:
-	case RTL_VER_13:
-	case RTL_VER_15:
-		break;
-	default:
-		goto out;
-	}
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xc4d6);
+		ocp_data &= ~BIT(0);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xc4d6, ocp_data);
 
-	if (__le32_to_cpu(fix->blk_hdr.length) != sizeof(*fix)) {
-		dev_err(&tp->intf->dev, "invalid block length\n");
-		goto out;
-	}
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xc5d4);
+		ocp_data |= BIT(2) | BIT(5);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xc5d4, ocp_data);
 
-	if (__le16_to_cpu(fix->setting.addr) != OCP_PHY_PATCH_CMD ||
-	    __le16_to_cpu(fix->setting.data) != BIT(7)) {
-		dev_err(&tp->intf->dev, "invalid phy fixup\n");
-		goto out;
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xd428);
+		ocp_data &= ~BIT(15);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xd428, ocp_data);
+
+		rtl_reset_ocp_base(tp);
 	}
 
-	rc = true;
-out:
-	return rc;
+	rtl_reset_ocp_base(tp);
 }
 
-static bool rtl8152_is_fw_phy_union_ok(struct r8152 *tp, struct fw_phy_union *phy)
+static void r8152_aldps_en(struct r8152 *tp, bool enable)
 {
-	u16 fw_offset;
-	u32 length;
-	bool rc = false;
-
-	switch (tp->version) {
-	case RTL_VER_10:
-	case RTL_VER_11:
-	case RTL_VER_12:
-	case RTL_VER_13:
-	case RTL_VER_15:
-		break;
-	default:
-		goto out;
-	}
-
-	fw_offset = __le16_to_cpu(phy->fw_offset);
-	length = __le32_to_cpu(phy->blk_hdr.length);
-	if (fw_offset < sizeof(*phy) || length <= fw_offset) {
-		dev_err(&tp->intf->dev, "invalid fw_offset\n");
-		goto out;
+	if (enable) {
+		ocp_reg_write(tp, OCP_ALDPS_CONFIG, ENPWRSAVE | ENPDNPS |
+						    LINKENA | DIS_SDSAVE);
+	} else {
+		ocp_reg_write(tp, OCP_ALDPS_CONFIG, ENPDNPS | LINKENA |
+						    DIS_SDSAVE);
+		msleep(20);
 	}
+}
 
-	length -= fw_offset;
-	if (length & 1) {
-		dev_err(&tp->intf->dev, "invalid block length\n");
-		goto out;
-	}
+static inline void r8152_mmd_indirect(struct r8152 *tp, u16 dev, u16 reg)
+{
+	ocp_reg_write(tp, OCP_EEE_AR, FUN_ADDR | dev);
+	ocp_reg_write(tp, OCP_EEE_DATA, reg);
+	ocp_reg_write(tp, OCP_EEE_AR, FUN_DATA | dev);
+}
 
-	if (phy->pre_num > 2) {
-		dev_err(&tp->intf->dev, "invalid pre_num %d\n", phy->pre_num);
-		goto out;
-	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+static u16 r8152_mmd_read(struct r8152 *tp, u16 dev, u16 reg)
+{
+	u16 data;
 
-	if (phy->bp_num > 8) {
-		dev_err(&tp->intf->dev, "invalid bp_num %d\n", phy->bp_num);
-		goto out;
-	}
+	r8152_mmd_indirect(tp, dev, reg);
+	data = ocp_reg_read(tp, OCP_EEE_DATA);
+	ocp_reg_write(tp, OCP_EEE_AR, 0x0000);
 
-	rc = true;
-out:
-	return rc;
+	return data;
 }
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
 
-static bool rtl8152_is_fw_phy_nc_ok(struct r8152 *tp, struct fw_phy_nc *phy)
+static void r8152_mmd_write(struct r8152 *tp, u16 dev, u16 reg, u16 data)
 {
-	u32 length;
-	u16 fw_offset, fw_reg, ba_reg, patch_en_addr, mode_reg, bp_start;
-	bool rc = false;
-
-	switch (tp->version) {
-	case RTL_VER_04:
-	case RTL_VER_05:
-	case RTL_VER_06:
-		fw_reg = 0xa014;
-		ba_reg = 0xa012;
-		patch_en_addr = 0xa01a;
-		mode_reg = 0xb820;
-		bp_start = 0xa000;
-		break;
-	default:
-		goto out;
-	}
-
-	fw_offset = __le16_to_cpu(phy->fw_offset);
-	if (fw_offset < sizeof(*phy)) {
-		dev_err(&tp->intf->dev, "fw_offset too small\n");
-		goto out;
-	}
+	r8152_mmd_indirect(tp, dev, reg);
+	ocp_reg_write(tp, OCP_EEE_DATA, data);
+	ocp_reg_write(tp, OCP_EEE_AR, 0x0000);
+}
 
-	length = __le32_to_cpu(phy->blk_hdr.length);
-	if (length < fw_offset) {
-		dev_err(&tp->intf->dev, "invalid fw_offset\n");
-		goto out;
-	}
+static void r8152_eee_en(struct r8152 *tp, bool enable)
+{
+	u16 config1, config2, config3;
+	u32 ocp_data;
 
-	length -= __le16_to_cpu(phy->fw_offset);
-	if (!length || (length & 1)) {
-		dev_err(&tp->intf->dev, "invalid block length\n");
-		goto out;
-	}
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);
+	config1 = ocp_reg_read(tp, OCP_EEE_CONFIG1) & ~sd_rise_time_mask;
+	config2 = ocp_reg_read(tp, OCP_EEE_CONFIG2);
+	config3 = ocp_reg_read(tp, OCP_EEE_CONFIG3) & ~fast_snr_mask;
 
-	if (__le16_to_cpu(phy->fw_reg) != fw_reg) {
-		dev_err(&tp->intf->dev, "invalid register to load firmware\n");
-		goto out;
+	if (enable) {
+		ocp_data |= EEE_RX_EN | EEE_TX_EN;
+		config1 |= EEE_10_CAP | EEE_NWAY_EN | TX_QUIET_EN | RX_QUIET_EN;
+		config1 |= sd_rise_time(1);
+		config2 |= RG_DACQUIET_EN | RG_LDVQUIET_EN;
+		config3 |= fast_snr(42);
+	} else {
+		ocp_data &= ~(EEE_RX_EN | EEE_TX_EN);
+		config1 &= ~(EEE_10_CAP | EEE_NWAY_EN | TX_QUIET_EN |
+			     RX_QUIET_EN);
+		config1 |= sd_rise_time(7);
+		config2 &= ~(RG_DACQUIET_EN | RG_LDVQUIET_EN);
+		config3 |= fast_snr(511);
 	}
 
-	if (__le16_to_cpu(phy->ba_reg) != ba_reg) {
-		dev_err(&tp->intf->dev, "invalid base address register\n");
-		goto out;
-	}
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_CR, ocp_data);
+	ocp_reg_write(tp, OCP_EEE_CONFIG1, config1);
+	ocp_reg_write(tp, OCP_EEE_CONFIG2, config2);
+	ocp_reg_write(tp, OCP_EEE_CONFIG3, config3);
+}
 
-	if (__le16_to_cpu(phy->patch_en_addr) != patch_en_addr) {
-		dev_err(&tp->intf->dev,
-			"invalid patch mode enabled register\n");
-		goto out;
-	}
+static void r8153_eee_en(struct r8152 *tp, bool enable)
+{
+	u32 ocp_data;
+	u16 config;
 
-	if (__le16_to_cpu(phy->mode_reg) != mode_reg) {
-		dev_err(&tp->intf->dev,
-			"invalid register to switch the mode\n");
-		goto out;
-	}
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);
+	config = ocp_reg_read(tp, OCP_EEE_CFG);
 
-	if (__le16_to_cpu(phy->bp_start) != bp_start) {
-		dev_err(&tp->intf->dev,
-			"invalid start register of break point\n");
-		goto out;
+	if (enable) {
+		ocp_data |= EEE_RX_EN | EEE_TX_EN;
+		config |= EEE10_EN;
+	} else {
+		ocp_data &= ~(EEE_RX_EN | EEE_TX_EN);
+		config &= ~EEE10_EN;
 	}
 
-	if (__le16_to_cpu(phy->bp_num) > 4) {
-		dev_err(&tp->intf->dev, "invalid break point number\n");
-		goto out;
-	}
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_CR, ocp_data);
+	ocp_reg_write(tp, OCP_EEE_CFG, config);
 
-	rc = true;
-out:
-	return rc;
+	tp->ups_info.eee = enable;
 }
 
-static bool rtl8152_is_fw_mac_ok(struct r8152 *tp, struct fw_mac *mac)
+static void r8156_eee_en(struct r8152 *tp, bool enable)
 {
-	u16 fw_reg, bp_ba_addr, bp_en_addr, bp_start, fw_offset;
-	bool rc = false;
-	u32 length, type;
-	int i, max_bp;
+	u16 config;
 
-	type = __le32_to_cpu(mac->blk_hdr.type);
-	if (type == RTL_FW_PLA) {
-		switch (tp->version) {
-		case RTL_VER_01:
-		case RTL_VER_02:
-		case RTL_VER_07:
-			fw_reg = 0xf800;
-			bp_ba_addr = PLA_BP_BA;
-			bp_en_addr = 0;
-			bp_start = PLA_BP_0;
-			max_bp = 8;
-			break;
-		case RTL_VER_03:
-		case RTL_VER_04:
-		case RTL_VER_05:
-		case RTL_VER_06:
-		case RTL_VER_08:
-		case RTL_VER_09:
-		case RTL_VER_11:
-		case RTL_VER_12:
-		case RTL_VER_13:
-		case RTL_VER_15:
-			fw_reg = 0xf800;
-			bp_ba_addr = PLA_BP_BA;
-			bp_en_addr = PLA_BP_EN;
-			bp_start = PLA_BP_0;
-			max_bp = 8;
-			break;
-		case RTL_VER_14:
-			fw_reg = 0xf800;
-			bp_ba_addr = PLA_BP_BA;
-			bp_en_addr = USB_BP2_EN;
-			bp_start = PLA_BP_0;
-			max_bp = 16;
-			break;
-		default:
-			goto out;
-		}
-	} else if (type == RTL_FW_USB) {
-		switch (tp->version) {
-		case RTL_VER_03:
-		case RTL_VER_04:
-		case RTL_VER_05:
-		case RTL_VER_06:
-			fw_reg = 0xf800;
-			bp_ba_addr = USB_BP_BA;
-			bp_en_addr = USB_BP_EN;
-			bp_start = USB_BP_0;
-			max_bp = 8;
-			break;
-		case RTL_VER_08:
-		case RTL_VER_09:
-		case RTL_VER_11:
-		case RTL_VER_12:
-		case RTL_VER_13:
-		case RTL_VER_14:
-		case RTL_VER_15:
-			fw_reg = 0xe600;
-			bp_ba_addr = USB_BP_BA;
-			bp_en_addr = USB_BP2_EN;
-			bp_start = USB_BP_0;
-			max_bp = 16;
-			break;
-		case RTL_VER_01:
-		case RTL_VER_02:
-		case RTL_VER_07:
-		default:
-			goto out;
-		}
-	} else {
-		goto out;
-	}
+	r8153_eee_en(tp, enable);
 
-	fw_offset = __le16_to_cpu(mac->fw_offset);
-	if (fw_offset < sizeof(*mac)) {
-		dev_err(&tp->intf->dev, "fw_offset too small\n");
-		goto out;
-	}
+	config = ocp_reg_read(tp, OCP_EEE_ADV2);
 
-	length = __le32_to_cpu(mac->blk_hdr.length);
-	if (length < fw_offset) {
-		dev_err(&tp->intf->dev, "invalid fw_offset\n");
-		goto out;
-	}
+	if (enable)
+		config |= MDIO_EEE_2_5GT;
+	else
+		config &= ~MDIO_EEE_2_5GT;
 
-	length -= fw_offset;
-	if (length < 4 || (length & 3)) {
-		dev_err(&tp->intf->dev, "invalid block length\n");
-		goto out;
-	}
+	ocp_reg_write(tp, OCP_EEE_ADV2, config);
+}
 
-	if (__le16_to_cpu(mac->fw_reg) != fw_reg) {
-		dev_err(&tp->intf->dev, "invalid register to load firmware\n");
-		goto out;
+static void rtl_eee_enable(struct r8152 *tp, bool enable)
+{
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+		if (enable) {
+			r8152_eee_en(tp, true);
+			r8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV,
+					tp->eee_adv);
+		} else {
+			r8152_eee_en(tp, false);
+			r8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, 0);
+		}
+		break;
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_VER_14:
+		if (enable) {
+			r8153_eee_en(tp, true);
+			ocp_reg_write(tp, OCP_EEE_ADV, tp->eee_adv);
+		} else {
+			r8153_eee_en(tp, false);
+			ocp_reg_write(tp, OCP_EEE_ADV, 0);
+		}
+		break;
+	case RTL_VER_10:
+	case RTL_VER_11:
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_15:
+		if (enable) {
+			r8156_eee_en(tp, true);
+			ocp_reg_write(tp, OCP_EEE_ADV, tp->eee_adv);
+		} else {
+			r8156_eee_en(tp, false);
+			ocp_reg_write(tp, OCP_EEE_ADV, 0);
+		}
+		break;
+	default:
+		break;
 	}
+}
 
-	if (__le16_to_cpu(mac->bp_ba_addr) != bp_ba_addr) {
-		dev_err(&tp->intf->dev, "invalid base address register\n");
-		goto out;
-	}
+static void r8152b_enable_fc(struct r8152 *tp)
+{
+	u16 anar;
 
-	if (__le16_to_cpu(mac->bp_en_addr) != bp_en_addr) {
-		dev_err(&tp->intf->dev, "invalid enabled mask register\n");
-		goto out;
-	}
+	anar = r8152_mdio_read(tp, MII_ADVERTISE);
+	anar |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
+	r8152_mdio_write(tp, MII_ADVERTISE, anar);
 
-	if (__le16_to_cpu(mac->bp_start) != bp_start) {
-		dev_err(&tp->intf->dev,
-			"invalid start register of break point\n");
-		goto out;
-	}
+	tp->ups_info.flow_control = true;
+}
 
-	if (__le16_to_cpu(mac->bp_num) > max_bp) {
-		dev_err(&tp->intf->dev, "invalid break point number\n");
-		goto out;
-	}
+static void rtl8152_disable(struct r8152 *tp)
+{
+	r8152_aldps_en(tp, false);
+	rtl_disable(tp);
+	r8152_aldps_en(tp, true);
+}
 
-	for (i = __le16_to_cpu(mac->bp_num); i < max_bp; i++) {
-		if (mac->bp[i]) {
-			dev_err(&tp->intf->dev, "unused bp%u is not zero\n", i);
-			goto out;
-		}
-	}
+static void r8152b_hw_phy_cfg(struct r8152 *tp)
+{
+	r8152b_firmware(tp);
 
-	rc = true;
-out:
-	return rc;
-}
+	rtl_eee_enable(tp, tp->eee_en);
+	r8152_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
 
-/* Verify the checksum for the firmware file. It is calculated from the version
- * field to the end of the file. Compare the result with the checksum field to
- * make sure the file is correct.
- */
-static long rtl8152_fw_verify_checksum(struct r8152 *tp,
-				       struct fw_header *fw_hdr, size_t size)
-{
-	unsigned char checksum[sizeof(fw_hdr->checksum)];
-	struct crypto_shash *alg;
-	struct shash_desc *sdesc;
-	size_t len;
-	long rc;
-
-	alg = crypto_alloc_shash("sha256", 0, 0);
-	if (IS_ERR(alg)) {
-		rc = PTR_ERR(alg);
-		goto out;
-	}
+	set_bit(PHY_RESET, &tp->flags);
+}
 
-	if (crypto_shash_digestsize(alg) != sizeof(fw_hdr->checksum)) {
-		rc = -EFAULT;
-		dev_err(&tp->intf->dev, "digestsize incorrect (%u)\n",
-			crypto_shash_digestsize(alg));
-		goto free_shash;
-	}
+static void wait_oob_link_list_ready(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i;
 
-	len = sizeof(*sdesc) + crypto_shash_descsize(alg);
-	sdesc = kmalloc(len, GFP_KERNEL);
-	if (!sdesc) {
-		rc = -ENOMEM;
-		goto free_shash;
+	for (i = 0; i < 1000; i++) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+		if (ocp_data & LINK_LIST_READY)
+			break;
+		usleep_range(1000, 2000);
 	}
-	sdesc->tfm = alg;
+}
 
-	len = size - sizeof(fw_hdr->checksum);
-	rc = crypto_shash_digest(sdesc, fw_hdr->version, len, checksum);
-	kfree(sdesc);
-	if (rc)
-		goto free_shash;
+static void r8156b_wait_loading_flash(struct r8152 *tp)
+{
+	if (r8156b_flash_used(tp)) {
+		int i;
 
-	if (memcmp(fw_hdr->checksum, checksum, sizeof(fw_hdr->checksum))) {
-		dev_err(&tp->intf->dev, "checksum fail\n");
-		rc = -EFAULT;
+		for (i = 0; i < 100; i++) {
+			if (ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL) &
+			    GPHY_PATCH_DONE)
+				break;
+			usleep_range(1000, 2000);
+		}
 	}
-
-free_shash:
-	crypto_free_shash(alg);
-out:
-	return rc;
 }
 
-static long rtl8152_check_firmware(struct r8152 *tp, struct rtl_fw *rtl_fw)
+static void r8152b_exit_oob(struct r8152 *tp)
 {
-	const struct firmware *fw = rtl_fw->fw;
-	struct fw_header *fw_hdr = (struct fw_header *)fw->data;
-	unsigned long fw_flags = 0;
-	long ret = -EFAULT;
-	int i;
+	u32 ocp_data;
 
-	if (fw->size < sizeof(*fw_hdr)) {
-		dev_err(&tp->intf->dev, "file too small\n");
-		goto fail;
-	}
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+	ocp_data &= ~RCR_ACPT_ALL;
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
 
-	ret = rtl8152_fw_verify_checksum(tp, fw_hdr, fw->size);
-	if (ret)
-		goto fail;
-
-	ret = -EFAULT;
-
-	for (i = sizeof(*fw_hdr); i < fw->size;) {
-		struct fw_block *block = (struct fw_block *)&fw->data[i];
-		u32 type;
-
-		if ((i + sizeof(*block)) > fw->size)
-			goto fail;
-
-		type = __le32_to_cpu(block->type);
-		switch (type) {
-		case RTL_FW_END:
-			if (__le32_to_cpu(block->length) != sizeof(*block))
-				goto fail;
-			goto fw_end;
-		case RTL_FW_PLA:
-			if (test_bit(FW_FLAGS_PLA, &fw_flags)) {
-				dev_err(&tp->intf->dev,
-					"multiple PLA firmware encountered");
-				goto fail;
-			}
+	rxdy_gated_en(tp, true);
+	r8153_teredo_off(tp);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, 0x00);
 
-			if (!rtl8152_is_fw_mac_ok(tp, (struct fw_mac *)block)) {
-				dev_err(&tp->intf->dev,
-					"check PLA firmware failed\n");
-				goto fail;
-			}
-			__set_bit(FW_FLAGS_PLA, &fw_flags);
-			break;
-		case RTL_FW_USB:
-			if (test_bit(FW_FLAGS_USB, &fw_flags)) {
-				dev_err(&tp->intf->dev,
-					"multiple USB firmware encountered");
-				goto fail;
-			}
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+	ocp_data &= ~NOW_IS_OOB;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
 
-			if (!rtl8152_is_fw_mac_ok(tp, (struct fw_mac *)block)) {
-				dev_err(&tp->intf->dev,
-					"check USB firmware failed\n");
-				goto fail;
-			}
-			__set_bit(FW_FLAGS_USB, &fw_flags);
-			break;
-		case RTL_FW_PHY_START:
-			if (test_bit(FW_FLAGS_START, &fw_flags) ||
-			    test_bit(FW_FLAGS_NC, &fw_flags) ||
-			    test_bit(FW_FLAGS_NC1, &fw_flags) ||
-			    test_bit(FW_FLAGS_NC2, &fw_flags) ||
-			    test_bit(FW_FLAGS_UC2, &fw_flags) ||
-			    test_bit(FW_FLAGS_UC, &fw_flags) ||
-			    test_bit(FW_FLAGS_STOP, &fw_flags)) {
-				dev_err(&tp->intf->dev,
-					"check PHY_START fail\n");
-				goto fail;
-			}
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+	ocp_data &= ~MCU_BORW_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
 
-			if (__le32_to_cpu(block->length) != sizeof(struct fw_phy_patch_key)) {
-				dev_err(&tp->intf->dev,
-					"Invalid length for PHY_START\n");
-				goto fail;
-			}
-			__set_bit(FW_FLAGS_START, &fw_flags);
-			break;
-		case RTL_FW_PHY_STOP:
-			if (test_bit(FW_FLAGS_STOP, &fw_flags) ||
-			    !test_bit(FW_FLAGS_START, &fw_flags)) {
-				dev_err(&tp->intf->dev,
-					"Check PHY_STOP fail\n");
-				goto fail;
-			}
+	wait_oob_link_list_ready(tp);
 
-			if (__le32_to_cpu(block->length) != sizeof(*block)) {
-				dev_err(&tp->intf->dev,
-					"Invalid length for PHY_STOP\n");
-				goto fail;
-			}
-			__set_bit(FW_FLAGS_STOP, &fw_flags);
-			break;
-		case RTL_FW_PHY_NC:
-			if (!test_bit(FW_FLAGS_START, &fw_flags) ||
-			    test_bit(FW_FLAGS_STOP, &fw_flags)) {
-				dev_err(&tp->intf->dev,
-					"check PHY_NC fail\n");
-				goto fail;
-			}
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+	ocp_data |= RE_INIT_LL;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
 
-			if (test_bit(FW_FLAGS_NC, &fw_flags)) {
-				dev_err(&tp->intf->dev,
-					"multiple PHY NC encountered\n");
-				goto fail;
-			}
+	wait_oob_link_list_ready(tp);
 
-			if (!rtl8152_is_fw_phy_nc_ok(tp, (struct fw_phy_nc *)block)) {
-				dev_err(&tp->intf->dev,
-					"check PHY NC firmware failed\n");
-				goto fail;
-			}
-			__set_bit(FW_FLAGS_NC, &fw_flags);
-			break;
-		case RTL_FW_PHY_UNION_NC:
-			if (!test_bit(FW_FLAGS_START, &fw_flags) ||
-			    test_bit(FW_FLAGS_NC1, &fw_flags) ||
-			    test_bit(FW_FLAGS_NC2, &fw_flags) ||
-			    test_bit(FW_FLAGS_UC2, &fw_flags) ||
-			    test_bit(FW_FLAGS_UC, &fw_flags) ||
-			    test_bit(FW_FLAGS_STOP, &fw_flags)) {
-				dev_err(&tp->intf->dev, "PHY_UNION_NC out of order\n");
-				goto fail;
-			}
+	rtl8152_nic_reset(tp);
 
-			if (test_bit(FW_FLAGS_NC, &fw_flags)) {
-				dev_err(&tp->intf->dev, "multiple PHY_UNION_NC encountered\n");
-				goto fail;
-			}
+	/* rx share fifo credit full threshold */
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_NORMAL);
 
-			if (!rtl8152_is_fw_phy_union_ok(tp, (struct fw_phy_union *)block)) {
-				dev_err(&tp->intf->dev, "check PHY_UNION_NC failed\n");
-				goto fail;
-			}
-			__set_bit(FW_FLAGS_NC, &fw_flags);
-			break;
-		case RTL_FW_PHY_UNION_NC1:
-			if (!test_bit(FW_FLAGS_START, &fw_flags) ||
-			    test_bit(FW_FLAGS_NC2, &fw_flags) ||
-			    test_bit(FW_FLAGS_UC2, &fw_flags) ||
-			    test_bit(FW_FLAGS_UC, &fw_flags) ||
-			    test_bit(FW_FLAGS_STOP, &fw_flags)) {
-				dev_err(&tp->intf->dev, "PHY_UNION_NC1 out of order\n");
-				goto fail;
-			}
+	if (tp->udev->speed == USB_SPEED_FULL ||
+	    tp->udev->speed == USB_SPEED_LOW) {
+		/* rx share fifo credit near full threshold */
+		ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,
+				RXFIFO_THR2_FULL);
+		ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,
+				RXFIFO_THR3_FULL);
+	} else {
+		/* rx share fifo credit near full threshold */
+		ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,
+				RXFIFO_THR2_HIGH);
+		ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,
+				RXFIFO_THR3_HIGH);
+	}
 
-			if (test_bit(FW_FLAGS_NC1, &fw_flags)) {
-				dev_err(&tp->intf->dev, "multiple PHY NC1 encountered\n");
-				goto fail;
-			}
+	/* TX share fifo free credit full threshold */
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, TXFIFO_THR_NORMAL2);
 
-			if (!rtl8152_is_fw_phy_union_ok(tp, (struct fw_phy_union *)block)) {
-				dev_err(&tp->intf->dev, "check PHY_UNION_NC1 failed\n");
-				goto fail;
-			}
-			__set_bit(FW_FLAGS_NC1, &fw_flags);
-			break;
-		case RTL_FW_PHY_UNION_NC2:
-			if (!test_bit(FW_FLAGS_START, &fw_flags) ||
-			    test_bit(FW_FLAGS_UC2, &fw_flags) ||
-			    test_bit(FW_FLAGS_UC, &fw_flags) ||
-			    test_bit(FW_FLAGS_STOP, &fw_flags)) {
-				dev_err(&tp->intf->dev, "PHY_UNION_NC2 out of order\n");
-				goto fail;
-			}
+	ocp_write_byte(tp, MCU_TYPE_USB, USB_TX_AGG, TX_AGG_MAX_THRESHOLD);
+	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_HIGH);
+	ocp_write_dword(tp, MCU_TYPE_USB, USB_TX_DMA,
+			TEST_MODE_DISABLE | TX_SIZE_ADJUST1);
 
-			if (test_bit(FW_FLAGS_NC2, &fw_flags)) {
-				dev_err(&tp->intf->dev, "multiple PHY NC2 encountered\n");
-				goto fail;
-			}
+	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
 
-			if (!rtl8152_is_fw_phy_union_ok(tp, (struct fw_phy_union *)block)) {
-				dev_err(&tp->intf->dev, "check PHY_UNION_NC2 failed\n");
-				goto fail;
-			}
-			__set_bit(FW_FLAGS_NC2, &fw_flags);
-			break;
-		case RTL_FW_PHY_UNION_UC2:
-			if (!test_bit(FW_FLAGS_START, &fw_flags) ||
-			    test_bit(FW_FLAGS_UC, &fw_flags) ||
-			    test_bit(FW_FLAGS_STOP, &fw_flags)) {
-				dev_err(&tp->intf->dev, "PHY_UNION_UC2 out of order\n");
-				goto fail;
-			}
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8152_RMS);
 
-			if (test_bit(FW_FLAGS_UC2, &fw_flags)) {
-				dev_err(&tp->intf->dev, "multiple PHY UC2 encountered\n");
-				goto fail;
-			}
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0);
+	ocp_data |= TCR0_AUTO_FIFO;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TCR0, ocp_data);
+}
 
-			if (!rtl8152_is_fw_phy_union_ok(tp, (struct fw_phy_union *)block)) {
-				dev_err(&tp->intf->dev, "check PHY_UNION_UC2 failed\n");
-				goto fail;
-			}
-			__set_bit(FW_FLAGS_UC2, &fw_flags);
-			break;
-		case RTL_FW_PHY_UNION_UC:
-			if (!test_bit(FW_FLAGS_START, &fw_flags) ||
-			    test_bit(FW_FLAGS_STOP, &fw_flags)) {
-				dev_err(&tp->intf->dev, "PHY_UNION_UC out of order\n");
-				goto fail;
-			}
+static void r8152b_enter_oob(struct r8152 *tp)
+{
+	u32 ocp_data;
 
-			if (test_bit(FW_FLAGS_UC, &fw_flags)) {
-				dev_err(&tp->intf->dev, "multiple PHY UC encountered\n");
-				goto fail;
-			}
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+	ocp_data &= ~NOW_IS_OOB;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
 
-			if (!rtl8152_is_fw_phy_union_ok(tp, (struct fw_phy_union *)block)) {
-				dev_err(&tp->intf->dev, "check PHY_UNION_UC failed\n");
-				goto fail;
-			}
-			__set_bit(FW_FLAGS_UC, &fw_flags);
-			break;
-		case RTL_FW_PHY_UNION_MISC:
-			if (!rtl8152_is_fw_phy_union_ok(tp, (struct fw_phy_union *)block)) {
-				dev_err(&tp->intf->dev, "check RTL_FW_PHY_UNION_MISC failed\n");
-				goto fail;
-			}
-			break;
-		case RTL_FW_PHY_FIXUP:
-			if (!rtl8152_is_fw_phy_fixup_ok(tp, (struct fw_phy_fixup *)block)) {
-				dev_err(&tp->intf->dev, "check PHY fixup failed\n");
-				goto fail;
-			}
-			break;
-		case RTL_FW_PHY_SPEED_UP:
-			if (test_bit(FW_FLAGS_SPEED_UP, &fw_flags)) {
-				dev_err(&tp->intf->dev, "multiple PHY firmware encountered");
-				goto fail;
-			}
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_OOB);
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_OOB);
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_OOB);
 
-			if (!rtl8152_is_fw_phy_speed_up_ok(tp, (struct fw_phy_speed_up *)block)) {
-				dev_err(&tp->intf->dev, "check PHY speed up failed\n");
-				goto fail;
-			}
-			__set_bit(FW_FLAGS_SPEED_UP, &fw_flags);
-			break;
-		case RTL_FW_PHY_VER:
-			if (test_bit(FW_FLAGS_START, &fw_flags) ||
-			    test_bit(FW_FLAGS_NC, &fw_flags) ||
-			    test_bit(FW_FLAGS_NC1, &fw_flags) ||
-			    test_bit(FW_FLAGS_NC2, &fw_flags) ||
-			    test_bit(FW_FLAGS_UC2, &fw_flags) ||
-			    test_bit(FW_FLAGS_UC, &fw_flags) ||
-			    test_bit(FW_FLAGS_STOP, &fw_flags)) {
-				dev_err(&tp->intf->dev, "Invalid order to set PHY version\n");
-				goto fail;
-			}
+	rtl_disable(tp);
 
-			if (test_bit(FW_FLAGS_VER, &fw_flags)) {
-				dev_err(&tp->intf->dev, "multiple PHY version encountered");
-				goto fail;
-			}
+	wait_oob_link_list_ready(tp);
 
-			if (!rtl8152_is_fw_phy_ver_ok(tp, (struct fw_phy_ver *)block)) {
-				dev_err(&tp->intf->dev, "check PHY version failed\n");
-				goto fail;
-			}
-			__set_bit(FW_FLAGS_VER, &fw_flags);
-			break;
-		default:
-			dev_warn(&tp->intf->dev, "Unknown type %u is found\n",
-				 type);
-			break;
-		}
-
-		/* next block */
-		i += ALIGN(__le32_to_cpu(block->length), 8);
-	}
-
-fw_end:
-	if (test_bit(FW_FLAGS_START, &fw_flags) && !test_bit(FW_FLAGS_STOP, &fw_flags)) {
-		dev_err(&tp->intf->dev, "without PHY_STOP\n");
-		goto fail;
-	}
-
-	return 0;
-fail:
-	return ret;
-}
-
-static void rtl_ram_code_speed_up(struct r8152 *tp, struct fw_phy_speed_up *phy, bool wait)
-{
-	u32 len;
-	u8 *data;
-
-	rtl_reset_ocp_base(tp);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+	ocp_data |= RE_INIT_LL;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
 
-	if (sram_read(tp, SRAM_GPHY_FW_VER) >= __le16_to_cpu(phy->version)) {
-		dev_dbg(&tp->intf->dev, "PHY firmware has been the newest\n");
-		return;
-	}
+	wait_oob_link_list_ready(tp);
 
-	len = __le32_to_cpu(phy->blk_hdr.length);
-	len -= __le16_to_cpu(phy->fw_offset);
-	data = (u8 *)phy + __le16_to_cpu(phy->fw_offset);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8152_RMS);
 
-	if (rtl_phy_patch_request(tp, true, wait))
-		return;
+	rtl_rx_vlan_en(tp, true);
 
-	while (len) {
-		u32 ocp_data, size;
-		int i;
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BDC_CR);
+	ocp_data |= ALDPS_PROXY_MODE;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_BDC_CR, ocp_data);
 
-		if (len < 2048)
-			size = len;
-		else
-			size = 2048;
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+	ocp_data |= NOW_IS_OOB | DIS_MCU_CLROOB;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
 
-		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL);
-		ocp_data |= GPHY_PATCH_DONE | BACKUP_RESTRORE;
-		ocp_write_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL, ocp_data);
+	rxdy_gated_en(tp, false);
 
-		generic_ocp_write(tp, __le16_to_cpu(phy->fw_reg), 0xff, size, data, MCU_TYPE_USB);
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+	ocp_data |= RCR_APM | RCR_AM | RCR_AB;
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+}
 
-		data += size;
-		len -= size;
+static int r8156_lock_main(struct r8152 *tp, bool lock)
+{
+	u16 data;
+	int i;
 
-		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL);
-		ocp_data |= POL_GPHY_PATCH;
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL, ocp_data);
+	data = ocp_reg_read(tp, 0xa46a);
+	if (lock)
+		data |= BIT(1);
+	else
+		data &= ~BIT(1);
+	ocp_reg_write(tp, 0xa46a, data);
 
-		for (i = 0; i < 1000; i++) {
-			if (!(ocp_read_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL) & POL_GPHY_PATCH))
+	if (lock) {
+		for (i = 0; i < 100; i++) {
+			usleep_range(1000, 2000);
+			data = ocp_reg_read(tp, 0xa730) & 0xff;
+			if (data == 1)
 				break;
 		}
-
-		if (i == 1000) {
-			dev_err(&tp->intf->dev, "ram code speedup mode timeout\n");
-			break;
+	} else {
+		for (i = 0; i < 100; i++) {
+			usleep_range(1000, 2000);
+			data = ocp_reg_read(tp, 0xa730) & 0xff;
+			if (data != 1)
+				break;
 		}
 	}
 
-	rtl_reset_ocp_base(tp);
-
-	rtl_phy_patch_request(tp, false, wait);
-
-	if (sram_read(tp, SRAM_GPHY_FW_VER) == __le16_to_cpu(phy->version))
-		dev_dbg(&tp->intf->dev, "successfully applied %s\n", phy->info);
+	if (i == 100)
+		return -ETIME;
 	else
-		dev_err(&tp->intf->dev, "ram code speedup mode fail\n");
+		return 0;
 }
 
-static int rtl8152_fw_phy_ver(struct r8152 *tp, struct fw_phy_ver *phy_ver)
+static void r8153_wdt1_end(struct r8152 *tp)
 {
-	u16 ver_addr, ver;
-
-	ver_addr = __le16_to_cpu(phy_ver->ver.addr);
-	ver = __le16_to_cpu(phy_ver->ver.data);
+	int i;
 
-	rtl_reset_ocp_base(tp);
+	/* Wait till the WTD timer is ready. It would take at most 104 ms. */
+	for (i = 0; i < 104; i++) {
+		u32 ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_WDT1_CTRL);
 
-	if (sram_read(tp, ver_addr) >= ver) {
-		dev_dbg(&tp->intf->dev, "PHY firmware has been the newest\n");
-		return 0;
+		if (!(ocp_data & WTD1_EN))
+			break;
+		usleep_range(1000, 2000);
 	}
+}
 
-	sram_write(tp, ver_addr, ver);
-
-	dev_dbg(&tp->intf->dev, "PHY firmware version %x\n", ver);
-
-	return ver;
+#define DBG_COUNTER_MASK		0x1f
+#define DBG_DRV_RUNNING			(1 << 5)
+#define DGB_DRV_STATE_MASK		(3 << 14)
+#define DGB_DRV_STATE_LOAD		(2 << 14)
+#define DGB_DRV_STATE_UNLOAD		(1 << 14)
+static void rtl_set_dbg_info_init(struct r8152 *tp)
+{
+	u32 counter;
+
+	counter = ocp_read_byte(tp, MCU_TYPE_USB, 0xcfcf);
+	counter++;
+	counter &= DBG_COUNTER_MASK;
+	ocp_write_byte(tp, MCU_TYPE_USB, 0xcfcf, counter | DBG_DRV_RUNNING);
+	counter = (counter << 5) | 0xb;
+	ocp_write_word(tp, MCU_TYPE_USB, 0xcfd0, counter);
 }
 
-static void rtl8152_fw_phy_fixup(struct r8152 *tp, struct fw_phy_fixup *fix)
+static void rtl_set_dbg_info_state(struct r8152 *tp, u16 state)
 {
-	u16 addr, data;
+	u32 ocp_data;
 
-	rtl_reset_ocp_base(tp);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xcfd0);
+	ocp_data &= ~DGB_DRV_STATE_MASK;
+	ocp_write_word(tp, MCU_TYPE_USB, 0xcfd0, state | ocp_data);
+}
 
-	addr = __le16_to_cpu(fix->setting.addr);
-	data = ocp_reg_read(tp, addr);
+static void rtl_fw_ver_erase(struct r8152 *tp)
+{
+	u16 outer_ver;
 
-	switch (__le16_to_cpu(fix->bit_cmd)) {
-	case FW_FIXUP_AND:
-		data &= __le16_to_cpu(fix->setting.data);
-		break;
-	case FW_FIXUP_OR:
-		data |= __le16_to_cpu(fix->setting.data);
-		break;
-	case FW_FIXUP_NOT:
-		data &= ~__le16_to_cpu(fix->setting.data);
-		break;
-	case FW_FIXUP_XOR:
-		data ^= __le16_to_cpu(fix->setting.data);
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_07:
+	case RTL_TEST_01:
+		return;
+	case RTL_VER_10:
+	case RTL_VER_11:
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_15:
+		outer_ver = USB_OUTSIDE_FW_VER;
 		break;
 	default:
-		return;
+		outer_ver = USB_OUTER_FW_VER;
+		break;
 	}
 
-	ocp_reg_write(tp, addr, data);
-
-	dev_dbg(&tp->intf->dev, "applied ocp %x %x\n", addr, data);
+	if (!ocp_read_word(tp, MCU_TYPE_USB, outer_ver)) {
+		ocp_write_word(tp, MCU_TYPE_USB, outer_ver, 0);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_FW_PLA_VER, 0);
+	}
 }
 
-static void rtl8152_fw_phy_union_apply(struct r8152 *tp, struct fw_phy_union *phy)
+static void r8153_firmware(struct r8152 *tp)
 {
-	__le16 *data;
-	u32 length;
-	int i, num;
+	if (tp->version == RTL_VER_03) {
+		rtl_reset_ocp_base(tp);
+
+		rtl_pre_ram_code(tp, 0x8146, 0x7000, true);
+		sram_write(tp, 0xb820, 0x0290);
+		sram_write(tp, 0xa012, 0x0000);
+		sram_write(tp, 0xa014, 0x2c04);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c18);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c45);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c45);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd501);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xe018);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x0308);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x60f2);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x607d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc117);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c16);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc116);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c16);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x607d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc117);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x0800);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd501);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x62d2);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x615d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc115);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc307);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c42);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc114);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc317);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd701);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x435d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c42);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x613d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc115);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc307);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c42);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc114);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc317);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd701);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x40dd);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd702);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x0800);
+		sram_write(tp, 0xa01a, 0x0000);
+		sram_write(tp, 0xa006, 0x0fff);
+		sram_write(tp, 0xa004, 0x0fff);
+		sram_write(tp, 0xa002, 0x05a3);
+		sram_write(tp, 0xa000, 0x3591);
+		sram_write(tp, 0xb820, 0x0210);
+		rtl_post_ram_code(tp, 0x8146, true);
+	} else if (tp->version == RTL_VER_04) {
+		static u8 usb_patch_b[] = {
+			0x08, 0xe0, 0x0f, 0xe0,
+			0x18, 0xe0, 0x24, 0xe0,
+			0x26, 0xe0, 0x3a, 0xe0,
+			0x84, 0xe0, 0x9c, 0xe0,
+			0xc2, 0x49, 0x04, 0xf0,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x14, 0x18, 0x02, 0xc0,
+			0x00, 0xb8, 0x2e, 0x18,
+			0x06, 0x89, 0x08, 0xc0,
+			0x0c, 0x61, 0x92, 0x48,
+			0x93, 0x48, 0x0c, 0x89,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x08, 0x05, 0x40, 0xb4,
+			0x16, 0x89, 0x6d, 0xc0,
+			0x00, 0x61, 0x95, 0x49,
+			0x06, 0xf0, 0xfa, 0xc0,
+			0x0c, 0x61, 0x92, 0x48,
+			0x93, 0x48, 0x0c, 0x89,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xe2, 0x04, 0x02, 0xc2,
+			0x00, 0xba, 0xec, 0x11,
+			0x60, 0x60, 0x85, 0x49,
+			0x0d, 0xf1, 0x11, 0xc6,
+			0xd2, 0x61, 0x91, 0x49,
+			0xfd, 0xf0, 0x74, 0x60,
+			0x04, 0x48, 0x74, 0x88,
+			0x08, 0xc6, 0x08, 0xc0,
+			0xc4, 0x98, 0x01, 0x18,
+			0xc0, 0x88, 0x02, 0xc0,
+			0x00, 0xb8, 0x6e, 0x12,
+			0x04, 0xe4, 0x0d, 0x00,
+			0x00, 0xd4, 0xd1, 0x49,
+			0x3c, 0xf1, 0xd2, 0x49,
+			0x16, 0xf1, 0xd3, 0x49,
+			0x18, 0xf1, 0xd4, 0x49,
+			0x19, 0xf1, 0xd5, 0x49,
+			0x1a, 0xf1, 0xd6, 0x49,
+			0x1b, 0xf1, 0xd7, 0x49,
+			0x1c, 0xf1, 0xd8, 0x49,
+			0x1d, 0xf1, 0xd9, 0x49,
+			0x20, 0xf1, 0xda, 0x49,
+			0x23, 0xf1, 0xdb, 0x49,
+			0x24, 0xf1, 0x02, 0xc4,
+			0x00, 0xbc, 0x20, 0x04,
+			0xe5, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0x14, 0x02,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x16, 0x02, 0x02, 0xc4,
+			0x00, 0xbc, 0x18, 0x02,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x1a, 0x02, 0x02, 0xc4,
+			0x00, 0xbc, 0x1c, 0x02,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x94, 0x02, 0x10, 0xc7,
+			0xe0, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0x8a, 0x02,
+			0x0b, 0xc7, 0xe4, 0x8e,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x88, 0x02, 0x02, 0xc4,
+			0x00, 0xbc, 0x6e, 0x02,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x5a, 0x02, 0x30, 0xe4,
+			0x0c, 0xc3, 0x60, 0x64,
+			0xc5, 0x49, 0x04, 0xf1,
+			0x74, 0x64, 0xc4, 0x48,
+			0x74, 0x8c, 0x06, 0xc3,
+			0x64, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0x20, 0x04,
+			0x00, 0xd8, 0x00, 0xe4,
+			0xb2, 0xc0, 0x00, 0x61,
+			0x90, 0x49, 0x09, 0xf1,
+			0x8b, 0xc6, 0xca, 0x61,
+			0x94, 0x49, 0x0e, 0xf1,
+			0xf6, 0xc6, 0xda, 0x60,
+			0x81, 0x49, 0x0a, 0xf0,
+			0x65, 0x60, 0x03, 0x48,
+			0x65, 0x88, 0xef, 0xc6,
+			0xdc, 0x60, 0x80, 0x48,
+			0xdc, 0x88, 0x05, 0xc6,
+			0x00, 0xbe, 0x02, 0xc6,
+			0x00, 0xbe, 0x36, 0x13,
+			0x4c, 0x17, 0x99, 0xc4,
+			0x80, 0x65, 0xd0, 0x49,
+			0x04, 0xf1, 0xfa, 0x75,
+			0x04, 0xc4, 0x00, 0xbc,
+			0x03, 0xc4, 0x00, 0xbc,
+			0x9a, 0x00, 0xee, 0x01 };
+		static u8 pla_patch_b[] = {
+			0x08, 0xe0, 0xea, 0xe0,
+			0xf2, 0xe0, 0x04, 0xe1,
+			0x09, 0xe1, 0x0e, 0xe1,
+			0x46, 0xe1, 0xf7, 0xe1,
+			0x14, 0xc2, 0x40, 0x73,
+			0xba, 0x48, 0x40, 0x9b,
+			0x11, 0xc2, 0x40, 0x73,
+			0xb0, 0x49, 0x17, 0xf0,
+			0xbf, 0x49, 0x03, 0xf1,
+			0x09, 0xc5, 0x00, 0xbd,
+			0xb1, 0x49, 0x11, 0xf0,
+			0xb1, 0x48, 0x40, 0x9b,
+			0x02, 0xc2, 0x00, 0xba,
+			0x1a, 0x17, 0x00, 0xe0,
+			0x1e, 0xfc, 0xbc, 0xc0,
+			0xf0, 0xc0, 0xde, 0xe8,
+			0x00, 0x80, 0x00, 0x20,
+			0x2c, 0x75, 0xd4, 0x49,
+			0x12, 0xf1, 0x32, 0xe0,
+			0xf8, 0xc2, 0x46, 0x71,
+			0xf7, 0xc2, 0x40, 0x73,
+			0xbe, 0x49, 0x03, 0xf1,
+			0xf5, 0xc7, 0x02, 0xe0,
+			0xf2, 0xc7, 0x4f, 0x30,
+			0x26, 0x62, 0xa1, 0x49,
+			0xf0, 0xf1, 0x22, 0x72,
+			0xa0, 0x49, 0xed, 0xf1,
+			0x25, 0x25, 0x18, 0x1f,
+			0x97, 0x30, 0x91, 0x30,
+			0x36, 0x9a, 0x2c, 0x75,
+			0x3c, 0xc3, 0x60, 0x73,
+			0xb1, 0x49, 0x0d, 0xf1,
+			0xdc, 0x21, 0xbc, 0x25,
+			0x30, 0xc6, 0xc0, 0x77,
+			0x04, 0x13, 0x21, 0xf0,
+			0x03, 0x13, 0x22, 0xf0,
+			0x02, 0x13, 0x23, 0xf0,
+			0x01, 0x13, 0x24, 0xf0,
+			0x08, 0x13, 0x08, 0xf1,
+			0x2e, 0x73, 0xba, 0x21,
+			0xbd, 0x25, 0x05, 0x13,
+			0x03, 0xf1, 0x24, 0xc5,
+			0x00, 0xbd, 0xd4, 0x49,
+			0x03, 0xf1, 0x1c, 0xc5,
+			0x00, 0xbd, 0xc4, 0xc6,
+			0xc6, 0x67, 0x2e, 0x75,
+			0xd7, 0x22, 0xdd, 0x26,
+			0x05, 0x15, 0x1b, 0xf0,
+			0x14, 0xc6, 0x00, 0xbe,
+			0x13, 0xc5, 0x00, 0xbd,
+			0x12, 0xc5, 0x00, 0xbd,
+			0xf1, 0x49, 0xfb, 0xf1,
+			0xef, 0xe7, 0xf4, 0x49,
+			0xfa, 0xf1, 0xec, 0xe7,
+			0xf3, 0x49, 0xf7, 0xf1,
+			0xe9, 0xe7, 0xf2, 0x49,
+			0xf4, 0xf1, 0xe6, 0xe7,
+			0xb6, 0xc0, 0x9e, 0x12,
+			0xde, 0x11, 0x0a, 0x12,
+			0x3c, 0x13, 0x00, 0xa0,
+			0xa0, 0xd1, 0x00, 0x00,
+			0xc0, 0x75, 0xd0, 0x49,
+			0x46, 0xf0, 0x26, 0x72,
+			0xa7, 0x49, 0x43, 0xf0,
+			0x22, 0x72, 0x25, 0x25,
+			0x20, 0x1f, 0x97, 0x30,
+			0x91, 0x30, 0x40, 0x73,
+			0xf3, 0xc4, 0x1c, 0x40,
+			0x04, 0xf0, 0xd7, 0x49,
+			0x05, 0xf1, 0x37, 0xe0,
+			0x53, 0x48, 0xc0, 0x9d,
+			0x08, 0x02, 0x40, 0x66,
+			0x64, 0x27, 0x06, 0x16,
+			0x30, 0xf1, 0x46, 0x63,
+			0x3b, 0x13, 0x2d, 0xf1,
+			0x34, 0x9b, 0x18, 0x1b,
+			0x93, 0x30, 0x2b, 0xc3,
+			0x10, 0x1c, 0x2b, 0xe8,
+			0x01, 0x14, 0x25, 0xf1,
+			0x00, 0x1d, 0x26, 0x1a,
+			0x8a, 0x30, 0x22, 0x73,
+			0xb5, 0x25, 0x0e, 0x0b,
+			0x00, 0x1c, 0x2c, 0xe8,
+			0x1f, 0xc7, 0x27, 0x40,
+			0x1a, 0xf1, 0x38, 0xe8,
+			0x32, 0x1f, 0x8f, 0x30,
+			0x08, 0x1b, 0x24, 0xe8,
+			0x36, 0x72, 0x46, 0x77,
+			0x00, 0x17, 0x0d, 0xf0,
+			0x13, 0xc3, 0x1f, 0x40,
+			0x03, 0xf1, 0x00, 0x1f,
+			0x46, 0x9f, 0x44, 0x77,
+			0x9f, 0x44, 0x5f, 0x44,
+			0x17, 0xe8, 0x0a, 0xc7,
+			0x27, 0x40, 0x05, 0xf1,
+			0x02, 0xc3, 0x00, 0xbb,
+			0xfa, 0x18, 0xb0, 0x18,
+			0xff, 0xc7, 0x00, 0xbf,
+			0xb8, 0xcd, 0xff, 0xff,
+			0x02, 0x0c, 0x54, 0xa5,
+			0xdc, 0xa5, 0x2f, 0x40,
+			0x05, 0xf1, 0x00, 0x14,
+			0xfa, 0xf1, 0x01, 0x1c,
+			0x02, 0xe0, 0x00, 0x1c,
+			0x80, 0xff, 0xb0, 0x49,
+			0x04, 0xf0, 0x01, 0x0b,
+			0xd3, 0xa1, 0x03, 0xe0,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x00, 0x13, 0xfb, 0xf1,
+			0x80, 0xff, 0x22, 0x73,
+			0xb5, 0x25, 0x18, 0x1e,
+			0xde, 0x30, 0xd9, 0x30,
+			0x64, 0x72, 0x11, 0x1e,
+			0x68, 0x23, 0x16, 0x31,
+			0x80, 0xff, 0x08, 0xc2,
+			0x40, 0x73, 0x3a, 0x48,
+			0x40, 0x9b, 0x06, 0xff,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x08, 0x16, 0x1e, 0xfc,
+			0x2c, 0x75, 0xdc, 0x21,
+			0xbc, 0x25, 0x04, 0x13,
+			0x0b, 0xf0, 0x03, 0x13,
+			0x09, 0xf0, 0x02, 0x13,
+			0x07, 0xf0, 0x01, 0x13,
+			0x05, 0xf0, 0x08, 0x13,
+			0x03, 0xf0, 0x04, 0xc3,
+			0x00, 0xbb, 0x03, 0xc3,
+			0x00, 0xbb, 0x8c, 0x15,
+			0x76, 0x15, 0xa0, 0x64,
+			0x40, 0x48, 0xa0, 0x8c,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x82, 0x00, 0xa0, 0x62,
+			0x21, 0x48, 0xa0, 0x8a,
+			0x02, 0xc2, 0x00, 0xba,
+			0x40, 0x03, 0x33, 0xc5,
+			0xa0, 0x74, 0xc0, 0x49,
+			0x1f, 0xf0, 0x30, 0xc5,
+			0xa0, 0x73, 0x00, 0x13,
+			0x04, 0xf1, 0xa2, 0x73,
+			0x00, 0x13, 0x14, 0xf0,
+			0x28, 0xc5, 0xa0, 0x74,
+			0xc8, 0x49, 0x1b, 0xf1,
+			0x26, 0xc5, 0xa0, 0x76,
+			0xa2, 0x74, 0x01, 0x06,
+			0x20, 0x37, 0xa0, 0x9e,
+			0xa2, 0x9c, 0x1e, 0xc5,
+			0xa2, 0x73, 0x23, 0x40,
+			0x10, 0xf8, 0x04, 0xf3,
+			0xa0, 0x73, 0x33, 0x40,
+			0x0c, 0xf8, 0x15, 0xc5,
+			0xa0, 0x74, 0x41, 0x48,
+			0xa0, 0x9c, 0x14, 0xc5,
+			0xa0, 0x76, 0x62, 0x48,
+			0xe0, 0x48, 0xa0, 0x9e,
+			0x10, 0xc6, 0x00, 0xbe,
+			0x0a, 0xc5, 0xa0, 0x74,
+			0x48, 0x48, 0xa0, 0x9c,
+			0x0b, 0xc5, 0x20, 0x1e,
+			0xa0, 0x9e, 0xe5, 0x48,
+			0xa0, 0x9e, 0xf0, 0xe7,
+			0xbc, 0xc0, 0xc8, 0xd2,
+			0xcc, 0xd2, 0x28, 0xe4,
+			0xe6, 0x01, 0xf0, 0xc0,
+			0x18, 0x89, 0x00, 0x1d,
+			0x3c, 0xc3, 0x64, 0x71,
+			0x3c, 0xc0, 0x02, 0x99,
+			0x00, 0x61, 0x67, 0x11,
+			0x3c, 0xf1, 0x69, 0x33,
+			0x35, 0xc0, 0x28, 0x40,
+			0xf6, 0xf1, 0x34, 0xc0,
+			0x00, 0x19, 0x81, 0x1b,
+			0x91, 0xe8, 0x31, 0xc0,
+			0x04, 0x1a, 0x84, 0x1b,
+			0x8d, 0xe8, 0x82, 0xe8,
+			0xa3, 0x49, 0xfe, 0xf0,
+			0x2b, 0xc0, 0x7e, 0xe8,
+			0xa1, 0x48, 0x28, 0xc0,
+			0x84, 0x1b, 0x84, 0xe8,
+			0x00, 0x1d, 0x69, 0x33,
+			0x00, 0x1e, 0x01, 0x06,
+			0xff, 0x18, 0x30, 0x40,
+			0xfd, 0xf1, 0x19, 0xc0,
+			0x00, 0x76, 0x2e, 0x40,
+			0xf7, 0xf1, 0x21, 0x48,
+			0x19, 0xc0, 0x84, 0x1b,
+			0x75, 0xe8, 0x10, 0xc0,
+			0x69, 0xe8, 0xa1, 0x49,
+			0xfd, 0xf0, 0x11, 0xc0,
+			0x00, 0x1a, 0x84, 0x1b,
+			0x6d, 0xe8, 0x62, 0xe8,
+			0xa5, 0x49, 0xfe, 0xf0,
+			0x09, 0xc0, 0x01, 0x19,
+			0x81, 0x1b, 0x66, 0xe8,
+			0x54, 0xe0, 0x10, 0xd4,
+			0x88, 0xd3, 0xb8, 0x0b,
+			0x50, 0xe8, 0x20, 0xb4,
+			0x10, 0xd8, 0x84, 0xd4,
+			0xfd, 0xc0, 0x52, 0xe8,
+			0x48, 0x33, 0xf9, 0xc0,
+			0x00, 0x61, 0x9c, 0x20,
+			0x9c, 0x24, 0xd0, 0x49,
+			0x04, 0xf0, 0x04, 0x11,
+			0x02, 0xf1, 0x03, 0xe0,
+			0x00, 0x11, 0x06, 0xf1,
+			0x5c, 0xc0, 0x00, 0x61,
+			0x92, 0x48, 0x00, 0x89,
+			0x3a, 0xe0, 0x06, 0x11,
+			0x06, 0xf1, 0x55, 0xc0,
+			0x00, 0x61, 0x11, 0x48,
+			0x00, 0x89, 0x33, 0xe0,
+			0x05, 0x11, 0x08, 0xf1,
+			0x4e, 0xc0, 0x00, 0x61,
+			0x91, 0x49, 0x04, 0xf0,
+			0x91, 0x48, 0x00, 0x89,
+			0x11, 0xe0, 0xd9, 0xc0,
+			0x00, 0x61, 0x98, 0x20,
+			0x98, 0x24, 0x25, 0x11,
+			0x24, 0xf1, 0x44, 0xc0,
+			0x29, 0xe8, 0x95, 0x49,
+			0x20, 0xf0, 0xcf, 0xc0,
+			0x00, 0x61, 0x98, 0x20,
+			0x98, 0x24, 0x25, 0x11,
+			0x1a, 0xf1, 0x37, 0xc0,
+			0x00, 0x61, 0x92, 0x49,
+			0x16, 0xf1, 0x12, 0x48,
+			0x00, 0x89, 0x2f, 0xc0,
+			0x00, 0x19, 0x00, 0x89,
+			0x2d, 0xc0, 0x01, 0x89,
+			0x2d, 0xc0, 0x04, 0x19,
+			0x81, 0x1b, 0x1c, 0xe8,
+			0x2a, 0xc0, 0x14, 0x19,
+			0x81, 0x1b, 0x18, 0xe8,
+			0x21, 0xc0, 0x0c, 0xe8,
+			0x1f, 0xc0, 0x12, 0x48,
+			0x81, 0x1b, 0x12, 0xe8,
+			0xae, 0xc3, 0x66, 0x71,
+			0xae, 0xc0, 0x02, 0x99,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x96, 0x07, 0x13, 0xc4,
+			0x84, 0x98, 0x00, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x80, 0x71, 0x82, 0x72,
+			0x80, 0xff, 0x09, 0xc4,
+			0x84, 0x98, 0x80, 0x99,
+			0x82, 0x9a, 0x86, 0x8b,
+			0x86, 0x73, 0xbf, 0x49,
+			0xfe, 0xf1, 0x80, 0xff,
+			0x08, 0xea, 0x30, 0xd4,
+			0x10, 0xc0, 0x12, 0xe8,
+			0x8a, 0xd3, 0x28, 0xe4,
+			0x2c, 0xe4, 0x00, 0xd8,
+			0x00, 0x00, 0x00, 0x00 };
+
+		rtl_pre_ram_code(tp, 0x8146, 0x7001, true);
+		sram_write(tp, 0xb820, 0x0290);
+		sram_write(tp, 0xa012, 0x0000);
+		sram_write(tp, 0xa014, 0x2c04);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c0a);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c0d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa240);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa104);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x292d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8620);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa480);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2a2c);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8480);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa101);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2a36);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd056);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2223);
+		sram_write(tp, 0xa01a, 0x0000);
+		sram_write(tp, 0xa006, 0x0222);
+		sram_write(tp, 0xa004, 0x0a35);
+		sram_write(tp, 0xa002, 0x0a2b);
+		sram_write(tp, 0xa000, 0xf92c);
+		sram_write(tp, 0xb820, 0x0210);
+		rtl_post_ram_code(tp, 0x8146, true);
+
+		r8153_wdt1_end(tp);
+
+		rtl_clear_bp(tp, MCU_TYPE_USB);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(usb_patch_b),
+				  usb_patch_b, MCU_TYPE_USB);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc26, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc28, 0x180c);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2a, 0x0506);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2c, 0x04E0);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2e, 0x11E4);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc30, 0x125C);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc32, 0x0232);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc34, 0x131E);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc36, 0x0098);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x00FF);
+
+		rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+		/* Enable backup/restore of MACDBG. This is required after
+		 * clearing PLA break points and before applying the PLA
+		 * firmware.
+		 */
+		if (!(ocp_read_word(tp, MCU_TYPE_PLA, PLA_MACDBG_POST) &
+		      DEBUG_OE)) {
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_MACDBG_PRE,
+				       DEBUG_LTSSM);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_MACDBG_POST,
+				       DEBUG_LTSSM);
+		}
 
-	rtl_reset_ocp_base(tp);
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch_b),
+				  pla_patch_b, MCU_TYPE_PLA);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x1154);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x1606);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x155a);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x0080);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc30, 0x033c);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc32, 0x01a0);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc34, 0x0794);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc36, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x007f);
+
+		/* reset UPHY timer to 36 ms */
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_UPHY_TIMER, 36000 / 16);
+
+		rtl_reset_ocp_base(tp);
+	} else if (tp->version == RTL_VER_05) {
+		u32 ocp_data;
+		static u8 usb_patch_c[] = {
+			0x08, 0xe0, 0x0a, 0xe0,
+			0x14, 0xe0, 0x58, 0xe0,
+			0x64, 0xe0, 0x79, 0xe0,
+			0xab, 0xe0, 0xb6, 0xe0,
+			0x02, 0xc5, 0x00, 0xbd,
+			0x38, 0x3b, 0xdb, 0x49,
+			0x04, 0xf1, 0x06, 0xc3,
+			0x00, 0xbb, 0x5a, 0x02,
+			0x05, 0xc4, 0x03, 0xc3,
+			0x00, 0xbb, 0xa4, 0x04,
+			0x7e, 0x02, 0x30, 0xd4,
+			0x65, 0xc6, 0x66, 0x61,
+			0x92, 0x49, 0x12, 0xf1,
+			0x3e, 0xc0, 0x02, 0x61,
+			0x97, 0x49, 0x05, 0xf0,
+			0x3c, 0xc0, 0x00, 0x61,
+			0x90, 0x49, 0x0a, 0xf1,
+			0xca, 0x63, 0xb0, 0x49,
+			0x09, 0xf1, 0xb1, 0x49,
+			0x05, 0xf0, 0x32, 0xc0,
+			0x00, 0x71, 0x9e, 0x49,
+			0x03, 0xf1, 0xb0, 0x48,
+			0x05, 0xe0, 0x30, 0x48,
+			0xda, 0x61, 0x10, 0x48,
+			0xda, 0x89, 0x4a, 0xc6,
+			0xc0, 0x60, 0x85, 0x49,
+			0x03, 0xf0, 0x31, 0x48,
+			0x04, 0xe0, 0xb1, 0x48,
+			0xb2, 0x48, 0x0f, 0xe0,
+			0x30, 0x18, 0x1b, 0xc1,
+			0x0f, 0xe8, 0x1a, 0xc6,
+			0xc7, 0x65, 0xd0, 0x49,
+			0x05, 0xf0, 0x32, 0x48,
+			0x02, 0xc2, 0x00, 0xba,
+			0x3e, 0x16, 0x02, 0xc2,
+			0x00, 0xba, 0x48, 0x16,
+			0x02, 0xc2, 0x00, 0xba,
+			0x4a, 0x16, 0x02, 0xb4,
+			0x09, 0xc2, 0x40, 0x99,
+			0x0e, 0x48, 0x42, 0x98,
+			0x42, 0x70, 0x8e, 0x49,
+			0xfe, 0xf1, 0x02, 0xb0,
+			0x80, 0xff, 0xc0, 0xd4,
+			0xe4, 0x40, 0x20, 0xd4,
+			0xca, 0xcf, 0x00, 0xcf,
+			0x3c, 0xe4, 0x0c, 0xc0,
+			0x00, 0x63, 0xb5, 0x49,
+			0x09, 0xc0, 0x30, 0x18,
+			0x06, 0xc1, 0xea, 0xef,
+			0xf5, 0xc7, 0x02, 0xc0,
+			0x00, 0xb8, 0xd0, 0x10,
+			0xe4, 0x4b, 0x00, 0xd8,
+			0x14, 0xc3, 0x60, 0x61,
+			0x90, 0x49, 0x06, 0xf0,
+			0x11, 0xc3, 0x70, 0x61,
+			0x12, 0x48, 0x70, 0x89,
+			0x08, 0xe0, 0x0a, 0xc6,
+			0xd4, 0x61, 0x93, 0x48,
+			0xd4, 0x89, 0x02, 0xc1,
+			0x00, 0xb9, 0x72, 0x17,
+			0x02, 0xc1, 0x00, 0xb9,
+			0x9c, 0x15, 0x00, 0xd8,
+			0xef, 0xcf, 0x20, 0xd4,
+			0x30, 0x18, 0xe7, 0xc1,
+			0xcb, 0xef, 0x2b, 0xc5,
+			0xa0, 0x77, 0x00, 0x1c,
+			0xa0, 0x9c, 0x28, 0xc5,
+			0xa0, 0x64, 0xc0, 0x48,
+			0xc1, 0x48, 0xc2, 0x48,
+			0xa0, 0x8c, 0xb1, 0x64,
+			0xc0, 0x48, 0xb1, 0x8c,
+			0x20, 0xc5, 0xa0, 0x64,
+			0x40, 0x48, 0x41, 0x48,
+			0xc2, 0x48, 0xa0, 0x8c,
+			0x19, 0xc5, 0xa4, 0x64,
+			0x44, 0x48, 0xa4, 0x8c,
+			0xb1, 0x64, 0x40, 0x48,
+			0xb1, 0x8c, 0x14, 0xc4,
+			0x80, 0x73, 0x13, 0xc4,
+			0x82, 0x9b, 0x11, 0x1b,
+			0x80, 0x9b, 0x0c, 0xc5,
+			0xa0, 0x64, 0x40, 0x48,
+			0x41, 0x48, 0x42, 0x48,
+			0xa0, 0x8c, 0x05, 0xc5,
+			0xa0, 0x9f, 0x02, 0xc5,
+			0x00, 0xbd, 0x6c, 0x3a,
+			0x1e, 0xfc, 0x10, 0xd8,
+			0x86, 0xd4, 0xf8, 0xcb,
+			0x20, 0xe4, 0x0a, 0xc0,
+			0x16, 0x61, 0x91, 0x48,
+			0x16, 0x89, 0x07, 0xc0,
+			0x11, 0x19, 0x0c, 0x89,
+			0x02, 0xc1, 0x00, 0xb9,
+			0x02, 0x06, 0x00, 0xd4,
+			0x40, 0xb4, 0xfe, 0xc0,
+			0x16, 0x61, 0x91, 0x48,
+			0x16, 0x89, 0xfb, 0xc0,
+			0x11, 0x19, 0x0c, 0x89,
+			0x02, 0xc1, 0x00, 0xb9,
+			0xd2, 0x05, 0x00, 0x00 };
+		static u8 pla_patch_c[] = {
+			0x5d, 0xe0, 0x07, 0xe0,
+			0x0f, 0xe0, 0x5a, 0xe0,
+			0x59, 0xe0, 0x1f, 0xe0,
+			0x57, 0xe0, 0x3e, 0xe1,
+			0x08, 0xc2, 0x40, 0x73,
+			0x3a, 0x48, 0x40, 0x9b,
+			0x06, 0xff, 0x02, 0xc6,
+			0x00, 0xbe, 0xcc, 0x17,
+			0x1e, 0xfc, 0x2c, 0x75,
+			0xdc, 0x21, 0xbc, 0x25,
+			0x04, 0x13, 0x0b, 0xf0,
+			0x03, 0x13, 0x09, 0xf0,
+			0x02, 0x13, 0x07, 0xf0,
+			0x01, 0x13, 0x05, 0xf0,
+			0x08, 0x13, 0x03, 0xf0,
+			0x04, 0xc3, 0x00, 0xbb,
+			0x03, 0xc3, 0x00, 0xbb,
+			0x50, 0x17, 0x3a, 0x17,
+			0x33, 0xc5, 0xa0, 0x74,
+			0xc0, 0x49, 0x1f, 0xf0,
+			0x30, 0xc5, 0xa0, 0x73,
+			0x00, 0x13, 0x04, 0xf1,
+			0xa2, 0x73, 0x00, 0x13,
+			0x14, 0xf0, 0x28, 0xc5,
+			0xa0, 0x74, 0xc8, 0x49,
+			0x1b, 0xf1, 0x26, 0xc5,
+			0xa0, 0x76, 0xa2, 0x74,
+			0x01, 0x06, 0x20, 0x37,
+			0xa0, 0x9e, 0xa2, 0x9c,
+			0x1e, 0xc5, 0xa2, 0x73,
+			0x23, 0x40, 0x10, 0xf8,
+			0x04, 0xf3, 0xa0, 0x73,
+			0x33, 0x40, 0x0c, 0xf8,
+			0x15, 0xc5, 0xa0, 0x74,
+			0x41, 0x48, 0xa0, 0x9c,
+			0x14, 0xc5, 0xa0, 0x76,
+			0x62, 0x48, 0xe0, 0x48,
+			0xa0, 0x9e, 0x10, 0xc6,
+			0x00, 0xbe, 0x0a, 0xc5,
+			0xa0, 0x74, 0x48, 0x48,
+			0xa0, 0x9c, 0x0b, 0xc5,
+			0x20, 0x1e, 0xa0, 0x9e,
+			0xe5, 0x48, 0xa0, 0x9e,
+			0xf0, 0xe7, 0xbc, 0xc0,
+			0xc8, 0xd2, 0xcc, 0xd2,
+			0x28, 0xe4, 0xfa, 0x01,
+			0xf0, 0xc0, 0x18, 0x89,
+			0x74, 0xc0, 0xcd, 0xe8,
+			0x80, 0x76, 0x00, 0x1d,
+			0x6e, 0xc3, 0x66, 0x62,
+			0xa0, 0x49, 0x06, 0xf0,
+			0x64, 0xc0, 0x02, 0x71,
+			0x60, 0x99, 0x62, 0xc1,
+			0x03, 0xe0, 0x5f, 0xc0,
+			0x60, 0xc1, 0x02, 0x99,
+			0x00, 0x61, 0x0f, 0x1b,
+			0x59, 0x41, 0x03, 0x13,
+			0x18, 0xf1, 0xe4, 0x49,
+			0x20, 0xf1, 0xe5, 0x49,
+			0x1e, 0xf0, 0x59, 0xc6,
+			0xd0, 0x73, 0xb7, 0x49,
+			0x08, 0xf0, 0x01, 0x0b,
+			0x80, 0x13, 0x03, 0xf0,
+			0xd0, 0x8b, 0x03, 0xe0,
+			0x3f, 0x48, 0xd0, 0x9b,
+			0x51, 0xc0, 0x10, 0x1a,
+			0x84, 0x1b, 0xb1, 0xe8,
+			0x4b, 0xc2, 0x40, 0x63,
+			0x30, 0x48, 0x0a, 0xe0,
+			0xe5, 0x49, 0x09, 0xf0,
+			0x47, 0xc0, 0x00, 0x1a,
+			0x84, 0x1b, 0xa7, 0xe8,
+			0x41, 0xc2, 0x40, 0x63,
+			0xb0, 0x48, 0x40, 0x8b,
+			0x67, 0x11, 0x3f, 0xf1,
+			0x69, 0x33, 0x32, 0xc0,
+			0x28, 0x40, 0xd2, 0xf1,
+			0x33, 0xc0, 0x00, 0x19,
+			0x81, 0x1b, 0x99, 0xe8,
+			0x30, 0xc0, 0x04, 0x1a,
+			0x84, 0x1b, 0x95, 0xe8,
+			0x8a, 0xe8, 0xa3, 0x49,
+			0xfe, 0xf0, 0x2a, 0xc0,
+			0x86, 0xe8, 0xa1, 0x48,
+			0x84, 0x1b, 0x8d, 0xe8,
+			0x00, 0x1d, 0x69, 0x33,
+			0x00, 0x1e, 0x01, 0x06,
+			0xff, 0x18, 0x30, 0x40,
+			0xfd, 0xf1, 0x1f, 0xc0,
+			0x00, 0x76, 0x2e, 0x40,
+			0xf7, 0xf1, 0x21, 0x48,
+			0x19, 0xc0, 0x84, 0x1b,
+			0x7e, 0xe8, 0x74, 0x08,
+			0x72, 0xe8, 0xa1, 0x49,
+			0xfd, 0xf0, 0x11, 0xc0,
+			0x00, 0x1a, 0x84, 0x1b,
+			0x76, 0xe8, 0x6b, 0xe8,
+			0xa5, 0x49, 0xfe, 0xf0,
+			0x09, 0xc0, 0x01, 0x19,
+			0x81, 0x1b, 0x6f, 0xe8,
+			0x5a, 0xe0, 0xb8, 0x0b,
+			0x50, 0xe8, 0x83, 0x00,
+			0x82, 0x00, 0x20, 0xb4,
+			0x10, 0xd8, 0x84, 0xd4,
+			0x88, 0xd3, 0x10, 0xe0,
+			0x00, 0xd8, 0x24, 0xd4,
+			0xf9, 0xc0, 0x57, 0xe8,
+			0x48, 0x33, 0xf3, 0xc0,
+			0x00, 0x61, 0x6a, 0xc0,
+			0x47, 0x11, 0x03, 0xf0,
+			0x57, 0x11, 0x05, 0xf1,
+			0x00, 0x61, 0x17, 0x48,
+			0x00, 0x89, 0x41, 0xe0,
+			0x9c, 0x20, 0x9c, 0x24,
+			0xd0, 0x49, 0x09, 0xf0,
+			0x04, 0x11, 0x07, 0xf1,
+			0x00, 0x61, 0x97, 0x49,
+			0x38, 0xf0, 0x97, 0x48,
+			0x00, 0x89, 0x2b, 0xe0,
+			0x00, 0x11, 0x05, 0xf1,
+			0x00, 0x61, 0x92, 0x48,
+			0x00, 0x89, 0x2f, 0xe0,
+			0x06, 0x11, 0x05, 0xf1,
+			0x00, 0x61, 0x11, 0x48,
+			0x00, 0x89, 0x29, 0xe0,
+			0x05, 0x11, 0x0f, 0xf1,
+			0x00, 0x61, 0x93, 0x49,
+			0x1a, 0xf1, 0x91, 0x49,
+			0x0a, 0xf0, 0x91, 0x48,
+			0x00, 0x89, 0x0f, 0xe0,
+			0xc6, 0xc0, 0x00, 0x61,
+			0x98, 0x20, 0x98, 0x24,
+			0x25, 0x11, 0x80, 0xff,
+			0xfa, 0xef, 0x17, 0xf1,
+			0x38, 0xc0, 0x1f, 0xe8,
+			0x95, 0x49, 0x13, 0xf0,
+			0xf4, 0xef, 0x11, 0xf1,
+			0x31, 0xc0, 0x00, 0x61,
+			0x92, 0x49, 0x0d, 0xf1,
+			0x12, 0x48, 0x00, 0x89,
+			0x29, 0xc0, 0x00, 0x19,
+			0x00, 0x89, 0x27, 0xc0,
+			0x01, 0x89, 0x23, 0xc0,
+			0x0e, 0xe8, 0x12, 0x48,
+			0x81, 0x1b, 0x15, 0xe8,
+			0xae, 0xc3, 0x66, 0x62,
+			0xa0, 0x49, 0x04, 0xf0,
+			0x64, 0x71, 0xa3, 0xc0,
+			0x02, 0x99, 0x02, 0xc0,
+			0x00, 0xb8, 0xd6, 0x07,
+			0x13, 0xc4, 0x84, 0x98,
+			0x00, 0x1b, 0x86, 0x8b,
+			0x86, 0x73, 0xbf, 0x49,
+			0xfe, 0xf1, 0x80, 0x71,
+			0x82, 0x72, 0x80, 0xff,
+			0x09, 0xc4, 0x84, 0x98,
+			0x80, 0x99, 0x82, 0x9a,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x80, 0xff, 0x08, 0xea,
+			0x30, 0xd4, 0x10, 0xc0,
+			0x12, 0xe8, 0x8a, 0xd3,
+			0x00, 0xd8, 0x02, 0xc6,
+			0x00, 0xbe, 0xe0, 0x08 };
+
+		rtl_pre_ram_code(tp, 0x8146, 0x7001, true);
+		sram_write(tp, 0xb820, 0x0290);
+		sram_write(tp, 0xa012, 0x0000);
+		sram_write(tp, 0xa014, 0x2c04);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c0a);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c0d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa240);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa104);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x292d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8620);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa480);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2a2c);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8480);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa101);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2a36);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd056);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2223);
+		sram_write(tp, 0xa01a, 0x0000);
+		sram_write(tp, 0xa006, 0x0222);
+		sram_write(tp, 0xa004, 0x0a35);
+		sram_write(tp, 0xa002, 0x0a2b);
+		sram_write(tp, 0xa000, 0xf92c);
+		sram_write(tp, 0xb820, 0x0210);
+		rtl_post_ram_code(tp, 0x8146, true);
+
+		r8153_wdt1_end(tp);
+
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN0);
+		ocp_data &= ~FW_FIX_SUSPEND;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN0, ocp_data);
+
+		rtl_clear_bp(tp, MCU_TYPE_USB);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(usb_patch_c),
+				  usb_patch_c, MCU_TYPE_USB);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc26, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc28, 0x3b34);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2a, 0x027c);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2c, 0x15de);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2e, 0x10ce);
+		if (ocp_read_byte(tp, MCU_TYPE_USB, USB_CSTMR) & FORCE_SUPER)
+			ocp_write_word(tp, MCU_TYPE_USB, 0xfc30, 0x1578);
+		else
+			ocp_write_word(tp, MCU_TYPE_USB, 0xfc30, 0x1adc);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc32, 0x3a28);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc34, 0x05f8);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc36, 0x05c8);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x00ff);
+
+		rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch_c),
+				  pla_patch_c, MCU_TYPE_PLA);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x1306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x17ca);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x171e);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc30, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc32, 0x01b4);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc34, 0x07d4);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc36, 0x0894);
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x00e6);
+
+		/* reset UPHY timer to 36 ms */
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_UPHY_TIMER, 36000 / 16);
+
+		/* enable U3P3 check, set the counter to 4 */
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS,
+			       U3P3_CHECK_EN | 4);
+
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN0);
+		ocp_data |= FW_FIX_SUSPEND;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN0, ocp_data);
 
-	num = phy->pre_num;
-	for (i = 0; i < num; i++)
-		sram_write(tp, __le16_to_cpu(phy->pre_set[i].addr),
-			   __le16_to_cpu(phy->pre_set[i].data));
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_USB2PHY);
+		ocp_data |= USB2PHY_L1 | USB2PHY_SUSPEND;
+		ocp_write_byte(tp, MCU_TYPE_USB, USB_USB2PHY, ocp_data);
 
-	length = __le32_to_cpu(phy->blk_hdr.length);
-	length -= __le16_to_cpu(phy->fw_offset);
-	num = length / 2;
-	data = (__le16 *)((u8 *)phy + __le16_to_cpu(phy->fw_offset));
+		rtl_reset_ocp_base(tp);
+	} else if (tp->version == RTL_VER_06) {
+		u32 ocp_data;
+		static u8 usb_patch_d[] = {
+			0x08, 0xe0, 0x0e, 0xe0,
+			0x11, 0xe0, 0x24, 0xe0,
+			0x2b, 0xe0, 0x33, 0xe0,
+			0x3a, 0xe0, 0x3c, 0xe0,
+			0x1e, 0xc3, 0x70, 0x61,
+			0x12, 0x48, 0x70, 0x89,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x02, 0x17, 0x32, 0x19,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x44, 0x14, 0x30, 0x18,
+			0x11, 0xc1, 0x05, 0xe8,
+			0x10, 0xc6, 0x02, 0xc2,
+			0x00, 0xba, 0x94, 0x17,
+			0x02, 0xb4, 0x09, 0xc2,
+			0x40, 0x99, 0x0e, 0x48,
+			0x42, 0x98, 0x42, 0x70,
+			0x8e, 0x49, 0xfe, 0xf1,
+			0x02, 0xb0, 0x80, 0xff,
+			0xc0, 0xd4, 0xe4, 0x40,
+			0x20, 0xd4, 0x30, 0x18,
+			0x06, 0xc1, 0xf1, 0xef,
+			0xfc, 0xc7, 0x02, 0xc0,
+			0x00, 0xb8, 0x38, 0x12,
+			0xe4, 0x4b, 0x0c, 0x61,
+			0x92, 0x48, 0x93, 0x48,
+			0x95, 0x48, 0x96, 0x48,
+			0x0c, 0x89, 0x02, 0xc0,
+			0x00, 0xb8, 0x0e, 0x06,
+			0x30, 0x18, 0xf5, 0xc1,
+			0xe0, 0xef, 0x04, 0xc5,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x76, 0x3c, 0x1e, 0xfc,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00 };
+		static u8 pla_patch_d[] = {
+			0x03, 0xe0, 0x16, 0xe0,
+			0x30, 0xe0, 0x12, 0xc2,
+			0x40, 0x73, 0xb0, 0x49,
+			0x08, 0xf0, 0xb8, 0x49,
+			0x06, 0xf0, 0xb8, 0x48,
+			0x40, 0x9b, 0x0b, 0xc2,
+			0x40, 0x76, 0x05, 0xe0,
+			0x02, 0x61, 0x02, 0xc3,
+			0x00, 0xbb, 0x54, 0x08,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x64, 0x08, 0x98, 0xd3,
+			0x1e, 0xfc, 0xfe, 0xc0,
+			0x02, 0x62, 0xa0, 0x48,
+			0x02, 0x8a, 0x00, 0x72,
+			0xa0, 0x49, 0x11, 0xf0,
+			0x13, 0xc1, 0x20, 0x62,
+			0x2e, 0x21, 0x2f, 0x25,
+			0x00, 0x71, 0x9f, 0x24,
+			0x0a, 0x40, 0x09, 0xf0,
+			0x00, 0x71, 0x18, 0x48,
+			0xa0, 0x49, 0x03, 0xf1,
+			0x9f, 0x48, 0x02, 0xe0,
+			0x1f, 0x48, 0x00, 0x99,
+			0x02, 0xc2, 0x00, 0xba,
+			0xac, 0x0c, 0x08, 0xe9,
+			0x36, 0xc0, 0x00, 0x61,
+			0x9c, 0x20, 0x9c, 0x24,
+			0x33, 0xc0, 0x07, 0x11,
+			0x05, 0xf1, 0x00, 0x61,
+			0x17, 0x48, 0x00, 0x89,
+			0x0d, 0xe0, 0x04, 0x11,
+			0x0b, 0xf1, 0x00, 0x61,
+			0x97, 0x49, 0x08, 0xf0,
+			0x97, 0x48, 0x00, 0x89,
+			0x23, 0xc0, 0x0e, 0xe8,
+			0x12, 0x48, 0x81, 0x1b,
+			0x15, 0xe8, 0x1f, 0xc0,
+			0x00, 0x61, 0x67, 0x11,
+			0x04, 0xf0, 0x02, 0xc0,
+			0x00, 0xb8, 0x42, 0x09,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x90, 0x08, 0x13, 0xc4,
+			0x84, 0x98, 0x00, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x80, 0x71, 0x82, 0x72,
+			0x80, 0xff, 0x09, 0xc4,
+			0x84, 0x98, 0x80, 0x99,
+			0x82, 0x9a, 0x86, 0x8b,
+			0x86, 0x73, 0xbf, 0x49,
+			0xfe, 0xf1, 0x80, 0xff,
+			0x08, 0xea, 0x30, 0xd4,
+			0x50, 0xe8, 0x8a, 0xd3 };
+
+		rtl_pre_ram_code(tp, 0x8146, 0x7003, true);
+		sram_write(tp, 0xb820, 0x0290);
+		sram_write(tp, 0xa012, 0x0000);
+		sram_write(tp, 0xa014, 0x2c04);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa240);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa104);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2944);
+		sram_write(tp, 0xa01a, 0x0000);
+		sram_write(tp, 0xa006, 0x0fff);
+		sram_write(tp, 0xa004, 0x0fff);
+		sram_write(tp, 0xa002, 0x0fff);
+		sram_write(tp, 0xa000, 0x1943);
+		sram_write(tp, 0xb820, 0x0210);
+		rtl_post_ram_code(tp, 0x8146, true);
+
+		rtl_clear_bp(tp, MCU_TYPE_USB);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(usb_patch_d),
+				  usb_patch_d, MCU_TYPE_USB);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc26, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc28, 0x16de);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2a, 0x1442);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2c, 0x1792);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2e, 0x1236);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc30, 0x0606);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc32, 0x3C74);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc34, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc36, 0x0000);
+		if (ocp_read_byte(tp, MCU_TYPE_USB, USB_CSTMR) & FORCE_SUPER)
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x003f);
+		else
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x003e);
+
+		rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch_d),
+				  pla_patch_d, MCU_TYPE_PLA);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x0852);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x0c92);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x088c);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc30, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc32, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc34, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc36, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x0007);
 
-	ocp_reg_write(tp, OCP_SRAM_ADDR, __le16_to_cpu(phy->fw_reg));
-	for (i = 0; i < num; i++)
-		ocp_reg_write(tp, OCP_SRAM_DATA, __le16_to_cpu(data[i]));
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_USB2PHY);
+		ocp_data |= USB2PHY_L1 | USB2PHY_SUSPEND;
+		ocp_write_byte(tp, MCU_TYPE_USB, USB_USB2PHY, ocp_data);
 
-	num = phy->bp_num;
-	for (i = 0; i < num; i++)
-		sram_write(tp, __le16_to_cpu(phy->bp[i].addr), __le16_to_cpu(phy->bp[i].data));
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1);
+		ocp_data |= FW_IP_RESET_EN;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1, ocp_data);
 
-	if (phy->bp_num && phy->bp_en.addr)
-		sram_write(tp, __le16_to_cpu(phy->bp_en.addr), __le16_to_cpu(phy->bp_en.data));
+		rtl_reset_ocp_base(tp);
+	}
 
-	dev_dbg(&tp->intf->dev, "successfully applied %s\n", phy->info);
+	rtl_reset_ocp_base(tp);
 }
 
-static void rtl8152_fw_phy_nc_apply(struct r8152 *tp, struct fw_phy_nc *phy)
+static void r8153b_firmware(struct r8152 *tp)
 {
-	u16 mode_reg, bp_index;
-	u32 length, i, num;
-	__le16 *data;
+	if (tp->version == RTL_VER_09) {
+		u32 ocp_data;
+		static u8 usb_patch2_b[] = {
+			0x10, 0xe0, 0x5b, 0xe0,
+			0x7c, 0xe0, 0x9c, 0xe0,
+			0xb0, 0xe0, 0xc9, 0xe0,
+			0xea, 0xe0, 0x46, 0xe1,
+			0x62, 0xe1, 0x65, 0xe1,
+			0x7d, 0xe1, 0x8f, 0xe1,
+			0x97, 0xe1, 0xf5, 0xe1,
+			0x11, 0xe2, 0x22, 0xe2,
+			0x43, 0xc4, 0x80, 0x63,
+			0xb2, 0x49, 0x05, 0xf0,
+			0x41, 0xc4, 0x02, 0xc3,
+			0x00, 0xbb, 0x88, 0x3d,
+			0x64, 0xc4, 0x3b, 0xc3,
+			0x84, 0x9b, 0x00, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x80, 0x73, 0x35, 0xc2,
+			0x40, 0x9b, 0x34, 0xc3,
+			0x80, 0x9b, 0x83, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x2e, 0xc3, 0x84, 0x9b,
+			0x00, 0x1b, 0x86, 0x8b,
+			0x86, 0x73, 0xbf, 0x49,
+			0xfe, 0xf1, 0x80, 0x73,
+			0xba, 0x48, 0xbb, 0x48,
+			0x80, 0x9b, 0x83, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x20, 0xc3, 0x84, 0x9b,
+			0x1f, 0xc3, 0x80, 0x9b,
+			0x83, 0x1b, 0x86, 0x8b,
+			0x86, 0x73, 0xbf, 0x49,
+			0xfe, 0xf1, 0x11, 0xc3,
+			0x84, 0x9b, 0x40, 0x73,
+			0x80, 0x9b, 0x83, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x0d, 0xc4, 0x80, 0x73,
+			0xbb, 0x48, 0x80, 0x9b,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x06, 0x3e, 0xee, 0xcf,
+			0x6c, 0xe8, 0xe0, 0xcb,
+			0x2e, 0xc3, 0x00, 0xa0,
+			0x08, 0xb4, 0x4a, 0xd8,
+			0x00, 0xb4, 0x00, 0x92,
+			0x1c, 0xc6, 0xc0, 0x61,
+			0x04, 0x11, 0x15, 0xf1,
+			0x19, 0xc6, 0xc0, 0x61,
+			0x9c, 0x20, 0x9c, 0x24,
+			0x09, 0x11, 0x0f, 0xf1,
+			0x14, 0xc6, 0x01, 0x19,
+			0xc0, 0x89, 0x13, 0xc1,
+			0x13, 0xc6, 0x24, 0x9e,
+			0x00, 0x1e, 0x26, 0x8e,
+			0x26, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0x22, 0x76,
+			0x08, 0xc1, 0x22, 0x9e,
+			0x07, 0xc6, 0x02, 0xc1,
+			0x00, 0xb9, 0x8c, 0x08,
+			0x18, 0xb4, 0x4a, 0xb4,
+			0x90, 0xcc, 0x80, 0xd4,
+			0x08, 0xdc, 0x10, 0xe8,
+			0x1f, 0xc0, 0x00, 0x75,
+			0xd1, 0x49, 0x15, 0xf0,
+			0x19, 0xc7, 0x17, 0xc2,
+			0xec, 0x9a, 0x00, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0xea, 0x71, 0x9f, 0x49,
+			0x0a, 0xf0, 0x11, 0xc2,
+			0xec, 0x9a, 0x00, 0x19,
+			0xe8, 0x99, 0x81, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x06, 0xc3, 0x02, 0xc2,
+			0x00, 0xba, 0xf0, 0x1d,
+			0x4c, 0xe8, 0x00, 0xdc,
+			0x00, 0xd4, 0x34, 0xd3,
+			0x24, 0xe4, 0x7b, 0xc0,
+			0x00, 0x75, 0xd1, 0x49,
+			0x0d, 0xf0, 0x74, 0xc0,
+			0x74, 0xc5, 0x00, 0x1e,
+			0x08, 0x9e, 0x72, 0xc6,
+			0x0a, 0x9e, 0x0c, 0x9d,
+			0x8f, 0x1c, 0x0e, 0x8c,
+			0x0e, 0x74, 0xcf, 0x49,
+			0xfe, 0xf1, 0x04, 0xc0,
+			0x02, 0xc1, 0x00, 0xb9,
+			0xc4, 0x16, 0x20, 0xd4,
+			0x66, 0xc0, 0x00, 0x75,
+			0xd1, 0x48, 0x00, 0x9d,
+			0xe3, 0xc7, 0x5f, 0xc2,
+			0xec, 0x9a, 0x00, 0x19,
+			0xe8, 0x9a, 0x81, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x2c, 0xc1, 0xec, 0x99,
+			0x81, 0x19, 0xee, 0x89,
+			0xee, 0x71, 0x9f, 0x49,
+			0xfe, 0xf1, 0x04, 0xc3,
+			0x02, 0xc2, 0x00, 0xba,
+			0x96, 0x1c, 0xc0, 0xd4,
+			0xc0, 0x88, 0x1e, 0xc6,
+			0xc0, 0x70, 0x8f, 0x49,
+			0x0e, 0xf0, 0x8f, 0x48,
+			0x1b, 0xc6, 0xca, 0x98,
+			0x11, 0x18, 0xc8, 0x98,
+			0x16, 0xc0, 0xcc, 0x98,
+			0x8f, 0x18, 0xce, 0x88,
+			0xce, 0x70, 0x8f, 0x49,
+			0xfe, 0xf1, 0x0b, 0xe0,
+			0x36, 0xc6, 0x00, 0x18,
+			0xc8, 0x98, 0x0b, 0xc0,
+			0xcc, 0x98, 0x81, 0x18,
+			0xce, 0x88, 0xce, 0x70,
+			0x8f, 0x49, 0xfe, 0xf1,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xf2, 0x19, 0x40, 0xd3,
+			0x20, 0xe4, 0x00, 0xdc,
+			0x90, 0x49, 0x1f, 0xf0,
+			0x29, 0xc0, 0x01, 0x66,
+			0x05, 0x16, 0x3f, 0xf0,
+			0x25, 0x16, 0x45, 0xf0,
+			0x09, 0x16, 0x23, 0xf0,
+			0x16, 0xe0, 0x1a, 0xc2,
+			0x40, 0x76, 0xe1, 0x48,
+			0x40, 0x9e, 0x17, 0xc2,
+			0x00, 0x1e, 0x48, 0x9e,
+			0xec, 0xc6, 0x4c, 0x9e,
+			0x81, 0x1e, 0x4e, 0x8e,
+			0x4e, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0x0b, 0xc6,
+			0x4c, 0x9e, 0x81, 0x1e,
+			0x4e, 0x8e, 0x4e, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x90, 0x49, 0x02, 0xc7,
+			0x00, 0xbf, 0xe2, 0x27,
+			0x24, 0xe4, 0x34, 0xd3,
+			0x00, 0xdc, 0x00, 0xdc,
+			0x24, 0xe4, 0x80, 0x02,
+			0x34, 0xd3, 0xf8, 0xc7,
+			0xf9, 0xc2, 0x40, 0x76,
+			0xe1, 0x48, 0x40, 0x9e,
+			0xf6, 0xc2, 0x00, 0x1e,
+			0x48, 0x9e, 0xcb, 0xc6,
+			0x4c, 0x9e, 0x81, 0x1e,
+			0x4e, 0x8e, 0x4e, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xea, 0xc6, 0x4c, 0x9e,
+			0x81, 0x1e, 0x4e, 0x8e,
+			0x4e, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xdf, 0xe7,
+			0x40, 0xd4, 0x00, 0x00,
+			0xfe, 0xc2, 0x4c, 0x73,
+			0xbf, 0x49, 0xc4, 0xf0,
+			0x06, 0x76, 0xfa, 0xc2,
+			0x32, 0x40, 0xc0, 0xf0,
+			0xde, 0xc6, 0xc0, 0x75,
+			0xd1, 0x49, 0xd1, 0xf0,
+			0xd7, 0xc0, 0xd7, 0xc6,
+			0x0c, 0x9e, 0x00, 0x1e,
+			0x08, 0x9e, 0xd4, 0xc6,
+			0x0a, 0x9e, 0x8f, 0x1e,
+			0x0e, 0x8e, 0x0e, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xc4, 0xe7, 0x1a, 0xc6,
+			0xc0, 0x67, 0xf0, 0x49,
+			0x13, 0xf0, 0xf0, 0x48,
+			0xc0, 0x8f, 0xc2, 0x77,
+			0x14, 0xc1, 0x14, 0xc6,
+			0x24, 0x9e, 0x22, 0x9f,
+			0x8c, 0x1e, 0x26, 0x8e,
+			0x26, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xfb, 0x49,
+			0x05, 0xf0, 0x07, 0xc6,
+			0xc0, 0x61, 0x10, 0x48,
+			0xc0, 0x89, 0x02, 0xc6,
+			0x00, 0xbe, 0x7e, 0x36,
+			0x6c, 0xb4, 0x90, 0xcc,
+			0x08, 0xdc, 0x10, 0xe8,
+			0x1e, 0x89, 0x02, 0xc0,
+			0x00, 0xb8, 0xfa, 0x12,
+			0x18, 0xc0, 0x00, 0x65,
+			0xd1, 0x49, 0x0d, 0xf0,
+			0x11, 0xc0, 0x11, 0xc5,
+			0x00, 0x1e, 0x08, 0x9e,
+			0x0c, 0x9d, 0x0e, 0xc6,
+			0x0a, 0x9e, 0x8f, 0x1c,
+			0x0e, 0x8c, 0x0e, 0x74,
+			0xcf, 0x49, 0xfe, 0xf1,
+			0x04, 0xc0, 0x02, 0xc2,
+			0x00, 0xba, 0xa0, 0x41,
+			0x06, 0xd4, 0x00, 0xdc,
+			0x24, 0xe4, 0x80, 0x02,
+			0x34, 0xd3, 0x9e, 0x49,
+			0x0a, 0xf0, 0x0f, 0xc2,
+			0x40, 0x71, 0x9f, 0x49,
+			0x02, 0xf1, 0x08, 0xe0,
+			0x0b, 0xc2, 0x40, 0x61,
+			0x91, 0x48, 0x40, 0x89,
+			0x02, 0xc5, 0x00, 0xbd,
+			0x82, 0x24, 0x02, 0xc5,
+			0x00, 0xbd, 0xf8, 0x23,
+			0xfe, 0xcf, 0x1e, 0xd4,
+			0xfe, 0xc7, 0xe0, 0x75,
+			0x5f, 0x48, 0xe0, 0x9d,
+			0x04, 0xc7, 0x02, 0xc5,
+			0x00, 0xbd, 0x82, 0x18,
+			0x14, 0xd8, 0xc0, 0x88,
+			0x5d, 0xc7, 0x56, 0xc6,
+			0xe4, 0x9e, 0x0f, 0x1e,
+			0xe6, 0x8e, 0xe6, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xe2, 0x75, 0xe0, 0x74,
+			0xd8, 0x25, 0xd8, 0x22,
+			0xd8, 0x26, 0x48, 0x23,
+			0x68, 0x27, 0x48, 0x26,
+			0x04, 0xb4, 0x05, 0xb4,
+			0x06, 0xb4, 0x45, 0xc6,
+			0xe2, 0x23, 0xfe, 0x39,
+			0x00, 0x1c, 0x00, 0x1d,
+			0x00, 0x13, 0x0c, 0xf0,
+			0xb0, 0x49, 0x04, 0xf1,
+			0x01, 0x05, 0xb1, 0x25,
+			0xfa, 0xe7, 0xb8, 0x33,
+			0x35, 0x43, 0x26, 0x31,
+			0x01, 0x05, 0xb1, 0x25,
+			0xf4, 0xe7, 0x06, 0xb0,
+			0x05, 0xb0, 0xae, 0x41,
+			0x25, 0x31, 0x30, 0xc5,
+			0x6c, 0x41, 0x04, 0xb0,
+			0x05, 0xb4, 0x30, 0xc7,
+			0x29, 0xc6, 0x04, 0x06,
+			0xe4, 0x9e, 0x0f, 0x1e,
+			0xe6, 0x8e, 0xe6, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xe0, 0x76, 0xe8, 0x25,
+			0xe8, 0x23, 0xf8, 0x27,
+			0x1e, 0xc5, 0x6f, 0x41,
+			0x33, 0x23, 0xb3, 0x31,
+			0x74, 0x41, 0xf5, 0x31,
+			0x19, 0xc6, 0x7e, 0x41,
+			0x1a, 0xc6, 0xc4, 0x9f,
+			0xf1, 0x21, 0xdf, 0x30,
+			0x05, 0xb0, 0xc2, 0x9d,
+			0x52, 0x22, 0xa3, 0x31,
+			0x0e, 0xc7, 0xb7, 0x31,
+			0x0e, 0xc7, 0x77, 0x41,
+			0x0e, 0xc7, 0xe6, 0x9e,
+			0x0b, 0xc3, 0xde, 0x30,
+			0x60, 0x64, 0xe8, 0x8c,
+			0x02, 0xc4, 0x00, 0xbc,
+			0xe8, 0x19, 0x00, 0xc0,
+			0x41, 0x00, 0xff, 0x00,
+			0x7f, 0x00, 0x00, 0xe6,
+			0x60, 0xd3, 0x08, 0xdc,
+			0x1b, 0xc4, 0x80, 0x75,
+			0x08, 0x15, 0x04, 0xf0,
+			0x01, 0x05, 0x80, 0x9d,
+			0x0f, 0xe0, 0x00, 0x1d,
+			0x80, 0x9d, 0x25, 0xc4,
+			0x80, 0x75, 0xd8, 0x22,
+			0xdc, 0x26, 0x01, 0x15,
+			0x04, 0xf1, 0x0d, 0xc4,
+			0x11, 0x1d, 0x80, 0x8d,
+			0x14, 0x1e, 0xe5, 0x8e,
+			0x04, 0xe0, 0xe5, 0x66,
+			0x62, 0x48, 0xe5, 0x8e,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x8c, 0x06, 0x50, 0xd3,
+			0x4c, 0xb4, 0x11, 0xc0,
+			0x00, 0x71, 0x98, 0x20,
+			0x9c, 0x24, 0x01, 0x11,
+			0x06, 0xf1, 0x0a, 0xc6,
+			0x01, 0x1d, 0xc6, 0x8d,
+			0x19, 0x1d, 0xc1, 0x8d,
+			0x04, 0xc0, 0x02, 0xc1,
+			0x00, 0xb9, 0xa2, 0x12,
+			0xc0, 0xd4, 0x04, 0xe4,
+			0xb4, 0xbb, 0xec, 0xc6,
+			0x00, 0x1d, 0xc0, 0x8d,
+			0xfb, 0xc6, 0x14, 0x1d,
+			0xc5, 0x8d, 0x04, 0xc6,
+			0x02, 0xc5, 0x00, 0xbd,
+			0xd2, 0x03, 0x40, 0xb4 };
+		static u8 pla_patch2_b[] = {
+			0x10, 0xe0, 0x26, 0xe0,
+			0x37, 0xe0, 0x6b, 0xe0,
+			0x7e, 0xe0, 0xcb, 0xe0,
+			0xcd, 0xe0, 0xcf, 0xe0,
+			0xd1, 0xe0, 0xd3, 0xe0,
+			0xd5, 0xe0, 0xd7, 0xe0,
+			0xd9, 0xe0, 0xdb, 0xe0,
+			0xdd, 0xe0, 0xdf, 0xe0,
+			0x15, 0xc6, 0xc2, 0x64,
+			0xd2, 0x49, 0x06, 0xf1,
+			0xc4, 0x48, 0xc5, 0x48,
+			0xc6, 0x48, 0xc7, 0x48,
+			0x05, 0xe0, 0x44, 0x48,
+			0x45, 0x48, 0x46, 0x48,
+			0x47, 0x48, 0xc2, 0x8c,
+			0xc0, 0x64, 0x46, 0x48,
+			0xc0, 0x8c, 0x05, 0xc5,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x18, 0x02, 0x06, 0xdc,
+			0xb0, 0xc0, 0x10, 0xc5,
+			0xa0, 0x77, 0xa0, 0x74,
+			0x46, 0x48, 0x47, 0x48,
+			0xa0, 0x9c, 0x0b, 0xc5,
+			0xa0, 0x74, 0x44, 0x48,
+			0x43, 0x48, 0xa0, 0x9c,
+			0x05, 0xc5, 0xa0, 0x9f,
+			0x02, 0xc5, 0x00, 0xbd,
+			0x3c, 0x03, 0x1c, 0xe8,
+			0x20, 0xe8, 0xd4, 0x49,
+			0x04, 0xf1, 0xd5, 0x49,
+			0x20, 0xf1, 0x28, 0xe0,
+			0x2a, 0xc7, 0xe0, 0x75,
+			0xda, 0x49, 0x14, 0xf0,
+			0x27, 0xc7, 0xe0, 0x75,
+			0xdc, 0x49, 0x10, 0xf1,
+			0x24, 0xc7, 0xe0, 0x75,
+			0x25, 0xc7, 0xe0, 0x74,
+			0x2c, 0x40, 0x0a, 0xfa,
+			0x1f, 0xc7, 0xe4, 0x75,
+			0xd0, 0x49, 0x09, 0xf1,
+			0x1c, 0xc5, 0xe6, 0x9d,
+			0x11, 0x1d, 0xe4, 0x8d,
+			0x04, 0xe0, 0x16, 0xc7,
+			0x00, 0x1d, 0xe4, 0x8d,
+			0xe0, 0x8e, 0x11, 0x1d,
+			0xe0, 0x8d, 0x07, 0xe0,
+			0x0c, 0xc7, 0xe0, 0x75,
+			0xda, 0x48, 0xe0, 0x9d,
+			0x0b, 0xc7, 0xe4, 0x8e,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x28, 0x03, 0x02, 0xc4,
+			0x00, 0xbc, 0x14, 0x03,
+			0x12, 0xe8, 0x4e, 0xe8,
+			0x1c, 0xe6, 0x20, 0xe4,
+			0x80, 0x02, 0xa4, 0xc0,
+			0x12, 0xc2, 0x40, 0x73,
+			0xb0, 0x49, 0x08, 0xf0,
+			0xb8, 0x49, 0x06, 0xf0,
+			0xb8, 0x48, 0x40, 0x9b,
+			0x0b, 0xc2, 0x40, 0x76,
+			0x05, 0xe0, 0x02, 0x61,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x0a, 0x0a, 0x02, 0xc3,
+			0x00, 0xbb, 0x1a, 0x0a,
+			0x98, 0xd3, 0x1e, 0xfc,
+			0x1f, 0xe8, 0xfd, 0xc0,
+			0x02, 0x62, 0xa0, 0x48,
+			0x02, 0x8a, 0x00, 0x72,
+			0xa0, 0x49, 0x11, 0xf0,
+			0x13, 0xc1, 0x20, 0x62,
+			0x2e, 0x21, 0x2f, 0x25,
+			0x00, 0x71, 0x9f, 0x24,
+			0x0a, 0x40, 0x09, 0xf0,
+			0x00, 0x71, 0x18, 0x48,
+			0xa0, 0x49, 0x03, 0xf1,
+			0x9f, 0x48, 0x02, 0xe0,
+			0x1f, 0x48, 0x00, 0x99,
+			0x02, 0xc2, 0x00, 0xba,
+			0xda, 0x0e, 0x08, 0xe9,
+			0x08, 0xea, 0x34, 0xd3,
+			0xe8, 0xd4, 0x00, 0xb4,
+			0x01, 0xb4, 0x02, 0xb4,
+			0xf9, 0xc1, 0x20, 0x62,
+			0x2e, 0x21, 0x2f, 0x25,
+			0xa0, 0x49, 0x23, 0xf0,
+			0xf4, 0xc0, 0xf4, 0xc2,
+			0x04, 0x9a, 0x00, 0x1a,
+			0x06, 0x8a, 0x06, 0x72,
+			0xaf, 0x49, 0xfe, 0xf1,
+			0x00, 0x72, 0xa1, 0x49,
+			0x18, 0xf0, 0xeb, 0xc2,
+			0x04, 0x9a, 0x00, 0x1a,
+			0x06, 0x8a, 0x06, 0x72,
+			0xaf, 0x49, 0xfe, 0xf1,
+			0x00, 0x72, 0xa1, 0x48,
+			0x00, 0x9a, 0x81, 0x1a,
+			0x06, 0x8a, 0x06, 0x72,
+			0xaf, 0x49, 0xfe, 0xf1,
+			0x00, 0x72, 0x21, 0x48,
+			0x00, 0x9a, 0x81, 0x1a,
+			0x06, 0x8a, 0x06, 0x72,
+			0xaf, 0x49, 0xfe, 0xf1,
+			0x02, 0xb0, 0x01, 0xb0,
+			0x00, 0xb0, 0x80, 0xff,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x00, 0x00 };
+		u8 new_ver;
+
+		rtl_fw_ver_erase(tp);
+
+		new_ver = 7;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_USB_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_USB);
+
+			/* enable fc timer and set timer to 1 second. */
+			ocp_write_word(tp, MCU_TYPE_USB, USB_FC_TIMER,
+				       CTRL_TIMER_EN | (1000 / 8));
+
+			generic_ocp_write(tp, 0xe600, 0xff,
+					  sizeof(usb_patch2_b), usb_patch2_b,
+					  MCU_TYPE_USB);
+
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xa000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x3d86);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x088a);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x1dee);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x16c2);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x1c94);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x19f0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x27e0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x35a8);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x12f8);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x419e);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x23f4);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x186e);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x19e6);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x0674);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x12a0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x03d0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0xffff);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_USB_VER,
+				       new_ver);
+		}
 
-	rtl_reset_ocp_base(tp);
+		new_ver = 3;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_PLA_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+			generic_ocp_write(tp, 0xf800, 0xff,
+					  sizeof(pla_patch2_b), pla_patch2_b,
+					  MCU_TYPE_PLA);
+
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_BA, 0x8000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_0, 0x0216);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_1, 0x0332);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_2, 0x030c);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_3, 0x0a08);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_4, 0x0ec0);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_5, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_6, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_7, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x001e);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_PLA_VER,
+				       new_ver);
+
+			if (ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_1) & BND_MASK) {
+				ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BP_EN);
+				ocp_data |= BIT(0);
+				ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, ocp_data);
+			}
+		}
+
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_CTRL);
+		ocp_data |= FLOW_CTRL_PATCH_OPT;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_FW_CTRL, ocp_data);
 
-	mode_reg = __le16_to_cpu(phy->mode_reg);
-	sram_write(tp, mode_reg, __le16_to_cpu(phy->mode_pre));
-	sram_write(tp, __le16_to_cpu(phy->ba_reg),
-		   __le16_to_cpu(phy->ba_data));
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);
+		ocp_data |= FC_PATCH_TASK;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);
 
-	length = __le32_to_cpu(phy->blk_hdr.length);
-	length -= __le16_to_cpu(phy->fw_offset);
-	num = length / 2;
-	data = (__le16 *)((u8 *)phy + __le16_to_cpu(phy->fw_offset));
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1);
+		ocp_data |= FW_IP_RESET_EN;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1, ocp_data);
 
-	ocp_reg_write(tp, OCP_SRAM_ADDR, __le16_to_cpu(phy->fw_reg));
-	for (i = 0; i < num; i++)
-		ocp_reg_write(tp, OCP_SRAM_DATA, __le16_to_cpu(data[i]));
+		rtl_reset_ocp_base(tp);
+	} else if (tp->version == RTL_VER_14) {
+		u32 ocp_data;
+		static u8 usb_patch3_a[] = {
+			0x10, 0xe0, 0x79, 0xe0,
+			0x97, 0xe0, 0x99, 0xe0,
+			0xa0, 0xe0, 0xa2, 0xe0,
+			0xa4, 0xe0, 0xa6, 0xe0,
+			0xa8, 0xe0, 0xaa, 0xe0,
+			0xac, 0xe0, 0xae, 0xe0,
+			0xb0, 0xe0, 0xb2, 0xe0,
+			0xb4, 0xe0, 0xb6, 0xe0,
+			0x01, 0xb4, 0x03, 0xb4,
+			0x04, 0xb4, 0x05, 0xb4,
+			0x07, 0xb4, 0x64, 0xc6,
+			0xc0, 0x60, 0x82, 0x48,
+			0xc0, 0x88, 0x5f, 0xc7,
+			0x58, 0xc6, 0xe4, 0x9e,
+			0x0f, 0x1e, 0xe6, 0x8e,
+			0xe6, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xe2, 0x73,
+			0xe0, 0x74, 0xb8, 0x22,
+			0xd8, 0x26, 0xb8, 0x25,
+			0x48, 0x23, 0x68, 0x27,
+			0x48, 0x26, 0x04, 0xb4,
+			0x05, 0xb4, 0x06, 0xb4,
+			0x47, 0xc6, 0xe2, 0x23,
+			0xfe, 0x39, 0x00, 0x1c,
+			0x00, 0x1d, 0x00, 0x13,
+			0x0c, 0xf0, 0xb0, 0x49,
+			0x04, 0xf1, 0x01, 0x05,
+			0xb1, 0x25, 0xfa, 0xe7,
+			0xb8, 0x33, 0x35, 0x43,
+			0x26, 0x31, 0x01, 0x05,
+			0xb1, 0x25, 0xf4, 0xe7,
+			0x06, 0xb0, 0x05, 0xb0,
+			0xae, 0x41, 0x25, 0x31,
+			0x32, 0xc5, 0x6c, 0x41,
+			0x04, 0xb0, 0x05, 0xb4,
+			0x32, 0xc7, 0x2b, 0xc6,
+			0x04, 0x06, 0xe4, 0x9e,
+			0x0f, 0x1e, 0xe6, 0x8e,
+			0xe6, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xe0, 0x76,
+			0xe8, 0x25, 0xe8, 0x23,
+			0xf8, 0x27, 0x20, 0xc5,
+			0x6f, 0x41, 0xb3, 0x20,
+			0x4b, 0x30, 0x4c, 0x41,
+			0x4d, 0x30, 0x1b, 0xc6,
+			0x4e, 0x41, 0x91, 0x21,
+			0xd9, 0x30, 0x05, 0xb0,
+			0x52, 0x22, 0xa3, 0x31,
+			0x13, 0xc7, 0xb7, 0x31,
+			0x13, 0xc7, 0x77, 0x41,
+			0x12, 0xc3, 0xde, 0x30,
+			0x60, 0x65, 0x10, 0xc7,
+			0xe0, 0x8d, 0xe2, 0x9e,
+			0x07, 0xb0, 0x05, 0xb0,
+			0x04, 0xb0, 0x03, 0xb0,
+			0x01, 0xb0, 0x02, 0xc0,
+			0x00, 0xb8, 0xd6, 0x20,
+			0x00, 0xc0, 0x41, 0x00,
+			0xff, 0x00, 0x7f, 0x00,
+			0x00, 0xe6, 0x7a, 0xd3,
+			0x08, 0xdc, 0xe8, 0xd4,
+			0x04, 0xb4, 0x05, 0xb4,
+			0x06, 0xb4, 0x1b, 0xc0,
+			0x00, 0x75, 0xd8, 0x49,
+			0x0d, 0xf0, 0x14, 0xc0,
+			0x14, 0xc5, 0x00, 0x1e,
+			0x08, 0x9e, 0x0c, 0x9d,
+			0x11, 0xc6, 0x0a, 0x9e,
+			0x8f, 0x1c, 0x0e, 0x8c,
+			0x0e, 0x74, 0xcf, 0x49,
+			0xfe, 0xf1, 0x07, 0xc1,
+			0x06, 0xb0, 0x05, 0xb0,
+			0x04, 0xb0, 0x02, 0xc0,
+			0x00, 0xb8, 0xdc, 0x5c,
+			0xe0, 0xcb, 0x00, 0xdc,
+			0x24, 0xe4, 0x80, 0x02,
+			0x34, 0xd3, 0x02, 0xc2,
+			0x00, 0xba, 0x42, 0x08,
+			0x40, 0x60, 0x80, 0x48,
+			0x81, 0x48, 0x82, 0x48,
+			0x40, 0x88, 0x02, 0xc2,
+			0x00, 0xba, 0xf0, 0x1b,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00 };
+		static u8 pla_patch3_a[] = {
+			0x10, 0xe0, 0x12, 0xe0,
+			0x15, 0xe0, 0x1a, 0xe0,
+			0x25, 0xe0, 0x31, 0xe0,
+			0x33, 0xe0, 0x35, 0xe0,
+			0x37, 0xe0, 0x39, 0xe0,
+			0x3b, 0xe0, 0x3d, 0xe0,
+			0x3f, 0xe0, 0x41, 0xe0,
+			0x43, 0xe0, 0x45, 0xe0,
+			0x02, 0xc6, 0x00, 0xbe,
+			0xec, 0x2c, 0x94, 0x49,
+			0x02, 0xc6, 0x00, 0xbe,
+			0xae, 0x2b, 0x05, 0xc0,
+			0x00, 0x72, 0x02, 0xc6,
+			0x00, 0xbe, 0xd6, 0x2b,
+			0x20, 0xe8, 0x08, 0xc3,
+			0x60, 0x65, 0xd0, 0x49,
+			0x06, 0xf1, 0xe0, 0x75,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x3e, 0x08, 0xb4, 0xd3,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x5e, 0x08, 0x6c, 0x74,
+			0xc4, 0x75, 0xe5, 0x41,
+			0xc2, 0x49, 0x05, 0xf0,
+			0x07, 0xc6, 0x01, 0x1c,
+			0xc0, 0x8c, 0xc1, 0x8c,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x16, 0x02, 0x99, 0xd3,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x00, 0x00 };
+		u8 new_ver;
+
+		rtl_fw_ver_erase(tp);
+
+		new_ver = 2;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_PLA_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+			generic_ocp_write(tp, 0xf800, 0xff,
+					  sizeof(pla_patch3_a), pla_patch3_a,
+					  MCU_TYPE_PLA);
+
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_BA, 0x8000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_0, 0x2be6);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_1, 0x2bac);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_2, 0x2bd4);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_3, 0x083c);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_4, 0x0214);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_5, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_6, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_7, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_8, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_9, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_10, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_11, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_12, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_13, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_14, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_15, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP2_EN, 0x001f);
+
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_PLA_VER,
+				       new_ver);
+		}
 
-	sram_write(tp, __le16_to_cpu(phy->patch_en_addr),
-		   __le16_to_cpu(phy->patch_en_value));
+		new_ver = 2;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_USB_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_USB);
+
+			/* enable fc timer and set timer to 1 second. */
+			ocp_write_word(tp, MCU_TYPE_USB, USB_FC_TIMER,
+				       CTRL_TIMER_EN | (1000 / 8));
+
+			generic_ocp_write(tp, 0xe600, 0xff,
+					  sizeof(usb_patch3_a), usb_patch3_a,
+					  MCU_TYPE_USB);
+
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xa000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x02ce);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x5cda);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x0834);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x1bec);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x000f);
+
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_USB_VER,
+				       new_ver);
+		}
 
-	bp_index = __le16_to_cpu(phy->bp_start);
-	num = __le16_to_cpu(phy->bp_num);
-	for (i = 0; i < num; i++) {
-		sram_write(tp, bp_index, __le16_to_cpu(phy->bp[i]));
-		bp_index += 2;
-	}
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_CTRL);
+		ocp_data |= FLOW_CTRL_PATCH_2;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_FW_CTRL, ocp_data);
 
-	sram_write(tp, mode_reg, __le16_to_cpu(phy->mode_post));
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);
+		ocp_data |= FC_PATCH_TASK;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);
+
+		rtl_reset_ocp_base(tp);
+	}
 
-	dev_dbg(&tp->intf->dev, "successfully applied %s\n", phy->info);
+	rtl_reset_ocp_base(tp);
 }
 
-static void rtl8152_fw_mac_apply(struct r8152 *tp, struct fw_mac *mac)
+static void r8156_firmware(struct r8152 *tp)
 {
-	u16 bp_en_addr, bp_index, type, bp_num, fw_ver_reg;
-	u32 length;
-	u8 *data;
-	int i;
+	if (tp->version == RTL_TEST_01) {
+		static u8 usb3_patch_t[] = {
+			0x01, 0xe0, 0x05, 0xc7,
+			0xf6, 0x65, 0x02, 0xc0,
+			0x00, 0xb8, 0x40, 0x03,
+			0x00, 0xd4, 0x00, 0x00 };
+		u16 data;
 
-	switch (__le32_to_cpu(mac->blk_hdr.type)) {
-	case RTL_FW_PLA:
-		type = MCU_TYPE_PLA;
-		break;
-	case RTL_FW_USB:
-		type = MCU_TYPE_USB;
-		break;
-	default:
-		return;
-	}
+		rtl_reset_ocp_base(tp);
 
-	fw_ver_reg = __le16_to_cpu(mac->fw_ver_reg);
-	if (fw_ver_reg && ocp_read_byte(tp, MCU_TYPE_USB, fw_ver_reg) >= mac->fw_ver_data) {
-		dev_dbg(&tp->intf->dev, "%s firmware has been the newest\n", type ? "PLA" : "USB");
-		return;
-	}
+		ocp_reg_write(tp, 0xb87c, 0x8099);
+		ocp_reg_write(tp, 0xb87e, 0x2a50);
+		ocp_reg_write(tp, 0xb87c, 0x80a1);
+		ocp_reg_write(tp, 0xb87e, 0x2a50);
+		ocp_reg_write(tp, 0xb87c, 0x809a);
+		ocp_reg_write(tp, 0xb87e, 0x5010);
+		ocp_reg_write(tp, 0xb87c, 0x80a2);
+		ocp_reg_write(tp, 0xb87e, 0x500f);
+		ocp_reg_write(tp, 0xb87c, 0x8087);
+		ocp_reg_write(tp, 0xb87e, 0xc0cf);
+		ocp_reg_write(tp, 0xb87c, 0x8080);
+		ocp_reg_write(tp, 0xb87e, 0x0f16);
+		ocp_reg_write(tp, 0xb87c, 0x8089);
+		ocp_reg_write(tp, 0xb87e, 0x161b);
+		ocp_reg_write(tp, 0xb87c, 0x808a);
+		ocp_reg_write(tp, 0xb87e, 0x1b1f);
+
+		ocp_reg_write(tp, 0xac36, 0x0080);
+		ocp_reg_write(tp, 0xac4a, 0xff00);
+		data = ocp_reg_read(tp, 0xac34);
+		data &= ~BIT(4);
+		data |= BIT(2) | BIT(3);
+		ocp_reg_write(tp, 0xac34, data);
+
+		data = ocp_reg_read(tp, 0xac54);
+		data &= ~(BIT(9) | BIT(10));
+		ocp_reg_write(tp, 0xac54, data);
+		ocp_reg_write(tp, 0xb87c, 0x8099);
+		ocp_reg_write(tp, 0xb87e, 0x2050);
+		ocp_reg_write(tp, 0xb87c, 0x80a1);
+		ocp_reg_write(tp, 0xb87e, 0x2050);
+		ocp_reg_write(tp, 0xb87c, 0x809a);
+		ocp_reg_write(tp, 0xb87e, 0x5010);
+		ocp_reg_write(tp, 0xb87c, 0x80a2);
+		ocp_reg_write(tp, 0xb87e, 0x500f);
+		data = ocp_reg_read(tp, 0xac34);
+		data &= ~BIT(5);
+		data |= BIT(6) | BIT(7);
+		ocp_reg_write(tp, 0xac34, data);
 
-	rtl_clear_bp(tp, type);
+		if (rtl_phy_patch_request(tp, true, true)) {
+			netif_err(tp, drv, tp->netdev,
+				  "patch request error\n");
+			return;
+		}
 
-	/* Enable backup/restore of MACDBG. This is required after clearing PLA
-	 * break points and before applying the PLA firmware.
-	 */
-	if (tp->version == RTL_VER_04 && type == MCU_TYPE_PLA &&
-	    !(ocp_read_word(tp, MCU_TYPE_PLA, PLA_MACDBG_POST) & DEBUG_OE)) {
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_MACDBG_PRE, DEBUG_LTSSM);
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_MACDBG_POST, DEBUG_LTSSM);
-	}
+		data = ocp_reg_read(tp, 0xb896);
+		data &= ~BIT(0);
+		ocp_reg_write(tp, 0xb896, data);
+		ocp_reg_write(tp, 0xb892, 0x0000);
+		ocp_reg_write(tp, 0xb88e, 0xc089);
+		ocp_reg_write(tp, 0xb890, 0xc1d0);
+		ocp_reg_write(tp, 0xb88e, 0xc08a);
+		ocp_reg_write(tp, 0xb890, 0xe0f0);
+		ocp_reg_write(tp, 0xb88e, 0xc08b);
+		ocp_reg_write(tp, 0xb890, 0xe0f0);
+		ocp_reg_write(tp, 0xb88e, 0xc08c);
+		ocp_reg_write(tp, 0xb890, 0xffff);
+		ocp_reg_write(tp, 0xb88e, 0xc08d);
+		ocp_reg_write(tp, 0xb890, 0xffff);
+		ocp_reg_write(tp, 0xb88e, 0xc08e);
+		ocp_reg_write(tp, 0xb890, 0xffff);
+		ocp_reg_write(tp, 0xb88e, 0xc08f);
+		ocp_reg_write(tp, 0xb890, 0xffff);
+		ocp_reg_write(tp, 0xb88e, 0xc090);
+		ocp_reg_write(tp, 0xb890, 0xff12);
+
+		ocp_reg_write(tp, 0xb88e, 0xc09a);
+		ocp_reg_write(tp, 0xb890, 0x191a);
+		ocp_reg_write(tp, 0xb88e, 0xc09b);
+		ocp_reg_write(tp, 0xb890, 0x191a);
+		ocp_reg_write(tp, 0xb88e, 0xc09e);
+		ocp_reg_write(tp, 0xb890, 0x1d1e);
+		ocp_reg_write(tp, 0xb88e, 0xc09f);
+		ocp_reg_write(tp, 0xb890, 0x1d1e);
+		ocp_reg_write(tp, 0xb88e, 0xc0a0);
+		ocp_reg_write(tp, 0xb890, 0x1f20);
+		ocp_reg_write(tp, 0xb88e, 0xc0a1);
+		ocp_reg_write(tp, 0xb890, 0x1f20);
+		ocp_reg_write(tp, 0xb88e, 0xc0a2);
+		ocp_reg_write(tp, 0xb890, 0x2122);
+		ocp_reg_write(tp, 0xb88e, 0xc0a3);
+		ocp_reg_write(tp, 0xb890, 0x2122);
+		ocp_reg_write(tp, 0xb88e, 0xc0a4);
+		ocp_reg_write(tp, 0xb890, 0x2324);
+		ocp_reg_write(tp, 0xb88e, 0xc0a5);
+		ocp_reg_write(tp, 0xb890, 0x2324);
+
+		ocp_reg_write(tp, 0xb88e, 0xc029);
+		ocp_reg_write(tp, 0xb890, 0xdff3);
+		ocp_reg_write(tp, 0xb88e, 0xc02a);
+		ocp_reg_write(tp, 0xb890, 0xf3f3);
+		ocp_reg_write(tp, 0xb88e, 0xc02b);
+		ocp_reg_write(tp, 0xb890, 0xf3f3);
+		ocp_reg_write(tp, 0xb88e, 0xc02c);
+		ocp_reg_write(tp, 0xb890, 0xf3ef);
+		ocp_reg_write(tp, 0xb88e, 0xc02d);
+		ocp_reg_write(tp, 0xb890, 0xf3ef);
+		ocp_reg_write(tp, 0xb88e, 0xc02e);
+		ocp_reg_write(tp, 0xb890, 0xebe7);
+		ocp_reg_write(tp, 0xb88e, 0xc02f);
+		ocp_reg_write(tp, 0xb890, 0xebe7);
+		ocp_reg_write(tp, 0xb88e, 0xc030);
+		ocp_reg_write(tp, 0xb890, 0xe4e2);
+		ocp_reg_write(tp, 0xb88e, 0xc031);
+		ocp_reg_write(tp, 0xb890, 0xe4e2);
+		ocp_reg_write(tp, 0xb88e, 0xc032);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc033);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc034);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc035);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc036);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc037);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc038);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc039);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc03a);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc03b);
+		ocp_reg_write(tp, 0xb890, 0xdfdf);
+		ocp_reg_write(tp, 0xb88e, 0xc03c);
+		ocp_reg_write(tp, 0xb890, 0xdf00);
 
-	length = __le32_to_cpu(mac->blk_hdr.length);
-	length -= __le16_to_cpu(mac->fw_offset);
+		data = ocp_reg_read(tp, 0xb896);
+		data |= BIT(0);
+		ocp_reg_write(tp, 0xb896, data);
 
-	data = (u8 *)mac;
-	data += __le16_to_cpu(mac->fw_offset);
+		rtl_patch_key_set(tp, 0x8024, 0x0000);
+		sram_write(tp, SRAM_PHY_LOCK, PHY_PATCH_LOCK);
 
-	generic_ocp_write(tp, __le16_to_cpu(mac->fw_reg), 0xff, length, data,
-			  type);
+		data = ocp_reg_read(tp, OCP_PHY_PATCH_CMD);
+		data |= BIT(7);
+		ocp_reg_write(tp, OCP_PHY_PATCH_CMD, data);
+
+		/* nc0_patch_171220_loop_test_USB */
+		sram_write(tp, 0xA016, 0x0000);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8027);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x802e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8035);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x806d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8077);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8091);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3709);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8017);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3bdd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x38c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1034);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4061);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x37b8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1034);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1044);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3b0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1032);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12ed);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2109);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1032);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa130);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd020);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa8c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd020);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd093);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa63f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa73f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd09e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd0dc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd03b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x617d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcdc7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4013);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f7a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f7a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8208);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcc08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x08ba);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x08c6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ee6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x068b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0e9d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x34a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0da2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f1c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd75e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ffd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0dca);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd707);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5e67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2f79);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0dc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd75e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2a51);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0db6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffec);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa540);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1308);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x159e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc445);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdb02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0608);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c47);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0542);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x408d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd075);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6045);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd05d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd07a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1b5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0771);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3b4d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x809f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2635);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0241);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2745);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0241);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x27d0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80aa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ec8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc446);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdb04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd064);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd018);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x068b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0753);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x407b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0771);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2745);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0241);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x608a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6306);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80c5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5e28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2730);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80c5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0771);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc447);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdb08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x406d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c07);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd056);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1c2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ce1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2734);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80c5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c07);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1b2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd0a8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdb08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc447);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x26d7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x648a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fbb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ca0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0320);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa208);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc317);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2c51);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdb10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc448);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa620);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x41dd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa306);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x415f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa210);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa330);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc575);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8210);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8320);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2c59);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3a33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd098);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd191);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x609f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8306);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa320);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa210);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd006);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1e3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc30f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4093);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc033);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02fb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa0f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8208);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02fb);
+		sram_write(tp, 0xA026, 0x0279);
+		sram_write(tp, 0xA024, 0x159c);
+		sram_write(tp, 0xA022, 0x0d94);
+		sram_write(tp, 0xA020, 0x0ee1);
+		sram_write(tp, 0xA006, 0x0f46);
+		sram_write(tp, 0xA004, 0x12e2);
+		sram_write(tp, 0xA002, 0x12ea);
+		sram_write(tp, 0xA000, 0x1034);
+		sram_write(tp, 0xA008, 0xff00);
+
+		/* nc2_patch_171109_USB */
+		sram_write(tp, 0xA016, 0x0020);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8018);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8024);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8056);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8062);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8069);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8080);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0390);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd37a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd21a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0508);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd164);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0441);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcf0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0437);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x010c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb60);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x210c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x001a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f57);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbb80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x605f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9b80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1c3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd074);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfff1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb62);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb910);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9930);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8406);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa780);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd141);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0441);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa70c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6041);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0441);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ed);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd164);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0441);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0450);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0236);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbb80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1c3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd074);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03f3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb17);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0441);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ec0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0e80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaec0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x34a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x012c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5d8e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0134);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb23);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0441);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ec0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0e80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaec0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0426);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5dee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0249);
+		sram_write(tp, 0xA10E, 0x0239);
+		sram_write(tp, 0xA10C, 0x0119);
+		sram_write(tp, 0xA10A, 0x03f2);
+		sram_write(tp, 0xA108, 0x0231);
+		sram_write(tp, 0xA106, 0x0413);
+		sram_write(tp, 0xA104, 0x0108);
+		sram_write(tp, 0xA102, 0x0506);
+		sram_write(tp, 0xA100, 0x038e);
+		sram_write(tp, 0xA110, 0x00ff);
+
+		/* uc2_patch_171006_calc_txcrc_reg_write_seq_USB */
+		sram_write(tp, 0xb87c, 0x82c1);
+		sram_write(tp, 0xb87e, 0xaf82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcdaf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82d6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd9af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82dc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0282);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdc02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x830c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd7af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0eea);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe4f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8169);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac23);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x815d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad23);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1bf7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfa02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b99);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0283);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3cf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d70);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8169);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac24);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x815d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad24);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1bf7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfa02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8349);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0283);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3cf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x861d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf70f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcfad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x27fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf60f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8375);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae16);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x83aa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae0e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x848f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae06);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x857e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad2b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x16ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ee1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x815d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf62c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe581);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5dbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8663);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe281);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa6e3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3905);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac2f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1da2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0417);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0285);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x815d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf62c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe581);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5dbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8663);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4412);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x20e6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe781);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa75d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0303);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe281);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa4e3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5d03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x030c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x260c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x341e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x121e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8666);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8d1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x09bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8669);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8675);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa201);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0abf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x867b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x64ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x22a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x020a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7e02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3f2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae15);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa203);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0abf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8681);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x64ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x08bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8684);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6483);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a63);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa81a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x961f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x66ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x563d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1fd9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef79);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef16);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x290a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x435c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef97);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1916);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaed9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8678);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2879);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3f2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa094);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe381);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa7d1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8672);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x100d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x121f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1259);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0043);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5903);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x851c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe681);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa4e7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5d03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x120c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x121e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x130c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x121e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x120c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x121e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8666);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8d1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x09bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8669);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8675);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x06bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8675);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f66);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8283);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3c00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2741);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2c00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8672);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x868a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x868d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8690);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x868a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1311);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x435c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2b02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x16ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3f2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ee2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe381);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa7d1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8672);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1259);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5903);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0da0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x900a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13e7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x81a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae2f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa094);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x26d1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8672);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x100d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x161f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1259);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x000d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5903);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcdbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8675);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd209);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3b0e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad3f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8669);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0243);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5c12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaee8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad2b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x44e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8169);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf62c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe581);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x815d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf62c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe581);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5def);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa400);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa601);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa300);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x44a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe070);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb468);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdab4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x68ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb468);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0b6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3a20);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb638);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeb6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x38ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb638);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10b5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0032);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54b5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0076);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4e70);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb450);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x52b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4e66);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb44e);
+		sram_write(tp, 0xb85e, 0x03d1);
+		sram_write(tp, 0xb860, 0x0ee4);
+		sram_write(tp, 0xb862, 0x0fde);
+		sram_write(tp, 0xb864, 0xffff);
+		sram_write(tp, 0xb878, 0x0001);
+
+		data = ocp_reg_read(tp, OCP_PHY_PATCH_CMD);
+		data &= ~BIT(7);
+		ocp_reg_write(tp, OCP_PHY_PATCH_CMD, data);
+
+		/* uc_patch_171212_customer_USB */
+		sram_write(tp, 0x8586, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x92af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8598);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa1af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0285);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa1af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0414);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7e02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1cf8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9e3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x83ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa601);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x580f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa008);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4659);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f9e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4239);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0aab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ead);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2729);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf60e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe283);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xab1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x239f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x28e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb714);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe1b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x155c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9fee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0285);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0af7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0fe0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffcf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0fe2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x83ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f23);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9f03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa6fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfb02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f77);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2ee1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb72f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ce0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb72c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe1b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x864c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2ae1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb72b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ce0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb728);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe1b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x864c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x26e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb727);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x47d2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb8e6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb468);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe5b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69d2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbce6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb468);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe4b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x866d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfffd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfad2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x675e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d71);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f7f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2803);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x010d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4112);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa210);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb463);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6901);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe4b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb463);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8016);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad2d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3bbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x08ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2832);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3f08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x29d2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x023f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x080d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11f6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2fef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x31e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf627);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf627);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86ca);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbfa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf4e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fed);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c21);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a92);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe08f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeee1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe08f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0217);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x70fc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xff04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2087);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0620);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8709);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0087);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cbb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa880);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeea8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8070);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa880);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60a8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x18e8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa818);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60a8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a00);
+		sram_write(tp, 0xb818, 0x040e);
+		sram_write(tp, 0xb81a, 0x1019);
+		sram_write(tp, 0xb81c, 0xffff);
+		sram_write(tp, 0xb81e, 0xffff);
+		sram_write(tp, 0xb832, 0x0003);
+
+		rtl_patch_key_set(tp, 0x8024, 0x0000);
+		ocp_reg_write(tp, 0xc414, 0x0200);
 
-	ocp_write_word(tp, type, __le16_to_cpu(mac->bp_ba_addr),
-		       __le16_to_cpu(mac->bp_ba_value));
+		rtl_phy_patch_request(tp, false, true);
 
-	bp_index = __le16_to_cpu(mac->bp_start);
-	bp_num = __le16_to_cpu(mac->bp_num);
-	for (i = 0; i < bp_num; i++) {
-		ocp_write_word(tp, type, bp_index, __le16_to_cpu(mac->bp[i]));
-		bp_index += 2;
+		r8156_lock_main(tp, true);
+
+		sram_write(tp, 0x80c9, 0x3478);
+		sram_write(tp, 0x80d0, 0xfe8f);
+		sram_write(tp, 0x80ca, 0x7843);
+		sram_write(tp, 0x80cb, 0x43b0);
+		sram_write(tp, 0x80cb, 0x4380);
+		sram_write(tp, 0x80cc, 0xb00b);
+		sram_write(tp, 0x80cd, 0x0ba1);
+		sram_write(tp, 0x80d8, 0x1078);
+		sram_write(tp, 0x8016, 0x3f00);
+		sram_write(tp, 0x8fed, 0x0386);
+		sram_write(tp, 0x8fee, 0x86f4);
+		sram_write(tp, 0x8fef, 0xf486);
+		sram_write(tp, 0x8ff0, 0x86fd);
+		sram_write(tp, 0x8ff1, 0xfd28);
+		sram_write(tp, 0x8ff2, 0x285a);
+		sram_write(tp, 0x8ff3, 0x5a70);
+		sram_write(tp, 0x8ff4, 0x7000);
+		sram_write(tp, 0x8ff5, 0x005d);
+		sram_write(tp, 0x8ff6, 0x5d77);
+		sram_write(tp, 0x8ff7, 0x7778);
+		sram_write(tp, 0x8ff8, 0x785f);
+		sram_write(tp, 0x8ff9, 0x5f74);
+		sram_write(tp, 0x8ffa, 0x7478);
+		sram_write(tp, 0x8ffb, 0x7858);
+		sram_write(tp, 0x8ffc, 0x5870);
+		sram_write(tp, 0x8ffd, 0x7078);
+		sram_write(tp, 0x8ffe, 0x7850);
+		sram_write(tp, 0x8fff, 0x5000);
+		sram_write(tp, 0x80dd, 0x34a4);
+		sram_write(tp, 0x80e4, 0xfe7f);
+		sram_write(tp, 0x80e6, 0x4a19);
+		sram_write(tp, 0x80de, 0xa443);
+		sram_write(tp, 0x80df, 0x43a0);
+		sram_write(tp, 0x80df, 0x43a0);
+		sram_write(tp, 0x80e0, 0xa00a);
+		sram_write(tp, 0x80e1, 0x0a00);
+		sram_write(tp, 0x80e8, 0x700c);
+		sram_write(tp, 0x80e2, 0x0007);
+		sram_write(tp, 0x80e3, 0x07fe);
+		sram_write(tp, 0x80ec, 0x0e78);
+		sram_write(tp, 0x80b5, 0x42f7);
+		sram_write(tp, 0x80bc, 0xfaa4);
+		sram_write(tp, 0x80bf, 0x1f80);
+		sram_write(tp, 0x80be, 0xff1f);
+		sram_write(tp, 0x80b7, 0x4280);
+		sram_write(tp, 0x80b6, 0xf742);
+		sram_write(tp, 0x80b8, 0x800f);
+		sram_write(tp, 0x80b9, 0x0fab);
+		sram_write(tp, 0x80c1, 0x1e0a);
+		sram_write(tp, 0x80c0, 0x801e);
+		sram_write(tp, 0x80bd, 0xa4ff);
+		sram_write(tp, 0x80bb, 0x0bfa);
+		sram_write(tp, 0x80ba, 0xab0b);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0x818d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x003d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x009b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00cb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00f2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00c2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0065);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0034);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x001b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x000e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0007);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		sram_write(tp, 0x8163, 0xdb06);
+		sram_write(tp, 0x816a, 0xdb06);
+		sram_write(tp, 0x8171, 0xdb06);
+
+		r8156_lock_main(tp, false);
+
+		rtl_clear_bp(tp, MCU_TYPE_USB);
+
+		generic_ocp_write(tp, 0xe600, 0xff, sizeof(usb3_patch_t),
+				  usb3_patch_t, MCU_TYPE_USB);
+
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x033e);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x0001);
 	}
 
-	bp_en_addr = __le16_to_cpu(mac->bp_en_addr);
-	if (bp_en_addr)
-		ocp_write_word(tp, type, bp_en_addr,
-			       __le16_to_cpu(mac->bp_en_value));
-
-	if (fw_ver_reg)
-		ocp_write_byte(tp, MCU_TYPE_USB, fw_ver_reg,
-			       mac->fw_ver_data);
-
-	dev_dbg(&tp->intf->dev, "successfully applied %s\n", mac->info);
+	rtl_reset_ocp_base(tp);
 }
 
-static void rtl8152_apply_firmware(struct r8152 *tp, bool power_cut)
+static void r8153_aldps_en(struct r8152 *tp, bool enable)
 {
-	struct rtl_fw *rtl_fw = &tp->rtl_fw;
-	const struct firmware *fw;
-	struct fw_header *fw_hdr;
-	struct fw_phy_patch_key *key;
-	u16 key_addr = 0;
-	int i, patch_phy = 1;
-
-	if (IS_ERR_OR_NULL(rtl_fw->fw))
-		return;
-
-	fw = rtl_fw->fw;
-	fw_hdr = (struct fw_header *)fw->data;
-
-	if (rtl_fw->pre_fw)
-		rtl_fw->pre_fw(tp);
+	u16 data;
 
-	for (i = offsetof(struct fw_header, blocks); i < fw->size;) {
-		struct fw_block *block = (struct fw_block *)&fw->data[i];
+	data = ocp_reg_read(tp, OCP_POWER_CFG);
+	if (enable) {
+		data |= EN_ALDPS;
+		ocp_reg_write(tp, OCP_POWER_CFG, data);
+	} else {
+		int i;
 
-		switch (__le32_to_cpu(block->type)) {
-		case RTL_FW_END:
-			goto post_fw;
-		case RTL_FW_PLA:
-		case RTL_FW_USB:
-			rtl8152_fw_mac_apply(tp, (struct fw_mac *)block);
-			break;
-		case RTL_FW_PHY_START:
-			if (!patch_phy)
-				break;
-			key = (struct fw_phy_patch_key *)block;
-			key_addr = __le16_to_cpu(key->key_reg);
-			rtl_pre_ram_code(tp, key_addr, __le16_to_cpu(key->key_data), !power_cut);
-			break;
-		case RTL_FW_PHY_STOP:
-			if (!patch_phy)
+		data &= ~EN_ALDPS;
+		ocp_reg_write(tp, OCP_POWER_CFG, data);
+		for (i = 0; i < 20; i++) {
+			usleep_range(1000, 2000);
+			if (ocp_read_word(tp, MCU_TYPE_PLA, 0xe000) & 0x0100)
 				break;
-			WARN_ON(!key_addr);
-			rtl_post_ram_code(tp, key_addr, !power_cut);
-			break;
-		case RTL_FW_PHY_NC:
-			rtl8152_fw_phy_nc_apply(tp, (struct fw_phy_nc *)block);
-			break;
-		case RTL_FW_PHY_VER:
-			patch_phy = rtl8152_fw_phy_ver(tp, (struct fw_phy_ver *)block);
-			break;
-		case RTL_FW_PHY_UNION_NC:
-		case RTL_FW_PHY_UNION_NC1:
-		case RTL_FW_PHY_UNION_NC2:
-		case RTL_FW_PHY_UNION_UC2:
-		case RTL_FW_PHY_UNION_UC:
-		case RTL_FW_PHY_UNION_MISC:
-			if (patch_phy)
-				rtl8152_fw_phy_union_apply(tp, (struct fw_phy_union *)block);
-			break;
-		case RTL_FW_PHY_FIXUP:
-			if (patch_phy)
-				rtl8152_fw_phy_fixup(tp, (struct fw_phy_fixup *)block);
-			break;
-		case RTL_FW_PHY_SPEED_UP:
-			rtl_ram_code_speed_up(tp, (struct fw_phy_speed_up *)block, !power_cut);
-			break;
-		default:
-			break;
 		}
-
-		i += ALIGN(__le32_to_cpu(block->length), 8);
 	}
 
-post_fw:
-	if (rtl_fw->post_fw)
-		rtl_fw->post_fw(tp);
-
-	rtl_reset_ocp_base(tp);
-	strscpy(rtl_fw->version, fw_hdr->version, RTL_VER_SIZE);
-	dev_info(&tp->intf->dev, "load %s successfully\n", rtl_fw->version);
+	tp->ups_info.aldps = enable;
 }
 
-static void rtl8152_release_firmware(struct r8152 *tp)
+static void r8153b_mcu_spdown_en(struct r8152 *tp, bool enable)
 {
-	struct rtl_fw *rtl_fw = &tp->rtl_fw;
+	u32 ocp_data;
 
-	if (!IS_ERR_OR_NULL(rtl_fw->fw)) {
-		release_firmware(rtl_fw->fw);
-		rtl_fw->fw = NULL;
-	}
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
+	if (enable)
+		ocp_data |= PLA_MCU_SPDWN_EN;
+	else
+		ocp_data &= ~PLA_MCU_SPDWN_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
 }
 
-static int rtl8152_request_firmware(struct r8152 *tp)
+static void r8153_hw_phy_cfg(struct r8152 *tp)
 {
-	struct rtl_fw *rtl_fw = &tp->rtl_fw;
-	long rc;
-
-	if (rtl_fw->fw || !rtl_fw->fw_name) {
-		dev_info(&tp->intf->dev, "skip request firmware\n");
-		rc = 0;
-		goto result;
-	}
+	u32 ocp_data;
+	u16 data;
 
-	rc = request_firmware(&rtl_fw->fw, rtl_fw->fw_name, &tp->intf->dev);
-	if (rc < 0)
-		goto result;
+	/* disable ALDPS before updating the PHY parameters */
+	r8153_aldps_en(tp, false);
 
-	rc = rtl8152_check_firmware(tp, rtl_fw);
-	if (rc < 0)
-		release_firmware(rtl_fw->fw);
+	/* disable EEE before updating the PHY parameters */
+	rtl_eee_enable(tp, false);
 
-result:
-	if (rc) {
-		rtl_fw->fw = ERR_PTR(rc);
+	r8153_firmware(tp);
 
-		dev_warn(&tp->intf->dev,
-			 "unable to load firmware patch %s (%ld)\n",
-			 rtl_fw->fw_name, rc);
+	if (tp->version == RTL_VER_03) {
+		data = ocp_reg_read(tp, OCP_EEE_CFG);
+		data &= ~CTAP_SHORT_EN;
+		ocp_reg_write(tp, OCP_EEE_CFG, data);
 	}
 
-	return rc;
-}
+	data = ocp_reg_read(tp, OCP_POWER_CFG);
+	data |= EEE_CLKDIV_EN;
+	ocp_reg_write(tp, OCP_POWER_CFG, data);
 
-static void r8152_aldps_en(struct r8152 *tp, bool enable)
-{
-	if (enable) {
-		ocp_reg_write(tp, OCP_ALDPS_CONFIG, ENPWRSAVE | ENPDNPS |
-						    LINKENA | DIS_SDSAVE);
-	} else {
-		ocp_reg_write(tp, OCP_ALDPS_CONFIG, ENPDNPS | LINKENA |
-						    DIS_SDSAVE);
-		msleep(20);
-	}
-}
+	data = ocp_reg_read(tp, OCP_DOWN_SPEED);
+	data |= EN_10M_BGOFF;
+	ocp_reg_write(tp, OCP_DOWN_SPEED, data);
+	data = ocp_reg_read(tp, OCP_POWER_CFG);
+	data |= EN_10M_PLLOFF;
+	ocp_reg_write(tp, OCP_POWER_CFG, data);
+	sram_write(tp, SRAM_IMPEDANCE, 0x0b13);
 
-static inline void r8152_mmd_indirect(struct r8152 *tp, u16 dev, u16 reg)
-{
-	ocp_reg_write(tp, OCP_EEE_AR, FUN_ADDR | dev);
-	ocp_reg_write(tp, OCP_EEE_DATA, reg);
-	ocp_reg_write(tp, OCP_EEE_AR, FUN_DATA | dev);
-}
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
+	ocp_data |= PFM_PWM_SWITCH;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
 
-static u16 r8152_mmd_read(struct r8152 *tp, u16 dev, u16 reg)
-{
-	u16 data;
+	/* Enable LPF corner auto tune */
+	sram_write(tp, SRAM_LPF_CFG, 0xf70f);
 
-	r8152_mmd_indirect(tp, dev, reg);
-	data = ocp_reg_read(tp, OCP_EEE_DATA);
-	ocp_reg_write(tp, OCP_EEE_AR, 0x0000);
+	/* Adjust 10M Amplitude */
+	sram_write(tp, SRAM_10M_AMP1, 0x00af);
+	sram_write(tp, SRAM_10M_AMP2, 0x0208);
 
-	return data;
-}
+	if (tp->eee_en)
+		rtl_eee_enable(tp, true);
 
-static void r8152_mmd_write(struct r8152 *tp, u16 dev, u16 reg, u16 data)
-{
-	r8152_mmd_indirect(tp, dev, reg);
-	ocp_reg_write(tp, OCP_EEE_DATA, data);
-	ocp_reg_write(tp, OCP_EEE_AR, 0x0000);
+	r8153_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
+
+	switch (tp->version) {
+	case RTL_VER_03:
+	case RTL_VER_04:
+		break;
+	case RTL_VER_05:
+	case RTL_VER_06:
+	default:
+		r8153_u2p3en(tp, true);
+		break;
+	}
+
+	set_bit(PHY_RESET, &tp->flags);
 }
 
-static void r8152_eee_en(struct r8152 *tp, bool enable)
+static u32 r8152_efuse_read(struct r8152 *tp, u8 addr)
 {
-	u16 config1, config2, config3;
 	u32 ocp_data;
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);
-	config1 = ocp_reg_read(tp, OCP_EEE_CONFIG1) & ~sd_rise_time_mask;
-	config2 = ocp_reg_read(tp, OCP_EEE_CONFIG2);
-	config3 = ocp_reg_read(tp, OCP_EEE_CONFIG3) & ~fast_snr_mask;
-
-	if (enable) {
-		ocp_data |= EEE_RX_EN | EEE_TX_EN;
-		config1 |= EEE_10_CAP | EEE_NWAY_EN | TX_QUIET_EN | RX_QUIET_EN;
-		config1 |= sd_rise_time(1);
-		config2 |= RG_DACQUIET_EN | RG_LDVQUIET_EN;
-		config3 |= fast_snr(42);
-	} else {
-		ocp_data &= ~(EEE_RX_EN | EEE_TX_EN);
-		config1 &= ~(EEE_10_CAP | EEE_NWAY_EN | TX_QUIET_EN |
-			     RX_QUIET_EN);
-		config1 |= sd_rise_time(7);
-		config2 &= ~(RG_DACQUIET_EN | RG_LDVQUIET_EN);
-		config3 |= fast_snr(511);
-	}
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EFUSE_CMD, EFUSE_READ_CMD | addr);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EFUSE_CMD);
+	ocp_data = (ocp_data & EFUSE_DATA_BIT16) << 9;	/* data of bit16 */
+	ocp_data |= ocp_read_word(tp, MCU_TYPE_PLA, PLA_EFUSE_DATA);
 
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_CR, ocp_data);
-	ocp_reg_write(tp, OCP_EEE_CONFIG1, config1);
-	ocp_reg_write(tp, OCP_EEE_CONFIG2, config2);
-	ocp_reg_write(tp, OCP_EEE_CONFIG3, config3);
+	return ocp_data;
 }
 
-static void r8153_eee_en(struct r8152 *tp, bool enable)
+static void r8153b_hw_phy_cfg(struct r8152 *tp)
 {
 	u32 ocp_data;
-	u16 config;
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);
-	config = ocp_reg_read(tp, OCP_EEE_CFG);
+	u16 data;
 
-	if (enable) {
-		ocp_data |= EEE_RX_EN | EEE_TX_EN;
-		config |= EEE10_EN;
-	} else {
-		ocp_data &= ~(EEE_RX_EN | EEE_TX_EN);
-		config &= ~EEE10_EN;
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);
+	if (ocp_data & PCUT_STATUS) {
+		ocp_data &= ~PCUT_STATUS;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);
 	}
 
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_CR, ocp_data);
-	ocp_reg_write(tp, OCP_EEE_CFG, config);
-
-	tp->ups_info.eee = enable;
-}
-
-static void r8156_eee_en(struct r8152 *tp, bool enable)
-{
-	u16 config;
+	/* disable ALDPS before updating the PHY parameters */
+	r8153_aldps_en(tp, false);
 
-	r8153_eee_en(tp, enable);
+	/* disable EEE before updating the PHY parameters */
+	rtl_eee_enable(tp, false);
 
-	config = ocp_reg_read(tp, OCP_EEE_ADV2);
+	/* U1/U2/L1 idle timer. 500 us */
+	ocp_write_word(tp, MCU_TYPE_USB, USB_U1U2_TIMER, 500);
 
-	if (enable)
-		config |= MDIO_EEE_2_5GT;
-	else
-		config &= ~MDIO_EEE_2_5GT;
+	data = r8153_phy_status(tp, 0);
 
-	ocp_reg_write(tp, OCP_EEE_ADV2, config);
-}
+	switch (data) {
+	case PHY_STAT_PWRDN:
+	case PHY_STAT_EXT_INIT:
+		r8153b_firmware(tp);
 
-static void rtl_eee_enable(struct r8152 *tp, bool enable)
-{
-	switch (tp->version) {
-	case RTL_VER_01:
-	case RTL_VER_02:
-	case RTL_VER_07:
-		if (enable) {
-			r8152_eee_en(tp, true);
-			r8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV,
-					tp->eee_adv);
-		} else {
-			r8152_eee_en(tp, false);
-			r8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, 0);
-		}
-		break;
-	case RTL_VER_03:
-	case RTL_VER_04:
-	case RTL_VER_05:
-	case RTL_VER_06:
-	case RTL_VER_08:
-	case RTL_VER_09:
-	case RTL_VER_14:
-		if (enable) {
-			r8153_eee_en(tp, true);
-			ocp_reg_write(tp, OCP_EEE_ADV, tp->eee_adv);
-		} else {
-			r8153_eee_en(tp, false);
-			ocp_reg_write(tp, OCP_EEE_ADV, 0);
-		}
-		break;
-	case RTL_VER_10:
-	case RTL_VER_11:
-	case RTL_VER_12:
-	case RTL_VER_13:
-	case RTL_VER_15:
-		if (enable) {
-			r8156_eee_en(tp, true);
-			ocp_reg_write(tp, OCP_EEE_ADV, tp->eee_adv);
-		} else {
-			r8156_eee_en(tp, false);
-			ocp_reg_write(tp, OCP_EEE_ADV, 0);
-		}
+		data = r8152_mdio_read(tp, MII_BMCR);
+		data &= ~BMCR_PDOWN;
+		r8152_mdio_write(tp, MII_BMCR, data);
 		break;
+	case PHY_STAT_LAN_ON:
 	default:
+		r8153b_firmware(tp);
 		break;
 	}
-}
 
-static void r8152b_enable_fc(struct r8152 *tp)
-{
-	u16 anar;
+	r8153b_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));
 
-	anar = r8152_mdio_read(tp, MII_ADVERTISE);
-	anar |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
-	r8152_mdio_write(tp, MII_ADVERTISE, anar);
+	data = sram_read(tp, SRAM_GREEN_CFG);
+	data |= R_TUNE_EN;
+	sram_write(tp, SRAM_GREEN_CFG, data);
+	data = ocp_reg_read(tp, OCP_NCTL_CFG);
+	data |= PGA_RETURN_EN;
+	ocp_reg_write(tp, OCP_NCTL_CFG, data);
 
-	tp->ups_info.flow_control = true;
-}
+	/* ADC Bias Calibration:
+	 * read efuse offset 0x7d to get a 17-bit data. Remove the dummy/fake
+	 * bit (bit3) to rebuild the real 16-bit data. Write the data to the
+	 * ADC ioffset.
+	 */
+	ocp_data = r8152_efuse_read(tp, 0x7d);
+	data = (u16)(((ocp_data & 0x1fff0) >> 1) | (ocp_data & 0x7));
+	if (data != 0xffff)
+		ocp_reg_write(tp, OCP_ADC_IOFFSET, data);
 
-static void rtl8152_disable(struct r8152 *tp)
-{
-	r8152_aldps_en(tp, false);
-	rtl_disable(tp);
-	r8152_aldps_en(tp, true);
-}
+	/* ups mode tx-link-pulse timing adjustment:
+	 * rg_saw_cnt = OCP reg 0xC426 Bit[13:0]
+	 * swr_cnt_1ms_ini = 16000000 / rg_saw_cnt
+	 */
+	ocp_data = ocp_reg_read(tp, 0xc426);
+	ocp_data &= 0x3fff;
+	if (ocp_data) {
+		u32 swr_cnt_1ms_ini;
 
-static void r8152b_hw_phy_cfg(struct r8152 *tp)
-{
-	rtl8152_apply_firmware(tp, false);
-	rtl_eee_enable(tp, tp->eee_en);
-	r8152_aldps_en(tp, true);
+		swr_cnt_1ms_ini = (16000000 / ocp_data) & SAW_CNT_1MS_MASK;
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_UPS_CFG);
+		ocp_data = (ocp_data & ~SAW_CNT_1MS_MASK) | swr_cnt_1ms_ini;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_UPS_CFG, ocp_data);
+	}
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
+	ocp_data |= PFM_PWM_SWITCH;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
+
+#ifdef CONFIG_CTAP_SHORT_OFF
+	data = ocp_reg_read(tp, OCP_EEE_CFG);
+	data &= ~CTAP_SHORT_EN;
+	ocp_reg_write(tp, OCP_EEE_CFG, data);
+
+	tp->ups_info.ctap_short_off = true;
+#endif
+	/* Advnace EEE */
+	if (!rtl_phy_patch_request(tp, true, true)) {
+		data = ocp_reg_read(tp, OCP_POWER_CFG);
+		data |= EEE_CLKDIV_EN;
+		ocp_reg_write(tp, OCP_POWER_CFG, data);
+		tp->ups_info.eee_ckdiv = true;
+
+		data = ocp_reg_read(tp, OCP_DOWN_SPEED);
+		data |= EN_EEE_CMODE | EN_EEE_1000 | EN_10M_CLKDIV;
+		ocp_reg_write(tp, OCP_DOWN_SPEED, data);
+		tp->ups_info.eee_cmod_lv = true;
+		tp->ups_info._10m_ckdiv = true;
+		tp->ups_info.eee_plloff_giga = true;
+
+		ocp_reg_write(tp, OCP_SYSCLK_CFG, 0);
+		ocp_reg_write(tp, OCP_SYSCLK_CFG, clk_div_expo(5));
+		tp->ups_info._250m_ckdiv = true;
+
+		rtl_phy_patch_request(tp, false, true);
+	}
+
+	if (tp->eee_en)
+		rtl_eee_enable(tp, true);
+
+	r8153_aldps_en(tp, true);
 	r8152b_enable_fc(tp);
+//	r8153_u2p3en(tp, true);
 
 	set_bit(PHY_RESET, &tp->flags);
+	rtl_set_dbg_info_state(tp, DGB_DRV_STATE_LOAD);
 }
 
-static void wait_oob_link_list_ready(struct r8152 *tp)
+static void r8153c_hw_phy_cfg(struct r8152 *tp)
 {
-	u32 ocp_data;
-	int i;
+	r8153b_hw_phy_cfg(tp);
 
-	for (i = 0; i < 1000; i++) {
-		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
-		if (ocp_data & LINK_LIST_READY)
-			break;
-		usleep_range(1000, 2000);
-	}
+	tp->ups_info.r_tune = true;
 }
 
-static void r8156b_wait_loading_flash(struct r8152 *tp)
+static void rtl8153_change_mtu(struct r8152 *tp)
 {
-	if ((ocp_read_word(tp, MCU_TYPE_PLA, PLA_GPHY_CTRL) & GPHY_FLASH) &&
-	    !(ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL) & BYPASS_FLASH)) {
-		int i;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, mtu_to_size(tp->netdev->mtu));
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_JUMBO);
+}
 
-		for (i = 0; i < 100; i++) {
-			if (ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL) & GPHY_PATCH_DONE)
-				break;
-			usleep_range(1000, 2000);
-		}
+static void r8153_lanwake_clr_en(struct r8152 *tp, bool enable)
+{
+	u32 ocp_data;
+
+	if (enable) {
+		/* Enable the feature that the MCU could clear the lanwake */
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6);
+		ocp_data |= LANWAKE_CLR_EN;
+		ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6, ocp_data);
+
+		/* Clear lanwake */
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG);
+		ocp_data &= ~LANWAKE_PIN;
+		ocp_write_byte(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG, ocp_data);
+	} else {
+		/* Disable the feature that the MCU could clear the lanwake */
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6);
+		ocp_data &= ~LANWAKE_CLR_EN;
+		ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6, ocp_data);
 	}
 }
 
-static void r8152b_exit_oob(struct r8152 *tp)
+static void r8153_first_init(struct r8152 *tp)
 {
 	u32 ocp_data;
 
+	rxdy_gated_en(tp, true);
+	r8153_teredo_off(tp);
+
 	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
 	ocp_data &= ~RCR_ACPT_ALL;
 	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
 
-	rxdy_gated_en(tp, true);
-	r8153_teredo_off(tp);
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, 0x00);
+	rtl8152_nic_reset(tp);
+	rtl_reset_bmu(tp);
 
 	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
 	ocp_data &= ~NOW_IS_OOB;
@@ -5415,44 +9175,27 @@ static void r8152b_exit_oob(struct r8152 *tp)
 
 	wait_oob_link_list_ready(tp);
 
+	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+
+	rtl8153_change_mtu(tp);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0);
+	ocp_data |= TCR0_AUTO_FIFO;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TCR0, ocp_data);
+
 	rtl8152_nic_reset(tp);
 
 	/* rx share fifo credit full threshold */
 	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_NORMAL);
-
-	if (tp->udev->speed == USB_SPEED_FULL ||
-	    tp->udev->speed == USB_SPEED_LOW) {
-		/* rx share fifo credit near full threshold */
-		ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,
-				RXFIFO_THR2_FULL);
-		ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,
-				RXFIFO_THR3_FULL);
-	} else {
-		/* rx share fifo credit near full threshold */
-		ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,
-				RXFIFO_THR2_HIGH);
-		ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,
-				RXFIFO_THR3_HIGH);
-	}
-
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_NORMAL);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_NORMAL);
 	/* TX share fifo free credit full threshold */
 	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, TXFIFO_THR_NORMAL2);
 
-	ocp_write_byte(tp, MCU_TYPE_USB, USB_TX_AGG, TX_AGG_MAX_THRESHOLD);
-	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_HIGH);
-	ocp_write_dword(tp, MCU_TYPE_USB, USB_TX_DMA,
-			TEST_MODE_DISABLE | TX_SIZE_ADJUST1);
-
-	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
-
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8152_RMS);
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0);
-	ocp_data |= TCR0_AUTO_FIFO;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TCR0, ocp_data);
+	r8153_lanwake_clr_en(tp, true);
 }
 
-static void r8152b_enter_oob(struct r8152 *tp)
+static void r8153_enter_oob(struct r8152 *tp)
 {
 	u32 ocp_data;
 
@@ -5460,11 +9203,13 @@ static void r8152b_enter_oob(struct r8152 *tp)
 	ocp_data &= ~NOW_IS_OOB;
 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
 
+	/* RX FIFO settings for OOB */
 	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_OOB);
-	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_OOB);
-	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_OOB);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_OOB);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_OOB);
 
 	rtl_disable(tp);
+	rtl_reset_bmu(tp);
 
 	wait_oob_link_list_ready(tp);
 
@@ -5474,7 +9219,32 @@ static void r8152b_enter_oob(struct r8152 *tp)
 
 	wait_oob_link_list_ready(tp);
 
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8152_RMS);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, 1522);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_DEFAULT);
+
+	switch (tp->version) {
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG);
+		ocp_data &= ~TEREDO_WAKE_MASK;
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG, ocp_data);
+		break;
+
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_VER_14:
+		/* Clear teredo wake event. bit[15:8] is the teredo wakeup
+		 * type. Set it to zero. bits[7:0] are the W1C bits about
+		 * the events. Set them to all 1 to clear them.
+		 */
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_WAKE_BASE, 0x00ff);
+		break;
+
+	default:
+		break;
+	}
 
 	rtl_rx_vlan_en(tp, true);
 
@@ -5486,233 +9256,409 @@ static void r8152b_enter_oob(struct r8152 *tp)
 	ocp_data |= NOW_IS_OOB | DIS_MCU_CLROOB;
 	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
 
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+	ocp_data |= MCU_BORW_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+
 	rxdy_gated_en(tp, false);
 
 	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
 	ocp_data |= RCR_APM | RCR_AM | RCR_AB;
 	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+
+	r8153_lanwake_clr_en(tp, false);
 }
 
-static int r8153_pre_firmware_1(struct r8152 *tp)
+static void rtl8153_disable(struct r8152 *tp)
 {
-	int i;
-
-	/* Wait till the WTD timer is ready. It would take at most 104 ms. */
-	for (i = 0; i < 104; i++) {
-		u32 ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_WDT1_CTRL);
-
-		if (!(ocp_data & WTD1_EN))
-			break;
-		usleep_range(1000, 2000);
-	}
-
-	return 0;
+	r8153_aldps_en(tp, false);
+	rtl_disable(tp);
+	rtl_reset_bmu(tp);
+	r8153_aldps_en(tp, true);
 }
 
-static int r8153_post_firmware_1(struct r8152 *tp)
+static u32 fc_pause_on_auto(struct r8152 *tp)
 {
-	/* set USB_BP_4 to support USB_SPEED_SUPER only */
-	if (ocp_read_byte(tp, MCU_TYPE_USB, USB_CSTMR) & FORCE_SUPER)
-		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, BP4_SUPER_ONLY);
-
-	/* reset UPHY timer to 36 ms */
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_UPHY_TIMER, 36000 / 16);
-
-	return 0;
+	return (ALIGN(mtu_to_size(tp->netdev->mtu), 1024) + 6 * 1024);
 }
 
-static int r8153_pre_firmware_2(struct r8152 *tp)
+static u32 fc_pause_off_auto(struct r8152 *tp)
 {
-	u32 ocp_data;
-
-	r8153_pre_firmware_1(tp);
+	return (ALIGN(mtu_to_size(tp->netdev->mtu), 1024) + 14 * 1024);
+}
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN0);
-	ocp_data &= ~FW_FIX_SUSPEND;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN0, ocp_data);
+static void r8156_fc_parameter(struct r8152 *tp)
+{
+	u32 pause_on = tp->fc_pause_on ? tp->fc_pause_on : fc_pause_on_auto(tp);
+	u32 pause_off = tp->fc_pause_off ? tp->fc_pause_off : fc_pause_off_auto(tp);
 
-	return 0;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, pause_on / 16);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, pause_off / 16);
 }
 
-static int r8153_post_firmware_2(struct r8152 *tp)
+static int rtl8156_enable(struct r8152 *tp)
 {
 	u32 ocp_data;
+	u16 speed;
 
-	/* enable bp0 if support USB_SPEED_SUPER only */
-	if (ocp_read_byte(tp, MCU_TYPE_USB, USB_CSTMR) & FORCE_SUPER) {
-		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BP_EN);
-		ocp_data |= BIT(0);
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, ocp_data);
-	}
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
 
-	/* reset UPHY timer to 36 ms */
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_UPHY_TIMER, 36000 / 16);
+	r8156_fc_parameter(tp);
+	set_tx_qlen(tp);
+	rtl_set_eee_plus(tp);
+	r8153_set_rx_early_timeout(tp);
+	r8153_set_rx_early_size(tp);
 
-	/* enable U3P3 check, set the counter to 4 */
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, U3P3_CHECK_EN | 4);
+	switch (tp->version) {
+	case RTL_TEST_01:
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, 0xe95a);
+		ocp_data &= ~0xf;
+		ocp_data |= 5;
+		ocp_write_byte(tp, MCU_TYPE_PLA, 0xe95a, ocp_data);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN0);
-	ocp_data |= FW_FIX_SUSPEND;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN0, ocp_data);
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, 0xe940);
+		ocp_data &= ~0x1f;
+		ocp_data |= 4;
+		ocp_write_byte(tp, MCU_TYPE_PLA, 0xe940, ocp_data);
+		break;
+	default:
+		break;
+	}
 
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_USB2PHY);
-	ocp_data |= USB2PHY_L1 | USB2PHY_SUSPEND;
-	ocp_write_byte(tp, MCU_TYPE_USB, USB_USB2PHY, ocp_data);
+	speed = rtl8152_get_speed(tp);
+	rtl_set_ifg(tp, speed);
 
-	return 0;
-}
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4);
+	if (speed & _2500bps)
+		ocp_data &= ~IDLE_SPDWN_EN;
+	else
+		ocp_data |= IDLE_SPDWN_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, ocp_data);
 
-static int r8153_post_firmware_3(struct r8152 *tp)
-{
-	u32 ocp_data;
+	if (speed & _1000bps)
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_TXTWSYS, 0x11);
+	else if (speed & _500bps)
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_TXTWSYS, 0x3d);
 
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_USB2PHY);
-	ocp_data |= USB2PHY_L1 | USB2PHY_SUSPEND;
-	ocp_write_byte(tp, MCU_TYPE_USB, USB_USB2PHY, ocp_data);
+	if (tp->udev->speed == USB_SPEED_HIGH) {
+		/* USB 0xb45e[3:0] l1_nyet_hird */
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_L1_CTRL);
+		ocp_data &= ~0xf;
+		if (is_flow_control(speed))
+			ocp_data |= 0xf;
+		else
+			ocp_data |= 0x1;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_L1_CTRL, ocp_data);
+	}
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1);
-	ocp_data |= FW_IP_RESET_EN;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1, ocp_data);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);
+	ocp_data &= ~FC_PATCH_TASK;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);
+	usleep_range(1000, 2000);
+	ocp_data |= FC_PATCH_TASK;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);
 
-	return 0;
+	return rtl_enable(tp);
 }
 
-static int r8153b_pre_firmware_1(struct r8152 *tp)
+static void rtl8156_disable(struct r8152 *tp)
 {
-	/* enable fc timer and set timer to 1 second. */
-	ocp_write_word(tp, MCU_TYPE_USB, USB_FC_TIMER,
-		       CTRL_TIMER_EN | (1000 / 8));
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, 0);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, 0);
 
-	return 0;
+	rtl8153_disable(tp);
 }
 
-static int r8153b_post_firmware_1(struct r8152 *tp)
+static int rtl8156b_enable(struct r8152 *tp)
 {
 	u32 ocp_data;
+	u16 speed;
 
-	/* enable bp0 for RTL8153-BND */
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_1);
-	if (ocp_data & BND_MASK) {
-		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BP_EN);
-		ocp_data |= BIT(0);
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, ocp_data);
-	}
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_CTRL);
-	ocp_data |= FLOW_CTRL_PATCH_OPT;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_CTRL, ocp_data);
+	set_tx_qlen(tp);
+	rtl_set_eee_plus(tp);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);
-	ocp_data |= FC_PATCH_TASK;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_RX_AGGR_NUM);
+	ocp_data &= ~RX_AGGR_NUM_MASK;
+//	ocp_data |= 2;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_RX_AGGR_NUM, ocp_data);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1);
-	ocp_data |= FW_IP_RESET_EN;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1, ocp_data);
+	r8153_set_rx_early_timeout(tp);
+	r8153_set_rx_early_size(tp);
 
-	return 0;
-}
+	speed = rtl8152_get_speed(tp);
+	rtl_set_ifg(tp, speed);
 
-static int r8153c_post_firmware_1(struct r8152 *tp)
-{
-	u32 ocp_data;
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4);
+	if (speed & _2500bps)
+		ocp_data &= ~IDLE_SPDWN_EN;
+	else
+		ocp_data |= IDLE_SPDWN_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, ocp_data);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_CTRL);
-	ocp_data |= FLOW_CTRL_PATCH_2;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_CTRL, ocp_data);
+	if (tp->udev->speed == USB_SPEED_HIGH) {
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_L1_CTRL);
+		ocp_data &= ~0xf;
+		if (is_flow_control(speed))
+			ocp_data |= 0xf;
+		else
+			ocp_data |= 0x1;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_L1_CTRL, ocp_data);
+	}
 
 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);
+	ocp_data &= ~FC_PATCH_TASK;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);
+	usleep_range(1000, 2000);
 	ocp_data |= FC_PATCH_TASK;
 	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);
 
-	return 0;
+	return rtl_enable(tp);
 }
 
-static int r8156a_post_firmware_1(struct r8152 *tp)
+static int rtl8152_set_speed(struct r8152 *tp, u8 autoneg, u32 speed, u8 duplex,
+			     u32 advertising)
 {
-	u32 ocp_data;
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1);
-	ocp_data |= FW_IP_RESET_EN;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1, ocp_data);
-
-	/* Modify U3PHY parameter for compatibility issue */
-	ocp_write_dword(tp, MCU_TYPE_USB, USB_UPHY3_MDCMDIO, 0x4026840e);
-	ocp_write_dword(tp, MCU_TYPE_USB, USB_UPHY3_MDCMDIO, 0x4001acc9);
-
-	return 0;
-}
+	u16 bmcr;
+	int ret = 0;
 
-static void r8153_aldps_en(struct r8152 *tp, bool enable)
-{
-	u16 data;
+	if (autoneg == AUTONEG_DISABLE) {
+		if (duplex != DUPLEX_HALF && duplex != DUPLEX_FULL)
+			return -EINVAL;
 
-	data = ocp_reg_read(tp, OCP_POWER_CFG);
-	if (enable) {
-		data |= EN_ALDPS;
-		ocp_reg_write(tp, OCP_POWER_CFG, data);
+		switch (speed) {
+		case SPEED_10:
+			bmcr = BMCR_SPEED10;
+			if (duplex == DUPLEX_FULL) {
+				bmcr |= BMCR_FULLDPLX;
+				tp->ups_info.speed_duplex = FORCE_10M_FULL;
+			} else {
+				tp->ups_info.speed_duplex = FORCE_10M_HALF;
+			}
+			break;
+		case SPEED_100:
+			bmcr = BMCR_SPEED100;
+			if (duplex == DUPLEX_FULL) {
+				bmcr |= BMCR_FULLDPLX;
+				tp->ups_info.speed_duplex = FORCE_100M_FULL;
+			} else {
+				tp->ups_info.speed_duplex = FORCE_100M_HALF;
+			}
+			break;
+		case SPEED_1000:
+			if (tp->mii.supports_gmii) {
+				bmcr = BMCR_SPEED1000 | BMCR_FULLDPLX;
+				tp->ups_info.speed_duplex = NWAY_1000M_FULL;
+				break;
+			}
+			fallthrough;
+		default:
+			ret = -EINVAL;
+			goto out;
+		}
+
+		if (duplex == DUPLEX_FULL)
+			tp->mii.full_duplex = 1;
+		else
+			tp->mii.full_duplex = 0;
+
+		tp->mii.force_media = 1;
 	} else {
+		u16 orig, new1;
+		u32 support;
+
+		support = RTL_ADVERTISED_10_HALF | RTL_ADVERTISED_10_FULL |
+			  RTL_ADVERTISED_100_HALF | RTL_ADVERTISED_100_FULL;
+
+		if (tp->mii.supports_gmii) {
+			support |= RTL_ADVERTISED_1000_FULL;
+
+			if (tp->support_2500full)
+				support |= RTL_ADVERTISED_2500_FULL;
+		}
+
+		if (!(advertising & support))
+			return -EINVAL;
+
+		orig = r8152_mdio_read(tp, MII_ADVERTISE);
+		new1 = orig & ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+				ADVERTISE_100HALF | ADVERTISE_100FULL);
+		if (advertising & RTL_ADVERTISED_10_HALF) {
+			new1 |= ADVERTISE_10HALF;
+			tp->ups_info.speed_duplex = NWAY_10M_HALF;
+		}
+		if (advertising & RTL_ADVERTISED_10_FULL) {
+			new1 |= ADVERTISE_10FULL;
+			tp->ups_info.speed_duplex = NWAY_10M_FULL;
+		}
+
+		if (advertising & RTL_ADVERTISED_100_HALF) {
+			new1 |= ADVERTISE_100HALF;
+			tp->ups_info.speed_duplex = NWAY_100M_HALF;
+		}
+		if (advertising & RTL_ADVERTISED_100_FULL) {
+			new1 |= ADVERTISE_100FULL;
+			tp->ups_info.speed_duplex = NWAY_100M_FULL;
+		}
+
+		if (orig != new1) {
+			r8152_mdio_write(tp, MII_ADVERTISE, new1);
+			tp->mii.advertising = new1;
+		}
+
+		if (tp->mii.supports_gmii) {
+			orig = r8152_mdio_read(tp, MII_CTRL1000);
+			new1 = orig & ~(ADVERTISE_1000FULL |
+					ADVERTISE_1000HALF);
+
+			if (advertising & RTL_ADVERTISED_1000_FULL) {
+				new1 |= ADVERTISE_1000FULL;
+				tp->ups_info.speed_duplex = NWAY_1000M_FULL;
+			}
+
+			if (orig != new1)
+				r8152_mdio_write(tp, MII_CTRL1000, new1);
+		}
+
+		if (tp->support_2500full) {
+			orig = ocp_reg_read(tp, OCP_10GBT_CTRL);
+			new1 = orig & ~MDIO_AN_10GBT_CTRL_ADV2_5G;
+
+			if (advertising & RTL_ADVERTISED_2500_FULL) {
+				new1 |= MDIO_AN_10GBT_CTRL_ADV2_5G;
+				tp->ups_info.speed_duplex = NWAY_2500M_FULL;
+			}
+
+			if (orig != new1)
+				ocp_reg_write(tp, OCP_10GBT_CTRL, new1);
+		}
+
+		bmcr = BMCR_ANENABLE | BMCR_ANRESTART;
+
+		tp->mii.force_media = 0;
+	}
+
+	if (test_and_clear_bit(PHY_RESET, &tp->flags))
+		bmcr |= BMCR_RESET;
+
+	r8152_mdio_write(tp, MII_BMCR, bmcr);
+
+	if (bmcr & BMCR_RESET) {
 		int i;
 
-		data &= ~EN_ALDPS;
-		ocp_reg_write(tp, OCP_POWER_CFG, data);
-		for (i = 0; i < 20; i++) {
-			usleep_range(1000, 2000);
-			if (ocp_read_word(tp, MCU_TYPE_PLA, 0xe000) & 0x0100)
+		for (i = 0; i < 50; i++) {
+			msleep(20);
+			if ((r8152_mdio_read(tp, MII_BMCR) & BMCR_RESET) == 0)
 				break;
 		}
 	}
 
-	tp->ups_info.aldps = enable;
+out:
+	return ret;
 }
 
-static void r8153_hw_phy_cfg(struct r8152 *tp)
+static bool rtl_speed_down(struct r8152 *tp)
 {
-	u32 ocp_data;
-	u16 data;
+	bool ret = false;
 
-	/* disable ALDPS before updating the PHY parameters */
-	r8153_aldps_en(tp, false);
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return ret;
 
-	/* disable EEE before updating the PHY parameters */
-	rtl_eee_enable(tp, false);
+	if ((tp->saved_wolopts & WAKE_ANY) && !(tp->saved_wolopts & WAKE_PHY)) {
+		u16 bmcr;
 
-	rtl8152_apply_firmware(tp, false);
+		bmcr = r8152_mdio_read(tp, MII_BMCR);
 
-	if (tp->version == RTL_VER_03) {
-		data = ocp_reg_read(tp, OCP_EEE_CFG);
-		data &= ~CTAP_SHORT_EN;
-		ocp_reg_write(tp, OCP_EEE_CFG, data);
+		if (netif_carrier_ok(tp->netdev) && (bmcr & BMCR_ANENABLE) &&
+		    (r8152_mdio_read(tp, MII_EXPANSION) & EXPANSION_NWAY)) {
+			u16 anar, gbcr = 0, lpa, gbcr2 = 0;
+
+			anar = r8152_mdio_read(tp, MII_ADVERTISE);
+			anar &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+				  ADVERTISE_100HALF | ADVERTISE_100FULL);
+
+			if (tp->mii.supports_gmii) {
+				gbcr = r8152_mdio_read(tp, MII_CTRL1000);
+				gbcr &= ~(ADVERTISE_1000FULL |
+					  ADVERTISE_1000HALF);
+				if (tp->support_2500full) {
+					gbcr2 = ocp_reg_read(tp, 0xa5d4);
+					gbcr2 &= ~BIT(7);
+				}
+			}
+
+			lpa = r8152_mdio_read(tp, MII_LPA);
+			if (lpa & (LPA_10HALF | LPA_10FULL)) {
+				anar |= ADVERTISE_10HALF | ADVERTISE_10FULL;
+				rtl_eee_plus_en(tp, true);
+			} else if (lpa & (LPA_100HALF | LPA_100FULL)) {
+				anar |= ADVERTISE_10HALF | ADVERTISE_10FULL |
+					ADVERTISE_100HALF | ADVERTISE_100FULL;
+			} else {
+				goto out1;
+			}
+
+			if (tp->mii.supports_gmii) {
+				r8152_mdio_write(tp, MII_CTRL1000, gbcr);
+				if (tp->support_2500full)
+					ocp_reg_write(tp, 0xa5d4, gbcr2);
+			}
+
+			r8152_mdio_write(tp, MII_ADVERTISE, anar);
+			r8152_mdio_write(tp, MII_BMCR, bmcr | BMCR_ANRESTART);
+
+			set_bit(RECOVER_SPEED, &tp->flags);
+			ret = true;
+		}
 	}
 
-	data = ocp_reg_read(tp, OCP_POWER_CFG);
-	data |= EEE_CLKDIV_EN;
-	ocp_reg_write(tp, OCP_POWER_CFG, data);
+out1:
+	return ret;
+}
 
-	data = ocp_reg_read(tp, OCP_DOWN_SPEED);
-	data |= EN_10M_BGOFF;
-	ocp_reg_write(tp, OCP_DOWN_SPEED, data);
-	data = ocp_reg_read(tp, OCP_POWER_CFG);
-	data |= EN_10M_PLLOFF;
-	ocp_reg_write(tp, OCP_POWER_CFG, data);
-	sram_write(tp, SRAM_IMPEDANCE, 0x0b13);
+static void rtl8152_up(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
-	ocp_data |= PFM_PWM_SWITCH;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
+	r8152_aldps_en(tp, false);
+	r8152b_exit_oob(tp);
+	r8152_aldps_en(tp, true);
+}
 
-	/* Enable LPF corner auto tune */
-	sram_write(tp, SRAM_LPF_CFG, 0xf70f);
+static void rtl8152_down(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		return;
+	}
 
-	/* Adjust 10M Amplitude */
-	sram_write(tp, SRAM_10M_AMP1, 0x00af);
-	sram_write(tp, SRAM_10M_AMP2, 0x0208);
+	r8152_power_cut_en(tp, false);
+	r8152_aldps_en(tp, false);
+	r8152b_enter_oob(tp);
+	r8152_aldps_en(tp, true);
+}
 
-	if (tp->eee_en)
-		rtl_eee_enable(tp, true);
+static void rtl8153_up(struct r8152 *tp)
+{
+	u32 ocp_data;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8153_u1u2en(tp, false);
+	r8153_u2p3en(tp, false);
+	r8153_aldps_en(tp, false);
+	r8153_first_init(tp);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SSPHYLINK1);
+	ocp_data &= ~DELAY_PHY_PWR_CHG;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_SSPHYLINK1, ocp_data);
 
 	r8153_aldps_en(tp, true);
-	r8152b_enable_fc(tp);
 
 	switch (tp->version) {
 	case RTL_VER_03:
@@ -5725,143 +9671,86 @@ static void r8153_hw_phy_cfg(struct r8152 *tp)
 		break;
 	}
 
-	set_bit(PHY_RESET, &tp->flags);
+	r8153_u1u2en(tp, true);
 }
 
-static u32 r8152_efuse_read(struct r8152 *tp, u8 addr)
+static void rtl8153_down(struct r8152 *tp)
 {
-	u32 ocp_data;
-
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EFUSE_CMD, EFUSE_READ_CMD | addr);
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EFUSE_CMD);
-	ocp_data = (ocp_data & EFUSE_DATA_BIT16) << 9;	/* data of bit16 */
-	ocp_data |= ocp_read_word(tp, MCU_TYPE_PLA, PLA_EFUSE_DATA);
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		return;
+	}
 
-	return ocp_data;
+	r8153_u1u2en(tp, false);
+	r8153_u2p3en(tp, false);
+	r8153_power_cut_en(tp, false);
+	r8153_aldps_en(tp, false);
+	r8153_enter_oob(tp);
+	r8153_aldps_en(tp, true);
 }
 
-static void r8153b_hw_phy_cfg(struct r8152 *tp)
+static void rtl8153b_up(struct r8152 *tp)
 {
-	u32 ocp_data;
-	u16 data;
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);
-	if (ocp_data & PCUT_STATUS) {
-		ocp_data &= ~PCUT_STATUS;
-		ocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);
-	}
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
 
-	/* disable ALDPS before updating the PHY parameters */
+	r8153b_u1u2en(tp, false);
+	r8153_u2p3en(tp, false);
 	r8153_aldps_en(tp, false);
 
-	/* disable EEE before updating the PHY parameters */
-	rtl_eee_enable(tp, false);
-
-	/* U1/U2/L1 idle timer. 500 us */
-	ocp_write_word(tp, MCU_TYPE_USB, USB_U1U2_TIMER, 500);
-
-	data = r8153_phy_status(tp, 0);
-
-	switch (data) {
-	case PHY_STAT_PWRDN:
-	case PHY_STAT_EXT_INIT:
-		rtl8152_apply_firmware(tp, true);
-
-		data = r8152_mdio_read(tp, MII_BMCR);
-		data &= ~BMCR_PDOWN;
-		r8152_mdio_write(tp, MII_BMCR, data);
-		break;
-	case PHY_STAT_LAN_ON:
-	default:
-		rtl8152_apply_firmware(tp, false);
-		break;
-	}
-
-	r8153b_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));
-
-	data = sram_read(tp, SRAM_GREEN_CFG);
-	data |= R_TUNE_EN;
-	sram_write(tp, SRAM_GREEN_CFG, data);
-	data = ocp_reg_read(tp, OCP_NCTL_CFG);
-	data |= PGA_RETURN_EN;
-	ocp_reg_write(tp, OCP_NCTL_CFG, data);
-
-	/* ADC Bias Calibration:
-	 * read efuse offset 0x7d to get a 17-bit data. Remove the dummy/fake
-	 * bit (bit3) to rebuild the real 16-bit data. Write the data to the
-	 * ADC ioffset.
-	 */
-	ocp_data = r8152_efuse_read(tp, 0x7d);
-	data = (u16)(((ocp_data & 0x1fff0) >> 1) | (ocp_data & 0x7));
-	if (data != 0xffff)
-		ocp_reg_write(tp, OCP_ADC_IOFFSET, data);
-
-	/* ups mode tx-link-pulse timing adjustment:
-	 * rg_saw_cnt = OCP reg 0xC426 Bit[13:0]
-	 * swr_cnt_1ms_ini = 16000000 / rg_saw_cnt
-	 */
-	ocp_data = ocp_reg_read(tp, 0xc426);
-	ocp_data &= 0x3fff;
-	if (ocp_data) {
-		u32 swr_cnt_1ms_ini;
-
-		swr_cnt_1ms_ini = (16000000 / ocp_data) & SAW_CNT_1MS_MASK;
-		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_UPS_CFG);
-		ocp_data = (ocp_data & ~SAW_CNT_1MS_MASK) | swr_cnt_1ms_ini;
-		ocp_write_word(tp, MCU_TYPE_USB, USB_UPS_CFG, ocp_data);
-	}
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
-	ocp_data |= PFM_PWM_SWITCH;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
-
-	/* Advnace EEE */
-	if (!rtl_phy_patch_request(tp, true, true)) {
-		data = ocp_reg_read(tp, OCP_POWER_CFG);
-		data |= EEE_CLKDIV_EN;
-		ocp_reg_write(tp, OCP_POWER_CFG, data);
-		tp->ups_info.eee_ckdiv = true;
-
-		data = ocp_reg_read(tp, OCP_DOWN_SPEED);
-		data |= EN_EEE_CMODE | EN_EEE_1000 | EN_10M_CLKDIV;
-		ocp_reg_write(tp, OCP_DOWN_SPEED, data);
-		tp->ups_info.eee_cmod_lv = true;
-		tp->ups_info._10m_ckdiv = true;
-		tp->ups_info.eee_plloff_giga = true;
-
-		ocp_reg_write(tp, OCP_SYSCLK_CFG, 0);
-		ocp_reg_write(tp, OCP_SYSCLK_CFG, clk_div_expo(5));
-		tp->ups_info._250m_ckdiv = true;
-
-		rtl_phy_patch_request(tp, false, true);
-	}
-
-	if (tp->eee_en)
-		rtl_eee_enable(tp, true);
+	r8153_first_init(tp);
+	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_B);
 
+	r8153b_mcu_spdown_en(tp, false);
 	r8153_aldps_en(tp, true);
-	r8152b_enable_fc(tp);
-
-	set_bit(PHY_RESET, &tp->flags);
+//	r8153_u2p3en(tp, true);
+	if (tp->udev->speed >= USB_SPEED_SUPER)
+		r8153b_u1u2en(tp, true);
 }
 
-static void r8153c_hw_phy_cfg(struct r8152 *tp)
+static void rtl8153b_down(struct r8152 *tp)
 {
-	r8153b_hw_phy_cfg(tp);
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		return;
+	}
 
-	tp->ups_info.r_tune = true;
+	r8153b_mcu_spdown_en(tp, true);
+	r8153b_u1u2en(tp, false);
+	r8153_u2p3en(tp, false);
+	r8153b_power_cut_en(tp, false);
+	r8153_aldps_en(tp, false);
+	r8153_enter_oob(tp);
+	r8153_aldps_en(tp, true);
 }
 
-static void rtl8153_change_mtu(struct r8152 *tp)
+static void rtl8153c_change_mtu(struct r8152 *tp)
 {
 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, mtu_to_size(tp->netdev->mtu));
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_JUMBO);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, 10 * 1024 / 64);
+
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);
+
+	/* Adjust the tx fifo free credit full threshold, otherwise
+	 * the fifo would be too small to send a jumbo frame packet.
+	 */
+	if (tp->netdev->mtu < 8000)
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL, 2048 / 8);
+	else
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL, 900 / 8);
 }
 
-static void r8153_first_init(struct r8152 *tp)
+static void rtl8153c_up(struct r8152 *tp)
 {
 	u32 ocp_data;
 
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8153b_u1u2en(tp, false);
+	r8153_u2p3en(tp, false);
+	r8153_aldps_en(tp, false);
+
 	rxdy_gated_en(tp, true);
 	r8153_teredo_off(tp);
 
@@ -5890,1338 +9779,7166 @@ static void r8153_first_init(struct r8152 *tp)
 
 	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
 
-	rtl8153_change_mtu(tp);
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0);
-	ocp_data |= TCR0_AUTO_FIFO;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TCR0, ocp_data);
+	rtl8153c_change_mtu(tp);
 
 	rtl8152_nic_reset(tp);
 
 	/* rx share fifo credit full threshold */
-	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_NORMAL);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, 0x02);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, 0x08);
 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_NORMAL);
 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_NORMAL);
+
+	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_B);
+
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);
+	ocp_data |= BIT(8);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);
+
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+
+	r8153b_mcu_spdown_en(tp, false);
+
+	r8153_aldps_en(tp, true);
+//	r8153_u2p3en(tp, true);
+	r8153b_u1u2en(tp, true);
+}
+
+static void rtl8156_change_mtu(struct r8152 *tp)
+{
+	u32 rx_max_size = mtu_to_size(tp->netdev->mtu);
+
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, rx_max_size);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_JUMBO);
+	r8156_fc_parameter(tp);
+
 	/* TX share fifo free credit full threshold */
-	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, TXFIFO_THR_NORMAL2);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL,
+		       ALIGN(rx_max_size + sizeof(struct tx_desc), 1024) / 16);
 }
 
-static void r8153_enter_oob(struct r8152 *tp)
+static void rtl8156_up(struct r8152 *tp)
 {
 	u32 ocp_data;
 
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
-	ocp_data &= ~NOW_IS_OOB;
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
 
-	/* RX FIFO settings for OOB */
-	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_OOB);
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_OOB);
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_OOB);
+	r8153b_u1u2en(tp, false);
+	r8153_u2p3en(tp, false);
+	r8153_aldps_en(tp, false);
 
-	rtl_disable(tp);
+	rxdy_gated_en(tp, true);
+	r8153_teredo_off(tp);
+
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+	ocp_data &= ~RCR_ACPT_ALL;
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+
+	rtl8152_nic_reset(tp);
 	rtl_reset_bmu(tp);
 
-	wait_oob_link_list_ready(tp);
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+	ocp_data &= ~NOW_IS_OOB;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
 
 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
-	ocp_data |= RE_INIT_LL;
+	ocp_data &= ~MCU_BORW_EN;
 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
 
-	wait_oob_link_list_ready(tp);
+	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
 
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, 1522);
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_DEFAULT);
+	rtl8156_change_mtu(tp);
 
 	switch (tp->version) {
-	case RTL_VER_03:
-	case RTL_VER_04:
-	case RTL_VER_05:
-	case RTL_VER_06:
-		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG);
-		ocp_data &= ~TEREDO_WAKE_MASK;
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG, ocp_data);
-		break;
-
-	case RTL_VER_08:
-	case RTL_VER_09:
-	case RTL_VER_14:
-		/* Clear teredo wake event. bit[15:8] is the teredo wakeup
-		 * type. Set it to zero. bits[7:0] are the W1C bits about
-		 * the events. Set them to all 1 to clear them.
-		 */
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_WAKE_BASE, 0x00ff);
+	case RTL_TEST_01:
+	case RTL_VER_10:
+	case RTL_VER_11:
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_BMU_CONFIG);
+		ocp_data |= ACT_ODMA;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BMU_CONFIG, ocp_data);
 		break;
-
 	default:
 		break;
 	}
 
-	rtl_rx_vlan_en(tp, true);
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BDC_CR);
-	ocp_data |= ALDPS_PROXY_MODE;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_BDC_CR, ocp_data);
+	/* share FIFO settings */
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL);
+	ocp_data &= ~RXFIFO_FULL_MASK;
+	ocp_data |= 0x08;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, ocp_data);
 
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
-	ocp_data |= NOW_IS_OOB | DIS_MCU_CLROOB;
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+	r8153b_mcu_spdown_en(tp, false);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
-	ocp_data |= MCU_BORW_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION);
+	ocp_data &= ~(RG_PWRDN_EN | ALL_SPEED_OFF);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION, ocp_data);
 
-	rxdy_gated_en(tp, false);
+	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, 0x00600400);
 
-	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
-	ocp_data |= RCR_APM | RCR_AM | RCR_AB;
-	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
-}
+	if (tp->saved_wolopts != __rtl_get_wol(tp)) {
+		netif_warn(tp, ifup, tp->netdev, "wol setting is changed\n");
+		__rtl_set_wol(tp, tp->saved_wolopts);
+	}
 
-static void rtl8153_disable(struct r8152 *tp)
-{
-	r8153_aldps_en(tp, false);
-	rtl_disable(tp);
-	rtl_reset_bmu(tp);
 	r8153_aldps_en(tp, true);
+	r8153_u2p3en(tp, true);
+
+	if (tp->udev->speed >= USB_SPEED_SUPER)
+		r8153b_u1u2en(tp, true);
 }
 
-static int rtl8156_enable(struct r8152 *tp)
+static void rtl8156_down(struct r8152 *tp)
 {
 	u32 ocp_data;
-	u16 speed;
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return -ENODEV;
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		return;
+	}
 
-	set_tx_qlen(tp);
-	rtl_set_eee_plus(tp);
-	r8153_set_rx_early_timeout(tp);
-	r8153_set_rx_early_size(tp);
+	r8153b_mcu_spdown_en(tp, true);
+	r8153b_u1u2en(tp, false);
+	r8153_u2p3en(tp, false);
+	r8153b_power_cut_en(tp, false);
+	r8153_aldps_en(tp, false);
 
-	speed = rtl8152_get_speed(tp);
-	rtl_set_ifg(tp, speed);
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+	ocp_data &= ~NOW_IS_OOB;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4);
-	if (speed & _2500bps)
-		ocp_data &= ~IDLE_SPDWN_EN;
-	else
-		ocp_data |= IDLE_SPDWN_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, ocp_data);
+	/* RX FIFO settings for OOB */
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, 64 / 16);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, 1024 / 16);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, 4096 / 16);
 
-	if (speed & _1000bps)
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_TXTWSYS, 0x11);
-	else if (speed & _500bps)
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_TXTWSYS, 0x3d);
+	rtl_disable(tp);
+	rtl_reset_bmu(tp);
 
-	if (tp->udev->speed == USB_SPEED_HIGH) {
-		/* USB 0xb45e[3:0] l1_nyet_hird */
-		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_L1_CTRL);
-		ocp_data &= ~0xf;
-		if (is_flow_control(speed))
-			ocp_data |= 0xf;
-		else
-			ocp_data |= 0x1;
-		ocp_write_word(tp, MCU_TYPE_USB, USB_L1_CTRL, ocp_data);
-	}
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, 1522);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_DEFAULT);
 
-	return rtl_enable(tp);
-}
+	/* Clear teredo wake event. bit[15:8] is the teredo wakeup
+	 * type. Set it to zero. bits[7:0] are the W1C bits about
+	 * the events. Set them to all 1 to clear them.
+	 */
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_WAKE_BASE, 0x00ff);
 
-static int rtl8156b_enable(struct r8152 *tp)
-{
-	u32 ocp_data;
-	u16 speed;
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BDC_CR);
+	ocp_data |= ALDPS_PROXY_MODE;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_BDC_CR, ocp_data);
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return -ENODEV;
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+	ocp_data |= NOW_IS_OOB | DIS_MCU_CLROOB;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
 
-	set_tx_qlen(tp);
-	rtl_set_eee_plus(tp);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+	ocp_data |= MCU_BORW_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_RX_AGGR_NUM);
-	ocp_data &= ~RX_AGGR_NUM_MASK;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_RX_AGGR_NUM, ocp_data);
+	rtl_rx_vlan_en(tp, true);
+	rxdy_gated_en(tp, false);
 
-	r8153_set_rx_early_timeout(tp);
-	r8153_set_rx_early_size(tp);
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+	ocp_data |= RCR_APM | RCR_AM | RCR_AB;
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
 
-	speed = rtl8152_get_speed(tp);
-	rtl_set_ifg(tp, speed);
+	r8153_aldps_en(tp, true);
+}
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4);
-	if (speed & _2500bps)
-		ocp_data &= ~IDLE_SPDWN_EN;
+static bool rtl8152_in_nway(struct r8152 *tp)
+{
+	u16 nway_state;
+
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, 0x2000);
+	tp->ocp_base = 0x2000;
+	ocp_write_byte(tp, MCU_TYPE_PLA, 0xb014, 0x4c);		/* phy state */
+	nway_state = ocp_read_word(tp, MCU_TYPE_PLA, 0xb01a);
+
+	/* bit 15: TXDIS_STATE, bit 14: ABD_STATE */
+	if (nway_state & 0xc000)
+		return false;
 	else
-		ocp_data |= IDLE_SPDWN_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, ocp_data);
+		return true;
+}
 
-	if (tp->udev->speed == USB_SPEED_HIGH) {
-		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_L1_CTRL);
-		ocp_data &= ~0xf;
-		if (is_flow_control(speed))
-			ocp_data |= 0xf;
-		else
-			ocp_data |= 0x1;
-		ocp_write_word(tp, MCU_TYPE_USB, USB_L1_CTRL, ocp_data);
-	}
+static bool rtl8153_in_nway(struct r8152 *tp)
+{
+	u16 phy_state = ocp_reg_read(tp, OCP_PHY_STATE) & 0xff;
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);
-	ocp_data &= ~FC_PATCH_TASK;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);
-	usleep_range(1000, 2000);
-	ocp_data |= FC_PATCH_TASK;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);
+	if (phy_state == TXDIS_STATE || phy_state == ABD_STATE)
+		return false;
+	else
+		return true;
+}
 
-	return rtl_enable(tp);
+static void r8156_mdio_force_mode(struct r8152 *tp)
+{
+	u16 data;
+
+	/* Select force mode through 0xa5b4 bit 15
+	 * 0: MDIO force mode
+	 * 1: MMD force mode
+	 */
+	data = ocp_reg_read(tp, 0xa5b4);
+	if (data & BIT(15)) {
+		data &= ~BIT(15);
+		ocp_reg_write(tp, 0xa5b4, data);
+	}
 }
 
-static int rtl8152_set_speed(struct r8152 *tp, u8 autoneg, u32 speed, u8 duplex,
-			     u32 advertising)
+static void set_carrier(struct r8152 *tp)
 {
-	u16 bmcr;
-	int ret = 0;
+	struct net_device *netdev = tp->netdev;
+	struct napi_struct *napi = &tp->napi;
+	u16 speed;
 
-	if (autoneg == AUTONEG_DISABLE) {
-		if (duplex != DUPLEX_HALF && duplex != DUPLEX_FULL)
-			return -EINVAL;
+	speed = rtl8152_get_speed(tp);
 
-		switch (speed) {
-		case SPEED_10:
-			bmcr = BMCR_SPEED10;
-			if (duplex == DUPLEX_FULL) {
-				bmcr |= BMCR_FULLDPLX;
-				tp->ups_info.speed_duplex = FORCE_10M_FULL;
-			} else {
-				tp->ups_info.speed_duplex = FORCE_10M_HALF;
-			}
-			break;
-		case SPEED_100:
-			bmcr = BMCR_SPEED100;
-			if (duplex == DUPLEX_FULL) {
-				bmcr |= BMCR_FULLDPLX;
-				tp->ups_info.speed_duplex = FORCE_100M_FULL;
-			} else {
-				tp->ups_info.speed_duplex = FORCE_100M_HALF;
-			}
-			break;
-		case SPEED_1000:
-			if (tp->mii.supports_gmii) {
-				bmcr = BMCR_SPEED1000 | BMCR_FULLDPLX;
-				tp->ups_info.speed_duplex = NWAY_1000M_FULL;
-				break;
-			}
-			fallthrough;
-		default:
-			ret = -EINVAL;
-			goto out;
+	if (speed & LINK_STATUS) {
+		if (!netif_carrier_ok(netdev)) {
+			tp->rtl_ops.enable(tp);
+			netif_stop_queue(netdev);
+			napi_disable(napi);
+			netif_carrier_on(netdev);
+			rtl_start_rx(tp);
+			rtl8152_set_rx_mode(netdev);
+			napi_enable(napi);
+			netif_wake_queue(netdev);
+			netif_info(tp, link, netdev, "carrier on\n");
+		} else if (netif_queue_stopped(netdev) &&
+			   skb_queue_len(&tp->tx_queue) < tp->tx_qlen) {
+			netif_wake_queue(netdev);
+		}
+	} else {
+		if (netif_carrier_ok(netdev)) {
+			netif_carrier_off(netdev);
+			tasklet_disable(&tp->tx_tl);
+			napi_disable(napi);
+			tp->rtl_ops.disable(tp);
+			napi_enable(napi);
+			tasklet_enable(&tp->tx_tl);
+			netif_info(tp, link, netdev, "carrier off\n");
 		}
+	}
+}
 
-		if (duplex == DUPLEX_FULL)
-			tp->mii.full_duplex = 1;
-		else
-			tp->mii.full_duplex = 0;
+static inline void __rtl_work_func(struct r8152 *tp)
+{
+	/* If the device is unplugged or !netif_running(), the workqueue
+	 * doesn't need to wake the device, and could return directly.
+	 */
+	if (test_bit(RTL8152_UNPLUG, &tp->flags) || !netif_running(tp->netdev))
+		return;
 
-		tp->mii.force_media = 1;
-	} else {
-		u16 orig, new1;
-		u32 support;
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
 
-		support = RTL_ADVERTISED_10_HALF | RTL_ADVERTISED_10_FULL |
-			  RTL_ADVERTISED_100_HALF | RTL_ADVERTISED_100_FULL;
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		goto out1;
 
-		if (tp->mii.supports_gmii) {
-			support |= RTL_ADVERTISED_1000_FULL;
+	if (!mutex_trylock(&tp->control)) {
+		if (tp->rtk_enable_diag)
+			goto link_chg_only;
 
-			if (tp->support_2500full)
-				support |= RTL_ADVERTISED_2500_FULL;
-		}
+		schedule_delayed_work(&tp->schedule, 0);
+		goto out1;
+	}
 
-		if (!(advertising & support))
-			return -EINVAL;
+	if (test_and_clear_bit(RTL8152_LINK_CHG, &tp->flags))
+		set_carrier(tp);
 
-		orig = r8152_mdio_read(tp, MII_ADVERTISE);
-		new1 = orig & ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
-				ADVERTISE_100HALF | ADVERTISE_100FULL);
-		if (advertising & RTL_ADVERTISED_10_HALF) {
-			new1 |= ADVERTISE_10HALF;
-			tp->ups_info.speed_duplex = NWAY_10M_HALF;
-		}
-		if (advertising & RTL_ADVERTISED_10_FULL) {
-			new1 |= ADVERTISE_10FULL;
-			tp->ups_info.speed_duplex = NWAY_10M_FULL;
-		}
+	if (test_bit(RTL8152_SET_RX_MODE, &tp->flags))
+		rtl8152_set_rx_mode(tp->netdev);
 
-		if (advertising & RTL_ADVERTISED_100_HALF) {
-			new1 |= ADVERTISE_100HALF;
-			tp->ups_info.speed_duplex = NWAY_100M_HALF;
-		}
-		if (advertising & RTL_ADVERTISED_100_FULL) {
-			new1 |= ADVERTISE_100FULL;
-			tp->ups_info.speed_duplex = NWAY_100M_FULL;
-		}
-
-		if (orig != new1) {
-			r8152_mdio_write(tp, MII_ADVERTISE, new1);
-			tp->mii.advertising = new1;
-		}
-
-		if (tp->mii.supports_gmii) {
-			orig = r8152_mdio_read(tp, MII_CTRL1000);
-			new1 = orig & ~(ADVERTISE_1000FULL |
-					ADVERTISE_1000HALF);
+	/* don't schedule tasket before linking */
+	if (test_and_clear_bit(SCHEDULE_TASKLET, &tp->flags) &&
+	    netif_carrier_ok(tp->netdev))
+		tasklet_schedule(&tp->tx_tl);
 
-			if (advertising & RTL_ADVERTISED_1000_FULL) {
-				new1 |= ADVERTISE_1000FULL;
-				tp->ups_info.speed_duplex = NWAY_1000M_FULL;
-			}
+	if (test_and_clear_bit(RX_EPROTO, &tp->flags) &&
+	    !list_empty(&tp->rx_done))
+		napi_schedule(&tp->napi);
 
-			if (orig != new1)
-				r8152_mdio_write(tp, MII_CTRL1000, new1);
-		}
+	mutex_unlock(&tp->control);
 
-		if (tp->support_2500full) {
-			orig = ocp_reg_read(tp, OCP_10GBT_CTRL);
-			new1 = orig & ~MDIO_AN_10GBT_CTRL_ADV2_5G;
+out1:
+	usb_autopm_put_interface(tp->intf);
 
-			if (advertising & RTL_ADVERTISED_2500_FULL) {
-				new1 |= MDIO_AN_10GBT_CTRL_ADV2_5G;
-				tp->ups_info.speed_duplex = NWAY_2500M_FULL;
-			}
+link_chg_only:
+	if (test_and_clear_bit(RTL8152_LINK_CHG, &tp->flags)) {
+		int lock;
 
-			if (orig != new1)
-				ocp_reg_write(tp, OCP_10GBT_CTRL, new1);
-		}
+		rtnl_lock();
+		lock = mutex_trylock(&tp->control);
+		set_carrier(tp);
+		if (lock)
+			mutex_unlock(&tp->control);
+		rtnl_unlock();
+		goto out1;
+	}
+}
 
-		bmcr = BMCR_ANENABLE | BMCR_ANRESTART;
+static inline void __rtl_hw_phy_work_func(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
 
-		tp->mii.force_media = 0;
-	}
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
 
-	if (test_and_clear_bit(PHY_RESET, &tp->flags))
-		bmcr |= BMCR_RESET;
+	mutex_lock(&tp->control);
 
-	r8152_mdio_write(tp, MII_BMCR, bmcr);
+	tp->rtl_ops.hw_phy_cfg(tp);
 
-	if (bmcr & BMCR_RESET) {
-		int i;
+	rtl8152_set_speed(tp, tp->autoneg, tp->speed, tp->duplex,
+			  tp->advertising);
 
-		for (i = 0; i < 50; i++) {
-			msleep(20);
-			if ((r8152_mdio_read(tp, MII_BMCR) & BMCR_RESET) == 0)
-				break;
-		}
-	}
+	mutex_unlock(&tp->control);
 
-out:
-	return ret;
+	usb_autopm_put_interface(tp->intf);
 }
 
-static void rtl8152_up(struct r8152 *tp)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+
+static void rtl_work_func_t(void *data)
 {
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return;
+	struct r8152 *tp = (struct r8152 *)data;
 
-	r8152_aldps_en(tp, false);
-	r8152b_exit_oob(tp);
-	r8152_aldps_en(tp, true);
+	__rtl_work_func(tp);
 }
 
-static void rtl8152_down(struct r8152 *tp)
+static void rtl_hw_phy_work_func_t(void *data)
 {
-	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
-		rtl_drop_queued_tx(tp);
-		return;
-	}
+	struct r8152 *tp = (struct r8152 *)data;
 
-	r8152_power_cut_en(tp, false);
-	r8152_aldps_en(tp, false);
-	r8152b_enter_oob(tp);
-	r8152_aldps_en(tp, true);
+	__rtl_hw_phy_work_func(tp);
 }
 
-static void rtl8153_up(struct r8152 *tp)
+#else
+
+static void rtl_work_func_t(struct work_struct *work)
 {
-	u32 ocp_data;
+	struct r8152 *tp = container_of(work, struct r8152, schedule.work);
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return;
+	__rtl_work_func(tp);
+}
 
-	r8153_u1u2en(tp, false);
-	r8153_u2p3en(tp, false);
-	r8153_aldps_en(tp, false);
-	r8153_first_init(tp);
+static void rtl_hw_phy_work_func_t(struct work_struct *work)
+{
+	struct r8152 *tp = container_of(work, struct r8152, hw_phy_work.work);
 
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6);
-	ocp_data |= LANWAKE_CLR_EN;
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6, ocp_data);
+	__rtl_hw_phy_work_func(tp);
+}
 
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG);
-	ocp_data &= ~LANWAKE_PIN;
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG, ocp_data);
+#endif
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SSPHYLINK1);
-	ocp_data &= ~DELAY_PHY_PWR_CHG;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_SSPHYLINK1, ocp_data);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP)
+static int rtl_notifier(struct notifier_block *nb, unsigned long action,
+			void *data)
+{
+	struct r8152 *tp = container_of(nb, struct r8152, pm_notifier);
 
-	r8153_aldps_en(tp, true);
+	switch (action) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		if (usb_autopm_get_interface(tp->intf) < 0)
+			netif_info(tp, drv, tp->netdev, "Auto-wake fail\n");
+		break;
 
-	switch (tp->version) {
-	case RTL_VER_03:
-	case RTL_VER_04:
+	case PM_POST_HIBERNATION:
+	case PM_POST_SUSPEND:
+		usb_autopm_put_interface(tp->intf);
 		break;
-	case RTL_VER_05:
-	case RTL_VER_06:
+
+	case PM_POST_RESTORE:
+	case PM_RESTORE_PREPARE:
 	default:
-		r8153_u2p3en(tp, true);
 		break;
 	}
 
-	r8153_u1u2en(tp, true);
+	return NOTIFY_DONE;
 }
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP) */
 
-static void rtl8153_down(struct r8152 *tp)
+#if defined(RTL8152_S5_WOL) && defined(CONFIG_PM)
+static int rtl_s5_wol(struct r8152 *tp)
 {
+	struct usb_device *udev = tp->udev;
 	u32 ocp_data;
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
-		rtl_drop_queued_tx(tp);
-		return;
+	if (!tp->saved_wolopts)
+		return -EOPNOTSUPP;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+		return -EOPNOTSUPP;
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+		goto remote_wake;
+	default:
+		break;
 	}
 
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6);
-	ocp_data &= ~LANWAKE_CLR_EN;
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6, ocp_data);
+	if (!(ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5) & LAN_WAKE_EN))
+		return -EOPNOTSUPP;
 
-	r8153_u1u2en(tp, false);
-	r8153_u2p3en(tp, false);
-	r8153_power_cut_en(tp, false);
-	r8153_aldps_en(tp, false);
-	r8153_enter_oob(tp);
-	r8153_aldps_en(tp, true);
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_INDICATE_FALG);
+	ocp_data |= BIT(1);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_INDICATE_FALG, ocp_data);
+
+remote_wake:
+	/* usb_enable_remote_wakeup */
+	if (udev->speed < USB_SPEED_SUPER)
+		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, USB_RECIP_DEVICE,
+				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
+				USB_CTRL_SET_TIMEOUT);
+	else
+		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
+				USB_INTRF_FUNC_SUSPEND,
+				USB_INTRF_FUNC_SUSPEND_RW |
+				USB_INTRF_FUNC_SUSPEND_LP,
+				NULL, 0, USB_CTRL_SET_TIMEOUT);
 }
 
-static void rtl8153b_up(struct r8152 *tp)
+static
+int rtl_reboot_notifier(struct notifier_block *nb, unsigned long action,
+			void *data)
 {
-	u32 ocp_data;
+	struct r8152 *tp = container_of(nb, struct r8152, reboot_notifier);
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return;
+	switch (action) {
+	case SYS_POWER_OFF:
+		if (test_and_clear_bit(WORK_ENABLE, &tp->flags)) {
+			int ret;
 
-	r8153b_u1u2en(tp, false);
-	r8153_u2p3en(tp, false);
-	r8153_aldps_en(tp, false);
+			if (usb_autopm_get_interface(tp->intf) < 0)
+				break;
 
-	r8153_first_init(tp);
-	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_B);
+			mutex_lock(&tp->control);
+			tp->rtl_ops.down(tp);
+			ret = rtl_s5_wol(tp);
+			if (ret < 0)
+				netif_info(tp, drv, tp->netdev,
+					   "S5 WOL is not enabled, %d\n", ret);
+			else
+				netif_info(tp, drv, tp->netdev, "Enable S5 WOL\n");
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
-	ocp_data &= ~PLA_MCU_SPDWN_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+			mutex_unlock(&tp->control);
+			usb_autopm_put_interface(tp->intf);
+		}
+		break;
 
-	r8153_aldps_en(tp, true);
+	case SYS_RESTART:
+	default:
+		break;
+	}
 
-	if (tp->udev->speed >= USB_SPEED_SUPER)
-		r8153b_u1u2en(tp, true);
+	return NOTIFY_DONE;
 }
+#endif /* defined(RTL8152_S5_WOL) && defined(CONFIG_PM) */
 
-static void rtl8153b_down(struct r8152 *tp)
+static int rtk_disable_diag(struct r8152 *tp)
 {
-	u32 ocp_data;
+	tp->rtk_enable_diag--;
+	rtl_reset_ocp_base(tp);
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
-		rtl_drop_queued_tx(tp);
-		return;
-	}
+	if (tp->support_2500full)
+		r8156_mdio_force_mode(tp);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
-	ocp_data |= PLA_MCU_SPDWN_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+	netif_info(tp, drv, tp->netdev, "disable rtk diag %d\n",
+		   tp->rtk_enable_diag);
+	mutex_unlock(&tp->control);
+	if (test_bit(WORK_ENABLE, &tp->flags))
+		schedule_delayed_work(&tp->schedule, 0);
+	usb_autopm_put_interface(tp->intf);
 
-	r8153b_u1u2en(tp, false);
-	r8153_u2p3en(tp, false);
-	r8153b_power_cut_en(tp, false);
-	r8153_aldps_en(tp, false);
-	r8153_enter_oob(tp);
-	r8153_aldps_en(tp, true);
+	return 0;
 }
 
-static void rtl8153c_change_mtu(struct r8152 *tp)
+static int rtl8152_open(struct net_device *netdev)
 {
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, mtu_to_size(tp->netdev->mtu));
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, 10 * 1024 / 64);
+	struct r8152 *tp = netdev_priv(netdev);
+	int res = 0;
 
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
 
-	/* Adjust the tx fifo free credit full threshold, otherwise
-	 * the fifo would be too small to send a jumbo frame packet.
-	 */
-	if (tp->netdev->mtu < 8000)
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL, 2048 / 8);
-	else
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL, 900 / 8);
-}
+	if (work_busy(&tp->hw_phy_work.work) & WORK_BUSY_PENDING) {
+		cancel_delayed_work_sync(&tp->hw_phy_work);
+		__rtl_hw_phy_work_func(tp);
+	}
 
-static void rtl8153c_up(struct r8152 *tp)
-{
-	u32 ocp_data;
+	res = alloc_all_mem(tp);
+	if (res)
+		goto out;
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return;
+	res = usb_autopm_get_interface(tp->intf);
+	if (res < 0)
+		goto out_free;
 
-	r8153b_u1u2en(tp, false);
-	r8153_u2p3en(tp, false);
-	r8153_aldps_en(tp, false);
+	mutex_lock(&tp->control);
 
-	rxdy_gated_en(tp, true);
-	r8153_teredo_off(tp);
+	tp->rtl_ops.up(tp);
 
-	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
-	ocp_data &= ~RCR_ACPT_ALL;
-	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+	netif_carrier_off(netdev);
+	netif_start_queue(netdev);
+	smp_mb__before_atomic();
+	set_bit(WORK_ENABLE, &tp->flags);
+	smp_mb__after_atomic();
 
-	rtl8152_nic_reset(tp);
-	rtl_reset_bmu(tp);
-
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
-	ocp_data &= ~NOW_IS_OOB;
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
-	ocp_data &= ~MCU_BORW_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+	if (test_and_clear_bit(RECOVER_SPEED, &tp->flags))
+		rtl8152_set_speed(tp, tp->autoneg, tp->speed, tp->duplex,
+				  tp->advertising);
 
-	wait_oob_link_list_ready(tp);
+	res = usb_submit_urb(tp->intr_urb, GFP_KERNEL);
+	if (res) {
+		if (res == -ENODEV)
+			netif_device_detach(tp->netdev);
+		netif_warn(tp, ifup, netdev, "intr_urb submit failed: %d\n",
+			   res);
+		goto out_unlock;
+	}
+	napi_enable(&tp->napi);
+	tasklet_enable(&tp->tx_tl);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
-	ocp_data |= RE_INIT_LL;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+	mutex_unlock(&tp->control);
 
-	wait_oob_link_list_ready(tp);
+	usb_autopm_put_interface(tp->intf);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP)
+	tp->pm_notifier.notifier_call = rtl_notifier;
+	register_pm_notifier(&tp->pm_notifier);
+#endif
+#if defined(RTL8152_S5_WOL) && defined(CONFIG_PM)
+	tp->reboot_notifier.notifier_call = rtl_reboot_notifier;
+	register_reboot_notifier(&tp->reboot_notifier);
+#endif /* defined(RTL8152_S5_WOL) && defined(CONFIG_PM) */
+	return 0;
 
-	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+out_unlock:
+	mutex_unlock(&tp->control);
+	usb_autopm_put_interface(tp->intf);
+out_free:
+	free_all_mem(tp);
+out:
+	return res;
+}
 
-	rtl8153c_change_mtu(tp);
+static int rtl8152_close(struct net_device *netdev)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	int res = 0;
 
-	rtl8152_nic_reset(tp);
+#if defined(RTL8152_S5_WOL) && defined(CONFIG_PM)
+	unregister_reboot_notifier(&tp->reboot_notifier);
+#endif /* defined(RTL8152_S5_WOL) && defined(CONFIG_PM) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP)
+	unregister_pm_notifier(&tp->pm_notifier);
+#endif
+	tasklet_disable(&tp->tx_tl);
+	smp_mb__before_atomic();
+	clear_bit(WORK_ENABLE, &tp->flags);
+	smp_mb__after_atomic();
+	usb_kill_urb(tp->intr_urb);
+	cancel_delayed_work_sync(&tp->schedule);
+	napi_disable(&tp->napi);
+	netif_stop_queue(netdev);
 
-	/* rx share fifo credit full threshold */
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, 0x02);
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, 0x08);
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_NORMAL);
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_NORMAL);
+	if (unlikely(tp->rtk_enable_diag)) {
+		netif_err(tp, drv, tp->netdev, "rtk diag isn't disabled\n");
+		rtk_disable_diag(tp);
+	}
 
-	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_B);
+	res = usb_autopm_get_interface(tp->intf);
+	if (res < 0 || test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		rtl_stop_rx(tp);
+	} else {
+		mutex_lock(&tp->control);
 
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+		tp->rtl_ops.down(tp);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);
-	ocp_data |= BIT(8);
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);
+#if defined(RTL8152_S5_WOL) && defined(CONFIG_PM)
+		if (rtl_s5_wol(tp) < 0)
+			netif_info(tp, drv, tp->netdev,
+				   "S5 WOL is not enabled\n");
+		else
+			netif_info(tp, drv, tp->netdev, "Enable S5 WOL\n");
+#endif /* defined(RTL8152_S5_WOL) && defined(CONFIG_PM) */
 
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+		if (tp->version == RTL_VER_01)
+			rtl8152_set_speed(tp, AUTONEG_ENABLE, 0, 0, 3);
+		else
+			rtl_speed_down(tp);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
-	ocp_data &= ~PLA_MCU_SPDWN_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+		mutex_unlock(&tp->control);
+	}
 
-	r8153_aldps_en(tp, true);
-	r8153b_u1u2en(tp, true);
-}
+	if (!res)
+		usb_autopm_put_interface(tp->intf);
 
-static inline u32 fc_pause_on_auto(struct r8152 *tp)
-{
-	return (ALIGN(mtu_to_size(tp->netdev->mtu), 1024) + 6 * 1024);
-}
+	free_all_mem(tp);
 
-static inline u32 fc_pause_off_auto(struct r8152 *tp)
-{
-	return (ALIGN(mtu_to_size(tp->netdev->mtu), 1024) + 14 * 1024);
+	return res;
 }
 
-static void r8156_fc_parameter(struct r8152 *tp)
+static void rtl_tally_reset(struct r8152 *tp)
 {
-	u32 pause_on = tp->fc_pause_on ? tp->fc_pause_on : fc_pause_on_auto(tp);
-	u32 pause_off = tp->fc_pause_off ? tp->fc_pause_off : fc_pause_off_auto(tp);
+	u32 ocp_data;
 
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, pause_on / 16);
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, pause_off / 16);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY);
+	ocp_data |= TALLY_RESET;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY, ocp_data);
 }
 
-static void rtl8156_change_mtu(struct r8152 *tp)
+static void rtl_disable_spi(struct r8152 *tp)
 {
-	u32 rx_max_size = mtu_to_size(tp->netdev->mtu);
-
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, rx_max_size);
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_JUMBO);
-	r8156_fc_parameter(tp);
+	u32 ocp_data;
 
-	/* TX share fifo free credit full threshold */
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL,
-		       ALIGN(rx_max_size + sizeof(struct tx_desc), 1024) / 16);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5);
+	ocp_data &= ~SPI_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG5, ocp_data);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xcbf0);
+	ocp_data |= BIT(1);
+	ocp_write_word(tp, MCU_TYPE_USB, 0xcbf0, ocp_data);
 }
 
-static void rtl8156_up(struct r8152 *tp)
+static void r8152b_init(struct r8152 *tp)
 {
 	u32 ocp_data;
+	u16 data;
 
 	if (test_bit(RTL8152_UNPLUG, &tp->flags))
 		return;
 
-	r8153b_u1u2en(tp, false);
-	r8153_u2p3en(tp, false);
-	r8153_aldps_en(tp, false);
-
-	rxdy_gated_en(tp, true);
-	r8153_teredo_off(tp);
-
-	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
-	ocp_data &= ~RCR_ACPT_ALL;
-	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
-
-	rtl8152_nic_reset(tp);
-	rtl_reset_bmu(tp);
-
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
-	ocp_data &= ~NOW_IS_OOB;
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
-	ocp_data &= ~MCU_BORW_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
-
-	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+#if 0
+	/* Clear EP3 Fifo before using interrupt transfer */
+	if (ocp_read_byte(tp, MCU_TYPE_USB, 0xb963) & 0x80) {
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xb963, 0x08);
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xb963, 0x40);
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xb963, 0x00);
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xb968, 0x00);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xb010, 0x00e0);
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xb963, 0x04);
+	}
+#endif
 
-	rtl8156_change_mtu(tp);
+	data = r8153_phy_status(tp, 0);
 
-	switch (tp->version) {
-	case RTL_TEST_01:
-	case RTL_VER_10:
-	case RTL_VER_11:
-		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_BMU_CONFIG);
-		ocp_data |= ACT_ODMA;
-		ocp_write_word(tp, MCU_TYPE_USB, USB_BMU_CONFIG, ocp_data);
-		break;
-	default:
-		break;
+	data = r8152_mdio_read(tp, MII_BMCR);
+	if (data & BMCR_PDOWN) {
+		data &= ~BMCR_PDOWN;
+		r8152_mdio_write(tp, MII_BMCR, data);
 	}
 
-	/* share FIFO settings */
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL);
-	ocp_data &= ~RXFIFO_FULL_MASK;
-	ocp_data |= 0x08;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, ocp_data);
+	r8152_aldps_en(tp, false);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
-	ocp_data &= ~PLA_MCU_SPDWN_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+	if (tp->version == RTL_VER_01) {
+		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE);
+		ocp_data &= ~LED_MODE_MASK;
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE, ocp_data);
+	}
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION);
-	ocp_data &= ~(RG_PWRDN_EN | ALL_SPEED_OFF);
-	ocp_write_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION, ocp_data);
+	r8152_power_cut_en(tp, false);
+	rtl_runtime_suspend_enable(tp, false);
 
-	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, 0x00600400);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
+	ocp_data |= TX_10M_IDLE_EN | PFM_PWM_SWITCH;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL);
+	ocp_data &= ~MCU_CLK_RATIO_MASK;
+	ocp_data |= MCU_CLK_RATIO | D3_CLK_GATED_EN;
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL, ocp_data);
+	ocp_data = GPHY_STS_MSK | SPEED_DOWN_MSK |
+		   SPDWN_RXDV_MSK | SPDWN_LINKCHG_MSK;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_GPHY_INTR_IMR, ocp_data);
 
-	if (tp->saved_wolopts != __rtl_get_wol(tp)) {
-		netif_warn(tp, ifup, tp->netdev, "wol setting is changed\n");
-		__rtl_set_wol(tp, tp->saved_wolopts);
-	}
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_TIMER);
+	ocp_data |= BIT(15);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_TIMER, ocp_data);
+	ocp_write_word(tp, MCU_TYPE_USB, 0xcbfc, 0x03e8);
+	ocp_data &= ~BIT(15);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_TIMER, ocp_data);
 
-	r8153_aldps_en(tp, true);
-	r8153_u2p3en(tp, true);
+	rtl_tally_reset(tp);
 
-	if (tp->udev->speed >= USB_SPEED_SUPER)
-		r8153b_u1u2en(tp, true);
+	/* enable rx aggregation */
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
+	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
 }
 
-static void rtl8156_down(struct r8152 *tp)
+static void r8153_init(struct r8152 *tp)
 {
 	u32 ocp_data;
+	u16 data;
+	int i;
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
-		rtl_drop_queued_tx(tp);
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
 		return;
-	}
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
-	ocp_data |= PLA_MCU_SPDWN_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+	r8153_u1u2en(tp, false);
 
-	r8153b_u1u2en(tp, false);
-	r8153_u2p3en(tp, false);
-	r8153b_power_cut_en(tp, false);
-	r8153_aldps_en(tp, false);
+	for (i = 0; i < 500; i++) {
+		if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &
+		    AUTOLOAD_DONE)
+			break;
 
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
-	ocp_data &= ~NOW_IS_OOB;
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+		msleep(20);
+		if (test_bit(RTL8152_UNPLUG, &tp->flags))
+			break;
+	}
 
-	/* RX FIFO settings for OOB */
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, 64 / 16);
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, 1024 / 16);
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, 4096 / 16);
+	data = r8153_phy_status(tp, 0);
 
-	rtl_disable(tp);
-	rtl_reset_bmu(tp);
+	if (tp->version == RTL_VER_03 || tp->version == RTL_VER_04 ||
+	    tp->version == RTL_VER_05)
+		ocp_reg_write(tp, OCP_ADC_CFG, CKADSEL_L | ADC_EN | EN_EMI_L);
 
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, 1522);
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_DEFAULT);
+	data = r8152_mdio_read(tp, MII_BMCR);
+	if (data & BMCR_PDOWN) {
+		data &= ~BMCR_PDOWN;
+		r8152_mdio_write(tp, MII_BMCR, data);
+	}
 
-	/* Clear teredo wake event. bit[15:8] is the teredo wakeup
-	 * type. Set it to zero. bits[7:0] are the W1C bits about
-	 * the events. Set them to all 1 to clear them.
-	 */
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_WAKE_BASE, 0x00ff);
+	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
 
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
-	ocp_data |= NOW_IS_OOB;
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+	r8153_u2p3en(tp, false);
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
-	ocp_data |= MCU_BORW_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+	if (tp->version == RTL_VER_04) {
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2);
+		ocp_data &= ~pwd_dn_scale_mask;
+		ocp_data |= pwd_dn_scale(96);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2, ocp_data);
 
-	rtl_rx_vlan_en(tp, true);
-	rxdy_gated_en(tp, false);
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_USB2PHY);
+		ocp_data |= USB2PHY_L1 | USB2PHY_SUSPEND;
+		ocp_write_byte(tp, MCU_TYPE_USB, USB_USB2PHY, ocp_data);
+	} else if (tp->version == RTL_VER_05) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_DMY_REG0);
+		ocp_data &= ~ECM_ALDPS;
+		ocp_write_byte(tp, MCU_TYPE_PLA, PLA_DMY_REG0, ocp_data);
 
-	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
-	ocp_data |= RCR_APM | RCR_AM | RCR_AB;
-	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1);
+		if (ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE) == 0)
+			ocp_data &= ~DYNAMIC_BURST;
+		else
+			ocp_data |= DYNAMIC_BURST;
+		ocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1, ocp_data);
+	} else if (tp->version == RTL_VER_06) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1);
+		if (ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE) == 0)
+			ocp_data &= ~DYNAMIC_BURST;
+		else
+			ocp_data |= DYNAMIC_BURST;
+		ocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1, ocp_data);
 
-	r8153_aldps_en(tp, true);
-}
+		r8153_queue_wake(tp, false);
 
-static bool rtl8152_in_nway(struct r8152 *tp)
-{
-	u16 nway_state;
+		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);
+		if (rtl8152_get_speed(tp) & LINK_STATUS)
+			ocp_data |= CUR_LINK_OK;
+		else
+			ocp_data &= ~CUR_LINK_OK;
 
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, 0x2000);
-	tp->ocp_base = 0x2000;
-	ocp_write_byte(tp, MCU_TYPE_PLA, 0xb014, 0x4c);		/* phy state */
-	nway_state = ocp_read_word(tp, MCU_TYPE_PLA, 0xb01a);
+		/* r8153_queue_wake() has set this bit */
+		/* ocp_data &= ~BIT(8); */
 
-	/* bit 15: TXDIS_STATE, bit 14: ABD_STATE */
-	if (nway_state & 0xc000)
-		return false;
-	else
-		return true;
-}
+		ocp_data |= POLL_LINK_CHG;
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);
+	}
 
-static bool rtl8153_in_nway(struct r8152 *tp)
-{
-	u16 phy_state = ocp_reg_read(tp, OCP_PHY_STATE) & 0xff;
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY2);
+	ocp_data |= EP4_FULL_FC;
+	ocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY2, ocp_data);
 
-	if (phy_state == TXDIS_STATE || phy_state == ABD_STATE)
-		return false;
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_WDT11_CTRL);
+	ocp_data &= ~TIMER11_EN;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_WDT11_CTRL, ocp_data);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE);
+	ocp_data &= ~LED_MODE_MASK;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE, ocp_data);
+
+	ocp_data = FIFO_EMPTY_1FB | ROK_EXIT_LPM;
+	if (tp->version == RTL_VER_04 && tp->udev->speed < USB_SPEED_SUPER)
+		ocp_data |= LPM_TIMER_500MS;
 	else
-		return true;
-}
+		ocp_data |= LPM_TIMER_500US;
+	ocp_write_byte(tp, MCU_TYPE_USB, USB_LPM_CTRL, ocp_data);
 
-static void r8156_mdio_force_mode(struct r8152 *tp)
-{
-	u16 data;
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_AFE_CTRL2);
+	ocp_data &= ~SEN_VAL_MASK;
+	ocp_data |= SEN_VAL_NORMAL | SEL_RXIDLE;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_AFE_CTRL2, ocp_data);
 
-	/* Select force mode through 0xa5b4 bit 15
-	 * 0: MDIO force mode
-	 * 1: MMD force mode
-	 */
-	data = ocp_reg_read(tp, 0xa5b4);
-	if (data & BIT(15)) {
-		data &= ~BIT(15);
-		ocp_reg_write(tp, 0xa5b4, data);
-	}
-}
+	ocp_write_word(tp, MCU_TYPE_USB, USB_CONNECT_TIMER, 0x0001);
 
-static void set_carrier(struct r8152 *tp)
-{
-	struct net_device *netdev = tp->netdev;
-	struct napi_struct *napi = &tp->napi;
-	u16 speed;
+	r8153_power_cut_en(tp, false);
+	rtl_runtime_suspend_enable(tp, false);
+	r8153_mac_clk_speed_down(tp, false);
+	r8153_u1u2en(tp, true);
+	usb_enable_lpm(tp->udev);
 
-	speed = rtl8152_get_speed(tp);
+	r8153_lanwake_clr_en(tp, true);
 
-	if (speed & LINK_STATUS) {
-		if (!netif_carrier_ok(netdev)) {
-			tp->rtl_ops.enable(tp);
-			netif_stop_queue(netdev);
-			napi_disable(napi);
-			netif_carrier_on(netdev);
-			rtl_start_rx(tp);
-			clear_bit(RTL8152_SET_RX_MODE, &tp->flags);
-			_rtl8152_set_rx_mode(netdev);
-			napi_enable(napi);
-			netif_wake_queue(netdev);
-			netif_info(tp, link, netdev, "carrier on\n");
-		} else if (netif_queue_stopped(netdev) &&
-			   skb_queue_len(&tp->tx_queue) < tp->tx_qlen) {
-			netif_wake_queue(netdev);
-		}
-	} else {
-		if (netif_carrier_ok(netdev)) {
-			netif_carrier_off(netdev);
-			tasklet_disable(&tp->tx_tl);
-			napi_disable(napi);
-			tp->rtl_ops.disable(tp);
-			napi_enable(napi);
-			tasklet_enable(&tp->tx_tl);
-			netif_info(tp, link, netdev, "carrier off\n");
-		}
+	/* rx aggregation */
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
+	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
+
+	rtl_tally_reset(tp);
+
+	switch (tp->udev->speed) {
+	case USB_SPEED_SUPER:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+	case USB_SPEED_SUPER_PLUS:
+#endif
+		tp->coalesce = COALESCE_SUPER;
+		break;
+	case USB_SPEED_HIGH:
+		tp->coalesce = COALESCE_HIGH;
+		break;
+	default:
+		tp->coalesce = COALESCE_SLOW;
+		break;
 	}
 }
 
-static void rtl_work_func_t(struct work_struct *work)
+static void r8153b_init(struct r8152 *tp)
 {
-	struct r8152 *tp = container_of(work, struct r8152, schedule.work);
+	u32 ocp_data;
+	u16 data;
+	int i;
 
-	/* If the device is unplugged or !netif_running(), the workqueue
-	 * doesn't need to wake the device, and could return directly.
-	 */
-	if (test_bit(RTL8152_UNPLUG, &tp->flags) || !netif_running(tp->netdev))
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
 		return;
 
-	if (usb_autopm_get_interface(tp->intf) < 0)
-		return;
+	rtl_set_dbg_info_init(tp);
+	r8153b_u1u2en(tp, false);
+	rtl_disable_spi(tp);
 
-	if (!test_bit(WORK_ENABLE, &tp->flags))
-		goto out1;
+	for (i = 0; i < 500; i++) {
+		if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &
+		    AUTOLOAD_DONE)
+			break;
 
-	if (!mutex_trylock(&tp->control)) {
-		schedule_delayed_work(&tp->schedule, 0);
-		goto out1;
+		msleep(20);
+		if (test_bit(RTL8152_UNPLUG, &tp->flags))
+			break;
 	}
 
-	if (test_and_clear_bit(RTL8152_LINK_CHG, &tp->flags))
-		set_carrier(tp);
+	data = r8153_phy_status(tp, 0);
 
-	if (test_and_clear_bit(RTL8152_SET_RX_MODE, &tp->flags))
-		_rtl8152_set_rx_mode(tp->netdev);
+	data = r8152_mdio_read(tp, MII_BMCR);
+	if (data & BMCR_PDOWN) {
+		data &= ~BMCR_PDOWN;
+		r8152_mdio_write(tp, MII_BMCR, data);
+	}
 
-	/* don't schedule tasket before linking */
-	if (test_and_clear_bit(SCHEDULE_TASKLET, &tp->flags) &&
-	    netif_carrier_ok(tp->netdev))
-		tasklet_schedule(&tp->tx_tl);
+	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
 
-	if (test_and_clear_bit(RX_EPROTO, &tp->flags) &&
-	    !list_empty(&tp->rx_done))
-		napi_schedule(&tp->napi);
+	r8153_u2p3en(tp, false);
 
-	mutex_unlock(&tp->control);
+	/* MSC timer = 0xfff * 8ms = 32760 ms */
+	ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
 
-out1:
-	usb_autopm_put_interface(tp->intf);
-}
+	r8153b_power_cut_en(tp, false);
+	r8153b_ups_en(tp, false);
+	r8153_queue_wake(tp, false);
+	rtl_runtime_suspend_enable(tp, false);
 
-static void rtl_hw_phy_work_func_t(struct work_struct *work)
-{
-	struct r8152 *tp = container_of(work, struct r8152, hw_phy_work.work);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);
+	if (rtl8152_get_speed(tp) & LINK_STATUS)
+		ocp_data |= CUR_LINK_OK;
+	else
+		ocp_data &= ~CUR_LINK_OK;
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return;
+	/* r8153_queue_wake() has set this bit */
+	/* ocp_data &= ~BIT(8); */
 
-	if (usb_autopm_get_interface(tp->intf) < 0)
-		return;
+	ocp_data |= POLL_LINK_CHG;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);
 
-	mutex_lock(&tp->control);
+	r8153_lanwake_clr_en(tp, true);
 
-	if (rtl8152_request_firmware(tp) == -ENODEV && tp->rtl_fw.retry) {
-		tp->rtl_fw.retry = false;
-		tp->rtl_fw.fw = NULL;
+	if (tp->udev->descriptor.idVendor == VENDOR_ID_LENOVO &&
+	    tp->udev->descriptor.idProduct == 0x3069)
+		ocp_write_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2, 0x0c8c);
 
-		/* Delay execution in case request_firmware() is not ready yet.
-		 */
-		queue_delayed_work(system_long_wq, &tp->hw_phy_work, HZ * 10);
-		goto ignore_once;
+//	if (tp->udev->speed >= USB_SPEED_SUPER)
+//		r8153b_u1u2en(tp, true);
+
+	usb_enable_lpm(tp->udev);
+
+	/* MAC clock speed down */
+	r8153_mac_clk_speed_down(tp, false);
+
+	r8153b_mcu_spdown_en(tp, false);
+
+	if (tp->version == RTL_VER_09) {
+		/* Disable Test IO for 32QFN */
+		if (ocp_read_byte(tp, MCU_TYPE_PLA, 0xdc00) & BIT(5)) {
+			ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
+			ocp_data |= TEST_IO_OFF;
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
+		}
 	}
 
-	tp->rtl_ops.hw_phy_cfg(tp);
+	set_bit(GREEN_ETHERNET, &tp->flags);
 
-	rtl8152_set_speed(tp, tp->autoneg, tp->speed, tp->duplex,
-			  tp->advertising);
+	/* rx aggregation */
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
+	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
 
-ignore_once:
-	mutex_unlock(&tp->control);
+	rtl_tally_reset(tp);
 
-	usb_autopm_put_interface(tp->intf);
+	tp->coalesce = 15000;	/* 15 us */
 }
 
-#ifdef CONFIG_PM_SLEEP
-static int rtl_notifier(struct notifier_block *nb, unsigned long action,
-			void *data)
+static void r8153c_init(struct r8152 *tp)
 {
-	struct r8152 *tp = container_of(nb, struct r8152, pm_notifier);
+	u32 ocp_data;
+	u16 data;
+	int i;
 
-	switch (action) {
-	case PM_HIBERNATION_PREPARE:
-	case PM_SUSPEND_PREPARE:
-		usb_autopm_get_interface(tp->intf);
-		break;
-
-	case PM_POST_HIBERNATION:
-	case PM_POST_SUSPEND:
-		usb_autopm_put_interface(tp->intf);
-		break;
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
 
-	case PM_POST_RESTORE:
-	case PM_RESTORE_PREPARE:
-	default:
-		break;
-	}
+	r8153b_u1u2en(tp, false);
 
-	return NOTIFY_DONE;
-}
-#endif
+	rtl_disable_spi(tp);
 
-static int rtl8152_open(struct net_device *netdev)
-{
-	struct r8152 *tp = netdev_priv(netdev);
-	int res = 0;
+	for (i = 0; i < 500; i++) {
+		if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &
+		    AUTOLOAD_DONE)
+			break;
 
-	if (work_busy(&tp->hw_phy_work.work) & WORK_BUSY_PENDING) {
-		cancel_delayed_work_sync(&tp->hw_phy_work);
-		rtl_hw_phy_work_func_t(&tp->hw_phy_work.work);
+		msleep(20);
+		if (test_bit(RTL8152_UNPLUG, &tp->flags))
+			return;
 	}
 
-	res = alloc_all_mem(tp);
-	if (res)
-		goto out;
+	data = r8153_phy_status(tp, 0);
 
-	res = usb_autopm_get_interface(tp->intf);
-	if (res < 0)
-		goto out_free;
+	data = r8152_mdio_read(tp, MII_BMCR);
+	if (data & BMCR_PDOWN) {
+		data &= ~BMCR_PDOWN;
+		r8152_mdio_write(tp, MII_BMCR, data);
+	}
 
-	mutex_lock(&tp->control);
+	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
 
-	tp->rtl_ops.up(tp);
+	r8153_u2p3en(tp, false);
 
-	netif_carrier_off(netdev);
-	netif_start_queue(netdev);
-	set_bit(WORK_ENABLE, &tp->flags);
+	/* MSC timer = 0xfff * 8ms = 32760 ms */
+	ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
 
-	res = usb_submit_urb(tp->intr_urb, GFP_KERNEL);
-	if (res) {
-		if (res == -ENODEV)
-			netif_device_detach(tp->netdev);
-		netif_warn(tp, ifup, netdev, "intr_urb submit failed: %d\n",
-			   res);
-		goto out_unlock;
-	}
-	napi_enable(&tp->napi);
-	tasklet_enable(&tp->tx_tl);
+	r8153b_power_cut_en(tp, false);
+	r8153c_ups_en(tp, false);
+	r8153_queue_wake(tp, false);
+	rtl_runtime_suspend_enable(tp, false);
 
-	mutex_unlock(&tp->control);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);
+	if (rtl8152_get_speed(tp) & LINK_STATUS)
+		ocp_data |= CUR_LINK_OK;
+	else
+		ocp_data &= ~CUR_LINK_OK;
 
-	usb_autopm_put_interface(tp->intf);
-#ifdef CONFIG_PM_SLEEP
-	tp->pm_notifier.notifier_call = rtl_notifier;
-	register_pm_notifier(&tp->pm_notifier);
-#endif
-	return 0;
+	/* r8153_queue_wake() has set this bit */
+	/* ocp_data &= ~BIT(8); */
 
-out_unlock:
-	mutex_unlock(&tp->control);
-	usb_autopm_put_interface(tp->intf);
-out_free:
-	free_all_mem(tp);
-out:
-	return res;
-}
+	ocp_data |= POLL_LINK_CHG;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);
 
-static int rtl8152_close(struct net_device *netdev)
-{
-	struct r8152 *tp = netdev_priv(netdev);
-	int res = 0;
+	r8153b_u1u2en(tp, true);
 
-#ifdef CONFIG_PM_SLEEP
-	unregister_pm_notifier(&tp->pm_notifier);
-#endif
-	tasklet_disable(&tp->tx_tl);
-	clear_bit(WORK_ENABLE, &tp->flags);
-	usb_kill_urb(tp->intr_urb);
-	cancel_delayed_work_sync(&tp->schedule);
-	napi_disable(&tp->napi);
-	netif_stop_queue(netdev);
+	usb_enable_lpm(tp->udev);
 
-	res = usb_autopm_get_interface(tp->intf);
-	if (res < 0 || test_bit(RTL8152_UNPLUG, &tp->flags)) {
-		rtl_drop_queued_tx(tp);
-		rtl_stop_rx(tp);
-	} else {
-		mutex_lock(&tp->control);
+	/* MAC clock speed down */
+	r8153_mac_clk_speed_down(tp, true);
 
-		tp->rtl_ops.down(tp);
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);
+	ocp_data &= ~BIT(7);
+	ocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);
 
-		mutex_unlock(&tp->control);
-	}
+	set_bit(GREEN_ETHERNET, &tp->flags);
 
-	if (!res)
-		usb_autopm_put_interface(tp->intf);
+	/* rx aggregation */
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
+	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
 
-	free_all_mem(tp);
+	rtl_tally_reset(tp);
 
-	return res;
+	tp->coalesce = 15000;	/* 15 us */
 }
 
-static void rtl_tally_reset(struct r8152 *tp)
+static void r8156_patch_code(struct r8152 *tp)
 {
-	u32 ocp_data;
+	if (tp->version == RTL_TEST_01) {
+		static u8 usb3_patch_t[] = {
+			0x01, 0xe0, 0x05, 0xc7,
+			0xf6, 0x65, 0x02, 0xc0,
+			0x00, 0xb8, 0x40, 0x03,
+			0x00, 0xd4, 0x00, 0x00 };
+
+		rtl_clear_bp(tp, MCU_TYPE_USB);
+
+		generic_ocp_write(tp, 0xe600, 0xff, sizeof(usb3_patch_t),
+				  usb3_patch_t, MCU_TYPE_USB);
+
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x033e);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x0000);
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x0001);
+	} else if (tp->version == RTL_VER_11) {
+		u32 ocp_data;
+		static u8 usb_patch3_b[] = {
+			0x10, 0xe0, 0x12, 0xe0,
+			0x33, 0xe0, 0x7d, 0xe0,
+			0x92, 0xe0, 0xae, 0xe0,
+			0xce, 0xe0, 0x23, 0xe1,
+			0x3f, 0xe1, 0x58, 0xe1,
+			0x84, 0xe1, 0xca, 0xe1,
+			0xd9, 0xe1, 0xeb, 0xe1,
+			0x02, 0xe2, 0xe0, 0xe2,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xf0, 0x4b, 0x1c, 0xc6,
+			0xc0, 0x61, 0x04, 0x11,
+			0x15, 0xf1, 0x19, 0xc6,
+			0xc0, 0x61, 0x9c, 0x20,
+			0x9c, 0x24, 0x09, 0x11,
+			0x0f, 0xf1, 0x14, 0xc6,
+			0x01, 0x19, 0xc0, 0x89,
+			0x13, 0xc1, 0x13, 0xc6,
+			0x24, 0x9e, 0x00, 0x1e,
+			0x26, 0x8e, 0x26, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x22, 0x76, 0x08, 0xc1,
+			0x22, 0x9e, 0x07, 0xc6,
+			0x02, 0xc1, 0x00, 0xb9,
+			0x9e, 0x09, 0x18, 0xb4,
+			0x4a, 0xb4, 0x90, 0xcc,
+			0x80, 0xd4, 0x08, 0xdc,
+			0x10, 0xe8, 0x28, 0xe8,
+			0x23, 0xc7, 0x21, 0xc2,
+			0xec, 0x9a, 0x00, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0xea, 0x71, 0x9f, 0x49,
+			0x14, 0xf0, 0x1a, 0xc2,
+			0xec, 0x9a, 0x00, 0x19,
+			0xe8, 0x99, 0x81, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x12, 0xc2, 0xec, 0x9a,
+			0x00, 0x19, 0x98, 0x20,
+			0xe8, 0x99, 0x82, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x06, 0xc3, 0x02, 0xc2,
+			0x00, 0xba, 0x3e, 0x29,
+			0x4c, 0xe8, 0x00, 0xdc,
+			0x00, 0xd4, 0x24, 0xe4,
+			0x04, 0xe4, 0x00, 0xb4,
+			0x04, 0xb4, 0x05, 0xb4,
+			0x06, 0xb4, 0x51, 0xc0,
+			0x00, 0x75, 0xd9, 0x49,
+			0x17, 0xf0, 0x30, 0xc0,
+			0xf6, 0xc5, 0x00, 0x1e,
+			0x68, 0x23, 0x08, 0x9e,
+			0x0c, 0x9d, 0x82, 0x1c,
+			0x0e, 0x8c, 0x0e, 0x74,
+			0xcf, 0x49, 0xfe, 0xf1,
+			0x25, 0xc0, 0xeb, 0xc5,
+			0x11, 0x1e, 0x68, 0x23,
+			0x08, 0x9e, 0x0c, 0x9d,
+			0x82, 0x1c, 0x0e, 0x8c,
+			0x0e, 0x74, 0xcf, 0x49,
+			0xfe, 0xf1, 0x06, 0xb0,
+			0x05, 0xb0, 0x04, 0xb0,
+			0x00, 0xb0, 0x80, 0xff,
+			0x32, 0xc0, 0x00, 0x75,
+			0xd8, 0x49, 0x0d, 0xf0,
+			0x11, 0xc0, 0xd6, 0xc5,
+			0x00, 0x1e, 0x08, 0x9e,
+			0x73, 0xc6, 0x0a, 0x9e,
+			0x0c, 0x9d, 0x8f, 0x1c,
+			0x0e, 0x8c, 0x0e, 0x74,
+			0xcf, 0x49, 0xfe, 0xf1,
+			0x04, 0xc0, 0x02, 0xc1,
+			0x00, 0xb9, 0x00, 0x1d,
+			0x20, 0xd4, 0x00, 0xdc,
+			0xc7, 0xef, 0x1b, 0xc0,
+			0x00, 0x75, 0xd8, 0x48,
+			0x00, 0x9d, 0xbe, 0xc7,
+			0x15, 0xc2, 0xec, 0x9a,
+			0x00, 0x19, 0xe8, 0x9a,
+			0x81, 0x19, 0xee, 0x89,
+			0xee, 0x71, 0x9f, 0x49,
+			0xfe, 0xf1, 0x2e, 0xc1,
+			0xec, 0x99, 0x81, 0x19,
+			0xee, 0x89, 0xee, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x04, 0xc3, 0x02, 0xc2,
+			0x00, 0xba, 0x3a, 0x27,
+			0xc0, 0xd4, 0x24, 0xe4,
+			0x34, 0xd3, 0xc0, 0x88,
+			0x1e, 0xc6, 0xc0, 0x70,
+			0x8f, 0x49, 0x0e, 0xf0,
+			0x8f, 0x48, 0x3f, 0xc6,
+			0xca, 0x98, 0x11, 0x18,
+			0xc8, 0x98, 0x16, 0xc0,
+			0xcc, 0x98, 0x8f, 0x18,
+			0xce, 0x88, 0xce, 0x70,
+			0x8f, 0x49, 0xfe, 0xf1,
+			0x0b, 0xe0, 0x33, 0xc6,
+			0x00, 0x18, 0xc8, 0x98,
+			0x0b, 0xc0, 0xcc, 0x98,
+			0x81, 0x18, 0xce, 0x88,
+			0xce, 0x70, 0x8f, 0x49,
+			0xfe, 0xf1, 0x02, 0xc0,
+			0x00, 0xb8, 0xbc, 0x21,
+			0x40, 0xd3, 0x20, 0xe4,
+			0x29, 0xc0, 0x01, 0x66,
+			0x05, 0x16, 0x3e, 0xf0,
+			0x25, 0x16, 0x40, 0xf0,
+			0x09, 0x16, 0x23, 0xf0,
+			0x16, 0xe0, 0x1a, 0xc2,
+			0x40, 0x76, 0xe1, 0x48,
+			0x40, 0x9e, 0x17, 0xc2,
+			0x00, 0x1e, 0x48, 0x9e,
+			0xef, 0xc6, 0x4c, 0x9e,
+			0x81, 0x1e, 0x4e, 0x8e,
+			0x4e, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0x0b, 0xc6,
+			0x4c, 0x9e, 0x81, 0x1e,
+			0x4e, 0x8e, 0x4e, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x90, 0x49, 0x02, 0xc7,
+			0x00, 0xbf, 0x64, 0x39,
+			0x24, 0xe4, 0x34, 0xd3,
+			0x00, 0xdc, 0x00, 0xdc,
+			0x24, 0xe4, 0x80, 0x02,
+			0x34, 0xd3, 0x80, 0xc3,
+			0xf9, 0xc2, 0x40, 0x76,
+			0xe1, 0x48, 0x40, 0x9e,
+			0xf6, 0xc2, 0x00, 0x1e,
+			0x48, 0x9e, 0xce, 0xc6,
+			0x4c, 0x9e, 0x81, 0x1e,
+			0x4e, 0x8e, 0x4e, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xea, 0xc6, 0x4c, 0x9e,
+			0x81, 0x1e, 0x4e, 0x8e,
+			0x4e, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xdf, 0xe7,
+			0x40, 0xd4, 0xff, 0xc2,
+			0x4c, 0x73, 0xbf, 0x49,
+			0xc5, 0xf0, 0xe3, 0xc6,
+			0xc0, 0x75, 0xd1, 0x49,
+			0xd6, 0xf0, 0xdc, 0xc0,
+			0xdc, 0xc6, 0x0c, 0x9e,
+			0x00, 0x1e, 0x08, 0x9e,
+			0xd9, 0xc6, 0x0a, 0x9e,
+			0x8f, 0x1e, 0x0e, 0x8e,
+			0x0e, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xc9, 0xe7,
+			0x1a, 0xc6, 0xc0, 0x67,
+			0xf0, 0x49, 0x13, 0xf0,
+			0xf0, 0x48, 0xc0, 0x8f,
+			0xc2, 0x77, 0x14, 0xc1,
+			0x14, 0xc6, 0x24, 0x9e,
+			0x22, 0x9f, 0x8c, 0x1e,
+			0x26, 0x8e, 0x26, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0xfb, 0x49, 0x05, 0xf0,
+			0x07, 0xc6, 0xc0, 0x61,
+			0x10, 0x48, 0xc0, 0x89,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x96, 0x52, 0x6c, 0xb4,
+			0x90, 0xcc, 0x08, 0xdc,
+			0x10, 0xe8, 0x16, 0xef,
+			0x18, 0xc0, 0x00, 0x72,
+			0xa8, 0x49, 0x0d, 0xf0,
+			0x11, 0xc0, 0x11, 0xc2,
+			0x00, 0x19, 0x08, 0x99,
+			0x0c, 0x9a, 0x0e, 0xc1,
+			0x0a, 0x99, 0x8f, 0x1b,
+			0x0e, 0x8b, 0x0e, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x04, 0xc0, 0x02, 0xc2,
+			0x00, 0xba, 0x64, 0x62,
+			0x02, 0xcf, 0x00, 0xdc,
+			0x24, 0xe4, 0x80, 0x02,
+			0x34, 0xd3, 0x2c, 0xc3,
+			0x60, 0x70, 0x80, 0x49,
+			0xfd, 0xf0, 0x27, 0xc3,
+			0x66, 0x60, 0x80, 0x48,
+			0x02, 0x48, 0x66, 0x88,
+			0x00, 0x48, 0x82, 0x48,
+			0x66, 0x88, 0x1b, 0xc3,
+			0x60, 0x70, 0x17, 0xc4,
+			0x88, 0x98, 0x14, 0xc0,
+			0x8c, 0x98, 0x83, 0x18,
+			0x8e, 0x88, 0x8e, 0x70,
+			0x8f, 0x49, 0xfe, 0xf1,
+			0x62, 0x70, 0x8a, 0x98,
+			0x0d, 0xc0, 0x8c, 0x98,
+			0x84, 0x18, 0x8e, 0x88,
+			0x8e, 0x70, 0x8f, 0x49,
+			0xfe, 0xf1, 0x08, 0xc3,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x68, 0x0f, 0x6c, 0xe9,
+			0x00, 0xdc, 0x50, 0xe8,
+			0x30, 0xc1, 0x36, 0xd3,
+			0x80, 0x10, 0x00, 0x00,
+			0x80, 0xd4, 0x26, 0xd8,
+			0x44, 0xc2, 0x4a, 0x41,
+			0x94, 0x20, 0x42, 0xc0,
+			0x16, 0x00, 0x00, 0x73,
+			0x40, 0xc4, 0x5c, 0x41,
+			0x8b, 0x41, 0x0b, 0x18,
+			0x38, 0xc6, 0xc0, 0x88,
+			0xc1, 0x99, 0x21, 0xe8,
+			0x35, 0xc0, 0x00, 0x73,
+			0xbd, 0x48, 0x0d, 0x18,
+			0x30, 0xc6, 0xc0, 0x88,
+			0xc1, 0x9b, 0x19, 0xe8,
+			0x2d, 0xc0, 0x02, 0x73,
+			0x35, 0x48, 0x0e, 0x18,
+			0x28, 0xc6, 0xc0, 0x88,
+			0xc1, 0x9b, 0x11, 0xe8,
+			0xdf, 0xc3, 0xdd, 0xc6,
+			0x01, 0x03, 0x1e, 0x40,
+			0xfe, 0xf1, 0x20, 0xc0,
+			0x02, 0x73, 0xb5, 0x48,
+			0x0e, 0x18, 0x1b, 0xc6,
+			0xc0, 0x88, 0xc1, 0x9b,
+			0x04, 0xe8, 0x02, 0xc6,
+			0x00, 0xbe, 0xb6, 0x10,
+			0x00, 0xb4, 0x01, 0xb4,
+			0x02, 0xb4, 0x03, 0xb4,
+			0x10, 0xc3, 0x0e, 0xc2,
+			0x61, 0x71, 0x40, 0x99,
+			0x60, 0x60, 0x0e, 0x48,
+			0x42, 0x98, 0x42, 0x70,
+			0x8e, 0x49, 0xfe, 0xf1,
+			0x03, 0xb0, 0x02, 0xb0,
+			0x01, 0xb0, 0x00, 0xb0,
+			0x80, 0xff, 0xc0, 0xd4,
+			0x8f, 0xcb, 0xaa, 0xc7,
+			0x1e, 0x00, 0x90, 0xc7,
+			0x1f, 0xfe, 0x0a, 0x10,
+			0x0c, 0xf0, 0x0b, 0x10,
+			0x0a, 0xf0, 0x0d, 0x10,
+			0x08, 0xf0, 0x0e, 0x10,
+			0x06, 0xf0, 0x24, 0x10,
+			0x04, 0xf0, 0x02, 0xc7,
+			0x00, 0xbf, 0x58, 0x11,
+			0x02, 0xc7, 0x00, 0xbf,
+			0x62, 0x11, 0xec, 0xc0,
+			0x02, 0x75, 0xd5, 0x48,
+			0x0e, 0x18, 0xe7, 0xc6,
+			0xc0, 0x88, 0xc1, 0x9d,
+			0xd0, 0xef, 0xe4, 0xc0,
+			0x02, 0x75, 0x55, 0x48,
+			0x0e, 0x18, 0xdf, 0xc6,
+			0xc0, 0x88, 0xc1, 0x9d,
+			0xc8, 0xef, 0x02, 0xc7,
+			0x00, 0xbf, 0x8e, 0x11,
+			0x16, 0xc0, 0xbb, 0x21,
+			0xb9, 0x25, 0x00, 0x71,
+			0x13, 0xc2, 0x4a, 0x41,
+			0x8b, 0x41, 0x24, 0x18,
+			0xd0, 0xc6, 0xc0, 0x88,
+			0xc1, 0x99, 0xb9, 0xef,
+			0x0a, 0xc0, 0x08, 0x71,
+			0x28, 0x18, 0xc9, 0xc6,
+			0xc0, 0x88, 0xc1, 0x99,
+			0xb2, 0xef, 0x02, 0xc0,
+			0x00, 0xb8, 0x3c, 0x11,
+			0xd8, 0xc7, 0x83, 0xff,
+			0x01, 0xb4, 0x02, 0xb4,
+			0x03, 0xb4, 0x04, 0xb4,
+			0x05, 0xb4, 0x44, 0xc4,
+			0x45, 0xc0, 0x48, 0xc1,
+			0x81, 0x1b, 0xce, 0xe8,
+			0x46, 0xc0, 0x44, 0xc2,
+			0x84, 0x1b, 0xca, 0xe8,
+			0x59, 0xc0, 0x00, 0x1b,
+			0xc7, 0xe8, 0x80, 0x65,
+			0xdb, 0x22, 0xdd, 0x26,
+			0x03, 0x15, 0x12, 0xf1,
+			0x4e, 0xc0, 0x37, 0xc1,
+			0x81, 0x1b, 0xbe, 0xe8,
+			0x4b, 0xc0, 0x32, 0xc1,
+			0x88, 0x1b, 0xba, 0xe8,
+			0x48, 0xc0, 0x49, 0xc1,
+			0x81, 0x1b, 0xb6, 0xe8,
+			0x04, 0x00, 0x46, 0xc1,
+			0x46, 0xc2, 0x8f, 0x1b,
+			0xb1, 0xe8, 0x25, 0xc0,
+			0x29, 0xc1, 0x2b, 0xc2,
+			0x8f, 0x1b, 0xac, 0xe8,
+			0x04, 0x00, 0x3e, 0xc1,
+			0x27, 0xc2, 0xa8, 0xe8,
+			0x04, 0x00, 0x2b, 0xc1,
+			0x2b, 0xc2, 0xa4, 0xe8,
+			0x04, 0x00, 0x29, 0xc1,
+			0x2b, 0xc2, 0xa0, 0xe8,
+			0x04, 0x00, 0x26, 0xc1,
+			0x26, 0xc2, 0x9c, 0xe8,
+			0x04, 0x00, 0x24, 0xc1,
+			0x21, 0xc2, 0x98, 0xe8,
+			0x04, 0x00, 0x21, 0xc1,
+			0x1f, 0xc2, 0x94, 0xe8,
+			0x04, 0x00, 0x1a, 0xc1,
+			0x1d, 0xc2, 0x90, 0xe8,
+			0x3d, 0xe0, 0x08, 0xdc,
+			0x3c, 0xe8, 0x14, 0xe8,
+			0x00, 0xf8, 0x00, 0x40,
+			0x00, 0x00, 0x01, 0x00,
+			0x9a, 0xd3, 0x04, 0xe0,
+			0x02, 0xe0, 0x0b, 0xe0,
+			0x0c, 0xe0, 0x25, 0xe0,
+			0xef, 0x1f, 0xa8, 0x8f,
+			0x02, 0xc7, 0x00, 0xbf,
+			0x76, 0x15, 0x66, 0x15,
+			0xa0, 0x49, 0x05, 0xf1,
+			0xa4, 0x49, 0x00, 0xbe,
+			0xca, 0x1a, 0x02, 0xc6,
+			0xe0, 0x1a, 0xce, 0x13,
+			0x80, 0xe0, 0xcb, 0xe0,
+			0xe0, 0xe8, 0x28, 0xdc,
+			0x13, 0x00, 0x08, 0x11,
+			0x42, 0x80, 0x0e, 0xe0,
+			0x06, 0xb4, 0x84, 0x76,
+			0x31, 0x40, 0x82, 0x71,
+			0x0c, 0xe8, 0x81, 0x24,
+			0x1f, 0x48, 0x84, 0x99,
+			0x08, 0xe8, 0x80, 0x49,
+			0x03, 0xf1, 0x80, 0x71,
+			0x80, 0xff, 0x85, 0x61,
+			0x96, 0x24, 0xfd, 0xf1,
+			0x06, 0xb0, 0x00, 0x11,
+			0x6c, 0x0f, 0x34, 0x1c,
+			0x28, 0xfc, 0x38, 0xfc,
+			0x0f, 0x00, 0xc8, 0x1a,
+			0xbe, 0x13, 0x04, 0x00,
+			0xe6, 0xc1, 0xea, 0xc2,
+			0x4f, 0xe8, 0x04, 0x00,
+			0xe3, 0xc1, 0xe3, 0xc2,
+			0x4b, 0xe8, 0x04, 0x00,
+			0xe8, 0xc1, 0xe0, 0xc2,
+			0x47, 0xe8, 0x04, 0x00,
+			0xc1, 0xc1, 0xdd, 0xc2,
+			0x43, 0xe8, 0x04, 0x00,
+			0xdb, 0xc1, 0xdb, 0xc2,
+			0x3f, 0xe8, 0x04, 0x00,
+			0xd9, 0xc1, 0xd9, 0xc2,
+			0x3b, 0xe8, 0x04, 0x00,
+			0xd7, 0xc1, 0xd7, 0xc2,
+			0x37, 0xe8, 0x04, 0x00,
+			0xd5, 0xc1, 0xaf, 0xc2,
+			0x33, 0xe8, 0x04, 0x00,
+			0xc9, 0xc1, 0xd5, 0xc2,
+			0x2f, 0xe8, 0x04, 0x00,
+			0xce, 0xc1, 0xce, 0xc2,
+			0x2b, 0xe8, 0x04, 0x00,
+			0xcc, 0xc1, 0xce, 0xc2,
+			0x27, 0xe8, 0x04, 0x00,
+			0xc9, 0xc1, 0xc5, 0xc2,
+			0x23, 0xe8, 0x04, 0x00,
+			0xa0, 0xc1, 0xa0, 0xc2,
+			0x1f, 0xe8, 0x04, 0x00,
+			0x9e, 0xc1, 0x9e, 0xc2,
+			0x1b, 0xe8, 0x04, 0x00,
+			0x9c, 0xc1, 0x83, 0x1b,
+			0x17, 0xe8, 0xbf, 0xc0,
+			0xc1, 0xc1, 0xc1, 0xc2,
+			0x8f, 0x1b, 0x12, 0xe8,
+			0x04, 0x00, 0xb8, 0xc1,
+			0x93, 0xc2, 0x8f, 0x1b,
+			0x0d, 0xe8, 0xb6, 0xc0,
+			0xb6, 0xc1, 0x81, 0x1b,
+			0x09, 0xe8, 0x05, 0xb0,
+			0x04, 0xb0, 0x03, 0xb0,
+			0x02, 0xb0, 0x01, 0xb0,
+			0x60, 0x70, 0xa9, 0xc3,
+			0x00, 0xbb, 0x84, 0x98,
+			0x80, 0x99, 0x82, 0x9a,
+			0x86, 0x8b, 0x86, 0x75,
+			0xdf, 0x49, 0xfe, 0xf1,
+			0x80, 0xff, 0x3b, 0xc0,
+			0x3b, 0xc1, 0x00, 0x70,
+			0x08, 0x40, 0x34, 0xf1,
+			0x38, 0xc0, 0x38, 0xc1,
+			0x0c, 0x99, 0x00, 0x19,
+			0x0e, 0x89, 0x0e, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x0a, 0x71, 0x9a, 0x48,
+			0x0a, 0x99, 0x8f, 0x19,
+			0x0e, 0x89, 0x0e, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x2a, 0xc0, 0x00, 0x71,
+			0x90, 0x48, 0x00, 0x99,
+			0x27, 0xc0, 0x00, 0x71,
+			0x13, 0x48, 0x00, 0x99,
+			0x20, 0xc0, 0x20, 0xc1,
+			0x0c, 0x99, 0x00, 0x19,
+			0x0e, 0x89, 0x0e, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x0a, 0x71, 0x9b, 0x48,
+			0x0a, 0x99, 0x8f, 0x19,
+			0x0e, 0x89, 0x0e, 0x71,
+			0x9f, 0x49, 0xfe, 0xf1,
+			0x12, 0xc0, 0x00, 0x71,
+			0x10, 0x48, 0x00, 0x99,
+			0x0f, 0xc0, 0x00, 0x71,
+			0x93, 0x48, 0x00, 0x99,
+			0x06, 0xc0, 0x00, 0x19,
+			0x00, 0x99, 0x09, 0xc7,
+			0x09, 0xc5, 0x00, 0xbd,
+			0x80, 0xd2, 0x86, 0x64,
+			0x00, 0xdc, 0x10, 0xe8,
+			0xb0, 0xd4, 0x06, 0xd4,
+			0xc0, 0xd4, 0x72, 0x14};
+		static u8 pla_patch11[] = {
+			0x05, 0xe0, 0x0a, 0xe0,
+			0x38, 0xe0, 0x3a, 0xe0,
+			0x57, 0xe0, 0x05, 0xc2,
+			0x40, 0x76, 0x02, 0xc4,
+			0x00, 0xbc, 0xd6, 0x0b,
+			0x1e, 0xfc, 0x29, 0xc5,
+			0xa0, 0x77, 0x2b, 0xc4,
+			0xa0, 0x9c, 0x26, 0xc5,
+			0xa0, 0x64, 0x01, 0x14,
+			0x0b, 0xf0, 0x02, 0x14,
+			0x09, 0xf0, 0x01, 0x07,
+			0xf1, 0x49, 0x06, 0xf0,
+			0x21, 0xc7, 0xe0, 0x8e,
+			0x11, 0x1e, 0xe0, 0x8e,
+			0x14, 0xe0, 0x17, 0xc5,
+			0x00, 0x1f, 0xa0, 0x9f,
+			0x13, 0xc5, 0xa0, 0x77,
+			0xa0, 0x74, 0x46, 0x48,
+			0x47, 0x48, 0xa0, 0x9c,
+			0x11, 0xc5, 0xa0, 0x74,
+			0x44, 0x48, 0x43, 0x48,
+			0xa0, 0x9c, 0x08, 0xc5,
+			0xa0, 0x9f, 0x02, 0xc5,
+			0x00, 0xbd, 0xea, 0x03,
+			0x02, 0xc5, 0x00, 0xbd,
+			0xf6, 0x03, 0x1c, 0xe8,
+			0xaa, 0xd3, 0x08, 0xb7,
+			0x6c, 0xe8, 0x20, 0xe8,
+			0x00, 0xa0, 0x38, 0xe4,
+			0x02, 0xc5, 0x00, 0xbd,
+			0xcc, 0x06, 0xd4, 0x49,
+			0x17, 0xf0, 0x19, 0xc5,
+			0xa4, 0x64, 0xc1, 0x49,
+			0x07, 0xf1, 0x16, 0xc5,
+			0xa0, 0x64, 0xc7, 0x48,
+			0x46, 0x48, 0xa0, 0x8c,
+			0x06, 0xe0, 0x10, 0xc5,
+			0xa0, 0x64, 0x47, 0x48,
+			0xc6, 0x48, 0xa0, 0x8c,
+			0x0c, 0xc7, 0xe0, 0x8e,
+			0x11, 0x1e, 0xe0, 0x8e,
+			0x02, 0xc7, 0x00, 0xbf,
+			0x88, 0x04, 0x02, 0xc7,
+			0x00, 0xbf, 0xbe, 0x03,
+			0x5c, 0xdc, 0xf0, 0xd3,
+			0x20, 0xe4, 0xd2, 0x49,
+			0x08, 0xf1, 0xd3, 0x49,
+			0x55, 0xf1, 0xd4, 0x49,
+			0x1e, 0xf1, 0xd5, 0x49,
+			0x45, 0xf1, 0x4d, 0xe0,
+			0x5a, 0xc7, 0xe0, 0x72,
+			0xa0, 0x49, 0x05, 0xf0,
+			0x54, 0xc7, 0xe0, 0x72,
+			0xaf, 0x49, 0x0e, 0xf1,
+			0x53, 0xc7, 0xff, 0x1a,
+			0xe0, 0x9a, 0x51, 0xc2,
+			0xe4, 0x9a, 0x50, 0xc2,
+			0xe6, 0x9a, 0x01, 0x1a,
+			0xe0, 0x9a, 0x4d, 0xc2,
+			0xe4, 0x9a, 0x4a, 0xc2,
+			0xe6, 0x9a, 0x44, 0xc7,
+			0xe5, 0x8e, 0x00, 0x1d,
+			0xe5, 0x8d, 0x30, 0xe0,
+			0x38, 0xc7, 0xe0, 0x75,
+			0xda, 0x49, 0x1f, 0xf0,
+			0x35, 0xc7, 0xe0, 0x75,
+			0xdc, 0x49, 0x1b, 0xf1,
+			0x32, 0xc7, 0xe0, 0x75,
+			0xd5, 0x49, 0x17, 0xf0,
+			0x39, 0xc7, 0xe0, 0x75,
+			0xd8, 0x48, 0xd9, 0x48,
+			0xda, 0x48, 0xdb, 0x48,
+			0xe0, 0x9d, 0x2a, 0xc7,
+			0xe0, 0x75, 0xdb, 0x49,
+			0x03, 0xf1, 0xde, 0x49,
+			0x0d, 0xf0, 0x22, 0xc7,
+			0xe4, 0x75, 0xd0, 0x49,
+			0x09, 0xf1, 0x1f, 0xc5,
+			0xe6, 0x9d, 0x11, 0x1d,
+			0xe4, 0x8d, 0x04, 0xe0,
+			0x19, 0xc7, 0x00, 0x1d,
+			0xe4, 0x8d, 0xe0, 0x8e,
+			0x11, 0x1d, 0xe0, 0x8d,
+			0x07, 0xe0, 0x0f, 0xc7,
+			0xe0, 0x75, 0xda, 0x48,
+			0xe0, 0x9d, 0x0e, 0xc7,
+			0xe4, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0xd6, 0x03,
+			0x02, 0xc4, 0x00, 0xbc,
+			0xc2, 0x03, 0x02, 0xc4,
+			0x00, 0xbc, 0x5a, 0x04,
+			0x12, 0xe8, 0x4e, 0xe8,
+			0x08, 0xe9, 0x20, 0xe4,
+			0x80, 0x02, 0x9a, 0xc0,
+			0x4e, 0xe8, 0x00, 0xe4,
+			0x10, 0xe0, 0xe0, 0xe8,
+			0x80, 0x11, 0x02, 0x80,
+			0x30, 0x10, 0xb4, 0xc0};
+		u8 new_ver;
+
+		rtl_fw_ver_erase(tp);
+
+		new_ver = 7;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_USB_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_USB);
+
+			generic_ocp_write(tp, 0xe600, 0xff,
+					  sizeof(usb_patch3_b), usb_patch3_b,
+					  MCU_TYPE_USB);
+
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xa000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x39d4);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x099c);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x293c);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x1cfe);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x2738);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x21ba);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x3962);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x51ba);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x6262);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x0f66);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x1098);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x1148);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x116c);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x10e0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x0f6a);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x7fff);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_USB_VER,
+				       new_ver);
+		}
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY);
-	ocp_data |= TALLY_RESET;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY, ocp_data);
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1);
+		ocp_data |= FW_IP_RESET_EN;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1, ocp_data);
+
+		ocp_write_dword(tp, MCU_TYPE_USB, USB_UPHY3_MDCMDIO, 0x4026840e);
+		ocp_write_dword(tp, MCU_TYPE_USB, USB_UPHY3_MDCMDIO, 0x4001acc9);
+
+		new_ver = 6;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_PLA_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+			generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch11),
+					  pla_patch11, MCU_TYPE_PLA);
+
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_BA, 0x8000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_0, 0x0bc2);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_1, 0x03e0);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_2, 0x06b8);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_3, 0x03ba);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_4, 0x03b2);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_5, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_6, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_7, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x0017);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_PLA_VER,
+				       new_ver);
+		}
+	} else if (tp->version == RTL_VER_12) {
+		static u8 usb_patch4_a[] = {
+			0x10, 0xe0, 0x38, 0xe0,
+			0x4e, 0xe0, 0x8b, 0xe0,
+			0xc1, 0xe0, 0xcd, 0xe0,
+			0xd5, 0xe0, 0xed, 0xe0,
+			0xf9, 0xe0, 0xfb, 0xe0,
+			0xfd, 0xe0, 0xff, 0xe0,
+			0x01, 0xe1, 0x03, 0xe1,
+			0x05, 0xe1, 0x07, 0xe1,
+			0x22, 0xc2, 0x4a, 0x41,
+			0x91, 0x20, 0x20, 0xc0,
+			0x16, 0x00, 0x00, 0x73,
+			0x1e, 0xc4, 0x5c, 0x41,
+			0x8b, 0x41, 0x1a, 0xc0,
+			0x1a, 0x00, 0x00, 0x73,
+			0xbd, 0x48, 0x0d, 0x18,
+			0x17, 0xc6, 0xc0, 0x88,
+			0xc1, 0x9b, 0x15, 0xe8,
+			0x0b, 0x18, 0x12, 0xc6,
+			0xc0, 0x88, 0xc1, 0x99,
+			0x10, 0xe8, 0x0c, 0xc0,
+			0x1c, 0x00, 0x00, 0x73,
+			0x0e, 0x18, 0x0a, 0xc6,
+			0xc0, 0x88, 0xc1, 0x9b,
+			0x08, 0xe8, 0x02, 0xc6,
+			0x00, 0xbe, 0x10, 0x12,
+			0xf0, 0x00, 0x90, 0xc7,
+			0x1f, 0xfe, 0x8f, 0xcb,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x66, 0x3f, 0x11, 0x21,
+			0x2b, 0x25, 0x13, 0xc4,
+			0xa2, 0x41, 0x80, 0x63,
+			0xf5, 0xc0, 0x48, 0x00,
+			0xbb, 0x21, 0xb9, 0x25,
+			0x00, 0x71, 0x0c, 0xc2,
+			0x4a, 0x41, 0x8b, 0x41,
+			0x24, 0x18, 0xee, 0xc6,
+			0xc0, 0x88, 0xc1, 0x99,
+			0xec, 0xef, 0x02, 0xc6,
+			0x00, 0xbe, 0x8a, 0x12,
+			0xa0, 0xf9, 0x83, 0xff,
+			0xd4, 0x18, 0x20, 0x88,
+			0x36, 0xe8, 0x22, 0x60,
+			0x85, 0x48, 0x06, 0x48,
+			0x21, 0x88, 0xf4, 0x18,
+			0x20, 0x88, 0x32, 0xe8,
+			0x2d, 0xc3, 0xc0, 0x18,
+			0x20, 0x88, 0x2b, 0xe8,
+			0x22, 0x60, 0x60, 0x88,
+			0xc1, 0x18, 0x20, 0x88,
+			0x26, 0xe8, 0x22, 0x60,
+			0x61, 0x88, 0xc2, 0x18,
+			0x20, 0x88, 0x21, 0xe8,
+			0x22, 0x60, 0x62, 0x88,
+			0xc3, 0x18, 0x20, 0x88,
+			0x1c, 0xe8, 0x22, 0x60,
+			0x63, 0x88, 0xc4, 0x18,
+			0x20, 0x88, 0x17, 0xe8,
+			0x22, 0x60, 0x64, 0x88,
+			0xc5, 0x18, 0x20, 0x88,
+			0x12, 0xe8, 0x22, 0x60,
+			0x65, 0x88, 0xc6, 0x18,
+			0x20, 0x88, 0x0d, 0xe8,
+			0x22, 0x60, 0x66, 0x88,
+			0xc7, 0x18, 0x20, 0x88,
+			0x08, 0xe8, 0x22, 0x60,
+			0x67, 0x88, 0xd4, 0x18,
+			0x02, 0xc5, 0x00, 0xbd,
+			0xc2, 0x35, 0xc0, 0xd3,
+			0x02, 0xc5, 0x00, 0xbd,
+			0xb2, 0x3e, 0x02, 0xc5,
+			0x00, 0xbd, 0x08, 0x3f,
+			0xd4, 0x18, 0xc0, 0x88,
+			0xf8, 0xef, 0xc2, 0x60,
+			0x85, 0x48, 0x06, 0x48,
+			0xc1, 0x88, 0xf4, 0x18,
+			0xc0, 0x88, 0xf4, 0xef,
+			0xef, 0xc3, 0x60, 0x60,
+			0xc1, 0x88, 0xe0, 0x18,
+			0xc0, 0x88, 0xee, 0xef,
+			0x61, 0x60, 0xc1, 0x88,
+			0xe1, 0x18, 0xc0, 0x88,
+			0xe9, 0xef, 0x62, 0x60,
+			0xc1, 0x88, 0xe2, 0x18,
+			0xc0, 0x88, 0xe4, 0xef,
+			0x63, 0x60, 0xc1, 0x88,
+			0xe3, 0x18, 0xc0, 0x88,
+			0xdf, 0xef, 0x64, 0x60,
+			0xc1, 0x88, 0xe4, 0x18,
+			0xc0, 0x88, 0xda, 0xef,
+			0x65, 0x60, 0xc1, 0x88,
+			0xe5, 0x18, 0xc0, 0x88,
+			0xd5, 0xef, 0x66, 0x60,
+			0xc1, 0x88, 0xe6, 0x18,
+			0xc0, 0x88, 0xd0, 0xef,
+			0x67, 0x60, 0xc1, 0x88,
+			0xe7, 0x18, 0xc0, 0x88,
+			0xcb, 0xef, 0xd4, 0x18,
+			0x02, 0xc2, 0x00, 0xba,
+			0x3a, 0x15, 0x0b, 0xc6,
+			0xc7, 0x65, 0xd0, 0x49,
+			0x05, 0xf1, 0x08, 0xc0,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x50, 0x2f, 0x02, 0xc7,
+			0x00, 0xbf, 0x56, 0x2f,
+			0x20, 0xd4, 0x00, 0xd4,
+			0x08, 0xc3, 0x60, 0x60,
+			0x03, 0x48, 0x60, 0x88,
+			0x00, 0x1b, 0x02, 0xc6,
+			0x00, 0xbe, 0xda, 0x2c,
+			0x60, 0xb4, 0x17, 0xc1,
+			0x17, 0xc2, 0x4c, 0x99,
+			0x00, 0x19, 0x4e, 0x89,
+			0x4f, 0x61, 0x97, 0x49,
+			0xfe, 0xf1, 0x48, 0x61,
+			0x01, 0xb4, 0x16, 0x48,
+			0x17, 0x48, 0x48, 0x89,
+			0x0a, 0xc1, 0x4c, 0x99,
+			0x81, 0x19, 0x4e, 0x89,
+			0x4f, 0x61, 0x97, 0x49,
+			0xfe, 0xf1, 0x02, 0xc0,
+			0x00, 0xb8, 0x32, 0x7c,
+			0x1c, 0xe8, 0x00, 0xdc,
+			0x01, 0xb0, 0xfe, 0xc2,
+			0x48, 0x89, 0xfb, 0xc1,
+			0x4c, 0x99, 0x81, 0x19,
+			0x4e, 0x89, 0x4f, 0x61,
+			0x97, 0x49, 0xfe, 0xf1,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x96, 0x7c, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x00, 0x00};
+		static u8 pla_patch4_a[] = {
+			0x08, 0xe0, 0x0c, 0xe0,
+			0x10, 0xe0, 0x3e, 0xe0,
+			0x40, 0xe0, 0x42, 0xe0,
+			0x44, 0xe0, 0x46, 0xe0,
+			0x03, 0xb4, 0x02, 0xb4,
+			0x02, 0xc7, 0x00, 0xbf,
+			0xb4, 0x03, 0x02, 0xb0,
+			0x03, 0xb0, 0x02, 0xc6,
+			0x00, 0xbe, 0x8c, 0x05,
+			0xaf, 0x49, 0x17, 0xf1,
+			0x20, 0xc6, 0x00, 0x1a,
+			0x23, 0xe8, 0x21, 0xc6,
+			0xc0, 0x61, 0x91, 0x49,
+			0x0c, 0xf0, 0x95, 0x49,
+			0x0a, 0xf1, 0x14, 0x48,
+			0x16, 0xc6, 0x81, 0x1a,
+			0x19, 0xe8, 0x14, 0xc6,
+			0xc0, 0x62, 0x24, 0x48,
+			0xc0, 0x8a, 0x0c, 0xe0,
+			0x10, 0xc6, 0xc0, 0x62,
+			0xa5, 0x49, 0x08, 0xf1,
+			0x0d, 0xc6, 0xc0, 0x62,
+			0xa0, 0x48, 0xc0, 0x8a,
+			0xc2, 0x62, 0xa3, 0x48,
+			0xc2, 0x8a, 0x02, 0xc6,
+			0x00, 0xbe, 0xd2, 0x16,
+			0x84, 0xd2, 0x6a, 0xdc,
+			0x90, 0xd3, 0x66, 0xb4,
+			0x08, 0xea, 0xff, 0xc0,
+			0x04, 0x9e, 0x00, 0x99,
+			0x06, 0x8a, 0x06, 0x72,
+			0xaf, 0x49, 0xfe, 0xf1,
+			0x80, 0xff, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00};
+		u8 new_ver;
+
+		rtl_fw_ver_erase(tp);
+
+		new_ver = 2;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_USB_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_USB);
+
+			generic_ocp_write(tp, 0xe600, 0xff,
+					  sizeof(usb_patch4_a), usb_patch4_a,
+					  MCU_TYPE_USB);
+
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xc000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x11e2);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x1268);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x35c0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x1538);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x2f4e);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x2cd8);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x7c26);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x7c90);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x0000);
+//			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x00df);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_USB_VER,
+				       new_ver);
+		}
+
+//		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1);
+//		ocp_data |= FW_IP_RESET_EN;
+//		ocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1, ocp_data);
+
+//		ocp_write_dword(tp, MCU_TYPE_USB, 0xd480, 0x4026840e);
+//		ocp_write_dword(tp, MCU_TYPE_USB, 0xd480, 0x4001acc9);
+
+		new_ver = 2;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_PLA_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+			generic_ocp_write(tp, 0xf800, 0xff,
+					  sizeof(pla_patch4_a), pla_patch4_a,
+					  MCU_TYPE_PLA);
+
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_BA, 0x8000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_0, 0x03b2);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_1, 0x058a);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_2, 0x16c0);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_3, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_4, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_5, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_6, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_7, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x0007);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_PLA_VER,
+				       new_ver);
+		}
+	} else if (tp->version == RTL_VER_13 || tp->version == RTL_VER_15) {
+		static u8 usb_patch_13[] = {
+			0x10, 0xe0, 0x25, 0xe0,
+			0x29, 0xe0, 0x2d, 0xe0,
+			0x52, 0xe0, 0xff, 0xe0,
+			0x02, 0xe1, 0x06, 0xe1,
+			0x16, 0xe1, 0x18, 0xe1,
+			0x39, 0xe1, 0x52, 0xe1,
+			0x54, 0xe1, 0x56, 0xe1,
+			0x58, 0xe1, 0x5a, 0xe1,
+			0x13, 0xc3, 0x60, 0x70,
+			0x8b, 0x49, 0x0d, 0xf1,
+			0x10, 0xc3, 0x60, 0x60,
+			0x85, 0x49, 0x09, 0xf1,
+			0x40, 0x03, 0x64, 0x60,
+			0x82, 0x49, 0x05, 0xf1,
+			0x09, 0xc3, 0x60, 0x60,
+			0x80, 0x48, 0x60, 0x88,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xde, 0x0f, 0xca, 0xcf,
+			0x00, 0xd8, 0x1e, 0xb4,
+			0x04, 0xc3, 0x02, 0xc0,
+			0x00, 0xb8, 0x62, 0x36,
+			0xc8, 0xd3, 0x04, 0xc3,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x7a, 0x14, 0xc8, 0xd3,
+			0x00, 0xb4, 0x01, 0xb4,
+			0x02, 0xb4, 0x03, 0xb4,
+			0x1f, 0xc1, 0x02, 0x1b,
+			0x2c, 0x8b, 0x0c, 0x62,
+			0xa7, 0x49, 0x0a, 0xf1,
+			0x00, 0x1b, 0x08, 0x72,
+			0x13, 0x40, 0x04, 0xf1,
+			0x0a, 0x72, 0x13, 0x40,
+			0x03, 0xf0, 0x01, 0x1b,
+			0x2c, 0x8b, 0x12, 0xc0,
+			0x01, 0x1a, 0x08, 0x8a,
+			0x0a, 0x8a, 0x0d, 0xc0,
+			0x12, 0x71, 0x19, 0x48,
+			0x1a, 0x48, 0x12, 0x99,
+			0x03, 0xb0, 0x02, 0xb0,
+			0x01, 0xb0, 0x00, 0xb0,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xb0, 0x77, 0x20, 0xc3,
+			0x18, 0xb4, 0x80, 0xcb,
+			0x00, 0xb4, 0x01, 0xb4,
+			0x02, 0xb4, 0x03, 0xb4,
+			0x07, 0xb4, 0x23, 0xc0,
+			0x24, 0xc1, 0x08, 0x1a,
+			0x2a, 0x8a, 0x24, 0x01,
+			0x0d, 0x1a, 0x20, 0x9a,
+			0x24, 0x09, 0x00, 0x1a,
+			0x22, 0x9a, 0x04, 0x72,
+			0x06, 0x73, 0x18, 0xc7,
+			0xe4, 0x9a, 0xe6, 0x9b,
+			0x17, 0xc2, 0x17, 0xc3,
+			0xe0, 0x9a, 0xe2, 0x9b,
+			0x80, 0x1b, 0x32, 0x8b,
+			0x00, 0x1a, 0x24, 0x9f,
+			0x26, 0x9a, 0x01, 0x1a,
+			0x28, 0x8a, 0x0f, 0xe8,
+			0x07, 0xb0, 0x03, 0xb0,
+			0x02, 0xb0, 0x01, 0xb0,
+			0x00, 0xb0, 0x02, 0xc6,
+			0x00, 0xbe, 0xe6, 0x60,
+			0x00, 0xc3, 0x20, 0xc3,
+			0x80, 0xcb, 0x55, 0x53,
+			0x42, 0x53, 0x80, 0xcb,
+			0x03, 0xb4, 0x06, 0xb4,
+			0x07, 0xb4, 0xfc, 0xc7,
+			0x79, 0xc7, 0xe0, 0x73,
+			0xba, 0x49, 0x0d, 0xf0,
+			0xf7, 0xc6, 0x24, 0x06,
+			0xc0, 0x77, 0xfa, 0x25,
+			0x76, 0x23, 0x66, 0x27,
+			0x70, 0xc7, 0xe1, 0x9e,
+			0x00, 0x16, 0x10, 0xf0,
+			0x01, 0x03, 0x0e, 0xe0,
+			0xb9, 0x49, 0x10, 0xf0,
+			0xe9, 0xc6, 0x24, 0x06,
+			0xc0, 0x77, 0xf9, 0x25,
+			0x77, 0x23, 0x67, 0x27,
+			0x62, 0xc7, 0xe1, 0x9e,
+			0x00, 0x16, 0x02, 0xf0,
+			0x01, 0x03, 0x5e, 0xc7,
+			0xe0, 0x8b, 0x12, 0xe8,
+			0x0d, 0xe0, 0xda, 0xc6,
+			0x24, 0x06, 0xc0, 0x77,
+			0xf6, 0x25, 0x7a, 0x23,
+			0x6a, 0x27, 0x53, 0xc7,
+			0xe1, 0x9e, 0x00, 0x16,
+			0xf3, 0xf0, 0x01, 0x03,
+			0xf1, 0xe7, 0x07, 0xb0,
+			0x06, 0xb0, 0x03, 0xb0,
+			0x80, 0xff, 0x03, 0xb4,
+			0x06, 0xb4, 0x07, 0xb4,
+			0xc7, 0xc6, 0xc4, 0x77,
+			0x40, 0xc3, 0x7c, 0x9f,
+			0x41, 0xc6, 0xc0, 0x73,
+			0xba, 0x49, 0x05, 0xf1,
+			0x00, 0x13, 0x05, 0xf1,
+			0x39, 0xc3, 0x04, 0xe0,
+			0x38, 0xc3, 0x02, 0xe0,
+			0x40, 0x1b, 0xb8, 0xc6,
+			0xfb, 0x31, 0xc4, 0x9f,
+			0x35, 0xc6, 0xc0, 0x67,
+			0x01, 0x17, 0x07, 0xfc,
+			0x30, 0xc6, 0xc1, 0x77,
+			0x01, 0x1b, 0xc0, 0x8b,
+			0x00, 0x17, 0x0c, 0xf1,
+			0x29, 0xc6, 0xc0, 0x73,
+			0xba, 0x49, 0x05, 0xf1,
+			0xb9, 0x49, 0x05, 0xf0,
+			0x21, 0xc7, 0x04, 0xe0,
+			0x20, 0xc7, 0x02, 0xe0,
+			0x40, 0x1f, 0x1a, 0xc6,
+			0x7e, 0x41, 0x1d, 0xc6,
+			0xc0, 0x63, 0xbb, 0x21,
+			0xbb, 0x41, 0x15, 0xc3,
+			0x66, 0x9f, 0x18, 0xc6,
+			0xc0, 0x67, 0xf9, 0x3b,
+			0xc0, 0x8f, 0x01, 0x17,
+			0x03, 0xfd, 0x00, 0x1f,
+			0x02, 0xe0, 0x01, 0x1f,
+			0x0e, 0xc6, 0xc0, 0x8f,
+			0x08, 0xc3, 0x04, 0x1e,
+			0x60, 0x8e, 0x07, 0xb0,
+			0x06, 0xb0, 0x03, 0xb0,
+			0x80, 0xff, 0xff, 0x07,
+			0x40, 0xd4, 0x00, 0x02,
+			0x00, 0x04, 0x80, 0xb9,
+			0xfd, 0xcb, 0xa2, 0xcb,
+			0xe8, 0x74, 0x02, 0xc5,
+			0x00, 0xbd, 0x96, 0x6d,
+			0x04, 0xc4, 0x02, 0xc3,
+			0x00, 0xbb, 0x50, 0x28,
+			0x7f, 0x00, 0x00, 0x1e,
+			0x00, 0x11, 0x0c, 0xf0,
+			0x90, 0x49, 0x04, 0xf1,
+			0x01, 0x06, 0x91, 0x24,
+			0xfa, 0xe7, 0x28, 0x32,
+			0x06, 0x43, 0xf8, 0x31,
+			0x01, 0x06, 0x91, 0x24,
+			0xf4, 0xe7, 0x02, 0xc0,
+			0x00, 0xb8, 0x0e, 0x28,
+			0x02, 0xc7, 0x00, 0xbf,
+			0x48, 0x31, 0x1c, 0xc6,
+			0xc0, 0x61, 0x04, 0x11,
+			0x15, 0xf1, 0x19, 0xc6,
+			0xc0, 0x61, 0x9c, 0x20,
+			0x9c, 0x24, 0x09, 0x11,
+			0x0f, 0xf1, 0x14, 0xc6,
+			0x01, 0x19, 0xc0, 0x89,
+			0x13, 0xc1, 0x13, 0xc6,
+			0x24, 0x9e, 0x00, 0x1e,
+			0x26, 0x8e, 0x26, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x22, 0x76, 0x08, 0xc1,
+			0x22, 0x9e, 0x07, 0xc6,
+			0x02, 0xc1, 0x00, 0xb9,
+			0xae, 0x09, 0x18, 0xb4,
+			0x4a, 0xb4, 0xe0, 0xcc,
+			0x80, 0xd4, 0x08, 0xdc,
+			0x10, 0xe8, 0xfc, 0xc6,
+			0xc0, 0x67, 0xf0, 0x49,
+			0x13, 0xf0, 0xf0, 0x48,
+			0xc0, 0x8f, 0xc2, 0x77,
+			0xf7, 0xc1, 0xf7, 0xc6,
+			0x24, 0x9e, 0x22, 0x9f,
+			0x8c, 0x1e, 0x26, 0x8e,
+			0x26, 0x76, 0xef, 0x49,
+			0xfe, 0xf1, 0xfb, 0x49,
+			0x05, 0xf0, 0x07, 0xc6,
+			0xc0, 0x61, 0x10, 0x48,
+			0xc0, 0x89, 0x02, 0xc6,
+			0x00, 0xbe, 0x06, 0x5f,
+			0x6c, 0xb4, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x00, 0x00, 0x02, 0xc0,
+			0x00, 0xb8, 0x00, 0x00};
+		static u8 pla_patch_13[] = {
+			0x08, 0xe0, 0x14, 0xe0,
+			0x18, 0xe0, 0x32, 0xe0,
+			0xc8, 0xe0, 0xd4, 0xe0,
+			0x0e, 0xe1, 0x10, 0xe1,
+			0x0c, 0xc4, 0x04, 0x40,
+			0x05, 0xf0, 0x8c, 0x26,
+			0x0b, 0x15, 0x02, 0xf0,
+			0x03, 0xe0, 0x00, 0x9a,
+			0x01, 0xe0, 0x02, 0xc4,
+			0x00, 0xbc, 0x36, 0x37,
+			0x6c, 0xe8, 0x3a, 0x73,
+			0xbb, 0x49, 0x02, 0xc6,
+			0x00, 0xbe, 0xde, 0x27,
+			0x3a, 0x73, 0xb5, 0x21,
+			0xbc, 0x25, 0x04, 0x13,
+			0x11, 0xf1, 0x12, 0x1b,
+			0x2a, 0x1d, 0x68, 0x31,
+			0xda, 0x3a, 0xab, 0x31,
+			0x00, 0x1a, 0xc0, 0x9a,
+			0x00, 0x13, 0xfb, 0xf1,
+			0x20, 0x76, 0x6e, 0x23,
+			0x6f, 0x27, 0x3c, 0x1a,
+			0xa1, 0x22, 0xb5, 0x41,
+			0xe2, 0x9e, 0xe4, 0x76,
+			0x6f, 0x48, 0xe4, 0x9e,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x62, 0x2a, 0x87, 0x49,
+			0x62, 0xf0, 0x03, 0x1b,
+			0x58, 0x41, 0x33, 0xf0,
+			0x20, 0x73, 0x0b, 0xc5,
+			0xa4, 0x74, 0xc0, 0x49,
+			0x1b, 0xf1, 0x08, 0xc4,
+			0x14, 0x40, 0x07, 0xf1,
+			0x01, 0x1c, 0xa6, 0x9c,
+			0xa0, 0x9b, 0x27, 0xe0,
+			0xb8, 0xd3, 0x6c, 0xe8,
+			0x2c, 0x26, 0x0b, 0x14,
+			0x0f, 0xf1, 0x70, 0xc4,
+			0xa6, 0x73, 0xb0, 0x49,
+			0x08, 0xf0, 0xb0, 0x48,
+			0xa6, 0x9b, 0xa0, 0x73,
+			0x80, 0x9b, 0x20, 0x73,
+			0x40, 0x83, 0x17, 0xe0,
+			0x20, 0x73, 0x40, 0x83,
+			0x14, 0xe0, 0x70, 0xc4,
+			0x22, 0x40, 0x0a, 0xf1,
+			0x38, 0x22, 0x48, 0x26,
+			0xe8, 0x14, 0x06, 0xfb,
+			0x6b, 0xc4, 0x80, 0x74,
+			0xca, 0x49, 0x02, 0xf1,
+			0xbe, 0x48, 0x40, 0x83,
+			0x56, 0xc4, 0x22, 0x40,
+			0x57, 0xf0, 0x54, 0xc4,
+			0x22, 0x40, 0x57, 0xf0,
+			0x0c, 0x1b, 0x58, 0x41,
+			0x57, 0xf0, 0x02, 0x24,
+			0x03, 0x1b, 0x58, 0x41,
+			0x53, 0xf0, 0x47, 0xc5,
+			0xa4, 0x74, 0xc0, 0x49,
+			0x0e, 0xf1, 0x2c, 0x26,
+			0x0b, 0x14, 0x0b, 0xf1,
+			0x41, 0xc4, 0x80, 0x73,
+			0xa2, 0x9b, 0xa0, 0x73,
+			0x80, 0x9b, 0x22, 0x73,
+			0x42, 0x83, 0xa2, 0x73,
+			0x80, 0x9b, 0x42, 0xe0,
+			0x22, 0x73, 0x45, 0xc4,
+			0x22, 0x40, 0x0a, 0xf1,
+			0x39, 0x22, 0x4e, 0x26,
+			0x03, 0x14, 0x06, 0xf1,
+			0x3f, 0xc4, 0x80, 0x74,
+			0xca, 0x49, 0x02, 0xf1,
+			0xbe, 0x48, 0x42, 0x83,
+			0x2a, 0xc4, 0x22, 0x40,
+			0x31, 0xf1, 0x29, 0xc4,
+			0x82, 0x83, 0x2e, 0xe0,
+			0x22, 0xc5, 0xa4, 0x74,
+			0xc0, 0x49, 0x12, 0xf1,
+			0x2c, 0x26, 0x0b, 0x14,
+			0x0f, 0xf1, 0x1b, 0xc5,
+			0x1b, 0xc4, 0xa6, 0x73,
+			0xb0, 0x49, 0x05, 0xf0,
+			0xb0, 0x48, 0xa6, 0x9b,
+			0xa0, 0x73, 0x80, 0x9b,
+			0x40, 0x73, 0x20, 0x9b,
+			0x42, 0x73, 0x22, 0x9b,
+			0x19, 0xe0, 0x86, 0x49,
+			0x03, 0xf0, 0x84, 0x49,
+			0x03, 0xf0, 0x40, 0x73,
+			0x20, 0x9b, 0x86, 0x49,
+			0x03, 0xf0, 0x85, 0x49,
+			0x0f, 0xf0, 0x42, 0x73,
+			0x22, 0x9b, 0x0c, 0xe0,
+			0xb8, 0xd3, 0x6c, 0xe8,
+			0x00, 0xc0, 0x04, 0xc0,
+			0x82, 0xcc, 0xff, 0xc4,
+			0x80, 0x83, 0xab, 0xe7,
+			0xfc, 0xc4, 0x84, 0x83,
+			0xa8, 0xe7, 0x02, 0xc5,
+			0x00, 0xbd, 0x66, 0x0a,
+			0x00, 0xea, 0x04, 0xdd,
+			0x02, 0xdd, 0x5a, 0xe8,
+			0x04, 0xe8, 0x02, 0xc1,
+			0x00, 0xb9, 0xac, 0x35,
+			0x08, 0xc1, 0x20, 0x70,
+			0x87, 0x48, 0x20, 0x98,
+			0x36, 0x70, 0x80, 0x48,
+			0x36, 0x98, 0x80, 0xff,
+			0xd4, 0xb5, 0x04, 0x10,
+			0x07, 0xf1, 0x27, 0xc1,
+			0x32, 0x70, 0x89, 0x48,
+			0x32, 0x98, 0xf1, 0xef,
+			0x18, 0xe0, 0x05, 0x10,
+			0x07, 0xf1, 0x1f, 0xc1,
+			0x32, 0x70, 0x89, 0x48,
+			0x32, 0x98, 0x1d, 0xe8,
+			0x10, 0xe0, 0x06, 0x10,
+			0x07, 0xf1, 0x17, 0xc1,
+			0x32, 0x70, 0x09, 0x48,
+			0x32, 0x98, 0x15, 0xe8,
+			0x08, 0xe0, 0x07, 0x10,
+			0x0d, 0xf1, 0x0f, 0xc1,
+			0x32, 0x70, 0x09, 0x48,
+			0x32, 0x98, 0x15, 0xe8,
+			0x0b, 0xc1, 0x28, 0x70,
+			0x09, 0x48, 0x28, 0x98,
+			0x02, 0xc1, 0x00, 0xb9,
+			0x44, 0x36, 0x02, 0xc1,
+			0x00, 0xb9, 0x52, 0x36,
+			0x00, 0xb4, 0x20, 0xb4,
+			0xd4, 0xc1, 0x20, 0x70,
+			0x87, 0x48, 0x20, 0x98,
+			0x36, 0x70, 0x00, 0x48,
+			0x36, 0x98, 0x80, 0xff,
+			0xcc, 0xc1, 0x20, 0x70,
+			0x07, 0x48, 0x20, 0x98,
+			0x36, 0x70, 0x00, 0x48,
+			0x36, 0x98, 0x80, 0xff,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x3a, 0x4e, 0x02, 0xc0,
+			0x00, 0xb8, 0x3a, 0x4e};
+		u8 new_ver;
+
+		rtl_fw_ver_erase(tp);
+
+		new_ver = 4;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_USB_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_USB);
+
+			generic_ocp_write(tp, 0xe600, 0xff,
+					  sizeof(usb_patch_13), usb_patch_13,
+					  MCU_TYPE_USB);
+
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0xc000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_0, 0x0fba);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_1, 0x3660);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_2, 0x1478);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_3, 0x77ae);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, 0x60e0);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_5, 0x6d94);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_6, 0x284e);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_7, 0x27f6);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0x3140);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0x09ac);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0x5e2a);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0x07ff);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_USB_VER,
+				       new_ver);
+		}
+
+		new_ver = 6;
+		if (rtl_check_fw_ver_ok(tp, USB_FW_PLA_VER, new_ver)) {
+			rtl_clear_bp(tp, MCU_TYPE_PLA);
+
+			generic_ocp_write(tp, 0xf800, 0xff,
+					  sizeof(pla_patch_13), pla_patch_13,
+					  MCU_TYPE_PLA);
+
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_BA, 0x8000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_0, 0x374e);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_1, 0x27dc);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_2, 0x2a5c);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_3, 0x09d0);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_4, 0x359e);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_5, 0x35b6);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_6, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_7, 0x0000);
+			ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x003f);
+			ocp_write_byte(tp, MCU_TYPE_USB, USB_FW_PLA_VER,
+				       new_ver);
+		}
+	}
+
+	rtl_reset_ocp_base(tp);
 }
 
-static void r8152b_init(struct r8152 *tp)
+static void rtl_ram_code_speed_up(struct r8152 *tp, bool wait)
 {
-	u32 ocp_data;
-	u16 data;
+	u32 ocp_data, len = 0;
+	u8 *data = NULL;
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return;
+	rtl_reset_ocp_base(tp);
 
-	data = r8152_mdio_read(tp, MII_BMCR);
-	if (data & BMCR_PDOWN) {
-		data &= ~BMCR_PDOWN;
-		r8152_mdio_write(tp, MII_BMCR, data);
+	if (tp->version == RTL_VER_13 || tp->version == RTL_VER_15) {
+		static u8 ram13[] = {
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x24, 0x80,
+			0x38, 0xb4, 0x01, 0x37,
+			0x36, 0xb4, 0x2e, 0xb8,
+			0x38, 0xb4, 0x01, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x20, 0xb8, 0x90, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x10, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3f, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x45, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x67, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x6d, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x71, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xb1, 0x80,
+			0x38, 0xb4, 0x93, 0xd0,
+			0x38, 0xb4, 0xc4, 0xd1,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xbc, 0x5f,
+			0x38, 0xb4, 0x04, 0xd5,
+			0x38, 0xb4, 0xf1, 0xc9,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xc9, 0x0f,
+			0x38, 0xb4, 0x50, 0xbb,
+			0x38, 0xb4, 0x05, 0xd5,
+			0x38, 0xb4, 0x02, 0xa2,
+			0x38, 0xb4, 0x04, 0xd5,
+			0x38, 0xb4, 0x0f, 0x8c,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x19, 0x15,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0xae, 0x5f,
+			0x38, 0xb4, 0x50, 0x9b,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0xae, 0x7f,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x07, 0xd7,
+			0x38, 0xb4, 0xa7, 0x40,
+			0x38, 0xb4, 0x19, 0xd7,
+			0x38, 0xb4, 0x71, 0x40,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x57, 0x15,
+			0x38, 0xb4, 0x19, 0xd7,
+			0x38, 0xb4, 0x70, 0x2f,
+			0x38, 0xb4, 0x3b, 0x80,
+			0x38, 0xb4, 0x73, 0x2f,
+			0x38, 0xb4, 0x6a, 0x15,
+			0x38, 0xb4, 0x70, 0x5e,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x5d, 0x15,
+			0x38, 0xb4, 0x05, 0xd5,
+			0x38, 0xb4, 0x02, 0xa2,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0xed, 0xff,
+			0x38, 0xb4, 0x09, 0xd7,
+			0x38, 0xb4, 0x54, 0x40,
+			0x38, 0xb4, 0x88, 0xa7,
+			0x38, 0xb4, 0x0b, 0xd7,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2a, 0x17,
+			0x38, 0xb4, 0xc1, 0xc0,
+			0x38, 0xb4, 0xc0, 0xc0,
+			0x38, 0xb4, 0x5a, 0xd0,
+			0x38, 0xb4, 0xba, 0xd1,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0x29, 0x25,
+			0x38, 0xb4, 0x2a, 0x02,
+			0x38, 0xb4, 0xa7, 0xd0,
+			0x38, 0xb4, 0xb9, 0xd1,
+			0x38, 0xb4, 0x08, 0xa2,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x0e, 0x08,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0x8b, 0x40,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x65, 0x0a,
+			0x38, 0xb4, 0x03, 0xf0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x6b, 0x0a,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x20, 0x09,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x15, 0x09,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x09, 0x09,
+			0x38, 0xb4, 0x8f, 0x22,
+			0x38, 0xb4, 0x4e, 0x80,
+			0x38, 0xb4, 0x01, 0x98,
+			0x38, 0xb4, 0x1e, 0xd7,
+			0x38, 0xb4, 0x61, 0x5d,
+			0x38, 0xb4, 0x01, 0xd7,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2a, 0x02,
+			0x38, 0xb4, 0x05, 0x20,
+			0x38, 0xb4, 0x1a, 0x09,
+			0x38, 0xb4, 0xd9, 0x3b,
+			0x38, 0xb4, 0x19, 0x09,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x16, 0x09,
+			0x38, 0xb4, 0x90, 0xd0,
+			0x38, 0xb4, 0xc9, 0xd1,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x64, 0x10,
+			0x38, 0xb4, 0x96, 0xd0,
+			0x38, 0xb4, 0xa9, 0xd1,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0x04, 0xa1,
+			0x38, 0xb4, 0x07, 0x0c,
+			0x38, 0xb4, 0x02, 0x09,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x10, 0xbc,
+			0x38, 0xb4, 0x01, 0xd5,
+			0x38, 0xb4, 0x01, 0xce,
+			0x38, 0xb4, 0x01, 0xa2,
+			0x38, 0xb4, 0x01, 0x82,
+			0x38, 0xb4, 0x00, 0xce,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x84, 0xc4,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0x02, 0xcc,
+			0x38, 0xb4, 0x0d, 0xcd,
+			0x38, 0xb4, 0x01, 0xaf,
+			0x38, 0xb4, 0x00, 0xd5,
+			0x38, 0xb4, 0x03, 0xd7,
+			0x38, 0xb4, 0x71, 0x43,
+			0x38, 0xb4, 0x08, 0xbd,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0xb3, 0x5f,
+			0x38, 0xb4, 0x03, 0xd5,
+			0x38, 0xb4, 0xf5, 0xd0,
+			0x38, 0xb4, 0xc6, 0xd1,
+			0x38, 0xb4, 0xf0, 0x0c,
+			0x38, 0xb4, 0x50, 0x0e,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0x1c, 0x40,
+			0x38, 0xb4, 0xf5, 0xd0,
+			0x38, 0xb4, 0xc6, 0xd1,
+			0x38, 0xb4, 0xf0, 0x0c,
+			0x38, 0xb4, 0xa0, 0x0e,
+			0x38, 0xb4, 0x1c, 0x40,
+			0x38, 0xb4, 0x7b, 0xd0,
+			0x38, 0xb4, 0xc5, 0xd1,
+			0x38, 0xb4, 0xf0, 0x8e,
+			0x38, 0xb4, 0x1c, 0x40,
+			0x38, 0xb4, 0x08, 0x9d,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0xb3, 0x7f,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x5e, 0xd7,
+			0x38, 0xb4, 0xad, 0x5f,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xc5, 0x14,
+			0x38, 0xb4, 0x03, 0xd7,
+			0x38, 0xb4, 0x81, 0x31,
+			0x38, 0xb4, 0xaf, 0x80,
+			0x38, 0xb4, 0xad, 0x60,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x5c, 0x13,
+			0x38, 0xb4, 0x03, 0xd7,
+			0x38, 0xb4, 0xba, 0x5f,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xc7, 0x0c,
+			0x38, 0xb4, 0x02, 0xa8,
+			0x38, 0xb4, 0x01, 0xa3,
+			0x38, 0xb4, 0x01, 0xa8,
+			0x38, 0xb4, 0x04, 0xc0,
+			0x38, 0xb4, 0x10, 0xd7,
+			0x38, 0xb4, 0x00, 0x40,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x79, 0x1e,
+			0x36, 0xb4, 0x26, 0xa0,
+			0x38, 0xb4, 0x78, 0x1e,
+			0x36, 0xb4, 0x24, 0xa0,
+			0x38, 0xb4, 0x93, 0x0c,
+			0x36, 0xb4, 0x22, 0xa0,
+			0x38, 0xb4, 0x62, 0x10,
+			0x36, 0xb4, 0x20, 0xa0,
+			0x38, 0xb4, 0x15, 0x09,
+			0x36, 0xb4, 0x06, 0xa0,
+			0x38, 0xb4, 0x0a, 0x02,
+			0x36, 0xb4, 0x04, 0xa0,
+			0x38, 0xb4, 0x26, 0x17,
+			0x36, 0xb4, 0x02, 0xa0,
+			0x38, 0xb4, 0x42, 0x15,
+			0x36, 0xb4, 0x00, 0xa0,
+			0x38, 0xb4, 0xc7, 0x0f,
+			0x36, 0xb4, 0x08, 0xa0,
+			0x38, 0xb4, 0x00, 0xff,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x10, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x10, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1d, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2c, 0x80,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x90, 0x60,
+			0x38, 0xb4, 0xd1, 0x60,
+			0x38, 0xb4, 0x5c, 0xc9,
+			0x38, 0xb4, 0x07, 0xf0,
+			0x38, 0xb4, 0xb1, 0x60,
+			0x38, 0xb4, 0x5a, 0xc9,
+			0x38, 0xb4, 0x04, 0xf0,
+			0x38, 0xb4, 0x56, 0xc9,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x4e, 0xc9,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0xcd, 0x00,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x90, 0x60,
+			0x38, 0xb4, 0xd1, 0x60,
+			0x38, 0xb4, 0x5c, 0xc9,
+			0x38, 0xb4, 0x07, 0xf0,
+			0x38, 0xb4, 0xb1, 0x60,
+			0x38, 0xb4, 0x5a, 0xc9,
+			0x38, 0xb4, 0x04, 0xf0,
+			0x38, 0xb4, 0x56, 0xc9,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x4e, 0xc9,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x2a, 0x02,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x32, 0x01,
+			0x36, 0xb4, 0x8e, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x8c, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x8a, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x88, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x86, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x84, 0xa0,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x82, 0xa0,
+			0x38, 0xb4, 0x2f, 0x01,
+			0x36, 0xb4, 0x80, 0xa0,
+			0x38, 0xb4, 0xcc, 0x00,
+			0x36, 0xb4, 0x90, 0xa0,
+			0x38, 0xb4, 0x03, 0x01,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x16, 0xa0,
+			0x38, 0xb4, 0x20, 0x00,
+			0x36, 0xb4, 0x12, 0xa0,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x14, 0xa0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x10, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x20, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2a, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x35, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3c, 0x80,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x3c, 0x80,
+			0x38, 0xb4, 0x07, 0xd1,
+			0x38, 0xb4, 0x42, 0xd0,
+			0x38, 0xb4, 0x04, 0xa4,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xdf, 0x09,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x80, 0x82,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0x65, 0x60,
+			0x38, 0xb4, 0x25, 0xd1,
+			0x38, 0xb4, 0x02, 0xf0,
+			0x38, 0xb4, 0x2b, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x7f, 0x07,
+			0x38, 0xb4, 0xf0, 0x0c,
+			0x38, 0xb4, 0x50, 0x0c,
+			0x38, 0xb4, 0x04, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xa8, 0x0a,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x2e, 0x0a,
+			0x38, 0xb4, 0x9b, 0xcb,
+			0x38, 0xb4, 0x10, 0xd1,
+			0x38, 0xb4, 0x40, 0xd0,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0x7b, 0x0b,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xdf, 0x09,
+			0x38, 0xb4, 0x00, 0xd7,
+			0x38, 0xb4, 0xb4, 0x5f,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x1b, 0x08,
+			0x38, 0xb4, 0x00, 0x10,
+			0x38, 0xb4, 0xdf, 0x09,
+			0x38, 0xb4, 0x04, 0xd7,
+			0x38, 0xb4, 0xb8, 0x7f,
+			0x38, 0xb4, 0x18, 0xa7,
+			0x38, 0xb4, 0x00, 0x18,
+			0x38, 0xb4, 0x4e, 0x07,
+			0x36, 0xb4, 0x0e, 0xa1,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x0c, 0xa1,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x0a, 0xa1,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x08, 0xa1,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x06, 0xa1,
+			0x38, 0xb4, 0x4d, 0x07,
+			0x36, 0xb4, 0x04, 0xa1,
+			0x38, 0xb4, 0x18, 0x08,
+			0x36, 0xb4, 0x02, 0xa1,
+			0x38, 0xb4, 0x2c, 0x0a,
+			0x36, 0xb4, 0x00, 0xa1,
+			0x38, 0xb4, 0x7e, 0x07,
+			0x36, 0xb4, 0x10, 0xa1,
+			0x38, 0xb4, 0x0f, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0x25, 0x86,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0x86, 0xaf,
+			0x38, 0xb4, 0xaf, 0x3d,
+			0x38, 0xb4, 0x89, 0x86,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xaf, 0x69,
+			0x38, 0xb4, 0x87, 0x88,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xaf, 0x9c,
+			0x38, 0xb4, 0x9c, 0x88,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xaf, 0x9c,
+			0x38, 0xb4, 0x9c, 0x88,
+			0x38, 0xb4, 0x86, 0xbf,
+			0x38, 0xb4, 0xd7, 0x49,
+			0x38, 0xb4, 0x40, 0x00,
+			0x38, 0xb4, 0x77, 0x02,
+			0x38, 0xb4, 0xaf, 0x7d,
+			0x38, 0xb4, 0x27, 0x27,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x05, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x08, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0xf3, 0x71,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0xf6, 0x71,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x29, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x2c, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x17, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x1a, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x1d, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x11, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x20, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x14, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x2f, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x23, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x32, 0x72,
+			0x38, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x26, 0x72,
+			0x38, 0xb4, 0xf9, 0xf8,
+			0x38, 0xb4, 0xe0, 0xfa,
+			0x38, 0xb4, 0xb3, 0x85,
+			0x38, 0xb4, 0x02, 0x38,
+			0x38, 0xb4, 0x27, 0xad,
+			0x38, 0xb4, 0xae, 0x02,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0x30, 0x88,
+			0x38, 0xb4, 0x66, 0x1f,
+			0x38, 0xb4, 0x65, 0xef,
+			0x38, 0xb4, 0xc2, 0xbf,
+			0x38, 0xb4, 0x1a, 0x1f,
+			0x38, 0xb4, 0xf7, 0x96,
+			0x38, 0xb4, 0xee, 0x05,
+			0x38, 0xb4, 0xd2, 0xff,
+			0x38, 0xb4, 0xda, 0x00,
+			0x38, 0xb4, 0x05, 0xf6,
+			0x38, 0xb4, 0xc2, 0xbf,
+			0x38, 0xb4, 0x1a, 0x2f,
+			0x38, 0xb4, 0xf7, 0x96,
+			0x38, 0xb4, 0xee, 0x05,
+			0x38, 0xb4, 0xd2, 0xff,
+			0x38, 0xb4, 0xdb, 0x00,
+			0x38, 0xb4, 0x05, 0xf6,
+			0x38, 0xb4, 0x02, 0xef,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x42, 0x0d,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x42,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x02, 0xef,
+			0x38, 0xb4, 0x03, 0x1b,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x42, 0x0d,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x45,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x02, 0xef,
+			0x38, 0xb4, 0x03, 0x1a,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x42, 0x0d,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x48,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0xc2, 0xbf,
+			0x38, 0xb4, 0x1a, 0x3f,
+			0x38, 0xb4, 0xf7, 0x96,
+			0x38, 0xb4, 0xee, 0x05,
+			0x38, 0xb4, 0xd2, 0xff,
+			0x38, 0xb4, 0xda, 0x00,
+			0x38, 0xb4, 0x05, 0xf6,
+			0x38, 0xb4, 0xc2, 0xbf,
+			0x38, 0xb4, 0x1a, 0x4f,
+			0x38, 0xb4, 0xf7, 0x96,
+			0x38, 0xb4, 0xee, 0x05,
+			0x38, 0xb4, 0xd2, 0xff,
+			0x38, 0xb4, 0xdb, 0x00,
+			0x38, 0xb4, 0x05, 0xf6,
+			0x38, 0xb4, 0x02, 0xef,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x42, 0x0d,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x4b,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x02, 0xef,
+			0x38, 0xb4, 0x03, 0x1b,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x42, 0x0d,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x4e,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x02, 0xef,
+			0x38, 0xb4, 0x03, 0x1a,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x42, 0x0d,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x51,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x56, 0xef,
+			0x38, 0xb4, 0x20, 0xd0,
+			0x38, 0xb4, 0x11, 0x1f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x54,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x57,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x5a,
+			0xff, 0xff, 0xff, 0xff,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xef, 0xa0,
+			0x38, 0xb4, 0x48, 0x03,
+			0x38, 0xb4, 0x28, 0x0a,
+			0x38, 0xb4, 0xef, 0x05,
+			0x38, 0xb4, 0x1b, 0x20,
+			0x38, 0xb4, 0xad, 0x01,
+			0x38, 0xb4, 0x35, 0x27,
+			0x38, 0xb4, 0x44, 0x1f,
+			0x38, 0xb4, 0x85, 0xe0,
+			0x38, 0xb4, 0xe1, 0x88,
+			0x38, 0xb4, 0x89, 0x85,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x5d,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x85, 0xe0,
+			0x38, 0xb4, 0xe1, 0x8e,
+			0x38, 0xb4, 0x8f, 0x85,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x60,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x85, 0xe0,
+			0x38, 0xb4, 0xe1, 0x94,
+			0x38, 0xb4, 0x95, 0x85,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x63,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x85, 0xe0,
+			0x38, 0xb4, 0xe1, 0x9a,
+			0x38, 0xb4, 0x9b, 0x85,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x66,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xbf, 0x3c,
+			0x38, 0xb4, 0x3f, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xad, 0x9c,
+			0x38, 0xb4, 0x35, 0x28,
+			0x38, 0xb4, 0x44, 0x1f,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xe1, 0xf8,
+			0x38, 0xb4, 0xf9, 0x8f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x5d,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xe1, 0xfa,
+			0x38, 0xb4, 0xfb, 0x8f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x60,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xe1, 0xfc,
+			0x38, 0xb4, 0xfd, 0x8f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x63,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xe1, 0xfe,
+			0x38, 0xb4, 0xff, 0x8f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x66,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x88, 0xaf,
+			0x38, 0xb4, 0xe1, 0x3c,
+			0x38, 0xb4, 0xa1, 0x85,
+			0x38, 0xb4, 0x21, 0x1b,
+			0x38, 0xb4, 0x37, 0xad,
+			0x38, 0xb4, 0x1f, 0x34,
+			0x38, 0xb4, 0xe0, 0x44,
+			0x38, 0xb4, 0x8a, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x8b,
+			0x38, 0xb4, 0x5d, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xe0, 0x7d,
+			0x38, 0xb4, 0x90, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x91,
+			0x38, 0xb4, 0x60, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xe0, 0x7d,
+			0x38, 0xb4, 0x96, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x97,
+			0x38, 0xb4, 0x63, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xe0, 0x7d,
+			0x38, 0xb4, 0x9c, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x9d,
+			0x38, 0xb4, 0x66, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xae, 0x7d,
+			0x38, 0xb4, 0x1f, 0x40,
+			0x38, 0xb4, 0xe0, 0x44,
+			0x38, 0xb4, 0x8c, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x8d,
+			0x38, 0xb4, 0x5d, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xe0, 0x7d,
+			0x38, 0xb4, 0x92, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x93,
+			0x38, 0xb4, 0x60, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xe0, 0x7d,
+			0x38, 0xb4, 0x98, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x99,
+			0x38, 0xb4, 0x63, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xe0, 0x7d,
+			0x38, 0xb4, 0x9e, 0x85,
+			0x38, 0xb4, 0x85, 0xe1,
+			0x38, 0xb4, 0xbf, 0x9f,
+			0x38, 0xb4, 0x66, 0x88,
+			0x38, 0xb4, 0x6e, 0x02,
+			0x38, 0xb4, 0xae, 0x7d,
+			0x38, 0xb4, 0xe1, 0x0c,
+			0x38, 0xb4, 0xb3, 0x85,
+			0x38, 0xb4, 0x04, 0x39,
+			0x38, 0xb4, 0x2f, 0xac,
+			0x38, 0xb4, 0xee, 0x04,
+			0x38, 0xb4, 0xb3, 0x85,
+			0x38, 0xb4, 0xaf, 0x00,
+			0x38, 0xb4, 0xd9, 0x39,
+			0x38, 0xb4, 0xac, 0x22,
+			0x38, 0xb4, 0xf0, 0xea,
+			0x38, 0xb4, 0xf6, 0xac,
+			0x38, 0xb4, 0xac, 0xf0,
+			0x38, 0xb4, 0xf0, 0xfa,
+			0x38, 0xb4, 0xf8, 0xac,
+			0x38, 0xb4, 0xac, 0xf0,
+			0x38, 0xb4, 0xf0, 0xfc,
+			0x38, 0xb4, 0x00, 0xad,
+			0x38, 0xb4, 0xac, 0xf0,
+			0x38, 0xb4, 0xf0, 0xfe,
+			0x38, 0xb4, 0xf0, 0xac,
+			0x38, 0xb4, 0xac, 0xf0,
+			0x38, 0xb4, 0xf0, 0xf4,
+			0x38, 0xb4, 0xf2, 0xac,
+			0x38, 0xb4, 0xac, 0xf0,
+			0x38, 0xb4, 0xf0, 0xb0,
+			0x38, 0xb4, 0xae, 0xac,
+			0x38, 0xb4, 0xac, 0xf0,
+			0x38, 0xb4, 0xf0, 0xac,
+			0x38, 0xb4, 0xaa, 0xac,
+			0x38, 0xb4, 0x00, 0xa1,
+			0x38, 0xb4, 0xe1, 0x0c,
+			0x38, 0xb4, 0xf7, 0x8f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x84,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x26, 0xaf,
+			0x38, 0xb4, 0xe1, 0xe9,
+			0x38, 0xb4, 0xf6, 0x8f,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x84,
+			0x38, 0xb4, 0x7d, 0x6e,
+			0x38, 0xb4, 0x26, 0xaf,
+			0x38, 0xb4, 0x20, 0xf5,
+			0x38, 0xb4, 0x86, 0xac,
+			0x38, 0xb4, 0x88, 0xbf,
+			0x38, 0xb4, 0x02, 0x3f,
+			0x38, 0xb4, 0x9c, 0x6e,
+			0x38, 0xb4, 0x28, 0xad,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0x24, 0x33,
+			0x38, 0xb4, 0x38, 0xad,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0xe6, 0x32,
+			0x38, 0xb4, 0x32, 0xaf,
+			0x38, 0xb4, 0x00, 0xfb,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0xf6, 0x8f,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0x05, 0x07,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0xf8, 0x8f,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0xcc, 0x19,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0xfa, 0x8f,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0xe3, 0x28,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0xfc, 0x8f,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0x47, 0x10,
+			0x36, 0xb4, 0x7c, 0xb8,
+			0x38, 0xb4, 0xfe, 0x8f,
+			0x36, 0xb4, 0x7e, 0xb8,
+			0x38, 0xb4, 0x45, 0x0a,
+			0x36, 0xb4, 0x5e, 0xb8,
+			0x38, 0xb4, 0x1e, 0x27,
+			0x36, 0xb4, 0x60, 0xb8,
+			0x38, 0xb4, 0x46, 0x38,
+			0x36, 0xb4, 0x62, 0xb8,
+			0x38, 0xb4, 0xe6, 0x26,
+			0x36, 0xb4, 0x64, 0xb8,
+			0x38, 0xb4, 0xe3, 0x32,
+			0x36, 0xb4, 0x86, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x88, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x8a, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x8c, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x38, 0xb8,
+			0x38, 0xb4, 0x0f, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x20, 0xb8, 0x10, 0x00,
+			0x6c, 0xe8, 0x00, 0xa0,
+			0x36, 0xb4, 0x6e, 0x84,
+			0x38, 0xb4, 0x84, 0xaf,
+			0x38, 0xb4, 0xaf, 0x86,
+			0x38, 0xb4, 0x90, 0x86,
+			0x38, 0xb4, 0x86, 0xaf,
+			0x38, 0xb4, 0xaf, 0xa4,
+			0x38, 0xb4, 0xa4, 0x86,
+			0x38, 0xb4, 0x86, 0xaf,
+			0x38, 0xb4, 0xaf, 0xa4,
+			0x38, 0xb4, 0xa4, 0x86,
+			0x38, 0xb4, 0x86, 0xaf,
+			0x38, 0xb4, 0xaf, 0xa4,
+			0x38, 0xb4, 0xa4, 0x86,
+			0x38, 0xb4, 0x82, 0xee,
+			0x38, 0xb4, 0x00, 0x5f,
+			0x38, 0xb4, 0x84, 0x02,
+			0x38, 0xb4, 0xaf, 0x90,
+			0x38, 0xb4, 0x41, 0x04,
+			0x38, 0xb4, 0xe0, 0xf8,
+			0x38, 0xb4, 0xf3, 0x8f,
+			0x38, 0xb4, 0x00, 0xa0,
+			0x38, 0xb4, 0x02, 0x05,
+			0x38, 0xb4, 0xa4, 0x84,
+			0x38, 0xb4, 0x06, 0xae,
+			0x38, 0xb4, 0x01, 0xa0,
+			0x38, 0xb4, 0x02, 0x03,
+			0x38, 0xb4, 0xc8, 0x84,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xf9, 0xf8,
+			0x38, 0xb4, 0x59, 0xef,
+			0x38, 0xb4, 0x80, 0xe0,
+			0x38, 0xb4, 0xad, 0x15,
+			0x38, 0xb4, 0x02, 0x27,
+			0x38, 0xb4, 0x03, 0xae,
+			0x38, 0xb4, 0x84, 0xaf,
+			0x38, 0xb4, 0xbf, 0xc3,
+			0x38, 0xb4, 0xca, 0x53,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xad, 0xc8,
+			0x38, 0xb4, 0x07, 0x28,
+			0x38, 0xb4, 0x85, 0x02,
+			0x38, 0xb4, 0xee, 0x2c,
+			0x38, 0xb4, 0xf3, 0x8f,
+			0x38, 0xb4, 0xef, 0x01,
+			0x38, 0xb4, 0xfd, 0x95,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xf9, 0xf8,
+			0x38, 0xb4, 0xef, 0xfa,
+			0x38, 0xb4, 0xbf, 0x69,
+			0x38, 0xb4, 0xca, 0x53,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xac, 0xc8,
+			0x38, 0xb4, 0x22, 0x28,
+			0x38, 0xb4, 0x80, 0xd4,
+			0x38, 0xb4, 0xbf, 0x00,
+			0x38, 0xb4, 0x84, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xbf, 0xa9,
+			0x38, 0xb4, 0x87, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xbf, 0xa9,
+			0x38, 0xb4, 0x8a, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xbf, 0xa9,
+			0x38, 0xb4, 0x8d, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xee, 0xa9,
+			0x38, 0xb4, 0xf3, 0x8f,
+			0x38, 0xb4, 0xaf, 0x00,
+			0x38, 0xb4, 0x26, 0x85,
+			0x38, 0xb4, 0x8f, 0xe0,
+			0x38, 0xb4, 0xe1, 0xf4,
+			0x38, 0xb4, 0xf5, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe2,
+			0x38, 0xb4, 0xe3, 0xf6,
+			0x38, 0xb4, 0xf7, 0x8f,
+			0x38, 0xb4, 0x45, 0x1b,
+			0x38, 0xb4, 0x27, 0xac,
+			0x38, 0xb4, 0xee, 0x0e,
+			0x38, 0xb4, 0xf4, 0x8f,
+			0x38, 0xb4, 0xee, 0x00,
+			0x38, 0xb4, 0xf5, 0x8f,
+			0x38, 0xb4, 0x02, 0x00,
+			0x38, 0xb4, 0x2c, 0x85,
+			0x38, 0xb4, 0x85, 0xaf,
+			0x38, 0xb4, 0xe0, 0x26,
+			0x38, 0xb4, 0xf4, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0x2c, 0xf5,
+			0x38, 0xb4, 0x01, 0x00,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xf4,
+			0x38, 0xb4, 0xf5, 0x8f,
+			0x38, 0xb4, 0x96, 0xef,
+			0x38, 0xb4, 0xfd, 0xfe,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xf9, 0xf8,
+			0x38, 0xb4, 0x59, 0xef,
+			0x38, 0xb4, 0x53, 0xbf,
+			0x38, 0xb4, 0x02, 0x22,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8b, 0xa1,
+			0x38, 0xb4, 0xae, 0x02,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0xda, 0x85,
+			0x38, 0xb4, 0x57, 0xbf,
+			0x38, 0xb4, 0x02, 0x72,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xf8,
+			0x38, 0xb4, 0xf9, 0x8f,
+			0x38, 0xb4, 0x57, 0xbf,
+			0x38, 0xb4, 0x02, 0x75,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xfa,
+			0x38, 0xb4, 0xfb, 0x8f,
+			0x38, 0xb4, 0x57, 0xbf,
+			0x38, 0xb4, 0x02, 0x78,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xfc,
+			0x38, 0xb4, 0xfd, 0x8f,
+			0x38, 0xb4, 0x57, 0xbf,
+			0x38, 0xb4, 0x02, 0x7b,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xfe,
+			0x38, 0xb4, 0xff, 0x8f,
+			0x38, 0xb4, 0x57, 0xbf,
+			0x38, 0xb4, 0x02, 0x6c,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x02, 0xa1,
+			0x38, 0xb4, 0xee, 0x13,
+			0x38, 0xb4, 0xfc, 0x8f,
+			0x38, 0xb4, 0xee, 0x80,
+			0x38, 0xb4, 0xfd, 0x8f,
+			0x38, 0xb4, 0xee, 0x00,
+			0x38, 0xb4, 0xfe, 0x8f,
+			0x38, 0xb4, 0xee, 0x80,
+			0x38, 0xb4, 0xff, 0x8f,
+			0x38, 0xb4, 0xaf, 0x00,
+			0x38, 0xb4, 0x99, 0x85,
+			0x38, 0xb4, 0x01, 0xa1,
+			0x38, 0xb4, 0xbf, 0x0c,
+			0x38, 0xb4, 0x4c, 0x53,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xa1, 0xc8,
+			0x38, 0xb4, 0x03, 0x03,
+			0x38, 0xb4, 0x85, 0xaf,
+			0x38, 0xb4, 0xbf, 0x77,
+			0x38, 0xb4, 0x22, 0x53,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xa1, 0xc8,
+			0x38, 0xb4, 0x02, 0x8b,
+			0x38, 0xb4, 0x03, 0xae,
+			0x38, 0xb4, 0x86, 0xaf,
+			0x38, 0xb4, 0xe0, 0x64,
+			0x38, 0xb4, 0xf8, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0x84, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe0, 0xa9,
+			0x38, 0xb4, 0xfa, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xbf, 0xfb,
+			0x38, 0xb4, 0x87, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe0, 0xa9,
+			0x38, 0xb4, 0xfc, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xbf, 0xfd,
+			0x38, 0xb4, 0x8a, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe0, 0xa9,
+			0x38, 0xb4, 0xfe, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe1,
+			0x38, 0xb4, 0xbf, 0xff,
+			0x38, 0xb4, 0x8d, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xaf, 0xa9,
+			0x38, 0xb4, 0x7f, 0x86,
+			0x38, 0xb4, 0x53, 0xbf,
+			0x38, 0xb4, 0x02, 0x22,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x44, 0xa1,
+			0x38, 0xb4, 0xbf, 0x3c,
+			0x38, 0xb4, 0x7b, 0x54,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe4, 0xc8,
+			0x38, 0xb4, 0xf8, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xbf, 0xf9,
+			0x38, 0xb4, 0x7e, 0x54,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe4, 0xc8,
+			0x38, 0xb4, 0xfa, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xbf, 0xfb,
+			0x38, 0xb4, 0x81, 0x54,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe4, 0xc8,
+			0x38, 0xb4, 0xfc, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xbf, 0xfd,
+			0x38, 0xb4, 0x84, 0x54,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xe4, 0xc8,
+			0x38, 0xb4, 0xfe, 0x8f,
+			0x38, 0xb4, 0x8f, 0xe5,
+			0x38, 0xb4, 0xbf, 0xff,
+			0x38, 0xb4, 0x22, 0x53,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xa1, 0xc8,
+			0x38, 0xb4, 0x48, 0x44,
+			0x38, 0xb4, 0x85, 0xaf,
+			0x38, 0xb4, 0xbf, 0xa7,
+			0x38, 0xb4, 0x22, 0x53,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xa1, 0xc8,
+			0x38, 0xb4, 0x3c, 0x31,
+			0x38, 0xb4, 0x54, 0xbf,
+			0x38, 0xb4, 0x02, 0x7b,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xf8,
+			0x38, 0xb4, 0xf9, 0x8f,
+			0x38, 0xb4, 0x54, 0xbf,
+			0x38, 0xb4, 0x02, 0x7e,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xfa,
+			0x38, 0xb4, 0xfb, 0x8f,
+			0x38, 0xb4, 0x54, 0xbf,
+			0x38, 0xb4, 0x02, 0x81,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xfc,
+			0x38, 0xb4, 0xfd, 0x8f,
+			0x38, 0xb4, 0x54, 0xbf,
+			0x38, 0xb4, 0x02, 0x84,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x8f, 0xe4,
+			0x38, 0xb4, 0xe5, 0xfe,
+			0x38, 0xb4, 0xff, 0x8f,
+			0x38, 0xb4, 0x53, 0xbf,
+			0x38, 0xb4, 0x02, 0x22,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x31, 0xa1,
+			0x38, 0xb4, 0xaf, 0x03,
+			0x38, 0xb4, 0xa7, 0x85,
+			0x38, 0xb4, 0x80, 0xd4,
+			0x38, 0xb4, 0xbf, 0x00,
+			0x38, 0xb4, 0x84, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xbf, 0xa9,
+			0x38, 0xb4, 0x87, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xbf, 0xa9,
+			0x38, 0xb4, 0x8a, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xbf, 0xa9,
+			0x38, 0xb4, 0x8d, 0x86,
+			0x38, 0xb4, 0x52, 0x02,
+			0x38, 0xb4, 0xef, 0xa9,
+			0x38, 0xb4, 0xfd, 0x95,
+			0x38, 0xb4, 0x04, 0xfc,
+			0x38, 0xb4, 0xd1, 0xf0,
+			0x38, 0xb4, 0xf0, 0x2a,
+			0x38, 0xb4, 0x2c, 0xd1,
+			0x38, 0xb4, 0xd1, 0xf0,
+			0x38, 0xb4, 0xf0, 0x44,
+			0x38, 0xb4, 0x46, 0xd1,
+			0x38, 0xb4, 0x86, 0xbf,
+			0x38, 0xb4, 0x02, 0xa1,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x86, 0xbf,
+			0x38, 0xb4, 0x02, 0xa1,
+			0x38, 0xb4, 0xc8, 0x52,
+			0x38, 0xb4, 0x01, 0xd1,
+			0x38, 0xb4, 0x06, 0xaf,
+			0x38, 0xb4, 0x70, 0xa5,
+			0x38, 0xb4, 0x42, 0xce,
+			0x36, 0xb4, 0x18, 0xb8,
+			0x38, 0xb4, 0x3d, 0x04,
+			0x36, 0xb4, 0x1a, 0xb8,
+			0x38, 0xb4, 0xa3, 0x06,
+			0x36, 0xb4, 0x1c, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x1e, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x50, 0xb8,
+			0xff, 0xff, 0xff, 0xff,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x52, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x78, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x84, 0xb8,
+			0x38, 0xb4, 0xff, 0xff,
+			0x36, 0xb4, 0x32, 0xb8,
+			0x38, 0xb4, 0x03, 0x00,
+			0x36, 0xb4, 0x00, 0x00,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x2e, 0xb8,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x24, 0x80,
+			0x38, 0xb4, 0x00, 0x00,
+			0x36, 0xb4, 0x1e, 0x80,
+			0x38, 0xb4, 0x21, 0x00,
+			0x6c, 0xe8, 0x00, 0xb0,
+			0x20, 0xb8, 0x00, 0x00,
+			0xff, 0xff, 0xff, 0xff};
+
+		if (sram_read(tp, SRAM_GPHY_FW_VER) < 0x0021) {
+			data = ram13;
+			len = sizeof(ram13);
+
+			if (r8156b_flash_used(tp)) {
+				u32 ocp_data;
+
+				ocp_data = ocp_read_word(tp, MCU_TYPE_USB,
+							 USB_GPHY_CTRL);
+				ocp_data |= BYPASS_FLASH;
+				ocp_write_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL,
+					       ocp_data);
+			}
+		}
 	}
 
-	r8152_aldps_en(tp, false);
-
-	if (tp->version == RTL_VER_01) {
-		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE);
-		ocp_data &= ~LED_MODE_MASK;
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE, ocp_data);
-	}
+	if (!data)
+		return;
 
-	r8152_power_cut_en(tp, false);
+	if (rtl_phy_patch_request(tp, true, wait))
+		return;
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
-	ocp_data |= TX_10M_IDLE_EN | PFM_PWM_SWITCH;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
-	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL);
-	ocp_data &= ~MCU_CLK_RATIO_MASK;
-	ocp_data |= MCU_CLK_RATIO | D3_CLK_GATED_EN;
-	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL, ocp_data);
-	ocp_data = GPHY_STS_MSK | SPEED_DOWN_MSK |
-		   SPDWN_RXDV_MSK | SPDWN_LINKCHG_MSK;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_GPHY_INTR_IMR, ocp_data);
+	while (len) {
+		u32 size;
+		int i;
 
-	rtl_tally_reset(tp);
+		if (len < 2048)
+			size = len;
+		else
+			size = 2048;
 
-	/* enable rx aggregation */
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
-	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
-	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
-}
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL);
+		ocp_data |= GPHY_PATCH_DONE | BACKUP_RESTRORE;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL, ocp_data);
 
-static void r8153_init(struct r8152 *tp)
-{
-	u32 ocp_data;
-	u16 data;
-	int i;
+		generic_ocp_write(tp, 0x9A00, 0xff, size, data, MCU_TYPE_USB);
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return;
+		data += size;
+		len -= size;
 
-	r8153_u1u2en(tp, false);
+		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL);
+		ocp_data |= POL_GPHY_PATCH;
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL, ocp_data);
 
-	for (i = 0; i < 500; i++) {
-		if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &
-		    AUTOLOAD_DONE)
-			break;
+		for (i = 0; i < 1000; i++) {
+			if (!(ocp_read_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL) & POL_GPHY_PATCH))
+				break;
+		}
 
-		msleep(20);
-		if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		if (i == 1000) {
+			dev_err(&tp->intf->dev, "ram code speedup mode fail\n");
 			break;
+		}
 	}
 
-	data = r8153_phy_status(tp, 0);
+	rtl_reset_ocp_base(tp);
 
-	if (tp->version == RTL_VER_03 || tp->version == RTL_VER_04 ||
-	    tp->version == RTL_VER_05)
-		ocp_reg_write(tp, OCP_ADC_CFG, CKADSEL_L | ADC_EN | EN_EMI_L);
+	rtl_phy_patch_request(tp, false, wait);
+}
 
-	data = r8152_mdio_read(tp, MII_BMCR);
-	if (data & BMCR_PDOWN) {
-		data &= ~BMCR_PDOWN;
-		r8152_mdio_write(tp, MII_BMCR, data);
+static void r8156_ram_code(struct r8152 *tp, bool power_cut)
+{
+	u16 data;
+
+	rtl_reset_ocp_base(tp);
+
+	if (tp->version == RTL_VER_10) {
+		rtl_pre_ram_code(tp, 0x8024, 0x8600, !power_cut);
+
+		data = ocp_reg_read(tp, OCP_PHY_PATCH_CMD);
+		data |= BIT(7);
+		ocp_reg_write(tp, OCP_PHY_PATCH_CMD, data);
+
+		/* nc0_patch_180504_usb */
+		sram_write(tp, 0xA016, 0x0000);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8013);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8021);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x802f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x803d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8042);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8051);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8051);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa088);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a50);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8008);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd707);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40c2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a6c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8080);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd019);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd707);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a84);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8970);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c07);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0901);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcf09);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xceff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf0a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1213);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8580);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1253);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd064);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd181);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4018);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc50f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd706);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2c59);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x804d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc60f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc605);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10fd);
+		sram_write(tp, 0xA026, 0xffff);
+		sram_write(tp, 0xA024, 0xffff);
+		sram_write(tp, 0xA022, 0x10f4);
+		sram_write(tp, 0xA020, 0x1252);
+		sram_write(tp, 0xA006, 0x1206);
+		sram_write(tp, 0xA004, 0x0a78);
+		sram_write(tp, 0xA002, 0x0a60);
+		sram_write(tp, 0xA000, 0x0a4f);
+		sram_write(tp, 0xA008, 0x3f00);
+
+		/* nc1_patch_180423_cml_usb */
+		sram_write(tp, 0xA016, 0x0010);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8066);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x807c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8089);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80b2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80c2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62db);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x655c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd73e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x614a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0505);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0509);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x653c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd73e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x614a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0506);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x050a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd73e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x614a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0505);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0506);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x050c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd73e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x614a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0509);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x050a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x050c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0508);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd73e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x614a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0321);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0321);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0321);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0508);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0321);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0346);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8208);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x609d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa50f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x001a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x001a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x607d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa50f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x017b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a05);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x017b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa50f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a05);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa50f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0231);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a05);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0231);
+		sram_write(tp, 0xA08E, 0xffff);
+		sram_write(tp, 0xA08C, 0x0221);
+		sram_write(tp, 0xA08A, 0x01ce);
+		sram_write(tp, 0xA088, 0x0169);
+		sram_write(tp, 0xA086, 0x00a6);
+		sram_write(tp, 0xA084, 0x000d);
+		sram_write(tp, 0xA082, 0x0308);
+		sram_write(tp, 0xA080, 0x029f);
+		sram_write(tp, 0xA090, 0x007f);
+
+		/* nc2_patch_180508_usb */
+		sram_write(tp, 0xA016, 0x0020);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8017);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8029);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8054);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x805a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8064);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9430);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9480);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb408);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd057);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x064b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9906);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0567);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb94);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8406);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8dff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa840);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0773);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb91);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4063);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd139);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07dc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4045);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x405d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0742);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07ec);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0742);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fb6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07dc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x064b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0481);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x94bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x870c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8220);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x078e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb92);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa840);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4063);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd150);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6121);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6223);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf02f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf00f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d20);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d30);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf005);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa008);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4046);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x405d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0742);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0742);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fb5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ad4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0537);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8840);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x064b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa70c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x890c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8840);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x064b);
+		sram_write(tp, 0xA10E, 0x0642);
+		sram_write(tp, 0xA10C, 0x0686);
+		sram_write(tp, 0xA10A, 0x0788);
+		sram_write(tp, 0xA108, 0x047b);
+		sram_write(tp, 0xA106, 0x065c);
+		sram_write(tp, 0xA104, 0x0769);
+		sram_write(tp, 0xA102, 0x0565);
+		sram_write(tp, 0xA100, 0x06f9);
+		sram_write(tp, 0xA110, 0x00ff);
+
+		/* uc2_patch_180507_usb */
+		sram_write(tp, 0xb87c, 0x8530);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xb87e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3caf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8593);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9caf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85a5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5afb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfb0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x020d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86d7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbe0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x83fc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xda02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdd02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5afb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfd0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x020d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86dd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbe0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x83fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf2f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2cac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x65af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x212b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x022c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86b6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf21);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cd1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x870d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8716);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x871f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x871c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8728);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8725);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8707);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x281c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2b02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd101);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2b02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd101);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4c02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2e02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ab7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf35);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7ff8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86e3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86fb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86e6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86ec);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x025a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0262);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86f2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0262);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86f5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0262);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0262);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0420);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb540);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x53b5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4086);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb540);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb9b5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40c8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb03a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc8b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbac8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb13a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc8b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xba77);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffbd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2677);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffbd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2840);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc8bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc8bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x28bb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa430);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x98b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1eba);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb01e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdcb0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e98);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb09e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbab0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9edc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb09e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x98b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1eba);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb11e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdcb1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e98);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb19e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbab1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9edc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb19e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e22);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb01e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x33b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb09e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x22b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9e33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb09e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e22);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb11e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x33b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1e11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb19e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x22b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9e33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb19e);
+		sram_write(tp, 0xb85e, 0x2f71);
+		sram_write(tp, 0xb860, 0x20d9);
+		sram_write(tp, 0xb862, 0x2109);
+		sram_write(tp, 0xb864, 0x34e7);
+		sram_write(tp, 0xb878, 0x000f);
+
+		data = ocp_reg_read(tp, OCP_PHY_PATCH_CMD);
+		data &= ~BIT(7);
+		ocp_reg_write(tp, OCP_PHY_PATCH_CMD, data);
+
+		rtl_post_ram_code(tp, 0x8024, !power_cut);
+	} else if (tp->version == RTL_VER_11) {
+		rtl_pre_ram_code(tp, 0x8024, 0x8601, !power_cut);
+
+		data = ocp_reg_read(tp, OCP_PHY_PATCH_CMD);
+		data |= BIT(7);
+		ocp_reg_write(tp, OCP_PHY_PATCH_CMD, data);
+
+		/* nc_patch */
+		sram_write(tp, 0xA016, 0x0000);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8093);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8097);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x809d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80aa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x607b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf00e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf01e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x615b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1456);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f2e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf01c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1456);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f2e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf024);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1456);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f2e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf02c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1456);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f2e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf034);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4118);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa410);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4779);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf034);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4118);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac22);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa420);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4559);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf023);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4118);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac44);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa440);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4339);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf012);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd719);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4118);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa480);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xce00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4119);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1456);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc48f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x141b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x121a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd0b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1bb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0898);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd0b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1bb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a0e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd064);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd18a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b7e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x401c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x053b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd500);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0648);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc520);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa201);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x252d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1646);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4006);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1646);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0308);
+		sram_write(tp, 0xA026, 0x0307);
+		sram_write(tp, 0xA024, 0x1645);
+		sram_write(tp, 0xA022, 0x0647);
+		sram_write(tp, 0xA020, 0x053a);
+		sram_write(tp, 0xA006, 0x0b7c);
+		sram_write(tp, 0xA004, 0x0a0c);
+		sram_write(tp, 0xA002, 0x0896);
+		sram_write(tp, 0xA000, 0x11a1);
+		sram_write(tp, 0xA008, 0xff00);
+
+		/* nc1_patch */
+		sram_write(tp, 0xA016, 0x0010);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8015);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x801a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02d7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ed);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0509);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x008f);
+		sram_write(tp, 0xA08E, 0xffff);
+		sram_write(tp, 0xA08C, 0xffff);
+		sram_write(tp, 0xA08A, 0xffff);
+		sram_write(tp, 0xA088, 0xffff);
+		sram_write(tp, 0xA086, 0xffff);
+		sram_write(tp, 0xA084, 0xffff);
+		sram_write(tp, 0xA082, 0x008d);
+		sram_write(tp, 0xA080, 0x00eb);
+		sram_write(tp, 0xA090, 0x0103);
+
+		/* nc2_patch */
+		sram_write(tp, 0xA016, 0x0020);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8018);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8024);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8051);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8055);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8072);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80dc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfffd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfffd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa70c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x890c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8840);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa380);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x066e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb91);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4063);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd139);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x405d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0743);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0743);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fb6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x066e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd158);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03d4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x94bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x870c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8380);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd10d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa220);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd130);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbb80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd074);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x604b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa90c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0556);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb92);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4063);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd116);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd119);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6241);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x63e2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6583);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf054);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x611e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf02f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d50);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf02a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x611e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d20);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf021);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d60);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf01c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x611e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d30);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf013);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d70);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf00e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x611e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf005);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x405d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5ff4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa008);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4046);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0743);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07fb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f6f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f2d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07e8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa740);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0743);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fb5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ad4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0556);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8610);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x066e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1f5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd049);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01ec);
+		sram_write(tp, 0xA10E, 0x01ea);
+		sram_write(tp, 0xA10C, 0x06a9);
+		sram_write(tp, 0xA10A, 0x078a);
+		sram_write(tp, 0xA108, 0x03d2);
+		sram_write(tp, 0xA106, 0x067f);
+		sram_write(tp, 0xA104, 0x0665);
+		sram_write(tp, 0xA102, 0x0000);
+		sram_write(tp, 0xA100, 0x0000);
+		sram_write(tp, 0xA110, 0x00fc);
+
+		/* uc2 */
+		sram_write(tp, 0xb87c, 0x8530);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xb87e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3caf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8545);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x45af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8545);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf900);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa601);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x58f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa080);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x37a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae16);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa188);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x07a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae1c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb463);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6901);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe4b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb463);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe0b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb463);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6901);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe4b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb463);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		sram_write(tp, 0xb85e, 0x03b3);
+		sram_write(tp, 0xb860, 0xffff);
+		sram_write(tp, 0xb862, 0xffff);
+		sram_write(tp, 0xb864, 0xffff);
+		sram_write(tp, 0xb878, 0x0001);
+
+		/* data_ram_patch_v02_usb */
+		sram_write(tp, 0xb892, 0x0000);
+		sram_write(tp, 0xb88e, 0xc089);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xb890);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6050);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f6e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e6e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e6e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1214);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1516);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x171b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b1c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2021);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2224);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2424);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2424);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2424);
+		sram_write(tp, 0xb88e, 0xc018);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xb890);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0af2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d4a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x118d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14f3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x175a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x19c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c26);
+
+		data = ocp_reg_read(tp, OCP_PHY_PATCH_CMD);
+		data &= ~BIT(7);
+		ocp_reg_write(tp, OCP_PHY_PATCH_CMD, data);
+
+		rtl_post_ram_code(tp, 0x8024, !power_cut);
+
+		/* 100M MLT-3 Tx interpolator coefficient */
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0x81b3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0043);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00d6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ec);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00f6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00fb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00fd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00bb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0058);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0029);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0013);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0009);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+	} else if (tp->version == RTL_VER_12) {
+		rtl_pre_ram_code(tp, 0x8024, 0x3700, !power_cut);
+
+		data = ocp_reg_read(tp, OCP_PHY_PATCH_CMD);
+		data |= BIT(7);
+		ocp_reg_write(tp, OCP_PHY_PATCH_CMD, data);
+
+		/* nc_patch */
+		sram_write(tp, 0xA016, 0x0000);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8025);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x803a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8044);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x808d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd712);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4077);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4159);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6099);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f44);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9201);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2425);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ce5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1afb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd712);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4077);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4159);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60b9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2421);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c17);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2425);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3ce5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6072);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x146e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b77);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x665d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x653e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x641f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62c4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6066);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x165a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc101);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1945);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x807d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1945);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2569);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8058);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x807d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc104);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1945);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x807d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1945);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x807d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1945);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fbe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x807d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1945);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd703);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fbd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6018);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x165a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x14f6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1e3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1356);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fbe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1559);
+		sram_write(tp, 0xA026, 0xffff);
+		sram_write(tp, 0xA024, 0xffff);
+		sram_write(tp, 0xA022, 0xffff);
+		sram_write(tp, 0xA020, 0x1557);
+		sram_write(tp, 0xA006, 0x1677);
+		sram_write(tp, 0xA004, 0x0b75);
+		sram_write(tp, 0xA002, 0x1c17);
+		sram_write(tp, 0xA000, 0x1b04);
+		sram_write(tp, 0xA008, 0x1f00);
+
+		/* nc1_patch */
+
+		/* nc2_patch */
+		sram_write(tp, 0xA016, 0x0020);
+		sram_write(tp, 0xA012, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xA014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8010);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x817f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82ab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x83f8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8454);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8459);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8465);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa50c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8310);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4076);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0903);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a4d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f84);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60f3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd413);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd410);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa108);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8108);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa910);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa780);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd14a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd048);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6255);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6326);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f07);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffe2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fab);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xba08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9a08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6535);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd40d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa780);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd14a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd048);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6206);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f47);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8064);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd40e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6073);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4216);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb21);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f9f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd196);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb22);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8910);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb23);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xafc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5dee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb24);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8f1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f6e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa111);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa215);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b43);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8111);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8205);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa104);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8104);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd193);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd046);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb29);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb820);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f65);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9820);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd13d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8149);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa220);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8151);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f51);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f63);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd411);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd409);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0433);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb15);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa508);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a4d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f9f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd115);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd413);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb16);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd17a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb17);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0f80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xafc0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a25);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61ce);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5db4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb18);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b43);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffd6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8f1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa131);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2d5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa407);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa720);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8310);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa308);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8308);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb19);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9503);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b43);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0b86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8111);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82c5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f82);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb1b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb820);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f65);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9820);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb1c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb1d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa220);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1f5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd049);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8221);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f51);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f84);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd14a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd048);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa780);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f94);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6208);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffe9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa406);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa220);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3444);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x827d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f51);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb2f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f63);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd411);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd409);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8406);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9808);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0433);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb30);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8380);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9308);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb301);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd408);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd141);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd043);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ccc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4c81);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x609e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa108);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8108);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa203);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8a0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa111);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8140);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd17a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8101);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8201);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa104);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8104);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa120);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa0f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd193);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd047);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd13d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf024);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8406);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4121);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60f3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa710);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb820);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd71f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f65);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9820);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb34);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6853);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8284);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb35);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd407);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8204);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4215);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1c3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd043);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8304);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4109);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf01e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb36);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd412);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6309);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42c7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8280);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd14a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd048);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a7d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcc55);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6041);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd13d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f71);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb38);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8224);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa288);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x800a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6041);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd415);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a37);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd13d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd04a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb39);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6041);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd17a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd047);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fb4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0560);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa111);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd3f5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd219);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa215);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd30e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd21a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x63e9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f65);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f36);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c35);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8004);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c35);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8001);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4098);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd103);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb401);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa108);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c35);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8108);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8110);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8294);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0bdb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd39c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd210);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd39c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd210);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5fa5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x29b5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x840e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd708);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f4a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1014);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c31);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd709);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7fa4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x901f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c23);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb43);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa508);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3699);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x844a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2109);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ea);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ea);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcb90);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0ca0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x06db);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd1ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd052);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa508);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8718);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa00a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa190);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa2a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa404);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c50);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x09ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a5e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd704);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2e70);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x06da);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f55);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa90c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0645);
+		sram_write(tp, 0xA10E, 0x0644);
+		sram_write(tp, 0xA10C, 0x09e9);
+		sram_write(tp, 0xA10A, 0x06da);
+		sram_write(tp, 0xA108, 0x05e1);
+		sram_write(tp, 0xA106, 0x0be4);
+		sram_write(tp, 0xA104, 0x0435);
+		sram_write(tp, 0xA102, 0x0141);
+		sram_write(tp, 0xA100, 0x026d);
+		sram_write(tp, 0xA110, 0x00ff);
+
+		/* uc2 */
+		sram_write(tp, 0xb87c, 0x85fe);
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0xb87e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x16af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8699);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe5af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x86f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7aaf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x883a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x58af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b6c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd48b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7c02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8644);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2c00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x503c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffd6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x18e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x82fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cd4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b84);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0286);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x442c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x003c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x06ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8299);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8299);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x23dc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcefa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x79fb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc4bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b76);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6dac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2804);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd203);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd201);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbdd8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x19d9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef94);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6d78);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x648a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbdd8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x19d9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef94);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6d78);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x72cd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac50);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x643a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x019f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe4ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4678);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd0ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x97ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfec6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x041f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x771f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x221c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x450d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x481f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7f04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a94);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a94);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac7f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03d7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1c45);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef57);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0272);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe8a7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x941b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x979e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x072d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef76);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef97);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d98);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd400);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xff1d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x941a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x89cf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a75);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b79);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6da1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0005);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa0ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf26);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9aac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x284d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe08f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x10c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe08f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfe10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04c8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67c8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8c02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc4bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6def);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x74e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x830c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad20);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x74ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xccef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x971b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x76ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae13);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef30);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc4ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x46e4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe58f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfce7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xcc10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb8d1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4fbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ec4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef74);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe083);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0cad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2003);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0274);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaccc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef97);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b76);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad5f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x69ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3111);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaed1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0287);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x80af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2293);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfafb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef59);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe080);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x252f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f44);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb91b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x64ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f1d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd688);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2bd7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x882e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0274);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x73ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5008);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x737c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0287);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd0bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x882b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x73e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x824c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf621);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe482);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4cbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8834);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0273);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7cef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x95ff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8f9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfafb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef79);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x737c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f22);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x31ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x12bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8822);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ed6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fba);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac3c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8837);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96d8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x19d9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1616);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdf12);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaecc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7373);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef97);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfffe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0466);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x88f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac8a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x92ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbadd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac6c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6cff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x99ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0030);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd4c3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0000);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00b4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xecee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8298);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1412);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf8bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b5d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6d58);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fb8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2901);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe58f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb8a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0049);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef47);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe483);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8303);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbfc2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x95f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffd2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00d8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf605);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef60);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf728);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf628);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0289);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf89);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0149);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef47);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe483);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8305);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbfc2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x95f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffd2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00d8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf605);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef60);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf729);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf629);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0289);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf89);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96a0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0249);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef47);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe483);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x06e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8307);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbfc2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5f1a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x95f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffd2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00d8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf605);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f11);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef60);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c6d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf72a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf62a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0c64);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef46);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0289);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x9902);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3920);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf89);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x96ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x47e4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8308);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe583);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x09bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc25f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a95);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd200);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd8f6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x051f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x60bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b30);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ebf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6df7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2bbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ef6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2bbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b33);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4e0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x64ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x46bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b69);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4e02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8999);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0239);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x20af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8996);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf39);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1ef8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9fa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe08f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb838);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x201f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x66ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x65bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc21f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd200);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdaf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc22f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd200);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdbf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x110d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b3c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x031f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x110d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b36);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x031f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x110d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b39);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ebf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc23f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd200);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdaf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc24f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a96);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeeff);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd200);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xdbf6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x05ef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x110d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b45);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x031f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x110d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b3f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x021a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x031f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x110d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x42bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b42);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4eef);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x56d0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x201f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x11bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ebf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ebf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b4b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ee1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8578);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef03);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x480a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2805);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xef20);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1b01);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad27);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3f1f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x44e0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8560);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x61bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b51);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8566);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b54);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x856c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6dbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b57);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ee0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8572);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x73bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b5a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x026c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4ee1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fb8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5900);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf728);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe58f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb8af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8b2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe185);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x791b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x21ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x373e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f44);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x62e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8563);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x68e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8569);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6ee1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x856f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x74e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8575);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb859);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x28e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fb8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae4a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1f44);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x64e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8565);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6ae1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x856b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x70e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8571);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe085);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x76e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8577);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6c4e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb859);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00f7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x28e5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8fb8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae0c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb839);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x04ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2f04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfefd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfc04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8efc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac8c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfaf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xacf8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf6f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfef0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xacfc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf4f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xacf2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xacb0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaef0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xacac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaaf0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xacee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x24f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb0a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0b1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x24f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb1a4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xee8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd400);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3976);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x66ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xeabb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa430);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e50);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e53);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e56);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e59);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e5c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e5f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e62);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6e65);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd9ac);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x70f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac6a);
+		sram_write(tp, 0xb85e, 0x23b7);
+		sram_write(tp, 0xb860, 0x74db);
+		sram_write(tp, 0xb862, 0x268c);
+		sram_write(tp, 0xb864, 0x3FE5);
+		sram_write(tp, 0xb886, 0x2250);
+		sram_write(tp, 0xb888, 0x140e);
+		sram_write(tp, 0xb88a, 0x3696);
+		sram_write(tp, 0xb88c, 0x3973);
+		sram_write(tp, 0xb838, 0x00ff);
+
+		data = ocp_reg_read(tp, OCP_PHY_PATCH_CMD);
+		data &= ~BIT(7);
+		ocp_reg_write(tp, OCP_PHY_PATCH_CMD, data);
+
+		/* uc */
+		ocp_reg_write(tp, OCP_SRAM_ADDR, 0x8464);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf84);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7caf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8485);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x13af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x851e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb9af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8684);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf87);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x01af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8701);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xac38);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x38bb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf38);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4618);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0a02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd400);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0fbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8507);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8504);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6759);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3008);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae06);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0d02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa183);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x15a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae10);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x59f0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa180);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x16bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8501);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x381b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae0b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xffbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x84fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x17bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x84fe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0254);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x84fb);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0254);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb7ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x09a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x5006);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf84);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfb02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf04);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4700);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad34);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0670);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae14);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf0a6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00b8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x30bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x30aa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xccbd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2ca1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x0705);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xec80);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf40);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf7af);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x40f5);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd101);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd10f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6abf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddd1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85aa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4d6a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbdd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfcdd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfddd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfedd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf3c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x2066);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb800);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb8bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x30ee);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb8bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7040);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc8bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8640);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbd88);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xc8bd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1929);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa202);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x03a2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x032e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd10f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf7bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf9bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae2c);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfdbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffe);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7e02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa100);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x02ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x25a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x041d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf1bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8675);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff2);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf3bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x867b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48ae);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x29a1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x070b);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xae24);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8102);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad28);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1be1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff4);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7502);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xe18f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xf5bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8678);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x48e1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf86);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x7b02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf09);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8420);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbc32);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x20bc);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x3e76);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbc08);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfda6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x1a00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb64e);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd101);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa402);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54c0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xd10f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaa02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f48);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024d);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x6abf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85ad);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b0);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff8);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b3);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ff9);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddbf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85b6);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x67bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8ffa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xddd1);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x00bf);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x85aa);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x024f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4802);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4d6a);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xad02);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfbdd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb002);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfcdd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb302);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfddd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xb602);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x4f67);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf8f);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xfedd);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xbf85);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xa702);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x54b7);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0xaf00);
+		ocp_reg_write(tp, OCP_SRAM_DATA, 0x8800);
+		sram_write(tp, 0xb818, 0x38b8);
+		sram_write(tp, 0xb81a, 0x0444);
+		sram_write(tp, 0xb81c, 0x40ee);
+		sram_write(tp, 0xb81e, 0x3C1A);
+		sram_write(tp, 0xb850, 0x0981);
+		sram_write(tp, 0xb852, 0x0085);
+		sram_write(tp, 0xb878, 0xffff);
+		sram_write(tp, 0xb884, 0xffff);
+		sram_write(tp, 0xb832, 0x003f);
+
+		rtl_post_ram_code(tp, 0x8024, !power_cut);
+	} else {
+		rtl_ram_code_speed_up(tp, !power_cut);
 	}
 
-	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+	rtl_reset_ocp_base(tp);
+}
 
-	r8153_u2p3en(tp, false);
+static void r8156_hw_phy_cfg(struct r8152 *tp)
+{
+	u32 ocp_data;
+	u16 data;
 
-	if (tp->version == RTL_VER_04) {
-		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2);
-		ocp_data &= ~pwd_dn_scale_mask;
-		ocp_data |= pwd_dn_scale(96);
-		ocp_write_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2, ocp_data);
-
-		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_USB2PHY);
-		ocp_data |= USB2PHY_L1 | USB2PHY_SUSPEND;
-		ocp_write_byte(tp, MCU_TYPE_USB, USB_USB2PHY, ocp_data);
-	} else if (tp->version == RTL_VER_05) {
-		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_DMY_REG0);
-		ocp_data &= ~ECM_ALDPS;
-		ocp_write_byte(tp, MCU_TYPE_PLA, PLA_DMY_REG0, ocp_data);
-
-		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1);
-		if (ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE) == 0)
-			ocp_data &= ~DYNAMIC_BURST;
-		else
-			ocp_data |= DYNAMIC_BURST;
-		ocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1, ocp_data);
-	} else if (tp->version == RTL_VER_06) {
-		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1);
-		if (ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE) == 0)
-			ocp_data &= ~DYNAMIC_BURST;
-		else
-			ocp_data |= DYNAMIC_BURST;
-		ocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1, ocp_data);
-
-		r8153_queue_wake(tp, false);
-
-		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);
-		if (rtl8152_get_speed(tp) & LINK_STATUS)
-			ocp_data |= CUR_LINK_OK;
-		else
-			ocp_data &= ~CUR_LINK_OK;
-		ocp_data |= POLL_LINK_CHG;
-		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);
-	}
-
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY2);
-	ocp_data |= EP4_FULL_FC;
-	ocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY2, ocp_data);
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_WDT11_CTRL);
-	ocp_data &= ~TIMER11_EN;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_WDT11_CTRL, ocp_data);
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE);
-	ocp_data &= ~LED_MODE_MASK;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE, ocp_data);
-
-	ocp_data = FIFO_EMPTY_1FB | ROK_EXIT_LPM;
-	if (tp->version == RTL_VER_04 && tp->udev->speed < USB_SPEED_SUPER)
-		ocp_data |= LPM_TIMER_500MS;
-	else
-		ocp_data |= LPM_TIMER_500US;
-	ocp_write_byte(tp, MCU_TYPE_USB, USB_LPM_CTRL, ocp_data);
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_AFE_CTRL2);
-	ocp_data &= ~SEN_VAL_MASK;
-	ocp_data |= SEN_VAL_NORMAL | SEL_RXIDLE;
-	ocp_write_word(tp, MCU_TYPE_USB, USB_AFE_CTRL2, ocp_data);
-
-	ocp_write_word(tp, MCU_TYPE_USB, USB_CONNECT_TIMER, 0x0001);
-
-	r8153_power_cut_en(tp, false);
-	rtl_runtime_suspend_enable(tp, false);
-	r8153_mac_clk_speed_down(tp, false);
-	r8153_u1u2en(tp, true);
-	usb_enable_lpm(tp->udev);
-
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6);
-	ocp_data |= LANWAKE_CLR_EN;
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6, ocp_data);
-
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG);
-	ocp_data &= ~LANWAKE_PIN;
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG, ocp_data);
-
-	/* rx aggregation */
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
-	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
-	if (tp->dell_tb_rx_agg_bug)
-		ocp_data |= RX_AGG_DISABLE;
-
-	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
-
-	rtl_tally_reset(tp);
-
-	switch (tp->udev->speed) {
-	case USB_SPEED_SUPER:
-	case USB_SPEED_SUPER_PLUS:
-		tp->coalesce = COALESCE_SUPER;
-		break;
-	case USB_SPEED_HIGH:
-		tp->coalesce = COALESCE_HIGH;
-		break;
-	default:
-		tp->coalesce = COALESCE_SLOW;
-		break;
-	}
-}
-
-static void r8153b_init(struct r8152 *tp)
-{
-	u32 ocp_data;
-	u16 data;
-	int i;
-
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return;
-
-	r8153b_u1u2en(tp, false);
-
-	for (i = 0; i < 500; i++) {
-		if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &
-		    AUTOLOAD_DONE)
-			break;
-
-		msleep(20);
-		if (test_bit(RTL8152_UNPLUG, &tp->flags))
-			break;
-	}
-
-	data = r8153_phy_status(tp, 0);
-
-	data = r8152_mdio_read(tp, MII_BMCR);
-	if (data & BMCR_PDOWN) {
-		data &= ~BMCR_PDOWN;
-		r8152_mdio_write(tp, MII_BMCR, data);
-	}
-
-	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
-
-	r8153_u2p3en(tp, false);
-
-	/* MSC timer = 0xfff * 8ms = 32760 ms */
-	ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
-
-	r8153b_power_cut_en(tp, false);
-	r8153b_ups_en(tp, false);
-	r8153_queue_wake(tp, false);
-	rtl_runtime_suspend_enable(tp, false);
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);
-	if (rtl8152_get_speed(tp) & LINK_STATUS)
-		ocp_data |= CUR_LINK_OK;
-	else
-		ocp_data &= ~CUR_LINK_OK;
-	ocp_data |= POLL_LINK_CHG;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);
-
-	if (tp->udev->speed >= USB_SPEED_SUPER)
-		r8153b_u1u2en(tp, true);
-
-	usb_enable_lpm(tp->udev);
-
-	/* MAC clock speed down */
-	r8153_mac_clk_speed_down(tp, true);
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
-	ocp_data &= ~PLA_MCU_SPDWN_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
-
-	if (tp->version == RTL_VER_09) {
-		/* Disable Test IO for 32QFN */
-		if (ocp_read_byte(tp, MCU_TYPE_PLA, 0xdc00) & BIT(5)) {
-			ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
-			ocp_data |= TEST_IO_OFF;
-			ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
-		}
-	}
-
-	set_bit(GREEN_ETHERNET, &tp->flags);
-
-	/* rx aggregation */
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
-	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
-	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
-
-	rtl_tally_reset(tp);
-
-	tp->coalesce = 15000;	/* 15 us */
-}
-
-static void r8153c_init(struct r8152 *tp)
-{
-	u32 ocp_data;
-	u16 data;
-	int i;
-
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return;
-
-	r8153b_u1u2en(tp, false);
-
-	/* Disable spi_en */
-	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5);
-	ocp_data &= ~BIT(3);
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG5, ocp_data);
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xcbf0);
-	ocp_data |= BIT(1);
-	ocp_write_word(tp, MCU_TYPE_USB, 0xcbf0, ocp_data);
-
-	for (i = 0; i < 500; i++) {
-		if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &
-		    AUTOLOAD_DONE)
-			break;
-
-		msleep(20);
-		if (test_bit(RTL8152_UNPLUG, &tp->flags))
-			return;
-	}
-
-	data = r8153_phy_status(tp, 0);
-
-	data = r8152_mdio_read(tp, MII_BMCR);
-	if (data & BMCR_PDOWN) {
-		data &= ~BMCR_PDOWN;
-		r8152_mdio_write(tp, MII_BMCR, data);
-	}
-
-	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
-
-	r8153_u2p3en(tp, false);
-
-	/* MSC timer = 0xfff * 8ms = 32760 ms */
-	ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
-
-	r8153b_power_cut_en(tp, false);
-	r8153c_ups_en(tp, false);
-	r8153_queue_wake(tp, false);
-	rtl_runtime_suspend_enable(tp, false);
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);
-	if (rtl8152_get_speed(tp) & LINK_STATUS)
-		ocp_data |= CUR_LINK_OK;
-	else
-		ocp_data &= ~CUR_LINK_OK;
-
-	ocp_data |= POLL_LINK_CHG;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);
-
-	r8153b_u1u2en(tp, true);
-
-	usb_enable_lpm(tp->udev);
-
-	/* MAC clock speed down */
-	r8153_mac_clk_speed_down(tp, true);
-
-	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);
-	ocp_data &= ~BIT(7);
-	ocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);
-
-	set_bit(GREEN_ETHERNET, &tp->flags);
-
-	/* rx aggregation */
-	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
-	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
-	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
-
-	rtl_tally_reset(tp);
-
-	tp->coalesce = 15000;	/* 15 us */
-}
-
-static void r8156_hw_phy_cfg(struct r8152 *tp)
-{
-	u32 ocp_data;
-	u16 data;
+	r8156_patch_code(tp);
 
 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);
 	if (ocp_data & PCUT_STATUS) {
@@ -7232,7 +16949,7 @@ static void r8156_hw_phy_cfg(struct r8152 *tp)
 	data = r8153_phy_status(tp, 0);
 	switch (data) {
 	case PHY_STAT_EXT_INIT:
-		rtl8152_apply_firmware(tp, true);
+		r8156_ram_code(tp, true);
 
 		data = ocp_reg_read(tp, 0xa468);
 		data &= ~(BIT(3) | BIT(1));
@@ -7241,7 +16958,7 @@ static void r8156_hw_phy_cfg(struct r8152 *tp)
 	case PHY_STAT_LAN_ON:
 	case PHY_STAT_PWRDN:
 	default:
-		rtl8152_apply_firmware(tp, false);
+		r8156_ram_code(tp, false);
 		break;
 	}
 
@@ -7363,6 +17080,7 @@ static void r8156_hw_phy_cfg(struct r8152 *tp)
 		ocp_reg_write(tp, 0xbd2c, data);
 		break;
 	case RTL_VER_11:
+		/* 2.5G INRX */
 		data = ocp_reg_read(tp, 0xad16);
 		data |= 0x3ff;
 		ocp_reg_write(tp, 0xad16, data);
@@ -7538,6 +17256,11 @@ static void r8156_hw_phy_cfg(struct r8152 *tp)
 				      ((swap_a & 0x1f) << 8) |
 				      ((swap_a >> 8) & 0x1f));
 		}
+
+		/* Notify the MAC when the speed is changed to force mode. */
+		data = ocp_reg_read(tp, OCP_INTR_EN);
+		data |= INTR_SPEED_FORCE;
+		ocp_reg_write(tp, OCP_INTR_EN, data);
 		break;
 	default:
 		break;
@@ -7568,6 +17291,8 @@ static void r8156b_hw_phy_cfg(struct r8152 *tp)
 	u32 ocp_data;
 	u16 data;
 
+	r8156_patch_code(tp);
+
 	switch (tp->version) {
 	case RTL_VER_12:
 		ocp_reg_write(tp, 0xbf86, 0x9000);
@@ -7604,7 +17329,7 @@ static void r8156b_hw_phy_cfg(struct r8152 *tp)
 	data = r8153_phy_status(tp, 0);
 	switch (data) {
 	case PHY_STAT_EXT_INIT:
-		rtl8152_apply_firmware(tp, true);
+		r8156_ram_code(tp, true);
 
 		data = ocp_reg_read(tp, 0xa466);
 		data &= ~BIT(0);
@@ -7617,7 +17342,7 @@ static void r8156b_hw_phy_cfg(struct r8152 *tp)
 	case PHY_STAT_LAN_ON:
 	case PHY_STAT_PWRDN:
 	default:
-		rtl8152_apply_firmware(tp, false);
+		r8156_ram_code(tp, false);
 		break;
 	}
 
@@ -7933,6 +17658,11 @@ static void r8156b_hw_phy_cfg(struct r8152 *tp)
 		break;
 	}
 
+	/* Notify the MAC when the speed is changed to force mode. */
+	data = ocp_reg_read(tp, OCP_INTR_EN);
+	data |= INTR_SPEED_FORCE;
+	ocp_reg_write(tp, OCP_INTR_EN, data);
+
 	if (rtl_phy_patch_request(tp, true, true))
 		return;
 
@@ -7975,13 +17705,163 @@ static void r8156b_hw_phy_cfg(struct r8152 *tp)
 	set_bit(PHY_RESET, &tp->flags);
 }
 
-static void r8156_init(struct r8152 *tp)
+static void r8156_hw_phy_cfg_test(struct r8152 *tp)
 {
 	u32 ocp_data;
 	u16 data;
-	int i;
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+	data = r8153_phy_status(tp, PHY_STAT_LAN_ON);
+
+	/* disable ALDPS before updating the PHY parameters */
+	r8153_aldps_en(tp, false);
+
+	/* disable EEE before updating the PHY parameters */
+	r8153_eee_en(tp, false);
+	ocp_reg_write(tp, OCP_EEE_ADV, 0);
+
+	r8156_firmware(tp);
+
+	data = ocp_reg_read(tp, 0xa5d4);
+	data |= BIT(7) | BIT(0);
+	ocp_reg_write(tp, 0xa5d4, data);
+	ocp_reg_write(tp, 0xa5e6, 0x6290);
+
+	data = ocp_reg_read(tp, 0xa5e8);
+	data &= ~BIT(3);
+	ocp_reg_write(tp, 0xa5e8, data);
+	data = ocp_reg_read(tp, 0xa428);
+	data |= BIT(9);
+	ocp_reg_write(tp, 0xa428, data);
+
+	ocp_reg_write(tp, 0xb636, 0x2c00);
+	data = ocp_reg_read(tp, 0xb460);
+	data &= ~BIT(13);
+	ocp_reg_write(tp, 0xb460, data);
+	ocp_reg_write(tp, 0xb83e, 0x00a9);
+	ocp_reg_write(tp, 0xb840, 0x0035);
+	ocp_reg_write(tp, 0xb680, 0x0022);
+	ocp_reg_write(tp, 0xb468, 0x10c0);
+	ocp_reg_write(tp, 0xb468, 0x90c0);
+
+	data = ocp_reg_read(tp, 0xb60a);
+	data &= ~0xfff;
+	data |= 0xc0;
+	ocp_reg_write(tp, 0xb60a, data);
+	data = ocp_reg_read(tp, 0xb628);
+	data &= ~0xfff;
+	data |= 0xc0;
+	ocp_reg_write(tp, 0xb628, data);
+	data = ocp_reg_read(tp, 0xb62a);
+	data &= ~0xfff;
+	data |= 0xc0;
+	ocp_reg_write(tp, 0xb62a, data);
+
+	data = ocp_reg_read(tp, 0xbc1e);
+	data &= 0xf;
+	data |= (data << 4) | (data << 8) | (data << 12);
+	ocp_reg_write(tp, 0xbce0, data);
+	data = ocp_reg_read(tp, 0xbd42);
+	data &= ~BIT(8);
+	ocp_reg_write(tp, 0xbd42, data);
+
+	data = ocp_reg_read(tp, 0xbf90);
+	data &= ~0xf0;
+	data |= BIT(7);
+	ocp_reg_write(tp, 0xbf90, data);
+	data = ocp_reg_read(tp, 0xbf92);
+	data &= ~0x3f;
+	data |= 0x3fc0;
+	ocp_reg_write(tp, 0xbf92, data);
+
+	data = ocp_reg_read(tp, 0xbf94);
+	data |= 0x3e00;
+	ocp_reg_write(tp, 0xbf94, data);
+	data = ocp_reg_read(tp, 0xbf88);
+	data &= ~0x3eff;
+	data |= 0x1e01;
+	ocp_reg_write(tp, 0xbf88, data);
+
+	data = ocp_reg_read(tp, 0xbc58);
+	data &= ~BIT(1);
+	ocp_reg_write(tp, 0xbc58, data);
+
+	data = ocp_reg_read(tp, 0xbd0c);
+	data &= ~0x3f;
+	ocp_reg_write(tp, 0xbd0c, data);
+
+	data = ocp_reg_read(tp, 0xbcc2);
+	data &= ~BIT(14);
+	ocp_reg_write(tp, 0xbcc2, data);
+
+	ocp_reg_write(tp, 0xd098, 0x0427);
+
+	data = ocp_reg_read(tp, 0xa430);
+	data &= ~BIT(12);
+	ocp_reg_write(tp, 0xa430, data);
+
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, 0xe84c);
+	ocp_data |= BIT(6);
+	ocp_write_dword(tp, MCU_TYPE_PLA, 0xe84c, ocp_data);
+
+	data = ocp_reg_read(tp, 0xbeb4);
+	data &= ~BIT(1);
+	ocp_reg_write(tp, 0xbeb4, data);
+	data = ocp_reg_read(tp, 0xbf0c);
+	data &= ~BIT(13);
+	data |= BIT(12);
+	ocp_reg_write(tp, 0xbf0c, data);
+	data = ocp_reg_read(tp, 0xbd44);
+	data &= ~BIT(2);
+	ocp_reg_write(tp, 0xbd44, data);
+
+	data = ocp_reg_read(tp, 0xa442);
+	data |= BIT(11);
+	ocp_reg_write(tp, 0xa442, data);
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, 0xe84c);
+	ocp_data |= BIT(7);
+	ocp_write_dword(tp, MCU_TYPE_PLA, 0xe84c, ocp_data);
+
+	r8156_lock_main(tp, true);
+	data = ocp_reg_read(tp, 0xcc46);
+	data &= ~0x700;
+	ocp_reg_write(tp, 0xcc46, data);
+	data = ocp_reg_read(tp, 0xcc46);
+	data &= ~0x70;
+	ocp_reg_write(tp, 0xcc46, data);
+	data = ocp_reg_read(tp, 0xcc46);
+	data &= ~0x70;
+	data |= BIT(6) | BIT(4);
+	ocp_reg_write(tp, 0xcc46, data);
+	r8156_lock_main(tp, false);
+
+	data = ocp_reg_read(tp, 0xbd38);
+	data &= ~BIT(13);
+	ocp_reg_write(tp, 0xbd38, data);
+	data = ocp_reg_read(tp, 0xbd38);
+	data |= BIT(12);
+	ocp_reg_write(tp, 0xbd38, data);
+	ocp_reg_write(tp, 0xbd36, 0x0fb4);
+	data = ocp_reg_read(tp, 0xbd38);
+	data |= BIT(13);
+	ocp_reg_write(tp, 0xbd38, data);
+
+//	if (tp->eee_en) {
+//		r8153_eee_en(tp, true);
+//		ocp_reg_write(tp, OCP_EEE_ADV, tp->eee_adv);
+//	}
+
+	r8153_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
+	r8153_u2p3en(tp, true);
+}
+
+static void r8156_init(struct r8152 *tp)
+{
+	u32 ocp_data;
+	u16 data;
+	int i;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
 		return;
 
 	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_ECM_OP);
@@ -8040,17 +17920,43 @@ static void r8156_init(struct r8152 *tp)
 
 	usb_enable_lpm(tp->udev);
 
-	r8156_mac_clk_spd(tp, true);
+//	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xd850) & 0xc000;
+//	switch (ocp_data) {
+//	case 0x4000:
+//		tp->dash_mode = 1;
+//		r8156_mac_clk_spd(tp, false);
+//		break;
+//	case 0x8000:
+//		tp->dash_mode = 0;
+		r8156_mac_clk_spd(tp, false);
+//		break;
+//	default:
+//		netif_warn(tp, drv, tp->netdev, "Invalid type %x\n", ocp_data);
+//		break;
+//	}
+
+
+	r8153b_mcu_spdown_en(tp, false);
+
+	/* enable fc timer and set timer to 1s. */
+	ocp_write_word(tp, MCU_TYPE_USB, USB_FC_TIMER,
+		       CTRL_TIMER_EN | (1000 / 8));
 
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
-	ocp_data &= ~PLA_MCU_SPDWN_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);
+	ocp_data |= FC_PATCH_TASK;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_CTRL);
+	ocp_data |= FLOW_CTRL_PATCH_OPT;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_CTRL, ocp_data);
 
 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);
 	if (rtl8152_get_speed(tp) & LINK_STATUS)
 		ocp_data |= CUR_LINK_OK;
 	else
 		ocp_data &= ~CUR_LINK_OK;
+	/* r8153_queue_wake() has cleared this bit */
+	/* ocp_data &= ~BIT(8); */
 	ocp_data |= POLL_LINK_CHG;
 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);
 
@@ -8061,6 +17967,12 @@ static void r8156_init(struct r8152 *tp)
 	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
 	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
 
+	/* Set Rx aggregation parameters to default value
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, 0xd4c9);
+	ocp_data |= BIT(2);
+	ocp_write_byte(tp, MCU_TYPE_USB, 0xd4c9, ocp_data);
+	*/
+
 	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_BMU_CONFIG);
 	ocp_data |= ACT_ODMA;
 	ocp_write_byte(tp, MCU_TYPE_USB, USB_BMU_CONFIG, ocp_data);
@@ -8174,17 +18086,16 @@ static void r8156b_init(struct r8152 *tp)
 	ocp_data |= FC_PATCH_TASK;
 	ocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);
 
-	r8156_mac_clk_spd(tp, true);
-
-	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
-	ocp_data &= ~PLA_MCU_SPDWN_EN;
-	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);
+	r8156_mac_clk_spd(tp, false);
+	r8153b_mcu_spdown_en(tp, false);
 
 	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);
 	if (rtl8152_get_speed(tp) & LINK_STATUS)
 		ocp_data |= CUR_LINK_OK;
 	else
 		ocp_data &= ~CUR_LINK_OK;
+	/* r8153_queue_wake() has cleared this bit */
+	/* ocp_data &= ~BIT(8); */
 	ocp_data |= POLL_LINK_CHG;
 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);
 
@@ -8195,6 +18106,12 @@ static void r8156b_init(struct r8152 *tp)
 	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
 	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
 
+	/* Set Rx aggregation parameters to default value
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, 0xd4c9);
+	ocp_data |= BIT(2);
+	ocp_write_byte(tp, MCU_TYPE_USB, 0xd4c9, ocp_data);
+	*/
+
 	r8156_mdio_force_mode(tp);
 	rtl_tally_reset(tp);
 
@@ -8204,6 +18121,64 @@ static void r8156b_init(struct r8152 *tp)
 static bool rtl_check_vendor_ok(struct usb_interface *intf)
 {
 	struct usb_host_interface *alt = intf->cur_altsetting;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+	struct usb_host_endpoint *in = NULL, *out = NULL, *intr = NULL;
+	unsigned int ep;
+
+	if (alt->desc.bNumEndpoints < 3) {
+		dev_err(&intf->dev, "Unexpected bNumEndpoints %d\n", alt->desc.bNumEndpoints);
+		return false;
+	}
+
+	for (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {
+		struct usb_host_endpoint *e;
+
+		e = alt->endpoint + ep;
+
+		/* ignore endpoints which cannot transfer data */
+		if (!usb_endpoint_maxp(&e->desc))
+			continue;
+
+		switch (e->desc.bmAttributes) {
+		case USB_ENDPOINT_XFER_INT:
+			if (!usb_endpoint_dir_in(&e->desc))
+				continue;
+			if (!intr)
+				intr = e;
+			break;
+		case USB_ENDPOINT_XFER_BULK:
+			if (usb_endpoint_dir_in(&e->desc)) {
+				if (!in)
+					in = e;
+			} else if (!out) {
+				out = e;
+			}
+			break;
+		default:
+			continue;
+		}
+	}
+
+	if (!in || !out || !intr) {
+		dev_err(&intf->dev, "Miss Endpoints\n");
+		return false;
+	}
+
+	if ((in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) != 1) {
+		dev_err(&intf->dev, "Invalid Rx endpoint address\n");
+		return false;
+	}
+
+	if ((out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) != 2) {
+		dev_err(&intf->dev, "Invalid Tx endpoint address\n");
+		return false;
+	}
+
+	if ((intr->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) != 3) {
+		dev_err(&intf->dev, "Invalid interrupt endpoint address\n");
+		return false;
+	}
+#else
 	struct usb_endpoint_descriptor *in, *out, *intr;
 
 	if (usb_find_common_endpoints(alt, &in, &out, &intr, NULL) < 0) {
@@ -8228,10 +18203,12 @@ static bool rtl_check_vendor_ok(struct usb_interface *intf)
 		dev_err(&intf->dev, "Invalid interrupt endpoint address\n");
 		return false;
 	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0) */
 
 	return true;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0)
 static bool rtl_vendor_mode(struct usb_interface *intf)
 {
 	struct usb_host_interface *alt = intf->cur_altsetting;
@@ -8242,6 +18219,9 @@ static bool rtl_vendor_mode(struct usb_interface *intf)
 	if (alt->desc.bInterfaceClass == USB_CLASS_VENDOR_SPEC)
 		return rtl_check_vendor_ok(intf);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	dev_err(&intf->dev, "The kernel is too old to set configuration\n");
+#else
 	/* The vendor mode is not always config #1, so to find it out. */
 	udev = interface_to_usbdev(intf);
 	c = udev->config;
@@ -8265,9 +18245,11 @@ static bool rtl_vendor_mode(struct usb_interface *intf)
 
 	if (i == num_configs)
 		dev_err(&intf->dev, "Unexpected Device\n");
+#endif
 
 	return false;
 }
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0) */
 
 static int rtl8152_pre_reset(struct usb_interface *intf)
 {
@@ -8283,7 +18265,9 @@ static int rtl8152_pre_reset(struct usb_interface *intf)
 
 	netif_stop_queue(netdev);
 	tasklet_disable(&tp->tx_tl);
+	smp_mb__before_atomic();
 	clear_bit(WORK_ENABLE, &tp->flags);
+	smp_mb__after_atomic();
 	usb_kill_urb(tp->intr_urb);
 	cancel_delayed_work_sync(&tp->schedule);
 	napi_disable(&tp->napi);
@@ -8308,7 +18292,11 @@ static int rtl8152_post_reset(struct usb_interface *intf)
 	/* reset the MAC address in case of policy change */
 	if (determine_ethernet_addr(tp, &sa) >= 0) {
 		rtnl_lock();
-		dev_set_mac_address (tp->netdev, &sa, NULL);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+		dev_set_mac_address(tp->netdev, &sa);
+#else
+		dev_set_mac_address(tp->netdev, &sa, NULL);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0) */
 		rtnl_unlock();
 	}
 
@@ -8316,12 +18304,14 @@ static int rtl8152_post_reset(struct usb_interface *intf)
 	if (!netif_running(netdev))
 		return 0;
 
+	smp_mb__before_atomic();
 	set_bit(WORK_ENABLE, &tp->flags);
+	smp_mb__after_atomic();
 	if (netif_carrier_ok(netdev)) {
 		mutex_lock(&tp->control);
 		tp->rtl_ops.enable(tp);
 		rtl_start_rx(tp);
-		_rtl8152_set_rx_mode(netdev);
+		rtl8152_set_rx_mode(netdev);
 		mutex_unlock(&tp->control);
 	}
 
@@ -8368,7 +18358,9 @@ static int rtl8152_runtime_resume(struct r8152 *tp)
 
 		tp->rtl_ops.autosuspend_en(tp, false);
 		napi_disable(napi);
+		smp_mb__before_atomic();
 		set_bit(WORK_ENABLE, &tp->flags);
+		smp_mb__after_atomic();
 
 		if (netif_carrier_ok(netdev)) {
 			if (rtl8152_get_speed(tp) & LINK_STATUS) {
@@ -8384,8 +18376,11 @@ static int rtl8152_runtime_resume(struct r8152 *tp)
 		clear_bit(SELECTIVE_SUSPEND, &tp->flags);
 		smp_mb__after_atomic();
 
-		if (!list_empty(&tp->rx_done))
+		if (!list_empty(&tp->rx_done)) {
+			local_bh_disable();
 			napi_schedule(&tp->napi);
+			local_bh_enable();
+		}
 
 		usb_submit_urb(tp->intr_urb, GFP_NOIO);
 	} else {
@@ -8393,6 +18388,7 @@ static int rtl8152_runtime_resume(struct r8152 *tp)
 			tp->rtl_ops.autosuspend_en(tp, false);
 
 		clear_bit(SELECTIVE_SUSPEND, &tp->flags);
+		smp_mb__after_atomic();
 	}
 
 	return 0;
@@ -8407,7 +18403,12 @@ static int rtl8152_system_resume(struct r8152 *tp)
 	if (netif_running(netdev) && (netdev->flags & IFF_UP)) {
 		tp->rtl_ops.up(tp);
 		netif_carrier_off(netdev);
+		smp_mb__before_atomic();
 		set_bit(WORK_ENABLE, &tp->flags);
+		smp_mb__after_atomic();
+		if (test_and_clear_bit(RECOVER_SPEED, &tp->flags))
+			rtl8152_set_speed(tp, tp->autoneg, tp->speed,
+					  tp->duplex, tp->advertising);
 		usb_submit_urb(tp->intr_urb, GFP_NOIO);
 	}
 
@@ -8447,7 +18448,9 @@ static int rtl8152_runtime_suspend(struct r8152 *tp)
 			}
 		}
 
+		smp_mb__before_atomic();
 		clear_bit(WORK_ENABLE, &tp->flags);
+		smp_mb__after_atomic();
 		usb_kill_urb(tp->intr_urb);
 
 		tp->rtl_ops.autosuspend_en(tp, true);
@@ -8481,12 +18484,20 @@ static int rtl8152_system_suspend(struct r8152 *tp)
 	if (netif_running(netdev) && test_bit(WORK_ENABLE, &tp->flags)) {
 		struct napi_struct *napi = &tp->napi;
 
+		smp_mb__before_atomic();
 		clear_bit(WORK_ENABLE, &tp->flags);
+		smp_mb__after_atomic();
 		usb_kill_urb(tp->intr_urb);
 		tasklet_disable(&tp->tx_tl);
 		napi_disable(napi);
 		cancel_delayed_work_sync(&tp->schedule);
 		tp->rtl_ops.down(tp);
+
+		if (tp->version == RTL_VER_01)
+			rtl8152_set_speed(tp, AUTONEG_ENABLE, 0, 0, 3);
+		else
+			rtl_speed_down(tp);
+
 		napi_enable(napi);
 		tasklet_enable(&tp->tx_tl);
 	}
@@ -8612,50 +18623,336 @@ static void rtl8152_get_drvinfo(struct net_device *netdev,
 	strscpy(info->driver, MODULENAME, sizeof(info->driver));
 	strscpy(info->version, DRIVER_VERSION, sizeof(info->version));
 	usb_make_path(tp->udev, info->bus_info, sizeof(info->bus_info));
-	if (!IS_ERR_OR_NULL(tp->rtl_fw.fw))
-		strscpy(info->fw_version, tp->rtl_fw.version,
-			sizeof(info->fw_version));
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0)
 static
-int rtl8152_get_link_ksettings(struct net_device *netdev,
-			       struct ethtool_link_ksettings *cmd)
+int rtl8152_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
 {
 	struct r8152 *tp = netdev_priv(netdev);
-	int ret;
+	u16 bmcr, bmsr;
+	int ret, advert;
 
-	if (!tp->mii.mdio_read)
-		return -EOPNOTSUPP;
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	cmd->supported =
+	    (SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+	     SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+	     SUPPORTED_Autoneg | SUPPORTED_MII);
+
+	/* only supports twisted-pair */
+	cmd->port = PORT_MII;
+
+	/* only supports internal transceiver */
+	cmd->transceiver = XCVR_INTERNAL;
+	cmd->phy_address = 32;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+	cmd->mdio_support = ETH_MDIO_SUPPORTS_C22;
+#endif
+	cmd->advertising = ADVERTISED_MII;
+
+	mutex_lock(&tp->control);
+
+	bmcr = r8152_mdio_read(tp, MII_BMCR);
+	bmsr = r8152_mdio_read(tp, MII_BMSR);
+
+	advert = r8152_mdio_read(tp, MII_ADVERTISE);
+	if (advert & ADVERTISE_10HALF)
+		cmd->advertising |= ADVERTISED_10baseT_Half;
+	if (advert & ADVERTISE_10FULL)
+		cmd->advertising |= ADVERTISED_10baseT_Full;
+	if (advert & ADVERTISE_100HALF)
+		cmd->advertising |= ADVERTISED_100baseT_Half;
+	if (advert & ADVERTISE_100FULL)
+		cmd->advertising |= ADVERTISED_100baseT_Full;
+	if (advert & ADVERTISE_PAUSE_CAP)
+		cmd->advertising |= ADVERTISED_Pause;
+	if (advert & ADVERTISE_PAUSE_ASYM)
+		cmd->advertising |= ADVERTISED_Asym_Pause;
+	if (tp->mii.supports_gmii) {
+		u16 ctrl1000 = r8152_mdio_read(tp, MII_CTRL1000);
+
+		cmd->supported |= SUPPORTED_1000baseT_Full;
+
+		if (tp->support_2500full) {
+			u16 data = ocp_reg_read(tp, 0xa5d4);
+
+			cmd->supported |= SUPPORTED_2500baseX_Full;
+			if (data & BIT(7))
+				cmd->advertising |= ADVERTISED_2500baseX_Full;
+		}
+
+		if (ctrl1000 & ADVERTISE_1000HALF)
+			cmd->advertising |= ADVERTISED_1000baseT_Half;
+		if (ctrl1000 & ADVERTISE_1000FULL)
+			cmd->advertising |= ADVERTISED_1000baseT_Full;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+	if (bmsr & BMSR_ANEGCOMPLETE) {
+		advert = r8152_mdio_read(tp, MII_LPA);
+		if (advert & LPA_LPACK)
+			cmd->lp_advertising |= ADVERTISED_Autoneg;
+		if (advert & ADVERTISE_10HALF)
+			cmd->lp_advertising |=
+				ADVERTISED_10baseT_Half;
+		if (advert & ADVERTISE_10FULL)
+			cmd->lp_advertising |=
+				ADVERTISED_10baseT_Full;
+		if (advert & ADVERTISE_100HALF)
+			cmd->lp_advertising |=
+				ADVERTISED_100baseT_Half;
+		if (advert & ADVERTISE_100FULL)
+			cmd->lp_advertising |=
+				ADVERTISED_100baseT_Full;
+
+		if (tp->mii.supports_gmii) {
+			u16 stat1000 = r8152_mdio_read(tp, MII_STAT1000);
+
+			if (stat1000 & LPA_1000HALF)
+				cmd->lp_advertising |=
+					ADVERTISED_1000baseT_Half;
+			if (stat1000 & LPA_1000FULL)
+				cmd->lp_advertising |=
+					ADVERTISED_1000baseT_Full;
+		}
+	} else {
+		cmd->lp_advertising = 0;
+	}
+#endif
+
+	if (bmcr & BMCR_ANENABLE) {
+		cmd->advertising |= ADVERTISED_Autoneg;
+		cmd->autoneg = AUTONEG_ENABLE;
+	} else {
+		cmd->autoneg = AUTONEG_DISABLE;
+	}
+
+
+	if (netif_running(netdev) && netif_carrier_ok(netdev)) {
+		u16 speed = rtl8152_get_speed(tp);
+
+		if (speed & _100bps)
+			cmd->speed = SPEED_100;
+		else if (speed & _10bps)
+			cmd->speed = SPEED_10;
+		else if (tp->mii.supports_gmii && (speed & _1000bps))
+			cmd->speed = SPEED_1000;
+		else if (tp->support_2500full && (speed & _2500bps))
+			cmd->speed = SPEED_2500;
+
+		cmd->duplex = (speed & FULL_DUP) ? DUPLEX_FULL : DUPLEX_HALF;
+	} else {
+		cmd->speed = SPEED_UNKNOWN;
+		cmd->duplex = DUPLEX_UNKNOWN;
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+
+static int rtl8152_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	u32 advertising = 0;
+	int ret;
 
 	ret = usb_autopm_get_interface(tp->intf);
 	if (ret < 0)
 		goto out;
 
+	if (cmd->advertising & ADVERTISED_10baseT_Half)
+		advertising |= RTL_ADVERTISED_10_HALF;
+	if (cmd->advertising & ADVERTISED_10baseT_Full)
+		advertising |= RTL_ADVERTISED_10_FULL;
+	if (cmd->advertising & ADVERTISED_100baseT_Half)
+		advertising |= RTL_ADVERTISED_100_HALF;
+	if (cmd->advertising & ADVERTISED_100baseT_Full)
+		advertising |= RTL_ADVERTISED_100_FULL;
+	if (cmd->advertising & ADVERTISED_1000baseT_Half)
+		advertising |= RTL_ADVERTISED_1000_HALF;
+	if (cmd->advertising & ADVERTISED_1000baseT_Full)
+		advertising |= RTL_ADVERTISED_1000_FULL;
+	if (cmd->advertising & ADVERTISED_2500baseX_Full)
+		advertising |= RTL_ADVERTISED_2500_FULL;
+
 	mutex_lock(&tp->control);
 
-	mii_ethtool_get_link_ksettings(&tp->mii, cmd);
+	ret = rtl8152_set_speed(tp, cmd->autoneg, cmd->speed, cmd->duplex,
+				advertising);
+	if (!ret) {
+		tp->autoneg = cmd->autoneg;
+		tp->speed = cmd->speed;
+		tp->duplex = cmd->duplex;
+		tp->advertising = advertising;
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+static int rtl8152_get_link_ksettings(struct net_device *netdev,
+				      struct ethtool_link_ksettings *cmd)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u16 bmcr, bmsr, advert;
+	int ret;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out1;
 
+	/* only supports twisted-pair */
+	cmd->base.port = PORT_MII;
+
+	/* this isn't fully supported at higher layers */
+	cmd->base.phy_address = 32;
+	cmd->base.mdio_support = ETH_MDIO_SUPPORTS_C22;
+
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+			 cmd->link_modes.supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+			 cmd->link_modes.supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+			 cmd->link_modes.supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+			 cmd->link_modes.supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
+			 cmd->link_modes.supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_MII_BIT,
+			 cmd->link_modes.supported);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+			 cmd->link_modes.supported, tp->mii.supports_gmii);
 	linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
 			 cmd->link_modes.supported, tp->support_2500full);
 
+	ret = mutex_lock_interruptible(&tp->control);
+	if (ret < 0)
+		goto out2;
+
+	bmcr = r8152_mdio_read(tp, MII_BMCR);
+	bmsr = r8152_mdio_read(tp, MII_BMSR);
+
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
+			 cmd->link_modes.advertising, bmcr & BMCR_ANENABLE);
+
+	if (bmcr & BMCR_ANENABLE)
+		cmd->base.autoneg = AUTONEG_ENABLE;
+	else
+		cmd->base.autoneg = AUTONEG_DISABLE;
+
+	advert = r8152_mdio_read(tp, MII_ADVERTISE);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+			 cmd->link_modes.advertising,
+			 advert & ADVERTISE_10HALF);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+			 cmd->link_modes.advertising,
+			 advert & ADVERTISE_10FULL);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+			 cmd->link_modes.advertising,
+			 advert & ADVERTISE_100HALF);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+			 cmd->link_modes.advertising,
+			 advert & ADVERTISE_100FULL);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+			 cmd->link_modes.advertising,
+			 advert & ADVERTISE_PAUSE_CAP);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+			 cmd->link_modes.advertising,
+			 advert & ADVERTISE_PAUSE_ASYM);
+
+	if (tp->mii.supports_gmii) {
+		u16 ctrl1000 = r8152_mdio_read(tp, MII_CTRL1000);
+
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+				 cmd->link_modes.advertising,
+				 ctrl1000 & ADVERTISE_1000HALF);
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+				 cmd->link_modes.advertising,
+				 ctrl1000 & ADVERTISE_1000FULL);
+	}
+
 	if (tp->support_2500full) {
 		linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
 				 cmd->link_modes.advertising,
 				 ocp_reg_read(tp, OCP_10GBT_CTRL) & MDIO_AN_10GBT_CTRL_ADV2_5G);
+	}
 
-		linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+	if (bmsr & BMSR_ANEGCOMPLETE) {
+		advert = r8152_mdio_read(tp, MII_LPA);
+
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
+				 cmd->link_modes.lp_advertising,
+				 advert & LPA_LPACK);
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+				 cmd->link_modes.lp_advertising,
+				 advert & ADVERTISE_10HALF);
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+				 cmd->link_modes.lp_advertising,
+				 advert & ADVERTISE_10FULL);
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+				 cmd->link_modes.lp_advertising,
+				 advert & ADVERTISE_100HALF);
+		linkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
 				 cmd->link_modes.lp_advertising,
-				 ocp_reg_read(tp, OCP_10GBT_STAT) & MDIO_AN_10GBT_STAT_LP2_5G);
+				 advert & ADVERTISE_100FULL);
+
+		if (tp->mii.supports_gmii) {
+			u16 stat1000 = r8152_mdio_read(tp, MII_STAT1000);
+
+			linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+					 cmd->link_modes.lp_advertising,
+					 stat1000 & LPA_1000HALF);
+			linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+					 cmd->link_modes.lp_advertising,
+					 stat1000 & LPA_1000FULL);
+		}
+
+		if (tp->support_2500full) {
+			u16 data = ocp_reg_read(tp, OCP_10GBT_STAT);
+
+			linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+					 cmd->link_modes.lp_advertising,
+					 data & MDIO_AN_10GBT_STAT_LP2_5G);
+		}
+	}
 
-		if (is_speed_2500(rtl8152_get_speed(tp)))
+	if (netif_running(netdev) && netif_carrier_ok(netdev)) {
+		u16 speed = rtl8152_get_speed(tp);
+
+		if (speed & _100bps)
+			cmd->base.speed = SPEED_100;
+		else if (speed & _10bps)
+			cmd->base.speed = SPEED_10;
+		else if (tp->mii.supports_gmii && (speed & _1000bps))
+			cmd->base.speed = SPEED_1000;
+		else if (tp->support_2500full && (speed & _2500bps))
 			cmd->base.speed = SPEED_2500;
+
+		cmd->base.duplex = (speed & FULL_DUP) ? DUPLEX_FULL :
+							DUPLEX_HALF;
+	} else {
+		cmd->base.speed = SPEED_UNKNOWN;
+		cmd->base.duplex = DUPLEX_UNKNOWN;
 	}
 
 	mutex_unlock(&tp->control);
 
+out2:
 	usb_autopm_put_interface(tp->intf);
-
-out:
+out1:
 	return ret;
 }
 
@@ -8716,6 +19013,7 @@ static int rtl8152_set_link_ksettings(struct net_device *dev,
 out:
 	return ret;
 }
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0) */
 
 static const char rtl8152_gstrings[][ETH_GSTRING_LEN] = {
 	"tx_packets",
@@ -8733,6 +19031,12 @@ static const char rtl8152_gstrings[][ETH_GSTRING_LEN] = {
 	"tx_underrun",
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+static int rtl8152_get_sset_count(struct net_device *dev)
+{
+	return ARRAY_SIZE(rtl8152_gstrings);
+}
+#else
 static int rtl8152_get_sset_count(struct net_device *dev, int sset)
 {
 	switch (sset) {
@@ -8742,6 +19046,7 @@ static int rtl8152_get_sset_count(struct net_device *dev, int sset)
 		return -EOPNOTSUPP;
 	}
 }
+#endif
 
 static void rtl8152_get_ethtool_stats(struct net_device *dev,
 				      struct ethtool_stats *stats, u64 *data)
@@ -8752,8 +19057,15 @@ static void rtl8152_get_ethtool_stats(struct net_device *dev,
 	if (usb_autopm_get_interface(tp->intf) < 0)
 		return;
 
+	if (mutex_lock_interruptible(&tp->control) < 0) {
+		usb_autopm_put_interface(tp->intf);
+		return;
+	}
+
 	generic_ocp_read(tp, PLA_TALLYCNT, sizeof(tally), &tally, MCU_TYPE_PLA);
 
+	mutex_unlock(&tp->control);
+
 	usb_autopm_put_interface(tp->intf);
 
 	data[0] = le64_to_cpu(tally.tx_packets);
@@ -8780,6 +19092,7 @@ static void rtl8152_get_strings(struct net_device *dev, u32 stringset, u8 *data)
 	}
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
 static int r8152_get_eee(struct r8152 *tp, struct ethtool_eee *eee)
 {
 	u32 lp, adv, supported = 0;
@@ -8884,7 +19197,7 @@ rtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *edata)
 
 	ret = tp->rtl_ops.eee_set(tp, edata);
 	if (!ret)
-		ret = mii_nway_restart(&tp->mii);
+		ret = rtl_nway_restart(tp);
 
 	mutex_unlock(&tp->control);
 
@@ -8893,6 +19206,7 @@ rtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *edata)
 out:
 	return ret;
 }
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
 
 static int rtl8152_nway_reset(struct net_device *dev)
 {
@@ -8905,7 +19219,7 @@ static int rtl8152_nway_reset(struct net_device *dev)
 
 	mutex_lock(&tp->control);
 
-	ret = mii_nway_restart(&tp->mii);
+	ret = rtl_nway_restart(tp);
 
 	mutex_unlock(&tp->control);
 
@@ -8916,9 +19230,13 @@ static int rtl8152_nway_reset(struct net_device *dev)
 }
 
 static int rtl8152_get_coalesce(struct net_device *netdev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+				struct ethtool_coalesce *coalesce)
+#else
 				struct ethtool_coalesce *coalesce,
 				struct kernel_ethtool_coalesce *kernel_coal,
 				struct netlink_ext_ack *extack)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
 {
 	struct r8152 *tp = netdev_priv(netdev);
 
@@ -8931,655 +19249,1635 @@ static int rtl8152_get_coalesce(struct net_device *netdev,
 		break;
 	}
 
-	coalesce->rx_coalesce_usecs = tp->coalesce;
+	coalesce->rx_coalesce_usecs = tp->coalesce / 1000;
 
 	return 0;
 }
 
-static int rtl8152_set_coalesce(struct net_device *netdev,
-				struct ethtool_coalesce *coalesce,
-				struct kernel_ethtool_coalesce *kernel_coal,
-				struct netlink_ext_ack *extack)
+static int rtl8152_set_coalesce(struct net_device *netdev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+				struct ethtool_coalesce *coalesce)
+#else
+				struct ethtool_coalesce *coalesce,
+				struct kernel_ethtool_coalesce *kernel_coal,
+				struct netlink_ext_ack *extack)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u32 rx_coalesce_nsecs;
+	int ret;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+	case RTL_TEST_01: /* fix me */
+		return -EOPNOTSUPP;
+	default:
+		break;
+	}
+
+	rx_coalesce_nsecs = coalesce->rx_coalesce_usecs * 1000;
+
+	if (rx_coalesce_nsecs > COALESCE_SLOW)
+		return -EINVAL;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&tp->control);
+
+	if (tp->coalesce != rx_coalesce_nsecs) {
+		tp->coalesce = rx_coalesce_nsecs;
+
+		if (netif_running(netdev) && netif_carrier_ok(netdev)) {
+			netif_stop_queue(netdev);
+			napi_disable(&tp->napi);
+			tp->rtl_ops.disable(tp);
+			tp->rtl_ops.enable(tp);
+			rtl_start_rx(tp);
+			napi_enable(&tp->napi);
+			rtl8152_set_rx_mode(netdev);
+			netif_wake_queue(netdev);
+		}
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+	return ret;
+}
+
+static int rtl8152_ethtool_begin(struct net_device *netdev)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+static int rtl8152_get_tunable(struct net_device *netdev,
+			       const struct ethtool_tunable *tunable, void *d)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	switch (tunable->id) {
+	case ETHTOOL_RX_COPYBREAK:
+		*(u32 *)d = tp->rx_copybreak;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int rtl8152_set_tunable(struct net_device *netdev,
+			       const struct ethtool_tunable *tunable,
+			       const void *d)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u32 val;
+
+	switch (tunable->id) {
+	case ETHTOOL_RX_COPYBREAK:
+		val = *(u32 *)d;
+		if (val < ETH_ZLEN) {
+			netif_err(tp, rx_err, netdev,
+				  "Invalid rx copy break value\n");
+			return -EINVAL;
+		}
+
+		if (tp->rx_copybreak != val) {
+			if (netdev->flags & IFF_UP) {
+				mutex_lock(&tp->control);
+				napi_disable(&tp->napi);
+				tp->rx_copybreak = val;
+				napi_enable(&tp->napi);
+				mutex_unlock(&tp->control);
+			} else {
+				tp->rx_copybreak = val;
+			}
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0) */
+
+static void rtl8152_get_ringparam(struct net_device *netdev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,17,0)
+				  struct ethtool_ringparam *ring)
+#else
+				  struct ethtool_ringparam *ring,
+				  struct kernel_ethtool_ringparam *kernel_ring,
+				  struct netlink_ext_ack *extack)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	ring->rx_max_pending = RTL8152_RX_MAX_PENDING;
+	ring->rx_pending = tp->rx_pending;
+}
+
+static int rtl8152_set_ringparam(struct net_device *netdev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,17,0)
+				 struct ethtool_ringparam *ring)
+#else
+				 struct ethtool_ringparam *ring,
+				 struct kernel_ethtool_ringparam *kernel_ring,
+				 struct netlink_ext_ack *extack)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	if (ring->rx_pending < (RTL8152_MAX_RX * 2))
+		return -EINVAL;
+
+	if (tp->rx_pending != ring->rx_pending) {
+		if (netdev->flags & IFF_UP) {
+			mutex_lock(&tp->control);
+			napi_disable(&tp->napi);
+			tp->rx_pending = ring->rx_pending;
+			napi_enable(&tp->napi);
+			mutex_unlock(&tp->control);
+		} else {
+			tp->rx_pending = ring->rx_pending;
+		}
+	}
+
+	return 0;
+}
+
+static void rtl8152_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u16 bmcr, lcladv, rmtadv;
+	u8 cap;
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	mutex_lock(&tp->control);
+
+	bmcr = r8152_mdio_read(tp, MII_BMCR);
+	lcladv = r8152_mdio_read(tp, MII_ADVERTISE);
+	rmtadv = r8152_mdio_read(tp, MII_LPA);
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+	if (!(bmcr & BMCR_ANENABLE)) {
+		pause->autoneg = 0;
+		pause->rx_pause = 0;
+		pause->tx_pause = 0;
+		return;
+	}
+
+	pause->autoneg = 1;
+
+	cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);
+
+	if (cap & FLOW_CTRL_RX)
+		pause->rx_pause = 1;
+
+	if (cap & FLOW_CTRL_TX)
+		pause->tx_pause = 1;
+}
+
+static int rtl8152_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u16 old, new1;
+	u8 cap = 0;
+	int ret;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&tp->control);
+
+	if (pause->autoneg && !(r8152_mdio_read(tp, MII_BMCR) & BMCR_ANENABLE)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (pause->rx_pause)
+		cap |= FLOW_CTRL_RX;
+
+	if (pause->tx_pause)
+		cap |= FLOW_CTRL_TX;
+
+	old = r8152_mdio_read(tp, MII_ADVERTISE);
+	new1 = (old & ~(ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM)) | mii_advertise_flowctrl(cap);
+	if (old != new1)
+		r8152_mdio_write(tp, MII_ADVERTISE, new1);
+
+	if (new1 & (ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM))
+		tp->ups_info.flow_control = true;
+	else
+		tp->ups_info.flow_control = false;
+
+out:
+	mutex_unlock(&tp->control);
+	usb_autopm_put_interface(tp->intf);
+
+	return ret;
+}
+
+static const struct ethtool_ops ops = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0)
+	.supported_coalesce_params = ETHTOOL_COALESCE_USECS,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0) */
+	.get_drvinfo = rtl8152_get_drvinfo,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0)
+	.get_settings = rtl8152_get_settings,
+	.set_settings = rtl8152_set_settings,
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0) */
+	.get_link = ethtool_op_get_link,
+	.nway_reset = rtl8152_nway_reset,
+	.get_msglevel = rtl8152_get_msglevel,
+	.set_msglevel = rtl8152_set_msglevel,
+	.get_wol = rtl8152_get_wol,
+	.set_wol = rtl8152_set_wol,
+	.get_strings = rtl8152_get_strings,
+	.get_sset_count = rtl8152_get_sset_count,
+	.get_ethtool_stats = rtl8152_get_ethtool_stats,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+	.get_tx_csum = ethtool_op_get_tx_csum,
+	.set_tx_csum = ethtool_op_set_tx_csum,
+	.get_sg = ethtool_op_get_sg,
+	.set_sg = ethtool_op_set_sg,
+#ifdef NETIF_F_TSO
+	.get_tso = ethtool_op_get_tso,
+	.set_tso = ethtool_op_set_tso,
+#endif
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0) */
+	.get_coalesce = rtl8152_get_coalesce,
+	.set_coalesce = rtl8152_set_coalesce,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+	.get_eee = rtl_ethtool_get_eee,
+	.set_eee = rtl_ethtool_set_eee,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+	.get_link_ksettings = rtl8152_get_link_ksettings,
+	.set_link_ksettings = rtl8152_set_link_ksettings,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0) */
+	.begin = rtl8152_ethtool_begin,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+	.get_tunable = rtl8152_get_tunable,
+	.set_tunable = rtl8152_set_tunable,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0) */
+	.get_ringparam = rtl8152_get_ringparam,
+	.set_ringparam = rtl8152_set_ringparam,
+	.get_pauseparam = rtl8152_get_pauseparam,
+	.set_pauseparam = rtl8152_set_pauseparam,
+};
+
+static int rtltool_ioctl(struct r8152 *tp, struct ifreq *ifr)
+{
+	struct net_device *netdev = tp->netdev;
+	struct rtltool_cmd my_cmd, *myptr;
+	struct usb_device_info *uinfo;
+	struct usb_device *udev;
+	__le32	ocp_data;
+	void	*buffer;
+	int	ret;
+
+	myptr = (struct rtltool_cmd *)ifr->ifr_data;
+	if (copy_from_user(&my_cmd, myptr, sizeof(my_cmd)))
+		return -EFAULT;
+
+	ret = 0;
+
+	switch (my_cmd.cmd) {
+	case RTLTOOL_PLA_OCP_READ_DWORD:
+		pla_ocp_read(tp, (u16)my_cmd.offset, sizeof(ocp_data),
+			     &ocp_data);
+		my_cmd.data = __le32_to_cpu(ocp_data);
+
+		if (copy_to_user(myptr, &my_cmd, sizeof(my_cmd))) {
+			ret = -EFAULT;
+			break;
+		}
+		break;
+
+	case RTLTOOL_PLA_OCP_WRITE_DWORD:
+		if (!tp->rtk_enable_diag && net_ratelimit())
+			netif_warn(tp, drv, netdev,
+				   "rtk diag isn't enable\n");
+
+		ocp_data = __cpu_to_le32(my_cmd.data);
+		pla_ocp_write(tp, (u16)my_cmd.offset, (u16)my_cmd.byteen,
+			      sizeof(ocp_data), &ocp_data);
+		break;
+
+	case RTLTOOL_USB_OCP_READ_DWORD:
+		usb_ocp_read(tp, (u16)my_cmd.offset, sizeof(ocp_data),
+			     &ocp_data);
+		my_cmd.data = __le32_to_cpu(ocp_data);
+
+		if (copy_to_user(myptr, &my_cmd, sizeof(my_cmd))) {
+			ret = -EFAULT;
+			break;
+		}
+		break;
+
+
+	case RTLTOOL_USB_OCP_WRITE_DWORD:
+		if (!tp->rtk_enable_diag && net_ratelimit())
+			netif_warn(tp, drv, netdev,
+				   "rtk diag isn't enable\n");
+
+		ocp_data = __cpu_to_le32(my_cmd.data);
+		usb_ocp_write(tp, (u16)my_cmd.offset, (u16)my_cmd.byteen,
+			      sizeof(ocp_data), &ocp_data);
+		break;
+
+	case RTLTOOL_PLA_OCP_READ:
+		buffer = kmalloc(my_cmd.data, GFP_KERNEL);
+		if (!buffer) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		pla_ocp_read(tp, (u16)my_cmd.offset, my_cmd.data, buffer);
+
+		if (copy_to_user(my_cmd.buf, buffer, my_cmd.data))
+			ret = -EFAULT;
+
+		kfree(buffer);
+		break;
+
+	case RTLTOOL_PLA_OCP_WRITE:
+		if (!tp->rtk_enable_diag && net_ratelimit())
+			netif_warn(tp, drv, netdev,
+				   "rtk diag isn't enable\n");
+
+		buffer = kmalloc(my_cmd.data, GFP_KERNEL);
+		if (!buffer) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		if (copy_from_user(buffer, my_cmd.buf, my_cmd.data)) {
+			ret = -EFAULT;
+			kfree(buffer);
+			break;
+		}
+
+		pla_ocp_write(tp, (u16)my_cmd.offset, (u16)my_cmd.byteen,
+			      my_cmd.data, buffer);
+		kfree(buffer);
+		break;
+
+	case RTLTOOL_USB_OCP_READ:
+		buffer = kmalloc(my_cmd.data, GFP_KERNEL);
+		if (!buffer) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		usb_ocp_read(tp, (u16)my_cmd.offset, my_cmd.data, buffer);
+
+		if (copy_to_user(my_cmd.buf, buffer, my_cmd.data))
+			ret = -EFAULT;
+
+		kfree(buffer);
+		break;
+
+	case RTLTOOL_USB_OCP_WRITE:
+		if (!tp->rtk_enable_diag && net_ratelimit())
+			netif_warn(tp, drv, netdev,
+				   "rtk diag isn't enable\n");
+
+		buffer = kmalloc(my_cmd.data, GFP_KERNEL);
+		if (!buffer) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		if (copy_from_user(buffer, my_cmd.buf, my_cmd.data)) {
+			ret = -EFAULT;
+			kfree(buffer);
+			break;
+		}
+
+		usb_ocp_write(tp, (u16)my_cmd.offset, (u16)my_cmd.byteen,
+			      my_cmd.data, buffer);
+		kfree(buffer);
+		break;
+
+	case RTLTOOL_USB_INFO:
+		uinfo = (struct usb_device_info *)&my_cmd.nic_info;
+		udev = tp->udev;
+		uinfo->idVendor = __le16_to_cpu(udev->descriptor.idVendor);
+		uinfo->idProduct = __le16_to_cpu(udev->descriptor.idProduct);
+		uinfo->bcdDevice = __le16_to_cpu(udev->descriptor.bcdDevice);
+		strlcpy(uinfo->devpath, udev->devpath, sizeof(udev->devpath));
+		pla_ocp_read(tp, PLA_IDR, sizeof(uinfo->dev_addr),
+			     uinfo->dev_addr);
+
+		if (copy_to_user(myptr, &my_cmd, sizeof(my_cmd)))
+			ret = -EFAULT;
+
+		break;
+
+	case RTL_ENABLE_USB_DIAG:
+		ret = usb_autopm_get_interface(tp->intf);
+		if (ret < 0)
+			break;
+
+		mutex_lock(&tp->control);
+		tp->rtk_enable_diag++;
+		netif_info(tp, drv, netdev, "enable rtk diag %d\n",
+			   tp->rtk_enable_diag);
+		break;
+
+	case RTL_DISABLE_USB_DIAG:
+		if (!tp->rtk_enable_diag) {
+			netif_err(tp, drv, netdev,
+				  "Invalid using rtk diag\n");
+			ret = -EPERM;
+			break;
+		}
+
+		rtk_disable_diag(tp);
+		break;
+
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0)
+static int rtl8152_siocdevprivate(struct net_device *netdev, struct ifreq *rq,
+				  void __user *data, int cmd)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	switch (cmd) {
+	case SIOCDEVPRIVATE:
+		if (!capable(CAP_NET_ADMIN)) {
+			ret = -EPERM;
+			break;
+		}
+		ret = rtltool_ioctl(tp, rq);
+		break;
+
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0) */
+
+static int rtl8152_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	struct mii_ioctl_data *data = if_mii(rq);
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	switch (cmd) {
+	case SIOCGMIIPHY:
+		data->phy_id = R8152_PHY_ID; /* Internal PHY */
+		break;
+
+	case SIOCGMIIREG:
+		if (unlikely(tp->rtk_enable_diag)) {
+			ret = -EBUSY;
+			break;
+		}
+
+		mutex_lock(&tp->control);
+		data->val_out = r8152_mdio_read(tp, data->reg_num);
+		mutex_unlock(&tp->control);
+		break;
+
+	case SIOCSMIIREG:
+		if (!capable(CAP_NET_ADMIN)) {
+			ret = -EPERM;
+			break;
+		}
+
+		if (unlikely(tp->rtk_enable_diag)) {
+			ret = -EBUSY;
+			break;
+		}
+
+		mutex_lock(&tp->control);
+		r8152_mdio_write(tp, data->reg_num, data->val_in);
+		mutex_unlock(&tp->control);
+		break;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+	case SIOCDEVPRIVATE:
+		if (!capable(CAP_NET_ADMIN)) {
+			ret = -EPERM;
+			break;
+		}
+		ret = rtltool_ioctl(tp, rq);
+		break;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+
+static int rtl8152_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	int ret;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+	u32 max_mtu;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0) */
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+		return eth_change_mtu(dev, new_mtu);
+#else
+		dev->mtu = new_mtu;
+		return 0;
+#endif
+	default:
+		break;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+	switch (tp->version) {
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_08:
+	case RTL_VER_09:
+	case RTL_VER_14:
+		max_mtu = size_to_mtu(9 * 1024);
+		break;
+	case RTL_VER_10:
+	case RTL_VER_11:
+		max_mtu = size_to_mtu(15 * 1024);
+		break;
+	case RTL_VER_12:
+	case RTL_VER_13:
+	case RTL_VER_15:
+		max_mtu = size_to_mtu(16 * 1024);
+		break;
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+	default:
+		max_mtu = ETH_DATA_LEN;
+		break;
+	}
+
+	if (new_mtu < 68 || new_mtu > max_mtu)
+		return -EINVAL;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0) */
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&tp->control);
+
+	dev->mtu = new_mtu;
+
+	if (netif_running(dev)) {
+		if (tp->rtl_ops.change_mtu)
+			tp->rtl_ops.change_mtu(tp);
+
+		if (netif_carrier_ok(dev)) {
+			netif_stop_queue(dev);
+			napi_disable(&tp->napi);
+			tasklet_disable(&tp->tx_tl);
+			tp->rtl_ops.disable(tp);
+			tp->rtl_ops.enable(tp);
+			rtl_start_rx(tp);
+			tasklet_enable(&tp->tx_tl);
+			napi_enable(&tp->napi);
+			rtl8152_set_rx_mode(dev);
+			netif_wake_queue(dev);
+		}
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+static const struct net_device_ops rtl8152_netdev_ops = {
+	.ndo_open		= rtl8152_open,
+	.ndo_stop		= rtl8152_close,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+	.ndo_do_ioctl		= rtl8152_ioctl,
+#else
+	.ndo_siocdevprivate	= rtl8152_siocdevprivate,
+	.ndo_eth_ioctl		= rtl8152_ioctl,
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0) */
+	.ndo_start_xmit		= rtl8152_start_xmit,
+	.ndo_tx_timeout		= rtl8152_tx_timeout,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+	.ndo_vlan_rx_register	= rtl8152_vlan_rx_register,
+#else
+	.ndo_set_features	= rtl8152_set_features,
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
+	.ndo_set_rx_mode	= rtl8152_set_rx_mode,
+	.ndo_set_mac_address	= rtl8152_set_mac_address,
+	.ndo_change_mtu		= rtl8152_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,4)
+	.ndo_features_check	= rtl8152_features_check,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,4) */
+};
+#endif
+
+static void rtl8152_unload(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8152_power_cut_en(tp, false);
+}
+
+static void rtl8153_unload(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8153_power_cut_en(tp, false);
+}
+
+static void rtl8153b_unload(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8153b_power_cut_en(tp, false);
+	rtl_set_dbg_info_state(tp, DGB_DRV_STATE_UNLOAD);
+}
+
+static int rtl_ops_init(struct r8152 *tp)
+{
+	struct rtl_ops *ops = &tp->rtl_ops;
+	int ret = 0;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+		ops->init		= r8152b_init;
+		ops->enable		= rtl8152_enable;
+		ops->disable		= rtl8152_disable;
+		ops->up			= rtl8152_up;
+		ops->down		= rtl8152_down;
+		ops->unload		= rtl8152_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8152_get_eee;
+		ops->eee_set		= r8152_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8152_in_nway;
+		ops->hw_phy_cfg		= r8152b_hw_phy_cfg;
+		ops->autosuspend_en	= rtl_runtime_suspend_enable;
+		tp->rx_buf_sz		= 16 * 1024;
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_100TX;
+		break;
+
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+		ops->init		= r8153_init;
+		ops->enable		= rtl8153_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8153_up;
+		ops->down		= rtl8153_down;
+		ops->unload		= rtl8153_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8153_get_eee;
+		ops->eee_set		= r8152_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8153_hw_phy_cfg;
+		ops->autosuspend_en	= rtl8153_runtime_enable;
+		ops->change_mtu		= rtl8153_change_mtu;
+		if (tp->udev->speed < USB_SPEED_SUPER)
+			tp->rx_buf_sz	= 16 * 1024;
+		else
+			tp->rx_buf_sz	= 32 * 1024;
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
+		break;
+
+	case RTL_VER_08:
+	case RTL_VER_09:
+		ops->init		= r8153b_init;
+		ops->enable		= rtl8153_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8153b_up;
+		ops->down		= rtl8153b_down;
+		ops->unload		= rtl8153b_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8153_get_eee;
+		ops->eee_set		= r8152_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8153b_hw_phy_cfg;
+		ops->autosuspend_en	= rtl8153b_runtime_enable;
+		ops->change_mtu		= rtl8153_change_mtu;
+		tp->rx_buf_sz		= 32 * 1024;
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
+		break;
+
+	case RTL_TEST_01:
+		ops->init		= r8156_init;
+		ops->enable		= rtl8156_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8156_up;
+		ops->down		= rtl8156_down;
+		ops->unload		= rtl8153_unload;
+//#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+//		ops->eee_get		= r8156_get_eee;
+//		ops->eee_set		= r8156_set_eee;
+//#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8156_hw_phy_cfg_test;
+		ops->autosuspend_en	= rtl8156_runtime_enable;
+		tp->rx_buf_sz		= 48 * 1024;
+		tp->support_2500full	= 1;
+		break;
+
+	case RTL_VER_11:
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
+		fallthrough;
+	case RTL_VER_10:
+		ops->init		= r8156_init;
+		ops->enable		= rtl8156_enable;
+		ops->disable		= rtl8156_disable;
+		ops->up			= rtl8156_up;
+		ops->down		= rtl8156_down;
+		ops->unload		= rtl8153_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8153_get_eee;
+		ops->eee_set		= r8152_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8156_hw_phy_cfg;
+		ops->autosuspend_en	= rtl8156_runtime_enable;
+		ops->change_mtu		= rtl8156_change_mtu;
+		tp->rx_buf_sz		= 48 * 1024;
+		tp->support_2500full	= 1;
+		break;
+
+	case RTL_VER_12:
+	case RTL_VER_13:
+		tp->support_2500full	= 1;
+		fallthrough;
+	case RTL_VER_15:
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
+		ops->init		= r8156b_init;
+		ops->enable		= rtl8156b_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8156_up;
+		ops->down		= rtl8156_down;
+		ops->unload		= rtl8153_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8153_get_eee;
+		ops->eee_set		= r8152_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8156b_hw_phy_cfg;
+		ops->autosuspend_en	= rtl8156_runtime_enable;
+		ops->change_mtu		= rtl8156_change_mtu;
+		tp->rx_buf_sz		= 48 * 1024;
+		break;
+
+	case RTL_VER_14:
+		ops->init		= r8153c_init;
+		ops->enable		= rtl8153_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8153c_up;
+		ops->down		= rtl8153b_down;
+		ops->unload		= rtl8153_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8153_get_eee;
+		ops->eee_set		= r8152_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->hw_phy_cfg		= r8153c_hw_phy_cfg;
+		ops->autosuspend_en	= rtl8153c_runtime_enable;
+		ops->change_mtu		= rtl8153c_change_mtu;
+		tp->rx_buf_sz		= 32 * 1024;
+		tp->eee_en		= true;
+		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
+		break;
+
+	default:
+		ret = -ENODEV;
+		dev_err(&tp->intf->dev, "Unknown Device\n");
+		break;
+	}
+
+	return ret;
+}
+
+static u8 __rtl_get_hw_ver(struct usb_device *udev)
+{
+	u32 ocp_data = 0;
+	__le32 *tmp;
+	u8 version;
+	int ret;
+
+	tmp = kmalloc(sizeof(*tmp), GFP_KERNEL);
+	if (!tmp)
+		return 0;
+
+	ret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+			      RTL8152_REQ_GET_REGS, RTL8152_REQT_READ,
+			      PLA_TCR0, MCU_TYPE_PLA, tmp, sizeof(*tmp), 500);
+	if (ret > 0)
+		ocp_data = (__le32_to_cpu(*tmp) >> 16) & VERSION_MASK;
+
+	kfree(tmp);
+
+	switch (ocp_data) {
+	case 0x4c00:
+		version = RTL_VER_01;
+		break;
+	case 0x4c10:
+		version = RTL_VER_02;
+		break;
+	case 0x5c00:
+		version = RTL_VER_03;
+		break;
+	case 0x5c10:
+		version = RTL_VER_04;
+		break;
+	case 0x5c20:
+		version = RTL_VER_05;
+		break;
+	case 0x5c30:
+		version = RTL_VER_06;
+		break;
+	case 0x4800:
+		version = RTL_VER_07;
+		break;
+	case 0x6000:
+		version = RTL_VER_08;
+		break;
+	case 0x6010:
+		version = RTL_VER_09;
+		break;
+	case 0x7010:
+		version = RTL_TEST_01;
+		break;
+	case 0x7020:
+		version = RTL_VER_10;
+		break;
+	case 0x7030:
+		version = RTL_VER_11;
+		break;
+	case 0x7400:
+		version = RTL_VER_12;
+		break;
+	case 0x7410:
+		version = RTL_VER_13;
+		break;
+	case 0x6400:
+		version = RTL_VER_14;
+		break;
+	case 0x7420:
+		version = RTL_VER_15;
+		break;
+	default:
+		version = RTL_VER_UNKNOWN;
+		dev_info(&udev->dev, "Unknown version 0x%04x\n", ocp_data);
+		break;
+	}
+
+	return version;
+}
+
+u8 rtl8152_get_version(struct usb_interface *intf)
+{
+	u8 version;
+
+	version = __rtl_get_hw_ver(interface_to_usbdev(intf));
+
+	dev_dbg(&intf->dev, "Detected version 0x%04x\n", version);
+
+	return version;
+}
+EXPORT_SYMBOL_GPL(rtl8152_get_version);
+
+#ifdef RTL8152_DEBUG
+
+static ssize_t
+ocp_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
+	struct net_device *netdev = to_net_dev(dev);
 	struct r8152 *tp = netdev_priv(netdev);
+	struct usb_interface *intf = tp->intf;
+	char tmp[256];
+	struct tally_counter tally;
 	int ret;
 
+	strcpy(buf, dev_name(dev));
+	strcat(buf, "\n");
+	strcat(buf, DRIVER_VERSION);
+	strcat(buf, "\n");
+
 	switch (tp->version) {
-	case RTL_VER_01:
-	case RTL_VER_02:
-	case RTL_VER_07:
-		return -EOPNOTSUPP;
+	case RTL_VER_05:
+		strcat(buf, "RTL_VER_05\n");
+		strcat(buf, "usb_patch_code_20190904\n");
+		strcat(buf, "pla_patch_code_20190220_0\n");
+		strcat(buf, "\n\n\n\n");
+		break;
+	case RTL_VER_06:
+		strcat(buf, "RTL_VER_06\n");
+		strcat(buf, "usb_patch_20190909\n");
+		strcat(buf, "pla_patch_code_20190408_0\n");
+		strcat(buf, "\n\n\n\n");
+		break;
+	case RTL_VER_09:
+		strcat(buf, "RTL_VER_09\n");
+		strcat(buf, "usb_patch_code_20190906.cfg\n");
+		strcat(buf, "plamcu_patch_code_20190408_0\n");
+		strcat(buf, "\n\n\n\n");
+		break;
+	case RTL_VER_11:
+		strcat(buf, "RTL_VER_11\n");
+		strcat(buf, "nc0_patch_190128_usb\n");
+		strcat(buf, "nc1_patch_181029_usb\n");
+		strcat(buf, "nc2_patch_180821_usb\n");
+		strcat(buf, "uc2_patch_181018_usb\n");
+		strcat(buf, "data_ram_patch_v02_usb\n");
+		strcat(buf, "100m_tx_coefficient_180716_usb\n");
+		strcat(buf, "USB_patch_code_20210310_v4\n");
+		strcat(buf, "PLA_patch_code_20210318_v6\n");
+		break;
+	case RTL_VER_12:
+		strcat(buf, "RTL_VER_12\n");
+		strcat(buf, "nc_patch_190821_usb\n");
+		strcat(buf, "nc2_patch_190823_usb\n");
+		strcat(buf, "uc2_patch_190817_usb\n");
+		strcat(buf, "uc_patch_190731_usb\n");
+		strcat(buf, "USB_patch_code_20190816_v2\n");
+		strcat(buf, "PLA_patch_code_20190827_v2\n");
+		break;
+	case RTL_VER_13:
+	case RTL_VER_15:
+		strcat(buf, "RTL_VER_13\n");
+		strcat(buf, "tgphy_ramcode_v21_usb_20220324\n");
+		strcat(buf, "\n");
+		strcat(buf, "\n");
+		strcat(buf, "\n");
+		strcat(buf, "USB_patch_code_20220314_v4\n");
+		strcat(buf, "PLA_SVN8948_20220330_v06\n");
+		break;
+	case RTL_VER_14:
+		strcat(buf, "RTL_VER_14\n");
+		strcat(buf, "USB_Patch_Code_svn3347\n");
+		strcat(buf, "PLA_Patch_Code_svn3346\n");
+		strcat(buf, "\n\n\n\n");
+		break;
 	default:
+		strcat(buf, "\n\n\n\n\n\n\n");
 		break;
 	}
 
-	if (coalesce->rx_coalesce_usecs > COALESCE_SLOW)
-		return -EINVAL;
-
-	ret = usb_autopm_get_interface(tp->intf);
+	ret = usb_autopm_get_interface(intf);
 	if (ret < 0)
 		return ret;
 
-	mutex_lock(&tp->control);
-
-	if (tp->coalesce != coalesce->rx_coalesce_usecs) {
-		tp->coalesce = coalesce->rx_coalesce_usecs;
-
-		if (netif_running(netdev) && netif_carrier_ok(netdev)) {
-			netif_stop_queue(netdev);
-			napi_disable(&tp->napi);
-			tp->rtl_ops.disable(tp);
-			tp->rtl_ops.enable(tp);
-			rtl_start_rx(tp);
-			clear_bit(RTL8152_SET_RX_MODE, &tp->flags);
-			_rtl8152_set_rx_mode(netdev);
-			napi_enable(&tp->napi);
-			netif_wake_queue(netdev);
-		}
+	ret = mutex_lock_interruptible(&tp->control);
+	if (ret < 0) {
+		usb_autopm_put_interface(intf);
+		goto err1;
 	}
 
+	generic_ocp_read(tp, PLA_TALLYCNT, sizeof(tally), &tally, MCU_TYPE_PLA);
+
 	mutex_unlock(&tp->control);
 
-	usb_autopm_put_interface(tp->intf);
+	usb_autopm_put_interface(intf);
+
+	sprintf(tmp, "tx_packets = %Lu\n", le64_to_cpu(tally.tx_packets));
+	strcat(buf, tmp);
+	sprintf(tmp, "rx_packets = %Lu\n", le64_to_cpu(tally.rx_packets));
+	strcat(buf, tmp);
+	sprintf(tmp, "tx_errors = %Lu\n", le64_to_cpu(tally.tx_errors));
+	strcat(buf, tmp);
+	sprintf(tmp, "tx_errors = %u\n", le32_to_cpu(tally.rx_errors));
+	strcat(buf, tmp);
+	sprintf(tmp, "rx_missed = %u\n", le16_to_cpu(tally.rx_missed));
+	strcat(buf, tmp);
+	sprintf(tmp, "align_errors = %u\n", le16_to_cpu(tally.align_errors));
+	strcat(buf, tmp);
+	sprintf(tmp, "tx_one_collision = %u\n",
+		le32_to_cpu(tally.tx_one_collision));
+	strcat(buf, tmp);
+	sprintf(tmp, "tx_multi_collision = %u\n",
+		le32_to_cpu(tally.tx_multi_collision));
+	strcat(buf, tmp);
+	sprintf(tmp, "rx_unicast = %Lu\n", le64_to_cpu(tally.rx_unicast));
+	strcat(buf, tmp);
+	sprintf(tmp, "rx_broadcast = %Lu\n", le64_to_cpu(tally.rx_broadcast));
+	strcat(buf, tmp);
+	sprintf(tmp, "rx_multicast = %u\n", le32_to_cpu(tally.rx_multicast));
+	strcat(buf, tmp);
+	sprintf(tmp, "tx_aborted = %u\n", le16_to_cpu(tally.tx_aborted));
+	strcat(buf, tmp);
+	sprintf(tmp, "tx_underrun = %u\n", le16_to_cpu(tally.tx_underrun));
+	strcat(buf, tmp);
 
-	return ret;
+err1:
+	if (ret < 0)
+		return ret;
+	else
+		return strlen(buf);
 }
 
-static int rtl8152_get_tunable(struct net_device *netdev,
-			       const struct ethtool_tunable *tunable, void *d)
+static inline bool hex_value(char p)
 {
-	struct r8152 *tp = netdev_priv(netdev);
-
-	switch (tunable->id) {
-	case ETHTOOL_RX_COPYBREAK:
-		*(u32 *)d = tp->rx_copybreak;
-		break;
-	default:
-		return -EOPNOTSUPP;
-	}
-
-	return 0;
+	return (p >= '0' && p <= '9') ||
+	       (p >= 'a' && p <= 'f') ||
+	       (p >= 'A' && p <= 'F');
 }
 
-static int rtl8152_set_tunable(struct net_device *netdev,
-			       const struct ethtool_tunable *tunable,
-			       const void *d)
+static int ocp_count(char *v1)
 {
-	struct r8152 *tp = netdev_priv(netdev);
-	u32 val;
+	int len = strlen(v1), count = 0;
+	char *v2 = strchr(v1, ' ');
+	bool is_vaild = false;
 
-	switch (tunable->id) {
-	case ETHTOOL_RX_COPYBREAK:
-		val = *(u32 *)d;
-		if (val < ETH_ZLEN) {
-			netif_err(tp, rx_err, netdev,
-				  "Invalid rx copy break value\n");
-			return -EINVAL;
-		}
+	if (len < 5 || !v2)
+		goto out1;
+//	else if (strncmp(v1, "pla ", 4) && strncmp(v1, "usb ", 4))
+//		goto out1;
 
-		if (tp->rx_copybreak != val) {
-			if (netdev->flags & IFF_UP) {
-				mutex_lock(&tp->control);
-				napi_disable(&tp->napi);
-				tp->rx_copybreak = val;
-				napi_enable(&tp->napi);
-				mutex_unlock(&tp->control);
-			} else {
-				tp->rx_copybreak = val;
-			}
-		}
-		break;
-	default:
-		return -EOPNOTSUPP;
+	v1 = v2;
+	len = strlen(v2);
+	while(len) {
+		if (*v1 != ' ')
+			break;
+		v1++;
+		len--;
 	}
 
-	return 0;
-}
-
-static void rtl8152_get_ringparam(struct net_device *netdev,
-				  struct ethtool_ringparam *ring,
-				  struct kernel_ethtool_ringparam *kernel_ring,
-				  struct netlink_ext_ack *extack)
-{
-	struct r8152 *tp = netdev_priv(netdev);
-
-	ring->rx_max_pending = RTL8152_RX_MAX_PENDING;
-	ring->rx_pending = tp->rx_pending;
-}
+	if (!len || *v1 == '\n')
+		goto out1;
 
-static int rtl8152_set_ringparam(struct net_device *netdev,
-				 struct ethtool_ringparam *ring,
-				 struct kernel_ethtool_ringparam *kernel_ring,
-				 struct netlink_ext_ack *extack)
-{
-	struct r8152 *tp = netdev_priv(netdev);
+check:
+	v2 = strchr(v1, ' ');
 
-	if (ring->rx_pending < (RTL8152_MAX_RX * 2))
-		return -EINVAL;
+	if (len > 2 && !strncasecmp(v1, "0x", 2)) {
+		v1 += 2;
+		len -= 2;
+		if (v1 == v2 || *v1 == '\n')
+			goto out1;
+	}
 
-	if (tp->rx_pending != ring->rx_pending) {
-		if (netdev->flags & IFF_UP) {
-			mutex_lock(&tp->control);
-			napi_disable(&tp->napi);
-			tp->rx_pending = ring->rx_pending;
-			napi_enable(&tp->napi);
-			mutex_unlock(&tp->control);
-		} else {
-			tp->rx_pending = ring->rx_pending;
+	if (v2) {
+		while (v1 < v2) {
+			if (!hex_value(*v1))
+				goto out1;
+			v1++;
+			len--;
 		}
-	}
 
-	return 0;
-}
+		count++;
 
-static void rtl8152_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
-{
-	struct r8152 *tp = netdev_priv(netdev);
-	u16 bmcr, lcladv, rmtadv;
-	u8 cap;
+		while(len) {
+			if (*v1 != ' ')
+				break;
+			v1++;
+			len--;
+		}
 
-	if (usb_autopm_get_interface(tp->intf) < 0)
-		return;
+		if (len)
+			goto check;
 
-	mutex_lock(&tp->control);
+		is_vaild = true;
+	} else {
+		int i;
 
-	bmcr = r8152_mdio_read(tp, MII_BMCR);
-	lcladv = r8152_mdio_read(tp, MII_ADVERTISE);
-	rmtadv = r8152_mdio_read(tp, MII_LPA);
+		if (len && v1[len - 1] == '\n')
+			len--;
 
-	mutex_unlock(&tp->control);
+		for (i = 0; i < len; i++) {
+			if (!hex_value(*v1))
+				goto out1;
+			v1++;
+		}
 
-	usb_autopm_put_interface(tp->intf);
+		if (len)
+			count++;
 
-	if (!(bmcr & BMCR_ANENABLE)) {
-		pause->autoneg = 0;
-		pause->rx_pause = 0;
-		pause->tx_pause = 0;
-		return;
+		is_vaild = true;
 	}
 
-	pause->autoneg = 1;
-
-	cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);
-
-	if (cap & FLOW_CTRL_RX)
-		pause->rx_pause = 1;
-
-	if (cap & FLOW_CTRL_TX)
-		pause->tx_pause = 1;
+out1:
+	if (is_vaild)
+		return count;
+	else
+		return 0;
 }
 
-static int rtl8152_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
+static ssize_t ocp_store(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
 {
+	struct net_device *netdev = to_net_dev(dev);
 	struct r8152 *tp = netdev_priv(netdev);
-	u16 old, new1;
-	u8 cap = 0;
-	int ret;
-
-	ret = usb_autopm_get_interface(tp->intf);
-	if (ret < 0)
-		return ret;
-
-	mutex_lock(&tp->control);
-
-	if (pause->autoneg && !(r8152_mdio_read(tp, MII_BMCR) & BMCR_ANENABLE)) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	if (pause->rx_pause)
-		cap |= FLOW_CTRL_RX;
-
-	if (pause->tx_pause)
-		cap |= FLOW_CTRL_TX;
-
-	old = r8152_mdio_read(tp, MII_ADVERTISE);
-	new1 = (old & ~(ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM)) | mii_advertise_flowctrl(cap);
-	if (old != new1)
-		r8152_mdio_write(tp, MII_ADVERTISE, new1);
-
-out:
-	mutex_unlock(&tp->control);
-	usb_autopm_put_interface(tp->intf);
+	struct usb_interface *intf = tp->intf;
+	u32 v1, v2, v3, v4;
+	u16 type;
+	int num, ret;
 
-	return ret;
-}
+	if (!strncmp(buf, "pla ", 4))
+		type = MCU_TYPE_PLA;
+	else if (!strncmp(buf, "usb ", 4))
+		type = MCU_TYPE_USB;
+	else
+		return -EINVAL;
 
-static const struct ethtool_ops ops = {
-	.supported_coalesce_params = ETHTOOL_COALESCE_USECS,
-	.get_drvinfo = rtl8152_get_drvinfo,
-	.get_link = ethtool_op_get_link,
-	.nway_reset = rtl8152_nway_reset,
-	.get_msglevel = rtl8152_get_msglevel,
-	.set_msglevel = rtl8152_set_msglevel,
-	.get_wol = rtl8152_get_wol,
-	.set_wol = rtl8152_set_wol,
-	.get_strings = rtl8152_get_strings,
-	.get_sset_count = rtl8152_get_sset_count,
-	.get_ethtool_stats = rtl8152_get_ethtool_stats,
-	.get_coalesce = rtl8152_get_coalesce,
-	.set_coalesce = rtl8152_set_coalesce,
-	.get_eee = rtl_ethtool_get_eee,
-	.set_eee = rtl_ethtool_set_eee,
-	.get_link_ksettings = rtl8152_get_link_ksettings,
-	.set_link_ksettings = rtl8152_set_link_ksettings,
-	.get_tunable = rtl8152_get_tunable,
-	.set_tunable = rtl8152_set_tunable,
-	.get_ringparam = rtl8152_get_ringparam,
-	.set_ringparam = rtl8152_set_ringparam,
-	.get_pauseparam = rtl8152_get_pauseparam,
-	.set_pauseparam = rtl8152_set_pauseparam,
-};
+	if (!ocp_count((char *)buf))
+		return -EINVAL;
 
-static int rtl8152_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
-{
-	struct r8152 *tp = netdev_priv(netdev);
-	struct mii_ioctl_data *data = if_mii(rq);
-	int res;
+	num = sscanf(strchr(buf, ' '), "%x %x %x %x\n", &v1, &v2, &v3, &v4);
 
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return -ENODEV;
+	if (num > 1) {
+		if ((v1 == 2 && (v2 & 1)) ||
+		    (v1 == 4 && (v2 & 3)) ||
+		    (type == MCU_TYPE_PLA &&
+		     (v2 < 0xc000 || (v2 & ~3) == PLA_OCP_GPHY_BASE)))
+			return -EINVAL;
+	}
 
-	res = usb_autopm_get_interface(tp->intf);
-	if (res < 0)
-		goto out;
+	ret = usb_autopm_get_interface(intf);
+	if (ret < 0)
+		return ret;
 
-	switch (cmd) {
-	case SIOCGMIIPHY:
-		data->phy_id = R8152_PHY_ID; /* Internal PHY */
-		break;
+	ret = mutex_lock_interruptible(&tp->control);
+	if (ret < 0)
+		goto put;
 
-	case SIOCGMIIREG:
-		mutex_lock(&tp->control);
-		data->val_out = r8152_mdio_read(tp, data->reg_num);
-		mutex_unlock(&tp->control);
+	switch(num) {
+	case 2:
+		switch (v1) {
+		case 1:
+			netif_info(tp, drv, netdev, "%s read byte %x = %x\n",
+				   type ? "PLA" : "USB", v2,
+				   ocp_read_byte(tp, type, v2));
+			break;
+		case 2:
+			netif_info(tp, drv, netdev, "%s read word %x = %x\n",
+				   type ? "PLA" : "USB", v2,
+				   ocp_read_word(tp, type, v2));
+			break;
+		case 4:
+			netif_info(tp, drv, netdev, "%s read dword %x = %x\n",
+				   type ? "PLA" : "USB", v2,
+				   ocp_read_dword(tp, type, v2));
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
 		break;
-
-	case SIOCSMIIREG:
-		if (!capable(CAP_NET_ADMIN)) {
-			res = -EPERM;
+	case 3:
+		switch (v1) {
+		case 1:
+			netif_info(tp, drv, netdev, "%s write byte %x = %x\n",
+				   type ? "PLA" : "USB", v2, v3);
+			ocp_write_byte(tp, type, v2, v3);
+			break;
+		case 2:
+			netif_info(tp, drv, netdev, "%s write word %x = %x\n",
+				   type ? "PLA" : "USB", v2, v3);
+			ocp_write_word(tp, type, v2, v3);
+			break;
+		case 4:
+			netif_info(tp, drv, netdev, "%s write dword %x = %x\n",
+				   type ? "PLA" : "USB", v2, v3);
+			ocp_write_dword(tp, type, v2, v3);
+			break;
+		default:
+			ret = -EINVAL;
 			break;
 		}
-		mutex_lock(&tp->control);
-		r8152_mdio_write(tp, data->reg_num, data->val_in);
-		mutex_unlock(&tp->control);
 		break;
-
+	case 4:
+	case 1:
 	default:
-		res = -EOPNOTSUPP;
+		ret = -EINVAL;
+		break;
 	}
 
-	usb_autopm_put_interface(tp->intf);
+	mutex_unlock(&tp->control);
 
-out:
-	return res;
+put:
+	usb_autopm_put_interface(intf);
+
+	if (ret < 0)
+		return ret;
+	else
+		return count;
 }
 
-static int rtl8152_change_mtu(struct net_device *dev, int new_mtu)
+static DEVICE_ATTR_RW(ocp);
+
+static struct attribute *rtk_attrs[] = {
+	&dev_attr_ocp.attr,
+	NULL
+};
+
+#define ATTR_PLA_SIZE	0x3000
+
+/* hexdump -e '"%04_ax\t" 16/1 "%02X " "\n"' pla */
+static ssize_t pla_read(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf, loff_t offset,
+			size_t size)
 {
-	struct r8152 *tp = netdev_priv(dev);
+	struct device *dev = kobj_to_dev(kobj);
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
 	int ret;
 
-	switch (tp->version) {
-	case RTL_VER_01:
-	case RTL_VER_02:
-	case RTL_VER_07:
-		dev->mtu = new_mtu;
-		return 0;
-	default:
-		break;
-	}
+	if (size <= ATTR_PLA_SIZE)
+		size = min(size, ATTR_PLA_SIZE - (size_t)offset);
+	else
+		return -EINVAL;
 
 	ret = usb_autopm_get_interface(tp->intf);
 	if (ret < 0)
 		return ret;
 
-	mutex_lock(&tp->control);
-
-	dev->mtu = new_mtu;
-
-	if (netif_running(dev)) {
-		if (tp->rtl_ops.change_mtu)
-			tp->rtl_ops.change_mtu(tp);
+	/* rtnl_lock(); */
+	ret = mutex_lock_interruptible(&tp->control);
+	if (ret < 0)
+		goto put;
 
-		if (netif_carrier_ok(dev)) {
-			netif_stop_queue(dev);
-			napi_disable(&tp->napi);
-			tasklet_disable(&tp->tx_tl);
-			tp->rtl_ops.disable(tp);
-			tp->rtl_ops.enable(tp);
-			rtl_start_rx(tp);
-			tasklet_enable(&tp->tx_tl);
-			napi_enable(&tp->napi);
-			rtl8152_set_rx_mode(dev);
-			netif_wake_queue(dev);
-		}
-	}
+	ret = pla_ocp_read(tp, offset + 0xc000, (u16)size, buf);
+	if (ret < 0)
+		netif_err(tp, drv, netdev,
+			  "Read PLA offset 0x%Lx, len = %zd fail\n",
+			  offset + 0xc000, size);
 
 	mutex_unlock(&tp->control);
+	/* rtnl_unlock(); */
 
+put:
 	usb_autopm_put_interface(tp->intf);
 
-	return ret;
+	if (ret < 0)
+		return ret;
+	else
+		return size;
 }
 
-static const struct net_device_ops rtl8152_netdev_ops = {
-	.ndo_open		= rtl8152_open,
-	.ndo_stop		= rtl8152_close,
-	.ndo_eth_ioctl		= rtl8152_ioctl,
-	.ndo_start_xmit		= rtl8152_start_xmit,
-	.ndo_tx_timeout		= rtl8152_tx_timeout,
-	.ndo_set_features	= rtl8152_set_features,
-	.ndo_set_rx_mode	= rtl8152_set_rx_mode,
-	.ndo_set_mac_address	= rtl8152_set_mac_address,
-	.ndo_change_mtu		= rtl8152_change_mtu,
-	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_features_check	= rtl8152_features_check,
+static BIN_ATTR_RO(pla, ATTR_PLA_SIZE);
+
+static struct bin_attribute *rtk_bin_attrs[] = {
+	&bin_attr_pla,
+	NULL
 };
 
-static void rtl8152_unload(struct r8152 *tp)
+static struct attribute_group rtk_dbg_grp = {
+	.name = "nic_swsd",
+	.attrs = rtk_attrs,
+	.bin_attrs = rtk_bin_attrs,
+};
+
+#endif /* RTL8152_DEBUG */
+
+static ssize_t rx_copybreak_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
 {
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return;
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+
+	sprintf(buf, "%u\n", tp->rx_copybreak);
 
-	if (tp->version != RTL_VER_01)
-		r8152_power_cut_en(tp, true);
+	return strlen(buf);
 }
 
-static void rtl8153_unload(struct r8152 *tp)
+static ssize_t rx_copybreak_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
 {
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+	u32 rx_copybreak;
+
+	if (sscanf(buf, "%u\n", &rx_copybreak) != 1)
+		return -EINVAL;
+
+	if (rx_copybreak < ETH_ZLEN)
+		return -EINVAL;
+
 	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return;
+		return -ENODEV;
 
-	r8153_power_cut_en(tp, false);
+	if (tp->rx_copybreak != rx_copybreak) {
+		if (tp->netdev->flags & IFF_UP) {
+			int ret;
+
+			ret = mutex_lock_interruptible(&tp->control);
+			if (ret < 0)
+				return ret;
+
+			napi_disable(&tp->napi);
+			tp->rx_copybreak = rx_copybreak;
+			napi_enable(&tp->napi);
+
+			mutex_unlock(&tp->control);
+		} else {
+			tp->rx_copybreak = rx_copybreak;
+		}
+	}
+
+	return count;
 }
 
-static void rtl8153b_unload(struct r8152 *tp)
+static DEVICE_ATTR_RW(rx_copybreak);
+
+static ssize_t fc_pause_on_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
 {
-	if (test_bit(RTL8152_UNPLUG, &tp->flags))
-		return;
+	struct r8152 *tp = netdev_priv(to_net_dev(dev));
 
-	r8153b_power_cut_en(tp, false);
+	if (!tp->fc_pause_on)
+		sprintf(buf, "(Auto)%u\n", fc_pause_on_auto(tp));
+	else
+		sprintf(buf, "%u\n", tp->fc_pause_on);
+
+	return strlen(buf);
 }
 
-static int rtl_ops_init(struct r8152 *tp)
+static ssize_t fc_pause_on_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
 {
-	struct rtl_ops *ops = &tp->rtl_ops;
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+	struct usb_interface *intf = tp->intf;
+	u32 pause_on, pause_off, tmp;
 	int ret = 0;
 
-	switch (tp->version) {
-	case RTL_VER_01:
-	case RTL_VER_02:
-	case RTL_VER_07:
-		ops->init		= r8152b_init;
-		ops->enable		= rtl8152_enable;
-		ops->disable		= rtl8152_disable;
-		ops->up			= rtl8152_up;
-		ops->down		= rtl8152_down;
-		ops->unload		= rtl8152_unload;
-		ops->eee_get		= r8152_get_eee;
-		ops->eee_set		= r8152_set_eee;
-		ops->in_nway		= rtl8152_in_nway;
-		ops->hw_phy_cfg		= r8152b_hw_phy_cfg;
-		ops->autosuspend_en	= rtl_runtime_suspend_enable;
-		tp->rx_buf_sz		= 16 * 1024;
-		tp->eee_en		= true;
-		tp->eee_adv		= MDIO_EEE_100TX;
-		break;
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
 
-	case RTL_VER_03:
-	case RTL_VER_04:
-	case RTL_VER_05:
-	case RTL_VER_06:
-		ops->init		= r8153_init;
-		ops->enable		= rtl8153_enable;
-		ops->disable		= rtl8153_disable;
-		ops->up			= rtl8153_up;
-		ops->down		= rtl8153_down;
-		ops->unload		= rtl8153_unload;
-		ops->eee_get		= r8153_get_eee;
-		ops->eee_set		= r8152_set_eee;
-		ops->in_nway		= rtl8153_in_nway;
-		ops->hw_phy_cfg		= r8153_hw_phy_cfg;
-		ops->autosuspend_en	= rtl8153_runtime_enable;
-		ops->change_mtu		= rtl8153_change_mtu;
-		if (tp->udev->speed < USB_SPEED_SUPER)
-			tp->rx_buf_sz	= 16 * 1024;
-		else
-			tp->rx_buf_sz	= 32 * 1024;
-		tp->eee_en		= true;
-		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
-		break;
+	if (sscanf(buf, "%u\n", &pause_on) != 1)
+		return -EINVAL;
 
-	case RTL_VER_08:
-	case RTL_VER_09:
-		ops->init		= r8153b_init;
-		ops->enable		= rtl8153_enable;
-		ops->disable		= rtl8153_disable;
-		ops->up			= rtl8153b_up;
-		ops->down		= rtl8153b_down;
-		ops->unload		= rtl8153b_unload;
-		ops->eee_get		= r8153_get_eee;
-		ops->eee_set		= r8152_set_eee;
-		ops->in_nway		= rtl8153_in_nway;
-		ops->hw_phy_cfg		= r8153b_hw_phy_cfg;
-		ops->autosuspend_en	= rtl8153b_runtime_enable;
-		ops->change_mtu		= rtl8153_change_mtu;
-		tp->rx_buf_sz		= 32 * 1024;
-		tp->eee_en		= true;
-		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
-		break;
+	if (tp->fc_pause_off)
+		pause_off = tp->fc_pause_off;
+	else
+		pause_off = fc_pause_off_auto(tp);
 
-	case RTL_VER_11:
-		tp->eee_en		= true;
-		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
-		fallthrough;
-	case RTL_VER_10:
-		ops->init		= r8156_init;
-		ops->enable		= rtl8156_enable;
-		ops->disable		= rtl8153_disable;
-		ops->up			= rtl8156_up;
-		ops->down		= rtl8156_down;
-		ops->unload		= rtl8153_unload;
-		ops->eee_get		= r8153_get_eee;
-		ops->eee_set		= r8152_set_eee;
-		ops->in_nway		= rtl8153_in_nway;
-		ops->hw_phy_cfg		= r8156_hw_phy_cfg;
-		ops->autosuspend_en	= rtl8156_runtime_enable;
-		ops->change_mtu		= rtl8156_change_mtu;
-		tp->rx_buf_sz		= 48 * 1024;
-		tp->support_2500full	= 1;
-		break;
+	if (pause_on)
+		tmp = pause_on;
+	else
+		tmp = fc_pause_on_auto(tp);
 
-	case RTL_VER_12:
-	case RTL_VER_13:
-		tp->support_2500full	= 1;
-		fallthrough;
-	case RTL_VER_15:
-		tp->eee_en		= true;
-		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
-		ops->init		= r8156b_init;
-		ops->enable		= rtl8156b_enable;
-		ops->disable		= rtl8153_disable;
-		ops->up			= rtl8156_up;
-		ops->down		= rtl8156_down;
-		ops->unload		= rtl8153_unload;
-		ops->eee_get		= r8153_get_eee;
-		ops->eee_set		= r8152_set_eee;
-		ops->in_nway		= rtl8153_in_nway;
-		ops->hw_phy_cfg		= r8156b_hw_phy_cfg;
-		ops->autosuspend_en	= rtl8156_runtime_enable;
-		ops->change_mtu		= rtl8156_change_mtu;
-		tp->rx_buf_sz		= 48 * 1024;
-		break;
+	if (tmp >= pause_off) {
+		netif_err(tp, drv, netdev, "fc_pause_on must be less than %u\n",
+			  pause_off);
+		return -EINVAL;
+	}
 
-	case RTL_VER_14:
-		ops->init		= r8153c_init;
-		ops->enable		= rtl8153_enable;
-		ops->disable		= rtl8153_disable;
-		ops->up			= rtl8153c_up;
-		ops->down		= rtl8153b_down;
-		ops->unload		= rtl8153_unload;
-		ops->eee_get		= r8153_get_eee;
-		ops->eee_set		= r8152_set_eee;
-		ops->in_nway		= rtl8153_in_nway;
-		ops->hw_phy_cfg		= r8153c_hw_phy_cfg;
-		ops->autosuspend_en	= rtl8153c_runtime_enable;
-		ops->change_mtu		= rtl8153c_change_mtu;
-		tp->rx_buf_sz		= 32 * 1024;
-		tp->eee_en		= true;
-		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
-		break;
+	if (tp->fc_pause_on != pause_on) {
+		ret = usb_autopm_get_interface(intf);
+		if (ret < 0)
+			return ret;
+
+		ret = mutex_lock_interruptible(&tp->control);
+		if (ret < 0)
+			goto put;
+
+		tp->fc_pause_on = pause_on;
 
-	default:
-		ret = -ENODEV;
-		dev_err(&tp->intf->dev, "Unknown Device\n");
-		break;
+		if (netdev->flags & IFF_UP) {
+			r8156_fc_parameter(tp);
+
+			if (netif_carrier_ok(netdev)) {
+				netif_stop_queue(netdev);
+				napi_disable(&tp->napi);
+				tasklet_disable(&tp->tx_tl);
+				tp->rtl_ops.disable(tp);
+				tp->rtl_ops.enable(tp);
+				rtl_start_rx(tp);
+				tasklet_enable(&tp->tx_tl);
+				napi_enable(&tp->napi);
+				rtl8152_set_rx_mode(netdev);
+				netif_wake_queue(netdev);
+			}
+		}
+
+		mutex_unlock(&tp->control);
+
+put:
+		usb_autopm_put_interface(intf);
 	}
 
-	return ret;
+	if (ret < 0)
+		return ret;
+	else
+		return count;
 }
 
-#define FIRMWARE_8153A_2	"rtl_nic/rtl8153a-2.fw"
-#define FIRMWARE_8153A_3	"rtl_nic/rtl8153a-3.fw"
-#define FIRMWARE_8153A_4	"rtl_nic/rtl8153a-4.fw"
-#define FIRMWARE_8153B_2	"rtl_nic/rtl8153b-2.fw"
-#define FIRMWARE_8153C_1	"rtl_nic/rtl8153c-1.fw"
-#define FIRMWARE_8156A_2	"rtl_nic/rtl8156a-2.fw"
-#define FIRMWARE_8156B_2	"rtl_nic/rtl8156b-2.fw"
+static DEVICE_ATTR_RW(fc_pause_on);
+
+static ssize_t fc_pause_off_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct r8152 *tp = netdev_priv(to_net_dev(dev));
+
+	if (!tp->fc_pause_off)
+		sprintf(buf, "(Auto)%u\n", fc_pause_off_auto(tp));
+	else
+		sprintf(buf, "%u\n", tp->fc_pause_off);
 
-MODULE_FIRMWARE(FIRMWARE_8153A_2);
-MODULE_FIRMWARE(FIRMWARE_8153A_3);
-MODULE_FIRMWARE(FIRMWARE_8153A_4);
-MODULE_FIRMWARE(FIRMWARE_8153B_2);
-MODULE_FIRMWARE(FIRMWARE_8153C_1);
-MODULE_FIRMWARE(FIRMWARE_8156A_2);
-MODULE_FIRMWARE(FIRMWARE_8156B_2);
+	return strlen(buf);
+}
 
-static int rtl_fw_init(struct r8152 *tp)
+static ssize_t fc_pause_off_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
 {
-	struct rtl_fw *rtl_fw = &tp->rtl_fw;
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+	struct usb_interface *intf = tp->intf;
+	u32 pause_on, pause_off, tmp;
+	int ret = 0;
 
-	switch (tp->version) {
-	case RTL_VER_04:
-		rtl_fw->fw_name		= FIRMWARE_8153A_2;
-		rtl_fw->pre_fw		= r8153_pre_firmware_1;
-		rtl_fw->post_fw		= r8153_post_firmware_1;
-		break;
-	case RTL_VER_05:
-		rtl_fw->fw_name		= FIRMWARE_8153A_3;
-		rtl_fw->pre_fw		= r8153_pre_firmware_2;
-		rtl_fw->post_fw		= r8153_post_firmware_2;
-		break;
-	case RTL_VER_06:
-		rtl_fw->fw_name		= FIRMWARE_8153A_4;
-		rtl_fw->post_fw		= r8153_post_firmware_3;
-		break;
-	case RTL_VER_09:
-		rtl_fw->fw_name		= FIRMWARE_8153B_2;
-		rtl_fw->pre_fw		= r8153b_pre_firmware_1;
-		rtl_fw->post_fw		= r8153b_post_firmware_1;
-		break;
-	case RTL_VER_11:
-		rtl_fw->fw_name		= FIRMWARE_8156A_2;
-		rtl_fw->post_fw		= r8156a_post_firmware_1;
-		break;
-	case RTL_VER_13:
-	case RTL_VER_15:
-		rtl_fw->fw_name		= FIRMWARE_8156B_2;
-		break;
-	case RTL_VER_14:
-		rtl_fw->fw_name		= FIRMWARE_8153C_1;
-		rtl_fw->pre_fw		= r8153b_pre_firmware_1;
-		rtl_fw->post_fw		= r8153c_post_firmware_1;
-		break;
-	default:
-		break;
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	if (sscanf(buf, "%u\n", &pause_off) != 1)
+		return -EINVAL;
+
+	if (tp->fc_pause_on)
+		pause_on = tp->fc_pause_on;
+	else
+		pause_on = fc_pause_on_auto(tp);
+
+	if (pause_off)
+		tmp = pause_off;
+	else
+		tmp = fc_pause_off_auto(tp);
+
+	if (tmp <= pause_on){
+		netif_err(tp, drv, netdev, "fc_pause_off must be more than %u\n",
+			  pause_on);
+		return -EINVAL;
 	}
 
-	return 0;
+	if (tp->fc_pause_off != pause_off) {
+		ret = usb_autopm_get_interface(intf);
+		if (ret < 0)
+			return ret;
+
+		ret = mutex_lock_interruptible(&tp->control);
+		if (ret < 0)
+			goto put;
+
+		tp->fc_pause_off = pause_off;
+
+		if (netdev->flags & IFF_UP) {
+			r8156_fc_parameter(tp);
+
+			if (netif_carrier_ok(netdev)) {
+				netif_stop_queue(netdev);
+				napi_disable(&tp->napi);
+				tasklet_disable(&tp->tx_tl);
+				tp->rtl_ops.disable(tp);
+				tp->rtl_ops.enable(tp);
+				rtl_start_rx(tp);
+				tasklet_enable(&tp->tx_tl);
+				napi_enable(&tp->napi);
+				rtl8152_set_rx_mode(netdev);
+				netif_wake_queue(netdev);
+			}
+		}
+
+		mutex_unlock(&tp->control);
+
+put:
+		usb_autopm_put_interface(intf);
+	}
+
+	if (ret < 0)
+		return ret;
+	else
+		return count;
 }
 
-u8 rtl8152_get_version(struct usb_interface *intf)
-{
-	struct usb_device *udev = interface_to_usbdev(intf);
-	u32 ocp_data = 0;
-	__le32 *tmp;
-	u8 version;
-	int ret;
+static DEVICE_ATTR_RW(fc_pause_off);
 
-	tmp = kmalloc(sizeof(*tmp), GFP_KERNEL);
-	if (!tmp)
-		return 0;
+static ssize_t
+sg_en_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
 
-	ret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
-			      RTL8152_REQ_GET_REGS, RTL8152_REQT_READ,
-			      PLA_TCR0, MCU_TYPE_PLA, tmp, sizeof(*tmp), 500);
-	if (ret > 0)
-		ocp_data = (__le32_to_cpu(*tmp) >> 16) & VERSION_MASK;
+	if (tp->sg_use)
+		strcat(buf, "enable\n");
+	else
+		strcat(buf, "disable\n");
 
-	kfree(tmp);
+	return strlen(buf);
+}
 
-	switch (ocp_data) {
-	case 0x4c00:
-		version = RTL_VER_01;
-		break;
-	case 0x4c10:
-		version = RTL_VER_02;
-		break;
-	case 0x5c00:
-		version = RTL_VER_03;
-		break;
-	case 0x5c10:
-		version = RTL_VER_04;
-		break;
-	case 0x5c20:
-		version = RTL_VER_05;
-		break;
-	case 0x5c30:
-		version = RTL_VER_06;
-		break;
-	case 0x4800:
-		version = RTL_VER_07;
-		break;
-	case 0x6000:
-		version = RTL_VER_08;
-		break;
-	case 0x6010:
-		version = RTL_VER_09;
-		break;
-	case 0x7010:
-		version = RTL_TEST_01;
-		break;
-	case 0x7020:
-		version = RTL_VER_10;
-		break;
-	case 0x7030:
-		version = RTL_VER_11;
-		break;
-	case 0x7400:
-		version = RTL_VER_12;
-		break;
-	case 0x7410:
-		version = RTL_VER_13;
-		break;
-	case 0x6400:
-		version = RTL_VER_14;
-		break;
-	case 0x7420:
-		version = RTL_VER_15;
-		break;
-	default:
-		version = RTL_VER_UNKNOWN;
-		dev_info(&intf->dev, "Unknown version 0x%04x\n", ocp_data);
-		break;
+static ssize_t sg_en_store(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	struct r8152 *tp = netdev_priv(netdev);
+	u32 tso_size;
+
+	if (!strncmp(buf, "enable", 6) &&
+	    usb_device_no_sg_constraint(tp->udev)) {
+		tp->sg_use = true;
+		tso_size = TSO_LEGACY_MAX_SIZE;
+	} else if (!strncmp(buf, "disable", 7)) {
+		tp->sg_use = false;
+		tso_size = RTL_LIMITED_TSO_SIZE;
+	} else {
+		return -EINVAL;
 	}
 
-	dev_dbg(&intf->dev, "Detected version 0x%04x\n", version);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	netif_set_tso_max_size(netdev, tso_size);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26) */
 
-	return version;
+	return count;
 }
-EXPORT_SYMBOL_GPL(rtl8152_get_version);
+
+static DEVICE_ATTR_RW(sg_en);
+
+static struct attribute *rtk_adv_attrs[] = {
+	&dev_attr_rx_copybreak.attr,
+	&dev_attr_sg_en.attr,
+	&dev_attr_fc_pause_on.attr,
+	&dev_attr_fc_pause_off.attr,
+	NULL
+};
+
+static struct attribute_group rtk_adv_grp = {
+	.name = "rtl_adv",
+	.attrs = rtk_adv_attrs,
+};
 
 static bool rtl8152_supports_lenovo_macpassthru(struct usb_device *udev)
 {
@@ -9606,20 +20904,59 @@ static bool rtl8152_supports_lenovo_macpassthru(struct usb_device *udev)
 	return 0;
 }
 
+static void rtl_get_mapt_ver(struct r8152 *tp)
+{
+	struct usb_device *udev = tp->udev;
+	u32 ocp_data;
+
+	/* test for -AD variant of RTL8153 */
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);
+	if ((ocp_data & AD_MASK) == 0x1000) {
+		/* test for MAC address pass-through bit */
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_EFUSE);
+		if (ocp_data & PASS_THRU_MASK) {
+			tp->dell_macpassthru = 1;
+			return;
+		}
+	}
+
+	/* test for RTL8153-BND and RTL8153-BD */
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_1);
+	if ((ocp_data & BND_MASK) || (ocp_data & BD_MASK)) {
+		tp->dell_macpassthru = 1;
+		return;
+	}
+
+	tp->lenovo_macpassthru = rtl8152_supports_lenovo_macpassthru(udev);
+}
+
 static int rtl8152_probe(struct usb_interface *intf,
 			 const struct usb_device_id *id)
 {
 	struct usb_device *udev = interface_to_usbdev(intf);
-	u8 version = rtl8152_get_version(intf);
 	struct r8152 *tp;
 	struct net_device *netdev;
+	u8 version;
 	int ret;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0)
+	version = rtl8152_get_version(intf);
 	if (version == RTL_VER_UNKNOWN)
 		return -ENODEV;
 
 	if (!rtl_vendor_mode(intf))
 		return -ENODEV;
+#else
+	if (intf->cur_altsetting->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC)
+		return -ENODEV;
+
+	if (!rtl_check_vendor_ok(intf))
+		return -ENODEV;
+
+	version = rtl8152_get_version(intf);
+	if (version == RTL_VER_UNKNOWN)
+		return -ENODEV;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0) */
 
 	usb_reset_device(udev);
 	netdev = alloc_etherdev(sizeof(struct r8152));
@@ -9658,21 +20995,43 @@ static int rtl8152_probe(struct usb_interface *intf,
 	if (ret)
 		goto out;
 
-	rtl_fw_init(tp);
-
 	mutex_init(&tp->control);
 	INIT_DELAYED_WORK(&tp->schedule, rtl_work_func_t);
 	INIT_DELAYED_WORK(&tp->hw_phy_work, rtl_hw_phy_work_func_t);
 	tasklet_setup(&tp->tx_tl, bottom_half);
 	tasklet_disable(&tp->tx_tl);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,2,3)
+	if (usb_device_no_sg_constraint(udev))
+		tp->sg_use = true;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,2,3) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	netdev->open = rtl8152_open;
+	netdev->stop = rtl8152_close;
+	netdev->get_stats = rtl8152_get_stats;
+	netdev->hard_start_xmit = rtl8152_start_xmit;
+	netdev->tx_timeout = rtl8152_tx_timeout;
+	netdev->change_mtu = rtl8152_change_mtu;
+	netdev->set_mac_address = rtl8152_set_mac_address;
+	netdev->do_ioctl = rtl8152_ioctl;
+	netdev->set_multicast_list = rtl8152_set_rx_mode;
+	netdev->vlan_rx_register = rtl8152_vlan_rx_register;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	netdev->vlan_rx_kill_vid = rtl8152_vlan_rx_kill_vid;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) */
+#else
 	netdev->netdev_ops = &rtl8152_netdev_ops;
+#endif /* HAVE_NET_DEVICE_OPS */
+
 	netdev->watchdog_timeo = RTL8152_TX_TIMEOUT;
 
 	netdev->features |= NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG |
 			    NETIF_F_TSO | NETIF_F_FRAGLIST | NETIF_F_IPV6_CSUM |
 			    NETIF_F_TSO6 | NETIF_F_HW_VLAN_CTAG_RX |
 			    NETIF_F_HW_VLAN_CTAG_TX;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)
 	netdev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG |
 			      NETIF_F_TSO | NETIF_F_FRAGLIST |
 			      NETIF_F_IPV6_CSUM | NETIF_F_TSO6 |
@@ -9680,24 +21039,26 @@ static int rtl8152_probe(struct usb_interface *intf,
 	netdev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
 				NETIF_F_HIGHDMA | NETIF_F_FRAGLIST |
 				NETIF_F_IPV6_CSUM | NETIF_F_TSO6;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39) */
 
 	if (tp->version == RTL_VER_01) {
 		netdev->features &= ~NETIF_F_RXCSUM;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)
 		netdev->hw_features &= ~NETIF_F_RXCSUM;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39) */
 	}
 
-	tp->lenovo_macpassthru = rtl8152_supports_lenovo_macpassthru(udev);
-
-	if (le16_to_cpu(udev->descriptor.bcdDevice) == 0x3011 && udev->serial &&
-	    (!strcmp(udev->serial, "000001000000") ||
-	     !strcmp(udev->serial, "000002000000"))) {
-		dev_info(&udev->dev, "Dell TB16 Dock, disable RX aggregation");
-		tp->dell_tb_rx_agg_bug = 1;
-	}
+	rtl_get_mapt_ver(tp);
 
 	netdev->ethtool_ops = &ops;
-	netif_set_tso_max_size(netdev, RTL_LIMITED_TSO_SIZE);
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if (!tp->sg_use)
+		netif_set_tso_max_size(netdev, RTL_LIMITED_TSO_SIZE);
+#else
+	netdev->features &= ~(NETIF_F_TSO | NETIF_F_TSO6);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
 	/* MTU range: 68 - 1500 or 9194 */
 	netdev->min_mtu = ETH_MIN_MTU;
 	switch (tp->version) {
@@ -9726,6 +21087,7 @@ static int rtl8152_probe(struct usb_interface *intf,
 		netdev->max_mtu = ETH_DATA_LEN;
 		break;
 	}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0) */
 
 	tp->mii.dev = netdev;
 	tp->mii.mdio_read = read_mii_word;
@@ -9733,6 +21095,9 @@ static int rtl8152_probe(struct usb_interface *intf,
 	tp->mii.phy_id_mask = 0x3f;
 	tp->mii.reg_num_mask = 0x1f;
 	tp->mii.phy_id = R8152_PHY_ID;
+	tp->mii.force_media = 0;
+	tp->mii.advertising = ADVERTISE_10HALF | ADVERTISE_10FULL |
+			      ADVERTISE_100HALF | ADVERTISE_100FULL;
 
 	tp->autoneg = AUTONEG_ENABLE;
 	tp->speed = SPEED_100;
@@ -9761,10 +21126,6 @@ static int rtl8152_probe(struct usb_interface *intf,
 		tp->saved_wolopts = __rtl_get_wol(tp);
 
 	tp->rtl_ops.init(tp);
-#if IS_BUILTIN(CONFIG_USB_RTL8152)
-	/* Retry in case request_firmware() is not ready yet. */
-	tp->rtl_fw.retry = true;
-#endif
 	queue_delayed_work(system_long_wq, &tp->hw_phy_work, 0);
 	set_ethernet_addr(tp, false);
 
@@ -9784,11 +21145,35 @@ static int rtl8152_probe(struct usb_interface *intf,
 	else
 		device_set_wakeup_enable(&udev->dev, false);
 
+	/* usb_enable_autosuspend(udev); */
+
 	netif_info(tp, probe, netdev, "%s\n", DRIVER_VERSION);
+	netif_info(tp, probe, netdev, "%s\n", PATENTS);
+
+	ret = sysfs_create_group(&netdev->dev.kobj, &rtk_adv_grp);
+	if (ret < 0) {
+		netif_err(tp, probe, netdev, "creat rtk_adv_grp fail\n");
+		goto out2;
+	}
+
+#ifdef RTL8152_DEBUG
+	ret = sysfs_create_group(&netdev->dev.kobj, &rtk_dbg_grp);
+	if (ret < 0) {
+		netif_err(tp, probe, netdev, "creat rtk_dbg_grp fail\n");
+		goto out3;
+	}
+#endif
 
 	return 0;
 
+#ifdef RTL8152_DEBUG
+out3:
+	sysfs_remove_group(&netdev->dev.kobj, &rtk_adv_grp);
+#endif
+out2:
+	unregister_netdev(netdev);
 out1:
+	netif_napi_del(&tp->napi);
 	tasklet_kill(&tp->tx_tl);
 	usb_set_intfdata(intf, NULL);
 out:
@@ -9802,15 +21187,21 @@ static void rtl8152_disconnect(struct usb_interface *intf)
 
 	usb_set_intfdata(intf, NULL);
 	if (tp) {
-		rtl_set_unplug(tp);
+		struct net_device *netdev = tp->netdev;
+
+#ifdef RTL8152_DEBUG
+		sysfs_remove_group(&netdev->dev.kobj, &rtk_dbg_grp);
+#endif
+		sysfs_remove_group(&netdev->dev.kobj, &rtk_adv_grp);
 
-		unregister_netdev(tp->netdev);
+		rtl_set_unplug(tp);
+		unregister_netdev(netdev);
+		netif_napi_del(&tp->napi);
 		tasklet_kill(&tp->tx_tl);
 		cancel_delayed_work_sync(&tp->hw_phy_work);
 		if (tp->rtl_ops.unload)
 			tp->rtl_ops.unload(tp);
-		rtl8152_release_firmware(tp);
-		free_netdev(tp->netdev);
+		free_netdev(netdev);
 	}
 }
 
@@ -9820,6 +21211,10 @@ static void rtl8152_disconnect(struct usb_interface *intf)
 { \
 	USB_DEVICE_AND_INTERFACE_INFO(vend, prod, USB_CLASS_COMM, \
 			USB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE), \
+}, \
+{ \
+	USB_DEVICE_AND_INTERFACE_INFO(vend, prod, USB_CLASS_COMM, \
+			USB_CDC_SUBCLASS_NCM, USB_CDC_PROTO_NONE), \
 }
 
 /* table of devices that work with this driver */
@@ -9837,20 +21232,44 @@ static const struct usb_device_id rtl8152_table[] = {
 	REALTEK_USB_DEVICE(VENDOR_ID_MICROSOFT, 0x07c6),
 	REALTEK_USB_DEVICE(VENDOR_ID_MICROSOFT, 0x0927),
 	REALTEK_USB_DEVICE(VENDOR_ID_MICROSOFT, 0x0c5e),
+
+	/* Samsung */
 	REALTEK_USB_DEVICE(VENDOR_ID_SAMSUNG, 0xa101),
-	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO,  0x304f),
-	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO,  0x3054),
-	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO,  0x3062),
-	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO,  0x3069),
-	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO,  0x3082),
-	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO,  0x7205),
-	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO,  0x720c),
-	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO,  0x7214),
-	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO,  0x721e),
-	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO,  0xa387),
+
+	/* Lenovo */
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x304f),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3052),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3054),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3057),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3062),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3069),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3082),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3098),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x7205),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x720a),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x720b),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x720c),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x7214),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x721e),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x8153),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0xa359),
+	REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0xa387),
+
+	/* LINKSYS */
 	REALTEK_USB_DEVICE(VENDOR_ID_LINKSYS, 0x0041),
-	REALTEK_USB_DEVICE(VENDOR_ID_NVIDIA,  0x09ff),
-	REALTEK_USB_DEVICE(VENDOR_ID_TPLINK,  0x0601),
+
+	/* Nvidia */
+	REALTEK_USB_DEVICE(VENDOR_ID_NVIDIA, 0x09ff),
+
+	/* TP-LINK */
+	REALTEK_USB_DEVICE(VENDOR_ID_TPLINK, 0x0601),
+
+	/* Getac */
+	REALTEK_USB_DEVICE(0x2baf, 0x0012),
+
+	/* ASUSTek */
+	REALTEK_USB_DEVICE(0x0b05, 0x1976),
+
 	{}
 };
 
@@ -9867,10 +21286,76 @@ static struct usb_driver rtl8152_driver = {
 	.pre_reset =	rtl8152_pre_reset,
 	.post_reset =	rtl8152_post_reset,
 	.supports_autosuspend = 1,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
 	.disable_hub_initiated_lpm = 1,
+#endif
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0)
 module_usb_driver(rtl8152_driver);
+#else
+static int rtl8152_cfgselector_probe(struct usb_device *udev)
+{
+	struct usb_host_config *c;
+	int i, num_configs;
+
+	/* Switch the device to vendor mode, if and only if the vendor mode
+	 * driver supports it.
+	 */
+	if (__rtl_get_hw_ver(udev) == RTL_VER_UNKNOWN)
+		return 0;
+
+	/* The vendor mode is not always config #1, so to find it out. */
+	c = udev->config;
+	num_configs = udev->descriptor.bNumConfigurations;
+	for (i = 0; i < num_configs; (i++, c++)) {
+		struct usb_interface_descriptor	*desc = NULL;
+
+		if (!c->desc.bNumInterfaces)
+			continue;
+		desc = &c->intf_cache[0]->altsetting->desc;
+		if (desc->bInterfaceClass == USB_CLASS_VENDOR_SPEC)
+			break;
+	}
+
+	if (i == num_configs)
+		return -ENODEV;
+
+	if (usb_set_configuration(udev, c->desc.bConfigurationValue)) {
+		dev_err(&udev->dev, "Failed to set configuration %d\n",
+			c->desc.bConfigurationValue);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static struct usb_device_driver rtl8152_cfgselector_driver = {
+	.name =		MODULENAME "-cfgselector",
+	.probe =	rtl8152_cfgselector_probe,
+	.id_table =	rtl8152_table,
+	.generic_subclass = 1,
+	.supports_autosuspend = 1,
+};
+
+static int __init rtl8152_driver_init(void)
+{
+	int ret;
+
+	ret = usb_register_device_driver(&rtl8152_cfgselector_driver, THIS_MODULE);
+	if (ret)
+		return ret;
+	return usb_register(&rtl8152_driver);
+}
+
+static void __exit rtl8152_driver_exit(void)
+{
+	usb_deregister(&rtl8152_driver);
+	usb_deregister_device_driver(&rtl8152_cfgselector_driver);
+}
+
+module_init(rtl8152_driver_init);
+module_exit(rtl8152_driver_exit);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0) */
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
