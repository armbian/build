From b857c037f5f0f56dad44f3948dbf431516c7b8ea Mon Sep 17 00:00:00 2001
From: Patrick Yavitz <pyavitz@xxxxx.com>
Date: Sun, 9 Jun 2024 09:57:21 -0400
Subject: [PATCH] Realtek 8852B SDIO Wireless driver 5

Signed-off-by: Patrick Yavitz <pyavitz@xxxxx.com>
---
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/_sdio.c   | 1027 ++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/_sdio.h   |  971 +++
 .../phl/hal_g6/mac/mac_ax/addr_cam.c          |  917 +++
 .../phl/hal_g6/mac/mac_ax/addr_cam.h          |  345 ++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/beacon.c  |  245 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/beacon.h  |   60 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/cmac_tx.c | 1891 ++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/cmac_tx.h |  837 +++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/coex.c    |  115 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/coex.h    |  127 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/common.c  |   29 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/common.h  |   37 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/cpuio.c   | 1361 +++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/cpuio.h   |  719 +++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/dbcc.c    |  637 ++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/dbcc.h    |  148 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/dbg_cmd.c | 3015 ++++++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/dbg_cmd.h | 1109 ++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/dbgpkg.c  | 3622 +++++++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/dbgpkg.h  | 1518 +++++
 .../phl/hal_g6/mac/mac_ax/dbgport_hw.c        |  945 +++
 .../phl/hal_g6/mac/mac_ax/dbgport_hw.h        |  471 ++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/dle.c     | 3524 +++++++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/dle.h     |  750 +++
 .../phl/hal_g6/mac/mac_ax/eco_patch_check.c   | 5337 +++++++++++++++++
 .../phl/hal_g6/mac/mac_ax/eco_patch_check.h   |   66 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/efuse.c   | 4187 +++++++++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/efuse.h   | 1108 ++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/flash.c   |  944 +++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/flash.h   |   52 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd.c   | 3809 ++++++++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd.h   |  850 +++
 .../phl/hal_g6/mac/mac_ax/fwcmd_intf_f2p.h    |  520 ++
 .../phl/hal_g6/mac/mac_ax/fwcmd_intf_f2p_v1.h |  262 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/fwdl.c    | 2060 +++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/fwdl.h    |  541 ++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/fwofld.c  | 3673 ++++++++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/fwofld.h  | 1407 +++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/gpio.c    |  851 +++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/gpio.h    |  340 ++
 .../phl/hal_g6/mac/mac_ax/gpio_cmd.h          |  321 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/h2c_agg.c |  243 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/h2c_agg.h |   32 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/hci_fc.c  | 2427 ++++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/hci_fc.h  |  155 +
 .../phl/hal_g6/mac/mac_ax/hdr_conv.c          |  643 ++
 .../phl/hal_g6/mac/mac_ax/hdr_conv.h          |  299 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/hw.c      | 3683 ++++++++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/hw.h      | 1344 +++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/hw_seq.c  |  278 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/hw_seq.h  |  116 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/hwamsdu.c |  256 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/hwamsdu.h |  171 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/init.c    |  913 +++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/init.h    |  273 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/la_mode.c |  188 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/la_mode.h |  140 +
 .../hal_g6/mac/mac_ax/mac_8852b/_pcie_8852b.c | 1867 ++++++
 .../hal_g6/mac/mac_ax/mac_8852b/_pcie_8852b.h |  741 +++
 .../hal_g6/mac/mac_ax/mac_8852b/_sdio_8852b.c |  622 ++
 .../hal_g6/mac/mac_ax/mac_8852b/_sdio_8852b.h |  352 ++
 .../hal_g6/mac/mac_ax/mac_8852b/_usb_8852b.c  |  620 ++
 .../hal_g6/mac/mac_ax/mac_8852b/_usb_8852b.h  |  538 ++
 .../mac/mac_ax/mac_8852b/cmac_tx_8852b.c      |  136 +
 .../mac/mac_ax/mac_8852b/cmac_tx_8852b.h      |   29 +
 .../hal_g6/mac/mac_ax/mac_8852b/coex_8852b.c  |  399 ++
 .../hal_g6/mac/mac_ax/mac_8852b/coex_8852b.h  |  272 +
 .../mac/mac_ax/mac_8852b/dbgpkg_8852b.c       | 3215 ++++++++++
 .../mac/mac_ax/mac_8852b/dbgpkg_8852b.h       |  163 +
 .../hal_g6/mac/mac_ax/mac_8852b/dle_8852b.c   |  658 ++
 .../hal_g6/mac/mac_ax/mac_8852b/dle_8852b.h   |  333 +
 .../hal_g6/mac/mac_ax/mac_8852b/efuse_8852b.c |  139 +
 .../hal_g6/mac/mac_ax/mac_8852b/efuse_8852b.h |   82 +
 .../hal_g6/mac/mac_ax/mac_8852b/fwcmd_8852b.c |   47 +
 .../hal_g6/mac/mac_ax/mac_8852b/fwcmd_8852b.h |   29 +
 .../hal_g6/mac/mac_ax/mac_8852b/gpio_8852b.c  | 1950 ++++++
 .../hal_g6/mac/mac_ax/mac_8852b/gpio_8852b.h  |   71 +
 .../mac/mac_ax/mac_8852b/hci_fc_8852b.c       |  292 +
 .../mac/mac_ax/mac_8852b/hci_fc_8852b.h       |  122 +
 .../mac/mac_ax/mac_8852b/hdr_conv_rx_8852b.c  |   29 +
 .../mac/mac_ax/mac_8852b/hdr_conv_rx_8852b.h  |   43 +
 .../mac/mac_ax/mac_8852b/hwamsdu_8852b.c      |   68 +
 .../mac/mac_ax/mac_8852b/hwamsdu_8852b.h      |   52 +
 .../hal_g6/mac/mac_ax/mac_8852b/init_8852b.c  |  929 +++
 .../hal_g6/mac/mac_ax/mac_8852b/init_8852b.h  |   39 +
 .../mac/mac_ax/mac_8852b/mac_priv_8852b.c     |  189 +
 .../mac/mac_ax/mac_8852b/mac_priv_8852b.h     |   26 +
 .../mac/mac_ax/mac_8852b/mac_txccxrpt.h       |  146 +
 .../mac/mac_ax/mac_8852b/phy_rpt_8852b.c      |   45 +
 .../mac/mac_ax/mac_8852b/phy_rpt_8852b.h      |   30 +
 .../mac/mac_ax/mac_8852b/pwr_seq_8852b.c      | 1488 +++++
 .../mac/mac_ax/mac_8852b/pwr_seq_8852b.h      |   32 +
 .../mac/mac_ax/mac_8852b/pwr_seq_func_8852b.c | 3040 ++++++++++
 .../mac/mac_ax/mac_8852b/pwr_seq_func_8852b.h |   43 +
 .../hal_g6/mac/mac_ax/mac_8852b/rrsr_8852b.c  |  137 +
 .../hal_g6/mac/mac_ax/mac_8852b/rrsr_8852b.h  |  109 +
 .../mac/mac_ax/mac_8852b/tblupd_8852b.c       |   52 +
 .../mac/mac_ax/mac_8852b/tblupd_8852b.h       |   60 +
 .../mac/mac_ax/mac_8852b/trx_desc_8852b.c     |  669 +++
 .../mac/mac_ax/mac_8852b/trx_desc_8852b.h     |  181 +
 .../phl/hal_g6/mac/mac_ax/mac_ax_dfs.h        |   28 +
 .../phl/hal_g6/mac/mac_ax/mac_ax_mac_info.h   |   47 +
 .../phl/hal_g6/mac/mac_ax/mac_priv.c          |   90 +
 .../phl/hal_g6/mac/mac_ax/mac_priv.h          |  256 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/mcc.c     |  935 +++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/mcc.h     |  413 ++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/mport.c   | 2756 +++++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/mport.h   |  298 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/nan.c     |  538 ++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/nan.h     |  125 +
 .../phl/hal_g6/mac/mac_ax/otpkeysinfo.c       |    7 +
 .../phl/hal_g6/mac/mac_ax/otpkeysinfo.h       |   22 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/p2p.c     |  371 ++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/p2p.h     |  118 +
 .../phl/hal_g6/mac/mac_ax/phy_misc.c          |  117 +
 .../phl/hal_g6/mac/mac_ax/phy_misc.h          |   26 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/phy_rpt.c |  733 +++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/phy_rpt.h |  144 +
 .../phl/hal_g6/mac/mac_ax/power_saving.c      | 1548 +++++
 .../phl/hal_g6/mac/mac_ax/power_saving.h      |  545 ++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/pwr.c     |  432 ++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/pwr.h     |  120 +
 .../phl/hal_g6/mac/mac_ax/pwr_seq_func.c      |  108 +
 .../phl/hal_g6/mac/mac_ax/pwr_seq_func.h      |   28 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/role.c    | 1397 +++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/role.h    |  381 ++
 .../phl/hal_g6/mac/mac_ax/rx_filter.c         |  431 ++
 .../phl/hal_g6/mac/mac_ax/rx_filter.h         |  169 +
 .../phl/hal_g6/mac/mac_ax/rx_forwarding.c     |  448 ++
 .../phl/hal_g6/mac/mac_ax/rx_forwarding.h     |  113 +
 .../phl/hal_g6/mac/mac_ax/secure_boot.c       |  481 ++
 .../phl/hal_g6/mac/mac_ax/secure_boot.h       |  102 +
 .../phl/hal_g6/mac/mac_ax/security_cam.c      | 1036 ++++
 .../phl/hal_g6/mac/mac_ax/security_cam.h      |  352 ++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/ser.c     | 1541 +++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/ser.h     |  815 +++
 .../phl/hal_g6/mac/mac_ax/sounding.c          | 3404 +++++++++++
 .../phl/hal_g6/mac/mac_ax/sounding.h          |  409 ++
 .../phl/hal_g6/mac/mac_ax/spatial_reuse.c     |   84 +
 .../phl/hal_g6/mac/mac_ax/spatial_reuse.h     |   29 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/sta_sch.c |  699 +++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/sta_sch.h |  137 +
 .../phl/hal_g6/mac/mac_ax/state_mach.h        |  249 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/status.c  |  149 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/status.h  |   73 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/tblupd.c  | 2616 ++++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/tblupd.h  |  766 +++
 .../mac/mac_ax/tcpip_checksum_offload.c       |  124 +
 .../mac/mac_ax/tcpip_checksum_offload.h       |   94 +
 .../phl/hal_g6/mac/mac_ax/trx_desc.c          |   17 +
 .../phl/hal_g6/mac/mac_ax/trx_desc.h          |   47 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/trxcfg.c  | 2342 ++++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/trxcfg.h  |  361 ++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/twt.c     |  329 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/twt.h     |  176 +
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/wowlan.c  | 2690 +++++++++
 .../rtl8852bs/phl/hal_g6/mac/mac_ax/wowlan.h  |  978 +++
 157 files changed, 114837 insertions(+)
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/_sdio.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/_sdio.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/addr_cam.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/addr_cam.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/beacon.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/beacon.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cmac_tx.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cmac_tx.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/coex.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/coex.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/common.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/common.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cpuio.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cpuio.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbcc.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbcc.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbg_cmd.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbg_cmd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgpkg.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgpkg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgport_hw.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgport_hw.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dle.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dle.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/eco_patch_check.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/eco_patch_check.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/efuse.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/efuse.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/flash.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/flash.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd_intf_f2p.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd_intf_f2p_v1.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwdl.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwdl.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwofld.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwofld.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/gpio.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/gpio.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/gpio_cmd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/h2c_agg.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/h2c_agg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hci_fc.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hci_fc.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hdr_conv.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hdr_conv.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw_seq.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw_seq.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hwamsdu.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hwamsdu.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/init.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/init.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/la_mode.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/la_mode.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_pcie_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_pcie_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_sdio_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_sdio_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_usb_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_usb_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/cmac_tx_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/cmac_tx_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/coex_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/coex_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dbgpkg_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dbgpkg_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dle_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dle_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/efuse_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/efuse_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/fwcmd_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/fwcmd_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/gpio_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/gpio_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hci_fc_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hci_fc_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hdr_conv_rx_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hdr_conv_rx_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hwamsdu_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hwamsdu_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/init_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/init_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/mac_priv_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/mac_priv_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/mac_txccxrpt.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/phy_rpt_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/phy_rpt_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_func_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_func_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/rrsr_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/rrsr_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/tblupd_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/tblupd_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/trx_desc_8852b.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/trx_desc_8852b.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_ax_dfs.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_ax_mac_info.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_priv.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_priv.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mcc.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mcc.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mport.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mport.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/nan.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/nan.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/otpkeysinfo.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/otpkeysinfo.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/p2p.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/p2p.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_misc.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_misc.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_rpt.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_rpt.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/power_saving.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/power_saving.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr_seq_func.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr_seq_func.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/role.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/role.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_filter.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_filter.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_forwarding.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_forwarding.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/secure_boot.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/secure_boot.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/security_cam.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/security_cam.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/ser.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/ser.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sounding.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sounding.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/spatial_reuse.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/spatial_reuse.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sta_sch.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sta_sch.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/state_mach.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/status.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/status.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tblupd.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tblupd.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tcpip_checksum_offload.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tcpip_checksum_offload.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trx_desc.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trx_desc.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trxcfg.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trxcfg.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/twt.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/twt.h
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/wowlan.c
 create mode 100644 drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/wowlan.h

diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/_sdio.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/_sdio.c
new file mode 100644
index 000000000000..391d149ef7bf
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/_sdio.c
@@ -0,0 +1,1027 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "_sdio.h"
+#include "mac_priv.h"
+
+#if MAC_AX_SDIO_SUPPORT
+static struct mac_sdio_tbl sdio_tbl;
+
+static u8 _patch_reg_sdio(struct mac_ax_adapter *adapter, u32 adr);
+static u16 _patch_fs_enuf(struct mac_ax_adapter *adapter,
+			  struct mac_ax_sdio_tx_info *tx_info);
+
+u8 _pltfm_sdio_cmd53_r8(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u32 dw_adr = adr & 0xFFFFFFFC;
+	u8 dw_sh = adr - dw_adr;
+	u8 cnt = 0;
+	union {
+		__le32 dword;
+		u8 byte[4];
+	} val32 = { 0x00000000 };
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		if (!(adr >= R_AX_CMAC_FUNC_EN && adr <= R_AX_CMAC_REG_END))
+			return PLTFM_SDIO_CMD53_R8(adr);
+	} else {
+		return PLTFM_SDIO_CMD53_R8(adr);
+	}
+
+	while (cnt < MAC_REG_POOL_COUNT) {
+		val32.dword = PLTFM_SDIO_CMD53_R32(dw_adr);
+
+		if (le32_to_cpu(val32.dword) != MAC_AX_R32_DEAD)
+			break;
+
+		PLTFM_MSG_ERR("[ERR]addr 0x%x = 0xdeadbeef\n", dw_adr);
+		PLTFM_SDIO_CMD53_W32(R_AX_CK_EN, CMAC_CLK_ALLEN);
+		cnt++;
+	}
+
+	return val32.byte[dw_sh];
+}
+
+u16 _pltfm_sdio_cmd53_r16(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u32 dw_adr = adr & 0xFFFFFFFD;
+	u8 dw_sh = (adr - dw_adr) ? 1 : 0;
+	u8 cnt = 0;
+	union {
+		__le32 dword;
+		u16 word[2];
+	} val32 = { 0x00000000 };
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		if (!(adr >= R_AX_CMAC_FUNC_EN && adr <= R_AX_CMAC_REG_END))
+			return PLTFM_SDIO_CMD53_R16(adr);
+	} else {
+		return PLTFM_SDIO_CMD53_R16(adr);
+	}
+
+	while (cnt < MAC_REG_POOL_COUNT) {
+		val32.dword = PLTFM_SDIO_CMD53_R32(dw_adr);
+
+		if (le32_to_cpu(val32.dword) != MAC_AX_R32_DEAD)
+			break;
+
+		PLTFM_MSG_ERR("[ERR]addr 0x%x = 0xdeadbeef\n", dw_adr);
+		PLTFM_SDIO_CMD53_W32(R_AX_CK_EN, CMAC_CLK_ALLEN);
+		cnt++;
+	}
+
+	return val32.word[dw_sh];
+}
+
+u32 _pltfm_sdio_cmd53_r32(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u8 cnt = 0;
+	__le32 dword = 0x00000000;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		if (!(adr >= R_AX_CMAC_FUNC_EN && adr <= R_AX_CMAC_REG_END))
+			return PLTFM_SDIO_CMD53_R32(adr);
+	} else {
+		return PLTFM_SDIO_CMD53_R32(adr);
+	}
+
+	while (cnt < MAC_REG_POOL_COUNT) {
+		dword = PLTFM_SDIO_CMD53_R32(adr);
+
+		if (le32_to_cpu(dword) != MAC_AX_R32_DEAD)
+			break;
+
+		PLTFM_MSG_ERR("[ERR]addr 0x%x = 0xdeadbeef\n", adr);
+		PLTFM_SDIO_CMD53_W32(R_AX_CK_EN, CMAC_CLK_ALLEN);
+		cnt++;
+	}
+
+	return dword;
+}
+
+u8 reg_read8_sdio(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u8 val8;
+	u8 pwr_state, reg_domain;
+	enum mac_ax_sdio_4byte_mode cmd53_4byte = adapter->sdio_info.sdio_4byte;
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+
+	if (adapter->mac_pwr_info.pwr_in_lps == 1) {
+		PLTFM_MSG_ERR("[DBG]pwr_in_lps r8 %x\n", adr);
+		if (mops->io_chk_access(adapter, adr) != MACSUCCESS) {
+			PLTFM_MSG_ERR("[DBG]block pwr_in_lps r8 %x\n", adr);
+			return PWR_IN_LPS_R8;
+		}
+	}
+
+	pwr_state = pwr_state_chk_sdio(adapter);
+	reg_domain = reg_chk_sdio(adapter, adr);
+
+	if (reg_domain == SDIO_REG_LOCAL) {
+		val8 = PLTFM_SDIO_CMD52_R8(adr);
+	} else if (reg_domain == SDIO_REG_WLAN_PLTFM) {
+		val8 = (u8)r_indir_sdio(adapter, adr, SDIO_IO_BYTE);
+	} else {
+		if (pwr_state == SDIO_PWR_OFF)
+			val8 = (u8)r_indir_sdio(adapter, adr, SDIO_IO_BYTE);
+		else if (cmd53_4byte == MAC_AX_SDIO_4BYTE_MODE_DISABLE)
+			val8 = _pltfm_sdio_cmd53_r8(adapter, adr);
+		else
+			val8 = (u8)(_pltfm_sdio_cmd53_r32(adapter, adr) & 0xFF);
+	}
+
+	return val8;
+}
+
+void reg_write8_sdio(struct mac_ax_adapter *adapter, u32 adr, u8 val)
+{
+	u8 reg_domain;
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+
+	if (adapter->mac_pwr_info.pwr_in_lps == 1) {
+		PLTFM_MSG_ERR("[DBG]pwr_in_lps w8 %x, %x\n", adr, val);
+		if (mops->io_chk_access(adapter, adr) != MACSUCCESS) {
+			PLTFM_MSG_ERR("[DBG]block pwr_in_lps w8 %x, %x\n", adr, val);
+			return;
+		}
+	}
+
+	reg_domain = reg_chk_sdio(adapter, adr);
+
+	if (reg_domain == SDIO_REG_LOCAL)
+		PLTFM_SDIO_CMD52_W8(adr, val);
+	else
+		w_indir_sdio(adapter, adr, val, SDIO_IO_BYTE);
+}
+
+u16 reg_read16_sdio(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u8 pwr_state, reg_domain;
+	enum mac_ax_sdio_4byte_mode sdio_4byte = adapter->sdio_info.sdio_4byte;
+	union {
+		__le16 word;
+		u8 byte[2];
+	} value16 = { 0x0000 };
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+
+	if (adapter->mac_pwr_info.pwr_in_lps == 1) {
+		PLTFM_MSG_ERR("[DBG]pwr_in_lps r16 %x\n", adr);
+		if (mops->io_chk_access(adapter, adr) != MACSUCCESS) {
+			PLTFM_MSG_ERR("[DBG]block pwr_in_lps r16 %x\n", adr);
+			return PWR_IN_LPS_R16;
+		}
+	}
+
+	pwr_state = pwr_state_chk_sdio(adapter);
+	reg_domain = reg_chk_sdio(adapter, adr);
+
+	if ((adr & (2 - 1)) == 0) {
+		if (pwr_state == SDIO_PWR_ON &&
+		    sdio_4byte == MAC_AX_SDIO_4BYTE_MODE_DISABLE)
+			return _pltfm_sdio_cmd53_r16(adapter, adr);
+		if (reg_domain == SDIO_REG_LOCAL) {
+			value16.byte[0] = PLTFM_SDIO_CMD52_R8(adr);
+			value16.byte[1] = PLTFM_SDIO_CMD52_R8(adr + 1);
+			return le16_to_cpu(value16.word);
+		}
+		if (pwr_state == SDIO_PWR_OFF ||
+		    reg_domain == SDIO_REG_WLAN_PLTFM)
+			return (u16)r_indir_sdio(adapter, adr, SDIO_IO_WORD);
+		return (u16)(_pltfm_sdio_cmd53_r32(adapter, adr) & 0xFFFF);
+	}
+
+	if (reg_domain == SDIO_REG_LOCAL) {
+		value16.byte[0] = PLTFM_SDIO_CMD52_R8(adr);
+		value16.byte[1] = PLTFM_SDIO_CMD52_R8(adr + 1);
+		return le16_to_cpu(value16.word);
+	}
+	value16.byte[0] = (u8)r_indir_sdio(adapter, adr, SDIO_IO_BYTE);
+	value16.byte[1] = (u8)r_indir_sdio(adapter, adr + 1, SDIO_IO_BYTE);
+	return le16_to_cpu(value16.word);
+}
+
+void reg_write16_sdio(struct mac_ax_adapter *adapter, u32 adr, u16 val)
+{
+	u8 pwr_state, reg_domain;
+	enum mac_ax_sdio_4byte_mode sdio_4byte = adapter->sdio_info.sdio_4byte;
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+
+	if (adapter->mac_pwr_info.pwr_in_lps == 1) {
+		PLTFM_MSG_ERR("[DBG]pwr_in_lps w16 %x, %x\n", adr, val);
+		if (mops->io_chk_access(adapter, adr) != MACSUCCESS) {
+			PLTFM_MSG_ERR("[DBG]block pwr_in_lps w16 %x, %x\n", adr, val);
+			return;
+		}
+	}
+
+	pwr_state = pwr_state_chk_sdio(adapter);
+	reg_domain = reg_chk_sdio(adapter, adr);
+
+	if ((adr & (2 - 1)) == 0) {
+		if (pwr_state == SDIO_PWR_ON &&
+		    sdio_4byte == MAC_AX_SDIO_4BYTE_MODE_DISABLE) {
+			PLTFM_SDIO_CMD53_W16(adr, val);
+		} else if (reg_domain == SDIO_REG_WLAN_REG ||
+			   reg_domain == SDIO_REG_WLAN_PLTFM) {
+			w_indir_sdio(adapter, adr, val, SDIO_IO_WORD);
+		} else {
+			PLTFM_SDIO_CMD52_W8(adr, (u8)(val & 0xFF));
+			PLTFM_SDIO_CMD52_W8(adr + 1,
+					    (u8)((val & 0xFF00) >> 8));
+		}
+	} else {
+		if (reg_domain == SDIO_REG_LOCAL) {
+			PLTFM_SDIO_CMD52_W8(adr, (u8)(val & 0xFF));
+			PLTFM_SDIO_CMD52_W8(adr + 1,
+					    (u8)((val & 0xFF00) >> 8));
+		} else {
+			w_indir_sdio(adapter, adr, (u8)(val & 0xFF),
+				     SDIO_IO_BYTE);
+			w_indir_sdio(adapter, adr + 1,
+				     (u8)((val & 0xFF00) >> 8), SDIO_IO_BYTE);
+		}
+	}
+}
+
+u32 reg_read32_sdio(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u8 pwr_state, reg_domain;
+	union {
+		__le32 dword;
+		u8 byte[4];
+	} value32 = { 0x00000000 };
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+
+	if (adapter->mac_pwr_info.pwr_in_lps == 1) {
+		PLTFM_MSG_ERR("[DBG]pwr_in_lps r32 %x\n", adr);
+		if (mops->io_chk_access(adapter, adr) != MACSUCCESS) {
+			PLTFM_MSG_ERR("[DBG]block pwr_in_lps r32 %x\n", adr);
+			return PWR_IN_LPS_R32;
+		}
+	}
+
+	pwr_state = pwr_state_chk_sdio(adapter);
+	reg_domain = reg_chk_sdio(adapter, adr);
+
+	if ((adr & (4 - 1)) == 0) {
+		if (pwr_state == SDIO_PWR_OFF && reg_domain == SDIO_REG_LOCAL) {
+			value32.byte[0] = PLTFM_SDIO_CMD52_R8(adr);
+			value32.byte[1] = PLTFM_SDIO_CMD52_R8(adr + 1);
+			value32.byte[2] = PLTFM_SDIO_CMD52_R8(adr + 2);
+			value32.byte[3] = PLTFM_SDIO_CMD52_R8(adr + 3);
+			return le32_to_cpu(value32.dword);
+		}
+		if (pwr_state == SDIO_PWR_ON &&
+		    (reg_domain == SDIO_REG_LOCAL ||
+		    reg_domain == SDIO_REG_WLAN_REG))
+			return _pltfm_sdio_cmd53_r32(adapter, adr);
+		return r_indir_sdio(adapter, adr, SDIO_IO_DWORD);
+	}
+
+	if (reg_domain == SDIO_REG_LOCAL) {
+		value32.byte[0] = PLTFM_SDIO_CMD52_R8(adr);
+		value32.byte[1] = PLTFM_SDIO_CMD52_R8(adr + 1);
+		value32.byte[2] = PLTFM_SDIO_CMD52_R8(adr + 2);
+		value32.byte[3] = PLTFM_SDIO_CMD52_R8(adr + 3);
+		return le32_to_cpu(value32.dword);
+	}
+	value32.byte[0] = (u8)r_indir_sdio(adapter, adr, SDIO_IO_BYTE);
+	value32.byte[1] = (u8)r_indir_sdio(adapter, adr + 1, SDIO_IO_BYTE);
+	value32.byte[2] = (u8)r_indir_sdio(adapter, adr + 2, SDIO_IO_BYTE);
+	value32.byte[3] = (u8)r_indir_sdio(adapter, adr + 3, SDIO_IO_BYTE);
+	return le32_to_cpu(value32.dword);
+}
+
+void reg_write32_sdio(struct mac_ax_adapter *adapter, u32 adr, u32 val)
+{
+	u8 pwr_state, reg_domain;
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+
+	if (adapter->mac_pwr_info.pwr_in_lps == 1) {
+		PLTFM_MSG_ERR("[DBG]pwr_in_lps w32 %x, %x\n", adr, val);
+		if (mops->io_chk_access(adapter, adr) != MACSUCCESS) {
+			PLTFM_MSG_ERR("[DBG]block pwr_in_lps w32 %x, %x\n", adr, val);
+			return;
+		}
+	}
+
+	pwr_state = pwr_state_chk_sdio(adapter);
+	reg_domain = reg_chk_sdio(adapter, adr);
+
+	if ((adr & (4 - 1)) == 0) {
+		if (pwr_state == SDIO_PWR_OFF && reg_domain == SDIO_REG_LOCAL) {
+			PLTFM_SDIO_CMD52_W8(adr, (u8)(val & 0xFF));
+			PLTFM_SDIO_CMD52_W8(adr + 1, (u8)((val >> 8) & 0xFF));
+			PLTFM_SDIO_CMD52_W8(adr + 2, (u8)((val >> 16) & 0xFF));
+			PLTFM_SDIO_CMD52_W8(adr + 3, (u8)((val >> 24) & 0xFF));
+		} else if (pwr_state == SDIO_PWR_ON &&
+			   (reg_domain == SDIO_REG_LOCAL ||
+			   reg_domain == SDIO_REG_WLAN_REG)) {
+			PLTFM_SDIO_CMD53_W32(adr, val);
+		} else {
+			w_indir_sdio(adapter, adr, val, SDIO_IO_DWORD);
+		}
+	} else {
+		if (reg_domain == SDIO_REG_LOCAL) {
+			PLTFM_SDIO_CMD52_W8(adr, (u8)(val & 0xFF));
+			PLTFM_SDIO_CMD52_W8(adr + 1, (u8)((val >> 8) & 0xFF));
+			PLTFM_SDIO_CMD52_W8(adr + 2, (u8)((val >> 16) & 0xFF));
+			PLTFM_SDIO_CMD52_W8(adr + 3, (u8)((val >> 24) & 0xFF));
+		} else {
+			w_indir_sdio(adapter, adr, (u8)(val & 0xFF),
+				     SDIO_IO_BYTE);
+			w_indir_sdio(adapter, adr + 1,
+				     (u8)((val >> 8) & 0xFF), SDIO_IO_BYTE);
+			w_indir_sdio(adapter, adr + 2,
+				     (u8)((val >> 16) & 0xFF), SDIO_IO_BYTE);
+			w_indir_sdio(adapter, adr + 3,
+				     (u8)((val >> 24) & 0xFF), SDIO_IO_BYTE);
+		}
+	}
+}
+
+u32 reg_read_n_sdio(struct mac_ax_adapter *adapter, u32 adr, u32 size, u8 *val)
+{
+	u8 *r_val = NULL;
+	u32 r_size;
+	u8 pwr_state, reg_domain;
+	enum mac_ax_sdio_4byte_mode cmd53_4byte = adapter->sdio_info.sdio_4byte;
+
+	pwr_state = pwr_state_chk_sdio(adapter);
+	reg_domain = reg_chk_sdio(adapter, adr);
+
+	if (reg_domain != SDIO_REG_LOCAL) {
+		PLTFM_MSG_ERR("[ERR]adr 0x%x\n", adr);
+		return MACBADDR;
+	}
+
+	if (pwr_state == SDIO_PWR_OFF) {
+		PLTFM_MSG_ERR("[ERR]power off\n");
+		return MACPWRSTAT;
+	}
+
+	if (cmd53_4byte == MAC_AX_SDIO_4BYTE_MODE_RW && (size & 0x03) != 0) {
+		PLTFM_MSG_WARN("[WARN]reg_rn !align,addr 0x%x,siz %d\n", adr,
+			       size);
+		r_size = size - (size & 0x03) + 4;
+		r_val = (u8 *)PLTFM_MALLOC(r_size);
+		if (!r_val) {
+			PLTFM_MSG_ERR("[ERR]malloc!!\n");
+			return MACBUFALLOC;
+		}
+		PLTFM_MEMSET(r_val, 0x00, r_size);
+		PLTFM_SDIO_CMD53_RN(adr, r_size, r_val);
+		PLTFM_MEMCPY(val, r_val, size);
+		PLTFM_FREE(r_val, r_size);
+	} else {
+		PLTFM_SDIO_CMD53_RN(adr, size, val);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 tx_allow_sdio(struct mac_ax_adapter *adapter,
+		  struct mac_ax_sdio_tx_info *info)
+{
+	u32 ret;
+
+	if (info->ch_dma != MAC_AX_DMA_H2C)
+		ret = tx_allow_data_ch(adapter, info);
+	else
+		ret = tx_allow_fwcmd_ch(adapter, info);
+
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 tx_cmd_addr_sdio(struct mac_ax_adapter *adapter,
+		     struct mac_ax_sdio_tx_info *info, u32 *cmd_addr)
+{
+	struct mac_ax_sdio_info *sdio_info = &adapter->sdio_info;
+	u16 block_size = sdio_info->block_size;
+	u32 len_unit1, len_unit8, val32, size;
+	enum sdio_tx_byte_cnt byte_cnt;
+	enum mac_ax_sdio_opn_mode opn_mode = sdio_info->opn_mode;
+
+	size = info->total_size;
+
+	if (size == 0) {
+		PLTFM_MSG_ERR("size is 0!!\n");
+		return MACBUFSZ;
+	}
+
+	if (info->ch_dma < 13)
+		*cmd_addr = (info->ch_dma << SDIO_CMD_ADDR_TXFF_SHIFT) |
+			     SDIO_TX_BASE;
+	else
+		return MACTXCHDMA;
+
+	len_unit8 = (size >> 3) + ((size & (8 - 1)) ? 1 : 0);
+	len_unit1 = (len_unit8 << 3);
+
+	switch (sdio_info->tx_mode) {
+	case MAC_AX_SDIO_TX_MODE_AGG:
+		byte_cnt = SDIO_TX_AGG_8_BYTE_CNT;
+		break;
+	case MAC_AX_SDIO_TX_MODE_DUMMY_BLOCK:
+		byte_cnt = SDIO_TX_DUMMY_4_BYTE_CNT;
+		break;
+	case MAC_AX_SDIO_TX_MODE_DUMMY_AUTO:
+		if (len_unit1 == SDIO_BYTE_MODE_SIZE_MAX) {
+			if (opn_mode == MAC_AX_SDIO_OPN_MODE_BYTE) {
+				byte_cnt = SDIO_TX_AGG_8_BYTE_CNT;
+			} else if (opn_mode == MAC_AX_SDIO_OPN_MODE_BLOCK) {
+				byte_cnt = SDIO_TX_DUMMY_4_BYTE_CNT;
+			} else {
+				PLTFM_MSG_ERR("[ERR]opn_mode is unknown\n");
+				return MACSDIOOPNMODE;
+			}
+		} else if (len_unit1 >= block_size) {
+			byte_cnt = SDIO_TX_DUMMY_4_BYTE_CNT;
+		} else if (len_unit1 < SDIO_BYTE_MODE_SIZE_MAX) {
+			byte_cnt = SDIO_TX_AGG_8_BYTE_CNT;
+		} else {
+			byte_cnt = SDIO_TX_DUMMY_4_BYTE_CNT;
+		}
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR]tx_mode is undefined\n");
+		return MACSDIOTXMODE;
+	}
+
+	if (byte_cnt == SDIO_TX_AGG_8_BYTE_CNT) {
+		*cmd_addr |= len_unit8 & SDIO_8BYTE_LEN_MASK;
+	} else if (byte_cnt == SDIO_TX_DUMMY_4_BYTE_CNT) {
+		val32 = len_unit1 & (block_size - 1);
+		if (val32)
+			val32 = block_size - val32;
+		val32 = (val32 >> 2) & SDIO_4BYTE_LEN_MASK;
+		*cmd_addr |= (val32 << 1) | sdio_info->tx_seq;
+		sdio_info->tx_seq = ~sdio_info->tx_seq & 0x01;
+	}
+
+	//cmd_len = adapter->sdio_info.tx_align_size;
+
+	return MACSUCCESS;
+}
+
+u32 sdio_init(struct mac_ax_adapter *adapter, void *param)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (adapter->hw_info->intf != MAC_AX_INTF_SDIO)
+		return MACINTF;
+
+	val32 = MAC_REG_R32(R_AX_RXDMA_SETTING);
+	MAC_REG_W32(R_AX_RXDMA_SETTING, val32 & ~B_AX_PLE_BURST_READ);
+
+	return MACSUCCESS;
+}
+
+u32 sdio_deinit(struct mac_ax_adapter *adapter, void *param)
+{
+	return MACSUCCESS;
+}
+
+u32 r_indir_sdio(struct mac_ax_adapter *adapter, u32 adr,
+		 enum sdio_io_size size)
+{
+	u32 value32 = 0;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	PLTFM_MUTEX_LOCK(&sdio_tbl.lock);
+
+	switch (size) {
+	case SDIO_IO_BYTE:
+		value32 = r8_indir_sdio(adapter, adr);
+		break;
+	case SDIO_IO_WORD:
+		value32 = p_ops->r16_indir_sdio(adapter, adr);
+		break;
+	case SDIO_IO_DWORD:
+		value32 = p_ops->r32_indir_sdio(adapter, adr);
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR]invalid IO size\n");
+		break;
+	}
+
+	PLTFM_MUTEX_UNLOCK(&sdio_tbl.lock);
+
+	return value32;
+}
+
+void w_indir_sdio(struct mac_ax_adapter *adapter, u32 adr, u32 val,
+		  enum sdio_io_size size)
+{
+	PLTFM_MUTEX_LOCK(&sdio_tbl.lock);
+
+	switch (size) {
+	case SDIO_IO_BYTE:
+		w8_indir_sdio(adapter, adr, val);
+		break;
+	case SDIO_IO_WORD:
+		w16_indir_sdio(adapter, adr, val);
+		break;
+	case SDIO_IO_DWORD:
+		w32_indir_sdio(adapter, adr, val);
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR]invalid IO size\n");
+		break;
+	}
+
+	PLTFM_MUTEX_UNLOCK(&sdio_tbl.lock);
+}
+
+u32 set_info_sdio(struct mac_ax_adapter *adapter, struct mac_ax_sdio_info *info)
+{
+	adapter->sdio_info.spec_ver = info->spec_ver;
+	adapter->sdio_info.block_size = info->block_size;
+	adapter->sdio_info.sdio_4byte = info->sdio_4byte;
+	adapter->sdio_info.opn_mode = info->opn_mode;
+
+	return MACSUCCESS;
+}
+
+u32 tx_agg_cfg_sdio(struct mac_ax_adapter *adapter,
+		    struct mac_ax_sdio_txagg_cfg *cfg)
+{
+	u8 i;
+	u8 flag = 0;
+	u16 align_size = cfg->align_size;
+	u8 enable = cfg->en;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if ((align_size & 0xF000) != 0) {
+		PLTFM_MSG_ERR("[ERR]out of range\n");
+		return MACFUNCINPUT;
+	}
+
+	for (i = 3; i <= 11; i++) {
+		if (align_size == 1 << i) {
+			flag = 1;
+			break;
+		}
+	}
+
+	if (flag == 0) {
+		PLTFM_MSG_ERR("[ERR]not 2^3 ~ 2^11\n");
+		return MACFUNCINPUT;
+	}
+
+	if (enable) {
+		MAC_REG_W32(R_AX_TXAGG_ALIGN_CFG,
+			    align_size | B_AX_TXAGG_ALIGN_SIZE_EN);
+	} else {
+		MAC_REG_W32(R_AX_TXAGG_ALIGN_CFG,
+			    align_size & ~B_AX_TXAGG_ALIGN_SIZE_EN);
+		align_size = 8;
+	}
+
+	adapter->sdio_info.tx_align_size = align_size;
+
+	return MACSUCCESS;
+}
+
+u32 sdio_tbl_init(struct mac_ax_adapter *adapter)
+{
+	PLTFM_MUTEX_INIT(&sdio_tbl.lock);
+
+	return MACSUCCESS;
+}
+
+u32 sdio_tbl_exit(struct mac_ax_adapter *adapter)
+{
+	PLTFM_MUTEX_DEINIT(&sdio_tbl.lock);
+
+	return MACSUCCESS;
+}
+
+u32 set_sdio_wowlan(struct mac_ax_adapter *adapter, enum mac_ax_wow_ctrl w_c)
+{
+	return MACSUCCESS;
+}
+
+u32 r_indir_cmd53_sdio(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u32 dw_adr = adr & 0xFFFFFFFC;
+	u8 dw_sh = (adr & (4 - 1)) << 3;
+	u8 count = 0;
+	u32 dw = 0;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		if (!(adr >= R_AX_CMAC_FUNC_EN && adr <= R_AX_CMAC_REG_END))
+			return p_ops->_r_indir_cmd53_sdio(adapter, adr);
+	} else {
+		return p_ops->_r_indir_cmd53_sdio(adapter, adr);
+	}
+
+	while (count < MAC_REG_POOL_COUNT) {
+		dw = p_ops->_r_indir_cmd53_sdio(adapter, dw_adr);
+		if (dw != MAC_AX_R32_DEAD)
+			break;
+		PLTFM_MSG_ERR("[ERR]addr 0x%x = 0xdeadbeef\n", dw_adr);
+		PLTFM_SDIO_CMD53_W32(R_AX_CK_EN, CMAC_CLK_ALLEN);
+		count++;
+	}
+
+	return (dw >> dw_sh);
+}
+
+u32 r8_indir_sdio(struct mac_ax_adapter *adapter, u32 adr)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u8 pwr_state;
+	union {
+		__le32 dword;
+		u8 byte[4];
+	} val32 = { 0x00000000 };
+
+	pwr_state = pwr_state_chk_sdio(adapter);
+
+	if (pwr_state == SDIO_PWR_OFF) {
+		val32.byte[0] = p_ops->r_indir_cmd52_sdio(adapter, adr);
+		return le32_to_cpu(val32.dword);
+	}
+
+	return r_indir_cmd53_sdio(adapter, adr);
+}
+
+void w8_indir_sdio(struct mac_ax_adapter *adapter, u32 adr, u32 val)
+{
+	u8 pwr_state = pwr_state_chk_sdio(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	if (pwr_state == SDIO_PWR_OFF)
+		p_ops->w_indir_cmd52_sdio(adapter, adr, val, SDIO_IO_BYTE);
+	else
+		p_ops->w_indir_cmd53_sdio(adapter, adr, val, SDIO_IO_BYTE);
+}
+
+void w16_indir_sdio(struct mac_ax_adapter *adapter, u32 adr, u32 val)
+{
+	u8 pwr_state = pwr_state_chk_sdio(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	if (pwr_state == SDIO_PWR_OFF)
+		p_ops->w_indir_cmd52_sdio(adapter, adr, val, SDIO_IO_WORD);
+	else
+		p_ops->w_indir_cmd53_sdio(adapter, adr, val, SDIO_IO_WORD);
+}
+
+void w32_indir_sdio(struct mac_ax_adapter *adapter, u32 adr, u32 val)
+{
+	u8 pwr_state = pwr_state_chk_sdio(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	if (pwr_state == SDIO_PWR_OFF)
+		p_ops->w_indir_cmd52_sdio(adapter, adr, val, SDIO_IO_DWORD);
+	else
+		p_ops->w_indir_cmd53_sdio(adapter, adr, val, SDIO_IO_DWORD);
+}
+
+u8 pwr_state_chk_sdio(struct mac_ax_adapter *adapter)
+{
+	if (adapter->mac_pwr_info.pwr_seq_proc == 1 ||
+	    adapter->sm.pwr == MAC_AX_PWR_OFF ||
+	    adapter->mac_pwr_info.pwr_in_lps == 1 ||
+	    adapter->sm.fw_rst == MAC_AX_FW_RESET_RECV ||
+	    adapter->sm.fw_rst == MAC_AX_FW_RESET_RECV_DONE ||
+	    adapter->sm.fw_rst == MAC_AX_FW_RESET_PROCESS) {
+		adapter->sdio_info.tx_seq = 1;
+		return SDIO_PWR_OFF;
+	}
+	return SDIO_PWR_ON;
+}
+
+u8 reg_chk_sdio(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u8 chip_id = adapter->hw_info->chip_id;
+
+	switch (chip_id) {
+	case MAC_AX_CHIP_ID_8852C:
+	case MAC_AX_CHIP_ID_8192XB:
+	case MAC_AX_CHIP_ID_8851E:
+	case MAC_AX_CHIP_ID_8852D:
+		if (adr >= SDIO_LOCAL_REG_START_V1 &&
+		    adr < SDIO_LOCAL_REG_END_V1)
+			return SDIO_REG_LOCAL;
+		break;
+	default:
+		if (chk_patch_reg_sdio(adapter))
+			return _patch_reg_sdio(adapter, adr);
+
+		if (adr >= SDIO_LOCAL_REG_START && adr < SDIO_LOCAL_REG_END)
+			return SDIO_REG_LOCAL;
+		break;
+	}
+
+	if (adr > SDIO_WLAN_REG_END)
+		return SDIO_REG_WLAN_PLTFM;
+
+	return SDIO_REG_WLAN_REG;
+}
+
+void chk_rqd_pg_num(struct mac_ax_adapter *adapter,
+		    struct mac_ax_sdio_tx_info *tx_info)
+{
+	u32 ple_rqd = 0;
+	u16 wde_rqd = 0;
+	u16 *pkt_size = tx_info->pkt_size;
+	u8 *wp_offset = tx_info->wp_offset;
+	u16 ple_pg_size = adapter->dle_info.ple_pg_size;
+	u16 wde_pg_size = adapter->dle_info.wde_pg_size;
+	u8 ple_rsvd_size = adapter->hw_info->ple_rsvd_space;
+	u8 pd_size = adapter->hw_info->payload_desc_size;
+	u16 size;
+	u32 ple_pg_size_sh;
+	u8 dma_txagg_num, i;
+
+	ple_pg_size_sh = get_pg_size_pow(ple_pg_size);
+
+	dma_txagg_num =
+		(tx_info->dma_txagg_num == 0) ? 1 : tx_info->dma_txagg_num;
+	for (i = 0; i < dma_txagg_num; i++) {
+		if (tx_info->ch_dma != MAC_AX_DMA_H2C)
+			size = *pkt_size + *wp_offset +
+			       ple_rsvd_size + pd_size;
+		else
+			size = *pkt_size + *wp_offset;
+		ple_rqd += (size >> ple_pg_size_sh) +
+			   ((size & (ple_pg_size - 1)) ? 1 : 0);
+		wde_rqd += wde_pg_size >> 6;
+		pkt_size++;
+		wp_offset++;
+	}
+	tx_info->ple_rqd_num = (u16)(ple_rqd << 1);
+	tx_info->wde_rqd_num = wde_rqd;
+}
+
+u32 chk_fs_enuf(struct mac_ax_adapter *adapter,
+		struct mac_ax_sdio_tx_info *tx_info)
+{
+	struct mac_ax_hfc_ch_cfg *ch_cfg = adapter->hfc_param->ch_cfg;
+	struct mac_ax_hfc_ch_info *ch_info = adapter->hfc_param->ch_info;
+	struct mac_ax_hfc_pub_info *pub_info = adapter->hfc_param->pub_info;
+	u16 wde_min = ch_cfg[tx_info->ch_dma].min;
+	u16 wde_max = ch_cfg[tx_info->ch_dma].max;
+	u16 wde_use = ch_info[tx_info->ch_dma].used;
+	u16 ple_thrd = adapter->hfc_param->pub_cfg->wp_thrd;
+	u16 wde_aval = (wde_max - wde_use < 0) ? 0 : (wde_max - wde_use);
+
+	if (chk_patch_fs_enuf(adapter))
+		wde_aval = _patch_fs_enuf(adapter, tx_info);
+
+	if (wde_aval < tx_info->wde_rqd_num)
+		return MACHFSWDENOTNUF;
+	if (pub_info->wp_aval < tx_info->ple_rqd_num)
+		return MACHFSPLENOTNUF;
+	if (pub_info->wp_aval <= ple_thrd && wde_use > wde_min)
+		return MACHFSPLENOTNUF;
+	return MACSUCCESS;
+}
+
+u32 get_pg_size_pow(u32 size)
+{
+	u32 val32;
+
+	switch (size) {
+	case 64:
+		val32 = 6;
+		break;
+	case 128:
+		val32 = 7;
+		break;
+	case 256:
+		val32 = 8;
+		break;
+	default:
+		val32 = 8;
+		break;
+	}
+
+	return val32;
+}
+
+u32 tx_allow_data_ch(struct mac_ax_adapter *adapter,
+		     struct mac_ax_sdio_tx_info *info)
+{
+	struct mac_ax_hfc_ch_info *ch_info = adapter->hfc_param->ch_info;
+	struct mac_ax_hfc_pub_info *pub_info = adapter->hfc_param->pub_info;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 cnt;
+	u32 ret;
+
+	chk_rqd_pg_num(adapter, info);
+
+	cnt = info->chk_cnt;
+	do {
+		ret = chk_fs_enuf(adapter, info);
+		if (ret == MACSUCCESS) {
+			ch_info[info->ch_dma].used += info->wde_rqd_num;
+			pub_info->wp_aval -= info->ple_rqd_num;
+			break;
+		}
+		p_ops->ud_fs(adapter);
+		cnt--;
+	} while (cnt);
+
+	if (!cnt)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 tx_allow_fwcmd_ch(struct mac_ax_adapter *adapter,
+		      struct mac_ax_sdio_tx_info *info)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_hfc_ch_info *ch_info = adapter->hfc_param->ch_info;
+	u32 cnt;
+
+	chk_rqd_pg_num(adapter, info);
+
+	cnt = info->chk_cnt;
+	do {
+		if (ch_info[MAC_AX_DMA_H2C].aval >= info->ple_rqd_num) {
+			ch_info[MAC_AX_DMA_H2C].aval -= info->ple_rqd_num;
+			break;
+		}
+		p_ops->ud_fs(adapter);
+		cnt--;
+	} while (cnt);
+
+	if (!cnt)
+		return MACHFSPLENOTNUF;
+
+	return MACSUCCESS;
+}
+
+u32 sdio_get_txagg_num(struct mac_ax_adapter *adapter, u8 band)
+{
+	return SDIO_DEFAULT_AGG_NUM;
+}
+
+u32 sdio_get_rx_state(struct mac_ax_adapter *adapter, u32 *val)
+{
+		return MACNOTSUP;
+}
+
+u32 dbcc_hci_ctrl_sdio(struct mac_ax_adapter *adapter,
+		       struct mac_ax_dbcc_hci_ctrl *info)
+{
+	return MACSUCCESS;
+}
+
+u32 ltr_set_sdio(struct mac_ax_adapter *adapter,
+		 struct mac_ax_pcie_ltr_param *param)
+{
+	return MACNOTSUP;
+}
+
+u32 ctrl_txdma_ch_sdio(struct mac_ax_adapter *adapter,
+		       struct mac_ax_txdma_ch_map *ch_map)
+{
+	return MACNOTSUP;
+}
+
+u32 clr_idx_all_sdio(struct mac_ax_adapter *adapter)
+{
+	return MACNOTSUP;
+}
+
+u32 poll_txdma_ch_idle_sdio(struct mac_ax_adapter *adapter,
+			    struct mac_ax_txdma_ch_map *ch_map)
+{
+	return MACNOTSUP;
+}
+
+u32 set_pcie_speed_sdio(struct mac_ax_adapter *adapter,
+			enum mac_ax_pcie_phy speed)
+{
+	return MACNOTSUP;
+}
+
+u32 get_pcie_speed_sdio(struct mac_ax_adapter *adapter,
+			u8 *speed)
+{
+	return MACNOTSUP;
+}
+
+u32 poll_rxdma_ch_idle_sdio(struct mac_ax_adapter *adapter,
+			    struct mac_ax_rxdma_ch_map *ch_map)
+{
+	return MACNOTSUP;
+}
+
+u32 ctrl_txhci_sdio(struct mac_ax_adapter *adapter, enum mac_ax_func_sw en)
+{
+	return MACNOTSUP;
+}
+
+u32 ctrl_rxhci_sdio(struct mac_ax_adapter *adapter, enum mac_ax_func_sw en)
+{
+	return MACNOTSUP;
+}
+
+u32 ctrl_dma_io_sdio(struct mac_ax_adapter *adapter, enum mac_ax_func_sw en)
+{
+	return MACNOTSUP;
+}
+
+u32 get_io_stat_sdio(struct mac_ax_adapter *adapter,
+		     struct mac_ax_io_stat *out_st)
+{
+	return MACNOTSUP;
+}
+
+u32 get_avail_txbd_sdio(struct mac_ax_adapter *adapter, u8 ch_idx,
+			u16 *host_idx, u16 *hw_idx, u16 *avail_txbd)
+{
+	return MACNOTSUP;
+}
+
+u32 get_avail_rxbd_sdio(struct mac_ax_adapter *adapter, u8 ch_idx,
+			u16 *host_idx, u16 *hw_idx, u16 *avail_rxbd)
+{
+	return MACNOTSUP;
+}
+
+u32 trigger_txdma_sdio(struct mac_ax_adapter *adapter,
+		       struct tx_base_desc *txbd_ring, u8 ch_idx)
+{
+	return MACNOTSUP;
+}
+
+u32 notify_rxdone_sdio(struct mac_ax_adapter *adapter,
+		       struct rx_base_desc *rxbd, u8 ch)
+{
+	return MACNOTSUP;
+}
+
+u32 sdio_autok_counter_avg(struct mac_ax_adapter *adapter)
+{
+	return MACSUCCESS;
+}
+
+u32 sdio_tp_adjust(struct mac_ax_adapter *adapter, struct mac_ax_tp_param tp)
+{
+	return MACSUCCESS;
+}
+
+static u8 _patch_reg_sdio(struct mac_ax_adapter *adapter, u32 adr)
+{
+	if (adr >= SDIO_LOCAL_REG_START && adr < SDIO_LOCAL_REG_END_PATCH)
+		return SDIO_REG_LOCAL;
+	else if (adr > SDIO_WLAN_REG_END_PATCH)
+		return SDIO_REG_WLAN_PLTFM;
+
+	return SDIO_REG_WLAN_REG;
+}
+
+static u16 _patch_fs_enuf(struct mac_ax_adapter *adapter,
+			  struct mac_ax_sdio_tx_info *tx_info)
+{
+	struct mac_ax_hfc_ch_cfg *ch_cfg = adapter->hfc_param->ch_cfg;
+	struct mac_ax_hfc_ch_info *ch_info = adapter->hfc_param->ch_info;
+	u16 wde_min = ch_cfg[tx_info->ch_dma].min;
+	u16 wde_max = ch_cfg[tx_info->ch_dma].max;
+	u16 wde_use = ch_info[tx_info->ch_dma].used;
+	u16 wde_aval;
+	u8 i, number_of_tx_channel = MAC_AX_DMA_CH_NUM;
+
+	wde_aval = wde_max - wde_min; //public
+	for (i = 0; i < number_of_tx_channel - 1; i++) {
+		wde_aval -= (ch_info[i].used < ch_cfg[i].min) ?
+			    0 : (ch_info[i].used - ch_cfg[i].min);
+	}
+	wde_aval += (wde_min < wde_use) ? 0 : (wde_min - wde_use);
+
+	return wde_aval;
+}
+
+#endif /*MAC_AX_SDIO_SUPPORT*/
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/_sdio.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/_sdio.h
new file mode 100644
index 000000000000..eb6b60b7cdbc
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/_sdio.h
@@ -0,0 +1,971 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_SDIO_H_
+#define _MAC_AX_SDIO_H_
+
+#include "../type.h"
+#include "pwr.h"
+
+#if MAC_AX_SDIO_SUPPORT
+/* SDIO CMD address mapping */
+#define SDIO_8BYTE_LEN_MASK	0x0FFF
+#define SDIO_4BYTE_LEN_MASK	0x03FF
+#define SDIO_LOCAL_MSK		0x00000FFF
+#define SDIO_LOCAL_SHIFT	0x00001000
+#define	WLAN_IOREG_MSK		0xFFFE0000
+
+/* IO Bus domain address mapping */
+#define SDIO_LOCAL_BASE		0x80000000
+#define WLAN_IOREG_BASE		0x00000000
+#define SDIO_TX_BASE		0x00010000
+
+#define SDIO_CMD_ADDR_TXFF_SHIFT	12
+#define SDIO_CMD_ADDR_TXFF_0	0
+#define SDIO_CMD_ADDR_TXFF_1	1
+#define SDIO_CMD_ADDR_TXFF_2	2
+#define SDIO_CMD_ADDR_TXFF_3	3
+#define SDIO_CMD_ADDR_TXFF_4	4
+#define SDIO_CMD_ADDR_TXFF_5	5
+#define SDIO_CMD_ADDR_TXFF_6	6
+#define SDIO_CMD_ADDR_TXFF_7	7
+#define SDIO_CMD_ADDR_TXFF_8	8
+#define SDIO_CMD_ADDR_TXFF_9	9
+#define SDIO_CMD_ADDR_TXFF_10	10
+#define SDIO_CMD_ADDR_TXFF_11	11
+#define SDIO_CMD_ADDR_TXFF_12	12
+#define SDIO_CMD_ADDR_RXFF	0x1F00
+
+#define SDIO_REG_LOCAL		0
+#define SDIO_REG_WLAN_REG	1
+#define SDIO_REG_WLAN_PLTFM	2
+
+#define SDIO_PWR_ON		0
+#define SDIO_PWR_OFF		1
+
+#define SDIO_WAIT_CNT		50
+
+#define SDIO_LOCAL_REG_START		0x1000
+#define SDIO_LOCAL_REG_END		0x1F00
+#define SDIO_LOCAL_REG_START_V1		0x4000
+#define SDIO_LOCAL_REG_END_V1		0x4F00
+#define SDIO_LOCAL_REG_END_PATCH	0x2000
+#define SDIO_WLAN_REG_END		0x1FFFF
+#define SDIO_WLAN_REG_END_PATCH		0xFFFF
+
+#define SDIO_BYTE_MODE_SIZE_MAX 512
+#define CMAC_CLK_ALLEN 0xFFFFFFFF
+#define SDIO_DEFAULT_AGG_NUM	0x40
+
+#define PWR_IN_LPS_R8	0xAA
+#define PWR_IN_LPS_R16	0xAAAA
+#define PWR_IN_LPS_R32	0xAAAAAAAA
+
+/**
+ * @struct mac_sdio_tbl
+ * @brief mac_sdio_tbl
+ *
+ * @var mac_sdio_tbl::lock
+ * Please Place Description here.
+ */
+struct mac_sdio_tbl {
+	mac_ax_mutex lock;
+};
+
+/**
+ * @struct mac_sdio_ch_thr
+ * @brief mac_sdio_ch_thr
+ *
+ * @var mac_sdio_ch_thr::thr
+ * Please Place Description here.
+ * @var mac_sdio_ch_thr::intrpt_en
+ * Please Place Description here.
+ * @var mac_sdio_ch_thr::wp_sh
+ * Please Place Description here.
+ * @var mac_sdio_ch_thr::wp_msk
+ * Please Place Description here.
+ * @var mac_sdio_ch_thr::wd_sh
+ * Please Place Description here.
+ * @var mac_sdio_ch_thr::wd_msk
+ * Please Place Description here.
+ */
+struct mac_sdio_ch_thr {
+	u16 thr;
+	u32 intrpt_en;
+	u8 wp_sh;
+	u16 wp_msk;
+	u8 wd_sh;
+	u16 wd_msk;
+};
+
+/**
+ * @enum sdio_io_size
+ *
+ * @brief sdio_io_size
+ *
+ * @var sdio_io_size::SDIO_IO_BYTE
+ * Please Place Description here.
+ * @var sdio_io_size::SDIO_IO_WORD
+ * Please Place Description here.
+ * @var sdio_io_size::SDIO_IO_DWORD
+ * Please Place Description here.
+ * @var sdio_io_size::SDIO_IO_LAST
+ * Please Place Description here.
+ * @var sdio_io_size::SDIO_IO_MAX
+ * Please Place Description here.
+ * @var sdio_io_size::SDIO_IO_INVALID
+ * Please Place Description here.
+ */
+enum sdio_io_size {
+	SDIO_IO_BYTE,
+	SDIO_IO_WORD,
+	SDIO_IO_DWORD,
+
+	/* keep last */
+	SDIO_IO_LAST,
+	SDIO_IO_MAX = SDIO_IO_LAST,
+	SDIO_IO_INVALID = SDIO_IO_LAST,
+};
+
+/**
+ * @enum sdio_tx_byte_cnt
+ *
+ * @brief sdio_tx_byte_cnt
+ *
+ * @var sdio_tx_byte_cnt::SDIO_IO_BYTE
+ * Please Place Description here.
+ * @var sdio_tx_byte_cnt::SDIO_IO_WORD
+ * Please Place Description here.
+ */
+enum sdio_tx_byte_cnt {
+	SDIO_TX_AGG_8_BYTE_CNT,
+	SDIO_TX_DUMMY_4_BYTE_CNT,
+};
+
+u32 r_indir_cmd53_sdio(struct mac_ax_adapter *adapter, u32 adr);
+u32 r8_indir_sdio(struct mac_ax_adapter *adapter, u32 adr);
+void w8_indir_sdio(struct mac_ax_adapter *adapter, u32 adr, u32 val);
+void w16_indir_sdio(struct mac_ax_adapter *adapter, u32 adr, u32 val);
+void w32_indir_sdio(struct mac_ax_adapter *adapter, u32 adr, u32 val);
+u8 pwr_state_chk_sdio(struct mac_ax_adapter *adapter);
+u8 reg_chk_sdio(struct mac_ax_adapter *adapter, u32 adr);
+void chk_rqd_pg_num(struct mac_ax_adapter *adapter,
+		    struct mac_ax_sdio_tx_info *tx_info);
+u32 chk_fs_enuf(struct mac_ax_adapter *adapter,
+		struct mac_ax_sdio_tx_info *tx_info);
+u32 get_pg_size_pow(u32 size);
+u32 tx_allow_data_ch(struct mac_ax_adapter *adapter,
+		     struct mac_ax_sdio_tx_info *info);
+u32 tx_allow_fwcmd_ch(struct mac_ax_adapter *adapter,
+		      struct mac_ax_sdio_tx_info *info);
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup BasicIO
+ * @{
+ */
+/**
+ * @brief reg_read8_sdio
+ *
+ * @param *adapter
+ * @param addr
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 reg_read8_sdio(struct mac_ax_adapter *adapter, u32 addr);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup BasicIO
+ * @{
+ */
+/**
+ * @brief reg_write8_sdio
+ *
+ * @param *adapter
+ * @param addr
+ * @param val
+ * @return Please Place Description here.
+ * @retval void
+ */
+void reg_write8_sdio(struct mac_ax_adapter *adapter, u32 addr, u8 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup BasicIO
+ * @{
+ */
+/**
+ * @brief reg_read16_sdio
+ *
+ * @param *adapter
+ * @param addr
+ * @return Please Place Description here.
+ * @retval u16
+ */
+u16 reg_read16_sdio(struct mac_ax_adapter *adapter, u32 addr);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup BasicIO
+ * @{
+ */
+/**
+ * @brief reg_write16_sdio
+ *
+ * @param *adapter
+ * @param addr
+ * @param val
+ * @return Please Place Description here.
+ * @retval void
+ */
+void reg_write16_sdio(struct mac_ax_adapter *adapter, u32 addr, u16 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup BasicIO
+ * @{
+ */
+
+/**
+ * @brief reg_read32_sdio
+ *
+ * @param *adapter
+ * @param addr
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 reg_read32_sdio(struct mac_ax_adapter *adapter, u32 addr);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup BasicIO
+ * @{
+ */
+/**
+ * @brief reg_write32_sdio
+ *
+ * @param *adapter
+ * @param addr
+ * @param val
+ * @return Please Place Description here.
+ * @retval void
+ */
+void reg_write32_sdio(struct mac_ax_adapter *adapter, u32 addr, u32 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+/**
+ * @brief reg_read_n_sdio
+ *
+ * @param *adapter
+ * @param adr
+ * @param size
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 reg_read_n_sdio(struct mac_ax_adapter *adapter, u32 adr, u32 size, u8 *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief tx_allow_sdio
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 tx_allow_sdio(struct mac_ax_adapter *adapter,
+		  struct mac_ax_sdio_tx_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief tx_cmd_addr_sdio
+ *
+ * @param *adapter
+ * @param *info
+ * @param *cmd_addr
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 tx_cmd_addr_sdio(struct mac_ax_adapter *adapter,
+		     struct mac_ax_sdio_tx_info *info, u32 *cmd_addr);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief sdio_init
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 sdio_init(struct mac_ax_adapter *adapter, void *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief sdio_deinit
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 sdio_deinit(struct mac_ax_adapter *adapter, void *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief r_indir_sdio
+ *
+ * @param *adapter
+ * @param adr
+ * @param size
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 r_indir_sdio(struct mac_ax_adapter *adapter, u32 adr,
+		 enum sdio_io_size size);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief w_indir_sdio
+ *
+ * @param *adapter
+ * @param adr
+ * @param val
+ * @param size
+ * @return Please Place Description here.
+ * @retval void
+ */
+void w_indir_sdio(struct mac_ax_adapter *adapter, u32 adr, u32 val,
+		  enum sdio_io_size size);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief set_info_sdio
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_info_sdio(struct mac_ax_adapter *adapter,
+		  struct mac_ax_sdio_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief tx_agg_cfg_sdio
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 tx_agg_cfg_sdio(struct mac_ax_adapter *adapter,
+		    struct mac_ax_sdio_txagg_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief sdio_tbl_init
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 sdio_tbl_init(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief sdio_tbl_exit
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 sdio_tbl_exit(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief sdio_pwr_switch
+ *
+ * @param *vadapter
+ * @param mac_ax_wow_ctrl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_sdio_wowlan(struct mac_ax_adapter *adapter, enum mac_ax_wow_ctrl w_c);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief sdio_get_txagg_num
+ *
+ * @param *adapter
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 sdio_get_txagg_num(struct mac_ax_adapter *adapter, u8 band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief sdio_get_rx_state
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 sdio_get_rx_state(struct mac_ax_adapter *adapter, u32 *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief dbcc_hci_ctrl_sdio
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dbcc_hci_ctrl_sdio(struct mac_ax_adapter *adapter,
+		       struct mac_ax_dbcc_hci_ctrl *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief ltr_set_sdio
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ltr_set_sdio(struct mac_ax_adapter *adapter,
+		 struct mac_ax_pcie_ltr_param *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief ctrl_txdma_ch_sdio
+ *
+ * @param *adapter
+ * @param *ch_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ctrl_txdma_ch_sdio(struct mac_ax_adapter *adapter,
+		       struct mac_ax_txdma_ch_map *ch_map);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief clr_idx_all_sdio
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 clr_idx_all_sdio(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief poll_txdma_ch_idle_sdio
+ *
+ * @param *adapter
+ * @param *ch_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 poll_txdma_ch_idle_sdio(struct mac_ax_adapter *adapter,
+			    struct mac_ax_txdma_ch_map *ch_map);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief set_pcie_speed_sdio
+ *
+ * @param *adapter
+ * @param speed
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_pcie_speed_sdio(struct mac_ax_adapter *adapter,
+			enum mac_ax_pcie_phy speed);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief get_pcie_speed_sdio
+ *
+ * @param *adapter
+ * @param *speed
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_pcie_speed_sdio(struct mac_ax_adapter *adapter,
+			u8 *speed);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief poll_rxdma_ch_idle_sdio
+ *
+ * @param *adapter
+ * @param *ch_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 poll_rxdma_ch_idle_sdio(struct mac_ax_adapter *adapter,
+			    struct mac_ax_rxdma_ch_map *ch_map);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief ctrl_txhci_sdio
+ *
+ * @param *adapter
+ * @param en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ctrl_txhci_sdio(struct mac_ax_adapter *adapter, enum mac_ax_func_sw en);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief ctrl_rxhci_sdio
+ *
+ * @param *adapter
+ * @param en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ctrl_rxhci_sdio(struct mac_ax_adapter *adapter, enum mac_ax_func_sw en);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief ctrl_dma_io_sdio
+ *
+ * @param *adapter
+ * @param en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ctrl_dma_io_sdio(struct mac_ax_adapter *adapter, enum mac_ax_func_sw en);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief get_io_stat_sdio
+ *
+ * @param *adapter
+ * @param *out_st
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_io_stat_sdio(struct mac_ax_adapter *adapter,
+		     struct mac_ax_io_stat *out_st);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief get_avail_txbd_sdio
+ *
+ * @param *adapter
+ * @param ch_idx
+ * @param *host_idx
+ * @param *hw_idx
+ * @param *avail_txbd
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_avail_txbd_sdio(struct mac_ax_adapter *adapter, u8 ch_idx,
+			u16 *host_idx, u16 *hw_idx, u16 *avail_txbd);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief get_avail_rxbd_sdio
+ *
+ * @param *adapter
+ * @param ch_idx
+ * @param *host_idx
+ * @param *hw_idx
+ * @param *avail_rxbd
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_avail_rxbd_sdio(struct mac_ax_adapter *adapter, u8 ch_idx,
+			u16 *host_idx, u16 *hw_idx, u16 *avail_rxbd);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief trigger_txdma_sdio
+ *
+ * @param *adapter
+ * @param *txbd_ring
+ * @param ch_idx
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 trigger_txdma_sdio(struct mac_ax_adapter *adapter,
+		       struct tx_base_desc *txbd_ring, u8 ch_idx);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief notify_rxdone_sdio
+ *
+ * @param *adapter
+ * @param *rxbd
+ * @param ch
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 notify_rxdone_sdio(struct mac_ax_adapter *adapter,
+		       struct rx_base_desc *rxbd, u8 ch);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief sdio_autok_counter_avg
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 sdio_autok_counter_avg(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief sdio_tp_adjust
+ *
+ * @param *adapter
+ * @param tp
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 sdio_tp_adjust(struct mac_ax_adapter *adapter, struct mac_ax_tp_param tp);
+/**
+ * @}
+ * @}
+ */
+
+#endif /*MAC_AX_SDIO_SUPPORT*/
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/addr_cam.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/addr_cam.c
new file mode 100644
index 000000000000..eb597a8f3e72
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/addr_cam.c
@@ -0,0 +1,917 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "addr_cam.h"
+
+struct mac_ax_mc_table {
+	u8 valid;
+	struct mac_ax_multicast_info mc;
+	struct mac_ax_role_info role;
+};
+
+#define MAC_AX_MAX_MC_ENTRY 32
+static struct mac_ax_mc_table mc_role[MAC_AX_MAX_MC_ENTRY];
+
+#define MAC_AX_NO_HIT_IDX 0xFF
+
+static u8 get_set_bits_of_msk(u8 msk)
+{
+	u8 set_bits;
+
+	if (msk == 0)
+		return 0;
+	set_bits = msk & (msk - 1);
+	if (set_bits == 0)
+		return 1;
+	return get_set_bits_of_msk(set_bits) + 1;
+}
+
+u32 find_avail_addr_cam_entry(struct mac_ax_adapter *adapter,
+			      struct mac_ax_role_info *info)
+{
+	u16 i;
+
+	for (i = 0; i < adapter->hw_info->macid_num; i++) {
+		if (!mac_role_srch_by_addr_cam(adapter, i))
+			break;
+	}
+	if (i == adapter->hw_info->macid_num)
+		return MACADDRCAMFL;
+	info->a_info.addr_cam_idx = (u8)i;
+
+	return MACSUCCESS;
+}
+
+u32 find_avail_bssid_cam_entry(struct mac_ax_adapter *adapter,
+			       struct mac_ax_role_info *info)
+{
+	u8 i;
+	struct mac_role_tbl *role;
+	u8 maddr_cmp_len = ETH_ALEN;
+
+	info->a_info.bssid_cam_idx = adapter->hw_info->bssid_num;
+	info->b_info.bssid_cam_idx = adapter->hw_info->bssid_num;
+
+	if (info->a_info.mask_sel == MAC_AX_BSSID_MSK)
+		maddr_cmp_len = get_set_bits_of_msk(info->a_info.addr_mask);
+
+	for (i = 0; i < adapter->hw_info->bssid_num; i++) {
+		role = mac_role_srch_by_bssid(adapter, i);
+		if (role &&
+		    !PLTFM_MEMCMP(info->bssid,
+				  role->info.bssid, maddr_cmp_len) &&
+		    info->band == role->info.band) {
+			info->a_info.bssid_cam_idx =
+				role->info.a_info.bssid_cam_idx;
+			if (maddr_cmp_len < ETH_ALEN) {
+				PLTFM_MEMCPY(info->b_info.bssid,
+					     role->info.b_info.bssid,
+					     ETH_ALEN);
+			}
+			break;
+		} else if (!role) {
+			if (info->a_info.bssid_cam_idx ==
+			    adapter->hw_info->bssid_num) {
+				info->a_info.bssid_cam_idx = i;
+			}
+		}
+	}
+
+	if (info->a_info.bssid_cam_idx == adapter->hw_info->bssid_num)
+		return MACBSSIDCAMFL;
+	info->b_info.bssid_cam_idx = info->a_info.bssid_cam_idx;
+
+	return MACSUCCESS;
+}
+
+u32 init_addr_cam_info(struct mac_ax_adapter *adapter,
+		       struct mac_ax_role_info *info,
+		       struct fwcmd_addrcam_info *fw_addrcam)
+{
+	u32 ret;
+
+	ret = find_avail_addr_cam_entry(adapter, info);
+	if (ret)
+		return ret;
+
+	ret = find_avail_bssid_cam_entry(adapter, info);
+	if (ret)
+		return ret;
+
+	fill_addr_cam_info(adapter, info, fw_addrcam);
+	fill_bssid_cam_info(adapter, info, fw_addrcam);
+
+	return MACSUCCESS;
+}
+
+u32 change_addr_cam_info(struct mac_ax_adapter *adapter,
+			 struct mac_ax_role_info *info,
+			 struct fwcmd_addrcam_info *fw_addrcam)
+{
+	u32 ret;
+
+	ret = find_avail_bssid_cam_entry(adapter, info);
+	if (ret)
+		return ret;
+
+	fill_addr_cam_info(adapter, info, fw_addrcam);
+	fill_bssid_cam_info(adapter, info, fw_addrcam);
+
+	return MACSUCCESS;
+}
+
+u32 fill_addr_cam_info(struct mac_ax_adapter *adapter,
+		       struct mac_ax_role_info *info,
+		       struct fwcmd_addrcam_info *fw_addrcam)
+{
+	struct mac_ax_addr_cam_info a_info;
+	u8 i;
+	u8 sma_hash = 0x00;
+	u8 tma_hash = 0x00;
+	u8 maddr_cmp_len;
+
+	maddr_cmp_len = get_set_bits_of_msk(info->a_info.addr_mask);
+
+	switch (info->a_info.mask_sel) {
+	case MAC_AX_SMA_MSK:
+		for (i = 0; i < maddr_cmp_len; i++)
+			sma_hash ^= info->a_info.sma[i];
+		for (i = 0; i < ETH_ALEN; i++)
+			tma_hash ^= info->a_info.tma[i];
+		break;
+	case MAC_AX_TMA_MSK:
+		for (i = 0; i < ETH_ALEN; i++)
+			sma_hash ^= info->a_info.sma[i];
+		for (i = 0; i < maddr_cmp_len; i++)
+			tma_hash ^= info->a_info.tma[i];
+		break;
+	case MAC_AX_NO_MSK:
+	case MAC_AX_BSSID_MSK:
+	default:
+		for (i = 0; i < ETH_ALEN; i++)
+			sma_hash ^= info->a_info.sma[i];
+		for (i = 0; i < ETH_ALEN; i++)
+			tma_hash ^= info->a_info.tma[i];
+		break;
+	}
+
+	a_info = info->a_info;
+
+	fw_addrcam->dword1 =
+	  cpu_to_le32(SET_WORD(a_info.addr_cam_idx,
+			       FWCMD_H2C_ADDRCAM_INFO_IDX) |
+		      SET_WORD(a_info.offset, FWCMD_H2C_ADDRCAM_INFO_OFFSET) |
+		      SET_WORD(a_info.len, FWCMD_H2C_ADDRCAM_INFO_LEN));
+
+	fw_addrcam->dword2 =
+	  cpu_to_le32(((a_info.valid) ? FWCMD_H2C_ADDRCAM_INFO_VALID : 0) |
+	   SET_WORD(a_info.net_type, FWCMD_H2C_ADDRCAM_INFO_NET_TYPE) |
+	   SET_WORD(a_info.bcn_hit_cond, FWCMD_H2C_ADDRCAM_INFO_BCN_HIT_COND) |
+	   SET_WORD(a_info.hit_rule, FWCMD_H2C_ADDRCAM_INFO_HIT_RULE) |
+	   ((a_info.bb_sel) ? FWCMD_H2C_ADDRCAM_INFO_BB_SEL : 0) |
+	   SET_WORD(a_info.addr_mask, FWCMD_H2C_ADDRCAM_INFO_ADDR_MASK) |
+	   SET_WORD(a_info.mask_sel, FWCMD_H2C_ADDRCAM_INFO_MASK_SEL) |
+	   SET_WORD(sma_hash, FWCMD_H2C_ADDRCAM_INFO_SMA_HASH) |
+	   SET_WORD(tma_hash, FWCMD_H2C_ADDRCAM_INFO_TMA_HASH));
+
+	fw_addrcam->dword3 =
+	  cpu_to_le32(SET_WORD(a_info.bssid_cam_idx,
+			       FWCMD_H2C_ADDRCAM_INFO_BSSID_CAM_IDX) |
+	   ((a_info.is_mul_ent) ? FWCMD_H2C_ADDRCAM_INFO_IS_MUL_ENT : 0));
+
+	fw_addrcam->dword4 =
+	  cpu_to_le32(SET_WORD(a_info.sma[0], FWCMD_H2C_ADDRCAM_INFO_SMA0) |
+	   SET_WORD(a_info.sma[1], FWCMD_H2C_ADDRCAM_INFO_SMA1) |
+	   SET_WORD(a_info.sma[2], FWCMD_H2C_ADDRCAM_INFO_SMA2) |
+	   SET_WORD(a_info.sma[3], FWCMD_H2C_ADDRCAM_INFO_SMA3));
+
+	fw_addrcam->dword5 =
+	  cpu_to_le32(SET_WORD(a_info.sma[4], FWCMD_H2C_ADDRCAM_INFO_SMA4) |
+	   SET_WORD(a_info.sma[5], FWCMD_H2C_ADDRCAM_INFO_SMA5) |
+	   SET_WORD(a_info.tma[0], FWCMD_H2C_ADDRCAM_INFO_TMA0) |
+	   SET_WORD(a_info.tma[1], FWCMD_H2C_ADDRCAM_INFO_TMA1));
+
+	fw_addrcam->dword6 =
+	  cpu_to_le32(SET_WORD(a_info.tma[2], FWCMD_H2C_ADDRCAM_INFO_TMA2) |
+	   SET_WORD(a_info.tma[3], FWCMD_H2C_ADDRCAM_INFO_TMA3) |
+	   SET_WORD(a_info.tma[4], FWCMD_H2C_ADDRCAM_INFO_TMA4) |
+	   SET_WORD(a_info.tma[5], FWCMD_H2C_ADDRCAM_INFO_TMA5));
+
+	// dword7 rsvd
+
+	fw_addrcam->dword8 =
+	  cpu_to_le32(SET_WORD(a_info.macid, FWCMD_H2C_ADDRCAM_INFO_MACID) |
+	   SET_WORD(a_info.port_int, FWCMD_H2C_ADDRCAM_INFO_PORT_INT) |
+	   SET_WORD(a_info.tsf_sync, FWCMD_H2C_ADDRCAM_INFO_TSF_SYNC) |
+	   ((a_info.tf_trs) ? FWCMD_H2C_ADDRCAM_INFO_TF_TRS : 0) |
+	   ((a_info.lsig_txop) ? FWCMD_H2C_ADDRCAM_INFO_LSIG_TXOP : 0) |
+	   SET_WORD(a_info.tgt_ind, FWCMD_H2C_ADDRCAM_INFO_TGT_IND) |
+	   SET_WORD(a_info.frm_tgt_ind, FWCMD_H2C_ADDRCAM_INFO_FRM_TGT_IND));
+
+	fw_addrcam->dword9 =
+	  cpu_to_le32((a_info.aid12 & 0xfff) |
+	   ((a_info.wol_pattern) ? FWCMD_H2C_ADDRCAM_INFO_WOL_PATTERN : 0) |
+	   ((a_info.wol_uc) ? FWCMD_H2C_ADDRCAM_INFO_WOL_UC : 0) |
+	   ((a_info.wol_magic) ? FWCMD_H2C_ADDRCAM_INFO_WOL_MAGIC : 0) |
+	   ((a_info.wapi) ? FWCMD_H2C_ADDRCAM_INFO_WAPI : 0) |
+	   SET_WORD(a_info.sec_ent_mode, FWCMD_H2C_ADDRCAM_INFO_SEC_ENT_MODE) |
+	   SET_WORD(a_info.sec_ent_keyid[0],
+		    FWCMD_H2C_ADDRCAM_INFO_SEC_ENT0_KEYID) |
+	   SET_WORD(a_info.sec_ent_keyid[1],
+		    FWCMD_H2C_ADDRCAM_INFO_SEC_ENT1_KEYID) |
+	   SET_WORD(a_info.sec_ent_keyid[2],
+		    FWCMD_H2C_ADDRCAM_INFO_SEC_ENT2_KEYID) |
+	   SET_WORD(a_info.sec_ent_keyid[3],
+		    FWCMD_H2C_ADDRCAM_INFO_SEC_ENT3_KEYID) |
+	   SET_WORD(a_info.sec_ent_keyid[4],
+		    FWCMD_H2C_ADDRCAM_INFO_SEC_ENT4_KEYID) |
+	   SET_WORD(a_info.sec_ent_keyid[5],
+		    FWCMD_H2C_ADDRCAM_INFO_SEC_ENT5_KEYID) |
+	   SET_WORD(a_info.sec_ent_keyid[6],
+		    FWCMD_H2C_ADDRCAM_INFO_SEC_ENT6_KEYID));
+
+	fw_addrcam->dword10 =
+	  cpu_to_le32(SET_WORD(a_info.sec_ent_valid,
+			       FWCMD_H2C_ADDRCAM_INFO_SEC_ENT_VALID) |
+	   SET_WORD(a_info.sec_ent[0], FWCMD_H2C_ADDRCAM_INFO_SEC_ENT0) |
+	   SET_WORD(a_info.sec_ent[1], FWCMD_H2C_ADDRCAM_INFO_SEC_ENT1) |
+	   SET_WORD(a_info.sec_ent[2], FWCMD_H2C_ADDRCAM_INFO_SEC_ENT2));
+
+	fw_addrcam->dword11 =
+	  cpu_to_le32(SET_WORD(a_info.sec_ent[3],
+			       FWCMD_H2C_ADDRCAM_INFO_SEC_ENT3) |
+	   SET_WORD(a_info.sec_ent[4], FWCMD_H2C_ADDRCAM_INFO_SEC_ENT4) |
+	   SET_WORD(a_info.sec_ent[5], FWCMD_H2C_ADDRCAM_INFO_SEC_ENT5) |
+	   SET_WORD(a_info.sec_ent[6], FWCMD_H2C_ADDRCAM_INFO_SEC_ENT6));
+
+	return MACSUCCESS;
+}
+
+u32 fill_bssid_cam_info(struct mac_ax_adapter *adapter,
+			struct mac_ax_role_info *role_info,
+			struct fwcmd_addrcam_info *fw_addrcam)
+{
+	struct mac_ax_bssid_cam_info b_info = role_info->b_info;
+	u8 msk = role_info->mask_sel == MAC_AX_BSSID_MSK ?
+		 role_info->addr_mask : MAC_AX_MSK_NONE;
+
+	fw_addrcam->dword12 =
+	  cpu_to_le32(SET_WORD(b_info.bssid_cam_idx,
+			       FWCMD_H2C_ADDRCAM_INFO_B_IDX) |
+		      SET_WORD(b_info.offset, FWCMD_H2C_ADDRCAM_INFO_B_OFFSET) |
+		      SET_WORD(b_info.len, FWCMD_H2C_ADDRCAM_INFO_B_LEN));
+
+	fw_addrcam->dword13 =
+	  cpu_to_le32(((b_info.valid) ? FWCMD_H2C_ADDRCAM_INFO_B_VALID : 0) |
+	   SET_WORD(msk, FWCMD_H2C_ADDRCAM_INFO_B_MSK) |
+	   ((b_info.bb_sel) ? FWCMD_H2C_ADDRCAM_INFO_B_BB_SEL : 0) |
+	   SET_WORD(b_info.bss_color, FWCMD_H2C_ADDRCAM_INFO_BSS_COLOR) |
+	   SET_WORD(b_info.bssid[0], FWCMD_H2C_ADDRCAM_INFO_BSSID0) |
+	   SET_WORD(b_info.bssid[1], FWCMD_H2C_ADDRCAM_INFO_BSSID1));
+
+	fw_addrcam->dword14 =
+	  cpu_to_le32(SET_WORD(b_info.bssid[2], FWCMD_H2C_ADDRCAM_INFO_BSSID2) |
+	   SET_WORD(b_info.bssid[3], FWCMD_H2C_ADDRCAM_INFO_BSSID3) |
+	   SET_WORD(b_info.bssid[4], FWCMD_H2C_ADDRCAM_INFO_BSSID4) |
+	   SET_WORD(b_info.bssid[5], FWCMD_H2C_ADDRCAM_INFO_BSSID5));
+
+	return MACSUCCESS;
+}
+
+u32 mac_upd_addr_cam(struct mac_ax_adapter *adapter,
+		     struct mac_ax_role_info *info,
+		     enum mac_ax_role_opmode op)
+{
+	u32 tbl[21];
+	u32 ret;
+	u32 i;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct fwcmd_addrcam_info *fwcmd_tbl;
+	u8 ctlinfo_aidx_off;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+		if (!h2cb)
+			return MACNPTR;
+		buf = h2cb_put(h2cb, sizeof(struct fwcmd_addrcam_info));
+		if (!buf) {
+			ret = MACNOBUF;
+			goto FWOFLD_END;
+		}
+		fwcmd_tbl = (struct fwcmd_addrcam_info *)buf;
+
+		if (op == CHG)
+			ret = change_addr_cam_info(adapter, info, fwcmd_tbl);
+		else
+			ret = init_addr_cam_info(adapter, info, fwcmd_tbl);
+		if (ret)
+			goto FWOFLD_END;
+		// dword 0
+
+		ret = h2c_pkt_set_hdr(adapter,
+				      h2cb,
+				      FWCMD_TYPE_H2C,
+				      FWCMD_H2C_CAT_MAC,
+				      FWCMD_H2C_CL_ADDR_CAM_UPDATE,
+				      FWCMD_H2C_FUNC_ADDRCAM_INFO,
+				      0,
+				      1);
+		if (ret)
+			goto FWOFLD_END;
+
+		// Return MACSUCCESS if h2c aggregation is enabled and enqueued successfully.
+		// The H2C shall be sent by mac_h2c_agg_tx.
+		ret = h2c_agg_enqueue(adapter, h2cb);
+		if (ret == MACSUCCESS)
+			return MACSUCCESS;
+
+		ret = h2c_pkt_build_txd(adapter, h2cb);
+		if (ret)
+			goto FWOFLD_END;
+		#if MAC_AX_PHL_H2C
+		ret = PLTFM_TX(h2cb);
+		#else
+		ret = PLTFM_TX(h2cb->data, h2cb->len);
+		#endif
+
+FWOFLD_END:
+		h2cb_free(adapter, h2cb);
+		if (!ret)
+			h2c_end_flow(adapter);
+
+		return ret;
+	}
+	if (op == CHG)
+		ret = change_addr_cam_info(adapter,
+					   info,
+					   (struct fwcmd_addrcam_info *)
+					   tbl);
+	else
+		ret = init_addr_cam_info(adapter, info,
+					 (struct fwcmd_addrcam_info *)
+					 tbl);
+	if (ret)
+		return ret;
+	// Indirect write addr cam
+	for (i = 0; i < (u32)((info->a_info.len)) / 4; i++)
+		mac_sram_dbg_write(adapter, (info->a_info.addr_cam_idx *
+					     info->a_info.len) + (i * 4),
+				   le32_to_cpu(tbl[i + 2]), ADDR_CAM_SEL);
+
+	// Indirect write BSSID cam
+	for (i = 0; i < (u32)((info->b_info.len)) / 4; i++)
+		mac_sram_dbg_write(adapter, (info->b_info.bssid_cam_idx *
+					     info->b_info.len) + (i * 4),
+				   le32_to_cpu(tbl[i + 13]), BSSID_CAM_SEL);
+
+	// Indirect write cmac table addr cam idx
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A))
+		ctlinfo_aidx_off = 0x18;
+	else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		 is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+		ctlinfo_aidx_off = 0x18;
+	else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		 is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		 is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		 is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))
+		ctlinfo_aidx_off = 0x17;
+	else
+		ctlinfo_aidx_off = 0xFF;
+	PLTFM_MSG_WARN("%s ind access cmac tbl start\n", __func__);
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+	adapter->hw_info->ind_aces_cnt++;
+	MAC_REG_W8(R_AX_INDIR_ACCESS_ENTRY +
+		   info->macid * CCTL_INFO_SIZE + ctlinfo_aidx_off,
+		   info->a_info.addr_cam_idx);
+	adapter->hw_info->ind_aces_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->ind_access_lock);
+	PLTFM_MSG_WARN("%s ind access cmac tbl end\n", __func__);
+
+	return MACSUCCESS;
+}
+
+static void addr_cam_opt_2_uint(struct mac_ax_adapter *adapter,
+				struct mac_ax_addrcam_ctrl_t *opt,
+				u32 *val32)
+{
+	*val32 = ((opt->addrcam_en) ? B_AX_ADDR_CAM_EN : 0) |
+		 ((opt->srch_per_mpdu) ? B_AX_ADDR_CAM_SRCH_PERPKT : 0) |
+		 ((opt->a2_bit0_cmp_en) ? B_AX_ADDR_CAM_A2_B0_CHK : 0) |
+		 //opt->clr_all_content) ? B_AX_ADDR_CAM_CLR: 0) |
+		 SET_WORD(opt->srch_time_lmt, B_AX_ADDR_CAM_CMPLIMT) |
+		 SET_WORD(opt->srch_range_lmt, B_AX_ADDR_CAM_RANGE);
+}
+
+static void addr_cam_dis_opt_2_uint(struct mac_ax_adapter *adapter,
+				    struct mac_ax_addrcam_dis_ctrl_t *opt,
+				    u32 *val32)
+{
+	*val32 = SET_WORD(opt->def_hit_idx, B_AX_ADDR_CAM_DIS_IDX) |
+		 ((opt->def_hit_result) ? B_AX_ADDR_CAM_DIS_CAM_HIT : 0) |
+		 ((opt->def_a1_hit_result) ? B_AX_ADDR_CAM_DIS_A1_HIT : 0) |
+		 ((opt->def_a2_hit_result) ? B_AX_ADDR_CAM_DIS_A2_HIT : 0) |
+		 ((opt->def_a3_hit_result) ? B_AX_ADDR_CAM_DIS_A3_HIT : 0) |
+		 SET_WORD(opt->def_port, B_AX_ADDR_CAM_DIS_PORT) |
+		 SET_WORD(opt->def_sec_idx, B_AX_ADDR_CAM_DIS_SEC_IDX) |
+		 SET_WORD(opt->def_macid, B_AX_ADDR_CAM_DIS_MACID);
+}
+
+u32 mac_get_cfg_addr_cam(struct mac_ax_adapter *adapter,
+			 struct mac_ax_addrcam_ctrl_t *opt,
+			 enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	if (!opt) {
+		PLTFM_MSG_ERR("[ERR]%s opt is null\n", __func__);
+		return MACNPTR;
+	}
+
+	val32 = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (val32 != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return val32;
+	}
+
+	val32 = MAC_REG_R32((band == MAC_AX_BAND_1) ?
+		R_AX_ADDR_CAM_CTRL_C1 : R_AX_ADDR_CAM_CTRL);
+	opt->addrcam_en = ((val32 & B_AX_ADDR_CAM_EN) != 0);
+	opt->srch_per_mpdu = ((val32 & B_AX_ADDR_CAM_SRCH_PERPKT) != 0);
+	opt->a2_bit0_cmp_en = ((val32 & B_AX_ADDR_CAM_A2_B0_CHK) != 0);
+	opt->srch_time_lmt = GET_FIELD(val32, B_AX_ADDR_CAM_CMPLIMT);
+	opt->srch_range_lmt = GET_FIELD(val32, B_AX_ADDR_CAM_RANGE);
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_cfg_addr_cam_dis(struct mac_ax_adapter *adapter,
+			     struct mac_ax_addrcam_dis_ctrl_t *opt,
+			     enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	if (!opt) {
+		PLTFM_MSG_ERR("[ERR]%s opt is null\n", __func__);
+		return MACNPTR;
+	}
+
+	val32 = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (val32 != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return val32;
+	}
+
+	val32 = MAC_REG_R32((band == MAC_AX_BAND_1) ?
+			     R_AX_ADDR_CAM_DIS_INFO_C1 :
+			     R_AX_ADDR_CAM_DIS_INFO);
+
+	opt->def_hit_idx = GET_FIELD(val32, B_AX_ADDR_CAM_DIS_IDX);
+	opt->def_hit_result = ((val32 & B_AX_ADDR_CAM_DIS_CAM_HIT) != 0);
+	opt->def_a1_hit_result = ((val32 & B_AX_ADDR_CAM_DIS_A1_HIT) != 0);
+	opt->def_a2_hit_result = ((val32 & B_AX_ADDR_CAM_DIS_A2_HIT) != 0);
+	opt->def_a3_hit_result = ((val32 & B_AX_ADDR_CAM_DIS_A3_HIT) != 0);
+	opt->def_port = GET_FIELD(val32, B_AX_ADDR_CAM_DIS_PORT);
+	opt->def_sec_idx = GET_FIELD(val32, B_AX_ADDR_CAM_DIS_SEC_IDX);
+	opt->def_macid = GET_FIELD(val32, B_AX_ADDR_CAM_DIS_MACID);
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_addr_cam(struct mac_ax_adapter *adapter,
+		     struct mac_ax_addrcam_ctrl_t *ctl_opt,
+		     struct mac_ax_addrcam_ctrl_t *ctl_msk,
+		     enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_addrcam_ctrl_t opt = {0};
+	u32 ctl_opt_val;
+	u32 ctl_msk_val;
+	u32 opt_val;
+	u32 reg;
+	u32 cnt;
+	u32 ret = MACSUCCESS;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+	reg = (band == MAC_AX_BAND_1) ?
+	      R_AX_ADDR_CAM_CTRL_C1 : R_AX_ADDR_CAM_CTRL;
+
+	mac_get_cfg_addr_cam(adapter, &opt, band);
+
+	addr_cam_opt_2_uint(adapter, ctl_opt, &ctl_opt_val);
+	addr_cam_opt_2_uint(adapter, ctl_msk, &ctl_msk_val);
+	addr_cam_opt_2_uint(adapter, &opt, &opt_val);
+
+	opt_val = (ctl_opt_val & ctl_msk_val) |
+		  (~(~ctl_opt_val & ctl_msk_val) & opt_val);
+
+	MAC_REG_W32(reg, opt_val);
+
+	if (ctl_opt->clr_all_content & ctl_msk->clr_all_content) {
+		opt_val |= B_AX_ADDR_CAM_CLR;
+		MAC_REG_W32(reg, opt_val);
+		cnt = TRXCFG_WAIT_CNT;
+		while (cnt--) {
+			if (!(MAC_REG_R16(reg) & B_AX_ADDR_CAM_CLR))
+				break;
+			PLTFM_DELAY_US(TRXCFG_WAIT_US);
+		}
+		if (!++cnt) {
+			PLTFM_MSG_ERR("[ERR]ADDR_CAM reset\n");
+			return MACPOLLTO;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_addr_cam_dis(struct mac_ax_adapter *adapter,
+			 struct mac_ax_addrcam_dis_ctrl_t *ctl_opt,
+			 struct mac_ax_addrcam_dis_ctrl_t *ctl_msk,
+			 enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_addrcam_dis_ctrl_t opt = {0};
+	u32 ctl_opt_val;
+	u32 ctl_msk_val;
+	u32 opt_val;
+	u32 reg;
+	u32 ret = MACSUCCESS;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+	reg = (band == MAC_AX_BAND_1) ?
+	      R_AX_ADDR_CAM_DIS_INFO_C1 : R_AX_ADDR_CAM_DIS_INFO;
+
+	mac_get_cfg_addr_cam_dis(adapter, &opt, band);
+
+	addr_cam_dis_opt_2_uint(adapter, ctl_opt, &ctl_opt_val);
+	addr_cam_dis_opt_2_uint(adapter, ctl_msk, &ctl_msk_val);
+	addr_cam_dis_opt_2_uint(adapter, &opt, &opt_val);
+
+	opt_val = (ctl_opt_val & ctl_msk_val) |
+		  (~(~ctl_opt_val & ctl_msk_val) & opt_val);
+
+	MAC_REG_W32(reg, opt_val);
+
+	return MACSUCCESS;
+}
+
+u32 addr_cam_init(struct mac_ax_adapter *adapter,
+		  enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, reg;
+	u32 cnt = TRXCFG_WAIT_CNT;
+	u32 ret;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	reg = band == MAC_AX_BAND_1 ?
+		R_AX_ADDR_CAM_CTRL_C1 : R_AX_ADDR_CAM_CTRL;
+	val32 = MAC_REG_R32(reg);
+	val32 |= (SET_WORD(ADDR_CAM_SERCH_RANGE, B_AX_ADDR_CAM_RANGE) |
+		  B_AX_ADDR_CAM_EN);
+	if (band == MAC_AX_BAND_0)
+		val32 |= B_AX_ADDR_CAM_CLR;
+	MAC_REG_W32(reg, val32);
+
+	cnt = TRXCFG_WAIT_CNT;
+	while (cnt--) {
+		if (!(MAC_REG_R16(band == MAC_AX_BAND_1 ?
+		    R_AX_ADDR_CAM_CTRL_C1 : R_AX_ADDR_CAM_CTRL)
+		    & B_AX_ADDR_CAM_CLR))
+			break;
+		PLTFM_DELAY_US(TRXCFG_WAIT_US);
+	}
+	if (!++cnt) {
+		PLTFM_MSG_ERR("[ERR]ADDR_CAM reset\n");
+		return MACPOLLTO;
+	}
+	return MACSUCCESS;
+}
+
+static u32 _set_mac_resp_ack(struct mac_ax_adapter *adapter, u32 ack, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val8;
+	u32 val32;
+	u32 offset_ctrl = band ? R_AX_ADDR_CAM_CTRL_C1 : R_AX_ADDR_CAM_CTRL;
+	u32 offset_hit = band ? R_AX_ADDR_CAM_DIS_INFO_C1 :
+		R_AX_ADDR_CAM_DIS_INFO;
+
+	if (ack) {
+		val8 = MAC_REG_R8(offset_ctrl);
+		MAC_REG_W8(offset_ctrl, val8 | B_AX_ADDR_CAM_EN);
+	} else {
+		val8 = MAC_REG_R8(offset_ctrl);
+		MAC_REG_W8(offset_ctrl, val8 & ~B_AX_ADDR_CAM_EN);
+		val32 = MAC_REG_R32(offset_hit);
+		val32 = SET_CLR_WORD(val32, MAC_AX_NO_HIT_IDX,
+				     B_AX_ADDR_CAM_DIS_IDX);
+		val32 &= ~(B_AX_ADDR_CAM_DIS_CAM_HIT |
+			   B_AX_ADDR_CAM_DIS_A1_HIT);
+		MAC_REG_W32(offset_hit, val32);
+	}
+
+	return MACSUCCESS;
+}
+
+#if MAC_AX_FW_REG_OFLD
+u32 set_mac_do_resp_ack_ofld(struct mac_ax_adapter *adapter)
+{
+	u32 ret;
+	u8 cmac1_en;
+
+	cmac1_en = check_mac_en(adapter, 1, MAC_AX_CMAC_SEL) == MACSUCCESS ?
+			1 : 0;
+
+	ret = MAC_REG_W_OFLD(R_AX_ADDR_CAM_CTRL, B_AX_ADDR_CAM_EN,
+			     1, cmac1_en ? 0 : 1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: config fail\n", __func__);
+		return ret;
+	}
+	if (cmac1_en) {
+		ret = MAC_REG_W_OFLD(R_AX_ADDR_CAM_CTRL_C1,
+				     B_AX_ADDR_CAM_EN,
+				     1, 1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s: config fail\n", __func__);
+			return ret;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+u32 set_mac_not_resp_ack_ofld(struct mac_ax_adapter *adapter)
+{
+	u32 ret, msk;
+	u8 cmac1_en;
+
+	cmac1_en = check_mac_en(adapter, 1, MAC_AX_CMAC_SEL) == MACSUCCESS ?
+			1 : 0;
+
+	/* set 0xCE34[0] = 0 */
+	ret = MAC_REG_W_OFLD(R_AX_ADDR_CAM_CTRL, B_AX_ADDR_CAM_EN,
+			     0, 0);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: config fail\n", __func__);
+		return ret;
+	}
+
+	/* set 0xCE38[9:0] = 0xFF */
+	msk = (B_AX_ADDR_CAM_DIS_IDX_MSK << B_AX_ADDR_CAM_DIS_IDX_SH) |
+		B_AX_ADDR_CAM_DIS_A1_HIT |
+		B_AX_ADDR_CAM_DIS_CAM_HIT;
+	ret = MAC_REG_W_OFLD(R_AX_ADDR_CAM_DIS_INFO, msk,
+			     MAC_AX_NO_HIT_IDX, cmac1_en ? 0 : 1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: config fail\n", __func__);
+		return ret;
+	}
+
+	if (cmac1_en) {
+		ret = MAC_REG_W_OFLD(R_AX_ADDR_CAM_CTRL_C1, B_AX_ADDR_CAM_EN,
+				     0, 0);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s: config fail\n", __func__);
+			return ret;
+		}
+
+		ret = MAC_REG_W_OFLD(R_AX_ADDR_CAM_DIS_INFO_C1, msk,
+				     MAC_AX_NO_HIT_IDX, 1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s: config fail\n", __func__);
+			return ret;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+u32 set_mac_resp_ack_ofld(struct mac_ax_adapter *adapter, u32 ack)
+{
+	u32 ret;
+
+	if (ack)
+		ret = set_mac_do_resp_ack_ofld(adapter);
+	else
+		ret = set_mac_not_resp_ack_ofld(adapter);
+
+	return ret;
+}
+#endif
+
+u32 set_mac_resp_ack(struct mac_ax_adapter *adapter, u32 *ack)
+{
+	u32 ret;
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY)
+		return ret = set_mac_resp_ack_ofld(adapter, *ack);
+#endif
+
+	ret = _set_mac_resp_ack(adapter, *ack, 0);
+	if (ret == MACSUCCESS &&
+	    check_mac_en(adapter, 1, MAC_AX_CMAC_SEL) == MACSUCCESS)
+		ret = _set_mac_resp_ack(adapter, *ack, 1);
+
+	return ret;
+}
+
+u32 get_mac_resp_ack(struct mac_ax_adapter *adapter, u32 *ack)
+{
+#define MAC_AX_ACK_CMAC1_SH 1
+#define MAC_AX_ACK_CMAC0_SH 0
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 cmac0 = 0, cmac1 = 0;
+
+	cmac0 = !!(MAC_REG_R8(R_AX_ADDR_CAM_CTRL) & B_AX_ADDR_CAM_EN);
+	if (check_mac_en(adapter, 1, MAC_AX_CMAC_SEL) == MACSUCCESS)
+		cmac1 = !!(MAC_REG_R8(R_AX_ADDR_CAM_CTRL_C1) &
+			   B_AX_ADDR_CAM_EN);
+
+	*ack = cmac0 << MAC_AX_ACK_CMAC0_SH | cmac1 << MAC_AX_ACK_CMAC1_SH;
+
+	return MACSUCCESS;
+}
+
+u8 get_addr_cam_size(struct mac_ax_adapter *adapter)
+{
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+		return ADDR_CAM_ENT_LONG_SIZE;
+	else
+		return ADDR_CAM_ENT_SHORT_SIZE;
+}
+
+struct mac_ax_mc_table *
+get_avalible_mc_entry(struct mac_ax_adapter *adapter,
+		      struct mac_ax_multicast_info *info)
+{
+	struct mac_ax_mc_table *mc_entry = mc_role;
+	u8 i;
+
+	for (i = 0; i < MAC_AX_MAX_MC_ENTRY; i++) {
+		if (!PLTFM_MEMCMP(&mc_entry->mc, info, sizeof(*info)) &&
+		    mc_entry->valid == 1) {
+			PLTFM_MSG_ERR("duplicated multicast info\n");
+			return NULL;
+		}
+
+		if (mc_entry->valid == 0)
+			return mc_entry;
+		mc_entry++;
+	}
+
+	return NULL;
+}
+
+struct mac_ax_mc_table *
+get_record_mc_entry(struct mac_ax_adapter *adapter,
+		    struct mac_ax_multicast_info *info)
+{
+	struct mac_ax_mc_table *mc_entry = mc_role;
+	u8 i;
+
+	for (i = 0; i < MAC_AX_MAX_MC_ENTRY; i++) {
+		if (!PLTFM_MEMCMP(&mc_entry->mc, info, sizeof(*info)) &&
+		    mc_entry->valid == 1) {
+			return mc_entry;
+		}
+		mc_entry++;
+	}
+
+	return NULL;
+}
+
+u8 get_avalible_mc_entry_macid(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_mc_table *mc_entry = mc_role;
+	u8 i, macid = adapter->hw_info->macid_num - 1;
+
+	for (i = 0; i < MAC_AX_MAX_MC_ENTRY; i++) {
+		if (mc_entry->valid == 1 && mc_entry->role.macid <= macid)
+			macid = mc_entry->role.macid - 1;
+		mc_entry++;
+	}
+
+	return macid;
+}
+
+static u32 mac_add_multicast(struct mac_ax_adapter *adapter,
+			     struct mac_ax_multicast_info *info)
+{
+	struct mac_ax_mc_table *mc_entry;
+	struct mac_ax_role_info *role;
+	u32 ret;
+
+	mc_entry = get_avalible_mc_entry(adapter, info);
+	if (!mc_entry) {
+		PLTFM_MSG_ERR("%s: fails to get avalible mc\n", __func__);
+		return MACNPTR;
+	}
+
+	PLTFM_MEMCPY(&mc_entry->mc, info, sizeof(mc_entry->mc));
+
+	role = &mc_entry->role;
+	PLTFM_MEMSET(role, 0, sizeof(*role));
+	role->upd_mode = MAC_AX_ROLE_CREATE;
+	role->opmode = MAC_AX_ROLE_DISCONN;
+	role->macid = get_avalible_mc_entry_macid(adapter);
+	role->mask_sel = MAC_AX_SMA_MSK;
+	role->addr_mask = MAC_AX_MSK_NONE;
+	PLTFM_MEMCPY(role->self_mac, info->mc_addr, 6);
+	PLTFM_MEMCPY(role->target_mac, info->bssid, 6);
+	PLTFM_MEMCPY(role->bssid, info->bssid, 6);
+	role->is_mul_ent = 1;
+
+	ret = mac_add_role(adapter, role);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: add role fail(%d)\n", __func__, ret);
+		return ret;
+	}
+	mc_entry->valid = 1;
+
+	return MACSUCCESS;
+}
+
+static u32 mac_del_multicast(struct mac_ax_adapter *adapter,
+			     struct mac_ax_multicast_info *info)
+{
+	struct mac_ax_mc_table *mc_entry;
+	u32 ret;
+
+	mc_entry = get_record_mc_entry(adapter, info);
+	if (!mc_entry) {
+		PLTFM_MSG_ERR("%s: fails to get record mc\n", __func__);
+		return MACNPTR;
+	}
+	ret = mac_remove_role(adapter, mc_entry->role.macid);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: remove role fail(%d)\n", __func__, ret);
+		return ret;
+	}
+	mc_entry->valid = 0;
+
+	return MACSUCCESS;
+}
+
+u32 mac_pre_proc_mc_info(struct mac_ax_multicast_info *info)
+{
+	u8 i;
+
+	for (i = 0; i < 6; i++) {
+		if (!(info->mc_msk & (1 << i)))
+			info->mc_addr[i] = 0;
+	}
+
+	return 0;
+}
+
+u32 mac_cfg_multicast(struct mac_ax_adapter *adapter, u8 add,
+		      struct mac_ax_multicast_info *info)
+{
+	u32 ret;
+
+	mac_pre_proc_mc_info(info);
+
+	if (add)
+		ret = mac_add_multicast(adapter, info);
+	else
+		ret = mac_del_multicast(adapter, info);
+
+	return ret;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/addr_cam.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/addr_cam.h
new file mode 100644
index 000000000000..7f765885d7d6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/addr_cam.h
@@ -0,0 +1,345 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_ADDR_CAM_H_
+#define _MAC_AX_ADDR_CAM_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+#include "../fw_ax/inc_hdr/fwcmd_intf.h"
+
+#define ADDR_CAM_ENT_LONG_SIZE  0x40
+#define ADDR_CAM_ENT_SHORT_SIZE  0x20
+
+#define BSSID_CAM_ENT_SIZE 0x08
+#define ETH_ALEN 6
+#define DEFAULT_HIT_MACID 0x0
+
+#define ADDR_CAM_SERCH_RANGE  0x7f
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+/**
+ * @brief addr_cam_init
+ *
+ * @param *adapter
+ * @param *info
+ * @param *fw_addrcam
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 addr_cam_init(struct mac_ax_adapter *adapter,
+		  enum mac_ax_band band);
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+/**
+ * @brief addr_cam_init
+ *
+ * @param *adapter
+ * @param *info
+ * @param *fw_addrcam
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_cfg_addr_cam(struct mac_ax_adapter *adapter,
+			 struct mac_ax_addrcam_ctrl_t *opt,
+			 enum mac_ax_band band);
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+/**
+ * @brief addr_cam_init
+ *
+ * @param *adapter
+ * @param *info
+ * @param *fw_addrcam
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_cfg_addr_cam_dis(struct mac_ax_adapter *adapter,
+			     struct mac_ax_addrcam_dis_ctrl_t *opt,
+			     enum mac_ax_band band);
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+/**
+ * @brief mac_cfg_addrcam
+ *
+ * @param *adapter
+ * @param *info
+ * @param *fw_addrcam
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_addr_cam(struct mac_ax_adapter *adapter,
+		     struct mac_ax_addrcam_ctrl_t *ctl_opt,
+		     struct mac_ax_addrcam_ctrl_t *ctl_msk,
+		     enum mac_ax_band band);
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+/**
+ * @brief mac_cfg_addrcam_dis
+ *
+ * @param *adapter
+ * @param *info
+ * @param *fw_addrcam
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_addr_cam_dis(struct mac_ax_adapter *adapter,
+			 struct mac_ax_addrcam_dis_ctrl_t *ctl_opt,
+			 struct mac_ax_addrcam_dis_ctrl_t *ctl_msk,
+			 enum mac_ax_band band);
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+/**
+ * @brief fill_addr_cam_info
+ *
+ * @param *adapter
+ * @param *info
+ * @param *fw_addrcam
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 fill_addr_cam_info(struct mac_ax_adapter *adapter,
+		       struct mac_ax_role_info *info,
+		       struct fwcmd_addrcam_info *fw_addrcam);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+
+/**
+ * @brief fill_bssid_cam_info
+ *
+ * @param *adapter
+ * @param *info
+ * @param *fw_addrcam
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 fill_bssid_cam_info(struct mac_ax_adapter *adapter,
+			struct mac_ax_role_info *info,
+			struct fwcmd_addrcam_info *fw_addrcam);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+
+/**
+ * @brief init_addr_cam_info
+ *
+ * @param *adapter
+ * @param *info
+ * @param *fw_addrcam
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 init_addr_cam_info(struct mac_ax_adapter *adapter,
+		       struct mac_ax_role_info *info,
+		       struct fwcmd_addrcam_info *fw_addrcam);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+
+/**
+ * @brief change_addr_cam_info
+ *
+ * @param *adapter
+ * @param *info
+ * @param *fw_addrcam
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 change_addr_cam_info(struct mac_ax_adapter *adapter,
+			 struct mac_ax_role_info *info,
+			 struct fwcmd_addrcam_info *fw_addrcam);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+
+/**
+ * @brief mac_upd_addr_cam
+ *
+ * @param *adapter
+ * @param *info
+ * @param change_role
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_upd_addr_cam(struct mac_ax_adapter *adapter,
+		     struct mac_ax_role_info *info,
+		     enum mac_ax_role_opmode op);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+
+/**
+ * @brief set_mac_resp_ack
+ *
+ * The function could contrl MAC resp ACK or not.
+ *
+ * @param *adapter
+ * @param ack
+ * @return 0 for success. Others are fail.
+ * @retval u32
+ */
+
+u32 set_mac_resp_ack(struct mac_ax_adapter *adapter, u32 *ack);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+
+/**
+ * @brief get_mac_resp_ack
+ *
+ * The function could get MAC resp ACK ability
+ *
+ * @param *adapter
+ * @param ack
+ * @return 0 for success. Others are fail.
+ * @retval u32
+ */
+
+u32 get_mac_resp_ack(struct mac_ax_adapter *adapter, u32 *ack);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup ADDRCAM
+ * @{
+ */
+
+/**
+ * @brief get_addr_cam_size
+ *
+ * Get the entry size of address CAM
+ *
+ * @param *adapter
+ * @return ret the size of address CAM.
+ * @retval u32
+ */
+
+u8 get_addr_cam_size(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+struct mac_ax_mc_table *
+get_avalible_mc_entry(struct mac_ax_adapter *adapter,
+		      struct mac_ax_multicast_info *info);
+
+struct mac_ax_mc_table *
+get_record_mc_entry(struct mac_ax_adapter *adapter,
+		    struct mac_ax_multicast_info *info);
+
+u8 get_avalible_mc_entry_macid(struct mac_ax_adapter *adapter);
+
+u32 mac_pre_proc_mc_info(struct mac_ax_multicast_info *info);
+
+u32 mac_cfg_multicast(struct mac_ax_adapter *adapter, u8 add,
+		      struct mac_ax_multicast_info *info);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/beacon.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/beacon.c
new file mode 100644
index 000000000000..b5119a9a56ca
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/beacon.c
@@ -0,0 +1,245 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "beacon.h"
+
+u8 _byte_rev(u8 in)
+{
+	u8 data = 0;
+	u8 i;
+
+	for (i = 0; i < 8; i++)
+		data |= in & BIT(i) ? BIT(7 - i) : 0;
+	return data;
+}
+
+u8 _crc8_htsig(u8 *mem, u32 len)
+{
+	u8 crc = 0xFF;
+	u8 key = 0x07;
+	u8 k;
+
+	if (!mem)
+		return 0xFF;
+
+	while (len--) {
+		crc ^= _byte_rev(*mem++);
+		for (k = 0; k < 8; k++)
+			crc = crc & 0x80 ? (crc << 1) ^ key : crc << 1;
+	}
+
+	return crc;
+}
+
+u32 mac_calc_crc(struct mac_ax_adapter *adapter, struct mac_calc_crc_info *info)
+{
+	if (!info->buf)
+		return MACNPTR;
+
+	if (!info->len)
+		return MACBUFSZ;
+
+	info->crc = (u32)_crc8_htsig(info->buf, info->len);
+
+	return MACSUCCESS;
+}
+
+u32 mac_bcn_ofld_ctrl(struct mac_ax_adapter *adapter, struct mac_bcn_ofld_info *info)
+{
+	struct fwcmd_ie_cam *cmd;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	u32 ret, iecam_len, i;
+	u8 *buf, *iecam_buf;
+	u8 rst = 0, num = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_ie_cam) - IECAM_INFO_SIZE);
+	if (!buf) {
+		ret = MACNOBUF;
+		return ret;
+	}
+
+	switch (info->ctrl_type) {
+	case MAC_BCN_OFLD_UPD_PARAM:
+	case MAC_BCN_OFLD_DIS:
+		num = 0;
+		rst = 0;
+		break;
+	case MAC_BCN_OFLD_EN:
+	case MAC_BCN_OFLD_UPD_CAM:
+		if (!info->cam_num) {
+			PLTFM_MSG_ERR("%s cam num is 0 when enable/update iecam\n", __func__);
+			return MACFUNCINPUT;
+		}
+
+		rst = info->rst_iecam == MAC_AX_FUNC_EN ? 1 : 0;
+		num = info->cam_num;
+	}
+
+	cmd = (struct fwcmd_ie_cam *)buf;
+	cmd->dword0 =
+		cpu_to_le32((info->band == MAC_AX_BAND_1 ? FWCMD_H2C_IE_CAM_BAND : 0) |
+			    SET_WORD(info->port, FWCMD_H2C_IE_CAM_PORT) |
+			    (info->ctrl_type == MAC_BCN_OFLD_DIS ?
+			     0 : FWCMD_H2C_IE_CAM_CAM_EN) |
+			    (info->hit_en == MAC_AX_FUNC_DIS ?
+			     0 : FWCMD_H2C_IE_CAM_HIT_FRWD_EN) |
+			    SET_WORD(info->hit_sel, FWCMD_H2C_IE_CAM_HIT_FRWD) |
+			    (info->miss_en == MAC_AX_FUNC_DIS ?
+			     0 : FWCMD_H2C_IE_CAM_MISS_FRWD_EN) |
+			    SET_WORD(info->miss_sel, FWCMD_H2C_IE_CAM_MISS_FRWD) |
+			    SET_WORD(num, FWCMD_H2C_IE_CAM_UPD_NUM) |
+			    (rst ? FWCMD_H2C_IE_CAM_RST : 0));
+
+	if (num) {
+		iecam_len = sizeof(struct mac_ie_cam_ent) * num;
+		iecam_buf = h2cb_put(h2cb, iecam_len);
+		if (!iecam_buf)
+			return MACNOBUF;
+
+		for (i = 0; i < num; i++) {
+			*(u32 *)iecam_buf = cpu_to_le32(info->cam_list[i].hdr.cam_idx);
+			iecam_buf += 4;
+			*(u32 *)iecam_buf = cpu_to_le32(info->cam_list[i].u.data.dw0);
+			iecam_buf += 4;
+			*(u32 *)iecam_buf = cpu_to_le32(info->cam_list[i].u.data.dw1);
+			iecam_buf += 4;
+		}
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_IE_CAM,
+			      FWCMD_H2C_FUNC_IE_CAM, 0, 1);
+	if (ret) {
+		PLTFM_MSG_ERR("iecam h2c set hdr fail %d\n", ret);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("iecam h2c build txd fail %d\n", ret);
+		goto fail;
+	}
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret) {
+		PLTFM_MSG_ERR("iecam h2c tx fail %d\n", ret);
+		goto fail;
+	}
+
+fail:
+	h2cb_free(adapter, h2cb);
+
+	if (!ret)
+		h2c_end_flow(adapter);
+
+	return ret;
+}
+
+u32 mac_set_bcn_ignore_edcca(struct mac_ax_adapter *adapter,
+			     struct mac_ax_bcn_ignore_edcca *bcn_ignore_edcca)
+{
+	u32 ret = MACSUCCESS;
+	u8 *buf;
+	struct fwcmd_bcn_ignore_edcca *fwcmd_bcn_ignore_edcca_setting;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+
+	adapter->bcn_ignore_edcca = *bcn_ignore_edcca;
+	PLTFM_MSG_ALWAYS("%s: port(%d), mbssid(%d ms), band(%d), en/dis(%d)\n",
+			 __func__, bcn_ignore_edcca->port, bcn_ignore_edcca->mbssid,
+			 bcn_ignore_edcca->band, bcn_ignore_edcca->ignore_edcca_en);
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb) {
+		PLTFM_MSG_ALWAYS("%s: h2cb_alloc fail.\n", __func__);
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_bcn_ignore_edcca));
+	if (!buf) {
+		PLTFM_MSG_ALWAYS("%s: h2cb_put fail.\n", __func__);
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_bcn_ignore_edcca_setting = (struct fwcmd_bcn_ignore_edcca *)buf;
+	fwcmd_bcn_ignore_edcca_setting->dword0 =
+		cpu_to_le32(SET_WORD(bcn_ignore_edcca->port, FWCMD_H2C_BCN_IGNORE_EDCCA_PORT) |
+			SET_WORD(bcn_ignore_edcca->mbssid, FWCMD_H2C_BCN_IGNORE_EDCCA_MBSSID) |
+			SET_WORD(bcn_ignore_edcca->band, FWCMD_H2C_BCN_IGNORE_EDCCA_BAND) |
+			(bcn_ignore_edcca->ignore_edcca_en ?
+			 FWCMD_H2C_BCN_IGNORE_EDCCA_IGNORE_EDCCA_EN : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FR_EXCHG,
+			      FWCMD_H2C_FUNC_BCN_IGNORE_EDCCA,
+			      0,
+			      1);
+	if (ret) {
+		PLTFM_MSG_ALWAYS("%s: h2c_pkt_set_hdr fail.\n", __func__);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ALWAYS("%s: h2c_pkt_build_txd fail.\n", __func__);
+		goto fail;
+	}
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret) {
+		PLTFM_MSG_ALWAYS("%s: port(%d), mbssid(%d ms), band(%d), en/dis(%d) fail\n",
+				 __func__, bcn_ignore_edcca->port, bcn_ignore_edcca->mbssid,
+				 bcn_ignore_edcca->band, bcn_ignore_edcca->ignore_edcca_en);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/beacon.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/beacon.h
new file mode 100644
index 000000000000..ca8460456ae1
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/beacon.h
@@ -0,0 +1,60 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_BEACON_H_
+#define _MAC_AX_BEACON_H_
+
+#include "../type.h"
+
+/*--------------------Define -------------------------------------------*/
+#define IECAM_INFO_SIZE 8 /* dword1 & dword2 is not used */
+
+/*--------------------Define MACRO--------------------------------------*/
+/*--------------------Define Enum---------------------------------------*/
+/*--------------------Define Struct-------------------------------------*/
+/*--------------------Function Prototype--------------------------------*/
+
+/**
+ * @brief mac_calc_crc
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_calc_crc(struct mac_ax_adapter *adapter, struct mac_calc_crc_info *info);
+
+/**
+ * @brief mac_bcn_ofld_ctrl
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_bcn_ofld_ctrl(struct mac_ax_adapter *adapter, struct mac_bcn_ofld_info *info);
+
+/**
+ * @brief mac_set_bcn_ignore_edcca
+ *
+ * @param *adapter
+ * @param *bcn_ignore_edcca
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_bcn_ignore_edcca(struct mac_ax_adapter *adapter,
+			     struct mac_ax_bcn_ignore_edcca *bcn_ignore_edcca);
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cmac_tx.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cmac_tx.c
new file mode 100644
index 000000000000..6e5f39934dba
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cmac_tx.c
@@ -0,0 +1,1891 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "cmac_tx.h"
+#include "mac_priv.h"
+
+static u32 stop_macid_ctn(struct mac_ax_adapter *adapter,
+			  struct mac_role_tbl *role,
+			  struct mac_ax_sch_tx_en_cfg *bak);
+static u32 tx_idle_sel_ck_b(struct mac_ax_adapter *adapter,
+			    enum ptcl_tx_sel sel, u8 band);
+static u32 band_idle_ck(struct mac_ax_adapter *adapter, u8 band);
+static void sch_2_u16(struct mac_ax_adapter *adapter,
+		      struct mac_ax_sch_tx_en *tx_en, u16 *val16);
+static void sch_2_u32(struct mac_ax_adapter *adapter,
+		      struct mac_ax_sch_tx_en *tx_en, u32 *val32);
+static u32 h2c_usr_edca(struct mac_ax_adapter *adapter,
+			struct mac_ax_usr_edca_param *param);
+static u32 h2c_usr_tx_rpt(struct mac_ax_adapter *adapter,
+			  struct mac_ax_usr_tx_rpt_cfg *cfg);
+static u32 tx_duty_h2c(struct mac_ax_adapter *adapter,
+		       u16 pause_intvl, u16 tx_intvl);
+
+u32 set_hw_ampdu_cfg(struct mac_ax_adapter *adapter,
+		     struct mac_ax_ampdu_cfg *cfg)
+{
+	u16 max_agg_num;
+	u8 max_agg_time;
+	u8 band;
+	u32 ret;
+	u32 bk_addr, agg_addr;
+	u32 val32;
+	u8 val8;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	band = cfg->band;
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	max_agg_num = cfg->max_agg_num;
+	max_agg_time = cfg->max_agg_time_32us;
+
+	bk_addr = band ? R_AX_AGG_BK_0_C1 : R_AX_AGG_BK_0;
+	agg_addr = band ? R_AX_AMPDU_AGG_LIMIT_C1 : R_AX_AMPDU_AGG_LIMIT;
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		switch (cfg->wdbk_mode) {
+		case MAC_AX_WDBK_MODE_SINGLE_BK:
+			ret = MAC_REG_W_OFLD((u16)bk_addr, B_AX_WDBK_CFG, 0, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_WDBK_MODE_GRP_BK:
+			ret = MAC_REG_W_OFLD((u16)bk_addr, B_AX_WDBK_CFG, 1, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		default:
+			return MACNOITEM;
+		}
+
+		switch (cfg->rty_bk_mode) {
+		case MAC_AX_RTY_BK_MODE_AGG:
+			ret = MAC_REG_W_OFLD((u16)bk_addr, B_AX_EN_RTY_BK, 0, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+			ret = MAC_REG_W_OFLD((u16)bk_addr, B_AX_EN_RTY_BK_COD,
+					     0, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_RTY_BK_MODE_RATE_FB:
+			ret = MAC_REG_W_OFLD((u16)bk_addr, B_AX_EN_RTY_BK, 0, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+			ret = MAC_REG_W_OFLD((u16)bk_addr, B_AX_EN_RTY_BK_COD,
+					     1, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_RTY_BK_MODE_BK:
+			ret = MAC_REG_W_OFLD((u16)bk_addr, B_AX_EN_RTY_BK, 1, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+			ret = MAC_REG_W_OFLD((u16)bk_addr, B_AX_EN_RTY_BK_COD,
+					     1, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		default:
+			return MACNOITEM;
+		}
+
+		val32 = 0;
+		if (max_agg_num > 0 && max_agg_num <= 0x100) {
+			ret = MAC_REG_W_OFLD((u16)agg_addr,
+					     GET_MSK(B_AX_MAX_AGG_NUM),
+					     max_agg_num - 1, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+		} else {
+			return MACSETVALERR;
+		}
+		if (max_agg_time > 0 && max_agg_time <= 0xA5) {
+			ret = MAC_REG_W_OFLD((u16)agg_addr,
+					     (u32)GET_MSK(B_AX_AMPDU_MAX_TIME),
+					     max_agg_time, 1);
+			if (ret != MACSUCCESS)
+				return ret;
+		} else {
+			return MACSETVALERR;
+		}
+
+		return MACSUCCESS;
+	}
+#endif
+
+	val8 = MAC_REG_R8(bk_addr);
+	switch (cfg->wdbk_mode) {
+	case MAC_AX_WDBK_MODE_SINGLE_BK:
+		val8 &= ~B_AX_WDBK_CFG;
+		break;
+	case MAC_AX_WDBK_MODE_GRP_BK:
+		val8 |= B_AX_WDBK_CFG;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	switch (cfg->rty_bk_mode) {
+	case MAC_AX_RTY_BK_MODE_AGG:
+		val8 &= ~(B_AX_EN_RTY_BK | B_AX_EN_RTY_BK_COD);
+		break;
+	case MAC_AX_RTY_BK_MODE_RATE_FB:
+		val8 &= ~(B_AX_EN_RTY_BK);
+		val8 |= B_AX_EN_RTY_BK_COD;
+		break;
+	case MAC_AX_RTY_BK_MODE_BK:
+		val8 |= B_AX_EN_RTY_BK | B_AX_EN_RTY_BK_COD;
+		break;
+	default:
+		return MACNOITEM;
+	}
+	MAC_REG_W8(bk_addr, val8);
+
+	val32 = MAC_REG_R32(agg_addr);
+	if (max_agg_num > 0 && max_agg_num <= 0x100)
+		val32 = SET_CLR_WORD(val32, max_agg_num - 1, B_AX_MAX_AGG_NUM);
+	else
+		return MACSETVALERR;
+	if (max_agg_time > 0 && max_agg_time <= 0xA5)
+		val32 = SET_CLR_WORD(val32, max_agg_time, B_AX_AMPDU_MAX_TIME);
+	else
+		return MACSETVALERR;
+	MAC_REG_W32(agg_addr, val32);
+
+	return MACSUCCESS;
+}
+
+u32 set_hw_usr_tx_rpt_cfg(struct mac_ax_adapter *adapter,
+			  struct mac_ax_usr_tx_rpt_cfg *cfg)
+{
+	u32 ret;
+
+	ret = h2c_usr_tx_rpt(adapter, cfg);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 set_hw_usr_edca_param(struct mac_ax_adapter *adapter,
+			  struct mac_ax_usr_edca_param *param)
+{
+	u32 ret;
+
+	ret = h2c_usr_edca(adapter, param);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 set_hw_edca_param(struct mac_ax_adapter *adapter,
+		      struct mac_ax_edca_param *param)
+{
+	u32 val32;
+	u32 reg_edca;
+	u32 ret;
+	u16 val16;
+	enum mac_ax_cmac_path_sel path;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = check_mac_en(adapter, param->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = get_edca_addr(adapter, param, &reg_edca);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	path = param->path;
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		if (path == MAC_AX_CMAC_PATH_SEL_MG0_1 ||
+		    path == MAC_AX_CMAC_PATH_SEL_MG2 ||
+		    path == MAC_AX_CMAC_PATH_SEL_BCN) {
+			val16 = SET_WORD((param->ecw_max << 4) | param->ecw_min,
+					 B_AX_BE_0_CW) |
+				SET_WORD(param->aifs_us, B_AX_BE_0_AIFS);
+			ret = MAC_REG_W16_OFLD((u16)reg_edca, val16, 1);
+			if (ret != MACSUCCESS)
+				return ret;
+		} else {
+			val32 = SET_WORD(param->txop_32us, B_AX_BE_0_TXOPLMT) |
+				SET_WORD((param->ecw_max << 4) | param->ecw_min,
+					 B_AX_BE_0_CW) |
+				SET_WORD(param->aifs_us, B_AX_BE_0_AIFS);
+			ret = MAC_REG_W32_OFLD((u16)reg_edca, val32, 1);
+			if (ret != MACSUCCESS)
+				return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+
+	if (path == MAC_AX_CMAC_PATH_SEL_MG0_1 ||
+	    path == MAC_AX_CMAC_PATH_SEL_MG2 ||
+	    path == MAC_AX_CMAC_PATH_SEL_BCN) {
+		val16 = SET_WORD((param->ecw_max << 4) | param->ecw_min,
+				 B_AX_BE_0_CW) |
+			SET_WORD(param->aifs_us, B_AX_BE_0_AIFS);
+		MAC_REG_W16(reg_edca, val16);
+	} else {
+		val32 = SET_WORD(param->txop_32us, B_AX_BE_0_TXOPLMT) |
+			SET_WORD((param->ecw_max << 4) | param->ecw_min,
+				 B_AX_BE_0_CW) |
+			SET_WORD(param->aifs_us, B_AX_BE_0_AIFS);
+		MAC_REG_W32(reg_edca, val32);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 get_hw_edca_param(struct mac_ax_adapter *adapter,
+		      struct mac_ax_edca_param *param)
+{
+	u32 val32;
+	u32 reg_edca;
+	u32 ret;
+	u16 val16;
+	enum mac_ax_cmac_path_sel path;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = check_mac_en(adapter, param->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = get_edca_addr(adapter, param, &reg_edca);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	path = param->path;
+
+	if (path == MAC_AX_CMAC_PATH_SEL_MG0_1 ||
+	    path == MAC_AX_CMAC_PATH_SEL_MG2 ||
+	    path == MAC_AX_CMAC_PATH_SEL_BCN) {
+		val16 = MAC_REG_R16(reg_edca);
+		param->txop_32us = 0;
+		param->aifs_us = GET_FIELD(val16, B_AX_BE_0_AIFS);
+		param->ecw_max = (GET_FIELD(val16, B_AX_BE_0_CW) & 0xF0) >> 4;
+		param->ecw_min = GET_FIELD(val16, B_AX_BE_0_CW) & 0x0F;
+	} else {
+		val32 = MAC_REG_R32(reg_edca);
+		param->txop_32us = GET_FIELD(val32, B_AX_BE_0_TXOPLMT);
+		param->aifs_us = GET_FIELD(val32, B_AX_BE_0_AIFS);
+		param->ecw_max = (GET_FIELD(val32, B_AX_BE_0_CW) & 0xF0) >> 4;
+		param->ecw_min = GET_FIELD(val32, B_AX_BE_0_CW) & 0x0F;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 set_hw_edcca_param(struct mac_ax_adapter *adapter,
+		       struct mac_ax_edcca_param *param)
+{
+	u32 reg_cca_ctl = 0;
+	u32 ret;
+	enum mac_ax_edcca_sel sel;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = check_mac_en(adapter, param->band, MAC_AX_CMAC_SEL);
+	if (ret)
+		return ret;
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		sel = param->sel;
+		if (sel == MAC_AX_EDCCA_IN_TB_CHK) {
+			if (param->tb_check_en)
+				reg_cca_ctl |= B_AX_TB_CHK_EDCCA;
+			else
+				reg_cca_ctl &= ~B_AX_TB_CHK_EDCCA;
+		}
+		if (sel == MAC_AX_EDCCA_IN_SIFS_CHK) {
+			if (param->sifs_check_en)
+				reg_cca_ctl |= B_AX_SIFS_CHK_EDCCA;
+			else
+				reg_cca_ctl &= ~B_AX_SIFS_CHK_EDCCA;
+		}
+		if (sel == MAC_AX_EDCCA_IN_CTN_CHK) {
+			if (param->ctn_check_en)
+				reg_cca_ctl |= B_AX_CTN_CHK_EDCCA;
+			else
+				reg_cca_ctl &= ~B_AX_CTN_CHK_EDCCA;
+		} else {
+			return MACNOITEM;
+		}
+		if (param->band)
+			ret = MAC_REG_W32_OFLD((u16)R_AX_CCA_CONTROL_C1,
+					       reg_cca_ctl, 1);
+		else
+			ret = MAC_REG_W32_OFLD((u16)R_AX_CCA_CONTROL,
+					       reg_cca_ctl, 1);
+		return ret;
+	}
+#endif
+
+	if (param->band)
+		reg_cca_ctl = MAC_REG_R32(R_AX_CCA_CONTROL_C1);
+	else
+		reg_cca_ctl = MAC_REG_R32(R_AX_CCA_CONTROL);
+
+	sel = param->sel;
+	if (sel == MAC_AX_EDCCA_IN_TB_CHK) {
+		if (param->tb_check_en)
+			reg_cca_ctl |= B_AX_TB_CHK_EDCCA;
+		else
+			reg_cca_ctl &= ~B_AX_TB_CHK_EDCCA;
+	}
+	if (sel == MAC_AX_EDCCA_IN_SIFS_CHK) {
+		if (param->sifs_check_en)
+			reg_cca_ctl |= B_AX_SIFS_CHK_EDCCA;
+		else
+			reg_cca_ctl &= ~B_AX_SIFS_CHK_EDCCA;
+	}
+	if (sel == MAC_AX_EDCCA_IN_CTN_CHK) {
+		if (param->ctn_check_en)
+			reg_cca_ctl |= B_AX_CTN_CHK_EDCCA;
+		else
+			reg_cca_ctl &= ~B_AX_CTN_CHK_EDCCA;
+	} else {
+		return MACNOITEM;
+	}
+
+	if (param->band)
+		MAC_REG_W32(R_AX_CCA_CONTROL_C1, reg_cca_ctl);
+	else
+		MAC_REG_W32(R_AX_CCA_CONTROL, reg_cca_ctl);
+
+	return MACSUCCESS;
+}
+
+u32 set_hw_muedca_param(struct mac_ax_adapter *adapter,
+			struct mac_ax_muedca_param *param)
+{
+	u32 val32;
+	u32 reg_edca;
+	u32 ret;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = check_mac_en(adapter, param->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = get_muedca_param_addr(adapter, param, &reg_edca);
+	if (ret != MACSUCCESS)
+		return ret;
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		val32 = SET_WORD(param->muedca_timer_32us,
+				 B_AX_MUEDCA_BE_PARAM_0_TIMER) |
+			SET_WORD((param->ecw_max << 4) | param->ecw_min,
+				 B_AX_MUEDCA_BE_PARAM_0_CW) |
+			SET_WORD(param->aifs_us, B_AX_MUEDCA_BE_PARAM_0_AIFS);
+		ret = MAC_REG_W32_OFLD((u16)reg_edca, val32, 1);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		return MACSUCCESS;
+	}
+#endif
+
+	val32 = SET_WORD(param->muedca_timer_32us,
+			 B_AX_MUEDCA_BE_PARAM_0_TIMER) |
+		SET_WORD((param->ecw_max << 4) | param->ecw_min,
+			 B_AX_MUEDCA_BE_PARAM_0_CW) |
+		SET_WORD(param->aifs_us, B_AX_MUEDCA_BE_PARAM_0_AIFS);
+	MAC_REG_W32(reg_edca, val32);
+
+	return MACSUCCESS;
+}
+
+u32 set_hw_muedca_ctrl(struct mac_ax_adapter *adapter,
+		       struct mac_ax_muedca_cfg *cfg)
+{
+	u32 ret;
+	u8 band;
+	u16 val16;
+	u32 reg_en;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	band = cfg->band;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	reg_en = band ? R_AX_MUEDCA_EN_C1 : R_AX_MUEDCA_EN;
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		val16 = 0;
+		if (cfg->wmm_sel == MAC_AX_CMAC_WMM1_SEL) {
+			ret = MAC_REG_W_OFLD((u16)reg_en, B_AX_MUEDCA_WMM_SEL,
+					     1, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+		} else {
+			ret = MAC_REG_W_OFLD((u16)reg_en, B_AX_MUEDCA_WMM_SEL,
+					     0, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+		}
+
+		ret = MAC_REG_W_OFLD((u16)reg_en, B_AX_MUEDCA_EN_0,
+				     cfg->countdown_en, 0);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		ret = MAC_REG_W_OFLD((u16)reg_en, B_AX_SET_MUEDCATIMER_TF_0,
+				     cfg->tb_update_en, 1);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		return MACSUCCESS;
+	}
+#endif
+
+	val16 = MAC_REG_R16(reg_en);
+
+	if (cfg->wmm_sel == MAC_AX_CMAC_WMM1_SEL)
+		val16 |= B_AX_MUEDCA_WMM_SEL;
+	else
+		val16 &= ~B_AX_MUEDCA_WMM_SEL;
+
+	if (cfg->countdown_en)
+		val16 |= B_AX_MUEDCA_EN_0;
+	else
+		val16 &= ~B_AX_MUEDCA_EN_0;
+
+	if (cfg->tb_update_en)
+		val16 |= B_AX_SET_MUEDCATIMER_TF_0;
+	else
+		val16 &= ~B_AX_SET_MUEDCATIMER_TF_0;
+
+	MAC_REG_W16(reg_en, val16);
+
+	return MACSUCCESS;
+}
+
+u32 set_hw_tb_ppdu_ctrl(struct mac_ax_adapter *adapter,
+			struct mac_ax_tb_ppdu_ctrl *ctrl)
+{
+	u16 val16;
+	u8 pri_ac;
+	u32 ret;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = check_mac_en(adapter, ctrl->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	switch (ctrl->pri_ac) {
+	case MAC_AX_CMAC_AC_SEL_BE:
+		pri_ac = 0;
+		break;
+	case MAC_AX_CMAC_AC_SEL_BK:
+		pri_ac = 1;
+		break;
+	case MAC_AX_CMAC_AC_SEL_VI:
+		pri_ac = 2;
+		break;
+	case MAC_AX_CMAC_AC_SEL_VO:
+		pri_ac = 3;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	val16 = MAC_REG_R16(ctrl->band ? R_AX_TB_PPDU_CTRL_C1 :
+			    R_AX_TB_PPDU_CTRL);
+	val16 &= ~(B_AX_TB_PPDU_BE_DIS | B_AX_TB_PPDU_BK_DIS |
+		   B_AX_TB_PPDU_VI_DIS | B_AX_TB_PPDU_VO_DIS);
+	val16 |= (ctrl->be_dis ? B_AX_TB_PPDU_BE_DIS : 0) |
+		 (ctrl->bk_dis ? B_AX_TB_PPDU_BK_DIS : 0) |
+		 (ctrl->vi_dis ? B_AX_TB_PPDU_VI_DIS : 0) |
+		 (ctrl->vo_dis ? B_AX_TB_PPDU_VO_DIS : 0);
+	val16 = SET_CLR_WORD(val16, pri_ac, B_AX_SW_PREFER_AC);
+	MAC_REG_W16(ctrl->band ? R_AX_TB_PPDU_CTRL_C1 : R_AX_TB_PPDU_CTRL,
+		    val16);
+
+	return MACSUCCESS;
+}
+
+u32 get_hw_tb_ppdu_ctrl(struct mac_ax_adapter *adapter,
+			struct mac_ax_tb_ppdu_ctrl *ctrl)
+{
+	u16 val16;
+	u8 pri_ac;
+	u32 ret;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = check_mac_en(adapter, ctrl->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	val16 = MAC_REG_R16(ctrl->band ? R_AX_TB_PPDU_CTRL_C1 :
+			    R_AX_TB_PPDU_CTRL);
+	ctrl->be_dis = (val16 & B_AX_TB_PPDU_BE_DIS) ? 1 : 0;
+	ctrl->bk_dis = (val16 & B_AX_TB_PPDU_BK_DIS) ? 1 : 0;
+	ctrl->vi_dis = (val16 & B_AX_TB_PPDU_VI_DIS) ? 1 : 0;
+	ctrl->vo_dis = (val16 & B_AX_TB_PPDU_VO_DIS) ? 1 : 0;
+	pri_ac = GET_FIELD(val16, B_AX_SW_PREFER_AC);
+
+	switch (pri_ac) {
+	case 0:
+		ctrl->pri_ac = MAC_AX_CMAC_AC_SEL_BE;
+		break;
+	case 1:
+		ctrl->pri_ac = MAC_AX_CMAC_AC_SEL_BK;
+		break;
+	case 2:
+		ctrl->pri_ac = MAC_AX_CMAC_AC_SEL_VI;
+		break;
+	case 3:
+		ctrl->pri_ac = MAC_AX_CMAC_AC_SEL_VO;
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 set_hw_sch_tx_en(struct mac_ax_adapter *adapter,
+		     struct mac_ax_sch_tx_en_cfg *cfg)
+{
+	u16 val16;
+	u8 band;
+	u32 ret;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u16 tx_en_u16;
+	u16 mask_u16;
+	u32 tx_en_u32, mask_u32, val32;
+	struct mac_ax_sch_tx_en tx_en;
+	struct mac_ax_sch_tx_en tx_en_mask;
+	u8 chip_id = adapter->hw_info->chip_id;
+
+	band = cfg->band;
+	tx_en = cfg->tx_en;
+	tx_en_mask = cfg->tx_en_mask;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	sch_2_u16(adapter, &tx_en, &tx_en_u16);
+	sch_2_u16(adapter, &tx_en_mask, &mask_u16);
+
+	if (chip_id == MAC_AX_CHIP_ID_8852A ||
+	    chip_id == MAC_AX_CHIP_ID_8852B ||
+	    chip_id == MAC_AX_CHIP_ID_8851B) {
+		if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+			val16 = MAC_REG_R16(band ? R_AX_CTN_TXEN_C1 :
+					    R_AX_CTN_TXEN);
+
+			val16 = (tx_en_u16 & mask_u16) |
+				(~(~tx_en_u16 & mask_u16) & val16);
+
+			MAC_REG_W16(band ? R_AX_CTN_TXEN_C1 : R_AX_CTN_TXEN,
+				    val16);
+		} else {
+			hw_sch_tx_en(adapter, band, tx_en_u16, mask_u16);
+		}
+	} else if (chip_id == MAC_AX_CHIP_ID_8852C ||
+		   chip_id == MAC_AX_CHIP_ID_8192XB ||
+		   chip_id == MAC_AX_CHIP_ID_8851E ||
+		   chip_id == MAC_AX_CHIP_ID_8852D) {
+		sch_2_u32(adapter, &tx_en, &tx_en_u32);
+		sch_2_u32(adapter, &tx_en_mask, &mask_u32);
+
+		val32 = MAC_REG_R32(band ? R_AX_CTN_DRV_TXEN_C1 :
+				    R_AX_CTN_DRV_TXEN);
+
+		val32 = (tx_en_u32 & mask_u32) |
+			(~(~tx_en_u32 & mask_u32) & val32);
+
+		MAC_REG_W32(band ? R_AX_CTN_DRV_TXEN_C1 :
+			    R_AX_CTN_DRV_TXEN, val32);
+	} else {
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 hw_sch_tx_en_h2c_pkt(struct mac_ax_adapter *adapter, u8 band,
+			 u16 tx_en_u16, u16 mask_u16)
+{
+	u32 ret = MACSUCCESS;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	struct fwcmd_sch_tx_en_pkt *write_ptr;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_ERR("[ERR]%s fw not ready\n", __func__);
+		return MACNOFW;
+	}
+
+	if (adapter->sm.sch_tx_en_ofld != MAC_AX_OFLD_H2C_IDLE) {
+		PLTFM_MSG_ERR("[ERR]SchTxEn PKT state machine not MAC_AX_OFLD_H2C_IDLE\n");
+		return MACPROCERR;
+	}
+
+	adapter->sm.sch_tx_en_ofld = MAC_AX_OFLD_H2C_SENDING;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_sch_tx_en_pkt));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto end;
+	}
+	write_ptr = (struct fwcmd_sch_tx_en_pkt *)buf;
+	write_ptr->dword0 =
+		cpu_to_le32(SET_WORD(tx_en_u16, FWCMD_H2C_H2CPKT_SCH_TX_PAUSE_TX_EN));
+	write_ptr->dword1 =
+		cpu_to_le32(SET_WORD(mask_u16, FWCMD_H2C_H2CPKT_SCH_TX_PAUSE_MASK) |
+			    (band ? FWCMD_H2C_H2CPKT_SCH_TX_PAUSE_BAND : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_SCH_TX_EN_PKT,
+			      0, 1);
+	if (ret)
+		goto end;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto end;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx\n");
+		goto end;
+	}
+end:
+	h2cb_free(adapter, h2cb);
+	return ret;
+}
+
+u32 hw_sch_tx_en(struct mac_ax_adapter *adapter, u8 band,
+		 u16 tx_en_u16, u16 mask_u16)
+{
+#define RETRY_WAIT_US 1
+#define RETRY_WAIT_PKT_US 50
+	u32 ret, cnt;
+	struct mac_ax_h2creg_info h2c = {0};
+	struct mac_ax_c2hreg_poll c2h = {0};
+
+	if (adapter->drv_stats.rx_ok) {
+		ret = hw_sch_tx_en_h2c_pkt(adapter, band, tx_en_u16, mask_u16);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]SchTxEn PKT %d\n", ret);
+			return ret;
+		}
+		/* Wait for C2H */
+		cnt = TX_PAUSE_WAIT_PKT_CNT;
+
+		while (--cnt) {
+			if (adapter->sm.sch_tx_en_ofld == MAC_AX_OFLD_H2C_DONE)
+				break;
+			PLTFM_SLEEP_US(RETRY_WAIT_PKT_US);
+		}
+		adapter->sm.sch_tx_en_ofld = MAC_AX_OFLD_H2C_IDLE;
+		if (!cnt) {
+			PLTFM_MSG_ERR("[ERR]SchTxEn DONE ACK timeout\n");
+			return MACPROCERR;
+		}
+		return MACSUCCESS;
+	}
+
+	h2c.id = FWCMD_H2CREG_FUNC_SCH_TX_EN;
+	h2c.content_len = sizeof(struct sch_tx_en_h2creg);
+
+	h2c.h2c_content.dword0 =
+		SET_WORD(tx_en_u16, FWCMD_H2C_H2CREG_SCH_TX_PAUSE_TX_EN);
+	h2c.h2c_content.dword1 =
+		SET_WORD(mask_u16, FWCMD_H2C_H2CREG_SCH_TX_PAUSE_MASK) |
+		    (band ? FWCMD_H2C_H2CREG_SCH_TX_PAUSE_BAND : 0);
+
+	c2h.polling_id = FWCMD_C2HREG_FUNC_TX_PAUSE_RPT;
+	c2h.retry_cnt = TX_PAUSE_WAIT_CNT;
+	c2h.retry_wait_us = RETRY_WAIT_US;
+
+	ret = proc_msg_reg(adapter, &h2c, &c2h);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]hw sch tx_en proc msg reg %d\n", ret);
+		return ret;
+	}
+	return MACSUCCESS;
+}
+
+u32 get_hw_sch_tx_en(struct mac_ax_adapter *adapter,
+		     struct mac_ax_sch_tx_en_cfg *cfg)
+{
+	u8 band;
+	u32 ret, val32;
+	u16 val16;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_sch_tx_en tx_en;
+	u8 chip_id = adapter->hw_info->chip_id;
+
+	band = cfg->band;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (chip_id == MAC_AX_CHIP_ID_8852A ||
+	    chip_id == MAC_AX_CHIP_ID_8852B ||
+	    chip_id == MAC_AX_CHIP_ID_8851B) {
+		val16 = MAC_REG_R16(band ? R_AX_CTN_TXEN_C1 : R_AX_CTN_TXEN);
+		u16_2_sch(adapter, &tx_en, val16);
+		cfg->tx_en = tx_en;
+	} else if (chip_id == MAC_AX_CHIP_ID_8852C ||
+		   chip_id == MAC_AX_CHIP_ID_8192XB ||
+		   chip_id == MAC_AX_CHIP_ID_8851E ||
+		   chip_id == MAC_AX_CHIP_ID_8852D) {
+		val32 = MAC_REG_R32(band ? R_AX_CTN_DRV_TXEN_C1 :
+				    R_AX_CTN_DRV_TXEN);
+		u32_2_sch(adapter, &tx_en, val32);
+		cfg->tx_en = tx_en;
+	} else {
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 set_hw_lifetime_cfg(struct mac_ax_adapter *adapter,
+			struct mac_ax_lifetime_cfg *cfg)
+{
+	u32 ret;
+	u8 band;
+	u8 val8;
+	u32 val32;
+	u32 reg_time_0, reg_time_1, reg_time_2, reg_en;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	band = cfg->band;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	reg_time_0 = band ? R_AX_LIFETIME_0_C1 : R_AX_LIFETIME_0;
+	reg_time_1 = band ? R_AX_LIFETIME_1_C1 : R_AX_LIFETIME_1;
+	reg_time_2 = band ? R_AX_LIFETIME_2_C1 : R_AX_LIFETIME_2;
+	reg_en = band ? R_AX_PTCL_COMMON_SETTING_0_C1 :
+		 R_AX_PTCL_COMMON_SETTING_0;
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		if (cfg->en.acq_en || cfg->en.mgq_en) {
+			ret = MAC_REG_W_OFLD(R_AX_TX_PASTE_TIMESTAMP_SETTING,
+					     B_AX_HDT_TIMESTAMP_EN, 1, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+		}
+		val32 = SET_WORD(cfg->val.acq_val_1, B_AX_PKT_LIFETIME_1) |
+			SET_WORD(cfg->val.acq_val_2, B_AX_PKT_LIFETIME_2);
+		ret = MAC_REG_W32_OFLD((u16)reg_time_0, val32, 0);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		val32 = SET_WORD(cfg->val.acq_val_3, B_AX_PKT_LIFETIME_3) |
+			SET_WORD(cfg->val.acq_val_4, B_AX_PKT_LIFETIME_4);
+		ret = MAC_REG_W32_OFLD((u16)reg_time_1, val32, 0);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		ret = MAC_REG_W16_OFLD((u16)reg_time_2, cfg->val.mgq_val, 0);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		ret = MAC_REG_W_OFLD((u16)reg_en, B_AX_LIFETIME_EN,
+				     cfg->en.acq_en, 0);
+		if (ret != MACSUCCESS)
+			return ret;
+		ret = MAC_REG_W_OFLD((u16)reg_en, B_AX_MGQ_LIFETIME_EN,
+				     cfg->en.mgq_en, 1);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		return MACSUCCESS;
+	}
+#endif
+
+	if (cfg->en.acq_en || cfg->en.mgq_en)
+		MAC_REG_W8(R_AX_TX_PASTE_TIMESTAMP_SETTING,
+			   MAC_REG_R8(R_AX_TX_PASTE_TIMESTAMP_SETTING) |
+			   B_AX_HDT_TIMESTAMP_EN);
+
+	val32 = SET_WORD(cfg->val.acq_val_1, B_AX_PKT_LIFETIME_1) |
+		SET_WORD(cfg->val.acq_val_2, B_AX_PKT_LIFETIME_2);
+	MAC_REG_W32(reg_time_0, val32);
+
+	val32 = SET_WORD(cfg->val.acq_val_3, B_AX_PKT_LIFETIME_3) |
+		SET_WORD(cfg->val.acq_val_4, B_AX_PKT_LIFETIME_4);
+	MAC_REG_W32(reg_time_1, val32);
+
+	MAC_REG_W16(reg_time_2, cfg->val.mgq_val);
+
+	val8 = MAC_REG_R8(reg_en);
+	val8 &=	~(B_AX_LIFETIME_EN | B_AX_MGQ_LIFETIME_EN);
+	val8 |= (cfg->en.acq_en ? B_AX_LIFETIME_EN : 0) |
+		(cfg->en.mgq_en ? B_AX_MGQ_LIFETIME_EN : 0);
+	MAC_REG_W8(reg_en, val8);
+
+	return MACSUCCESS;
+}
+
+u32 get_hw_lifetime_cfg(struct mac_ax_adapter *adapter,
+			struct mac_ax_lifetime_cfg *cfg)
+{
+	u32 ret;
+	u8 band;
+	u8 val8;
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	band = cfg->band;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	val8 = MAC_REG_R8(band ? R_AX_PTCL_COMMON_SETTING_0_C1 :
+			  R_AX_PTCL_COMMON_SETTING_0);
+	cfg->en.acq_en = (val8 & B_AX_LIFETIME_EN) ? 1 : 0;
+	cfg->en.mgq_en = (val8 & B_AX_MGQ_LIFETIME_EN) ? 1 : 0;
+
+	val32 = MAC_REG_R32(band ? R_AX_LIFETIME_0_C1 : R_AX_LIFETIME_0);
+	cfg->val.acq_val_1 = GET_FIELD(val32, B_AX_PKT_LIFETIME_1);
+	cfg->val.acq_val_2 = GET_FIELD(val32, B_AX_PKT_LIFETIME_2);
+
+	val32 = MAC_REG_R32(band ? R_AX_LIFETIME_1_C1 : R_AX_LIFETIME_1);
+	cfg->val.acq_val_3 = GET_FIELD(val32, B_AX_PKT_LIFETIME_3);
+	cfg->val.acq_val_4 = GET_FIELD(val32, B_AX_PKT_LIFETIME_4);
+
+	cfg->val.mgq_val = MAC_REG_R16(band ? R_AX_LIFETIME_2_C1 :
+				       R_AX_LIFETIME_2);
+
+	return MACSUCCESS;
+}
+
+/* this function is only for WFA Tx TB PPDU SIFS timing workaround*/
+u32 set_hw_sifs_r2t_t2t(struct mac_ax_adapter *adapter,
+			struct mac_ax_sifs_r2t_t2t_ctrl *ctrl)
+{
+	u32 reg, val32, ret, mactxen;
+	u8 band;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	band = ctrl->band;
+	mactxen = ctrl->mactxen;
+
+	PLTFM_MSG_ERR("[WARN] %s is only for ", __func__);
+	PLTFM_MSG_ERR("WFA Tx TB PPDU SIFS timing workaround\n");
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (mactxen > MACTXEN_MAX || mactxen < MACTXEN_MIN) {
+		PLTFM_MSG_ALWAYS("[ERR] sifs_r2t_t2t mactxen violation %d ",
+				 mactxen);
+		PLTFM_MSG_ALWAYS("must be %d ~ %d\n", MACTXEN_MIN, MACTXEN_MAX);
+		return MACFUNCINPUT;
+	}
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_PREBKF_CFG_1_C1 : R_AX_PREBKF_CFG_1;
+	val32 = MAC_REG_R32(reg);
+	val32 = SET_CLR_WORD(val32, ctrl->mactxen, B_AX_SIFS_MACTXEN_T1);
+	MAC_REG_W32(reg, val32);
+
+	return MACSUCCESS;
+}
+
+u32 resume_sch_tx(struct mac_ax_adapter *adapter,
+		  struct mac_ax_sch_tx_en_cfg *bak)
+{
+	u32 ret;
+
+	u16_2_sch(adapter, &bak->tx_en_mask, 0xFFFF);
+	ret = set_hw_sch_tx_en(adapter, bak);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 stop_macid_tx(struct mac_ax_adapter *adapter, struct mac_role_tbl *role,
+		  enum tb_stop_sel stop_sel, struct macid_tx_bak *bak)
+{
+	u8 band;
+	u32 ret;
+	struct mac_ax_macid_pause_cfg pause;
+
+	band = role->info.band;
+
+	if (role->info.a_info.tf_trs) {
+		bak->ac_dis_bak.band = band;
+		ret = stop_ac_tb_tx(adapter, stop_sel, &bak->ac_dis_bak);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+
+	pause.macid = role->macid;
+	pause.pause = 1;
+	ret = set_macid_pause(adapter, &pause);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	bak->sch_bak.band = band;
+	ret = stop_macid_ctn(adapter, role, &bak->sch_bak);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 resume_macid_tx(struct mac_ax_adapter *adapter, struct mac_role_tbl *role,
+		    struct macid_tx_bak *bak)
+{
+	u32 ret;
+	struct mac_ax_macid_pause_cfg pause_cfg;
+
+	if (role->info.band == MAC_AX_BAND_0) {
+		u16_2_sch(adapter, &bak->sch_bak.tx_en_mask, 0xFFFF);
+		ret = set_hw_sch_tx_en(adapter, &bak->sch_bak);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+
+	if (role->info.a_info.tf_trs) {
+		ret = set_hw_tb_ppdu_ctrl(adapter, &bak->ac_dis_bak);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+
+	pause_cfg.macid = role->macid;
+	pause_cfg.pause = 0;
+	ret = set_macid_pause(adapter, &pause_cfg);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 tx_idle_poll_macid(struct mac_ax_adapter *adapter,
+		       struct mac_role_tbl *role)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	return p_ops->macid_idle_ck(adapter, role);
+}
+
+u32 tx_idle_poll_band(struct mac_ax_adapter *adapter, u8 band)
+{
+	return band_idle_ck(adapter, band);
+}
+
+u32 tx_idle_poll_sel(struct mac_ax_adapter *adapter, enum ptcl_tx_sel sel,
+		     u8 band)
+{
+	return tx_idle_sel_ck_b(adapter, sel, band);
+}
+
+u32 stop_ac_tb_tx(struct mac_ax_adapter *adapter, enum tb_stop_sel stop_sel,
+		  struct mac_ax_tb_ppdu_ctrl *ac_dis_bak)
+{
+	u32 ret;
+	struct mac_ax_tb_ppdu_ctrl ctrl;
+
+	ret = get_hw_tb_ppdu_ctrl(adapter, ac_dis_bak);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ctrl.band = ac_dis_bak->band;
+	ctrl.pri_ac = ac_dis_bak->pri_ac;
+	ctrl.be_dis = 0;
+	ctrl.bk_dis = 0;
+	ctrl.vi_dis = 0;
+	ctrl.vo_dis = 0;
+
+	switch (stop_sel) {
+	case TB_STOP_SEL_ALL:
+		ctrl.be_dis = 1;
+		ctrl.bk_dis = 1;
+		ctrl.vi_dis = 1;
+		ctrl.vo_dis = 1;
+		ret = set_hw_tb_ppdu_ctrl(adapter, &ctrl);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case TB_STOP_SEL_BE:
+		ctrl.be_dis = 1;
+		ret = set_hw_tb_ppdu_ctrl(adapter, &ctrl);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case TB_STOP_SEL_BK:
+		ctrl.bk_dis = 1;
+		ret = set_hw_tb_ppdu_ctrl(adapter, &ctrl);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case TB_STOP_SEL_VI:
+		ctrl.vi_dis = 1;
+		ret = set_hw_tb_ppdu_ctrl(adapter, &ctrl);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case TB_STOP_SEL_VO:
+		ctrl.vo_dis = 1;
+		ret = set_hw_tb_ppdu_ctrl(adapter, &ctrl);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 get_edca_addr(struct mac_ax_adapter *adapter,
+		  struct mac_ax_edca_param *param, u32 *reg_edca)
+{
+	u8 band;
+	u32 ret;
+	enum mac_ax_cmac_path_sel path;
+
+	band = param->band;
+	path = param->path;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	switch (path) {
+	case MAC_AX_CMAC_PATH_SEL_BE0:
+		*reg_edca =
+			band ? R_AX_EDCA_BE_PARAM_0_C1 : R_AX_EDCA_BE_PARAM_0;
+		break;
+	case MAC_AX_CMAC_PATH_SEL_BK0:
+		*reg_edca =
+			band ? R_AX_EDCA_BK_PARAM_0_C1 : R_AX_EDCA_BK_PARAM_0;
+		break;
+	case MAC_AX_CMAC_PATH_SEL_VI0:
+		*reg_edca =
+			band ? R_AX_EDCA_VI_PARAM_0_C1 : R_AX_EDCA_VI_PARAM_0;
+		break;
+	case MAC_AX_CMAC_PATH_SEL_VO0:
+		*reg_edca =
+			band ? R_AX_EDCA_VO_PARAM_0_C1 : R_AX_EDCA_VO_PARAM_0;
+		break;
+	case MAC_AX_CMAC_PATH_SEL_BE1:
+		*reg_edca =
+			band ? R_AX_EDCA_BE_PARAM_1_C1 : R_AX_EDCA_BE_PARAM_1;
+		break;
+	case MAC_AX_CMAC_PATH_SEL_BK1:
+		*reg_edca =
+			band ? R_AX_EDCA_BK_PARAM_1_C1 : R_AX_EDCA_BK_PARAM_1;
+		break;
+	case MAC_AX_CMAC_PATH_SEL_VI1:
+		*reg_edca =
+			band ? R_AX_EDCA_VI_PARAM_1_C1 : R_AX_EDCA_VI_PARAM_1;
+		break;
+	case MAC_AX_CMAC_PATH_SEL_VO1:
+		*reg_edca =
+			band ? R_AX_EDCA_VO_PARAM_1_C1 : R_AX_EDCA_VO_PARAM_1;
+		break;
+	case MAC_AX_CMAC_PATH_SEL_MG0_1:
+		*reg_edca =
+			band ? R_AX_EDCA_MGQ_PARAM_C1 : R_AX_EDCA_MGQ_PARAM;
+		break;
+	case MAC_AX_CMAC_PATH_SEL_MG2:
+		*reg_edca =
+			band ? (R_AX_EDCA_MGQ_PARAM_C1 + 2) :
+			(R_AX_EDCA_MGQ_PARAM + 2);
+		break;
+	case MAC_AX_CMAC_PATH_SEL_BCN:
+		*reg_edca =
+			band ? (R_AX_EDCA_BCNQ_PARAM_C1 + 2) :
+			(R_AX_EDCA_BCNQ_PARAM + 2);
+		break;
+	case MAC_AX_CMAC_PATH_SEL_TF:
+		*reg_edca = R_AX_EDCA_ULQ_PARAM;
+		break;
+	case MAC_AX_CMAC_PATH_SEL_TWT0:
+	case MAC_AX_CMAC_PATH_SEL_TWT2:
+		*reg_edca = R_AX_EDCA_TWT_PARAM_0;
+		break;
+	case MAC_AX_CMAC_PATH_SEL_TWT1:
+	case MAC_AX_CMAC_PATH_SEL_TWT3:
+		*reg_edca = R_AX_EDCA_TWT_PARAM_1;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 get_muedca_param_addr(struct mac_ax_adapter *adapter,
+			  struct mac_ax_muedca_param *param,
+			  u32 *reg_edca)
+{
+	u8 band;
+	u32 ret;
+	enum mac_ax_cmac_ac_sel ac;
+
+	band = param->band;
+	ac = param->ac;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	switch (ac) {
+	case MAC_AX_CMAC_AC_SEL_BE:
+		*reg_edca =
+			band ? R_AX_MUEDCA_BE_PARAM_0_C1 :
+			R_AX_MUEDCA_BE_PARAM_0;
+		break;
+	case MAC_AX_CMAC_AC_SEL_BK:
+		*reg_edca =
+			band ? R_AX_MUEDCA_BK_PARAM_0_C1 :
+			R_AX_MUEDCA_BK_PARAM_0;
+		break;
+	case MAC_AX_CMAC_AC_SEL_VI:
+		*reg_edca =
+			band ? R_AX_MUEDCA_VI_PARAM_0_C1 :
+			R_AX_MUEDCA_VI_PARAM_0;
+		break;
+	case MAC_AX_CMAC_AC_SEL_VO:
+		*reg_edca =
+			band ? R_AX_MUEDCA_VO_PARAM_0_C1 :
+			R_AX_MUEDCA_VO_PARAM_0;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+void tx_on_dly(struct mac_ax_adapter *adapter, u8 band)
+{
+	u32 val32;
+	u32 drop_dly_max;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(band ? R_AX_TX_CTRL_C1 : R_AX_TX_CTRL);
+	drop_dly_max = GET_FIELD(val32, B_AX_DROP_CHK_MAX_NUM) >> 2;
+	PLTFM_DELAY_US((drop_dly_max > TX_DLY_MAX) ? drop_dly_max : TX_DLY_MAX);
+}
+
+/* for sw mode Tx, need to stop sch */
+/* (for "F2PCMD.disable_sleep_chk"), soar 20200225*/
+static u32 stop_macid_ctn(struct mac_ax_adapter *adapter,
+			  struct mac_role_tbl *role,
+			  struct mac_ax_sch_tx_en_cfg *bak)
+{
+	struct mac_ax_sch_tx_en_cfg cfg;
+	u32 ret;
+
+	ret = check_mac_en(adapter, role->info.band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = get_hw_sch_tx_en(adapter, bak);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	cfg.band = role->info.band;
+	u16_2_sch(adapter, &cfg.tx_en_mask, 0);
+
+	u16_2_sch(adapter, &cfg.tx_en, 0);
+	u16_2_sch(adapter, &cfg.tx_en_mask, 0xFFFF);
+	cfg.tx_en_mask.mg0 = 0;
+	cfg.tx_en_mask.mg1 = 0;
+	cfg.tx_en_mask.mg2 = 0;
+	cfg.tx_en_mask.hi = 0;
+	cfg.tx_en_mask.bcn = 0;
+
+	ret = set_hw_sch_tx_en(adapter, &cfg);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+static u32 tx_idle_sel_ck_b(struct mac_ax_adapter *adapter,
+			    enum ptcl_tx_sel sel, u8 band)
+{
+	u32 cnt;
+	u8 val8;
+	u32 ret;
+	u8 ptcl_tx_qid;
+	u32 poll_addr;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	poll_addr = band ? R_AX_PTCL_TX_CTN_SEL_C1 : R_AX_PTCL_TX_CTN_SEL;
+
+	val8 = MAC_REG_R8(poll_addr);
+	if (val8 & B_AX_PTCL_TX_ON_STAT)
+		tx_on_dly(adapter, band);
+	else
+		return MACSUCCESS;
+
+	switch (sel) {
+	case PTCL_TX_SEL_HIQ:
+		ptcl_tx_qid = PTCL_TXQ_HIQ;
+		break;
+	case PTCL_TX_SEL_MG0:
+		ptcl_tx_qid = PTCL_TXQ_MG0;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	cnt = PTCL_IDLE_POLL_CNT;
+	while (--cnt) {
+		val8 = MAC_REG_R8(poll_addr);
+		if ((val8 & B_AX_PTCL_TX_ON_STAT) && (val8 & B_AX_PTCL_DROP))
+			PLTFM_DELAY_US(SW_CVR_DUR_US);
+		else if ((val8 & B_AX_PTCL_TX_ON_STAT) &&
+			 (GET_FIELD(val8, B_AX_PTCL_TX_QUEUE_IDX) ==
+			 ptcl_tx_qid))
+			PLTFM_DELAY_US(SW_CVR_DUR_US);
+		else
+			break;
+	}
+	PLTFM_MSG_ALWAYS("%s: cnt %d, band %d, 0x%x\n", __func__, cnt, band, val8);
+	if (!cnt)
+		return MACPOLLTXIDLE;
+
+	return MACSUCCESS;
+}
+
+static u32 band_idle_ck(struct mac_ax_adapter *adapter, u8 band)
+{
+	u32 cnt;
+	u8 val8;
+	u32 ret;
+	u32 poll_addr;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	poll_addr = band ? R_AX_PTCL_TX_CTN_SEL_C1 : R_AX_PTCL_TX_CTN_SEL;
+
+	cnt = PTCL_IDLE_POLL_CNT;
+	while (--cnt) {
+		val8 = MAC_REG_R8(poll_addr);
+		if (val8 & B_AX_PTCL_TX_ON_STAT)
+			PLTFM_DELAY_US(SW_CVR_DUR_US);
+		else
+			break;
+	}
+	PLTFM_MSG_ALWAYS("%s: cnt %d, band %d, 0x%x\n", __func__, cnt, band, val8);
+	if (!cnt)
+		return MACPOLLTXIDLE;
+
+	return MACSUCCESS;
+}
+
+static void sch_2_u16(struct mac_ax_adapter *adapter,
+		      struct mac_ax_sch_tx_en *tx_en, u16 *val16)
+{
+	*val16 = (tx_en->be0 ? B_AX_CTN_TXEN_BE_0 : 0) |
+		(tx_en->bk0 ? B_AX_CTN_TXEN_BK_0 : 0) |
+		(tx_en->vi0 ? B_AX_CTN_TXEN_VI_0 : 0) |
+		(tx_en->vo0 ? B_AX_CTN_TXEN_VO_0 : 0) |
+		(tx_en->be1 ? B_AX_CTN_TXEN_BE_1 : 0) |
+		(tx_en->bk1 ? B_AX_CTN_TXEN_BK_1 : 0) |
+		(tx_en->vi1 ? B_AX_CTN_TXEN_VI_1 : 0) |
+		(tx_en->vo1 ? B_AX_CTN_TXEN_VO_1 : 0) |
+		(tx_en->mg0 ? B_AX_CTN_TXEN_MGQ : 0) |
+		(tx_en->mg1 ? B_AX_CTN_TXEN_MGQ1 : 0) |
+		(tx_en->mg2 ? B_AX_CTN_TXEN_CPUMGQ : 0) |
+		(tx_en->hi ? B_AX_CTN_TXEN_HGQ : 0) |
+		(tx_en->bcn ? B_AX_CTN_TXEN_BCNQ : 0) |
+		(tx_en->ul ? B_AX_CTN_TXEN_ULQ : 0) |
+		(tx_en->twt0 ? B_AX_CTN_TXEN_TWT_0 : 0) |
+		(tx_en->twt1 ? B_AX_CTN_TXEN_TWT_1 : 0);
+}
+
+static void sch_2_u32(struct mac_ax_adapter *adapter,
+		      struct mac_ax_sch_tx_en *tx_en, u32 *val32)
+{
+	*val32 = (tx_en->be0 ? B_AX_CTN_TXEN_BE_0 : 0) |
+		(tx_en->bk0 ? B_AX_CTN_TXEN_BK_0 : 0) |
+		(tx_en->vi0 ? B_AX_CTN_TXEN_VI_0 : 0) |
+		(tx_en->vo0 ? B_AX_CTN_TXEN_VO_0 : 0) |
+		(tx_en->be1 ? B_AX_CTN_TXEN_BE_1 : 0) |
+		(tx_en->bk1 ? B_AX_CTN_TXEN_BK_1 : 0) |
+		(tx_en->vi1 ? B_AX_CTN_TXEN_VI_1 : 0) |
+		(tx_en->vo1 ? B_AX_CTN_TXEN_VO_1 : 0) |
+		(tx_en->mg0 ? B_AX_CTN_TXEN_MGQ : 0) |
+		(tx_en->mg1 ? B_AX_CTN_TXEN_MGQ1 : 0) |
+		(tx_en->mg2 ? B_AX_CTN_TXEN_CPUMGQ : 0) |
+		(tx_en->hi ? B_AX_CTN_TXEN_HGQ : 0) |
+		(tx_en->bcn ? B_AX_CTN_TXEN_BCNQ : 0) |
+		(tx_en->ul ? B_AX_CTN_TXEN_ULQ : 0) |
+		(tx_en->twt0 ? B_AX_CTN_TXEN_TWT_0 : 0) |
+		(tx_en->twt1 ? B_AX_CTN_TXEN_TWT_1 : 0) |
+		(tx_en->twt2 ? B_AX_CTN_TXEN_TWT_2 : 0) |
+		(tx_en->twt3 ? B_AX_CTN_TXEN_TWT_3 : 0);
+}
+
+void u16_2_sch(struct mac_ax_adapter *adapter,
+	       struct mac_ax_sch_tx_en *tx_en, u16 val16)
+{
+	tx_en->be0 = val16 & B_AX_CTN_TXEN_BE_0 ? 1 : 0;
+	tx_en->bk0 = val16 & B_AX_CTN_TXEN_BK_0 ? 1 : 0;
+	tx_en->vi0 = val16 & B_AX_CTN_TXEN_VI_0 ? 1 : 0;
+	tx_en->vo0 = val16 & B_AX_CTN_TXEN_VO_0 ? 1 : 0;
+	tx_en->be1 = val16 & B_AX_CTN_TXEN_BE_1 ? 1 : 0;
+	tx_en->bk1 = val16 & B_AX_CTN_TXEN_BK_1 ? 1 : 0;
+	tx_en->vi1 = val16 & B_AX_CTN_TXEN_VI_1 ? 1 : 0;
+	tx_en->vo1 = val16 & B_AX_CTN_TXEN_VO_1 ? 1 : 0;
+	tx_en->mg0 = val16 & B_AX_CTN_TXEN_MGQ ? 1 : 0;
+	tx_en->mg1 = val16 & B_AX_CTN_TXEN_MGQ1 ? 1 : 0;
+	tx_en->mg2 = val16 & B_AX_CTN_TXEN_CPUMGQ ? 1 : 0;
+	tx_en->hi = val16 & B_AX_CTN_TXEN_HGQ ? 1 : 0;
+	tx_en->bcn = val16 & B_AX_CTN_TXEN_BCNQ ? 1 : 0;
+	tx_en->ul = val16 & B_AX_CTN_TXEN_ULQ ? 1 : 0;
+	tx_en->twt0 = val16 & B_AX_CTN_TXEN_TWT_0 ? 1 : 0;
+	tx_en->twt1 = val16 & B_AX_CTN_TXEN_TWT_1 ? 1 : 0;
+}
+
+void u32_2_sch(struct mac_ax_adapter *adapter,
+	       struct mac_ax_sch_tx_en *tx_en, u32 val32)
+{
+	tx_en->be0 = val32 & B_AX_CTN_TXEN_BE_0 ? 1 : 0;
+	tx_en->bk0 = val32 & B_AX_CTN_TXEN_BK_0 ? 1 : 0;
+	tx_en->vi0 = val32 & B_AX_CTN_TXEN_VI_0 ? 1 : 0;
+	tx_en->vo0 = val32 & B_AX_CTN_TXEN_VO_0 ? 1 : 0;
+	tx_en->be1 = val32 & B_AX_CTN_TXEN_BE_1 ? 1 : 0;
+	tx_en->bk1 = val32 & B_AX_CTN_TXEN_BK_1 ? 1 : 0;
+	tx_en->vi1 = val32 & B_AX_CTN_TXEN_VI_1 ? 1 : 0;
+	tx_en->vo1 = val32 & B_AX_CTN_TXEN_VO_1 ? 1 : 0;
+	tx_en->mg0 = val32 & B_AX_CTN_TXEN_MGQ ? 1 : 0;
+	tx_en->mg1 = val32 & B_AX_CTN_TXEN_MGQ1 ? 1 : 0;
+	tx_en->mg2 = val32 & B_AX_CTN_TXEN_CPUMGQ ? 1 : 0;
+	tx_en->hi = val32 & B_AX_CTN_TXEN_HGQ ? 1 : 0;
+	tx_en->bcn = val32 & B_AX_CTN_TXEN_BCNQ ? 1 : 0;
+	tx_en->ul = val32 & B_AX_CTN_TXEN_ULQ ? 1 : 0;
+	tx_en->twt0 = val32 & B_AX_CTN_TXEN_TWT_0 ? 1 : 0;
+	tx_en->twt1 = val32 & B_AX_CTN_TXEN_TWT_1 ? 1 : 0;
+	tx_en->twt2 = val32 & B_AX_CTN_TXEN_TWT_2 ? 1 : 0;
+	tx_en->twt3 = val32 & B_AX_CTN_TXEN_TWT_3 ? 1 : 0;
+}
+
+static u32 h2c_usr_edca(struct mac_ax_adapter *adapter,
+			struct mac_ax_usr_edca_param *param)
+{
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_usr_edca *fwcmd_tbl;
+	u32 ret;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_usr_edca));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto usr_edca_fail;
+	}
+
+	fwcmd_tbl = (struct fwcmd_usr_edca *)buf;
+	fwcmd_tbl->dword0 =
+	cpu_to_le32(SET_WORD(param->idx, FWCMD_H2C_USR_EDCA_PARAM_SEL) |
+		    (param->enable ? FWCMD_H2C_USR_EDCA_ENABLE : 0) |
+		    (param->band ? FWCMD_H2C_USR_EDCA_BAND : 0) |
+		    (param->wmm ? FWCMD_H2C_USR_EDCA_WMM : 0) |
+		    SET_WORD(param->ac, FWCMD_H2C_USR_EDCA_AC));
+	fwcmd_tbl->dword1 =
+	cpu_to_le32(SET_WORD(param->aggressive.txop_32us, B_AX_BE_0_TXOPLMT) |
+		    SET_WORD((param->aggressive.ecw_max << 4) |
+			     param->aggressive.ecw_min, B_AX_BE_0_CW) |
+		    SET_WORD(param->aggressive.aifs_us, B_AX_BE_0_AIFS));
+	fwcmd_tbl->dword2 =
+	cpu_to_le32(SET_WORD(param->moderate.txop_32us, B_AX_BE_0_TXOPLMT) |
+		    SET_WORD((param->moderate.ecw_max << 4) |
+			     param->moderate.ecw_min, B_AX_BE_0_CW) |
+		    SET_WORD(param->moderate.aifs_us, B_AX_BE_0_AIFS));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_USR_EDCA,
+			      0,
+			      0);
+
+	if (ret != MACSUCCESS)
+		goto usr_edca_fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto usr_edca_fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto usr_edca_fail;
+
+	h2cb_free(adapter, h2cb);
+	return MACSUCCESS;
+
+usr_edca_fail:
+	h2cb_free(adapter, h2cb);
+	return ret;
+}
+
+static u32 h2c_usr_tx_rpt(struct mac_ax_adapter *adapter,
+			  struct mac_ax_usr_tx_rpt_cfg *param)
+{
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_usr_tx_rpt *fwcmd_tbl;
+	u32 ret;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_usr_tx_rpt));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_tbl = (struct fwcmd_usr_tx_rpt *)buf;
+	fwcmd_tbl->dword0 =
+	cpu_to_le32(SET_WORD(param->mode, FWCMD_H2C_USR_TX_RPT_MODE) |
+		    (param->rpt_start ? FWCMD_H2C_USR_TX_RPT_RTP_START : 0));
+	fwcmd_tbl->dword1 =
+	cpu_to_le32(SET_WORD(param->macid, FWCMD_H2C_USR_TX_RPT_MACID) |
+		    (param->band ? FWCMD_H2C_USR_TX_RPT_BAND : 0) |
+		    SET_WORD(param->port, FWCMD_H2C_USR_TX_RPT_PORT));
+	fwcmd_tbl->dword2 = cpu_to_le32(param->rpt_period_us);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_USR_TX_RPT,
+			      0,
+			      0);
+
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+	return MACSUCCESS;
+
+fail:
+	h2cb_free(adapter, h2cb);
+	return ret;
+}
+
+u32 mac_set_cctl_max_tx_time(struct mac_ax_adapter *adapter,
+			     struct mac_ax_max_tx_time *tx_time)
+{
+#define MAC_AX_DFLT_TX_TIME 5280
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct rtw_hal_mac_ax_cctl_info info, msk = {0};
+	u32 ret = MACSUCCESS;
+	struct mac_role_tbl *role;
+	u8 band;
+	u32 offset, max_tx_time;
+
+	role = mac_role_srch(adapter, tx_time->macid);
+	if (!role) {
+		PLTFM_MSG_ERR("%s: The MACID%d does not exist\n",
+			      __func__, tx_time->macid);
+		return MACNOITEM;
+	}
+
+	max_tx_time = tx_time->max_tx_time == 0 ?
+		MAC_AX_DFLT_TX_TIME : tx_time->max_tx_time;
+
+	if (tx_time->is_cctrl) {
+		msk.ampdu_time_sel = 1;
+		info.ampdu_time_sel = 1;
+		msk.ampdu_max_time = FWCMD_H2C_CCTRL_AMPDU_MAX_TIME_MSK;
+		info.ampdu_max_time = (max_tx_time - 512) >> 9;
+		ret = mops->upd_cctl_info(adapter, &info, &msk, tx_time->macid, 1);
+	} else {
+		band = role->info.wmm < 2 ? 0 : 1;
+		offset = band == 0 ? R_AX_AMPDU_AGG_LIMIT + 3 :
+			R_AX_AMPDU_AGG_LIMIT_C1 + 3;
+		ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+		if (ret != MACSUCCESS)
+			return ret;
+
+#if MAC_AX_FW_REG_OFLD
+		if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+			ret = MAC_REG_W8_OFLD((u16)offset,
+					      max_tx_time >> 5,
+					      1);
+			if (ret != MACSUCCESS)
+				PLTFM_MSG_ERR("%s: ofld fail %d\n",
+					      __func__, ret);
+			return ret;
+		}
+#endif
+		MAC_REG_W8(offset, max_tx_time >> 5);
+	}
+
+	return ret;
+}
+
+u32 mac_get_max_tx_time(struct mac_ax_adapter *adapter,
+			struct mac_ax_max_tx_time *tx_time)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = MACSUCCESS;
+	struct mac_role_tbl *role;
+	u32 offset;
+	u8 band;
+
+	role = mac_role_srch(adapter, tx_time->macid);
+	if (!role) {
+		PLTFM_MSG_ERR("%s: The MACID%d does not exist\n",
+			      __func__, tx_time->macid);
+		return MACNOITEM;
+	}
+
+	if (role->info.c_info.ampdu_time_sel) {
+		tx_time->max_tx_time = (role->info.c_info.ampdu_max_time + 1) << 9;
+		tx_time->is_cctrl = 1;
+	} else {
+		band = role->info.wmm < 2 ? 0 : 1;
+		offset = band == 0 ? R_AX_AMPDU_AGG_LIMIT + 3 :
+			R_AX_AMPDU_AGG_LIMIT_C1 + 3;
+		ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+		if (ret == MACSUCCESS)
+			tx_time->max_tx_time = MAC_REG_R8(offset) << 5;
+		tx_time->is_cctrl = 0;
+	}
+
+	return ret;
+}
+
+u32 mac_set_hw_rts_th(struct mac_ax_adapter *adapter,
+		      struct mac_ax_hw_rts_th *th)
+{
+#define MAC_AX_MULT32_SH 5
+#define MAC_AX_MULT16_SH 4
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret, offset;
+	u16 val;
+
+	ret = check_mac_en(adapter, th->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+	offset = th->band ? R_AX_AGG_LEN_HT_0_C1 : R_AX_AGG_LEN_HT_0;
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = MAC_REG_W_OFLD((u16)offset,
+				     B_AX_RTS_LEN_TH_MSK << B_AX_RTS_LEN_TH_SH,
+				     th->len_th >> MAC_AX_MULT16_SH, 0);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s: config fail\n", __func__);
+			return ret;
+		}
+		ret = MAC_REG_W_OFLD((u16)offset,
+				     B_AX_RTS_TXTIME_TH_MSK <<
+				     B_AX_RTS_TXTIME_TH_SH,
+				     th->time_th >> MAC_AX_MULT32_SH, 1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s: config fail\n", __func__);
+			return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+	val = SET_WORD(th->len_th >> MAC_AX_MULT16_SH, B_AX_RTS_LEN_TH) |
+		SET_WORD(th->time_th >> MAC_AX_MULT32_SH, B_AX_RTS_TXTIME_TH);
+	MAC_REG_W16(offset, val);
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_hw_rts_th(struct mac_ax_adapter *adapter,
+		      struct mac_ax_hw_rts_th *th)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret, offset;
+	u16 val;
+
+	ret = check_mac_en(adapter, th->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	offset = th->band ? R_AX_AGG_LEN_HT_0_C1 : R_AX_AGG_LEN_HT_0;
+	val = MAC_REG_R16(offset);
+
+	th->len_th = GET_FIELD(val, B_AX_RTS_LEN_TH);
+	th->len_th = th->len_th << MAC_AX_MULT16_SH;
+	th->time_th = GET_FIELD(val, B_AX_RTS_TXTIME_TH);
+	th->time_th = th->time_th << MAC_AX_MULT32_SH;
+
+	return MACSUCCESS;
+#undef MAC_AX_MULT32_SH
+#undef MAC_AX_MULT16_SH
+}
+
+u32 mac_tx_idle_poll(struct mac_ax_adapter *adapter,
+		     struct mac_ax_tx_idle_poll_cfg *poll_cfg)
+{
+	switch (poll_cfg->sel) {
+	case MAC_AX_TX_IDLE_POLL_SEL_BAND:
+		return tx_idle_poll_band(adapter, poll_cfg->band);
+	default:
+		return MACNOITEM;
+	}
+}
+
+u32 mac_set_tx_ru26_tb(struct mac_ax_adapter *adapter,
+		       u8 disable)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+#if MAC_AX_FW_REG_OFLD
+	u32 ret;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		if (disable)
+			ret = MAC_REG_W_OFLD(R_AX_RXTRIG_TEST_USER_2, B_AX_RXTRIG_RU26_DIS, 1, 1);
+		else
+			ret = MAC_REG_W_OFLD(R_AX_RXTRIG_TEST_USER_2, B_AX_RXTRIG_RU26_DIS, 0, 1);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, R_AX_RXTRIG_TEST_USER_2);
+			return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+	val32 = MAC_REG_R32(R_AX_RXTRIG_TEST_USER_2) & (~B_AX_RXTRIG_RU26_DIS);
+
+	if (disable)
+		MAC_REG_W32(R_AX_RXTRIG_TEST_USER_2, val32 | B_AX_RXTRIG_RU26_DIS);
+	else
+		MAC_REG_W32(R_AX_RXTRIG_TEST_USER_2, val32);
+
+	return MACSUCCESS;
+}
+
+u32 set_cts2self(struct mac_ax_adapter *adapter,
+		 struct mac_ax_cts2self_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg;
+	u32 val32;
+
+	if (!cfg) {
+		PLTFM_MSG_ERR("[ERR]: the parameter is NULL in %s\n", __func__);
+		return MACNPTR;
+	}
+
+	reg = cfg->band_sel == MAC_AX_BAND_1 ?
+	      R_AX_SIFS_SETTING_C1 : R_AX_SIFS_SETTING;
+	val32 = MAC_REG_R32(reg);
+
+	if (cfg->threshold_sel == MAC_AX_CTS2SELF_DISABLE) {
+		val32 &= ~B_AX_HW_CTS2SELF_EN;
+		MAC_REG_W32(reg, val32);
+		return MACSUCCESS;
+	} else {
+		val32 |= B_AX_HW_CTS2SELF_EN;
+	}
+	if (cfg->threshold_sel == MAC_AX_CTS2SELF_NON_SEC_THRESHOLD ||
+	    cfg->threshold_sel == MAC_AX_CTS2SELF_BOTH_THRESHOLD) {
+		if (cfg->non_sec_threshold & ~B_AX_HW_CTS2SELF_PKT_LEN_TH_MSK) {
+			PLTFM_MSG_ERR("[ERR]: value out of range in %s\n", __func__);
+			return MACHWNOSUP;
+		}
+		val32 = SET_CLR_WORD(val32, cfg->non_sec_threshold,
+				     B_AX_HW_CTS2SELF_PKT_LEN_TH);
+	}
+	if (cfg->threshold_sel == MAC_AX_CTS2SELF_SEC_THRESHOLD ||
+	    cfg->threshold_sel == MAC_AX_CTS2SELF_BOTH_THRESHOLD) {
+		if (cfg->sec_threshold & ~B_AX_HW_CTS2SELF_PKT_LEN_TH_TWW_MSK) {
+			PLTFM_MSG_ERR("[ERR]: value out of range in %s\n", __func__);
+			return MACHWNOSUP;
+		}
+		val32 = SET_CLR_WORD(val32, cfg->sec_threshold,
+				     B_AX_HW_CTS2SELF_PKT_LEN_TH_TWW);
+	}
+
+	MAC_REG_W32(reg, val32);
+	return MACSUCCESS;
+}
+
+u32 mac_tx_duty(struct mac_ax_adapter *adapter,
+		u16 pause_intvl, u16 tx_intvl)
+{
+	u32 ret;
+
+	if (!(pause_intvl) || !(tx_intvl))
+		return MACFUNCINPUT;
+
+	ret = tx_duty_h2c(adapter, pause_intvl, tx_intvl);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_tx_duty_stop(struct mac_ax_adapter *adapter)
+{
+	u32 ret;
+
+	ret = tx_duty_h2c(adapter, 0, 0);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 tx_duty_h2c(struct mac_ax_adapter *adapter,
+		u16 pause_intvl, u16 tx_intvl)
+{
+	u32 ret, size;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	struct fwcmd_tx_duty cfg;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	size = sizeof(struct fwcmd_tx_duty);
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, size);
+	if (!buf) {
+		h2cb_free(adapter, h2cb);
+		return MACNOBUF;
+	}
+
+	cfg.dword0 =
+	cpu_to_le32(SET_WORD(pause_intvl, FWCMD_H2C_TX_DUTY_PAUSE_INTVL) |
+		    SET_WORD(tx_intvl, FWCMD_H2C_TX_DUTY_TX_INTVL)
+	);
+	cfg.dword1 = cpu_to_le32(pause_intvl ? 0 : FWCMD_H2C_TX_DUTY_STOP);
+
+	PLTFM_MEMCPY(buf, &cfg, size);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_TX_DUTY,
+			      0, 0);
+	if (ret != MACSUCCESS) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]platform tx\n");
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cmac_tx.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cmac_tx.h
new file mode 100644
index 000000000000..dd68022fb8b6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cmac_tx.h
@@ -0,0 +1,837 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_CMAC_TX_H_
+#define _MAC_AX_CMAC_TX_H_
+
+#include "../type.h"
+#include "trxcfg.h"
+#include "role.h"
+#include "hw.h"
+#include "dbgpkg.h"
+
+/*--------------------Define ----------------------------------------*/
+#define PTCL_TXQ_WMM0_BE	0
+#define PTCL_TXQ_WMM0_BK	1
+#define PTCL_TXQ_WMM0_VI	2
+#define PTCL_TXQ_WMM0_VO	3
+#define PTCL_TXQ_WMM1_BE	4
+#define PTCL_TXQ_WMM1_BK	5
+#define PTCL_TXQ_WMM1_VI	6
+#define PTCL_TXQ_WMM1_VO	7
+#define PTCL_TXQ_MG0		8
+#define PTCL_TXQ_MG1		9
+#define PTCL_TXQ_MG2		10
+#define PTCL_TXQ_HIQ		11
+#define PTCL_TXQ_BCNQ		12
+#define PTCL_TXQ_UL		13
+#define PTCL_TXQ_TWT0		14
+#define PTCL_TXQ_TWT1		15
+
+#define TX_PAUSE_WAIT_CNT	5000
+#define TX_PAUSE_WAIT_PKT_CNT 20000
+
+#define PTCL_IDLE_POLL_CNT	2200
+#define SW_CVR_DUR_US	30
+#define SW_CVR_CNT	8
+#define TX_DLY_MAX	9
+
+#define MACTXEN_MAX	81
+#define MACTXEN_MIN	56
+
+/*--------------------Define Enum------------------------------------*/
+
+/**
+ * @enum tb_stop_sel
+ *
+ * @brief tb_stop_sel
+ *
+ * @var tb_stop_sel::TB_STOP_SEL_BE
+ * Please Place Description here.
+ * @var tb_stop_sel::TB_STOP_SEL_BK
+ * Please Place Description here.
+ * @var tb_stop_sel::TB_STOP_SEL_VI
+ * Please Place Description here.
+ * @var tb_stop_sel::TB_STOP_SEL_VO
+ * Please Place Description here.
+ * @var tb_stop_sel::TB_STOP_SEL_ALL
+ * Please Place Description here.
+ */
+enum tb_stop_sel {
+	TB_STOP_SEL_BE,
+	TB_STOP_SEL_BK,
+	TB_STOP_SEL_VI,
+	TB_STOP_SEL_VO,
+	TB_STOP_SEL_ALL,
+};
+
+/**
+ * @enum sch_tx_sel
+ *
+ * @brief sch_tx_sel
+ *
+ * @var sch_tx_sel::SCH_TX_SEL_ALL
+ * Please Place Description here.
+ * @var sch_tx_sel::SCH_TX_SEL_HIQ
+ * Please Place Description here.
+ * @var sch_tx_sel::SCH_TX_SEL_MG0
+ * Please Place Description here.
+ * @var sch_tx_sel::SCH_TX_SEL_MACID
+ * Please Place Description here.
+ */
+enum sch_tx_sel {
+	SCH_TX_SEL_ALL,
+	SCH_TX_SEL_HIQ,
+	SCH_TX_SEL_MG0,
+	SCH_TX_SEL_MACID,
+};
+
+/**
+ * @enum ptcl_tx_sel
+ *
+ * @brief ptcl_tx_sel
+ *
+ * @var ptcl_tx_sel::PTCL_TX_SEL_HIQ
+ * Please Place Description here.
+ * @var ptcl_tx_sel::PTCL_TX_SEL_MG0
+ * Please Place Description here.
+ */
+enum ptcl_tx_sel {
+	PTCL_TX_SEL_HIQ,
+	PTCL_TX_SEL_MG0,
+};
+
+/*--------------------Define MACRO----------------------------------*/
+/*--------------------Define Struct----------------------------------*/
+
+/**
+ * @struct sch_tx_en_h2creg
+ * @brief sch_tx_en_h2creg
+ *
+ * @var sch_tx_en_h2creg::tx_en
+ * Please Place Description here.
+ * @var sch_tx_en_h2creg::mask
+ * Please Place Description here.
+ * @var sch_tx_en_h2creg::band
+ * Please Place Description here.
+ * @var sch_tx_en_h2creg::rsvd
+ * Please Place Description here.
+ */
+struct sch_tx_en_h2creg {
+	/* dword0 */
+	u32 tx_en:16;
+	/* dword1 */
+	u32 mask:16;
+	u32 band:1;
+	u32 rsvd0:15;
+};
+
+/*--------------------Export global variable----------------------------*/
+/*--------------------Function declaration-----------------------------*/
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+/**
+ * @brief tx_on_dly
+ *
+ * @param *adapter
+ * @param band
+ * @void.
+ * @retval N/A
+ */
+void tx_on_dly(struct mac_ax_adapter *adapter, u8 band);
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+/**
+ * @brief set_hw_ampdu_cfg
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_hw_ampdu_cfg(struct mac_ax_adapter *adapter,
+		     struct mac_ax_ampdu_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief set_hw_usr_edca_param
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_hw_usr_edca_param(struct mac_ax_adapter *adapter,
+			  struct mac_ax_usr_edca_param *param);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief set_hw_usr_tx_rpt_cfg
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return MACSUCCESS
+ * @retval u32
+ */
+u32 set_hw_usr_tx_rpt_cfg(struct mac_ax_adapter *adapter,
+			  struct mac_ax_usr_tx_rpt_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief set_hw_edca_param
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_hw_edca_param(struct mac_ax_adapter *adapter,
+		      struct mac_ax_edca_param *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief get_hw_edca_param
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_hw_edca_param(struct mac_ax_adapter *adapter,
+		      struct mac_ax_edca_param *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief set_hw_edcca_param
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_hw_edcca_param(struct mac_ax_adapter *adapter,
+		       struct mac_ax_edcca_param *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief set_hw_muedca_param
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_hw_muedca_param(struct mac_ax_adapter *adapter,
+			struct mac_ax_muedca_param *param);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief set_hw_muedca_ctrl
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_hw_muedca_ctrl(struct mac_ax_adapter *adapter,
+		       struct mac_ax_muedca_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief set_hw_tb_ppdu_ctrl
+ *
+ * @param *adapter
+ * @param *ctrl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_hw_tb_ppdu_ctrl(struct mac_ax_adapter *adapter,
+			struct mac_ax_tb_ppdu_ctrl *ctrl);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief get_hw_tb_ppdu_ctrl
+ *
+ * @param *adapter
+ * @param *ctrl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_hw_tb_ppdu_ctrl(struct mac_ax_adapter *adapter,
+			struct mac_ax_tb_ppdu_ctrl *ctrl);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief set_hw_sch_tx_en
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_hw_sch_tx_en(struct mac_ax_adapter *adapter,
+		     struct mac_ax_sch_tx_en_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief hw_sch_tx_en
+ *
+ * @param *adapter
+ * @param band
+ * @param tx_en_u16
+ * @param mask_u16
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 hw_sch_tx_en(struct mac_ax_adapter *adapter, u8 band,
+		 u16 tx_en_u16, u16 mask_u16);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief get_hw_sch_tx_en
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_hw_sch_tx_en(struct mac_ax_adapter *adapter,
+		     struct mac_ax_sch_tx_en_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief set_hw_lifetime_cfg
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_hw_lifetime_cfg(struct mac_ax_adapter *adapter,
+			struct mac_ax_lifetime_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief get_hw_lifetime_cfg
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_hw_lifetime_cfg(struct mac_ax_adapter *adapter,
+			struct mac_ax_lifetime_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief set_hw_sifs_r2t_t2t
+ *
+ * @param *adapter
+ * @param *ctrl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_hw_sifs_r2t_t2t(struct mac_ax_adapter *adapter,
+			struct mac_ax_sifs_r2t_t2t_ctrl *ctrl);
+
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief resume_sch_tx
+ *
+ * @param *adapter
+ * @param *bak
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 resume_sch_tx(struct mac_ax_adapter *adapter,
+		  struct mac_ax_sch_tx_en_cfg *bak);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief stop_macid_tx
+ *
+ * @param *adapter
+ * @param *role
+ * @param stop_sel
+ * @param *bak
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 stop_macid_tx(struct mac_ax_adapter *adapter, struct mac_role_tbl *role,
+		  enum tb_stop_sel stop_sel, struct macid_tx_bak *bak);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief resume_macid_tx
+ *
+ * @param *adapter
+ * @param *role
+ * @param *bak
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 resume_macid_tx(struct mac_ax_adapter *adapter, struct mac_role_tbl *role,
+		    struct macid_tx_bak *bak);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief tx_idle_poll_macid
+ *
+ * @param *adapter
+ * @param *role
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 tx_idle_poll_macid(struct mac_ax_adapter *adapter,
+		       struct mac_role_tbl *role);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief tx_idle_poll_band
+ *
+ * @param *adapter
+ * @param band: 0/1 for band 0/1
+ * @return MACSUCCESS
+ * @retval u32
+ */
+u32 tx_idle_poll_band(struct mac_ax_adapter *adapter, u8 band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief tx_idle_poll_sel
+ *
+ * @param *adapter
+ * @param sel
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 tx_idle_poll_sel(struct mac_ax_adapter *adapter, enum ptcl_tx_sel sel,
+		     u8 band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief stop_ac_tb_tx
+ *
+ * @param *adapter
+ * @param stop_sel
+ * @param *ac_dis_bak
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 stop_ac_tb_tx(struct mac_ax_adapter *adapter, enum tb_stop_sel stop_sel,
+		  struct mac_ax_tb_ppdu_ctrl *ac_dis_bak);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+u32 get_edca_addr(struct mac_ax_adapter *adapter,
+		  struct mac_ax_edca_param *param, u32 *reg_edca);
+
+u32 get_muedca_param_addr(struct mac_ax_adapter *adapter,
+			  struct mac_ax_muedca_param *param,
+			  u32 *reg_edca);
+
+/**
+ * @brief mac_set_cctl_max_tx_time
+ *
+ * @param *adapter
+ * @param *tx_time
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_cctl_max_tx_time(struct mac_ax_adapter *adapter,
+			     struct mac_ax_max_tx_time *tx_time);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_get_max_tx_time
+ *
+ * @param *adapter
+ * @param *tx_time
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_max_tx_time(struct mac_ax_adapter *adapter,
+			struct mac_ax_max_tx_time *tx_time);
+/**
+ * @}
+ * @}
+ */
+u32 mac_tx_idle_poll(struct mac_ax_adapter *adapter,
+		     struct mac_ax_tx_idle_poll_cfg *poll_cfg);
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_set_hw_rts_th
+ *
+ * @param *adapter
+ * @param *
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_hw_rts_th(struct mac_ax_adapter *adapter,
+		      struct mac_ax_hw_rts_th *th);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_get_hw_rts_th
+ *
+ * @param *adapter
+ * @param *
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_hw_rts_th(struct mac_ax_adapter *adapter,
+		      struct mac_ax_hw_rts_th *th);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_set_tx_ru26_tb
+ *
+ * @param *adapter
+ * @param disable
+ * @return To enable or disable responding TB in RU26
+ * @retval u32
+ */
+u32 mac_set_tx_ru26_tb(struct mac_ax_adapter *adapter,
+		       u8 disable);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief set_cts2self_ax
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_cts2self(struct mac_ax_adapter *adapter,
+		 struct mac_ax_cts2self_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_tx_duty
+ *
+ * @param *adapter
+ * @param pause_intvl
+ * @param tx_intvl
+ * @return Do tx_duty for Thermal Prodection
+ * @retval u32
+ */
+u32 mac_tx_duty(struct mac_ax_adapter *adapter,
+		u16 pause_intvl, u16 tx_intvl);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_tx_duty_stop
+ *
+ * @param *adapter
+ * @param pause_intvl
+ * @param tx_intvl
+ * @return Stop tx_duty for Thermal Prodection
+ * @retval u32
+ */
+u32 mac_tx_duty_stop(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+void u16_2_sch(struct mac_ax_adapter *adapter,
+	       struct mac_ax_sch_tx_en *tx_en, u16 val16);
+void u32_2_sch(struct mac_ax_adapter *adapter,
+	       struct mac_ax_sch_tx_en *tx_en, u32 val32);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/coex.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/coex.c
new file mode 100644
index 000000000000..41361d7171b5
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/coex.c
@@ -0,0 +1,115 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "coex.h"
+#include "../mac_reg.h"
+#include "hw.h"
+#include "power_saving.h"
+
+#define MAC_AX_RTK_RATE 5
+
+#define MAC_AX_BT_MODE_0_3 0
+#define MAC_AX_BT_MODE_2 2
+
+#define MAC_AX_CSR_DELAY 0
+#define MAC_AX_CSR_PRI_TO 5
+#define MAC_AX_CSR_TRX_TO 4
+
+#define MAC_AX_CSR_RATE 80
+
+#define MAC_AX_SB_DRV_MSK 0xFFFFFF
+#define MAC_AX_SB_DRV_SH 0
+#define MAC_AX_SB_FW_MSK 0x7F
+#define MAC_AX_SB_FW_SH 24
+
+#define MAC_AX_BTGS1_NOTIFY BIT(0)
+
+u32 mac_cfg_plt(struct mac_ax_adapter *adapter, struct mac_ax_plt *plt)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg, ret;
+	u16 val;
+
+	ret = check_mac_en(adapter, plt->band, MAC_AX_CMAC_SEL);
+	if (ret)
+		return ret;
+
+	reg = plt->band == 0 ? R_AX_BT_PLT : R_AX_BT_PLT_C1;
+	val = (plt->tx & MAC_AX_PLT_LTE_RX ? B_AX_TX_PLT_GNT_LTE_RX : 0) |
+		(plt->tx & MAC_AX_PLT_GNT_BT_TX ? B_AX_TX_PLT_GNT_BT_TX : 0) |
+		(plt->tx & MAC_AX_PLT_GNT_BT_RX ? B_AX_TX_PLT_GNT_BT_RX : 0) |
+		(plt->tx & MAC_AX_PLT_GNT_WL ? B_AX_TX_PLT_GNT_WL : 0) |
+		(plt->rx & MAC_AX_PLT_LTE_RX ? B_AX_RX_PLT_GNT_LTE_RX : 0) |
+		(plt->rx & MAC_AX_PLT_GNT_BT_TX ? B_AX_RX_PLT_GNT_BT_TX : 0) |
+		(plt->rx & MAC_AX_PLT_GNT_BT_RX ? B_AX_RX_PLT_GNT_BT_RX : 0) |
+		(plt->rx & MAC_AX_PLT_GNT_WL ? B_AX_RX_PLT_GNT_WL : 0) |
+		B_AX_PLT_EN;
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = MAC_REG_W_OFLD((u16)reg,
+				     B_AX_TX_PLT_GNT_LTE_RX |
+				     B_AX_TX_PLT_GNT_BT_TX |
+				     B_AX_TX_PLT_GNT_BT_RX |
+				     B_AX_TX_PLT_GNT_WL |
+				     B_AX_RX_PLT_GNT_LTE_RX |
+				     B_AX_RX_PLT_GNT_BT_TX |
+				     B_AX_RX_PLT_GNT_BT_RX |
+				     B_AX_RX_PLT_GNT_WL,
+				     val, 1);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("%s: write offload fail %d",
+				      __func__, ret);
+
+		return ret;
+	}
+#endif
+	MAC_REG_W16(reg, val);
+
+	return MACSUCCESS;
+}
+
+void mac_cfg_sb(struct mac_ax_adapter *adapter, u32 val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 fw_sb;
+
+	fw_sb = MAC_REG_R32(R_AX_SCOREBOARD);
+	fw_sb = GET_FIELD(fw_sb, MAC_AX_SB_FW);
+	fw_sb = fw_sb & ~MAC_AX_BTGS1_NOTIFY;
+	if (adapter->sm.pwr == MAC_AX_PWR_OFF || _is_in_lps(adapter))
+		fw_sb = fw_sb | MAC_AX_NOTIFY_PWR_MAJOR;
+	else
+		fw_sb = fw_sb | MAC_AX_NOTIFY_TP_MAJOR;
+	val = GET_FIELD(val, MAC_AX_SB_DRV);
+	val = B_AX_TOGGLE |
+		SET_WORD(val, MAC_AX_SB_DRV) |
+		SET_WORD(fw_sb, MAC_AX_SB_FW);
+	MAC_REG_W32(R_AX_SCOREBOARD, val);
+}
+
+u32 mac_get_bt_polt_cnt(struct mac_ax_adapter *adapter,
+			struct mac_ax_bt_polt_cnt *cnt)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 offset = cnt->band ? R_AX_BT_PLT_C1 : R_AX_BT_PLT;
+	u8 val;
+
+	cnt->cnt = MAC_REG_R16(offset + 2);
+
+	val = MAC_REG_R8(offset + 1);
+	MAC_REG_W8(offset + 1, val | BIT(1));
+
+	return MACSUCCESS;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/coex.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/coex.h
new file mode 100644
index 000000000000..e95ff1bda152
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/coex.h
@@ -0,0 +1,127 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_COEX_H_
+#define _MAC_AX_COEX_H_
+
+#include "../mac_def.h"
+
+#define MAC_AX_NOTIFY_TP_MAJOR 0x81
+#define MAC_AX_NOTIFY_PWR_MAJOR 0x80
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_plt
+ *
+ * @param *adapter
+ * @param *plt
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_cfg_plt(struct mac_ax_adapter *adapter, struct mac_ax_plt *plt);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_sb
+ *
+ * @param *adapter
+ * @param val
+ * @return Please Place Description here.
+ * @retval void
+ */
+
+void mac_cfg_sb(struct mac_ax_adapter *adapter, u32 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @brief mac_get_bt_polt_cnt
+ *
+ * @param *adapter
+ * @param *cnt
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_get_bt_polt_cnt(struct mac_ax_adapter *adapter,
+			struct mac_ax_bt_polt_cnt *cnt);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @brief mac_write_coex_mask
+ *
+ * Write coex reg with mask
+ *
+ * @param *adapter
+ * @param offset
+ * @param mask
+ * @param val
+ * @return 0 for success, others are fail
+ * @retval u32
+ */
+
+u32 mac_write_coex_mask(struct mac_ax_adapter *adapter,
+			u32 offset, u32 mask, u32 val);
+
+/**
+ * @}
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/common.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/common.c
new file mode 100644
index 000000000000..1d8c9f6ffca3
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/common.c
@@ -0,0 +1,29 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "common.h"
+
+u8 shift_mask(u32 mask)
+{
+	u8 i;
+
+	for (i = 0; i < 32; i++) {
+		if ((mask >> i) & BIT0)
+			break;
+	}
+
+	return i;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/common.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/common.h
new file mode 100644
index 000000000000..ff6f8642e8f8
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/common.h
@@ -0,0 +1,37 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_COMMON_H_
+#define _MAC_AX_COMMON_H_
+
+#include "../type.h"
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+/**
+ * @brief shift_mask
+ *
+ * @param mask
+ * @return Please Place Description here.
+ * @retval  mask_last_bit
+ */
+u8 shift_mask(u32 mask);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cpuio.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cpuio.c
new file mode 100644
index 000000000000..a341b5299011
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cpuio.c
@@ -0,0 +1,1361 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "cpuio.h"
+#include "mac_priv.h"
+
+#define MAX_MACID_NUM		256
+
+static u32 band_pkt_drop(struct mac_ax_adapter *adapter,
+			 struct mac_ax_pkt_drop_info *info, u8 once);
+static u32 hw_link_drop(struct mac_ax_adapter *adapter,
+			struct mac_ax_pkt_drop_info *info);
+static u32 macid_pkt_drop_all(struct mac_ax_adapter *adapter, u8 macid);
+static u32 h2c_pkt_drop(struct mac_ax_adapter *adapter,
+			struct mac_ax_pkt_drop_info *info,
+			struct mac_role_tbl *role,
+			u32 *macid_band_sel);
+static u32 ac_pkt_drop(struct mac_ax_adapter *adapter, u8 macid,
+		       enum pkt_drop_ac ac);
+static u32 deq_enq_to_tail(struct mac_ax_adapter *adapter,
+			   struct deq_enq_info *info);
+static u32 get_1st_pktid(struct mac_ax_adapter *adapter,
+			 struct first_pid_info *info);
+static u32 get_next_pktid(struct mac_ax_adapter *adapter,
+			  struct next_pid_info *info);
+static void set_dmac_macid_drop(struct mac_ax_adapter *adapter, u8 macid);
+static void set_cmac_macid_drop(struct mac_ax_adapter *adapter, u8 macid);
+static void rel_dmac_macid_drop(struct mac_ax_adapter *adapter, u8 macid);
+static void rel_cmac_macid_drop(struct mac_ax_adapter *adapter, u8 macid);
+static u32 hiq_drop_ctrl(struct mac_ax_adapter *adapter,
+			 struct mac_ax_pkt_drop_info *info, u8 drop_en);
+static u32 set_hiq_drop(struct mac_ax_adapter *adapter,
+			struct mac_ax_pkt_drop_info *info);
+static u32 rel_hiq_drop(struct mac_ax_adapter *adapter,
+			struct mac_ax_pkt_drop_info *info);
+static void ss_hw_len_udn_clr(struct mac_ax_adapter *adapter);
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+static u32 _hiq_drop_v0(struct mac_ax_adapter *adapter,
+			struct mac_ax_pkt_drop_info *info);
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+static u32 _hiq_drop_v1(struct mac_ax_adapter *adapter,
+			struct mac_ax_pkt_drop_info *info);
+#endif
+static u32 hiq_link_drop(struct mac_ax_adapter *adapter,
+			 struct mac_ax_pkt_drop_info *info);
+static u32 mg0_link_drop(struct mac_ax_adapter *adapter, u8 band);
+
+u32 mac_dle_buf_req_wd(struct mac_ax_adapter *adapter,
+		       struct cpuio_buf_req_t *buf_req_p)
+{
+	u32 val32, timeout;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = 0;
+	val32 = SET_CLR_WORD(val32, buf_req_p->len, B_AX_WD_BUF_REQ_LEN);
+	val32 |= B_AX_WD_BUF_REQ_EXEC;
+	MAC_REG_W32(R_AX_WD_BUF_REQ, val32);
+
+	timeout = DLE_BUF_REQ_DLY_CNT;
+	while (timeout--) {
+		val32 = MAC_REG_R32(R_AX_WD_BUF_STATUS);
+		if (val32 & B_AX_WD_BUF_STAT_DONE)
+			break;
+		PLTFM_DELAY_US(DLE_BUF_REQ_DLY_US);
+	}
+
+	if (!++timeout) {
+		PLTFM_MSG_ERR("[ERR]dle buf req wd %d timeout\n",
+			      buf_req_p->len);
+		return MACPOLLTO;
+	}
+
+	buf_req_p->pktid = GET_FIELD(val32, B_AX_WD_BUF_STAT_PKTID);
+
+	if (buf_req_p->pktid == 0xfff) {
+		PLTFM_MSG_ERR("[ERR]dle buf req wd %d no pktid\n",
+			      buf_req_p->len);
+		return MACNOBUF;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_dle_buf_req_pl(struct mac_ax_adapter *adapter,
+		       struct cpuio_buf_req_t *buf_req_p)
+{
+	u32 val32, timeout;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = 0;
+	val32 = SET_CLR_WORD(val32, buf_req_p->len, B_AX_PL_BUF_REQ_LEN);
+	val32 |= B_AX_PL_BUF_REQ_EXEC;
+	MAC_REG_W32(R_AX_PL_BUF_REQ, val32);
+
+	timeout = DLE_BUF_REQ_DLY_CNT;
+	while (timeout--) {
+		val32 = MAC_REG_R32(R_AX_PL_BUF_STATUS);
+		if (val32 & B_AX_PL_BUF_STAT_DONE)
+			break;
+		PLTFM_DELAY_US(DLE_BUF_REQ_DLY_US);
+	}
+
+	if (!++timeout) {
+		PLTFM_MSG_ERR("[ERR]dle buf req pl %d timeout\n",
+			      buf_req_p->len);
+		return MACPOLLTO;
+	}
+
+	buf_req_p->pktid = GET_FIELD(val32, B_AX_PL_BUF_STAT_PKTID);
+
+	if (buf_req_p->pktid == 0xfff) {
+		PLTFM_MSG_ERR("[ERR]dle buf req pl %d no pktid\n",
+			      buf_req_p->len);
+		return MACNOBUF;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_set_cpuio_wd(struct mac_ax_adapter *adapter,
+		     struct cpuio_ctrl_t *ctrl_para_p)
+{
+	u32 val_op0, val_op1, val_op2;
+	u32 val32, cmd_type, timeout;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	cmd_type = ctrl_para_p->cmd_type;
+
+	val_op2 = 0;
+	val_op2 = SET_CLR_WORD(val_op2, ctrl_para_p->start_pktid,
+			       B_AX_WD_CPUQ_OP_STRT_PKTID);
+	val_op2 = SET_CLR_WORD(val_op2, ctrl_para_p->end_pktid,
+			       B_AX_WD_CPUQ_OP_END_PKTID);
+	MAC_REG_W32(R_AX_WD_CPUQ_OP_2, val_op2);
+
+	val_op1 = 0;
+	val_op1 = SET_CLR_WORD(val_op1, ctrl_para_p->src_pid,
+			       B_AX_WD_CPUQ_OP_SRC_PID);
+	val_op1 = SET_CLR_WORD(val_op1, ctrl_para_p->src_qid,
+			       B_AX_WD_CPUQ_OP_SRC_QID);
+	val_op1 = SET_CLR_WORD(val_op1, ctrl_para_p->dst_pid,
+			       B_AX_WD_CPUQ_OP_DST_PID);
+	val_op1 = SET_CLR_WORD(val_op1, ctrl_para_p->dst_qid,
+			       B_AX_WD_CPUQ_OP_DST_QID);
+	MAC_REG_W32(R_AX_WD_CPUQ_OP_1, val_op1);
+
+	val_op0 = 0;
+	val_op0 = SET_CLR_WORD(val_op0, cmd_type,
+			       B_AX_WD_CPUQ_OP_CMD_TYPE);
+	val_op0 = SET_CLR_WORD(val_op0, ctrl_para_p->macid,
+			       B_AX_WD_CPUQ_OP_MACID);
+	val_op0 = SET_CLR_WORD(val_op0, ctrl_para_p->pkt_num,
+			       B_AX_WD_CPUQ_OP_PKTNUM);
+	val_op0 |= B_AX_WD_CPUQ_OP_EXEC;
+	MAC_REG_W32(R_AX_WD_CPUQ_OP_0, val_op0);
+
+	timeout = SET_CPUIO_DLY_CNT;
+	do {
+		val32 = MAC_REG_R32(R_AX_WD_CPUQ_OP_STATUS);
+		if (val32 & B_AX_WD_CPUQ_OP_STAT_DONE)
+			break;
+		PLTFM_DELAY_US(SET_CPUIO_DLY_US);
+		timeout--;
+	} while (timeout);
+
+	if (!timeout) {
+		PLTFM_MSG_ERR("[ERR]set cpuio wd timeout\n");
+		PLTFM_MSG_ERR("[ERR]op_0=0x%X, op_1=0x%X, op_2=0x%X\n",
+			      val_op0, val_op1, val_op2);
+		return MACPOLLTO;
+	}
+
+	if (cmd_type == CPUIO_OP_CMD_GET_1ST_PID ||
+	    cmd_type == CPUIO_OP_CMD_GET_NEXT_PID)
+		ctrl_para_p->pktid = GET_FIELD(val32, B_AX_WD_CPUQ_OP_PKTID);
+
+	return MACSUCCESS;
+}
+
+u32 mac_set_cpuio_pl(struct mac_ax_adapter *adapter,
+		     struct cpuio_ctrl_t *ctrl_para_p)
+{
+	u32 val_op0, val_op1, val_op2;
+	u32 val32, cmd_type, timeout;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	cmd_type = ctrl_para_p->cmd_type;
+
+	val_op2 = 0;
+	val_op2 = SET_CLR_WORD(val_op2, ctrl_para_p->start_pktid,
+			       B_AX_PL_CPUQ_OP_STRT_PKTID);
+	val_op2 = SET_CLR_WORD(val_op2, ctrl_para_p->end_pktid,
+			       B_AX_PL_CPUQ_OP_END_PKTID);
+	MAC_REG_W32(R_AX_PL_CPUQ_OP_2, val_op2);
+
+	val_op1 = 0;
+	val_op1 = SET_CLR_WORD(val_op1, ctrl_para_p->src_pid,
+			       B_AX_PL_CPUQ_OP_SRC_PID);
+	val_op1 = SET_CLR_WORD(val_op1, ctrl_para_p->src_qid,
+			       B_AX_PL_CPUQ_OP_SRC_QID);
+	val_op1 = SET_CLR_WORD(val_op1, ctrl_para_p->dst_pid,
+			       B_AX_PL_CPUQ_OP_DST_PID);
+	val_op1 = SET_CLR_WORD(val_op1, ctrl_para_p->dst_qid,
+			       B_AX_PL_CPUQ_OP_DST_QID);
+	MAC_REG_W32(R_AX_PL_CPUQ_OP_1, val_op1);
+
+	val_op0 = 0;
+	val_op0 = SET_CLR_WORD(val_op0, cmd_type,
+			       B_AX_PL_CPUQ_OP_CMD_TYPE);
+	val_op0 = SET_CLR_WORD(val_op0, ctrl_para_p->macid,
+			       B_AX_PL_CPUQ_OP_MACID);
+	val_op0 = SET_CLR_WORD(val_op0, ctrl_para_p->pkt_num,
+			       B_AX_PL_CPUQ_OP_PKTNUM);
+	val_op0 |= B_AX_PL_CPUQ_OP_EXEC;
+	MAC_REG_W32(R_AX_PL_CPUQ_OP_0, val_op0);
+
+	timeout = SET_CPUIO_DLY_CNT;
+	do {
+		val32 = MAC_REG_R32(R_AX_PL_CPUQ_OP_STATUS);
+		if (val32 & B_AX_PL_CPUQ_OP_STAT_DONE)
+			break;
+		PLTFM_DELAY_US(SET_CPUIO_DLY_US);
+		timeout--;
+	} while (timeout);
+
+	if (!timeout) {
+		PLTFM_MSG_ERR("[ERR]set cpuio pl timeout\n");
+		PLTFM_MSG_ERR("[ERR]op_0=0x%X, op_1=0x%X, op_2=0x%X\n",
+			      val_op0, val_op1, val_op2);
+		return MACPOLLTO;
+	}
+
+	if (cmd_type == CPUIO_OP_CMD_GET_1ST_PID ||
+	    cmd_type == CPUIO_OP_CMD_GET_NEXT_PID)
+		ctrl_para_p->pktid = GET_FIELD(val32, B_AX_PL_CPUQ_OP_PKTID);
+
+	return MACSUCCESS;
+}
+
+u32 mac_wde_pkt_drop(struct mac_ax_adapter *adapter,
+		     struct mac_ax_pkt_drop_info *info)
+{
+	u32 ret;
+	struct mac_role_tbl *role;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		switch (info->sel) {
+		case MAC_AX_PKT_DROP_SEL_MACID_BE_ONCE:
+		case MAC_AX_PKT_DROP_SEL_MACID_BK_ONCE:
+		case MAC_AX_PKT_DROP_SEL_MACID_VI_ONCE:
+		case MAC_AX_PKT_DROP_SEL_MACID_VO_ONCE:
+		case MAC_AX_PKT_DROP_SEL_MACID_ALL:
+			role = mac_role_srch(adapter, info->macid);
+			if (info->sel == MAC_AX_PKT_DROP_SEL_MACID_ALL) {
+				set_dmac_macid_drop(adapter, info->macid);
+				set_cmac_macid_drop(adapter, info->macid);
+			}
+			ret = h2c_pkt_drop(adapter, info, role, NULL);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_BAND_ONCE:
+			ret = band_pkt_drop(adapter, info, 1);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_BAND:
+			ret = band_pkt_drop(adapter, info, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_HIQ_ONCE:
+		case MAC_AX_PKT_DROP_SEL_MG0_ONCE:
+			ret = h2c_pkt_drop(adapter, info, NULL, NULL);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_HIQ_PORT:
+		case MAC_AX_PKT_DROP_SEL_HIQ_MBSSID:
+			ret = hiq_drop_ctrl(adapter, info, MAC_AX_FUNC_EN);
+			if (ret != MACSUCCESS)
+				return ret;
+			ret = h2c_pkt_drop(adapter, info, NULL, NULL);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_REL_MACID:
+			rel_dmac_macid_drop(adapter, info->macid);
+			rel_cmac_macid_drop(adapter, info->macid);
+			break;
+		case MAC_AX_PKT_DROP_SEL_REL_HIQ_PORT:
+		case MAC_AX_PKT_DROP_SEL_REL_HIQ_MBSSID:
+			ret = rel_hiq_drop(adapter, info);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		default:
+			return MACNOITEM;
+		}
+	} else {
+		switch (info->sel) {
+		case MAC_AX_PKT_DROP_SEL_MACID_BE_ONCE:
+			ret = ac_pkt_drop(adapter, info->macid, PKT_DROP_BE);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_MACID_BK_ONCE:
+			ret = ac_pkt_drop(adapter, info->macid, PKT_DROP_BK);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_MACID_VI_ONCE:
+			ret = ac_pkt_drop(adapter, info->macid, PKT_DROP_VI);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_MACID_VO_ONCE:
+			ret = ac_pkt_drop(adapter, info->macid, PKT_DROP_VO);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_MACID_ALL:
+			ret = macid_pkt_drop_all(adapter, info->macid);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_BAND_ONCE:
+			ret = band_pkt_drop(adapter, info, 1);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_BAND:
+			ret = band_pkt_drop(adapter, info, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_REL_MACID:
+			rel_dmac_macid_drop(adapter, info->macid);
+			rel_cmac_macid_drop(adapter, info->macid);
+			break;
+		case MAC_AX_PKT_DROP_SEL_REL_HIQ_PORT:
+		case MAC_AX_PKT_DROP_SEL_REL_HIQ_MBSSID:
+			ret = rel_hiq_drop(adapter, info);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_HIQ_ONCE:
+		case MAC_AX_PKT_DROP_SEL_MG0_ONCE:
+			ret = hw_link_drop(adapter, info);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		case MAC_AX_PKT_DROP_SEL_HIQ_PORT:
+		case MAC_AX_PKT_DROP_SEL_HIQ_MBSSID:
+			ret = set_hiq_drop(adapter, info);
+			if (ret != MACSUCCESS)
+				return ret;
+			break;
+		default:
+			return MACNOITEM;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 band_pkt_drop(struct mac_ax_adapter *adapter,
+			 struct mac_ax_pkt_drop_info *info, u8 once)
+{
+	u32 ret;
+	u32 qid;
+	u8 band = info->band;
+	u8 macid_grp_num = MAX_MACID_NUM >> 5;
+	u32 macid_band_sel[MAX_MACID_NUM >> 5] = {0};
+	u32 macid_ctrl_sel[MAX_MACID_NUM >> 5] = {0};
+	u32 macid_pause_bak[MAX_MACID_NUM >> 5] = {0};
+	u32 macid_sleep_bak[MAX_MACID_NUM >> 5] = {0};
+	u8 i_u8;
+	u16 i_u16;
+	u8 macid_grp;
+	u8 macid_sh;
+	u16 macid_num = adapter->hw_info->macid_num;
+	struct mac_role_tbl *role;
+	struct deq_enq_info q_info;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_sch_tx_en_cfg sch_backup;
+	struct mac_ax_tb_ppdu_ctrl ac_dis_bak;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	PLTFM_MEMSET(&q_info, 0, sizeof(struct deq_enq_info));
+
+	for (i_u16 = 0; i_u16 < macid_num; i_u16++) {
+		role = mac_role_srch(adapter, (u8)i_u16);
+		if (role) {
+			macid_sh = i_u16 & (32 - 1);
+			macid_grp = i_u16 >> 5;
+			if (role->info.band)
+				macid_band_sel[macid_grp] |= BIT(macid_sh);
+			else
+				macid_band_sel[macid_grp] &= ~(BIT(macid_sh));
+		}
+	}
+
+	if (once == 0) {
+		if (chk_patch_dmac_macid_drop_issue(adapter) == PATCH_ENABLE) {
+			PLTFM_MSG_TRACE("[TRACE]:do not support DMAC drop\n");
+		} else {
+			MAC_REG_W32(R_AX_DMAC_MACID_DROP_0,
+				    MAC_REG_R32(R_AX_DMAC_MACID_DROP_0) |
+				    macid_ctrl_sel[0]);
+			MAC_REG_W32(R_AX_DMAC_MACID_DROP_1,
+				    MAC_REG_R32(R_AX_DMAC_MACID_DROP_1) |
+				    macid_ctrl_sel[1]);
+			MAC_REG_W32(R_AX_DMAC_MACID_DROP_2,
+				    MAC_REG_R32(R_AX_DMAC_MACID_DROP_2) |
+				    macid_ctrl_sel[2]);
+			MAC_REG_W32(R_AX_DMAC_MACID_DROP_3,
+				    MAC_REG_R32(R_AX_DMAC_MACID_DROP_3) |
+				    macid_ctrl_sel[3]);
+		}
+	}
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = h2c_pkt_drop(adapter, info, NULL, macid_band_sel);
+		if (ret != MACSUCCESS)
+			return ret;
+	} else {
+		if (band == MAC_AX_BAND_1) {
+			for (i_u8 = 0; i_u8 < macid_grp_num; i_u8++)
+				macid_ctrl_sel[i_u8] = macid_band_sel[i_u8];
+		} else {
+			for (i_u8 = 0; i_u8 < macid_grp_num; i_u8++)
+				macid_ctrl_sel[i_u8] = ~macid_band_sel[i_u8];
+		}
+
+		/* TBD, pause H2C in val, mask format, Soar, 20200109 */
+
+		macid_sleep_bak[0] = MAC_REG_R32(R_AX_MACID_SLEEP_0);
+		MAC_REG_W32(R_AX_MACID_SLEEP_0, macid_sleep_bak[0] | macid_ctrl_sel[0]);
+		macid_pause_bak[0] = MAC_REG_R32(R_AX_SS_MACID_PAUSE_0);
+		MAC_REG_W32(R_AX_SS_MACID_PAUSE_0, macid_pause_bak[0] |
+				macid_ctrl_sel[0]);
+		macid_sleep_bak[1] = MAC_REG_R32(R_AX_MACID_SLEEP_1);
+		MAC_REG_W32(R_AX_MACID_SLEEP_1, macid_sleep_bak[1] | macid_ctrl_sel[1]);
+		macid_pause_bak[1] = MAC_REG_R32(R_AX_SS_MACID_PAUSE_1);
+		MAC_REG_W32(R_AX_SS_MACID_PAUSE_1, macid_pause_bak[1] |
+				macid_ctrl_sel[1]);
+		macid_sleep_bak[2] = MAC_REG_R32(R_AX_MACID_SLEEP_2);
+		MAC_REG_W32(R_AX_MACID_SLEEP_2, macid_sleep_bak[2] | macid_ctrl_sel[2]);
+		macid_pause_bak[2] = MAC_REG_R32(R_AX_SS_MACID_PAUSE_2);
+		MAC_REG_W32(R_AX_SS_MACID_PAUSE_2, macid_pause_bak[2] |
+				macid_ctrl_sel[2]);
+		macid_sleep_bak[3] = MAC_REG_R32(R_AX_MACID_SLEEP_3);
+		MAC_REG_W32(R_AX_MACID_SLEEP_3, macid_sleep_bak[3] | macid_ctrl_sel[3]);
+		macid_pause_bak[3] = MAC_REG_R32(R_AX_SS_MACID_PAUSE_3);
+		MAC_REG_W32(R_AX_SS_MACID_PAUSE_3, macid_pause_bak[3] |
+				macid_ctrl_sel[3]);
+
+		sch_backup.band = band;
+		ret = p_ops->stop_sch_tx(adapter, SCH_TX_SEL_ALL, &sch_backup);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		ac_dis_bak.band = band;
+		ret = stop_ac_tb_tx(adapter, TB_STOP_SEL_ALL, &ac_dis_bak);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		ret = tx_idle_poll_band(adapter, band);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		q_info.dst_pid = WDE_DLE_PID_WDRLS;
+		q_info.dst_qid = WDE_DLE_QID_WDRLS_DROP;
+		q_info.src_pid =
+			(band == MAC_AX_BAND_1) ? WDE_DLE_PID_C1 : WDE_DLE_PID_C0;
+
+		if (band == MAC_AX_BAND_1) {
+			for (qid = WDE_DLE_QID_BCN_C1; qid <= WDE_DLE_QID_MG2_C1;
+					qid++) {
+				if (qid == WDE_DLE_QID_HI_C1) {
+					ret = hiq_link_drop(adapter, info);
+					if (ret != MACSUCCESS)
+						return ret;
+				} else {
+					q_info.src_qid = (u8)qid;
+					ret = deq_enq_all(adapter, &q_info);
+					if (ret != MACSUCCESS)
+						return ret;
+				}
+			}
+		} else {
+			for (qid = WDE_DLE_QID_BCN_C0; qid <= WDE_DLE_QID_MG2_C0;
+					qid++) {
+				if (qid == WDE_DLE_QID_HI_C0) {
+					ret = hiq_link_drop(adapter, info);
+					if (ret != MACSUCCESS)
+						return ret;
+				} else {
+					q_info.src_qid = (u8)qid;
+					ret = deq_enq_all(adapter, &q_info);
+					if (ret != MACSUCCESS)
+						return ret;
+				}
+			}
+		}
+
+		for (i_u16 = 0; i_u16 < macid_num; i_u16++) {
+			macid_grp = i_u16 >> 5;
+			if (macid_ctrl_sel[macid_grp] & BIT(i_u16 & 31)) {
+				q_info.macid = (u8)i_u16;
+				q_info.src_pid = WDE_DLE_PID_C0;
+				q_info.dst_pid = WDE_DLE_PID_WDRLS;
+				q_info.dst_qid = WDE_DLE_QID_WDRLS_DROP;
+
+				for (qid = WDE_DLE_QID_BE;
+						qid <= WDE_DLE_QID_VO; qid++) {
+					q_info.src_qid = (u8)qid;
+					ret = deq_enq_all(adapter, &q_info);
+					if (ret != MACSUCCESS)
+						return ret;
+				}
+			}
+		}
+
+		PLTFM_DELAY_MS(1);
+		ss_hw_len_udn_clr(adapter);
+
+		/* TBD, pause H2C in val, mask format, Soar, 20200109 */
+
+		MAC_REG_W32(R_AX_MACID_SLEEP_0, macid_sleep_bak[0]);
+		MAC_REG_W32(R_AX_SS_MACID_PAUSE_0, macid_pause_bak[0]);
+		MAC_REG_W32(R_AX_MACID_SLEEP_1, macid_sleep_bak[1]);
+		MAC_REG_W32(R_AX_SS_MACID_PAUSE_1, macid_pause_bak[1]);
+		MAC_REG_W32(R_AX_MACID_SLEEP_2, macid_sleep_bak[2]);
+		MAC_REG_W32(R_AX_SS_MACID_PAUSE_2, macid_pause_bak[2]);
+		MAC_REG_W32(R_AX_MACID_SLEEP_3, macid_sleep_bak[3]);
+		MAC_REG_W32(R_AX_SS_MACID_PAUSE_3, macid_pause_bak[3]);
+
+		ret = resume_sch_tx(adapter, &sch_backup);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		ret = set_hw_tb_ppdu_ctrl(adapter, &ac_dis_bak);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+
+	return ret;
+}
+
+static u32 hw_link_drop(struct mac_ax_adapter *adapter,
+			struct mac_ax_pkt_drop_info *info)
+{
+	u32 ret;
+	u8 band = info->band;
+	struct mac_ax_sch_tx_en_cfg sch_backup;
+	enum ptcl_tx_sel ptcl_sel;
+	enum sch_tx_sel sch_sel;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	switch (info->sel) {
+	case MAC_AX_PKT_DROP_SEL_MG0_ONCE:
+		ptcl_sel = PTCL_TX_SEL_MG0;
+		sch_sel = SCH_TX_SEL_MG0;
+		break;
+	case MAC_AX_PKT_DROP_SEL_HIQ_ONCE:
+		ptcl_sel = PTCL_TX_SEL_HIQ;
+		sch_sel = SCH_TX_SEL_HIQ;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	sch_backup.band = band;
+	ret = p_ops->stop_sch_tx(adapter, sch_sel, &sch_backup);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = tx_idle_poll_sel(adapter, ptcl_sel, band);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	switch (info->sel) {
+	case MAC_AX_PKT_DROP_SEL_MG0_ONCE:
+		ret = mg0_link_drop(adapter, band);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_PKT_DROP_SEL_HIQ_ONCE:
+		ret = hiq_link_drop(adapter, info);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	ret = resume_sch_tx(adapter, &sch_backup);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return ret;
+}
+
+static u32 macid_pkt_drop_all(struct mac_ax_adapter *adapter, u8 macid)
+{
+	u32 ret;
+	u32 qid;
+	struct deq_enq_info info;
+	struct macid_tx_bak bak;
+	struct mac_role_tbl *role;
+
+	PLTFM_MEMSET(&info, 0, sizeof(struct deq_enq_info));
+
+	role = mac_role_srch(adapter, macid);
+	if (!role) {
+		PLTFM_MSG_ERR("[ERR]:role info is null\n");
+		return MACNOITEM;
+	}
+
+	ret = stop_macid_tx(adapter, role, TB_STOP_SEL_ALL, &bak);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	set_dmac_macid_drop(adapter, macid);
+	set_cmac_macid_drop(adapter, macid);
+
+	ret = tx_idle_poll_macid(adapter, role);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	info.macid = macid;
+	info.src_pid = WDE_DLE_PID_C0;
+	info.dst_pid = WDE_DLE_PID_WDRLS;
+	info.dst_qid = WDE_DLE_QID_WDRLS_DROP;
+
+	for (qid = WDE_DLE_QID_BE; qid <= WDE_DLE_QID_VO; qid++) {
+		info.src_qid = (u8)qid;
+		ret = deq_enq_all(adapter, &info);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+
+	ret = resume_macid_tx(adapter, role, &bak);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return ret;
+}
+
+static u32 h2c_pkt_drop(struct mac_ax_adapter *adapter,
+			struct mac_ax_pkt_drop_info *info,
+			struct mac_role_tbl *role,
+			u32 *macid_band_sel)
+{
+	u32 ret = 0;
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_pkt_drop *drop;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_pkt_drop));
+	if (!buf) {
+		ret = MACNOBUF;
+		/* goto fail; */
+		if (ret)
+			goto fail;
+	}
+	PLTFM_MEMSET(buf, 0, sizeof(struct fwcmd_pkt_drop));
+
+	drop = (struct fwcmd_pkt_drop *)buf;
+
+	if (role) {
+		drop->dword0 =
+		cpu_to_le32(SET_WORD(info->sel, FWCMD_H2C_PKT_DROP_DROP_SEL) |
+			    SET_WORD(role->macid, FWCMD_H2C_PKT_DROP_MACID) |
+			    SET_WORD(role->info.band, FWCMD_H2C_PKT_DROP_BAND) |
+			    SET_WORD(info->port, FWCMD_H2C_PKT_DROP_PORT));
+		drop->dword1 =
+		cpu_to_le32(SET_WORD(info->mbssid,
+				     FWCMD_H2C_PKT_DROP_MBSSID) |
+			    SET_WORD(role->info.a_info.tf_trs,
+				     FWCMD_H2C_PKT_DROP_ROLE_A_INFO_TF_TRS));
+	} else {
+		drop->dword0 =
+		cpu_to_le32(SET_WORD(info->sel, FWCMD_H2C_PKT_DROP_DROP_SEL) |
+			    SET_WORD(info->macid, FWCMD_H2C_PKT_DROP_MACID) |
+			    SET_WORD(info->band, FWCMD_H2C_PKT_DROP_BAND) |
+			    SET_WORD(info->port, FWCMD_H2C_PKT_DROP_PORT));
+		drop->dword1 =
+		cpu_to_le32(SET_WORD(info->mbssid,
+				     FWCMD_H2C_PKT_DROP_MBSSID));
+	}
+	if (macid_band_sel) {
+		drop->dword2 =
+		cpu_to_le32(SET_WORD(macid_band_sel[0],
+				     FWCMD_H2C_PKT_DROP_MACID_BAND_SEL_0));
+		drop->dword3 =
+		cpu_to_le32(SET_WORD(macid_band_sel[1],
+				     FWCMD_H2C_PKT_DROP_MACID_BAND_SEL_1));
+		drop->dword4 =
+		cpu_to_le32(SET_WORD(macid_band_sel[2],
+				     FWCMD_H2C_PKT_DROP_MACID_BAND_SEL_2));
+		drop->dword5 =
+		cpu_to_le32(SET_WORD(macid_band_sel[3],
+				     FWCMD_H2C_PKT_DROP_MACID_BAND_SEL_3));
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_PKT_DROP,
+			      0, 0);
+
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 ac_pkt_drop(struct mac_ax_adapter *adapter, u8 macid,
+		       enum pkt_drop_ac ac)
+{
+	u32 ret;
+	struct deq_enq_info info;
+	struct mac_role_tbl *role;
+	enum tb_stop_sel stop_sel;
+	struct macid_tx_bak bak;
+
+	PLTFM_MEMSET(&info, 0, sizeof(struct deq_enq_info));
+
+	role = mac_role_srch(adapter, macid);
+	if (!role) {
+		PLTFM_MSG_ERR("[ERR]:role info is null\n");
+		return MACNOITEM;
+	}
+
+	switch (ac) {
+	case PKT_DROP_BE:
+		stop_sel = TB_STOP_SEL_BE;
+		break;
+	case PKT_DROP_BK:
+		stop_sel = TB_STOP_SEL_BK;
+		break;
+	case PKT_DROP_VI:
+		stop_sel = TB_STOP_SEL_VI;
+		break;
+	case PKT_DROP_VO:
+		stop_sel = TB_STOP_SEL_VO;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	ret = stop_macid_tx(adapter, role, stop_sel, &bak);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = tx_idle_poll_macid(adapter, role);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	info.macid = macid;
+	info.src_pid = WDE_DLE_PID_C0;
+	info.src_qid = ac;
+	info.dst_pid = WDE_DLE_PID_WDRLS;
+	info.dst_qid = WDE_DLE_QID_WDRLS_DROP;
+
+	ret = deq_enq_all(adapter, &info);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = resume_macid_tx(adapter, role, &bak);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return ret;
+}
+
+static u32 deq_enq_to_tail(struct mac_ax_adapter *adapter,
+			   struct deq_enq_info *info)
+{
+	struct cpuio_ctrl_t cpuio;
+	u32 ret;
+
+	PLTFM_MEMSET(&cpuio, 0, sizeof(struct cpuio_ctrl_t));
+
+	cpuio.cmd_type = CPUIO_OP_CMD_DEQ_ENQ_TO_TAIL;
+	cpuio.macid = info->macid;
+	cpuio.pkt_num = 0;
+	cpuio.src_pid = info->src_pid;
+	cpuio.src_qid = info->src_qid;
+	cpuio.dst_pid = info->dst_pid;
+	cpuio.dst_qid = info->dst_qid;
+	cpuio.start_pktid = info->pktid;
+	cpuio.end_pktid = info->pktid;
+
+	ret = mac_set_cpuio_wd(adapter, &cpuio);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 deq_enq_all(struct mac_ax_adapter *adapter, struct deq_enq_info *info)
+{
+	struct cpuio_ctrl_t cpuio;
+	struct first_pid_info pktid_info;
+	u32 ret;
+
+	PLTFM_MEMSET(&cpuio, 0, sizeof(struct cpuio_ctrl_t));
+
+	pktid_info.macid = info->macid;
+	pktid_info.src_pid = info->src_pid;
+	pktid_info.src_qid = info->src_qid;
+
+	ret = get_1st_pktid(adapter, &pktid_info);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (pktid_info.pktid != 0xFFF) {
+		cpuio.cmd_type = CPUIO_OP_CMD_DEQ_ENQ_ALL;
+		cpuio.macid = info->macid;
+		cpuio.src_pid = info->src_pid;
+		cpuio.src_qid = info->src_qid;
+		cpuio.dst_pid = info->dst_pid;
+		cpuio.dst_qid = info->dst_qid;
+
+		ret = mac_set_cpuio_wd(adapter, &cpuio);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 get_1st_pktid(struct mac_ax_adapter *adapter,
+			 struct first_pid_info *info)
+{
+	u32 ret = MACSUCCESS;
+	struct cpuio_ctrl_t cpuio;
+
+	PLTFM_MEMSET(&cpuio, 0, sizeof(struct cpuio_ctrl_t));
+
+	cpuio.cmd_type = CPUIO_OP_CMD_GET_1ST_PID;
+	cpuio.macid = info->macid;
+	cpuio.src_pid = info->src_pid;
+	cpuio.src_qid = info->src_qid;
+	ret = mac_set_cpuio_wd(adapter, &cpuio);
+
+	info->pktid = cpuio.pktid;
+
+	return ret;
+}
+
+static u32 get_next_pktid(struct mac_ax_adapter *adapter,
+			  struct next_pid_info *info)
+{
+	u32 ret = MACSUCCESS;
+	struct cpuio_ctrl_t cpuio;
+
+	PLTFM_MEMSET(&cpuio, 0, sizeof(struct cpuio_ctrl_t));
+
+	cpuio.cmd_type = CPUIO_OP_CMD_GET_NEXT_PID;
+	cpuio.macid = info->macid;
+	cpuio.src_pid = info->src_pid;
+	cpuio.src_qid = info->src_qid;
+	cpuio.start_pktid = info->start_pktid;
+	ret = mac_set_cpuio_wd(adapter, &cpuio);
+
+	info->pktid = cpuio.pktid;
+
+	return ret;
+}
+
+static void set_dmac_macid_drop(struct mac_ax_adapter *adapter, u8 macid)
+{
+	u32 val32;
+	u8 macid_sh = macid & (32 - 1);
+	u8 macid_grp = macid >> 5;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (chk_patch_dmac_macid_drop_issue(adapter) == PATCH_ENABLE) {
+		PLTFM_MSG_TRACE("hw do not support dmac drop!\n");
+		return;
+	}
+
+	if (MAC_REG_R32(R_AX_SS_DBG_3) & B_AX_SS_HW_DECR_LEN_UDN)
+		PLTFM_MSG_WARN("STA len underflow bef drop\n");
+
+	switch (macid_grp) {
+	case 0:
+		val32 = MAC_REG_R32(R_AX_DMAC_MACID_DROP_0);
+		MAC_REG_W32(R_AX_DMAC_MACID_DROP_0, val32 | BIT(macid_sh));
+		break;
+	case 1:
+		val32 = MAC_REG_R32(R_AX_DMAC_MACID_DROP_1);
+		MAC_REG_W32(R_AX_DMAC_MACID_DROP_1, val32 | BIT(macid_sh));
+		break;
+	case 2:
+		val32 = MAC_REG_R32(R_AX_DMAC_MACID_DROP_2);
+		MAC_REG_W32(R_AX_DMAC_MACID_DROP_2, val32 | BIT(macid_sh));
+		break;
+	case 3:
+		val32 = MAC_REG_R32(R_AX_DMAC_MACID_DROP_3);
+		MAC_REG_W32(R_AX_DMAC_MACID_DROP_3, val32 | BIT(macid_sh));
+		break;
+	default:
+		break;
+	}
+}
+
+static void set_cmac_macid_drop(struct mac_ax_adapter *adapter, u8 macid)
+{
+	u32 val32;
+	u8 macid_sh = macid & (32 - 1);
+	u8 macid_grp = macid >> 5;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (macid_grp) {
+	case 0:
+		val32 = MAC_REG_R32(R_AX_CMAC_MACID_DROP_0);
+		MAC_REG_W32(R_AX_CMAC_MACID_DROP_0, val32 | BIT(macid_sh));
+		break;
+	case 1:
+		val32 = MAC_REG_R32(R_AX_CMAC_MACID_DROP_1);
+		MAC_REG_W32(R_AX_CMAC_MACID_DROP_1, val32 | BIT(macid_sh));
+		break;
+	case 2:
+		val32 = MAC_REG_R32(R_AX_CMAC_MACID_DROP_2);
+		MAC_REG_W32(R_AX_CMAC_MACID_DROP_2, val32 | BIT(macid_sh));
+		break;
+	case 3:
+		val32 = MAC_REG_R32(R_AX_CMAC_MACID_DROP_3);
+		MAC_REG_W32(R_AX_CMAC_MACID_DROP_3, val32 | BIT(macid_sh));
+		break;
+	default:
+		break;
+	}
+}
+
+static void rel_dmac_macid_drop(struct mac_ax_adapter *adapter, u8 macid)
+{
+	u32 val32;
+	u8 macid_sh = macid & (32 - 1);
+	u8 macid_grp = macid >> 5;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (macid_grp) {
+	case 0:
+		val32 = MAC_REG_R32(R_AX_DMAC_MACID_DROP_0);
+		MAC_REG_W32(R_AX_DMAC_MACID_DROP_0, val32 & ~(BIT(macid_sh)));
+		break;
+	case 1:
+		val32 = MAC_REG_R32(R_AX_DMAC_MACID_DROP_1);
+		MAC_REG_W32(R_AX_DMAC_MACID_DROP_1, val32 & ~(BIT(macid_sh)));
+		break;
+	case 2:
+		val32 = MAC_REG_R32(R_AX_DMAC_MACID_DROP_2);
+		MAC_REG_W32(R_AX_DMAC_MACID_DROP_2, val32 & ~(BIT(macid_sh)));
+		break;
+	case 3:
+		val32 = MAC_REG_R32(R_AX_DMAC_MACID_DROP_3);
+		MAC_REG_W32(R_AX_DMAC_MACID_DROP_3, val32 & ~(BIT(macid_sh)));
+		break;
+	default:
+		break;
+	}
+
+	ss_hw_len_udn_clr(adapter);
+}
+
+static void rel_cmac_macid_drop(struct mac_ax_adapter *adapter, u8 macid)
+{
+	u32 val32;
+	u8 macid_sh = macid & (32 - 1);
+	u8 macid_grp = macid >> 5;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (macid_grp) {
+	case 0:
+		val32 = MAC_REG_R32(R_AX_CMAC_MACID_DROP_0);
+		MAC_REG_W32(R_AX_CMAC_MACID_DROP_0, val32 & ~(BIT(macid_sh)));
+		break;
+	case 1:
+		val32 = MAC_REG_R32(R_AX_CMAC_MACID_DROP_1);
+		MAC_REG_W32(R_AX_CMAC_MACID_DROP_1, val32 & ~(BIT(macid_sh)));
+		break;
+	case 2:
+		val32 = MAC_REG_R32(R_AX_CMAC_MACID_DROP_2);
+		MAC_REG_W32(R_AX_CMAC_MACID_DROP_2, val32 & ~(BIT(macid_sh)));
+		break;
+	case 3:
+		val32 = MAC_REG_R32(R_AX_CMAC_MACID_DROP_3);
+		MAC_REG_W32(R_AX_CMAC_MACID_DROP_3, val32 & ~(BIT(macid_sh)));
+		break;
+	default:
+		break;
+	}
+}
+
+static u32 hiq_drop_ctrl(struct mac_ax_adapter *adapter,
+			 struct mac_ax_pkt_drop_info *info, u8 drop_en)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 addr, ret;
+	u16 mbssid_sh;
+	u8 port_sh;
+
+	if (chk_patch_cmac_hiq_drop(adapter) == PATCH_ENABLE) {
+		PLTFM_MSG_TRACE("hw do not support cmac hiq drop!\n");
+		return MACSUCCESS;
+	}
+
+	ret = check_mac_en(adapter, info->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	addr = info->band ? R_AX_MBSSID_DROP_0_C1 : R_AX_MBSSID_DROP_0;
+	mbssid_sh = 1 << info->mbssid;
+	port_sh = 1 << info->port;
+
+	val32 = MAC_REG_R32(addr);
+	switch (info->sel) {
+	case MAC_AX_PKT_DROP_SEL_HIQ_PORT:
+	case MAC_AX_PKT_DROP_SEL_REL_HIQ_PORT:
+		val32 = drop_en == MAC_AX_FUNC_EN ?
+			(val32 | port_sh << B_AX_PORT_DROP_4_0_SH) :
+			(val32 & ~(port_sh << B_AX_PORT_DROP_4_0_SH));
+		if (info->port == 0)
+			val32 = drop_en == MAC_AX_FUNC_EN ?
+				(val32 | BIT(0)) : (val32 & ~BIT(0));
+		break;
+	case MAC_AX_PKT_DROP_SEL_HIQ_MBSSID:
+	case MAC_AX_PKT_DROP_SEL_REL_HIQ_MBSSID:
+		val32 = drop_en == MAC_AX_FUNC_EN ?
+			(val32 | mbssid_sh) : (val32 & ~mbssid_sh);
+		break;
+	default:
+		return MACNOITEM;
+	}
+	MAC_REG_W32(addr, val32);
+
+	return MACSUCCESS;
+}
+
+static u32 set_hiq_drop(struct mac_ax_adapter *adapter,
+			struct mac_ax_pkt_drop_info *info)
+{
+	u32 ret;
+	u8 band = info->band;
+	enum ptcl_tx_sel ptcl_sel;
+	enum sch_tx_sel sch_sel;
+	struct mac_ax_sch_tx_en_cfg sch_backup;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	ret = hiq_drop_ctrl(adapter, info, MAC_AX_FUNC_EN);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ptcl_sel = PTCL_TX_SEL_HIQ;
+	sch_sel = SCH_TX_SEL_HIQ;
+
+	sch_backup.band = band;
+	ret = p_ops->stop_sch_tx(adapter, sch_sel, &sch_backup);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = tx_idle_poll_sel(adapter, ptcl_sel, band);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = hiq_link_drop(adapter, info);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = resume_sch_tx(adapter, &sch_backup);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+static u32 rel_hiq_drop(struct mac_ax_adapter *adapter,
+			struct mac_ax_pkt_drop_info *info)
+{
+	u32 ret;
+
+	ret = hiq_drop_ctrl(adapter, info, MAC_AX_FUNC_DIS);
+	return ret;
+}
+
+static void ss_hw_len_udn_clr(struct mac_ax_adapter *adapter)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_SS_DBG_3);
+	if (val32 & B_AX_SS_HW_DECR_LEN_UDN) {
+		val32 &= ~(B_AX_SS_HW_ADD_LEN_OVF | B_AX_SS_SW_DECR_LEN_UDN |
+			 B_AX_SS_HW_DECR_LEN_UDN | B_AX_SS_ATM_ERR |
+			 B_AX_SS_DEL_STA_ERR | B_AX_SS_ADD_STA_ERR);
+		MAC_REG_W32(R_AX_SS_DBG_3, val32 | B_AX_SS_HW_DECR_LEN_UDN);
+	}
+}
+
+#if MAC_AX_8852A_SUPPORT ||  MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+static u32 _hiq_drop_v0(struct mac_ax_adapter *adapter,
+			struct mac_ax_pkt_drop_info *info)
+{
+	u32 ret, indrct_offset, wdi_dword0, wdi_port;
+	u16 tmp_pktid;
+	u8 band = info->band;
+	struct deq_enq_info q_info;
+	struct first_pid_info f_info;
+	struct next_pid_info n_info;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	PLTFM_MEMSET(&q_info, 0, sizeof(struct deq_enq_info));
+
+	q_info.dst_pid = WDE_DLE_PID_WDRLS;
+	q_info.dst_qid = WDE_DLE_QID_WDRLS_DROP;
+	if (band == MAC_AX_BAND_1) {
+		q_info.src_pid = WDE_DLE_PID_C1;
+		q_info.src_qid = WDE_DLE_QID_HI_C1;
+	} else {
+		q_info.src_pid = WDE_DLE_PID_C0;
+		q_info.src_qid = WDE_DLE_QID_HI_C0;
+	}
+	switch (info->sel) {
+	case MAC_AX_PKT_DROP_SEL_HIQ_PORT:
+		f_info.src_pid = q_info.src_pid;
+		n_info.src_pid = q_info.src_pid;
+		f_info.src_qid = q_info.src_qid;
+		n_info.src_qid = q_info.src_qid;
+		f_info.macid = 0;
+		n_info.macid = 0;
+		ret = get_1st_pktid(adapter, &f_info);
+		if (ret != MACSUCCESS || f_info.pktid == 0xFFF)
+			return ret;
+		tmp_pktid = f_info.pktid;
+		do {
+			n_info.start_pktid = tmp_pktid;
+			ret = get_next_pktid(adapter, &n_info);
+			if (ret != MACSUCCESS)
+				return ret;
+			indrct_offset = ((u32)tmp_pktid << 15) + (u32)WD_BODY_LEN;
+			wdi_dword0 = mac_sram_dbg_read(adapter, indrct_offset,
+						       WD_PAGE_SEL);
+			wdi_port = GET_FIELD(le32_to_cpu(wdi_dword0),
+					     AX_TXD_MULTIPORT_ID);
+			if (info->port == wdi_port) {
+				q_info.pktid = tmp_pktid;
+				ret = deq_enq_to_tail(adapter, &q_info);
+				if (ret != MACSUCCESS)
+					return ret;
+			}
+			tmp_pktid = n_info.pktid;
+		} while (n_info.pktid != 0xFFF);
+		break;
+	case MAC_AX_PKT_DROP_SEL_HIQ_MBSSID:
+		break;
+	case MAC_AX_PKT_DROP_SEL_HIQ_ONCE:
+	case MAC_AX_PKT_DROP_SEL_BAND:
+	case MAC_AX_PKT_DROP_SEL_BAND_ONCE:
+		ret = deq_enq_all(adapter, &q_info);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	default:
+		return MACNOTSUP;
+	}
+
+	return MACSUCCESS;
+}
+#endif
+
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+static u32 _hiq_drop_v1(struct mac_ax_adapter *adapter,
+			struct mac_ax_pkt_drop_info *info)
+{
+	u32 ret;
+	u8 mbid, port, mbssid_num, port_num;
+	u8 band = info->band;
+	struct deq_enq_info q_info;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	mbssid_num = adapter->hw_info->mbssid_num;
+	port_num = adapter->hw_info->port_num;
+
+	PLTFM_MEMSET(&q_info, 0, sizeof(struct deq_enq_info));
+
+	q_info.dst_pid = WDE_DLE_PID_WDRLS;
+	q_info.dst_qid = WDE_DLE_QID_WDRLS_DROP;
+	if (band == MAC_AX_BAND_1) {
+		q_info.src_pid = WDE_DLE_PID_C1;
+		q_info.src_qid = WDE_DLE_QID_HI_C1;
+	} else {
+		q_info.src_pid = WDE_DLE_PID_C0;
+		q_info.src_qid = WDE_DLE_QID_HI_C0;
+	}
+	switch (info->sel) {
+	case MAC_AX_PKT_DROP_SEL_HIQ_PORT:
+		if (info->port == 0) {
+			for (mbid = 0; mbid < mbssid_num; mbid++) {
+				q_info.macid = mbid;
+				ret = deq_enq_all(adapter, &q_info);
+				if (ret != MACSUCCESS)
+					return ret;
+			}
+		} else {
+			q_info.macid = info->port <<
+					WDE_DLE_SUBQID_PORT_SH;
+			ret = deq_enq_all(adapter, &q_info);
+			if (ret != MACSUCCESS)
+				return ret;
+		}
+		break;
+	case MAC_AX_PKT_DROP_SEL_HIQ_MBSSID:
+		q_info.macid = info->mbssid;
+		ret = deq_enq_all(adapter, &q_info);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_PKT_DROP_SEL_HIQ_ONCE:
+	case MAC_AX_PKT_DROP_SEL_BAND:
+	case MAC_AX_PKT_DROP_SEL_BAND_ONCE:
+		for (mbid = 0; mbid < mbssid_num; mbid++) {
+			q_info.macid = mbid;
+			ret = deq_enq_all(adapter, &q_info);
+			if (ret != MACSUCCESS)
+				return ret;
+		}
+		for (port = 1; port < port_num; port++) {
+			q_info.macid = port << WDE_DLE_SUBQID_PORT_SH;
+			ret = deq_enq_all(adapter, &q_info);
+			if (ret != MACSUCCESS)
+				return ret;
+		}
+		break;
+	default:
+		return MACNOTSUP;
+	}
+
+	return MACSUCCESS;
+}
+#endif
+
+static u32 hiq_link_drop(struct mac_ax_adapter *adapter,
+			 struct mac_ax_pkt_drop_info *info)
+{
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u32 ret;
+
+	switch (hw_info->chip_id) {
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	case MAC_AX_CHIP_ID_8852A:
+	case MAC_AX_CHIP_ID_8852B:
+	case MAC_AX_CHIP_ID_8851B:
+		ret = _hiq_drop_v0(adapter, info);
+		break;
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	case MAC_AX_CHIP_ID_8852C:
+	case MAC_AX_CHIP_ID_8192XB:
+	case MAC_AX_CHIP_ID_8851E:
+	case MAC_AX_CHIP_ID_8852D:
+		ret = _hiq_drop_v1(adapter, info);
+		break;
+#endif
+	default:
+		ret = MACNOTSUP;
+		break;
+	}
+	return ret;
+}
+
+static u32 mg0_link_drop(struct mac_ax_adapter *adapter, u8 band)
+{
+	u32 ret;
+	struct deq_enq_info q_info;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	PLTFM_MEMSET(&q_info, 0, sizeof(struct deq_enq_info));
+
+	q_info.dst_pid = WDE_DLE_PID_WDRLS;
+	q_info.dst_qid = WDE_DLE_QID_WDRLS_DROP;
+	if (band == MAC_AX_BAND_1) {
+		q_info.src_pid = WDE_DLE_PID_C1;
+		q_info.src_qid = WDE_DLE_QID_MG0_C1;
+	} else {
+		q_info.src_pid = WDE_DLE_PID_C0;
+		q_info.src_qid = WDE_DLE_QID_MG0_C0;
+	}
+
+	ret = deq_enq_all(adapter, &q_info);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return ret;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cpuio.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cpuio.h
new file mode 100644
index 000000000000..5cab9a4b4dae
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/cpuio.h
@@ -0,0 +1,719 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_CPUIO_H_
+#define _MAC_AX_CPUIO_H_
+
+#include "../type.h"
+#include "trxcfg.h"
+#include "role.h"
+#include "hw.h"
+
+/*--------------------Define ----------------------------------------*/
+#define WDE_DLE_PID_C0 3
+#define WDE_DLE_PID_C1 4
+#define WDE_DLE_PID_WDRLS 7
+#define WDE_DLE_QID_BE 0
+#define WDE_DLE_QID_BK 1
+#define WDE_DLE_QID_VI 2
+#define WDE_DLE_QID_VO 3
+#define WDE_DLE_QID_WDRLS_DROP 3
+#define WDE_DLE_QID_BCN_C0 0x10
+#define WDE_DLE_QID_HI_C0 0x11
+#define WDE_DLE_QID_MG0_C0 0x12
+#define WDE_DLE_QID_MG1_C0 0x13
+#define WDE_DLE_QID_MG2_C0 0x14
+#define WDE_DLE_QID_BCN_C1 0x18
+#define WDE_DLE_QID_HI_C1 0x19
+#define WDE_DLE_QID_MG0_C1 0x1A
+#define WDE_DLE_QID_MG1_C1 0x1B
+#define WDE_DLE_QID_MG2_C1 0x1C
+
+#define WDE_DLE_SUBQID_PORT_SH	4
+
+#define WDE_DLE_MAX_PKT_NUM 0xFFFF
+#define WDE_DLE_NULL_PKTID 0xFFF
+
+#define DLE_BUF_REQ_DLY_CNT 2000
+#define DLE_BUF_REQ_DLY_US 1
+#define SET_CPUIO_DLY_CNT 2000
+#define SET_CPUIO_DLY_US 1
+
+/*--------------------Define Enum------------------------------------*/
+
+/**
+ * @enum WDE_DLE_PORT_ID
+ *
+ * @brief WDE_DLE_PORT_ID
+ *
+ * @var WDE_DLE_PORT_ID::WDE_DLE_PORT_ID_DISPATCH
+ * Please Place Description here.
+ * @var WDE_DLE_PORT_ID::WDE_DLE_PORT_ID_PKTIN
+ * Please Place Description here.
+ * @var WDE_DLE_PORT_ID::WDE_DLE_PORT_ID_CMAC0
+ * Please Place Description here.
+ * @var WDE_DLE_PORT_ID::WDE_DLE_PORT_ID_CMAC1
+ * Please Place Description here.
+ * @var WDE_DLE_PORT_ID::WDE_DLE_PORT_ID_CPU_IO
+ * Please Place Description here.
+ * @var WDE_DLE_PORT_ID::WDE_DLE_PORT_ID_WDRLS
+ * Please Place Description here.
+ * @var WDE_DLE_PORT_ID::WDE_DLE_PORT_ID_END
+ * Please Place Description here.
+ */
+enum WDE_DLE_PORT_ID {
+	WDE_DLE_PORT_ID_DISPATCH = 0,
+	WDE_DLE_PORT_ID_PKTIN = 1,
+	WDE_DLE_PORT_ID_CMAC0 = 3,
+	WDE_DLE_PORT_ID_CMAC1 = 4,
+	WDE_DLE_PORT_ID_CPU_IO = 6,
+	WDE_DLE_PORT_ID_WDRLS = 7,
+	WDE_DLE_PORT_ID_END = 8
+};
+
+/**
+ * @enum PLE_DLE_PORT_ID
+ *
+ * @brief PLE_DLE_PORT_ID
+ *
+ * @var PLE_DLE_PORT_ID::PLE_DLE_PORT_ID_DISPATCH
+ * Please Place Description here.
+ * @var PLE_DLE_PORT_ID::PLE_DLE_PORT_ID_MPDU
+ * Please Place Description here.
+ * @var PLE_DLE_PORT_ID::PLE_DLE_PORT_ID_SEC
+ * Please Place Description here.
+ * @var PLE_DLE_PORT_ID::PLE_DLE_PORT_ID_CMAC0
+ * Please Place Description here.
+ * @var PLE_DLE_PORT_ID::PLE_DLE_PORT_ID_CMAC1
+ * Please Place Description here.
+ * @var PLE_DLE_PORT_ID::PLE_DLE_PORT_ID_WDRLS
+ * Please Place Description here.
+ * @var PLE_DLE_PORT_ID::PLE_DLE_PORT_ID_CPU_IO
+ * Please Place Description here.
+ * @var PLE_DLE_PORT_ID::PLE_DLE_PORT_ID_PLRLS
+ * Please Place Description here.
+ * @var PLE_DLE_PORT_ID::PLE_DLE_PORT_ID_END
+ * Please Place Description here.
+ */
+enum PLE_DLE_PORT_ID {
+	PLE_DLE_PORT_ID_DISPATCH = 0,
+	PLE_DLE_PORT_ID_MPDU = 1,
+	PLE_DLE_PORT_ID_SEC = 2,
+	PLE_DLE_PORT_ID_CMAC0 = 3,
+	PLE_DLE_PORT_ID_CMAC1 = 4,
+	PLE_DLE_PORT_ID_WDRLS = 5,
+	PLE_DLE_PORT_ID_CPU_IO = 6,
+	PLE_DLE_PORT_ID_PLRLS = 7,
+	PLE_DLE_PORT_ID_END = 8
+};
+
+/**
+ * @enum WDE_DLE_QUEID_PKTIN
+ *
+ * @brief WDE_DLE_QUEID_PKTIN
+ *
+ * @var WDE_DLE_QUEID_PKTIN::WDE_DLE_QUEID_AC0
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_PKTIN::WDE_DLE_QUEID_AC1
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_PKTIN::WDE_DLE_QUEID_AC2
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_PKTIN::WDE_DLE_QUEID_AC3
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_PKTIN::WDE_DLE_QUEID_MSIC
+ * Please Place Description here.
+ */
+enum WDE_DLE_QUEID_PKTIN {
+	WDE_DLE_QUEID_AC0 = 0x0,
+	WDE_DLE_QUEID_AC1 = 0x1,
+	WDE_DLE_QUEID_AC2 = 0x2,
+	WDE_DLE_QUEID_AC3 = 0x3,
+	WDE_DLE_QUEID_MSIC = 0x4
+};
+
+/**
+ * @enum WDE_DLE_QUEID_CMAC
+ *
+ * @brief WDE_DLE_QUEID_CMAC
+ *
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_ACQ_BE
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_ACQ_BK
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_ACQ_VI
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_ACQ_VO
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B0_BEACON
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B0_HIGH
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B0_MGN_NORMAL
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B0_MGN_NO_POWER_SAVE
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B0_MGN_FAST_EDCA
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B1_BEACON
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B1_HIGH
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B1_MGN_NORMAL
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B1_MGN_NO_POWER_SAVE
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B1_MGN_FAST_EDCA
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_WMM0_F2P_VO
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_WMM0_F2P_VI
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_WMM0_F2P_BE
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_WMM0_F2P_BK
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_WMM1_F2P_VO
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_WMM1_F2P_VI
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_WMM1_F2P_BE
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_WMM1_F2P_BK
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B0_ULQ
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B0_TWTQ0
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CMAC::WDE_DLE_QUEID_B0_TWTQ1
+ * Please Place Description here.
+ */
+enum WDE_DLE_QUEID_CMAC {
+	WDE_DLE_QUEID_ACQ_BE = 0,
+	WDE_DLE_QUEID_ACQ_BK = 1,
+	WDE_DLE_QUEID_ACQ_VI = 2,
+	WDE_DLE_QUEID_ACQ_VO = 3,
+	WDE_DLE_QUEID_B0_BEACON = 0x10,
+	WDE_DLE_QUEID_B0_HIGH = 0x11,
+	WDE_DLE_QUEID_B0_MGN_NORMAL = 0x12,
+	WDE_DLE_QUEID_B0_MGN_NO_POWER_SAVE = 0x13,
+	WDE_DLE_QUEID_B0_MGN_FAST_EDCA = 0x14,
+	WDE_DLE_QUEID_B1_BEACON = 0x18,
+	WDE_DLE_QUEID_B1_HIGH = 0x19,
+	WDE_DLE_QUEID_B1_MGN_NORMAL = 0x1A,
+	WDE_DLE_QUEID_B1_MGN_NO_POWER_SAVE = 0x1B,
+	WDE_DLE_QUEID_B1_MGN_FAST_EDCA = 0x1C,
+	WDE_DLE_QUEID_WMM0_F2P_VO = 0x20,
+	WDE_DLE_QUEID_WMM0_F2P_VI = 0x21,
+	WDE_DLE_QUEID_WMM0_F2P_BE = 0x22,
+	WDE_DLE_QUEID_WMM0_F2P_BK = 0x23,
+	WDE_DLE_QUEID_WMM1_F2P_VO = 0x24,
+	WDE_DLE_QUEID_WMM1_F2P_VI = 0x25,
+	WDE_DLE_QUEID_WMM1_F2P_BE = 0x26,
+	WDE_DLE_QUEID_WMM1_F2P_BK = 0x27,
+	WDE_DLE_QUEID_B0_ULQ = 0x30,
+	WDE_DLE_QUEID_B0_TWTQ0 = 0x31,
+	WDE_DLE_QUEID_B0_TWTQ1 = 0x32
+};
+
+/**
+ * @enum WDE_DLE_QUEID_CPUIO
+ *
+ * @brief WDE_DLE_QUEID_CPUIO
+ *
+ * @var WDE_DLE_QUEID_CPUIO::WDE_DLE_QUEID_CPUIO_0
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_CPUIO::WDE_DLE_QUEID_CPUIO_1
+ * Please Place Description here.
+ */
+enum WDE_DLE_QUEID_CPUIO {
+	WDE_DLE_QUEID_CPUIO_0 = 0x0,
+	WDE_DLE_QUEID_CPUIO_1 = 0x1
+};
+
+/**
+ * @enum PLE_DLE_QUEID_CPUIO
+ *
+ * @brief PLE_DLE_QUEID_CPUIO
+ *
+ * @var PLE_DLE_QUEID_CPUIO::PLE_DLE_QUEID_CPUIO_0
+ * Please Place Description here.
+ * @var PLE_DLE_QUEID_CPUIO::PLE_DLE_QUEID_CPUIO_1
+ * Please Place Description here.
+ */
+enum PLE_DLE_QUEID_CPUIO {
+	PLE_DLE_QUEID_CPUIO_0 = 0x0,
+	PLE_DLE_QUEID_CPUIO_1 = 0x1
+};
+
+/**
+ * @enum WDE_DLE_QUEID_WDRLS
+ *
+ * @brief WDE_DLE_QUEID_WDRLS
+ *
+ * @var WDE_DLE_QUEID_WDRLS::WDE_DLE_QUEID_TXOK
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_WDRLS::WDE_DLE_QUEID_DROP_RETRY_LIMIT
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_WDRLS::WDE_DLE_QUEID_DROP_LIFETIME_TO
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_WDRLS::WDE_DLE_QUEID_DROP_MACID_DROP
+ * Please Place Description here.
+ * @var WDE_DLE_QUEID_WDRLS::WDE_DLE_QUEID_NO_REPORT
+ * Please Place Description here.
+ */
+enum WDE_DLE_QUEID_WDRLS {
+	WDE_DLE_QUEID_TXOK = 0x0,
+	WDE_DLE_QUEID_DROP_RETRY_LIMIT = 0x1,
+	WDE_DLE_QUEID_DROP_LIFETIME_TO = 0x2,
+	WDE_DLE_QUEID_DROP_MACID_DROP = 0x3,
+	WDE_DLE_QUEID_NO_REPORT = 0x4
+};
+
+/**
+ * @enum PLE_DLE_QUEID_PLRLS
+ *
+ * @brief PLE_DLE_QUEID_PLRLS
+ *
+ * @var PLE_DLE_QUEID_PLRLS::PLE_DLE_QUEID_NO_REPORT
+ * Please Place Description here.
+ */
+enum PLE_DLE_QUEID_PLRLS {
+	PLE_DLE_QUEID_NO_REPORT = 0x0
+};
+
+/**
+ * @enum WDE_DLE_QUOTA_ID
+ *
+ * @brief WDE_DLE_QUOTA_ID
+ *
+ * @var WDE_DLE_QUOTA_ID::WDE_DLE_QUOTA_ID_HOST_IF
+ * Please Place Description here.
+ * @var WDE_DLE_QUOTA_ID::WDE_DLE_QUOTA_ID_WLAN_CPU
+ * Please Place Description here.
+ * @var WDE_DLE_QUOTA_ID::WDE_DLE_QUOTA_ID_DATA_CPU
+ * Please Place Description here.
+ * @var WDE_DLE_QUOTA_ID::WDE_DLE_QUOTA_ID_PKTIN
+ * Please Place Description here.
+ * @var WDE_DLE_QUOTA_ID::WDE_DLE_QUOTA_ID_CPUIO
+ * Please Place Description here.
+ * @var WDE_DLE_QUOTA_ID::WDE_DLE_QUOTA_ID_END
+ * Please Place Description here.
+ */
+enum WDE_DLE_QUOTA_ID {
+	WDE_DLE_QUOTA_ID_HOST_IF = 0,
+	WDE_DLE_QUOTA_ID_WLAN_CPU = 1,
+	WDE_DLE_QUOTA_ID_DATA_CPU = 2,
+	WDE_DLE_QUOTA_ID_PKTIN = 3,
+	WDE_DLE_QUOTA_ID_CPUIO = 4,
+	WDE_DLE_QUOTA_ID_END = 5
+};
+
+/**
+ * @enum PLE_DLE_QUOTA_ID
+ *
+ * @brief PLE_DLE_QUOTA_ID
+ *
+ * @var PLE_DLE_QUOTA_ID::PLE_DLE_QUOTA_ID_BAND0_TXPL
+ * Please Place Description here.
+ * @var PLE_DLE_QUOTA_ID::PLE_DLE_QUOTA_ID_BAND1_TXPL
+ * Please Place Description here.
+ * @var PLE_DLE_QUOTA_ID::PLE_DLE_QUOTA_ID_C2H
+ * Please Place Description here.
+ * @var PLE_DLE_QUOTA_ID::PLE_DLE_QUOTA_ID_H2C
+ * Please Place Description here.
+ * @var PLE_DLE_QUOTA_ID::PLE_DLE_QUOTA_ID_WLAN_CPU
+ * Please Place Description here.
+ * @var PLE_DLE_QUOTA_ID::PLE_DLE_QUOTA_ID_MPDU
+ * Please Place Description here.
+ * @var PLE_DLE_QUOTA_ID::PLE_DLE_QUOTA_ID_CMAC0_RX
+ * Please Place Description here.
+ * @var PLE_DLE_QUOTA_ID::PLE_DLE_QUOTA_ID_CMAC1_RX
+ * Please Place Description here.
+ * @var PLE_DLE_QUOTA_ID::PLE_DLE_QUOTA_ID_CMAC1_BBRPT
+ * Please Place Description here.
+ * @var PLE_DLE_QUOTA_ID::PLE_DLE_QUOTA_ID_WDRLS_RPT
+ * Please Place Description here.
+ * @var PLE_DLE_QUOTA_ID::PLE_DLE_QUOTA_ID_CPUIO
+ * Please Place Description here.
+ * @var PLE_DLE_QUOTA_ID::PLE_DLE_QUOTA_ID_END
+ * Please Place Description here.
+ */
+enum PLE_DLE_QUOTA_ID {
+	PLE_DLE_QUOTA_ID_BAND0_TXPL = 0,
+	PLE_DLE_QUOTA_ID_BAND1_TXPL = 1,
+	PLE_DLE_QUOTA_ID_C2H = 2,
+	PLE_DLE_QUOTA_ID_H2C = 3,
+	PLE_DLE_QUOTA_ID_WLAN_CPU = 4,
+	PLE_DLE_QUOTA_ID_MPDU = 5,
+	PLE_DLE_QUOTA_ID_CMAC0_RX = 6,
+	PLE_DLE_QUOTA_ID_CMAC1_RX = 7,
+	PLE_DLE_QUOTA_ID_CMAC1_BBRPT = 8,
+	PLE_DLE_QUOTA_ID_WDRLS_RPT = 9,
+	PLE_DLE_QUOTA_ID_CPUIO = 10,
+	PLE_DLE_QUOTA_ID_END = 11
+};
+
+/**
+ * @enum CPUIO_CTRL_TYPE
+ *
+ * @brief CPUIO_CTRL_TYPE
+ *
+ * @var CPUIO_CTRL_TYPE::CPUIO_CTRL_TYPE_WD
+ * Please Place Description here.
+ * @var CPUIO_CTRL_TYPE::CPUIO_CTRL_TYPE_PLD
+ * Please Place Description here.
+ * @var CPUIO_CTRL_TYPE::CPUIO_CTRL_TYPE_NUM
+ * Please Place Description here.
+ */
+enum CPUIO_CTRL_TYPE {
+	CPUIO_CTRL_TYPE_WD = 0,
+	CPUIO_CTRL_TYPE_PLD = 1,
+	CPUIO_CTRL_TYPE_NUM = 2
+};
+
+/**
+ * @enum CPUIO_OP_COMMAND_TYPE
+ *
+ * @brief CPUIO_OP_COMMAND_TYPE
+ *
+ * @var CPUIO_OP_COMMAND_TYPE::CPUIO_OP_CMD_GET_1ST_PID
+ * Please Place Description here.
+ * @var CPUIO_OP_COMMAND_TYPE::CPUIO_OP_CMD_GET_NEXT_PID
+ * Please Place Description here.
+ * @var CPUIO_OP_COMMAND_TYPE::CPUIO_OP_CMD_ENQ_TO_TAIL
+ * Please Place Description here.
+ * @var CPUIO_OP_COMMAND_TYPE::CPUIO_OP_CMD_ENQ_TO_HEAD
+ * Please Place Description here.
+ * @var CPUIO_OP_COMMAND_TYPE::CPUIO_OP_CMD_DEQ
+ * Please Place Description here.
+ * @var CPUIO_OP_COMMAND_TYPE::CPUIO_OP_CMD_DEQ_ENQ_ALL
+ * Please Place Description here.
+ * @var CPUIO_OP_COMMAND_TYPE::CPUIO_OP_CMD_DEQ_ENQ_TO_TAIL
+ * Please Place Description here.
+ */
+enum CPUIO_OP_COMMAND_TYPE {
+	CPUIO_OP_CMD_GET_1ST_PID = 0,
+	CPUIO_OP_CMD_GET_NEXT_PID = 1,
+	CPUIO_OP_CMD_ENQ_TO_TAIL = 4,
+	CPUIO_OP_CMD_ENQ_TO_HEAD = 5,
+	CPUIO_OP_CMD_DEQ = 8,
+	CPUIO_OP_CMD_DEQ_ENQ_ALL = 9,
+	CPUIO_OP_CMD_DEQ_ENQ_TO_TAIL = 12
+};
+
+/**
+ * @enum pkt_drop_ac
+ *
+ * @brief pkt_drop_ac
+ *
+ * @var pkt_drop_ac::PKT_DROP_BE
+ * Please Place Description here.
+ * @var pkt_drop_ac::PKT_DROP_BK
+ * Please Place Description here.
+ * @var pkt_drop_ac::PKT_DROP_VI
+ * Please Place Description here.
+ * @var pkt_drop_ac::PKT_DROP_VO
+ * Please Place Description here.
+ * @var pkt_drop_ac::PKT_DROP_AC_LAST
+ * Please Place Description here.
+ * @var pkt_drop_ac::PKT_DROP_AC_MAX
+ * Please Place Description here.
+ * @var pkt_drop_ac::PKT_DROP_AC_INVALID
+ * Please Place Description here.
+ */
+enum pkt_drop_ac {
+	PKT_DROP_BE = WDE_DLE_QID_BE,
+	PKT_DROP_BK = WDE_DLE_QID_BK,
+	PKT_DROP_VI = WDE_DLE_QID_VI,
+	PKT_DROP_VO = WDE_DLE_QID_VO,
+
+	/* keep last */
+	PKT_DROP_AC_LAST,
+	PKT_DROP_AC_MAX = PKT_DROP_AC_LAST,
+	PKT_DROP_AC_INVALID = PKT_DROP_AC_LAST,
+};
+
+/*--------------------Define MACRO----------------------------------*/
+#define VIRTUAL_ADDRESS_MAPPING(eng_sel, pkt_id, offset)	\
+	(0x00000000 | (((eng_sel) & 0x1) << 27) |		\
+	(((pkt_id) & 0xFFF) << 15) | ((offset) & 0xEFFF))
+
+#define GET_VIRTUAL_ADDRESS_WD(pkt_id, offset)\
+	((((pkt_id) & 0xFFF) << 15) | ((offset) & 0xEFFF))
+
+/*--------------------Define Struct----------------------------------*/
+
+/**
+ * @struct cpuio_buf_req_t
+ * @brief cpuio_buf_req_t
+ *
+ * @var cpuio_buf_req_t::len
+ * Please Place Description here.
+ * @var cpuio_buf_req_t::pktid
+ * Please Place Description here.
+ */
+struct cpuio_buf_req_t {
+	// input
+	u16 len;
+	// output
+	u16 pktid;
+};
+
+/**
+ * @struct cpuio_ctrl_t
+ * @brief cpuio_ctrl_t
+ *
+ * @var cpuio_ctrl_t::pkt_num
+ * Please Place Description here.
+ * @var cpuio_ctrl_t::start_pktid
+ * Please Place Description here.
+ * @var cpuio_ctrl_t::end_pktid
+ * Please Place Description here.
+ * @var cpuio_ctrl_t::cmd_type
+ * Please Place Description here.
+ * @var cpuio_ctrl_t::macid
+ * Please Place Description here.
+ * @var cpuio_ctrl_t::src_pid
+ * Please Place Description here.
+ * @var cpuio_ctrl_t::src_qid
+ * Please Place Description here.
+ * @var cpuio_ctrl_t::dst_pid
+ * Please Place Description here.
+ * @var cpuio_ctrl_t::dst_qid
+ * Please Place Description here.
+ * @var cpuio_ctrl_t::pktid
+ * Please Place Description here.
+ */
+struct cpuio_ctrl_t {
+	// input
+	u16 pkt_num;
+	u16 start_pktid;
+	u16 end_pktid;
+	u8 cmd_type;
+	u8 macid;
+	u8 src_pid;
+	u8 src_qid;
+	u8 dst_pid;
+	u8 dst_qid;
+	// output
+	u16 pktid;
+};
+
+/**
+ * @struct deq_enq_info
+ * @brief deq_enq_info
+ *
+ * @var deq_enq_info::macid
+ * Please Place Description here.
+ * @var deq_enq_info::src_pid
+ * Please Place Description here.
+ * @var deq_enq_info::src_qid
+ * Please Place Description here.
+ * @var deq_enq_info::dst_pid
+ * Please Place Description here.
+ * @var deq_enq_info::dst_qid
+ * Please Place Description here.
+ * @var deq_enq_info::pktid
+ * Please Place Description here.
+ */
+struct deq_enq_info {
+	u8 macid;
+	u8 src_pid;
+	u8 src_qid;
+	u8 dst_pid;
+	u8 dst_qid;
+	u16 pktid;
+};
+
+/**
+ * @struct first_pid_info
+ * @brief first_pid_info
+ *
+ * @var first_pid_info::macid
+ * Please Place Description here.
+ * @var first_pid_info::src_pid
+ * Please Place Description here.
+ * @var first_pid_info::src_qid
+ * Please Place Description here.
+ * @var first_pid_info::pktid
+ * Please Place Description here.
+ */
+struct first_pid_info {
+	u8 macid;
+	u8 src_pid;
+	u8 src_qid;
+	u16 pktid;
+};
+
+/**
+ * @struct next_pid_info
+ * @brief next_pid_info
+ *
+ * @var next_pid_info::macid
+ * Please Place Description here.
+ * @var next_pid_info::src_pid
+ * Please Place Description here.
+ * @var next_pid_info::src_qid
+ * Please Place Description here.
+ * @var next_pid_info::start_pktid
+ * Please Place Description here.
+ * @var next_pid_info::pktid
+ * Please Place Description here.
+ */
+struct next_pid_info {
+	u8 macid;
+	u8 src_pid;
+	u8 src_qid;
+	u16 start_pktid;
+	u16 pktid;
+};
+
+/*--------------------Export global variable----------------------------*/
+
+/*--------------------Function declaration-----------------------------*/
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup CPU_IO
+ * @{
+ */
+
+/**
+ * @brief deq_enq_all
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 deq_enq_all(struct mac_ax_adapter *adapter, struct deq_enq_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup CPU_IO
+ * @{
+ */
+
+/**
+ * @brief mac_dle_buf_req_wd
+ *
+ * @param *adapter
+ * @param *buf_req_p
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dle_buf_req_wd(struct mac_ax_adapter *adapter,
+		       struct cpuio_buf_req_t *buf_req_p);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup CPU_IO
+ * @{
+ */
+
+/**
+ * @brief mac_dle_buf_req_pl
+ *
+ * @param *adapter
+ * @param *buf_req_p
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dle_buf_req_pl(struct mac_ax_adapter *adapter,
+		       struct cpuio_buf_req_t *buf_req_p);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup CPU_IO
+ * @{
+ */
+
+/**
+ * @brief mac_set_cpuio_wd
+ *
+ * @param *adapter
+ * @param *ctrl_para_p
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_cpuio_wd(struct mac_ax_adapter *adapter,
+		     struct cpuio_ctrl_t *ctrl_para_p);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup CPU_IO
+ * @{
+ */
+
+/**
+ * @brief mac_set_cpuio_pl
+ *
+ * @param *adapter
+ * @param *ctrl_para_p
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_cpuio_pl(struct mac_ax_adapter *adapter,
+		     struct cpuio_ctrl_t *ctrl_para_p);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup CPU_IO
+ * @{
+ */
+
+/**
+ * @brief mac_wde_pkt_drop
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_wde_pkt_drop(struct mac_ax_adapter *adapter,
+		     struct mac_ax_pkt_drop_info *info);
+/**
+ * @}
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbcc.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbcc.c
new file mode 100644
index 000000000000..f9232a1cf535
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbcc.c
@@ -0,0 +1,637 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "dbcc.h"
+#include "mac_priv.h"
+#include "cpuio.h"
+
+u32 dbcc_info_init(struct mac_ax_adapter *adapter)
+{
+	u32 ret = MACSUCCESS;
+
+	adapter->dbcc_info =
+		(struct mac_ax_dbcc_info *)PLTFM_MALLOC(DBCC_INFO_SIZE);
+	if (!adapter->dbcc_info) {
+		PLTFM_MSG_ERR("dbcc info malloc fail\n");
+		return MACNPTR;
+	}
+
+	adapter->dbcc_info->dbcc_wmm_list = (u8 *)PLTFM_MALLOC(DBCC_WMM_LIST_SIZE);
+	if (!adapter->dbcc_info->dbcc_wmm_list) {
+		PLTFM_MSG_ERR("dbcc wmm list malloc fail\n");
+		return MACNPTR;
+	}
+
+	ret = rst_dbcc_info(adapter);
+
+	return ret;
+}
+
+u32 dbcc_info_exit(struct mac_ax_adapter *adapter)
+{
+	PLTFM_FREE(adapter->dbcc_info->dbcc_wmm_list, DBCC_WMM_LIST_SIZE);
+	PLTFM_FREE(adapter->dbcc_info, DBCC_INFO_SIZE);
+
+	return MACSUCCESS;
+}
+
+u32 rst_dbcc_info(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_dbcc_info *dbcc_info = adapter->dbcc_info;
+	u32 i;
+
+	if (!dbcc_info) {
+		PLTFM_MSG_ERR("no dbcc info when rst dbcc info\n");
+		return MACNPTR;
+	}
+
+	PLTFM_MEMSET(dbcc_info->dbcc_wmm_list, MAC_AX_DBCC_WMM_INVALID,
+		     DBCC_WMM_LIST_SIZE);
+	for (i = 0; i < MAC_AX_DBCC_WMM_MAX; i++) {
+		dbcc_info->dbcc_role_cnt[i] = 0;
+		dbcc_info->dbcc_wmm_type[i] = MAC_AX_NET_TYPE_INVLAID;
+		dbcc_info->dbcc_wmm_bp[i] = DBCC_BP_INVALID;
+	}
+
+	for (i = MAC_AX_BAND_0; i < MAC_AX_BAND_NUM; i++) {
+		dbcc_info->bkp_flag[i] = 0;
+		PLTFM_MEMSET(&dbcc_info->ppdu_rpt_bkp, 0,
+			     sizeof(struct mac_ax_phy_rpt_cfg));
+		PLTFM_MEMSET(&dbcc_info->chinfo_bkp, 0,
+			     sizeof(struct mac_ax_phy_rpt_cfg));
+	}
+
+	dbcc_info->notify_fw_flag = 0;
+
+	return MACSUCCESS;
+}
+
+static u32 get_valid_dbcc_wmm(struct mac_ax_adapter *adapter, u8 *out_dbcc_wmm)
+{
+	struct mac_ax_dbcc_info *dbcc_info = adapter->dbcc_info;
+	u8 wmmidx;
+
+	if (!dbcc_info) {
+		PLTFM_MSG_ERR("no dbcc info when get valid dbcc wmm\n");
+		*out_dbcc_wmm = MAC_AX_DBCC_WMM_INVALID;
+		return MACNPTR;
+	}
+
+	for (wmmidx = MAC_AX_DBCC_WMM0; wmmidx < MAC_AX_DBCC_WMM_MAX; wmmidx++) {
+		if (!dbcc_info->dbcc_role_cnt[wmmidx])
+			break;
+	}
+
+	if (wmmidx == MAC_AX_DBCC_WMM_MAX) {
+		PLTFM_MSG_ERR("no valid dbcc wmm\n");
+		*out_dbcc_wmm = MAC_AX_DBCC_WMM_INVALID;
+		return MACNOITEM;
+	}
+
+	*out_dbcc_wmm = wmmidx;
+	return MACSUCCESS;
+}
+
+u32 dbcc_wmm_add_macid(struct mac_ax_adapter *adapter,
+		       struct mac_ax_role_info *info)
+{
+	struct mac_ax_dbcc_info *dbcc_info = adapter->dbcc_info;
+	enum mac_ax_ss_wmm_tbl dst_link;
+	u8 *cur_dbcc_wmm_type;
+	u32 ret;
+	u8 chk_emp, tar_dbcc_wmm, wmmidx, curr_bp;
+
+	if (!dbcc_info) {
+		PLTFM_MSG_ERR("no dbcc info when add macid\n");
+		return MACNPTR;
+	}
+
+	curr_bp = (info->port & DBCC_PORT_MASK) |
+		  (info->band == MAC_AX_BAND_1 ? DBCC_BAND_BIT : 0);
+	tar_dbcc_wmm = MAC_AX_DBCC_WMM_INVALID;
+
+	if (info->net_type == MAC_AX_NET_TYPE_AP) {
+		for (wmmidx = MAC_AX_DBCC_WMM0; wmmidx < MAC_AX_DBCC_WMM_MAX; wmmidx++) {
+			if (dbcc_info->dbcc_wmm_bp[wmmidx] == curr_bp &&
+			    dbcc_info->dbcc_wmm_type[wmmidx] == info->net_type)
+				break;
+		}
+
+		if (wmmidx < MAC_AX_DBCC_WMM_MAX)
+			tar_dbcc_wmm = wmmidx;
+	}
+
+	if (tar_dbcc_wmm == MAC_AX_DBCC_WMM_INVALID) {
+		ret = get_valid_dbcc_wmm(adapter, &tar_dbcc_wmm);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("get_valid_dbcc_wmm %d\n", ret);
+			return ret;
+		}
+	}
+
+	cur_dbcc_wmm_type = &dbcc_info->dbcc_wmm_type[tar_dbcc_wmm];
+	if ((info->net_type != MAC_AX_NET_TYPE_AP &&
+	     *cur_dbcc_wmm_type != MAC_AX_NET_TYPE_INVLAID) ||
+	    (info->net_type == MAC_AX_NET_TYPE_AP &&
+	     *cur_dbcc_wmm_type != MAC_AX_NET_TYPE_INVLAID &&
+	     *cur_dbcc_wmm_type != MAC_AX_NET_TYPE_AP)) {
+		PLTFM_MSG_ERR("dbcc wmm%d is occupied by type%d\n",
+			      tar_dbcc_wmm, *cur_dbcc_wmm_type);
+		return MACPROCERR;
+	}
+
+	if (info->macid >= DBCC_WMM_LIST_SIZE) {
+		PLTFM_MSG_ERR("macid%d not support in dbcc wmm add macid\n",
+			      info->macid);
+		return MACFUNCINPUT;
+	}
+
+	if (info->band == MAC_AX_BAND_0)
+		dst_link = info->wmm ?
+			   MAC_AX_SS_WMM_TBL_C0_WMM1 : MAC_AX_SS_WMM_TBL_C0_WMM0;
+	else
+		dst_link = info->wmm ?
+			   MAC_AX_SS_WMM_TBL_C1_WMM1 : MAC_AX_SS_WMM_TBL_C1_WMM0;
+	chk_emp = (!dbcc_info->dbcc_role_cnt[tar_dbcc_wmm] ||
+		   *cur_dbcc_wmm_type != MAC_AX_NET_TYPE_AP) ? 1 : 0;
+	ret = mac_ss_wmm_map_upd(adapter, (enum mac_ax_ss_wmm)tar_dbcc_wmm,
+				 dst_link, chk_emp);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("mac_ss_wmm_map_upd %d/%d/%d/%d\n",
+			      tar_dbcc_wmm, dst_link, chk_emp, ret);
+		return ret;
+	}
+
+	*(dbcc_info->dbcc_wmm_list + info->macid) = tar_dbcc_wmm;
+	dbcc_info->dbcc_role_cnt[tar_dbcc_wmm]++;
+	*cur_dbcc_wmm_type = info->net_type;
+	dbcc_info->dbcc_wmm_bp[tar_dbcc_wmm] = curr_bp;
+
+	return MACSUCCESS;
+}
+
+u32 dbcc_wmm_rm_macid(struct mac_ax_adapter *adapter,
+		      struct mac_ax_role_info *info)
+{
+	struct mac_ax_dbcc_info *dbcc_info = adapter->dbcc_info;
+	u8 dbcc_wmm;
+
+	if (!dbcc_info) {
+		PLTFM_MSG_ERR("no dbcc info when rm macid\n");
+		return MACNPTR;
+	}
+
+	if (info->macid >= DBCC_WMM_LIST_SIZE) {
+		PLTFM_MSG_ERR("macid%d not support in dbcc wmm rm macid\n",
+			      info->macid);
+		return MACFUNCINPUT;
+	}
+
+	dbcc_wmm = *(dbcc_info->dbcc_wmm_list + info->macid);
+	if (dbcc_wmm == MAC_AX_DBCC_WMM_INVALID) {
+		PLTFM_MSG_ERR("macid%d dbcc wmm invalid in dbcc wmm list\n",
+			      info->macid);
+		return MACPROCERR;
+	}
+
+	if (!dbcc_info->dbcc_role_cnt[dbcc_wmm]) {
+		PLTFM_MSG_ERR("dbcc wmm%d rm macid%d underflow\n",
+			      dbcc_wmm, info->macid);
+		if (dbcc_info->dbcc_wmm_type[dbcc_wmm] !=
+		    MAC_AX_NET_TYPE_INVLAID) {
+			PLTFM_MSG_ERR("dbcc wmm not invalid when no role\n");
+			return MACPROCERR;
+		}
+		return MACCMP;
+	}
+
+	*(dbcc_info->dbcc_wmm_list + info->macid) = MAC_AX_DBCC_WMM_INVALID;
+	dbcc_info->dbcc_role_cnt[dbcc_wmm]--;
+	if (!dbcc_info->dbcc_role_cnt[dbcc_wmm]) {
+		dbcc_info->dbcc_wmm_type[dbcc_wmm] = MAC_AX_NET_TYPE_INVLAID;
+		dbcc_info->dbcc_wmm_bp[dbcc_wmm] = DBCC_BP_INVALID;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 band1_enable(struct mac_ax_adapter *adapter,
+			struct mac_ax_trx_info *info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret;
+
+	ret = tx_idle_poll_band(adapter, 0);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]tx idle poll %d\n", ret);
+		return ret;
+	}
+
+	ret = dle_quota_change(adapter, info->qta_mode);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]DLE quota change %d\n", ret);
+		return ret;
+	}
+
+	ret = preload_init(adapter, MAC_AX_BAND_1, info->qta_mode);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]preload init B1 %d\n", ret);
+		return ret;
+	}
+
+	ret = p_ops->cmac_func_en(adapter, MAC_AX_BAND_1, MAC_AX_FUNC_EN);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d func en %d\n", MAC_AX_BAND_1, ret);
+		return ret;
+	}
+
+	ret = p_ops->cmac_init(adapter, info, MAC_AX_BAND_1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d init %d\n", MAC_AX_BAND_1, ret);
+		return ret;
+	}
+
+	MAC_REG_W32(R_AX_SYS_ISO_CTRL_EXTEND,
+		    MAC_REG_R32(R_AX_SYS_ISO_CTRL_EXTEND) |
+		    B_AX_R_SYM_FEN_WLBBGLB_1 | B_AX_R_SYM_FEN_WLBBFUN_1);
+
+	adapter->sm.bb1_func = MAC_AX_FUNC_ON;
+
+	ret = mac_enable_imr(adapter, MAC_AX_BAND_1, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] enable CMAC1 IMR %d\n", ret);
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 band1_disable(struct mac_ax_adapter *adapter,
+			 struct mac_ax_trx_info *info)
+{
+	u32 ret;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	MAC_REG_W32(R_AX_SYS_ISO_CTRL_EXTEND,
+		    MAC_REG_R32(R_AX_SYS_ISO_CTRL_EXTEND) &
+		    ~B_AX_R_SYM_FEN_WLBBFUN_1);
+
+	ret = p_ops->cmac_func_en(adapter, MAC_AX_BAND_1, MAC_AX_FUNC_DIS);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d func dis %d\n", MAC_AX_BAND_1, ret);
+		return ret;
+	}
+
+	ret = dle_quota_change(adapter, info->qta_mode);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]DLE quota change %d\n", ret);
+		return ret;
+	}
+
+	ret = rst_port_info(adapter, MAC_AX_BAND_1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]Reset band 1 port info %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static u32 dbcc_chk_notify_done(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_dbcc_info *dbcc_info = adapter->dbcc_info;
+	u32 cnt = DBCC_CHK_NTFY_CNT;
+
+	while (cnt) {
+		if (!dbcc_info->notify_fw_flag)
+			break;
+		PLTFM_SLEEP_US(DBCC_CHK_NTFY_DLY);
+		cnt--;
+	}
+
+	if (!cnt)
+		return MACPOLLTO;
+
+	PLTFM_MSG_ALWAYS("[TRACE]DBCC check notify cnt %d\n", DBCC_CHK_NTFY_CNT - cnt);
+	return MACSUCCESS;
+}
+
+u32 dbcc_trx_ctrl_bkp(struct mac_ax_adapter *adapter, enum mac_ax_band band)
+{
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+	struct mac_ax_dbcc_info *dbcc_info = adapter->dbcc_info;
+	struct mac_ax_phy_rpt_cfg *ppdu_rpt_cfg;
+	struct mac_ax_phy_rpt_cfg *chinfo_cfg;
+	u32 ret;
+
+	if (!dbcc_info) {
+		PLTFM_MSG_ERR("no dbcc info when bkp trx\n");
+		return MACNPTR;
+	}
+
+	if (dbcc_info->bkp_flag[band]) {
+		PLTFM_MSG_ERR("band%d trx ctrl already backup\n", band);
+		return MACPROCERR;
+	}
+
+	ppdu_rpt_cfg = &dbcc_info->ppdu_rpt_bkp[band];
+	ppdu_rpt_cfg->type = MAC_AX_PPDU_STATUS;
+	ppdu_rpt_cfg->u.ppdu.band = band;
+	ret = mops->get_phy_rpt_cfg(adapter, ppdu_rpt_cfg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("get ppdu stus rpt cfg %d\n", ret);
+		return ret;
+	}
+
+	chinfo_cfg = &dbcc_info->chinfo_bkp[band];
+	chinfo_cfg->type = MAC_AX_CH_INFO;
+	ret = mops->get_phy_rpt_cfg(adapter, chinfo_cfg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("get ch info cfg %d\n", ret);
+		return ret;
+	}
+
+	dbcc_info->bkp_flag[band] = 1;
+	return ret;
+}
+
+u32 mac_dbcc_trx_ctrl(struct mac_ax_adapter *adapter,
+		      enum mac_ax_band band, u8 pause)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+	struct mac_ax_dbcc_info *dbcc_info = adapter->dbcc_info;
+	struct mac_ax_sch_tx_en_cfg sch_cfg;
+	struct mac_ax_phy_rpt_cfg phyrpt_cfg;
+	struct mac_ax_phy_rpt_cfg *ppdu_rpt_bkp;
+	struct mac_ax_phy_rpt_cfg *chinfo_cfg_kbp;
+	u32 ret, reg;
+	u16 val16;
+
+	if (!dbcc_info) {
+		PLTFM_MSG_ERR("no dbcc info when trx ctrl\n");
+		return MACNPTR;
+	}
+
+	if (pause) {
+		ret = dbcc_trx_ctrl_bkp(adapter, band);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("B%d dbcc trx bkp %d\n", band, ret);
+			return ret;
+		}
+	} else if (!dbcc_info->bkp_flag[band]) {
+		PLTFM_MSG_ERR("B%d dbcc trx is not backup\n", band);
+		return MACPROCERR;
+	}
+
+	if (!pause && band == MAC_AX_BAND_1 &&
+	    check_mac_en(adapter, MAC_AX_BAND_1, MAC_AX_CMAC_SEL) != MACSUCCESS) {
+		dbcc_info->bkp_flag[band] = 0;
+		return MACSUCCESS;
+	}
+
+	ppdu_rpt_bkp = &dbcc_info->ppdu_rpt_bkp[band];
+	chinfo_cfg_kbp = &dbcc_info->chinfo_bkp[band];
+
+	sch_cfg.band = (u8)band;
+	if (pause)
+		PLTFM_MEMSET(&sch_cfg.tx_en, 0, SCH_TX_EN_SIZE);
+	else
+		PLTFM_MEMSET(&sch_cfg.tx_en, 0xFF, SCH_TX_EN_SIZE);
+	PLTFM_MEMSET(&sch_cfg.tx_en_mask, 0xFF, SCH_TX_EN_SIZE);
+	ret = mops->set_hw_value(adapter, MAC_AX_HW_SET_SCH_TXEN_CFG,
+				 (void *)&sch_cfg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("B%d pause%d sch txen cfg %d\n", band, pause, ret);
+		return ret;
+	}
+
+	reg = band == MAC_AX_BAND_0 ? R_AX_RCR : R_AX_RCR_C1;
+	val16 = MAC_REG_R16(reg);
+	if (pause)
+		MAC_REG_W16(reg, val16 | B_AX_STOP_RX_IN);
+	else
+		MAC_REG_W16(reg, val16 & ~B_AX_STOP_RX_IN);
+
+	phyrpt_cfg.type = MAC_AX_PPDU_STATUS;
+	phyrpt_cfg.en = pause ? 0 : ppdu_rpt_bkp->en;
+	phyrpt_cfg.dest = ppdu_rpt_bkp->dest;
+	phyrpt_cfg.u.ppdu = ppdu_rpt_bkp->u.ppdu;
+	ret = mops->cfg_phy_rpt(adapter, &phyrpt_cfg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("B%d pause%d ppdu status cfg %d\n", band, pause, ret);
+		return ret;
+	}
+
+	phyrpt_cfg.type = MAC_AX_CH_INFO;
+	phyrpt_cfg.en = pause ? 0 : chinfo_cfg_kbp->en;
+	phyrpt_cfg.dest = chinfo_cfg_kbp->dest;
+	phyrpt_cfg.u.chif = chinfo_cfg_kbp->u.chif;
+	ret = mops->cfg_phy_rpt(adapter, &phyrpt_cfg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("B%d pause%d ch info cfg %d\n", band, pause, ret);
+		return ret;
+	}
+
+	if (!pause)
+		dbcc_info->bkp_flag[band] = 0;
+
+	return ret;
+}
+
+u32 mac_dbcc_enable(struct mac_ax_adapter *adapter,
+		    struct mac_ax_trx_info *info, u8 dbcc_en)
+{
+	u32 ret;
+
+	if (dbcc_en) {
+		ret = band1_enable(adapter, info);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] band1_enable %d\n", ret);
+			return ret;
+		}
+		if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+			ret = mac_notify_fw_dbcc(adapter, 1);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s:[ERR]notfify dbcc1 fail %d\n",
+					      __func__, ret);
+				return ret;
+			}
+		} else {
+			PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		}
+	} else {
+		if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+			ret = mac_notify_fw_dbcc(adapter, 0);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s:[ERR]notfify dbcc0 fail %d\n",
+					      __func__, ret);
+				return ret;
+			}
+		} else {
+			PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		}
+		ret = band1_disable(adapter, info);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] band1_disable %d\n", ret);
+			return ret;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_dbcc_pre_cfg(struct mac_ax_adapter *adapter, struct mac_dbcc_cfg_info *info)
+{
+	struct mac_ax_dbcc_info *dbcc_info = adapter->dbcc_info;
+	struct mac_ax_trx_info trx_info;
+	u32 ret = MACSUCCESS;
+	u8 notify_en;
+
+	trx_info.trx_mode = info->trx_mode;
+	trx_info.qta_mode = info->qta_mode;
+	trx_info.rpr_cfg = NULL;
+
+	if (info->dbcc_en) {
+		notify_en = 1;
+		ret = band1_enable(adapter, &trx_info);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] band1_enable %d\n", ret);
+			return ret;
+		}
+		if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+			if (dbcc_info->notify_fw_flag) {
+				PLTFM_MSG_WARN("[WARN]Notify FW dbcc %d flag already set\n",
+					       notify_en);
+			}
+			dbcc_info->notify_fw_flag = 1;
+			ret = mac_notify_fw_dbcc(adapter, notify_en);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s:[ERR]Notify dbcc %d fail %d\n",
+					      __func__, notify_en, ret);
+				return ret;
+			}
+		} else {
+			PLTFM_MSG_WARN("%s en %d fw not ready\n", __func__, info->dbcc_en);
+		}
+	} else {
+		notify_en = 0;
+		if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+			if (dbcc_info->notify_fw_flag) {
+				PLTFM_MSG_WARN("[WARN]Notify FW dbcc %d flag already set\n",
+					       notify_en);
+			}
+			dbcc_info->notify_fw_flag = 1;
+			ret = mac_notify_fw_dbcc(adapter, notify_en);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s:[ERR]Notify dbcc %d fail %d\n",
+					      __func__, notify_en, ret);
+				return ret;
+			}
+		} else {
+			PLTFM_MSG_WARN("%s en %d fw not ready\n", __func__, info->dbcc_en);
+		}
+	}
+
+	return ret;
+}
+
+u32 mac_dbcc_cfg(struct mac_ax_adapter *adapter, struct mac_dbcc_cfg_info *info)
+{
+	struct mac_ax_trx_info trx_info;
+	u32 ret = MACSUCCESS;
+
+	trx_info.trx_mode = info->trx_mode;
+	trx_info.qta_mode = info->qta_mode;
+	trx_info.rpr_cfg = NULL;
+
+	if (info->dbcc_en) {
+		ret = dbcc_chk_notify_done(adapter);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]Check dbcc notify %d fail %d\n",
+				      info->dbcc_en, ret);
+			return ret;
+		}
+	} else {
+		ret = dbcc_chk_notify_done(adapter);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]Check dbcc notify %d fail %d\n",
+				      info->dbcc_en, ret);
+			return ret;
+		}
+
+		ret = band1_disable(adapter, &trx_info);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] band1_disable %d\n", ret);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+u32 mac_dbcc_move_wmm(struct mac_ax_adapter *adapter,
+		      struct mac_ax_role_info *info)
+{
+	struct mac_ax_dbcc_info *dbcc_info = adapter->dbcc_info;
+	enum mac_ax_ss_wmm_tbl dst_link;
+	u8 dbcc_wmm;
+	u8 role_cnt;
+	u8 wmm_type;
+	u8 dbcc_en = info->band;
+	u32 ret;
+
+	if (!dbcc_info) {
+		PLTFM_MSG_ERR("no dbcc info when move wmm\n");
+		return MACNPTR;
+	}
+
+	dbcc_wmm = *(dbcc_info->dbcc_wmm_list + info->macid);
+	role_cnt = dbcc_info->dbcc_role_cnt[dbcc_wmm];
+	wmm_type = dbcc_info->dbcc_wmm_type[dbcc_wmm];
+
+	if (!role_cnt) {
+		PLTFM_MSG_ERR("dbcc en%d move wmm%d role cnt 0\n",
+			      dbcc_en, dbcc_wmm);
+		return MACCMP;
+	}
+
+	dst_link = dbcc_en ?
+		   MAC_AX_SS_WMM_TBL_C1_WMM0 : MAC_AX_SS_WMM_TBL_C0_WMM0;
+	if (dbcc_en == MAC_AX_BAND_0)
+		dst_link = info->wmm ?
+			   MAC_AX_SS_WMM_TBL_C0_WMM1 : MAC_AX_SS_WMM_TBL_C0_WMM0;
+	else
+		dst_link = info->wmm ?
+			   MAC_AX_SS_WMM_TBL_C1_WMM1 : MAC_AX_SS_WMM_TBL_C1_WMM0;
+	ret = mac_ss_wmm_sta_move(adapter,
+				  (enum mac_ax_ss_wmm)dbcc_wmm,
+				  dst_link);
+	if (ret == MACARDYDONE) {
+		if (wmm_type != MAC_AX_NET_TYPE_AP)
+			PLTFM_MSG_WARN("dbcc en%d move wmm%d is already mapped\n",
+				       dbcc_en, dbcc_wmm);
+		return MACSUCCESS;
+	} else if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("dbcc en%d move wmm%d sta %d\n",
+			      dbcc_en, dbcc_wmm, ret);
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbcc.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbcc.h
new file mode 100644
index 000000000000..6890d12f19f1
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbcc.h
@@ -0,0 +1,148 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_DBCC_H_
+#define _MAC_AX_DBCC_H_
+
+#include "../type.h"
+#include "trxcfg.h"
+#include "sta_sch.h"
+
+/*--------------------Define -------------------------------------------*/
+#define DBCC_INFO_SIZE sizeof(struct mac_ax_dbcc_info)
+#define DBCC_WMM_LIST_SIZE 32
+
+#define SCH_TX_EN_SIZE sizeof(struct mac_ax_sch_tx_en)
+#define PPDU_RPT_CFG_SIZE sizeof(struct mac_ax_phy_rpt_cfg)
+#define CHINFO_CFG_SIZE sizeof(struct mac_ax_phy_rpt_cfg)
+
+#define DBCC_BAND_BIT BIT7
+#define DBCC_PORT_MASK 0xF
+#define DBCC_BP_INVALID 0xFF
+
+#define DBCC_CHK_NTFY_CNT 20000
+#define DBCC_CHK_NTFY_DLY 50
+
+/*--------------------Define MACRO--------------------------------------*/
+/*--------------------Define Enum---------------------------------------*/
+/*--------------------Define Struct-------------------------------------*/
+/*--------------------Function Prototype--------------------------------*/
+
+/**
+ * @brief dbcc_info_init
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dbcc_info_init(struct mac_ax_adapter *adapter);
+
+/**
+ * @brief dbcc_info_exit
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dbcc_info_exit(struct mac_ax_adapter *adapter);
+
+/**
+ * @brief rst_dbcc_info
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 rst_dbcc_info(struct mac_ax_adapter *adapter);
+
+/**
+ * @brief dbcc_wmm_add_macid
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dbcc_wmm_add_macid(struct mac_ax_adapter *adapter,
+		       struct mac_ax_role_info *info);
+
+/**
+ * @brief dbcc_wmm_rm_macid
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dbcc_wmm_rm_macid(struct mac_ax_adapter *adapter,
+		      struct mac_ax_role_info *info);
+
+/**
+ * @brief mac_dbcc_trx_ctrl
+ *
+ * @param *adapter
+ * @param band
+ * @param pause
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dbcc_trx_ctrl(struct mac_ax_adapter *adapter,
+		      enum mac_ax_band band, u8 pause);
+
+/**
+ * @brief mac_dbcc_enable
+ *
+ * @param *adapter
+ * @param *info
+ * @param dbcc_en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dbcc_enable(struct mac_ax_adapter *adapter,
+		    struct mac_ax_trx_info *info, u8 dbcc_en);
+
+/**
+ * @brief mac_dbcc_pre_cfg
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dbcc_pre_cfg(struct mac_ax_adapter *adapter, struct mac_dbcc_cfg_info *info);
+
+/**
+ * @brief mac_dbcc_cfg
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dbcc_cfg(struct mac_ax_adapter *adapter, struct mac_dbcc_cfg_info *info);
+
+/**
+ * @brief mac_dbcc_move_wmm
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dbcc_move_wmm(struct mac_ax_adapter *adapter,
+		      struct mac_ax_role_info *info);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbg_cmd.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbg_cmd.c
new file mode 100644
index 000000000000..60c4ebd8e931
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbg_cmd.c
@@ -0,0 +1,3015 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "dbg_cmd.h"
+
+const char *MallocIDName[eMallocMAX] = {
+	"OS",
+	"Common",
+	"Task",
+	"AXIDMA",
+	"SPIC",
+	"Timer",
+	"UART",
+	"H2C",
+	"C2H",
+	"DBG",
+	"Role",
+	"PS",
+	"WoWLAN",
+	"Sec",
+	"Ofld",
+	"TX",
+	"RX",
+	"Report",
+	"PHYDM",
+	"RF",
+	"BTCoex",
+	"SCSI",
+	"Free"
+};
+
+const char *MallocTypeName[eMallocTypeMAX] = {
+	"N/A",
+	"Fixed",
+	"Dynamic"
+};
+
+const char *ISRName[ISRStatistic_MAX] = {
+	/* First layer */
+	// WDTISRROM8852A
+	"WDT",
+	// CMACISRROM8852A
+	"CMAC0",
+	"CMAC1",
+	"CMAC2",
+	"CMAC3",
+	"CMAC4",
+	"CMAC5",
+	"CMAC6",
+	"CMAC7",
+	"CMAC8",
+	"CMAC9",
+	"CMAC10",
+	// DMACISRROM8852A
+	"DMAC0",
+	"DMAC1",
+	"DMAC2",
+	// SysISRROM8852A
+	"SYS0",
+	// DataHDLISRROM8852A
+	"IPSec",
+	"AXIDMA",
+	"IDDMA",
+	// PlatISRROM8852A
+	"MACErr",
+	"UART",
+	"RXI300",
+	/* Second layer */
+	"DMAC0_GT0",
+	"DMAC0_GT1",
+	"DMAC0_GT2_3",
+	"DMAC0_H2C",
+	"SYS0_HALT_H2C",
+	"SYS0_GPIO",
+	"MACErr_DMAC",
+	"MACErr_CMAC0",
+	"MACErr_CMAC1"
+};
+
+// gerrit test 5
+static const struct mac_hal_cmd_info mac_hal_cmd_i[] = {
+	{"-h", MAC_HAL_HELP, cmd_mac_help, ""},
+	/*@do not move this element to other position*/
+	/*for MAC Debug Command Usage*/
+	{"dd_dbg", MAC_MAC_DD_DBG, cmd_mac_dbg_dump, ""},
+	{"reg_dump", MAC_MAC_REG_DUMP, cmd_mac_reg_dump, ""},
+	{"error_dump", MAC_MAC_ERROR_DUMP, cmd_mac_error_dump, ""},
+	{"dbg_tx", MAC_MAC_DBG_TX, cmd_mac_dbg_tx_dump, ""},
+	{"dbg_rx", MAC_MAC_DBG_RX, cmd_mac_dbg_rx_dump, ""},
+	{"dbg_cmac", MAC_MAC_DBG_CMAC, cmd_mac_dbg_rx_dump, ""},
+	{"dbg_dmac", MAC_MAC_DBG_DMAC, cmd_mac_dbg_rx_dump, ""},
+	{"dbg_bdsts", MAC_MAC_DBG_BDSTS, cmd_mac_bd_status, ""},
+	{"dbg_bcn", MAC_MAC_DBG_BCN, cmd_mac_dbg_bcn, \
+	 "param1: <Band Number> (0 or 1)"},
+	{"dbg_tx_cnt", MAC_MAC_DBG_TX_CNT, cmd_mac_tx_cnt, ""},
+	{"dbg_rx_cnt", MAC_MAC_DBG_RX_CNT, cmd_mac_rx_cnt, ""},
+	{"ser_cnt", MAC_MAC_SER_CNT_DUMP, cmd_mac_ser_cnt_dump, "Show SER Count Status"},
+	{"set_ser_log_lvl", MAC_MAC_SET_SER_LVL, cmd_mac_ser_level_set, \
+	 "param1: <One Byte Hex Number> (Bit0:mac_reg, Bit1:txflow, Bit2:dmac," \
+	 "Bit3:cmac, Bit4:share_mem, Bit5:dbgprt)"},
+	{"get_ser_log_lvl", MAC_MAC_GET_SER_LVL, cmd_mac_ser_level_dump, "Get the SER log level"},
+	{"bcn_stats", MAC_MAC_QC_START, cmd_mac_bcn_stats, ""},
+	{"dbg_read", MAC_MAC_DBG_READ, cmd_mac_dbg_read, "MAC CMD for SRAM FIFO Debug Read"\
+	" 'cmd mac dbg_read <enum sel> <offset> <size>'"},
+	{"dbg_write", MAC_MAC_DBG_WRITE, cmd_mac_dbg_write, "MAC CMD for SRAM FIFO Write"\
+	" 'cmd mac dbg_write <enum sel> <offset> <write_val>'"},
+	{"trx_info_macid", MAC_MAC_TRX_INFO_MACID, cmd_mac_trx_info_macid, \
+	 "Per MACID T/RX information"},
+	{"trx_info_global", MAC_MAC_TRX_INFO_GLOBAL, cmd_mac_trx_info_global, \
+	 "Global T/RX information and SW mode TXCMD/SS2F information"},
+	{"dl_result", MAC_MAC_DL_RESULT, cmd_mac_dl_result, "DL Decision result and break reason"},
+	{"curr_wd_cnt", MAC_MAC_CURR_WD_CNT, cmd_mac_curr_wd_cnt, "Current WD count"},
+	{"pkt_cal", MAC_MAC_PKT_CAL, cmd_mac_pkt_cal, "Packet Per Second calculation"},
+	{"trg_ser_l0", MAC_MAC_TRG_SER_L0, cmd_mac_trigger_l0_err, "Trigger SER L0"},
+	{"trg_ser_l1", MAC_MAC_TRG_SER_L1, cmd_mac_trigger_l1_err, "Trigger SER L1"},
+	{"set_cmac_dbg", MAC_MAC_SET_SER_L0_DBG, cmd_mac_set_l0_dbg_mode, "Set SER L0 debug mode"},
+	{"set_dmac_dbg", MAC_MAC_SET_SER_L1_DBG, cmd_mac_set_l1_dbg_mode, "Set SER L1 debug mode"},
+	 /*for FW Debug Command Usage*/
+	{"fw_dbg", MAC_MAC_FW_DBG, cmd_mac_fw_dump, ""},
+	{"help", MAC_HAL_HELP, cmd_mac_help, ""},
+	{"fw_log", MAC_MAC_FW_LOG, cmd_mac_fw_log_cfg, ""},
+	{"fw_curtcb", MAC_MAC_FW_CURTCB, cmd_mac_fw_curtcb, ""},
+	{"fw_info", MAC_MAC_FW_INFO, cmd_mac_fw_status_parser, ""},
+	{"dl_sym", MAC_MAC_DL_SYM, cmd_mac_dl_sym, ""},
+	{"tbtt_tuning", MAC_MAC_TBTT_TUNING, cmd_mac_tbtt_tuning, ""},
+	/*for QC Command Usage*/
+	{"qc_start", MAC_MAC_QC_START, cmd_mac_qc_start, ""},
+	{"qc_end", MAC_MAC_QC_END, cmd_mac_qc_end, ""},
+	{"req_pwr_st", MAC_MAC_REQ_PWR_ST, cmd_mac_req_pwr_st, ""},
+	{"req_pwr_lvl", MAC_MAC_REQ_PWR_LVL, cmd_mac_req_pwr_lvl, ""},
+	{"chsw", MAC_MAC_CHSW, cmd_mac_fw_chsw, ""},
+	{"chsw_ret", MAC_MAC_CHSW_RET, cmd_mac_fw_chsw_ret, ""},
+	{"rpt_queue_sts", MAC_MAC_RPT_QUEUE_STS, cmd_mac_rpt_queue_sts, \
+	 "Number and Status of RPT enqueue(AXIDMA/RPT QUEUE)"}
+	/*@do not move this element to other position*/
+};
+
+static const struct mac_hal_cmd_info mac_fw_status_cmd_i[] = {
+	{"task", FW_STATUS_TASKINFO},
+	{"flash", FW_STATUS_FLASHINFO},
+	{"heap", FW_STATUS_HEAPINFO},
+	{"mem_fast", FW_STATUS_MEMINFO_FAST},
+	{"mem_slow", FW_STATUS_MEMINFO_SLOW},
+	{"ps", FW_STATUS_PSINFO},
+	{"h2c_c2h", FW_STATUS_H2C_C2HINFO},
+	{"isr", FW_STATUS_ISRINFO},
+	{"chsw", FW_STATUS_CHSW_TIMING}
+};
+
+static const char * const type_names[] = {
+	"level",
+	"output",
+	"comp",
+	"comp_ext",
+	NULL
+};
+
+static struct fw_status_proc_class fw_status_proc_sys[] = {
+	{FW_STATUS_TASKINFO, fw_status_taskinfo_handler},
+	{FW_STATUS_FLASHINFO, fw_status_flashinfo_handler},
+	{FW_STATUS_HEAPINFO, fw_status_heapinfo_handler},
+	{FW_STATUS_MEMINFO_FAST, fw_status_meminfo_fast_handler},
+	{FW_STATUS_MEMINFO_SLOW, fw_status_meminfo_slow_handler},
+	{FW_STATUS_PSINFO, fw_status_psinfo_handler},
+	{FW_STATUS_H2C_C2HINFO, fw_status_h2c_c2hinfo_handler},
+	{FW_STATUS_ISRINFO, fw_status_isrinfo_handler},
+	{FW_STATUS_CHSW_TIMING, fw_status_chsw_handler},
+	{FW_STATUS_MAX, NULL},
+};
+
+u8 qc_cmd_id;
+u32 fheap_start, sheap_start;
+
+u32 cmd_mac_help(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		 char *output, u32 out_len, u32 *used)
+{
+	u32 hal_cmd_ary_size = sizeof(mac_hal_cmd_i) / sizeof(struct mac_hal_cmd_info);
+	u32 i;
+
+	//PLTFM_MSG_TRACE("HAL cmd ==>\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used, "HAL cmd ==>\n");
+	for (i = 0; i < hal_cmd_ary_size - 1; i++) {
+		//PLTFM_MSG_TRACE("	 %-5d: %s\n",
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used, "	 %-5d: %s\n",
+			    i, mac_hal_cmd_i[i + 1].name);
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used, "\t\tNote: %s\n\n",
+			    mac_hal_cmd_i[i + 1].description);
+	}
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_dbg_dump(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		     char *output, u32 out_len, u32 *used)
+{
+	//struct hal_info_t *hal = hal_com->hal_priv;
+	struct mac_ax_adapter *mac = adapter;
+	//struct mac_ax_ops *ops = mac->ops;
+	struct mac_ax_dbgpkg ss_dbg = {0};
+	struct mac_ax_dbgpkg_en dbg_msk = {0};
+
+	ss_dbg.ss_dbg_0 = 0;
+	ss_dbg.ss_dbg_1 = 0;
+	dbg_msk.ss_dbg = 1;
+	dbg_msk.dle_dbg = 1;
+	dbg_msk.dmac_dbg = 1;
+	dbg_msk.cmac_dbg = 1;
+	dbg_msk.mac_dbg_port = 1;
+
+	mac_dbg_status_dump(mac, &ss_dbg, &dbg_msk);
+
+	//PLTFM_MSG_TRACE("rtw_hal_mac_dbg_dump(): ss_dbg.ss_dbg_0 = 0x%08X,
+	//		      ss_dbg.ss_dbg_1 = 0x%08X\n",
+	//		      ss_dbg.ss_dbg_0, ss_dbg.ss_dbg_1);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "rtw_hal_mac_dbg_dump(): ss_dbg.ss_dbg_0 = 0x%08X,ss_dbg.ss_dbg_1 = 0x%08X\n",
+		    ss_dbg.ss_dbg_0, ss_dbg.ss_dbg_1);
+
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_reg_dump(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		     char *output, u32 out_len, u32 *used)
+{
+	u32 ret = MACSUCCESS, val = 0;
+
+	// input argument start from input[1], input[0] is mac_hal_cmd_info.name
+	if (input_num < 2) {
+		//PLTFM_MSG_TRACE("invalid argument\n");
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "invalid argument\n");
+		return MACFWSTATUSFAIL;
+	}
+	//PLTFM_SSCANF(input[1], "%d", &val);
+	val = PLTFM_STRTOUL(input[1], 10);
+
+	//PLTFM_MSG_TRACE("%s: sel:%d\n", __func__, val);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "%s: sel:%d\n", __func__, val);
+	ret = mac_reg_dump(adapter, (enum mac_ax_reg_sel)val);
+	return ret;
+}
+
+u32 cmd_mac_error_dump(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		       char *output, u32 out_len, u32 *used)
+{
+	u32 ret = MACSUCCESS;
+
+	return ret;
+}
+
+void cmd_mac_get_version(struct mac_ax_adapter *adapter, char *ver_str, u16 len)
+{
+	PLTFM_SNPRINTF(ver_str, len, "V%u.%u.%u.%u",
+		       MAC_AX_MAJOR_VER, MAC_AX_PROTOTYPE_VER,
+		       MAC_AX_SUB_VER, MAC_AX_SUB_INDEX);
+}
+
+void cmd_mac_get_fw_ver(struct mac_ax_adapter *adapter, char *ver_str, u16 len)
+{
+	PLTFM_SNPRINTF(ver_str, len, "V%u.%u.%u.%u",
+		       adapter->fw_info.major_ver, adapter->fw_info.minor_ver,
+		       adapter->fw_info.sub_ver, adapter->fw_info.sub_idx);
+}
+
+u32 cmd_mac_fw_dump(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV], u32 input_num,
+		    char *output, u32 out_len, u32 *used)
+{
+	//struct rtw_hal_com_t *hal_com = hal_info->hal_com;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 i;
+	char mac_ver[20], fw_ver[20];
+
+	cmd_mac_get_version(adapter, mac_ver, sizeof(mac_ver));
+	//PLTFM_MSG_TRACE("HALMAC version %s\n", mac_ver);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "HALMAC version %s\n", mac_ver);
+
+	cmd_mac_get_fw_ver(adapter, fw_ver, sizeof(fw_ver));
+	//PLTFM_MSG_TRACE("FW version %s\n", fw_ver);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "FW version %s\n", fw_ver);
+
+	/* dump dbg reg */
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "0x01f0[31:0] = 0x%08x\n", MAC_REG_R32(0x01f0));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "0x01f4[31:0] = 0x%08x\n", MAC_REG_R32(0x01f4));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "0x01f8[31:0] = 0x%08x\n", MAC_REG_R32(0x01f8));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "0x016c[31:0] = 0x%08x\n", MAC_REG_R32(0x016c));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "0x01fc[31:0] = 0x%08x\n", MAC_REG_R32(0x01fc));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "0x8424[31:0] = 0x%08x\n", MAC_REG_R32(0x8424));
+
+	/* dump fw pc */
+	MAC_REG_W32(0x58, 0xf200f2);
+	MAC_REG_W8(0xf6, 0x1);
+	for (i = 0; i < 15; i++) {
+		//PLTFM_MSG_TRACE("0x00c0[31:0] = 0x%08x\n", MAC_REG_R32(0xc0));
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "0x00c0[31:0] = 0x%08x\n", MAC_REG_R32(0xc0));
+		PLTFM_DELAY_MS(1);
+	}
+	return MACSUCCESS;
+}
+
+static void cmd_mac_fw_log_set(struct mac_ax_fw_log *fl_cfg, u8 type, u32 value)
+{
+	switch (type) {
+	case FWDGB_CFG_TYPE_LEVEL:
+		fl_cfg->level = value;
+		break;
+
+	case FWDGB_CFG_TYPE_OUTPUT:
+		fl_cfg->output |= value;
+		break;
+
+	case FWDGB_CFG_TYPE_COMP:
+		fl_cfg->comp |= value;
+		break;
+
+	case FWDGB_CFG_TYPE_COMP_EXT:
+		fl_cfg->comp_ext |= value;
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void cmd_mac_fw_log_clr(struct mac_ax_fw_log *fl_cfg, u8 type, u32 value)
+{
+	switch (type) {
+	case FWDGB_CFG_TYPE_LEVEL:
+		break;
+	case FWDGB_CFG_TYPE_OUTPUT:
+		fl_cfg->output &= (~value);
+		break;
+	case FWDGB_CFG_TYPE_COMP:
+		fl_cfg->comp &= (~value);
+		break;
+	case FWDGB_CFG_TYPE_COMP_EXT:
+		fl_cfg->comp_ext &= (~value);
+		break;
+	default:
+		break;
+	}
+}
+
+u32 cmd_mac_dbg_tx_dump(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV], u32 input_num,
+			char *output, u32 out_len, u32 *used)
+{
+	u32 ret;
+
+	PLTFM_MSG_TRACE("%s\n", __func__);
+	ret = mac_tx_flow_dbg(adapter);
+
+	return ret;
+}
+
+u32 cmd_mac_dbg_rx_dump(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV], u32 input_num,
+			char *output, u32 out_len, u32 *used)
+{
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+	u32 ret;
+
+	PLTFM_MSG_TRACE("%s\n", __func__);
+
+	ret = mops->event_notify(adapter, MSG_EVT_DBG_RX_DUMP, HW_BAND_0);
+
+	return ret;
+}
+
+u32 cmd_mac_dbg_dmac(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV], u32 input_num,
+		     char *output, u32 out_len, u32 *used)
+{
+	//struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret = MACSUCCESS;
+
+	PLTFM_MSG_TRACE("%s\n", __func__);
+
+	if (adapter->sm.dmac_func == MAC_AX_FUNC_ON) {
+		//ret = p_ops->dmac_dbg_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("dmac dbg dump\n");
+	}
+
+	return ret;
+}
+
+u32 cmd_mac_dbg_cmac(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV], u32 input_num,
+		     char *output, u32 out_len, u32 *used)
+{
+	//struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret = MACSUCCESS;
+
+	PLTFM_MSG_TRACE("%s\n", __func__);
+
+	if (adapter->sm.cmac0_func == MAC_AX_FUNC_ON) {
+		//ret = p_ops->cmac_dbg_dump(adapter, MAC_AX_BAND_0);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("cmac%d dbg dump %d\n", MAC_AX_BAND_0, ret);
+	}
+
+	if (adapter->sm.cmac1_func == MAC_AX_FUNC_ON) {
+		//ret = p_ops->cmac_dbg_dump(adapter, MAC_AX_BAND_1);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("cmac%d dbg dump %d\n", MAC_AX_BAND_1, ret);
+	}
+
+	return ret;
+}
+
+u32 cmd_mac_dbg_bcn(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV], u32 input_num,
+		    char *output, u32 out_len, u32 *used)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 i, band, en_port_num = 0;
+	u32 reg, address;
+	char mac_ver[20], fw_ver[20];
+
+	cmd_mac_get_version(adapter, mac_ver, sizeof(mac_ver));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "HALMAC version %s\n", mac_ver);
+	cmd_mac_get_fw_ver(adapter, fw_ver, sizeof(fw_ver));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "FW version %s\n", fw_ver);
+
+	if (input_num == 2) {
+		band = PLTFM_STRCMP(input[1], "1") == 0 ? 1 : 0;
+		PLTFM_MSG_ERR("Select band: %d\n", band);
+
+		/* TRX Setting */
+		/* Check MACID Sleep */
+		address = (band == MAC_AX_BAND_0) ?
+			  R_AX_MACID_SLEEP_0 : R_AX_MACID_SLEEP_0_C1;
+		reg = MAC_REG_R32(address);
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "Check MACID Sleep:\t0x%08x[31:0] = 0x%08x\n",
+			    address, reg);
+		if ((reg & 0x1) != 0)
+			PLTFM_MSG_ERR("[ERR] 0x%08x[0] should not be 1\n", address);
+
+		/* Check MACID Pause */
+		reg = MAC_REG_R32(R_AX_SS_MACID_PAUSE_0);
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "Check MACID Pause:\t0x%08x[31:0] = 0x%08x\n",
+			    R_AX_SS_MACID_PAUSE_0, reg);
+		if ((reg & 0x1) != 0)
+			PLTFM_MSG_ERR("[ERR] 0x%08x[0] should not be 1\n", R_AX_SS_MACID_PAUSE_0);
+
+		/* Check Contention EN */
+		address = (band == MAC_AX_BAND_0) ? R_AX_CTN_TXEN : R_AX_CTN_TXEN_C1;
+		reg = MAC_REG_R32(address);
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "Check Contention EN Flag:\t0x%08x[31:0] = 0x%08x\n",
+			    address, reg);
+		if ((reg & B_AX_CTN_TXEN_MGQ) != B_AX_CTN_TXEN_MGQ)
+			PLTFM_MSG_ERR("[ERR] 0x%08x[8] should enable MGQ\n", address);
+		if ((reg & B_AX_CTN_TXEN_MGQ1) != B_AX_CTN_TXEN_MGQ1)
+			PLTFM_MSG_ERR("[ERR] 0x%08x[9] should enable MGQ1\n", address);
+		if ((reg & B_AX_CTN_TXEN_HGQ) != B_AX_CTN_TXEN_HGQ)
+			PLTFM_MSG_ERR("[ERR] 0x%08x[11] should enable HGQ\n", address);
+		if ((reg & B_AX_CTN_TXEN_BCNQ) != B_AX_CTN_TXEN_BCNQ)
+			PLTFM_MSG_ERR("[ERR] 0x%08x[12] should enable BCNQ\n", address);
+
+		address = (band == MAC_AX_BAND_0) ? R_AX_CTN_DRV_TXEN : R_AX_CTN_DRV_TXEN_C1;
+		reg = MAC_REG_R32(address);
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "Check Driver Contention EN Flag:\t0x%08x[31:0] = 0x%08x\n",
+			    address, reg);
+		if ((reg & B_AX_CTN_TXEN_MGQ) != B_AX_CTN_TXEN_MGQ)
+			PLTFM_MSG_ERR("[ERR] 0x%08x[8] should enable MGQ\n", address);
+		if ((reg & B_AX_CTN_TXEN_MGQ1) != B_AX_CTN_TXEN_MGQ1)
+			PLTFM_MSG_ERR("[ERR] 0x%08x[9] should enable MGQ1\n", address);
+		if ((reg & B_AX_CTN_TXEN_HGQ) != B_AX_CTN_TXEN_HGQ)
+			PLTFM_MSG_ERR("[ERR] 0x%08x[11] should enable HGQ\n", address);
+		if ((reg & B_AX_CTN_TXEN_BCNQ) != B_AX_CTN_TXEN_BCNQ)
+			PLTFM_MSG_ERR("[ERR] 0x%08x[12] should enable BCNQ\n", address);
+
+		/* Check TXON */
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "Check PTCL TXON Status:\n");
+		for (i = 0; i < 5; i++) {
+			address = (band == MAC_AX_BAND_0) ?
+			R_AX_PTCL_TX_CTN_SEL : R_AX_PTCL_TX_CTN_SEL_C1;
+			reg = MAC_REG_R32(address);
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "\t0x%08x[31:0] = 0x%08x\n", address, reg);
+			if (reg == 0x12)
+				break;
+			PLTFM_DELAY_MS(100);
+		}
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8852D_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT)
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		address = (band == MAC_AX_BAND_0) ?
+			  R_AX_MBSSID_CTRL : R_AX_MBSSID_CTRL_C1;
+		reg = MAC_REG_R32(address);
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "Check MBSSID EN:\t0x%08x[31:0] = 0x%08x\n", address, reg);
+		PLTFM_MSG_ERR("Number of enable MBSSID: %d\n", (reg >> 16) & 0xf);
+
+		address = (band == MAC_AX_BAND_0) ? R_AX_MBSSID_DROP_0 : R_AX_MBSSID_DROP_0_C1;
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "Check MBSSID Drop:\t0x%08x[31:0] = 0x%08x\n",
+			    address, MAC_REG_R32(address));
+	}
+#endif
+
+		/* Check BCN Setting */
+		for (i = 0; i < MAC_AX_PORT_NUM; i++) {
+			/* Check BCN ISR Flag */
+			address = ((band == MAC_AX_BAND_0) ? R_AX_FWC01ISR : R_AX_FWC01ISR_C1)
+				  + i * FWCISR_OFFSET;
+			reg = MAC_REG_R32(address);
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "Check Port%d Beacon ISR Flag:\t0x%08x[31:0] = 0x%08x\n",
+				    i, address, reg);
+			if (reg != 0x0)
+				PLTFM_MSG_ERR("[ERR] Please clear port%d beacon ISR flag "\
+					      "and read again\n", i);
+
+			/* Check TXBCNEN */
+			address = ((band == MAC_AX_BAND_0) ?
+				   R_AX_PORT_CFG_P0 : R_AX_PORT_CFG_P0_C1)
+				   + i * PORT_CFG_OFFSET;
+			reg = MAC_REG_R32(address);
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "Check Port%d Beacon Setting:\t0x%08x[31:0] = 0x%08x\n",
+				    i, address, reg);
+			en_port_num += (((reg >> 12) & 0x1) == 0) ? 0 : 1;
+
+			/* Check BCN Space */
+			address = ((band == MAC_AX_BAND_0) ?
+				   R_AX_BCN_SPACE_CFG_P0 : R_AX_BCN_SPACE_CFG_P0_C1)
+				   + i * PORT_CFG_OFFSET;
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "Check Port%d Beacon Space:\t0x%08x[31:0] = 0x%08x\n",
+				    i, address, MAC_REG_R32(address));
+
+			/* Check BCN Error Flag */
+			address = ((band == MAC_AX_BAND_0) ?
+				   R_AX_BCN_ERR_FLAG_P0 : R_AX_BCN_ERR_FLAG_P0_C1)
+				   + i * PORT_CFG_OFFSET;
+			reg = MAC_REG_R32(address);
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "Check Port%d Beacon Error Flag:\t0x%08x[31:0] = 0x%08x\n",
+				    i, address, reg);
+			if ((reg & 0xffff) != 0x0000)
+				PLTFM_MSG_ERR("[ERR] 0x%08x[15:0] should be all 0\n", address);
+
+			/* Check BCN Error Counter */
+			address = ((band == MAC_AX_BAND_0) ?
+				   R_AX_BCN_ERR_CNT_P0 : R_AX_BCN_ERR_CNT_P0_C1)
+				   + i * PORT_CFG_OFFSET;
+			reg = MAC_REG_R32(address);
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "Check Port%d Beacon Error Counter:\t0x%08x[31:0] = 0x%08x\n",
+				    i, address, reg);
+			if (reg != 0x0)
+				PLTFM_MSG_ERR("[ERR] 0x%08x[31:0] should be all 0\n", address);
+		}
+		PLTFM_MSG_ERR("Number of enable port: %d\n", en_port_num);
+	} else {
+		PLTFM_MSG_ERR("Command example: \"cmd mac dbg_bcn <band number>\"\n");
+	}
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_ser_cnt_dump(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV], u32 input_num,
+			 char *output, u32 out_len, u32 *used)
+{
+	u32 ret;
+	struct mac_ser_status status = {0};
+
+	PLTFM_MSG_TRACE("%s\n", __func__);
+	ret = mac_dump_ser_cnt(adapter, &status);
+	PLTFM_MSG_ALWAYS("SER L0 Count: %d\n" \
+			 "SER L1 Count: %d\n" \
+			 "SER L0 pro event:%d\n" \
+			 "rmac PPDU Hang Out: %d\n" \
+			 , status.l0_cnt, status.l1_cnt
+			 , status.l0_pro_event, status.rmac_ppdu_hang_cnt);
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_ser_level_set(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV],
+			  u32 input_num, char *output, u32 out_len, u32 *used)
+{
+	if (input_num == 2) {
+		adapter->ser_info.dbg_lvl.dbgprt_dump = (PLTFM_STRTOUL(input[1], 16) & BIT(5)) \
+							>> 5 == 0 ? 0 : 1;
+		adapter->ser_info.dbg_lvl.share_mem_dump = (PLTFM_STRTOUL(input[1], 16) & BIT(4)) \
+							   >> 4 == 0 ? 0 : 1;
+		adapter->ser_info.dbg_lvl.cmac_dbg_dump = (PLTFM_STRTOUL(input[1], 16) & BIT(3)) \
+							  >> 3 == 0 ? 0 : 1;
+		adapter->ser_info.dbg_lvl.dmac_dbg_dump = (PLTFM_STRTOUL(input[1], 16) & BIT(2)) \
+							  >> 2 == 0 ? 0 : 1;
+		adapter->ser_info.dbg_lvl.txflow_dbg_dump = (PLTFM_STRTOUL(input[1], 16) & BIT(1)) \
+							    >> 1 == 0 ? 0 : 1;
+		adapter->ser_info.dbg_lvl.mac_reg_dump = (PLTFM_STRTOUL(input[1], 16) & BIT(0))
+							 == 0 ? 0 : 1;
+		cmd_mac_ser_level_dump(adapter, input, input_num, output, out_len, used);
+	} else {
+		PLTFM_MSG_ERR("Please type cmd mac set_ser_log_lvl <One Byte Hex Number> " \
+			      "Bit0:mac_reg, Bit1:txflow, Bit2:dmac, " \
+			      "Bit3:cmac, Bit4:share_mem, Bit5:dbgprt\n");
+	}
+
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_ser_level_dump(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV],
+			   u32 input_num, char *output, u32 out_len, u32 *used)
+{
+	PLTFM_MSG_TRACE("%s\n", __func__);
+
+	PLTFM_MSG_ALWAYS("dbgprt_dump: %d\n", adapter->ser_info.dbg_lvl.dbgprt_dump);
+	PLTFM_MSG_ALWAYS("share_mem_dump: %d\n", adapter->ser_info.dbg_lvl.share_mem_dump);
+	PLTFM_MSG_ALWAYS("cmac_dbg_dump: %d\n", adapter->ser_info.dbg_lvl.cmac_dbg_dump);
+	PLTFM_MSG_ALWAYS("dmac_dbg_dump: %d\n", adapter->ser_info.dbg_lvl.dmac_dbg_dump);
+	PLTFM_MSG_ALWAYS("txflow_dbg_dump: %d\n", adapter->ser_info.dbg_lvl.txflow_dbg_dump);
+	PLTFM_MSG_ALWAYS("mac_reg_dump: %d\n", adapter->ser_info.dbg_lvl.mac_reg_dump);
+
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_fw_log_cfg_set(struct mac_ax_adapter *adapter,
+			   struct mac_ax_fw_log *log_cfg, char *output, u32 out_len, u32 *used)
+{
+	//struct hal_info_t *hal = hal_com->hal_priv;
+	struct mac_ax_adapter *mac = adapter;
+	//struct mac_ax_fw_log log_cfg = {0};
+	u32 status;
+
+	if (!mac)
+		return MACFWSTATUSFAIL;
+
+	//log_cfg.level = fl_cfg->level;
+	//log_cfg.output = fl_cfg->output;
+	//log_cfg.comp = fl_cfg->comp;
+	//log_cfg.comp_ext = fl_cfg->comp_ext;
+	/*
+	 *PLTFM_MSG_TRACE("Configuring firmware log level %d, output 0x%08x, "
+	 *	  "comp 0x%08x, comp ext 0x%08x.\n",
+	 *		log_cfg->level,
+	 *		log_cfg->output,
+	 *		log_cfg->comp,
+	 *		log_cfg->comp_ext);
+	 */
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "Config firmware log level %d,output 0x%08x,comp 0x%08x,comp ext 0x%08x.\n",
+		    log_cfg->level,
+		    log_cfg->output,
+		    log_cfg->comp,
+		    log_cfg->comp_ext);
+	if (log_cfg->output & MAC_AX_FL_LV_UART)	{
+		//PLTFM_MSG_TRACE("%s: Enabling UART...\n", __func__);
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "%s: Enabling UART...\n", __func__);
+		mac->ops->pinmux_set_func(mac, MAC_AX_GPIO_UART_TX_GPIO5);
+		mac->ops->sel_uart_tx_pin(mac, MAC_AX_UART_TX_GPIO5);
+		mac->ops->pinmux_set_func(mac, MAC_AX_GPIO_UART_RX_GPIO6);
+		mac->ops->sel_uart_rx_pin(mac, MAC_AX_UART_RX_GPIO6);
+	}
+
+	status = mac->ops->fw_log_cfg(mac, log_cfg);
+	if (status != MACSUCCESS) {
+		//PLTFM_MSG_TRACE("%s fault, status = %d.\n", __func__, status);
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "%s fault, status = %d.\n", __func__, status);
+		//return status;
+	}
+	return status;
+}
+
+u32 cmd_mac_fw_log_cfg(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		       char *output, u32 out_len, u32 *used)
+{
+	//struct rtw_hal_com_t *hal_com = (struct rtw_hal_com_t *)adapter->drv_adapter;
+	//struct rtw_hal_fw_log_cfg *fl_cfg = &hal_com->fw_log_cfg;
+	/* TYPE VALUE(HEX) 1(SET)|2(CLEAR) */
+	struct mac_ax_fw_log *plog_cfg = &adapter->log_cfg;
+	u8 type = 0;
+	u32 op = FWDGB_CFG_OP_INFO, value = 0;
+
+	if (input_num == 4) {
+		//PLTFM_MSG_TRACE("%s,%s,%s\n", input[1], input[2], input[3]);
+		while (type_names[type]) {
+			if (PLTFM_STRCMP(input[1], type_names[type]) == 0)
+				break;
+			type++;
+		}
+		if (!type_names[type]) {
+			//PLTFM_MSG_TRACE("Invalid type \"%s\"\n", input[1]);
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "Invalid type \"%s\"\n", input[1]);
+			return MACFWSTATUSFAIL;
+		}
+		//PLTFM_SSCANF(input[2], "%x", &value);
+		value = PLTFM_STRTOUL(input[2], 16);
+		//PLTFM_SSCANF(input[3], "%d", &op);
+		op = PLTFM_STRTOUL(input[3], 10);
+		//PLTFM_MSG_TRACE("value = 0x%x, op = %d\n", value, op);
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "value = 0x%x, op = %d\n", value, op);
+		if (op == 1)
+			op = FWDGB_CFG_OP_SET;
+		else if (op == 2)
+			op = FWDGB_CFG_OP_CLR;
+		else
+			op = FWDGB_CFG_OP_INFO;
+	} else {
+		//PLTFM_MSG_TRACE("invalid argument\n");
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "invalid argument\n");
+		return MACFWSTATUSFAIL;
+	}
+
+	switch (op) {
+	case FWDGB_CFG_OP_SET:
+		cmd_mac_fw_log_set(plog_cfg, type, value);
+		break;
+	case FWDGB_CFG_OP_CLR:
+		cmd_mac_fw_log_clr(plog_cfg, type, value);
+		break;
+	case FWDGB_CFG_OP_INFO:
+	//default:
+		//_hal_fw_log_info(&log_cfg);
+		//PLTFM_MSG_TRACE("fw_log invalid op\n");
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "fw_log invalid op\n");
+		return MACFWSTATUSFAIL;
+	}
+
+	return cmd_mac_fw_log_cfg_set(adapter, plog_cfg, output, out_len, used);
+}
+
+u32 cmd_mac_fw_curtcb(struct mac_ax_adapter *adapter,
+		      char input[][MAC_MAX_ARGV], u32 input_num,
+		      char *output, u32 out_len, u32 *used)
+{
+	//struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 curtcb, index, val32;
+	char task_name[FW_MAX_TASK_NAME_LEN];
+
+	curtcb = mac_sram_dbg_read(adapter, FW_CURTCB_AX, WCPU_DATA_SEL);
+
+	val32 = mac_sram_dbg_read(adapter, (curtcb & FW_TCB_ADDR_MASK_AX) +
+				  FW_CURTCB_SP_START_OFFSET, WCPU_DATA_SEL);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "[FW]Start of the stack = 0x%08x\n", val32);
+
+	for (index = 0; index < 16 ; index = index + 4) {
+		val32 = mac_sram_dbg_read(adapter, (curtcb & FW_TCB_ADDR_MASK_AX) +
+					FW_CURTCB_TASK_NAME_OFFSET + index, WCPU_DATA_SEL);
+
+		PLTFM_MEMCPY((u8 *)&task_name[index], (u8 *)&val32, 4);
+	}
+
+	task_name[FW_MAX_TASK_NAME_LEN - 1] = '\0';
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "[FW]Current task name = %s\n", task_name);
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_fw_status_parser(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			     u32 input_num, char *output, u32 out_len, u32 *used)
+{
+	u32 i, cmd_strlen, *para_start_addr, para_val;
+	char *fw_status_cmd;
+	u16 id = FWSTATUS_OPCODE_MASK;
+	struct mac_ax_fwstatus_payload data;
+	u32 hal_cmd_ary_size = sizeof(mac_fw_status_cmd_i) / sizeof(struct mac_hal_cmd_info);
+
+	if (input_num < OPCODE_HDR_LEN) {
+		//PLTFM_MSG_TRACE("fw status invalid op code\n");
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\nfw status invalid op code\n");
+		return MACFWSTATUSFAIL;
+	}
+	if (input_num > MAX_FWSTATSUS_PKT_LEN) {
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\nfw status argument should be less than 10\n");
+		return MACFWSTATUSFAIL;
+	}
+	 /* Parsing Cmd ID */
+	fw_status_cmd = input[1];
+	cmd_strlen = PLTFM_STRLEN(fw_status_cmd);
+	for (i = 0; i < cmd_strlen; i++) {
+		if (*fw_status_cmd == '\n')
+			*fw_status_cmd = '\0';
+		fw_status_cmd++;
+	}
+	for (i = 0; i < hal_cmd_ary_size; i++) {
+		//PLTFM_MSG_TRACE("[FW STATUS]input string : [%s], input_num = %d\n",
+		//		input[1], input_num);
+		//PLTFM_MSG_TRACE("mac_fw_status_cmd_i[i].name : [%s]",mac_fw_status_cmd_i[i].name);
+		//MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		//	"[FW STATUS]input string : [%s], input_num = %d\n",
+		//	input[1], input_num);
+		//MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		//	"mac_fw_status_cmd_i[i].name : [%s]", mac_fw_status_cmd_i[i].name);
+		if (PLTFM_STRCMP(mac_fw_status_cmd_i[i].name, input[1]) == 0) {
+			id = mac_fw_status_cmd_i[i].id;
+			//PLTFM_MSG_TRACE("enter fw status dbg %s\n", mac_fw_status_cmd_i[i].name);
+			//MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			//	"enter fw status dbg %s\n", mac_fw_status_cmd_i[i].name);
+			break;
+		}
+	}
+	if (i == hal_cmd_ary_size) {
+		//PLTFM_MSG_TRACE("FW STATUS command not found!\n");
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "FW STATUS command not found!\n");
+		return MACFWSTATUSFAIL;
+	}
+	// gen h2c
+	data.dword0 = (u32)id;
+	data.dword1 = (u32)input_num - OPCODE_HDR_LEN;
+	if (input_num > OPCODE_HDR_LEN) {
+		para_start_addr = &data.dword2;
+		for (i = OPCODE_HDR_LEN; i < input_num; i++) {
+			para_val = PLTFM_STRTOUL(input[i], 16);
+			*para_start_addr = para_val;
+			para_start_addr++;
+		}
+		/*
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "input parameter num = %d\n", input_num);
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "data 0 = 0x%x\n", data.dword0);
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "data 1 = 0x%x\n", data.dword1);
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "data 2 = 0x%x\n", data.dword2);
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "data 3 = 0x%x\n", data.dword3);
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "data 4 = 0x%x\n", data.dword4);
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "data 5 = 0x%x\n", data.dword5);
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "data 6 = 0x%x\n", data.dword6);
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "data 7 = 0x%x\n", data.dword7);
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "data 8 = 0x%x\n", data.dword8);
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "data 9 = 0x%x\n", data.dword9);
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "data10 = 0x%x\n", data.dword10);
+		 *MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		 *	    "data11 = 0x%x\n", data.dword11);
+		 */
+	}
+	if (mac_fw_status_cmd(adapter, &data)) {
+		//PLTFM_MSG_TRACE("FW STATUS H2C Fail!\n");
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "FW STATUS H2C Fail!\n");
+		return MACFWSTATUSFAIL;
+	}
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_dl_sym(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+		   u32 input_num, char *output, u32 out_len, u32 *used)
+{
+#if MAC_AX_FEATURE_DBGDEC
+	u32 val, ret;
+	struct mac_ax_adapter *mac = adapter;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u8 *symbol_ptr = NULL;
+	u32 file_size = 0;
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "down symbol.bin\n");
+	// input argument start from input[1], input[0] is mac_hal_cmd_info.name
+	if (input_num < 2) {
+		//PLTFM_MSG_TRACE("invalid argument\n");
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "invalid argument\n");
+		return MACFWSTATUSFAIL;
+	}
+	//PLTFM_SSCANF(input[1], "%d", &val);
+	val = PLTFM_STRTOUL(input[1], 10);
+
+	if (val == 1) {
+		// download file
+		// PLTFM_DL file, assign symbol_ptr and file_size
+		switch (hw_info->chip_id) {
+#if MAC_AX_8852A_SUPPORT
+		case MAC_AX_CHIP_ID_8852A:
+			ret = PLTFM_LD_FW_SYMBOL("hal8852a_msg_symbol.bin", &symbol_ptr,
+						 &file_size);
+			break;
+#endif
+#if MAC_AX_8852B_SUPPORT
+		case MAC_AX_CHIP_ID_8852B:
+			ret = PLTFM_LD_FW_SYMBOL("hal8852b_msg_symbol.bin", &symbol_ptr,
+						 &file_size);
+			break;
+#endif
+#if MAC_AX_8852C_SUPPORT
+		case MAC_AX_CHIP_ID_8852C:
+			ret = PLTFM_LD_FW_SYMBOL("hal8852c_msg_symbol.bin", &symbol_ptr,
+						 &file_size);
+			break;
+#endif
+#if MAC_AX_8192XB_SUPPORT
+		case MAC_AX_CHIP_ID_8192XB:
+			ret = PLTFM_LD_FW_SYMBOL("hal8192xb_msg_symbol.bin", &symbol_ptr,
+						 &file_size);
+			break;
+#endif
+#if MAC_AX_8851B_SUPPORT
+		case MAC_AX_CHIP_ID_8851B:
+			ret = PLTFM_LD_FW_SYMBOL("hal8851b_msg_symbol.bin", &symbol_ptr,
+						 &file_size);
+			break;
+#endif
+#if MAC_AX_8851E_SUPPORT
+		case MAC_AX_CHIP_ID_8851E:
+			ret = PLTFM_LD_FW_SYMBOL("hal8851e_msg_symbol.bin", &symbol_ptr,
+						 &file_size);
+			break;
+#endif
+#if MAC_AX_8852D_SUPPORT
+		case MAC_AX_CHIP_ID_8852D:
+			ret = PLTFM_LD_FW_SYMBOL("hal8852d_msg_symbol.bin", &symbol_ptr,
+						 &file_size);
+			break;
+#endif
+		default:
+			return MACFWSTATUSFAIL;
+			break;
+		}
+
+		if (ret != MACSUCCESS) {
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "reading fw failed !!!\n");
+			return MACFWSTATUSFAIL;
+		}
+
+		ret = mac->ops->fw_log_set_array(adapter, (void *)symbol_ptr, file_size);
+		if (ret != MACSUCCESS) {
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "load symbol failed\n");
+			return MACFWSTATUSFAIL;
+		}
+	} else if (val == 0) {
+		//release file
+		ret = mac->ops->fw_log_unset_array(adapter);
+		if (ret != MACSUCCESS)
+			return MACFWSTATUSFAIL;
+	}
+	return MACSUCCESS;
+#endif
+}
+
+u32 cmd_mac_tbtt_tuning(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+			char *output, u32 out_len, u32 *used)
+{
+	u32 ret = MACSUCCESS;
+	struct mac_ax_tbtt_tuning_info parm;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct mac_ax_tbtt_tuning_info));
+
+	if (input_num < 4) {
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\ninvalid argument\n");
+		return MACFWSTATUSFAIL;
+	}
+
+	parm.band = PLTFM_STRTOUL(input[1], 10);
+	parm.port = PLTFM_STRTOUL(input[2], 10);
+	parm.shift_val = PLTFM_STRTOUL(input[3], 10);
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "\n%s: band:%d port:%d shift_val:%d\n",
+		    __func__, parm.band, parm.port, parm.shift_val);
+
+	ret = mac_tbtt_tuning_cfg(adapter, &parm);
+
+	return ret;
+}
+
+u32 cmd_mac_qc_start(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		     char *output, u32 out_len, u32 *used)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32[4];
+	struct mac_ax_fwstatus_payload data;
+	u8 val8;
+
+	/* dump fw status reg */
+	val32[0] = MAC_REG_R32(R_AX_HALT_C2H);
+	val32[1] = MAC_REG_R32(R_AX_UDM0);
+	val32[2] = MAC_REG_R32(R_AX_UDM1);
+	val32[3] = MAC_REG_R32(R_AX_UDM2);
+
+	/* initial fw status register*/
+	MAC_REG_W32(R_AX_HALT_C2H, 0);
+	MAC_REG_W8(R_AX_UDM0 + 1, 0);
+	MAC_REG_W32(R_AX_UDM1, 0);
+	MAC_REG_W32(R_AX_UDM2, 0);
+
+#if 0
+	PLTFM_MSG_TRACE("\nQC Start:");
+	PLTFM_MSG_TRACE("\n0x016c[31:0] = 0x%08x", val32[0]);
+	PLTFM_MSG_TRACE("\n0x01f0[31:0] = 0x%08x", val32[1]);
+	PLTFM_MSG_TRACE("\n0x01f4[31:0] = 0x%08x", val32[2]);
+	PLTFM_MSG_TRACE("\n0x01f8[31:0] = 0x%08x", val32[3]);
+#endif
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "\n0x016c[31:0] = 0x%08x", val32[0]);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "\n0x01f0[31:0] = 0x%08x", val32[1]);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "\n0x01f4[31:0] = 0x%08x", val32[2]);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "\n0x01f8[31:0] = 0x%08x", val32[3]);
+
+	val8 = (u8)((val32[1] & 0x0000FF00) >> 8);
+
+	/* Fail: reg0x16c >=0x1000 && reg0x16c != 0x1002. Fail: 0<reg0x1f1<0x80 */
+	if ((val32[0] != 0x1002 && val32[0] >= 0x1000) || (val8 < 0x80 && val8 > 0)) {
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n\n==> [Register Check]:FAIL!!\n\n");
+	} else {
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n\n==> [Register Check]:PASS!!\n\n");
+	}
+
+	/* dump heapinfo */
+	data.dword0 = (u32)FW_STATUS_HEAPINFO;
+	data.dword1 = 0;
+
+	qc_cmd_id = 1;
+
+	if (mac_fw_status_cmd(adapter, &data)) {
+		//PLTFM_MSG_TRACE("FW STATUS H2C Fail!\n");
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\nFW STATUS H2C Fail!\n");
+		return MACFWSTATUSFAIL;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_qc_end(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		   char *output, u32 out_len, u32 *used)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32[4];
+	struct mac_ax_fwstatus_payload data;
+	u8 val8;
+
+	/* dump fw status reg */
+	val32[0] = MAC_REG_R32(R_AX_HALT_C2H);
+	val32[1] = MAC_REG_R32(R_AX_UDM0);
+	val32[2] = MAC_REG_R32(R_AX_UDM1);
+	val32[3] = MAC_REG_R32(R_AX_UDM2);
+
+#if 0
+	PLTFM_MSG_TRACE("\nQC End:");
+	PLTFM_MSG_TRACE("\n0x016c[31:0] = 0x%08x", val32[0]);
+	PLTFM_MSG_TRACE("\n0x01f0[31:0] = 0x%08x", val32[1]);
+	PLTFM_MSG_TRACE("\n0x01f4[31:0] = 0x%08x", val32[2]);
+	PLTFM_MSG_TRACE("\n0x01f8[31:0] = 0x%08x", val32[3]);
+#endif
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "\n0x016c[31:0] = 0x%08x", val32[0]);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "\n0x01f0[31:0] = 0x%08x", val32[1]);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "\n0x01f4[31:0] = 0x%08x", val32[2]);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "\n0x01f8[31:0] = 0x%08x", val32[3]);
+
+	val8 = (u8)((val32[1] & 0x0000FF00) >> 8);
+
+	/* Fail: reg0x16c >=0x1000 && reg0x16c != 0x1002. Fail: 0<reg0x1f1<0x80 */
+	if ((val32[0] != 0x1002 && val32[0] >= 0x1000) || (val8 < 0x80 && val8 > 0)) {
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n\n==> [Register Check]:FAIL!!\n\n");
+	} else {
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n\n==> [Register Check]:PASS!!\n\n");
+	}
+
+	/* dump heapinfo */
+	data.dword0 = (u32)FW_STATUS_HEAPINFO;
+	data.dword1 = 0;
+
+	qc_cmd_id = 2;
+
+	if (mac_fw_status_cmd(adapter, &data)) {
+		//PLTFM_MSG_TRACE("FW STATUS H2C Fail!\n");
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\nFW STATUS H2C Fail!\n");
+		return MACFWSTATUSFAIL;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_req_pwr_st(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		       char *output, u32 out_len, u32 *used)
+{
+	u32 req_pwr_st = 0, ret = MACSUCCESS;
+
+	if (input_num < 2) {
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\ninvalid argument\n");
+		return MACFWSTATUSFAIL;
+	}
+
+	req_pwr_st = PLTFM_STRTOUL(input[1], 10);
+
+	switch (req_pwr_st) {
+	case REQ_PWR_ST_OPEN_RF:
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n%s: OPEN_RF\n", __func__);
+		break;
+	case REQ_PWR_ST_CLOSE_RF:
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n%s: CLOSE_RF\n", __func__);
+		break;
+	case REQ_PWR_ST_ADC_OFF:
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n%s: ADC_OFF\n", __func__);
+		break;
+	case REQ_PWR_ST_BB_OFF:
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n%s: BB_OFF\n", __func__);
+		break;
+	case REQ_PWR_ST_CPU_OFF:
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n%s: CPU_OFF\n", __func__);
+		break;
+	case REQ_PWR_ST_MAC_OFF:
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n%s: MAC_OFF\n", __func__);
+		break;
+	case REQ_PWR_ST_PLL_OFF:
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n%s: PLL_OFF\n", __func__);
+		break;
+	case REQ_PWR_ST_SWRD_OFF:
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n%s: SWRD_OFF\n", __func__);
+		break;
+	case REQ_PWR_ST_XTAL_OFF:
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n%s: XTAL_OFF\n", __func__);
+		break;
+	case REQ_PWR_ST_ADIE_OFF:
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n%s: ADIE_OFF\n", __func__);
+		break;
+	case REQ_PWR_ST_BYPASS_DATA_ON:
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n%s: BYPASS_DATA_ON\n", __func__);
+		break;
+	default:
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\n%s: nonvalid cmd\n", __func__);
+		break;
+	}
+
+	ret = mac_req_pwr_state_cfg(adapter, (enum mac_req_pwr_st)req_pwr_st);
+
+	return ret;
+}
+
+u32 cmd_mac_req_pwr_lvl(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+			char *output, u32 out_len, u32 *used)
+{
+	u32 ret = MACSUCCESS;
+	struct mac_ax_req_pwr_lvl_info parm;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct mac_ax_req_pwr_lvl_info));
+
+	if (input_num < 5) {
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\ninvalid argument\n");
+		return MACFWSTATUSFAIL;
+	}
+
+	parm.macid = PLTFM_STRTOUL(input[1], 10);
+	parm.bcn_to_val = PLTFM_STRTOUL(input[2], 10);
+	parm.ps_lvl = PLTFM_STRTOUL(input[3], 10);
+	parm.trx_lvl = PLTFM_STRTOUL(input[4], 10);
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "\n%s: macid:%d req_bcn_to_val:%d req_ps_lvl:%d req_trx_lvl:%d\n",
+		    __func__, parm.macid, parm.bcn_to_val, parm.ps_lvl, parm.trx_lvl);
+
+	ret = mac_req_pwr_lvl_cfg(adapter, &parm);
+
+	return ret;
+}
+
+u32 cmd_mac_fw_chsw(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		    char *output, u32 out_len, u32 *used)
+{
+	// struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_ch_switch_parm parm = {0};
+	u8 channel;
+
+	if (input_num < 2) {
+		//PLTFM_MSG_TRACE("invalid argument\n");
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    " invalid argument\n");
+		return MACFWSTATUSFAIL;
+	}
+
+	channel = (u8)PLTFM_STRTOUL(input[2], 10);
+
+	if (PLTFM_STRCMP(input[1], "24G") == 0)
+		parm.ch_band = BAND_ON_24G;
+	else if (PLTFM_STRCMP(input[1], "5G") == 0)
+		parm.ch_band = BAND_ON_5G;
+	else if (PLTFM_STRCMP(input[1], "6G") == 0)
+		parm.ch_band = BAND_ON_6G;
+	else
+		return MACFWSTATUSFAIL;
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "\n channel = %d / ch_band = %d\n", channel, parm.ch_band);
+
+	parm.pri_ch = channel;
+	parm.central_ch = channel;
+
+	mac_ch_switch_ofld(adapter, parm);
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_fw_chsw_ret(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+			char *output, u32 out_len, u32 *used)
+{
+	// struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_ch_switch_rpt rpt = {0};
+
+	mac_get_ch_switch_rpt(adapter, &rpt);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "\n Channel switch result (%d)\n", rpt.result);
+
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_bcn_stats(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		      char *output, u32 out_len, u32 *used)
+{
+	static u32 bcn_early_cnt;
+	static u32 bcn_rx_cnt;
+	u32 bcn_early_tmp;
+	u32 bcn_rx_tmp;
+	u32 dbg_addr = mac_get_ple_dbg_addr(adapter);
+
+	if (PLTFM_STRCMP(input[1], "start") == 0) {
+		bcn_early_cnt = mac_sram_dbg_read(adapter,
+						  dbg_addr + R_COMMON_BCNEARLY, SHARED_BUF_SEL);
+		bcn_rx_cnt = mac_sram_dbg_read(adapter,
+					       dbg_addr + R_COMMON_BCN_CNT, SHARED_BUF_SEL);
+
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\nStart. Current bcn_early_cnt = %d, bcn_rx_cnt = %d\n",
+			    bcn_early_cnt, bcn_rx_cnt);
+	} else if (PLTFM_STRCMP(input[1], "end") == 0) {
+		bcn_early_tmp = mac_sram_dbg_read(adapter,
+						  dbg_addr + R_COMMON_BCNEARLY, SHARED_BUF_SEL);
+		bcn_early_tmp -= bcn_early_cnt;
+		bcn_rx_tmp = mac_sram_dbg_read(adapter,
+					       dbg_addr + R_COMMON_BCN_CNT, SHARED_BUF_SEL);
+		bcn_rx_tmp -= bcn_rx_cnt;
+
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			    "\nEnd. Diff bcn_early_cnt = %d, bcn_rx_cnt = %d, ratio = %d\n",
+			    bcn_early_tmp, bcn_rx_tmp, bcn_rx_tmp * 100 / bcn_early_tmp);
+	} else {
+		return MACFWSTATUSFAIL;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_dbg_read(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		     char *output, u32 out_len, u32 *used)
+{
+	u32 ret, offset, size;
+	enum mac_ax_sram_dbg_sel sel = AXIDMA_SEL;
+	u32 i = 0;
+	u32 reg_base = 0;
+
+	offset = PLTFM_STRTOUL(input[2], 16);
+	size = PLTFM_STRTOUL(input[3], 10);
+
+	if (input_num == 4) {
+		if (PLTFM_STRCMP(input[1], "AXIDMA_SEL") == 0) {
+			sel = AXIDMA_SEL;
+			reg_base = AXIDMA_BASE_ADDR + offset;
+		} else if (PLTFM_STRCMP(input[1], "STA_SCHED_SEL") == 0) {
+			sel = STA_SCHED_SEL;
+			reg_base = STA_SCHED_BASE_ADDR;
+		} else if (PLTFM_STRCMP(input[1], "RXPLD_FLTR_CAM_SEL") == 0) {
+			sel = RXPLD_FLTR_CAM_SEL;
+			reg_base = RXPLD_FLTR_CAM_BASE_ADDR;
+		} else if (PLTFM_STRCMP(input[1], "SEC_CAM_SEL") == 0) {
+			sel = SEC_CAM_SEL;
+			reg_base = SEC_CAM_BASE_ADDR;
+		} else if (PLTFM_STRCMP(input[1], "WOW_CAM_SEL") == 0) {
+			sel = WOW_CAM_SEL;
+			reg_base = WOW_CAM_BASE_ADDR;
+		} else if (PLTFM_STRCMP(input[1], "CMAC_TBL_SEL") == 0) {
+			sel = CMAC_TBL_SEL;
+			reg_base = CMAC_TBL_BASE_ADDR;
+		} else if (PLTFM_STRCMP(input[1], "ADDR_CAM_SEL") == 0) {
+			sel = ADDR_CAM_SEL;
+			reg_base = ADDR_CAM_BASE_ADDR;
+		} else if (PLTFM_STRCMP(input[1], "BSSID_CAM_SEL") == 0) {
+			sel = BSSID_CAM_SEL;
+			reg_base = BSSID_CAM_BASE_ADDR;
+		} else if (PLTFM_STRCMP(input[1], "BA_CAM_SEL") == 0) {
+			sel = BA_CAM_SEL;
+			reg_base = BA_CAM_BASE_ADDR;
+		} else if (PLTFM_STRCMP(input[1], "BCN_IE_CAM0_SEL") == 0) {
+			sel = BCN_IE_CAM0_SEL;
+			reg_base = BCN_IE_CAM0_BASE_ADDR;
+		} else if (PLTFM_STRCMP(input[1], "SHARED_BUF_SEL") == 0) {
+			sel = SHARED_BUF_SEL;
+			reg_base = SHARED_BUF_BASE_ADDR;
+		} else if (PLTFM_STRCMP(input[1], "DMAC_TBL_SEL") == 0) {
+			sel = DMAC_TBL_SEL;
+			reg_base = DMAC_TBL_BASE_ADDR;
+		} else if (PLTFM_STRCMP(input[1], "SHCUT_MACHDR_SEL") == 0) {
+			sel = SHCUT_MACHDR_SEL;
+			reg_base = SHCUT_MACHDR_BASE_ADDR;
+		} else if (PLTFM_STRCMP(input[1], "BCN_IE_CAM1_SEL") == 0) {
+			sel = BCN_IE_CAM1_SEL;
+			reg_base = BCN_IE_CAM1_BASE_ADDR;
+		}
+		for (i = 0; i < size; i += 4) {
+			ret = mac_sram_dbg_read(adapter, offset + i, sel);
+			PLTFM_MSG_ALWAYS("(0x%X) : 0x%X\n", reg_base + offset + i, ret);
+		}
+	} else if (input_num == 2) {
+		if (PLTFM_STRCMP(input[1], "-h") == 0) {
+			PLTFM_MSG_ALWAYS("Please type cmd mac dbg_write <dbg_sel >"\
+			"<offset (4 byte aligned)> <val (DWORD)>\n"\
+			"\ndbg_sel list:\n\n"\
+			"1.  AXIDMA_SEL <offset> <size>\n" \
+			"2.  STA_SCHED_SEL <offset> <size>\n" \
+			"3.  RXPLD_FLTR_CAM_SEL <offset> <size>\n"\
+			"4.  SEC_CAM_SEL <offset> <size>\n" \
+			"5.  WOW_CAM_SEL <offset> <size>\n" \
+			"6.  CMAC_TBL_SEL <offset> <size>\n" \
+			"7.  ADDR_CAM_SEL <offset> <size>\n" \
+			"8.  BSSID_CAM_SEL <offset> <size>\n" \
+			"9.  BA_CAM_SEL <offset> <size>\n"\
+			"10. BCN_IE_CAM0_SEL <offset> <size>\n" \
+			"11. SHARED_BUF_SEL <offset> <size>\n"\
+			"12. DMAC_TBL_SEL <offset> <size>\n" \
+			"13. SHCUT_MACHDR_SEL <offset> <size>\n" \
+			"14. BCN_IE_CAM1_SEL <offset> <size>\n");
+			return MACNOITEM;
+		}
+	} else {
+		PLTFM_MSG_ERR(" 'cmd mac dbg_read -h' list available  selection.\n");
+		return MACNOITEM;
+	}
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_dbg_write(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		      char *output, u32 out_len, u32 *used)
+{
+	u32 reg_base, val, offset, ret;
+	enum mac_ax_sram_dbg_sel sel = AXIDMA_SEL;
+
+	reg_base = 0;
+	offset = PLTFM_STRTOUL(input[2], 16);
+	val = PLTFM_STRTOUL(input[3], 16);
+	if (offset & (4 - 1)) {
+		PLTFM_MSG_ERR("[ERR]not 4byte alignment\n");
+		return MACBUFSZ;
+	}
+
+	if (input_num == 4) {
+		if (PLTFM_STRCMP(input[1], "AXIDMA_SEL") == 0)
+			sel = AXIDMA_SEL;
+		else if (PLTFM_STRCMP(input[1], "STA_SCHED_SEL") == 0)
+			sel = STA_SCHED_SEL;
+		else if (PLTFM_STRCMP(input[1], "RXPLD_FLTR_CAM_SEL") == 0)
+			sel = RXPLD_FLTR_CAM_SEL;
+		else if (PLTFM_STRCMP(input[1], "SEC_CAM_SEL") == 0)
+			sel = SEC_CAM_SEL;
+		else if (PLTFM_STRCMP(input[1], "WOW_CAM_SEL") == 0)
+			sel = WOW_CAM_SEL;
+		else if (PLTFM_STRCMP(input[1], "CMAC_TBL_SEL") == 0)
+			sel = CMAC_TBL_SEL;
+		else if (PLTFM_STRCMP(input[1], "ADDR_CAM_SEL") == 0)
+			sel = ADDR_CAM_SEL;
+		else if (PLTFM_STRCMP(input[1], "BSSID_CAM_SEL") == 0)
+			sel = BSSID_CAM_SEL;
+		else if (PLTFM_STRCMP(input[1], "BA_CAM_SEL") == 0)
+			sel = BA_CAM_SEL;
+		else if (PLTFM_STRCMP(input[1], "BCN_IE_CAM0_SEL") == 0)
+			sel = BCN_IE_CAM0_SEL;
+		else if (PLTFM_STRCMP(input[1], "SHARED_BUF_SEL") == 0)
+			sel = SHARED_BUF_SEL;
+		else if (PLTFM_STRCMP(input[1], "DMAC_TBL_SEL") == 0)
+			sel = DMAC_TBL_SEL;
+		else if (PLTFM_STRCMP(input[1], "SHCUT_MACHDR_SEL") == 0)
+			sel = SHCUT_MACHDR_SEL;
+		else if (PLTFM_STRCMP(input[1], "BCN_IE_CAM1_SEL") == 0)
+			sel = BCN_IE_CAM1_SEL;
+		ret = mac_sram_dbg_write (adapter, offset, val, sel);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("Write Error!!\n");
+	} else if (input_num == 2) {
+		if (PLTFM_STRCMP(input[1], "-h") == 0) {
+			PLTFM_MSG_ALWAYS("Please type cmd mac dbg_write <dbg_sel >"\
+			"<offset (4 byte aligned)> <val (DWORD)>\n"\
+			"\ndbg_sel list:\n\n"\
+			"1.  AXIDMA_SEL <offset> <val>\n" \
+			"2.  STA_SCHED_SEL <offset> <val>\n" \
+			"3.  RXPLD_FLTR_CAM_SEL <offset> <val>\n"\
+			"4.  SEC_CAM_SEL <offset> <val>\n" \
+			"5.  WOW_CAM_SEL <offset> <val>\n" \
+			"6.  CMAC_TBL_SEL <offset> <val>\n" \
+			"7.  ADDR_CAM_SEL <offset> <val>\n" \
+			"8.  BSSID_CAM_SEL <offset> <val>\n" \
+			"9.  BA_CAM_SEL <offset> <val>\n"\
+			"10. BCN_IE_CAM0_SEL <offset> <val>\n" \
+			"11. SHARED_BUF_SEL <offset> <val>\n"\
+			"12. DMAC_TBL_SEL <offset> <val>\n" \
+			"13. SHCUT_MACHDR_SEL <offset> <val>\n" \
+			"14. BCN_IE_CAM1_SEL <offset> <val>\n");
+			return MACNOITEM;
+		}
+	} else {
+		PLTFM_MSG_ERR(" 'cmd mac dbg_write -h' list available  selection.\n");
+		return MACNOITEM;
+	}
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_bd_status(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		      char *output, u32 out_len, u32 *used)
+{
+	u32 ret;
+
+	ret = mac_bdinfo_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN] mac bd_status dump err %d\n", ret);
+
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_tx_cnt(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		   char *output, u32 out_len, u32 *used)
+{
+	u32 ret;
+	u8 band;
+
+	if (input_num == 2) {
+		band = PLTFM_STRCMP(input[1], "1") == 0 ? 1 : 0;
+		/* dump TMAC tr counter */
+		ret = tx_cnt_dump(adapter, band, TXFLOW_TRX_CNT_REPT_CNT);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B%d tx cnt dump err %d\n", band, ret);
+	} else {
+		PLTFM_MSG_ERR("Command example: \"cmd mac dbg_tx_cnt <band number>\"\n");
+	}
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_rx_cnt(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		   char *output, u32 out_len, u32 *used)
+{
+	u32 ret;
+	u8 band;
+
+	if (input_num == 2) {
+		band = PLTFM_STRCMP(input[1], "1") == 0 ? 1 : 0;
+		/* dump TMAC tr counter */
+		ret = rx_cnt_dump(adapter, band, TRX_CNT_REPT_CNT);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B%d rx cnt dump err %d\n", band, ret);
+	} else {
+		PLTFM_MSG_ERR("Command example: \"cmd mac dbg_rx_cnt <band number>\"\n");
+	}
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_trx_info_macid(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			   u32 input_num, char *output, u32 out_len, u32 *used)
+{
+	u32 macid, band;
+	struct mac_ax_wlaninfo_get info = {0};
+	u32 ret = 0;
+
+	info.info_sel = DUMPWLANS;
+	if (input_num == 4) {
+		macid = PLTFM_STRTOUL(input[2], 10);
+		band = PLTFM_STRTOUL(input[3], 10);
+		info.argv1 = macid;
+		info.argv2 = band;
+		PLTFM_MSG_ERR("Select macid: %d", macid);
+		if (!PLTFM_STRCMP(input[1], "reset")) {
+			info.argv0 = 8;
+			ret = mac_wlaninfo_get(adapter, &info);
+		} else if (!PLTFM_STRCMP(input[1], "dump")) {
+			info.argv0 = 11;
+			ret = mac_wlaninfo_get(adapter, &info);
+		} else {
+			PLTFM_MSG_ERR("Please type cmd mac trx_info" \
+				      "<dump|reset> <macid> <band>\n");
+		}
+	} else {
+		PLTFM_MSG_ERR("Please type cmd mac trx_info " \
+			      "<dump|reset> <macid> <band>\n");
+	}
+	return ret;
+}
+
+u32 cmd_mac_trx_info_global(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			    u32 input_num, char *output, u32 out_len, u32 *used)
+{
+	u32 band;
+	struct mac_ax_wlaninfo_get info = {0};
+	u32 ret = 0;
+
+	info.info_sel = DUMPWLANC;
+	if (input_num == 3) {
+		band = PLTFM_STRTOUL(input[2], 10);
+		info.argv1 = band;
+		if (!PLTFM_STRCMP(input[1], "dump")) {
+			info.argv0 = 0;
+			ret = mac_wlaninfo_get(adapter, &info);
+		} else if (!PLTFM_STRCMP(input[1], "reset")) {
+			info.argv0 = 1;
+			ret = mac_wlaninfo_get(adapter, &info);
+		} else {
+			PLTFM_MSG_ERR("Please type cmd mac trx_info_global" \
+				      "<dump|reset> <band>\n");
+		}
+	} else {
+		PLTFM_MSG_ERR("Please type cmd mac trx_info_global" \
+			      "<dump|reset> <band>\n");
+	}
+	return ret;
+}
+
+u32 cmd_mac_dl_result(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		      char *output, u32 out_len, u32 *used)
+{
+	u32 band;
+	struct mac_ax_wlaninfo_get info = {0};
+	u32 ret = 0;
+
+	info.info_sel = DUMPWLANC;
+	if (input_num == 3) {
+		band = PLTFM_STRTOUL(input[2], 10);
+		info.argv1 = band;
+		if (!PLTFM_STRCMP(input[1], "dump")) {
+			info.argv0 = 2;
+			ret = mac_wlaninfo_get(adapter, &info);
+		} else if (!PLTFM_STRCMP(input[1], "reset")) {
+			info.argv0 = 3;
+			ret = mac_wlaninfo_get(adapter, &info);
+		} else {
+			PLTFM_MSG_ERR("Please type cmd mac dl_result" \
+				      "<dump|reset> <band>\n");
+		}
+	} else {
+		PLTFM_MSG_ERR("Please type cmd mac dl_result" \
+			      "<dump|reset> <band>\n");
+	}
+	return ret;
+}
+
+u32 cmd_mac_curr_wd_cnt(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+			char *output, u32 out_len, u32 *used)
+{
+	u32 band;
+	struct mac_ax_wlaninfo_get info = {0};
+	u32 ret = 0;
+
+	info.info_sel = DUMPWLANC;
+	if (input_num == 2) {
+		band = PLTFM_STRTOUL(input[1], 10);
+		info.argv1 = band;
+		info.argv0 = 7;
+		ret = mac_wlaninfo_get(adapter, &info);
+	} else {
+		PLTFM_MSG_ERR("Please type cmd mac curr_wd_cnt <band>\n");
+	}
+	return ret;
+}
+
+u32 cmd_mac_pkt_cal(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		    char *output, u32 out_len, u32 *used)
+{
+	u32 band;
+	struct mac_ax_wlaninfo_get info = {0};
+	u32 ret = 0;
+
+	info.info_sel = DUMPWLANC;
+	if (input_num == 3) {
+		band = PLTFM_STRTOUL(input[2], 10);
+		info.argv1 = band;
+		if (!PLTFM_STRCMP(input[1], "reset")) {
+			info.argv0 = 11;
+			ret = mac_wlaninfo_get(adapter, &info);
+		} else if (!PLTFM_STRCMP(input[1], "dump")) {
+			info.argv0 = 12;
+			ret = mac_wlaninfo_get(adapter, &info);
+		} else {
+			PLTFM_MSG_ERR("Please type cmd mac pkt_cal" \
+				      "<reset|dump> <band>\n");
+		}
+	} else {
+		PLTFM_MSG_ERR("Please type cmd mac pkt_cal" \
+			      "<reset|dump> <band>\n");
+	}
+	return ret;
+}
+
+u32 cmd_mac_rpt_queue_sts(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			  u32 input_num, char *output, u32 out_len, u32 *used)
+{
+	u32 band;
+	struct mac_ax_wlaninfo_get info = {0};
+	u32 ret = 0;
+
+	info.info_sel = DUMPWLANC;
+	if (input_num == 3) {
+		band = PLTFM_STRTOUL(input[2], 10);
+		info.argv1 = band;
+		if (!PLTFM_STRCMP(input[1], "dump")) {
+			info.argv0 = 16;
+			ret = mac_wlaninfo_get(adapter, &info);
+		} else if (!PLTFM_STRCMP(input[1], "reset")) {
+			info.argv0 = 17;
+			ret = mac_wlaninfo_get(adapter, &info);
+		} else {
+			PLTFM_MSG_ERR("Please type cmd mac rpt_queue_sts" \
+				      "<dump|reset> <band>\n");
+		}
+	} else {
+		PLTFM_MSG_ERR("Please type cmd mac rpt_queue_sts" \
+			      "<dump|reset> <band>\n");
+	}
+	return ret;
+}
+
+s32 mac_halmac_cmd(struct mac_ax_adapter *adapter, char *input, char *output, u32 out_len)
+{
+	char *token;
+	u32 argc = 0;
+	u32 token_len = 0;
+	char argv[MAC_MAX_ARGC][MAC_MAX_ARGV];
+
+	if (output) {
+		adapter->fw_dbgcmd.buf = output;
+		adapter->fw_dbgcmd.out_len = out_len;
+		adapter->fw_dbgcmd.used = 0;
+	} else {
+		PLTFM_MSG_TRACE("%s invalid argument\n", __func__);
+		return MACFWSTATUSFAIL;
+	}
+	do {
+		token = PLTFM_STRSEP(&input, ", ");
+		if (token) {
+			token_len = PLTFM_STRLEN(token);
+			if (token_len <= MAC_MAX_ARGV) {
+				if (token_len > 0) {
+					if (token[token_len - 1] == '\n') {
+						--token_len;
+						token[token_len] = 0;
+					}
+				}
+				PLTFM_STRCPY(argv[argc], token);
+			}
+			argc++;
+		} else {
+			break;
+		}
+	} while (argc < MAC_MAX_ARGC);
+
+	mac_halmac_cmd_parser(adapter, argv, argc, output, out_len);
+
+	return MACSUCCESS;
+}
+
+void mac_halmac_cmd_parser(struct mac_ax_adapter *adapter,
+			   char input[][MAC_MAX_ARGV], u32 input_num,
+			   char *output, u32 out_len)
+{
+	u32 hal_cmd_ary_size = sizeof(mac_hal_cmd_i) / sizeof(struct mac_hal_cmd_info);
+	u32 i = 0;
+	u32 *used;
+
+	if (output) {
+		adapter->fw_dbgcmd.buf = output;
+		adapter->fw_dbgcmd.out_len = out_len;
+		adapter->fw_dbgcmd.used = 0;
+	} else {
+		PLTFM_MSG_TRACE("%s invalid argument\n", __func__);
+		return;
+	}
+
+	used = &adapter->fw_dbgcmd.used;
+	//struct mac_ax_fwstatus_payload data;
+
+	if (hal_cmd_ary_size == 0)
+		return;
+
+	/* Parsing Cmd ID */
+	if (input_num) {
+		for (i = 0; i < hal_cmd_ary_size; i++) {
+			//PLTFM_MSG_TRACE("input string : %s\n, input_num = %d",
+			//		input[0], input_num);
+			if (PLTFM_STRCMP(mac_hal_cmd_i[i].name, input[0]) == 0) {
+				//PLTFM_MSG_TRACE("enter hal dbg %s\n", mac_hal_cmd_i[i].name);
+				//MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				//"enter hal dbg %s\n", mac_hal_cmd_i[i].name);
+				if (mac_hal_cmd_i[i].handler(adapter, input, input_num,
+							     output, out_len, used)) {
+					//PLTFM_MSG_TRACE("%s command process error\n",
+					MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+						    mac_hal_cmd_i[i].name);
+				}
+				PLTFM_DELAY_MS(200);
+				break;
+			}
+		}
+		if (i == hal_cmd_ary_size) {
+			//PLTFM_MSG_TRACE("HAL command not found!\n");
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "HAL command not found!\n");
+			return;
+		}
+	}
+	PLTFM_MSG_TRACE("-----------------------%s function return\n", __func__);
+}
+
+u32 c2h_fw_status(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		  struct rtw_c2h_info *info)
+{
+	//struct c2h_proc_func *proc = c2h_proc_sys_palt_autotest;
+	//u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+	//		struct rtw_c2h_info *info) = NULL;
+	u32 hdr0, ret = MACSUCCESS;
+	u32 func, pkt_cnt, i;
+	u8 *content;
+	struct fw_status_pkt pkt_info;
+	struct fw_status_proc_class *proc = fw_status_proc_sys;
+	char *output = adapter->fw_dbgcmd.buf;
+	u32 *used = &adapter->fw_dbgcmd.used;
+	u32 out_len = adapter->fw_dbgcmd.out_len;
+	//u32 remain_len = out_len - *used;
+
+	PLTFM_MSG_TRACE("[--------------------]%s\n", __func__);
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	//set info
+	info->c2h_cat = GET_FIELD(hdr0, C2H_HDR_CAT);
+	info->c2h_class = GET_FIELD(hdr0, C2H_HDR_CLASS);
+	info->c2h_func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+	//info->done_ack = 0;
+	//info->rec_ack = 0;
+	info->content = buf  + FWCMD_HDR_LEN;
+	//info->h2c_return = info->c2h_data[1];
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	if (func == FWCMD_C2H_FUNC_FW_STATUS) {
+		pkt_cnt = le32_to_cpu(*((u32 *)info->content));
+		//PLTFM_MSG_TRACE("[------------------pkt_cnt--] %d\n", pkt_cnt);
+		content = info->content + LEN_PKTCNT;
+		for (i = 0; i < pkt_cnt; i++) {
+			proc = fw_status_proc_sys;
+			pkt_info.op_code = le32_to_cpu(*((u32 *)(content)));
+			//PLTFM_MSG_TRACE("[------------------op_code--] %d\n", pkt_info.op_code);
+			content += LEN_OPCODE;
+			pkt_info.length = le32_to_cpu(*((u32 *)(content)));
+			//PLTFM_MSG_TRACE("[------------------length--] %d\n", pkt_info.length);
+			content += LEN_LENGTH;
+			pkt_info.data = content;
+			content += pkt_info.length;
+			for (; proc->id != FW_STATUS_MAX; proc++) {
+				if (GET_FIELD_OPCODE(pkt_info.op_code) == proc->id) {
+					MAC_DBG_MSG(out_len, *used, output + *used,
+						    out_len - *used, "\n");
+					ret = proc->handler(adapter, pkt_info.data,
+					pkt_info.length);
+				}
+			}
+		}
+	}
+	return ret;
+}
+
+u32 fw_status_taskinfo_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len)
+{
+	u32 ret = MACSUCCESS;
+	char *output = adapter->fw_dbgcmd.buf;
+	u32 *used = &adapter->fw_dbgcmd.used;
+	u32 out_len = adapter->fw_dbgcmd.out_len;
+	u32 remain_len = out_len - *used;
+
+	if (len > remain_len)
+		return MACFWSTATUSFAIL;
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "Task\t\tState\tPrio\tStack start\tMin Stack(DW)\tNum\tCnt\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "-------------------------------------------\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "%s\n", (const char *)buf);
+
+	//PLTFM_MSG_TRACE("Task\t\tState\tPrio\tStack start\tMin Stack(DW)\tNum\n");
+	//PLTFM_MSG_TRACE("-------------------------------------------\n");
+	//PLTFM_MSG_TRACE("%s", (const char *)buf);
+	return ret;
+}
+
+u32 fw_status_flashinfo_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len)
+{
+	struct flash_info flashinfo;
+	char *output = adapter->fw_dbgcmd.buf;
+	u32 *used = &adapter->fw_dbgcmd.used;
+	u32 out_len = adapter->fw_dbgcmd.out_len;
+	u32 remain_len = out_len - *used;
+
+	if (len > remain_len)
+		return MACFWSTATUSFAIL;
+
+	//PLTFM_MSG_TRACE("[--------------------]%s\n", __func__);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "[--------------------]%s\n", __func__);
+	PLTFM_MEMCPY(&flashinfo, buf, sizeof(struct flash_info));
+	//PLTFM_MSG_TRACE("b1InitDone : %d\n", flashinfo.b1initdone);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "b1InitDone : %d\n", flashinfo.b1initdone);
+	//PLTFM_MSG_TRACE("u1FlashType : %d\n", flashinfo.u1flashtype);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "u1FlashType : %d\n", flashinfo.u1flashtype);
+	//PLTFM_MSG_TRACE("u4FlashSize : %d\n", flashinfo.u4flashsize);
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "u4FlashSize : %d\n", flashinfo.u4flashsize);
+
+	return MACSUCCESS;
+}
+
+u32 fw_status_heapinfo_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len)
+{
+	u32 ret = MACSUCCESS;
+	char *output = adapter->fw_dbgcmd.buf;
+	u32 *used = &adapter->fw_dbgcmd.used;
+	u32 out_len = adapter->fw_dbgcmd.out_len;
+	u32 remain_len = out_len - *used;
+	char *p;
+	char str[160] = {0};
+	char *pstr = str;
+	u8 i = 0;
+	u32 fastheap_free = 0, slowheap_free = 0;
+
+	if (len > remain_len)
+		return MACFWSTATUSFAIL;
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "Index\t\tStart\t\tTotal(B)\tFree(B)\tMin Free(B)\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "-------------------------------------------------------------------\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "%s", (const char *)buf);
+
+	//below is related to qc_start, qc_end cmd
+	if (qc_cmd_id > 0) {
+		PLTFM_MEMCPY(str, buf, len);
+		p = PLTFM_STRSEP(&pstr, "\t");
+		while (p) {
+			//MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+			//    "%s, i=%d\n", (const char *)p, i);
+
+			if (i == 4)
+				fastheap_free = PLTFM_STRTOUL(p, 10);
+			else if (i == 9)
+				slowheap_free = PLTFM_STRTOUL(p, 10);
+
+			i++;
+			p = PLTFM_STRSEP(&pstr, "\t");
+		}
+
+		//MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		//                "fh=%d\n", fastheap_free);
+		//MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		//                "sh=%d\n", slowheap_free);
+
+		if (qc_cmd_id == 1) {
+			fheap_start = fastheap_free;
+			sheap_start = slowheap_free;
+		} else if (qc_cmd_id == 2) {
+			u32 fh_diff = fastheap_free - fheap_start;
+			u32 sh_diff = slowheap_free - sheap_start;
+
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "[Difference] Fast heap : %d\n", fh_diff);
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "[Difference] Slow heap : %d\n", sh_diff);
+
+			if (fheap_start == 0 || sheap_start == 0) {
+				MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+					    "\n==> [Heap check]:Wrong cmd sequence!!\n");
+			} else {
+				if (fh_diff <= FWQC_FAST_HEAP_TH && sh_diff <= FWQC_SLOW_HEAP_TH) {
+					MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+						    "\n==> [Heap check]:PASS!!\n");
+				} else {
+					MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+						    "\n==> [Heap check]:FAIL!!\n");
+				}
+			}
+			fheap_start = 0;
+			sheap_start = 0;
+		}
+		qc_cmd_id = 0;
+	}
+
+	return ret;
+}
+
+u32 fw_status_meminfo_fast_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len)
+{
+	struct mem_info *mem_info;
+	char *output = adapter->fw_dbgcmd.buf;
+	u32 *used = &adapter->fw_dbgcmd.used;
+	u32 out_len = adapter->fw_dbgcmd.out_len;
+	u32 remain_len = out_len - *used;
+
+	if (len > remain_len)
+		return MACFWSTATUSFAIL;
+
+	mem_info = (struct mem_info *)buf;
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "Fast Heap:\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "Owner ID\tType\t\tTotalSize(B)\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "------------------------------------------------\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "%s\n", (const char *)buf);
+	#if 0
+	while (mem_info->total_size != 0) {
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used, "%s\t\t%s\t\t%u\r\n",
+			    MallocIDName[mem_info->owner_id],
+			    MallocTypeName[mem_info->owner_type],
+			    mem_info->total_size);
+		mem_info++;
+	}
+	#endif
+	return MACSUCCESS;
+}
+
+u32 fw_status_meminfo_slow_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len)
+{
+	struct mem_info *mem_info;
+	char *output = adapter->fw_dbgcmd.buf;
+	u32 *used = &adapter->fw_dbgcmd.used;
+	u32 out_len = adapter->fw_dbgcmd.out_len;
+	u32 remain_len = out_len - *used;
+
+	if (len > remain_len)
+		return MACFWSTATUSFAIL;
+
+	mem_info = (struct mem_info *)buf;
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "Slow Heap:\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "Owner ID\tType\t\tTotalSize(B)\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "------------------------------------------------\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "%s\n", (const char *)buf);
+	#if 0
+	while (mem_info->total_size != 0) {
+		MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used, "%s\t\t%s\t\t%u\r\n",
+			    MallocIDName[mem_info->owner_id],
+			    MallocTypeName[mem_info->owner_type],
+			    mem_info->total_size);
+		mem_info++;
+	}
+	#endif
+	return MACSUCCESS;
+}
+
+u32 fw_status_psinfo_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len)
+{
+	char *output = adapter->fw_dbgcmd.buf;
+	u32 *used = &adapter->fw_dbgcmd.used;
+	u32 out_len = adapter->fw_dbgcmd.out_len;
+
+	// Not support now
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "[Err]\n");
+	return MACFWSTATUSFAIL;
+}
+
+u32 fw_status_h2c_c2hinfo_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len)
+{
+	char *output = adapter->fw_dbgcmd.buf;
+	u32 *used = &adapter->fw_dbgcmd.used;
+	u32 out_len = adapter->fw_dbgcmd.out_len;
+
+	// Not support now
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "[Err]\n");
+	return MACFWSTATUSFAIL;
+}
+
+u32 fw_status_isrinfo_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len)
+{
+	struct isr_info *isr_info;
+	char *output = adapter->fw_dbgcmd.buf;
+	u32 *used = &adapter->fw_dbgcmd.used;
+	u32 out_len = adapter->fw_dbgcmd.out_len;
+	u32 remain_len = out_len - *used;
+	u32 i;
+
+	if (len > remain_len)
+		return MACFWSTATUSFAIL;
+
+	isr_info = (struct isr_info *)buf;
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "ISR Name\tCount\t\tExec Time(historical high)\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "------------------------------------------------\n");
+
+	for (i = ISRStatistic_WDT; i < ISRStatistic_MAX; i++) {
+		if (i >= ISRStatistic_DMAC0_GT0) {
+			if (i == ISRStatistic_DMAC0_GT0) {
+				MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+					    "------------------------------------------------\n");
+			}
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "%s\t%u\t\t%u_%u\n", ISRName[i],
+				    isr_info->ISRCnt[i], isr_info->ISRExecTimeMax_hi[i],
+				    isr_info->ISRExecTimeMax_lo[i]);
+		} else {
+			MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+				    "%s\t\t%u\t\t%u_%u\n", ISRName[i],
+				    isr_info->ISRCnt[i], isr_info->ISRExecTimeMax_hi[i],
+				    isr_info->ISRExecTimeMax_lo[i]);
+		}
+	}
+	return MACSUCCESS;
+}
+
+u32 fw_status_chsw_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len)
+{
+	struct chswofld_timing_info *timing;
+	char *output = adapter->fw_dbgcmd.buf;
+	u32 *used = &adapter->fw_dbgcmd.used;
+	u32 out_len = adapter->fw_dbgcmd.out_len;
+	u32 remain_len = out_len - *used;
+
+	if (len > remain_len)
+		return MACFWSTATUSFAIL;
+
+	timing = (struct chswofld_timing_info *)buf;
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    " total: %d us\n\t(mac: %d, bb: %d, rf: %d, rf reld: %d)\n",
+		    timing->total, timing->mac, timing->bb, timing->rf, timing->rf_reld);
+	return MACSUCCESS;
+}
+
+u32 mac_bdinfo_dump(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	char *output = adapter->fw_dbgcmd.buf;
+	u32 *used = &adapter->fw_dbgcmd.used;
+	u32 out_len = adapter->fw_dbgcmd.out_len;
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "TX Related Infomation\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH0_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_ACH0_TXBD_IDX), MAC_REG_R32(R_AX_ACH0_PAGE_INFO));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH1_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_ACH1_TXBD_IDX), MAC_REG_R32(R_AX_ACH1_PAGE_INFO));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH2_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_ACH2_TXBD_IDX), MAC_REG_R32(R_AX_ACH2_PAGE_INFO));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH3_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_ACH3_TXBD_IDX), MAC_REG_R32(R_AX_ACH3_PAGE_INFO));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH4_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_ACH4_TXBD_IDX), MAC_REG_R32(R_AX_ACH4_PAGE_INFO));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH5_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_ACH5_TXBD_IDX), MAC_REG_R32(R_AX_ACH5_PAGE_INFO));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH6_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_ACH6_TXBD_IDX), MAC_REG_R32(R_AX_ACH6_PAGE_INFO));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH7_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_ACH7_TXBD_IDX), MAC_REG_R32(R_AX_ACH7_PAGE_INFO));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH8_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_CH8_TXBD_IDX), MAC_REG_R32(R_AX_CH8_PAGE_INFO));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH9_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_CH9_TXBD_IDX), MAC_REG_R32(R_AX_CH9_PAGE_INFO));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH10_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_CH10_TXBD_IDX), MAC_REG_R32(R_AX_CH10_PAGE_INFO));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH11_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_CH11_TXBD_IDX), MAC_REG_R32(R_AX_CH11_PAGE_INFO));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "CH12_TXBD IDX = 0x%08x PAGE = 0x%08x\n",
+		    MAC_REG_R32(R_AX_CH12_TXBD_IDX), MAC_REG_R32(R_AX_CH12_PAGE_INFO));
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "Used page for group 0/1: 0x%08x\n", MAC_REG_R32(R_AX_PUB_PAGE_INFO1));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "Available page for group 0/1: 0x%08x\n", MAC_REG_R32(R_AX_PUB_PAGE_INFO3));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "Available page for public: 0x%08x\n", MAC_REG_R32(R_AX_PUB_PAGE_INFO2));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "Available page for WP: 0x%08x\n", MAC_REG_R32(R_AX_WP_PAGE_INFO1));
+
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "RX Related Infomation\n");
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "RXQ0 BD IDX: 0x%08x\n", MAC_REG_R32(R_AX_RXQ_RXBD_IDX));
+	MAC_DBG_MSG(out_len, *used, output + *used, out_len - *used,
+		    "RPQ0 BD IDX: 0x%08x\n", MAC_REG_R32(R_AX_RPQ_RXBD_IDX));
+
+	return MACSUCCESS;
+}
+
+#if MAC_AX_FEATURE_DBGDEC
+static void fw_log_private_dump(struct mac_ax_adapter *adapter, u32 *buf, u32 msgno,
+				u8 para_num, u8 isint, char *str_buf)
+{
+	// check data integrity
+	switch (para_num) {
+	case 1:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf));
+		break;
+	case 2:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)));
+		break;
+	case 3:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)));
+		break;
+	case 4:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)));
+		break;
+	case 5:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)));
+		break;
+	case 6:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)));
+		break;
+	case 7:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)));
+		break;
+	case 8:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)));
+		break;
+	case 9:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x,%x,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)));
+		break;
+	case 10:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)));
+		break;
+	case 11:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)),
+			       le32_to_cpu(*(u32 *)(buf + 10)));
+		break;
+	case 12:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)),
+			       le32_to_cpu(*(u32 *)(buf + 10)),
+			       le32_to_cpu(*(u32 *)(buf + 11)));
+		break;
+	case 13:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)),
+			       le32_to_cpu(*(u32 *)(buf + 10)),
+			       le32_to_cpu(*(u32 *)(buf + 11)),
+			       le32_to_cpu(*(u32 *)(buf + 12)));
+		break;
+	case 14:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)),
+			       le32_to_cpu(*(u32 *)(buf + 10)),
+			       le32_to_cpu(*(u32 *)(buf + 11)),
+			       le32_to_cpu(*(u32 *)(buf + 12)),
+			       le32_to_cpu(*(u32 *)(buf + 13)));
+		break;
+	case 15:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)),
+			       le32_to_cpu(*(u32 *)(buf + 10)),
+			       le32_to_cpu(*(u32 *)(buf + 11)),
+			       le32_to_cpu(*(u32 *)(buf + 12)),
+			       le32_to_cpu(*(u32 *)(buf + 13)),
+			       le32_to_cpu(*(u32 *)(buf + 14)));
+		break;
+	case 16:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x)",
+			       msgno,
+			       isint,
+			       para_num,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)),
+			       le32_to_cpu(*(u32 *)(buf + 10)),
+			       le32_to_cpu(*(u32 *)(buf + 11)),
+			       le32_to_cpu(*(u32 *)(buf + 12)),
+			       le32_to_cpu(*(u32 *)(buf + 13)),
+			       le32_to_cpu(*(u32 *)(buf + 14)),
+			       le32_to_cpu(*(u32 *)(buf + 15)));
+		break;
+	default:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       "fw_enc(%d,%d,%d)",
+			       msgno,
+			       isint,
+			       para_num);
+		break;
+	}
+	PLTFM_MSG_ALWAYS("C2H log: %s\n", str_buf);
+	//PLTFM_FREE(str_buf, H2C_LONG_DATA_LEN);
+	//return;
+}
+
+static void fw_log_int_dump(struct mac_ax_adapter *adapter, u32 *buf, u32 msg_array_idx,
+			    u8 para_num, char *str_buf)
+{
+	// check data integrity
+	switch (para_num) {
+	case 1:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf));
+		break;
+	case 2:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)));
+
+		break;
+	case 3:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)));
+		break;
+	case 4:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)));
+		break;
+	case 5:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)));
+		break;
+	case 6:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)));
+		break;
+	case 7:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)));
+		break;
+	case 8:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)));
+		break;
+	case 9:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)));
+		break;
+	case 10:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)));
+		break;
+	case 11:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)),
+			       le32_to_cpu(*(u32 *)(buf + 10)));
+		break;
+	case 12:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)),
+			       le32_to_cpu(*(u32 *)(buf + 10)),
+			       le32_to_cpu(*(u32 *)(buf + 11)));
+		break;
+	case 13:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)),
+			       le32_to_cpu(*(u32 *)(buf + 10)),
+			       le32_to_cpu(*(u32 *)(buf + 11)),
+			       le32_to_cpu(*(u32 *)(buf + 12)));
+		break;
+	case 14:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)),
+			       le32_to_cpu(*(u32 *)(buf + 10)),
+			       le32_to_cpu(*(u32 *)(buf + 11)),
+			       le32_to_cpu(*(u32 *)(buf + 12)),
+			       le32_to_cpu(*(u32 *)(buf + 13)));
+		break;
+	case 15:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)),
+			       le32_to_cpu(*(u32 *)(buf + 10)),
+			       le32_to_cpu(*(u32 *)(buf + 11)),
+			       le32_to_cpu(*(u32 *)(buf + 12)),
+			       le32_to_cpu(*(u32 *)(buf + 13)),
+			       le32_to_cpu(*(u32 *)(buf + 14)));
+		break;
+	case 16:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       le32_to_cpu(*(u32 *)buf),
+			       le32_to_cpu(*(u32 *)(buf + 1)),
+			       le32_to_cpu(*(u32 *)(buf + 2)),
+			       le32_to_cpu(*(u32 *)(buf + 3)),
+			       le32_to_cpu(*(u32 *)(buf + 4)),
+			       le32_to_cpu(*(u32 *)(buf + 5)),
+			       le32_to_cpu(*(u32 *)(buf + 6)),
+			       le32_to_cpu(*(u32 *)(buf + 7)),
+			       le32_to_cpu(*(u32 *)(buf + 8)),
+			       le32_to_cpu(*(u32 *)(buf + 9)),
+			       le32_to_cpu(*(u32 *)(buf + 10)),
+			       le32_to_cpu(*(u32 *)(buf + 11)),
+			       le32_to_cpu(*(u32 *)(buf + 12)),
+			       le32_to_cpu(*(u32 *)(buf + 13)),
+			       le32_to_cpu(*(u32 *)(buf + 14)),
+			       le32_to_cpu(*(u32 *)(buf + 15)));
+		break;
+	default:
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg);
+		break;
+	}
+	PLTFM_MSG_ALWAYS("C2H log: %s\n", str_buf);
+	//return;
+}
+
+u32 fw_log_scan_array(struct mac_ax_adapter *adapter, u32 msgno)
+{
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u32 i = 0, msg_last, array_size;
+
+	if (adapter->fw_log_array_dl_size) {
+		array_size = adapter->fw_log_array_dl_size / sizeof(struct mac_fw_msg);
+		for (i = 0; i < array_size ; i++) {
+			if (adapter->fw_log_array[i].msgno == msgno)
+				return i;
+		}
+		return 0;
+	} else {
+		switch (hw_info->chip_id) {
+#if MAC_AX_8852A_SUPPORT
+		case MAC_AX_CHIP_ID_8852A:
+			msg_last = MSG_8852A_LAST;
+			break;
+#endif
+#if MAC_AX_8852B_SUPPORT
+		case MAC_AX_CHIP_ID_8852B:
+			msg_last = MSG_8852B_LAST;
+			break;
+#endif
+#if MAC_AX_8852C_SUPPORT
+		case MAC_AX_CHIP_ID_8852C:
+			msg_last = MSG_8852C_LAST;
+			break;
+#endif
+#if MAC_AX_8192XB_SUPPORT
+		case MAC_AX_CHIP_ID_8192XB:
+			msg_last = MSG_8192XB_LAST;
+			break;
+#endif
+#if MAC_AX_8851B_SUPPORT
+		case MAC_AX_CHIP_ID_8851B:
+			msg_last = MSG_8851B_LAST;
+			break;
+#endif
+#if MAC_AX_8851E_SUPPORT
+		case MAC_AX_CHIP_ID_8851E:
+			msg_last = MSG_8851E_LAST;
+			break;
+#endif
+#if MAC_AX_8852D_SUPPORT
+		case MAC_AX_CHIP_ID_8852D:
+			msg_last = MSG_8852D_LAST;
+			break;
+#endif
+		default:
+			PLTFM_MSG_WARN("array not exist\n");
+			return 0;
+		}
+		if (msgno >= msg_last)
+			return 0;
+
+		while (adapter->fw_log_array[i].msgno != msg_last) {
+			if (adapter->fw_log_array[i].msgno == msgno)
+				return i;
+			i++;
+		}
+		return 0;
+	}
+}
+
+void fw_log_set_array(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+
+	switch (hw_info->chip_id) {
+#if MAC_AX_8852A_SUPPORT
+	case MAC_AX_CHIP_ID_8852A:
+		adapter->fw_log_array = fw_log_8852a;
+		break;
+#endif
+#if MAC_AX_8852B_SUPPORT
+	case MAC_AX_CHIP_ID_8852B:
+		adapter->fw_log_array = fw_log_8852b;
+		break;
+#endif
+#if MAC_AX_8852C_SUPPORT
+	case MAC_AX_CHIP_ID_8852C:
+		adapter->fw_log_array = fw_log_8852c;
+		break;
+#endif
+#if MAC_AX_8192XB_SUPPORT
+	case MAC_AX_CHIP_ID_8192XB:
+		adapter->fw_log_array = fw_log_8192xb;
+		break;
+#endif
+#if MAC_AX_8851B_SUPPORT
+	case MAC_AX_CHIP_ID_8851B:
+		adapter->fw_log_array = fw_log_8851b;
+		break;
+#endif
+#if MAC_AX_8851E_SUPPORT
+	case MAC_AX_CHIP_ID_8851E:
+		adapter->fw_log_array = fw_log_8851e;
+		break;
+#endif
+#if MAC_AX_8852D_SUPPORT
+	case MAC_AX_CHIP_ID_8852D:
+		adapter->fw_log_array = fw_log_8852d;
+		break;
+#endif
+	default:
+		return;
+	}
+}
+
+void fw_log_dump(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		 struct rtw_c2h_info *info)
+{
+	u8 syntax_3, isint, fileno;
+	u32 msgno_0, msgno_1, msgno_2, msgno_3;
+	u16 lineno_0, lineno_1;
+	u8 para_num, paranum_idx, color;
+	u32 msgno, msg_array_idx;
+	u16 lineno;
+	u8 *para;
+	char str_buf[STR_BUF_SIZE];
+
+	if (!adapter->fw_log_array)
+		fw_log_set_array(adapter);
+	if (!adapter->fw_log_array) {
+		PLTFM_MSG_ERR("[ERR]unsupported fw_log_array\n");
+		return;
+	}
+	color = (*(buf + FWCMD_HDR_LEN + 2)) >> 1;
+	isint = (color & BIT1) >> 1;
+	paranum_idx = color & BIT0;
+	syntax_3 = *(buf + FWCMD_HDR_LEN + 3);
+	msgno_0 = (u32)*(buf + FWCMD_HDR_LEN + 4);
+	msgno_1 = (u32)*(buf + FWCMD_HDR_LEN + 5);
+	msgno_2 = (u32)*(buf + FWCMD_HDR_LEN + 6);
+	msgno_3 = (u32)*(buf + FWCMD_HDR_LEN + 7);
+	msgno = (msgno_0 & 0x000000ff) |
+		((msgno_1 & 0x000000ff) << 8) |
+		((msgno_2 & 0x000000ff) << 16) |
+		((msgno_3 & 0x000000ff) << 24);
+
+	fileno = *(buf + FWCMD_HDR_LEN + 8);
+	lineno_0 = (u16)*(buf + FWCMD_HDR_LEN + 9);
+	lineno_1 = (u16)*(buf + FWCMD_HDR_LEN + 10);
+	lineno = (lineno_0 & 0x00ff) | ((lineno_1 & 0x00ff) << 8);
+	if (paranum_idx) {
+		para_num = *(buf + FWCMD_HDR_LEN + 11);
+		para = (buf + FWCMD_HDR_LEN + 12);
+	} else {
+		para_num = 0;
+		para = NULL;
+	}
+	PLTFM_MEMSET(str_buf, 0, STR_BUF_SIZE);
+	#if 0
+	str_buf = (char *)PLTFM_MALLOC(H2C_LONG_DATA_LEN);
+	if (!str_buf) {
+		PLTFM_MSG_WARN("fw_log_int_dump str_buf 0\n");
+		return;
+	}
+	#endif
+	msg_array_idx = fw_log_scan_array(adapter, msgno);
+	//PLTFM_MSG_WARN("%s, msgno = %d, idx = %d, isint = %d, para_num = %d\n",
+	//__FUNCTION__, msgno, msg_array_idx, isint, para_num);
+	if (isint == 0 && para_num != 0 && msg_array_idx != 0) {
+		if (buf[len - 1] != '\0')
+			buf[len - 1] = '\0';
+
+		PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+			       adapter->fw_log_array[msg_array_idx].msg,
+			       (char *)(buf + FWCMD_HDR_LEN + 12));
+		PLTFM_MSG_ALWAYS("C2H log: %s\n", str_buf);
+	} else if (msg_array_idx != 0 && isint == 1) {
+		fw_log_int_dump(adapter, (u32 *)para, msg_array_idx, para_num, str_buf);
+	} else {
+		// print specific message and msgno, parameters
+		if (isint == 1) {
+			fw_log_private_dump(adapter, (u32 *)para, msgno, para_num, isint, str_buf);
+		} else if (para_num != 0) {
+			PLTFM_SNPRINTF(str_buf, STR_BUF_SIZE,
+				       "fw_enc(%d,%d,%d,%s)",
+				       msgno,
+				       isint,
+				       para_num,
+				       (char *)(buf + FWCMD_HDR_LEN + 12));
+			PLTFM_MSG_ALWAYS("C2H log: %s\n", str_buf);
+		}
+	}
+	//return;
+}
+
+u8 *fw_log_skip_trailing_zero(u8 *s_ptr, u8 *end_ptr)
+{
+	u8 charac;
+
+	while (s_ptr < end_ptr) {
+		charac = *(s_ptr);
+		if (charac != 0x00)
+			break;
+		s_ptr++;
+	}
+	return s_ptr;
+}
+
+u32 fw_log_check_integrity(u8 *symbol_tab, u8 *end_ptr)
+{
+	u8 charac, i = 0;
+	u8 reserved[] = {'R', 'E', 'S', 'E', 'R', 'V', 'E', 'D', '\0'};
+
+	charac = *symbol_tab;
+	while (charac != 0x00) {
+		if (charac != reserved[i])
+			return MACFWLOGINTERR;// return fail
+		i++;
+		if ((symbol_tab + i) >= end_ptr)
+			return MACFWLOGINTERR;// return fail
+		charac = *(symbol_tab + i);
+	}
+	return MACSUCCESS;
+}
+
+u32 fw_log_create_array(struct mac_ax_adapter *adapter, struct mac_fw_msg *array_ptr,
+			u8 *symbol_tab, u8 *end_ptr, u32 enum_count, u8 *enum_list)
+{
+	u32 i;
+	u8 charac;
+
+	for (i = 0; i < enum_count; i++) {
+		array_ptr[i].msgno = le32_to_cpu(*(u32 *)enum_list);
+		enum_list += 4;
+		// walk through symbol table
+		array_ptr[i].msg = (char *)symbol_tab;
+		//PLTFM_MSG_WARN("[test str] %s\n", (char *)symbol_tab);
+		//point to next msg
+		while (symbol_tab < end_ptr) {
+			charac = *(symbol_tab);
+			if (charac == 0x00)
+				break;
+			symbol_tab++;
+		}
+		symbol_tab = fw_log_skip_trailing_zero(symbol_tab, end_ptr);
+		if (symbol_tab > end_ptr)
+			return MACFWLOGINTERR;
+	}
+	return MACSUCCESS;
+}
+
+u32 mac_fw_log_set_array(struct mac_ax_adapter *adapter, void *symbol_ptr, u32 file_size)
+{
+	u8 *sym_hdr, *enum_list, *symbol_tab, *end_ptr;
+	u32 enum_count, alignment_size, ret;
+	struct mac_fw_msg *new_fw_log_array = NULL;
+
+	sym_hdr = (u8 *)symbol_ptr;
+	enum_list = (u8 *)(sym_hdr + 8);
+	alignment_size = le32_to_cpu(*(u32 *)sym_hdr);
+	enum_count = le32_to_cpu(*(u32 *)(sym_hdr + 4));
+	symbol_tab = (u8 *)(enum_list + 4 * enum_count);
+	end_ptr = sym_hdr + file_size;
+	//PLTFM_MSG_WARN("alignment_size = %d, enum_count = %d\n", alignment_size, enum_count);
+	// alignment
+	symbol_tab = fw_log_skip_trailing_zero(symbol_tab, end_ptr);
+
+	// check integrity
+	ret = fw_log_check_integrity(symbol_tab, end_ptr);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]check symbol integrity\n");
+		return MACFWLOGINTERR;// return fail
+	}
+
+	//create array
+	new_fw_log_array = (struct mac_fw_msg *)PLTFM_MALLOC(enum_count *
+			    sizeof(struct mac_fw_msg));
+	if (!new_fw_log_array) {
+		PLTFM_MSG_ERR("[ERR]malloc new_fw_log_array\n");
+		return MACBUFALLOC;
+	}
+
+	//PLTFM_MSG_WARN("addr of array = 0x%llx\n", (u64)new_fw_log_array);
+	ret = fw_log_create_array(adapter, new_fw_log_array, symbol_tab, end_ptr, enum_count,
+				  enum_list);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_WARN("unexpected symbol\n");
+		PLTFM_FREE((void *)new_fw_log_array, enum_count * sizeof(struct mac_fw_msg));
+		return MACFWLOGINTERR;// return fail
+	}
+
+	//PLTFM_FREE((void *)new_fw_log_array, enum_count * sizeof(struct mac_fw_msg));
+	adapter->fw_log_array = new_fw_log_array;
+	adapter->fw_log_array_dl = new_fw_log_array;
+	adapter->fw_log_array_dl_size = enum_count * sizeof(struct mac_fw_msg);
+	return MACSUCCESS;
+}
+
+u32 mac_fw_log_unset_array(struct mac_ax_adapter *adapter)
+{
+	if (adapter->fw_log_array_dl) {
+		PLTFM_FREE(adapter->fw_log_array_dl, adapter->fw_log_array_dl_size);
+		adapter->fw_log_array = NULL;
+		adapter->fw_log_array_dl = NULL;
+		adapter->fw_log_array_dl_size = 0;
+	}
+	fw_log_set_array(adapter);
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_trigger_l0_err(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			   u32 input_num, char *output, u32 out_len, u32 *used)
+{
+	u32 ret;
+
+	ret = mac_trigger_cmac_err (adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ALWAYS("[ERR]Err %d\n", ret);
+		return ret;
+	}
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_trigger_l1_err(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			   u32 input_num, char *output, u32 out_len, u32 *used)
+{
+	u32 ret;
+
+	ret = mac_trigger_dmac_err (adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ALWAYS("[ERR]Err %d\n", ret);
+		return ret;
+	}
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_set_l0_dbg_mode(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			    u32 input_num, char *output, u32 out_len, u32 *used)
+{
+	u32 ret;
+
+	ret = adapter->ops->set_l0_dbg_mode(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ALWAYS("[ERR]Err %d\n", ret);
+		return ret;
+	}
+	return MACSUCCESS;
+}
+
+u32 cmd_mac_set_l1_dbg_mode(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			    u32 input_num, char *output, u32 out_len, u32 *used)
+{
+	u32 ret;
+
+	ret = adapter->ops->set_l1_dbg_mode(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ALWAYS("[ERR]Err %d\n", ret);
+		return ret;
+	}
+	return MACSUCCESS;
+}
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbg_cmd.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbg_cmd.h
new file mode 100644
index 000000000000..67d4812bc76b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbg_cmd.h
@@ -0,0 +1,1109 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+ #ifndef _MAC_AX_DBG_CMD_H_
+#define _MAC_AX_DBG_CMD_H_
+
+#include "../type.h"
+#include "../mac_def.h"
+#include "../mac_ax.h"
+#include "tblupd.h"
+#if MAC_AX_8852A_SUPPORT
+#include "../fw_ax/rtl8852a/hal8852a_fw_log.h"
+#endif
+#if MAC_AX_8852B_SUPPORT
+#include "../fw_ax/rtl8852b/hal8852b_fw_log.h"
+#endif
+#if MAC_AX_8852C_SUPPORT
+#include "../fw_ax/rtl8852c/hal8852c_fw_log.h"
+#endif
+#if MAC_AX_8192XB_SUPPORT
+#include "../fw_ax/rtl8192xb/hal8192xb_fw_log.h"
+#endif
+#if MAC_AX_8851B_SUPPORT
+#include "../fw_ax/rtl8851b/hal8851b_fw_log.h"
+#endif
+#if MAC_AX_8851E_SUPPORT
+#include "../fw_ax/rtl8851e/hal8851e_fw_log.h"
+#endif
+#if MAC_AX_8852D_SUPPORT
+#include "../fw_ax/rtl8852d/hal8852d_fw_log.h"
+#endif
+
+#define FWDGB_CFG_OP_SET 0
+#define FWDGB_CFG_OP_CLR 1
+#define FWDGB_CFG_OP_INFO 2
+
+#define FWDGB_CFG_TYPE_LEVEL 0
+#define FWDGB_CFG_TYPE_OUTPUT 1
+#define FWDGB_CFG_TYPE_COMP 2
+#define FWDGB_CFG_TYPE_COMP_EXT 3
+
+#define LEN_PKT_HDR 8
+#define LEN_PKTCNT 4
+#define LEN_OPCODE 4
+#define LEN_LENGTH 4
+#define FWSTATUS_OPCODE_MASK 0xFFFF
+
+#define FW_CURTCB_AX	0xf5fc
+#define FW_CURTCB_BE	0xf5fc
+#define FW_TCB_ADDR_MASK_AX	0x3FFFF
+#define FW_TCB_ADDR_MASK_BE	0x3FFFF
+#define FW_CURTCB_SP_START_OFFSET 0x30
+#define FW_CURTCB_TASK_NAME_OFFSET 0x34
+#define FW_MAX_TASK_NAME_LEN 16
+
+#define eMallocMAX	23
+#define eMallocTypeMAX	3
+
+#define OPCODE_HDR_LEN 2
+#define MAX_FWSTATSUS_PKT_LEN 12
+//STR_BUF_SIZE , -128 for driver stack size warning
+#define STR_BUF_SIZE (1024 - 128)
+
+#define FWQC_SLOW_HEAP_TH 0
+#define FWQC_FAST_HEAP_TH 0
+
+#define FWCISR_OFFSET 0x08
+#define PORT_CFG_OFFSET 0x40
+
+#define GET_FIELD_OPCODE(opcode) ((opcode) & (FWSTATUS_OPCODE_MASK))
+#define	MAC_DBG_MSG(max_buff_len, used_len, buff_addr, remain_len, fmt, ...)\
+	do {									\
+		u32 *used_len_tmp = &(used_len);				\
+		if (*used_len_tmp < max_buff_len)				\
+			*used_len_tmp += PLTFM_SNPRINTF(buff_addr, remain_len, fmt, ##__VA_ARGS__);\
+	} while (0)
+
+/**
+ * @enum mac_hal_cmd_id
+ *
+ * @brief mac_hal_cmd_id
+ *
+ * @var mac_hal_cmd_id::MAC_HAL_HELP
+ * Please Place Description here.
+ * @var mac_hal_cmd_id::MAC_MAC_DD_DBG
+ * Please Place Description here.
+ * @var mac_hal_cmd_id::MAC_MAC_REG_DUMP
+ * Please Place Description here.
+ * @var mac_hal_cmd_id::MAC_MAC_FW_DBG
+ * Please Place Description here.
+ * @var mac_hal_cmd_id::MAC_MAC_FW_LOG
+ * Please Place Description here.
+ * @var mac_hal_cmd_id::MAC_MAC_FW_CURTCB
+ * Please Place Description here.
+ * @var mac_hal_cmd_id::MAC_MAC_FW_INFO
+ * Please Place Description here.
+ * @var mac_hal_cmd_id::MAC_MAC_QC_START
+ * Please Place Description here.
+ * @var mac_hal_cmd_id::MAC_MAC_QC_END
+ * Please Place Description here.
+ */
+enum mac_hal_cmd_id {
+	MAC_HAL_HELP = 0,
+	MAC_MAC_DD_DBG,
+	MAC_MAC_REG_DUMP,
+	MAC_MAC_FW_DBG,
+	MAC_MAC_FW_LOG,
+	MAC_MAC_FW_CURTCB,
+	MAC_MAC_FW_INFO,
+	MAC_MAC_DBG_TX,
+	MAC_MAC_DBG_RX,
+	MAC_MAC_DBG_DMAC,
+	MAC_MAC_DBG_CMAC,
+	MAC_MAC_DBG_BDSTS,
+	MAC_MAC_DBG_BCN,
+	MAC_MAC_DBG_TX_CNT,
+	MAC_MAC_DBG_RX_CNT,
+	MAC_MAC_ERROR_DUMP,
+	MAC_MAC_SER_CNT_DUMP,
+	MAC_MAC_SET_SER_LVL,
+	MAC_MAC_GET_SER_LVL,
+	MAC_MAC_DL_SYM,
+	MAC_MAC_QC_START,
+	MAC_MAC_QC_END,
+	MAC_MAC_REQ_PWR_ST,
+	MAC_MAC_REQ_PWR_LVL,
+	MAC_MAC_CHSW,
+	MAC_MAC_CHSW_RET,
+	MAC_MAC_TBTT_TUNING,
+	MAC_MAC_DBG_READ,
+	MAC_MAC_DBG_WRITE,
+	MAC_MAC_TRX_INFO_MACID,
+	MAC_MAC_TRX_INFO_GLOBAL,
+	MAC_MAC_DL_RESULT,
+	MAC_MAC_CURR_WD_CNT,
+	MAC_MAC_PKT_CAL,
+	MAC_MAC_RPT_QUEUE_STS,
+	MAC_MAC_TRG_SER_L0,
+	MAC_MAC_TRG_SER_L1,
+	MAC_MAC_SET_SER_L0_DBG,
+	MAC_MAC_SET_SER_L1_DBG
+};
+
+/**
+ * @enum mac_ax_fw_status
+ *
+ * @brief mac_ax_fw_status
+ *
+ * @var mac_ax_fw_status::FW_STATUS_TASKINFO
+ * Please Place Description here.
+ * @var mac_ax_fw_status::FW_STATUS_FLASHINFO
+ * Please Place Description here.
+ * @var mac_ax_fw_status::FW_STATUS_HEAPINFO
+ * Please Place Description here.
+ * @var mac_ax_fw_status::FW_STATUS_MEMINFO_FAST
+ * Please Place Description here.
+ * @var mac_ax_fw_status::FW_STATUS_MEMINFO_SLOW
+ * Please Place Description here.
+ * @var mac_ax_fw_status::FW_STATUS_PSINFO
+ * Please Place Description here.
+ * @var mac_ax_fw_status::FW_STATUS_H2C_C2HINFO
+ * Please Place Description here.
+ * @var mac_ax_fw_status::FW_STATUS_ISRINFO
+ * Please Place Description here.
+ * @var mac_ax_fw_status::FW_STATUS_MAX
+ * Please Place Description here.
+ */
+enum mac_ax_fw_status {
+	FW_STATUS_TASKINFO,
+	FW_STATUS_FLASHINFO,
+	FW_STATUS_HEAPINFO,
+	FW_STATUS_MEMINFO_FAST,
+	FW_STATUS_MEMINFO_SLOW,
+	FW_STATUS_PSINFO,
+	FW_STATUS_H2C_C2HINFO,
+	FW_STATUS_ISRINFO,
+	FW_STATUS_DBGINFO_REG,
+	FW_STATUS_SERINFO,
+	FW_STATUS_CHSW_TIMING,
+	FW_STATUS_MAX
+};
+
+/**
+ * @enum ISRStatistic
+ *
+ * @brief ISRStatistic
+ *
+ * @var ISRStatistic::ISRStatistic_WDT
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_CMAC0
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_CMAC1
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_CMAC2
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_CMAC3
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_CMAC4
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_CMAC5
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_CMAC6
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_CMAC7
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_CMAC8
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_CMAC9
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_CMAC10
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_DMAC0
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_DMAC1
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_DMAC2
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_SYS0
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_IPSec
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_AXIDMA
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_IDDMA
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_MACErr
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_UART
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_RXI300
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_DMAC0_GT0
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_DMAC0_GT1
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_DMAC0_GT2_3
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_DMAC0_H2C
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_SYS0_HALT_H2C
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_SYS0_GPIO
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_MACErr_DMAC
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_MACErr_CMAC0
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_MACErr_CMAC1
+ * Please Place Description here.
+ * @var ISRStatistic::ISRStatistic_MAX
+ * Please Place Description here.
+ */
+enum ISRStatistic {
+	/* Fisrt layer */
+	// WDTISRROM8852A
+	ISRStatistic_WDT = 0,	// no use currently
+	// CMACISRROM8852A
+	ISRStatistic_CMAC0 = 1,
+	ISRStatistic_CMAC1 = 2,
+	ISRStatistic_CMAC2 = 3,
+	ISRStatistic_CMAC3 = 4,
+	ISRStatistic_CMAC4 = 5,
+	ISRStatistic_CMAC5 = 6,
+	ISRStatistic_CMAC6 = 7,
+	ISRStatistic_CMAC7 = 8,
+	ISRStatistic_CMAC8 = 9,
+	ISRStatistic_CMAC9 = 10,
+	ISRStatistic_CMAC10 = 11,
+	// DMACISRROM8852A
+	ISRStatistic_DMAC0 = 12,
+	ISRStatistic_DMAC1 = 13,
+	ISRStatistic_DMAC2 = 14,
+	// SysISRROM8852A
+	ISRStatistic_SYS0 = 15,
+	// DataHDLISRROM8852A
+	ISRStatistic_IPSec = 16,
+	ISRStatistic_AXIDMA = 17,
+	ISRStatistic_IDDMA = 18,
+	// PlatISRROM8852A
+	ISRStatistic_MACErr = 19,
+	ISRStatistic_UART = 20,
+	ISRStatistic_RXI300 = 21,
+	// Second layer
+	ISRStatistic_DMAC0_GT0 = 22,
+	ISRStatistic_DMAC0_GT1 = 23,
+	ISRStatistic_DMAC0_GT2_3 = 24,
+	ISRStatistic_DMAC0_H2C = 25,
+	ISRStatistic_SYS0_HALT_H2C = 26,
+	ISRStatistic_SYS0_GPIO = 27,
+	ISRStatistic_MACErr_DMAC = 28,
+	ISRStatistic_MACErr_CMAC0 = 29,
+	ISRStatistic_MACErr_CMAC1 = 30,
+	ISRStatistic_MAX = 31
+};
+
+/**
+ * @struct mac_hal_cmd_info
+ * @brief mac_hal_cmd_info
+ *
+ * @var mac_hal_cmd_info::name
+ * Please Place Description here.
+ * @var mac_hal_cmd_info::id
+ * Please Place Description here.
+ */
+struct mac_hal_cmd_info {
+	char name[16];
+	u16 id;
+	u32 (*handler)(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+		       u32 input_num, char *output, u32 out_len, u32 *used);
+	char description[256];
+};
+
+/**
+ * @struct fw_status_pkt
+ * @brief fw_status_pkt
+ *
+ * @var fw_status_pkt::op_code
+ * Please Place Description here.
+ * @var fw_status_pkt::length
+ * Please Place Description here.
+ * @var fw_status_pkt::data
+ * Please Place Description here.
+ */
+struct fw_status_pkt {
+	u32 op_code;
+	u32 length;
+	u8 *data;
+};
+
+/**
+ * @struct flash_info
+ * @brief flash_info
+ *
+ * @var flash_info::b1initdone
+ * Please Place Description here.
+ * @var flash_info::b7rsvd
+ * Please Place Description here.
+ * @var flash_info::pid
+ * Please Place Description here.
+ */
+struct flash_info {
+	u8 b1initdone: 1;
+	u8 b7rsvd: 7;
+	u8 pid[3];
+	u8 u1flashtype;
+	u8 u1dienum;
+	u8 dieindex;
+	u8 pageindex;
+	u8 bsupportps; //PS is Page Switch. Page size is 16MB for 3-Bytes address mode.
+	u8 u1addressmode;
+	u8 u1dieunitsize; // unit is "Byte"
+	u8 rsvd1;
+	u32 u4dieunitnum; // unit number of die
+	u32 u4flashsize; // flash total size = u4DieUnitNum * DieNum * FlashUnit.
+};
+
+/**
+ * @struct mem_info
+ * @brief mem_info
+ *
+ * @var mem_info::owner_id
+ * Please Place Description here.
+ * @var mem_info::owner_type
+ * Please Place Description here.
+ * @var mem_info::total_size
+ * Please Place Description here.
+ */
+struct mem_info {
+	u8 owner_id;
+	u8 owner_type;
+	u16 total_size;
+};
+
+/**
+ * @struct isr_info
+ * @brief isr_info
+ *
+ * @var isr_info::ISRCnt
+ * Please Place Description here.
+ * @var isr_info::ISRExecTimeMax_hi
+ * Please Place Description here.
+ * @var isr_info::ISRExecTimeMax_lo
+ * Please Place Description here.
+ */
+struct isr_info {
+	u32 ISRCnt[ISRStatistic_MAX];
+	u32 ISRExecTimeMax_hi[ISRStatistic_MAX];
+	u32 ISRExecTimeMax_lo[ISRStatistic_MAX];
+};
+
+/**
+ * @struct chswofld_timing_info
+ * @brief chswofld_timing_info
+ *
+ * @var chswofld_timing_info::mac
+ * Please Place Description here.
+ * @var chswofld_timing_info::bb
+ * Please Place Description here.
+ * @var chswofld_timing_info::rf
+ * Please Place Description here.
+ * @var chswofld_timing_info::rfReload
+ * Please Place Description here.
+ * @var chswofld_timing_info::total
+ * Please Place Description here.
+
+ */
+struct chswofld_timing_info {
+	u32 mac;
+	u32 bb;
+	u32 rf;
+	u32 rf_reld;
+	u32 total;
+};
+
+/**
+ * @struct fw_status_proc_class
+ * @brief fw_status_proc_class
+ *
+ * @var flash_info::b1initdone
+ * Please Place Description here.
+ * @var flash_info::b7rsvd
+ * Please Place Description here.
+ * @var flash_info::pid
+ * Please Place Description here.
+ */
+struct halcmd_proc_class {
+	u16 id;
+	u32 (*handler)(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV]);
+};
+
+/**
+ * @brief mac_fw_status_parser
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+void mac_fw_status_parser(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			  u32 input_num);
+
+/**
+ * @brief mac_halmac_cmd
+ *
+ * @param *adapter
+ * @param *input
+ * @param *output
+ * @param *out_len
+ * @return Please Place Description here.
+ * @retval s32
+ */
+s32 mac_halmac_cmd(struct mac_ax_adapter *adapter, char *input, char *output, u32 out_len);
+
+/**
+ * @brief mac_halmac_cmd_parser
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @param *output
+ * @param *out_len
+ * @return Please Place Description here.
+ * @retval void
+ */
+void mac_halmac_cmd_parser(struct mac_ax_adapter *adapter,
+			   char input[][MAC_MAX_ARGV], u32 input_num,
+			   char *output, u32 out_len);
+
+/**
+ * @brief c2h_fw_status
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *len
+ * @param *info
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 c2h_fw_status(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		  struct rtw_c2h_info *info);
+
+/**
+ * @brief fw_status_taskinfo_handler
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *len
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 fw_status_taskinfo_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len);
+
+/**
+ * @brief fw_status_flashinfo_handler
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *len
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 fw_status_flashinfo_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len);
+
+/**
+ * @brief fw_status_heapinfo_handler
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *len
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 fw_status_heapinfo_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len);
+
+/**
+ * @brief fw_status_meminfo_fast_handler
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *len
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 fw_status_meminfo_fast_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len);
+
+/**
+ * @brief fw_status_meminfo_slow_handler
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *len
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 fw_status_meminfo_slow_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len);
+
+/**
+ * @brief fw_status_psinfo_handler
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *len
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 fw_status_psinfo_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len);
+
+/**
+ * @brief fw_status_h2c_c2hinfo_handler
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *len
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 fw_status_h2c_c2hinfo_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len);
+
+/**
+ * @brief fw_status_isrinfo_handler
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *len
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 fw_status_isrinfo_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len);
+
+/**
+ * @brief fw_status_chsw_handler
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *len
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 fw_status_chsw_handler(struct mac_ax_adapter *adapter, u8 *buf, u32 len);
+
+/**
+ * @brief cmd_mac_help
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_help(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		 char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_dbg_dump
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_dbg_dump(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		     char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_reg_dump
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_reg_dump(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		     char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_fw_dump
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_fw_dump(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV], u32 input_num,
+		    char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_fw_log_cfg
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_fw_log_cfg(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		       char *output, u32 out_len, u32 *used);
+/**
+ * @brief cmd_mac_fw_curtcb
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_fw_curtcb(struct mac_ax_adapter *adapter,
+		      char input[][MAC_MAX_ARGV],
+		      u32 input_num,
+		      char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_fw_status_parser
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_fw_status_parser(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			     u32 input_num, char *output, u32 out_len, u32 *used);
+
+u32 cmd_mac_dl_sym(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+		   u32 input_num, char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_error_dump
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_error_dump(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		       char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_dbg_tx_dump
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_dbg_tx_dump(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV],
+			u32 input_num, char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_dbg_rx_dump
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_dbg_rx_dump(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV],
+			u32 input_num, char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_dbg_dmac
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_dbg_dmac(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV], u32 input_num,
+		     char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_dbg_cmac
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_dbg_cmac(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV], u32 input_num,
+		     char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_dbg_bcn
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_dbg_bcn(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV], u32 input_num,
+		    char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_ser_cnt_dump
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_ser_cnt_dump(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV], u32 input_num,
+			 char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_qc_start
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_qc_start(struct mac_ax_adapter *adapter,
+		     char input[][MAC_MAX_ARGV],
+		     u32 input_num,
+		     char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_qc_end
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_qc_end(struct mac_ax_adapter *adapter,
+		   char input[][MAC_MAX_ARGV],
+		   u32 input_num,
+		   char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_req_pwr_st
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+
+u32 cmd_mac_req_pwr_st(struct mac_ax_adapter *adapter,
+		       char input[][MAC_MAX_ARGV],
+		       u32 input_num,
+		       char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_req_pwr_lvl
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_req_pwr_lvl(struct mac_ax_adapter *adapter,
+			char input[][MAC_MAX_ARGV],
+			u32 input_num,
+			char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief fw_log_int_dump
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *msgno
+ * @param *para_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+static void fw_log_int_dump(struct mac_ax_adapter *adapter, u32 *buf, u32 msgno, u8 para_num,
+			    char *str_buf);
+
+/**
+ * @brief fw_log_scan_array
+ *
+ * @param *adapter
+ * @param *msgno
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 fw_log_scan_array(struct mac_ax_adapter *adapter, u32 msgno);
+
+/**
+ * @brief fw_log_set_array
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+void fw_log_set_array(struct mac_ax_adapter *adapter);
+
+/**
+ * @brief fw_log_dump
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *len
+ * @param *info
+ * @return Please Place Description here.
+ * @retval void
+ */
+void fw_log_dump(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		 struct rtw_c2h_info *info);
+
+/**
+ * @brief fw_log_skip_trailing_zero
+ *
+ * @param *s_ptr
+ * @param *end_ptr
+ * @return Please Place Description here.
+ * @retval u8*
+ */
+u8 *fw_log_skip_trailing_zero(u8 *s_ptr, u8 *end_ptr);
+
+/**
+ * @brief fw_log_check_integrity
+ *
+ * @param *symbol_tab
+ * @param *end_ptr
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 fw_log_check_integrity(u8 *symbol_tab, u8 *end_ptr);
+
+/**
+ * @brief fw_log_create_array
+ *
+ * @param *array_ptr
+ * @param *symbol_tab
+ * @param *end_ptr
+ * @param *enum_count
+ * @param *enum_list
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 fw_log_create_array(struct mac_ax_adapter *adapter, struct mac_fw_msg *array_ptr,
+			u8 *symbol_tab, u8 *end_ptr, u32 enum_count, u8 *enum_list);
+
+/**
+ * @brief mac_fw_log_set_array
+ *
+ * @param *adapter
+ * @param *symbol_ptr
+ * @param *file_size
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_fw_log_set_array(struct mac_ax_adapter *adapter, void *symbol_ptr, u32 file_size);
+
+/**
+ * @brief mac_fw_log_unset_array
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_fw_log_unset_array(struct mac_ax_adapter *adapter);
+
+/**
+ * @brief cmd_mac_ser_level_set
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_ser_level_set(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV],
+			  u32 input_num, char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_ser_level_dump
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_ser_level_dump(struct mac_ax_adapter *adapter,  char input[][MAC_MAX_ARGV],
+			   u32 input_num, char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_fw_chsw
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_fw_chsw(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		    char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_fw_chsw_ret
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_fw_chsw_ret(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+			char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_bcn_stats
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_bcn_stats(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		      char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_bd_status
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_bd_status(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		      char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_tbtt_tuning
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_tbtt_tuning(struct mac_ax_adapter *adapter,
+			char input[][MAC_MAX_ARGV],
+			u32 input_num,
+			char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_tx_cnt
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_tx_cnt(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		   char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_rx_cnt
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_rx_cnt(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		   char *output, u32 out_len, u32 *used);
+
+u32 cmd_mac_trx_info_macid(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			   u32 input_num, char *output, u32 out_len, u32 *used);
+
+u32 cmd_mac_trx_info_global(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			    u32 input_num, char *output, u32 out_len, u32 *used);
+
+u32 cmd_mac_dl_result(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		      char *output, u32 out_len, u32 *used);
+
+u32 cmd_mac_curr_wd_cnt(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+			char *output, u32 out_len, u32 *used);
+
+u32 cmd_mac_pkt_cal(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+		    char *output, u32 out_len, u32 *used);
+
+u32 cmd_mac_rpt_queue_sts(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV], u32 input_num,
+			  char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief mac_bdinfo_dump
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_bdinfo_dump(struct mac_ax_adapter *adapter);
+
+/**
+ * @brief cmd_mac_dbg_read
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_dbg_read(struct mac_ax_adapter *adapter,
+		     char input[][MAC_MAX_ARGV],
+		     u32 input_num,
+		     char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_dbg_write
+ *
+ * @param *adapter
+ * @param *input
+ * @param *input_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+u32 cmd_mac_dbg_write(struct mac_ax_adapter *adapter,
+		      char input[][MAC_MAX_ARGV],
+		      u32 input_num,
+		      char *output, u32 out_len, u32 *used);
+/**
+ * @brief cmd_mac_trigger_l0_err
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_trigger_l0_err(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			   u32 input_num, char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_trigger_l1_err
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_trigger_l1_err(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			   u32 input_num, char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_set_l0_dbg_mode
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_set_l0_dbg_mode(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			    u32 input_num, char *output, u32 out_len, u32 *used);
+
+/**
+ * @brief cmd_mac_set_l0_dbg_mode
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmd_mac_set_l1_dbg_mode(struct mac_ax_adapter *adapter, char input[][MAC_MAX_ARGV],
+			    u32 input_num, char *output, u32 out_len, u32 *used);
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgpkg.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgpkg.c
new file mode 100644
index 000000000000..d72095f23140
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgpkg.c
@@ -0,0 +1,3622 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "dbgpkg.h"
+#include "dbgport_hw.h"
+#include "mac_priv.h"
+
+#if MAC_AX_FEATURE_HV
+#include "../hv_ax/phy_rpt_hv.h"
+#endif
+
+static u8 *fwcmd_lb_data;
+
+const char *tx_cnt_type_g6[] = {"LCCK", "SCCK", "OFDM", "HT", "HT_GF", "VHTSU", "VHTMU",
+				"HESU", "HEERSU", "HEMU", "HETB"};
+
+const char *rx_cnt_type[] = {"OFDM_OK", "OFDM_FAIL", "OFDM_FAM",
+			     "CCK_OK", "CCK_FAIL", "CCK_FAM",
+			     "HT_OK", "HT_FAIL", "HT_PPDU", "HT_FAM",
+			     "VHTSU_OK", "VHTSU_FAIL", "VHTSU_PPDU", "VHTSU_FAM",
+			     "VHTMU_OK", "VHTMU_FAIL", "VHTMU_PPDU", "VHTMU_FAM",
+			     "HESU_OK", "HESU_FAIL", "HESU_PPDU", "HESU_FAM",
+			     "HEMU_OK", "HEMU_FAIL", "HEMU_PPDU", "HEMU_FAM",
+			     "HETB_OK", "HETB_FAIL", "HETB_PPDU", "HETB_FAM",
+			     "INVD", "RECCA", "FULLDRP", "FULLDRP_PKT", "RXDMA",
+			     "PKTFLTR_DRP", "CSIPKT_DMA_OK", "CSIPKT_DMA_DROP",
+			     "NDP_PPDU", "CONT_FCS",
+			     "USER0", "USER1", "USER2", "USER3",
+			     "USER4", "USER5", "USER6", "USER7"};
+
+/* base address mapping table of enum mac_ax_mem_sel */
+static u32 base_addr_map_tbl[MAC_AX_MEM_MAX] = {
+	CPU_LOCAL_BASE_ADDR,
+	WCPU_DATA_BASE_ADDR,
+	AXIDMA_BASE_ADDR,
+	SHARED_BUF_BASE_ADDR,
+	DMAC_TBL_BASE_ADDR,
+	SHCUT_MACHDR_BASE_ADDR,
+	STA_SCHED_BASE_ADDR,
+	RXPLD_FLTR_CAM_BASE_ADDR,
+	SEC_CAM_BASE_ADDR,
+	WOW_CAM_BASE_ADDR,
+	CMAC_TBL_BASE_ADDR,
+	ADDR_CAM_BASE_ADDR,
+	BA_CAM_BASE_ADDR,
+	BCN_IE_CAM0_BASE_ADDR,
+	BCN_IE_CAM1_BASE_ADDR,
+	TXD_FIFO_0_BASE_ADDR,
+	TXD_FIFO_1_BASE_ADDR,
+};
+
+u32 mac_fwcmd_lb(struct mac_ax_adapter *adapter, u32 len, u8 burst)
+{
+	u32 i;
+	u32 ret;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	enum h2c_buf_class buf_class;
+	u8 *buf;
+
+	if (!burst) {
+		if (fwcmd_lb_data) {
+			PLTFM_MSG_ERR("C2H loopbakc is not received\n");
+			return MACWQBUSY;
+		}
+	}
+
+	if (len <= H2C_CMD_LEN)
+		buf_class = H2CB_CLASS_CMD;
+	else if (len <= H2C_DATA_LEN)
+		buf_class = H2CB_CLASS_DATA;
+	else
+		buf_class = H2CB_CLASS_LONG_DATA;
+
+	h2cb = h2cb_alloc(adapter, buf_class);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, len - FWCMD_HDR_LEN);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	for (i = 0; i < len - FWCMD_HDR_LEN; i++)
+		buf[i] = (u8)(i & 0xFF);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_TEST,
+			      FWCMD_H2C_CL_CMD_PATH,
+			      FWCMD_H2C_FUNC_H2C_LB,
+			      0,
+			      0);
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	if (!burst) {
+		fwcmd_lb_data = (u8 *)PLTFM_MALLOC(len);
+#if MAC_AX_PHL_H2C
+		PLTFM_MEMCPY(fwcmd_lb_data, h2cb->vir_data, len);
+#else
+		PLTFM_MEMCPY(fwcmd_lb_data, h2cb->data, len);
+#endif
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]platform tx\n");
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	PLTFM_FREE(fwcmd_lb_data, len);
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 c2h_sys_cmd_lb(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			  struct rtw_c2h_info *info)
+{
+	u32 hdr1;
+	u32 c2h_len;
+	u32 h2c_len;
+	u32 ret = MACSUCCESS;
+
+	PLTFM_MSG_TRACE("receive c2h cmd_lb\n");
+
+	if (!fwcmd_lb_data)
+		return MACSUCCESS;
+
+	hdr1 = ((struct fwcmd_hdr *)buf)->hdr1;
+	hdr1 = le32_to_cpu(hdr1);
+	c2h_len = GET_FIELD(hdr1, C2H_HDR_TOTAL_LEN);
+
+	hdr1 = ((struct fwcmd_hdr *)fwcmd_lb_data)->hdr1;
+	hdr1 = le32_to_cpu(hdr1);
+	h2c_len = GET_FIELD(hdr1, H2C_HDR_TOTAL_LEN);
+
+	if (c2h_len != h2c_len) {
+		PLTFM_MSG_ERR("[ERR]fwcmd lb wrong len\n");
+		ret = MACCMP;
+		goto END;
+	}
+
+	if (PLTFM_MEMCMP(buf + FWCMD_HDR_LEN, fwcmd_lb_data + FWCMD_HDR_LEN,
+			 c2h_len - FWCMD_HDR_LEN)) {
+		PLTFM_MSG_ERR("[ERR]fwcmd lb contents compare fail\n");
+		ret = MACCMP;
+		goto END;
+	}
+
+END:
+	PLTFM_FREE(fwcmd_lb_data, len);
+	fwcmd_lb_data = NULL;
+
+	return ret;
+}
+
+static struct c2h_proc_func c2h_proc_sys_cmd_path[] = {
+	{FWCMD_C2H_FUNC_C2H_LB, c2h_sys_cmd_lb},
+#if MAC_AX_FEATURE_HV
+	{FWCMD_C2H_FUNC_TEST_PHY_RPT, c2h_test_phy_rpt},
+#endif
+	{FWCMD_C2H_FUNC_NULL, NULL},
+};
+
+u32 c2h_sys_cmd_path(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		     struct rtw_c2h_info *info)
+{
+	struct c2h_proc_func *proc = c2h_proc_sys_cmd_path;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info) = NULL;
+	u32 hdr0;
+	u32 func;
+
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	while (proc->id != FWCMD_C2H_FUNC_NULL) {
+		if (func == proc->id) {
+			handler = proc->handler;
+			break;
+		}
+		proc++;
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]null func handler id: 0x%X\n", proc->id);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, buf, len, info);
+}
+
+u32 c2h_sys_plat_autotest(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			  struct rtw_c2h_info *info)
+{
+	//struct c2h_proc_func *proc = c2h_proc_sys_palt_autotest;
+	//u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+	//	       struct rtw_c2h_info *info) = NULL;
+	u32 hdr0;
+	u32 func;
+
+	//PLTFM_MSG_TRACE("c2h_sys_plat_autotest\n");
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	//set info
+	info->c2h_cat = GET_FIELD(hdr0, C2H_HDR_CAT);
+	info->c2h_class = GET_FIELD(hdr0, C2H_HDR_CLASS);
+	info->c2h_func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+	//info->done_ack = 0;
+	//info->rec_ack = 0;
+	info->content = buf  + FWCMD_HDR_LEN;
+	//info->h2c_return = info->c2h_data[1];
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+	return MACSUCCESS;
+}
+
+u32 iecam_aces_cfg(struct mac_ax_adapter *adapter, u8 band, u8 en,
+		   struct iecam_cfg_info *info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 camctrl_reg, rbp_reg, ioctrl_reg, val32;
+	u16 ioctrl_bit, val16;
+	u32 cnt;
+
+	camctrl_reg = band == MAC_AX_BAND_0 ?
+		      R_AX_BCN_IECAM_CTRL : R_AX_BCN_IECAM_CTRL_C1;
+
+	rbp_reg = band == MAC_AX_BAND_0 ?
+		  R_AX_BCN_PSR_CTRL : R_AX_BCN_PSR_CTRL_C1;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		ioctrl_reg = band == MAC_AX_BAND_0 ?
+			     R_AX_RXGCK_CTRL : R_AX_RXGCK_CTRL_C1;
+		ioctrl_bit = B_AX_DISGCLK;
+	} else {
+		ioctrl_reg = camctrl_reg;
+		ioctrl_bit = B_AX_BCN_IECAM_IORST;
+	}
+
+	if (en == MAC_AX_FUNC_DIS) {
+		/* Restore original setting */
+		MAC_REG_W16(camctrl_reg, info->camctrl_bkp);
+		MAC_REG_W32(rbp_reg, info->rbp_bkp);
+		MAC_REG_W16(ioctrl_reg, info->ioctrl_bkp);
+		return MACSUCCESS;
+	}
+	info->camctrl_bkp = MAC_REG_R16(camctrl_reg);
+	info->rbp_bkp = MAC_REG_R32(rbp_reg);
+	info->ioctrl_bkp = MAC_REG_R16(ioctrl_reg);
+
+	val16 = MAC_REG_R16(camctrl_reg);
+	if (val16 & B_AX_BCN_IECAM_EN)
+		MAC_REG_W16(camctrl_reg, val16 & ~B_AX_BCN_IECAM_EN);
+
+	val32 = MAC_REG_R32(rbp_reg);
+	if (val32 & B_AX_TIM_PARSER_EN)
+		MAC_REG_W32(rbp_reg, val32 & ~B_AX_TIM_PARSER_EN);
+
+	val16 = MAC_REG_R16(ioctrl_reg);
+	if (!(val16 & ioctrl_bit))
+		MAC_REG_W16(ioctrl_reg, val16 | ioctrl_bit);
+
+	cnt = BCN_PSR_WAIT_CNT;
+	while (cnt-- && MAC_REG_R16(camctrl_reg) & B_AX_BCN_PSR_BUSY)
+		PLTFM_DELAY_US(BCN_PSR_WAIT_US);
+	if (!++cnt) {
+		PLTFM_MSG_ERR("[ERR]BCN PSR polling timeout\n");
+		return MACPOLLTO;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 __dump_mac_mem(struct mac_ax_adapter *adapter,
+			  enum mac_ax_mem_sel sel, u32 offset, u8 *buf, u32 len,
+			  u32 dbg_path)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct iecam_cfg_info iec_info;
+	u32 base_addr, strt_pg, residue, i, cnt, val32;
+	u32 ret = MACSUCCESS, ret2;
+	u8 iecam_cfg_flag, band;
+
+	if (sel >= MAC_AX_MEM_LAST)
+		return MACNOITEM;
+
+	if (adapter->hw_info->is_sec_ic) {
+		PLTFM_MSG_ERR("[ERR]%s sec mode ind aces\n", __func__);
+		return MACIOERRINSEC;
+	}
+
+	if (sel == MAC_AX_MEM_BCN_IE_CAM0 || sel == MAC_AX_MEM_BCN_IE_CAM1) {
+		iecam_cfg_flag = 1;
+		band = sel == MAC_AX_MEM_BCN_IE_CAM0 ?
+		       MAC_AX_BAND_0 : MAC_AX_BAND_1;
+	} else {
+		iecam_cfg_flag = 0;
+		band = 0;
+	}
+
+	if (iecam_cfg_flag) {
+		ret = iecam_aces_cfg(adapter, band, MAC_AX_FUNC_EN, &iec_info);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]iecam access en fail %d\n", ret);
+			ret2 = iecam_aces_cfg(adapter, band, MAC_AX_FUNC_DIS,
+					      &iec_info);
+			if (ret2 != MACSUCCESS)
+				PLTFM_MSG_ERR("[ERR]iecam access dis fail %d\n",
+					      ret2);
+			return ret;
+		}
+	}
+
+	strt_pg = offset / MAC_MEM_DUMP_PAGE_SIZE;
+	residue = offset % MAC_MEM_DUMP_PAGE_SIZE;
+	base_addr = base_addr_map_tbl[sel] + strt_pg * MAC_MEM_DUMP_PAGE_SIZE;
+
+	cnt = 0;
+	while (cnt < len) {
+		//PLTFM_MSG_ERR("%s ind access sel %d start\n", __func__, sel);
+		PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+		adapter->hw_info->ind_aces_cnt++;
+		MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, base_addr);
+		for (i = R_AX_INDIR_ACCESS_ENTRY + residue;
+		     i < R_AX_INDIR_ACCESS_ENTRY + MAC_MEM_DUMP_PAGE_SIZE;
+		     i += 4) {
+			val32 = le32_to_cpu(MAC_REG_R32(i));
+			if (dbg_path)
+				*(u32 *)(buf + cnt) = val32;
+			else
+				PLTFM_MSG_ALWAYS("0x%X: 0x%X\n",
+						 (base_addr + i -
+						  R_AX_INDIR_ACCESS_ENTRY),
+						 val32);
+			cnt += 4;
+			if (cnt >= len)
+				break;
+		}
+		adapter->hw_info->ind_aces_cnt--;
+		PLTFM_MUTEX_UNLOCK(&adapter->hw_info->ind_access_lock);
+		//PLTFM_MSG_ERR("%s ind access sel %d end\n", __func__, sel);
+
+		residue = 0;
+		base_addr += MAC_MEM_DUMP_PAGE_SIZE;
+	}
+
+	if (iecam_cfg_flag) {
+		ret = iecam_aces_cfg(adapter, band, MAC_AX_FUNC_DIS, &iec_info);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[ERR]iecam access dis fail %d\n", ret);
+	}
+
+	return ret;
+}
+
+u32 mac_mem_dump(struct mac_ax_adapter *adapter, enum mac_ax_mem_sel sel,
+		 u32 strt_addr, u8 *buf, u32 len, u32 dbg_path)
+{
+	u32 ret, size;
+
+	if (len & (4 - 1)) {
+		PLTFM_MSG_ERR("[ERR]not 4byte alignment\n");
+		return MACBUFSZ;
+	}
+
+	size = mac_get_mem_size(adapter, sel);
+	if (len > size) {
+		PLTFM_MSG_ERR("[ERR]len %d over max mem size %d\n", len, size);
+		return MACBUFSZ;
+	}
+
+	/* dbg_path: 1: memory ; 0: console */
+	if (dbg_path) {
+		if (!buf) {
+			PLTFM_MSG_ERR("[ERR]null buf for mem dump\n");
+			return MACNPTR;
+		}
+	}
+
+	ret = __dump_mac_mem(adapter, sel, strt_addr, buf, len, dbg_path);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dump mac memory\n");
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_mem_size(struct mac_ax_adapter *adapter, enum mac_ax_mem_sel sel)
+{
+	u32 size;
+	u16 macid_num = adapter->hw_info->macid_num;
+
+	switch (sel) {
+	case MAC_AX_MEM_AXIDMA:
+		size = AXIDMA_REG_SIZE;
+		break;
+	case MAC_AX_MEM_SHARED_BUF:
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A))
+			size = SHARE_BUFFER_SIZE_8852A;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B))
+			size = SHARE_BUFFER_SIZE_8852B;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C))
+			size = SHARE_BUFFER_SIZE_8852C;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB))
+			size = SHARE_BUFFER_SIZE_8192XB;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+			size = SHARE_BUFFER_SIZE_8851B;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E))
+			size = SHARE_BUFFER_SIZE_8851E;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))
+			size = SHARE_BUFFER_SIZE_8852D;
+		else
+			size = 0;
+		break;
+	case MAC_AX_MEM_DMAC_TBL:
+		size = DCTL_INFO_SIZE * macid_num;
+		break;
+	case MAC_AX_MEM_SHCUT_MACHDR:
+		size = MACHDR_SIZE * macid_num;
+		break;
+	case MAC_AX_MEM_STA_SCHED:
+		size = STA_SCHED_MEM_SIZE;
+		break;
+	case MAC_AX_MEM_RXPLD_FLTR_CAM:
+		size = RXPLD_FLTR_CAM_MEM_SIZE;
+		break;
+	case MAC_AX_MEM_SECURITY_CAM:
+		size = SECURITY_CAM_MEM_SIZE;
+		break;
+	case MAC_AX_MEM_WOW_CAM:
+		size = WOW_CAM_MEM_SIZE;
+		break;
+	case MAC_AX_MEM_CMAC_TBL:
+		size = CCTL_INFO_SIZE * macid_num;
+		break;
+	case MAC_AX_MEM_ADDR_CAM:
+		size = ADDR_CAM_MEM_SIZE;
+		break;
+	case MAC_AX_MEM_BA_CAM:
+		size = BA_CAM_SIZE << BA_CAM_NUM_SH;
+		break;
+	case MAC_AX_MEM_BCN_IE_CAM0:
+		size = BCN_IE_CAM_SIZE * BCN_IE_CAM_NUM;
+		break;
+	case MAC_AX_MEM_BCN_IE_CAM1:
+		size = BCN_IE_CAM_SIZE * BCN_IE_CAM_NUM;
+		break;
+	case MAC_AX_MEM_TXD_FIFO_0:
+	case MAC_AX_MEM_TXD_FIFO_1:
+		size = TXD_FIFO_SIZE;
+		break;
+	default:
+		size = 0;
+		break;
+	}
+
+	return size;
+}
+
+static u32 __dump_reg_range(struct mac_ax_adapter *adapter,
+			    u32 srt, u32 end)
+{
+#define REG_PAGE_SIZE 0x100
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 i, j, page, val32_1, val32_2, val32_3, val32_4;
+
+	for (i = srt; i <= end; i++) {
+		page = i << 8;
+		for (j = page; j < page + REG_PAGE_SIZE; j += 16) {
+			val32_1 = MAC_REG_R32(j);
+			val32_2 = MAC_REG_R32(j + 4);
+			val32_3 = MAC_REG_R32(j + 8);
+			val32_4 = MAC_REG_R32(j + 12);
+			PLTFM_MSG_ALWAYS("%08x        %08x %08x %08x %08x\n",
+					 j, val32_1, val32_2, val32_3, val32_4);
+		}
+	}
+
+	return MACSUCCESS;
+#undef REG_PAGE_SIZE
+}
+
+static u32 __dump_mac_reg(struct mac_ax_adapter *adapter,
+			  enum mac_ax_reg_sel sel)
+{
+	u32 srt, end;
+
+	switch (sel) {
+	case MAC_AX_REG_MAC:
+		srt = MAC_PAGE_SRT;
+		if (adapter->sm.pwr != MAC_AX_PWR_ON) {
+			PLTFM_MSG_WARN("[WARN]MAC is not power on %d\n",
+				       adapter->sm.pwr);
+			end = MAC_PAGE_AON_END;
+		} else {
+			end = MAC_PAGE_TOP_END;
+		}
+		PLTFM_MSG_ALWAYS("dump MAC REG pg 0x%X-0x%X\n", srt, end);
+		__dump_reg_range(adapter, srt, end);
+
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			srt = MAC_PAGE_HCI_SRT;
+			end = MAC_PAGE_HCI_END;
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+			   is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+			   is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+			   is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+				srt = MAC_PAGE_PCIE_SRT;
+				end = MAC_PAGE_PCIE_END;
+			} else if (adapter->hw_info->intf == MAC_AX_INTF_USB) {
+				srt = MAC_PAGE_USB_SRT;
+				end = MAC_PAGE_USB_END;
+			} else if (adapter->hw_info->intf == MAC_AX_INTF_SDIO) {
+				srt = MAC_PAGE_SDIO_SRT;
+				end = MAC_PAGE_SDIO_END;
+			} else {
+				PLTFM_MSG_ERR("Undefined intf for hci reg range\n");
+				return MACINTF;
+			}
+			PLTFM_MSG_ALWAYS("dump MAC REG pg 0x%X-0x%X\n", srt, end);
+			__dump_reg_range(adapter, srt, end);
+
+			srt = MAC_PAGE_HAXI_SRT;
+			end = MAC_PAGE_HAXI_END;
+		} else {
+			PLTFM_MSG_ERR("Undefined chip id for hci reg range\n");
+			return MACCHIPID;
+		}
+		PLTFM_MSG_ALWAYS("dump MAC REG pg 0x%X-0x%X\n", srt, end);
+		__dump_reg_range(adapter, srt, end);
+
+		if (check_mac_en(adapter, MAC_AX_BAND_0, MAC_AX_DMAC_SEL)
+		    == MACSUCCESS) {
+			srt = MAC_PAGE_DMAC_SRT;
+			end = MAC_PAGE_DMAC_END;
+			PLTFM_MSG_ALWAYS("dump MAC REG pg 0x%X-0x%X\n", srt, end);
+			__dump_reg_range(adapter, srt, end);
+		}
+
+		if (check_mac_en(adapter, MAC_AX_BAND_0, MAC_AX_CMAC_SEL)
+		    == MACSUCCESS) {
+			srt = MAC_PAGE_CMAC0_SRT;
+			end = MAC_PAGE_CMAC0_END;
+			PLTFM_MSG_ALWAYS("dump MAC REG pg 0x%X-0x%X\n", srt, end);
+			__dump_reg_range(adapter, srt, end);
+		}
+
+		if (check_mac_en(adapter, MAC_AX_BAND_1, MAC_AX_CMAC_SEL)
+		    == MACSUCCESS) {
+			srt = MAC_PAGE_CMAC1_SRT;
+			end = MAC_PAGE_END;
+			PLTFM_MSG_ALWAYS("dump MAC REG pg 0x%X-0x%X\n", srt, end);
+			__dump_reg_range(adapter, srt, end);
+		}
+
+		PLTFM_MSG_ALWAYS("dump MAC REG all\n");
+		break;
+	case MAC_AX_REG_BB:
+		srt = BB_PAGE_SRT;
+		end = BB_PAGE_END;
+		PLTFM_MSG_ALWAYS("dump MAC REG pg 0x%X-0x%X\n", srt, end);
+		__dump_reg_range(adapter, srt, end);
+		PLTFM_MSG_ALWAYS("dump BB REG all\n");
+		break;
+	case MAC_AX_REG_IQK:
+		srt = IQK_PAGE_SRT;
+		end = IQK_PAGE_END;
+		PLTFM_MSG_ALWAYS("dump MAC REG pg 0x%X-0x%X\n", srt, end);
+		__dump_reg_range(adapter, srt, end);
+		PLTFM_MSG_ALWAYS("dump IQK REG all\n");
+		break;
+	case MAC_AX_REG_RFC:
+		srt = RFC_PAGE_SRT;
+		end = RFC_PAGE_END;
+		PLTFM_MSG_ALWAYS("dump MAC REG pg 0x%X-0x%X\n", srt, end);
+		__dump_reg_range(adapter, srt, end);
+		PLTFM_MSG_ALWAYS("dump RFC REG all\n");
+		break;
+	default:
+		PLTFM_MSG_ERR("Page sel error (%d)\n", sel);
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_reg_dump(struct mac_ax_adapter *adapter, enum mac_ax_reg_sel sel)
+{
+	u32 ret;
+
+	adapter->sm.l2_st = MAC_AX_L2_DIS;
+
+	PLTFM_MSG_ALWAYS("MAC Registers:\n");
+	ret = __dump_mac_reg(adapter, sel);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dump mac memory\n");
+		return ret;
+	}
+
+	adapter->sm.l2_st = MAC_AX_L2_EN;
+
+	return MACSUCCESS;
+}
+
+static void print_dbg_port_sel(struct mac_ax_adapter *adapter, u32 sel)
+{
+	u32 i;
+
+	switch (sel) {
+	case MAC_AX_DBG_PORT_SEL_PTCL_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port PTCL C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PTCL_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port PTCL C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_SCH_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port SCH C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_SCH_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port SCH C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TMAC_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port TMAC C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TMAC_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port TMAC C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_RMAC_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port RMAC C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_RMAC_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port RMAC C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_RMACST_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port RMACST C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_RMACST_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port RMACST C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TRXPTCL_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port TRXPTCL C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TRXPTCL_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port TRXPTCL C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TX_INFOL_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port TXINFOL C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TX_INFOH_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port TXINFOH C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TX_INFOL_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port TXINFOL C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TX_INFOH_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port TXINFOH C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXTF_INFOL_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port TXTFINFOL C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXTF_INFOH_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port TXTFINFOH C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXTF_INFOL_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port TXTFINFOL C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXTF_INFOH_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port TXTFINFOH C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_CMAC_DMA0_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port CMAC DMA0 C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_CMAC_DMA1_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port CMAC DMA1 C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_CMAC_DMA2_C0:
+		PLTFM_MSG_ALWAYS("Dump debug port CMAC DMA2 C0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_CMAC_DMA0_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port CMAC DMA0 C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_CMAC_DMA1_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port CMAC DMA1 C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_CMAC_DMA2_C1:
+		PLTFM_MSG_ALWAYS("Dump debug port CMAC DMA2 C1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_BUFMGN_CTL:
+		PLTFM_MSG_ALWAYS("Dump debug port wde bufmgn ctl:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_BUFMGN_ARB:
+		PLTFM_MSG_ALWAYS("Dump debug port wde bufmgn arb:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_QUEMGN_CTL:
+		PLTFM_MSG_ALWAYS("Dump debug port wde quemgn ctl:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_QUEMGN_INFO:
+		PLTFM_MSG_ALWAYS("Dump debug port wde quemgn info:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_QUEMGN_ARB:
+		PLTFM_MSG_ALWAYS("Dump debug port wde quemgn arb:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_PORT0:
+		PLTFM_MSG_ALWAYS("Dump debug port wde port 0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_PORT1:
+		PLTFM_MSG_ALWAYS("Dump debug port wde port 1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_PORT3:
+		PLTFM_MSG_ALWAYS("Dump debug port wde port 3:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_PORT4:
+		PLTFM_MSG_ALWAYS("Dump debug port wde port 4:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_PORT6:
+		PLTFM_MSG_ALWAYS("Dump debug port wde port 6:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_PORT7:
+		PLTFM_MSG_ALWAYS("Dump debug port wde port 7:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_BUFMGN_CTL:
+		PLTFM_MSG_ALWAYS("Dump debug port ple bufmgn ctl:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_BUFMGN_ARB:
+		PLTFM_MSG_ALWAYS("Dump debug port ple bufmgn arb:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_QUEMGN_CTL:
+		PLTFM_MSG_ALWAYS("Dump debug port ple quemgn ctl:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_QUEMGN_INFO:
+		PLTFM_MSG_ALWAYS("Dump debug port ple quemgn info:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_QUEMGN_ARB:
+		PLTFM_MSG_ALWAYS("Dump debug port ple quemgn arb:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT0:
+		PLTFM_MSG_ALWAYS("Dump debug port ple port 0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT1:
+		PLTFM_MSG_ALWAYS("Dump debug port ple port 1_0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT2:
+		PLTFM_MSG_ALWAYS("Dump debug port ple port 2:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT2_1:
+		PLTFM_MSG_ALWAYS("Dump debug port ple port 2_1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT3:
+		PLTFM_MSG_ALWAYS("Dump debug port ple port 3:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT4:
+		PLTFM_MSG_ALWAYS("Dump debug port ple port 4:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT5:
+		PLTFM_MSG_ALWAYS("Dump debug port ple port 5:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT6:
+		PLTFM_MSG_ALWAYS("Dump debug port ple port 6:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDRLS_CTL:
+		PLTFM_MSG_ALWAYS("Dump debug port wdrls ctl:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDRLS_RPTGEN0:
+		PLTFM_MSG_ALWAYS("Dump debug port wdrls rptgen0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDRLS_RPTGEN1:
+		PLTFM_MSG_ALWAYS("Dump debug port wdrls rptgen1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDRLS_PLED_CH0:
+		PLTFM_MSG_ALWAYS("Dump debug port wdrls pledchn0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDRLS_PLED_CH1:
+		PLTFM_MSG_ALWAYS("Dump debug port wdrls pledchn1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_FETPKT:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl fetpkt:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_CMDPSR:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 cmdpsr:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_CMACDMAIF:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 cmacdmaif:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_PRELD0:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 preld0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_PRELD1:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 preld1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT0_0:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit0_0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT0_1:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit0_1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT1_0:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit1_0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT1_1:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit1_1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT2_0:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit2_0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT2_1:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit2_1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT3_0:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit3_0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT3_1:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit3_1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT4_0:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit4_0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT4_1:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit4_1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT5_0:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit5_0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT5_1:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit5_1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT6_0:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit6_0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT6_1:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit6_1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT7_0:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit7_0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT7_1:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b0 unit7_1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B1_CMDPSR:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b1 cmdpsr:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B1_CMACDMAIF:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b1 cmacdmaif:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B1_UNIT0_0:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b1 unit0_0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B1_UNIT0_1:
+		PLTFM_MSG_ALWAYS("Dump debug port txpktctrl b1 unit0_1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PKTINFO:
+		PLTFM_MSG_ALWAYS("Dump debug port pktinfo:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_MPDUINFO_B0:
+		PLTFM_MSG_ALWAYS("Dump debug port mpduinfo b0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_MPDUINFO_B1:
+		PLTFM_MSG_ALWAYS("Dump debug port mpduinfo b1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PRELD_B0:
+		PLTFM_MSG_ALWAYS("Dump debug port preld b0:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PRELD_B1:
+		PLTFM_MSG_ALWAYS("Dump debug port preld b1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_TXDMA:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE TXDMA:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_RXDMA:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE RXDMA:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_CVT:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE CVT:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC04:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE EMAC 0-4:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC5:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE EMAC 5:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC6:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE EMAC 6:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC7:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE EMAC 7:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_PNP_IO:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE EMAC P-NP-IO:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC814:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE EMAC 8-14:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC15:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE EMAC 15:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC16:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE EMAC 16:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC17:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE EMAC 17:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC18:
+		PLTFM_MSG_ALWAYS("Dump debug port PCIE EMAC 18:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_PHY:
+		PLTFM_MSG_ALWAYS("Dump debug port USB2 PHY:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_SIE:
+		PLTFM_MSG_ALWAYS("Dump debug port USB2 SIE:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_UTMI:
+		PLTFM_MSG_ALWAYS("Dump debug port USB2 UTMI:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_SIE_MMU:
+		PLTFM_MSG_ALWAYS("Dump debug port USB2 SIE MMU:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_SIE_PCE:
+		PLTFM_MSG_ALWAYS("Dump debug port USB2 SIE PCE:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_UTMI_IF:
+		PLTFM_MSG_ALWAYS("Dump debug port USB2 UTMI IF:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_WLTX:
+		PLTFM_MSG_ALWAYS("Dump debug port USB WLTX:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_WLRX:
+		PLTFM_MSG_ALWAYS("Dump debug port USB WLRX:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB3:
+		PLTFM_MSG_ALWAYS("Dump debug port USB3:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_SETUP:
+		PLTFM_MSG_ALWAYS("Dump debug port USB SETUP:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_WLTX_DMA:
+		PLTFM_MSG_ALWAYS("Dump debug port USB WLTXDMA:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_WLRX_DMA:
+		PLTFM_MSG_ALWAYS("Dump debug port USB WLRXDMA:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_AINST:
+		PLTFM_MSG_ALWAYS("Dump debug port USB AINST:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_MISC:
+		PLTFM_MSG_ALWAYS("Dump debug port USB2 MISC:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_BTTX:
+		PLTFM_MSG_ALWAYS("Dump debug port USB2 BTTX:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_BT:
+		PLTFM_MSG_ALWAYS("Dump debug port USB2 BT:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX0:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX1:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX2:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX3:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX4:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX5:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX6:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX7:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX8:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX9:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXA:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXB:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXC:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXD:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXE:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXF:
+		i = sel - MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX0;
+		PLTFM_MSG_ALWAYS("Dump debug port DISPATCHER HDT TX%x:\n", i);
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX0:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX3:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX4:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX5:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX6:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX7:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX8:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX9:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TXA:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TXB:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TXC:
+		if (sel == MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX0)
+			i = 0;
+		else
+			i = sel + 3 - MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX3;
+		PLTFM_MSG_ALWAYS("Dump debug port DISPATCHER CDT TX%x:\n", i);
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX0:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX1:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX2:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX3:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX4:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX5:
+		i = sel - MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX0;
+		PLTFM_MSG_ALWAYS("Dump debug port DISPATCHER HDT RX%x:\n", i);
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0_0:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0_1:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0_2:
+		i = sel - MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0_0;
+		PLTFM_MSG_ALWAYS("Dump debug port DISP CDT RX part0 %x:\n",
+				 i);
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P1:
+		PLTFM_MSG_ALWAYS("Dump debug port DISPATCHER CDT RX part1:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_STF_CTRL:
+		PLTFM_MSG_ALWAYS("Dump debug port DISPATCHER STF Control:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_ADDR_CTRL:
+		PLTFM_MSG_ALWAYS("Dump debug port DISPATCHER ADDR Control:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_WDE_INTF:
+		PLTFM_MSG_ALWAYS("Dump debug port DISPATCHER WDE Interface:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_PLE_INTF:
+		PLTFM_MSG_ALWAYS("Dump debug port DISPATCHER PLE Interface:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_FLOW_CTRL:
+		PLTFM_MSG_ALWAYS("Dump debug port DISPATCHER FLOW Control:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_AXI_TXDMA_CTRL:
+		PLTFM_MSG_ALWAYS("Dump debug port AXI_TXDMA_CTRL:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_AXI_RXDMA_CTRL:
+		PLTFM_MSG_ALWAYS("Dump debug port AXI_RXDMA_CTRL:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_AXI_MST_WLAN:
+		PLTFM_MSG_ALWAYS("Dump debug port AXI_MST_WLAN:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_AXI_INT_WLAN:
+		PLTFM_MSG_ALWAYS("Dump debug port AXI_INT_WLAN::\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_AXI_PAGE_FLOW_CTRL:
+		PLTFM_MSG_ALWAYS("Dump debug port AXI_PAGE_FLOW_CTRL:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PAXI_TXDMA:
+		PLTFM_MSG_ALWAYS("Dump debug port PAXIDMA TXDMA:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PAXI_RXDMA:
+		PLTFM_MSG_ALWAYS("Dump debug port PAXIDMA RXDMA:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PAXI_MST:
+		PLTFM_MSG_ALWAYS("Dump debug port PAXIDMA MST:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PAXI_INT:
+		PLTFM_MSG_ALWAYS("Dump debug port PAXIDMA INT:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_HAXI_TXDMA:
+		PLTFM_MSG_ALWAYS("Dump debug port HAXIDMA TXDMA:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_HAXI_RXDMA:
+		PLTFM_MSG_ALWAYS("Dump debug port HAXIDMA RXDMA:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_HAXI_MST:
+		PLTFM_MSG_ALWAYS("Dump debug port HAXIDMA MST:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_HAXI_INT:
+		PLTFM_MSG_ALWAYS("Dump debug port HAXIDMA INT:\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_STA_SCH:
+		PLTFM_MSG_ALWAYS("Dump debug port STA scheduler:\n");
+		break;
+	default:
+		PLTFM_MSG_WARN("Dump unknown debug port sel %d:\n", sel);
+		break;
+	}
+}
+
+void print_dbg_port(struct mac_ax_adapter *adapter, struct mac_ax_dbg_port_info *info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 i;
+	u8 val8;
+	u16 val16;
+	u32 val32;
+
+	for (i = info->srt; i <= info->end; i += info->inc_num) {
+		switch (info->sel_byte) {
+		case MAC_AX_BYTE_SEL_1:
+		default:
+			val8 = SET_CLR_WOR2(MAC_REG_R8(info->sel_addr), i,
+					    info->sel_sh,
+					    info->sel_msk);
+			MAC_REG_W8(info->sel_addr, val8);
+			PLTFM_MSG_ALWAYS("0x%02X: ", val8);
+			break;
+		case MAC_AX_BYTE_SEL_2:
+			val16 = SET_CLR_WOR2(MAC_REG_R16(info->sel_addr), i,
+					     info->sel_sh,
+					     info->sel_msk);
+			MAC_REG_W16(info->sel_addr, val16);
+			PLTFM_MSG_ALWAYS("0x%04X: ", val16);
+			break;
+		case MAC_AX_BYTE_SEL_4:
+			val32 = SET_CLR_WOR2(MAC_REG_R32(info->sel_addr), i,
+					     info->sel_sh,
+					     info->sel_msk);
+			MAC_REG_W32(info->sel_addr, val32);
+			PLTFM_MSG_ALWAYS("0x%08X: ", val32);
+			break;
+		}
+
+		PLTFM_DELAY_US(DBG_PORT_DUMP_DLY_US);
+
+		switch (info->rd_byte) {
+		case MAC_AX_BYTE_SEL_1:
+		default:
+			val8 = GET_FIEL2(MAC_REG_R8(info->rd_addr),
+					 info->rd_sh, info->rd_msk);
+			PLTFM_MSG_ALWAYS("0x%02X\n", val8);
+			break;
+		case MAC_AX_BYTE_SEL_2:
+			val16 = GET_FIEL2(MAC_REG_R16(info->rd_addr),
+					  info->rd_sh, info->rd_msk);
+			PLTFM_MSG_ALWAYS("0x%04X\n", val16);
+			break;
+		case MAC_AX_BYTE_SEL_4:
+			val32 = GET_FIEL2(MAC_REG_R32(info->rd_addr),
+					  info->rd_sh, info->rd_msk);
+			PLTFM_MSG_ALWAYS("0x%08X\n", val32);
+			break;
+		}
+	}
+}
+
+u32 dbg_port_dump(struct mac_ax_adapter *adapter, u32 sel)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_dbg_port_info *info;
+	u32 ret;
+
+	ret = p_ops->dbg_port_sel(adapter, &info, sel);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	print_dbg_port_sel(adapter, sel);
+
+	PLTFM_MSG_ALWAYS("Sel addr = 0x%X\n", info->sel_addr);
+	PLTFM_MSG_ALWAYS("Read addr = 0x%X\n", info->rd_addr);
+
+	print_dbg_port(adapter, info);
+
+	ret = p_ops->dbg_port_sel_rst(adapter, sel);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("[ERR] dbg sel reset %d\n", ret);
+
+	adapter->hw_info->dbg_port_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->dbg_port_lock);
+
+	return ret;
+}
+
+static u32 ss_poll_own(struct mac_ax_adapter *adapter, u32 addr)
+{
+	u32 cnt = 100;
+	u32 val32 = SS_POLL_UNEXPECTED;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	while (--cnt) {
+		val32 = MAC_REG_R32(addr);
+		if ((val32 & B_AX_SS_OWN) == 0)
+			break;
+		PLTFM_DELAY_US(1);
+	}
+
+	return val32;
+}
+
+static u32 ss_tx_len_chk(struct mac_ax_adapter *adapter, u16 macid)
+{
+	u32 sel;
+	u32 val32 = 0;
+	u32 dw[4];
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	for (sel = 0; sel < 4; sel++) {
+		MAC_REG_W32(R_AX_SS_SRAM_CTRL_1,
+			    B_AX_SS_OWN |
+			    SET_WORD(SS_CTRL1_R_TX_LEN, B_AX_SS_CMD_SEL) |
+			    SET_WORD(sel, B_AX_SS_AC) | macid);
+		dw[sel] = ss_poll_own(adapter, R_AX_SS_SRAM_CTRL_1);
+		if (dw[sel] & (BIT(29) | BIT(30))) {
+			val32 |= SS_POLL_STAT_TX_LEN;
+			PLTFM_MSG_ALWAYS("[WARN]SS_POLL_STAT_TX_LEN, macid %d, ",
+					 macid);
+			PLTFM_MSG_ALWAYS("ac %d\n", sel);
+			PLTFM_MSG_ALWAYS("R_AX_SS_SRAM_CTRL_1 = 0x%x\n",
+					 dw[sel]);
+			break;
+		}
+		if (dw[sel] & B_AX_SS_OWN) {
+			val32 |= SS_POLL_OWN_TX_LEN;
+			PLTFM_MSG_ALWAYS("[WARN]SS_POLL_OWN_TX_LEN, macid %d, ",
+					 macid);
+			PLTFM_MSG_ALWAYS("ac %d\n", sel);
+			PLTFM_MSG_ALWAYS("R_AX_SS_SRAM_CTRL_1 = 0x%x\n",
+					 dw[sel]);
+			break;
+		}
+	}
+
+	if (((dw[0] >> SS_MACID_SH) & SS_TX_LEN_MSK) != 0) {
+		val32 |= SS_TX_LEN_BE;
+		PLTFM_MSG_ALWAYS("[WARN]SS_TX_LEN_BE, macid %d, ", macid);
+		PLTFM_MSG_ALWAYS("len 0x%X\n",
+				 (dw[0] >> SS_MACID_SH) & SS_TX_LEN_MSK);
+	}
+	if (((dw[1] >> SS_MACID_SH) & SS_TX_LEN_MSK) != 0) {
+		val32 |= SS_TX_LEN_BK;
+		PLTFM_MSG_ALWAYS("[WARN]SS_TX_LEN_BK, macid %d, ", macid);
+		PLTFM_MSG_ALWAYS("len 0x%X\n",
+				 (dw[1] >> SS_MACID_SH) & SS_TX_LEN_MSK);
+	}
+	if (((dw[2] >> SS_MACID_SH) & SS_TX_LEN_MSK) != 0) {
+		val32 |= SS_TX_LEN_VI;
+		PLTFM_MSG_ALWAYS("[WARN]SS_TX_LEN_VI, macid %d, ", macid);
+		PLTFM_MSG_ALWAYS("len 0x%X\n",
+				 (dw[2] >> SS_MACID_SH) & SS_TX_LEN_MSK);
+	}
+	if (((dw[3] >> SS_MACID_SH) & SS_TX_LEN_MSK) != 0) {
+		val32 |= SS_TX_LEN_VO;
+		PLTFM_MSG_ALWAYS("[WARN]SS_TX_LEN_VO, macid %d, ", macid);
+		PLTFM_MSG_ALWAYS("len 0x%X\n",
+				 (dw[3] >> SS_MACID_SH) & SS_TX_LEN_MSK);
+	}
+
+	return val32;
+}
+
+static u32 ss_link_chk(struct mac_ax_adapter *adapter,
+		       struct ss_link_info *link)
+{
+	u32 val32 = 0;
+	u32 poll;
+	u8 wmm, ac;
+	u8 link_head;
+	u8 link_tail;
+	u8 link_len;
+	u32 i;
+	u32 cmd;
+	u8 macid;
+	u16 id_empty = adapter->hw_info->sta_empty_flg;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (link->ul) {
+		wmm = 0;
+		ac = 0;
+	} else {
+		wmm = link->wmm;
+		ac = link->ac;
+	}
+
+	MAC_REG_W32(R_AX_SS_LINK_INFO, B_AX_SS_OWN |
+		    (link->ul ? B_AX_SS_UL : 0) |
+		    SET_WORD(wmm, B_AX_SS_WMM) |
+		    SET_WORD(ac, B_AX_SS_AC));
+	poll = ss_poll_own(adapter, R_AX_SS_LINK_INFO);
+	link_head = GET_FIELD(poll, B_AX_SS_LINK_HEAD);
+	link_tail = GET_FIELD(poll, B_AX_SS_LINK_TAIL);
+	link_len = GET_FIELD(poll, B_AX_SS_LINK_LEN);
+
+	if (poll & (BIT(29) | BIT(30))) {
+		val32 |= SS_POLL_STAT_LINK;
+		PLTFM_MSG_ALWAYS("[WARN]SS_POLL_STAT_LINK, ul/wmm/ac %d/%d/%d\n",
+				 link->ul, wmm, ac);
+		PLTFM_MSG_ALWAYS("R_AX_SS_LINK_INFO = 0x%x\n", poll);
+		return val32;
+	}
+	if (poll & B_AX_SS_OWN) {
+		val32 |= SS_POLL_OWN_LINK;
+		PLTFM_MSG_ALWAYS("[WARN]SS_POLL_OWN_LINK, ul/wmm/ac %d/%d/%d\n",
+				 link->ul, wmm, ac);
+		PLTFM_MSG_ALWAYS("R_AX_SS_LINK_INFO = 0x%x\n", poll);
+		return val32;
+	}
+
+	if (link_head != id_empty || link_tail != id_empty || link_len != 0) {
+		if (link->ul)
+			val32 |= SS_LINK_UL << ((wmm << 2) + ac);
+		else
+			val32 |= SS_LINK_WMM0_BE << ((wmm << 2) + ac);
+		PLTFM_MSG_ALWAYS("[WARN]SS_LINK_DUMP, ul/wmm/ac %d/%d/%d, ",
+				 link->ul, wmm, ac);
+		PLTFM_MSG_ALWAYS("head/tail/len 0x%X/0x%X/%d\n",
+				 link_head, link_tail, link_len);
+		macid = link_head;
+		i = 0;
+		do {
+			PLTFM_MSG_ALWAYS("0x%X, ", macid);
+			cmd = B_AX_SS_OWN |
+			      SET_WORD(SS_CTRL1_R_NEXT_LINK, B_AX_SS_CMD_SEL) |
+			      SET_WORD(ac, B_AX_SS_AC) |
+			      (link->ul ? BIT(23) : 0) | macid;
+			MAC_REG_W32(R_AX_SS_SRAM_CTRL_1, cmd);
+			poll = ss_poll_own(adapter, R_AX_SS_SRAM_CTRL_1);
+			if (poll & (BIT(29) | BIT(30))) {
+				PLTFM_MSG_ALWAYS("SS_LINK_DUMP_POLL_STAT\n");
+				PLTFM_MSG_ALWAYS("R_AX_SS_SRAM_CTRL_1 = 0x%x\n",
+						 poll);
+				break;
+			}
+			if (poll & B_AX_SS_OWN) {
+				PLTFM_MSG_ALWAYS("SS_LINK_DUMP_POLL_OWN\n");
+				PLTFM_MSG_ALWAYS("R_AX_SS_SRAM_CTRL_1 = 0x%x\n",
+						 poll);
+				break;
+			}
+
+			if (GET_FIELD(poll, B_AX_SS_VALUE) == id_empty) {
+				if (macid != link_tail) {
+					PLTFM_MSG_ALWAYS("[WARN]tail error!!\n");
+					break;
+				}
+				if (i >= link_len) {
+					PLTFM_MSG_ALWAYS("[WARN]len error!!\n");
+					break;
+				}
+				break;
+			}
+			macid = GET_FIELD(poll, B_AX_SS_VALUE);
+
+			i++;
+		} while (i < SS_LINK_SIZE);
+		PLTFM_MSG_ALWAYS("\nSS_LINK_DUMP, end\n");
+	}
+
+	return val32;
+}
+
+static void ss_dbgpkg_val_parser(struct mac_ax_adapter *adapter,
+				 struct mac_ax_dbgpkg *val)
+{
+	/* STA Scheduler 0, indirect */
+	PLTFM_MSG_ALWAYS("[WARN][STA_SCH] ss_dbg_0 = 0x%X\n", val->ss_dbg_0);
+	if (val->ss_dbg_0 & SS_TX_LEN_BE)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] some MACID's BE length != 0\n");
+	if (val->ss_dbg_0 & SS_TX_LEN_BK)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] some MACID's BK length != 0\n");
+	if (val->ss_dbg_0 & SS_TX_LEN_VI)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] some MACID's VI length != 0\n");
+	if (val->ss_dbg_0 & SS_TX_LEN_VO)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] some MACID's VO length != 0\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM0_BE)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_0 BE not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM0_BK)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_0 BK not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM0_VI)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_0 VI not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM0_VO)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_0 VO not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM1_BE)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_1 BE not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM1_BK)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_1 BK not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM1_VI)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_1 VI not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM1_VO)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_1 VO not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM2_BE)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_2 BE not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM2_BK)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_2 BK not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM2_VI)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_2 VI not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM2_VO)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_2 VO not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM3_BE)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_3 BE not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM3_BK)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_3 BK not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM3_VI)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_3 VI not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_WMM3_VO)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WMM_3 VO not empty\n");
+	if (val->ss_dbg_0 & SS_LINK_UL)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] UL not empty\n");
+	if (val->ss_dbg_0 & SS_POLL_OWN_TX_LEN)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] (length) own bit polling fail\n");
+	if (val->ss_dbg_0 & SS_POLL_OWN_LINK)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] (link) own bit polling fail\n");
+	if (val->ss_dbg_0 & SS_POLL_STAT_TX_LEN)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] (length) state machine fail\n");
+	if (val->ss_dbg_0 & SS_POLL_STAT_LINK)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] (link) state machine fail\n");
+
+	/* STA Scheduler 1, direct */
+	PLTFM_MSG_ALWAYS("[WARN][STA_SCH] ss_dbg_1 = 0x%X\n", val->ss_dbg_1);
+	if (val->ss_dbg_1 & SS_TX_HW_LEN_UDN)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] HW cause length underflow\n");
+	if (val->ss_dbg_1 & SS_TX_SW_LEN_UDN)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] SW cause length underflow\n");
+	if (val->ss_dbg_1 & SS_TX_HW_LEN_OVF)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] HW cause length overflow\n");
+	if (val->ss_dbg_1 & SS_STAT_FWTX)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] SW Tx state machine not idle\n");
+	if (val->ss_dbg_1 & SS_STAT_RPTA)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] Report state machine not idle\n");
+	if (val->ss_dbg_1 & SS_STAT_WDEA)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] WDE state machine not idle\n");
+	if (val->ss_dbg_1 & SS_STAT_PLEA)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] PLE state machine not idle\n");
+	if (val->ss_dbg_1 & SS_STAT_ULRU)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] UL RU state machine not idle\n");
+	if (val->ss_dbg_1 & SS_STAT_DLTX)
+		PLTFM_MSG_ERR("[WARN][STA_SCH] HW Tx state machine not idle\n");
+}
+
+static void ps_dbg_dump(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	enum mac_ax_intf intf = adapter->hw_info->intf;
+	u16 reg32 = 0;
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		reg32 = R_AX_CPWM;
+	}
+#endif
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		reg32 = R_AX_CPWM_V1;
+	}
+#endif
+
+	PLTFM_MSG_ALWAYS("R_AX_PLATFORM_ENABLE=0x%x\n",
+			 MAC_REG_R32(R_AX_PLATFORM_ENABLE));
+	PLTFM_MSG_ALWAYS("R_AX_WLLPS_CTRL=0x%x\n",
+			 MAC_REG_R32(R_AX_WLLPS_CTRL));
+	PLTFM_MSG_ALWAYS("R_AX_WLRESUME_CTRL=0x%x\n",
+			 MAC_REG_R32(R_AX_WLRESUME_CTRL));
+	PLTFM_MSG_ALWAYS("R_AX_SYS_CFG5=0x%x\n",
+			 MAC_REG_R32(R_AX_SYS_CFG5));
+	PLTFM_MSG_ALWAYS("R_AX_IC_PWR_STATE=0x%x\n",
+			 MAC_REG_R32(R_AX_IC_PWR_STATE));
+	switch (intf) {
+	case MAC_AX_INTF_USB:
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ALWAYS("USB HRPWM=0x%x\n",
+					 MAC_REG_R16(R_AX_USB_D2F_F2D_INFO + 2));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ALWAYS("USB HRPWM=0x%x\n",
+					 MAC_REG_R16(R_AX_USB_D2F_F2D_INFO_V1 + 2));
+		}
+#endif
+		break;
+	case MAC_AX_INTF_SDIO:
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ALWAYS("SDIO HRPWM=0x%x\n",
+					 MAC_REG_R16(R_AX_SDIO_HRPWM1 + 2));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ALWAYS("SDIO HRPWM=0x%x\n",
+					 MAC_REG_R16(R_AX_SDIO_HRPWM1_V1 + 2));
+		}
+#endif
+		break;
+	case MAC_AX_INTF_PCIE:
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ALWAYS("PCIE HRPWM=0x%x\n",
+					 MAC_REG_R16(R_AX_PCIE_HRPWM));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ALWAYS("PCIE HRPWM=0x%x\n",
+					 MAC_REG_R16(R_AX_PCIE_HRPWM_V1));
+		}
+#endif
+		break;
+	default:
+		PLTFM_MSG_ALWAYS("RPWM error interface=%d\n",
+				 intf);
+		break;
+	}
+	PLTFM_MSG_ALWAYS("R_AX_RPWM=0x%x\n",
+			 MAC_REG_R16(R_AX_RPWM));
+	PLTFM_MSG_ALWAYS("R_AX_LDM=0x%x\n",
+			 MAC_REG_R32(R_AX_LDM));
+
+	if (mac_io_chk_access(adapter, reg32) == MACSUCCESS) {
+		PLTFM_MSG_ALWAYS("R_AX_CPWM=0x%x\n",
+				 MAC_REG_R16(reg32));
+	}
+}
+
+u32 fw_backtrace_dump(struct mac_ax_adapter *adapter)
+{
+	u32 addr = 0;
+	u32 str_addr = 0;
+	u32 size = 0;
+	u32 key = 0;
+	u32 i;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct fw_backtrace_info info;
+
+	if (adapter->mac_pwr_info.pwr_seq_proc ||
+	    adapter->sm.pwr != MAC_AX_PWR_ON ||
+	    adapter->mac_pwr_info.pwr_in_lps ||
+	    adapter->sm.fw_rst == MAC_AX_FW_RESET_RECV_DONE ||
+	    adapter->sm.fw_rst == MAC_AX_FW_RESET_PROCESS) {
+		PLTFM_MSG_ERR("[ERR]pwr seq proc %d/sm pwr %d/pwr in lps %d\n",
+			      adapter->mac_pwr_info.pwr_seq_proc,
+			      adapter->sm.pwr,
+			      adapter->mac_pwr_info.pwr_in_lps);
+		PLTFM_MSG_ERR("[ERR]sm fw rst %d\n", adapter->sm.fw_rst);
+		return MACPROCERR;
+	}
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+		addr = RSVD_PLE_OFST_8852A;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+		addr = RSVD_PLE_OFST_8852B;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C)) {
+		addr = RSVD_PLE_OFST_8852C;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) {
+		addr = RSVD_PLE_OFST_8192XB;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		addr = RSVD_PLE_OFST_8851B;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E)) {
+		addr = RSVD_PLE_OFST_8851E;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		addr = RSVD_PLE_OFST_8852D;
+	} else {
+		PLTFM_MSG_ERR("[ERR]unknown chip id\n");
+		return MACCHIPID;
+	}
+
+	// Get FW Backtrace start address and size
+	if (adapter->hw_info->is_sec_ic) {
+		PLTFM_MSG_ERR("[ERR]security mode ind accees!\n");
+		PLTFM_MSG_ERR("[ERR]Skip FW Backtrace Check!\n");
+	} else {
+		addr = base_addr_map_tbl[MAC_AX_MEM_SHARED_BUF] + addr;
+		PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+		adapter->hw_info->ind_aces_cnt++;
+		MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, addr);
+		str_addr = MAC_REG_R32(R_AX_INDIR_ACCESS_ENTRY) & ~0xA0000000;
+		size = MAC_REG_R32(R_AX_INDIR_ACCESS_ENTRY + FW_BACKTRACE_SIZE_OFST);
+		key = MAC_REG_R32(R_AX_INDIR_ACCESS_ENTRY + FW_BACKTRACE_KEY_OFST);
+		adapter->hw_info->ind_aces_cnt--;
+		PLTFM_MUTEX_UNLOCK(&adapter->hw_info->ind_access_lock);
+		if (str_addr == 0) {
+			PLTFM_MSG_ERR("[FW Backtrace] Invalid address(0x%x)!\n", str_addr);
+			return MACBADDR;
+		}
+		if (size == 0 || size > FW_BACKTRACE_MAX_SIZE
+		    || (size % sizeof(struct fw_backtrace_info) != 0)) {
+			PLTFM_MSG_ERR("[FW Backtrace] Invalid size(0x%x)!\n", size);
+			return MACBUFSZ;
+		}
+		if (key != FW_BACKTRACE_KEY) {
+			PLTFM_MSG_ERR("[FW Backtrace] Invalid key(0x%x)!\n", key);
+			return MACNOITEM;
+		}
+	}
+
+	// Dump FW backtrace
+	if (adapter->hw_info->is_sec_ic) {
+		PLTFM_MSG_ERR("[ERR]security mode ind accees!\n");
+		PLTFM_MSG_ERR("[ERR]Skip FW Backtrace Check!\n");
+	} else {
+		PLTFM_MSG_WARN("%s ind access FW backtrace start\n", __func__);
+		PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+		adapter->hw_info->ind_aces_cnt++;
+		MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, str_addr);
+		for (i = 0; i < size; i += sizeof(struct fw_backtrace_info)) {
+			info.ra = MAC_REG_R32(R_AX_INDIR_ACCESS_ENTRY + i);
+			info.sp = MAC_REG_R32(R_AX_INDIR_ACCESS_ENTRY + i + 4);
+			PLTFM_MSG_ERR("Next SP:0x%x, Next RA:0x%x\n", info.sp, info.ra);
+		}
+		adapter->hw_info->ind_aces_cnt--;
+		PLTFM_MUTEX_UNLOCK(&adapter->hw_info->ind_access_lock);
+		PLTFM_MSG_WARN("%s ind access FW backtrace end\n", __func__);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 fw_ple_fwerror_dump(struct mac_ax_adapter *adapter)
+{
+	u32 addr = 0;
+	u32 val = 0;
+	u32 i;
+
+	addr = mac_get_ple_dbg_addr(adapter);
+
+	// Dump FW Error
+	if (adapter->hw_info->is_sec_ic) {
+		PLTFM_MSG_WARN("[ERR]security mode ind accees\n");
+		PLTFM_MSG_WARN("[ERR]Skip FW Error Check!\n");
+	} else {
+		PLTFM_MSG_WARN("%s ind access FW Error PLE start\n", __func__);
+		for (i = R_EXCEPTION_RA0; i <= R_EXCEPTION_RA6; i += 4) {
+			val = mac_sram_dbg_read(adapter, addr + i, SHARED_BUF_SEL);
+			if (val == 0)
+				continue;
+
+			if (i >= (u32)R_EXCEPTION_RA0 && i <= (u32)R_EXCEPTION_RA6)
+				PLTFM_MSG_ERR("possible RA = 0x%x\n", val);
+		}
+		PLTFM_MSG_WARN("%s ind access FW Error PLE Dump end\n", __func__);
+	}
+	return MACSUCCESS;
+}
+
+void pltfm_dbg_dump(struct mac_ax_adapter *adapter)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	PLTFM_MSG_ALWAYS("R_AX_SER_DBG_INFO =0x%08x\n",
+			 MAC_REG_R32(R_AX_SER_DBG_INFO));
+
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_INIT_CFG1, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_INIT_CFG1 = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_DMA_STOP, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_DMA_STOP = 0x%x\n", val32);
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_INIT_CFG2, AXIDMA_SEL);
+		PLTFM_MSG_ALWAYS("R_PL_AXIDMA_INIT_CFG2 = 0x%x\n", val32);
+	}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		val32 = mac_sram_dbg_read(adapter, R_AX_HAXI_INIT_CFG1, AXIDMA_SEL);
+		PLTFM_MSG_ALWAYS("R_AX_HAXI_INIT_CFG1 = 0x%x\n", val32);
+	}
+#endif
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_INFO, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_INFO = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_BUSY, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_BUSY = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_CH0_RXBD_IDX, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_CH0_RXBD_IDX = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_CH1_RXBD_IDX, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_CH1_RXBD_IDX = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_CH2_RXBD_IDX, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_CH2_RXBD_IDX = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_CH3_RXBD_IDX, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_CH3_RXBD_IDX = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_CH4_RXBD_IDX, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_CH4_RXBD_IDX = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_CH5_RXBD_IDX, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_CH5_RXBD_IDX = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_CH0_TXBD_IDX, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_CH0_TXBD_IDX = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_CH1_TXBD_IDX, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_CH1_TXBD_IDX = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_CH2_TXBD_IDX, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_CH2_TXBD_IDX = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_CH3_TXBD_IDX, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_CH3_TXBD_IDX = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_DBG_ERR_FLAG, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_DBG_ERR_FLAG = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_FWIMR0, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_FWIMR0 = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_FWIMR1, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_FWIMR1 = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_FWISR0, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_FWISR0 = 0x%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, R_PL_AXIDMA_FWISR1, AXIDMA_SEL);
+	PLTFM_MSG_ALWAYS("R_PL_AXIDMA_FWISR1 = 0x%x\n", val32);
+}
+
+u32 fw_pc_dbg_dump_ax(struct mac_ax_adapter *adapter)
+{
+	u32 val32;
+	u16 index;
+	u8 chip_id;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	chip_id = adapter->hw_info->chip_id;
+
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->dbg_port_lock);
+	adapter->hw_info->dbg_port_cnt++;
+
+	MAC_REG_W32(R_AX_DBG_CTRL, 0xf200f2);
+	val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+	val32 = SET_CLR_WORD(val32, 0x1, B_AX_SEL_0XC0);
+	MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+
+	for (index = 0; index < 15; index++) {
+		switch (chip_id) {
+#if defined(MAC_8852A_SUPPORT) || defined(MAC_8852B_SUPPORT) || defined(MAC_8851B_SUPPORT)
+		case MAC_AX_CHIP_ID_8852A:
+		case MAC_AX_CHIP_ID_8852B:
+		case MAC_AX_CHIP_ID_8851B:
+			val32 = MAC_REG_R32(R_AX_DBG_PORT_SEL);
+			break;
+#endif
+#if (defined(MAC_8852C_SUPPORT) || defined(MAC_8192XB_SUPPORT) || \
+defined(MAC_8851E_SUPPORT) || defined(MAC_8852D_SUPPORT))
+		case MAC_AX_CHIP_ID_8852C:
+		case MAC_AX_CHIP_ID_8192XB:
+		case MAC_AX_CHIP_ID_8851E:
+		case MAC_AX_CHIP_ID_8852D:
+			val32 = MAC_REG_R32(R_AX_WLCPU_PORT_PC);
+			break;
+#endif
+		default:
+			val32 = 0xEAEAEAEA;
+			PLTFM_MSG_ERR("[ERR]%s :Unknown Chip ID. 0x%X\n", __func__, chip_id);
+			break;
+		}
+
+		PLTFM_MSG_ERR("[ERR]fw PC = 0x%x\n", val32);
+		PLTFM_DELAY_US(10);
+	}
+
+	adapter->hw_info->dbg_port_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->dbg_port_lock);
+	return MACSUCCESS;
+}
+
+u32 fw_st_dbg_dump(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, ret;
+
+	if (adapter->mac_pwr_info.pwr_seq_proc ||
+	    adapter->sm.pwr != MAC_AX_PWR_ON) {
+		PLTFM_MSG_ERR("[ERR]pwr seq proc %d/sm pwr %d\n",
+			      adapter->mac_pwr_info.pwr_seq_proc,
+			      adapter->sm.pwr);
+		return MACPROCERR;
+	}
+
+	PLTFM_MSG_ALWAYS("FW status = 0x%x\n", MAC_REG_R32(R_AX_UDM0));
+	PLTFM_MSG_ALWAYS("FW BADADDR = 0x%x\n", MAC_REG_R32(R_AX_UDM1));
+	PLTFM_MSG_ALWAYS("FW EPC/RA = 0x%x\n", MAC_REG_R32(R_AX_UDM2));
+	PLTFM_MSG_ALWAYS("FW MISC = 0x%x\n", MAC_REG_R32(R_AX_UDM3));
+	PLTFM_MSG_ALWAYS("R_AX_HALT_C2H = 0x%x\n", MAC_REG_R32(R_AX_HALT_C2H));
+
+	val32 = MAC_REG_R32(R_AX_HALT_C2H);
+	if (val32 == MAC_AX_ERR_L1_ERR_DMAC || val32 == MAC_AX_ERR_L1_RESET_DISABLE_DMAC_DONE)
+		PLTFM_MSG_ALWAYS("[WARN] SER L1 is occured, but not recovery done yet\n");
+
+	if (mac_io_chk_access(adapter, R_AX_SER_DBG_INFO) == MACSUCCESS) {
+		PLTFM_MSG_ALWAYS("R_AX_SER_DBG_INFO = 0x%x\n", MAC_REG_R32(R_AX_SER_DBG_INFO));
+		PLTFM_MSG_ALWAYS("R_AX_DMAC_ERR_ISR = 0x%x\n", MAC_REG_R32(R_AX_DMAC_ERR_ISR));
+	}
+
+	/* Dump FW program counter */
+	ret = fw_pc_dbg_dump_ax(adapter);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 rsvd_ple_dump(struct mac_ax_adapter *adapter)
+{
+	u32 ret;
+	u32 addr;
+
+	if (adapter->mac_pwr_info.pwr_seq_proc ||
+	    adapter->sm.pwr != MAC_AX_PWR_ON ||
+	    adapter->mac_pwr_info.pwr_in_lps ||
+	    adapter->sm.fw_rst == MAC_AX_FW_RESET_RECV_DONE ||
+	    adapter->sm.fw_rst == MAC_AX_FW_RESET_PROCESS) {
+		PLTFM_MSG_ERR("[ERR]pwr seq proc %d/sm pwr %d/pwr in lps %d\n",
+			      adapter->mac_pwr_info.pwr_seq_proc,
+			      adapter->sm.pwr,
+			      adapter->mac_pwr_info.pwr_in_lps);
+		PLTFM_MSG_ERR("[ERR]sm fw rst %d\n", adapter->sm.fw_rst);
+		return MACPROCERR;
+	}
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+		addr = RSVD_PLE_OFST_8852A;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+		addr = RSVD_PLE_OFST_8852B;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C)) {
+		addr = RSVD_PLE_OFST_8852C;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) {
+		addr = RSVD_PLE_OFST_8192XB;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		addr = RSVD_PLE_OFST_8851B;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E)) {
+		addr = RSVD_PLE_OFST_8851E;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		addr = RSVD_PLE_OFST_8852D;
+	} else {
+		PLTFM_MSG_ERR("[ERR]unknown chip id\n");
+		return MACCHIPID;
+	}
+
+	ret = mac_mem_dump(adapter, MAC_AX_MEM_SHARED_BUF, addr, 0,
+			   FW_RSVD_PLE_SIZE, 0);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("Dump fw rsvd ple\n");
+		return ret;
+	}
+
+	ret = fw_backtrace_dump(adapter);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("fw backtrace dump %d\n", ret);
+
+	return MACSUCCESS;
+}
+
+u32 ss_dbgpkg(struct mac_ax_adapter *adapter, struct mac_ax_dbgpkg *val)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_role_tbl *role;
+	struct ss_link_info link;
+	u32 ret, val32;
+	u16 macid_num = adapter->hw_info->macid_num;
+	u16 i_u16;
+	u8 wmm_num, ul_vld, wmm, ac;
+
+	PLTFM_MSG_ALWAYS("%s...", __func__);
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ALWAYS("[ERR] check dmac en %d\n", ret);
+		return ret;
+	}
+
+	val32 = MAC_REG_R32(R_AX_DMAC_FUNC_EN);
+	if ((val32 & B_AX_MAC_FUNC_EN) == 0) {
+		PLTFM_MSG_ALWAYS("[ERR] B_AX_MAC_FUNC_EN=0");
+		return MACSUCCESS;
+	}
+	if ((val32 & B_AX_DMAC_FUNC_EN) == 0) {
+		PLTFM_MSG_ALWAYS("[ERR] B_AX_DMAC_FUNC_EN=0");
+		return MACSUCCESS;
+	}
+	if ((val32 & B_AX_STA_SCH_EN) == 0) {
+		PLTFM_MSG_ALWAYS("[ERR] B_AX_STA_SCH_EN=0");
+		return MACSUCCESS;
+	}
+	val32 = MAC_REG_R32(R_AX_DMAC_CLK_EN);
+	if ((val32 & B_AX_STA_SCH_CLK_EN) == 0) {
+		PLTFM_MSG_ALWAYS("[ERR] B_AX_STA_SCH_CLK_EN=0");
+		return MACSUCCESS;
+	}
+	val32 = MAC_REG_R32(R_AX_SS_CTRL);
+	if ((val32 & B_AX_SS_EN) == 0) {
+		PLTFM_MSG_ALWAYS("[ERR] B_AX_SS_EN=0");
+		return MACSUCCESS;
+	}
+
+	switch (adapter->hw_info->chip_id) {
+	case MAC_AX_CHIP_ID_8852A:
+		wmm_num = SS_WMM_NUM_8852A;
+		ul_vld = SS_UL_SUPPORT_8852A;
+		break;
+	case MAC_AX_CHIP_ID_8852B:
+		wmm_num = SS_WMM_NUM_8852B;
+		ul_vld = SS_UL_SUPPORT_8852B;
+		break;
+	case MAC_AX_CHIP_ID_8852C:
+		wmm_num = SS_WMM_NUM_8852C;
+		ul_vld = SS_UL_SUPPORT_8852C;
+		break;
+	case MAC_AX_CHIP_ID_8192XB:
+		wmm_num = SS_WMM_NUM_8192XB;
+		ul_vld = SS_UL_SUPPORT_8192XB;
+		break;
+	case MAC_AX_CHIP_ID_8851B:
+		wmm_num = SS_WMM_NUM_8851B;
+		ul_vld = SS_UL_SUPPORT_8851B;
+		break;
+	case MAC_AX_CHIP_ID_8851E:
+		wmm_num = SS_WMM_NUM_8851E;
+		ul_vld = SS_UL_SUPPORT_8851E;
+		break;
+	case MAC_AX_CHIP_ID_8852D:
+		wmm_num = SS_WMM_NUM_8852D;
+		ul_vld = SS_UL_SUPPORT_8852D;
+		break;
+	default:
+		wmm_num = 0;
+		ul_vld = 0;
+		break;
+	}
+
+	for (i_u16 = 0; i_u16 < macid_num; i_u16++) {
+		role = mac_role_srch(adapter, (u8)i_u16);
+		if (role) {
+			PLTFM_MSG_ALWAYS("[ss_tx_len] macid = %d", i_u16);
+			val->ss_dbg_0 |= ss_tx_len_chk(adapter, i_u16);
+			if (val->ss_dbg_0 &
+			    (SS_POLL_STAT_TX_LEN | SS_POLL_OWN_TX_LEN))
+				break;
+		}
+	}
+
+	link.ul = 0;
+	for (wmm = 0; wmm < wmm_num; wmm++) {
+		link.wmm = wmm;
+		for (ac = 0; ac < 4; ac++) {
+			link.ac = ac;
+			val->ss_dbg_0 |= ss_link_chk(adapter, &link);
+			if (val->ss_dbg_0 &
+			    (SS_POLL_STAT_LINK | SS_POLL_OWN_LINK))
+				break;
+		}
+		if (val->ss_dbg_0 & (SS_POLL_STAT_LINK | SS_POLL_OWN_LINK))
+			break;
+	}
+
+	if (ul_vld) {
+		link.ul = 1;
+		link.wmm = 0;
+		link.ac = 0;
+		val->ss_dbg_0 |= ss_link_chk(adapter, &link);
+	}
+
+	val->ss_dbg_1 |= p_ops->ss_stat_chk(adapter);
+	ss_dbgpkg_val_parser(adapter, val);
+
+	return MACSUCCESS;
+}
+
+u32 dle_dbg_dump(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct dle_dfi_freepg_t freepg;
+	struct dle_dfi_quota_t quota;
+	struct dle_dfi_qempty_t qempty;
+	u32 qtaid, grpsel;
+	u32 qnum, qtanum, ret, val32;
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] check dmac en %d\n", ret);
+		return ret;
+	}
+
+	PLTFM_MSG_ALWAYS("R_AX_WDE_PKTBUF_CFG=0x%x\n",
+			 MAC_REG_R32(R_AX_WDE_PKTBUF_CFG));
+	PLTFM_MSG_ALWAYS("R_AX_PLE_PKTBUF_CFG=0x%x\n",
+			 MAC_REG_R32(R_AX_PLE_PKTBUF_CFG));
+
+	val32 = MAC_REG_R32(R_AX_WDE_QTA0_CFG);
+	PLTFM_MSG_ALWAYS("[WDE][HIF]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_WDE_Q0_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[WDE][HIF]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_WDE_Q0_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_WDE_QTA1_CFG);
+	PLTFM_MSG_ALWAYS("[WDE][WLAN_CPU]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_WDE_Q1_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[WDE][WLAN_CPU]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_WDE_Q1_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_WDE_QTA2_CFG);
+	PLTFM_MSG_ALWAYS("[WDE][DATA_CPU]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_WDE_Q2_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[WDE][DATA_CPU]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_WDE_Q2_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_WDE_QTA3_CFG);
+	PLTFM_MSG_ALWAYS("[WDE][PKTIN]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_WDE_Q3_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[WDE][PKTIN]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_WDE_Q3_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_WDE_QTA4_CFG);
+	PLTFM_MSG_ALWAYS("[WDE][CPUIO]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_WDE_Q4_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[WDE][CPUIO]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_WDE_Q4_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA0_CFG);
+	PLTFM_MSG_ALWAYS("[PLE][B0_TXPL]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q0_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[PLE][B0_TXPL]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q0_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA1_CFG);
+	PLTFM_MSG_ALWAYS("[PLE][B1_TXPL]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q1_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[PLE][B1_TXPL]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q1_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA2_CFG);
+	PLTFM_MSG_ALWAYS("[PLE][C2H]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q2_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[PLE][C2H]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q2_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA3_CFG);
+	PLTFM_MSG_ALWAYS("[PLE][H2C]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q3_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[PLE][H2C]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q3_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA4_CFG);
+	PLTFM_MSG_ALWAYS("[PLE][WLAN_CPU]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q4_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[PLE][WLAN_CPU]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q4_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA5_CFG);
+	PLTFM_MSG_ALWAYS("[PLE][MPDU]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q5_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[PLE][MPDU]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q5_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA6_CFG);
+	PLTFM_MSG_ALWAYS("[PLE][CMAC0_RX]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q6_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[PLE][CMAC0_RX]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q6_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA7_CFG);
+	PLTFM_MSG_ALWAYS("[PLE][CMAC1_RX]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q7_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[PLE][CMAC1_RX]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q7_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA8_CFG);
+	PLTFM_MSG_ALWAYS("[PLE][BBRPT]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q8_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[PLE][BBRPT]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q8_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA9_CFG);
+	PLTFM_MSG_ALWAYS("[PLE][WDRLS]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q9_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[PLE][WDRLS]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q9_MAX_SIZE));
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA10_CFG);
+	PLTFM_MSG_ALWAYS("[PLE][CPUIO]min_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q10_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[PLE][CPUIO]max_pgnum=0x%x\n",
+			 GET_FIELD(val32, B_AX_PLE_Q10_MAX_SIZE));
+
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		val32 = MAC_REG_R32(R_AX_PLE_QTA11_CFG);
+		PLTFM_MSG_ALWAYS("[PLE][TXRPT]min_pgnum=0x%x\n",
+				 GET_FIELD(val32, B_AX_PLE_Q11_MIN_SIZE));
+		PLTFM_MSG_ALWAYS("[PLE][TXRPT]max_pgnum=0x%x\n",
+				 GET_FIELD(val32, B_AX_PLE_Q11_MAX_SIZE));
+	}
+#endif
+
+	freepg.dle_type = DLE_CTRL_TYPE_WDE;
+	ret = dle_dfi_freepg(adapter, &freepg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] wde dfi freepg %d\n", ret);
+		return ret;
+	}
+	PLTFM_MSG_ALWAYS("[WDE]free_headpg = 0x%x\n", freepg.free_headpg);
+	PLTFM_MSG_ALWAYS("[WDE]free_tailpg = 0x%x\n", freepg.free_tailpg);
+	PLTFM_MSG_ALWAYS("[WDE]pub_pgnum = 0x%x\n", freepg.pub_pgnum);
+
+	freepg.dle_type = DLE_CTRL_TYPE_PLE;
+	ret = dle_dfi_freepg(adapter, &freepg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] ple dfi freepg %d\n", ret);
+		return ret;
+	}
+	PLTFM_MSG_ALWAYS("[PLE]free_headpg = 0x%x\n", freepg.free_headpg);
+	PLTFM_MSG_ALWAYS("[PLE]free_tailpg = 0x%x\n", freepg.free_tailpg);
+	PLTFM_MSG_ALWAYS("[PLE]pub_pgunm = 0x%x\n", freepg.pub_pgnum);
+
+	quota.dle_type = DLE_CTRL_TYPE_WDE;
+	for (qtaid = 0; qtaid < WDE_QTA_NUM; qtaid++) {
+		quota.qtaid = qtaid;
+		ret = dle_dfi_quota(adapter, &quota);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] wde dfi quota %d\n", ret);
+			return ret;
+		}
+
+		switch (qtaid) {
+		case WDE_QTAID_HOST_IF:
+			PLTFM_MSG_ALWAYS("[WDE][HIF]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[WDE][HIF]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case WDE_QTAID_WLAN_CPU:
+			PLTFM_MSG_ALWAYS("[WDE][WLAN_CPU]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[WDE][WLAN_CPU]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case WDE_QTAID_DATA_CPU:
+			PLTFM_MSG_ALWAYS("[WDE][DATA_CPU]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[WDE][DATA_CPU]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case WDE_QTAID_PKTIN:
+			PLTFM_MSG_ALWAYS("[WDE][PKTIN]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[WDE][PKTIN]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case WDE_QTAID_CPUIO:
+			PLTFM_MSG_ALWAYS("[WDE][CPUIO]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[WDE][CPUIO]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		}
+	}
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		qtanum = PLE_QTA_NUM_8852AB;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		   is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		   is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		   is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		qtanum = PLE_QTA_NUM_8852C;
+	} else {
+		PLTFM_MSG_ERR("[ERR] ple qta num not define\n");
+		return MACCHIPID;
+	}
+	quota.dle_type = DLE_CTRL_TYPE_PLE;
+	for (qtaid = 0; qtaid < qtanum; qtaid++) {
+		quota.qtaid = qtaid;
+		ret = dle_dfi_quota(adapter, &quota);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] dle dfi quota %d\n", ret);
+			return ret;
+		}
+
+		switch (qtaid) {
+		case PLE_QTAID_B0_TXPL:
+			PLTFM_MSG_ALWAYS("[PLE][B0_TXPL]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[PLE][B0_TXPL]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case PLE_QTAID_B1_TXPL:
+			PLTFM_MSG_ALWAYS("[PLE][B1_TXPL]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[PLE][B1_TXPL]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case PLE_QTAID_C2H:
+			PLTFM_MSG_ALWAYS("[PLE][C2H]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[PLE][C2H]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case PLE_QTAID_H2C:
+			PLTFM_MSG_ALWAYS("[PLE][H2C]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[PLE][H2C]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case PLE_QTAID_WLAN_CPU:
+			PLTFM_MSG_ALWAYS("[PLE][WLAN_CPU]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[PLE][WLAN_CPU]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case PLE_QTAID_MPDU:
+			PLTFM_MSG_ALWAYS("[PLE][MPDU]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[PLE][MPDU]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case PLE_QTAID_CMAC0_RX:
+			PLTFM_MSG_ALWAYS("[PLE][CMAC0_RX]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[PLE][CMAC0_RX]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case PLE_QTAID_CMAC1_RX:
+			PLTFM_MSG_ALWAYS("[PLE][CMAC1_RX]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[PLE][CMAC1_RX]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case PLE_QTAID_BBRPT:
+			PLTFM_MSG_ALWAYS("[PLE][BBRPT]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[PLE][BBRPT]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case PLE_QTAID_WDRLS:
+			PLTFM_MSG_ALWAYS("[PLE][WDRLS]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[PLE][WDRLS]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case PLE_QTAID_CPUIO:
+			PLTFM_MSG_ALWAYS("[PLE][CPUIO]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[PLE][CPUIO]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		case PLE_QTAID_TXRPT:
+			PLTFM_MSG_ALWAYS("[PLE][TXRPT]rsv_pgnum = %d\n",
+					 quota.rsv_pgnum);
+			PLTFM_MSG_ALWAYS("[PLE][TXRPT]use_pgnum = %d\n",
+					 quota.use_pgnum);
+			break;
+		default:
+			PLTFM_MSG_ERR("[ERR] ple invalid qtaid %d\n", qtaid);
+			break;
+		}
+	}
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+		qnum = WDE_QEMPTY_NUM_8852A;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+		qnum = WDE_QEMPTY_NUM_8852B;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C)) {
+		qnum = WDE_QEMPTY_NUM_8852C;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) {
+		qnum = WDE_QEMPTY_NUM_8192XB;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		qnum = WDE_QEMPTY_NUM_8851B;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E)) {
+		qnum = WDE_QEMPTY_NUM_8851E;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		qnum = WDE_QEMPTY_NUM_8852D;
+	} else {
+		PLTFM_MSG_ERR("[ERR] wde qempty num not define\n");
+		return MACCHIPID;
+	}
+	qempty.dle_type = DLE_CTRL_TYPE_WDE;
+	for (grpsel = 0; grpsel < qnum; grpsel++) {
+		qempty.grpsel = grpsel;
+		ret = dle_dfi_qempty(adapter, &qempty);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] wde dfi qempty %d\n", ret);
+			return ret;
+		}
+		PLTFM_MSG_ALWAYS("[WDE][Group_%d]qempty = 0x%x\n",
+				 grpsel, qempty.qempty);
+	}
+
+	qempty.dle_type = DLE_CTRL_TYPE_PLE;
+	for (grpsel = 0; grpsel < PLE_QEMPTY_NUM; grpsel++) {
+		qempty.grpsel = grpsel;
+		ret = dle_dfi_qempty(adapter, &qempty);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] ple dfi qempty %d\n", ret);
+			return ret;
+		}
+		PLTFM_MSG_ALWAYS("[PLE][Group_%d]qempty = 0x%x\n",
+				 grpsel, qempty.qempty);
+	}
+
+	return MACSUCCESS;
+}
+
+u8 chk_dle_dfi_valid(struct mac_ax_adapter *adapter, u32 dbg_sel)
+{
+	if ((check_mac_en(adapter, 0, MAC_AX_DMAC_SEL) == MACSUCCESS) &&
+	    dbg_sel <= MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_QEMPTY)
+		return 1;
+
+	return 0;
+}
+
+u32 dle_dfi_dump(struct mac_ax_adapter *adapter, u32 sel)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_dle_dfi_info *info;
+	struct dle_dfi_ctrl_t ctrl;
+	u32 ret, i;
+
+	ret = p_ops->dle_dfi_sel(adapter, &info, &ctrl.target, sel);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] dle dfi sel %d %d\n", sel, ret);
+		return ret;
+	}
+
+	if (sel <= MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_QEMPTY) {
+		ctrl.type = DLE_CTRL_TYPE_WDE;
+	} else if (sel >= MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_FREEPG &&
+		 sel <= MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_QEMPTY) {
+		ctrl.type = DLE_CTRL_TYPE_PLE;
+	} else {
+		PLTFM_MSG_ERR("[ERR]unknown dle dfi sel-2 %d\n", sel);
+		return MACFUNCINPUT;
+	}
+
+	switch (sel) {
+	case MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_FREEPG:
+		PLTFM_MSG_ALWAYS("WDE_BUFMGN_FREEPG\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_QUOTA:
+		PLTFM_MSG_ALWAYS("WDE_BUFMGN_QUOTA\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_PAGELLT:
+		PLTFM_MSG_ALWAYS("WDE_BUFMGN_PAGELLT\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_PKTINFO:
+		PLTFM_MSG_ALWAYS("WDE_BUFMGN_PKTINFO\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_PREPKT:
+		PLTFM_MSG_ALWAYS("WDE_QUEMGN_PREPKT\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_NXTPKT:
+		PLTFM_MSG_ALWAYS("WDE_QUEMGN_NXTPKT\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_QLNKTBL:
+		PLTFM_MSG_ALWAYS("WDE_QUEMGN_QLNKTBL\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_QEMPTY:
+		PLTFM_MSG_ALWAYS("WDE_QUEMGN_QEMPTY\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_FREEPG:
+		PLTFM_MSG_ALWAYS("PLE_BUFMGN_FREEPG\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_QUOTA:
+		PLTFM_MSG_ALWAYS("PLE_BUFMGN_QUOTA\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_PAGELLT:
+		PLTFM_MSG_ALWAYS("PLE_BUFMGN_PAGELLT\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_PKTINFO:
+		PLTFM_MSG_ALWAYS("PLE_BUFMGN_PKTINFO\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_PREPKT:
+		PLTFM_MSG_ALWAYS("PLE_QUEMGN_PREPKT\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_NXTPKT:
+		PLTFM_MSG_ALWAYS("PLE_QUEMGN_NXTPKT\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_QLNKTBL:
+		PLTFM_MSG_ALWAYS("PLE_QUEMGN_QLNKTBL\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_QEMPTY:
+		PLTFM_MSG_ALWAYS("PLE_QUEMGN_QEMPTY\n");
+		break;
+	default:
+		break;
+	}
+
+	for (i = info->srt; i <= info->end; i += info->inc_num) {
+		ctrl.addr = i;
+		ret = p_ops->dle_dfi_ctrl(adapter, &ctrl);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]dle dfi ctrl %d\n", ret);
+			return ret;
+		}
+		PLTFM_MSG_ALWAYS("trg %d addr 0x%X: 0x%X\n",
+				 ctrl.target, ctrl.addr, ctrl.out_data);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 tx_cnt_dump(struct mac_ax_adapter *adapter, u8 band, u32 loop_num)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret, reg, val32, i;
+	u8 idx;
+	u32 prev_cnt[TMAC_TX_CNT_NUM];
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[WARN] check cmac en %d\n", ret);
+		return ret;
+	}
+
+	PLTFM_MEMSET(prev_cnt, 0, sizeof(prev_cnt));
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_TX_PPDU_CNT_C1 : R_AX_TX_PPDU_CNT;
+	for (i = 0; i < loop_num; i++) {
+		for (idx = 0; idx < TMAC_TX_CNT_NUM; idx++) {
+			MAC_REG_W8(reg, idx);
+			PLTFM_DELAY_US(TRX_CNT_READ_DLY_US);
+			val32 = GET_FIELD(MAC_REG_R32(reg), B_AX_TX_PPDU_CNT);
+			if (i == 0 || val32 != prev_cnt[idx])
+				PLTFM_MSG_ALWAYS("B%d TX_PPDU_CNT[%d %s]-%d=0x%x\n",
+						 band, idx, tx_cnt_type_g6[idx], i, val32);
+			prev_cnt[idx] = val32;
+		}
+		PLTFM_DELAY_US(TRX_CNT_REPT_DLY_US);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 rx_cnt_dump(struct mac_ax_adapter *adapter, u8 band, u32 loop_num)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret, reg, val32, i;
+	u8 idx;
+	u32 prev_cnt[RMAC_RX_CNT_NUM];
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[WARN] check cmac en %d\n", ret);
+		return ret;
+	}
+
+	PLTFM_MEMSET(prev_cnt, 0, sizeof(prev_cnt));
+
+	reg = band == MAC_AX_BAND_1 ?
+		      R_AX_RX_DBG_CNT_SEL_C1 : R_AX_RX_DBG_CNT_SEL;
+	for (i = 0; i < loop_num; i++) {
+		for (idx = 0; idx < RMAC_RX_CNT_NUM; idx++) {
+			MAC_REG_W8(reg, idx);
+			PLTFM_DELAY_US(TRX_CNT_READ_DLY_US);
+			val32 = GET_FIELD(MAC_REG_R32(reg), B_AX_RX_DBG_CNT);
+			if (i == 0 || val32 != prev_cnt[idx])
+				PLTFM_MSG_ALWAYS("B%d RX_CNT[%d %s]-%d=0x%x\n",
+						 band, idx, rx_cnt_type[idx],
+						 i, val32);
+			prev_cnt[idx] = val32;
+		}
+		PLTFM_DELAY_US(TRX_CNT_REPT_DLY_US);
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 mac_dle_status_dump(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	PLTFM_MSG_ALWAYS("R_AX_DLE_EMPTY0=0x%x\n",
+			 MAC_REG_R32(R_AX_DLE_EMPTY0));
+	PLTFM_MSG_ALWAYS("R_AX_DLE_EMPTY1=0x%x\n",
+			 MAC_REG_R32(R_AX_DLE_EMPTY1));
+
+	return MACSUCCESS;
+}
+
+static u32 mac_hci_flow_ctrl_dump(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		PLTFM_MSG_ALWAYS("R_AX_HDP_DBG_INFO_4=0x%x\n",
+				 MAC_REG_R32(R_AX_HDP_DBG_INFO_4));
+	}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		PLTFM_MSG_ALWAYS("R_AX_HDP_DBG_INFO_4=0x%x\n",
+				 MAC_REG_R32(R_AX_HDP_DBG_INFO_4_V1));
+	}
+#endif
+
+	return MACSUCCESS;
+}
+
+static u32 mac_quota_dump(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	/* quota */
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		PLTFM_MSG_ALWAYS("R_AX_ACH0_PAGE_INFO=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH0_PAGE_INFO));
+		PLTFM_MSG_ALWAYS("R_AX_ACH1_PAGE_INFO=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH1_PAGE_INFO));
+		PLTFM_MSG_ALWAYS("R_AX_ACH2_PAGE_INFO=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH2_PAGE_INFO));
+		PLTFM_MSG_ALWAYS("R_AX_ACH3_PAGE_INFO=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH3_PAGE_INFO));
+		PLTFM_MSG_ALWAYS("R_AX_ACH4_PAGE_INFO=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH4_PAGE_INFO));
+		PLTFM_MSG_ALWAYS("R_AX_ACH5_PAGE_INFO=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH5_PAGE_INFO));
+		PLTFM_MSG_ALWAYS("R_AX_ACH6_PAGE_INFO=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH6_PAGE_INFO));
+		PLTFM_MSG_ALWAYS("R_AX_ACH7_PAGE_INFO=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH7_PAGE_INFO));
+		PLTFM_MSG_ALWAYS("R_AX_CH8_PAGE_INFO=0x%x\n",
+				 MAC_REG_R32(R_AX_CH8_PAGE_INFO));
+		PLTFM_MSG_ALWAYS("R_AX_CH9_PAGE_INFO=0x%x\n",
+				 MAC_REG_R32(R_AX_CH9_PAGE_INFO));
+#if MAC_AX_8852A_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+			PLTFM_MSG_ALWAYS("R_AX_CH10_PAGE_INFO=0x%x\n",
+					 MAC_REG_R32(R_AX_CH10_PAGE_INFO));
+			PLTFM_MSG_ALWAYS("R_AX_CH11_PAGE_INFO=0x%x\n",
+					 MAC_REG_R32(R_AX_CH11_PAGE_INFO));
+		}
+#endif
+		PLTFM_MSG_ALWAYS("R_AX_CH12_PAGE_INFO=0x%x\n",
+				 MAC_REG_R32(R_AX_CH12_PAGE_INFO));
+	}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		PLTFM_MSG_ALWAYS("R_AX_ACH0_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH0_PAGE_INFO_V1));
+		PLTFM_MSG_ALWAYS("R_AX_ACH1_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH1_PAGE_INFO_V1));
+		PLTFM_MSG_ALWAYS("R_AX_ACH2_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH2_PAGE_INFO_V1));
+		PLTFM_MSG_ALWAYS("R_AX_ACH3_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH3_PAGE_INFO_V1));
+		PLTFM_MSG_ALWAYS("R_AX_ACH4_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH4_PAGE_INFO_V1));
+		PLTFM_MSG_ALWAYS("R_AX_ACH5_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH5_PAGE_INFO_V1));
+		PLTFM_MSG_ALWAYS("R_AX_ACH6_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH6_PAGE_INFO_V1));
+		PLTFM_MSG_ALWAYS("R_AX_ACH7_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH7_PAGE_INFO_V1));
+		PLTFM_MSG_ALWAYS("R_AX_CH8_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_CH8_PAGE_INFO_V1));
+		PLTFM_MSG_ALWAYS("R_AX_CH9_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_CH9_PAGE_INFO_V1));
+		PLTFM_MSG_ALWAYS("R_AX_CH10_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_CH10_PAGE_INFO_V1));
+		PLTFM_MSG_ALWAYS("R_AX_CH11_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_CH11_PAGE_INFO_V1));
+		PLTFM_MSG_ALWAYS("R_AX_CH12_PAGE_INFO_V1=0x%x\n",
+				 MAC_REG_R32(R_AX_CH12_PAGE_INFO_V1));
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 mac_tx_status_dump(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 idx = 0, ret = 0, cmac0_en = 0, cmac1_en = 0;
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ALWAYS("[WARN] check dmac en %d\n", ret);
+		return ret;
+	}
+
+	/* Dispatcher */
+	PLTFM_MSG_ALWAYS("R_AX_DMAC_MACID_DROP_0=0x%x\n",
+			 MAC_REG_R32(R_AX_DMAC_MACID_DROP_0));
+	PLTFM_MSG_ALWAYS("R_AX_DMAC_MACID_DROP_1=0x%x\n",
+			 MAC_REG_R32(R_AX_DMAC_MACID_DROP_1));
+	PLTFM_MSG_ALWAYS("R_AX_DMAC_MACID_DROP_2=0x%x\n",
+			 MAC_REG_R32(R_AX_DMAC_MACID_DROP_2));
+	PLTFM_MSG_ALWAYS("R_AX_DMAC_MACID_DROP_3=0x%x\n",
+			 MAC_REG_R32(R_AX_DMAC_MACID_DROP_3));
+
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+	cmac0_en = check_mac_en(adapter, 0, MAC_AX_CMAC_SEL);
+	if (cmac0_en == MACSUCCESS) {
+		/* MGQ */
+		PLTFM_MSG_ALWAYS("R_AX_CMAC_MACID_DROP_0=0x%x\n",
+				 MAC_REG_R32(R_AX_CMAC_MACID_DROP_0));
+		PLTFM_MSG_ALWAYS("R_AX_CMAC_MACID_DROP_1=0x%x\n",
+				 MAC_REG_R32(R_AX_CMAC_MACID_DROP_1));
+		PLTFM_MSG_ALWAYS("R_AX_CMAC_MACID_DROP_2=0x%x\n",
+				 MAC_REG_R32(R_AX_CMAC_MACID_DROP_2));
+		PLTFM_MSG_ALWAYS("R_AX_CMAC_MACID_DROP_3=0x%x\n",
+				 MAC_REG_R32(R_AX_CMAC_MACID_DROP_3));
+		/* HIQ */
+		PLTFM_MSG_ALWAYS("R_AX_MBSSID_DROP_0=0x%x\n",
+				 MAC_REG_R32(R_AX_MBSSID_DROP_0));
+		/* lifetime, PTCL TX mode */
+		PLTFM_MSG_ALWAYS("R_AX_PTCL_COMMON_SETTING_0=0x%x\n",
+				 MAC_REG_R32(R_AX_PTCL_COMMON_SETTING_0));
+
+		/* MAC response abort counter */
+		PLTFM_MSG_ALWAYS("R_AX_RESP_TX_NAV_ABORT_COUNTER=0x%x\n",
+				 MAC_REG_R32(R_AX_RESP_TX_NAV_ABORT_COUNTER));
+		PLTFM_MSG_ALWAYS("R_AX_RESP_TX_CCA_ABORT_COUNTER=0x%x\n",
+				 MAC_REG_R32(R_AX_RESP_TX_CCA_ABORT_COUNTER));
+		PLTFM_MSG_ALWAYS("R_AX_TRXPTCL_RESP_TX_ABORT_COUNTER=0x%x\n",
+				 MAC_REG_R32(R_AX_TRXPTCL_RESP_TX_ABORT_COUNTER));
+	}
+	cmac1_en = check_mac_en(adapter, 1, MAC_AX_CMAC_SEL);
+	if (cmac1_en == MACSUCCESS) {
+		/* MGQ */
+		PLTFM_MSG_ALWAYS("R_AX_CMAC_MACID_DROP_0_C1=0x%x\n",
+				 MAC_REG_R32(R_AX_CMAC_MACID_DROP_0_C1));
+		PLTFM_MSG_ALWAYS("R_AX_CMAC_MACID_DROP_1_C1=0x%x\n",
+				 MAC_REG_R32(R_AX_CMAC_MACID_DROP_1_C1));
+		PLTFM_MSG_ALWAYS("R_AX_CMAC_MACID_DROP_2_C1=0x%x\n",
+				 MAC_REG_R32(R_AX_CMAC_MACID_DROP_2_C1));
+		PLTFM_MSG_ALWAYS("R_AX_CMAC_MACID_DROP_3_C1=0x%x\n",
+				 MAC_REG_R32(R_AX_CMAC_MACID_DROP_3_C1));
+		/* HIQ */
+		PLTFM_MSG_ALWAYS("R_AX_MBSSID_DROP_0_C1=0x%x\n",
+				 MAC_REG_R32(R_AX_MBSSID_DROP_0_C1));
+		/* lifetime, PTCL TX mode */
+		PLTFM_MSG_ALWAYS("R_AX_PTCL_COMMON_SETTING_0_C1=0x%x\n",
+				 MAC_REG_R32(R_AX_PTCL_COMMON_SETTING_0_C1));
+
+		/* MAC response abort counter */
+		PLTFM_MSG_ALWAYS("R_AX_RESP_TX_NAV_ABORT_COUNTER_C1=0x%x\n",
+				 MAC_REG_R32(R_AX_RESP_TX_NAV_ABORT_COUNTER_C1));
+		PLTFM_MSG_ALWAYS("R_AX_RESP_TX_CCA_ABORT_COUNTER_C1=0x%x\n",
+				 MAC_REG_R32(R_AX_RESP_TX_CCA_ABORT_COUNTER_C1));
+		PLTFM_MSG_ALWAYS("R_AX_TRXPTCL_RESP_TX_ABORT_COUNTER_C1=0x%x\n",
+				 MAC_REG_R32(R_AX_TRXPTCL_RESP_TX_ABORT_COUNTER_C1));
+	}
+#endif
+
+	/* Sleep */
+	PLTFM_MSG_ALWAYS("R_AX_MACID_SLEEP_0=0x%x\n",
+			 MAC_REG_R32(R_AX_MACID_SLEEP_0));
+	PLTFM_MSG_ALWAYS("R_AX_MACID_SLEEP_1=0x%x\n",
+			 MAC_REG_R32(R_AX_MACID_SLEEP_1));
+	PLTFM_MSG_ALWAYS("R_AX_MACID_SLEEP_2=0x%x\n",
+			 MAC_REG_R32(R_AX_MACID_SLEEP_2));
+	PLTFM_MSG_ALWAYS("R_AX_MACID_SLEEP_3=0x%x\n",
+			 MAC_REG_R32(R_AX_MACID_SLEEP_3));
+
+	/* Pause */
+	PLTFM_MSG_ALWAYS("R_AX_SS_MACID_PAUSE_0=0x%x\n",
+			 MAC_REG_R32(R_AX_SS_MACID_PAUSE_0));
+	PLTFM_MSG_ALWAYS("R_AX_SS_MACID_PAUSE_1=0x%x\n",
+			 MAC_REG_R32(R_AX_SS_MACID_PAUSE_1));
+	PLTFM_MSG_ALWAYS("R_AX_SS_MACID_PAUSE_2=0x%x\n",
+			 MAC_REG_R32(R_AX_SS_MACID_PAUSE_2));
+	PLTFM_MSG_ALWAYS("R_AX_SS_MACID_PAUSE_3=0x%x\n",
+			 MAC_REG_R32(R_AX_SS_MACID_PAUSE_3));
+
+	if (cmac0_en == MACSUCCESS) {
+		/* Scheduler Tx_en */
+		PLTFM_MSG_ALWAYS("R_AX_CTN_TXEN=0x%x\n",
+				 MAC_REG_R32(R_AX_CTN_TXEN));
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ALWAYS("R_AX_CTN_DRV_TXEN=0x%x\n",
+					 MAC_REG_R32(R_AX_CTN_DRV_TXEN));
+		}
+#endif
+		/* Loopback mode */
+		PLTFM_MSG_ALWAYS("R_AX_MAC_LOOPBACK=0x%x\n",
+				 MAC_REG_R32(R_AX_MAC_LOOPBACK));
+	}
+
+	if (cmac1_en == MACSUCCESS) {
+		/* Scheduler Tx_en */
+		PLTFM_MSG_ALWAYS("R_AX_CTN_TXEN_C1=0x%x\n",
+				 MAC_REG_R32(R_AX_CTN_TXEN_C1));
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ALWAYS("R_AX_CTN_DRV_TXEN_C1=0x%x\n",
+					 MAC_REG_R32(R_AX_CTN_DRV_TXEN_C1));
+		}
+#endif
+		/* Loopback mode */
+		PLTFM_MSG_ALWAYS("R_AX_MAC_LOOPBACK_C1=0x%x\n",
+				 MAC_REG_R32(R_AX_MAC_LOOPBACK_C1));
+	}
+
+	/* per MACID WD empty */
+	for (idx = 0; idx < 4; idx++) {
+		MAC_REG_W32(R_AX_WDE_Q_STATUS_CFG, idx);
+		PLTFM_MSG_ALWAYS("R_AX_WDE_Q_STATUS_VAL=0x%x\n",
+				 MAC_REG_R32(R_AX_WDE_Q_STATUS_VAL));
+	}
+
+	mac_quota_dump(adapter);
+
+	/* Polluted */
+	PLTFM_MSG_ALWAYS("R_AX_CCA_CONTROL=0x%x\n",
+			 MAC_REG_R32(R_AX_CCA_CONTROL));
+	PLTFM_MSG_ALWAYS("R_AX_BT_PLT=0x%x\n",
+			 MAC_REG_R32(R_AX_BT_PLT));
+
+	/* FW Tx report counter */
+	PLTFM_MSG_ALWAYS("R_AX_UDM0=0x%x\n",
+			 MAC_REG_R32(R_AX_UDM0));
+
+	pltfm_dbg_dump(adapter);
+
+	/* FW CMAC error counter */
+	if (mac_io_chk_access(adapter, R_AX_SER_DBG_INFO) == MACSUCCESS)
+		PLTFM_MSG_ALWAYS("R_AX_SER_DBG_INFO = 0x%x\n",
+				 MAC_REG_R32(R_AX_SER_DBG_INFO));
+	PLTFM_DELAY_US(MAC_DBG_DUMP_DLY_US);
+
+	return MACSUCCESS;
+}
+
+static u32 ptcl_status_dump(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret, reg, val32;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[WARN] check cmac en %d\n", ret);
+		return ret;
+	}
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		reg = band == MAC_AX_BAND_1 ?
+		      R_AX_PTCL_TX_CTN_SEL_C1 : R_AX_PTCL_TX_CTN_SEL;
+		val32 = MAC_REG_R32(reg);
+		PLTFM_MSG_ALWAYS("B%d PTCL_TX_CTN_SEL=0x%x\n", band, val32);
+#endif
+	} else {
+		PLTFM_MSG_ERR("[WARN] unknown chip for ptcl_status dump\n");
+		return MACCHIPID;
+	}
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		reg = band == MAC_AX_BAND_1 ?
+		      R_AX_PTCL_TX_MACID_0_C1 : R_AX_PTCL_TX_MACID_0;
+		val32 = MAC_REG_R32(reg);
+		PLTFM_MSG_ALWAYS("B%d PTCL_TX_MACID_0=0x%x\n", band, val32);
+#endif
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		   is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		   is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		   is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		reg = band == MAC_AX_BAND_1 ?
+		      R_AX_PTCL_TX_MACID_0_V1_C1 : R_AX_PTCL_TX_MACID_0_V1;
+		val32 = MAC_REG_R32(reg);
+		PLTFM_MSG_ALWAYS("B%d PTCL_TX_MACID_0=0x%x\n", band, val32);
+#endif
+	} else {
+		PLTFM_MSG_ERR("[WARN] unknown chip for ptcl_status dump\n");
+		return MACCHIPID;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_tx_flow_dbg(struct mac_ax_adapter *adapter)
+{
+	u32 ret, idx = 0;
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	u32 i, val32;
+#endif
+
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	for (idx = 0; idx < TX_FLOW_DMP_NUM; idx++) {
+		/* commom check */
+		ret = mac_tx_status_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]common check %d\n", ret);
+
+		/* dump TMAC tr counter */
+		ret = tx_cnt_dump(adapter, MAC_AX_BAND_0,
+				  TXFLOW_TRX_CNT_REPT_CNT);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B0 tx cnt dump err %d\n", ret);
+
+		ret = tx_cnt_dump(adapter, MAC_AX_BAND_1,
+				  TXFLOW_TRX_CNT_REPT_CNT);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B1 tx cnt dump err %d\n", ret);
+
+		ret = p_ops->crit_dbg_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("crit dbg dump %d\n", ret);
+
+		/* dump PTCL TX status */
+		ret = ptcl_status_dump(adapter, MAC_AX_BAND_0);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B0 ptcl tx status dump err %d\n", ret);
+		ret = ptcl_status_dump(adapter, MAC_AX_BAND_1);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B1 ptcl tx status dump err %d\n", ret);
+
+		/* PTCL Debug port */
+		ret = p_ops->tx_flow_ptcl_dbg_port(adapter, MAC_AX_BAND_0);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B0 ptcl dbg dump err %d\n", ret);
+
+		ret = p_ops->tx_flow_ptcl_dbg_port(adapter, MAC_AX_BAND_1);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B1 ptcl dbg dump err %d\n", ret);
+
+		/* check dle status */
+		ret = mac_dle_status_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN] dle status err %d\n", ret);
+
+		/* Sch Debug port */
+		ret = p_ops->tx_flow_sch_dbg_port(adapter, MAC_AX_BAND_0);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B0 sch dbg err %d\n", ret);
+
+		ret = p_ops->tx_flow_sch_dbg_port(adapter, MAC_AX_BAND_1);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B1 sch dbg dump err %d\n", ret);
+
+		/* HCI flow control */
+		mac_hci_flow_ctrl_dump(adapter);
+
+		/* zero delimiter */
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ALWAYS("R_AX_DEBUG_ZLD_COUNTER_U0_U1=0x%x\n",
+					 MAC_REG_R32(R_AX_DEBUG_ZLD_COUNTER_U0_U1));
+			PLTFM_MSG_ALWAYS("R_AX_DEBUG_ZLD_COUNTER_U2_U3=0x%x\n",
+					 MAC_REG_R32(R_AX_DEBUG_ZLD_COUNTER_U2_U3));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			for (i = 0; i <= 3; i++) {
+				val32 = MAC_REG_R32(R_AX_MACTX_DBG_SEL_CNT);
+				val32 = SET_CLR_WORD(val32, i, B_AX_DBG_USER_SEL);
+				MAC_REG_W32(R_AX_MACTX_DBG_SEL_CNT, val32);
+				PLTFM_MSG_ALWAYS("R_AX_MACTX_ZLD_CNT %d=0x%x\n", i,
+						 MAC_REG_R32(R_AX_MACTX_ZLD_CNT));
+			}
+		}
+#endif
+
+		PLTFM_MSG_ALWAYS("R_AX_PREBKF_CFG_0=0x%x\n",
+				 MAC_REG_R32(R_AX_PREBKF_CFG_0));
+	}
+
+	return MACSUCCESS;
+}
+
+void mac_dbg_status_dump(struct mac_ax_adapter *adapter,
+			 struct mac_ax_dbgpkg *val, struct mac_ax_dbgpkg_en *en)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret, i;
+	u32 ret_dmac = MACSUCCESS;
+	u8 cmac_allow;
+
+	adapter->sm.l2_st = MAC_AX_L2_DIS;
+	ret = p_ops->crit_dbg_dump(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("crit dbg dump %d\n", ret);
+		return;
+	}
+
+	ret = fw_st_dbg_dump(adapter);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("fw st dump %d\n", ret);
+
+	if (en->dmac_dbg) {
+		ret_dmac = p_ops->dmac_dbg_dump(adapter);
+		if (ret_dmac != MACSUCCESS)
+			PLTFM_MSG_ERR("dmac dbg dump %d\n", ret_dmac);
+	}
+
+	cmac_allow = en->cmac_dbg && ret_dmac == MACSUCCESS ? 1 : 0;
+	if (cmac_allow) {
+		ret = p_ops->cmac_dbg_dump(adapter, MAC_AX_BAND_0);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("cmac%d dbg dump %d\n",
+				      MAC_AX_BAND_0, ret);
+
+		ret = p_ops->cmac_dbg_dump(adapter, MAC_AX_BAND_1);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("cmac%d dbg dump %d\n",
+				      MAC_AX_BAND_1, ret);
+	}
+
+	if (en->mac_dbg_port) {
+		for (i = MAC_AX_DBG_PORT_SEL_PTCL_C0;
+		     i < MAC_AX_DBG_PORT_SEL_LAST; i++) {
+			if (p_ops->is_dbg_port_not_valid(adapter, i))
+				continue;
+			ret = dbg_port_dump(adapter, i);
+			if (ret == MACDBGPORTSEL) {
+				PLTFM_MSG_WARN("no dbg port sel %d\n", i);
+				continue;
+			} else if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("dbg port %d dump %d\n", i, ret);
+				break;
+			}
+		}
+	}
+
+	if (cmac_allow) {
+		/* 2nd dump trx counter after dbg port dump */
+		ret = tx_cnt_dump(adapter, MAC_AX_BAND_0, TRX_CNT_REPT_CNT);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B0 tx cnt dump err %d\n", ret);
+		ret = rx_cnt_dump(adapter, MAC_AX_BAND_0, TRX_CNT_REPT_CNT);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B0 rx cnt dump err %d\n", ret);
+
+		ret = tx_cnt_dump(adapter, MAC_AX_BAND_1, TRX_CNT_REPT_CNT);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B1 tx cnt dump err %d\n", ret);
+		ret = rx_cnt_dump(adapter, MAC_AX_BAND_1, TRX_CNT_REPT_CNT);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("[WARN]B1 rx cnt dump err %d\n", ret);
+	}
+
+	if (en->dle_dbg && ret_dmac == MACSUCCESS) {
+		ret = dle_dbg_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("dle dbg dump %d\n", ret);
+
+		for (i = MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_FREEPG;
+		     i < MAC_AX_DLE_DFI_SEL_LAST; i++) {
+			if (!chk_dle_dfi_valid(adapter, i))
+				continue;
+			ret = dle_dfi_dump(adapter, i);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("dle dfi %d dump %d\n", i, ret);
+				break;
+			}
+		}
+	}
+
+	if (en->plersvd_dbg) {
+		ret = rsvd_ple_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("rsvd dle dump %d\n", ret);
+	}
+
+	if (en->ss_dbg && ret_dmac == MACSUCCESS) {
+		ret = ss_dbgpkg(adapter, val);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ALWAYS("ss dbgpkg %d\n", ret);
+	}
+
+	ret = dbgport_hw_dump(adapter, &en->dp_hw_en);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("dbgport hw dump %d\n", ret);
+
+	PLTFM_MSG_ALWAYS("access H2CREG before MAC init: %d\n",
+			 adapter->stats.h2c_reg_uninit);
+	PLTFM_MSG_ALWAYS("access C2HREG before MAC init: %d\n",
+			 adapter->stats.c2h_reg_uninit);
+	PLTFM_MSG_ALWAYS("access H2CPKT before MAC init: %d\n",
+			 adapter->stats.h2c_pkt_uninit);
+
+	adapter->sm.l2_st = MAC_AX_L2_EN;
+
+	if (en->tx_flow_dbg) {
+		ret = mac_tx_flow_dbg(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("tx flow dbg %d\n", ret);
+	}
+}
+
+u32 mac_sram_dbg_write(struct mac_ax_adapter *adapter, u32 offset,
+		       u32 val, enum mac_ax_sram_dbg_sel sel)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_base;
+
+	if (adapter->hw_info->is_sec_ic) {
+		PLTFM_MSG_ERR("[ERR]security mode ind accees\n");
+		return MACIOERRINSEC;
+	}
+
+	switch (sel) {
+	case CPU_LOCAL_SEL:
+		reg_base = CPU_LOCAL_BASE_ADDR + offset;
+		break;
+	case WCPU_DATA_SEL:
+		reg_base = WCPU_DATA_BASE_ADDR + offset;
+		break;
+	case AXIDMA_SEL:
+		reg_base = AXIDMA_BASE_ADDR + offset;
+		break;
+	case STA_SCHED_SEL:
+		reg_base = STA_SCHED_BASE_ADDR + offset;
+		break;
+	case RXPLD_FLTR_CAM_SEL:
+		reg_base = RXPLD_FLTR_CAM_BASE_ADDR + offset;
+		break;
+	case SEC_CAM_SEL:
+		reg_base = SEC_CAM_BASE_ADDR + offset;
+		break;
+	case WOW_CAM_SEL:
+		reg_base = WOW_CAM_BASE_ADDR + offset;
+		break;
+	case CMAC_TBL_SEL:
+		reg_base = CMAC_TBL_BASE_ADDR + offset;
+		break;
+	case ADDR_CAM_SEL:
+		reg_base = ADDR_CAM_BASE_ADDR + offset;
+		break;
+	case BSSID_CAM_SEL:
+		reg_base = BSSID_CAM_BASE_ADDR + offset;
+		break;
+	case BA_CAM_SEL:
+		reg_base = BA_CAM_BASE_ADDR + offset;
+		break;
+	case BCN_IE_CAM0_SEL:
+		reg_base = BCN_IE_CAM0_BASE_ADDR + offset;
+		break;
+	case SHARED_BUF_SEL:
+		reg_base = SHARED_BUF_BASE_ADDR + offset;
+		break;
+	case DMAC_TBL_SEL:
+		reg_base = DMAC_TBL_BASE_ADDR + offset;
+		break;
+	case SHCUT_MACHDR_SEL:
+		reg_base = SHCUT_MACHDR_BASE_ADDR + offset;
+		break;
+	case BCN_IE_CAM1_SEL:
+		reg_base = BCN_IE_CAM1_BASE_ADDR + offset;
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR] sel %d", sel);
+		return MACNOITEM;
+	}
+
+	//PLTFM_MSG_TRACE("%s ind access sel %d start\n", __func__, sel);
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+	adapter->hw_info->ind_aces_cnt++;
+	MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, reg_base);
+	MAC_REG_W32(R_AX_INDIR_ACCESS_ENTRY, val);
+	adapter->hw_info->ind_aces_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->ind_access_lock);
+	//PLTFM_MSG_TRACE("%s ind access sel %d end\n", __func__, sel);
+
+	return MACSUCCESS;
+}
+
+u32 mac_sram_dbg_read(struct mac_ax_adapter *adapter, u32 offset,
+		      enum mac_ax_sram_dbg_sel sel)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_base, ret;
+
+	if (adapter->hw_info->is_sec_ic) {
+		PLTFM_MSG_ERR("[ERR]security mode ind accees\n");
+		return MACIOERRINSEC;
+	}
+
+	switch (sel) {
+	case CPU_LOCAL_SEL:
+		reg_base = CPU_LOCAL_BASE_ADDR + offset;
+		break;
+	case WCPU_DATA_SEL:
+		reg_base = WCPU_DATA_BASE_ADDR + offset;
+		break;
+	case AXIDMA_SEL:
+		reg_base = AXIDMA_BASE_ADDR + offset;
+		break;
+	case STA_SCHED_SEL:
+		reg_base = STA_SCHED_BASE_ADDR + offset;
+		break;
+	case RXPLD_FLTR_CAM_SEL:
+		reg_base = RXPLD_FLTR_CAM_BASE_ADDR + offset;
+		break;
+	case SEC_CAM_SEL:
+		reg_base = SEC_CAM_BASE_ADDR + offset;
+		break;
+	case WOW_CAM_SEL:
+		reg_base = WOW_CAM_BASE_ADDR + offset;
+		break;
+	case CMAC_TBL_SEL:
+		reg_base = CMAC_TBL_BASE_ADDR + offset;
+		break;
+	case ADDR_CAM_SEL:
+		reg_base = ADDR_CAM_BASE_ADDR + offset;
+		break;
+	case BSSID_CAM_SEL:
+		reg_base = BSSID_CAM_BASE_ADDR + offset;
+		break;
+	case BA_CAM_SEL:
+		reg_base = BA_CAM_BASE_ADDR + offset;
+		break;
+	case BCN_IE_CAM0_SEL:
+		reg_base = BCN_IE_CAM0_BASE_ADDR + offset;
+		break;
+	case SHARED_BUF_SEL:
+		reg_base = SHARED_BUF_BASE_ADDR + offset;
+		break;
+	case DMAC_TBL_SEL:
+		reg_base = DMAC_TBL_BASE_ADDR + offset;
+		break;
+	case SHCUT_MACHDR_SEL:
+		reg_base = SHCUT_MACHDR_BASE_ADDR + offset;
+		break;
+	case BCN_IE_CAM1_SEL:
+		reg_base = BCN_IE_CAM1_BASE_ADDR + offset;
+		break;
+	case WD_PAGE_SEL:
+		reg_base = WD_PAGE_BASE_ADDR + offset;
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR] sel %d", sel);
+		return MACNOITEM;
+	}
+
+	//PLTFM_MSG_TRACE("%s ind access sel %d start\n", __func__, sel);
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+	adapter->hw_info->ind_aces_cnt++;
+	MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, reg_base);
+	ret = MAC_REG_R32(R_AX_INDIR_ACCESS_ENTRY);
+	adapter->hw_info->ind_aces_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->ind_access_lock);
+	//PLTFM_MSG_TRACE("%s ind access sel %d end\n", __func__, sel);
+
+	return ret;
+}
+
+static u32 get_rx_idx(struct mac_ax_adapter *adapter,
+		      struct mac_ax_rx_cnt *rxcnt, u8 *idx)
+{
+	u8 rx_type[MAC_AX_RX_CNT_TYPE_NUM][MAC_AX_RX_PPDU_MAX] = {
+		MAC_AX_RXCRC_OK_IDX, MAC_AX_RXCRC_FAIL_IDX,
+		 MAC_AX_RXFA_IDX, MAC_AX_RXPPDU_IDX};
+	u8 type = rxcnt->type;
+
+	switch (type) {
+	case MAC_AX_RX_CRC_OK:
+	case MAC_AX_RX_CRC_FAIL:
+	case MAC_AX_RX_FA:
+	case MAC_AX_RX_PPDU:
+		PLTFM_MEMCPY(idx, rx_type[type], MAC_AX_RX_PPDU_MAX);
+		break;
+	case MAC_AX_RX_IDX:
+		PLTFM_MEMSET(idx, MAC_AX_RX_CNT_IDX_MAX, MAC_AX_RX_PPDU_MAX);
+		idx[0] = rxcnt->idx;
+		break;
+	default:
+		PLTFM_MSG_ERR("Wrong RX cnt type\n");
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_rx_cnt(struct mac_ax_adapter *adapter,
+	       struct mac_ax_rx_cnt *rxcnt)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = MACSUCCESS;
+	u32 reg = rxcnt->band ? R_AX_RX_DBG_CNT_SEL_C1 : R_AX_RX_DBG_CNT_SEL;
+	u32 clk = rxcnt->band ? R_AX_RXGCK_CTRL_C1 : R_AX_RXGCK_CTRL;
+	u8 i;
+	u8 idx[MAC_AX_RX_PPDU_MAX] = {MAC_AX_RX_CNT_IDX_MAX};
+	u16 *buf = rxcnt->buf;
+	u8 val;
+
+	switch (rxcnt->op) {
+	case MAC_AX_RXCNT_R:
+		if (!buf) {
+			PLTFM_MSG_ERR("The rx cnt buffer is NULL\n");
+			return MACNPTR;
+		}
+
+		ret = get_rx_idx(adapter, rxcnt, idx);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("Get RX index fail\n");
+			return ret;
+		}
+
+		for (i = 0; i < MAC_AX_RX_PPDU_MAX; i++) {
+			if (idx[i] ==  MAC_AX_RX_CNT_IDX_MAX) {
+				buf[i] = 0;
+				continue;
+			}
+			MAC_REG_W8(reg, idx[i]);
+			buf[i] = MAC_REG_R16(reg + 2);
+		}
+		break;
+	case MAC_AX_RXCNT_RST_ALL:
+		val = MAC_REG_R8(clk);
+		MAC_REG_W8(clk, val | BIT(0));
+		MAC_REG_W8(reg + 1, BIT(0));
+		MAC_REG_W8(clk, val);
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_dump_fw_rsvd_ple(struct mac_ax_adapter *adapter, u8 **buf)
+{
+	u32 ret = MACSUCCESS;
+	u32 addr;
+	*buf = NULL;
+
+	if (adapter->mac_pwr_info.pwr_seq_proc ||
+	    adapter->sm.pwr != MAC_AX_PWR_ON ||
+	    adapter->mac_pwr_info.pwr_in_lps ||
+	    adapter->sm.fw_rst == MAC_AX_FW_RESET_RECV ||
+	    adapter->sm.fw_rst == MAC_AX_FW_RESET_RECV_DONE ||
+	    adapter->sm.fw_rst == MAC_AX_FW_RESET_PROCESS)
+		return MACPWRSTAT;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+		addr = RSVD_PLE_OFST_8852A;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+		addr = RSVD_PLE_OFST_8852B;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C)) {
+		addr = RSVD_PLE_OFST_8852C;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) {
+		addr = RSVD_PLE_OFST_8192XB;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		addr = RSVD_PLE_OFST_8851B;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E)) {
+		addr = RSVD_PLE_OFST_8851E;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		addr = RSVD_PLE_OFST_8852D;
+	} else {
+		PLTFM_MSG_ERR("[ERR]unknown chip id\n");
+		return MACCHIPID;
+	}
+
+	*buf = (u8 *)PLTFM_MALLOC(FW_RSVD_PLE_SIZE);
+	if (!*buf)
+		return MACBUFALLOC;
+
+	ret = __dump_mac_mem(adapter, MAC_AX_MEM_SHARED_BUF, addr,
+			     *buf, FW_RSVD_PLE_SIZE, 1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("Dump fw rsvd ple %d\n", ret);
+		PLTFM_FREE(*buf, FW_RSVD_PLE_SIZE);
+	}
+
+	ret = fw_backtrace_dump(adapter);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("fw backtrace dump %d\n", ret);
+
+	ret = fw_ple_fwerror_dump(adapter);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("fw error dump %d\n", ret);
+
+	return ret;
+}
+
+void mac_dump_ple_dbg_page(struct mac_ax_adapter *adapter, u8 page_num)
+{
+	u32 ret = MACSUCCESS;
+	u32 addr = 0;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+		addr = RSVD_PLE_OFST_8852A;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+		addr = RSVD_PLE_OFST_8852B;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C)) {
+		addr = RSVD_PLE_OFST_8852C;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) {
+		addr = RSVD_PLE_OFST_8192XB;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		addr = RSVD_PLE_OFST_8851B;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E)) {
+		addr = RSVD_PLE_OFST_8851E;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		addr = RSVD_PLE_OFST_8852D;
+	} else {
+		PLTFM_MSG_ERR("unknown chip id\n");
+		return;
+	}
+
+	addr = addr + RSVD_PLE_OFST_DBG_START + (page_num * FW_RSVD_PLE_DBG_SIZE);
+	PLTFM_MSG_ERR("Dump fw ple dbg page %d:\n", page_num);
+	ret = __dump_mac_mem(adapter, MAC_AX_MEM_SHARED_BUF, addr,
+			     NULL, FW_RSVD_PLE_DBG_SIZE, 0);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("Dump fw ple dbg page fail: %d\n", ret);
+		return;
+	}
+}
+
+u32 mac_fw_dbg_dump(struct mac_ax_adapter *adapter, u8 **buf, struct mac_ax_fwdbg_en *en)
+{
+	u32 ret = MACSUCCESS;
+
+	if (en->status_dbg)
+		fw_st_dbg_dump(adapter);
+
+	if (en->rsv_ple_dbg)
+		mac_dump_fw_rsvd_ple(adapter, buf);
+
+	if (en->ps_dbg)
+		ps_dbg_dump(adapter);
+
+	return ret;
+}
+
+u32 mac_event_notify(struct mac_ax_adapter *adapter, enum phl_msg_evt_id id,
+		     u8 band)
+{
+	u32 ret = MACSUCCESS, io_ret = MACSUCCESS;
+	struct mac_ax_dbgpkg dbg_val;
+	struct mac_ax_dbgpkg_en dbg_en;
+	struct mac_ax_io_stat pcie_io_stat;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_drv_stats *status = &adapter->drv_stats;
+
+	switch (id) {
+	case MSG_EVT_DBG_SIP_REG_DUMP:
+		ret = p_ops->crit_dbg_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("crit dbg dump %d\n", ret);
+
+		ret = fw_st_dbg_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("fw st dump %d\n", ret);
+
+		ret = p_ops->dmac_dbg_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("dmac dbg dump %d\n", ret);
+
+		ret = p_ops->cmac_dbg_dump(adapter, MAC_AX_BAND_0);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("cmac%d dbg dump %d\n",
+				      MAC_AX_BAND_0, ret);
+
+		break;
+	case MSG_EVT_DBG_FULL_REG_DUMP:
+		ret = mac_reg_dump(adapter, MAC_AX_REG_MAC);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("fw st dump %d\n", ret);
+		break;
+	case MSG_EVT_DBG_L2_DIAGNOSE:
+		ret = mac_ps_pwr_state(adapter, MAC_AX_PWR_STATE_ACT_REQ,
+				       MAC_AX_RPWM_REQ_PWR_STATE_ACTIVE);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("PWR_STATE_ACT_REQ fail\n");
+
+		PLTFM_MEMSET(&dbg_en, 0, sizeof(struct mac_ax_dbgpkg_en));
+
+		if (ret == MACSUCCESS) {
+			if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+				io_ret = ops->get_io_stat(adapter,
+							  &pcie_io_stat);
+				if (io_ret == MACSUCCESS &&
+				    pcie_io_stat.to_flag == 0) {
+					dbg_en.dle_dbg = 1;
+					dbg_en.dmac_dbg = 1;
+					dbg_en.cmac_dbg = 1;
+					dbg_en.plersvd_dbg = 1;
+				}
+			} else {
+				dbg_en.dle_dbg = 1;
+				dbg_en.dmac_dbg = 1;
+				dbg_en.cmac_dbg = 1;
+				dbg_en.plersvd_dbg = 1;
+			}
+		}
+		mac_dbg_status_dump(adapter, &dbg_val, &dbg_en);
+		break;
+	case MSG_EVT_DBG_RX_DUMP:
+		ret = p_ops->crit_dbg_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("crit dbg dump %d\n", ret);
+
+		ret = p_ops->dmac_dbg_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("dmac dbg dump %d\n", ret);
+
+		ret = p_ops->cmac_dbg_dump(adapter, MAC_AX_BAND_0);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("cmac%d dbg dump %d\n",
+				      MAC_AX_BAND_0, ret);
+
+		ret = dle_dbg_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("dle dbg dump %d\n", ret);
+		break;
+	case MSG_EVT_DBG_TX_DUMP:
+		ret = p_ops->tx_dbg_dump(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("tx dbg dump %d\n", ret);
+		break;
+	case MSG_EVT_DATA_PATH_START:
+		status->rx_ok = 1;
+		break;
+	case MSG_EVT_DATA_PATH_STOP:
+		status->rx_ok = 0;
+		break;
+	case MSG_EVT_SURPRISE_REMOVE:
+		status->drv_rm = 1;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return ret;
+}
+
+u32 mac_fw_dbg_dle_cfg(struct mac_ax_adapter *adapter, bool lock)
+{
+	u8 *buf;
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_general_pkt *write_ptr;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_general_pkt_ids));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+	write_ptr = (struct fwcmd_general_pkt *)buf;
+	write_ptr->dword0 =
+	cpu_to_le32((lock ? FWCMD_H2C_FW_DBGREG_CFG_FW_DBG_LOCK : 0));
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_INFO,
+			      FWCMD_H2C_FUNC_FW_DBGREG_CFG,
+			      0, 0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %d\n", ret);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_get_fw_status(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val8 = FWDL_INITIAL_STATE;
+	u32 i = 0, fw_pc = 0;
+	u32 val32, dbg_ctrl_bk, sys_status_bk;
+
+	val8 = GET_FIELD(MAC_REG_R8(R_AX_WCPU_FW_CTRL), B_AX_WCPU_FWDL_STS);
+	if (val8 == FWDL_WCPU_FW_INIT_RDY) {
+		/* Dump FW status */
+		val32 = READ_DBG_FS_REG();
+		if (val32 == FS_L2ERR_IN ||
+		    val32 == FS_L2ERR_CPU_IN ||
+		    val32 == FS_L2ERR_HCI_IN ||
+		    val32 == FS_L2ERR_ELSE_IN) {
+			return MACFWRXI300;
+		} else if (val32 == FS_ASSERT_IN) {
+			return MACFWASSERT;
+		} else if (val32 == FS_EXCEP_IN) {
+			return MACFWEXCEP;
+		}
+
+		/* Dump FW program counter */
+		dbg_ctrl_bk = MAC_REG_R32(R_AX_DBG_CTRL);
+		sys_status_bk = MAC_REG_R32(R_AX_SYS_STATUS1);
+		MAC_REG_W32(R_AX_DBG_CTRL, DBG_SEL_FW_PROG_CNTR);
+
+		val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+		val32 = SET_CLR_WORD(val32, MAC_DBG_SEL, B_AX_SEL_0XC0);
+		MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+		val8 = 0;
+		for (i = 0; i < FW_PROG_CNTR_DMP_CNT; i++) {
+			val32 = MAC_REG_R32(R_AX_DBG_PORT_SEL);
+			if (fw_pc == val32)
+				val8++;
+			fw_pc = val32;
+			PLTFM_DELAY_US(FW_PROG_CNTR_DMP_DLY_US);
+		}
+		if (val8 == FW_PROG_CNTR_DMP_CNT) {
+			PLTFM_MSG_ALWAYS("FW PC = 0x%x\n", val32);
+			return MACFWPCHANG;
+		}
+
+		MAC_REG_W32(R_AX_DBG_CTRL, dbg_ctrl_bk);
+		MAC_REG_W32(R_AX_SYS_STATUS1, sys_status_bk);
+	} else {
+		return MACNOFW;
+	}
+	return MACSUCCESS;
+}
+
+u32 mac_get_ple_dbg_addr(struct mac_ax_adapter *adapter)
+{
+	u32 addr = RSVD_PLE_OFST_DBG_START;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+		addr += RSVD_PLE_OFST_8852A;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+		addr += RSVD_PLE_OFST_8852B;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C)) {
+		addr += RSVD_PLE_OFST_8852C;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) {
+		addr += RSVD_PLE_OFST_8192XB;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		addr += RSVD_PLE_OFST_8851B;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E)) {
+		addr += RSVD_PLE_OFST_8851E;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		addr += RSVD_PLE_OFST_8852D;
+	} else {
+		PLTFM_MSG_ERR("[ERR]unknown chip id\n");
+		return MACCHIPID;
+	}
+
+	return addr;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgpkg.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgpkg.h
new file mode 100644
index 000000000000..16810e968101
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgpkg.h
@@ -0,0 +1,1518 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_DBGPKG_H_
+#define _MAC_AX_DBGPKG_H_
+
+#include "../mac_def.h"
+#include "../mac_ax.h"
+#include "fwcmd.h"
+#include "trx_desc.h"
+#include "trxcfg.h"
+#include "dle.h"
+
+#define FW_RSVD_PLE_SIZE 0x800
+#define RSVD_PLE_OFST_8852A 0x6f800
+#define RSVD_PLE_OFST_8852B 0x2f800
+#define RSVD_PLE_OFST_8852C 0x6f800
+#define RSVD_PLE_OFST_8192XB 0x6f800
+#define RSVD_PLE_OFST_8851B 0x2f800
+#define RSVD_PLE_OFST_8851E 0x6f800
+#define RSVD_PLE_OFST_8852D 0x6f800
+#define FW_RSVD_PLE_DBG_SIZE 0x100
+#define RSVD_PLE_OFST_DBG_START 0x400
+#define SHARE_BUFFER_SIZE_8852A 0x70000
+#define SHARE_BUFFER_SIZE_8852B 0x30000
+#define SHARE_BUFFER_SIZE_8852C 0x70000
+#define SHARE_BUFFER_SIZE_8192XB 0x70000
+#define SHARE_BUFFER_SIZE_8851B 0x30000
+#define SHARE_BUFFER_SIZE_8851E 0x70000
+#define SHARE_BUFFER_SIZE_8852D 0x70000
+#define STA_SCHED_MEM_SIZE 0x1200
+#define RXPLD_FLTR_CAM_MEM_SIZE 0x200
+#define SECURITY_CAM_MEM_SIZE 0x800
+#define WOW_CAM_MEM_SIZE 0x240
+#define ADDR_CAM_MEM_SIZE 0x4000
+#define TXD_FIFO_SIZE 0x200
+#define DBG_PORT_DUMP_DLY_US 10
+#define FW_BACKTRACE_MAX_SIZE 512 // 8 * 64(entry)
+#define FW_BACKTRACE_KEY 0xBACEBACE
+#define FW_BACKTRACE_SIZE_OFST 4
+#define FW_BACKTRACE_KEY_OFST 8
+
+#define B_AX_AXIDMA_INT_SEL_SH 22
+#define B_AX_AXIDMA_INT_SEL_MSK 0x7
+
+#define TMAC_TX_CNT_NUM 11
+#define RMAC_RX_CNT_NUM 37
+#define TRX_CNT_REPT_CNT 5
+#define TRX_CNT_REPT_DLY_US 10
+#define TRX_CNT_READ_DLY_US 1
+#define PTCL_ST_READ_DLY_US 1
+#define PTCL_SEL_FSM_0 0x0
+#define PTCL_SEL_FSM_1 0x1
+#define PTCL_SEL_PHY_DBG 0x10
+#define SCH_SEL_PREBKF_DBG_1 0x03
+#define SCH_SEL_TX_NAV_ABORT_DBG 0x07
+#define PTCL_DBG_DMP_CNT 5
+#define SCH_DBG_DMP_CNT 5
+#define TX_FLOW_DMP_NUM 10
+#define TXFLOW_TRX_CNT_REPT_CNT 1
+
+#define MAC_DBG_DMP_CNT 15
+#define MAC_DBG_DUMP_DLY_US 10
+
+#define DBG_SEL_FW_PROG_CNTR 0xF200F2
+#define FW_PROG_CNTR_DMP_CNT 15
+#define FW_PROG_CNTR_DMP_DLY_US 10
+
+/* Wait for BCN parser idle shall consider RX beacon max time */
+#define BCN_PSR_WAIT_CNT 900
+#define BCN_PSR_WAIT_US 10
+
+/* REG dump*/
+#define MAC_PAGE_SRT		0
+#define	MAC_PAGE_AON_END	0x4
+#define	MAC_PAGE_TOP_END	0xF
+#define	MAC_PAGE_HCI_SRT	0x10
+#define	MAC_PAGE_HCI_END	0x1F
+#define	MAC_PAGE_HAXI_SRT	0x10
+#define	MAC_PAGE_HAXI_END	0x17
+#define MAC_PAGE_PCIE_SRT	0x30
+#define MAC_PAGE_PCIE_END	0x37
+#define MAC_PAGE_USB_SRT	0x50
+#define MAC_PAGE_USB_END	0x5F
+#define MAC_PAGE_SDIO_SRT	0x40
+#define MAC_PAGE_SDIO_END	0x47
+#define MAC_PAGE_DMAC_SRT	0x80
+#define	MAC_PAGE_DMAC_END	0x9F
+#define	MAC_PAGE_CMAC0_SRT	0xC0
+#define	MAC_PAGE_CMAC0_END	0xDF
+#define	MAC_PAGE_CMAC1_SRT	0xE0
+#define MAC_PAGE_END		0xFF
+#define BB_PAGE_SRT		0x100
+#define BB_PAGE_END		0x17F
+#define IQK_PAGE_SRT		0x180
+#define IQK_PAGE_END		0x1BF
+#define RFC_PAGE_SRT		0x1C0
+#define RFC_PAGE_END		0x1FF
+
+/* STA scheduler */
+#define SS_MACID_SH		8
+#define SS_TX_LEN_MSK		0x1FFFFF
+#define SS_CTRL1_R_TX_LEN	5
+#define SS_CTRL1_R_NEXT_LINK	20
+#define SS_WMM_NUM_8852A   4
+#define SS_WMM_NUM_8852B   2
+#define SS_WMM_NUM_8852C   4
+#define SS_WMM_NUM_8192XB   4
+#define SS_WMM_NUM_8851B   2
+#define SS_WMM_NUM_8851E   4
+#define SS_WMM_NUM_8852D   4
+#define SS_UL_SUPPORT_8852A    1
+#define SS_UL_SUPPORT_8852B    0
+#define SS_UL_SUPPORT_8852C    1
+#define SS_UL_SUPPORT_8192XB    1
+#define SS_UL_SUPPORT_8851B    0
+#define SS_UL_SUPPORT_8851E    1
+#define SS_UL_SUPPORT_8852D    1
+#define SS_FW_SUPPORT_8852A    1
+#define SS_FW_SUPPORT_8852B    0
+#define SS_FW_SUPPORT_8852C    1
+#define SS_FW_SUPPORT_8192XB    1
+#define SS_FW_SUPPORT_8851B    0
+#define SS_FW_SUPPORT_8851E    1
+#define SS_FW_SUPPORT_8852D    1
+#define SS_POLL_UNEXPECTED	0xFFFFFFFF
+
+/* MAC debug port */
+#define CMAC_DMA_DBG_SEL_C0 0xA0
+#define TMAC_DBG_SEL_C0 0xA5
+#define RMAC_DBG_SEL_C0 0xA6
+#define TRXPTCL_DBG_SEL_C0 0xA7
+#define CMAC_DMA_DBG_SEL_C1 0xB0
+#define TMAC_DBG_SEL_C1 0xB5
+#define RMAC_DBG_SEL_C1 0xB6
+#define TRXPTCL_DBG_SEL_C1 0xB7
+#define PCIE_TXDMA_DBG_SEL 0x30
+#define PCIE_RXDMA_DBG_SEL 0x31
+#define PCIE_CVT_DBG_SEL 0x32
+#define PCIE_EMAC04_DBG_SEL 0x33
+#define PCIE_EMAC5_DBG_SEL 0x34
+#define PCIE_EMAC6_DBG_SEL 0x35
+#define PCIE_EMAC7_DBG_SEL 0x36
+#define PCIE_PNP_IO_DBG_SEL 0x37
+#define PCIE_EMAC814_DBG_SEL 0x38
+#define PCIE_EMAC15_DBG_SEL 0x39
+#define PCIE_EMAC16_DBG_SEL 0x3A
+#define PCIE_EMAC17_DBG_SEL 0x3B
+#define PCIE_EMAC18_DBG_SEL 0x3C
+#define PCIE_IO_DBG_SEL 0x37
+#define PCIE_MISC_DBG_SEL 0x38
+#define PCIE_MISC2_DBG_SEL 0x00
+#define USB2_PHY_DBG_SEL 0x40
+#define USB2_SIE_DBG_SEL 0x41
+#define USB2_UTMI_DBG_SEL 0x42
+#define USB2_SIE_MMU_DBG_SEL 0x43
+#define USB2_SIE_PCE_DBG_SEL 0x44
+#define USB2_UTMI_IF_DBG_SEL 0x45
+#define USB_WLTX_DBG_SEL 0x46
+#define USB_WLRX_DBG_SEL 0x47
+#define USB3_DBG_SEL 0x48
+#define USB_SETUP_DBG_SEL 0x49
+#define USB_WLTXDMA_DBG_SEL 0x4A
+#define USB_WLRXDMA_DBG_SEL 0x4B
+#define USB_AINST_DBG_SEL 0x4C
+#define USB_MISC_DBG_SEL 0x4D
+#define USB_BTTX_DBG_SEL 0x4E
+#define USB2_BT_DBG_SEL 0x4F
+#define HAXIDMA_DBG_SEL 0x70
+#define PAXIDMA_DBG_SEL 0x71
+#define DISPATCHER_DBG_SEL 0x80
+#define STA_SCH_DBG_SEL	0x89
+
+#define MAC_DBG_SEL 1
+#define RMAC_CMAC_DBG_SEL 1
+
+/* TRXPTCL dbg port sel */
+#define TRXPTRL_DBG_SEL_TMAC 0
+#define TRXPTRL_DBG_SEL_RMAC 1
+
+#define MAC_AX_RX_CNT_NUM 48
+#define MAC_AX_RX_CNT_IDX_MAX MAC_AX_RX_CNT_NUM
+#define MAC_AX_RX_CNT_TYPE_NUM 5
+
+/* the order is CCK, OFDM, HT, VHTSU, VHTMU, HESU, HEMU, HETB */
+#define MAC_AX_RXCRC_OK_IDX \
+	{3, 0, 6, 10, 14, 18, 22, 26}
+#define MAC_AX_RXCRC_FAIL_IDX \
+	{4, 1, 7, 11, 15, 19, 23, 27}
+#define MAC_AX_RXPPDU_IDX \
+	{MAC_AX_RX_CNT_IDX_MAX, MAC_AX_RX_CNT_IDX_MAX, 8, 12, 16, 20, 24, 28}
+#define MAC_AX_RXFA_IDX \
+	{5, 2, 9, 13, 17, 21, 25, 29}
+
+#define READ_DBG_FS_REG() GET_FIELD(MAC_REG_R32(R_AX_UDM0), B_AX_UDM0_FS_CODE)
+
+/**
+ * @enum mac_ax_sram_dbg_sel
+ *
+ * @brief mac_ax_sram_dbg_sel
+ *
+ * @var mac_ax_sram_dbg_sel::CPU_LOCAL_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::WCPU_DATA_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::AXIDMA_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::STA_SCHED_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::RXPLD_FLTR_CAM_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::SEC_CAM_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::WOW_CAM_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::CMAC_TBL_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::ADDR_CAM_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::BSSID_CAM_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::BA_CAM_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::BCN_IE_CAM0_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::SHARED_BUF_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::DMAC_TBL_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::SHCUT_MACHDR_SEL
+ * Please Place Description here.
+ * @var mac_ax_sram_dbg_sel::BCN_IE_CAM1_SEL
+ * Please Place Description here.
+ */
+enum mac_ax_sram_dbg_sel {
+	CPU_LOCAL_SEL,
+	WCPU_DATA_SEL,
+	AXIDMA_SEL,
+	STA_SCHED_SEL,
+	RXPLD_FLTR_CAM_SEL,
+	SEC_CAM_SEL,
+	WOW_CAM_SEL,
+	CMAC_TBL_SEL,
+	ADDR_CAM_SEL,
+	BSSID_CAM_SEL,
+	BA_CAM_SEL,
+	BCN_IE_CAM0_SEL,
+	SHARED_BUF_SEL,
+	DMAC_TBL_SEL,
+	SHCUT_MACHDR_SEL,
+	BCN_IE_CAM1_SEL,
+	WD_PAGE_SEL,
+};
+
+/**
+ * @struct mac_ax_fwdbgreg_offset
+ * @brief mac_ax_fwdbgreg_offset
+ *
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_SIGNATURE
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_SEQNUM
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_FWERR_IDX
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_FWERR_0
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_FWERR_1
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_FWERR_2
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_FWERR_3
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_FWERR_NOW_0
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_FWERR_NOW_1
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_FWERR_NOW_2
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_FWERR_NOW_3
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_L2_HALTINFO
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_L2_ERRADDR
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_FWDBGREG_L2_EPC
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_BKP_STR
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_BKP_DONE
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_RES_STR_WTM
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_RES_MAC_STR_WTM
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_RES_BB_STR_WTM
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_RES_RF_STR_WTM
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_RES_DONE_WTM
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_RES_DONE
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_COMMON_BCNEARLY
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_OPEN_RF_STR
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_OPEN_RF_DONE
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_TBTT
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_BCN_NO_HIT
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_COMMON_BCN_CNT
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_BCN_TO_CNT
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_SLEEP_STATUS
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_SLEEP_ERROR
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_SLEEP_INFO
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_OS_EXPECTED_IDLE_TIME
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_OS_BEFORE_SLEEP_TIME
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_OS_AFTER_SLEEP_TIME
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_OS_COMPLETE_TIME
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_WTM_SC
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_WTM_CNT
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_WLAN_ERR_ERR_REC
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_TWT_ERR_ERR_REC
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_MPORT_ERR_REC
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_LPS_RF_BBRST_DBG_CNT
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_WOW_CONFIG_INFO
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_WOW_COMMON_DBG_INFO
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_WOW_RX_WAKE_INFO
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_WOW_AOAC_INFO
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_WOW_RX_CNT_INFO
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_WOW_RX_CNT_INFO_1
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_WOW_RX_CNT_INFO_2
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_DBGPKT_FAIL_INFO_1
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_DBGPKT_FAIL_INFO_2
+ * Please Place Description here.
+ * @var mac_ax_fwdbgreg_offset::R_TWT_TASK_CNT
+ * Please Place Description here.
+ */
+enum mac_ax_fwdbgreg_offset {
+	R_FWDBGREG_SIGNATURE        = 0x00,
+	R_FWDBGREG_SEQNUM           = 0x04,
+	//                            = 0x08
+	R_FWDBGREG_FWERR_IDX        = 0x0C,
+	R_FWDBGREG_FWERR_0          = 0x10,
+	R_FWDBGREG_FWERR_1          = 0x14,
+	R_FWDBGREG_FWERR_2          = 0x18,
+	R_FWDBGREG_FWERR_3          = 0x1C,
+	R_FWDBGREG_FWERR_NOW_0      = 0x20,
+	R_FWDBGREG_FWERR_NOW_1      = 0x24,
+	R_FWDBGREG_FWERR_NOW_2      = 0x28,
+	R_FWDBGREG_FWERR_NOW_3      = 0x2C,
+	R_FWDBGREG_L2_HALTINFO      = 0x30,
+	R_FWDBGREG_L2_ERRADDR       = 0x34,
+	R_FWDBGREG_L2_EPC           = 0x38,
+	//R_RSVD                      = 0x3C,
+	R_LPS_BKP_STR               = 0x40,
+	R_LPS_BKP_DONE              = 0x44,
+	R_LPS_RES_STR_WTM           = 0x48,
+	R_LPS_RES_MAC_STR_WTM       = 0x4C,
+	R_LPS_RES_BB_STR_WTM        = 0x50,
+	R_LPS_RES_RF_STR_WTM        = 0x54,
+	R_LPS_RES_DONE_WTM          = 0x58,
+	R_LPS_RES_DONE              = 0x5C,
+	R_COMMON_BCNEARLY           = 0x60,
+	R_LPS_OPEN_RF_STR           = 0x64,
+	R_LPS_OPEN_RF_DONE          = 0x68,
+	R_LPS_TBTT                  = 0x6C,
+	R_LPS_BCN_NO_HIT            = 0x70,
+	R_LPS_RX_BCN                = 0x74,
+	R_LPS_CLOSE_RF_STR          = 0x78,
+	R_LPS_CLOSE_RF_DONE         = 0x7C,
+	R_LPS_TIME_END              = 0x80,
+	R_LPS_BCN_NO_HIT_CNT        = 0x84,
+	R_COMMON_BCN_CNT            = 0x88,
+	R_LPS_BCN_TO_CNT            = 0x8C,
+	R_LPS_SLEEP_STATUS          = 0x90,
+	R_LPS_SLEEP_ERROR           = 0x94,
+	R_LPS_SLEEP_INFO            = 0x98,
+	//R_RSVD                      = 0x9C,
+	R_OS_EXPECTED_IDLE_TIME     = 0xA0,
+	R_OS_BEFORE_SLEEP_TIME      = 0xA4,
+	R_OS_AFTER_SLEEP_TIME       = 0xA8,
+	R_OS_COMPLETE_TIME          = 0xAC,
+	R_LPS_WTM_SC                = 0xB0,
+	R_LPS_WTM_CNT               = 0xB4,
+	R_IPS_PTCL_DBG              = 0xB8,
+	//R_RSVD                      = 0xBC,
+	R_WLAN_ERR_ERR_REC          = 0xC0,
+	R_TWT_ERR_ERR_REC           = 0xC4,
+	R_MPORT_ERR_REC             = 0xC8,
+	R_LPS_RF_BBRST_DBG_CNT      = 0xCC,
+	R_WOW_CONFIG_INFO           = 0xD0,
+	R_WOW_COMMON_DBG_INFO       = 0xD4,
+	R_WOW_RX_WAKE_INFO          = 0xD8,
+	R_WOW_AOAC_INFO             = 0xDC,
+	//R_RSVD                      = 0xE0,
+	R_WOW_RX_CNT_INFO           = 0xE4,
+	R_WOW_RX_CNT_INFO_1         = 0xE8,
+	R_WOW_RX_CNT_INFO_2         = 0xEC,
+	R_DBGPKT_FAIL_INFO_1        = 0xF0,
+	R_DBGPKT_FAIL_INFO_2        = 0xF4,
+	R_TWT_TASK_CNT              = 0xF8,
+	R_WOW_COMMON_DBG_INFO_2     = 0xFC,
+	R_EXCEPTION_RA0             = 0x100,
+	R_EXCEPTION_RA1             = 0x104,
+	R_EXCEPTION_RA2             = 0x108,
+	R_EXCEPTION_RA3             = 0x10C,
+	R_EXCEPTION_RA4             = 0x110,
+	R_EXCEPTION_RA5             = 0x114,
+	R_EXCEPTION_RA6             = 0x118,
+	R_FWERROR_LAST
+};
+
+/**
+ * @enum mac_ax_dle_dfi_sel
+ *
+ * @brief mac_ax_dle_dfi_sel
+ *
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_FREEPG
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_QUOTA
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_PAGELLT
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_PKTINFO
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_PREPKT
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_NXTPKT
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_QLNKTBL
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_QEMPTY
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_FREEPG
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_QUOTA
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_PAGELLT
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_PKTINFO
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_PREPKT
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_NXTPKT
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_QLNKTBL
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_QEMPTY
+ * Please Place Description here.
+ */
+enum mac_ax_dle_dfi_sel {
+	MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_FREEPG = 0,
+	MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_QUOTA,
+	MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_PAGELLT,
+	MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_PKTINFO,
+	MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_PREPKT,
+	MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_NXTPKT,
+	MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_QLNKTBL,
+	MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_QEMPTY,
+	MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_FREEPG,
+	MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_QUOTA,
+	MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_PAGELLT,
+	MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_PKTINFO,
+	MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_PREPKT,
+	MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_NXTPKT,
+	MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_QLNKTBL,
+	MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_QEMPTY,
+
+	/* keep last */
+	MAC_AX_DLE_DFI_SEL_LAST,
+	MAC_AX_DLE_DFI_SEL_MAX = MAC_AX_DLE_DFI_SEL_LAST,
+	MAC_AX_DLE_DFI_SEL_INVALID = MAC_AX_DLE_DFI_SEL_LAST,
+};
+
+/**
+ * @struct mac_ax_dle_dfi_info
+ * @brief mac_ax_dle_dfi_info
+ *
+ * @var mac_ax_dle_dfi_info::srt
+ * Please Place Description here.
+ * @var mac_ax_dle_dfi_info::end
+ * Please Place Description here.
+ * @var mac_ax_dle_dfi_info::inc_num
+ * Please Place Description here.
+ */
+struct mac_ax_dle_dfi_info {
+	u32 srt;
+	u32 end;
+	u32 inc_num;
+};
+
+/**
+ * @enum mac_ax_dbg_port_sel
+ *
+ * @brief mac_ax_dbg_port_sel
+ *
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PTCL_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_SCH_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TMAC_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_RMAC_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_RMACST_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_RMAC_PLCP_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TRXPTCL_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TX_INFOL_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TX_INFOH_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TXTF_INFOL_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TXTF_INFOH_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_CMAC_DMA0_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_CMAC_DMA1_C0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PTCL_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_SCH_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TMAC_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_RMAC_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_RMACST_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_RMAC_PLCP_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TRXPTCL_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TX_INFOL_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TX_INFOH_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TXTF_INFOL_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TXTF_INFOH_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_CMAC_DMA0_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_CMAC_DMA1_C1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PKTINFO
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TXPKT_CTRL0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TXPKT_CTRL1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TXPKT_CTRL2
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TXPKT_CTRL3
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_TXPKT_CTRL4
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_TXDMA
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_RXDMA
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_CVT
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_EMAC04
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_EMAC5
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_EMAC6
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_EMAC7
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_PNP_IO
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_EMAC814
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_EMAC15
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_EMAC16
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_EMAC17
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_PCIE_EMAC18
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB2_PHY
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB2_SIE
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB2_UTMI
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB2_SIE_MMU
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB2_SIE_PCE
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB2_UTMI_IF
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB_WLTX
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB_WLRX
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB3
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB_SETUP
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB_WLTX_DMA
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB_WLRX_DMA
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB_AINST
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB_MISC
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB_BTTX
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_USB2_BT
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX2
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX3
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX4
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX5
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX6
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX7
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX8
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX9
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXA
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXB
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXC
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXD
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX3
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX4
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX5
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX6
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX7
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX8
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX9
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX2
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX3
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P1
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_STF_CTRL
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_ADDR_CTRL
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_WDE_INTF
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_PLE_INTF
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_DSPT_FLOW_CTRL
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_AXI_TXDMA_CTRL
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_AXI_RXDMA_CTRL
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_AXI_MST_WLAN
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_AXI_INT_WLAN
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_AXI_PAGE_FLOW_CTRL
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_LAST
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_MAX
+ * Please Place Description here.
+ * @var mac_ax_dbg_port_sel::MAC_AX_DBG_PORT_SEL_INVALID
+ * Please Place Description here.
+ */
+enum mac_ax_dbg_port_sel {
+	/* CMAC 0 related */
+	MAC_AX_DBG_PORT_SEL_PTCL_C0 = 0,
+	MAC_AX_DBG_PORT_SEL_SCH_C0,
+	MAC_AX_DBG_PORT_SEL_TMAC_C0,
+	MAC_AX_DBG_PORT_SEL_RMAC_C0,
+	MAC_AX_DBG_PORT_SEL_RMACST_C0,
+	MAC_AX_DBG_PORT_SEL_RMAC_PLCP_C0,
+	MAC_AX_DBG_PORT_SEL_TRXPTCL_C0,
+	MAC_AX_DBG_PORT_SEL_TX_INFOL_C0,
+	MAC_AX_DBG_PORT_SEL_TX_INFOH_C0,
+	MAC_AX_DBG_PORT_SEL_TXTF_INFOL_C0,
+	MAC_AX_DBG_PORT_SEL_TXTF_INFOH_C0,
+	MAC_AX_DBG_PORT_SEL_CMAC_DMA0_C0,
+	MAC_AX_DBG_PORT_SEL_CMAC_DMA1_C0,
+	MAC_AX_DBG_PORT_SEL_CMAC_DMA2_C0,
+	/* CMAC 1 related */
+	MAC_AX_DBG_PORT_SEL_PTCL_C1,
+	MAC_AX_DBG_PORT_SEL_SCH_C1,
+	MAC_AX_DBG_PORT_SEL_TMAC_C1,
+	MAC_AX_DBG_PORT_SEL_RMAC_C1,
+	MAC_AX_DBG_PORT_SEL_RMACST_C1,
+	MAC_AX_DBG_PORT_SEL_RMAC_PLCP_C1,
+	MAC_AX_DBG_PORT_SEL_TRXPTCL_C1,
+	MAC_AX_DBG_PORT_SEL_TX_INFOL_C1,
+	MAC_AX_DBG_PORT_SEL_TX_INFOH_C1,
+	MAC_AX_DBG_PORT_SEL_TXTF_INFOL_C1,
+	MAC_AX_DBG_PORT_SEL_TXTF_INFOH_C1,
+	MAC_AX_DBG_PORT_SEL_CMAC_DMA0_C1,
+	MAC_AX_DBG_PORT_SEL_CMAC_DMA1_C1,
+	MAC_AX_DBG_PORT_SEL_CMAC_DMA2_C1,
+	/* DLE related */
+	MAC_AX_DBG_PORT_SEL_WDE_BUFMGN_CTL,
+	MAC_AX_DBG_PORT_SEL_WDE_BUFMGN_ARB,
+	MAC_AX_DBG_PORT_SEL_WDE_QUEMGN_CTL,
+	MAC_AX_DBG_PORT_SEL_WDE_QUEMGN_INFO,
+	MAC_AX_DBG_PORT_SEL_WDE_QUEMGN_ARB,
+	MAC_AX_DBG_PORT_SEL_WDE_PORT0,
+	MAC_AX_DBG_PORT_SEL_WDE_PORT1,
+	MAC_AX_DBG_PORT_SEL_WDE_PORT3,
+	MAC_AX_DBG_PORT_SEL_WDE_PORT4,
+	MAC_AX_DBG_PORT_SEL_WDE_PORT6,
+	MAC_AX_DBG_PORT_SEL_WDE_PORT7,
+	MAC_AX_DBG_PORT_SEL_PLE_BUFMGN_CTL,
+	MAC_AX_DBG_PORT_SEL_PLE_BUFMGN_ARB,
+	MAC_AX_DBG_PORT_SEL_PLE_QUEMGN_CTL,
+	MAC_AX_DBG_PORT_SEL_PLE_QUEMGN_INFO,
+	MAC_AX_DBG_PORT_SEL_PLE_QUEMGN_ARB,
+	MAC_AX_DBG_PORT_SEL_PLE_PORT0,
+	MAC_AX_DBG_PORT_SEL_PLE_PORT1,
+	MAC_AX_DBG_PORT_SEL_PLE_PORT2,
+	MAC_AX_DBG_PORT_SEL_PLE_PORT2_1,
+	MAC_AX_DBG_PORT_SEL_PLE_PORT3,
+	MAC_AX_DBG_PORT_SEL_PLE_PORT4,
+	MAC_AX_DBG_PORT_SEL_PLE_PORT5,
+	MAC_AX_DBG_PORT_SEL_PLE_PORT6,
+	/* WDRLS related */
+	MAC_AX_DBG_PORT_SEL_WDRLS_CTL,
+	MAC_AX_DBG_PORT_SEL_WDRLS_RPTGEN0,
+	MAC_AX_DBG_PORT_SEL_WDRLS_RPTGEN1,
+	MAC_AX_DBG_PORT_SEL_WDRLS_PLED_CH0,
+	MAC_AX_DBG_PORT_SEL_WDRLS_PLED_CH1,
+	/* TXPKT_CTRL related */
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_FETPKT,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_CMDPSR,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_CMACDMAIF,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_PRELD0,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_PRELD1,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT0_0,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT0_1,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT1_0,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT1_1,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT2_0,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT2_1,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT3_0,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT3_1,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT4_0,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT4_1,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT5_0,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT5_1,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT6_0,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT6_1,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT7_0,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT7_1,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B1_CMDPSR,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B1_CMACDMAIF,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B1_UNIT0_0,
+	MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B1_UNIT0_1,
+	MAC_AX_DBG_PORT_SEL_PKTINFO,
+	MAC_AX_DBG_PORT_SEL_MPDUINFO_B0,
+	MAC_AX_DBG_PORT_SEL_MPDUINFO_B1,
+	MAC_AX_DBG_PORT_SEL_PRELD_B0,
+	MAC_AX_DBG_PORT_SEL_PRELD_B1,
+	/* PCIE related */
+	MAC_AX_DBG_PORT_SEL_PCIE_TXDMA,
+	MAC_AX_DBG_PORT_SEL_PCIE_RXDMA,
+	MAC_AX_DBG_PORT_SEL_PCIE_CVT,
+	MAC_AX_DBG_PORT_SEL_PCIE_EMAC04,
+	MAC_AX_DBG_PORT_SEL_PCIE_EMAC5,
+	MAC_AX_DBG_PORT_SEL_PCIE_EMAC6,
+	MAC_AX_DBG_PORT_SEL_PCIE_EMAC7,
+	MAC_AX_DBG_PORT_SEL_PCIE_PNP_IO,
+	MAC_AX_DBG_PORT_SEL_PCIE_EMAC814,
+	MAC_AX_DBG_PORT_SEL_PCIE_EMAC15,
+	MAC_AX_DBG_PORT_SEL_PCIE_EMAC16,
+	MAC_AX_DBG_PORT_SEL_PCIE_EMAC17,
+	MAC_AX_DBG_PORT_SEL_PCIE_EMAC18,
+	/* USB related */
+	MAC_AX_DBG_PORT_SEL_USB2_PHY,
+	MAC_AX_DBG_PORT_SEL_USB2_SIE,
+	MAC_AX_DBG_PORT_SEL_USB2_UTMI,
+	MAC_AX_DBG_PORT_SEL_USB2_SIE_MMU,
+	MAC_AX_DBG_PORT_SEL_USB2_SIE_PCE,
+	MAC_AX_DBG_PORT_SEL_USB2_UTMI_IF,
+	MAC_AX_DBG_PORT_SEL_USB_WLTX,
+	MAC_AX_DBG_PORT_SEL_USB_WLRX,
+	MAC_AX_DBG_PORT_SEL_USB3,
+	MAC_AX_DBG_PORT_SEL_USB_SETUP,
+	MAC_AX_DBG_PORT_SEL_USB_WLTX_DMA,
+	MAC_AX_DBG_PORT_SEL_USB_WLRX_DMA,
+	MAC_AX_DBG_PORT_SEL_USB_AINST,
+	MAC_AX_DBG_PORT_SEL_USB_MISC,
+	MAC_AX_DBG_PORT_SEL_USB_BTTX,
+	MAC_AX_DBG_PORT_SEL_USB2_BT,
+	/* DISPATCHER related */
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX0,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX1,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX2,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX3,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX4,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX5,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX6,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX7,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX8,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX9,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXA,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXB,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXC,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXD,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXE,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXF,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX0,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX1,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX3,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX4,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX5,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX6,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX7,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX8,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX9,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_TXA,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_TXB,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_TXC,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX0,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX1,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX2,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX3,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX4,
+	MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX5,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0_0,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0_1,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0_2,
+	MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P1,
+	MAC_AX_DBG_PORT_SEL_DSPT_STF_CTRL,
+	MAC_AX_DBG_PORT_SEL_DSPT_ADDR_CTRL,
+	MAC_AX_DBG_PORT_SEL_DSPT_WDE_INTF,
+	MAC_AX_DBG_PORT_SEL_DSPT_PLE_INTF,
+	MAC_AX_DBG_PORT_SEL_DSPT_FLOW_CTRL,
+	/*AXIDMAC related*/
+	MAC_AX_DBG_PORT_SEL_AXI_TXDMA_CTRL,
+	MAC_AX_DBG_PORT_SEL_AXI_RXDMA_CTRL,
+	MAC_AX_DBG_PORT_SEL_AXI_MST_WLAN,
+	MAC_AX_DBG_PORT_SEL_AXI_INT_WLAN,
+	MAC_AX_DBG_PORT_SEL_AXI_PAGE_FLOW_CTRL,
+	/*PAXIDMA related*/
+	MAC_AX_DBG_PORT_SEL_PAXI_TXDMA,
+	MAC_AX_DBG_PORT_SEL_PAXI_RXDMA,
+	MAC_AX_DBG_PORT_SEL_PAXI_MST,
+	MAC_AX_DBG_PORT_SEL_PAXI_INT,
+	/*HAXIDMA related*/
+	MAC_AX_DBG_PORT_SEL_HAXI_TXDMA,
+	MAC_AX_DBG_PORT_SEL_HAXI_RXDMA,
+	MAC_AX_DBG_PORT_SEL_HAXI_MST,
+	MAC_AX_DBG_PORT_SEL_HAXI_INT,
+	/*STA shceduler related*/
+	MAC_AX_DBG_PORT_SEL_STA_SCH,
+
+	/* keep last */
+	MAC_AX_DBG_PORT_SEL_LAST,
+	MAC_AX_DBG_PORT_SEL_MAX = MAC_AX_DBG_PORT_SEL_LAST,
+	MAC_AX_DBG_PORT_SEL_INVALID = MAC_AX_DBG_PORT_SEL_LAST,
+};
+
+struct ss_link_info {
+	u8 wmm;
+	u8 ac;
+	u8 ul;
+};
+
+/**
+ * @struct iecam_cfg_info
+ * @brief iecam_cfg_info
+ *
+ * @var iecam_cfg_info::camctrl_bkp
+ * Please Place Description here.
+ * @var iecam_cfg_info::ioctrl_bkp
+ * Please Place Description here.
+ * @var iecam_cfg_info::rbp_bkp
+ * Please Place Description here.
+ */
+struct iecam_cfg_info {
+	u16 camctrl_bkp;
+	u16 ioctrl_bkp;
+	u32 rbp_bkp;
+};
+
+struct fw_backtrace_info {
+	u32 ra;
+	u32 sp;
+};
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief mac_fwcmd_lb
+ *
+ * @param *adapter
+ * @param len
+ * @param burst
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_fwcmd_lb(struct mac_ax_adapter *adapter, u32 len, u8 burst);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief c2h_sys_cmd_path
+ *
+ * @param *adapter
+ * @param *buf
+ * @param len
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 c2h_sys_cmd_path(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		     struct rtw_c2h_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief c2h_sys_plat_autotest
+ *
+ * @param *adapter
+ * @param *buf
+ * @param len
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 c2h_sys_plat_autotest(struct mac_ax_adapter *adapter,  u8 *buf, u32 len,
+			  struct rtw_c2h_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief iecam_aces_cfg
+ *
+ * @param *adapter
+ * @param band
+ * @param en
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 iecam_aces_cfg(struct mac_ax_adapter *adapter, u8 band, u8 en,
+		   struct iecam_cfg_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief mac_mem_dump
+ *
+ * @param *adapter
+ * @param sel
+ * @param strt_addr
+ * @param *buf
+ * @param len
+ * @param dbg_path
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_mem_dump(struct mac_ax_adapter *adapter, enum mac_ax_mem_sel sel,
+		 u32 strt_addr, u8 *buf, u32 len, u32 dbg_path);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief mac_get_mem_size
+ *
+ * @param *adapter
+ * @param sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_mem_size(struct mac_ax_adapter *adapter, enum mac_ax_mem_sel sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief mac_reg_dump
+ *
+ * @param *adapter
+ * @param sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_reg_dump(struct mac_ax_adapter *adapter, enum mac_ax_reg_sel sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief mac_dbg_status_dump
+ *
+ * @param *adapter
+ * @param *val
+ * @param *en
+ * @return Please Place Description here.
+ * @retval void
+ */
+void mac_dbg_status_dump(struct mac_ax_adapter *adapter,
+			 struct mac_ax_dbgpkg *val,
+			 struct mac_ax_dbgpkg_en *en);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief mac_sram_dbg_write
+ *
+ * @param *adapter
+ * @param offset
+ * @param val
+ * @param sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_sram_dbg_write(struct mac_ax_adapter *adapter, u32 offset,
+		       u32 val, enum mac_ax_sram_dbg_sel sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief mac_sram_dbg_read
+ *
+ * @param *adapter
+ * @param offset
+ * @param sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_sram_dbg_read(struct mac_ax_adapter *adapter, u32 offset,
+		      enum mac_ax_sram_dbg_sel sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief mac_rx_cnt
+ *
+ * @param *adapter
+ * @param *rxcnt
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_rx_cnt(struct mac_ax_adapter *adapter,
+	       struct mac_ax_rx_cnt *rxcnt);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief mac_dump_fw_rsvd_ple
+ *
+ * @param *adapter
+ * @param **buf
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dump_fw_rsvd_ple(struct mac_ax_adapter *adapter, u8 **buf);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_dump_ple_dbg_page
+ *
+ * @param *adapter
+ * @param page_num
+ * @return Please Place Description here.
+ * @retval void
+ */
+void mac_dump_ple_dbg_page(struct mac_ax_adapter *adapter, u8 page_num);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief mac_fw_dbg_dump
+ *
+ * @param *adapter
+ * @param **buf
+ * @param *en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_fw_dbg_dump(struct mac_ax_adapter *adapter,
+		    u8 **buf,
+		    struct mac_ax_fwdbg_en *en);
+/**
+ * @}
+ * @}
+ */
+u32 fw_st_dbg_dump(struct mac_ax_adapter *adapter);
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief mac_event_notify
+ * for Sta mode debug usage
+ * @param *adapter
+ * @param **buf
+ * @param *en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_event_notify(struct mac_ax_adapter *adapter, enum phl_msg_evt_id id,
+		     u8 band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+
+/**
+ * @brief mac_fwdbg_lock
+ * lock or unlock fwdbgreg
+ * @param *adapter
+ * @param lock
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_fw_dbg_dle_cfg(struct mac_ax_adapter *adapter, bool lock);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief pltfm_dbg_dump
+ * dump cpu platform for dbg
+ * @param *adapter
+ */
+void pltfm_dbg_dump(struct mac_ax_adapter *adapter);
+
+/**
+ * @}
+ * @}
+ */
+/**
+ * @brief mac_get_fw_status
+ * get fw status
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_get_fw_status(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief dbg_port_dump
+ * get mac debug port dump
+ * @param *adapter
+ * @param *sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dbg_port_dump(struct mac_ax_adapter *adapter, u32 sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief tx_cnt_dump
+ * get mac tx status dump
+ * @param *adapter
+ * @param *band
+ * @param *loop_num
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 tx_cnt_dump(struct mac_ax_adapter *adapter, u8 band, u32 loop_num);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief rx_cnt_dump
+ * get mac rx status dump
+ * @param *adapter
+ * @param *band
+ * @param *loop_num
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 rx_cnt_dump(struct mac_ax_adapter *adapter, u8 band, u32 loop_num);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief dle_dbg_dump
+ * get mac dle dbg dump
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dle_dbg_dump(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief chk_dle_dfi_valid
+ * check dle dfi status
+ * @param *adapter
+ * @param *dbg_sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u8 chk_dle_dfi_valid(struct mac_ax_adapter *adapter, u32 dbg_sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief dle_dfi_dump
+ * mac dle dfi status
+ * @param *adapter
+ * @param *dbg_sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dle_dfi_dump(struct mac_ax_adapter *adapter, u32 sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief rsvd_ple_dump
+ * mac rsvd ple dump
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 rsvd_ple_dump(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief ss_dbgpkg
+ * mac station scheduler dbg
+ * @param *adapter
+ * @param *mac_ax_dbgpkg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ss_dbgpkg(struct mac_ax_adapter *adapter, struct mac_ax_dbgpkg *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_tx_flow_dbg
+ * mac tx flow debug
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_tx_flow_dbg(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief print_dbg_port
+ * print_dbg_port
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+void print_dbg_port(struct mac_ax_adapter *adapter,
+		    struct mac_ax_dbg_port_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DebugPackage
+ * @{
+ */
+/**
+ * @brief mac_get_ple_dbg_addr
+ * print_dbg_port
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_ple_dbg_addr(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief fw_pc_dbg_dump_ax
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 fw_pc_dbg_dump_ax(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgport_hw.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgport_hw.c
new file mode 100644
index 000000000000..fd4f983571f9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgport_hw.c
@@ -0,0 +1,945 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "dbgpkg.h"
+#include "dbgport_hw.h"
+
+static u32 dp_intn_idx_set(struct mac_ax_adapter *adapter,
+			   struct mac_ax_dbgport_hw *dp_hw, u8 sel_idx)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, intn_val;
+	u16 val16;
+	u8 dbg_sel, intn_idx;
+
+	dbg_sel = dp_hw->dbg_sel[sel_idx];
+	intn_idx = dp_hw->intn_idx[sel_idx];
+
+	switch (dbg_sel) {
+	case MAC_AX_DP_SEL_SYS_0:
+	case MAC_AX_DP_SEL_SYS_1F:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_PINMUX_0:
+	case MAC_AX_DP_SEL_PINMUX_7:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_LOADER_0:
+	case MAC_AX_DP_SEL_LOADER_3:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_HMUX_0:
+	case MAC_AX_DP_SEL_HMUX_3:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_PCIE_0:
+		switch (intn_idx) {
+		case MAC_AX_DP_INTN_IDX_PCIE_0_0:
+		case MAC_AX_DP_INTN_IDX_PCIE_0_1:
+		case MAC_AX_DP_INTN_IDX_PCIE_0_2:
+		case MAC_AX_DP_INTN_IDX_PCIE_0_3:
+			break;
+		default:
+			return MACNOITEM;
+		}
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			val32 = MAC_REG_R32(R_AX_PCIE_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, intn_idx, B_AX_DBG_SEL);
+			MAC_REG_W32(R_AX_PCIE_DBG_CTRL, val32);
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			val32 = MAC_REG_R32(R_AX_HAXI_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, intn_idx, B_AX_DBG_SEL);
+			MAC_REG_W32(R_AX_HAXI_DBG_CTRL, val32);
+		}
+#endif
+		break;
+	case MAC_AX_DP_SEL_PCIE_1:
+		switch (intn_idx) {
+		case MAC_AX_DP_INTN_IDX_PCIE_1_0:
+		case MAC_AX_DP_INTN_IDX_PCIE_1_1:
+		case MAC_AX_DP_INTN_IDX_PCIE_1_2:
+		case MAC_AX_DP_INTN_IDX_PCIE_1_3:
+		case MAC_AX_DP_INTN_IDX_PCIE_1_4:
+			break;
+		default:
+			return MACNOITEM;
+		}
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			val32 = MAC_REG_R32(R_AX_PCIE_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, intn_idx, B_AX_DBG_SEL);
+			MAC_REG_W32(R_AX_PCIE_DBG_CTRL, val32);
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			val32 = MAC_REG_R32(R_AX_HAXI_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, intn_idx, B_AX_DBG_SEL);
+			MAC_REG_W32(R_AX_HAXI_DBG_CTRL, val32);
+		}
+#endif
+		break;
+	case MAC_AX_DP_SEL_PCIE_2:
+		switch (intn_idx) {
+		case MAC_AX_DP_INTN_IDX_PCIE_2_0:
+		case MAC_AX_DP_INTN_IDX_PCIE_2_1:
+			break;
+		default:
+			return MACNOITEM;
+		}
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			val32 = MAC_REG_R32(R_AX_PCIE_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, intn_idx, B_AX_DBG_SEL);
+			MAC_REG_W32(R_AX_PCIE_DBG_CTRL, val32);
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			val32 = MAC_REG_R32(R_AX_HAXI_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, intn_idx, B_AX_DBG_SEL);
+			MAC_REG_W32(R_AX_HAXI_DBG_CTRL, val32);
+		}
+#endif
+		break;
+	case MAC_AX_DP_SEL_PCIE_3:
+		switch (intn_idx) {
+		case MAC_AX_DP_INTN_IDX_PCIE_3_0:
+		case MAC_AX_DP_INTN_IDX_PCIE_3_1:
+		case MAC_AX_DP_INTN_IDX_PCIE_3_2:
+		case MAC_AX_DP_INTN_IDX_PCIE_3_3:
+		case MAC_AX_DP_INTN_IDX_PCIE_3_4:
+		case MAC_AX_DP_INTN_IDX_PCIE_3_5:
+			break;
+		default:
+			return MACNOITEM;
+		}
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			val32 = MAC_REG_R32(R_AX_PCIE_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, intn_idx, B_AX_DBG_SEL);
+			MAC_REG_W32(R_AX_PCIE_DBG_CTRL, val32);
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			val32 = MAC_REG_R32(R_AX_HAXI_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, intn_idx, B_AX_DBG_SEL);
+			MAC_REG_W32(R_AX_HAXI_DBG_CTRL, val32);
+		}
+#endif
+		break;
+	case MAC_AX_DP_SEL_PCIE_4:
+	case MAC_AX_DP_SEL_PCIE_5:
+	case MAC_AX_DP_SEL_PCIE_6:
+		// don't have internal setting
+		break;
+	case MAC_AX_DP_SEL_PCIE_7:
+		switch (intn_idx) {
+		case MAC_AX_DP_INTN_IDX_PCIE_7_0:
+			intn_val = 0x0;
+			break;
+		case MAC_AX_DP_INTN_IDX_PCIE_7_1:
+			intn_val = 0x4;
+			break;
+		case MAC_AX_DP_INTN_IDX_PCIE_7_2:
+			intn_val = 0x1;
+			break;
+		case MAC_AX_DP_INTN_IDX_PCIE_7_3:
+			intn_val = 0x5;
+			break;
+		case MAC_AX_DP_INTN_IDX_PCIE_7_4:
+			intn_val = 0x2;
+			break;
+		default:
+			return MACNOITEM;
+		}
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			val32 = MAC_REG_R32(R_AX_PCIE_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, intn_val, B_AX_DBG_SEL);
+			MAC_REG_W32(R_AX_PCIE_DBG_CTRL, val32);
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			val32 = MAC_REG_R32(R_AX_HAXI_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, intn_val, B_AX_DBG_SEL);
+			MAC_REG_W32(R_AX_HAXI_DBG_CTRL, val32);
+		}
+#endif
+		break;
+	case MAC_AX_DP_SEL_PCIE_8:
+		switch (intn_idx) {
+		case MAC_AX_DP_INTN_IDX_PCIE_8_0:
+		case MAC_AX_DP_INTN_IDX_PCIE_8_1:
+		case MAC_AX_DP_INTN_IDX_PCIE_8_2:
+		case MAC_AX_DP_INTN_IDX_PCIE_8_3:
+		case MAC_AX_DP_INTN_IDX_PCIE_8_4:
+		case MAC_AX_DP_INTN_IDX_PCIE_8_5:
+		case MAC_AX_DP_INTN_IDX_PCIE_8_6:
+			break;
+		default:
+			return MACNOITEM;
+		}
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			val32 = MAC_REG_R32(R_AX_PCIE_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, intn_idx, B_AX_DBG_SEL);
+			MAC_REG_W32(R_AX_PCIE_DBG_CTRL, val32);
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			val32 = MAC_REG_R32(R_AX_HAXI_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, intn_idx, B_AX_DBG_SEL);
+			MAC_REG_W32(R_AX_HAXI_DBG_CTRL, val32);
+		}
+#endif
+		break;
+	case MAC_AX_DP_SEL_PCIE_9:
+	case MAC_AX_DP_SEL_PCIE_A:
+	case MAC_AX_DP_SEL_PCIE_B:
+	case MAC_AX_DP_SEL_PCIE_C:
+		// don't have internal setting
+		break;
+	case MAC_AX_DP_SEL_PCIE_D:
+	case MAC_AX_DP_SEL_PCIE_E:
+	case MAC_AX_DP_SEL_PCIE_F:
+		// don't have this item
+		return MACNOITEM;
+	case MAC_AX_DP_SEL_USB_0:
+	case MAC_AX_DP_SEL_USB_F:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_SDIO_0:
+	case MAC_AX_DP_SEL_SDIO_F:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_BT:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_AXIDMA:
+		switch (intn_idx) {
+		case MAC_AX_DP_INTN_IDX_AXIDMA_0:
+			intn_val = (0x0 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x0 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x0 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_1:
+			intn_val = (0x1 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x1 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x0 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_2:
+			intn_val = (0x2 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x2 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x0 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_3:
+			intn_val = (0x3 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x3 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x0 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_4:
+			intn_val = (0x0 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x0 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x1 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_5:
+			intn_val = (0x1 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x1 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x1 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_6:
+			intn_val = (0x2 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x2 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x1 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_7:
+			intn_val = (0x3 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x3 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x1 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_8:
+			intn_val = (0x4 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x4 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x1 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_9:
+			intn_val = (0x5 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x5 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x1 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_A:
+			intn_val = (0x6 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x6 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x1 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_B:
+			intn_val = (0x0 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x0 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x2 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_C:
+			intn_val = (0x0 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x0 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x3 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		case MAC_AX_DP_INTN_IDX_AXIDMA_D:
+			intn_val = (0x0 << AXIDMA_DBG_SEL_INTN0_SH) |
+				   (0x0 << AXIDMA_DBG_SEL_INTN1_SH) |
+				   (0x4 << AXIDMA_DBG_SEL_INTN2_SH);
+			break;
+		default:
+			return MACNOITEM;
+		}
+		MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, AXIDMA_BASE_ADDR);
+		val32 = MAC_REG_R32(R_AX_INDIR_ACCESS_ENTRY + R_PL_AXIDMA_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, intn_val, B_PL_AXIDMA_DBG_SEL);
+		MAC_REG_W32(R_AX_INDIR_ACCESS_ENTRY + R_PL_AXIDMA_DBG_CTRL, val32);
+		break;
+	case MAC_AX_DP_SEL_WLPHYDBG_GPIO:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_BTCOEXIST:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_LTECOEX:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_WLPHYDBG:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_WLAN_MAC_REG:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_WLAN_MAC_PMC:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CALIB_TOP:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_DISPATCHER_TOP:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_WDE_DLE:
+		switch (intn_idx) {
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_0:
+			intn_val = 0x0;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_1:
+			intn_val = 0x1;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_2:
+			intn_val = 0xE;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_3:
+			intn_val = 0x10;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_4:
+			intn_val = 0x11;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_5:
+			intn_val = 0x14;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_6:
+			intn_val = 0x1E;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_7:
+			intn_val = 0x80;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_8:
+			intn_val = 0x81;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_9:
+			intn_val = 0x82;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_A:
+			intn_val = 0x90;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_B:
+			intn_val = 0x91;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_C:
+			intn_val = 0x92;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_D:
+			intn_val = 0xB0;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_E:
+			intn_val = 0xB1;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_F:
+			intn_val = 0xB2;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_10:
+			intn_val = 0xC0;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_11:
+			intn_val = 0xC1;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_12:
+			intn_val = 0xC2;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_13:
+			intn_val = 0xE0;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_14:
+			intn_val = 0xE1;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_15:
+			intn_val = 0xE2;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_16:
+			intn_val = 0xF0;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_17:
+			intn_val = 0xF1;
+			break;
+		case MAC_AX_DP_INTN_IDX_WDE_DLE_18:
+			intn_val = 0xF2;
+			break;
+		default:
+			return MACNOITEM;
+		}
+		val16 = MAC_REG_R16(R_AX_WDE_DBG_CTL);
+		val16 = SET_CLR_WORD(val16, intn_val, B_AX_WDE_DBG0_SEL);
+		val16 = SET_CLR_WORD(val16, intn_val, B_AX_WDE_DBG1_SEL);
+		MAC_REG_W16(R_AX_WDE_DBG_CTL, val16);
+		break;
+	case MAC_AX_DP_SEL_PLE_DLE:
+		switch (intn_idx) {
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_0:
+			intn_val = 0x0;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_1:
+			intn_val = 0x1;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_2:
+			intn_val = 0xE;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_3:
+			intn_val = 0x10;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_4:
+			intn_val = 0x11;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_5:
+			intn_val = 0x14;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_6:
+			intn_val = 0x1E;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_7:
+			intn_val = 0x80;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_8:
+			intn_val = 0x81;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_9:
+			intn_val = 0x82;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_A:
+			intn_val = 0x90;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_B:
+			intn_val = 0x91;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_C:
+			intn_val = 0x92;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_D:
+			intn_val = 0xA0;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_E:
+			intn_val = 0xA1;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_F:
+			intn_val = 0xA2;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_10:
+			intn_val = 0xB0;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_11:
+			intn_val = 0xB1;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_12:
+			intn_val = 0xB2;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_13:
+			intn_val = 0xC0;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_14:
+			intn_val = 0xC1;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_15:
+			intn_val = 0xC2;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_16:
+			intn_val = 0xD0;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_17:
+			intn_val = 0xD1;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_18:
+			intn_val = 0xD2;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_19:
+			intn_val = 0xE0;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_1A:
+			intn_val = 0xE1;
+			break;
+		case MAC_AX_DP_INTN_IDX_PLE_DLE_1B:
+			intn_val = 0xE2;
+			break;
+		default:
+			return MACNOITEM;
+		}
+		val16 = MAC_REG_R16(R_AX_PLE_DBG_CTL);
+		val16 = SET_CLR_WORD(val16, intn_val, B_AX_PLE_DBG0_SEL);
+		val16 = SET_CLR_WORD(val16, intn_val, B_AX_PLE_DBG1_SEL);
+		MAC_REG_W16(R_AX_PLE_DBG_CTL, val16);
+		break;
+	case MAC_AX_DP_SEL_WDRLS:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_DLE_CPUIO:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_BBRPT:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_TXPKTCTL:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_PKTBUFFER:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_DMAC_TABLE:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_STA_SCHEDULER:
+		val32 = MAC_REG_R32(R_AX_SS_DBG_0);
+		val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_LM_STAT);
+		val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_SA_STAT);
+		val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_PC_STAT);
+		val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_PARAM_STAT);
+		MAC_REG_W32(R_AX_SS_DBG_0, val32);
+
+		val32 = MAC_REG_R32(R_AX_SS_DBG_1);
+		val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_LEN_STAT);
+		val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_DLTX_STAT);
+		val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_ULRU_STAT);
+		val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_ADD_STAT);
+		val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_DEL_STAT);
+		MAC_REG_W32(R_AX_SS_DBG_1, val32);
+
+		val32 = MAC_REG_R32(R_AX_SS_DBG_2);
+		val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_FWTX_STAT);
+		val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_RPTA_STAT);
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_WDEA_STAT);
+			val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_PLEA_STAT);
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_WDEA_STAT_V1);
+			val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_PLEA_STAT_V1);
+		}
+#endif
+		MAC_REG_W32(R_AX_SS_DBG_2, val32);
+
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			val32 = MAC_REG_R32(R_AX_SS_MU_CTRL);
+			val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_DLMU_STATE);
+			val32 = SET_CLR_WORD(val32, 0x1, B_AX_SS_DLRU_STATE);
+			MAC_REG_W32(R_AX_SS_MU_CTRL, val32);
+		}
+#endif
+
+		switch (intn_idx) {
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_0:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_1:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_2:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_3:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_4:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_5:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_6:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_7:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_8:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_9:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_A:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_B:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_C:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_D:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_E:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_F:
+		case MAC_AX_DP_INTN_IDX_STA_SCHEDULER_10:
+			break;
+		default:
+			return MACNOITEM;
+		}
+		val32 = MAC_REG_R32(R_AX_SS_DBG_3);
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			val32 = SET_CLR_WORD(val32, intn_idx,
+					     B_AX_SS_TOP_DBG_SEL);
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			val32 = SET_CLR_WORD(val32, intn_idx,
+					     B_AX_SS_TOP_DBG_SEL_V1);
+		}
+#endif
+		MAC_REG_W32(R_AX_SS_DBG_3, val32);
+		break;
+	case MAC_AX_DP_SEL_DMAC_PKTIN:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_WSEC_TOP:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_MPDU_PROCESSOR:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_DMAC_APB_BRIDGE:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_LTR_CTRL:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC0_CMAC_DMAC_TOP:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC0_PTCLTOP:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC0_SCHEDULERTOP:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC0_TXPWR_CTRL:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC0_CMAC_APB_BRIDGE:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC0_MACTX:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC0_MACRX:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC0_WMAC_TRXPTCL:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC1_CMAC_DMAC_TOP:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC1_PTCLTOP:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC1_SCHEDULERTOP:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC1_TXPWR_CTRL:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC1_CMAC_APB_BRIDGE:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC1_MACTX:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC1_MACRX:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC1_WMAC_TRXPTCL:
+		/* To do... */
+		break;
+	case MAC_AX_DP_SEL_CMAC_SHARE:
+		/* To do... */
+		break;
+	/* WLAN_MAC */
+	case MAC_AX_DP_SEL_WL_CPU_0:
+	case MAC_AX_DP_SEL_WL_CPU_F:
+		/* To do... */
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 dp_intn_dump(struct mac_ax_adapter *adapter,
+			u8 dbg_sel, u8 intn_idx_max)
+{
+	struct mac_ax_dbgport_hw dp_hw;
+	u32 ret = MACSUCCESS;
+	u8 intn_idx;
+
+	PLTFM_MEMSET(&dp_hw, 0, sizeof(struct mac_ax_dbgport_hw));
+
+	for (intn_idx = 0; intn_idx < intn_idx_max; intn_idx++) {
+		dp_hw.dbg_sel[0] = dbg_sel;
+		dp_hw.intn_idx[0] = intn_idx;
+		dp_hw.dbg_sel_16b[0] = MAC_AX_DP_SEL0_16B_0_15;
+		dp_hw.dbg_sel_4b[0] = MAC_AX_DP_SEL_4B_0_7;
+		dp_hw.dbg_sel[1] = dbg_sel;
+		dp_hw.intn_idx[1] = intn_idx;
+		dp_hw.dbg_sel_16b[1] = MAC_AX_DP_SEL1_16B_16_31;
+		dp_hw.dbg_sel_4b[1] = MAC_AX_DP_SEL_4B_0_7;
+		dp_hw.mode = MAC_AX_DP_MODE_DUMP;
+
+		PLTFM_MSG_ERR("Internal index(%d):", intn_idx);
+		ret = mac_dbgport_hw_set(adapter, &dp_hw);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s, %d\n", __func__, ret);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+u32 dbgport_hw_dump(struct mac_ax_adapter *adapter,
+		    struct mac_ax_dbgport_hw_en *dp_hw_en)
+{
+	u32 ret;
+	u8 dbg_sel, intn_idx_max = MAC_AX_DP_INTN_IDX_NA_MAX;
+
+	/* PCIE */
+	if (dp_hw_en->pcie) {
+		for (dbg_sel = MAC_AX_DP_SEL_PCIE_0;
+		     dbg_sel <= MAC_AX_DP_SEL_PCIE_C; dbg_sel++) {
+			switch (dbg_sel) {
+			case MAC_AX_DP_SEL_PCIE_0:
+				intn_idx_max = MAC_AX_DP_INTN_IDX_PCIE_0_MAX;
+				break;
+			case MAC_AX_DP_SEL_PCIE_1:
+				intn_idx_max = MAC_AX_DP_INTN_IDX_PCIE_1_MAX;
+				break;
+			case MAC_AX_DP_SEL_PCIE_2:
+				intn_idx_max = MAC_AX_DP_INTN_IDX_PCIE_2_MAX;
+				break;
+			case MAC_AX_DP_SEL_PCIE_3:
+				intn_idx_max = MAC_AX_DP_INTN_IDX_PCIE_3_MAX;
+				break;
+			case MAC_AX_DP_SEL_PCIE_4:
+			case MAC_AX_DP_SEL_PCIE_5:
+			case MAC_AX_DP_SEL_PCIE_6:
+				intn_idx_max = MAC_AX_DP_INTN_IDX_NA_MAX;
+				break;
+			case MAC_AX_DP_SEL_PCIE_7:
+				intn_idx_max = MAC_AX_DP_INTN_IDX_PCIE_7_MAX;
+				break;
+			case MAC_AX_DP_SEL_PCIE_8:
+				intn_idx_max = MAC_AX_DP_INTN_IDX_PCIE_8_MAX;
+				break;
+			case MAC_AX_DP_SEL_PCIE_9:
+			case MAC_AX_DP_SEL_PCIE_A:
+			case MAC_AX_DP_SEL_PCIE_B:
+			case MAC_AX_DP_SEL_PCIE_C:
+				intn_idx_max = MAC_AX_DP_INTN_IDX_NA_MAX;
+				break;
+			}
+			PLTFM_MSG_ERR("Dbgport PCIE(0x%x):\n", dbg_sel);
+
+			ret = dp_intn_dump(adapter, dbg_sel, intn_idx_max);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s, %d\n", __func__, ret);
+				return ret;
+			}
+		}
+	}
+
+	/* WLAN_MAC */
+	if (dp_hw_en->axidma) {
+		if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+			ret = MACFWNONRDY;
+			PLTFM_MSG_ERR("%s, %d\n", __func__, ret);
+			return ret;
+		}
+		dbg_sel = MAC_AX_DP_SEL_AXIDMA;
+		intn_idx_max = MAC_AX_DP_INTN_IDX_AXIDMA_MAX;
+		PLTFM_MSG_TRACE("Dbgport axidma(0x%x):\n", dbg_sel);
+
+		ret = dp_intn_dump(adapter, dbg_sel, intn_idx_max);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s, %d\n", __func__, ret);
+			return ret;
+		}
+	}
+
+	/* DMAC */
+	if (dp_hw_en->wde_dle) {
+		dbg_sel = MAC_AX_DP_SEL_WDE_DLE;
+		intn_idx_max = MAC_AX_DP_INTN_IDX_WDE_DLE_MAX;
+		PLTFM_MSG_TRACE("Dbgport wde dle(0x%x):\n", dbg_sel);
+
+		ret = dp_intn_dump(adapter, dbg_sel, intn_idx_max);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s, %d\n", __func__, ret);
+			return ret;
+		}
+	}
+
+	if (dp_hw_en->ple_dle) {
+		dbg_sel = MAC_AX_DP_SEL_PLE_DLE;
+		intn_idx_max = MAC_AX_DP_INTN_IDX_PLE_DLE_MAX;
+		PLTFM_MSG_TRACE("Dbgport ple dle(0x%x):\n", dbg_sel);
+
+		ret = dp_intn_dump(adapter, dbg_sel, intn_idx_max);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s, %d\n", __func__, ret);
+			return ret;
+		}
+	}
+
+	if (dp_hw_en->sta_scheduler) {
+		dbg_sel = MAC_AX_DP_SEL_STA_SCHEDULER;
+		intn_idx_max = MAC_AX_DP_INTN_IDX_STA_SCHEDULER_MAX;
+		PLTFM_MSG_TRACE("Dbgport sta scheduler(0x%x):\n", dbg_sel);
+
+		ret = dp_intn_dump(adapter, dbg_sel, intn_idx_max);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s, %d\n", __func__, ret);
+			return ret;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_dbgport_hw_set(struct mac_ax_adapter *adapter,
+		       struct mac_ax_dbgport_hw *dp_hw)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = MACSUCCESS, backup = 0, val32;
+	u8 dbg_sel, dbg_sel_16b, dbg_sel_4b, sel_idx;
+
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+	adapter->hw_info->ind_aces_cnt++;
+
+	if (dp_hw->mode == MAC_AX_DP_MODE_LA) {
+		/* For AL mode, set GPIO PINMUX */
+		val32 = 0xEEEEEEEE;
+		MAC_REG_W32(R_AX_GPIO0_7_FUNC_SEL, val32);
+		MAC_REG_W32(R_AX_GPIO8_15_FUNC_SEL, val32);
+	} else {
+		/* For dump mode, need backup R_AX_DBG_CTRL */
+		backup = MAC_REG_R32(R_AX_DBG_CTRL);
+	}
+
+	val32 = 0;
+	for (sel_idx = 0; sel_idx < MAC_AX_DP_SEL_NUM; sel_idx++) {
+		dbg_sel = dp_hw->dbg_sel[sel_idx];
+		dbg_sel_16b = dp_hw->dbg_sel_16b[sel_idx];
+		dbg_sel_4b = dp_hw->dbg_sel_4b[sel_idx];
+
+		/* dbg port select */
+		if (sel_idx == 0) {
+			val32 = SET_CLR_WORD(val32, dbg_sel, B_AX_DBG_SEL0);
+			val32 |= (dbg_sel_16b ? B_AX_DBG_SEL0_16BIT : 0);
+			val32 = SET_CLR_WORD(val32, dbg_sel_4b,
+					     B_AX_DBG_SEL0_4BIT);
+		} else {
+			val32 = SET_CLR_WORD(val32, dbg_sel, B_AX_DBG_SEL1);
+			val32 |= (dbg_sel_16b ? B_AX_DBG_SEL1_16BIT : 0);
+			val32 = SET_CLR_WORD(val32, dbg_sel_4b,
+					     B_AX_DBG_SEL1_4BIT);
+		}
+
+		/* internal index for each module */
+		ret = dp_intn_idx_set(adapter, dp_hw, sel_idx);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s, %d\n", __func__, ret);
+			goto DONE;
+		}
+	}
+	MAC_REG_W32(R_AX_DBG_CTRL, val32);
+
+	/* Enable */
+	val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+	val32 = SET_CLR_WORD(val32, MAC_DBG_SEL, B_AX_SEL_0XC0);
+	MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+
+	/* dump info */
+	dp_hw->rsp_val = MAC_REG_R32(R_AX_DBG_PORT_SEL);
+	PLTFM_MSG_TRACE("0x%08X\n", dp_hw->rsp_val);
+
+	/* For dump mode, need restore R_AX_DBG_CTRL */
+	if (dp_hw->mode == MAC_AX_DP_MODE_DUMP)
+		MAC_REG_W32(R_AX_DBG_CTRL, backup);
+
+DONE:
+	adapter->hw_info->ind_aces_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->ind_access_lock);
+
+	return ret;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgport_hw.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgport_hw.h
new file mode 100644
index 000000000000..a2e1be3fe328
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dbgport_hw.h
@@ -0,0 +1,471 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_DBGPORT_HW_H_
+#define _MAC_AX_DBGPORT_HW_H_
+
+#include "../mac_def.h"
+#include "../mac_ax.h"
+
+#define MAC_AX_DP_MODE_DUMP	0
+#define MAC_AX_DP_MODE_LA	1
+
+#define AXIDMA_DBG_SEL_INTN0_SH 0
+#define AXIDMA_DBG_SEL_INTN1_SH 3
+#define AXIDMA_DBG_SEL_INTN2_SH 6
+
+/**
+ * @enum mac_ax_dbgport_sel
+ *
+ * @brief mac_ax_dbgport_sel
+ *
+ * @var mac_ax_dbgport_sel::MAC_AX_DP_SEL_SYS_0
+ * Please Place Description here.
+ * @var mac_ax_dbgport_sel::MAC_AX_DP_SEL_SYS_1F
+ * Please Place Description here.
+ * @var mac_ax_dbgport_sel::MAC_AX_DP_SEL_LAST
+ * Please Place Description here.
+ */
+enum mac_ax_dbgport_sel {
+	/* SYSTEM */
+	MAC_AX_DP_SEL_SYS_0 = 0x0, // 0x0 -0x1F
+	MAC_AX_DP_SEL_SYS_1F = 0x1F,
+	/* PINMUX */
+	MAC_AX_DP_SEL_PINMUX_0 = 0x20, // 0x20 - 0x27
+	MAC_AX_DP_SEL_PINMUX_7 = 0x27,
+	/* LOADER */
+	MAC_AX_DP_SEL_LOADER_0 = 0x28, //0x28-0x2B
+	MAC_AX_DP_SEL_LOADER_3 = 0x2B,
+	/* HMUX */
+	MAC_AX_DP_SEL_HMUX_0 = 0x2C, //0x2C-0x2F
+	MAC_AX_DP_SEL_HMUX_3 = 0x2F,
+	/* PCIE */
+	MAC_AX_DP_SEL_PCIE_0 = 0x30,
+	MAC_AX_DP_SEL_PCIE_1 = 0x31,
+	MAC_AX_DP_SEL_PCIE_2 = 0x32,
+	MAC_AX_DP_SEL_PCIE_3 = 0x33,
+	MAC_AX_DP_SEL_PCIE_4 = 0x34,
+	MAC_AX_DP_SEL_PCIE_5 = 0x35,
+	MAC_AX_DP_SEL_PCIE_6 = 0x36,
+	MAC_AX_DP_SEL_PCIE_7 = 0x37,
+	MAC_AX_DP_SEL_PCIE_8 = 0x38,
+	MAC_AX_DP_SEL_PCIE_9 = 0x39,
+	MAC_AX_DP_SEL_PCIE_A = 0x3A,
+	MAC_AX_DP_SEL_PCIE_B = 0x3B,
+	MAC_AX_DP_SEL_PCIE_C = 0x3C,
+	MAC_AX_DP_SEL_PCIE_D = 0x3D,
+	MAC_AX_DP_SEL_PCIE_E = 0x3E,
+	MAC_AX_DP_SEL_PCIE_F = 0x3F,
+	/* USB */
+	MAC_AX_DP_SEL_USB_0 = 0x40, //0x40-0x4F
+	MAC_AX_DP_SEL_USB_F = 0x4F,
+	/* SDIO */
+	MAC_AX_DP_SEL_SDIO_0 = 0x50, //0x50-0x5F
+	MAC_AX_DP_SEL_SDIO_F = 0x5F,
+	/* BT */
+	MAC_AX_DP_SEL_BT = 0x60,
+	/* WLAN_MAC */
+	MAC_AX_DP_SEL_AXIDMA = 0x71,
+	MAC_AX_DP_SEL_WLPHYDBG_GPIO = 0x72,
+	MAC_AX_DP_SEL_BTCOEXIST = 0x74,
+	MAC_AX_DP_SEL_LTECOEX = 0x75,
+	MAC_AX_DP_SEL_WLPHYDBG = 0x76,
+	MAC_AX_DP_SEL_WLAN_MAC_REG = 0x77,
+	MAC_AX_DP_SEL_WLAN_MAC_PMC = 0x78,
+	MAC_AX_DP_SEL_CALIB_TOP = 0x79,
+	/* MAC */
+	// DMAC
+	MAC_AX_DP_SEL_DISPATCHER_TOP = 0x80,
+	MAC_AX_DP_SEL_WDE_DLE = 0x81,
+	MAC_AX_DP_SEL_PLE_DLE = 0x82,
+	MAC_AX_DP_SEL_WDRLS = 0x83,
+	MAC_AX_DP_SEL_DLE_CPUIO = 0x84,
+	MAC_AX_DP_SEL_BBRPT = 0x85,
+	MAC_AX_DP_SEL_TXPKTCTL = 0x86,
+	MAC_AX_DP_SEL_PKTBUFFER = 0x87,
+	MAC_AX_DP_SEL_DMAC_TABLE = 0x88,
+	MAC_AX_DP_SEL_STA_SCHEDULER = 0x89,
+	MAC_AX_DP_SEL_DMAC_PKTIN = 0x8A,
+	MAC_AX_DP_SEL_WSEC_TOP = 0x8B,
+	MAC_AX_DP_SEL_MPDU_PROCESSOR = 0x8C,
+	MAC_AX_DP_SEL_DMAC_APB_BRIDGE = 0x8D,
+	MAC_AX_DP_SEL_LTR_CTRL = 0x8E,
+	// CMAC_0
+	MAC_AX_DP_SEL_CMAC0_CMAC_DMAC_TOP = 0xA0,
+	MAC_AX_DP_SEL_CMAC0_PTCLTOP = 0xA1,
+	MAC_AX_DP_SEL_CMAC0_SCHEDULERTOP = 0xA2,
+	MAC_AX_DP_SEL_CMAC0_TXPWR_CTRL = 0xA3,
+	MAC_AX_DP_SEL_CMAC0_CMAC_APB_BRIDGE = 0xA4,
+	MAC_AX_DP_SEL_CMAC0_MACTX = 0xA5,
+	MAC_AX_DP_SEL_CMAC0_MACRX = 0xA6,
+	MAC_AX_DP_SEL_CMAC0_WMAC_TRXPTCL = 0xA7,
+	// CMAC_1
+	MAC_AX_DP_SEL_CMAC1_CMAC_DMAC_TOP = 0xB0,
+	MAC_AX_DP_SEL_CMAC1_PTCLTOP = 0xB1,
+	MAC_AX_DP_SEL_CMAC1_SCHEDULERTOP = 0xB2,
+	MAC_AX_DP_SEL_CMAC1_TXPWR_CTRL = 0xB3,
+	MAC_AX_DP_SEL_CMAC1_CMAC_APB_BRIDGE = 0xB4,
+	MAC_AX_DP_SEL_CMAC1_MACTX = 0xB5,
+	MAC_AX_DP_SEL_CMAC1_MACRX = 0xB6,
+	MAC_AX_DP_SEL_CMAC1_WMAC_TRXPTCL = 0xB7,
+	MAC_AX_DP_SEL_CMAC_SHARE = 0xC0,
+	/* WLAN_MAC */
+	MAC_AX_DP_SEL_WL_CPU_0 = 0xF0, //0xF0-0xFF
+	MAC_AX_DP_SEL_WL_CPU_F = 0xFF,
+
+	/* keep last */
+	MAC_AX_DP_SEL_LAST
+};
+
+/**
+ * @enum mac_ax_dbgport_sel0_16b
+ *
+ * @brief mac_ax_dbgport_sel0_16b
+ *
+ * @var mac_ax_dbgport_sel0_16b::MAC_AX_DP_SEL0_16B_0_15
+ * Please Place Description here.
+ * @var mac_ax_dbgport_sel0_16b::MAC_AX_DP_SEL0_16B_16_31
+ * Please Place Description here.
+ * @var mac_ax_dbgport_sel0_16b::MAC_AX_DP_SEL0_16B_END
+ * Please Place Description here.
+ */
+enum mac_ax_dbgport_sel0_16b {
+	MAC_AX_DP_SEL0_16B_0_15 = 0,
+	MAC_AX_DP_SEL0_16B_16_31 = 1,
+	MAC_AX_DP_SEL0_16B_END
+};
+
+/**
+ * @enum mac_ax_dbgport_sel1_16b
+ *
+ * @brief mac_ax_dbgport_sel1_16b
+ *
+ * @var mac_ax_dbgport_sel1_16b::MAC_AX_DP_SEL1_16B_16_31
+ * Please Place Description here.
+ * @var mac_ax_dbgport_sel1_16b::MAC_AX_DP_SEL1_16B_0_15
+ * Please Place Description here.
+ * @var mac_ax_dbgport_sel1_16b::MAC_AX_DP_SEL1_16B_END
+ * Please Place Description here.
+ */
+enum mac_ax_dbgport_sel1_16b {
+	MAC_AX_DP_SEL1_16B_16_31 = 0,
+	MAC_AX_DP_SEL1_16B_0_15 = 1,
+	MAC_AX_DP_SEL1_16B_END
+};
+
+/**
+ * @enum mac_ax_dbgport_sel_4b
+ *
+ * @brief mac_ax_dbgport_sel_4b
+ *
+ * @var mac_ax_dbgport_sel_4b::MAC_AX_DP_SEL_4B_0_7
+ * Please Place Description here.
+ * @var mac_ax_dbgport_sel_4b::MAC_AX_DP_SEL_4B_4_11
+ * Please Place Description here.
+ * @var mac_ax_dbgport_sel_4b::MAC_AX_DP_SEL_4B_8_15
+ * Please Place Description here.
+ * @var mac_ax_dbgport_sel_4b::MAC_AX_DP_SEL_4B_0_3_12_15
+ * Please Place Description here.
+ * @var mac_ax_dbgport_sel_4b::MAC_AX_DP_SEL_4B_END
+ * Please Place Description here.
+ */
+enum mac_ax_dbgport_sel_4b {
+	MAC_AX_DP_SEL_4B_0_7 = 0,
+	MAC_AX_DP_SEL_4B_4_11 = 1,
+	MAC_AX_DP_SEL_4B_8_15 = 2,
+	MAC_AX_DP_SEL_4B_0_3_12_15 = 3,
+	MAC_AX_DP_SEL_4B_END
+};
+
+/* For internal index */
+/* COMMON */
+enum mac_ax_dbgport_intn_idx_na {
+	MAC_AX_DP_INTN_IDX_NA = 0x0,
+	MAC_AX_DP_INTN_IDX_NA_MAX = 0x1,
+};
+
+/* SYSTEM */
+// MAC_AX_DP_SEL_SYS_0 = 0x0, // 0x0 -0x1F
+// MAC_AX_DP_SEL_SYS_1F = 0x1F,
+
+/* PINMUX */
+// MAC_AX_DP_SEL_PINMUX_0 = 0x20, // 0x20 - 0x27
+// MAC_AX_DP_SEL_PINMUX_7 = 0x27,
+
+/* LOADER */
+// MAC_AX_DP_SEL_LOADER_0 = 0x28, //0x28-0x2B
+// MAC_AX_DP_SEL_LOADER_3 = 0x2B,
+
+/* HMUX */
+// MAC_AX_DP_SEL_HMUX_0 = 0x2C, //0x2C-0x2F
+// MAC_AX_DP_SEL_HMUX_3 = 0x2F,
+
+/* PCIE */
+// MAC_AX_DP_SEL_PCIE_0 = 0x30,
+enum mac_ax_dbgport_intn_idx_pcie_0 {
+	MAC_AX_DP_INTN_IDX_PCIE_0_0 = 0x0,
+	MAC_AX_DP_INTN_IDX_PCIE_0_1 = 0x1,
+	MAC_AX_DP_INTN_IDX_PCIE_0_2 = 0x2,
+	MAC_AX_DP_INTN_IDX_PCIE_0_3 = 0x3,
+	MAC_AX_DP_INTN_IDX_PCIE_0_MAX = 0x4
+};
+
+// MAC_AX_DP_SEL_PCIE_1 = 0x31,
+enum mac_ax_dbgport_intn_idx_pcie_1 {
+	MAC_AX_DP_INTN_IDX_PCIE_1_0 = 0x0,
+	MAC_AX_DP_INTN_IDX_PCIE_1_1 = 0x1,
+	MAC_AX_DP_INTN_IDX_PCIE_1_2 = 0x2,
+	MAC_AX_DP_INTN_IDX_PCIE_1_3 = 0x3,
+	MAC_AX_DP_INTN_IDX_PCIE_1_4 = 0x4,
+	MAC_AX_DP_INTN_IDX_PCIE_1_MAX = 0x5
+};
+
+// MAC_AX_DP_SEL_PCIE_2 = 0x32,
+enum mac_ax_dbgport_intn_idx_pcie_2 {
+	MAC_AX_DP_INTN_IDX_PCIE_2_0 = 0x0,
+	MAC_AX_DP_INTN_IDX_PCIE_2_1 = 0x1,
+	MAC_AX_DP_INTN_IDX_PCIE_2_MAX = 0x2
+};
+
+// MAC_AX_DP_SEL_PCIE_3 = 0x33,
+enum mac_ax_dbgport_intn_idx_pcie_3 {
+	MAC_AX_DP_INTN_IDX_PCIE_3_0 = 0x0,
+	MAC_AX_DP_INTN_IDX_PCIE_3_1 = 0x1,
+	MAC_AX_DP_INTN_IDX_PCIE_3_2 = 0x2,
+	MAC_AX_DP_INTN_IDX_PCIE_3_3 = 0x3,
+	MAC_AX_DP_INTN_IDX_PCIE_3_4 = 0x4,
+	MAC_AX_DP_INTN_IDX_PCIE_3_5 = 0x5,
+	MAC_AX_DP_INTN_IDX_PCIE_3_MAX = 0x6
+};
+
+// MAC_AX_DP_SEL_PCIE_4 = 0x34,
+// MAC_AX_DP_SEL_PCIE_5 = 0x35,
+// MAC_AX_DP_SEL_PCIE_6 = 0x36,
+// MAC_AX_DP_SEL_PCIE_7 = 0x37,
+enum mac_ax_dbgport_intn_idx_pcie_7 {
+	MAC_AX_DP_INTN_IDX_PCIE_7_0 = 0x0,
+	MAC_AX_DP_INTN_IDX_PCIE_7_1 = 0x1,
+	MAC_AX_DP_INTN_IDX_PCIE_7_2 = 0x2,
+	MAC_AX_DP_INTN_IDX_PCIE_7_3 = 0x3,
+	MAC_AX_DP_INTN_IDX_PCIE_7_4 = 0x4,
+	MAC_AX_DP_INTN_IDX_PCIE_7_MAX = 0x5
+};
+
+// MAC_AX_DP_SEL_PCIE_8 = 0x38,
+enum mac_ax_dbgport_intn_idx_pcie_8 {
+	MAC_AX_DP_INTN_IDX_PCIE_8_0 = 0x0,
+	MAC_AX_DP_INTN_IDX_PCIE_8_1 = 0x1,
+	MAC_AX_DP_INTN_IDX_PCIE_8_2 = 0x2,
+	MAC_AX_DP_INTN_IDX_PCIE_8_3 = 0x3,
+	MAC_AX_DP_INTN_IDX_PCIE_8_4 = 0x4,
+	MAC_AX_DP_INTN_IDX_PCIE_8_5 = 0x5,
+	MAC_AX_DP_INTN_IDX_PCIE_8_6 = 0x6,
+	MAC_AX_DP_INTN_IDX_PCIE_8_MAX = 0x7
+};
+
+// MAC_AX_DP_SEL_PCIE_9 = 0x39,
+// MAC_AX_DP_SEL_PCIE_A = 0x3A,
+// MAC_AX_DP_SEL_PCIE_B = 0x3B,
+// MAC_AX_DP_SEL_PCIE_C = 0x3C,
+// MAC_AX_DP_SEL_PCIE_D = 0x3D,
+// MAC_AX_DP_SEL_PCIE_E = 0x3E,
+// MAC_AX_DP_SEL_PCIE_F = 0x3F,
+
+/* USB */
+// MAC_AX_DP_SEL_USB_0 = 0x40, //0x40-0x4F
+// MAC_AX_DP_SEL_USB_F = 0x4F,
+
+/* SDIO */
+// MAC_AX_DP_SEL_SDIO_0 = 0x50, //0x50-0x5F
+// MAC_AX_DP_SEL_SDIO_F = 0x5F,
+
+/* BT */
+// MAC_AX_DP_SEL_BT = 0x60,
+
+/* WLAN_MAC */
+// MAC_AX_DP_SEL_AXIDMA = 0x71,
+enum mac_ax_dbgport_intn_idx_axidma {
+	MAC_AX_DP_INTN_IDX_AXIDMA_0 = 0x0,
+	MAC_AX_DP_INTN_IDX_AXIDMA_1 = 0x1,
+	MAC_AX_DP_INTN_IDX_AXIDMA_2 = 0x2,
+	MAC_AX_DP_INTN_IDX_AXIDMA_3 = 0x3,
+	MAC_AX_DP_INTN_IDX_AXIDMA_4 = 0x4,
+	MAC_AX_DP_INTN_IDX_AXIDMA_5 = 0x5,
+	MAC_AX_DP_INTN_IDX_AXIDMA_6 = 0x6,
+	MAC_AX_DP_INTN_IDX_AXIDMA_7 = 0x7,
+	MAC_AX_DP_INTN_IDX_AXIDMA_8 = 0x8,
+	MAC_AX_DP_INTN_IDX_AXIDMA_9 = 0x9,
+	MAC_AX_DP_INTN_IDX_AXIDMA_A = 0xA,
+	MAC_AX_DP_INTN_IDX_AXIDMA_B = 0xB,
+	MAC_AX_DP_INTN_IDX_AXIDMA_C = 0xC,
+	MAC_AX_DP_INTN_IDX_AXIDMA_D = 0xD,
+	MAC_AX_DP_INTN_IDX_AXIDMA_MAX = 0xE
+};
+
+// MAC_AX_DP_SEL_WLPHYDBG_GPIO = 0x72,
+// MAC_AX_DP_SEL_BTCOEXIST = 0x74,
+// MAC_AX_DP_SEL_LTECOEX = 0x75,
+// MAC_AX_DP_SEL_WLPHYDBG = 0x76,
+// MAC_AX_DP_SEL_WLAN_MAC_REG = 0x77,
+// MAC_AX_DP_SEL_WLAN_MAC_PMC = 0x78,
+// MAC_AX_DP_SEL_CALIB_TOP = 0x79,
+
+/* MAC */
+// DMAC
+// MAC_AX_DP_SEL_DISPATCHER_TOP = 0x80,
+// MAC_AX_DP_SEL_WDE_DLE = 0x81,
+enum mac_ax_dbgport_intn_idx_wde_dle {
+	MAC_AX_DP_INTN_IDX_WDE_DLE_0 = 0x0,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_1 = 0x1,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_2 = 0x2,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_3 = 0x3,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_4 = 0x4,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_5 = 0x5,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_6 = 0x6,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_7 = 0x7,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_8 = 0x8,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_9 = 0x9,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_A = 0xA,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_B = 0xB,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_C = 0xC,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_D = 0xD,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_E = 0xE,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_F = 0xF,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_10 = 0x10,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_11 = 0x11,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_12 = 0x12,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_13 = 0x13,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_14 = 0x14,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_15 = 0x15,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_16 = 0x16,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_17 = 0x17,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_18 = 0x18,
+	MAC_AX_DP_INTN_IDX_WDE_DLE_MAX = 0x19
+};
+
+// MAC_AX_DP_SEL_PLE_DLE = 0x82,
+enum mac_ax_dbgport_intn_idx_ple_dle {
+	MAC_AX_DP_INTN_IDX_PLE_DLE_0 = 0x0,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_1 = 0x1,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_2 = 0x2,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_3 = 0x3,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_4 = 0x4,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_5 = 0x5,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_6 = 0x6,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_7 = 0x7,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_8 = 0x8,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_9 = 0x9,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_A = 0xA,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_B = 0xB,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_C = 0xC,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_D = 0xD,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_E = 0xE,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_F = 0xF,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_10 = 0x10,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_11 = 0x11,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_12 = 0x12,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_13 = 0x13,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_14 = 0x14,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_15 = 0x15,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_16 = 0x16,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_17 = 0x17,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_18 = 0x18,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_19 = 0x19,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_1A = 0x1A,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_1B = 0x1B,
+	MAC_AX_DP_INTN_IDX_PLE_DLE_MAX = 0x1C
+};
+
+// MAC_AX_DP_SEL_WDRLS = 0x83,
+// MAC_AX_DP_SEL_DLE_CPUIO = 0x84,
+// MAC_AX_DP_SEL_BBRPT = 0x85,
+// MAC_AX_DP_SEL_TXPKTCTL = 0x86,
+// MAC_AX_DP_SEL_PKTBUFFER = 0x87,
+// MAC_AX_DP_SEL_DMAC_TABLE = 0x88,
+// MAC_AX_DP_SEL_STA_SCHEDULER = 0x89,
+enum mac_ax_dbgport_intn_idx_sta_scheduler {
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_0 = 0x0,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_1 = 0x1,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_2 = 0x2,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_3 = 0x3,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_4 = 0x4,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_5 = 0x5,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_6 = 0x6,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_7 = 0x7,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_8 = 0x8,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_9 = 0x9,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_A = 0xA,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_B = 0xB,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_C = 0xC,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_D = 0xD,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_E = 0xE,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_F = 0xF,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_10 = 0x10,
+	MAC_AX_DP_INTN_IDX_STA_SCHEDULER_MAX = 0x11
+};
+
+// MAC_AX_DP_SEL_DMAC_PKTIN = 0x8A,
+// MAC_AX_DP_SEL_WSEC_TOP = 0x8B,
+// MAC_AX_DP_SEL_MPDU_PROCESSOR = 0x8C,
+// MAC_AX_DP_SEL_DMAC_APB_BRIDGE = 0x8D,
+// MAC_AX_DP_SEL_LTR_CTRL = 0x8E,
+// CMAC_0
+// MAC_AX_DP_SEL_CMAC0_CMAC_DMAC_TOP = 0xA0,
+// MAC_AX_DP_SEL_CMAC0_PTCLTOP = 0xA1,
+// MAC_AX_DP_SEL_CMAC0_SCHEDULERTOP = 0xA2,
+// MAC_AX_DP_SEL_CMAC0_TXPWR_CTRL = 0xA3,
+// MAC_AX_DP_SEL_CMAC0_CMAC_APB_BRIDGE = 0xA4,
+// MAC_AX_DP_SEL_CMAC0_MACTX = 0xA5,
+// MAC_AX_DP_SEL_CMAC0_MACRX = 0xA6,
+// MAC_AX_DP_SEL_CMAC0_WMAC_TRXPTCL = 0xA7,
+// CMAC_1
+// MAC_AX_DP_SEL_CMAC1_CMAC_DMAC_TOP = 0xB0,
+// MAC_AX_DP_SEL_CMAC1_PTCLTOP = 0xB1,
+// MAC_AX_DP_SEL_CMAC1_SCHEDULERTOP = 0xB2,
+// MAC_AX_DP_SEL_CMAC1_TXPWR_CTRL = 0xB3,
+// MAC_AX_DP_SEL_CMAC1_CMAC_APB_BRIDGE = 0xB4,
+// MAC_AX_DP_SEL_CMAC1_MACTX = 0xB5,
+// MAC_AX_DP_SEL_CMAC1_MACRX = 0xB6,
+// MAC_AX_DP_SEL_CMAC1_WMAC_TRXPTCL = 0xB7,
+// MAC_AX_DP_SEL_CMAC_SHARE = 0xC0,
+
+/* WLAN_MAC */
+// MAC_AX_DP_SEL_WL_CPU_0 = 0xF0, //0xF0-0xFF
+// MAC_AX_DP_SEL_WL_CPU_F = 0xFF,
+
+/**
+ * @brief mac_dbgport_hw_dump
+ *
+ * @param *adapter
+ * @param *dp_hw_en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dbgport_hw_dump(struct mac_ax_adapter *adapter,
+		    struct mac_ax_dbgport_hw_en *dp_hw_en);
+
+/**
+ * @brief mac_dbgport_hw_set
+ *
+ * @param *adapter
+ * @param *dbgport_hw
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dbgport_hw_set(struct mac_ax_adapter *adapter,
+		       struct mac_ax_dbgport_hw *dp_hw);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dle.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dle.c
new file mode 100644
index 000000000000..cd252a77415d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dle.c
@@ -0,0 +1,3524 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "dle.h"
+#include "mac_priv.h"
+
+/* PCIE 64 */
+static struct dle_size_t wde_size0 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	4095, /* lnk_pge_num */
+	1, /* unlnk_pge_num */
+};
+
+/* SDIO, PCIE STF, USB */
+static struct dle_size_t wde_size1 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	768, /* lnk_pge_num */
+	0, /* unlnk_pge_num */
+};
+
+/* PCIE 128 */
+static struct dle_size_t wde_size2 = {
+	MAC_AX_WDE_PG_128, /* pge_size */
+	2016, /* lnk_pge_num */
+	32, /* unlnk_pge_num */
+};
+
+/* PCIE SU TP */
+static struct dle_size_t wde_size3 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	496, /* lnk_pge_num */
+	3600, /* unlnk_pge_num */
+};
+
+/* DLFW */
+static struct dle_size_t wde_size4 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	0, /* lnk_pge_num */
+	4096, /* unlnk_pge_num */
+};
+
+/* PCIE BCN TEST */
+static struct dle_size_t wde_size5 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	3904, /* lnk_pge_num */
+	64, /* unlnk_pge_num */
+};
+
+/* PCIE 64 */
+static struct dle_size_t wde_size6 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	512, /* lnk_pge_num */
+	0, /* unlnk_pge_num */
+};
+
+/* 8852B PCIE SCC */
+static struct dle_size_t wde_size7 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	510, /* lnk_pge_num */
+	2, /* unlnk_pge_num */
+};
+
+/* PCIE STF, USB */
+static struct dle_size_t wde_size8 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	256, /* lnk_pge_num */
+	0, /* unlnk_pge_num */
+};
+
+/* DLFW */
+static struct dle_size_t wde_size9 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	0, /* lnk_pge_num */
+	1024, /* unlnk_pge_num */
+};
+
+/* LA-PCIE */
+static struct dle_size_t wde_size10 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	1408, /* lnk_pge_num */
+	0, /* unlnk_pge_num */
+};
+
+/* LA-PCIE */
+static struct dle_size_t wde_size11 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	256, /* lnk_pge_num */
+	0, /* unlnk_pge_num */
+};
+
+/* LA-SDIO */
+static struct dle_size_t wde_size12 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	328, /* lnk_pge_num */
+	56, /* unlnk_pge_num */
+};
+
+/* SDIO SCC */
+static struct dle_size_t wde_size13 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	126, /* lnk_pge_num */
+	2, /* unlnk_pge_num */
+};
+
+/* SDIO LA */
+static struct dle_size_t wde_size14 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	124, /* lnk_pge_num */
+	4, /* unlnk_pge_num */
+};
+
+/* LA-USB 8852A*/
+static struct dle_size_t wde_size15 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	384, /* lnk_pge_num */
+	0, /* unlnk_pge_num */
+};
+
+/* LA-USB 8852B*/
+static struct dle_size_t wde_size16 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	124, /* lnk_pge_num */
+	4, /* unlnk_pge_num */
+};
+
+/* 8852C USB3.0 */
+static struct dle_size_t wde_size17 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	354, /* lnk_pge_num */
+	30, /* unlnk_pge_num */
+};
+
+/* 8852C DLFW */
+static struct dle_size_t wde_size18 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	0, /* lnk_pge_num */
+	2048, /* unlnk_pge_num */
+};
+
+/* 8852C PCIE SCC */
+static struct dle_size_t wde_size19 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	3328, /* lnk_pge_num */
+	0, /* unlnk_pge_num */
+};
+
+/* 8852C PCIE DBCC */
+static struct dle_size_t wde_size20 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	3328, /* lnk_pge_num */
+	0, /* unlnk_pge_num */
+};
+
+/* 8852C PCIE SCC/DBCC STF */
+static struct dle_size_t wde_size21 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	256, /* lnk_pge_num */
+	0, /* unlnk_pge_num */
+};
+
+/* 8852C PCIE LA */
+static struct dle_size_t wde_size22 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	3224, /* lnk_pge_num */
+	104, /* unlnk_pge_num */
+};
+
+/* PCIE SCC TURBO */
+static struct dle_size_t wde_size23 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	1022, /* lnk_pge_num */
+	2, /* unlnk_pge_num */
+};
+
+/* 8852B USB CABV*/
+static struct dle_size_t wde_size24 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	216, /* lnk_pge_num */
+	40, /* unlnk_pge_num */
+};
+
+/* 8852B USB2.0/USB3.0 SCC */
+static struct dle_size_t wde_size25 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	162, /* lnk_pge_num */
+	94, /* unlnk_pge_num */
+};
+
+/* 8852AU ccv*/
+static struct dle_size_t wde_size26 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	760, /* lnk_pge_num */
+	8, /* unlnk_pge_num */
+};
+
+/* 8852C DBCC USB */
+static struct dle_size_t wde_size27 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	374, /* lnk_pge_num */
+	10, /* unlnk_pge_num */
+};
+
+/* 1115E PCIE DBCC & DLFW */
+static struct dle_size_t wde_size28 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	0, /* lnk_pge_num */
+	3328, /* unlnk_pge_num */
+};
+
+/* 8852B USB2.0 SCC */
+static struct dle_size_t wde_size30 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	220, /* lnk_pge_num */
+	36, /* unlnk_pge_num */
+};
+
+/* 8852C USB2.0 */
+static struct dle_size_t wde_size31 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	384, /* lnk_pge_num */
+	0, /* unlnk_pge_num */
+};
+
+/* 8851E USB2.0 */
+static struct dle_size_t wde_size32 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	166, /* lnk_pge_num */
+	90, /* unlnk_pge_num */
+};
+
+/* 8851E DLFW */
+static struct dle_size_t wde_size33 = {
+	MAC_AX_WDE_PG_64, /* pge_size */
+	0, /* lnk_pge_num */
+	256, /* unlnk_pge_num */
+};
+
+/* PCIE */
+static struct dle_size_t ple_size0 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1520, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* SDIO, USB */
+static struct dle_size_t ple_size1 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	3184, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* PCIE STF */
+static struct dle_size_t ple_size2 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	3184, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* PCIE SU TP */
+static struct dle_size_t ple_size3 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	330, /* lnk_pge_num */
+	1206, /* unlnk_pge_num */
+};
+
+/* DLFW */
+static struct dle_size_t ple_size4 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	64, /* lnk_pge_num */
+	1472, /* unlnk_pge_num */
+};
+
+/* PCIE BCN TEST */
+static struct dle_size_t ple_size5 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1520, /* lnk_pge_num */
+	80, /* unlnk_pge_num */
+};
+
+/* PCIE 64 */
+static struct dle_size_t ple_size6 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	496, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* PCIE STF, USB */
+static struct dle_size_t ple_size7 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1392, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* DLFW */
+static struct dle_size_t ple_size8 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	64, /* lnk_pge_num */
+	960, /* unlnk_pge_num */
+};
+
+/* PCIE 128 */
+static struct dle_size_t ple_size9 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	576, /* lnk_pge_num */
+	0, /* unlnk_pge_num */
+};
+
+/* LA-PCIE 8852A*/
+static struct dle_size_t ple_size10 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	816, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* LA-PCIE */
+static struct dle_size_t ple_size11 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	368, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* LA-SDIO 8852A*/
+static struct dle_size_t ple_size12 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1328, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* SDIO SCC */
+static struct dle_size_t ple_size13 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	688, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* SDIO LA */
+static struct dle_size_t ple_size14 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	432, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* LA-USB 8852A */
+static struct dle_size_t ple_size15 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1328, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* LA-USB 8852B */
+static struct dle_size_t ple_size16 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	424, /* lnk_pge_num */
+	24, /* unlnk_pge_num */
+};
+
+/* 8852C USB */
+static struct dle_size_t ple_size17 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	3368, /* lnk_pge_num */
+	24, /* unlnk_pge_num */
+};
+
+/* 8852C DLFW*/
+static struct dle_size_t ple_size18 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	2544, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+#ifdef PHL_FEATURE_AP
+/* 8852C PCIE SCC PLE 256 */
+static struct dle_size_t ple_size19 = {
+	MAC_AX_PLE_PG_256, /* pge_size */
+	952, /* lnk_pge_num */
+	8, /* unlnk_pge_num */
+};
+#else
+/* 8852C PCIE SCC */
+static struct dle_size_t ple_size19 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1904, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+#endif
+
+/* 8852C PCIE DBCC */
+static struct dle_size_t ple_size20 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1904, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* 8852C PCIE SCC/DBCC STF */
+static struct dle_size_t ple_size21 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	3440, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* 8852C PCIE LA */
+static struct dle_size_t ple_size22 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1904, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* 8852B PCIE TURBO AB */
+static struct dle_size_t ple_size23 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	496, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* PCIE SCC TURBO */
+static struct dle_size_t ple_size24 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1008, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* 8852B USB2.0 TURBO*/
+static struct dle_size_t ple_size27 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1396, /* lnk_pge_num */
+	12, /* unlnk_pge_num */
+};
+
+/* 8852C DBCC USB2.0 */
+static struct dle_size_t ple_size28 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	3347, /* lnk_pge_num */
+	45, /* unlnk_pge_num */
+};
+
+/* SDIO SCC TURBO */
+static struct dle_size_t ple_size29 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1456, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* 1115E PCIE DBCC & DLFW */
+static struct dle_size_t ple_size30 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	2672, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* 8852B USB3.0 TURBO*/
+static struct dle_size_t ple_size31 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1386, /* lnk_pge_num */
+	22, /* unlnk_pge_num */
+};
+
+/* 8852B USB2.0 SCC*/
+static struct dle_size_t ple_size32 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	620, /* lnk_pge_num */
+	20, /* unlnk_pge_num */
+};
+
+/* 8852B USB3.0 SCC*/
+static struct dle_size_t ple_size33 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	632, /* lnk_pge_num */
+	8, /* unlnk_pge_num */
+};
+
+/* 8852C  USB2.0 */
+static struct dle_size_t ple_size34 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	3374, /* lnk_pge_num */
+	18, /* unlnk_pge_num */
+};
+
+/* 8852C DBCC USB3.0 */
+static struct dle_size_t ple_size35 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	3376, /* lnk_pge_num */
+	16, /* unlnk_pge_num */
+};
+
+/* 8851E USB 2.0 mode */
+static struct dle_size_t ple_size36 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	1386, /* lnk_pge_num */
+	22, /* unlnk_pge_num */
+};
+
+/* 8851E DLFW*/
+static struct dle_size_t ple_size37 = {
+	MAC_AX_PLE_PG_128, /* pge_size */
+	64, /* lnk_pge_num */
+	1344, /* unlnk_pge_num */
+};
+
+/* PCIE 64 */
+static struct wde_quota_t wde_qt0 = {
+	3792, /* hif */
+	196, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	107, /* cpu_io */
+};
+
+/* SDIO, PCIE STF, USB */
+static struct wde_quota_t wde_qt1 = {
+	512, /* hif */
+	196, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	60, /* cpu_io */
+};
+
+/* PCIE 128 */
+static struct wde_quota_t wde_qt2 = {
+	1896, /* hif */
+	98, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	22, /* cpu_io */
+};
+
+/* PCIE SU TP */
+static struct wde_quota_t wde_qt3 = {
+	256, /* hif */
+	196, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	44, /* cpu_io */
+};
+
+/* DLFW */
+static struct wde_quota_t wde_qt4 = {
+	0, /* hif */
+	0, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	0, /* cpu_io */
+};
+
+/* PCIE BCN TEST */
+static struct wde_quota_t wde_qt5 = {
+	3666, /* hif */
+	196, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	44, /* cpu_io */
+};
+
+/* PCIE 64 */
+static struct wde_quota_t wde_qt6 = {
+	448, /* hif */
+	48, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	16, /* cpu_io */
+};
+
+/* 8852B PCIE SCC */
+static struct wde_quota_t wde_qt7 = {
+	446, /* hif */
+	48, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	16, /* cpu_io */
+};
+
+/* PCIE STF, USB */
+static struct wde_quota_t wde_qt8 = {
+	204, /* hif */
+	44, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	8, /* cpu_io */
+};
+
+/* LA-PCIE 8852A*/
+static struct wde_quota_t wde_qt9 = {
+	1172, /* hif */
+	196, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	40, /* cpu_io */
+};
+
+/* LA-PCIE */
+static struct wde_quota_t wde_qt10 = {
+	200, /* hif */
+	48, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	8, /* cpu_io */
+};
+
+/* LA-SDIO 8852A*/
+static struct wde_quota_t wde_qt11 = {
+	128, /* hif */
+	196, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	4, /* cpu_io */
+};
+
+/* SDIO SCC */
+static struct wde_quota_t wde_qt12 = {
+	112, /* hif */
+	8, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	6, /* cpu_io */
+};
+
+/* SDIO LA */
+static struct wde_quota_t wde_qt13 = {
+	112, /* hif */
+	4, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	8, /* cpu_io */
+};
+
+/* LA USB 8852A */
+static struct wde_quota_t wde_qt14 = {
+	256, /* hif */
+	118, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	10, /* cpu_io */
+};
+
+/* LA USB 8852B */
+static struct wde_quota_t wde_qt15 = {
+	112, /* hif */
+	4, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	8, /* cpu_io */
+};
+
+/*8852C   USB3.0 */
+static struct wde_quota_t wde_qt16 = {
+	344, /* hif */
+	2, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	8, /* cpu_io */
+};
+
+/*8852C & 8192XB & 1115E DLFW */
+static struct wde_quota_t wde_qt17 = {
+	0, /* hif */
+	0, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	0, /* cpu_io */
+};
+
+/* 8852C PCIE SCC */
+static struct wde_quota_t wde_qt18 = {
+	3228, /* hif */
+	60, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	40, /* cpu_io */
+};
+
+/* 8852C PCIE DBCC */
+static struct wde_quota_t wde_qt19 = {
+	3218, /* hif */
+	60, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	50, /* cpu_io */
+};
+
+/* 8852C PCIE SCC STF */
+static struct wde_quota_t wde_qt20 = {
+	216, /* hif */
+	20, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	20, /* cpu_io */
+};
+
+/* 8852C PCIE DBCC STF */
+static struct wde_quota_t wde_qt21 = {
+	152, /* hif */
+	64, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	40, /* cpu_io */
+};
+
+/* 8852C PCIE LA */
+static struct wde_quota_t wde_qt22 = {
+	3120, /* hif */
+	64, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	40, /* cpu_io */
+};
+
+/* PCIE SCC TRUBO */
+static struct wde_quota_t wde_qt23 = {
+	958, /* hif */
+	48, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	16, /* cpu_io */
+};
+
+/* 8852B USB CABV */
+static struct wde_quota_t wde_qt24 = {
+	164, /* hif */
+	44, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	8, /* cpu_io */
+};
+
+/* 8852B USB2.0/USB3.0 SCC*/
+static struct wde_quota_t wde_qt25 = {
+	152, /* hif */
+	2, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	8, /* cpu_io */
+};
+
+/* 8852AU ccv */
+static struct wde_quota_t wde_qt26 = {
+	504, /* hif */
+	196, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	60, /* cpu_io */
+};
+
+/*8852C   USB DBCC USB2.0 */
+static struct wde_quota_t wde_qt27 = {
+	328, /* hif */
+	6, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	40, /* cpu_io */
+};
+
+/* 1115E PCIE DBCC */
+static struct wde_quota_t wde_qt28 = {
+	3218, /* hif */
+	60, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	50, /* cpu_io */
+};
+
+/* 1115E PCIE SCC */
+static struct wde_quota_t wde_qt29 = {
+	3228, /* hif */
+	60, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	40, /* cpu_io */
+};
+
+/* 8852B USB2.0/USB3.0 SCC TURBO*/
+static struct wde_quota_t wde_qt30 = {
+	210, /* hif */
+	2, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	8, /* cpu_io */
+};
+
+/*8852C   USB2.0 */
+static struct wde_quota_t wde_qt31 = {
+	338, /* hif */
+	6, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	40, /* cpu_io */
+};
+
+/*8851E   USB2.0 */
+static struct wde_quota_t wde_qt32 = {
+	156, /* hif */
+	2, /* wcpu */
+	0, /* dcpu */
+	0, /* pkt_in */
+	8, /* cpu_io */
+};
+
+/* PCIE DBCC */
+static struct ple_quota_t ple_qt0 = {
+	264, /* cmac0_tx */
+	66, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	26, /* wcpu */
+	13, /* mpdu_proc */
+	356, /* cmac0_dma */
+	94, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE DBCC */
+static struct ple_quota_t ple_qt1 = {
+	264, /* cmac0_tx */
+	66, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	64, /* wcpu */
+	13, /* mpdu_proc */
+	941, /* cmac0_dma */
+	679, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	240, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* SDIO */
+static struct ple_quota_t ple_qt2 = {
+	1536, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	13, /* wcpu */
+	26, /* mpdu_proc */
+	360, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* SDIO */
+static struct ple_quota_t ple_qt3 = {
+	1536, /* cmac0_tx */
+	0, /* cmac1_tx */
+	1149, /* c2h */
+	20, /* h2c */
+	64, /* wcpu */
+	1159, /* mpdu_proc */
+	1493, /* cmac0_dma */
+	0, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	120, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE SCC */
+static struct ple_quota_t ple_qt4 = {
+	264, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	26, /* wcpu */
+	13, /* mpdu_proc */
+	356, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE SCC */
+static struct ple_quota_t ple_qt5 = {
+	264, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	64, /* wcpu */
+	13, /* mpdu_proc */
+	1101, /* cmac0_dma */
+	0, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	120, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* SDIO */
+static struct ple_quota_t ple_qt6 = {
+	2048, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	26, /* wcpu */
+	26, /* mpdu_proc */
+	360, /* cmac0_dma */
+	94, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* SDIO */
+static struct ple_quota_t ple_qt7 = {
+	2048, /* cmac0_tx */
+	0, /* cmac1_tx */
+	530, /* c2h */
+	20, /* h2c */
+	64, /* wcpu */
+	540, /* mpdu_proc */
+	874, /* cmac0_dma */
+	608, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	240, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE STF SCC */
+static struct ple_quota_t ple_qt8 = {
+	1536, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	13, /* wcpu */
+	13, /* mpdu_proc */
+	356, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE STF SCC */
+static struct ple_quota_t ple_qt9 = {
+	2686, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	64, /* wcpu */
+	13, /* mpdu_proc */
+	1506, /* cmac0_dma */
+	0, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	120, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE STF DBCC */
+static struct ple_quota_t ple_qt10 = {
+	2272, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	26, /* wcpu */
+	13, /* mpdu_proc */
+	356, /* cmac0_dma */
+	94, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE STF DBCC */
+static struct ple_quota_t ple_qt11 = {
+	2579, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	64, /* wcpu */
+	13, /* mpdu_proc */
+	663, /* cmac0_dma */
+	401, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	240, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE SU TP */
+static struct ple_quota_t ple_qt12 = {
+	66, /* cmac0_tx */
+	66, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	26, /* wcpu */
+	13, /* mpdu_proc */
+	25, /* cmac0_dma */
+	25, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* DLFW */
+static struct ple_quota_t ple_qt13 = {
+	0, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	0, /* wcpu */
+	0, /* mpdu_proc */
+	0, /* cmac0_dma */
+	0, /* cma1_dma */
+	0, /* bb_rpt */
+	0, /* wd_rel */
+	0, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE BCN TEST */
+static struct ple_quota_t ple_qt14 = {
+	588, /* cmac0_tx */
+	147, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	26, /* wcpu */
+	26, /* mpdu_proc */
+	356, /* cmac0_dma */
+	89, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	80, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE BCN TEST */
+static struct ple_quota_t ple_qt15 = {
+	688, /* cmac0_tx */
+	247, /* cmac1_tx */
+	116, /* c2h */
+	20, /* h2c */
+	64, /* wcpu */
+	126, /* mpdu_proc */
+	456, /* cmac0_dma */
+	189, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	80, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB DBCC */
+static struct ple_quota_t ple_qt16 = {
+	2048, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	26, /* wcpu */
+	13, /* mpdu_proc */
+	360, /* cmac0_dma */
+	94, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB DBCC */
+static struct ple_quota_t ple_qt17 = {
+	2048, /* cmac0_tx */
+	0, /* cmac1_tx */
+	515, /* c2h */
+	48, /* h2c */
+	64, /* wcpu */
+	13, /* mpdu_proc */
+	859, /* cmac0_dma */
+	593, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	240, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE 64 */
+static struct ple_quota_t ple_qt18 = {
+	147, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	17, /* wcpu */
+	13, /* mpdu_proc */
+	89, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE 64 */
+static struct ple_quota_t ple_qt19 = {
+	147, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	580, /* wcpu */
+	13, /* mpdu_proc */
+	745, /* cmac0_dma */
+	0, /* cma1_dma */
+	599, /* bb_rpt */
+	14, /* wd_rel */
+	24, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE STF */
+static struct ple_quota_t ple_qt20 = {
+	962, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	88, /* wcpu */
+	13, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE STF */
+static struct ple_quota_t ple_qt21 = {
+	1023, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	149, /* wcpu */
+	13, /* mpdu_proc */
+	239, /* cmac0_dma */
+	0, /* cma1_dma */
+	93, /* bb_rpt */
+	14, /* wd_rel */
+	24, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE 128 */
+static struct ple_quota_t ple_qt22 = {
+	269, /* cmac0_tx */
+	0, /* cmac1_tx */
+	18, /* c2h */
+	20, /* h2c */
+	15, /* wcpu */
+	28, /* mpdu_proc */
+	180, /* cmac0_dma */
+	0, /* cma1_dma */
+	34, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* LA PCIE 8852A*/
+static struct ple_quota_t ple_qt23 = {
+	104, /* cmac0_tx */
+	26, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	26, /* wcpu */
+	13, /* mpdu_proc */
+	356, /* cmac0_dma */
+	94, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* LA PCIE 8852A*/
+static struct ple_quota_t ple_qt24 = {
+	104, /* cmac0_tx */
+	26, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	64, /* wcpu */
+	13, /* mpdu_proc */
+	437, /* cmac0_dma */
+	175, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	89, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB SCC */
+static struct ple_quota_t ple_qt25 = {
+	1536, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	13, /* wcpu */
+	13, /* mpdu_proc */
+	360, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB SCC */
+static struct ple_quota_t ple_qt26 = {
+	1536, /* cmac0_tx */
+	0, /* cmac1_tx */
+	1134, /* c2h */
+	48, /* h2c */
+	64, /* wcpu */
+	13, /* mpdu_proc */
+	1478, /* cmac0_dma */
+	0, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	120, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB3.0 52B TURBO */
+static struct ple_quota_t ple_qt27 = {
+	1040, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	4, /* wcpu */
+	13, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB3.0 52B TURBO*/
+static struct ple_quota_t ple_qt28 = {
+	1040, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	48, /* h2c */
+	37, /* wcpu */
+	13, /* mpdu_proc */
+	211, /* cmac0_dma */
+	0, /* cma1_dma */
+	65, /* bb_rpt */
+	14, /* wd_rel */
+	24, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE SU TP */
+static struct ple_quota_t ple_qt29 = {
+	66, /* cmac0_tx */
+	66, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	64, /* wcpu */
+	13, /* mpdu_proc */
+	1224, /* cmac0_dma */
+	1224, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	240, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE LA */
+static struct ple_quota_t ple_qt30 = {
+	51, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	13, /* wcpu */
+	13, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE LA */
+static struct ple_quota_t ple_qt31 = {
+	74, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	36, /* wcpu */
+	13, /* mpdu_proc */
+	201, /* cmac0_dma */
+	0, /* cma1_dma */
+	55, /* bb_rpt */
+	14, /* wd_rel */
+	24, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* LA SDIO 8852A*/
+static struct ple_quota_t ple_qt32 = {
+	500, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	26, /* wcpu */
+	26, /* mpdu_proc */
+	360, /* cmac0_dma */
+	94, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* LA SDIO 8852A*/
+static struct ple_quota_t ple_qt33 = {
+	500, /* cmac0_tx */
+	0, /* cmac1_tx */
+	222, /* c2h */
+	20, /* h2c */
+	64, /* wcpu */
+	232, /* mpdu_proc */
+	566, /* cmac0_dma */
+	300, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	214, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* SDIO SCC */
+static struct ple_quota_t ple_qt34 = {
+	320, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	16, /* h2c */
+	26, /* wcpu */
+	0, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	16, /* bb_rpt */
+	1, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* SDIO SCC */
+static struct ple_quota_t ple_qt35 = {
+	320, /* cmac0_tx */
+	0, /* cmac1_tx */
+	123, /* c2h */
+	16, /* h2c */
+	133, /* wcpu */
+	0, /* mpdu_proc */
+	285, /* cmac0_dma */
+	0, /* cma1_dma */
+	123, /* bb_rpt */
+	1, /* wd_rel */
+	24, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* SDIO LA */
+static struct ple_quota_t ple_qt36 = {
+	86, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	52, /* wcpu */
+	26, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* SDIO LA */
+static struct ple_quota_t ple_qt37 = {
+	86, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	52, /* wcpu */
+	26, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* LA USB 8852A*/
+static struct ple_quota_t ple_qt38 = {
+	512, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	60, /* h2c */
+	26, /* wcpu */
+	13, /* mpdu_proc */
+	360, /* cmac0_dma */
+	94, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* LA USB 8852A*/
+static struct ple_quota_t ple_qt39 = {
+	512, /* cmac0_tx */
+	0, /* cmac1_tx */
+	184, /* c2h */
+	60, /* h2c */
+	64, /* wcpu */
+	13, /* mpdu_proc */
+	527, /* cmac0_dma */
+	261, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	175, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* LA USB 8852B*/
+static struct ple_quota_t ple_qt40 = {
+	130, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	52, /* wcpu */
+	13, /* mpdu_proc */
+	66, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* LA USB 8852B*/
+static struct ple_quota_t ple_qt41 = {
+	175, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	48, /* h2c */
+	97, /* wcpu */
+	13, /* mpdu_proc */
+	111, /* cmac0_dma */
+	0, /* cma1_dma */
+	77, /* bb_rpt */
+	14, /* wd_rel */
+	24, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB 52C USB3.0*/
+static struct ple_quota_t ple_qt42 = {
+	1068, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	4, /* wcpu */
+	13, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	16, /* bb_rpt */
+	1, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB 52C USB3.0*/
+static struct ple_quota_t ple_qt43 = {
+	3068, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	48, /* h2c */
+	4, /* wcpu */
+	13, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	16, /* bb_rpt */
+	1, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* DLFW 8852C & 8192XB & 1115E */
+static struct ple_quota_t ple_qt44 = {
+	0, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	256, /* h2c */
+	0, /* wcpu */
+	0, /* mpdu_proc */
+	0, /* cmac0_dma */
+	0, /* cma1_dma */
+	0, /* bb_rpt */
+	0, /* wd_rel */
+	0, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* DLFW 8852C & 8192XB & 1115E */
+static struct ple_quota_t ple_qt45 = {
+	0, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	256, /* h2c */
+	0, /* wcpu */
+	0, /* mpdu_proc */
+	0, /* cmac0_dma */
+	0, /* cma1_dma */
+	0, /* bb_rpt */
+	0, /* wd_rel */
+	0, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+#ifdef PHL_FEATURE_AP
+/* 8852C PCIE SCC PLE 256 */
+static struct ple_quota_t ple_qt46 = {
+	100, /* cmac0_tx */
+	0, /* cmac1_tx */
+	8, /* c2h */
+	10, /* h2c */
+	7, /* wcpu */
+	7, /* mpdu_proc */
+	90, /* cmac0_dma */
+	0, /* cma1_dma */
+	16, /* bb_rpt */
+	31, /* wd_rel */
+	4, /* cpu_io */
+	8, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* 8852C PCIE SCC PLE 256 */
+static struct ple_quota_t ple_qt47 = {
+	771, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	10, /* h2c */
+	678, /* wcpu */
+	7, /* mpdu_proc */
+	761, /* cmac0_dma */
+	0, /* cma1_dma */
+	687, /* bb_rpt */
+	31, /* wd_rel */
+	80, /* cpu_io */
+	679, /* tx_rpt */
+	0, /* h2d */
+};
+#else
+/* 8852C PCIE SCC */
+static struct ple_quota_t ple_qt46 = {
+	525, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	13, /* wcpu */
+	13, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	62, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* 8852C PCIE SCC */
+static struct ple_quota_t ple_qt47 = {
+	525, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	1034, /* wcpu */
+	13, /* mpdu_proc */
+	1199, /* cmac0_dma */
+	0, /* cma1_dma */
+	1053, /* bb_rpt */
+	62, /* wd_rel */
+	160, /* cpu_io */
+	1037, /* tx_rpt */
+	0, /* h2d */
+};
+#endif
+
+/* 8852C PCIE DBCC */
+static struct ple_quota_t ple_qt48 = {
+	525, /* cmac0_tx */
+	200, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	13, /* wcpu */
+	13, /* mpdu_proc */
+	178, /* cmac0_dma */
+	178, /* cma1_dma */
+	32, /* bb_rpt */
+	62, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* 8852C PCIE DBCC */
+static struct ple_quota_t ple_qt49 = {
+	525, /* cmac0_tx */
+	200, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	656, /* wcpu */
+	13, /* mpdu_proc */
+	821, /* cmac0_dma */
+	821, /* cma1_dma */
+	675, /* bb_rpt */
+	62, /* wd_rel */
+	160, /* cpu_io */
+	659, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* 8852C PCIE SCC STF */
+static struct ple_quota_t ple_qt50 = {
+	1248, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	13, /* wcpu */
+	13, /* mpdu_proc */
+	130, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	38, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* 8852C PCIE SCC STF */
+static struct ple_quota_t ple_qt51 = {
+	3154, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	1919, /* wcpu */
+	13, /* mpdu_proc */
+	2036, /* cmac0_dma */
+	0, /* cma1_dma */
+	1938, /* bb_rpt */
+	38, /* wd_rel */
+	40, /* cpu_io */
+	1922, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* 8852C PCIE DBCC STF */
+static struct ple_quota_t ple_qt52 = {
+	1664, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	13, /* wcpu */
+	13, /* mpdu_proc */
+	130, /* cmac0_dma */
+	130, /* cma1_dma */
+	32, /* bb_rpt */
+	38, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* 8852C PCIE DBCC STF */
+static struct ple_quota_t ple_qt53 = {
+	3024, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	1373, /* wcpu */
+	13, /* mpdu_proc */
+	1490, /* cmac0_dma */
+	1490, /* cma1_dma */
+	1392, /* bb_rpt */
+	38, /* wd_rel */
+	160, /* cpu_io */
+	1376, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* 8852C PCIE LA */
+static struct ple_quota_t ple_qt54 = {
+	300, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	13, /* wcpu */
+	13, /* mpdu_proc */
+	356, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	62, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* 8852C PCIE LA */
+static struct ple_quota_t ple_qt55 = {
+	300, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	1081, /* wcpu */
+	13, /* mpdu_proc */
+	1424, /* cmac0_dma */
+	0, /* cma1_dma */
+	1100, /* bb_rpt */
+	62, /* wd_rel */
+	160, /* cpu_io */
+	1084, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* 8852B PCIE AB */
+static struct ple_quota_t ple_qt56 = {
+	147, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	68, /* wcpu */
+	13, /* mpdu_proc */
+	233, /* cmac0_dma */
+	0, /* cma1_dma */
+	87, /* bb_rpt */
+	14, /* wd_rel */
+	24, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE SCC TURBO */
+static struct ple_quota_t ple_qt57 = {
+	147, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	13, /* wcpu */
+	13, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* PCIE 64 */
+static struct ple_quota_t ple_qt58 = {
+	147, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	157, /* wcpu */
+	13, /* mpdu_proc */
+	229, /* cmac0_dma */
+	0, /* cma1_dma */
+	172, /* bb_rpt */
+	14, /* wd_rel */
+	24, /* cpu_io */
+	0, /* tx_rpt */
+};
+
+/* USB2.0 52B TURBO */
+static struct ple_quota_t ple_qt61 = {
+	858, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	4, /* wcpu */
+	13, /* mpdu_proc */
+	370, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB2.0 52B TURBO*/
+static struct ple_quota_t ple_qt62 = {
+	858, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	48, /* h2c */
+	37, /* wcpu */
+	13, /* mpdu_proc */
+	403, /* cmac0_dma */
+	0, /* cma1_dma */
+	65, /* bb_rpt */
+	14, /* wd_rel */
+	24, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* 8852AU ccv */
+static struct ple_quota_t ple_qt63 = {
+	2654, /* cmac0_tx */
+	0, /* cmac1_tx */
+	1134, /* c2h */
+	48, /* h2c */
+	64, /* wcpu */
+	13, /* mpdu_proc */
+	1478, /* cmac0_dma */
+	0, /* cma1_dma */
+	64, /* bb_rpt */
+	128, /* wd_rel */
+	120, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/*8852C USB DBCC USB2.0*/
+static struct ple_quota_t ple_qt64 = {
+	442, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	13, /* wcpu */
+	14, /* mpdu_proc */
+	390, /* cmac0_dma */
+	390, /* cma1_dma */
+	32, /* bb_rpt */
+	38, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/*8852C USB DBCC USB2.0*/
+static struct ple_quota_t ple_qt65 = {
+	442, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	48, /* h2c */
+	1953, /* wcpu */
+	14, /* mpdu_proc */
+	2330, /* cmac0_dma */
+	2330, /* cma1_dma */
+	1972, /* bb_rpt */
+	38, /* wd_rel */
+	120, /* cpu_io */
+	1956, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* SDIO SCC TURBO */
+static struct ple_quota_t ple_qt66 = {
+	836, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	16, /* h2c */
+	26, /* wcpu */
+	0, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	16, /* bb_rpt */
+	1, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* SDIO SCC TURBO */
+static struct ple_quota_t ple_qt67 = {
+	836, /* cmac0_tx */
+	0, /* cmac1_tx */
+	375, /* c2h */
+	16, /* h2c */
+	385, /* wcpu */
+	0, /* mpdu_proc */
+	537, /* cmac0_dma */
+	0, /* cma1_dma */
+	375, /* bb_rpt */
+	1, /* wd_rel */
+	24, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* LA PCIE 8852C modified*/
+static struct ple_quota_t ple_qt68 = {
+	104, /* cmac0_tx */
+	26, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	26, /* wcpu */
+	13, /* mpdu_proc */
+	356, /* cmac0_dma */
+	94, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* LA PCIE 8852C modified*/
+static struct ple_quota_t ple_qt69 = {
+	104, /* cmac0_tx */
+	26, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	64, /* wcpu */
+	13, /* mpdu_proc */
+	421, /* cmac0_dma */
+	159, /* cma1_dma */
+	64, /* bb_rpt */
+	105, /* wd_rel */
+	73, /* cpu_io */
+	81, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* 1115E PCIE DBCC */
+static struct ple_quota_t ple_qt70 = {
+	501, /* cmac0_tx */
+	901, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	13, /* wcpu */
+	13, /* mpdu_proc */
+	300, /* cmac0_dma */
+	600, /* cma1_dma */
+	32, /* bb_rpt */
+	62, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	13, /* h2d */
+};
+
+/* 1115E PCIE DBCC */
+static struct ple_quota_t ple_qt71 = {
+	501, /* cmac0_tx */
+	901, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	190, /* wcpu */
+	13, /* mpdu_proc */
+	477, /* cmac0_dma */
+	777, /* cma1_dma */
+	209, /* bb_rpt */
+	62, /* wd_rel */
+	128, /* cpu_io */
+	193, /* tx_rpt */
+	190, /* h2d */
+};
+
+/* USB2.0 52B SCC*/
+static struct ple_quota_t ple_qt72 = {
+	130, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	4, /* wcpu */
+	13, /* mpdu_proc */
+	322, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB2.0 52B 92K*/
+static struct ple_quota_t ple_qt73 = {
+	130, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	48, /* h2c */
+	37, /* wcpu */
+	13, /* mpdu_proc */
+	355, /* cmac0_dma */
+	0, /* cma1_dma */
+	65, /* bb_rpt */
+	14, /* wd_rel */
+	24, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB3.0 52B 92K*/
+static struct ple_quota_t ple_qt74 = {
+	286, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	4, /* wcpu */
+	13, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB3.0 52B 92K*/
+static struct ple_quota_t ple_qt75 = {
+	286, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	48, /* h2c */
+	37, /* wcpu */
+	13, /* mpdu_proc */
+	211, /* cmac0_dma */
+	0, /* cma1_dma */
+	65, /* bb_rpt */
+	14, /* wd_rel */
+	24, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* LA PCIE 8192XB modified*/
+static struct ple_quota_t ple_qt76 = {
+	104, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	20, /* h2c */
+	26, /* wcpu */
+	13, /* mpdu_proc */
+	356, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	40, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* LA PCIE 8192XB modified*/
+static struct ple_quota_t ple_qt77 = {
+	104, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	20, /* h2c */
+	64, /* wcpu */
+	13, /* mpdu_proc */
+	541, /* cmac0_dma */
+	0, /* cma1_dma */
+	64, /* bb_rpt */
+	105, /* wd_rel */
+	193, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB2.0 52C */
+static struct ple_quota_t ple_qt78 = {
+	1560, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	13, /* wcpu */
+	13, /* mpdu_proc */
+	390, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	38, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB2.0 52C */
+static struct ple_quota_t ple_qt79 = {
+	1560, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	48, /* h2c */
+	1253, /* wcpu */
+	13, /* mpdu_proc */
+	1630, /* cmac0_dma */
+	0, /* cma1_dma */
+	1272, /* bb_rpt */
+	38, /* wd_rel */
+	120, /* cpu_io */
+	1256, /* tx_rpt */
+	0, /* h2d */
+};
+
+/*8852C USB DBCC USB3.0*/
+static struct ple_quota_t ple_qt80 = {
+	1112, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	13, /* wcpu */
+	13, /* mpdu_proc */
+	390, /* cmac0_dma */
+	390, /* cma1_dma */
+	32, /* bb_rpt */
+	38, /* wd_rel */
+	8, /* cpu_io */
+	16, /* tx_rpt */
+	0, /* h2d */
+};
+
+/*8852C USB DBCC USB3.0*/
+static struct ple_quota_t ple_qt81 = {
+	2392, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	48, /* h2c */
+	1313, /* wcpu */
+	13, /* mpdu_proc */
+	390, /* cmac0_dma */
+	390, /* cma1_dma */
+	1332, /* bb_rpt */
+	38, /* wd_rel */
+	120, /* cpu_io */
+	1316, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB2.0 8851E */
+static struct ple_quota_t ple_qt82 = {
+	1040, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	4, /* wcpu */
+	13, /* mpdu_proc */
+	178, /* cmac0_dma */
+	0, /* cma1_dma */
+	32, /* bb_rpt */
+	14, /* wd_rel */
+	8, /* cpu_io */
+	8, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* USB2.0 8851E */
+static struct ple_quota_t ple_qt83 = {
+	1065, /* cmac0_tx */
+	0, /* cmac1_tx */
+	32, /* c2h */
+	48, /* h2c */
+	29, /* wcpu */
+	13, /* mpdu_proc */
+	203, /* cmac0_dma */
+	0, /* cma1_dma */
+	57, /* bb_rpt */
+	14, /* wd_rel */
+	24, /* cpu_io */
+	33, /* tx_rpt */
+	0, /* h2d */
+};
+
+/* DLFW 8851E */
+static struct ple_quota_t ple_qt84 = {
+	0, /* cmac0_tx */
+	0, /* cmac1_tx */
+	16, /* c2h */
+	48, /* h2c */
+	0, /* wcpu */
+	0, /* mpdu_proc */
+	0, /* cmac0_dma */
+	0, /* cma1_dma */
+	0, /* bb_rpt */
+	0, /* wd_rel */
+	0, /* cpu_io */
+	0, /* tx_rpt */
+	0, /* h2d */
+};
+
+#if MAC_AX_PCIE_SUPPORT
+static struct dle_mem_t dle_mem_pcie_8852a[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size0, &ple_size0, /* wde_size, ple_size */
+	 &wde_qt0, &wde_qt0, /* wde_min_qt, wde_max_qt */
+	 &ple_qt4, &ple_qt5}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size0, &ple_size0, /* wde_size, ple_size */
+	 &wde_qt0, &wde_qt0, /* wde_min_qt, wde_max_qt */
+	 &ple_qt0, &ple_qt1}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_SCC_STF, /* qta_mode */
+	 &wde_size1, &ple_size2, /* wde_size, ple_size */
+	 &wde_qt1, &wde_qt1, /* wde_min_qt, wde_max_qt */
+	 &ple_qt8, &ple_qt9}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC_STF, /* qta_mode */
+	 &wde_size1, &ple_size2, /* wde_size, ple_size */
+	 &wde_qt1, &wde_qt1, /* wde_min_qt, wde_max_qt */
+	 &ple_qt10, &ple_qt11}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_SU_TP, /* qta_mode */
+	 &wde_size3, &ple_size3, /* wde_size, ple_size */
+	 &wde_qt3, &wde_qt3, /* wde_min_qt, wde_max_qt */
+	 &ple_qt12, &ple_qt29}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size4, &ple_size4, /* wde_size, ple_size */
+	 &wde_qt4, &wde_qt4, /* wde_min_qt, wde_max_qt */
+	 &ple_qt13, &ple_qt13}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size10, &ple_size10, /* wde_size, ple_size */
+	 &wde_qt9, &wde_qt9, /* wde_min_qt, wde_max_qt */
+	 &ple_qt23, &ple_qt24}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_pcie_8852b[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size7, &ple_size6, /* wde_size, ple_size */
+	 &wde_qt7, &wde_qt7, /* wde_min_qt, wde_max_qt */
+	 &ple_qt18, &ple_qt58}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_SCC_TURBO, /* qta_mode */
+	 &wde_size23, &ple_size24, /* wde_size, ple_size */
+	 &wde_qt23, &wde_qt23, /* wde_min_qt, wde_max_qt */
+	 &ple_qt57, &ple_qt19}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_SCC_STF, /* qta_mode */
+	 &wde_size8, &ple_size7, /* wde_size, ple_size */
+	 &wde_qt8, &wde_qt8, /* wde_min_qt, wde_max_qt */
+	 &ple_qt20, &ple_qt21}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size9, &ple_size8, /* wde_size, ple_size */
+	 &wde_qt4, &wde_qt4, /* wde_min_qt, wde_max_qt */
+	 &ple_qt13, &ple_qt13}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size11, &ple_size11, /* wde_size, ple_size */
+	 &wde_qt10, &wde_qt10, /* wde_min_qt, wde_max_qt */
+	 &ple_qt30, &ple_qt31}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_pcie_8852c[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size19, &ple_size19, /* wde_size, ple_size */
+	 &wde_qt18, &wde_qt18, /* wde_min_qt, wde_max_qt */
+	 &ple_qt46, &ple_qt47}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size20, &ple_size20, /* wde_size, ple_size */
+	 &wde_qt19, &wde_qt19, /* wde_min_qt, wde_max_qt */
+	 &ple_qt48, &ple_qt49}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_SCC_STF, /* qta_mode */
+	 &wde_size21, &ple_size21, /* wde_size, ple_size */
+	 &wde_qt20, &wde_qt20, /* wde_min_qt, wde_max_qt */
+	 &ple_qt50, &ple_qt51}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC_STF, /* qta_mode */
+	 &wde_size21, &ple_size21, /* wde_size, ple_size */
+	 &wde_qt21, &wde_qt21, /* wde_min_qt, wde_max_qt */
+	 &ple_qt52, &ple_qt53}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size18, &ple_size18, /* wde_size, ple_size */
+	 &wde_qt17, &wde_qt17, /* wde_min_qt, wde_max_qt */
+	 &ple_qt44, &ple_qt45}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size10, &ple_size10, /* wde_size, ple_size */
+	 &wde_qt9, &wde_qt9, /* wde_min_qt, wde_max_qt */
+	 &ple_qt68, &ple_qt69}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_pcie_8192xb[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size19, &ple_size19, /* wde_size, ple_size */
+	 &wde_qt18, &wde_qt18, /* wde_min_qt, wde_max_qt */
+	 &ple_qt46, &ple_qt47}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_SCC_STF, /* qta_mode */
+	 &wde_size21, &ple_size21, /* wde_size, ple_size */
+	 &wde_qt20, &wde_qt20, /* wde_min_qt, wde_max_qt */
+	 &ple_qt50, &ple_qt51}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size18, &ple_size18, /* wde_size, ple_size */
+	 &wde_qt17, &wde_qt17, /* wde_min_qt, wde_max_qt */
+	 &ple_qt44, &ple_qt45}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size10, &ple_size10, /* wde_size, ple_size */
+	 &wde_qt9, &wde_qt9, /* wde_min_qt, wde_max_qt */
+	 &ple_qt76, &ple_qt77}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_pcie_8851b[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size6, &ple_size6, /* wde_size, ple_size */
+	 &wde_qt6, &wde_qt6, /* wde_min_qt, wde_max_qt */
+	 &ple_qt18, &ple_qt58}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_SCC_TURBO, /* qta_mode */
+	 &wde_size23, &ple_size24, /* wde_size, ple_size */
+	 &wde_qt23, &wde_qt23, /* wde_min_qt, wde_max_qt */
+	 &ple_qt57, &ple_qt19}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_SCC_STF, /* qta_mode */
+	 &wde_size8, &ple_size7, /* wde_size, ple_size */
+	 &wde_qt8, &wde_qt8, /* wde_min_qt, wde_max_qt */
+	 &ple_qt20, &ple_qt21}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size9, &ple_size8, /* wde_size, ple_size */
+	 &wde_qt4, &wde_qt4, /* wde_min_qt, wde_max_qt */
+	 &ple_qt13, &ple_qt13}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size11, &ple_size11, /* wde_size, ple_size */
+	 &wde_qt10, &wde_qt10, /* wde_min_qt, wde_max_qt */
+	 &ple_qt30, &ple_qt31}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_pcie_8851e[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size19, &ple_size19, /* wde_size, ple_size */
+	 &wde_qt18, &wde_qt18, /* wde_min_qt, wde_max_qt */
+	 &ple_qt46, &ple_qt47}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size20, &ple_size20, /* wde_size, ple_size */
+	 &wde_qt19, &wde_qt19, /* wde_min_qt, wde_max_qt */
+	 &ple_qt48, &ple_qt49}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_SCC_STF, /* qta_mode */
+	 &wde_size21, &ple_size21, /* wde_size, ple_size */
+	 &wde_qt20, &wde_qt20, /* wde_min_qt, wde_max_qt */
+	 &ple_qt50, &ple_qt51}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC_STF, /* qta_mode */
+	 &wde_size21, &ple_size21, /* wde_size, ple_size */
+	 &wde_qt21, &wde_qt21, /* wde_min_qt, wde_max_qt */
+	 &ple_qt52, &ple_qt53}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size18, &ple_size18, /* wde_size, ple_size */
+	 &wde_qt17, &wde_qt17, /* wde_min_qt, wde_max_qt */
+	 &ple_qt44, &ple_qt45}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size10, &ple_size10, /* wde_size, ple_size */
+	 &wde_qt9, &wde_qt9, /* wde_min_qt, wde_max_qt */
+	 &ple_qt68, &ple_qt69}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_pcie_8852d[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size19, &ple_size19, /* wde_size, ple_size */
+	 &wde_qt18, &wde_qt18, /* wde_min_qt, wde_max_qt */
+	 &ple_qt46, &ple_qt47}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size20, &ple_size20, /* wde_size, ple_size */
+	 &wde_qt19, &wde_qt19, /* wde_min_qt, wde_max_qt */
+	 &ple_qt48, &ple_qt49}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_SCC_STF, /* qta_mode */
+	 &wde_size21, &ple_size21, /* wde_size, ple_size */
+	 &wde_qt20, &wde_qt20, /* wde_min_qt, wde_max_qt */
+	 &ple_qt50, &ple_qt51}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC_STF, /* qta_mode */
+	 &wde_size21, &ple_size21, /* wde_size, ple_size */
+	 &wde_qt21, &wde_qt21, /* wde_min_qt, wde_max_qt */
+	 &ple_qt52, &ple_qt53}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size18, &ple_size18, /* wde_size, ple_size */
+	 &wde_qt17, &wde_qt17, /* wde_min_qt, wde_max_qt */
+	 &ple_qt44, &ple_qt45}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size10, &ple_size10, /* wde_size, ple_size */
+	 &wde_qt9, &wde_qt9, /* wde_min_qt, wde_max_qt */
+	 &ple_qt68, &ple_qt69}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_pcie_1115e[] = {
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size28, &ple_size30, /* wde_size, ple_size */
+	 &wde_qt28, &wde_qt28, /* wde_min_qt, wde_max_qt */
+	 &ple_qt70, &ple_qt71}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size28, &ple_size30, /* wde_size, ple_size */
+	 &wde_qt17, &wde_qt17, /* wde_min_qt, wde_max_qt */
+	 &ple_qt44, &ple_qt45}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+#endif
+
+#if MAC_AX_USB_SUPPORT
+static struct dle_mem_t dle_mem_usb_8852a[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size1, &ple_size1, /* wde_size, ple_size */
+	 &wde_qt1, &wde_qt1, /* wde_min_qt, wde_max_qt */
+	 &ple_qt25, &ple_qt26}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size1, &ple_size1, /* wde_size, ple_size */
+	 &wde_qt1, &wde_qt1, /* wde_min_qt, wde_max_qt */
+	 &ple_qt16, &ple_qt17}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size4, &ple_size4, /* wde_size, ple_size */
+	 &wde_qt4, &wde_qt4, /* wde_min_qt, wde_max_qt */
+	 &ple_qt13, &ple_qt13}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size15, &ple_size15, /* wde_size, ple_size */
+	 &wde_qt14, &wde_qt14, /* wde_min_qt, wde_max_qt */
+	 &ple_qt38, &ple_qt39}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_usb_8852a_ccv[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size26, &ple_size1, /* wde_size, ple_size */
+	 &wde_qt26, &wde_qt26, /* wde_min_qt, wde_max_qt */
+	 &ple_qt25, &ple_qt63}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size1, &ple_size1, /* wde_size, ple_size */
+	 &wde_qt1, &wde_qt1, /* wde_min_qt, wde_max_qt */
+	 &ple_qt16, &ple_qt17}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size4, &ple_size4, /* wde_size, ple_size */
+	 &wde_qt4, &wde_qt4, /* wde_min_qt, wde_max_qt */
+	 &ple_qt13, &ple_qt13}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size15, &ple_size15, /* wde_size, ple_size */
+	 &wde_qt14, &wde_qt14, /* wde_min_qt, wde_max_qt */
+	 &ple_qt38, &ple_qt39}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_usb2_8852b[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size25, &ple_size32, /* wde_size, ple_size */
+	 &wde_qt25, &wde_qt25, /* wde_min_qt, wde_max_qt */
+	 &ple_qt72, &ple_qt73}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size9, &ple_size8, /* wde_size, ple_size */
+	 &wde_qt4, &wde_qt4, /* wde_min_qt, wde_max_qt */
+	 &ple_qt13, &ple_qt13}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size16, &ple_size16, /* wde_size, ple_size */
+	 &wde_qt15, &wde_qt15, /* wde_min_qt, wde_max_qt */
+	 &ple_qt40, &ple_qt41}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_SCC_TURBO, /* qta_mode */
+	 &wde_size30, &ple_size31, /* wde_size, ple_size */
+	 &wde_qt30, &wde_qt30, /* wde_min_qt, wde_max_qt */
+	 &ple_qt27, &ple_qt28}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_usb3_8852b[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size25, &ple_size33, /* wde_size, ple_size */
+	 &wde_qt25, &wde_qt25, /* wde_min_qt, wde_max_qt */
+	 &ple_qt74, &ple_qt75}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size9, &ple_size8, /* wde_size, ple_size */
+	 &wde_qt4, &wde_qt4, /* wde_min_qt, wde_max_qt */
+	 &ple_qt13, &ple_qt13}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size16, &ple_size16, /* wde_size, ple_size */
+	 &wde_qt15, &wde_qt15, /* wde_min_qt, wde_max_qt */
+	 &ple_qt40, &ple_qt41}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_SCC_TURBO, /* qta_mode */
+	 &wde_size30, &ple_size31, /* wde_size, ple_size */
+	 &wde_qt30, &wde_qt30, /* wde_min_qt, wde_max_qt */
+	 &ple_qt27, &ple_qt28}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_usb2_8852c[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size31, &ple_size34, /* wde_size, ple_size */
+	 &wde_qt31, &wde_qt31, /* wde_min_qt, wde_max_qt */
+	 &ple_qt78, &ple_qt79}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size27, &ple_size28, /* wde_size, ple_size */
+	 &wde_qt27, &wde_qt27, /* wde_min_qt, wde_max_qt */
+	 &ple_qt64, &ple_qt65}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size18, &ple_size18, /* wde_size, ple_size */
+	 &wde_qt17, &wde_qt17, /* wde_min_qt, wde_max_qt */
+	 &ple_qt44, &ple_qt45}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size16, &ple_size16, /* wde_size, ple_size */
+	 &wde_qt15, &wde_qt15, /* wde_min_qt, wde_max_qt */
+	 &ple_qt40, &ple_qt41}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_usb3_8852c[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size17, &ple_size17, /* wde_size, ple_size */
+	 &wde_qt16, &wde_qt16, /* wde_min_qt, wde_max_qt */
+	 &ple_qt42, &ple_qt43}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size27, &ple_size35, /* wde_size, ple_size */
+	 &wde_qt27, &wde_qt27, /* wde_min_qt, wde_max_qt */
+	 &ple_qt80, &ple_qt81}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size18, &ple_size18, /* wde_size, ple_size */
+	 &wde_qt17, &wde_qt17, /* wde_min_qt, wde_max_qt */
+	 &ple_qt44, &ple_qt45}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size16, &ple_size16, /* wde_size, ple_size */
+	 &wde_qt15, &wde_qt15, /* wde_min_qt, wde_max_qt */
+	 &ple_qt40, &ple_qt41}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_usb_8192xb[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size17, &ple_size17, /* wde_size, ple_size */
+	 &wde_qt16, &wde_qt16, /* wde_min_qt, wde_max_qt */
+	 &ple_qt42, &ple_qt43}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size27, &ple_size28, /* wde_size, ple_size */
+	 &wde_qt27, &wde_qt27, /* wde_min_qt, wde_max_qt */
+	 &ple_qt64, &ple_qt65}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size18, &ple_size18, /* wde_size, ple_size */
+	 &wde_qt17, &wde_qt17, /* wde_min_qt, wde_max_qt */
+	 &ple_qt44, &ple_qt45}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size16, &ple_size16, /* wde_size, ple_size */
+	 &wde_qt15, &wde_qt15, /* wde_min_qt, wde_max_qt */
+	 &ple_qt40, &ple_qt41}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_usb2_8851b[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size25, &ple_size32, /* wde_size, ple_size */
+	 &wde_qt25, &wde_qt25, /* wde_min_qt, wde_max_qt */
+	 &ple_qt72, &ple_qt73}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size9, &ple_size8, /* wde_size, ple_size */
+	 &wde_qt4, &wde_qt4, /* wde_min_qt, wde_max_qt */
+	 &ple_qt13, &ple_qt13}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size16, &ple_size16, /* wde_size, ple_size */
+	 &wde_qt15, &wde_qt15, /* wde_min_qt, wde_max_qt */
+	 &ple_qt40, &ple_qt41}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_SCC_TURBO, /* qta_mode */
+	 &wde_size30, &ple_size27, /* wde_size, ple_size */
+	 &wde_qt30, &wde_qt30, /* wde_min_qt, wde_max_qt */
+	 &ple_qt61, &ple_qt62}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_usb3_8851b[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size25, &ple_size33, /* wde_size, ple_size */
+	 &wde_qt25, &wde_qt25, /* wde_min_qt, wde_max_qt */
+	 &ple_qt74, &ple_qt75}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size9, &ple_size8, /* wde_size, ple_size */
+	 &wde_qt4, &wde_qt4, /* wde_min_qt, wde_max_qt */
+	 &ple_qt13, &ple_qt13}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size16, &ple_size16, /* wde_size, ple_size */
+	 &wde_qt15, &wde_qt15, /* wde_min_qt, wde_max_qt */
+	 &ple_qt40, &ple_qt41}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_SCC_TURBO, /* qta_mode */
+	 &wde_size30, &ple_size31, /* wde_size, ple_size */
+	 &wde_qt30, &wde_qt30, /* wde_min_qt, wde_max_qt */
+	 &ple_qt27, &ple_qt28}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_usb2_8851e[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size32, &ple_size36, /* wde_size, ple_size */
+	 &wde_qt32, &wde_qt32, /* wde_min_qt, wde_max_qt */
+	 &ple_qt82, &ple_qt83}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size27, &ple_size28, /* wde_size, ple_size */
+	 &wde_qt27, &wde_qt27, /* wde_min_qt, wde_max_qt */
+	 &ple_qt64, &ple_qt65}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size33, &ple_size37, /* wde_size, ple_size */
+	 &wde_qt17, &wde_qt17, /* wde_min_qt, wde_max_qt */
+	 &ple_qt84, &ple_qt84}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size16, &ple_size16, /* wde_size, ple_size */
+	 &wde_qt15, &wde_qt15, /* wde_min_qt, wde_max_qt */
+	 &ple_qt40, &ple_qt41}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_usb3_8851e[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size17, &ple_size17, /* wde_size, ple_size */
+	 &wde_qt16, &wde_qt16, /* wde_min_qt, wde_max_qt */
+	 &ple_qt42, &ple_qt43}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size27, &ple_size35, /* wde_size, ple_size */
+	 &wde_qt27, &wde_qt27, /* wde_min_qt, wde_max_qt */
+	 &ple_qt80, &ple_qt81}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size18, &ple_size18, /* wde_size, ple_size */
+	 &wde_qt17, &wde_qt17, /* wde_min_qt, wde_max_qt */
+	 &ple_qt44, &ple_qt45}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size16, &ple_size16, /* wde_size, ple_size */
+	 &wde_qt15, &wde_qt15, /* wde_min_qt, wde_max_qt */
+	 &ple_qt40, &ple_qt41}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_usb2_8852d[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size31, &ple_size34, /* wde_size, ple_size */
+	 &wde_qt31, &wde_qt31, /* wde_min_qt, wde_max_qt */
+	 &ple_qt78, &ple_qt79}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size27, &ple_size28, /* wde_size, ple_size */
+	 &wde_qt27, &wde_qt27, /* wde_min_qt, wde_max_qt */
+	 &ple_qt64, &ple_qt65}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size18, &ple_size18, /* wde_size, ple_size */
+	 &wde_qt17, &wde_qt17, /* wde_min_qt, wde_max_qt */
+	 &ple_qt44, &ple_qt45}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size16, &ple_size16, /* wde_size, ple_size */
+	 &wde_qt15, &wde_qt15, /* wde_min_qt, wde_max_qt */
+	 &ple_qt40, &ple_qt41}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_usb3_8852d[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size17, &ple_size17, /* wde_size, ple_size */
+	 &wde_qt16, &wde_qt16, /* wde_min_qt, wde_max_qt */
+	 &ple_qt42, &ple_qt43}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size27, &ple_size35, /* wde_size, ple_size */
+	 &wde_qt27, &wde_qt27, /* wde_min_qt, wde_max_qt */
+	 &ple_qt80, &ple_qt81}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size18, &ple_size18, /* wde_size, ple_size */
+	 &wde_qt17, &wde_qt17, /* wde_min_qt, wde_max_qt */
+	 &ple_qt44, &ple_qt45}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size16, &ple_size16, /* wde_size, ple_size */
+	 &wde_qt15, &wde_qt15, /* wde_min_qt, wde_max_qt */
+	 &ple_qt40, &ple_qt41}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+#endif
+
+#if MAC_AX_SDIO_SUPPORT
+static struct dle_mem_t dle_mem_sdio_8852a[] = {
+	{MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size1, &ple_size1, /* wde_size, ple_size */
+	 &wde_qt1, &wde_qt1, /* wde_min_qt, wde_max_qt */
+	 &ple_qt2, &ple_qt3}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DBCC, /* qta_mode */
+	 &wde_size1, &ple_size1, /* wde_size, ple_size */
+	 &wde_qt1, &wde_qt1, /* wde_min_qt, wde_max_qt */
+	 &ple_qt6, &ple_qt7}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size4, &ple_size4, /* wde_size, ple_size */
+	 &wde_qt4, &wde_qt4, /* wde_min_qt, wde_max_qt */
+	 &ple_qt13, &ple_qt13}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size12, &ple_size12, /* wde_size, ple_size */
+	 &wde_qt11, &wde_qt11, /* wde_min_qt, wde_max_qt */
+	 &ple_qt32, &ple_qt33}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_sdio_8852b[] = {
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size9, &ple_size8, /* wde_size, ple_size */
+	 &wde_qt4, &wde_qt4, /* wde_min_qt, wde_max_qt */
+	 &ple_qt13, &ple_qt13}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size13, &ple_size13, /* wde_size, ple_size */
+	 &wde_qt12, &wde_qt12, /* wde_min_qt, wde_max_qt */
+	 &ple_qt34, &ple_qt35}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_SCC_TURBO, /* qta_mode */
+	 &wde_size13, &ple_size29, /* wde_size, ple_size */
+	 &wde_qt12, &wde_qt12, /* wde_min_qt, wde_max_qt */
+	 &ple_qt66, &ple_qt67}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size14, &ple_size14, /* wde_size, ple_size */
+	 &wde_qt13, &wde_qt13, /* wde_min_qt, wde_max_qt */
+	 &ple_qt36, &ple_qt37}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+
+static struct dle_mem_t dle_mem_sdio_8851b[] = {
+	{MAC_AX_QTA_DLFW, /* qta_mode */
+	 &wde_size9, &ple_size8, /* wde_size, ple_size */
+	 &wde_qt4, &wde_qt4, /* wde_min_qt, wde_max_qt */
+	 &ple_qt13, &ple_qt13}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_SCC, /* qta_mode */
+	 &wde_size13, &ple_size13, /* wde_size, ple_size */
+	 &wde_qt12, &wde_qt12, /* wde_min_qt, wde_max_qt */
+	 &ple_qt34, &ple_qt35}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_SCC_TURBO, /* qta_mode */
+	 &wde_size13, &ple_size29, /* wde_size, ple_size */
+	 &wde_qt12, &wde_qt12, /* wde_min_qt, wde_max_qt */
+	 &ple_qt66, &ple_qt67}, /* ple_min_qt, ple_max_qt */
+	 {MAC_AX_QTA_LAMODE, /* qta_mode */
+	 &wde_size14, &ple_size14, /* wde_size, ple_size */
+	 &wde_qt13, &wde_qt13, /* wde_min_qt, wde_max_qt */
+	 &ple_qt36, &ple_qt37}, /* ple_min_qt, ple_max_qt */
+	{MAC_AX_QTA_INVALID, NULL, NULL, NULL, NULL, NULL, NULL},
+};
+#endif
+
+static u32 dle_rsvd_size(struct mac_ax_adapter *adapter, enum mac_ax_qta_mode mode);
+static u32 h2c_dle_qta_change(struct mac_ax_adapter *adapter);
+
+u32 dle_dfi_freepg(struct mac_ax_adapter *adapter,
+		   struct dle_dfi_freepg_t *freepg)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct dle_dfi_ctrl_t ctrl;
+	u32 ret;
+
+	ctrl.type = freepg->dle_type;
+	ctrl.target = DLE_DFI_TYPE_FREEPG;
+	ctrl.addr = DFI_TYPE_FREEPG_IDX;
+	ret = p_ops->dle_dfi_ctrl(adapter, &ctrl);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dle_dfi_ctrl %d\n", ret);
+		return ret;
+	}
+	freepg->free_headpg = ctrl.u.freepg.free_headpg;
+	freepg->free_tailpg = ctrl.u.freepg.free_tailpg;
+
+	ctrl.addr = DFI_TYPE_FREEPG_PUBNUM;
+	ret = p_ops->dle_dfi_ctrl(adapter, &ctrl);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dle_dfi_ctrl %d\n", ret);
+		return ret;
+	}
+	freepg->pub_pgnum = ctrl.u.freepg.pub_pgnum;
+
+	return MACSUCCESS;
+}
+
+u32 dle_dfi_quota(struct mac_ax_adapter *adapter,
+		  struct dle_dfi_quota_t *quota)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct dle_dfi_ctrl_t ctrl;
+	u32 ret;
+
+	ctrl.type = quota->dle_type;
+	ctrl.target = DLE_DFI_TYPE_QUOTA;
+	ctrl.addr = quota->qtaid;
+	ret = p_ops->dle_dfi_ctrl(adapter, &ctrl);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dle_dfi_ctrl %d\n", ret);
+		return ret;
+	}
+
+	quota->rsv_pgnum = ctrl.u.quota.rsv_pgnum;
+	quota->use_pgnum = ctrl.u.quota.use_pgnum;
+
+	return MACSUCCESS;
+}
+
+u32 dle_dfi_qempty(struct mac_ax_adapter *adapter,
+		   struct dle_dfi_qempty_t *qempty)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct dle_dfi_ctrl_t ctrl;
+	u32 ret;
+
+	ctrl.type = qempty->dle_type;
+	ctrl.target = DLE_DFI_TYPE_QEMPTY;
+	ctrl.addr = qempty->grpsel;
+	ret = p_ops->dle_dfi_ctrl(adapter, &ctrl);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dle_dfi_ctrl %d\n", ret);
+		return ret;
+	}
+
+	qempty->qempty = ctrl.u.qempty.qempty;
+
+	return MACSUCCESS;
+}
+
+u32 mac_chk_allq_empty(struct mac_ax_adapter *adapter, u8 *empty)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u8 chk_cnt, txq_empty, rxq_empty;
+	u32 ret;
+	*empty = 1;
+
+	for (chk_cnt = 0; chk_cnt < QUEUE_EMPTY_CHK_CNT; chk_cnt++) {
+		ret = p_ops->dle_is_txq_empty(adapter, &txq_empty);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] TXQ chk fail %d\n", ret);
+			return ret;
+		}
+
+		ret = p_ops->dle_is_rxq_empty(adapter, &rxq_empty);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] TXQ chk fail %d\n", ret);
+			return ret;
+		}
+
+		if (!(txq_empty & rxq_empty)) {
+			PLTFM_MSG_TRACE("[TRACE] CHK TXQ %d RXQ %d\n",
+					txq_empty, rxq_empty);
+			*empty = 0;
+			break;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 chk_preload_allow(struct mac_ax_adapter *adapter)
+{
+	u8 is_poh;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+	    adapter->hw_info->intf != MAC_AX_INTF_PCIE)
+		return MACHWNOSUP;
+
+	if (is_qta_poh(adapter, adapter->dle_info.qta_mode, &is_poh) != MACSUCCESS)
+		return MACFUNCINPUT;
+
+	if (!is_poh)
+		return MACHWNOSUP;
+
+	return MACSUCCESS;
+}
+
+u32 mac_preload_cfg(struct mac_ax_adapter *adapter, enum mac_ax_band band,
+		    struct mac_ax_preld_cfg *cfg)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret;
+
+	ret = chk_preload_allow(adapter);
+	if (ret == MACHWNOSUP) {
+		return MACSUCCESS;
+	} else if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]check preload allow %d\n", ret);
+		return ret;
+	}
+
+	if (cfg->hiq_en && cfg->hiq_port >= MAC_AX_PORT_NUM) {
+		PLTFM_MSG_ERR("[ERR]preload hiq p%d invalid\n", cfg->hiq_port);
+		return MACFUNCINPUT;
+	}
+
+	if (cfg->hiq_en && cfg->hiq_port == MAC_AX_PORT_0 &&
+	    cfg->hiq_mbid >= MAC_AX_P0_MBID_MAX) {
+		PLTFM_MSG_ERR("[ERR]preload hiq p0mb%d invalid\n", cfg->hiq_mbid);
+		return MACFUNCINPUT;
+	}
+
+	ret = p_ops->preload_cfg_set(adapter, band, cfg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]preload cfg set %d\n", ret);
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 preload_init(struct mac_ax_adapter *adapter, enum mac_ax_band band,
+		 enum mac_ax_qta_mode mode)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret;
+
+	ret = chk_preload_allow(adapter);
+	if (ret == MACHWNOSUP) {
+		return MACSUCCESS;
+	} else if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]check preload allow %d\n", ret);
+		return ret;
+	}
+
+	ret = p_ops->preload_init_set(adapter, band, mode);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]preload init set %d\n", ret);
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 get_dle_rsvd_info(struct mac_ax_adapter *adapter, enum DLE_RSVD_INFO *info)
+{
+	enum mac_ax_qta_mode mode = adapter->dle_info.qta_mode;
+	u32 rsvd_size;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		if (mode == MAC_AX_QTA_LAMODE)
+			*info = DLE_RSVD_INFO_LAMODE;
+		else if (mode == MAC_AX_QTA_SCC)
+			*info = DLE_RSVD_INFO_FW;
+		else
+			*info = DLE_RSVD_INFO_NONE;
+	} else {
+		if (mode == MAC_AX_QTA_LAMODE)
+			*info = DLE_RSVD_INFO_LAMODE;
+		else
+			*info = DLE_RSVD_INFO_NONE;
+	}
+
+	rsvd_size = dle_rsvd_size(adapter, mode);
+	if (rsvd_size != 0 && *info == DLE_RSVD_INFO_NONE) {
+		PLTFM_MSG_ERR("[ERR]get dle_rsvd_info %d, rsvd_size %d\n",
+			      *info, rsvd_size);
+		return MACFFCFG;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 dle_used_size(struct dle_size_t *wde, struct dle_size_t *ple)
+{
+	return (u32)(wde->pge_size * (wde->lnk_pge_num + wde->unlnk_pge_num)) +
+	       (u32)(ple->pge_size * (ple->lnk_pge_num + ple->unlnk_pge_num));
+}
+
+static u32 dle_rsvd_size(struct mac_ax_adapter *adapter, enum mac_ax_qta_mode mode)
+{
+	if (mode == MAC_AX_QTA_LAMODE) {
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A))
+			return DLE_LAMODE_SIZE_8852A;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B))
+			return DLE_LAMODE_SIZE_8852B;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C))
+			return DLE_LAMODE_SIZE_8852C;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB))
+			return DLE_LAMODE_SIZE_8192XB;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+			return DLE_LAMODE_SIZE_8851B;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E))
+			return DLE_LAMODE_SIZE_8851E;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))
+			return DLE_LAMODE_SIZE_8852D;
+		else
+			return 0;
+	} else if (mode == MAC_AX_QTA_SCC) {
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B))
+			return DLE_SCC_RSVD_SIZE_8852B;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+			return DLE_SCC_RSVD_SIZE_8851B;
+		else
+			return 0;
+	} else {
+		return 0;
+	}
+}
+
+static struct dle_mem_t *get_dle_mem_cfg(struct mac_ax_adapter *adapter,
+					 enum mac_ax_qta_mode mode)
+{
+	struct dle_mem_t *cfg;
+	enum mac_ax_intf intf = adapter->hw_info->intf;
+
+	switch (intf) {
+#if MAC_AX_SDIO_SUPPORT
+	case MAC_AX_INTF_SDIO:
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A))
+			cfg = dle_mem_sdio_8852a;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B))
+			cfg = dle_mem_sdio_8852b;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C))
+			cfg = dle_mem_sdio_8852b;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB))
+			cfg = dle_mem_sdio_8852b;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+			cfg = dle_mem_sdio_8851b;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E))
+			cfg = dle_mem_sdio_8852b;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))
+			cfg = dle_mem_sdio_8852b;
+		else
+			cfg = NULL;
+		break;
+#endif
+#if MAC_AX_USB_SUPPORT
+	case MAC_AX_INTF_USB:
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A))
+			cfg = dle_mem_usb_8852a;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) &&
+			 (get_usb_mode(adapter) == MAC_AX_USB2))
+			cfg = dle_mem_usb3_8852b;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B))
+			cfg = dle_mem_usb3_8852b;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) &&
+			 (get_usb_mode(adapter) == MAC_AX_USB2))
+			cfg = dle_mem_usb2_8852c;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C))
+			cfg = dle_mem_usb3_8852c;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB))
+			cfg = dle_mem_usb_8192xb;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) &&
+			 (get_usb_mode(adapter) == MAC_AX_USB2))
+			cfg = dle_mem_usb2_8851b;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+			cfg = dle_mem_usb3_8851b;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) &&
+			 (get_usb_mode(adapter) == MAC_AX_USB2))
+			cfg = dle_mem_usb2_8851e;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E))
+			cfg = dle_mem_usb3_8851e;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D) &&
+			 (get_usb_mode(adapter) == MAC_AX_USB2))
+			cfg = dle_mem_usb2_8852d;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))
+			cfg = dle_mem_usb3_8852d;
+		else
+			cfg = NULL;
+		break;
+#endif
+#if MAC_AX_PCIE_SUPPORT
+	case MAC_AX_INTF_PCIE:
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A))
+			cfg = dle_mem_pcie_8852a;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B))
+			cfg = dle_mem_pcie_8852b;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C))
+			cfg = dle_mem_pcie_8852c;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB))
+			cfg = dle_mem_pcie_8192xb;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+			cfg = dle_mem_pcie_8851b;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E))
+			cfg = dle_mem_pcie_8851e;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))
+			cfg = dle_mem_pcie_8852d;
+		else if (is_chip_id(adapter, MAC_BE_CHIP_ID_1115E))
+			cfg = dle_mem_pcie_1115e;
+		else
+			cfg = NULL;
+		break;
+#endif
+	default:
+		cfg = NULL;
+		break;
+	}
+
+	if (!cfg)
+		return NULL;
+	for (; cfg->mode != MAC_AX_QTA_INVALID; cfg++) {
+		if (cfg->mode == mode) {
+			adapter->dle_info.wde_pg_size = cfg->wde_size->pge_size;
+			adapter->dle_info.ple_pg_size = cfg->ple_size->pge_size;
+			adapter->dle_info.qta_mode = mode;
+			adapter->dle_info.c0_rx_qta = cfg->ple_min_qt->cma0_dma;
+			adapter->dle_info.c1_rx_qta = cfg->ple_min_qt->cma1_dma;
+			adapter->dle_info.c0_tx_min = cfg->ple_min_qt->cma0_tx;
+			adapter->dle_info.c0_tx_max = cfg->ple_max_qt->cma0_tx;
+			adapter->dle_info.c1_tx_min = cfg->ple_min_qt->cma1_tx;
+			adapter->dle_info.c1_tx_max = cfg->ple_max_qt->cma1_tx;
+			adapter->dle_info.hif_min = cfg->wde_min_qt->hif;
+			return cfg;
+		}
+	}
+
+	return NULL;
+}
+
+static u32 dle_quota_cfg(struct mac_ax_adapter *adapter, struct dle_mem_t *cfg)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret;
+
+	ret = p_ops->wde_quota_cfg(adapter, cfg->wde_min_qt, cfg->wde_max_qt);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]wde quota cfg %d\n", ret);
+		return ret;
+	}
+	ret = p_ops->ple_quota_cfg(adapter, cfg->ple_min_qt, cfg->ple_max_qt);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]ple quota cfg %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+u32 dle_quota_change(struct mac_ax_adapter *adapter, enum mac_ax_qta_mode mode)
+{
+	u32 ret = MACSUCCESS;
+	struct dle_mem_t *cfg;
+	struct cpuio_buf_req_t buf_req;
+	struct cpuio_ctrl_t ctrl_para;
+	u32 val32_1, val32_2;
+
+	cfg = get_dle_mem_cfg(adapter, mode);
+	if (!cfg) {
+		PLTFM_MSG_ERR("[ERR]wd/dle mem cfg\n");
+		return MACNOITEM;
+	}
+
+	val32_1 = dle_used_size(cfg->wde_size, cfg->ple_size);
+	val32_2 = adapter->hw_info->fifo_size - dle_rsvd_size(adapter, mode);
+	if (val32_1 != val32_2) {
+		PLTFM_MSG_ERR("[ERR]dle used size %d not match %d\n",
+			      val32_1, val32_2);
+		return MACFFCFG;
+	}
+
+	ret = dle_quota_cfg(adapter, cfg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dle qutoa cfg %d\n", ret);
+		return ret;
+	}
+
+	//Trigger change by enqueue packet
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		/* send h2c as workaround */
+		ret = h2c_dle_qta_change(adapter);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]h2c_dle_qta_change %d\n", ret);
+			return ret;
+		}
+	} else {
+		// Use CPUIO as workaround (suggested by DD TM_LIN).
+		//WD
+		buf_req.len = 0x20; // chris comment
+		ret = mac_dle_buf_req_wd(adapter, &buf_req);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]WDE DLE buf req %d\n", ret);
+			return ret;
+		}
+
+		PLTFM_MEMSET((void *)&ctrl_para, 0, sizeof(ctrl_para));
+		ctrl_para.cmd_type = CPUIO_OP_CMD_ENQ_TO_HEAD;
+		ctrl_para.start_pktid = buf_req.pktid;
+		ctrl_para.end_pktid = buf_req.pktid;
+		ctrl_para.pkt_num = 0;
+		ctrl_para.dst_pid = WDE_DLE_PORT_ID_WDRLS;
+		ctrl_para.dst_qid = WDE_DLE_QUEID_NO_REPORT;
+		ret = mac_set_cpuio_wd(adapter, &ctrl_para);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]WDE DLE enqueue to head %d\n", ret);
+			return ret;
+		}
+
+		//PL
+		buf_req.len = 0x20;
+		ret = mac_dle_buf_req_pl(adapter, &buf_req);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]PLE DLE buf req %d\n", ret);
+			return ret;
+		}
+
+		PLTFM_MEMSET((void *)&ctrl_para, 0, sizeof(ctrl_para));
+		ctrl_para.cmd_type = CPUIO_OP_CMD_ENQ_TO_HEAD;
+		ctrl_para.start_pktid = buf_req.pktid;
+		ctrl_para.end_pktid = buf_req.pktid;
+		ctrl_para.pkt_num = 0;
+		ctrl_para.dst_pid = PLE_DLE_PORT_ID_PLRLS;
+		ctrl_para.dst_qid = PLE_DLE_QUEID_NO_REPORT;
+		ret = mac_set_cpuio_pl(adapter, &ctrl_para);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]PLE DLE enqueue to head %d\n", ret);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+u32 dle_init(struct mac_ax_adapter *adapter, enum mac_ax_qta_mode mode,
+	     enum mac_ax_qta_mode ext_mode)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret = MACSUCCESS, ret2;
+	u32 val32_1, val32_2;
+	struct dle_mem_t *cfg, *ext_cfg;
+	struct dle_mem_t cfg_tmp;
+	struct dle_size_t wde_size_tmp, ple_size_tmp;
+	struct wde_quota_t wde_min_qt_tmp, wde_max_qt_tmp;
+	struct ple_quota_t ple_min_qt_tmp, ple_max_qt_tmp;
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]chk dmac en %d\n", ret);
+		return ret;
+	}
+
+	cfg = get_dle_mem_cfg(adapter, mode);
+	if (!cfg) {
+		ret = MACNOITEM;
+		PLTFM_MSG_ERR("[ERR]get_dle_mem_cfg %d\n", mode);
+		goto error;
+	}
+
+	PLTFM_MEMCPY(&wde_size_tmp, cfg->wde_size, sizeof(struct dle_size_t));
+	PLTFM_MEMCPY(&ple_size_tmp, cfg->ple_size, sizeof(struct dle_size_t));
+	PLTFM_MEMCPY(&wde_min_qt_tmp, cfg->wde_min_qt, sizeof(struct wde_quota_t));
+	PLTFM_MEMCPY(&wde_max_qt_tmp, cfg->wde_max_qt, sizeof(struct wde_quota_t));
+	PLTFM_MEMCPY(&ple_min_qt_tmp, cfg->ple_min_qt, sizeof(struct ple_quota_t));
+	PLTFM_MEMCPY(&ple_max_qt_tmp, cfg->ple_max_qt, sizeof(struct ple_quota_t));
+	cfg_tmp.mode = cfg->mode;
+	cfg_tmp.wde_size = &wde_size_tmp;
+	cfg_tmp.ple_size = &ple_size_tmp;
+	cfg_tmp.wde_min_qt = &wde_min_qt_tmp;
+	cfg_tmp.wde_max_qt = &wde_max_qt_tmp;
+	cfg_tmp.ple_min_qt = &ple_min_qt_tmp;
+	cfg_tmp.ple_max_qt = &ple_max_qt_tmp;
+	cfg = &cfg_tmp;
+
+	if (mode == MAC_AX_QTA_DLFW) {
+		ext_cfg = get_dle_mem_cfg(adapter, ext_mode);
+		if (!ext_cfg) {
+			ret = MACNOITEM;
+			PLTFM_MSG_ERR("[ERR]get_dle_ext_mem_cfg %d\n",
+				      ext_mode);
+			goto error;
+		}
+
+		cfg->wde_min_qt->wcpu = ext_cfg->wde_min_qt->wcpu;
+	}
+
+	val32_1 = dle_used_size(cfg->wde_size, cfg->ple_size);
+	val32_2 = adapter->hw_info->fifo_size - dle_rsvd_size(adapter, mode);
+	if (val32_1 != val32_2) {
+		PLTFM_MSG_ERR("[ERR]dle init used size %d not match %d\n",
+			      val32_1, val32_2);
+		ret = MACFFCFG;
+		goto error;
+	}
+
+	ret = p_ops->dle_func_en(adapter, MAC_AX_FUNC_DIS);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dle func disable %d\n", ret);
+		goto error;
+	}
+
+	ret = p_ops->dle_clk_en(adapter, MAC_AX_FUNC_EN);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dle clk enable %d\n", ret);
+		goto error;
+	}
+
+	ret = p_ops->dle_mix_cfg(adapter, cfg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] dle mix cfg %d\n", ret);
+		goto error;
+	}
+
+	ret = dle_quota_cfg(adapter, cfg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dle qutoa cfg %d\n", ret);
+		goto error;
+	}
+
+	ret = p_ops->dle_func_en(adapter, MAC_AX_FUNC_EN);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dle func enable %d\n", ret);
+		goto error;
+	}
+
+	ret = p_ops->chk_dle_rdy(adapter, DLE_CTRL_TYPE_WDE);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]check wde ready %d\n", ret);
+		goto error;
+	}
+
+	ret = p_ops->chk_dle_rdy(adapter, DLE_CTRL_TYPE_PLE);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]check ple ready %d\n", ret);
+		goto error;
+	}
+
+	return ret;
+error:
+	ret2 = p_ops->dle_func_en(adapter, MAC_AX_FUNC_DIS);
+	if (ret2 != MACSUCCESS)
+		PLTFM_MSG_ERR("[ERR]dle func disable %d\n", ret2);
+
+	return ret;
+}
+
+u32 is_qta_dbcc(struct mac_ax_adapter *adapter, enum mac_ax_qta_mode mode,
+		u8 *is_dbcc)
+{
+	struct dle_mem_t *cfg;
+
+	cfg = get_dle_mem_cfg(adapter, mode);
+	if (!cfg) {
+		PLTFM_MSG_ERR("[ERR]get_dle_mem_cfg\n");
+		return MACNOITEM;
+	}
+
+	*is_dbcc = (cfg->ple_min_qt->cma1_dma && cfg->ple_max_qt->cma1_dma) ?
+		   1 : 0;
+
+	return MACSUCCESS;
+}
+
+u8 is_curr_dbcc(struct mac_ax_adapter *adapter)
+{
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+		return 0;
+
+	return adapter->dle_info.c1_rx_qta ? 1 : 0;
+}
+
+u32 is_qta_poh(struct mac_ax_adapter *adapter, enum mac_ax_qta_mode mode,
+	       u8 *is_poh)
+{
+	*is_poh = (mode == MAC_AX_QTA_SCC_STF || mode == MAC_AX_QTA_DBCC_STF ||
+		   adapter->hw_info->intf != MAC_AX_INTF_PCIE) ? 0 : 1;
+
+	return MACSUCCESS;
+}
+
+u32 redu_wowlan_rx_qta(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u16 new_qta, qta_min, qta_max, rdu_pg_num;
+
+	if (!(is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	      is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	      is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)))
+		return MACSUCCESS;
+
+	val32 = GET_FIELD(MAC_REG_R32(R_AX_PLE_PKTBUF_CFG), B_AX_PLE_PAGE_SEL);
+	if (val32 == S_AX_PLE_PAGE_SEL_128) {
+		rdu_pg_num = PLE_QTA_PG128B_12KB;
+	} else if (val32 == S_AX_PLE_PAGE_SEL_256) {
+		rdu_pg_num = PLE_QTA_PG128B_12KB / 2;
+	} else {
+		PLTFM_MSG_ERR("[ERR]PLE page sel %d unsupport\n", val32);
+		return MACHWERR;
+	}
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA6_CFG);
+	if (!val32) {
+		PLTFM_MSG_ERR("[ERR]no rx 0 qta\n");
+		return MACHWERR;
+	}
+	qta_min = GET_FIELD(val32, B_AX_PLE_Q6_MIN_SIZE);
+	qta_max = GET_FIELD(val32, B_AX_PLE_Q6_MAX_SIZE);
+
+	adapter->dle_info.c0_ori_max = qta_max;
+
+	new_qta = (qta_max - qta_min) < rdu_pg_num ?
+		  qta_min : (qta_max - rdu_pg_num);
+	val32 = SET_CLR_WORD(val32, new_qta, B_AX_PLE_Q6_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA6_CFG, val32);
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA7_CFG);
+	if (!val32)
+		return MACSUCCESS;
+	qta_min = GET_FIELD(val32, B_AX_PLE_Q7_MIN_SIZE);
+	qta_max = GET_FIELD(val32, B_AX_PLE_Q7_MAX_SIZE);
+
+	adapter->dle_info.c1_ori_max = qta_max;
+
+	new_qta = (qta_max - qta_min) < rdu_pg_num ?
+		  qta_min : (qta_max - rdu_pg_num);
+	val32 = SET_CLR_WORD(val32, new_qta, B_AX_PLE_Q7_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA7_CFG, val32);
+#endif
+	return MACSUCCESS;
+}
+
+u32 restr_wowlan_rx_qta(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, w_val32;
+
+	if (!(is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	      is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	      is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)))
+		return MACSUCCESS;
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA6_CFG);
+	if (!val32) {
+		PLTFM_MSG_ERR("[ERR]no rx 0 qta\n");
+		return MACHWERR;
+	}
+	w_val32 = SET_CLR_WORD(val32, adapter->dle_info.c0_ori_max,
+			       B_AX_PLE_Q6_MAX_SIZE);
+	if (w_val32 != val32)
+		MAC_REG_W32(R_AX_PLE_QTA6_CFG, w_val32);
+
+	val32 = MAC_REG_R32(R_AX_PLE_QTA7_CFG);
+	if (!val32)
+		return MACSUCCESS;
+	w_val32 = SET_CLR_WORD(val32, adapter->dle_info.c1_ori_max,
+			       B_AX_PLE_Q7_MAX_SIZE);
+	if (w_val32 != val32)
+		MAC_REG_W32(R_AX_PLE_QTA7_CFG, w_val32);
+#endif
+	return MACSUCCESS;
+}
+
+static u32 h2c_dle_qta_change(struct mac_ax_adapter *adapter)
+{
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	u32 ret;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, 0);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto dle_qta_change_fail;
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_DLE_QTA_CHANGE,
+			      0,
+			      0);
+
+	if (ret != MACSUCCESS)
+		goto dle_qta_change_fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto dle_qta_change_fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto dle_qta_change_fail;
+
+	h2cb_free(adapter, h2cb);
+	return MACSUCCESS;
+
+dle_qta_change_fail:
+	h2cb_free(adapter, h2cb);
+	return ret;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dle.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dle.h
new file mode 100644
index 000000000000..6d3692578bd7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/dle.h
@@ -0,0 +1,750 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_DLE_H_
+#define _MAC_AX_DLE_H_
+
+#include "../type.h"
+#include "../mac_ax.h"
+#include "cpuio.h"
+
+/*--------------------Define ----------------------------------------*/
+#define DLE_DFI_WAIT_CNT 1000
+#define DLE_DFI_WAIT_US 1
+
+#define DLE_WAIT_CNT 2000
+#define DLE_WAIT_US 1
+
+// DLE_DFI_TYPE_FREEPG
+#define B_AX_DLE_FREE_TAILPG_SH 16
+#define B_AX_DLE_FREE_TAILPG_MSK 0xfff
+#define B_AX_DLE_FREE_HEADPG_SH 0
+#define B_AX_DLE_FREE_HEADPG_MSK 0xfff
+
+#define B_AX_DLE_PUB_PGNUM_SH 0
+#define B_AX_DLE_PUB_PGNUM_MSK 0x1fff
+
+// DLE_DFI_TYPE_QUOTA
+#define B_AX_DLE_USE_PGNUM_SH 16
+#define B_AX_DLE_USE_PGNUM_MSK 0xfff
+#define B_AX_DLE_RSV_PGNUM_SH 0
+#define B_AX_DLE_RSV_PGNUM_MSK 0xfff
+
+// DLE_DFI_TYPE_QEMPTY
+#define B_AX_DLE_QEMPTY_GRP_SH 0
+#define B_AX_DLE_QEMPTY_GRP_MSK 0xffffffff
+
+#define QUEUE_EMPTY_CHK_CNT 2
+#define WDE_QEMPTY_NUM_8852A 18
+#define WDE_QEMPTY_NUM_8852B 5
+#define WDE_QEMPTY_NUM_8852C 19
+#define WDE_QEMPTY_NUM_8192XB 18
+#define WDE_QEMPTY_NUM_8851B 5
+#define WDE_QEMPTY_NUM_8851E 19
+#define WDE_QEMPTY_NUM_8852D 19
+#define WDE_QEMPTY_NUM_1115E 36
+#define PLE_QEMPTY_NUM 2
+#define WDE_QEMPTY_ACQ_NUM_8852A 16 /* cannot over WDE_QEMPTY_ACQ_NUM_MAX */
+#define WDE_QEMPTY_ACQ_NUM_8852B 4 /* cannot over WDE_QEMPTY_ACQ_NUM_MAX */
+#define WDE_QEMPTY_ACQ_NUM_8852C 16 /* cannot over WDE_QEMPTY_ACQ_NUM_MAX */
+#define WDE_QEMPTY_ACQ_NUM_8192XB 16 /* cannot over WDE_QEMPTY_ACQ_NUM_MAX */
+#define WDE_QEMPTY_ACQ_NUM_8851B 4 /* cannot over WDE_QEMPTY_ACQ_NUM_MAX */
+#define WDE_QEMPTY_ACQ_NUM_8851E 16 /* cannot over WDE_QEMPTY_ACQ_NUM_MAX */
+#define WDE_QEMPTY_ACQ_NUM_8852D 16 /* cannot over WDE_QEMPTY_ACQ_NUM_MAX */
+#define WDE_QEMPTY_ACQ_NUM_1115E 16 /* cannot over WDE_QEMPTY_ACQ_NUM_MAX */
+#define WDE_QEMPTY_MGQ_SEL_8852A 16
+#define WDE_QEMPTY_MGQ_SEL_8852B 4
+#define WDE_QEMPTY_MGQ_SEL_8852C 16
+#define WDE_QEMPTY_MGQ_SEL_8192XB 16
+#define WDE_QEMPTY_MGQ_SEL_8851B 4
+#define WDE_QEMPTY_MGQ_SEL_8851E 16
+#define WDE_QEMPTY_MGQ_SEL_8852D 16
+#define WDE_QEMPTY_MGQ_SEL_1115E 16
+#define QEMP_ACQ_GRP_MACID_NUM 8
+#define QEMP_ACQ_GRP_QSEL_SH 4
+#define QEMP_ACQ_GRP_QSEL_MASK 0xF
+#define S_AX_WDE_PAGE_SEL_64	0
+#define S_AX_WDE_PAGE_SEL_128	1
+/* #define S_AX_WDE_PAGE_SEL_256	2 // HDP not support */
+
+/* #define S_AX_PLE_PAGE_SEL_64	0 // HDP not support */
+#define S_AX_PLE_PAGE_SEL_128	1
+#define S_AX_PLE_PAGE_SEL_256	2
+
+#define DLE_BOUND_UNIT (8 * 1024)
+
+#define DLE_QUEUE_NONEMPTY	0
+#define DLE_QUEUE_EMPTY		1
+
+#define B_CMAC0_MGQ_NORMAL	BIT2
+#define B_CMAC0_MGQ_NO_PWRSAV	BIT3
+#define B_CMAC0_CPUMGQ		BIT4
+#define B_CMAC1_MGQ_NORMAL	BIT10
+#define B_CMAC1_MGQ_NO_PWRSAV	BIT11
+#define B_CMAC1_CPUMGQ		BIT12
+
+#define DLE_LAMODE_SIZE_8852A 262144 // (256 * 1024)
+#define DLE_LAMODE_SIZE_8852B 131072 // (128 * 1024)
+#define DLE_LAMODE_SIZE_8852C 262144 // (256 * 1024)
+#define DLE_LAMODE_SIZE_8192XB 262144 // (256 * 1024)
+#define DLE_LAMODE_SIZE_8851B 131072 // (128 * 1024)
+#define DLE_LAMODE_SIZE_8851E 262144 // (256 * 1024)
+#define DLE_LAMODE_SIZE_8852D 262144 // (256 * 1024)
+
+#define DLE_SCC_RSVD_SIZE_8852B 98304 // (96 * 1024)
+#define DLE_SCC_RSVD_SIZE_8851B 98304 // (96 * 1024)
+
+#define WDE_QTA_NUM 5
+#define PLE_QTA_NUM_8852AB 11
+#define PLE_QTA_NUM_8852C 12
+#define PLE_QTA_NUM_8192XB 12
+#define PLE_QTA_NUM_8851E 12
+#define PLE_QTA_NUM_8852D 12
+
+#define PLE_QTA_PG128B_12KB 96
+
+#define QLNKTBL_ADDR_INFO_SEL BIT(0)
+#define QLNKTBL_ADDR_INFO_SEL_0 0
+#define QLNKTBL_ADDR_INFO_SEL_1 1
+#define QLNKTBL_ADDR_TBL_IDX_MSK 0x3FF
+#define QLNKTBL_ADDR_TBL_IDX_SH 1
+#define QLNKTBL_DATA_SEL0_HEAD_PKT_ID_11_8_MSK 0xF
+#define QLNKTBL_DATA_SEL0_HEAD_PKT_ID_11_8_SH 0
+#define QLNKTBL_DATA_SEL1_PKT_CNT_MSK 0xFFF
+#define QLNKTBL_DATA_SEL1_PKT_CNT_SH 0
+#define QLNKTBL_DATA_SEL1_TAIL_PKTID_MSK 0xFFF
+#define QLNKTBL_DATA_SEL1_TAIL_PKT_ID_SH 12
+#define QLNKTBL_DATA_SEL1_HEAD_PKTID_7_0_MSK 0xFF
+#define QLNKTBL_DATA_SEL1_HEAD_PKTID_7_0_SH 24
+
+#define PRELD_B0_ENT_NUM 10
+#define PRELD_B1_ENT_NUM 4
+#define PRELD_AMSDU_SIZE 52 // (1536 + 128) * 2 / 64
+#define PRELD_NEXT_WND 1
+
+/*--------------------Define Enum------------------------------------*/
+
+/**
+ * @enum WDE_QTAID
+ *
+ * @brief WDE_QTAID
+ *
+ * @var WDE_QTAID::WDE_QTAID_HOST_IF
+ * Please Place Description here.
+ * @var WDE_QTAID::WDE_QTAID_WLAN_CPU
+ * Please Place Description here.
+ * @var WDE_QTAID::WDE_QTAID_DATA_CPU
+ * Please Place Description here.
+ * @var WDE_QTAID::WDE_QTAID_PKTIN
+ * Please Place Description here.
+ * @var WDE_QTAID::WDE_QTAID_CPUIO
+ * Please Place Description here.
+ */
+enum WDE_QTAID {
+	WDE_QTAID_HOST_IF = 0,
+	WDE_QTAID_WLAN_CPU = 1,
+	WDE_QTAID_DATA_CPU = 2,
+	WDE_QTAID_PKTIN = 3,
+	WDE_QTAID_CPUIO = 4
+};
+
+/**
+ * @enum PLE_QTAID
+ *
+ * @brief PLE_QTAID
+ *
+ * @var PLE_QTAID::PLE_QTAID_B0_TXPL
+ * Please Place Description here.
+ * @var PLE_QTAID::PLE_QTAID_B1_TXPL
+ * Please Place Description here.
+ * @var PLE_QTAID::PLE_QTAID_C2H
+ * Please Place Description here.
+ * @var PLE_QTAID::PLE_QTAID_H2C
+ * Please Place Description here.
+ * @var PLE_QTAID::PLE_QTAID_WLAN_CPU
+ * Please Place Description here.
+ * @var PLE_QTAID::PLE_QTAID_MPDU
+ * Please Place Description here.
+ * @var PLE_QTAID::PLE_QTAID_CMAC0_RX
+ * Please Place Description here.
+ * @var PLE_QTAID::PLE_QTAID_CMAC1_RX
+ * Please Place Description here.
+ * @var PLE_QTAID::PLE_QTAID_CMAC1_BBRPT
+ * Please Place Description here.
+ * @var PLE_QTAID::PLE_QTAID_WDRLS
+ * Please Place Description here.
+ * @var PLE_QTAID::PLE_QTAID_CPUIO
+ * Please Place Description here.
+ */
+enum PLE_QTAID {
+	PLE_QTAID_B0_TXPL = 0,
+	PLE_QTAID_B1_TXPL = 1,
+	PLE_QTAID_C2H = 2,
+	PLE_QTAID_H2C = 3,
+	PLE_QTAID_WLAN_CPU = 4,
+	PLE_QTAID_MPDU = 5,
+	PLE_QTAID_CMAC0_RX = 6,
+	PLE_QTAID_CMAC1_RX = 7,
+	PLE_QTAID_BBRPT = 8,
+	PLE_QTAID_WDRLS = 9,
+	PLE_QTAID_CPUIO = 10,
+	PLE_QTAID_TXRPT = 11
+};
+
+/**
+ * @enum DLE_CTRL_TYPE
+ *
+ * @brief DLE_CTRL_TYPE
+ *
+ * @var DLE_CTRL_TYPE::DLE_CTRL_TYPE_WDE
+ * Please Place Description here.
+ * @var DLE_CTRL_TYPE::DLE_CTRL_TYPE_PLE
+ * Please Place Description here.
+ * @var DLE_CTRL_TYPE::DLE_CTRL_TYPE_NUM
+ * Please Place Description here.
+ */
+enum DLE_CTRL_TYPE {
+	DLE_CTRL_TYPE_WDE = 0,
+	DLE_CTRL_TYPE_PLE = 1,
+	DLE_CTRL_TYPE_NUM = 2
+};
+
+/**
+ * @enum DLE_DFI_TYPE
+ *
+ * @brief DLE_DFI_TYPE
+ *
+ * @var DLE_DFI_TYPE::DLE_DFI_TYPE_FREEPG
+ * Please Place Description here.
+ * @var DLE_DFI_TYPE::DLE_DFI_TYPE_QUOTA
+ * Please Place Description here.
+ * @var DLE_DFI_TYPE::DLE_DFI_TYPE_PAGELLT
+ * Please Place Description here.
+ * @var DLE_DFI_TYPE::DLE_DFI_TYPE_PKTINFO
+ * Please Place Description here.
+ * @var DLE_DFI_TYPE::DLE_DFI_TYPE_PREPKTLLT
+ * Please Place Description here.
+ * @var DLE_DFI_TYPE::DLE_DFI_TYPE_NXTPKTLLT
+ * Please Place Description here.
+ * @var DLE_DFI_TYPE::DLE_DFI_TYPE_QLNKTBL
+ * Please Place Description here.
+ * @var DLE_DFI_TYPE::DLE_DFI_TYPE_QEMPTY
+ * Please Place Description here.
+ */
+enum DLE_DFI_TYPE {
+	DLE_DFI_TYPE_FREEPG = 0,
+	DLE_DFI_TYPE_QUOTA = 1,
+	DLE_DFI_TYPE_PAGELLT = 2,
+	DLE_DFI_TYPE_PKTINFO = 3,
+	DLE_DFI_TYPE_PREPKTLLT = 4,
+	DLE_DFI_TYPE_NXTPKTLLT = 5,
+	DLE_DFI_TYPE_QLNKTBL = 6,
+	DLE_DFI_TYPE_QEMPTY = 7
+};
+
+enum DFI_TYPE_FREEPG_SEL {
+	DFI_TYPE_FREEPG_IDX = 0,
+	DFI_TYPE_FREEPG_PUBNUM
+};
+
+/**
+ * @enum DLE_RSVD_INFO
+ *
+ * @brief DLE_RSVD_INFO
+ *
+ * @var DLE_RSVD_INFO::DLE_RSVD_INFO_NONE
+ * do not rsvd dle quota.
+ * @var DLE_RSVD_INFO::DLE_RSVD_INFO_FW
+ * rsvd dle quota for fw.
+ * @var DLE_RSVD_INFO::DLE_RSVD_INFO_LAMODE
+ * rsvd dle quota for BB LA mode.
+ */
+enum DLE_RSVD_INFO {
+	DLE_RSVD_INFO_NONE,
+	DLE_RSVD_INFO_FW,
+	DLE_RSVD_INFO_LAMODE,
+};
+
+/*--------------------Define MACRO----------------------------------*/
+
+/*--------------------Define Struct-----------------------------------*/
+
+/**
+ * @struct dle_dfi_freepg_t
+ * @brief dle_dfi_freepg_t
+ *
+ * @var dle_dfi_freepg_t::dle_type
+ * Please Place Description here.
+ * @var dle_dfi_freepg_t::free_headpg
+ * Please Place Description here.
+ * @var dle_dfi_freepg_t::free_tailpg
+ * Please Place Description here.
+ * @var dle_dfi_freepg_t::pub_pgnum
+ * Please Place Description here.
+ */
+struct dle_dfi_freepg_t {
+	// input parameter
+	enum DLE_CTRL_TYPE dle_type;
+	// output parameter
+	u16 free_headpg;
+	u16 free_tailpg;
+	u16 pub_pgnum;
+};
+
+/**
+ * @struct dle_dfi_quota_t
+ * @brief dle_dfi_quota_t
+ *
+ * @var dle_dfi_quota_t::dle_type
+ * Please Place Description here.
+ * @var dle_dfi_quota_t::qtaid
+ * Please Place Description here.
+ * @var dle_dfi_quota_t::rsv_pgnum
+ * Please Place Description here.
+ * @var dle_dfi_quota_t::use_pgnum
+ * Please Place Description here.
+ */
+struct dle_dfi_quota_t {
+	// input parameter
+	enum DLE_CTRL_TYPE dle_type;
+	u32 qtaid;
+	// output parameter
+	u16 rsv_pgnum;
+	u16 use_pgnum;
+};
+
+/**
+ * @struct dle_dfi_qempty_t
+ * @brief dle_dfi_qempty_t
+ *
+ * @var dle_dfi_qempty_t::dle_type
+ * Please Place Description here.
+ * @var dle_dfi_qempty_t::grpsel
+ * Please Place Description here.
+ * @var dle_dfi_qempty_t::qempty
+ * Please Place Description here.
+ */
+struct dle_dfi_qempty_t {
+	// input parameter
+	enum DLE_CTRL_TYPE dle_type;
+	u32 grpsel;
+	// output parameter
+	u32 qempty;
+};
+
+/**
+ * @struct dle_dfi_ctrl_t
+ * @brief dle_dfi_ctrl_t
+ *
+ * @var dle_dfi_ctrl_t::ctrl_type
+ * Please Place Description here.
+ * @var dle_dfi_ctrl_t::dfi_ctrl
+ * Please Place Description here.
+ * @var dle_dfi_ctrl_t::dfi_data
+ * Please Place Description here.
+ */
+struct dle_dfi_ctrl_t {
+	enum DLE_CTRL_TYPE type;
+	u32 target;
+	u32 addr;
+	u32 out_data;
+	union {
+		struct dle_dfi_freepg_t freepg;
+		struct dle_dfi_quota_t quota;
+		struct dle_dfi_qempty_t qempty;
+	} u;
+};
+
+/**
+ * @struct dle_size_t
+ * @brief dle_size_t
+ *
+ * @var dle_size_t::pge_size
+ * Please Place Description here.
+ * @var dle_size_t::lnk_pge_num
+ * Please Place Description here.
+ * @var dle_size_t::unlnk_pge_num
+ * Please Place Description here.
+ */
+struct dle_size_t {
+	u16 pge_size;
+	u16 lnk_pge_num;
+	u16 unlnk_pge_num;
+};
+
+/**
+ * @struct wde_quota_t
+ * @brief wde_quota_t
+ *
+ * @var wde_quota_t::hif
+ * Please Place Description here.
+ * @var wde_quota_t::wcpu
+ * Please Place Description here.
+ * @var wde_quota_t::dcpu
+ * Please Place Description here.
+ * @var wde_quota_t::pkt_in
+ * Please Place Description here.
+ * @var wde_quota_t::cpu_io
+ * Please Place Description here.
+ */
+struct wde_quota_t {
+	u16 hif;
+	u16 wcpu;
+	u16 dcpu;
+	u16 pkt_in;
+	u16 cpu_io;
+};
+
+/**
+ * @struct ple_quota_t
+ * @brief ple_quota_t
+ *
+ * @var ple_quota_t::cma0_tx
+ * Please Place Description here.
+ * @var ple_quota_t::cma1_tx
+ * Please Place Description here.
+ * @var ple_quota_t::c2h
+ * Please Place Description here.
+ * @var ple_quota_t::h2c
+ * Please Place Description here.
+ * @var ple_quota_t::wcpu
+ * Please Place Description here.
+ * @var ple_quota_t::mpdu_proc
+ * Please Place Description here.
+ * @var ple_quota_t::cma0_dma
+ * Please Place Description here.
+ * @var ple_quota_t::cma1_dma
+ * Please Place Description here.
+ * @var ple_quota_t::bb_rpt
+ * Please Place Description here.
+ * @var ple_quota_t::wd_rel
+ * Please Place Description here.
+ * @var ple_quota_t::cpu_io
+ * Please Place Description here.
+ * @var ple_quota_t::tx_rpt
+ * Please Place Description here.
+ * @var ple_quota_t::h2d
+ * Please Place Description here.
+ */
+struct ple_quota_t {
+	u16 cma0_tx;
+	u16 cma1_tx;
+	u16 c2h;
+	u16 h2c;
+	u16 wcpu;
+	u16 mpdu_proc;
+	u16 cma0_dma;
+	u16 cma1_dma;
+	u16 bb_rpt;
+	u16 wd_rel;
+	u16 cpu_io;
+	u16 tx_rpt;
+	u16 h2d;
+};
+
+/**
+ * @struct dle_mem_t
+ * @brief dle_mem_t
+ *
+ * @var dle_mem_t::mode
+ * Please Place Description here.
+ * @var dle_mem_t::wde_size
+ * Please Place Description here.
+ * @var dle_mem_t::ple_size
+ * Please Place Description here.
+ * @var dle_mem_t::wde_min_qt
+ * Please Place Description here.
+ * @var dle_mem_t::wde_max_qt
+ * Please Place Description here.
+ * @var dle_mem_t::ple_min_qt
+ * Please Place Description here.
+ * @var dle_mem_t::ple_max_qt
+ * Please Place Description here.
+ */
+struct dle_mem_t {
+	enum mac_ax_qta_mode mode;
+	struct dle_size_t *wde_size;
+	struct dle_size_t *ple_size;
+	struct wde_quota_t *wde_min_qt;
+	struct wde_quota_t *wde_max_qt;
+	struct ple_quota_t *ple_min_qt;
+	struct ple_quota_t *ple_max_qt;
+};
+
+/*--------------------Export global variable----------------------------*/
+
+/*--------------------Function declaration-----------------------------*/
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief dle_dfi_freepg
+ *
+ * @param *adapter
+ * @param *freepg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dle_dfi_freepg(struct mac_ax_adapter *adapter,
+		   struct dle_dfi_freepg_t *freepg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+
+/**
+ * @brief dle_dfi_quota
+ *
+ * @param *adapter
+ * @param *quota
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 dle_dfi_quota(struct mac_ax_adapter *adapter,
+		  struct dle_dfi_quota_t *quota);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+
+/**
+ * @brief dle_dfi_qempty
+ *
+ * @param *adapter
+ * @param *qempty
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 dle_dfi_qempty(struct mac_ax_adapter *adapter,
+		   struct dle_dfi_qempty_t *qempty);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+
+/**
+ * @brief mac_chk_allq_empty
+ *
+ * @param *adapter
+ * @param *empty
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_chk_allq_empty(struct mac_ax_adapter *adapter, u8 *empty);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+
+/**
+ * @brief dle_quota_change
+ *
+ * @param *adapter
+ * @param mode
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 dle_quota_change(struct mac_ax_adapter *adapter, enum mac_ax_qta_mode mode);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+
+/**
+ * @brief dle_init
+ *
+ * @param *adapter
+ * @param mode
+ * @param ext_mode
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 dle_init(struct mac_ax_adapter *adapter, enum mac_ax_qta_mode mode,
+	     enum mac_ax_qta_mode ext_mode);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+
+/**
+ * @brief is_qta_dbcc
+ *
+ * @param *adapter
+ * @param mode
+ * @param *is_dbcc
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 is_qta_dbcc(struct mac_ax_adapter *adapter, enum mac_ax_qta_mode mode,
+		u8 *is_dbcc);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+
+/**
+ * @brief is_qta_poh
+ *
+ * @param *adapter
+ * @param mode
+ * @param *is_poh
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u8 is_curr_dbcc(struct mac_ax_adapter *adapter);
+
+u32 is_qta_poh(struct mac_ax_adapter *adapter, enum mac_ax_qta_mode mode,
+	       u8 *is_poh);
+/**
+ * @}
+ * @}
+ */
+
+u32 redu_wowlan_rx_qta(struct mac_ax_adapter *adapter);
+u32 restr_wowlan_rx_qta(struct mac_ax_adapter *adapter);
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+
+/**
+ * @brief mac_preload_cfg
+ *
+ * @param *adapter
+ * @param band
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_preload_cfg(struct mac_ax_adapter *adapter, enum mac_ax_band band,
+		    struct mac_ax_preld_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+
+/**
+ * @brief preload_init
+ *
+ * @param *adapter
+ * @param band
+ * @param mode
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 preload_init(struct mac_ax_adapter *adapter, enum mac_ax_band band,
+		 enum mac_ax_qta_mode mode);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+
+/**
+ * @brief get_dle_rsvd_info
+ *
+ * @param *adapter
+ * @param *info
+ * @return success or fail
+ * @retval u32
+ */
+
+u32 get_dle_rsvd_info(struct mac_ax_adapter *adapter, enum DLE_RSVD_INFO *info);
+
+/**
+ * @}
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/eco_patch_check.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/eco_patch_check.c
new file mode 100644
index 000000000000..5dfcf66ec2db
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/eco_patch_check.c
@@ -0,0 +1,5337 @@
+#include "eco_patch_check.h"
+bool chk_patch_l2_ldo_power(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_aphy_pc(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_flr_lps(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_pcie_vmain(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_otp_power_issue(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_pcie_gen2_force_ib(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_pcie_power_wake_efuse(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_pcie_power_wake(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_power_on(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_power_off(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_swr_pfm2pwm_issue(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_dmac_macid_drop_issue(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_txamsdu_rls_wd_issue(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_cut_amsdu_rls_ple_issue(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_is_cfg_avl(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_cmac_dma_err_fa(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_hi_pri_resp_tx(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_port_dis_flow(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_dis_resp_chk(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_dis_separation(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_rsp_ack(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_hwamsdu_fa(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_vht_ampdu_max_len(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_haxidma_ind(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_tbtt_shift_setval(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_tmac_zld_thold(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_snd_ple_modify(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_snd_mu_err(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_snd_fifofull_err(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_snd_ng3_setting(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_wmac_timer_src(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_v_pulse_control(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_cmac_hiq_drop(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_reg_sdio(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_pcie_sw_ltr(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_ltssm_card_loss(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_l12_reboot(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_rx_prefetch(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_sic_clkreq(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_pcie_deglitch(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_otp_pwr_drop(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_usb2_rx_nak(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_pcie_err_ind(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_fs_enuf(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_apb_hang(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_fix_emac_delay(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_filter_out(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_pcie_clkreq_delay(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_l11_exit(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_ck_buf_level(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_pclk_nrdy(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_pcie_hci_ldo(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_pcie_l2_rxen_lat(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_pcie_autok_x(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_pcie_hang(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_ENABLE;
+		}
+}
+
+bool chk_patch_cmac_io_fail(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				case CDV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+bool chk_patch_flash_boot_timing(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852BT:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/eco_patch_check.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/eco_patch_check.h
new file mode 100644
index 000000000000..d0defe073be8
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/eco_patch_check.h
@@ -0,0 +1,66 @@
+#ifndef __ECO_PATCH_CHECK_H__
+#define __ECO_PATCH_CHECK_H__
+
+#include "../mac_def.h"
+
+#define PATCH_DISABLE false
+#define PATCH_ENABLE true
+
+bool chk_patch_l2_ldo_power(struct mac_ax_adapter *adapter);
+bool chk_patch_aphy_pc(struct mac_ax_adapter *adapter);
+bool chk_patch_flr_lps(struct mac_ax_adapter *adapter);
+bool chk_patch_pcie_vmain(struct mac_ax_adapter *adapter);
+bool chk_patch_otp_power_issue(struct mac_ax_adapter *adapter);
+bool chk_patch_pcie_gen2_force_ib(struct mac_ax_adapter *adapter);
+bool chk_patch_pcie_power_wake_efuse(struct mac_ax_adapter *adapter);
+bool chk_patch_pcie_power_wake(struct mac_ax_adapter *adapter);
+bool chk_patch_power_on(struct mac_ax_adapter *adapter);
+bool chk_patch_power_off(struct mac_ax_adapter *adapter);
+bool chk_patch_swr_pfm2pwm_issue(struct mac_ax_adapter *adapter);
+bool chk_patch_dmac_macid_drop_issue(struct mac_ax_adapter *adapter);
+bool chk_patch_txamsdu_rls_wd_issue(struct mac_ax_adapter *adapter);
+bool chk_patch_cut_amsdu_rls_ple_issue(struct mac_ax_adapter *adapter);
+bool chk_patch_is_cfg_avl(struct mac_ax_adapter *adapter);
+bool chk_patch_cmac_dma_err_fa(struct mac_ax_adapter *adapter);
+bool chk_patch_hi_pri_resp_tx(struct mac_ax_adapter *adapter);
+bool chk_patch_port_dis_flow(struct mac_ax_adapter *adapter);
+bool chk_patch_dis_resp_chk(struct mac_ax_adapter *adapter);
+bool chk_patch_dis_separation(struct mac_ax_adapter *adapter);
+bool chk_patch_rsp_ack(struct mac_ax_adapter *adapter);
+bool chk_patch_hwamsdu_fa(struct mac_ax_adapter *adapter);
+bool chk_patch_vht_ampdu_max_len(struct mac_ax_adapter *adapter);
+bool chk_patch_haxidma_ind(struct mac_ax_adapter *adapter);
+bool chk_patch_tbtt_shift_setval(struct mac_ax_adapter *adapter);
+bool chk_patch_tmac_zld_thold(struct mac_ax_adapter *adapter);
+bool chk_patch_snd_ple_modify(struct mac_ax_adapter *adapter);
+bool chk_patch_snd_mu_err(struct mac_ax_adapter *adapter);
+bool chk_patch_snd_fifofull_err(struct mac_ax_adapter *adapter);
+bool chk_patch_snd_ng3_setting(struct mac_ax_adapter *adapter);
+bool chk_patch_wmac_timer_src(struct mac_ax_adapter *adapter);
+bool chk_patch_v_pulse_control(struct mac_ax_adapter *adapter);
+bool chk_patch_cmac_hiq_drop(struct mac_ax_adapter *adapter);
+bool chk_patch_reg_sdio(struct mac_ax_adapter *adapter);
+bool chk_patch_pcie_sw_ltr(struct mac_ax_adapter *adapter);
+bool chk_patch_ltssm_card_loss(struct mac_ax_adapter *adapter);
+bool chk_patch_l12_reboot(struct mac_ax_adapter *adapter);
+bool chk_patch_rx_prefetch(struct mac_ax_adapter *adapter);
+bool chk_patch_sic_clkreq(struct mac_ax_adapter *adapter);
+bool chk_patch_pcie_deglitch(struct mac_ax_adapter *adapter);
+bool chk_patch_otp_pwr_drop(struct mac_ax_adapter *adapter);
+bool chk_patch_usb2_rx_nak(struct mac_ax_adapter *adapter);
+bool chk_patch_pcie_err_ind(struct mac_ax_adapter *adapter);
+bool chk_patch_fs_enuf(struct mac_ax_adapter *adapter);
+bool chk_patch_apb_hang(struct mac_ax_adapter *adapter);
+bool chk_patch_fix_emac_delay(struct mac_ax_adapter *adapter);
+bool chk_patch_filter_out(struct mac_ax_adapter *adapter);
+bool chk_patch_pcie_clkreq_delay(struct mac_ax_adapter *adapter);
+bool chk_patch_l11_exit(struct mac_ax_adapter *adapter);
+bool chk_patch_ck_buf_level(struct mac_ax_adapter *adapter);
+bool chk_patch_pclk_nrdy(struct mac_ax_adapter *adapter);
+bool chk_patch_pcie_hci_ldo(struct mac_ax_adapter *adapter);
+bool chk_patch_pcie_l2_rxen_lat(struct mac_ax_adapter *adapter);
+bool chk_patch_pcie_autok_x(struct mac_ax_adapter *adapter);
+bool chk_patch_pcie_hang(struct mac_ax_adapter *adapter);
+bool chk_patch_cmac_io_fail(struct mac_ax_adapter *adapter);
+bool chk_patch_flash_boot_timing(struct mac_ax_adapter *adapter);
+#endif /* __ECO_PATCH_CHECK_H__ */
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/efuse.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/efuse.c
new file mode 100644
index 000000000000..7ca61e87124c
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/efuse.c
@@ -0,0 +1,4187 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "efuse.h"
+#include "mac_priv.h"
+
+static struct efuse_info_item offset_pcie = {
+	0x400, /* mac_addr */
+	0, /* pid */
+	0x408, /* did */
+	0x406, /* vid */
+	0x40A, /* svid */
+	0x40C, /* smid */
+};
+
+static struct efuse_info_item offset_usb_8852a = {
+	0x438, /* mac_addr */
+	0x432, /* pid */
+	0, /* did */
+	0x430, /* vid */
+	0, /* svid */
+	0, /* smid */
+};
+
+static struct efuse_info_item offset_usb_8852b = {
+	0x488, /* mac_addr */
+	0x482, /* pid */
+	0, /* did */
+	0x480, /* vid */
+	0, /* svid */
+	0, /* smid */
+};
+
+static struct efuse_info_item offset_sdio = {
+	0x41A, /* mac_addr */
+	0, /* pid */
+	0, /* did */
+	0, /* vid */
+	0, /* svid */
+	0, /* smid */
+};
+
+static struct efuse_info_item def_val_pcie = {
+	0x0, /* mac_addr */
+	0, /* pid */
+	0x52, /* did */
+	0xEC, /* vid */
+	0xEC, /* svid */
+	0x52, /* smid */
+};
+
+static struct efuse_info_item def_val_usb_8852a = {
+	0x0, /* mac_addr */
+	0x5A, /* pid */
+	0, /* did */
+	0xDA, /* vid */
+	0, /* svid */
+	0, /* smid */
+};
+
+static struct efuse_info_item def_val_usb_8852b = {
+	0x0, /* mac_addr */
+	0x5B, /* pid */
+	0, /* did */
+	0xDA, /* vid */
+	0, /* svid */
+	0, /* smid */
+};
+
+static struct efuse_info_item def_val_sdio = {
+	0x0, /* mac_addr */
+	0, /* pid */
+	0, /* did */
+	0, /* vid */
+	0, /* svid */
+	0, /* smid */
+};
+
+static struct efuse_info_item len_pcie = {
+	6, /* mac_addr */
+	0, /* pid */
+	2, /* did */
+	2, /* vid */
+	2, /* svid */
+	2, /* smid */
+};
+
+static struct efuse_info_item len_usb = {
+	6, /* mac_addr */
+	2, /* pid */
+	0, /* did */
+	2, /* vid */
+	0, /* svid */
+	0, /* smid */
+};
+
+static struct efuse_info_item len_sdio = {
+	6, /* mac_addr */
+	0, /* pid */
+	0, /* did */
+	0, /* vid */
+	0, /* svid */
+	0, /* smid */
+};
+
+static struct efuse_info efuse_info_pcie = {
+	&offset_pcie, /* offset */
+	&def_val_pcie, /* def_val */
+	&len_pcie, /* len */
+};
+
+static struct efuse_info efuse_info_usb_8852a = {
+	&offset_usb_8852a, /* offset */
+	&def_val_usb_8852a, /* def_val */
+	&len_usb, /* len */
+};
+
+static struct efuse_info efuse_info_usb_8852b = {
+	&offset_usb_8852b, /* offset */
+	&def_val_usb_8852b, /* def_val */
+	&len_usb, /* len */
+};
+
+static struct efuse_info efuse_info_sdio = {
+	&offset_sdio, /* offset */
+	&def_val_sdio, /* def_val */
+	&len_sdio, /* len */
+};
+
+static u32 efuse_map_init(struct mac_ax_adapter *adapter,
+			  enum efuse_map_sel map_sel);
+static u32 efuse_fwcmd_ck(struct mac_ax_adapter *adapter);
+static u32 efuse_proc_ck(struct mac_ax_adapter *adapter);
+static u32 cnv_efuse_state(struct mac_ax_adapter *adapter, u8 dest_state);
+static u32 proc_dump_efuse(struct mac_ax_adapter *adapter,
+			   enum mac_ax_efuse_read_cfg cfg);
+static u32 read_hw_efuse(struct mac_ax_adapter *adapter, u32 offset, u32 size,
+			 u8 *map);
+static u32 write_hw_efuse(struct mac_ax_adapter *adapter, u32 offset, u8 value);
+static u32 cmp_hw_efuse(struct mac_ax_adapter *adapter, u32 offset, u16 val);
+static u32 eeprom_parser(struct mac_ax_adapter *adapter, u8 *phy_map,
+			 u8 *log_map, enum mac_ax_efuse_parser_cfg cfg);
+static u32 read_log_efuse_map(struct mac_ax_adapter *adapter, u8 *map,
+			      u32 log_efuse_size);
+static u32 proc_pg_efuse_by_map(struct mac_ax_adapter *adapter,
+				struct mac_ax_pg_efuse_info *info,
+				enum mac_ax_efuse_read_cfg cfg);
+static u32 dump_efuse_drv(struct mac_ax_adapter *adapter);
+static u32 dump_efuse_fw(struct mac_ax_adapter *adapter);
+static u32 proc_write_log_efuse(struct mac_ax_adapter *adapter, u32 offset,
+				u8 value);
+static u32 read_efuse(struct mac_ax_adapter *adapter, u32 offset, u32 size,
+		      u8 *map);
+static u32 update_eeprom_mask(struct mac_ax_adapter *adapter,
+			      struct mac_ax_pg_efuse_info *info,
+			      u8 *updated_mask, bool pg_sim);
+static u32 check_efuse_enough(struct mac_ax_adapter *adapter,
+			      struct mac_ax_pg_efuse_info *info,
+			      u8 *updated_mask);
+static u32 proc_pg_efuse(struct mac_ax_adapter *adapter,
+			 struct mac_ax_pg_efuse_info *info, u8 word_en,
+			 u8 pre_word_en, u32 eeprom_offset, bool pg_sim);
+static u32 program_efuse(struct mac_ax_adapter *adapter,
+			 struct mac_ax_pg_efuse_info *info, u8 *updated_mask,
+			 bool pg_sim);
+static void mask_eeprom(struct mac_ax_adapter *adapter,
+			struct mac_ax_pg_efuse_info *info);
+static u32 query_status_map(struct mac_ax_adapter *adapter,
+			    enum mac_ax_efuse_feature_id feature_id,
+			    u8 *map, bool is_limit);
+static u32 adjust_mask(struct mac_ax_adapter *adapter,
+		       struct mac_ax_pg_efuse_info *info);
+static u32 compare_info_length(struct efuse_info *info,
+			       enum rtw_efuse_info id, u32 length);
+static u32 set_check_sum_val(struct mac_ax_adapter *adapter,
+			     u8 *map, u16 value);
+static void cal_check_sum(struct mac_ax_adapter *adapter,
+			  u16 *chksum);
+static u32 compare_version(struct mac_ax_adapter *adapter,
+			   struct mac_ax_pg_efuse_info *info, u32 ver_len);
+static u32 read_hw_efuse_dav(struct mac_ax_adapter *adapter, u32 offset, u32 size,
+			     u8 *map);
+static u32 write_hw_efuse_dav(struct mac_ax_adapter *adapter, u32 offset,
+			      u8 value);
+static void switch_dv(struct mac_ax_adapter *adapter, enum rtw_dv_sel);
+static void free_map_mask(struct mac_ax_adapter *adapter, u32 ver_len,
+			  struct mac_ax_pg_efuse_info *info_DAV,
+			  struct mac_ax_pg_efuse_info *info_DDV);
+static u32 proc_dump_hidden(struct mac_ax_adapter *adapter);
+
+u32 mac_dump_efuse_map_wl_plus(struct mac_ax_adapter *adapter,
+			       enum mac_ax_efuse_read_cfg cfg, u8 *efuse_map)
+{
+	u32 ret = 0;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u8 chip_id = hw_info->chip_id;
+	bool dav_exist = (hw_info->dav_full_efuse_size == 0) ? false : true;
+
+	if (chip_id == MAC_AX_CHIP_ID_8852A) {
+		ret = mac_dump_efuse_map_wl(adapter, cfg, efuse_map);
+	} else if ((chip_id == MAC_AX_CHIP_ID_8852B) ||
+		   (chip_id == MAC_AX_CHIP_ID_8852C) ||
+		   (chip_id == MAC_AX_CHIP_ID_8851E) ||
+		   (chip_id == MAC_AX_CHIP_ID_8852D)) {
+		ret = mac_dump_efuse_map_wl(adapter, cfg, efuse_map);
+		if (ret)
+			return ret;
+		if (dav_exist) {
+			switch_dv(adapter, DAV);
+			ret = mac_dump_efuse_map_wl(adapter, cfg, efuse_map + hw_info->efuse_size);
+			switch_dv(adapter, DDV);
+		}
+	} else {
+		ret = mac_dump_efuse_map_wl(adapter, cfg, efuse_map);
+		if (ret)
+			return ret;
+		if (dav_exist) {
+			switch_dv(adapter, DAV);
+			ret = mac_dump_efuse_map_wl(adapter, MAC_AX_EFUSE_R_DRV,
+						    efuse_map + hw_info->efuse_size);
+			switch_dv(adapter, DDV);
+		}
+	}
+
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_dump_efuse_map_wl(struct mac_ax_adapter *adapter,
+			  enum mac_ax_efuse_read_cfg cfg, u8 *efuse_map)
+{
+	u32 ret, stat;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	enum rtw_dv_sel dv_sel = adapter->efuse_param.dv_sel;
+
+#if 0
+	if (cfg == MAC_AX_EFUSE_R_FW ||
+	    (cfg == MAC_AX_EFUSE_R_AUTO &&
+	     adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY))
+		return MACNOITEM;
+#else
+	if (cfg == MAC_AX_EFUSE_R_FW &&
+	    adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) // no fw file
+		return MACNOFW;
+#endif
+
+	PLTFM_MSG_TRACE("[TRACE]cfg = %d\n", cfg);
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_PHY);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank!!\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	if (dv_sel == DAV)
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_DAV);
+	else
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_WL);
+	if (ret != 0)
+		return ret;
+
+	ret = proc_dump_efuse(adapter, cfg);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]dump efuse!!\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	query_status_map(adapter, MAC_AX_DUMP_PHYSICAL_EFUSE, efuse_map, 0);
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_dump_efuse_map_bt(struct mac_ax_adapter *adapter,
+			  enum mac_ax_efuse_read_cfg cfg, u8 *efuse_map)
+{
+	u32 ret, stat;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+#if 0
+	if (cfg == MAC_AX_EFUSE_R_FW ||
+	    (cfg == MAC_AX_EFUSE_R_AUTO &&
+	     adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY))
+		return MACNOITEM;
+#else
+	if (cfg == MAC_AX_EFUSE_R_FW &&
+	    adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) // no fw file
+		return MACNOFW;
+#endif
+
+	PLTFM_MSG_TRACE("[TRACE]cfg = %d\n", cfg);
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_PHY);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_BT);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank!!\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_BT);
+	if (ret != 0)
+		return ret;
+
+	ret = proc_dump_efuse(adapter, cfg);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]dump efuse!!\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	query_status_map(adapter, MAC_AX_DUMP_PHYSICAL_EFUSE, efuse_map, 0);
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_efuse_plus(struct mac_ax_adapter *adapter, u32 addr, u8 val,
+			 enum mac_ax_efuse_bank bank)
+{
+	u32 ret = 0;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u8 chip_id = hw_info->chip_id;
+	u32 efuse_size = hw_info->wl_efuse_size;
+	bool dav_exist = (hw_info->dav_full_efuse_size == 0) ? false : true;
+
+	switch (bank) {
+	case MAC_AX_EFUSE_BANK_WIFI:
+		if (chip_id == MAC_AX_CHIP_ID_8852A) {
+			ret = mac_write_efuse(adapter, addr, val, bank);
+		} else {
+			if (addr < efuse_size) {
+				ret = mac_write_efuse(adapter, addr, val, bank);
+			} else {
+				if (dav_exist) {
+					switch_dv(adapter, DAV);
+					ret = mac_write_efuse(adapter, addr -
+							      efuse_size, val, bank);
+					switch_dv(adapter, DDV);
+				}
+			}
+		}
+		break;
+	case MAC_AX_EFUSE_BANK_BT:
+		ret = mac_write_efuse(adapter, addr, val, bank);
+		break;
+	default:
+		break;
+	}
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_efuse(struct mac_ax_adapter *adapter, u32 addr, u8 val,
+		    enum mac_ax_efuse_bank bank)
+{
+	u32 ret, stat, efuse_size = 0;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	bool OTP_test = adapter->efuse_param.OTP_test;
+
+	if (bank == MAC_AX_EFUSE_BANK_WIFI) {
+		if (OTP_test)
+			efuse_size = OTP_PHY_SIZE;
+		else
+			efuse_size = adapter->hw_info->wl_efuse_size;
+	} else if (bank == MAC_AX_EFUSE_BANK_BT) {
+		efuse_size = adapter->hw_info->bt_efuse_size;
+	} else {
+		return MACEFUSEBANK;
+	}
+
+	if (addr >= efuse_size) {
+		PLTFM_MSG_ERR("[ERR]Offset is too large\n");
+		return MACEFUSESIZE;
+	}
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_PHY);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, bank);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	p_ops->enable_efuse_sw_pwr_cut(adapter, 1);
+	ret = write_hw_efuse(adapter, addr, val);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]write physical efuse\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+	p_ops->disable_efuse_sw_pwr_cut(adapter, 1);
+
+	if (bank == MAC_AX_EFUSE_BANK_BT) {
+		ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+		if (ret != 0) {
+			PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+			stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+			if (stat != 0)
+				return stat;
+			return ret;
+		}
+	}
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return ret;
+}
+
+u32 mac_read_efuse_plus(struct mac_ax_adapter *adapter, u32 addr, u32 size,
+			u8 *val, enum mac_ax_efuse_bank bank)
+{
+	u32 ret = 0;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u8 chip_id = hw_info->chip_id;
+	u32 efuse_size = hw_info->wl_efuse_size;
+	u32 size1, size2;
+	bool dav_exist = (hw_info->dav_full_efuse_size == 0) ? false : true;
+
+	switch (bank) {
+	case MAC_AX_EFUSE_BANK_WIFI:
+		if (chip_id == MAC_AX_CHIP_ID_8852A) {
+			ret =  mac_read_efuse(adapter, addr, size, val, bank);
+		} else {
+			if (addr < efuse_size && addr + size <= efuse_size) {
+				ret = mac_read_efuse(adapter, addr, size,
+						     val, bank);
+			} else if (addr >= efuse_size) {
+				if (dav_exist) {
+					switch_dv(adapter, DAV);
+					ret = mac_read_efuse(adapter, addr - efuse_size,
+							     size, val, bank);
+					switch_dv(adapter, DDV);
+				}
+			} else if (addr < efuse_size &&
+				   addr + size > efuse_size) {
+				size1 = efuse_size - addr;
+				size2 = addr + size - efuse_size;
+
+				ret = mac_read_efuse(adapter, addr, size1,
+						     val, bank);
+				if (ret)
+					return ret;
+				if (dav_exist) {
+					switch_dv(adapter, DAV);
+					ret = mac_read_efuse(adapter, 0, size2,
+							     val + size1, bank);
+					switch_dv(adapter, DDV);
+				}
+			}
+		}
+		break;
+	case MAC_AX_EFUSE_BANK_BT:
+		ret =  mac_read_efuse(adapter, addr, size, val, bank);
+		break;
+	default:
+		break;
+	}
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_read_efuse(struct mac_ax_adapter *adapter, u32 addr, u32 size, u8 *val,
+		   enum mac_ax_efuse_bank bank)
+{
+	u32 ret, stat, efuse_size = 0;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	bool OTP_test = adapter->efuse_param.OTP_test;
+
+	if (bank == MAC_AX_EFUSE_BANK_WIFI) {
+		if (OTP_test)
+			efuse_size = OTP_PHY_SIZE;
+		else
+			efuse_size = adapter->hw_info->wl_efuse_size;
+	} else if (bank == MAC_AX_EFUSE_BANK_BT) {
+		efuse_size = adapter->hw_info->bt_efuse_size;
+	} else {
+		return MACEFUSEBANK;
+	}
+
+	if (addr >= efuse_size || addr + size > efuse_size) {
+		PLTFM_MSG_ERR("[ERR] Wrong efuse index\n");
+		return MACEFUSESIZE;
+	}
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_PHY);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, bank);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = read_hw_efuse(adapter, addr, size, val);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]read hw efuse\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	if (bank == MAC_AX_EFUSE_BANK_BT) {
+		ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+		if (ret != 0) {
+			PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+			stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+			if (stat != 0)
+				return stat;
+			return ret;
+		}
+	}
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_read_hidden_efuse(struct mac_ax_adapter *adapter, u32 addr, u32 size,
+			  u8 *val, enum mac_ax_efuse_hidden_cfg hidden_cfg)
+{
+	u32 ret, stat;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 log_sec_size = hw_info->efuse_size + hw_info->sec_data_efuse_size;
+
+	switch (hidden_cfg) {
+	case MAC_AX_EFUSE_HIDDEN_RF:
+		if (addr < log_sec_size || addr + size >
+		    log_sec_size + hw_info->hidden_efuse_rf_size) {
+			PLTFM_MSG_ERR("[ERR] Wrong hidden rf index\n");
+			return MACEFUSESIZE;
+		}
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR] Hidden config invalid\n");
+		return MACNOITEM;
+	}
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_PHY);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank!!\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = efuse_map_init(adapter, EFUSE_MAP_SEL_HIDDEN_RF);
+	if (ret != 0)
+		return ret;
+
+	ret = proc_dump_hidden(adapter);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]dump hidden!!\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	PLTFM_MEMCPY(val, adapter->efuse_param.hidden_rf_map +
+		     (addr - log_sec_size), size);
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+static u32 proc_dump_hidden(struct mac_ax_adapter *adapter)
+{
+	u8 *map = NULL;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u32 efuse_size = hw_info->efuse_size;
+	u32 sec_data_efuse_size = hw_info->sec_data_efuse_size;
+	u32 hidden_efuse_rf_size = hw_info->hidden_efuse_rf_size;
+	u8 hidden_rf_map_valid = adapter->efuse_param.hidden_rf_map_valid;
+	u32 ret;
+
+	if (hidden_rf_map_valid == 0) {
+		map = (u8 *)PLTFM_MALLOC(hidden_efuse_rf_size);
+		if (!map) {
+			PLTFM_MSG_ERR("[ERR]malloc map\n");
+			return MACBUFALLOC;
+		}
+
+		ret = read_hw_efuse(adapter, efuse_size + sec_data_efuse_size,
+				    hidden_efuse_rf_size, map);
+		if (ret != 0) {
+			PLTFM_FREE(map, hidden_efuse_rf_size);
+			return ret;
+		}
+
+		PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+		PLTFM_MEMCPY(adapter->efuse_param.hidden_rf_map, map, hidden_efuse_rf_size);
+		adapter->efuse_param.hidden_rf_map_valid = 1;
+		PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+		PLTFM_FREE(map, hidden_efuse_rf_size);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_efuse_avl_size(struct mac_ax_adapter *adapter, u32 *size)
+{
+	u32 ret;
+	u8 *map;
+	u32 efuse_size = adapter->hw_info->log_efuse_size;
+	struct mac_ax_efuse_param *efuse_param = &adapter->efuse_param;
+
+	map = (u8 *)PLTFM_MALLOC(efuse_size);
+	if (!map) {
+		PLTFM_MSG_ERR("[ERR]malloc map\n");
+		return MACBUFALLOC;
+	}
+
+	ret = mac_dump_log_efuse(adapter, MAC_AX_EFUSE_PARSER_MAP,
+				 MAC_AX_EFUSE_R_AUTO, map, 0);
+
+	PLTFM_FREE(map, efuse_size);
+
+	if (ret != 0)
+		return ret;
+
+	*size = adapter->hw_info->efuse_size - efuse_param->efuse_end;
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_efuse_avl_size_bt(struct mac_ax_adapter *adapter, u32 *size)
+{
+	u32 ret;
+	u8 *map;
+	u32 efuse_size = adapter->hw_info->bt_log_efuse_size;
+	struct mac_ax_efuse_param *efuse_param = &adapter->efuse_param;
+
+	map = (u8 *)PLTFM_MALLOC(efuse_size);
+	if (!map) {
+		PLTFM_MSG_ERR("[ERR]malloc map\n");
+		return MACBUFALLOC;
+	}
+
+	ret = mac_dump_log_efuse_bt(adapter, MAC_AX_EFUSE_PARSER_MAP,
+				    MAC_AX_EFUSE_R_DRV, map);
+
+	PLTFM_FREE(map, efuse_size);
+
+	if (ret != 0)
+		return ret;
+
+	*size = adapter->hw_info->bt_efuse_size - efuse_param->bt_efuse_end;
+
+	return MACSUCCESS;
+}
+
+u32 mac_dump_log_efuse_plus(struct mac_ax_adapter *adapter,
+			    enum mac_ax_efuse_parser_cfg parser_cfg,
+			    enum mac_ax_efuse_read_cfg cfg,
+			    u8 *efuse_map, bool is_limit)
+{
+	u32 ret = 0;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u8 chip_id = hw_info->chip_id;
+	enum mac_ax_intf intf = adapter->hw_info->intf;
+	u32 map_size = hw_info->log_efuse_size;
+	bool dav_exist = (hw_info->dav_full_efuse_size == 0) ? false : true;
+
+	if (chip_id == MAC_AX_CHIP_ID_8852A) {
+		ret = mac_dump_log_efuse(adapter, parser_cfg, cfg,
+					 efuse_map, is_limit);
+	} else {
+		ret = mac_dump_log_efuse(adapter, parser_cfg, cfg,
+					 efuse_map, is_limit);
+		if (ret)
+			return ret;
+
+		if (dav_exist) {
+			switch_dv(adapter, DAV);
+			if (is_limit) {
+				switch (intf) {
+				case MAC_AX_INTF_PCIE:
+					map_size = hw_info->limit_efuse_size_pcie;
+					break;
+				case MAC_AX_INTF_USB:
+					map_size = hw_info->limit_efuse_size_usb;
+					break;
+				case MAC_AX_INTF_SDIO:
+					map_size = hw_info->limit_efuse_size_sdio;
+					break;
+				default:
+					break;
+				}
+			}
+			if ((is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) ||
+			    (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C)) ||
+			    (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E)) ||
+			    (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))) {
+				ret = mac_dump_log_efuse(adapter, parser_cfg, cfg,
+							 efuse_map + map_size, 0);
+			} else {
+				ret = mac_dump_log_efuse(adapter, parser_cfg,
+							 MAC_AX_EFUSE_R_DRV,
+							 efuse_map + map_size, 0);
+			}
+			switch_dv(adapter, DDV);
+		}
+	}
+
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_dump_log_efuse(struct mac_ax_adapter *adapter,
+		       enum mac_ax_efuse_parser_cfg parser_cfg,
+		       enum mac_ax_efuse_read_cfg cfg,
+		       u8 *efuse_map, bool is_limit)
+{
+	u8 *map = NULL;
+	u32 ret, stat;
+	u32 efuse_size;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	enum rtw_dv_sel dv_sel = adapter->efuse_param.dv_sel;
+
+#if 0
+	if (cfg == MAC_AX_EFUSE_R_FW ||
+	    (cfg == MAC_AX_EFUSE_R_AUTO &&
+	     adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY))
+		return MACNOITEM;
+#else
+	if (cfg == MAC_AX_EFUSE_R_FW &&
+	    adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+#endif
+	PLTFM_MSG_TRACE("[TRACE]cfg = %d\n", cfg);
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_LOG_MAP);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank!!\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	efuse_size = *bank_efuse_info->log_map_size;
+
+	if (dv_sel == DAV) {
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_DAV);
+		if (ret != 0)
+			return ret;
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG_DAV);
+	} else {
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG);
+		if (ret != 0)
+			return ret;
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_WL);
+	}
+	if (ret)
+		return ret;
+
+	if (*bank_efuse_info->log_map_valid == 0) {
+		ret = proc_dump_efuse(adapter, cfg);
+		if (ret != 0) {
+			PLTFM_MSG_ERR("[ERR]dump efuse\n");
+			stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+			if (stat != 0)
+				return stat;
+			return ret;
+		}
+
+		if (*bank_efuse_info->phy_map_valid == 1) {
+			map = (u8 *)PLTFM_MALLOC(efuse_size);
+			if (!map) {
+				PLTFM_MSG_ERR("[ERR]malloc map\n");
+				stat = cnv_efuse_state(adapter,
+						       MAC_AX_EFUSE_IDLE);
+				if (stat != 0)
+					return stat;
+				return MACBUFALLOC;
+			}
+
+			ret = eeprom_parser(adapter, *bank_efuse_info->phy_map,
+					    map, parser_cfg);
+			if (ret != 0) {
+				PLTFM_FREE(map, efuse_size);
+				stat = cnv_efuse_state(adapter,
+						       MAC_AX_EFUSE_IDLE);
+				if (stat != 0)
+					return stat;
+				return ret;
+			}
+			PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+			PLTFM_MEMCPY(*bank_efuse_info->log_map, map,
+				     efuse_size);
+			*bank_efuse_info->log_map_valid = 1;
+			PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+			PLTFM_FREE(map, efuse_size);
+		}
+	}
+
+	query_status_map(adapter, MAC_AX_DUMP_LOGICAL_EFUSE,
+			 efuse_map, is_limit);
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_read_log_efuse_plus(struct mac_ax_adapter *adapter, u32 addr, u32 size,
+			    u8 *val)
+{
+	u32 ret = 0;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u8 chip_id = hw_info->chip_id;
+	u32 efuse_size = hw_info->log_efuse_size;
+	u32 size1, size2;
+	bool dav_exist = (hw_info->dav_full_efuse_size == 0) ? false : true;
+
+	if (chip_id == MAC_AX_CHIP_ID_8852A) {
+		ret = mac_read_log_efuse(adapter, addr, size, val);
+	} else {
+		if (addr < efuse_size && addr + size <= efuse_size) {
+			ret = mac_read_log_efuse(adapter, addr, size, val);
+		} else if (addr >= efuse_size) {
+			if (dav_exist) {
+				switch_dv(adapter, DAV);
+				ret = mac_read_log_efuse(adapter, addr - efuse_size,
+							 size, val);
+				switch_dv(adapter, DDV);
+			}
+		} else if (addr < efuse_size && addr + size > efuse_size) {
+			size1 = efuse_size - addr;
+			size2 = addr + size - efuse_size;
+
+			ret = mac_read_log_efuse(adapter, addr, size1, val);
+			if (ret)
+				return ret;
+
+			if (dav_exist) {
+				switch_dv(adapter, DAV);
+				ret = mac_read_log_efuse(adapter, 0, size2,
+							 val + size1);
+				switch_dv(adapter, DDV);
+			}
+		}
+	}
+
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_read_log_efuse(struct mac_ax_adapter *adapter, u32 addr, u32 size,
+		       u8 *val)
+{
+	u8 *map = NULL;
+	u32 ret = 0, stat;
+	u32 efuse_size;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	enum rtw_dv_sel dv_sel = adapter->efuse_param.dv_sel;
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_LOG_MAP);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank!!\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	efuse_size = *bank_efuse_info->log_map_size;
+
+	if (addr >= efuse_size || addr + size > efuse_size) {
+		PLTFM_MSG_ERR("[ERR] Wrong efuse index\n");
+		return MACEFUSESIZE;
+	}
+
+	if (dv_sel == DAV) {
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_DAV);
+		if (ret)
+			return ret;
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG_DAV);
+	} else {
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_WL);
+		if (ret)
+			return ret;
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG);
+	}
+	if (ret)
+		return ret;
+
+	map = (u8 *)PLTFM_MALLOC(efuse_size);
+	if (!map) {
+		PLTFM_MSG_ERR("[ERR]malloc map\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return MACBUFALLOC;
+	}
+
+	ret = read_log_efuse_map(adapter, map, efuse_size);
+	if (ret != 0) {
+		PLTFM_FREE(map, efuse_size);
+		PLTFM_MSG_ERR("[ERR]read logical efuse\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+	PLTFM_MEMCPY(val, map + addr, size);
+	PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+	PLTFM_FREE(map, efuse_size);
+
+	stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (stat != 0)
+		return stat;
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_log_efuse_plus(struct mac_ax_adapter *adapter, u32 addr, u8 val)
+{
+	u32 ret = 0;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u8 chip_id = hw_info->chip_id;
+	u32 efuse_size = hw_info->log_efuse_size;
+	bool dav_exist = (hw_info->dav_full_efuse_size == 0) ? false : true;
+
+	if (chip_id == MAC_AX_CHIP_ID_8852A) {
+		ret = mac_write_log_efuse(adapter, addr, val);
+	} else {
+		if (addr < efuse_size) {
+			ret = mac_write_log_efuse(adapter, addr, val);
+		} else {
+			if (dav_exist) {
+				switch_dv(adapter, DAV);
+				ret = mac_write_log_efuse(adapter,
+							  addr - efuse_size, val);
+				switch_dv(adapter, DDV);
+			}
+		}
+	}
+
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_log_efuse(struct mac_ax_adapter *adapter, u32 addr, u8 val)
+{
+	u32 ret, stat;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	enum rtw_dv_sel dv_sel = adapter->efuse_param.dv_sel;
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_LOG_MAP);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	if (addr >= *bank_efuse_info->log_map_size) {
+		PLTFM_MSG_ERR("[ERR]addr is too large\n");
+		return MACEFUSESIZE;
+	}
+
+	if (dv_sel == DAV) {
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_DAV);
+		if (ret)
+			return ret;
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG_DAV);
+	} else {
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_WL);
+		if (ret)
+			return ret;
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG);
+	}
+	if (ret)
+		return ret;
+
+	ret = proc_write_log_efuse(adapter, addr, val);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]write logical efuse\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_dump_log_efuse_bt(struct mac_ax_adapter *adapter,
+			  enum mac_ax_efuse_parser_cfg parser_cfg,
+			  enum mac_ax_efuse_read_cfg cfg,
+			  u8 *efuse_map)
+{
+	u8 *map = NULL;
+	u32 ret, stat;
+	u32 efuse_size = adapter->hw_info->bt_log_efuse_size;
+	struct mac_ax_efuse_param *efuse_param = &adapter->efuse_param;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+#if 0
+	if (cfg == MAC_AX_EFUSE_R_FW ||
+	    (cfg == MAC_AX_EFUSE_R_AUTO &&
+	     adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY))
+		return MACNOITEM;
+#else
+	if (cfg == MAC_AX_EFUSE_R_FW &&
+	    adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+#endif
+
+	PLTFM_MSG_TRACE("[TRACE]cfg = %d\n", cfg);
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_LOG_MAP);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_BT);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank!!\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG_BT);
+	if (ret != 0)
+		return ret;
+	ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_BT);
+	if (ret != 0)
+		return ret;
+
+	if (efuse_param->bt_log_efuse_map_valid == 0) {
+		ret = proc_dump_efuse(adapter, cfg);
+		if (ret != 0) {
+			PLTFM_MSG_ERR("[ERR]dump efuse\n");
+			stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+			if (stat != 0)
+				return stat;
+			return ret;
+		}
+
+		if (efuse_param->bt_efuse_map_valid == 1) {
+			map = (u8 *)PLTFM_MALLOC(efuse_size);
+			if (!map) {
+				PLTFM_MSG_ERR("[ERR]malloc map\n");
+				stat = cnv_efuse_state(adapter,
+						       MAC_AX_EFUSE_IDLE);
+				if (stat != 0)
+					return stat;
+				return MACBUFALLOC;
+			}
+
+			ret = eeprom_parser(adapter, efuse_param->bt_efuse_map,
+					    map, parser_cfg);
+			if (ret != 0) {
+				PLTFM_FREE(map, efuse_size);
+				stat = cnv_efuse_state(adapter,
+						       MAC_AX_EFUSE_IDLE);
+				if (stat != 0)
+					return stat;
+				return ret;
+			}
+			PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+			PLTFM_MEMCPY(efuse_param->bt_log_efuse_map, map,
+				     efuse_size);
+			efuse_param->bt_log_efuse_map_valid = 1;
+			PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+			PLTFM_FREE(map, efuse_size);
+		}
+	}
+
+	query_status_map(adapter, MAC_AX_DUMP_LOGICAL_EFUSE, efuse_map, 0);
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_read_log_efuse_bt(struct mac_ax_adapter *adapter, u32 addr, u32 size,
+			  u8 *val)
+{
+	u8 *map = NULL;
+	u32 ret, stat;
+	u32 efuse_size = adapter->hw_info->bt_log_efuse_size;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	if (addr >= efuse_size || addr + size > efuse_size) {
+		PLTFM_MSG_ERR("[ERR] Wrong efuse index\n");
+		return MACEFUSESIZE;
+	}
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_LOG_MAP);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_BT);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank!!\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_BT);
+	if (ret)
+		return ret;
+	ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG_BT);
+	if (ret)
+		return ret;
+
+	map = (u8 *)PLTFM_MALLOC(efuse_size);
+	if (!map) {
+		PLTFM_MSG_ERR("[ERR]malloc map\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return MACBUFALLOC;
+	}
+	PLTFM_MEMSET(map, 0xFF, efuse_size);
+
+	ret = read_log_efuse_map(adapter, map, efuse_size);
+	if (ret != 0) {
+		PLTFM_FREE(map, efuse_size);
+		PLTFM_MSG_ERR("[ERR]read logical efuse\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+	PLTFM_MEMCPY(val, map + addr, size);
+	PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+	PLTFM_FREE(map, efuse_size);
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (stat != 0)
+		return stat;
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_log_efuse_bt(struct mac_ax_adapter *adapter, u32 addr, u8 val)
+{
+	u32 ret, stat;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	if (addr >= adapter->hw_info->log_efuse_size) {
+		PLTFM_MSG_ERR("[ERR]addr is too large\n");
+		return MACEFUSESIZE;
+	}
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_LOG_MAP);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_BT);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_BT);
+	if (ret)
+		return ret;
+	ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG_BT);
+	if (ret)
+		return ret;
+
+	ret = proc_write_log_efuse(adapter, addr, val);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]write logical efuse\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_pg_efuse_by_map_plus(struct mac_ax_adapter *adapter,
+			     struct mac_ax_pg_efuse_info *info,
+			     enum mac_ax_efuse_read_cfg cfg,
+			     bool part, bool is_limit)
+{
+	u8 chip_id = adapter->hw_info->chip_id;
+	u32 ret;
+	struct mac_ax_pg_efuse_info info_DAV = {0};
+	struct mac_ax_pg_efuse_info info_DDV = {0};
+	u32 ver_len = 0;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	enum mac_ax_intf intf = adapter->hw_info->intf;
+	u32 map_size = adapter->hw_info->log_efuse_size;
+	bool dav_exist = (hw_info->dav_full_efuse_size == 0) ? false : true;
+
+	ret = mac_get_hw_value(adapter,
+			       MAC_AX_HW_GET_EFUSE_VERSION_SIZE, &ver_len);
+	if (ret)
+		return ret;
+
+	if (chip_id == MAC_AX_CHIP_ID_8852A) {
+		ret = mac_pg_efuse_by_map(adapter, info, cfg, part, is_limit);
+		if (ret)
+			return ret;
+	} else {
+		if (is_limit) {
+			switch (intf) {
+			case MAC_AX_INTF_PCIE:
+				map_size = hw_info->limit_efuse_size_pcie;
+				break;
+			case MAC_AX_INTF_USB:
+				map_size = hw_info->limit_efuse_size_usb;
+				break;
+			case MAC_AX_INTF_SDIO:
+				map_size = hw_info->limit_efuse_size_sdio;
+				break;
+			default:
+				break;
+			}
+		}
+
+		/* a-die */
+		info_DAV.efuse_map_size = hw_info->dav_log_efuse_size;
+		info_DAV.efuse_mask_size = hw_info->dav_log_efuse_size >> 4;
+
+		info_DAV.efuse_map =
+			(u8 *)PLTFM_MALLOC(info_DAV.efuse_map_size + ver_len);
+		if (!info_DAV.efuse_map) {
+			PLTFM_MSG_ERR("[ERR]malloc map\n");
+			return MACBUFALLOC;
+		}
+		info_DAV.efuse_mask =
+			(u8 *)PLTFM_MALLOC(info_DAV.efuse_mask_size + ver_len);
+		if (!info_DAV.efuse_mask) {
+			free_map_mask(adapter, ver_len, &info_DAV, &info_DDV);
+			PLTFM_MSG_ERR("[ERR]malloc map\n");
+			return MACBUFALLOC;
+		}
+
+		PLTFM_MEMCPY(info_DAV.efuse_map, info->efuse_map + map_size,
+			     info_DAV.efuse_map_size + ver_len);
+		PLTFM_MEMCPY(info_DAV.efuse_mask,
+			     info->efuse_mask + (map_size >> 4),
+			     info_DAV.efuse_mask_size + ver_len);
+
+		/* d-die */
+		info_DDV.efuse_map_size =
+			info->efuse_map_size - info_DAV.efuse_map_size;
+		info_DDV.efuse_mask_size =
+			info->efuse_mask_size - info_DAV.efuse_mask_size;
+
+		info_DDV.efuse_map =
+			(u8 *)PLTFM_MALLOC(info_DDV.efuse_map_size + ver_len);
+		if (!info_DDV.efuse_map) {
+			free_map_mask(adapter, ver_len, &info_DAV, &info_DDV);
+			PLTFM_MSG_ERR("[ERR]malloc map\n");
+			return MACBUFALLOC;
+		}
+		info_DDV.efuse_mask =
+			(u8 *)PLTFM_MALLOC(info_DDV.efuse_mask_size + ver_len);
+		if (!info_DDV.efuse_mask) {
+			free_map_mask(adapter, ver_len, &info_DAV, &info_DDV);
+			PLTFM_MSG_ERR("[ERR]malloc map\n");
+			return MACBUFALLOC;
+		}
+
+		PLTFM_MEMCPY(info_DDV.efuse_map, info->efuse_map,
+			     info_DDV.efuse_map_size);
+		PLTFM_MEMCPY(info_DDV.efuse_map + info_DDV.efuse_map_size,
+			     info->efuse_map + info->efuse_map_size, ver_len);
+
+		PLTFM_MEMCPY(info_DDV.efuse_mask, info->efuse_mask,
+			     info_DDV.efuse_mask_size);
+		PLTFM_MEMCPY(info_DDV.efuse_mask + info_DDV.efuse_mask_size,
+			     info->efuse_mask + info->efuse_mask_size, ver_len);
+
+		ret = mac_pg_efuse_by_map(adapter,
+					  &info_DDV, cfg, part, is_limit);
+		if (ret) {
+			free_map_mask(adapter, ver_len, &info_DAV, &info_DDV);
+			return ret;
+		}
+
+		if (dav_exist) {
+			switch_dv(adapter, DAV);
+			ret = mac_pg_efuse_by_map(adapter,
+						  &info_DAV, cfg, part, 0);
+			if (ret) {
+				free_map_mask(adapter, ver_len, &info_DAV, &info_DDV);
+				return ret;
+			}
+			switch_dv(adapter, DDV);
+		}
+	}
+
+	free_map_mask(adapter, ver_len, &info_DAV, &info_DDV);
+	return MACSUCCESS;
+}
+
+static void free_map_mask(struct mac_ax_adapter *adapter, u32 ver_len,
+			  struct mac_ax_pg_efuse_info *info_DAV,
+			  struct mac_ax_pg_efuse_info *info_DDV)
+{
+	if (info_DAV->efuse_map)
+		PLTFM_FREE(info_DAV->efuse_map,
+			   info_DAV->efuse_map_size + ver_len);
+	if (info_DAV->efuse_mask)
+		PLTFM_FREE(info_DAV->efuse_mask,
+			   info_DAV->efuse_mask_size + ver_len);
+	if (info_DDV->efuse_map)
+		PLTFM_FREE(info_DDV->efuse_map,
+			   info_DDV->efuse_map_size + ver_len);
+	if (info_DDV->efuse_mask)
+		PLTFM_FREE(info_DDV->efuse_mask,
+			   info_DDV->efuse_mask_size + ver_len);
+}
+
+u32 mac_pg_efuse_by_map(struct mac_ax_adapter *adapter,
+			struct mac_ax_pg_efuse_info *info,
+			enum mac_ax_efuse_read_cfg cfg,
+			bool part, bool is_limit)
+{
+	u32 ret, stat;
+	enum mac_ax_intf intf = adapter->hw_info->intf;
+	u32 map_size = adapter->hw_info->log_efuse_size;
+	u32 ver_len = 0;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	enum rtw_dv_sel dv_sel = adapter->efuse_param.dv_sel;
+
+	if (is_limit) {
+		switch (intf) {
+		case MAC_AX_INTF_PCIE:
+			map_size = adapter->hw_info->limit_efuse_size_pcie;
+			break;
+		case MAC_AX_INTF_USB:
+			map_size = adapter->hw_info->limit_efuse_size_usb;
+			break;
+		case MAC_AX_INTF_SDIO:
+			map_size = adapter->hw_info->limit_efuse_size_sdio;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (dv_sel == DAV)
+		map_size = adapter->hw_info->dav_log_efuse_size;
+
+	if (info->efuse_map_size != map_size) {
+		PLTFM_MSG_ERR("[ERR]map size error\n");
+		return MACEFUSESIZE;
+	}
+
+	if ((info->efuse_map_size & 0xF) > 0) {
+		PLTFM_MSG_ERR("[ERR]not multiple of 16\n");
+		return MACEFUSESIZE;
+	}
+
+	if (info->efuse_mask_size != info->efuse_map_size >> 4) {
+		PLTFM_MSG_ERR("[ERR]mask size error\n");
+		return MACEFUSESIZE;
+	}
+
+	if (!info->efuse_map) {
+		PLTFM_MSG_ERR("[ERR]map is NULL\n");
+		return MACNPTR;
+	}
+
+	if (!info->efuse_mask) {
+		PLTFM_MSG_ERR("[ERR]mask is NULL\n");
+		return MACNPTR;
+	}
+
+	ret = mac_get_hw_value(adapter,
+			       MAC_AX_HW_GET_EFUSE_VERSION_SIZE, &ver_len);
+	if (ret)
+		return ret;
+	ret = compare_version(adapter, info, ver_len);
+	if (ret != 0)
+		return ret;
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_PHY);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	if (dv_sel == DAV) {
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_DAV);
+		if (ret)
+			return ret;
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG_DAV);
+	} else {
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_WL);
+		if (ret)
+			return ret;
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG);
+	}
+	if (ret)
+		return ret;
+
+	if (part)
+		ret = adjust_mask(adapter, info);
+	if (ret != 0) {
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = proc_pg_efuse_by_map(adapter, info, cfg);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]pg efuse\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_pg_efuse_by_map_bt(struct mac_ax_adapter *adapter,
+			   struct mac_ax_pg_efuse_info *info,
+			   enum mac_ax_efuse_read_cfg cfg)
+{
+	u32 ret, stat;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	if (info->efuse_map_size != adapter->hw_info->bt_log_efuse_size) {
+		PLTFM_MSG_ERR("[ERR]map size error\n");
+		return MACEFUSESIZE;
+	}
+
+	if ((info->efuse_map_size & 0xF) > 0) {
+		PLTFM_MSG_ERR("[ERR]not multiple of 16\n");
+		return MACEFUSESIZE;
+	}
+
+	if (info->efuse_mask_size != info->efuse_map_size >> 4) {
+		PLTFM_MSG_ERR("[ERR]mask size error\n");
+		return MACEFUSESIZE;
+	}
+
+	if (!info->efuse_map) {
+		PLTFM_MSG_ERR("[ERR]map is NULL\n");
+		return MACNPTR;
+	}
+
+	if (!info->efuse_mask) {
+		PLTFM_MSG_ERR("[ERR]mask is NULL\n");
+		return MACNPTR;
+	}
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_PHY);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_BT);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = proc_pg_efuse_by_map(adapter, info, cfg);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]pg efuse\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_mask_log_efuse(struct mac_ax_adapter *adapter,
+		       struct mac_ax_pg_efuse_info *info)
+{
+	if (info->efuse_map_size != adapter->hw_info->log_efuse_size) {
+		PLTFM_MSG_ERR("[ERR]map size error\n");
+		return MACEFUSESIZE;
+	}
+
+	if ((info->efuse_map_size & 0xF) > 0) {
+		PLTFM_MSG_ERR("[ERR]not multiple of 16\n");
+		return MACEFUSESIZE;
+	}
+
+	if (info->efuse_mask_size != info->efuse_map_size >> 4) {
+		PLTFM_MSG_ERR("[ERR]mask size error\n");
+		return MACEFUSESIZE;
+	}
+
+	if (!info->efuse_map) {
+		PLTFM_MSG_ERR("[ERR]map is NULL\n");
+		return MACNPTR;
+	}
+
+	if (!info->efuse_mask) {
+		PLTFM_MSG_ERR("[ERR]mask is NULL\n");
+		return MACNPTR;
+	}
+
+	mask_eeprom(adapter, info);
+
+	return MACSUCCESS;
+}
+
+u32 mac_pg_sec_data_by_map(struct mac_ax_adapter *adapter,
+			   struct mac_ax_pg_efuse_info *info)
+{
+	u32 ret, stat;
+	u32 addr, efuse_size, sec_data_size;
+	u8 *map_pg;
+	u32 mac_addr_size = 6;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	/*Soar TBD add MAC address PG*/
+
+	map_pg = info->efuse_map;
+	efuse_size = adapter->hw_info->efuse_size;
+	sec_data_size = adapter->hw_info->sec_data_efuse_size;
+
+	if (info->efuse_map_size != adapter->hw_info->sec_data_efuse_size) {
+		PLTFM_MSG_ERR("[ERR]map size error\n");
+		return MACEFUSESIZE;
+	}
+
+	if (!info->efuse_map) {
+		PLTFM_MSG_ERR("[ERR]map is NULL\n");
+		return MACNPTR;
+	}
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_PHY);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	p_ops->enable_efuse_sw_pwr_cut(adapter, 1);
+	for (addr = mac_addr_size; addr < sec_data_size; addr++) {
+		ret = write_hw_efuse(adapter, addr + efuse_size,
+				     *(map_pg + addr));
+		if (ret != 0) {
+			PLTFM_MSG_ERR("[ERR]write physical efuse\n");
+			stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+			if (stat != 0)
+				return stat;
+			return ret;
+		}
+	}
+	p_ops->disable_efuse_sw_pwr_cut(adapter, 1);
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_cmp_sec_data_by_map(struct mac_ax_adapter *adapter,
+			    struct mac_ax_pg_efuse_info *info)
+{
+	u32 ret, stat;
+	u32 addr, start_addr, sec_data_size;
+	u16 val16;
+	u8 *map_pg;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	map_pg = info->efuse_map;
+	start_addr = adapter->hw_info->efuse_size;
+	sec_data_size = adapter->hw_info->sec_data_efuse_size;
+
+	if (info->efuse_map_size != adapter->hw_info->sec_data_efuse_size) {
+		PLTFM_MSG_ERR("[ERR]map size error\n");
+		return MACEFUSESIZE;
+	}
+
+	if (!info->efuse_map) {
+		PLTFM_MSG_ERR("[ERR]map is NULL\n");
+		return MACNPTR;
+	}
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != 0)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_PHY);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != 0)
+			return stat;
+		return ret;
+	}
+
+	for (addr = 0;
+	     addr < sec_data_size; addr += 2) {
+		val16 = *(map_pg + addr) | (*(map_pg + addr + 1) << 8);
+		ret = cmp_hw_efuse(adapter, addr + start_addr, val16);
+		if (ret == MACEFUSECMP) {
+			*(map_pg + addr) = 0xFF;
+			*(map_pg + addr + 1) = 0xFF;
+		} else if (ret == MACEFUSEREAD) {
+			PLTFM_MSG_ERR("[ERR]compare hw efuse\n");
+			stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+			if (stat != 0)
+				return stat;
+		} else if (ret == 0) {
+			*(map_pg + addr) = 0x00;
+			*(map_pg + addr + 1) = 0x00;
+		}
+	}
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != 0)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_efuse_info(struct mac_ax_adapter *adapter, u8 *efuse_map,
+		       enum rtw_efuse_info id, void *value, u32 length,
+		       u8 *autoload_status)
+{
+	u32 offset, def_val;
+	u32 ret;
+	enum mac_ax_intf intf = adapter->hw_info->intf;
+	struct efuse_info info;
+
+	switch (intf) {
+	case MAC_AX_INTF_USB:
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A))
+			info = efuse_info_usb_8852a;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B))
+			info = efuse_info_usb_8852b;
+		else
+			info = efuse_info_usb_8852b;
+		break;
+	case MAC_AX_INTF_PCIE:
+		info = efuse_info_pcie;
+		break;
+	case MAC_AX_INTF_SDIO:
+		info = efuse_info_sdio;
+		break;
+	default:
+		return MACINTF;
+	}
+
+	ret = compare_info_length(&info, id, length);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	switch (id) {
+	case EFUSE_INFO_MAC_ADDR:
+		offset = info.offset->mac_addr;
+		def_val = info.def_val->mac_addr;
+		break;
+	case EFUSE_INFO_MAC_PID:
+		offset = info.offset->pid;
+		def_val = info.def_val->pid;
+		break;
+	case EFUSE_INFO_MAC_DID:
+		offset = info.offset->did;
+		def_val = info.def_val->did;
+		break;
+	case EFUSE_INFO_MAC_VID:
+		offset = info.offset->vid;
+		def_val = info.def_val->vid;
+		break;
+	case EFUSE_INFO_MAC_SVID:
+		offset = info.offset->svid;
+		def_val = info.def_val->svid;
+		break;
+	case EFUSE_INFO_MAC_SMID:
+		offset = info.offset->smid;
+		def_val = info.def_val->smid;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	if (*autoload_status == 0)
+		PLTFM_MEMCPY(value, &def_val, 1);
+	else
+		PLTFM_MEMCPY(value, efuse_map + offset, length);
+
+	return MACSUCCESS;
+}
+
+u32 mac_set_efuse_info(struct mac_ax_adapter *adapter, u8 *efuse_map,
+		       enum rtw_efuse_info id, void *value, u32 length)
+{
+	u32 offset;
+	u32 ret;
+	enum mac_ax_intf intf = adapter->hw_info->intf;
+	struct efuse_info info;
+
+	switch (intf) {
+	case MAC_AX_INTF_USB:
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A))
+			info = efuse_info_usb_8852a;
+		else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B))
+			info = efuse_info_usb_8852b;
+		else
+			info = efuse_info_usb_8852b;
+		break;
+	case MAC_AX_INTF_PCIE:
+		info = efuse_info_pcie;
+		break;
+	case MAC_AX_INTF_SDIO:
+		info = efuse_info_sdio;
+		break;
+	default:
+		return MACINTF;
+	}
+
+	ret = compare_info_length(&info, id, length);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	switch (id) {
+	case EFUSE_INFO_MAC_ADDR:
+		offset = info.offset->mac_addr;
+		break;
+	case EFUSE_INFO_MAC_PID:
+		offset = info.offset->pid;
+		break;
+	case EFUSE_INFO_MAC_DID:
+		offset = info.offset->did;
+		break;
+	case EFUSE_INFO_MAC_VID:
+		offset = info.offset->vid;
+		break;
+	case EFUSE_INFO_MAC_SVID:
+		offset = info.offset->svid;
+		break;
+	case EFUSE_INFO_MAC_SMID:
+		offset = info.offset->smid;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	PLTFM_MEMCPY(efuse_map + offset, value, length);
+
+	return MACSUCCESS;
+}
+
+u32 mac_read_hidden_rpt(struct mac_ax_adapter *adapter,
+			struct mac_defeature_value *rpt)
+{
+#if 0
+	return MACNOITEM;
+#else
+	u32 ret, stat;
+	struct mac_ax_h2creg_info h2c;
+	struct mac_ax_c2hreg_poll c2h;
+	struct fwcmd_c2hreg *c2h_content;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	ret = efuse_proc_ck(adapter);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_PHY);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank!!\n");
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat != MACSUCCESS)
+			return stat;
+		return ret;
+	}
+
+	ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_WL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	h2c.id = FWCMD_H2CREG_FUNC_HIDDEN_GET;
+	h2c.content_len = sizeof(struct mac_efuse_hidden_h2creg);
+
+	c2h.polling_id = FWCMD_C2HREG_FUNC_EFUSE_HIDDEN;
+	c2h.retry_cnt = EFUSE_C2HREG_WAIT_CNT;
+	c2h.retry_wait_us = EFUSE_C2HREG_RETRY_WAIT_US;
+
+	ret = proc_msg_reg(adapter, &h2c, &c2h);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]read hidden rpt proc msg reg %d\n", ret);
+		stat = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+		if (stat)
+			return stat;
+		return ret;
+	}
+
+	c2h_content = &c2h.c2hreg_cont.c2h_content;
+
+	rpt->rx_spatial_stream = GET_FIELD(c2h_content->dword0, FWCMD_C2HREG_EFUSE_HIDDEN_RX_NSS);
+	rpt->bandwidth = GET_FIELD(c2h_content->dword0, FWCMD_C2HREG_EFUSE_HIDDEN_BW);
+	rpt->tx_spatial_stream = GET_FIELD(c2h_content->dword1, FWCMD_C2HREG_EFUSE_HIDDEN_TX_NSS);
+	rpt->protocol_80211 = GET_FIELD(c2h_content->dword1, FWCMD_C2HREG_EFUSE_HIDDEN_PROT80211);
+	rpt->NIC_router = GET_FIELD(c2h_content->dword1, FWCMD_C2HREG_EFUSE_HIDDEN_NIC_ROUTER);
+	rpt->wl_func_support =
+	GET_FIELD(c2h_content->dword1, FWCMD_C2HREG_EFUSE_HIDDEN_WL_FUNC_SUPPORT);
+	rpt->hw_special_type =
+	GET_FIELD(c2h_content->dword2, FWCMD_C2HREG_EFUSE_HIDDEN_HW_SPECIAL_TYPE);
+	rpt->uuid =
+	GET_FIELD(c2h_content->dword3, FWCMD_C2HREG_EFUSE_HIDDEN_UUID_BYTE_3) << 24 |
+	GET_FIELD(c2h_content->dword2, FWCMD_C2HREG_EFUSE_HIDDEN_UUID_BYTE_2) << 16 |
+	GET_FIELD(c2h_content->dword2, FWCMD_C2HREG_EFUSE_HIDDEN_UUID_BYTE_1) << 8 |
+	GET_FIELD(c2h_content->dword2, FWCMD_C2HREG_EFUSE_HIDDEN_UUID_BYTE_0);
+	rpt->tx_path_num = GET_FIELD(c2h_content->dword3, FWCMD_C2HREG_EFUSE_HIDDEN_TX_PATH_NUM);
+	rpt->rx_path_num = GET_FIELD(c2h_content->dword3, FWCMD_C2HREG_EFUSE_HIDDEN_RX_PATH_NUM);
+
+	ret = cnv_efuse_state(adapter, MAC_AX_EFUSE_IDLE);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+#endif
+}
+
+u32 mac_check_efuse_autoload(struct mac_ax_adapter *adapter,
+			     u8 *autoload_status)
+{
+#define AUTOLOAD_SUS 1
+#define AUTOLOAD_FAIL 0
+
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (MAC_REG_R16(R_AX_SYS_WL_EFUSE_CTRL) & B_AX_AUTOLOAD_SUS)
+		*autoload_status = AUTOLOAD_SUS;
+	else
+		*autoload_status = AUTOLOAD_FAIL;
+
+	return MACSUCCESS;
+
+#undef AUTOLOAD_SUS
+#undef AUTOLOAD_FAIL
+}
+
+u32 mac_pg_simulator_plus(struct mac_ax_adapter *adapter,
+			  struct mac_ax_pg_efuse_info *info, u8 *phy_map)
+{
+	u8 chip_id = adapter->hw_info->chip_id;
+	u32 ret;
+	struct mac_ax_pg_efuse_info info_dav;
+	u32 ver_len = 0;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u32 map_size = hw_info->log_efuse_size;
+	bool dav_exist = (hw_info->dav_full_efuse_size == 0) ? false : true;
+
+	ret = mac_get_hw_value(adapter,
+			       MAC_AX_HW_GET_EFUSE_VERSION_SIZE, &ver_len);
+	if (ret)
+		return ret;
+
+	if (chip_id == MAC_AX_CHIP_ID_8852A) {
+		ret = mac_pg_simulator(adapter, info, phy_map);
+	} else {
+		info_dav.efuse_map_size = hw_info->dav_log_efuse_size;
+		info_dav.efuse_mask_size = hw_info->dav_log_efuse_size >> 4;
+
+		info_dav.efuse_map =
+			(u8 *)PLTFM_MALLOC(info_dav.efuse_map_size + ver_len);
+		if (!info_dav.efuse_map) {
+			PLTFM_MSG_ERR("[ERR]malloc map\n");
+			return MACBUFALLOC;
+		}
+		info_dav.efuse_mask =
+			(u8 *)PLTFM_MALLOC(info_dav.efuse_mask_size +
+					   ver_len);
+		if (!info_dav.efuse_mask) {
+			PLTFM_MSG_ERR("[ERR]malloc map\n");
+			return MACBUFALLOC;
+		}
+
+		PLTFM_MEMCPY(info_dav.efuse_map, info->efuse_map + map_size,
+			     info_dav.efuse_map_size + ver_len);
+		PLTFM_MEMCPY(info_dav.efuse_mask,
+			     info->efuse_mask + (map_size >> 4),
+			     info_dav.efuse_mask_size + ver_len);
+
+		info->efuse_map_size -= info_dav.efuse_map_size;
+		info->efuse_mask_size -= info_dav.efuse_mask_size;
+
+		PLTFM_MEMCPY(info->efuse_map + map_size, info->efuse_map +
+			     map_size + info_dav.efuse_map_size, ver_len);
+		PLTFM_MEMCPY(info->efuse_mask + (map_size >> 4),
+			     info->efuse_mask + (map_size >> 4) +
+			     info_dav.efuse_mask_size, ver_len);
+
+		ret = mac_pg_simulator(adapter, info, phy_map);
+		if (ret)
+			return ret;
+
+		if (dav_exist) {
+			switch_dv(adapter, DAV);
+			ret = mac_pg_simulator(adapter, &info_dav,
+					       phy_map + hw_info->wl_efuse_size);
+			switch_dv(adapter, DDV);
+			PLTFM_MEMCPY(info->efuse_map + map_size, info_dav.efuse_map,
+				     info_dav.efuse_map_size + ver_len);
+		}
+	}
+
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_pg_simulator(struct mac_ax_adapter *adapter,
+		     struct mac_ax_pg_efuse_info *info, u8 *phy_map)
+{
+	u8 *updated_mask;
+	u32 ret;
+	u32 mask_size;
+	u8 *log_efuse_map = NULL;
+	enum mac_ax_intf intf = adapter->hw_info->intf;
+	u32 map_size = adapter->hw_info->log_efuse_size;
+	u32 ver_len = 0;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	enum rtw_dv_sel dv_sel = adapter->efuse_param.dv_sel;
+
+	if (info->efuse_map_size != adapter->hw_info->log_efuse_size) {
+		switch (intf) {
+		case MAC_AX_INTF_PCIE:
+			map_size = adapter->hw_info->limit_efuse_size_pcie;
+			break;
+		case MAC_AX_INTF_USB:
+			map_size = adapter->hw_info->limit_efuse_size_usb;
+			break;
+		case MAC_AX_INTF_SDIO:
+			map_size = adapter->hw_info->limit_efuse_size_sdio;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (dv_sel == DAV)
+		map_size = adapter->hw_info->dav_log_efuse_size;
+
+	if (info->efuse_map_size != map_size) {
+		PLTFM_MSG_ERR("[ERR]map size error\n");
+		return MACEFUSESIZE;
+	}
+
+	mask_size = map_size >> 4;
+
+	ret = mac_get_hw_value(adapter,
+			       MAC_AX_HW_GET_EFUSE_VERSION_SIZE, &ver_len);
+	if (ret)
+		return ret;
+
+	ret = compare_version(adapter, info, ver_len);
+	if (ret != 0)
+		return ret;
+
+	ret = p_ops->switch_efuse_bank(adapter, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]switch efuse bank!!\n");
+		return ret;
+	}
+
+	if (dv_sel == DAV) {
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_DAV);
+		if (ret)
+			return ret;
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG_DAV);
+	} else {
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_PHY_WL);
+		if (ret)
+			return ret;
+		ret = efuse_map_init(adapter, EFUSE_MAP_SEL_LOG);
+	}
+	if (ret)
+		return ret;
+
+	ret = eeprom_parser(adapter, phy_map, *bank_efuse_info->log_map,
+			    MAC_AX_EFUSE_PARSER_MAP);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]logical map parser\n");
+		return ret;
+	}
+	PLTFM_MEMCPY(*bank_efuse_info->phy_map, phy_map,
+		     *bank_efuse_info->phy_map_size);
+
+	updated_mask = (u8 *)PLTFM_MALLOC(mask_size);
+	if (!updated_mask) {
+		PLTFM_MSG_ERR("[ERR]malloc updated mask\n");
+		return MACBUFALLOC;
+	}
+	PLTFM_MEMSET(updated_mask, 0x00, mask_size);
+
+	ret = update_eeprom_mask(adapter, info, updated_mask, 1);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]update eeprom mask\n");
+		goto error;
+	}
+
+	ret = check_efuse_enough(adapter, info, updated_mask);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]chk efuse enough\n");
+		goto error;
+	}
+
+	ret = program_efuse(adapter, info, updated_mask, 1);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]pg efuse\n");
+		goto error;
+	}
+
+	PLTFM_FREE(updated_mask, mask_size);
+
+	PLTFM_MEMCPY(phy_map, *bank_efuse_info->phy_map,
+		     *bank_efuse_info->phy_map_size);
+	ret = eeprom_parser(adapter, phy_map, info->efuse_map,
+			    MAC_AX_EFUSE_PARSER_MAP);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]parser error\n");
+		PLTFM_FREE(log_efuse_map, map_size);
+		return ret;
+	}
+
+	/* For subsequent dump */
+	*bank_efuse_info->log_map_valid = 0;
+	*bank_efuse_info->phy_map_valid = 0;
+
+	return MACSUCCESS;
+
+error:
+	PLTFM_FREE(updated_mask, mask_size);
+	return ret;
+}
+
+u32 mac_checksum_update(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u32 log_efuse_size = hw_info->log_efuse_size;
+	u8 *map;
+	u16 chksum;
+	u32 ret;
+
+	map = (u8 *)PLTFM_MALLOC(log_efuse_size);
+	if (!map) {
+		PLTFM_MSG_ERR("[ERR]malloc map\n");
+		return MACBUFALLOC;
+	}
+	PLTFM_MEMSET(map, 0xFF, log_efuse_size);
+
+	ret = mac_dump_log_efuse(adapter, MAC_AX_EFUSE_PARSER_MAP,
+				 MAC_AX_EFUSE_R_AUTO, map, 0);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]Dump log map\n");
+		goto error;
+	}
+
+	cal_check_sum(adapter, &chksum);
+
+	ret = set_check_sum_val(adapter, map, chksum);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]write check sum\n");
+		goto error;
+	}
+
+	PLTFM_FREE(map, log_efuse_size);
+	return MACSUCCESS;
+error:
+	PLTFM_FREE(map, log_efuse_size);
+	return ret;
+}
+
+u32 mac_checksum_rpt(struct mac_ax_adapter *adapter, u16 *chksum)
+{
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u32 log_efuse_size = hw_info->log_efuse_size;
+	u8 *tmp;
+	u32 ret;
+	u16 real_chksum = 0;
+
+	/* Read chksum val */
+	tmp = (u8 *)PLTFM_MALLOC(sizeof(real_chksum));
+	if (!tmp) {
+		PLTFM_MSG_ERR("[ERR]malloc tmp\n");
+		return MACBUFALLOC;
+	}
+	ret = mac_read_log_efuse(adapter, chksum_offset_1, sizeof(real_chksum),
+				 tmp);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]read log efuse\n");
+		PLTFM_FREE(tmp, sizeof(real_chksum));
+		return ret;
+	}
+
+	real_chksum = *(u16 *)tmp;
+	PLTFM_FREE(tmp, sizeof(real_chksum));
+
+	if (real_chksum == 0xFFFF)
+		return MACCHKSUMEMPTY;
+
+	/* Read log map*/
+	tmp = (u8 *)PLTFM_MALLOC(log_efuse_size);
+	if (!tmp) {
+		PLTFM_MSG_ERR("[ERR]malloc map\n");
+		return MACBUFALLOC;
+	}
+	PLTFM_MEMSET(tmp, 0xFF, log_efuse_size);
+
+	ret = mac_read_log_efuse(adapter, 0, log_efuse_size, tmp);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]read log efuse\n");
+		PLTFM_FREE(tmp, log_efuse_size);
+		return ret;
+	}
+	PLTFM_FREE(tmp, log_efuse_size);
+
+	cal_check_sum(adapter, chksum);
+	if (*chksum != real_chksum)
+		return MACCHKSUMFAIL;
+
+	return MACSUCCESS;
+}
+
+u32 mac_disable_rf_ofld_by_info(struct mac_ax_adapter *adapter,
+				struct mac_disable_rf_ofld_info info)
+{
+	u32 ret;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	u8 *buf;
+	struct fwcmd_disable_rf *write_ptr;
+
+	/* H2C */
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	if (adapter->sm.disable_rf != MAC_AX_OFLD_H2C_IDLE)
+		return MACPROCERR;
+
+	adapter->sm.disable_rf = MAC_AX_OFLD_H2C_SENDING;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_pkt_ofld_hdr));
+	if (!buf) {
+		h2cb_free(adapter, h2cb);
+		return MACNOBUF;
+	}
+
+	write_ptr = (struct fwcmd_disable_rf *)buf;
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD(info.func, FWCMD_H2C_DISABLE_RF_FUNC) |
+		    SET_WORD(info.type, FWCMD_H2C_DISABLE_RF_NET_TYPE)
+	);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_DISABLE_RF,
+			      0, 0);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx\n");
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	if (adapter->sm.disable_rf != MAC_AX_OFLD_H2C_SENDING)
+		return MACPROCERR;
+
+	adapter->sm.disable_rf = MAC_AX_OFLD_H2C_IDLE;
+
+	return MACSUCCESS;
+}
+
+u32 _patch_otp_power_issue(struct mac_ax_adapter *adapter)
+{
+#define secure 1
+	u8 val8;
+	u32 ret, stat;
+
+	ret = mac_set_efuse_ctrl(adapter, secure);
+	if (ret != MACSUCCESS)
+		return ret;
+	adapter->efuse_param.read_efuse_cnt = CHK_OTP_WAIT_CNT;
+
+	ret = mac_read_efuse_plus(adapter, CHK_OTP_ADDR, 1, &val8,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		adapter->efuse_param.read_efuse_cnt = EFUSE_WAIT_CNT;
+		stat = mac_set_efuse_ctrl(adapter, !secure);
+		if (stat != MACSUCCESS)
+			return stat;
+		return ret;
+	}
+
+	adapter->efuse_param.read_efuse_cnt = EFUSE_WAIT_CNT;
+	ret = mac_set_efuse_ctrl(adapter, !secure);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_set_efuse_ctrl(struct mac_ax_adapter *adapter, bool is_secure)
+{
+	if (is_secure)
+		adapter->efuse_param.efuse_ctrl = R_AX_EFUSE_CTRL_S;
+	else
+		adapter->efuse_param.efuse_ctrl = R_AX_EFUSE_CTRL;
+	PLTFM_MSG_TRACE("[TRACE]is_secure= 0x%x, adapter->efuse_ctrl = 0x%x\n", is_secure,
+			adapter->efuse_param.efuse_ctrl);
+
+	return MACSUCCESS;
+}
+
+u32 mac_otp_test(struct mac_ax_adapter *adapter, bool is_OTP_test)
+{
+	if (is_OTP_test)
+		adapter->efuse_param.OTP_test = 1;
+	else
+		adapter->efuse_param.OTP_test = 0;
+	PLTFM_MSG_TRACE("[TRACE]is_OTP_test= 0x%x, adapter->OTP_test = 0x%x\n", is_OTP_test,
+			adapter->efuse_param.OTP_test);
+
+	return MACSUCCESS;
+}
+
+void cfg_efuse_auto_ck(struct mac_ax_adapter *adapter, u8 enable)
+{
+	/*Soar TBD* move to set hw value */
+
+#ifdef NEVER
+	PLTFM_MSG_TRACE("[TRACE]%s ===>\n", __func__);
+	adapter->efuse_param.auto_ck_en = enable;
+	PLTFM_MSG_TRACE("[TRACE]%s <===\n", __func__);
+#endif /* NEVER */
+}
+
+u32 get_fv_info(struct mac_ax_adapter *adapter)
+{
+	u32 ret = MACCHIPID;
+	u8 efv = 0, ecv = 0;
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		ret = mac_ops->read_efuse(adapter, EF_FV_OFSET_AX, 1, &efv,
+		      MAC_AX_EFUSE_BANK_WIFI);
+	}
+#endif
+#if MAC_BE_1115E_SUPPORT
+	if (is_chip_id(adapter, MAC_BE_CHIP_ID_1115E))
+		ret = mac_ops->read_efuse(adapter, EF_FV_OFSET_BE, 1, &efv,
+		      MAC_AX_EFUSE_BANK_WIFI);
+#endif
+#if (MAC_BE_8922A_SUPPORT || MAC_BE_8952A_SUPPORT)
+	if (is_chip_id(adapter, MAC_BE_CHIP_ID_8922A) ||
+	    is_chip_id(adapter, MAC_BE_CHIP_ID_8952A)) {
+		ret = mac_ops->read_efuse(adapter, EF_FV_OFSET_BE_V1, 1, &efv,
+		      MAC_AX_EFUSE_BANK_WIFI);
+	}
+#endif
+
+	if (ret == MACSUCCESS && efv != 0) {
+		ecv = (efv >> EF_CV_OFSET) & EF_CV_MSK;
+		efv &= 0x0F;
+
+		if (ecv != 0xF)
+			adapter->hw_info->cv = ecv;
+
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT)
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		switch (efv) {
+		case FV_TYPE1:
+			adapter->hw_info->fv = FUV;
+			break;
+		case FV_TYPE2:
+			adapter->hw_info->fv = FSV;
+			break;
+		case FV_TYPE3:
+			adapter->hw_info->fv = FTV;
+			break;
+		//case FV_TYPE4:
+			//adapter->hw_info->fv = FTV;
+			//break;
+		default:
+			PLTFM_MSG_ERR("[ERR]Error efv = %x\n", efv);
+			ret = MACNOITEM;
+		}
+	}
+#endif
+#if (MAC_AX_8851B_SUPPORT || MAC_AX_8192XB_SUPPORT)
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) {
+		switch (efv) {
+		case FV_TYPE1:
+			adapter->hw_info->fv = FTV;
+			break;
+		case FV_TYPE2:
+			adapter->hw_info->fv = FSV;
+			break;
+		case FV_TYPE3:
+			adapter->hw_info->fv = FUV;
+			break;
+		//case FV_TYPE4:
+			//adapter->hw_info->fv = FTV;
+			//break;
+		default:
+			PLTFM_MSG_ERR("[ERR]Error efv = %x\n", efv);
+			ret = MACNOITEM;
+		}
+	}
+#endif
+#if (MAC_BE_1115E_SUPPORT || MAC_BE_8922A_SUPPORT || MAC_BE_8952A_SUPPORT)
+	if (is_chip_id(adapter, MAC_BE_CHIP_ID_1115E) ||
+	    is_chip_id(adapter, MAC_BE_CHIP_ID_8922A) ||
+	    is_chip_id(adapter, MAC_BE_CHIP_ID_8952A))
+		switch (efv) {
+		case FV_TYPE1:
+			adapter->hw_info->fv = FTV;
+			break;
+		case FV_TYPE2:
+			adapter->hw_info->fv = FSV;
+			break;
+		case FV_TYPE3:
+			adapter->hw_info->fv = FUV;
+			break;
+		//case FV_TYPE4:
+			//adapter->hw_info->fv = FTV;
+			//break;
+		default:
+			PLTFM_MSG_ERR("[ERR]Error efv = %x\n", efv);
+			ret = MACNOITEM;
+		}
+#endif
+	}
+	PLTFM_MSG_ALWAYS("fv = %x\n", adapter->hw_info->fv);
+
+	return ret;
+}
+
+u32 efuse_info_init(struct mac_ax_adapter *adapter)
+{
+	u32 ret;
+
+	PLTFM_MUTEX_INIT(&adapter->efuse_param.efuse_tbl.lock);
+
+	adapter->efuse_param.dv_sel = DDV;
+	adapter->efuse_param.efuse_ctrl = R_AX_EFUSE_CTRL;
+	adapter->efuse_param.read_efuse_cnt = EFUSE_WAIT_CNT;
+
+	ret = get_fv_info(adapter);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("[ERR]get_fv_info error\n");
+
+	return MACSUCCESS;
+}
+
+u32 efuse_info_exit(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_efuse_param *efuse_param = &adapter->efuse_param;
+
+	PLTFM_MUTEX_DEINIT(&adapter->efuse_param.efuse_tbl.lock);
+
+	if (efuse_param->efuse_map) {
+		PLTFM_FREE(efuse_param->efuse_map,
+			   adapter->hw_info->efuse_size);
+		efuse_param->efuse_map = (u8 *)NULL;
+	}
+
+	if (efuse_param->bt_efuse_map) {
+		PLTFM_FREE(efuse_param->bt_efuse_map,
+			   adapter->hw_info->bt_efuse_size);
+		efuse_param->bt_efuse_map = (u8 *)NULL;
+	}
+
+	if (efuse_param->log_efuse_map) {
+		PLTFM_FREE(efuse_param->log_efuse_map,
+			   adapter->hw_info->log_efuse_size);
+		efuse_param->log_efuse_map = (u8 *)NULL;
+	}
+
+	if (efuse_param->bt_log_efuse_map) {
+		PLTFM_FREE(efuse_param->bt_log_efuse_map,
+			   adapter->hw_info->bt_log_efuse_size);
+		efuse_param->bt_log_efuse_map = (u8 *)NULL;
+	}
+
+	if (efuse_param->dav_efuse_map) {
+		PLTFM_FREE(efuse_param->dav_efuse_map,
+			   adapter->hw_info->dav_efuse_size);
+		efuse_param->dav_efuse_map = (u8 *)NULL;
+	}
+
+	if (efuse_param->dav_log_efuse_map) {
+		PLTFM_FREE(efuse_param->dav_log_efuse_map,
+			   adapter->hw_info->dav_log_efuse_size);
+		efuse_param->dav_log_efuse_map = (u8 *)NULL;
+	}
+
+	if (efuse_param->hidden_rf_map) {
+		PLTFM_FREE(efuse_param->hidden_rf_map,
+			   adapter->hw_info->hidden_efuse_rf_size);
+		efuse_param->hidden_rf_map = (u8 *)NULL;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 efuse_map_init(struct mac_ax_adapter *adapter,
+			  enum efuse_map_sel map_sel)
+{
+	u32 size;
+	struct mac_ax_efuse_param *efuse_param = &adapter->efuse_param;
+
+	switch (map_sel) {
+	case EFUSE_MAP_SEL_PHY_WL:
+		size = adapter->hw_info->efuse_size;
+		if (!efuse_param->efuse_map) {
+			efuse_param->efuse_map = (u8 *)PLTFM_MALLOC(size);
+			if (!efuse_param->efuse_map) {
+				PLTFM_MSG_ERR("[ERR]malloc map\n");
+				return MACBUFALLOC;
+			}
+		}
+		break;
+	case EFUSE_MAP_SEL_PHY_BT:
+		size = adapter->hw_info->bt_efuse_size;
+		if (!efuse_param->bt_efuse_map) {
+			efuse_param->bt_efuse_map = (u8 *)PLTFM_MALLOC(size);
+			if (!efuse_param->bt_efuse_map) {
+				PLTFM_MSG_ERR("[ERR]malloc map\n");
+				return MACBUFALLOC;
+			}
+		}
+		break;
+	case EFUSE_MAP_SEL_LOG:
+		size = adapter->hw_info->log_efuse_size;
+		if (!efuse_param->log_efuse_map) {
+			efuse_param->log_efuse_map = (u8 *)PLTFM_MALLOC(size);
+			if (!efuse_param->log_efuse_map) {
+				PLTFM_MSG_ERR("[ERR]malloc map\n");
+				return MACBUFALLOC;
+			}
+		}
+		break;
+	case EFUSE_MAP_SEL_LOG_BT:
+		size = adapter->hw_info->bt_log_efuse_size;
+		if (!efuse_param->bt_log_efuse_map) {
+			efuse_param->bt_log_efuse_map =
+				(u8 *)PLTFM_MALLOC(size);
+			if (!efuse_param->bt_log_efuse_map) {
+				PLTFM_MSG_ERR("[ERR]malloc map\n");
+				return MACBUFALLOC;
+			}
+		}
+		break;
+	case EFUSE_MAP_SEL_PHY_DAV:
+		size = adapter->hw_info->dav_efuse_size;
+		if (!efuse_param->dav_efuse_map) {
+			efuse_param->dav_efuse_map = (u8 *)PLTFM_MALLOC(size);
+			if (!efuse_param->dav_efuse_map) {
+				PLTFM_MSG_ERR("[ERR]malloc map\n");
+				return MACBUFALLOC;
+			}
+		}
+		break;
+	case EFUSE_MAP_SEL_LOG_DAV:
+		size = adapter->hw_info->dav_log_efuse_size;
+		if (!efuse_param->dav_log_efuse_map) {
+			efuse_param->dav_log_efuse_map =
+				(u8 *)PLTFM_MALLOC(size);
+			if (!efuse_param->dav_log_efuse_map) {
+				PLTFM_MSG_ERR("[ERR]malloc map\n");
+				return MACBUFALLOC;
+			}
+		}
+		break;
+	case EFUSE_MAP_SEL_HIDDEN_RF:
+		size = adapter->hw_info->hidden_efuse_rf_size;
+		if (!efuse_param->hidden_rf_map) {
+			efuse_param->hidden_rf_map = (u8 *)PLTFM_MALLOC(size);
+			if (!efuse_param->hidden_rf_map) {
+				PLTFM_MSG_ERR("[ERR]malloc map\n");
+				return MACBUFALLOC;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 efuse_fwcmd_ck(struct mac_ax_adapter *adapter)
+{
+/*Soar TBD*/
+#ifdef NEVER
+	u32 ret;
+
+	ret = fwcmd_wq_idle(adapter,
+			    SET_FWCMD_ID(FWCMD_TYPE_H2C,
+					 FWCMD_H2C_CAT_MAC,
+					 TBD,
+					 TBD));
+	if (ret != 0) {
+		PLTFM_MSG_WARN("[WARN]H2C not idle(efuse)\n");
+		return ret;
+	}
+#endif /* NEVER */
+	return MACSUCCESS;
+}
+
+static u32 efuse_proc_ck(struct mac_ax_adapter *adapter)
+{
+/*Soar TBD*/
+#ifdef NEVER
+	u32 ret;
+
+	ret = efuse_fwcmd_ck(adapter);
+	if (ret != 0)
+		return ret;
+#endif /* NEVER */
+	if (adapter->sm.efuse != MAC_AX_EFUSE_IDLE) {
+		PLTFM_MSG_WARN("[WARN]Proc not idle(efuse)\n");
+		return MACPROCBUSY;
+	}
+
+	if (adapter->sm.pwr != MAC_AX_PWR_ON)
+		PLTFM_MSG_ERR("[ERR]Access efuse in suspend\n");
+
+	return MACSUCCESS;
+}
+
+static u32 cnv_efuse_state(struct mac_ax_adapter *adapter, u8 dest_state)
+{
+#define BT_DISN_EN 1
+#define BT_DISN_DIS 0
+	u8 cnt;
+	u32 val32, ret, bt_dis_state;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (adapter->sm.efuse >= MAC_AX_EFUSE_MAX)
+		return MACPROCERR;
+
+	if (adapter->sm.efuse == dest_state)
+		return MACPROCERR;
+
+	if (dest_state != MAC_AX_EFUSE_IDLE) {
+		if (adapter->sm.efuse != MAC_AX_EFUSE_IDLE)
+			return MACPROCERR;
+	}
+
+	adapter->sm.efuse = dest_state;
+
+	if (adapter->sm.efuse != MAC_AX_EFUSE_IDLE) {
+		bt_dis_state = mac_get_bt_dis(adapter);
+		if (bt_dis_state == BT_DISN_EN) {
+			ret = mac_set_bt_dis(adapter, BT_DISN_DIS);
+			if (ret != MACSUCCESS)
+				return ret;
+		}
+
+		cnt = BT_DIS_WAIT_CNT;
+		while (cnt) {
+			val32 = MAC_REG_R32(R_AX_IC_PWR_STATE);
+			val32 = GET_FIELD(val32, B_AX_WHOLE_SYS_PWR_STE);
+			if (val32 == MAC_AX_SYS_ACT)
+				break;
+
+			PLTFM_DELAY_US(BT_DIS_WAIT_US);
+			cnt--;
+		}
+
+		if (!cnt) {
+			PLTFM_MSG_ERR("[ERR]Whole system PWR state not ACT\n");
+			return MACSYSSTEERR;
+		}
+	} else {
+		bt_dis_state = mac_get_bt_dis(adapter);
+		if (bt_dis_state == BT_DISN_DIS) {
+			ret = mac_set_bt_dis(adapter, BT_DISN_EN);
+			if (ret != MACSUCCESS)
+				return ret;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 proc_dump_efuse(struct mac_ax_adapter *adapter,
+			   enum mac_ax_efuse_read_cfg cfg)
+{
+	u32 ret;
+
+	if (cfg == MAC_AX_EFUSE_R_AUTO) {
+		if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+			ret = dump_efuse_drv(adapter);
+		else
+			ret = dump_efuse_fw(adapter);
+	} else if (cfg == MAC_AX_EFUSE_R_FW) {
+		ret = dump_efuse_fw(adapter);
+	} else {
+		ret = dump_efuse_drv(adapter);
+	}
+
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]dump efsue drv/fw\n");
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 read_hw_efuse(struct mac_ax_adapter *adapter, u32 offset, u32 size,
+			 u8 *map)
+{
+	u32 addr;
+	u32 tmp32 = 0;
+	u32 cnt;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	u32 efuse_start = *bank_efuse_info->efuse_start;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	enum rtw_dv_sel dv_sel = adapter->efuse_param.dv_sel;
+	u16 read_efuse_cnt = adapter->efuse_param.read_efuse_cnt;
+	u16 efuse_ctrl = adapter->efuse_param.efuse_ctrl;
+
+	offset += efuse_start;
+
+	if (dv_sel == DDV) {
+		p_ops->enable_efuse_sw_pwr_cut(adapter, 0);
+
+		for (addr = offset; addr < offset + size; addr++) {
+			MAC_REG_W32(efuse_ctrl,
+				    ((addr & B_AX_EF_ADDR_MSK) << B_AX_EF_ADDR_SH)
+				    & ~B_AX_EF_RDY);
+
+			cnt = read_efuse_cnt;
+			if ((is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+			     is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+			     is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+			     is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+			     is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) &&
+			    efuse_ctrl == R_AX_EFUSE_CTRL)
+				cnt = EFUSE_WAIT_CNT_PLUS;
+
+			while (--cnt) {
+				tmp32 = MAC_REG_R32(efuse_ctrl);
+				if (tmp32 & B_AX_EF_RDY)
+					break;
+				PLTFM_DELAY_US(1);
+			}
+
+			if (!cnt) {
+				PLTFM_MSG_ERR("[ERR]read efuse\n");
+				return MACEFUSEREAD;
+			}
+
+			*(map + addr - offset) = (u8)(tmp32 & 0xFF);
+		}
+
+		p_ops->disable_efuse_sw_pwr_cut(adapter, 0);
+	} else {
+		read_hw_efuse_dav(adapter, offset, size, map);
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 write_hw_efuse(struct mac_ax_adapter *adapter, u32 offset, u8 value)
+{
+	//const u8 unlock_code = 0x69;
+	u8 value_read = 0;
+	u32 value32;
+	u32 cnt;
+	u32 ret;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_efuse_param *efuse_param = &adapter->efuse_param;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	u32 efuse_start = *bank_efuse_info->efuse_start;
+	enum rtw_dv_sel dv_sel = adapter->efuse_param.dv_sel;
+	u16 efuse_ctrl = adapter->efuse_param.efuse_ctrl;
+
+	PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+	*bank_efuse_info->phy_map_valid = 0;
+	*bank_efuse_info->log_map_valid = 0;
+	efuse_param->hidden_rf_map_valid = 0;
+	PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+
+	offset += efuse_start;
+
+	if (dv_sel == DDV) {
+		//MAC_REG_W8(R_AX_PMC_DBG_CTRL2 + 3, unlock_code);
+
+		value32 = value |
+			  ((offset & B_AX_EF_ADDR_MSK) << B_AX_EF_ADDR_SH);
+		value32 &= ~B_AX_EF_RDY;
+		MAC_REG_W32(efuse_ctrl,
+			    value32 | (MODE_WRITE << B_AX_EF_MODE_SEL_SH));
+
+		cnt = EFUSE_WAIT_CNT;
+		while (--cnt) {
+			if (MAC_REG_R32(efuse_ctrl) & B_AX_EF_RDY)
+				break;
+			PLTFM_DELAY_US(1);
+		}
+
+		if (!cnt) {
+			PLTFM_MSG_ERR("[ERR]write efuse\n");
+			return MACEFUSEWRITE;
+		}
+
+		//MAC_REG_W8(R_AX_PMC_DBG_CTRL2 + 3, 0x00);
+	} else {
+		write_hw_efuse_dav(adapter, offset, value);
+	}
+
+	if (efuse_param->auto_ck_en == 1) {
+		ret = read_hw_efuse(adapter, offset, 1, &value_read);
+		if (ret != 0)
+			return ret;
+
+		if (value_read != value) {
+			PLTFM_MSG_ERR("[ERR]efuse compare\n");
+			return MACEFUSEWRITE;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 cmp_hw_efuse(struct mac_ax_adapter *adapter, u32 offset, u16 val)
+{
+	u32 val32;
+	u32 tmp32 = 0;
+	u32 cnt;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u16 efuse_ctrl = adapter->efuse_param.efuse_ctrl;
+
+	val32 = val | ((offset & B_AX_EF_ADDR_MSK) << B_AX_EF_ADDR_SH);
+	MAC_REG_W32(efuse_ctrl, val32 | (MODE_CMP << B_AX_EF_MODE_SEL_SH));
+
+	cnt = EFUSE_WAIT_CNT;
+	while (--cnt) {
+		tmp32 = MAC_REG_R32(efuse_ctrl);
+		if (tmp32 & B_AX_EF_RDY)
+			break;
+		PLTFM_DELAY_US(1);
+	}
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR]compare efuse\n");
+		return MACEFUSEREAD;
+	}
+
+	if (0 == (tmp32 & B_AX_EF_COMP_RESULT))
+		return MACEFUSECMP;
+
+	return MACSUCCESS;
+}
+
+static u32 eeprom_parser(struct mac_ax_adapter *adapter, u8 *phy_map,
+			 u8 *log_map, enum mac_ax_efuse_parser_cfg cfg)
+{
+	u8 i;
+	u8 value8;
+	u8 blk_idx;
+	u8 word_en;
+	u8 valid;
+	u8 hdr = 0;
+	u8 hdr2 = 0;
+	u32 eeprom_idx;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u32 sec_ctrl_size = hw_info->sec_ctrl_efuse_size;
+	u32 efuse_idx;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	u32 efuse_size = *bank_efuse_info->phy_map_size;
+	bool is_bt = 0;
+	u32 log_efuse_size = *bank_efuse_info->log_map_size;
+
+	PLTFM_MEMSET(log_map, 0xFF, log_efuse_size);
+
+	if (log_efuse_size == hw_info->bt_log_efuse_size) {
+		sec_ctrl_size = 0;
+		is_bt = 1;
+	}
+	efuse_idx = sec_ctrl_size;
+
+	do {
+		if (efuse_idx >= efuse_size) // secure zone
+			break;
+
+		value8 = *(phy_map + efuse_idx);
+		hdr = value8;
+		if (hdr == 0xff)
+			break;
+		efuse_idx++;
+
+		if (is_bt) {
+			if ((hdr & 0xF) != 0xF) {// 1byte entry
+				blk_idx = (hdr & 0xF0) >> 4;
+				word_en = hdr & 0x0F;
+			} else {// 2byte entry
+				value8 = *(phy_map + efuse_idx);
+				hdr2 = value8;
+				if (hdr2 == 0xff)
+					break;
+
+				blk_idx = (((hdr2 & 0xF0) >> 4) << 3) +
+					  (((hdr & 0xF0) >> 4) >> 1); // offset
+				word_en = hdr2 & 0x0F;
+
+				efuse_idx++;
+			}
+		} else { // WLAN
+			value8 = *(phy_map + efuse_idx);
+			hdr2 = value8;
+			if (hdr2 == 0xff)
+				break;
+
+			blk_idx = ((hdr2 & 0xF0) >> 4) | ((hdr & 0x0F) << 4);
+			word_en = hdr2 & 0x0F;
+
+			efuse_idx++;
+		}
+
+		if (efuse_idx >= efuse_size - 1)
+			return MACEFUSEPARSE;
+
+		for (i = 0; i < 4; i++) {
+			valid = (u8)((~(word_en >> i)) & BIT(0));
+			if (valid == 1) {
+				eeprom_idx = (blk_idx << 3) + (i << 1);
+
+				if ((eeprom_idx + 1) >
+				    *bank_efuse_info->log_map_size) {
+					PLTFM_MSG_ERR("[ERR]efuse idx:0x%X\n",
+						      efuse_idx - 1);
+					PLTFM_MSG_ERR("[ERR]read hdr:0x%X\n",
+						      hdr);
+					PLTFM_MSG_ERR("[ERR]read hdr2:0x%X\n",
+						      hdr2);
+					return MACEFUSEPARSE;
+				}
+
+				if (cfg == MAC_AX_EFUSE_PARSER_MAP) {
+					value8 = *(phy_map + efuse_idx);
+					*(log_map + eeprom_idx) = value8;
+				} else if (cfg == MAC_AX_EFUSE_PARSER_MASK) {
+					*(log_map + eeprom_idx) = 0x00;
+				}
+
+				eeprom_idx++;// 1 byte
+				efuse_idx++;
+
+				if (efuse_idx > efuse_size - 1)
+					return MACEFUSEPARSE;
+
+				if (cfg == MAC_AX_EFUSE_PARSER_MAP) {
+					value8 = *(phy_map + efuse_idx);
+					*(log_map + eeprom_idx) = value8;
+				} else if (cfg == MAC_AX_EFUSE_PARSER_MASK) {
+					*(log_map + eeprom_idx) = 0x00;
+				}
+
+				efuse_idx++;
+
+				if (efuse_idx > efuse_size)
+					return MACEFUSEPARSE;
+			}
+		}
+	} while (1);
+
+	*bank_efuse_info->efuse_end = efuse_idx;
+
+	return MACSUCCESS;
+}
+
+static u32 read_log_efuse_map(struct mac_ax_adapter *adapter, u8 *map,
+			      u32 log_efuse_size)
+{
+	u8 *local_map = NULL;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	u32 efuse_size = *bank_efuse_info->phy_map_size;
+	u32 ret;
+
+	if (*bank_efuse_info->log_map_valid == 0) {
+		if (*bank_efuse_info->phy_map_valid == 0) {
+			local_map = (u8 *)PLTFM_MALLOC(efuse_size);
+			if (!local_map) {
+				PLTFM_MSG_ERR("[ERR]malloc map\n");
+				return MACBUFALLOC;
+			}
+
+			ret = read_efuse(adapter, 0, efuse_size, local_map);
+			if (ret != 0) {
+				PLTFM_MSG_ERR("[ERR]read efuse\n");
+				goto error;
+			}
+
+			PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+			PLTFM_MEMCPY(*bank_efuse_info->phy_map, local_map,
+				     efuse_size);
+			*bank_efuse_info->phy_map_valid = 1;
+			PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+
+			PLTFM_FREE(local_map, efuse_size);
+		}
+
+		ret = eeprom_parser(adapter, *bank_efuse_info->phy_map, map,
+				    MAC_AX_EFUSE_PARSER_MAP);
+		if (ret != 0)
+			return ret;
+
+		PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+		PLTFM_MEMCPY(*bank_efuse_info->log_map, map, log_efuse_size);
+		*bank_efuse_info->log_map_valid = 1;
+		PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+	} else {
+		PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+		PLTFM_MEMCPY(map, *bank_efuse_info->log_map, log_efuse_size);
+		PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+	}
+
+	return MACSUCCESS;
+error:
+	PLTFM_FREE(local_map, efuse_size);
+	return ret;
+}
+
+static u32 proc_pg_efuse_by_map(struct mac_ax_adapter *adapter,
+				struct mac_ax_pg_efuse_info *info,
+				enum mac_ax_efuse_read_cfg cfg)
+{
+	u8 *updated_mask = NULL;
+	u32 ret;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	u32 log_efuse_size = *bank_efuse_info->log_map_size;
+	u32 mask_size = log_efuse_size >> 4;
+
+	updated_mask = (u8 *)PLTFM_MALLOC(mask_size);
+	if (!updated_mask) {
+		PLTFM_MSG_ERR("[ERR]malloc updated mask\n");
+		return MACBUFALLOC;
+	}
+	PLTFM_MEMSET(updated_mask, 0x00, mask_size);
+
+	ret = update_eeprom_mask(adapter, info, updated_mask, 0);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]update eeprom mask\n");
+		goto error;
+	}
+
+	ret = check_efuse_enough(adapter, info, updated_mask);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]chk efuse enough\n");
+		goto error;
+	}
+
+	ret = program_efuse(adapter, info, updated_mask, 0);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("[ERR]pg efuse\n");
+		goto error;
+	}
+
+	PLTFM_FREE(updated_mask, mask_size);
+	return MACSUCCESS;
+error:
+	PLTFM_FREE(updated_mask, mask_size);
+	return ret;
+}
+
+static u32 dump_efuse_drv(struct mac_ax_adapter *adapter)
+{
+	u8 *map = NULL;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	u32 efuse_size = *bank_efuse_info->phy_map_size;
+	u32 ret;
+
+	PLTFM_MSG_TRACE("[TRACE]dump_efuse_drv\n");
+
+	if (*bank_efuse_info->phy_map_valid == 0) {
+		map = (u8 *)PLTFM_MALLOC(efuse_size);
+		if (!map) {
+			PLTFM_MSG_ERR("[ERR]malloc map\n");
+			return MACBUFALLOC;
+		}
+
+		ret = read_hw_efuse(adapter, 0, efuse_size, map);
+		if (ret != 0) {
+			PLTFM_FREE(map, efuse_size);
+			return ret;
+		}
+
+		PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+		PLTFM_MEMCPY(*bank_efuse_info->phy_map, map, efuse_size);
+		*bank_efuse_info->phy_map_valid = 1;
+		PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+		PLTFM_FREE(map, efuse_size);
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 dump_efuse_fw(struct mac_ax_adapter *adapter)
+{
+	u32 ret, cnt;
+	struct mac_ax_ops *ops = adapter->ops;
+	u8 *map = NULL;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	u32 efuse_size = *bank_efuse_info->phy_map_size;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u8 ofld_type = 0;
+
+	PLTFM_MSG_TRACE("[TRACE]dump_efuse_fw\n");
+
+	if (*bank_efuse_info->phy_map_valid == 0) {
+		if (bank_efuse_info->phy_map_size == &hw_info->dav_efuse_size)
+			ofld_type = DUMP_OFLD_TYPE_DAV;
+
+		/* H2C */
+		ret = ops->dump_efuse_ofld(adapter, efuse_size, ofld_type);
+		if (ret)
+			return ret;
+
+		/* Wait for C2H */
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A))
+			cnt = EFUSE_FW_DUMP_WAIT_CNT;
+		else
+			cnt = EFUSE_FW_DUMP_WAIT_CNT_V1;
+
+		while (--cnt) {
+			if (adapter->sm.efuse_ofld == MAC_AX_OFLD_H2C_DONE)
+				break;
+			PLTFM_DELAY_MS(1);
+		}
+		if (!cnt) {
+			PLTFM_MSG_ERR("[ERR]efuse C2H\n");
+			adapter->sm.efuse_ofld = MAC_AX_OFLD_H2C_IDLE;
+			return MACPROCERR;
+		}
+
+		/* cpy map */
+		map = (u8 *)PLTFM_MALLOC(efuse_size);
+		if (!map) {
+			PLTFM_MSG_ERR("[ERR]malloc map\n");
+			return MACBUFALLOC;
+		}
+		PLTFM_MEMSET(map, 0xFF, efuse_size);
+
+		ret = ops->efuse_ofld_map(adapter, map, efuse_size);
+		if (ret) {
+			PLTFM_FREE(map, efuse_size);
+			return ret;
+		}
+
+		PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+		PLTFM_MEMCPY(*bank_efuse_info->phy_map, map, efuse_size);
+		*bank_efuse_info->phy_map_valid = 1;
+		PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+		PLTFM_FREE(map, efuse_size);
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 proc_write_log_efuse(struct mac_ax_adapter *adapter, u32 offset,
+				u8 value)
+{
+	u8 byte1;
+	u8 byte2;
+	u8 blk;
+	u8 blk_idx;
+	u8 hdr;
+	u8 hdr2 = 0;
+	u8 *map = NULL;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	u32 log_efuse_size = *bank_efuse_info->log_map_size;
+	u32 end, ret;
+	bool is_bt = 0;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	map = (u8 *)PLTFM_MALLOC(log_efuse_size);
+	if (!map) {
+		PLTFM_MSG_ERR("[ERR]malloc map\n");
+		return MACBUFALLOC;
+	}
+
+	if (*bank_efuse_info->log_map_valid == 0) {
+		ret = read_log_efuse_map(adapter, map, log_efuse_size);
+		if (ret != 0) {
+			PLTFM_MSG_ERR("[ERR]read logical efuse\n");
+			PLTFM_FREE(map, log_efuse_size);
+			return ret;
+		}
+	} else {
+		PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+		PLTFM_MEMCPY(map, *bank_efuse_info->log_map, log_efuse_size);
+		PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+	}
+
+	if (log_efuse_size == adapter->hw_info->bt_log_efuse_size)
+		is_bt = 1;
+
+	if (*(map + offset) != value) {
+		end = *bank_efuse_info->efuse_end;
+
+		if (is_bt) {
+			if (offset < BT_1B_ENTRY_SIZE) { // 1 byte entry
+				blk = (u8)(offset >> 3);
+				blk_idx = (u8)((offset & (8 - 1)) >> 1);//mod8
+
+				hdr = (u8)((blk << 4) +
+					   ((0x1 << blk_idx) ^ 0x0F));
+			} else { // 2 byte entry
+				blk = (u8)(offset >> 3 >> 3); // large section
+				blk_idx = (u8)(((offset >> 3) & (8 - 1)) << 1);
+				hdr = (u8)((blk_idx << 4) + 0xF);
+
+				blk_idx = (u8)((offset & (8 - 1)) >> 1);
+				hdr2 = (u8)((blk << 4) +
+					    ((0x1 << blk_idx) ^ 0x0F));
+			}
+		} else {
+			blk = (u8)(offset >> 3);// offset
+			blk_idx = (u8)((offset & (8 - 1)) >> 1); // mod8 0 1 2 3
+
+			hdr = ((blk & 0xF0) >> 4) | 0x30;
+			hdr2 = (u8)(((blk & 0x0F) << 4) +
+				    ((0x1 << blk_idx) ^ 0x0F));
+		}
+
+		if ((offset & 1) == 0) {
+			byte1 = value;
+			byte2 = *(map + offset + 1);
+		} else {
+			byte1 = *(map + offset - 1);
+			byte2 = value;
+		}
+
+		if (*bank_efuse_info->phy_map_size <= 4 + end) { // write 4 bytes
+			PLTFM_FREE(map, log_efuse_size);
+			return MACEFUSESIZE;
+		}
+
+		p_ops->enable_efuse_sw_pwr_cut(adapter, 1);
+
+		ret = write_hw_efuse(adapter, end, hdr);
+		if (ret != 0)
+			goto error;
+
+		if (!is_bt || offset >= BT_1B_ENTRY_SIZE) {
+			ret = write_hw_efuse(adapter, end + 1, hdr2);
+			if (ret != 0)
+				goto error;
+			end++;
+		}
+
+		ret = write_hw_efuse(adapter, end + 1, byte1);
+		if (ret != 0)
+			goto error;
+
+		ret = write_hw_efuse(adapter, end + 2, byte2);
+		if (ret != 0)
+			goto error;
+
+		p_ops->disable_efuse_sw_pwr_cut(adapter, 1);
+	}
+
+	PLTFM_FREE(map, log_efuse_size);
+	return MACSUCCESS;
+error:
+	PLTFM_FREE(map, log_efuse_size);
+	return ret;
+}
+
+static u32 read_efuse(struct mac_ax_adapter *adapter, u32 offset, u32 size,
+		      u8 *map)
+{
+	u32 ret;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+
+	if (!map) {
+		PLTFM_MSG_ERR("[ERR]malloc map\n");
+		return MACBUFALLOC;
+	}
+
+	if (*bank_efuse_info->phy_map_valid == 1) {
+		PLTFM_MEMCPY(map, *bank_efuse_info->phy_map + offset, size);
+	} else {
+		ret = read_hw_efuse(adapter, offset, size, map);
+		if (ret != 0)
+			return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 update_eeprom_mask(struct mac_ax_adapter *adapter,
+			      struct mac_ax_pg_efuse_info *info,
+			      u8 *updated_mask, bool pg_sim)
+{
+	u8 *map = NULL;
+	u8 *mask_map = NULL;
+	u8 clr_bit = 0;
+	u8 *map_pg;
+	u8 *efuse_mask;
+	u32 i;
+	u16 j;
+	u16 map_offset;
+	u16 mask_offset;
+	u32 ret;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	u32 log_efuse_size = *bank_efuse_info->log_map_size;
+
+	map = (u8 *)PLTFM_MALLOC(log_efuse_size);
+	if (!map) {
+		PLTFM_MSG_ERR("[ERR]malloc map\n");
+		return MACBUFALLOC;
+	}
+	PLTFM_MEMSET(map, 0xFF, log_efuse_size); // default: 0xFF
+
+	if (pg_sim) { //WL
+		PLTFM_MEMCPY(map, *bank_efuse_info->log_map, log_efuse_size);
+	} else {
+		ret = read_log_efuse_map(adapter, map, log_efuse_size);
+		if (ret != 0)
+			goto error;
+	}
+
+	/*log mask*/
+	mask_map = (u8 *)PLTFM_MALLOC(log_efuse_size);
+	if (!mask_map) {
+		PLTFM_MSG_ERR("[ERR]malloc mask map\n");
+		PLTFM_FREE(map, log_efuse_size);
+		return MACBUFALLOC;
+	}
+	PLTFM_MEMSET(mask_map, 0xFF, log_efuse_size);// default: 0xFF
+
+	ret = eeprom_parser(adapter, *bank_efuse_info->phy_map,
+			    mask_map, MAC_AX_EFUSE_PARSER_MASK);
+	if (ret != 0) {
+		PLTFM_FREE(mask_map, log_efuse_size);
+		goto error;
+	}
+
+	map_pg = info->efuse_map;
+	efuse_mask = info->efuse_mask;
+
+	PLTFM_MEMCPY(updated_mask, efuse_mask, info->efuse_mask_size);
+
+	for (i = 0; i < info->efuse_map_size; i += 16) {
+		for (j = 0; j < 16; j += 2) {
+			map_offset = i + j;
+			mask_offset = i >> 4;
+			if (*(u16 *)(map_pg + map_offset) ==
+			    *(u16 *)(map + map_offset) &&
+			    *(mask_map + map_offset) == 0x00) {
+				switch (j) {
+				case 0:
+					clr_bit = BIT(4);
+					break;
+				case 2:
+					clr_bit = BIT(5);
+					break;
+				case 4:
+					clr_bit = BIT(6);
+					break;
+				case 6:
+					clr_bit = BIT(7);
+					break;
+				case 8:
+					clr_bit = BIT(0);
+					break;
+				case 10:
+					clr_bit = BIT(1);
+					break;
+				case 12:
+					clr_bit = BIT(2);
+					break;
+				case 14:
+					clr_bit = BIT(3);
+					break;
+				default:
+					break;
+				}
+				*(updated_mask + mask_offset) &= ~clr_bit;
+			}
+		}
+	}
+
+	PLTFM_FREE(map, log_efuse_size);
+	PLTFM_FREE(mask_map, log_efuse_size);
+	return MACSUCCESS;
+error:
+	PLTFM_FREE(map, log_efuse_size);
+	return ret;
+}
+
+static u32 check_efuse_enough(struct mac_ax_adapter *adapter,
+			      struct mac_ax_pg_efuse_info *info,
+			      u8 *updated_mask)
+{
+	u8 pre_word_en;
+	u32 i;
+	u16 j;
+	u32 eeprom_offset;
+	u32 pg_num = 0;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+
+	for (i = 0; i < info->efuse_map_size; i += 8) {
+		eeprom_offset = i;
+
+		if ((eeprom_offset & 0xF) > 0)
+			pre_word_en = (*(updated_mask + (i >> 4)) & 0x0F);
+		else
+			pre_word_en = (*(updated_mask + (i >> 4)) >> 4);
+
+		if (pre_word_en > 0) { // msk ==1 -> write
+			pg_num += 2;
+			for (j = 0; j < 4; j++) {
+				if (((pre_word_en >> j) & 0x1) > 0)
+					pg_num += 2;
+			}
+		}
+	}
+
+	if (*bank_efuse_info->phy_map_size
+		< (pg_num + *bank_efuse_info->efuse_end))
+		return MACEFUSESIZE;
+
+	return MACSUCCESS;
+}
+
+static u32 proc_pg_efuse(struct mac_ax_adapter *adapter,
+			 struct mac_ax_pg_efuse_info *info, u8 word_en,
+			 u8 pre_word_en, u32 eeprom_offset, bool pg_sim)
+{
+	u8 blk, blk_idx;
+	u8 hdr;
+	u8 hdr2 = 0xFF;
+	u8 i;
+	u32 efuse_end, ret;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	u8 *efuse_map = *bank_efuse_info->phy_map;
+	bool is_bt = 0;
+
+	if (info->efuse_map_size == adapter->hw_info->bt_log_efuse_size)
+		is_bt = 1;
+
+	efuse_end = *bank_efuse_info->efuse_end;
+
+	if (is_bt) {
+		if (eeprom_offset < BT_1B_ENTRY_SIZE) {
+			blk = (u8)(eeprom_offset >> 3);
+			hdr = (u8)((blk << 4) + word_en);
+		} else {
+			blk = (u8)(eeprom_offset >> 3 >> 3);
+			blk_idx = (u8)(((eeprom_offset >> 3) & (8 - 1)) << 1);
+			hdr = (u8)((blk_idx << 4) | 0xF);
+			hdr2 = (u8)((blk << 4) + word_en);
+		}
+	} else {
+		blk = (u8)(eeprom_offset >> 3);
+		hdr = ((blk & 0xF0) >> 4) | 0x30;
+		hdr2 = (u8)(((blk & 0x0F) << 4) + word_en);
+	}
+
+	if (pg_sim) { //WL
+		*(efuse_map + efuse_end) = hdr;
+		*(efuse_map + efuse_end + 1) = hdr2;
+
+		efuse_end += 2;
+
+		for (i = 0; i < 4; i++) {
+			if (((pre_word_en >> i) & 0x1) > 0) {
+				*(efuse_map + efuse_end) = *(info->efuse_map +
+					eeprom_offset + (i << 1));
+				efuse_end++;
+
+				*(efuse_map + efuse_end) = *(info->efuse_map +
+					eeprom_offset + (i << 1) + 1);
+				efuse_end++;
+			}
+		}
+	} else {
+		ret = write_hw_efuse(adapter, efuse_end, hdr);
+		if (ret != 0) {
+			PLTFM_MSG_ERR("[ERR]write efuse\n");
+			return ret;
+		}
+
+		if (is_bt == 0 || eeprom_offset >= BT_1B_ENTRY_SIZE) {
+			ret = write_hw_efuse(adapter, efuse_end + 1, hdr2);
+			if (ret != 0) {
+				PLTFM_MSG_ERR("[ERR]write efuse(+1)\n");
+				return ret;
+			}
+			efuse_end++;
+		}
+
+		efuse_end++;
+		for (i = 0; i < 4; i++) {
+			if (((pre_word_en >> i) & 0x1) > 0) {
+				ret = write_hw_efuse(adapter, efuse_end,
+						     *(info->efuse_map +
+						     eeprom_offset + (i << 1)));
+				if (ret != 0) {
+					PLTFM_MSG_ERR("[ERR]write efuse\n");
+					return ret;
+				}
+
+				ret = write_hw_efuse(adapter, efuse_end + 1,
+						     *(info->efuse_map +
+						     eeprom_offset +
+						     (i << 1) + 1));
+				if (ret != 0) {
+					PLTFM_MSG_ERR("[ERR]write efuse+1\n");
+					return ret;
+				}
+				efuse_end = efuse_end + 2;
+			}
+		}
+	}
+	*bank_efuse_info->efuse_end = efuse_end;
+	return MACSUCCESS;
+}
+
+static u32 program_efuse(struct mac_ax_adapter *adapter,
+			 struct mac_ax_pg_efuse_info *info, u8 *updated_mask,
+			 bool pg_sim)
+{
+	u8 pre_word_en;
+	u8 word_en;
+	u32 i;
+	u32 eeprom_offset, ret;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	p_ops->enable_efuse_sw_pwr_cut(adapter, 1);
+
+	for (i = 0; i < info->efuse_map_size; i += 8) {
+		eeprom_offset = i;
+
+		if (((eeprom_offset >> 3) & 1) > 0) {
+			pre_word_en = (*(updated_mask + (i >> 4)) & 0x0F);
+			word_en = pre_word_en ^ 0x0F;
+		} else {
+			pre_word_en = (*(updated_mask + (i >> 4)) >> 4);
+			word_en = pre_word_en ^ 0x0F;
+		}
+
+		if (pre_word_en > 0) {
+			ret = proc_pg_efuse(adapter, info, word_en, pre_word_en,
+					    eeprom_offset, pg_sim);
+			if (ret != 0) {
+				PLTFM_MSG_ERR("[ERR]pg efuse");
+				return ret;
+			}
+		}
+	}
+
+	p_ops->disable_efuse_sw_pwr_cut(adapter, 1);
+
+	return MACSUCCESS;
+}
+
+static void mask_eeprom(struct mac_ax_adapter *adapter,
+			struct mac_ax_pg_efuse_info *info)
+{
+	u8 pre_word_en;
+	u8 *updated_mask;
+	u8 *efuse_map;
+	u32 i;
+	u16 j;
+	u32 offset;
+
+	updated_mask = info->efuse_mask;
+	efuse_map = info->efuse_map;
+
+	for (i = 0; i < info->efuse_map_size; i += 8) {
+		offset = i;
+
+		if (((offset >> 3) & 1) > 0)
+			pre_word_en = (*(updated_mask + (i >> 4)) & 0x0F);
+		else
+			pre_word_en = (*(updated_mask + (i >> 4)) >> 4);
+
+		for (j = 0; j < 4; j++) {
+			if (((pre_word_en >> j) & 0x1) == 0) {
+				*(efuse_map + offset + (j << 1)) = 0xFF;
+				*(efuse_map + offset + (j << 1) + 1) = 0xFF;
+			}
+		}
+	}
+}
+
+static u32 query_status_map(struct mac_ax_adapter *adapter,
+			    enum mac_ax_efuse_feature_id feature_id,
+			    u8 *map, bool is_limit)
+{
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	enum mac_ax_intf intf = adapter->hw_info->intf;
+	u32 map_size = 0;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+
+	PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+	switch (feature_id) {
+	case MAC_AX_DUMP_PHYSICAL_EFUSE:
+		map_size = *bank_efuse_info->phy_map_size;
+		PLTFM_MEMCPY(map, *bank_efuse_info->phy_map, map_size);
+		break;
+	case MAC_AX_DUMP_LOGICAL_EFUSE:
+		if (!is_limit) {
+			map_size = *bank_efuse_info->log_map_size;
+		} else {// WL
+			switch (intf) {
+			case MAC_AX_INTF_PCIE:
+				map_size = hw_info->limit_efuse_size_pcie;
+				break;
+			case MAC_AX_INTF_USB:
+				map_size = hw_info->limit_efuse_size_usb;
+				break;
+			case MAC_AX_INTF_SDIO:
+				map_size = hw_info->limit_efuse_size_sdio;
+				break;
+			default:
+				break;
+			}
+		}
+		PLTFM_MEMCPY(map, *bank_efuse_info->log_map, map_size);
+		break;
+	default:
+		return MACFUNCINPUT;
+	}
+	PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+
+	return MACSUCCESS;
+}
+
+static u32 adjust_mask(struct mac_ax_adapter *adapter,
+		       struct mac_ax_pg_efuse_info *info)
+{
+	u8 *efuse_mask = info->efuse_mask;
+	u8 *efuse_map = info->efuse_map;
+	u32 i = 0;
+	u16 j = 0;
+	u16 map_offset;
+	u16 mask_offset;
+	u8 adj_bit = 0;
+
+	PLTFM_MEMSET(efuse_mask, 0xFF, info->efuse_mask_size);
+
+	for (i = 0; i < info->efuse_map_size; i += 16) {
+		for (j = 0; j < 16; j += 2) {
+			map_offset = i + j;
+			mask_offset = i >> 4;
+
+			if (*(u16 *)(efuse_map + map_offset) == 0xFFFF) {
+				switch (j) {
+				case 0:
+					adj_bit = BIT(4);
+					break;
+				case 2:
+					adj_bit = BIT(5);
+					break;
+				case 4:
+					adj_bit = BIT(6);
+					break;
+				case 6:
+					adj_bit = BIT(7);
+					break;
+				case 8:
+					adj_bit = BIT(0);
+					break;
+				case 10:
+					adj_bit = BIT(1);
+					break;
+				case 12:
+					adj_bit = BIT(2);
+					break;
+				case 14:
+					adj_bit = BIT(3);
+					break;
+				}
+				*(efuse_mask + mask_offset) &= ~adj_bit;
+			}
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 compare_info_length(struct efuse_info *info,
+			       enum rtw_efuse_info id, u32 length)
+{
+	u32 idle_len;
+
+	switch (id) {
+	case EFUSE_INFO_MAC_ADDR:
+		idle_len = info->len->mac_addr;
+		break;
+	case EFUSE_INFO_MAC_PID:
+		idle_len = info->len->pid;
+		break;
+	case EFUSE_INFO_MAC_DID:
+		idle_len = info->len->did;
+		break;
+	case EFUSE_INFO_MAC_VID:
+		idle_len = info->len->vid;
+		break;
+	case EFUSE_INFO_MAC_SVID:
+		idle_len = info->len->svid;
+		break;
+	case EFUSE_INFO_MAC_SMID:
+		idle_len = info->len->smid;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	if (length != idle_len || idle_len == 0)
+		return MACLENCMP;
+
+	return MACSUCCESS;
+}
+
+static u32 set_check_sum_val(struct mac_ax_adapter *adapter,
+			     u8 *map, u16 value)
+{
+	u8 byte1;
+	u8 byte2;
+	u8 blk;
+	u8 blk_idx;
+	u8 hdr;
+	u8 hdr2;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	u32 end = *bank_efuse_info->efuse_end, ret;
+	u32 offset = chksum_offset_1;
+	u8 i = 0;
+	u8 value8 = (u8)(value & 0xFF);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	p_ops->enable_efuse_sw_pwr_cut(adapter, 1);
+
+	for (i = 0; i < 2; i++) {
+		blk = (u8)(offset >> 3);
+		blk_idx = (u8)((offset & (8 - 1)) >> 1);
+
+		hdr = ((blk & 0xF0) >> 4) | 0x30;
+		hdr2 = (u8)(((blk & 0x0F) << 4) + ((0x1 << blk_idx) ^ 0x0F));
+
+		if ((offset & 1) == 0) {
+			byte1 = value8;
+			byte2 = *(map + offset + 1);
+		} else {
+			byte1 = (u8)(value & 0xFF);
+			byte2 = value8;
+		}
+
+		if (*bank_efuse_info->phy_map_size <= 4 + end)
+			return MACEFUSESIZE;
+
+		ret = write_hw_efuse(adapter, end, hdr);
+		if (ret != 0)
+			return ret;
+
+		ret = write_hw_efuse(adapter, end + 1, hdr2);
+		if (ret != 0)
+			return ret;
+
+		ret = write_hw_efuse(adapter, end + 2, byte1);
+		if (ret != 0)
+			return ret;
+
+		ret = write_hw_efuse(adapter, end + 3, byte2);
+		if (ret != 0)
+			return ret;
+
+		offset = chksum_offset_2;
+		value8 = (u8)((value & 0xFF00) >> 8);
+		end += 4;
+	}
+
+	p_ops->disable_efuse_sw_pwr_cut(adapter, 1);
+
+	return MACSUCCESS;
+}
+
+static void cal_check_sum(struct mac_ax_adapter *adapter, u16 *chksum)
+{
+	u32 i = 0;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	struct mac_ax_efuse_param *efuse_param = &adapter->efuse_param;
+	u8 *map = efuse_param->log_efuse_map;
+	u16 *data;
+
+	data = (u16 *)map;
+
+	*chksum = 0x0000;
+	for (i = 0; i < hw_info->log_efuse_size >> 2; i++) {
+		if (i == chksum_offset_1 >> 2)
+			*chksum ^= 0x0000 ^ *(data + (2 * i + 1));
+		else
+			*chksum ^= *(data + 2 * i) ^ *(data + (2 * i + 1));
+	}
+}
+
+static u32 compare_version(struct mac_ax_adapter *adapter,
+			   struct mac_ax_pg_efuse_info *info, u32 ver_len)
+{
+	u8 *map = info->efuse_map;
+	u8 *mask = info->efuse_mask;
+	u32 map_size = info->efuse_map_size;
+	u32 i = 0;
+
+	for (i = 0; i < ver_len; i++) {
+		if (*(map + map_size + i) != *(mask + (map_size >> 4) + i))
+			return MACVERERR;
+	}
+	return MACSUCCESS;
+}
+
+u32 enable_efuse_pwr_cut_dav(struct mac_ax_adapter *adapter,
+			     bool is_write)
+{
+	u32 ret;
+	u8 chip_id = adapter->hw_info->chip_id;
+
+	if (!(is_write))
+		return MACSUCCESS;
+
+	if (chip_id == MAC_AX_CHIP_ID_8852A) {
+		return MACSUCCESS;
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_PWR_CUT,
+					XTAL_SI_SMALL_PWR_CUT,
+					XTAL_SI_SMALL_PWR_CUT);
+		if (ret)
+			return ret;
+
+		ret = mac_write_xtal_si(adapter, XTAL_SI_PWR_CUT,
+					XTAL_SI_BIG_PWR_CUT,
+					XTAL_SI_BIG_PWR_CUT);
+		if (ret)
+			return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 disable_efuse_pwr_cut_dav(struct mac_ax_adapter *adapter,
+			      bool is_write)
+{
+	u32 ret;
+	u8 chip_id = adapter->hw_info->chip_id;
+
+	if (!(is_write))
+		return MACSUCCESS;
+
+	if (chip_id == MAC_AX_CHIP_ID_8852A) {
+		return MACSUCCESS;
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_PWR_CUT, 0,
+					XTAL_SI_BIG_PWR_CUT);
+		if (ret)
+			return ret;
+
+		ret = mac_write_xtal_si(adapter, XTAL_SI_PWR_CUT, 0,
+					XTAL_SI_SMALL_PWR_CUT);
+		if (ret)
+			return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 read_hw_efuse_dav(struct mac_ax_adapter *adapter, u32 offset, u32 size,
+			     u8 *map)
+{
+	u32 addr;
+	u8 tmp8;
+	u32 cnt;
+	u32 ret;
+
+	ret = enable_efuse_pwr_cut_dav(adapter, 0);
+	if (ret)
+		return ret;
+
+	for (addr = offset; addr < offset + size; addr++) {
+		/* clear ready bit*/
+		ret = mac_write_xtal_si(adapter, XTAL_SI_CTRL, 0x40, FULL_BIT_MASK);
+		if (ret)
+			return ret;
+		/* set addr */
+		ret = mac_write_xtal_si(adapter, XTAL_SI_LOW_ADDR,
+					(addr & 0xff) << XTAL_SI_LOW_ADDR_SH,
+					XTAL_SI_LOW_ADDR_MSK);
+		if (ret)
+			return ret;
+		ret = mac_write_xtal_si(adapter, XTAL_SI_CTRL, (addr >> 8)
+					<< XTAL_SI_HIGH_ADDR_SH,
+					XTAL_SI_HIGH_ADDR_MSK
+					<< XTAL_SI_HIGH_ADDR_SH);
+		if (ret)
+			return ret;
+		/* set ctrl mode sel */
+		ret = mac_write_xtal_si(adapter, XTAL_SI_CTRL, 0,
+					XTAL_SI_MODE_SEL_MSK
+					<< XTAL_SI_MODE_SEL_SH);
+		if (ret)
+			return ret;
+
+		/* polling */
+		cnt = EFUSE_WAIT_CNT;
+		while (--cnt) {
+			ret = mac_read_xtal_si(adapter, XTAL_SI_CTRL, &tmp8);
+			if (ret)
+				return ret;
+			if (tmp8 & XTAL_SI_RDY)
+				break;
+			PLTFM_DELAY_US(1);
+		}
+		if (!cnt) {
+			PLTFM_MSG_ERR("[ERR]read efuse\n");
+			return MACEFUSEREAD;
+		}
+
+		ret = mac_read_xtal_si(adapter, XTAL_SI_READ_VAL, &tmp8);
+		if (ret)
+			return ret;
+		*(map + addr - offset) = tmp8;
+	}
+
+	ret = disable_efuse_pwr_cut_dav(adapter, 0);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+static u32 write_hw_efuse_dav(struct mac_ax_adapter *adapter, u32 offset,
+			      u8 value)
+{
+	u32 cnt;
+	u32 ret;
+	u8 tmp8;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+
+	PLTFM_MUTEX_LOCK(&adapter->efuse_param.efuse_tbl.lock);
+	*bank_efuse_info->phy_map_valid = 0;
+	*bank_efuse_info->log_map_valid = 0;
+	PLTFM_MUTEX_UNLOCK(&adapter->efuse_param.efuse_tbl.lock);
+
+	/* clear ready bit*/
+	ret = mac_write_xtal_si(adapter, XTAL_SI_CTRL, 0x40, FULL_BIT_MASK);
+	if (ret)
+		return ret;
+	/* set val */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WRITE_VAL, value <<
+				XTAL_SI_WRITE_DATA_SH, XTAL_SI_WRITE_DATA_MSK <<
+				XTAL_SI_WRITE_DATA_SH);
+	if (ret)
+		return ret;
+	/* set addr */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_LOW_ADDR, (offset & 0xff)
+				<< XTAL_SI_LOW_ADDR_SH,
+				XTAL_SI_LOW_ADDR_MSK << XTAL_SI_LOW_ADDR_SH);
+	if (ret)
+		return ret;
+	ret = mac_write_xtal_si(adapter, XTAL_SI_CTRL, (offset >> 8)
+				<< XTAL_SI_HIGH_ADDR_SH,
+				XTAL_SI_HIGH_ADDR_MSK << XTAL_SI_HIGH_ADDR_SH);
+	if (ret)
+		return ret;
+	/* set ctrl mode sel */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_CTRL, 0x2
+				<< XTAL_SI_MODE_SEL_SH,
+				XTAL_SI_MODE_SEL_MSK <<	XTAL_SI_MODE_SEL_SH);
+	if (ret)
+		return ret;
+
+	/* polling */
+	cnt = EFUSE_WAIT_CNT;
+	while (--cnt) {
+		ret = mac_read_xtal_si(adapter, XTAL_SI_CTRL, &tmp8);
+		if (ret)
+			return ret;
+		if (tmp8 & XTAL_SI_RDY)
+			break;
+		PLTFM_DELAY_US(1);
+	}
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR]write efuse\n");
+		return MACEFUSEREAD;
+	}
+
+	return MACSUCCESS;
+}
+
+static void switch_dv(struct mac_ax_adapter *adapter, enum rtw_dv_sel sel)
+{
+	adapter->efuse_param.dv_sel = sel;
+	PLTFM_MSG_TRACE("[TRACE]dv_sel= 0x%x, adapter->dv_sel = 0x%x\n",
+			sel, adapter->efuse_param.dv_sel);
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/efuse.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/efuse.h
new file mode 100644
index 000000000000..9a57f4ac8550
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/efuse.h
@@ -0,0 +1,1108 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_EFUSE_H_
+#define _MAC_AX_EFUSE_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+
+#define RSVD_EFUSE_SIZE		16
+#define RSVD_CS_EFUSE_SIZE	24
+#define EFUSE_WAIT_CNT		10000
+#define EFUSE_WAIT_CNT_PLUS	30000
+#define EFUSE_C2HREG_WAIT_CNT	10000
+#define EFUSE_C2HREG_RETRY_WAIT_US 1
+#define EFUSE_FW_DUMP_WAIT_CNT	100
+#define EFUSE_FW_DUMP_WAIT_CNT_V1 400
+#define OTP_PHY_SIZE		0x800
+#define CHK_OTP_ADDR		0x4
+#define CHK_OTP_WAIT_CNT	50000
+#define DUMMY_READ_DELAY	200
+
+#define BT_1B_ENTRY_SIZE	0x80
+#define UNLOCK_CODE		0x69
+
+#define XTAL_SI_PWR_CUT		0x10
+#define XTAL_SI_SMALL_PWR_CUT	BIT(0)
+#define XTAL_SI_BIG_PWR_CUT	BIT(1)
+
+#define XTAL_SI_LOW_ADDR	0x62
+#define XTAL_SI_LOW_ADDR_SH	0
+#define XTAL_SI_LOW_ADDR_MSK	0xFF
+
+#define XTAL_SI_CTRL		0x63
+#define XTAL_SI_MODE_SEL_SH	6
+#define XTAL_SI_MODE_SEL_MSK	0x3
+#define XTAL_SI_RDY		BIT(5)
+#define XTAL_SI_HIGH_ADDR_SH	0
+#define XTAL_SI_HIGH_ADDR_MSK	0x7
+
+#define XTAL_SI_READ_VAL	0x7A
+#define XTAL_SI_WRITE_VAL	0x60
+#define XTAL_SI_WRITE_DATA_SH	0
+#define XTAL_SI_WRITE_DATA_MSK	0xFF
+
+#define DUMP_OFLD_TYPE_HIDDEN	1
+#define DUMP_OFLD_TYPE_DAV	2
+
+#define BT_DIS_WAIT_CNT	100
+#define BT_DIS_WAIT_US	50
+
+#define EF_FV_OFSET_AX 0x5EA
+#define EF_FV_OFSET_BE 0x77CA
+#define EF_FV_OFSET_BE_V1 0x1FCA
+
+#define EF_CV_OFSET 0x4
+#define EF_CV_MSK 0xF
+
+/**
+ * @struct mac_efuse_hidden_h2creg
+ * @brief mac_efuse_hidden_h2creg
+ *
+ * @var mac_efuse_hidden_h2creg::rsvd0
+ * Please Place Description here.
+ */
+struct mac_efuse_hidden_h2creg {
+	/* dword0 */
+	u32 rsvd0:16;
+};
+
+/**
+ * @enum efuse_map_sel
+ *
+ * @brief efuse_map_sel
+ *
+ * @var efuse_map_sel::EFUSE_MAP_SEL_PHY_WL
+ * Please Place Description here.
+ * @var efuse_map_sel::EFUSE_MAP_SEL_PHY_BT
+ * Please Place Description here.
+ * @var efuse_map_sel::EFUSE_MAP_SEL_LOG
+ * Please Place Description here.
+ * @var efuse_map_sel::EFUSE_MAP_SEL_LOG_BT
+ * Please Place Description here.
+ * @var efuse_map_sel::EFUSE_MAP_SEL_PHY_OTP
+ * Please Place Description here.
+ * @var efuse_map_sel::EFUSE_MAP_SEL_LAST
+ * Please Place Description here.
+ * @var efuse_map_sel::EFUSE_MAP_SEL_MAX
+ * Please Place Description here.
+ * @var efuse_map_sel::EFUSE_MAP_SEL_INVALID
+ * Please Place Description here.
+ */
+enum efuse_map_sel {
+	EFUSE_MAP_SEL_PHY_WL,
+	EFUSE_MAP_SEL_PHY_BT,
+	EFUSE_MAP_SEL_LOG,
+	EFUSE_MAP_SEL_LOG_BT,
+	EFUSE_MAP_SEL_PHY_OTP,
+	EFUSE_MAP_SEL_PHY_DAV,
+	EFUSE_MAP_SEL_LOG_DAV,
+	EFUSE_MAP_SEL_HIDDEN_RF,
+
+	/* keep last */
+	EFUSE_MAP_SEL_LAST,
+	EFUSE_MAP_SEL_MAX = EFUSE_MAP_SEL_LAST,
+	EFUSE_MAP_SEL_INVALID = EFUSE_MAP_SEL_LAST,
+};
+
+/**
+ * @struct efuse_info_item
+ * @brief efuse_info_item
+ *
+ * @var efuse_info_item::mac_addr
+ * MAC Address
+ * @var efuse_info_item::pid
+ * Product ID
+ * @var efuse_info_item::did
+ * Device ID
+ * @var efuse_info_item::vid
+ * Vendor ID
+ * @var efuse_info_item::svid
+ * Sybsystem Vendor ID
+ * @var efuse_info_offset::smid
+ * Sybsystem Device ID
+ */
+struct efuse_info_item {
+	u32 mac_addr;
+	u32 pid;
+	u32 did;
+	u32 vid;
+	u32 svid;
+	u32 smid;
+};
+
+/**
+ * @struct efuse_info
+ * @brief efuse_info
+ *
+ * @var efuse_info::offset
+ * Efuse information offset
+ * @var efuse_info::def_val
+ * Efuse information default value
+ * @var efuse_info::len
+ * Efuse information length
+ */
+struct efuse_info {
+	struct efuse_info_item *offset;
+	struct efuse_info_item *def_val;
+	struct efuse_info_item *len;
+};
+
+/**
+ * @enum mac_checksum_offset
+ *
+ * @brief mac_checksum_offset
+ *
+ * @var mac_checksum_offset::chksum_offset_1
+ * Please Place Description here.
+ * @var mac_checksum_offset::chksum_offset_2
+ * Please Place Description here.
+ */
+enum mac_checksum_offset {
+	chksum_offset_1 = 0x1AC,
+	chksum_offset_2 = 0x1AD,
+};
+
+/**
+ * @enum mac_defeature_offset
+ *
+ * @brief mac_defeature_offset
+ *
+ * @var mac_defeature_offset::rx_spatial_stream
+ * Please Place Description here.
+ * @var mac_defeature_offset::rx_spatial_stream_sh
+ * Please Place Description here.
+ * @var mac_defeature_offset::rx_spatial_stream_msk
+ * Please Place Description here.
+ * @var mac_defeature_offset::bandwidth
+ * Please Place Description here.
+ * @var mac_defeature_offset::bandwidth_sh
+ * Please Place Description here.
+ * @var mac_defeature_offset::bandwidth_msk
+ * Please Place Description here.
+ * @var mac_defeature_offset::tx_spatial_stream
+ * Please Place Description here.
+ * @var mac_defeature_offset::tx_spatial_stream_sh
+ * Please Place Description here.
+ * @var mac_defeature_offset::tx_spatial_stream_msk
+ * Please Place Description here.
+ * @var mac_defeature_offset::protocol_80211
+ * Please Place Description here.
+ * @var mac_defeature_offset::protocol_80211_sh
+ * Please Place Description here.
+ * @var mac_defeature_offset::protocol_80211_msk
+ * Please Place Description here.
+ * @var mac_defeature_offset::NIC_router
+ * Please Place Description here.
+ * @var mac_defeature_offset::NIC_router_sh
+ * Please Place Description here.
+ * @var mac_defeature_offset::NIC_router_msk
+ * Please Place Description here.
+ */
+enum mac_defeature_offset {
+	rx_spatial_stream = 0xB,
+	rx_spatial_stream_sh = 0x4,
+	rx_spatial_stream_msk = 0x7,
+	bandwidth = 0xD,
+	bandwidth_sh = 0x0,
+	bandwidth_msk = 0x7,
+	tx_spatial_stream = 0xD,
+	tx_spatial_stream_sh = 0x4,
+	tx_spatial_stream_msk = 0x7,
+	protocol_80211 = 0x11,
+	protocol_80211_sh = 0x2,
+	protocol_80211_msk = 0x3,
+	NIC_router = 0x11,
+	NIC_router_sh = 0x6,
+	NIC_router_msk = 0x3,
+};
+
+/**
+ * @enum mac_cntlr_mode_sel
+ *
+ * @brief mac_cntlr_mode_sel
+ *
+ * @var mac_cntlr_mode_sel::MODE_READ
+ * Please Place Description here.
+ * @var mac_cntlr_mode_sel::MODE_AUTOLOAD_EN
+ * Please Place Description here.
+ * @var mac_cntlr_mode_sel::MODE_WRITE
+ * Please Place Description here.
+ * @var mac_cntlr_mode_sel::MODE_CMP
+ * Please Place Description here.
+ */
+enum mac_cntlr_mode_sel {
+	MODE_READ,
+	MODE_AUTOLOAD_EN,
+	MODE_WRITE,
+	MODE_CMP,
+};
+
+enum efuse_fv_type {
+	FV_TYPE1 = 0xF,
+	FV_TYPE2 = 0xE,
+	FV_TYPE3 = 0xC,
+	FV_TYPE4 = 0x8,
+};
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_dump_efuse_map_wl
+ *
+ * @param *adapter
+ * @param cfg
+ * @param *efuse_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dump_efuse_map_wl_plus(struct mac_ax_adapter *adapter,
+			       enum mac_ax_efuse_read_cfg cfg, u8 *efuse_map);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_dump_efuse_map_wl
+ *
+ * @param *adapter
+ * @param cfg
+ * @param *efuse_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dump_efuse_map_wl(struct mac_ax_adapter *adapter,
+			  enum mac_ax_efuse_read_cfg cfg, u8 *efuse_map);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_dump_efuse_map_bt
+ *
+ * @param *adapter
+ * @param cfg
+ * @param *efuse_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dump_efuse_map_bt(struct mac_ax_adapter *adapter,
+			  enum mac_ax_efuse_read_cfg cfg, u8 *efuse_map);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_write_efuse
+ *
+ * @param *adapter
+ * @param addr
+ * @param val
+ * @param bank
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_efuse_plus(struct mac_ax_adapter *adapter, u32 addr, u8 val,
+			 enum mac_ax_efuse_bank bank);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_write_efuse
+ *
+ * @param *adapter
+ * @param addr
+ * @param val
+ * @param bank
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_efuse(struct mac_ax_adapter *adapter, u32 addr, u8 val,
+		    enum mac_ax_efuse_bank bank);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_read_efuse_plus
+ *
+ * @param *adapter
+ * @param addr
+ * @param size
+ * @param *val
+ * @param bank
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_efuse_plus(struct mac_ax_adapter *adapter, u32 addr, u32 size,
+			u8 *val, enum mac_ax_efuse_bank bank);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_read_efuse
+ *
+ * @param *adapter
+ * @param addr
+ * @param size
+ * @param *val
+ * @param bank
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_efuse(struct mac_ax_adapter *adapter, u32 addr, u32 size, u8 *val,
+		   enum mac_ax_efuse_bank bank);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_read_hidden_efuse
+ *
+ * @param *adapter
+ * @param addr
+ * @param size
+ * @param *val
+ * @param hidden_cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_hidden_efuse(struct mac_ax_adapter *adapter, u32 addr, u32 size,
+			  u8 *val, enum mac_ax_efuse_hidden_cfg hidden_cfg);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_get_efuse_avl_size
+ *
+ * @param *adapter
+ * @param *size
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_efuse_avl_size(struct mac_ax_adapter *adapter, u32 *size);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_get_efuse_avl_size_bt
+ *
+ * @param *adapter
+ * @param *size
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_efuse_avl_size_bt(struct mac_ax_adapter *adapter, u32 *size);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_dump_log_efuse
+ *
+ * @param *adapter
+ * @param parser_cfg
+ * @param cfg
+ * @param *efuse_map
+ * @param is_limit
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dump_log_efuse_plus(struct mac_ax_adapter *adapter,
+			    enum mac_ax_efuse_parser_cfg parser_cfg,
+			    enum mac_ax_efuse_read_cfg cfg,
+			    u8 *efuse_map, bool is_limit);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_dump_log_efuse
+ *
+ * @param *adapter
+ * @param parser_cfg
+ * @param cfg
+ * @param *efuse_map
+ * @param is_limit
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dump_log_efuse(struct mac_ax_adapter *adapter,
+		       enum mac_ax_efuse_parser_cfg parser_cfg,
+		       enum mac_ax_efuse_read_cfg cfg,
+		       u8 *efuse_map, bool is_limit);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_read_log_efuse_plus
+ *
+ * @param *adapter
+ * @param addr
+ * @param size
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_log_efuse_plus(struct mac_ax_adapter *adapter, u32 addr, u32 size,
+			    u8 *val);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_read_log_efuse
+ *
+ * @param *adapter
+ * @param addr
+ * @param size
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_log_efuse(struct mac_ax_adapter *adapter, u32 addr, u32 size,
+		       u8 *val);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_write_log_efuse_plus
+ *
+ * @param *adapter
+ * @param addr
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_log_efuse_plus(struct mac_ax_adapter *adapter, u32 addr, u8 val);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_write_log_efuse
+ *
+ * @param *adapter
+ * @param addr
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_log_efuse(struct mac_ax_adapter *adapter, u32 addr, u8 val);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_dump_log_efuse_bt
+ *
+ * @param *adapter
+ * @param parser_cfg
+ * @param cfg
+ * @param *efuse_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dump_log_efuse_bt(struct mac_ax_adapter *adapter,
+			  enum mac_ax_efuse_parser_cfg parser_cfg,
+			  enum mac_ax_efuse_read_cfg cfg,
+			  u8 *efuse_map);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_read_log_efuse_bt
+ *
+ * @param *adapter
+ * @param addr
+ * @param size
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_log_efuse_bt(struct mac_ax_adapter *adapter, u32 addr, u32 size,
+			  u8 *val);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_write_log_efuse_bt
+ *
+ * @param *adapter
+ * @param addr
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_log_efuse_bt(struct mac_ax_adapter *adapter, u32 addr, u8 val);
+
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_pg_efuse_by_map_plus
+ *
+ * @param *adapter
+ * @param *info
+ * @param cfg
+ * @param part
+ * @param is_limit
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_pg_efuse_by_map_plus(struct mac_ax_adapter *adapter,
+			     struct mac_ax_pg_efuse_info *info,
+			     enum mac_ax_efuse_read_cfg cfg,
+			     bool part, bool is_limit);
+
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_pg_efuse_by_map
+ *
+ * @param *adapter
+ * @param *info
+ * @param cfg
+ * @param part
+ * @param is_limit
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_pg_efuse_by_map(struct mac_ax_adapter *adapter,
+			struct mac_ax_pg_efuse_info *info,
+			enum mac_ax_efuse_read_cfg cfg, bool part,
+			bool is_limit);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_pg_efuse_by_map_bt
+ *
+ * @param *adapter
+ * @param *info
+ * @param cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_pg_efuse_by_map_bt(struct mac_ax_adapter *adapter,
+			   struct mac_ax_pg_efuse_info *info,
+			   enum mac_ax_efuse_read_cfg cfg);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_mask_log_efuse
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_mask_log_efuse(struct mac_ax_adapter *adapter,
+		       struct mac_ax_pg_efuse_info *info);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_pg_sec_data_by_map
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_pg_sec_data_by_map(struct mac_ax_adapter *adapter,
+			   struct mac_ax_pg_efuse_info *info);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_cmp_sec_data_by_map
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cmp_sec_data_by_map(struct mac_ax_adapter *adapter,
+			    struct mac_ax_pg_efuse_info *info);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_get_efuse_info
+ *
+ * @param *adapter
+ * @param *efuse_map
+ * @param id
+ * @param *value
+ * @param length
+ * @param *autoload_status
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_efuse_info(struct mac_ax_adapter *adapter, u8 *efuse_map,
+		       enum rtw_efuse_info id, void *value, u32 length,
+		       u8 *autoload_status);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_set_efuse_info
+ *
+ * @param *adapter
+ * @param *efuse_map
+ * @param id
+ * @param *value
+ * @param length
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_efuse_info(struct mac_ax_adapter *adapter, u8 *efuse_map,
+		       enum rtw_efuse_info id, void *value, u32 length);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_read_hidden_rpt
+ *
+ * @param *adapter
+ * @param *rpt
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_hidden_rpt(struct mac_ax_adapter *adapter,
+			struct mac_defeature_value *rpt);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_check_efuse_autoload
+ *
+ * @param *adapter
+ * @param *autoload_status
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_efuse_autoload(struct mac_ax_adapter *adapter,
+			     u8 *autoload_status);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_pg_simulator_plus
+ *
+ * @param *adapter
+ * @param *info
+ * @param *phy_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_pg_simulator_plus(struct mac_ax_adapter *adapter,
+			  struct mac_ax_pg_efuse_info *info, u8 *phy_map);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_pg_simulator
+ *
+ * @param *adapter
+ * @param *info
+ * @param *phy_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_pg_simulator(struct mac_ax_adapter *adapter,
+		     struct mac_ax_pg_efuse_info *info, u8 *phy_map);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_checksum_update
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_checksum_update(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_checksum_rpt
+ *
+ * @param *adapter
+ * @param *chksum
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_checksum_rpt(struct mac_ax_adapter *adapter, u16 *chksum);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_disable_rf_ofld_by_info
+ *
+ * @param *adapter
+ * @param info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_disable_rf_ofld_by_info(struct mac_ax_adapter *adapter,
+				struct mac_disable_rf_ofld_info info);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief _patch_otp_power_issue
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 _patch_otp_power_issue(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_set_efuse_ctrl
+ *
+ * @param *adapter
+ * @param is_secure
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_efuse_ctrl(struct mac_ax_adapter *adapter, bool is_secure);
+/**
+ * @}
+ */
+
+u32 get_fv_info(struct mac_ax_adapter *adapter);
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief mac_otp_test
+ *
+ * @param *adapter
+ * @param is_OTP_test
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_otp_test(struct mac_ax_adapter *adapter, bool is_OTP_test);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief cfg_efuse_auto_ck
+ *
+ * @param *adapter
+ * @param enable
+ * @return Please Place Description here.
+ * @retval void
+ */
+void cfg_efuse_auto_ck(struct mac_ax_adapter *adapter, u8 enable);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief efuse_info_init
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 efuse_info_init(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief efuse_info_exit
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 efuse_info_exit(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief enable_efuse_pwr_cut_dav
+ *
+ * @param *adapter
+ * @param is_write
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 enable_efuse_pwr_cut_dav(struct mac_ax_adapter *adapter,
+			     bool is_write);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief enable_efuse_pwr_cut_dav
+ *
+ * @param *adapter
+ * @param is_write
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 disable_efuse_pwr_cut_dav(struct mac_ax_adapter *adapter,
+			      bool is_write);
+/**
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/flash.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/flash.c
new file mode 100644
index 000000000000..1eb0f49adf43
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/flash.c
@@ -0,0 +1,944 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "flash.h"
+#include "../mac_ax/fwcmd.h"
+
+#if MAC_AX_FW_REG_OFLD
+u32 mac_flash_erase(struct mac_ax_adapter *adapter,
+		    u32 addr,
+		    u32 length,
+		    u32 timeout)
+{
+	u8 *buf;
+	u32 ret = 0, pkt_len, local_timeout = 10000, no_timeout = 0;
+	u32 data[2];
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	if (timeout == 0)
+		no_timeout = 1;
+	else
+		local_timeout = timeout;
+
+	PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+	adapter->flash_info.erase_done = 0;
+	adapter->flash_info.erasing = 1;
+	adapter->flash_info.erase_addr = addr;
+	PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.erasing = 0;
+		adapter->flash_info.erase_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		return MACNPTR; // Maybe set a timeout counter
+	}
+	pkt_len = LEN_FLASH_H2C_HDR;
+	buf = h2cb_put(h2cb, pkt_len);
+	if (!buf) {
+		ret = MACNOBUF;
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.erasing = 0;
+		adapter->flash_info.erase_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+	data[0] = cpu_to_le32(addr);
+	data[1] = cpu_to_le32(length);
+	PLTFM_MEMCPY(buf, (u8 *)data, pkt_len);
+	ret = h2c_pkt_set_hdr_fwdl(adapter, h2cb,
+				   FWCMD_TYPE_H2C,
+				   FWCMD_H2C_CAT_MAC,
+				   FWCMD_H2C_CL_FLASH,
+				   FWCMD_H2C_FUNC_PLAT_FLASH_ERASE,/*platform auto test*/
+				   0,
+				   0);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.erasing = 0;
+		adapter->flash_info.erase_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.erasing = 0;
+		adapter->flash_info.erase_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %x\n", ret);
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.erasing = 0;
+		adapter->flash_info.erase_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+	h2cb_free(adapter, h2cb);
+	h2cb = NULL;
+	while (1) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		if (adapter->flash_info.erase_done == 1) {
+			adapter->flash_info.erase_done = 0;
+			adapter->flash_info.erasing = 0;
+			adapter->flash_info.erase_addr = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			break;
+		}
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+
+		//Sleep(50);
+		PLTFM_DELAY_MS(1);
+		if (no_timeout == 0) {
+			local_timeout--;
+			if (local_timeout == 0) {
+				ret = MACFLASHFAIL;
+				PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+				adapter->flash_info.erasing = 0;
+				adapter->flash_info.erase_addr = 0;
+				PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+				goto fail;
+			}
+		}
+	}
+	PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+	adapter->flash_info.erasing = 0;
+	adapter->flash_info.erase_addr = 0;
+	PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+	return MACSUCCESS;
+fail:
+	if (h2cb)
+		h2cb_free(adapter, h2cb);
+	adapter->fw_info.h2c_seq--;
+
+	return ret;
+}
+
+u32 mac_flash_read(struct mac_ax_adapter *adapter,
+		   u32 addr,
+		   u32 length,
+		   u8 *buffer,
+		   u32 timeout)
+{
+	u8 *buf;
+	u32 ret = 0, pkt_len, local_timeout = 10000, no_timeout = 0;
+	u32 data[2];
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	//PLTFM_MSG_TRACE("testdata = 0x%llx\n", (u64)buffer);
+	if (length > FLASH_H2C_SIZE)
+		return MACFLASHFAIL;
+
+	if (timeout == 0)
+		no_timeout = 1;
+	else
+		local_timeout = timeout;
+	if ((addr % 4) || (length % 4)) {
+		PLTFM_MSG_ERR("Address/length not 4 byte aligned, addr : 0x%x, length : 0x%x\n"
+			, addr, length);
+		return MACFLASHFAIL;
+	}
+	// mutex
+	PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+	adapter->flash_info.read_done = 0;
+	adapter->flash_info.reading = 1;
+	adapter->flash_info.buf_addr = buffer;
+	adapter->flash_info.read_addr = addr;
+	PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR; // Maybe set a timeout counter
+	pkt_len = LEN_FLASH_H2C_HDR;
+	buf = h2cb_put(h2cb, pkt_len);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+	data[0] = cpu_to_le32(addr);
+	data[1] = cpu_to_le32(length);
+	PLTFM_MEMCPY(buf, (u8 *)data, pkt_len);
+	ret = h2c_pkt_set_hdr_fwdl(adapter, h2cb,
+				   FWCMD_TYPE_H2C,
+				   FWCMD_H2C_CAT_MAC,
+				   FWCMD_H2C_CL_FLASH,
+				   FWCMD_H2C_FUNC_PLAT_FLASH_READ,/*platform auto test*/
+				   0,
+				   0);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.reading = 0;
+		adapter->flash_info.buf_addr = NULL;
+		adapter->flash_info.read_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.reading = 0;
+		adapter->flash_info.buf_addr = NULL;
+		adapter->flash_info.read_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %x\n", ret);
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.reading = 0;
+		adapter->flash_info.buf_addr = NULL;
+		adapter->flash_info.read_addr = 0;
+		adapter->flash_info.read_done = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+	h2cb_free(adapter, h2cb);
+	h2cb = NULL;
+	while (1) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		//PLTFM_MSG_TRACE("polling enter critical\n");
+		if (adapter->flash_info.read_done == 1) {
+			//PLTFM_MSG_TRACE("read DONE\n");
+			adapter->flash_info.reading = 0;
+			adapter->flash_info.buf_addr = NULL;
+			adapter->flash_info.read_addr = 0;
+			adapter->flash_info.read_done = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			break;
+		}
+		//PLTFM_MSG_TRACE("polling exit critical\n");
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		//Sleep(1);
+		PLTFM_DELAY_MS(1);
+		if (no_timeout == 0) {
+			local_timeout--;
+			if (local_timeout == 0) {
+				ret = MACFLASHFAIL;
+				PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+				adapter->flash_info.reading = 0;
+				adapter->flash_info.buf_addr = NULL;
+				adapter->flash_info.read_addr = 0;
+				adapter->flash_info.read_done = 0;
+				PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+				goto fail;
+			}
+		}
+	}
+	// end mutex
+	//adapter->flash_info.read_done == 0;
+	PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+	adapter->flash_info.reading = 0;
+	adapter->flash_info.buf_addr = NULL;
+	adapter->flash_info.read_addr = 0;
+	PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+	return MACSUCCESS;
+fail:
+	if (h2cb)
+		h2cb_free(adapter, h2cb);
+	adapter->fw_info.h2c_seq--;
+
+	return ret;
+}
+
+u32 mac_flash_write(struct mac_ax_adapter *adapter,
+		    u32 addr,
+		    u32 length,
+		    u8 *buffer,
+		    u32 timeout)
+{
+	u8 *buf;
+	u32 ret = 0, residue_len, pkt_len, local_timeout = 5000, no_timeout = 0, i;
+	u32 data[2];
+	u32 waddr, wlength;
+	u32 *pbuf;
+	u32 *psource_data;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	if (timeout == 0)
+		no_timeout = 1;
+	else
+		local_timeout = timeout;
+
+	residue_len = length;
+	waddr = addr;
+	wlength = length;
+	if ((addr % 4) || (length % 4)) {
+		PLTFM_MSG_ERR("Address/length not 4 byte aligned, addr : 0x%x, length : 0x%x\n"
+			, addr, length);
+		return MACFLASHFAIL;
+	}
+	while (residue_len) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.write_done = 0;
+		adapter->flash_info.writing = 1;
+		adapter->flash_info.write_addr = waddr;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		if (residue_len >= FLASH_H2C_SIZE)
+			pkt_len = FLASH_H2C_SIZE;
+		else
+			pkt_len = residue_len;
+
+		h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+		if (!h2cb) {
+			PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+			adapter->flash_info.writing = 0;
+			adapter->flash_info.write_addr = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			return MACNPTR; // Maybe set a timeout counter
+		}
+
+		buf = h2cb_put(h2cb, pkt_len + LEN_FLASH_H2C_HDR);
+		if (!buf) {
+			ret = MACNOBUF;
+			PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+			adapter->flash_info.writing = 0;
+			adapter->flash_info.write_addr = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			goto fail;
+		}
+		data[0] = cpu_to_le32(waddr);
+		data[1] = cpu_to_le32(pkt_len);
+		PLTFM_MEMCPY(buf, (u8 *)data, LEN_FLASH_H2C_HDR);
+		buf += LEN_FLASH_H2C_HDR;
+		//copy data
+		pbuf = (u32 *)buf;
+		psource_data = (u32 *)buffer;
+		for (i = 0; i < (pkt_len / sizeof(u32)); i++) {
+			*pbuf = cpu_to_le32(*psource_data);
+			pbuf++;
+			psource_data++;
+		}
+		//PLTFM_MEMCPY(buf, buffer, pkt_len);
+		ret = h2c_pkt_set_hdr_fwdl(adapter, h2cb,
+					   FWCMD_TYPE_H2C,
+					   FWCMD_H2C_CAT_MAC,
+					   FWCMD_H2C_CL_FLASH,
+					   FWCMD_H2C_FUNC_PLAT_FLASH_WRITE,/*platform auto test*/
+					   0,
+					   0);
+		if (ret) {
+			PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+			adapter->flash_info.writing = 0;
+			adapter->flash_info.write_addr = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			goto fail;
+		}
+		ret = h2c_pkt_build_txd(adapter, h2cb);
+		if (ret) {
+			PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+			adapter->flash_info.writing = 0;
+			adapter->flash_info.write_addr = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			goto fail;
+		}
+#if MAC_AX_PHL_H2C
+		ret = PLTFM_TX(h2cb);
+#else
+		ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]platform tx: %x\n", ret);
+			PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+			adapter->flash_info.writing = 0;
+			adapter->flash_info.write_addr = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			goto fail;
+		}
+		h2cb_free(adapter, h2cb);
+		h2cb = NULL;
+		PLTFM_MSG_ERR("Write H2C, addr = 0x%x, length = %d\n", waddr, pkt_len);
+
+		// delay for flash write
+		//Sleep(1000);
+		while (1) {
+			PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+			if (adapter->flash_info.write_done == 1) {
+				adapter->flash_info.writing = 0;
+				adapter->flash_info.write_addr = 0;
+				adapter->flash_info.write_done = 0;
+				PLTFM_MSG_TRACE("write DONE\n");
+				PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+				break;
+			}
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			//Sleep(1);
+			PLTFM_DELAY_MS(1);
+			if (no_timeout == 0) {
+				local_timeout--;
+				if (local_timeout == 0) {
+					ret = MACFLASHFAIL;
+					PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+					adapter->flash_info.writing = 0;
+					adapter->flash_info.write_addr = 0;
+					PLTFM_MSG_TRACE("write timeout\n");
+					PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+					goto fail;
+				}
+			}
+		}
+		residue_len -= pkt_len;
+		buffer += pkt_len;
+		waddr += pkt_len;
+	}
+	PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+	adapter->flash_info.writing = 0;
+	adapter->flash_info.write_addr = 0;
+	PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+	return MACSUCCESS;
+fail:
+	if (h2cb)
+		h2cb_free(adapter, h2cb);
+	adapter->fw_info.h2c_seq--;
+
+	return ret;
+}
+
+#else
+u32 mac_flash_erase(struct mac_ax_adapter *adapter,
+		    u32 addr,
+		    u32 length,
+		    u32 timeout)
+{
+	u8 *buf;
+	u32 ret = 0, pkt_len, local_timeout = 10000, no_timeout = 0;
+	u32 data[2];
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	if (timeout == 0)
+		no_timeout = 1;
+	else
+		local_timeout = timeout;
+
+	PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+	adapter->flash_info.erase_done = 0;
+	adapter->flash_info.erasing = 1;
+	adapter->flash_info.erase_addr = addr;
+	PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.erasing = 0;
+		adapter->flash_info.erase_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		return MACNPTR; // Maybe set a timeout counter
+	}
+	pkt_len = LEN_FLASH_H2C_HDR;
+	buf = h2cb_put(h2cb, pkt_len);
+	if (!buf) {
+		ret = MACNOBUF;
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.erasing = 0;
+		adapter->flash_info.erase_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+	data[0] = cpu_to_le32(addr);
+	data[1] = cpu_to_le32(length);
+	PLTFM_MEMCPY(buf, (u8 *)data, pkt_len);
+	ret = h2c_pkt_set_hdr_fwdl(adapter, h2cb,
+				   FWCMD_TYPE_H2C,
+				   FWCMD_H2C_CAT_MAC,
+				   FWCMD_H2C_CL_FLASH,
+				   FWCMD_H2C_FUNC_PLAT_FLASH_ERASE,/*platform auto test*/
+				   0,
+				   0);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.erasing = 0;
+		adapter->flash_info.erase_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.erasing = 0;
+		adapter->flash_info.erase_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %x\n", ret);
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.erasing = 0;
+		adapter->flash_info.erase_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+	h2cb_free(adapter, h2cb);
+	h2cb = NULL;
+	while (1) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		if (adapter->flash_info.erase_done == 1) {
+			adapter->flash_info.erase_done = 0;
+			adapter->flash_info.erasing = 0;
+			adapter->flash_info.erase_addr = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			break;
+		}
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+
+		//Sleep(50);
+		PLTFM_DELAY_MS(1);
+		if (no_timeout == 0) {
+			local_timeout--;
+			if (local_timeout == 0) {
+				ret = MACFLASHFAIL;
+				PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+				adapter->flash_info.erasing = 0;
+				adapter->flash_info.erase_addr = 0;
+				PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+				goto fail;
+			}
+		}
+	}
+	PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+	adapter->flash_info.erasing = 0;
+	adapter->flash_info.erase_addr = 0;
+	PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+	return MACSUCCESS;
+fail:
+	if (h2cb)
+		h2cb_free(adapter, h2cb);
+	adapter->fw_info.h2c_seq--;
+
+	return ret;
+}
+
+u32 mac_flash_read(struct mac_ax_adapter *adapter,
+		   u32 addr,
+		   u32 length,
+		   u8 *buffer,
+		   u32 timeout)
+{
+	u8 *buf;
+	u32 ret = 0, pkt_len, local_timeout = 10000, no_timeout = 0;
+	u32 data[2];
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	//PLTFM_MSG_TRACE("testdata = 0x%llx\n", (u64)buffer);
+	if (length > FLASH_H2C_SIZE)
+		return MACFLASHFAIL;
+
+	if (timeout == 0)
+		no_timeout = 1;
+	else
+		local_timeout = timeout;
+	if ((addr % 4) || (length % 4)) {
+		PLTFM_MSG_ERR("Address/length not 4 byte aligned, addr : 0x%x, length : 0x%x\n"
+			, addr, length);
+		return MACFLASHFAIL;
+	}
+	// mutex
+	PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+	adapter->flash_info.read_done = 0;
+	adapter->flash_info.reading = 1;
+	adapter->flash_info.buf_addr = buffer;
+	adapter->flash_info.read_addr = addr;
+	PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR; // Maybe set a timeout counter
+	pkt_len = LEN_FLASH_H2C_HDR;
+	buf = h2cb_put(h2cb, pkt_len);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+	data[0] = cpu_to_le32(addr);
+	data[1] = cpu_to_le32(length);
+	PLTFM_MEMCPY(buf, (u8 *)data, pkt_len);
+	ret = h2c_pkt_set_hdr_fwdl(adapter, h2cb,
+				   FWCMD_TYPE_H2C,
+				   FWCMD_H2C_CAT_MAC,
+				   FWCMD_H2C_CL_FLASH,
+				   FWCMD_H2C_FUNC_PLAT_FLASH_READ,/*platform auto test*/
+				   0,
+				   0);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.reading = 0;
+		adapter->flash_info.buf_addr = NULL;
+		adapter->flash_info.read_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.reading = 0;
+		adapter->flash_info.buf_addr = NULL;
+		adapter->flash_info.read_addr = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %x\n", ret);
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.reading = 0;
+		adapter->flash_info.buf_addr = NULL;
+		adapter->flash_info.read_addr = 0;
+		adapter->flash_info.read_done = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		goto fail;
+	}
+	h2cb_free(adapter, h2cb);
+	h2cb = NULL;
+	while (1) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		//PLTFM_MSG_TRACE("polling enter critical\n");
+		if (adapter->flash_info.read_done == 1) {
+			//PLTFM_MSG_TRACE("read DONE\n");
+			adapter->flash_info.reading = 0;
+			adapter->flash_info.buf_addr = NULL;
+			adapter->flash_info.read_addr = 0;
+			adapter->flash_info.read_done = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			break;
+		}
+		//PLTFM_MSG_TRACE("polling exit critical\n");
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		//Sleep(1);
+		PLTFM_DELAY_MS(1);
+		if (no_timeout == 0) {
+			local_timeout--;
+			if (local_timeout == 0) {
+				ret = MACFLASHFAIL;
+				PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+				adapter->flash_info.reading = 0;
+				adapter->flash_info.buf_addr = NULL;
+				adapter->flash_info.read_addr = 0;
+				adapter->flash_info.read_done = 0;
+				PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+				goto fail;
+			}
+		}
+	}
+	// end mutex
+	//adapter->flash_info.read_done == 0;
+	PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+	adapter->flash_info.reading = 0;
+	adapter->flash_info.buf_addr = NULL;
+	adapter->flash_info.read_addr = 0;
+	PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+	return MACSUCCESS;
+fail:
+	if (h2cb)
+		h2cb_free(adapter, h2cb);
+	adapter->fw_info.h2c_seq--;
+
+	return ret;
+}
+
+u32 mac_flash_write(struct mac_ax_adapter *adapter,
+		    u32 addr,
+		    u32 length,
+		    u8 *buffer,
+		    u32 timeout)
+{
+	u8 *buf;
+	u32 ret = 0, residue_len, pkt_len, local_timeout = 5000, no_timeout = 0, i;
+	u32 data[2];
+	u32 waddr, wlength;
+	u32 *pbuf;
+	u32 *psource_data;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	if (timeout == 0)
+		no_timeout = 1;
+	else
+		local_timeout = timeout;
+
+	residue_len = length;
+	waddr = addr;
+	wlength = length;
+	if ((addr % 4) || (length % 4)) {
+		PLTFM_MSG_ERR("Address/length not 4 byte aligned, addr : 0x%x, length : 0x%x\n"
+			, addr, length);
+		return MACFLASHFAIL;
+	}
+	while (residue_len) {
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		adapter->flash_info.write_done = 0;
+		adapter->flash_info.writing = 1;
+		adapter->flash_info.write_addr = waddr;
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		if (residue_len >= FLASH_H2C_SIZE)
+			pkt_len = FLASH_H2C_SIZE;
+		else
+			pkt_len = residue_len;
+
+		h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+		if (!h2cb) {
+			PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+			adapter->flash_info.writing = 0;
+			adapter->flash_info.write_addr = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			return MACNPTR; // Maybe set a timeout counter
+		}
+
+		buf = h2cb_put(h2cb, pkt_len + LEN_FLASH_H2C_HDR);
+		if (!buf) {
+			ret = MACNOBUF;
+			PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+			adapter->flash_info.writing = 0;
+			adapter->flash_info.write_addr = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			goto fail;
+		}
+		data[0] = cpu_to_le32(waddr);
+		data[1] = cpu_to_le32(pkt_len);
+		PLTFM_MEMCPY(buf, (u8 *)data, LEN_FLASH_H2C_HDR);
+		buf += LEN_FLASH_H2C_HDR;
+		//copy data
+		pbuf = (u32 *)buf;
+		psource_data = (u32 *)buffer;
+		for (i = 0; i < (pkt_len / sizeof(u32)); i++) {
+			*pbuf = cpu_to_le32(*psource_data);
+			pbuf++;
+			psource_data++;
+		}
+		//PLTFM_MEMCPY(buf, buffer, pkt_len);
+		ret = h2c_pkt_set_hdr_fwdl(adapter, h2cb,
+					   FWCMD_TYPE_H2C,
+					   FWCMD_H2C_CAT_MAC,
+					   FWCMD_H2C_CL_FLASH,
+					   FWCMD_H2C_FUNC_PLAT_FLASH_WRITE,/*platform auto test*/
+					   0,
+					   0);
+		if (ret) {
+			PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+			adapter->flash_info.writing = 0;
+			adapter->flash_info.write_addr = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			goto fail;
+		}
+		ret = h2c_pkt_build_txd(adapter, h2cb);
+		if (ret) {
+			PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+			adapter->flash_info.writing = 0;
+			adapter->flash_info.write_addr = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			goto fail;
+		}
+#if MAC_AX_PHL_H2C
+		ret = PLTFM_TX(h2cb);
+#else
+		ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]platform tx: %x\n", ret);
+			PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+			adapter->flash_info.writing = 0;
+			adapter->flash_info.write_addr = 0;
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			goto fail;
+		}
+		h2cb_free(adapter, h2cb);
+		h2cb = NULL;
+		PLTFM_MSG_ERR("Write H2C, addr = 0x%x, length = %d\n", waddr, pkt_len);
+
+		// delay for flash write
+		//Sleep(1000);
+		while (1) {
+			PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+			if (adapter->flash_info.write_done == 1) {
+				adapter->flash_info.writing = 0;
+				adapter->flash_info.write_addr = 0;
+				adapter->flash_info.write_done = 0;
+				PLTFM_MSG_TRACE("write DONE\n");
+				PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+				break;
+			}
+			PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+			//Sleep(1);
+			PLTFM_DELAY_MS(1);
+			if (no_timeout == 0) {
+				local_timeout--;
+				if (local_timeout == 0) {
+					ret = MACFLASHFAIL;
+					PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+					adapter->flash_info.writing = 0;
+					adapter->flash_info.write_addr = 0;
+					PLTFM_MSG_TRACE("write timeout\n");
+					PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+					goto fail;
+				}
+			}
+		}
+		residue_len -= pkt_len;
+		buffer += pkt_len;
+		waddr += pkt_len;
+	}
+	PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+	adapter->flash_info.writing = 0;
+	adapter->flash_info.write_addr = 0;
+	PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+	return MACSUCCESS;
+fail:
+	if (h2cb)
+		h2cb_free(adapter, h2cb);
+	adapter->fw_info.h2c_seq--;
+
+	return ret;
+}
+#endif
+
+u32 c2h_sys_flash_pkt(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		      struct rtw_c2h_info *info)
+{
+	u32 hdr0, i;
+	u32 func, length, addr;
+	u32 *pbuf;
+	u32 *psource_data;
+
+	PLTFM_MSG_TRACE("%s\n", __func__);
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	//set info
+	info->c2h_cat = GET_FIELD(hdr0, C2H_HDR_CAT);
+	info->c2h_class = GET_FIELD(hdr0, C2H_HDR_CLASS);
+	info->c2h_func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+	//info->done_ack = 0;
+	//info->rec_ack = 0;
+	info->content = buf  + FWCMD_HDR_LEN;
+	//info->h2c_return = info->c2h_data[1];
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	if (func == FWCMD_H2C_FUNC_PLAT_FLASH_READ) {
+		addr = *((u32 *)info->content);
+		addr = le32_to_cpu(addr);
+		length = *((u32 *)(info->content + LEN_FLASH_C2H_HDR_ADDR));
+		length = le32_to_cpu(length);
+		PLTFM_MSG_TRACE("addr = 0x%x, length = 0x%x\n", addr, length);
+		PLTFM_MSG_TRACE("adapter->flash_info.read_addr = 0x%x\n",
+				adapter->flash_info.read_addr);
+		//PLTFM_MSG_TRACE("adapter->flash_info.buf_addr = 0x%llx\n",
+				//(u64)adapter->flash_info.buf_addr);
+
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		if (addr == adapter->flash_info.read_addr && adapter->flash_info.reading == 1) {
+			// lost data if timeout happened
+			//PLTFM_MSG_TRACE("ready to read\n");
+			if (adapter->flash_info.buf_addr && length <= MAX_READ_SIZE) {
+				PLTFM_MSG_TRACE("memcpy to buf\n");
+				//PLTFM_MEMCPY(adapter->flash_info.buf_addr,
+				//	     info->content + LEN_FLASH_C2H_HDR, length);
+				pbuf = (u32 *)adapter->flash_info.buf_addr;
+				psource_data = (u32 *)(info->content + LEN_FLASH_C2H_HDR);
+				for (i = 0; i < length / sizeof(u32); i++) {
+					*pbuf = le32_to_cpu(*psource_data);
+					pbuf++;
+					psource_data++;
+				}
+				//PLTFM_MSG_TRACE("memcpy to buf end\n");
+			}
+		}
+		//PLTFM_MSG_TRACE("set reading = 0\n");
+		adapter->flash_info.reading = 0;
+		adapter->flash_info.read_done = 1;
+		//PLTFM_MSG_TRACE("set reading = 0 end\n");
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+		//PLTFM_MSG_TRACE("exit critical\n");
+	} else if (func == FWCMD_H2C_FUNC_PLAT_FLASH_WRITE) {
+		addr = *((u32 *)info->content);
+		addr = le32_to_cpu(addr);
+		length = *((u32 *)(info->content + LEN_FLASH_C2H_HDR_ADDR));
+		length = le32_to_cpu(length);
+		PLTFM_MSG_TRACE("write addr = 0x%x\n", *((u32 *)info->content));
+		PLTFM_MSG_TRACE("adapter->flash_info.write_addr = 0x%x\n",
+				adapter->flash_info.write_addr);
+		PLTFM_MSG_TRACE("write length = 0x%x\n", length);
+
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		if (addr == adapter->flash_info.write_addr && adapter->flash_info.writing == 1) {
+			adapter->flash_info.writing = 0;
+			adapter->flash_info.write_done = 1;
+		}
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+	} else if (func == FWCMD_H2C_FUNC_PLAT_FLASH_ERASE) {
+		addr = *((u32 *)info->content);
+		addr = le32_to_cpu(addr);
+		length = *((u32 *)(info->content + LEN_FLASH_C2H_HDR_ADDR));
+		length = le32_to_cpu(length);
+		PLTFM_MSG_TRACE("erase addr = 0x%x\n", *((u32 *)info->content));
+		PLTFM_MSG_TRACE("adapter->flash_info.erase_addr = 0x%x\n",
+				adapter->flash_info.erase_addr);
+		PLTFM_MSG_TRACE("erase length = 0x%x\n", length);
+
+		PLTFM_MUTEX_LOCK(&adapter->flash_info.lock);
+		if (addr == adapter->flash_info.erase_addr && adapter->flash_info.erasing == 1) {
+			adapter->flash_info.erasing = 0;
+			adapter->flash_info.erase_done = 1;
+		}
+		PLTFM_MUTEX_UNLOCK(&adapter->flash_info.lock);
+	}
+
+	return MACSUCCESS;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/flash.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/flash.h
new file mode 100644
index 000000000000..a94c0e2bc910
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/flash.h
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_FLASH_H_
+#define _MAC_AX_FLASH_H_
+
+#include "../type.h"
+#include "../mac_def.h"
+#include "../mac_ax.h"
+#include "fwcmd.h"
+#include "trx_desc.h"
+#include "trxcfg.h"
+#include "dle.h"
+
+#define MAX_LENGTH_ENUM 7
+#define FLASH_H2C_SIZE 1984
+#define LEN_FLASH_C2H_HDR_ADDR 4
+#define LEN_FLASH_C2H_HDR_LENGTH 4
+#define LEN_FLASH_H2C_HDR 8
+#define LEN_FLASH_C2H_HDR 8
+#define MAX_READ_SIZE 1984
+
+u32 mac_flash_erase(struct mac_ax_adapter *adapter,
+		    u32 addr,
+		    u32 length,
+		    u32 timeout);
+u32 mac_flash_read(struct mac_ax_adapter *adapter,
+		   u32 addr,
+		   u32 length,
+		   u8 *buffer,
+		   u32 timeout);
+u32 mac_flash_write(struct mac_ax_adapter *adapter,
+		    u32 addr,
+		    u32 length,
+		    u8 *buffer,
+		    u32 timeout);
+u32 c2h_sys_flash_pkt(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		      struct rtw_c2h_info *info);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd.c
new file mode 100644
index 000000000000..ce64181507c7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd.c
@@ -0,0 +1,3809 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "fwcmd.h"
+#include "mcc.h"
+#include "mac_priv.h"
+#include "twt.h"
+
+#if MAC_AX_FEATURE_HV
+#include "../hv_ax/dbgpkg_hv.h"
+#endif
+
+/* 8852A/8852B: the format of H2C/DLFW descriptor: WD Body
+ * 8852C: the format of H2C/DLFW descriptor: RX Descriptor
+ * WD body max len: 24 bytes
+ * RX descriptor max len: 32 bytes
+ * We use the max RX descriptor size as the header size
+ * WD_BODY_LEN_V1 = RX descriptor max len = 32 bytes
+ */
+
+#define H2CB_CMD_HDR_SIZE	(FWCMD_HDR_LEN + WD_BODY_LEN_V1)
+#define H2CB_CMD_SIZE		(H2C_CMD_LEN - FWCMD_HDR_LEN)
+#define H2CB_CMD_QLEN		8
+
+#define H2CB_DATA_HDR_SIZE	(FWCMD_HDR_LEN + WD_BODY_LEN_V1)
+#define H2CB_DATA_SIZE		(H2C_DATA_LEN - FWCMD_HDR_LEN)
+#define H2CB_DATA_QLEN		4
+
+#define H2CB_LONG_DATA_HDR_SIZE	(FWCMD_HDR_LEN + WD_BODY_LEN)
+#define H2CB_LONG_DATA_SIZE	(H2C_LONG_DATA_LEN - FWCMD_HDR_LEN)
+#define H2CB_LONG_DATA_QLEN	1
+
+#define FWCMD_WQ_MAX_JOB_NUM	5
+
+#define FWCMD_LMT		12
+
+#define MAC_AX_H2C_LMT_EN	0
+
+#define FWCMD_H2CREG_BYTE0_SH 0
+#define FWCMD_H2CREG_BYTE0_MSK 0xFF
+#define FWCMD_H2CREG_BYTE1_SH 8
+#define FWCMD_H2CREG_BYTE1_MSK 0xFF
+#define FWCMD_H2CREG_BYTE2_SH 16
+#define FWCMD_H2CREG_BYTE2_MSK 0xFF
+#define FWCMD_H2CREG_BYTE3_SH 24
+#define FWCMD_H2CREG_BYTE3_MSK 0xFF
+
+#define BCN_GRPIE_OFST_EN BIT(7)
+
+#define SCANOFLD_RSP_EVT_ID 1
+#define SCANOFLD_RSP_EVT_PARSE 1
+#define SCANOFLD_ACK_BAND_SHIFT 6
+#define SCANOFLD_ACK_RETURN_MASK 0x3F
+
+static struct h2c_buf_head h2cb_head[H2CB_CLASS_MAX];
+static struct fwcmd_wkb_head fwcmd_wq_head;
+
+struct fwcmd_outsrc_info {
+#define MAX_OUTSRC_LEN 60 //need to extend if needed
+	u32 dword0[MAX_OUTSRC_LEN];
+};
+
+struct c2h_event_id_proc {
+	u8 cat;
+	u8 cls;
+	u8 func;
+	u32 (*hdl)(struct mac_ax_adapter *adapter, struct rtw_c2h_info *c2h,
+		   enum phl_msg_evt_id *id, u8 *c2h_info);
+};
+
+static inline u32 h2cb_queue_len(struct h2c_buf_head *list)
+{
+	return list->qlen;
+}
+
+static inline void __h2cb_queue_head_init(struct h2c_buf_head *list)
+{
+	list->prev = (struct h2c_buf *)list;
+	list->next = (struct h2c_buf *)list;
+	list->qlen = 0;
+	list->suspend = 0;
+}
+
+static inline void h2cb_queue_head_init(struct mac_ax_adapter *adapter,
+					struct h2c_buf_head *list)
+{
+	PLTFM_MUTEX_INIT(&list->lock);
+	__h2cb_queue_head_init(list);
+}
+
+static inline void __h2cb_insert(struct h2c_buf *new_h2cb, struct h2c_buf *prev,
+				 struct h2c_buf *next,
+				 struct h2c_buf_head *list)
+{
+	new_h2cb->next = next;
+	new_h2cb->prev = prev;
+	next->prev  = new_h2cb;
+	prev->next = new_h2cb;
+	list->qlen++;
+}
+
+static inline void __h2cb_queue_before(struct h2c_buf_head *list,
+				       struct h2c_buf *next,
+				       struct h2c_buf *new_h2cb)
+{
+	__h2cb_insert(new_h2cb, next->prev, next, list);
+}
+
+static inline void __h2cb_queue_tail(struct h2c_buf_head *list,
+				     struct h2c_buf *new_h2cb)
+{
+	__h2cb_queue_before(list, (struct h2c_buf *)list, new_h2cb);
+}
+
+static inline void __h2cb_unlink(struct h2c_buf *h2cb,
+				 struct h2c_buf_head *list)
+{
+	struct h2c_buf *next, *prev;
+
+	list->qlen--;
+	next = h2cb->next;
+	prev = h2cb->prev;
+	h2cb->prev = NULL;
+	h2cb->next = NULL;
+	next->prev = prev;
+	prev->next = next;
+}
+
+static inline struct h2c_buf *h2cb_peek(struct h2c_buf_head *list)
+{
+	struct h2c_buf *h2cb = list->next;
+
+	if (h2cb == (struct h2c_buf *)list)
+		h2cb = NULL;
+	return h2cb;
+}
+
+#if MAC_AX_PHL_H2C
+static inline u8 *h2cb_tail_pointer(const struct rtw_h2c_pkt *h2cb)
+{
+	return h2cb->vir_tail;
+}
+#else
+static inline u8 *h2cb_tail_pointer(const struct h2c_buf *h2cb)
+{
+	return h2cb->tail;
+}
+#endif
+
+static inline struct h2c_buf *h2cb_dequeue(struct h2c_buf_head *list)
+{
+	struct h2c_buf *h2cb = h2cb_peek(list);
+
+	if (h2cb)
+		__h2cb_unlink(h2cb, list);
+	return h2cb;
+}
+
+static u8 *__h2cb_alloc_buf_pool(struct mac_ax_adapter *adapter,
+				 struct h2c_buf_head *list, u32 size, int num)
+{
+	u32 block_size = (size * num);
+	u8 *ptr;
+
+	ptr = (u8 *)PLTFM_MALLOC(block_size);
+	list->pool = ptr;
+	list->size = block_size;
+
+	return ptr;
+}
+
+static struct h2c_buf *__h2cb_alloc(struct mac_ax_adapter *adapter,
+				    enum h2c_buf_class buf_class,
+				    u32 hdr_size, u8 *buf_ptr, int buf_size)
+{
+	struct h2c_buf *h2cb;
+
+	//_ASSERT_(!buf_ptr);
+
+	h2cb = (struct h2c_buf *)PLTFM_MALLOC(sizeof(struct h2c_buf));
+	if (!h2cb)
+		return NULL;
+	PLTFM_MEMSET(h2cb, 0, sizeof(struct h2c_buf));
+
+	h2cb->_class_ = buf_class;
+	h2cb->id = 0;
+	h2cb->master = 0;
+	h2cb->len = 0;
+	h2cb->head = buf_ptr;
+	h2cb->end = h2cb->head + buf_size;
+	h2cb->data = h2cb->head + hdr_size;
+	h2cb->tail = h2cb->data;
+	h2cb->hdr_len = hdr_size;
+	h2cb->flags |= H2CB_FLAGS_FREED;
+
+	return h2cb;
+}
+
+static u32 __h2cb_free(struct mac_ax_adapter *adapter,
+		       enum h2c_buf_class buf_class)
+{
+	struct h2c_buf_head *list_head = &h2cb_head[buf_class];
+	struct h2c_buf *h2cb;
+
+	if (buf_class >= H2CB_CLASS_LAST)
+		return MACNOITEM;
+
+	if (!list_head->pool)
+		return MACNPTR;
+
+	if (!h2cb_queue_len(list_head))
+		return MACSUCCESS;
+
+	while ((h2cb = h2cb_dequeue(list_head)))
+		PLTFM_FREE(h2cb, sizeof(struct h2c_buf));
+
+	PLTFM_FREE(list_head->pool, list_head->size);
+	list_head->pool = NULL;
+	list_head->size = 0;
+	PLTFM_MUTEX_DEINIT(&list_head->lock);
+
+	return MACSUCCESS;
+}
+
+static u32 __h2cb_init(struct mac_ax_adapter *adapter,
+		       enum h2c_buf_class buf_class, u32 num, u32 buf_size,
+		       u32 hdr_size, u32 tailer_size)
+{
+	u32 i;
+	u8 *ptr;
+	struct h2c_buf_head *list_head = &h2cb_head[buf_class];
+	u32 real_size = buf_size + hdr_size + tailer_size;
+	struct h2c_buf *h2cb;
+
+	if (buf_class >= H2CB_CLASS_LAST)
+		return MACNOITEM;
+
+	if (h2cb_queue_len(list_head))
+		return MACBUFSZ;
+
+	h2cb_queue_head_init(adapter, list_head);
+
+	ptr = __h2cb_alloc_buf_pool(adapter, list_head, real_size, num);
+	if (!ptr)
+		return MACNPTR;
+
+	for (i = 0; i < num; i++) {
+		h2cb = __h2cb_alloc(adapter,
+				    buf_class, hdr_size, ptr, real_size);
+		if (!h2cb)
+			goto h2cb_fail;
+		__h2cb_queue_tail(list_head, h2cb);
+		ptr += real_size;
+	}
+
+	return MACSUCCESS;
+h2cb_fail:
+	__h2cb_free(adapter, buf_class);
+
+	return MACBUFALLOC;
+}
+
+static inline u32 fwcmd_wkb_queue_len(struct fwcmd_wkb_head *list)
+{
+	return list->qlen;
+};
+
+static inline void __fwcmd_wkb_queue_head_init(struct fwcmd_wkb_head *list)
+{
+	list->prev = (struct h2c_buf *)list;
+	list->next = (struct h2c_buf *)list;
+	list->qlen = 0;
+};
+
+static inline void fwcmd_wkb_queue_head_init(struct mac_ax_adapter *adapter,
+					     struct fwcmd_wkb_head *list)
+{
+	PLTFM_MUTEX_INIT(&list->lock);
+	__fwcmd_wkb_queue_head_init(list);
+}
+
+static u32 __fwcmd_wkb_init(struct mac_ax_adapter *adapter)
+{
+	struct fwcmd_wkb_head *list_head = &fwcmd_wq_head;
+
+	if (fwcmd_wkb_queue_len(list_head))
+		return MACBUFSZ;
+
+	fwcmd_wkb_queue_head_init(adapter, list_head);
+
+	return MACSUCCESS;
+}
+
+u32 h2cb_init(struct mac_ax_adapter *adapter)
+{
+	u32 ret;
+
+	ret = __h2cb_init(adapter, H2CB_CLASS_CMD, H2CB_CMD_QLEN,
+			  H2CB_CMD_SIZE, H2CB_CMD_HDR_SIZE, 0);
+	if (ret)
+		return ret;
+
+	ret = __h2cb_init(adapter, H2CB_CLASS_DATA, H2CB_DATA_QLEN,
+			  H2CB_DATA_SIZE, H2CB_DATA_HDR_SIZE, 0);
+	if (ret)
+		return ret;
+
+	ret = __h2cb_init(adapter, H2CB_CLASS_LONG_DATA, H2CB_LONG_DATA_QLEN,
+			  H2CB_LONG_DATA_SIZE, H2CB_LONG_DATA_HDR_SIZE, 0);
+	if (ret)
+		return ret;
+
+	ret = __fwcmd_wkb_init(adapter);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 h2cb_exit(struct mac_ax_adapter *adapter)
+{
+	struct fwcmd_wkb_head *list_head = &fwcmd_wq_head;
+
+	if (fwcmd_wkb_queue_len(list_head))
+		return MACBUFSZ;
+
+	__h2cb_free(adapter, H2CB_CLASS_CMD);
+	__h2cb_free(adapter, H2CB_CLASS_DATA);
+	__h2cb_free(adapter, H2CB_CLASS_LONG_DATA);
+
+	return MACSUCCESS;
+}
+
+u32 h2c_end_flow(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_fw_info *fwinfo = &adapter->fw_info;
+
+	PLTFM_MUTEX_LOCK(&fwinfo->seq_lock);
+	fwinfo->h2c_seq++;
+	PLTFM_MUTEX_UNLOCK(&fwinfo->seq_lock);
+
+	return MACSUCCESS;
+}
+
+#if MAC_AX_PHL_H2C
+u32 h2c_agg_enqueue(struct mac_ax_adapter *adapter, struct rtw_h2c_pkt *h2cb)
+#else
+u32 h2c_agg_enqueue(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb)
+#endif
+{
+	struct mac_ax_h2c_agg_node *h2c_agg_node = NULL;
+	u32 ret = MACSUCCESS;
+
+	PLTFM_MUTEX_LOCK(&adapter->h2c_agg_info.h2c_agg_lock);
+
+	if (!adapter->h2c_agg_info.h2c_agg_en) {
+		/* return fall and send the H2C pkt by the orginal function*/
+		ret = MACNOITEM;
+		goto fail;
+	}
+
+	h2c_agg_node = (struct mac_ax_h2c_agg_node *)
+				   PLTFM_MALLOC(sizeof(struct mac_ax_h2c_agg_node));
+	if (!h2c_agg_node) {
+		/* return fall and send the H2C pkt by the orginal function*/
+		ret = MACBUFALLOC;
+		goto fail;
+	}
+
+	PLTFM_MEMSET(h2c_agg_node, 0, sizeof(struct mac_ax_h2c_agg_node));
+	h2c_agg_node->h2c_pkt = (u8 *)h2cb;
+	h2c_agg_node->next = NULL;
+	adapter->h2c_agg_info.h2c_agg_pkt_num++;
+
+	if (!adapter->h2c_agg_info.h2c_agg_queue_head) {
+		adapter->h2c_agg_info.h2c_agg_queue_head = h2c_agg_node;
+		adapter->h2c_agg_info.h2c_agg_queue_last = h2c_agg_node;
+	} else {
+		adapter->h2c_agg_info.h2c_agg_queue_last->next = h2c_agg_node;
+		adapter->h2c_agg_info.h2c_agg_queue_last = h2c_agg_node;
+	}
+
+fail:
+	PLTFM_MUTEX_UNLOCK(&adapter->h2c_agg_info.h2c_agg_lock);
+	return ret;
+}
+
+#if MAC_AX_PHL_H2C
+struct rtw_h2c_pkt *h2cb_alloc(struct mac_ax_adapter *adapter,
+			       enum rtw_h2c_pkt_type buf_class)
+{
+	struct rtw_h2c_pkt *h2cb;
+#if MAC_AX_H2C_LMT_EN
+	struct mac_ax_fw_info *fwinfo = &adapter->fw_info;
+	u8 diff;
+	u8 cnt = 100;
+#endif
+
+	if (buf_class >= H2CB_TYPE_MAX) {
+		PLTFM_MSG_ERR("[ERR]unknown class\n");
+		return NULL;
+	}
+
+#if MAC_AX_H2C_LMT_EN
+	while (--cnt) {
+		if (fwinfo->h2c_seq >= fwinfo->rec_seq)
+			diff = fwinfo->h2c_seq - fwinfo->rec_seq;
+		else
+			diff = (255 - fwinfo->rec_seq) + fwinfo->h2c_seq;
+
+		if (diff < FWCMD_LMT)
+			break;
+		PLTFM_DELAY_US(100);
+	}
+
+	if (diff >= FWCMD_LMT) {
+		PLTFM_MSG_ERR("The number of H2C has reached the limitation\n");
+		PLTFM_MSG_ERR("curr: %d, rec: %d\n",
+			      fwinfo->h2c_seq, fwinfo->rec_seq);
+		return NULL;
+	}
+#endif
+
+	h2cb = PLTFM_QUERY_H2C(buf_class);
+
+	return h2cb;
+}
+
+void h2cb_free(struct mac_ax_adapter *adapter, struct rtw_h2c_pkt *h2cb)
+{
+}
+
+u8 *h2cb_push(struct rtw_h2c_pkt *h2cb, u32 len)
+{
+	h2cb->vir_data -= len;
+	h2cb->data_len  += len;
+
+	if (h2cb->vir_data < h2cb->vir_head)
+		return NULL;
+
+	return h2cb->vir_data;
+}
+
+u8 *h2cb_pull(struct rtw_h2c_pkt *h2cb, u32 len)
+{
+	h2cb->vir_data += len;
+
+	if (h2cb->vir_data > h2cb->vir_end)
+		return NULL;
+
+	if (h2cb->data_len < len)
+		return NULL;
+
+	h2cb->data_len -= len;
+
+	return h2cb->vir_data;
+}
+
+u8 *h2cb_put(struct rtw_h2c_pkt *h2cb, u32 len)
+{
+	u8 *tmp = h2cb_tail_pointer(h2cb);
+
+	h2cb->vir_tail += len;
+	h2cb->data_len += len;
+
+	if (h2cb->vir_tail > h2cb->vir_end)
+		return NULL;
+
+	return tmp;
+}
+
+u32 h2c_pkt_set_hdr(struct mac_ax_adapter *adapter, struct rtw_h2c_pkt *h2cb,
+		    u8 type, u8 cat, u8 _class_, u8 func, u16 rack, u16 dack)
+{
+	struct fwcmd_hdr *hdr;
+	struct mac_ax_fw_info *fwinfo = &adapter->fw_info;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACFWNONRDY;
+
+	if (adapter->sm.mac_rdy != MAC_AX_MAC_RDY) {
+		PLTFM_MSG_TRACE("%s: MAC is not ready\n", __func__);
+		adapter->stats.h2c_pkt_uninit++;
+	}
+
+	hdr = (struct fwcmd_hdr *)h2cb_push(h2cb, FWCMD_HDR_LEN);
+	if (!hdr)
+		return MACNPTR;
+
+	hdr->hdr0 = cpu_to_le32(SET_WORD(type, H2C_HDR_DEL_TYPE) |
+				SET_WORD(cat, H2C_HDR_CAT) |
+				SET_WORD(_class_, H2C_HDR_CLASS) |
+				SET_WORD(func, H2C_HDR_FUNC) |
+				SET_WORD(fwinfo->h2c_seq, H2C_HDR_H2C_SEQ));
+
+	hdr->hdr1 = cpu_to_le32(SET_WORD(h2cb->data_len, H2C_HDR_TOTAL_LEN) |
+				(rack ?	H2C_HDR_REC_ACK : 0) |
+				(dack ? H2C_HDR_DONE_ACK : 0));
+
+	h2cb->id = SET_FWCMD_ID(type, cat, _class_, func);
+	h2cb->h2c_seq = fwinfo->h2c_seq;
+
+	return MACSUCCESS;
+}
+
+u32 h2c_pkt_set_hdr_fwdl(struct mac_ax_adapter *adapter,
+			 struct rtw_h2c_pkt *h2cb, u8 type, u8 cat,
+			 u8 _class_, u8 func, u16 rack, u16 dack)
+{
+	struct fwcmd_hdr *hdr;
+	struct mac_ax_fw_info *fwinfo = &adapter->fw_info;
+
+	hdr = (struct fwcmd_hdr *)h2cb_push(h2cb, FWCMD_HDR_LEN);
+	if (!hdr)
+		return MACNPTR;
+
+	hdr->hdr0 = cpu_to_le32(SET_WORD(type, H2C_HDR_DEL_TYPE) |
+				SET_WORD(cat, H2C_HDR_CAT) |
+				SET_WORD(_class_, H2C_HDR_CLASS) |
+				SET_WORD(func, H2C_HDR_FUNC) |
+				SET_WORD(fwinfo->h2c_seq, H2C_HDR_H2C_SEQ));
+
+	hdr->hdr1 = cpu_to_le32(SET_WORD(h2cb->data_len, H2C_HDR_TOTAL_LEN) |
+				(rack ? H2C_HDR_REC_ACK : 0) |
+				(dack ? H2C_HDR_DONE_ACK : 0));
+
+	h2cb->id = SET_FWCMD_ID(type, cat, _class_, func);
+	h2cb->h2c_seq = fwinfo->h2c_seq;
+
+	return MACSUCCESS;
+}
+
+u32 h2c_pkt_set_cmd(struct mac_ax_adapter *adapter, struct rtw_h2c_pkt *h2cb,
+		    u8 *cmd, u32 len)
+{
+	u8 *buf;
+
+	buf = h2cb_put(h2cb, len);
+	if (!buf)
+		return MACNPTR;
+	PLTFM_MEMCPY(buf, cmd, len);
+	return MACSUCCESS;
+}
+
+u32 h2c_pkt_build_txd(struct mac_ax_adapter *adapter, struct rtw_h2c_pkt *h2cb)
+{
+	u8 *buf;
+	u32 ret;
+	u32 txd_len;
+	struct rtw_t_meta_data info = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+
+	info.type = RTW_PHL_PKT_TYPE_H2C;
+	info.pktlen = (u16)h2cb->data_len;
+	txd_len = ops->txdesc_len(adapter, &info);
+	if (adapter->hw_info->intf == MAC_AX_INTF_USB) {
+		if (((info.pktlen + txd_len) & (512 - 1)) == 0) {
+			buf = h2cb_put(h2cb, 4);
+			if (!buf) {
+				PLTFM_MSG_ERR("Avoid USB 512-byte FAIL\n");
+				return MACNPTR;
+			}
+			info.pktlen = (u16)h2cb->data_len;
+			txd_len = ops->txdesc_len(adapter, &info);
+		}
+	}
+
+	buf = h2cb_push(h2cb, txd_len);
+	if (!buf)
+		return MACNPTR;
+
+	ret = ops->build_txdesc(adapter, &info, buf, txd_len);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 fwcmd_wq_idle(struct mac_ax_adapter *adapter, u32 id)
+{
+	return MACSUCCESS;
+}
+
+#else
+struct h2c_buf *h2cb_alloc(struct mac_ax_adapter *adapter,
+			   enum h2c_buf_class buf_class)
+{
+	struct h2c_buf_head *list_head = &h2cb_head[buf_class];
+	struct h2c_buf *h2cb;
+
+	if (buf_class >= H2CB_CLASS_LAST) {
+		PLTFM_MSG_ERR("[ERR]unknown class\n");
+		return NULL;
+	}
+
+	PLTFM_MUTEX_LOCK(&list_head->lock);
+
+	h2cb = h2cb_dequeue(list_head);
+	if (!h2cb) {
+		PLTFM_MSG_ERR("[ERR]allocate h2cb, class : %d\n", buf_class);
+		goto h2cb_fail;
+	}
+
+	if (!(h2cb->flags & H2CB_FLAGS_FREED)) {
+		PLTFM_MSG_ERR("[ERR]not freed flag\n");
+		PLTFM_FREE(h2cb, sizeof(struct h2c_buf));
+		goto h2cb_fail;
+	}
+
+	h2cb->flags &= ~H2CB_FLAGS_FREED;
+	PLTFM_MUTEX_UNLOCK(&list_head->lock);
+
+	return h2cb;
+h2cb_fail:
+	PLTFM_MUTEX_UNLOCK(&list_head->lock);
+	return NULL;
+}
+
+void h2cb_free(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb)
+{
+	struct h2c_buf_head *list_head;
+
+	if (h2cb->flags & H2CB_FLAGS_FREED) {
+		PLTFM_MSG_ERR("[ERR]freed flag\n");
+		return;
+	}
+
+	if (h2cb->_class_ >= H2CB_CLASS_LAST) {
+		PLTFM_MSG_ERR("[ERR]unknown class\n");
+		return;
+	}
+
+	list_head = &h2cb_head[h2cb->_class_];
+
+	h2cb->len = 0;
+	h2cb->data = h2cb->head + h2cb->hdr_len;
+	h2cb->tail = h2cb->data;
+	h2cb->flags |= H2CB_FLAGS_FREED;
+
+	PLTFM_MUTEX_LOCK(&list_head->lock);
+	__h2cb_queue_tail(list_head, h2cb);
+	PLTFM_MUTEX_UNLOCK(&list_head->lock);
+}
+
+u8 *h2cb_push(struct h2c_buf *h2cb, u32 len)
+{
+	h2cb->data -= len;
+	h2cb->len  += len;
+
+	if (h2cb->data < h2cb->head)
+		return NULL;
+
+	return h2cb->data;
+}
+
+u8 *h2cb_pull(struct h2c_buf *h2cb, u32 len)
+{
+	h2cb->data += len;
+
+	if (h2cb->data > h2cb->end)
+		return NULL;
+
+	if (h2cb->len < len)
+		return NULL;
+
+	h2cb->len -= len;
+
+	return h2cb->data;
+}
+
+u8 *h2cb_put(struct h2c_buf *h2cb, u32 len)
+{
+	u8 *tmp = h2cb_tail_pointer(h2cb);
+
+	h2cb->tail += len;
+	h2cb->len += len;
+
+	if (h2cb->tail > h2cb->end)
+		return NULL;
+
+	return tmp;
+}
+
+u32 h2c_pkt_set_hdr(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb,
+		    u8 type, u8 cat, u8 _class_, u8 func, u16 rack, u16 dack)
+{
+	struct fwcmd_hdr *hdr;
+	struct mac_ax_fw_info *fwinfo = &adapter->fw_info;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACFWNONRDY;
+
+	if (adapter->sm.mac_rdy != MAC_AX_MAC_RDY) {
+		PLTFM_MSG_TRACE("MAC is not ready\n");
+		adapter->stats.h2c_pkt_uninit++;
+	}
+
+	hdr = (struct fwcmd_hdr *)h2cb_push(h2cb, FWCMD_HDR_LEN);
+	if (!hdr)
+		return MACNPTR;
+
+	hdr->hdr0 = cpu_to_le32(SET_WORD(type, H2C_HDR_DEL_TYPE) |
+				SET_WORD(cat, H2C_HDR_CAT) |
+				SET_WORD(_class_, H2C_HDR_CLASS) |
+				SET_WORD(func, H2C_HDR_FUNC) |
+				SET_WORD(fwinfo->h2c_seq, H2C_HDR_H2C_SEQ));
+
+	hdr->hdr1 = cpu_to_le32(SET_WORD(h2cb->len, H2C_HDR_TOTAL_LEN) |
+				(rack ? H2C_HDR_REC_ACK : 0) |
+				(dack ? H2C_HDR_DONE_ACK : 0));
+
+	h2cb->id = SET_FWCMD_ID(type, cat, _class_, func);
+	h2cb->h2c_seq = fwinfo->h2c_seq;
+
+	return 0;
+}
+
+u32 h2c_pkt_set_hdr_fwdl(struct mac_ax_adapter *adapter,
+			 struct h2c_buf *h2cb, u8 type, u8 cat,
+			 u8 _class_, u8 func, u16 rack, u16 dack)
+{
+	struct fwcmd_hdr *hdr;
+	struct mac_ax_fw_info *fwinfo = &adapter->fw_info;
+
+	hdr = (struct fwcmd_hdr *)h2cb_push(h2cb, FWCMD_HDR_LEN);
+	if (!hdr)
+		return MACNPTR;
+
+	hdr->hdr0 = cpu_to_le32(SET_WORD(type, H2C_HDR_DEL_TYPE) |
+				SET_WORD(cat, H2C_HDR_CAT) |
+				SET_WORD(_class_, H2C_HDR_CLASS) |
+				SET_WORD(func, H2C_HDR_FUNC) |
+				SET_WORD(fwinfo->h2c_seq, H2C_HDR_H2C_SEQ));
+
+	hdr->hdr1 = cpu_to_le32(SET_WORD(h2cb->len, H2C_HDR_TOTAL_LEN) |
+				(rack ? H2C_HDR_REC_ACK : 0) |
+				(dack ? H2C_HDR_DONE_ACK : 0));
+
+	h2cb->id = SET_FWCMD_ID(type, cat, _class_, func);
+	h2cb->h2c_seq = fwinfo->h2c_seq;
+
+	return 0;
+}
+
+u32 h2c_pkt_set_cmd(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb,
+		    u8 *cmd, u32 len)
+{
+	u8 *buf;
+
+	buf = h2cb_put(h2cb, len);
+	if (!buf)
+		return MACNPTR;
+	PLTFM_MEMCPY(buf, cmd, len);
+	return MACSUCCESS;
+}
+
+u32 h2c_pkt_build_txd(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb)
+{
+	u8 *buf;
+	u32 ret;
+	u32 txd_len;
+	struct rtw_t_meta_data info = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+
+	info.type = RTW_PHL_PKT_TYPE_H2C;
+	info.pktlen = (u16)h2cb->len;
+	txd_len = ops->txdesc_len(adapter, &info);
+	if (adapter->hw_info->intf == MAC_AX_INTF_USB) {
+		if (((info.pktlen + txd_len) & (512 - 1)) == 0) {
+			buf = h2cb_put(h2cb, 4);
+			if (!buf) {
+				PLTFM_MSG_ERR("Avoid USB 512-byte FAIL\n");
+				return MACNPTR;
+			}
+			info.pktlen = (u16)h2cb->len;
+			txd_len = ops->txdesc_len(adapter, &info);
+		}
+	}
+
+	buf = h2cb_push(h2cb, txd_len);
+	if (!buf)
+		return MACNPTR;
+
+	ret = ops->build_txdesc(adapter, &info, buf, txd_len);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+static inline void __fwcmd_wq_insert(struct h2c_buf *new_h2cb,
+				     struct h2c_buf *prev, struct h2c_buf *next,
+				     struct fwcmd_wkb_head *list)
+{
+	new_h2cb->next = next;
+	new_h2cb->prev = prev;
+	next->prev  = new_h2cb;
+	prev->next = new_h2cb;
+	list->qlen++;
+}
+
+static inline void __fwcmd_wq_before(struct fwcmd_wkb_head *list,
+				     struct h2c_buf *next,
+				     struct h2c_buf *new_h2cb)
+{
+	__fwcmd_wq_insert(new_h2cb, next->prev, next, list);
+}
+
+static inline void __fwcmd_wq_tail(struct fwcmd_wkb_head *list,
+				   struct h2c_buf *new_h2cb)
+{
+	__fwcmd_wq_before(list, (struct h2c_buf *)list, new_h2cb);
+}
+
+u32 fwcmd_wq_enqueue(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb)
+{
+	struct fwcmd_wkb_head *list_head = &fwcmd_wq_head;
+
+	if (list_head->qlen > FWCMD_WQ_MAX_JOB_NUM) {
+		PLTFM_MSG_WARN("[WARN]fwcmd work queue full\n");
+		return MACBUFALLOC;
+	}
+
+	/* worq queue doesn't need wd body */
+	h2cb_pull(h2cb, WD_BODY_LEN);
+	PLTFM_MUTEX_LOCK(&list_head->lock);
+	__fwcmd_wq_tail(list_head, h2cb);
+	PLTFM_MUTEX_UNLOCK(&list_head->lock);
+
+	return MACSUCCESS;
+}
+
+static inline void __fwcmd_wq_unlink(struct h2c_buf *h2cb,
+				     struct fwcmd_wkb_head *list)
+{
+	struct h2c_buf *next, *prev;
+
+	list->qlen--;
+	next = h2cb->next;
+	prev = h2cb->prev;
+	h2cb->prev = NULL;
+	h2cb->next = NULL;
+	next->prev = prev;
+	prev->next = next;
+}
+
+struct h2c_buf *fwcmd_wq_dequeue(struct mac_ax_adapter *adapter, u32 id)
+{
+	struct fwcmd_wkb_head *list_head = &fwcmd_wq_head;
+	struct h2c_buf *h2cb;
+	u32 hdr0;
+	u16 type = GET_FWCMD_TYPE(id);
+	u16 cat = GET_FWCMD_CAT(id);
+	u16 _class_ = GET_FWCMD_CLASS(id);
+	u16 func = GET_FWCMD_FUNC(id);
+
+	PLTFM_MUTEX_LOCK(&list_head->lock);
+
+	for (h2cb = list_head->next; h2cb->next != list_head->next;
+	     h2cb = h2cb->next) {
+		hdr0 = ((struct fwcmd_hdr *)h2cb->data)->hdr0;
+		hdr0 = le32_to_cpu(hdr0);
+		if (type == GET_FIELD(hdr0, H2C_HDR_DEL_TYPE) &&
+		    cat == GET_FIELD(hdr0, H2C_HDR_CAT) &&
+		    _class_ == GET_FIELD(hdr0, H2C_HDR_CLASS) &&
+		    func == GET_FIELD(hdr0, H2C_HDR_FUNC)) {
+			__fwcmd_wq_unlink(h2cb, list_head);
+			PLTFM_MUTEX_UNLOCK(&list_head->lock);
+			return h2cb;
+		}
+	}
+
+	PLTFM_MUTEX_UNLOCK(&list_head->lock);
+
+	PLTFM_MSG_ERR("[ERR]cannot find wq item: %X\n", id);
+
+	return NULL;
+}
+
+u32 fwcmd_wq_idle(struct mac_ax_adapter *adapter, u32 id)
+{
+	struct fwcmd_wkb_head *list_head = &fwcmd_wq_head;
+	struct h2c_buf *h2cb;
+
+	PLTFM_MUTEX_LOCK(&list_head->lock);
+
+	for (h2cb = list_head->next; h2cb->next != list_head->next;
+	     h2cb = h2cb->next) {
+		if (h2cb->id == id) {
+			PLTFM_MUTEX_UNLOCK(&list_head->lock);
+			return MACWQBUSY;
+		}
+	}
+
+	PLTFM_MUTEX_UNLOCK(&list_head->lock);
+
+	return MACSUCCESS;
+}
+#endif
+
+static u32 c2h_fwi_cmd_log(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			   struct rtw_c2h_info *info)
+{
+#if MAC_AX_FEATURE_DBGDEC
+	u8 syntax_1 = 0, syntax_2 = 0;
+
+	if ((len - FWCMD_HDR_LEN) >= 11) {
+		syntax_1 = *(buf + FWCMD_HDR_LEN);
+		syntax_2 = *(buf + FWCMD_HDR_LEN + 1);
+	}
+	//PLTFM_MSG_WARN("C2H encoded log syntax_1 %x, syntax_2 %x", syntax_1, syntax_2);
+	if (syntax_1 == 0xa5 && syntax_2 == 0xa5) {
+		//PLTFM_MSG_WARN("C2H encoded log");
+		fw_log_dump(adapter, buf, len, info);
+	} else {
+		if (buf[len - 1] != '\0')
+			buf[len - 1] = '\0';
+		PLTFM_MSG_WARN("C2H log: %s", (char *)(buf + FWCMD_HDR_LEN));
+	}
+#else
+	if (buf[len - 1] != '\0')
+		buf[len - 1] = '\0';
+	PLTFM_MSG_WARN("C2H log: %s", (char *)(buf + FWCMD_HDR_LEN));
+#endif
+	return MACSUCCESS;
+}
+
+static u32 c2h_wow_rcv_ack_hdl(struct mac_ax_adapter *adapter,
+			       struct rtw_c2h_info *info)
+{
+	u8 *state;
+
+	switch (info->c2h_func) {
+	case FWCMD_H2C_FUNC_AOAC_REPORT_REQ:
+		state = &adapter->sm.aoac_rpt;
+		PLTFM_MSG_ERR("aoac_rpt rcv ack success\n");
+		break;
+
+	default:
+		return MACSUCCESS;
+	}
+
+	if (*state == MAC_AX_AOAC_RPT_H2C_SENDING)
+		*state = MAC_AX_AOAC_RPT_H2C_RCVD;
+
+	return MACSUCCESS;
+}
+
+static u32 c2h_fwofld_rcv_ack_hdl(struct mac_ax_adapter *adapter,
+				  struct rtw_c2h_info *info)
+{
+	u8 *state;
+
+	switch (info->c2h_func) {
+	case FWCMD_H2C_FUNC_WRITE_OFLD:
+		state = &adapter->sm.write_h2c;
+		break;
+
+	case FWCMD_H2C_FUNC_CONF_OFLD:
+		state = &adapter->sm.conf_h2c;
+		break;
+
+	case FWCMD_H2C_FUNC_PACKET_OFLD:
+		state = &adapter->sm.pkt_ofld;
+		break;
+
+	case FWCMD_H2C_FUNC_READ_OFLD:
+		state = &adapter->sm.read_h2c;
+		break;
+
+	case FWCMD_H2C_FUNC_DUMP_EFUSE:
+		state = &adapter->sm.efuse_ofld;
+		break;
+	case FWCMD_H2C_FUNC_CH_SWITCH:
+		state = &adapter->sm.ch_switch;
+		break;
+	case FWCMD_H2C_FUNC_STA_CSA:
+		state = &adapter->sm.sta_csa_st;
+		PLTFM_MSG_TRACE("sta_csa rcv ack success\n");
+		if (*state == MAC_AX_STA_CSA_SENDING)
+			*state = MAC_AX_STA_CSA_BUSY;
+		else
+			PLTFM_MSG_ERR("sta_csa fw state err: curr st(%d) ret(%d)\n", *state,
+				      adapter->sm.sta_csa_ret);
+		return MACSUCCESS;
+
+	default:
+		return MACSUCCESS;
+	}
+
+	if (*state == MAC_AX_OFLD_H2C_SENDING)
+		*state = MAC_AX_OFLD_H2C_RCVD;
+
+	return MACSUCCESS;
+}
+
+static u32 c2h_proxy_ack(struct mac_ax_adapter *adapter, struct rtw_c2h_info *info, u8 is_rcv)
+{
+	struct mac_ax_state_mach *sm = &adapter->sm;
+
+	switch (is_rcv) {
+	case 0:
+		if (sm->proxy_st != MAC_AX_PROXY_BUSY) {
+			PLTFM_MSG_ERR("[Proxy][DoneAck] is_rcv (%d) doesn't match sm (%d)\n",
+				      is_rcv, sm->proxy_st);
+			return MACPROCERR;
+		}
+		sm->proxy_st = MAC_AX_PROXY_IDLE;
+		sm->proxy_ret = info->h2c_return;
+		if (info->h2c_return != MACSUCCESS)
+			PLTFM_MSG_ERR("[Proxy][DoneAck] h2c return not success (%d)\n",
+				      info->h2c_return);
+		else
+			PLTFM_MSG_TRACE("[Proxy][DoneAck]\n");
+		break;
+	case 1:
+		if (sm->proxy_st != MAC_AX_PROXY_SENDING) {
+			PLTFM_MSG_ERR("[Proxy][RecvAck] is_rcv (%d) doesn't match sm (%d)\n",
+				      is_rcv, sm->proxy_st);
+			return MACPROCERR;
+		}
+		PLTFM_MSG_TRACE("[Proxy][RecvAck]\n");
+		sm->proxy_st = MAC_AX_PROXY_BUSY;
+		break;
+	default:
+		PLTFM_MSG_ERR("[Proxy][Ack] is_rcv bad value (%d)\n", is_rcv);
+	}
+	return MACSUCCESS;
+}
+
+static u32 c2h_fwi_rev_ack(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			   struct rtw_c2h_info *info)
+{
+	u32 data = *(u32 *)(buf + FWCMD_HDR_LEN);
+	u32 ret;
+	u32 cat;
+
+	data = le32_to_cpu(data);
+
+	cat = GET_FIELD(data, FWCMD_C2H_REC_ACK_CAT);
+	if (cat == FWCMD_H2C_CAT_OUTSRC || cat == FWCMD_H2C_CAT_TEST)
+		return MACSUCCESS;
+
+	info->c2h_cat = GET_FIELD(data, FWCMD_C2H_REC_ACK_CAT);
+	info->c2h_class = GET_FIELD(data, FWCMD_C2H_REC_ACK_CLASS);
+	info->c2h_func = GET_FIELD(data, FWCMD_C2H_REC_ACK_FUNC);
+	info->h2c_seq = GET_FIELD(data, FWCMD_C2H_REC_ACK_H2C_SEQ);
+	adapter->fw_info.rec_seq = info->h2c_seq;
+	info->type_rec_ack = 1;
+
+	if (info->c2h_cat == FWCMD_H2C_CAT_MAC) {
+		switch (info->c2h_class) {
+		case FWCMD_H2C_CL_WOW:
+			ret = c2h_wow_rcv_ack_hdl(adapter, info);
+			if (ret)
+				return ret;
+			break;
+
+		case FWCMD_H2C_CL_FW_OFLD:
+			ret = c2h_fwofld_rcv_ack_hdl(adapter, info);
+			if (ret)
+				return ret;
+			break;
+		case FWCMD_H2C_CL_PROXY:
+			ret = c2h_proxy_ack(adapter, info, 1);
+			if (ret)
+				return ret;
+			break;
+
+		default:
+			return MACSUCCESS;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 c2h_fwofld_done_ack_hdl(struct mac_ax_adapter *adapter,
+				   struct rtw_c2h_info *info)
+{
+	struct mac_ax_state_mach *sm = &adapter->sm;
+	struct mac_ax_pkt_ofld_info *ofld_info = &adapter->pkt_ofld_info;
+	struct mac_ax_scanofld_info *scanofld_info = &adapter->scanofld_info;
+	struct sensing_csi_info *csi_info = &adapter->csi_info;
+	u8 scanofld_band;
+	u8 scanofld_return;
+	u8 *pfw_scan_busy;
+	u8 *pfw_chlist_busy;
+	u8 *state;
+	u8 *ret;
+	u8 done_ret = info->h2c_return;
+
+	switch (info->c2h_func) {
+	case FWCMD_H2C_FUNC_WRITE_OFLD:
+		if (sm->write_h2c == MAC_AX_OFLD_H2C_RCVD) {
+			if (info->h2c_return == MACSUCCESS)
+				sm->write_h2c = MAC_AX_OFLD_H2C_IDLE;
+			else
+				sm->write_h2c = MAC_AX_OFLD_H2C_ERROR;
+		}
+		break;
+
+	case FWCMD_H2C_FUNC_CONF_OFLD:
+		if (sm->conf_h2c == MAC_AX_OFLD_H2C_RCVD) {
+			if (info->h2c_return == MACSUCCESS)
+				sm->conf_h2c = MAC_AX_OFLD_H2C_IDLE;
+			else
+				sm->conf_h2c = MAC_AX_OFLD_H2C_ERROR;
+		}
+		break;
+
+	case FWCMD_H2C_FUNC_PACKET_OFLD:
+		if (sm->pkt_ofld == MAC_AX_OFLD_H2C_RCVD) {
+			if (info->h2c_return == MACSUCCESS) {
+				if (ofld_info->last_op == PKT_OFLD_OP_READ)
+					sm->pkt_ofld = MAC_AX_OFLD_H2C_DONE;
+				else
+					sm->pkt_ofld = MAC_AX_OFLD_H2C_IDLE;
+			} else {
+				sm->pkt_ofld = MAC_AX_OFLD_H2C_ERROR;
+			}
+		} else {
+			PLTFM_MSG_ERR("cant set pkt ofld state since no recv ack is received.");
+		}
+		break;
+
+	case FWCMD_H2C_FUNC_READ_OFLD:
+		if (sm->read_h2c == MAC_AX_OFLD_H2C_RCVD) {
+			if (info->h2c_return == MACSUCCESS)
+				sm->read_h2c = MAC_AX_OFLD_H2C_DONE;
+			else
+				sm->read_h2c = MAC_AX_OFLD_H2C_ERROR;
+		}
+		break;
+
+	case FWCMD_H2C_FUNC_DUMP_EFUSE:
+		if (sm->efuse_ofld == MAC_AX_OFLD_H2C_RCVD) {
+			if (info->h2c_return == MACSUCCESS)
+				sm->efuse_ofld = MAC_AX_OFLD_H2C_DONE;
+			else
+				sm->efuse_ofld = MAC_AX_OFLD_H2C_ERROR;
+		}
+		break;
+	case FWCMD_H2C_FUNC_ADD_SCANOFLD_CH:
+		scanofld_band = info->h2c_return >> SCANOFLD_ACK_BAND_SHIFT;
+		scanofld_return = info->h2c_return & SCANOFLD_ACK_RETURN_MASK;
+		PLTFM_MSG_TRACE("[scnofld](%d) got add scanofld done ack. clear fw chlist busy\n",
+				scanofld_band);
+
+		PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+		adapter->scanofld_info.fw_chlist_busy[scanofld_band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+
+		PLTFM_MSG_TRACE("[scnofld][%d] drv_chlist_state = %d, fw_chlist_state = %d\n",
+				scanofld_band,
+				adapter->scanofld_info.drv_chlist_busy[scanofld_band],
+				adapter->scanofld_info.fw_chlist_busy[scanofld_band]);
+		break;
+	case FWCMD_H2C_FUNC_SCANOFLD:
+		scanofld_band = info->h2c_return >> SCANOFLD_ACK_BAND_SHIFT;
+		scanofld_return = info->h2c_return & SCANOFLD_ACK_RETURN_MASK;
+		if (scanofld_return != MACSUCCESS) {
+			PLTFM_MSG_TRACE("[scnofld][%d] scan func fail,revert fw related status\n",
+					scanofld_band);
+
+			PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+			pfw_chlist_busy = &scanofld_info->fw_chlist_busy[scanofld_band];
+			*pfw_chlist_busy = scanofld_info->last_fw_chlist_busy[scanofld_band];
+			PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+
+			pfw_scan_busy = &scanofld_info->fw_scan_busy[scanofld_band];
+			*pfw_scan_busy = scanofld_info->last_fw_scan_busy[scanofld_band];
+		}
+		PLTFM_MSG_TRACE("[scnofld][%d] fw_scan_busy = %d, fw_chlist_state = %d\n",
+				scanofld_band,
+				scanofld_info->fw_scan_busy[scanofld_band],
+				scanofld_info->fw_chlist_busy[scanofld_band]);
+		break;
+
+	case FWCMD_H2C_FUNC_WIFI_SENSING_CSI:
+		if (csi_info->start_cmd_send && csi_info->stop_cmd_send)
+			PLTFM_MSG_ERR("[ERR][csi][DoneAck] state machine error!\n");
+
+		if (csi_info->start_cmd_send) {
+			if (info->h2c_return == MACSUCCESS)
+				csi_info->func_en = 1;
+
+			csi_info->start_cmd_send = 0;
+		}
+
+		if (csi_info->stop_cmd_send) {
+			if (info->h2c_return == MACSUCCESS)
+				csi_info->func_en = 0;
+
+			csi_info->stop_cmd_send = 0;
+		}
+
+		PLTFM_MUTEX_LOCK(&csi_info->state_lock);
+		sm->sensing_csi_st = MAC_AX_SENSING_CSI_IDLE;
+		PLTFM_MUTEX_UNLOCK(&csi_info->state_lock);
+		break;
+
+	case FWCMD_H2C_FUNC_SCH_TX_EN_PKT:
+		if (sm->sch_tx_en_ofld == MAC_AX_OFLD_H2C_SENDING) {
+			if (info->h2c_return == MACSUCCESS)
+				sm->sch_tx_en_ofld = MAC_AX_OFLD_H2C_DONE;
+			else
+				sm->sch_tx_en_ofld = MAC_AX_OFLD_H2C_ERROR;
+		}
+		break;
+
+	case FWCMD_H2C_FUNC_MACID_PAUSE_SLEEP:
+		if (sm->macid_pause_sleep == MAC_AX_OFLD_H2C_SENDING) {
+			if (info->h2c_return == MACSUCCESS)
+				sm->macid_pause_sleep = MAC_AX_OFLD_H2C_DONE;
+			else
+				sm->macid_pause_sleep = MAC_AX_OFLD_H2C_ERROR;
+		}
+		break;
+	case FWCMD_H2C_FUNC_STA_CSA:
+		state = &adapter->sm.sta_csa_st;
+		ret = &adapter->sm.sta_csa_ret;
+		PLTFM_MSG_TRACE("sta_csa done ack with ret (%d)\n", done_ret);
+		if (*state == MAC_AX_STA_CSA_BUSY) {
+			*state = MAC_AX_STA_CSA_IDLE;
+			*ret = done_ret;
+		} else {
+			PLTFM_MSG_ERR("sta_csa fw state err: curr st(%d) ret(%d)\n", *state, *ret);
+		}
+		break;
+	default:
+		break;
+	}
+	return MACSUCCESS;
+}
+
+static u32 c2h_role_done_ack_hdl(struct mac_ax_adapter *adapter,
+				 struct rtw_c2h_info *info)
+{
+	struct mac_ax_dbcc_info *dbcc_info = adapter->dbcc_info;
+	struct mac_ax_state_mach *sm = &adapter->sm;
+
+	if (info->c2h_class == FWCMD_H2C_CL_MEDIA_RPT &&
+	    info->c2h_func == FWCMD_H2C_FUNC_FWROLE_MAINTAIN) {
+		if (info->h2c_return == MACSUCCESS) {
+			sm->role_stat = MAC_AX_ROLE_ALOC_SUCC;
+		} else {
+			PLTFM_MSG_ERR("[ERR]role_maintain: alloc failed\n");
+			sm->role_stat = MAC_AX_ROLE_ALOC_FAIL;
+			return MACROLEALOCFL;
+		}
+	} else if (info->c2h_class == FWCMD_H2C_CL_MEDIA_RPT &&
+		   info->c2h_func == FWCMD_H2C_FUNC_JOININFO) {
+		if (info->h2c_return == MACSUCCESS) {
+			sm->role_stat = MAC_AX_ROLE_INIT_SUCC;
+		} else {
+			PLTFM_MSG_ERR("[ERR]role_join: init failed\n");
+			sm->role_stat = MAC_AX_ROLE_INIT_FAIL;
+			return MACROLEINITFL;
+		}
+	} else if (info->c2h_class == FWCMD_H2C_CL_MEDIA_RPT &&
+		   info->c2h_func == FWCMD_H2C_FUNC_NOTIFY_DBCC) {
+		if (info->h2c_return == MACSUCCESS) {
+			dbcc_info->notify_fw_flag = 0;
+		} else {
+			PLTFM_MSG_ERR("[ERR]dbcc notify ack fail %d\n",
+				      info->h2c_return);
+			return MACSUCCESS;
+		}
+	} else if (info->c2h_class == FWCMD_H2C_CL_ADDR_CAM_UPDATE &&
+		   info->c2h_func == FWCMD_H2C_FUNC_ADDRCAM_INFO) {
+		if (info->h2c_return == MACSUCCESS) {
+			sm->role_stat = MAC_AX_ROLE_HW_UPD_SUCC;
+		} else {
+			PLTFM_MSG_ERR("[ERR]ADDR_CAM: upd failed\n");
+			sm->role_stat = MAC_AX_ROLE_HW_UPD_FAIL;
+			return MACROLEHWUPDFL;
+		}
+	}
+	return MACSUCCESS;
+}
+
+static u32 c2h_ps_done_ack_hdl(struct mac_ax_adapter *adapter,
+			       struct rtw_c2h_info *info)
+{
+	struct mac_ax_state_mach *sm = &adapter->sm;
+	u8 p2pid;
+	u32 ret;
+
+	switch (info->c2h_func) {
+	case FWCMD_H2C_FUNC_P2P_ACT:
+		if (sm->p2p_stat != MAC_AX_P2P_ACT_BUSY) {
+			PLTFM_MSG_ERR("[ERR]p2p act dack stat err %d\n",
+				      sm->p2p_stat);
+			return MACPROCERR;
+		}
+
+		if (info->h2c_return != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]p2p act dack ret %d\n",
+				      info->h2c_return);
+			sm->p2p_stat = MAC_AX_P2P_ACT_FAIL;
+			break;
+		}
+
+		p2pid = P2PID_INVALID;
+		ret = get_wait_dack_p2pid(adapter, &p2pid);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]p2p act dack get wait id %d\n", ret);
+			return ret;
+		}
+		if (p2pid == P2PID_INVALID) {
+			PLTFM_MSG_ERR("[ERR]p2p act dack no wait id\n");
+			sm->p2p_stat = MAC_AX_P2P_ACT_IDLE;
+			return MACPROCERR;
+		}
+
+		if (adapter->p2p_info[p2pid].wait_term &&
+		    adapter->p2p_info[p2pid].wait_init) {
+			PLTFM_MSG_ERR("[ERR]p2p act dack wait term & init\n");
+		} else if (adapter->p2p_info[p2pid].wait_term) {
+			PLTFM_MEMSET(&adapter->p2p_info[p2pid], 0,
+				     sizeof(struct mac_ax_p2p_info));
+		} else if (adapter->p2p_info[p2pid].wait_init) {
+			adapter->p2p_info[p2pid].run = 1;
+			adapter->p2p_info[p2pid].wait_init = 0;
+			adapter->p2p_info[p2pid].wait_dack = 0;
+		} else {
+			adapter->p2p_info[p2pid].wait_dack = 0;
+		}
+		sm->p2p_stat = MAC_AX_P2P_ACT_IDLE;
+		break;
+	case FWCMD_H2C_FUNC_P2P_MACID_CTRL:
+		if (sm->p2p_stat != MAC_AX_P2P_ACT_BUSY) {
+			PLTFM_MSG_ERR("[ERR]p2p macid ctrl dack stat err %d\n",
+				      sm->p2p_stat);
+			return MACPROCERR;
+		}
+
+		if (info->h2c_return != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]p2p macid ctrl dack ret %d\n",
+				      info->h2c_return);
+			sm->p2p_stat = MAC_AX_P2P_ACT_FAIL;
+			break;
+		}
+
+		p2pid = P2PID_INVALID;
+		ret = get_wait_dack_p2pid(adapter, &p2pid);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]p2p macid ctrl dack get wait id %d\n",
+				      ret);
+			return ret;
+		}
+		if (p2pid != P2PID_INVALID) {
+			if (adapter->p2p_info[p2pid].run) {
+				adapter->p2p_info[p2pid].wait_dack = 0;
+			} else {
+				PLTFM_MSG_ERR("[ERR]p2p%d macid ctrl dack not run\n",
+					      p2pid);
+			}
+		} else {
+			PLTFM_MSG_ERR("[ERR]p2p macid ctrl dack no wait id\n");
+		}
+		sm->p2p_stat = MAC_AX_P2P_ACT_IDLE;
+		break;
+	case FWCMD_H2C_FUNC_IPS_CFG:
+		if (info->h2c_return != MACSUCCESS)
+			PLTFM_MSG_ERR("[ERR]fwips dack ret %d\n", info->h2c_return);
+		break;
+	case FWCMD_H2C_FUNC_PS_ADVANCE_PARM:
+		if (info->h2c_return != MACSUCCESS)
+			PLTFM_MSG_ERR("[ERR]ps advanced parm dack ret %d\n", info->h2c_return);
+		break;
+	case FWCMD_H2C_FUNC_PERIODIC_WAKE:
+		if (info->h2c_return != MACSUCCESS)
+			PLTFM_MSG_ERR("[ERR] periodic wake dack ret %d\n", info->h2c_return);
+		break;
+	default:
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 c2h_nan_done_ack_hdl(struct mac_ax_adapter *adapter, struct rtw_c2h_info *info)
+{
+	struct mac_ax_state_mach *sm = &adapter->sm;
+
+	switch (info->c2h_func) {
+	case FWCMD_H2C_FUNC_ACT_SCHEDULE_REQ:
+
+		PLTFM_MSG_ERR("[ERR] nan current state %d\n", sm->nan_stat);
+		if (info->h2c_return == MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]nan act dack ret %d\n", info->h2c_return);
+			sm->nan_stat = MAX_AX_NAN_ACT_H2C_FAIL;
+			break;
+		}
+	}
+	return MACSUCCESS;
+}
+
+static u32 c2h_wow_done_ack_hdl(struct mac_ax_adapter* adapter, struct rtw_c2h_info* info)
+{
+	switch (info->c2h_func) {
+	case FWCMD_H2C_FUNC_MAGIC_WAKER_FILTER:
+		if (info->h2c_return != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] WoW MAGIC_WAKER_FILTER failed\n");
+		}
+		else {
+			PLTFM_MSG_TRACE("[TRACE] WoW MAGIC_WAKER_FILTER Success\n");
+		}
+		break;
+	case FWCMD_H2C_FUNC_TCP_KEEPALIVE:
+		if (info->h2c_return != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] WoW TCP_KEEPALIVE failed\n");
+		}
+		else {
+			PLTFM_MSG_TRACE("[TRACE] WoW TCP_KEEPALIVE Success\n");
+		}
+		break;
+	}
+	return MACSUCCESS;
+}
+
+static u32 c2h_fwi_done_ack(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			    struct rtw_c2h_info *info)
+{
+	u32 data = *(u32 *)(buf + FWCMD_HDR_LEN);
+	u32 ret;
+	u32 cat;
+
+	data = le32_to_cpu(data);
+
+	cat = GET_FIELD(data, FWCMD_C2H_REC_ACK_CAT);
+	if (cat == FWCMD_H2C_CAT_OUTSRC || cat == FWCMD_H2C_CAT_TEST)
+		return MACSUCCESS;
+
+	info->c2h_cat = GET_FIELD(data, FWCMD_C2H_DONE_ACK_CAT);
+	info->c2h_class = GET_FIELD(data, FWCMD_C2H_DONE_ACK_CLASS);
+	info->c2h_func = GET_FIELD(data, FWCMD_C2H_DONE_ACK_FUNC);
+	info->h2c_return = GET_FIELD(data, FWCMD_C2H_DONE_ACK_H2C_RETURN);
+	info->h2c_seq = GET_FIELD(data, FWCMD_C2H_DONE_ACK_H2C_SEQ);
+	info->type_done_ack = 1;
+
+	if (info->c2h_cat == FWCMD_H2C_CAT_MAC) {
+		if (info->c2h_class == FWCMD_H2C_CL_FW_OFLD) {
+			ret = c2h_fwofld_done_ack_hdl(adapter, info);
+			if (ret != MACSUCCESS)
+				return ret;
+		} else if (info->c2h_class == FWCMD_H2C_CL_PS) {
+			ret = c2h_ps_done_ack_hdl(adapter, info);
+			if (ret != MACSUCCESS)
+				return ret;
+		} else if (info->c2h_class == FWCMD_H2C_CL_MEDIA_RPT ||
+			   info->c2h_class == FWCMD_H2C_CL_ADDR_CAM_UPDATE) {
+			ret = c2h_role_done_ack_hdl(adapter, info);
+			if (ret != MACSUCCESS)
+				return ret;
+		} else if (info->c2h_class == FWCMD_H2C_CL_PROXY) {
+			ret = c2h_proxy_ack(adapter, info, 0);
+			if (ret != MACSUCCESS)
+				return ret;
+		} else if (info->c2h_class == FWCMD_H2C_CL_NAN) {
+			ret = c2h_nan_done_ack_hdl(adapter, info);
+			if (ret != MACSUCCESS)
+				return ret;
+		} else if (info->c2h_class == FWCMD_H2C_CL_WOW) {
+			ret = c2h_wow_done_ack_hdl(adapter, info);
+			if (ret != MACSUCCESS)
+				return ret;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 c2h_fwi_bcn_stats(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			     struct rtw_c2h_info *info)
+{
+	return MACSUCCESS;
+}
+
+static u32 c2h_fwi_bcn_csazero(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			       struct rtw_c2h_info *info)
+{
+	return MACSUCCESS;
+}
+
+static struct c2h_proc_func c2h_proc_fw_info_cmd[] = {
+	{FWCMD_C2H_FUNC_REC_ACK, c2h_fwi_rev_ack},
+	{FWCMD_C2H_FUNC_DONE_ACK, c2h_fwi_done_ack},
+	{FWCMD_C2H_FUNC_C2H_LOG, c2h_fwi_cmd_log},
+	{FWCMD_C2H_FUNC_BCN_CNT, c2h_fwi_bcn_stats},
+	{FWCMD_C2H_FUNC_BCN_CSAZERO, c2h_fwi_bcn_csazero},
+	{FWCMD_C2H_FUNC_NULL, NULL},
+};
+
+u32 c2h_fw_info(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		struct rtw_c2h_info *info)
+{
+	struct c2h_proc_func *proc = c2h_proc_fw_info_cmd;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info) = NULL;
+	u32 hdr0;
+	u32 func;
+
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	while (proc->id != FWCMD_C2H_FUNC_NULL) {
+		if (func == proc->id) {
+			handler = proc->handler;
+			break;
+		}
+		proc++;
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]null func handler id: %X", func);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, buf, len, info);
+}
+
+static u32 c2h_dump_efuse_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+			      u32 len, struct rtw_c2h_info *info)
+{
+	struct mac_ax_efuse_ofld_info *ofld_info = &adapter->efuse_ofld_info;
+	u32 size;
+
+	if (adapter->sm.efuse_ofld != MAC_AX_OFLD_H2C_RCVD) {
+		PLTFM_MSG_ERR("[ERR]not cmd sending\n");
+		return MACPROCERR;
+	}
+
+	size = adapter->hw_info->efuse_size;
+
+	if (!ofld_info->buf) {
+		ofld_info->buf = (u8 *)PLTFM_MALLOC(size);
+		if (!ofld_info->buf) {
+			adapter->sm.efuse = MAC_AX_EFUSE_IDLE;
+			return MACBUFALLOC;
+		}
+	}
+
+	PLTFM_MEMCPY(ofld_info->buf, buf + FWCMD_HDR_LEN, size);
+
+	adapter->sm.efuse_ofld = MAC_AX_OFLD_H2C_DONE;
+
+	return MACSUCCESS;
+}
+
+static u32 c2h_read_rsp_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+			    u32 len, struct rtw_c2h_info *info)
+{
+	struct mac_ax_read_ofld_value *value_info = &adapter->read_ofld_value;
+	u32 hdr1;
+	u16 read_len;
+	u8 *read_buff;
+
+	if (value_info->buf)
+		PLTFM_FREE(value_info->buf, value_info->len);
+
+	hdr1 = ((struct fwcmd_hdr *)buf)->hdr1;
+	hdr1 = le32_to_cpu(hdr1);
+
+	read_len = GET_FIELD(hdr1, C2H_HDR_TOTAL_LEN) - FWCMD_HDR_LEN;
+
+	read_buff = (u8 *)PLTFM_MALLOC(read_len);
+	if (!read_buff)
+		return MACBUFALLOC;
+
+	PLTFM_MEMCPY(read_buff, buf + FWCMD_HDR_LEN, read_len);
+
+	value_info->len = read_len;
+	value_info->buf = read_buff;
+
+	return MACSUCCESS;
+}
+
+static u32 c2h_pkt_ofld_rsp_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+				u32 len, struct rtw_c2h_info *info)
+{
+	struct mac_ax_pkt_ofld_info *ofld_info = &adapter->pkt_ofld_info;
+	struct mac_ax_pkt_ofld_pkt *ofld_pkt = &adapter->pkt_ofld_pkt;
+	struct mac_ax_state_mach *sm = &adapter->sm;
+	u32 c2h_content = *(u32 *)(buf + FWCMD_HDR_LEN);
+	u16 pkt_len;
+	u8 id, pkt_op;
+	u8 *pkt_buff;
+	u8 *pkt_content;
+
+	c2h_content = le32_to_cpu(c2h_content);
+
+	pkt_op = GET_FIELD(c2h_content, FWCMD_C2H_PKT_OFLD_RSP_PKT_OP);
+	pkt_len = GET_FIELD(c2h_content, FWCMD_C2H_PKT_OFLD_RSP_PKT_LENGTH);
+	id = GET_FIELD(c2h_content, FWCMD_C2H_PKT_OFLD_RSP_PKT_ID);
+
+	PLTFM_MSG_TRACE("get pktofld rsp. pkt_op: %d, pkt_len: %d, id: %d\n", pkt_op, pkt_len, id);
+	if (id == PKT_OFLD_NOT_EXISTS_ID) {
+		PLTFM_MSG_ERR("pktofld id %d is for NOT_EXISTS and shouldn't be rpt from fw\n",
+			      PKT_OFLD_NOT_EXISTS_ID);
+		return MACNOITEM;
+	}
+
+	switch (pkt_op) {
+	case PKT_OFLD_OP_ADD:
+		if (pkt_len != 0) {
+			if (!(ofld_info->id_bitmap[id >> 3] & (1 << (id & 7)))) {
+				ofld_info->free_id_count--;
+				ofld_info->used_id_count++;
+			}
+			ofld_info->id_bitmap[id >> 3] |= (1 << (id & 7));
+		}
+
+		break;
+
+	case PKT_OFLD_OP_DEL:
+		if (pkt_len != 0) {
+			if (ofld_info->id_bitmap[id >> 3] & (1 << (id & 7))) {
+				ofld_info->free_id_count++;
+				ofld_info->used_id_count--;
+			}
+			ofld_info->id_bitmap[id >> 3] &= ~(1 << (id & 7));
+		}
+
+		break;
+
+	case PKT_OFLD_OP_READ:
+		if (pkt_len != 0) {
+			if (ofld_pkt->pkt)
+				PLTFM_FREE(ofld_pkt->pkt, ofld_pkt->pkt_len);
+
+			pkt_buff = (u8 *)PLTFM_MALLOC(pkt_len);
+			if (!pkt_buff)
+				return MACBUFALLOC;
+
+			pkt_content = buf + FWCMD_HDR_LEN;
+			pkt_content += sizeof(struct mac_ax_pkt_ofld_hdr);
+			PLTFM_MEMCPY(pkt_buff, pkt_content, pkt_len);
+			ofld_pkt->pkt_id = id;
+			ofld_pkt->pkt_len = pkt_len;
+			ofld_pkt->pkt = pkt_buff;
+		}
+		break;
+
+	default:
+		PLTFM_MSG_ERR("[ERR]invalid packet offload op: %d", pkt_op);
+		break;
+	}
+	if (sm->pkt_ofld == MAC_AX_OFLD_H2C_ERROR) {
+		if (ofld_info->last_op == PKT_OFLD_OP_READ)
+			sm->pkt_ofld = MAC_AX_OFLD_H2C_DONE;
+		else
+			sm->pkt_ofld = MAC_AX_OFLD_H2C_IDLE;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 c2h_beacon_resend_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+				 u32 len, struct rtw_c2h_info *info)
+{
+	return MACSUCCESS;
+}
+
+static u32 c2h_macid_pause_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+			       u32 len, struct rtw_c2h_info *info)
+{
+	return MACSUCCESS;
+}
+
+static u32 c2h_tx_duty_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+			   u32 len, struct rtw_c2h_info *info)
+{
+	u32 content = *(u32 *)(buf + FWCMD_HDR_LEN);
+	struct mac_ax_tx_duty_ofld_info ofld_info;
+
+	content = le32_to_cpu(content);
+
+	ofld_info.timer_err =
+		GET_FIELD(content, FWCMD_C2H_TX_DUTY_RPT_TIMER_ERR);
+
+	if (ofld_info.timer_err)
+		PLTFM_MSG_ERR("[ERR]Tx duty FW timer error\n");
+
+	return MACSUCCESS;
+}
+
+static u32 c2h_tsf32_togl_rpt_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+				  u32 len, struct rtw_c2h_info *info)
+{
+	struct fwcmd_tsf32_togl_rpt rpt;
+	struct mac_ax_t32_togl_rpt *out_rpt;
+	u8 band, port;
+
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]tsf32 togl rpt no buf\n");
+		return MACNPTR;
+	}
+
+	rpt.dword0 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN));
+	rpt.dword1 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 4));
+	rpt.dword2 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 8));
+
+	band = rpt.dword0 & FWCMD_C2H_TSF32_TOGL_RPT_BAND;
+	if (band >= MAC_AX_BAND_NUM) {
+		PLTFM_MSG_ERR("[ERR]invalid band %d in tsf32 togl rpt\n", band);
+		return MACNOITEM;
+	}
+
+	port = GET_FIELD(rpt.dword0, FWCMD_C2H_TSF32_TOGL_RPT_PORT);
+	if (port >= MAC_AX_PORT_NUM) {
+		PLTFM_MSG_ERR("[ERR]invalid port %d in tsf32 togl rpt\n", port);
+		return MACNOITEM;
+	}
+
+	out_rpt = &adapter->t32_togl_rpt[get_bp_idx(band, port)];
+	out_rpt->band = band;
+	out_rpt->port = port;
+	out_rpt->status = GET_FIELD(rpt.dword0, FWCMD_C2H_TSF32_TOGL_RPT_STATUS);
+	out_rpt->early = GET_FIELD(rpt.dword0, FWCMD_C2H_TSF32_TOGL_RPT_EARLY);
+	out_rpt->tsf_l = GET_FIELD(rpt.dword1, FWCMD_C2H_TSF32_TOGL_RPT_TSF_L);
+	out_rpt->tsf_h = GET_FIELD(rpt.dword2, FWCMD_C2H_TSF32_TOGL_RPT_TSF_H);
+	out_rpt->valid = 1;
+
+	return MACSUCCESS;
+}
+
+static u32 c2h_cmd_ofld_rsp_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+				u32 len, struct rtw_c2h_info *info)
+{
+	struct fwcmd_cmd_ofld_rsp rsp;
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+	struct mac_ax_state_mach *sm = &adapter->sm;
+
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]tsf32 togl rpt no buf\n");
+		return MACNPTR;
+	}
+
+	rsp.dword0 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN));
+
+	ofld_info->result = rsp.dword0 & FWCMD_C2H_CMD_OFLD_RSP_RESULT;
+	if (ofld_info->result) {
+		PLTFM_MSG_ERR("%s: IO offload fail!!!\n", __func__);
+		rsp.dword1 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 4));
+		rsp.dword2 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 8));
+		rsp.dword3 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 12));
+		PLTFM_MSG_ERR("offset = %x\n", rsp.dword1);
+		PLTFM_MSG_ERR("expected val = %x\n", rsp.dword2);
+		PLTFM_MSG_ERR("read val = %x\n", rsp.dword3);
+	}
+
+	if (sm->cmd_state != MAC_AX_CMD_OFLD_SENDING)
+		PLTFM_MSG_ERR("%s: IO offload stat err\n", __func__);
+	else
+		sm->cmd_state = MAC_AX_CMD_OFLD_RCVD;
+
+	return MACSUCCESS;
+}
+
+static u32 c2h_scanofld_rsp_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+				u32 len, struct rtw_c2h_info *info)
+{
+#if SCANOFLD_RSP_EVT_PARSE
+	return 0;
+#else
+	struct fwcmd_scanofld_rsp *pkg;
+	struct mac_ax_scanofld_rsp rsp;
+	struct mac_ax_scanofld_chrpt chrpt_struct;
+	u32 chrpt_size_h_dw;
+	u32 *chrpt;
+	u32 *chrpt_in;
+	u32 sh;
+	u32 chidx;
+
+	pkg = (struct fwcmd_scanofld_rsp *)(buf + FWCMD_HDR_LEN);
+	chrpt_in = (u32 *)(buf + FWCMD_HDR_LEN + sizeof(struct fwcmd_scanofld_rsp));
+
+	chrpt_size_h_dw = sizeof(struct mac_ax_scanofld_chrpt) / sizeof(u32);
+
+	PLTFM_MEMSET(&rsp, 0, sizeof(struct mac_ax_scanofld_rsp));
+
+	pkg->dword0 = le32_to_cpu(pkg->dword0);
+	pkg->dword1 = le32_to_cpu(pkg->dword1);
+	pkg->dword2 = le32_to_cpu(pkg->dword2);
+	pkg->dword3 = le32_to_cpu(pkg->dword3);
+
+	rsp.pri_ch = GET_FIELD(pkg->dword0, FWCMD_C2H_SCANOFLD_RSP_PRI_CH);
+	rsp.notify_reason = GET_FIELD(pkg->dword0, FWCMD_C2H_SCANOFLD_RSP_NOTIFY_REASON);
+	rsp.status = GET_FIELD(pkg->dword0, FWCMD_C2H_SCANOFLD_RSP_STATUS);
+	rsp.ch_band = GET_FIELD(pkg->dword3, FWCMD_C2H_SCANOFLD_RSP_CH_BAND);
+	rsp.band = pkg->dword3 & FWCMD_C2H_SCANOFLD_RSP_BAND;
+	PLTFM_MSG_TRACE("[scnofld][rsp][%d]: Reason %d, ch %d (band %d), status %d\n",
+			rsp.band, rsp.notify_reason, rsp.pri_ch, rsp.ch_band, rsp.status);
+
+	switch (rsp.notify_reason) {
+	case MAC_AX_SCAN_END_SCAN_NOTIFY:
+		PLTFM_MUTEX_LOCK(&adapter->scanofld_info.fw_chlist_state_lock);
+		adapter->scanofld_info.fw_chlist_busy[rsp.band] = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->scanofld_info.fw_chlist_state_lock);
+		adapter->scanofld_info.fw_scan_busy[rsp.band] = 0;
+		/* fall through */
+
+	case MAC_AX_SCAN_GET_RPT_NOTIFY:
+		rsp.scanned_round = GET_FIELD(pkg->dword0, FWCMD_C2H_SCANOFLD_RSP_SCANNED_ROUND);
+		rsp.spent_low = pkg->dword1;
+		rsp.spent_high = pkg->dword2;
+		rsp.air_density = GET_FIELD(pkg->dword3, FWCMD_C2H_SCANOFLD_RSP_AIR_DENSITY);
+		rsp.actual_period = GET_FIELD(pkg->dword0, FWCMD_C2H_SCANOFLD_RSP_ACTUAL_PERIOD);
+		rsp.tx_fail_cnt = GET_FIELD(pkg->dword3, FWCMD_C2H_SCANOFLD_RSP_TX_FAIL_CNT);
+		rsp.num_ch_rpt = GET_FIELD(pkg->dword3, FWCMD_C2H_SCANOFLD_RSP_NUM_CH_RPT);
+		rsp.ch_rpt_size = GET_FIELD(pkg->dword3, FWCMD_C2H_SCANOFLD_RSP_CH_RPT_SIZE);
+
+		PLTFM_MSG_TRACE("[scnofld][rsp][%d][end] scan %d rnd in %llu us, last slot %d us\n",
+				rsp.band, rsp.scanned_round,
+				((u64)rsp.spent_high << 32) + rsp.spent_low, rsp.actual_period);
+		PLTFM_MSG_TRACE("[scnofld][rsp][%d][end] airDense %d, txFail %d\n",
+				rsp.band, rsp.air_density, rsp.tx_fail_cnt);
+		PLTFM_MSG_TRACE("[scnofld][rsp][%d][end] %d ch rpt (size %d)\n",
+				rsp.band, rsp.num_ch_rpt, rsp.ch_rpt_size);
+
+		if (!rsp.num_ch_rpt || !rsp.ch_rpt_size)
+			break;
+
+		for (chidx = 0; chidx < rsp.num_ch_rpt; chidx++) {
+			chrpt = (u32 *)&chrpt_struct;
+			for (sh = 0; sh < chrpt_size_h_dw; sh++) {
+				*chrpt_in = le32_to_cpu(*chrpt_in);
+				PLTFM_MEMCPY(chrpt++, chrpt_in++, sizeof(u32));
+			}
+			chrpt_in += (rsp.ch_rpt_size - chrpt_size_h_dw);
+			PLTFM_MSG_TRACE("[scnofld][rsp][%d][end] ch %d, rx %d, txfail %x, hit %d\n",
+					rsp.band, chrpt_struct.pri_ch, chrpt_struct.rx_cnt,
+					chrpt_struct.tx_fail, chrpt_struct.parsed);
+		}
+		break;
+
+	case MAC_AX_SCAN_LEAVE_CH_NOTIFY:
+		rsp.actual_period = GET_FIELD(pkg->dword0,
+					      FWCMD_C2H_SCANOFLD_RSP_ACTUAL_PERIOD);
+		rsp.tx_fail_cnt = GET_FIELD(pkg->dword3,
+					    FWCMD_C2H_SCANOFLD_RSP_TX_FAIL_CNT);
+		PLTFM_MSG_TRACE("[scnofld][rsp][%d][leave] pd %d, txfail %d\n",
+				rsp.band, rsp.actual_period, rsp.tx_fail_cnt);
+		break;
+
+	default:
+		break;
+	}
+	return 0;
+#endif
+}
+
+static u32 c2h_ch_switch_rpt_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+				 u32 len, struct rtw_c2h_info *info)
+{
+	u32 *content = (u32 *)(buf + FWCMD_HDR_LEN);
+	u8 *state;
+	struct mac_ax_ch_switch_rpt *rpt;
+
+	state = &adapter->sm.ch_switch;
+	if (*state != MAC_AX_OFLD_H2C_SENDING && *state != MAC_AX_OFLD_H2C_RCVD)
+		return MACPROCERR;
+
+	rpt = &adapter->ch_switch_rpt;
+	rpt->result = (u8)GET_FIELD(le32_to_cpu(*content), FWCMD_C2H_CH_SWITCH_RPT_RESULT);
+	*state = MAC_AX_CH_SWITCH_GET_RPT;
+	return MACSUCCESS;
+}
+
+static u32 c2h_bcn_filter_rpt_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+				  u32 len, struct rtw_c2h_info *info)
+{
+	struct fwcmd_bcnfltr_rpt *rpt = (struct fwcmd_bcnfltr_rpt *)(buf + FWCMD_HDR_LEN);
+	u32 dword;
+	u8 macid, type, rssi_evt, rssi_ma;
+	struct mac_ax_bcn_fltr_rpt *adp_rpt;
+
+	dword = le32_to_cpu(rpt->dword0);
+	macid = GET_FIELD(dword, FWCMD_C2H_BCNFLTR_RPT_MACID);
+	type = GET_FIELD(dword, FWCMD_C2H_BCNFLTR_RPT_TYPE);
+	rssi_evt = GET_FIELD(dword, FWCMD_C2H_BCNFLTR_RPT_RSSI_EVT);
+	rssi_ma = GET_FIELD(dword, FWCMD_C2H_BCNFLTR_RPT_RSSI_MA);
+
+	adp_rpt = &adapter->bcn_fltr_rpt;
+	adp_rpt->macid = macid;
+	adp_rpt->type = type;
+	switch (type) {
+	case BCNFLTR_NOTI_BCN_LOSS:
+		PLTFM_MSG_TRACE("[BCNFLTR] bcn loss\n");
+		break;
+	case BCNFLTR_NOTI_DENY_SCAN:
+		PLTFM_MSG_TRACE("[BCNFLTR] deny scan\n");
+		break;
+	case BCNFLTR_NOTI_RSSI:
+		adp_rpt->rssi_evt = rssi_evt;
+		adp_rpt->rssi_ma = rssi_ma;
+		PLTFM_MSG_TRACE("[BCNFLTR] rssi: ma=%d, evt=%d\n", rssi_ma, rssi_evt);
+		break;
+	}
+	adp_rpt->notified = 1;
+	return MACSUCCESS;
+}
+
+static u32 c2h_csi_tx_result_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+				 u32 len, struct rtw_c2h_info *info)
+{
+	return MACSUCCESS;
+}
+
+static u32 c2h_bcn_erly_notify(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			       struct rtw_c2h_info *info)
+{
+	return MACSUCCESS;
+}
+
+static struct c2h_proc_func c2h_proc_fw_ofld_cmd[] = {
+	{FWCMD_C2H_FUNC_EFUSE_DUMP, c2h_dump_efuse_hdl},
+	{FWCMD_C2H_FUNC_READ_RSP, c2h_read_rsp_hdl},
+	{FWCMD_C2H_FUNC_PKT_OFLD_RSP, c2h_pkt_ofld_rsp_hdl},
+	{FWCMD_C2H_FUNC_BEACON_RESEND, c2h_beacon_resend_hdl},
+	{FWCMD_C2H_FUNC_MACID_PAUSE, c2h_macid_pause_hdl},
+	{FWCMD_C2H_FUNC_TSF32_TOGL_RPT, c2h_tsf32_togl_rpt_hdl},
+	{FWCMD_C2H_FUNC_CMD_OFLD_RSP, c2h_cmd_ofld_rsp_hdl},
+	{FWCMD_C2H_FUNC_SCANOFLD_RSP, c2h_scanofld_rsp_hdl},
+	{FWCMD_C2H_FUNC_TX_DUTY_RPT, c2h_tx_duty_hdl},
+	{FWCMD_C2H_FUNC_CH_SWITCH_RPT, c2h_ch_switch_rpt_hdl},
+	{FWCMD_C2H_FUNC_BCNFLTR_RPT, c2h_bcn_filter_rpt_hdl},
+	{FWCMD_C2H_FUNC_WIFI_SENSING_CSI_TX_RESULT, c2h_csi_tx_result_hdl},
+	{FWCMD_C2H_FUNC_BCNERLYNTFY, c2h_bcn_erly_notify},
+	{FWCMD_C2H_FUNC_NULL, NULL},
+};
+
+u32 c2h_fw_ofld(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		struct rtw_c2h_info *info)
+{
+	struct c2h_proc_func *proc = c2h_proc_fw_ofld_cmd;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info) = NULL;
+	u32 hdr0;
+	u32 func;
+
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	while (proc->id != FWCMD_C2H_FUNC_NULL) {
+		if (func == proc->id) {
+			handler = proc->handler;
+			break;
+		}
+		proc++;
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]null func handler id: %X", func);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, buf, len, info);
+}
+
+static u32 c2h_wait_announ_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+			       u32 len, struct rtw_c2h_info *info)
+{
+	struct fwcmd_wait_announce rpt;
+
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]wait announce no buf\n");
+		return MACNPTR;
+	}
+
+	rpt.dword0 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN));
+
+	return MACSUCCESS;
+}
+
+static u32 c2h_stat_rpt_hdl(struct mac_ax_adapter *adapter, u8 *buf,
+			    u32 len, struct rtw_c2h_info *info)
+{
+	struct fwcmd_stat_rpt rpt;
+	struct mac_ax_twt_info *twt_info = adapter->twt_info;
+	u32 i, buff_sh;
+
+	if (!buf || !info->content) {
+		PLTFM_MSG_ERR("[ERR]stat rpt no buf\n");
+		return MACNPTR;
+	}
+
+	if (!twt_info) {
+		PLTFM_MSG_ERR("[ERR]no twt info\n");
+		return MACNPTR;
+	}
+
+	rpt.dword0 = le32_to_cpu(*(u32 *)info->content);
+
+	twt_info->err_rec = GET_FIELD(rpt.dword0, FWCMD_C2H_STAT_RPT_TWT_ERR_REC);
+	for (i = 0; i < TWT_DBG_INFO_SIZE; i += 4) {
+		buff_sh = 4 + i;
+		if (buff_sh >= info->content_len) {
+			*(u32 *)(twt_info->pdbg_info + i) = MAC_AX_R32_FF;
+		} else {
+			*(u32 *)(twt_info->pdbg_info + i) =
+				le32_to_cpu(*(u32 *)(info->content + buff_sh));
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+static struct c2h_proc_func c2h_proc_twt_cmd[] = {
+	{FWCMD_C2H_FUNC_WAIT_ANNOUNCE, c2h_wait_announ_hdl},
+	{FWCMD_C2H_FUNC_STAT_RPT, c2h_stat_rpt_hdl},
+	{FWCMD_C2H_FUNC_NULL, NULL}
+};
+
+u32 c2h_twt(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+	    struct rtw_c2h_info *info)
+{
+	struct c2h_proc_func *proc = c2h_proc_twt_cmd;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info) = NULL;
+	u32 hdr0;
+	u32 func;
+
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	while (proc->id != FWCMD_C2H_FUNC_NULL) {
+		if (func == proc->id) {
+			handler = proc->handler;
+			break;
+		}
+		proc++;
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]null func handler id: %X", func);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, buf, len, info);
+}
+
+u32 c2h_wow_aoac_report_hdl(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			    struct rtw_c2h_info *info)
+{
+	struct mac_ax_wowlan_info *wowlan_info = &adapter->wowlan_info;
+	u8 *c2h_content = buf + FWCMD_HDR_LEN;
+
+	if (adapter->sm.aoac_rpt != MAC_AX_AOAC_RPT_H2C_RCVD)
+		return MACPROCERR;
+
+	if (!wowlan_info->aoac_report)
+		return MACBUFALLOC;
+
+	PLTFM_MEMCPY(wowlan_info->aoac_report, c2h_content, sizeof(struct mac_ax_aoac_report));
+
+	adapter->sm.aoac_rpt = MAC_AX_AOAC_RPT_H2C_DONE;
+
+	return MACSUCCESS;
+}
+
+static struct c2h_proc_func c2h_proc_wow_cmd[] = {
+	{FWCMD_C2H_FUNC_AOAC_REPORT, c2h_wow_aoac_report_hdl},
+	{FWCMD_C2H_FUNC_NULL, NULL},
+};
+
+u32 c2h_wow(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+	    struct rtw_c2h_info *info)
+{
+	struct c2h_proc_func *proc = c2h_proc_wow_cmd;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info) = NULL;
+	u32 hdr0;
+	u32 func;
+
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	while (proc->id != FWCMD_C2H_FUNC_NULL) {
+		if (func == proc->id) {
+			handler = proc->handler;
+			break;
+		}
+		proc++;
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]null func handler id: %X", func);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, buf, len, info);
+}
+
+u32 c2h_mcc_rcv_ack_hdl(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			struct rtw_c2h_info *info)
+{
+	struct mac_ax_state_mach *sm = &adapter->sm;
+	u32 c2h_content = *(u32 *)(buf + FWCMD_HDR_LEN);
+	u8 group, h2c_func;
+
+	c2h_content = le32_to_cpu(c2h_content);
+	group = GET_FIELD(c2h_content, FWCMD_C2H_MCC_RCV_ACK_GROUP);
+	h2c_func = GET_FIELD(c2h_content, FWCMD_C2H_MCC_RCV_ACK_H2C_FUNC);
+
+	if (h2c_func <= FWCMD_H2C_FUNC_RESET_MCC_GROUP) {
+		PLTFM_MSG_TRACE("[TRACE]%s: MCC group H2C rcv ack\n",
+				__func__);
+
+		if (sm->mcc_group[group] == MAC_AX_MCC_STATE_H2C_SENT) {
+			sm->mcc_group[group] = MAC_AX_MCC_STATE_H2C_RCVD;
+
+			PLTFM_MSG_TRACE("[TRACE]%s: MCC group %d state: %d\n",
+					__func__, group,
+					MAC_AX_MCC_STATE_H2C_RCVD);
+		}
+	} else if (h2c_func <= FWCMD_H2C_FUNC_MCC_SET_DURATION) {
+		PLTFM_MSG_TRACE("[TRACE]%s: MCC request H2C rcv ack\n",
+				__func__);
+
+		if (sm->mcc_request[group] == MAC_AX_MCC_REQ_H2C_SENT) {
+			sm->mcc_request[group] = MAC_AX_MCC_REQ_H2C_RCVD;
+
+			PLTFM_MSG_TRACE("[TRACE]%s: MCC group %d state: %d\n",
+					__func__, group,
+					MAC_AX_MCC_REQ_H2C_RCVD);
+		}
+	} else {
+		PLTFM_MSG_ERR("[ERR]%s: invalid MCC H2C func %d\n",
+			      __func__, h2c_func);
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 c2h_mcc_req_ack_hdl(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			struct rtw_c2h_info *info)
+{
+	struct mac_ax_state_mach *sm = &adapter->sm;
+	u32 c2h_content = *(u32 *)(buf + FWCMD_HDR_LEN);
+	u8 group, h2c_func, h2c_return;
+
+	c2h_content = le32_to_cpu(c2h_content);
+	group = GET_FIELD(c2h_content, FWCMD_C2H_MCC_REQ_ACK_GROUP);
+	h2c_func = GET_FIELD(c2h_content, FWCMD_C2H_MCC_REQ_ACK_H2C_FUNC);
+	h2c_return = GET_FIELD(c2h_content, FWCMD_C2H_MCC_REQ_ACK_H2C_RETURN);
+
+	PLTFM_MSG_TRACE("[TRACE]%s: group: %d, h2c_func: %d, h2c_return: %d\n",
+			__func__, group, h2c_func, h2c_return);
+
+	if (h2c_func < FWCMD_H2C_FUNC_MCC_REQ_TSF) {
+		PLTFM_MSG_ERR("[ERR]%s: invalid MCC H2C func: %d\n",
+			      __func__, h2c_func);
+		return MACNOITEM;
+	}
+
+	sm->mcc_request_state[group] = h2c_return;
+
+	PLTFM_MSG_TRACE("[TRACE]%s: group %d curr req state: %d\n",
+			__func__, group, sm->mcc_request[group]);
+
+	if (sm->mcc_request[group] == MAC_AX_MCC_REQ_H2C_RCVD) {
+		if (h2c_return == 0) {
+			if (h2c_func == FWCMD_H2C_FUNC_MCC_REQ_TSF)
+				sm->mcc_request[group] = MAC_AX_MCC_REQ_DONE;
+			else
+				sm->mcc_request[group] = MAC_AX_MCC_REQ_IDLE;
+		} else {
+			sm->mcc_request[group] = MAC_AX_MCC_REQ_FAIL;
+			PLTFM_MSG_ERR("[ERR]%s: MCC H2C func %d fail: %d\n",
+				      __func__, h2c_func, h2c_return);
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+u32 c2h_mcc_tsf_rpt_hdl(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			struct rtw_c2h_info *info)
+{
+	struct mac_ax_mcc_group_info *mcc_info = &adapter->mcc_group_info;
+	struct fwcmd_mcc_tsf_rpt *tsf_rpt;
+	u32 c2h_content;
+	u32 tsf;
+	u8 macid_x, macid_y, group;
+
+	PLTFM_MSG_TRACE("[TRACE]%s: mcc tsf report received\n", __func__);
+
+	tsf_rpt = (struct fwcmd_mcc_tsf_rpt *)(buf + FWCMD_HDR_LEN);
+
+	c2h_content = tsf_rpt->dword0;
+	c2h_content = le32_to_cpu(c2h_content);
+	group = GET_FIELD(c2h_content, FWCMD_C2H_MCC_TSF_RPT_GROUP);
+	macid_x = GET_FIELD(c2h_content, FWCMD_C2H_MCC_TSF_RPT_MACID_X);
+	macid_y = GET_FIELD(c2h_content, FWCMD_C2H_MCC_TSF_RPT_MACID_Y);
+
+	PLTFM_MSG_TRACE("[TRACE]%s: group: %d, macid_x: %d, macid_y: %d\n",
+			__func__, group, macid_x, macid_y);
+
+	mcc_info->groups[group].macid_x = macid_x;
+	mcc_info->groups[group].macid_y = macid_y;
+
+	tsf = tsf_rpt->dword1;
+	tsf = le32_to_cpu(tsf);
+	mcc_info->groups[group].tsf_x_low = tsf;
+
+	tsf = tsf_rpt->dword2;
+	tsf = le32_to_cpu(tsf);
+	mcc_info->groups[group].tsf_x_high = tsf;
+
+	tsf = tsf_rpt->dword3;
+	tsf = le32_to_cpu(tsf);
+	mcc_info->groups[group].tsf_y_low = tsf;
+
+	tsf = tsf_rpt->dword4;
+	tsf = le32_to_cpu(tsf);
+	mcc_info->groups[group].tsf_y_high = tsf;
+
+	PLTFM_MSG_TRACE("[TRACE]%s: tsf_x_high: 0x%x, tsf_x_low: 0x%x\n",
+			__func__, mcc_info->groups[group].tsf_x_high,
+			mcc_info->groups[group].tsf_x_low);
+
+	PLTFM_MSG_TRACE("[TRACE]%s: tsf_y_high: 0x%x, tsf_y_low: 0x%x\n",
+			__func__, mcc_info->groups[group].tsf_y_high,
+			mcc_info->groups[group].tsf_y_low);
+
+	return MACSUCCESS;
+}
+
+u32 c2h_mcc_status_rpt_hdl(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			   struct rtw_c2h_info *info)
+{
+	struct mac_ax_mcc_group_info *mcc_info = &adapter->mcc_group_info;
+	struct mac_ax_state_mach *sm = &adapter->sm;
+	struct fwcmd_mcc_status_rpt *mcc_rpt;
+	u32 c2h_content;
+	u32 tsf_low;
+	u32 tsf_high;
+	u8 group, status, macid;
+
+	PLTFM_MSG_TRACE("[TRACE]%s: mcc status report received\n", __func__);
+
+	mcc_rpt = (struct fwcmd_mcc_status_rpt *)(buf + FWCMD_HDR_LEN);
+
+	c2h_content = mcc_rpt->dword0;
+	tsf_low = mcc_rpt->dword1;
+	tsf_high = mcc_rpt->dword2;
+
+	c2h_content = le32_to_cpu(c2h_content);
+	group = GET_FIELD(c2h_content, FWCMD_C2H_MCC_STATUS_RPT_GROUP);
+	macid = GET_FIELD(c2h_content, FWCMD_C2H_MCC_STATUS_RPT_MACID);
+	status = GET_FIELD(c2h_content, FWCMD_C2H_MCC_STATUS_RPT_STATUS);
+
+	PLTFM_MSG_TRACE("[TRACE]%s: mcc group: %d, macid: %d, status: %d\n",
+			__func__, group, macid, status);
+
+	sm->mcc_group_state[group] = status;
+
+	switch (status) {
+	case MAC_AX_MCC_ADD_ROLE_OK:
+		if (sm->mcc_group[group] == MAC_AX_MCC_STATE_H2C_RCVD) {
+			sm->mcc_group[group] = MAC_AX_MCC_ADD_DONE;
+			PLTFM_MSG_TRACE("[TRACE]%s: mcc group %d add done\n",
+					__func__, group);
+		}
+		break;
+
+	case MAC_AX_MCC_START_GROUP_OK:
+		if (sm->mcc_group[group] == MAC_AX_MCC_STATE_H2C_RCVD) {
+			sm->mcc_group[group] = MAC_AX_MCC_START_DONE;
+			PLTFM_MSG_TRACE("[TRACE]%s: mcc group %d start done\n",
+					__func__, group);
+		}
+		break;
+
+	case MAC_AX_MCC_STOP_GROUP_OK:
+		sm->mcc_group[group] = MAC_AX_MCC_STOP_DONE;
+		PLTFM_MSG_TRACE("[TRACE]%s: mcc group %d stop done\n",
+				__func__, group);
+		break;
+
+	case MAC_AX_MCC_DEL_GROUP_OK:
+		sm->mcc_group[group] = MAC_AX_MCC_EMPTY;
+		PLTFM_MSG_TRACE("[TRACE]%s: mcc group %d empty\n",
+				__func__, group);
+		break;
+
+	case MAC_AX_MCC_RESET_GROUP_OK:
+		if (sm->mcc_group[group] == MAC_AX_MCC_STATE_H2C_RCVD) {
+			sm->mcc_group[group] = MAC_AX_MCC_EMPTY;
+			PLTFM_MSG_TRACE("[TRACE]%s: mcc group %d empty\n",
+					__func__, group);
+		}
+		break;
+
+	case MAC_AX_MCC_EMPTY_GRP_FAIL:
+	case MAC_AX_MCC_ROLE_NOT_EXIST_FAIL:
+	case MAC_AX_MCC_DATA_NOT_FOUND_FAIL:
+	case MAC_AX_MCC_ACT_INVALID_FAIL:
+	case MAC_AX_MCC_BANDTYPE_INVALID_FAIL:
+	case MAC_AX_MCC_ADD_PSTIMER_FAIL:
+	case MAC_AX_MCC_MALLOC_FAIL:
+	case MAC_AX_MCC_SWITCH_CH_FAIL:
+	case MAC_AX_MCC_TXNULL0_FAIL:
+		if (sm->mcc_group[group] == MAC_AX_MCC_STATE_H2C_RCVD) {
+			PLTFM_MSG_ERR("[ERR]%s: mcc group %d fail status: %d\n",
+				      __func__, group, status);
+			sm->mcc_group[group] = MAC_AX_MCC_STATE_ERROR;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	tsf_low = le32_to_cpu(tsf_low);
+	tsf_high = le32_to_cpu(tsf_high);
+
+	mcc_info->groups[group].rpt_status = status;
+	mcc_info->groups[group].rpt_macid = macid;
+	mcc_info->groups[group].rpt_tsf_low = tsf_low;
+	mcc_info->groups[group].rpt_tsf_high = tsf_high;
+
+	PLTFM_MSG_TRACE("[TRACE]%s: tsf_high: 0x%x, tsf_low: 0x%x\n",
+			__func__, tsf_high, tsf_low);
+
+	return MACSUCCESS;
+}
+
+static struct c2h_proc_func c2h_proc_mcc_cmd[] = {
+	{FWCMD_C2H_FUNC_MCC_RCV_ACK, c2h_mcc_rcv_ack_hdl},
+	{FWCMD_C2H_FUNC_MCC_REQ_ACK, c2h_mcc_req_ack_hdl},
+	{FWCMD_C2H_FUNC_MCC_TSF_RPT, c2h_mcc_tsf_rpt_hdl},
+	{FWCMD_C2H_FUNC_MCC_STATUS_RPT, c2h_mcc_status_rpt_hdl},
+	{FWCMD_C2H_FUNC_NULL, NULL},
+};
+
+u32 c2h_mcc(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+	    struct rtw_c2h_info *info)
+{
+	struct c2h_proc_func *proc = c2h_proc_mcc_cmd;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info) = NULL;
+	u32 hdr0;
+	u32 func;
+
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	PLTFM_MSG_TRACE("[TRACE]%s: func: %d\n", __func__, func);
+
+	while (proc->id != FWCMD_C2H_FUNC_NULL) {
+		if (func == proc->id) {
+			handler = proc->handler;
+			break;
+		}
+		proc++;
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]%s: null func handler id: %X",
+			      __func__, func);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, buf, len, info);
+}
+
+u32 c2h_rx_dbg_hdl(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		   struct rtw_c2h_info *info)
+{
+	PLTFM_MSG_ERR("[ERR]%s: FW encounter Rx problem!\n", __func__);
+
+	return MACSUCCESS;
+}
+
+static struct c2h_proc_func c2h_proc_fw_dbg_cmd[] = {
+	{FWCMD_C2H_FUNC_RX_DBG, c2h_rx_dbg_hdl},
+	{FWCMD_C2H_FUNC_NULL, NULL},
+};
+
+u32 c2h_fw_dbg(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+	       struct rtw_c2h_info *info)
+{
+	struct c2h_proc_func *proc = c2h_proc_fw_dbg_cmd;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info) = NULL;
+	u32 hdr0;
+	u32 func;
+
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	PLTFM_MSG_TRACE("[TRACE]%s: func: %d\n", __func__, func);
+
+	while (proc->id != FWCMD_C2H_FUNC_NULL) {
+		if (func == proc->id) {
+			handler = proc->handler;
+			break;
+		}
+		proc++;
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]%s: null func handler id: %X",
+			      __func__, func);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, buf, len, info);
+}
+
+u32 c2h_wps_rpt(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		struct rtw_c2h_info *info)
+{
+	PLTFM_MSG_TRACE("recevied wps report\n");
+	return MACSUCCESS;
+}
+
+static u32 c2h_misc_ccxrpt(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			   struct rtw_c2h_info *info)
+{
+	return MACSUCCESS;
+}
+
+static struct c2h_proc_func c2h_proc_misc[] = {
+	{FWCMD_C2H_FUNC_WPS_RPT, c2h_wps_rpt},
+	{FWCMD_C2H_FUNC_CCXRPT, c2h_misc_ccxrpt},
+	{FWCMD_C2H_FUNC_NULL, NULL},
+};
+
+static u32 c2h_cl_misc(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info)
+{
+	struct c2h_proc_func *proc = c2h_proc_misc;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info) = NULL;
+	u32 hdr0;
+	u32 func;
+
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	while (proc->id != FWCMD_C2H_FUNC_NULL) {
+		if (func == proc->id) {
+			handler = proc->handler;
+			break;
+		}
+		proc++;
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]null func handler id: %X", func);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, buf, len, info);
+}
+
+u32 c2h_fast_ch_sw_rpt_hdl(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			   struct rtw_c2h_info *info)
+{
+	u32 *c2h_content;
+	u32 *rpt_status;
+
+	PLTFM_MSG_TRACE("[HM][C2H][FCS] get rpt func\n");
+	adapter->fast_ch_sw_info.busy = 0;
+	c2h_content = (u32 *)(buf + FWCMD_HDR_LEN);
+	rpt_status = &adapter->fast_ch_sw_info.status;
+	PLTFM_MEMCPY(rpt_status, c2h_content, sizeof(u32));
+	PLTFM_MSG_TRACE("[HM][C2H][FCS] Report Status: 0x%x\n",  adapter->fast_ch_sw_info.status);
+
+	return MACSUCCESS;
+}
+
+static struct c2h_proc_func c2h_proc_fast_ch_sw_cmd[] = {
+	{FWCMD_C2H_FUNC_FCS_RPT, c2h_fast_ch_sw_rpt_hdl},
+	{FWCMD_C2H_FUNC_NULL, NULL},
+};
+
+u32 c2h_fast_ch_sw(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		   struct rtw_c2h_info *info)
+{
+	u32 hdr0;
+	u32 func;
+	u32 (*handler)(struct mac_ax_adapter *adpater, u8 *buf,
+		       u32 len, struct rtw_c2h_info *info);
+	struct c2h_proc_func *proc;
+
+	proc = c2h_proc_fast_ch_sw_cmd;
+	handler = NULL;
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	while (proc->id != FWCMD_C2H_FUNC_NULL) {
+		if (func == proc->id) {
+			handler = proc->handler;
+			break;
+		}
+		proc++;
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR][%s]: sent id = %x", __func__, func);
+		return MACNOITEM;
+	}
+
+	return  handler(adapter, buf, len, info);
+}
+
+u32 c2h_port_init_stat(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info)
+{
+	struct fwcmd_port_init_stat stat;
+	struct mac_ax_port_info *pinfo;
+	u8 band, port;
+	u32 ret, tmp32;
+
+	stat.dword0 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN));
+	stat.dword1 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 4));
+	stat.dword2 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 8));
+
+	band = stat.dword0 & FWCMD_C2H_PORT_INIT_STAT_BAND;
+	if (band >= MAC_AX_BAND_NUM) {
+		PLTFM_MSG_ERR("[ERR]invalid band %d in port init stat\n", band);
+		return MACNOITEM;
+	}
+
+	port = GET_FIELD(stat.dword0, FWCMD_C2H_PORT_INIT_STAT_PORT);
+	if (port >= MAC_AX_PORT_NUM) {
+		PLTFM_MSG_ERR("[ERR]invalid port %d in port init stat\n", port);
+		return MACNOITEM;
+	}
+
+	pinfo = &adapter->port_info[get_bp_idx(band, port)];
+
+	ret = GET_FIELD(stat.dword2, FWCMD_C2H_PORT_INIT_STAT_RET);
+	if (ret != C2H_MPORT_RET_SUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d init fail: ret %d\n",
+			      band, port, ret);
+		tmp32 = GET_FIELD(stat.dword0, FWCMD_C2H_PORT_INIT_STAT_STEP);
+		PLTFM_MSG_ERR("[ERR]B%dP%d init fail: step %d\n",
+			      band, port, tmp32);
+		tmp32 = GET_FIELD(stat.dword0, FWCMD_C2H_PORT_INIT_STAT_CFG_MBID_IDX);
+		PLTFM_MSG_ERR("[ERR]B%dP%d init fail: cfg mbid %d\n",
+			      band, port, tmp32);
+		tmp32 = GET_FIELD(stat.dword0, FWCMD_C2H_PORT_INIT_STAT_CFG_TYPE);
+		PLTFM_MSG_ERR("[ERR]B%dP%d init fail: cfg type %d\n",
+			      band, port, tmp32);
+		tmp32 = GET_FIELD(stat.dword1, FWCMD_C2H_PORT_INIT_STAT_CFG_VAL);
+		PLTFM_MSG_ERR("[ERR]B%dP%d init fail: cfg val %d\n",
+			      band, port, tmp32);
+		pinfo->h2c_sm = MAC_AX_PORT_H2C_FAIL;
+	} else {
+		pinfo->h2c_sm = MAC_AX_PORT_H2C_IDLE;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 c2h_port_cfg_stat(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		      struct rtw_c2h_info *info)
+{
+	struct fwcmd_port_cfg_stat stat;
+	struct mac_ax_port_info *pinfo;
+	u8 band, port, mbssid;
+	u32 ret, tmp32;
+
+	stat.dword0 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN));
+	stat.dword1 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 4));
+	stat.dword2 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 8));
+
+	band = stat.dword0 & FWCMD_C2H_PORT_CFG_STAT_BAND;
+	if (band >= MAC_AX_BAND_NUM) {
+		PLTFM_MSG_ERR("[ERR]invalid band %d in port cfg stat\n", band);
+		return MACNOITEM;
+	}
+
+	port = GET_FIELD(stat.dword0, FWCMD_C2H_PORT_CFG_STAT_PORT);
+	if (port >= MAC_AX_PORT_NUM) {
+		PLTFM_MSG_ERR("[ERR]invalid port %d in port cfg stat\n", port);
+		return MACNOITEM;
+	}
+
+	pinfo = &adapter->port_info[get_bp_idx(band, port)];
+	mbssid = GET_FIELD(stat.dword0, FWCMD_C2H_PORT_CFG_STAT_MBSSID_IDX);
+
+	ret = GET_FIELD(stat.dword2, FWCMD_C2H_PORT_CFG_STAT_RET);
+	if (ret != C2H_MPORT_RET_SUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%dMB%d cfg fail: ret %d\n",
+			      band, port, mbssid, ret);
+		tmp32 = GET_FIELD(stat.dword0, FWCMD_C2H_PORT_CFG_STAT_TYPE);
+		PLTFM_MSG_ERR("[ERR]B%dP%dMB%d cfg fail: type %d\n",
+			      band, port, mbssid, tmp32);
+		tmp32 = GET_FIELD(stat.dword1, FWCMD_C2H_PORT_CFG_STAT_VAL);
+		PLTFM_MSG_ERR("[ERR]B%dP%dMB%d cfg fail: val %d\n",
+			      band, port, mbssid, tmp32);
+		pinfo->h2c_sm = MAC_AX_PORT_H2C_FAIL;
+	} else {
+		pinfo->h2c_sm = MAC_AX_PORT_H2C_IDLE;
+	}
+
+	return MACSUCCESS;
+}
+
+static struct c2h_proc_func c2h_proc_mport[] = {
+	{FWCMD_C2H_FUNC_PORT_INIT_STAT, c2h_port_init_stat},
+	{FWCMD_C2H_FUNC_PORT_CFG_STAT, c2h_port_cfg_stat},
+	{FWCMD_C2H_FUNC_NULL, NULL},
+};
+
+static u32 c2h_cl_mport(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			struct rtw_c2h_info *info)
+{
+	struct c2h_proc_func *proc = c2h_proc_mport;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info) = NULL;
+	u32 hdr0;
+	u32 func;
+
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	while (proc->id != FWCMD_C2H_FUNC_NULL) {
+		if (func == proc->id) {
+			handler = proc->handler;
+			break;
+		}
+		proc++;
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]null func handler id: %X", func);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, buf, len, info);
+}
+
+u32 c2h_nan_act_req_ack_hdl(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			    struct rtw_c2h_info *info)
+{
+	struct fwcmd_act_schedule_req_ack act_schedule;
+	struct mac_ax_act_ack_info *ack_info;
+
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]nan act schedule req ack no buf\n");
+		return MACNPTR;
+	}
+
+	act_schedule.dword0 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN));
+	act_schedule.dword1 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 4));
+	ack_info = &adapter->nan_info.nan_act_ack_info;
+	ack_info->schedule_id = GET_FIELD(act_schedule.dword1,
+					  FWCMD_C2H_ACT_SCHEDULE_REQ_ACK_SCHEDULE_ID);
+	PLTFM_MSG_TRACE("[test]nan act schedule req ack moduleid %d\n", ack_info->schedule_id);
+	return MACSUCCESS;
+}
+
+u32 c2h_nan_cluster_info_hdl(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+			     struct rtw_c2h_info *info)
+{
+	struct fwcmd_nan_info_notify_cluster_info cluster_info;
+	struct mac_ax_nan_info *nan_info;
+
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]nan cluster info ack no buf\n");
+		return MACNPTR;
+	}
+
+	cluster_info.dword0 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN));
+	cluster_info.dword1 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 4));
+	cluster_info.dword2 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 8));
+	cluster_info.dword3 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 12));
+	cluster_info.dword4 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 16));
+	cluster_info.dword5 = le32_to_cpu(*(u32 *)(buf + FWCMD_HDR_LEN + 20));
+
+	nan_info = &adapter->nan_info;
+
+	nan_info->rpt_cluster_id[0] = GET_FIELD(cluster_info.dword1,
+						FWCMD_C2H_NAN_INFO_NOTIFY_CLUSTER_INFO_CLUSTER_ID0);
+	nan_info->rpt_cluster_id[1] = GET_FIELD(cluster_info.dword1,
+						FWCMD_C2H_NAN_INFO_NOTIFY_CLUSTER_INFO_CLUSTER_ID1);
+	nan_info->rpt_cluster_id[2] = GET_FIELD(cluster_info.dword1,
+						FWCMD_C2H_NAN_INFO_NOTIFY_CLUSTER_INFO_CLUSTER_ID2);
+	nan_info->rpt_cluster_id[3] = GET_FIELD(cluster_info.dword1,
+						FWCMD_C2H_NAN_INFO_NOTIFY_CLUSTER_INFO_CLUSTER_ID3);
+	nan_info->rpt_cluster_id[4] = GET_FIELD(cluster_info.dword2,
+						FWCMD_C2H_NAN_INFO_NOTIFY_CLUSTER_INFO_CLUSTER_ID4);
+	nan_info->rpt_cluster_id[5] = GET_FIELD(cluster_info.dword2,
+						FWCMD_C2H_NAN_INFO_NOTIFY_CLUSTER_INFO_CLUSTER_ID5);
+	nan_info->rpt_master_pref = GET_FIELD(cluster_info.dword2,
+					      FWCMD_C2H_NAN_INFO_NOTIFY_CLUSTER_INFO_MASTERPREF);
+	nan_info->rpt_random_factor =
+		GET_FIELD(cluster_info.dword2, FWCMD_C2H_NAN_INFO_NOTIFY_CLUSTER_INFO_RANDOMFACTOR);
+	nan_info->rpt_amr = GET_FIELD(cluster_info.dword3,
+				      FWCMD_C2H_NAN_INFO_NOTIFY_CLUSTER_INFO_AMR);
+	nan_info->rpt_ambtt = GET_FIELD(cluster_info.dword4,
+					FWCMD_C2H_NAN_INFO_NOTIFY_CLUSTER_INFO_AMBTT);
+	nan_info->rpt_hop_count = GET_FIELD(cluster_info.dword5,
+					    FWCMD_C2H_NAN_INFO_NOTIFY_CLUSTER_INFO_HOPCOUNT);
+
+	PLTFM_MSG_TRACE("[test]nan rpt_ambtt %d\n", nan_info->rpt_ambtt);
+	return MACSUCCESS;
+}
+
+static struct c2h_proc_func c2h_proc_nan_cmd[] = {
+	{FWCMD_C2H_FUNC_ACT_SCHEDULE_REQ_ACK, c2h_nan_act_req_ack_hdl},
+	{FWCMD_C2H_FUNC_BCN_REQ_ACK, c2h_nan_act_req_ack_hdl},
+	{FWCMD_C2H_FUNC_NAN_FUNC_CTRL_ACK, c2h_nan_act_req_ack_hdl},
+	{FWCMD_C2H_FUNC_NAN_DE_INFO_ACK, c2h_nan_act_req_ack_hdl},
+	{FWCMD_C2H_FUNC_NAN_JOIN_CLUSTER_ACK, c2h_nan_act_req_ack_hdl},
+	{FWCMD_C2H_FUNC_NAN_PAUSE_FAW_TX_ACK, c2h_nan_act_req_ack_hdl},
+	{FWCMD_C2H_FUNC_NAN_INFO_NOTIFY_CLUSTER_INFO, c2h_nan_cluster_info_hdl},
+	//{FWCMD_C2H_FUNC_NAN_INFO_NOTIFY_CLUSTER_JOIN, c2h_nan_join_info_hdl},
+	{FWCMD_C2H_FUNC_NULL, NULL},
+};
+
+u32 c2h_nan(struct mac_ax_adapter *adapter, u8 *buf, u32 len, struct rtw_c2h_info *info)
+{
+	struct c2h_proc_func *proc = c2h_proc_nan_cmd;
+	u32(*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		      struct rtw_c2h_info *info) = NULL;
+	u32 hdr0;
+	u32 func;
+
+	hdr0 = ((struct fwcmd_hdr *)buf)->hdr0;
+	hdr0 = le32_to_cpu(hdr0);
+
+	func = GET_FIELD(hdr0, C2H_HDR_FUNC);
+
+	PLTFM_MSG_TRACE("[TRACE]%s: func: %d\n", __func__, func);
+
+	while (proc->id != FWCMD_C2H_FUNC_NULL) {
+		if (func == proc->id) {
+			handler = proc->handler;
+			break;
+		}
+		proc++;
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]%s: null func handler id: %X", __func__, func);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, buf, len, info);
+}
+
+static struct c2h_proc_class c2h_proc_sys[] = {
+#if MAC_AX_FEATURE_DBGPKG
+	{FWCMD_C2H_CL_CMD_PATH, c2h_sys_cmd_path},
+	{FWCMD_H2C_CL_PLAT_AUTO_TEST, c2h_sys_plat_autotest},
+#if MAC_AX_FEATURE_HV
+	{FWCMD_C2H_CL_FW_AUTO, c2h_sys_fw_autotest},
+#endif
+#endif
+	{FWCMD_C2H_CL_FW_STATUS, c2h_fw_status},
+	{FWCMD_C2H_CL_NULL, NULL},
+};
+
+static struct c2h_proc_class c2h_proc_mac[] = {
+	{FWCMD_C2H_CL_FW_INFO, c2h_fw_info},
+	{FWCMD_C2H_CL_FW_OFLD, c2h_fw_ofld},
+	{FWCMD_C2H_CL_TWT, c2h_twt},
+	{FWCMD_C2H_CL_WOW, c2h_wow},
+	{FWCMD_C2H_CL_MCC, c2h_mcc},
+	{FWCMD_C2H_CL_FW_DBG, c2h_fw_dbg},
+	{FWCMD_C2H_CL_FLASH, c2h_sys_flash_pkt},
+	{FWCMD_C2H_CL_MISC, c2h_cl_misc},
+	{FWCMD_C2H_CL_FCS, c2h_fast_ch_sw},
+	{FWCMD_C2H_CL_MPORT, c2h_cl_mport},
+	{FWCMD_C2H_CL_NAN, c2h_nan},
+	{FWCMD_C2H_CL_NULL, NULL},
+};
+
+static inline struct c2h_proc_class *c2h_proc_sel(u8 cat)
+{
+	struct c2h_proc_class *proc;
+
+	switch (cat) {
+	case FWCMD_C2H_CAT_TEST:
+		proc = c2h_proc_sys;
+		break;
+	case FWCMD_C2H_CAT_MAC:
+		proc = c2h_proc_mac;
+		break;
+	default:
+		proc = NULL;
+		break;
+	}
+
+	return proc;
+}
+
+u8 c2h_field_parsing(struct fwcmd_hdr *hdr, struct rtw_c2h_info *info)
+{
+	u32 val;
+
+	val = le32_to_cpu(hdr->hdr0);
+	info->c2h_cat = GET_FIELD(val, C2H_HDR_CAT);
+	info->c2h_class = GET_FIELD(val, C2H_HDR_CLASS);
+	info->c2h_func = GET_FIELD(val, C2H_HDR_FUNC);
+
+	val = le32_to_cpu(hdr->hdr1);
+	info->content_len = GET_FIELD(val, C2H_HDR_TOTAL_LEN) -
+				FWCMD_HDR_LEN;
+	info->content = (u8 *)(hdr + 1);
+
+	return MACSUCCESS;
+}
+
+u32 mac_process_c2h(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		    u8 *ret)
+{
+	u8 _class_, result;
+	struct c2h_proc_class *proc;
+	struct fwcmd_hdr *hdr;
+	struct rtw_c2h_info *info;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info) = NULL;
+	u8 cat;
+	u32 val;
+
+	hdr = (struct fwcmd_hdr *)buf;
+
+	info = (struct rtw_c2h_info *)ret;
+	val = le32_to_cpu(hdr->hdr0);
+
+	result = c2h_field_parsing(hdr, info);
+	if (result) {
+		PLTFM_MSG_ERR("[ERR]parsing c2h hdr error: %X\n", val);
+		return MACNOITEM;
+	}
+
+	if (GET_FIELD(val, C2H_HDR_DEL_TYPE) != FWCMD_TYPE_C2H) {
+		PLTFM_MSG_ERR("[ERR]wrong fwcmd type: %X\n", val);
+		return MACNOITEM;
+	}
+
+	cat = (u8)GET_FIELD(val, C2H_HDR_CAT);
+
+	if (cat == FWCMD_C2H_CAT_OUTSRC)
+		return MACSUCCESS;
+
+	proc = c2h_proc_sel(cat);
+	if (!proc) {
+		PLTFM_MSG_ERR("[ERR]wrong fwcmd cat: %X\n", val);
+		return MACNOITEM;
+	}
+
+	_class_ = GET_FIELD(val, C2H_HDR_CLASS);
+
+	for (; proc->id != FWCMD_C2H_CL_NULL; proc++) {
+		if (_class_ == proc->id) {
+			handler = proc->handler;
+			break;
+		}
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]null class handler id: %X", proc->id);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, buf, len, info);
+}
+
+u32 mac_outsrc_h2c_common(struct mac_ax_adapter *adapter,
+			  struct rtw_g6_h2c_hdr *hdr, u32 *pvalue)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_outsrc_info *info;
+
+	/*temp workaround for h2cb no functionality and outsrc has its timer*/
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_ERR("FW is not ready\n");
+		return MACFWNONRDY;
+	}
+
+	h2cb = h2cb_alloc(adapter, (enum h2c_buf_class)hdr->type);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, hdr->content_len);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+	info = (struct fwcmd_outsrc_info *)buf;
+	PLTFM_MEMCPY(info->dword0, pvalue, hdr->content_len);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_OUTSRC,
+			      hdr->h2c_class,
+			      hdr->h2c_func,
+			      hdr->rec_ack,
+			      hdr->done_ack);
+	if (ret)
+		goto fail;
+
+	// Return MACSUCCESS if h2c aggregation is enabled and enqueued successfully.
+	// The H2C shall be sent by mac_h2c_agg_tx.
+	ret = h2c_agg_enqueue(adapter, h2cb);
+	if (ret == MACSUCCESS)
+		return MACSUCCESS;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_fw_log_cfg(struct mac_ax_adapter *adapter,
+		   struct mac_ax_fw_log *log_cfg)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_log_cfg *log;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_log_cfg));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+	PLTFM_MEMSET(buf, 0, sizeof(struct fwcmd_log_cfg));
+
+	log = (struct fwcmd_log_cfg *)buf;
+
+	log->dword0 = cpu_to_le32(SET_WORD(log_cfg->level,
+					   FWCMD_H2C_LOG_CFG_DBG_LV) |
+				  SET_WORD(log_cfg->output,
+					   FWCMD_H2C_LOG_CFG_PATH));
+	log->dword1 = cpu_to_le32(log_cfg->comp);
+
+	log->dword2 = cpu_to_le32(log_cfg->comp_ext);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_INFO,
+			      FWCMD_H2C_FUNC_LOG_CFG,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_send_bcn_h2c(struct mac_ax_adapter *adapter,
+		     struct mac_ax_bcn_info *info)
+{
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	struct fwcmd_bcn_upd_v1 *hdr;
+	u32 ret = MACSUCCESS;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_bcn_upd_v1 *)
+		h2cb_put(h2cb, sizeof(struct fwcmd_bcn_upd_v1));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	info->grp_ie_ofst |= info->grp_ie_ofst ? BCN_GRPIE_OFST_EN : 0;
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(info->port,
+				     FWCMD_H2C_BCN_UPD_V1_PORT) |
+			    SET_WORD(info->mbssid,
+				     FWCMD_H2C_BCN_UPD_V1_MBSSID) |
+			    SET_WORD(info->band,
+				     FWCMD_H2C_BCN_UPD_V1_BAND) |
+			    SET_WORD(info->grp_ie_ofst,
+				     FWCMD_H2C_BCN_UPD_V1_GRP_IE_OFST));
+
+	hdr->dword1 =
+		cpu_to_le32(SET_WORD(info->macid,
+				     FWCMD_H2C_BCN_UPD_V1_MACID) |
+			    SET_WORD(info->ssn_sel,
+				     FWCMD_H2C_BCN_UPD_V1_SSN_SEL) |
+			    SET_WORD(info->ssn_mode,
+				     FWCMD_H2C_BCN_UPD_V1_SSN_MODE) |
+			    SET_WORD(info->rate_sel,
+				     FWCMD_H2C_BCN_UPD_V1_RATE) |
+			    SET_WORD(info->txpwr,
+				     FWCMD_H2C_BCN_UPD_V1_TXPWR) |
+			    FWCMD_H2C_BCN_UPD_V1_ECSA_SUPPORT);
+
+	hdr->dword2 =
+		cpu_to_le32((info->txinfo_ctrl_en ?
+			     FWCMD_H2C_BCN_UPD_V1_TXINFO_CTRL_EN : 0) |
+			    SET_WORD(info->ntx_path_en,
+				     FWCMD_H2C_BCN_UPD_V1_NTX_PATH_EN) |
+			    SET_WORD(info->path_map_a,
+				     FWCMD_H2C_BCN_UPD_V1_PATH_MAP_A) |
+			    SET_WORD(info->path_map_b,
+				     FWCMD_H2C_BCN_UPD_V1_PATH_MAP_B) |
+			    SET_WORD(info->path_map_c,
+				     FWCMD_H2C_BCN_UPD_V1_PATH_MAP_C) |
+			    SET_WORD(info->path_map_d,
+				     FWCMD_H2C_BCN_UPD_V1_PATH_MAP_D) |
+			    (info->antsel_a ?
+			     FWCMD_H2C_BCN_UPD_V1_ANTSEL_A : 0) |
+			    (info->antsel_b ?
+			     FWCMD_H2C_BCN_UPD_V1_ANTSEL_B : 0) |
+			    (info->antsel_c ?
+			     FWCMD_H2C_BCN_UPD_V1_ANTSEL_C : 0) |
+			    (info->antsel_d ?
+			     FWCMD_H2C_BCN_UPD_V1_ANTSEL_D : 0) |
+			     SET_WORD(info->csa_ofst,
+				      FWCMD_H2C_BCN_UPD_V1_CSA_OFST));
+	hdr->dword3 =
+		cpu_to_le32(SET_WORD(info->ecsa_ofst,
+				     FWCMD_H2C_BCN_UPD_V1_ECSA_OFST));
+
+	buf = h2cb_put(h2cb, info->pld_len);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	PLTFM_MEMCPY(buf, info->pld_buf, info->pld_len);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FR_EXCHG,
+			      FWCMD_H2C_FUNC_BCN_UPD_V1,
+			      0,
+			      0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_host_getpkt_h2c(struct mac_ax_adapter *adapter, u8 macid, u8 pkttype)
+{
+	struct mac_ax_h2creg_info content = {0};
+	u32 ret;
+
+	content.id = FWCMD_H2CREG_FUNC_GETPKT_INFORM;
+	content.content_len = 4;
+	content.h2c_content.dword0 =
+				SET_WORD(macid,
+					 FWCMD_H2CREG_GETPKT_INFORM_MACID) |
+				SET_WORD(pkttype,
+					 FWCMD_H2CREG_GETPKT_INFORM_PKTTYPE);
+
+	ret = proc_msg_reg(adapter, &content, NULL);
+
+	return ret;
+}
+
+#if MAC_AX_PHL_H2C
+u32 __ie_cam_set_cmd(struct mac_ax_adapter *adapter, struct rtw_h2c_pkt *h2cb,
+		     struct mac_ax_ie_cam_cmd_info *info)
+{
+	struct fwcmd_ie_cam *cmd;
+	u8 *buf;
+	u32 ret = MACSUCCESS;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_ie_cam));
+	if (!buf) {
+		ret = MACNOBUF;
+		return ret;
+	}
+
+	cmd = (struct fwcmd_ie_cam *)buf;
+	cmd->dword0 =
+		cpu_to_le32((info->en ? FWCMD_H2C_IE_CAM_CAM_EN : 0) |
+			    (info->band ? FWCMD_H2C_IE_CAM_BAND : 0) |
+			    (info->hit_en ? FWCMD_H2C_IE_CAM_HIT_FRWD_EN : 0) |
+			    (info->miss_en ?
+			     FWCMD_H2C_IE_CAM_MISS_FRWD_EN : 0) |
+			    (info->rst ? FWCMD_H2C_IE_CAM_RST : 0) |
+			    SET_WORD(info->port, FWCMD_H2C_IE_CAM_PORT) |
+			    SET_WORD(info->hit_sel, FWCMD_H2C_IE_CAM_HIT_FRWD) |
+			    SET_WORD(info->miss_sel,
+				     FWCMD_H2C_IE_CAM_MISS_FRWD) |
+			    SET_WORD(info->num, FWCMD_H2C_IE_CAM_UPD_NUM));
+
+	buf = h2cb_put(h2cb, info->buf_len);
+	if (!buf) {
+		ret = MACNOBUF;
+		return ret;
+	}
+
+	PLTFM_MEMCPY(buf, info->buf, info->buf_len);
+
+	return ret;
+}
+
+#else
+u32 __ie_cam_set_cmd(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb,
+		     struct mac_ax_ie_cam_cmd_info *info)
+{
+	struct fwcmd_ie_cam *cmd;
+	u8 *buf;
+	u32 ret = MACSUCCESS;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_ie_cam));
+	if (!buf) {
+		ret = MACNOBUF;
+		return ret;
+	}
+
+	cmd = (struct fwcmd_ie_cam *)buf;
+	cmd->dword0 =
+		cpu_to_le32((info->en ? FWCMD_H2C_IE_CAM_CAM_EN : 0) |
+			    (info->band ? FWCMD_H2C_IE_CAM_BAND : 0) |
+			    (info->hit_en ? FWCMD_H2C_IE_CAM_HIT_FRWD_EN : 0) |
+			    (info->miss_en ?
+			     FWCMD_H2C_IE_CAM_MISS_FRWD_EN : 0) |
+			    (info->rst ? FWCMD_H2C_IE_CAM_RST : 0) |
+			    SET_WORD(info->port, FWCMD_H2C_IE_CAM_PORT) |
+			    SET_WORD(info->hit_sel, FWCMD_H2C_IE_CAM_HIT_FRWD) |
+			    SET_WORD(info->miss_sel,
+				     FWCMD_H2C_IE_CAM_MISS_FRWD) |
+			    SET_WORD(info->num, FWCMD_H2C_IE_CAM_UPD_NUM));
+
+	buf = h2cb_put(h2cb, info->buf_len);
+	if (!buf) {
+		ret = MACNOBUF;
+		return ret;
+	}
+
+	PLTFM_MEMCPY(buf, info->buf, info->buf_len);
+
+	return ret;
+}
+#endif
+u32 mac_ie_cam_upd(struct mac_ax_adapter *adapter,
+		   struct mac_ax_ie_cam_cmd_info *info)
+{
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u32 ret;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	ret = __ie_cam_set_cmd(adapter, h2cb, info);
+	if (ret) {
+		PLTFM_MSG_ERR("H2C IE CAM set cmd fail %d\n", ret);
+		goto fail;
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_IE_CAM,
+			      FWCMD_H2C_FUNC_IE_CAM, 0, 1);
+	if (ret) {
+		PLTFM_MSG_ERR("H2C IE CAM set hdr fail %d\n", ret);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("H2C IE CAM build txd fail %d\n", ret);
+		goto fail;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("H2C IE CAM tx fail %d\n", ret);
+		goto fail;
+	}
+
+fail:
+	h2cb_free(adapter, h2cb);
+
+	if (!ret)
+		h2c_end_flow(adapter);
+
+	return ret;
+}
+
+u32 _mac_send_h2creg(struct mac_ax_adapter *adapter,
+		     struct mac_ax_h2creg_info *h2c)
+{
+#define MAC_AX_H2CREG_CNT 100
+#define MAC_AX_H2CREG_US 200
+	u32 cnt = MAC_AX_H2CREG_CNT;
+	u8 len, byte0, byte1, val;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct fwcmd_h2creg h2creg;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_h2creg_offset *h2creg_offset;
+
+	if (!h2c)
+		return MACSUCCESS;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_ERR("FW is not ready\n");
+		return MACFWNONRDY;
+	}
+
+	if (adapter->sm.mac_rdy != MAC_AX_MAC_RDY) {
+		PLTFM_MSG_TRACE("MAC is not ready\n");
+		adapter->stats.h2c_reg_uninit++;
+	}
+
+	h2creg_offset = p_ops->get_h2creg_offset(adapter);
+	if (!h2creg_offset) {
+		PLTFM_MSG_ERR("Get H2CREG offset FAIL\n");
+		return MACNPTR;
+	}
+
+	do {
+		if (!(MAC_REG_R8(h2creg_offset->ctrl) & B_AX_H2CREG_TRIGGER))
+			break;
+		PLTFM_DELAY_US(MAC_AX_H2CREG_US);
+		cnt--;
+	} while (cnt);
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("FW does not process H2CREG\n");
+		return MACPOLLTO;
+	}
+
+	if (h2c->content_len > H2CREG_CONTENT_LEN) {
+		PLTFM_MSG_ERR("%s: h2creg len is TOO large\n", __func__);
+		return MACFUNCINPUT;
+	}
+
+	len = h2c->content_len + H2CREG_HDR_LEN;
+	if ((h2c->content_len + H2CREG_HDR_LEN) & 3)
+		len = ((h2c->content_len + H2CREG_HDR_LEN) >> 2) + 1;
+	else
+		len = (h2c->content_len + H2CREG_HDR_LEN) >> 2;
+
+	byte0 = (u8)GET_FIELD(h2c->h2c_content.dword0, FWCMD_H2CREG_BYTE2);
+	byte1 = (u8)GET_FIELD(h2c->h2c_content.dword0, FWCMD_H2CREG_BYTE3);
+
+	h2creg.dword0 = SET_WORD(h2c->id, FWCMD_H2CREG_H2CREG_HDR_FUNC) |
+			SET_WORD(len, FWCMD_H2CREG_H2CREG_HDR_TOTAL_LEN) |
+			SET_WORD(byte0, FWCMD_H2CREG_BYTE2) |
+			SET_WORD(byte1, FWCMD_H2CREG_BYTE3);
+
+	h2creg.dword1 = h2c->h2c_content.dword1;
+	h2creg.dword2 = h2c->h2c_content.dword2;
+	h2creg.dword3 = h2c->h2c_content.dword3;
+
+	MAC_REG_W32(h2creg_offset->data0, h2creg.dword0);
+	MAC_REG_W32(h2creg_offset->data1, h2creg.dword1);
+	MAC_REG_W32(h2creg_offset->data2, h2creg.dword2);
+	MAC_REG_W32(h2creg_offset->data3, h2creg.dword3);
+
+	val = MAC_REG_R8(h2creg_offset->ctrl);
+	MAC_REG_W8(h2creg_offset->ctrl, val | B_AX_H2CREG_TRIGGER);
+
+	return MACSUCCESS;
+}
+
+u32 __recv_c2hreg(struct mac_ax_adapter *adapter, struct fwcmd_c2hreg *c2h)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_c2hreg_offset *c2hreg;
+	u8 val;
+
+	c2hreg = p_ops->get_c2hreg_offset(adapter);
+	if (!c2hreg) {
+		PLTFM_MSG_ERR("Get C2HREG offset FAIL\n");
+		return MACNPTR;
+	}
+
+	if (!(MAC_REG_R8(c2hreg->ctrl) & B_AX_C2HREG_TRIGGER))
+		return MACC2HREGEMP;
+
+	c2h->dword0 = MAC_REG_R32(c2hreg->data0);
+	c2h->dword1 = MAC_REG_R32(c2hreg->data1);
+	c2h->dword2 = MAC_REG_R32(c2hreg->data2);
+	c2h->dword3 = MAC_REG_R32(c2hreg->data3);
+	val = MAC_REG_R8(c2hreg->ctrl);
+	MAC_REG_W8(c2hreg->ctrl, val & ~B_AX_C2HREG_TRIGGER);
+
+	return MACSUCCESS;
+}
+
+u32 mac_recv_c2hreg(struct mac_ax_adapter *adapter,
+		    struct mac_ax_c2hreg_cont *cont)
+{
+	u32 ret;
+
+	cont->id = FWCMD_C2H_FUNC_NULL;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_ERR("FW is not ready\n");
+		return MACFWNONRDY;
+	}
+
+	if (adapter->sm.mac_rdy != MAC_AX_MAC_RDY) {
+		PLTFM_MSG_TRACE("MAC is not ready\n");
+		adapter->stats.c2h_reg_uninit++;
+	}
+
+	ret = __recv_c2hreg(adapter, &cont->c2h_content);
+	if (ret == MACC2HREGEMP) {
+		return ret;
+	} else if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]Get C2H REG fail %d\n", ret);
+		return ret;
+	}
+
+	cont->id = GET_FIELD(cont->c2h_content.dword0,
+			     FWCMD_C2HREG_C2HREG_HDR_FUNC);
+	cont->content_len = GET_FIELD(cont->c2h_content.dword0,
+				      FWCMD_C2HREG_C2HREG_HDR_TOTAL_LEN);
+	cont->content_len = (cont->content_len << 2) - C2HREG_HDR_LEN;
+
+	return MACSUCCESS;
+}
+
+u32 mac_notify_fw_dbcc(struct mac_ax_adapter *adapter, u8 en)
+{
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u32 ret;
+	struct fwcmd_notify_dbcc *dbcc;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	dbcc = (struct fwcmd_notify_dbcc *)
+		h2cb_put(h2cb, sizeof(struct fwcmd_notify_dbcc));
+	if (!dbcc) {
+		ret = MACNPTR;
+		PLTFM_MSG_ERR("%s: h2c put fail\n", __func__);
+		goto fail;
+	}
+
+	dbcc->dword0 = en ? FWCMD_H2C_NOTIFY_DBCC_EN : 0;
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MEDIA_RPT,
+			      FWCMD_H2C_FUNC_NOTIFY_DBCC, 0, 1);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: set hdr fail %d\n", __func__, ret);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: build txd fail %d\n", __func__, ret);
+		goto fail;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("%s: tx fail %d\n", __func__, ret);
+		goto fail;
+	}
+
+fail:
+	h2cb_free(adapter, h2cb);
+
+	if (!ret)
+		h2c_end_flow(adapter);
+
+	return ret;
+}
+
+u32 poll_c2hreg(struct mac_ax_adapter *adapter,
+		struct mac_ax_c2hreg_poll *c2h)
+{
+	u32 cnt, poll_us, ret;
+	struct mac_ax_c2hreg_cont *c2hreg_cont;
+	struct mac_ax_drv_stats *drv_stats = &adapter->drv_stats;
+
+	if (!c2h)
+		return MACSUCCESS;
+
+	cnt = c2h->retry_cnt;
+	poll_us = c2h->retry_wait_us;
+	c2hreg_cont = &c2h->c2hreg_cont;
+	do {
+		ret = mac_recv_c2hreg(adapter, c2hreg_cont);
+		if (cnt == 0 || ret == MACSUCCESS)
+			break;
+
+		if (drv_stats->drv_rm) {
+			PLTFM_MSG_ERR("%s: driver removed\n", __func__);
+			return MACDRVRM;
+		}
+
+		if (ret != MACSUCCESS) {
+			if (ret == MACC2HREGEMP) {
+				PLTFM_DELAY_US(poll_us);
+				cnt--;
+			} else {
+				PLTFM_MSG_ERR("%s: c2hreg fail\n", __func__);
+				return ret;
+			}
+		}
+	} while (cnt);
+
+	PLTFM_MSG_TRACE("%s: cnt = %d, us = %d\n",
+			__func__, cnt, poll_us);
+
+	if (ret == MACSUCCESS) {
+		if (c2h->polling_id != FWCMD_C2H_FUNC_NULL &&
+		    c2h->polling_id != c2hreg_cont->id) {
+			PLTFM_MSG_ERR("%s: surprised c2h\n", __func__);
+			PLTFM_MSG_ERR("rev: %x\n", c2h->polling_id);
+			PLTFM_MSG_ERR("exp: %x\n", c2hreg_cont->id);
+			ret = MACBADC2HREG;
+		}
+	} else {
+		PLTFM_MSG_ERR("%s: polling c2hreg timeout\n", __func__);
+	}
+
+	return ret;
+}
+
+u32 proc_msg_reg(struct mac_ax_adapter *adapter,
+		 struct mac_ax_h2creg_info *h2c,
+		 struct mac_ax_c2hreg_poll *c2h)
+{
+	struct mac_ax_dbgpkg_en en = {0};
+	u32 ret = MACSUCCESS;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_ERR("FW is not ready\n");
+		return MACFWNONRDY;
+	}
+
+	if (adapter->sm.fw_rst != MAC_AX_FW_RESET_IDLE) {
+		PLTFM_MSG_ERR("FW is not ready\n");
+		return MACIOERRSERL1;
+	}
+
+	PLTFM_MUTEX_LOCK(&adapter->fw_info.msg_reg);
+
+	ret = _mac_send_h2creg(adapter, h2c);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: send h2c reg fail: %d\n", __func__, ret);
+		goto END;
+	}
+
+	ret = poll_c2hreg(adapter, c2h);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("%s: poll c2h reg fail: %d\n", __func__, ret);
+
+END:
+	PLTFM_MUTEX_UNLOCK(&adapter->fw_info.msg_reg);
+	if (ret != MACSUCCESS) {
+		en.plersvd_dbg = 1;
+		mac_dbg_status_dump(adapter, NULL, &en);
+	}
+	return ret;
+}
+
+static u32 get_wps_rpt_event_id(struct mac_ax_adapter *adapter,
+				struct rtw_c2h_info *c2h,
+				enum phl_msg_evt_id *id,
+				u8 *c2h_info)
+{
+	struct fwcmd_wps_rpt *rpt = (struct fwcmd_wps_rpt *)c2h->content;
+	u32 state, val;
+
+	val = le32_to_cpu(rpt->dword0);
+	state = GET_FIELD(val, FWCMD_C2H_WPS_RPT_STATE);
+
+	if (!state)
+		*id = MSG_EVT_WPS_RELEASED;
+	else
+		*id = MSG_EVT_WPS_PRESSED;
+
+	return MACSUCCESS;
+}
+
+static u32 get_bcn_resend_event(struct mac_ax_adapter *adapter,
+				struct rtw_c2h_info *c2h,
+				enum phl_msg_evt_id *id,
+				u8 *c2h_info)
+{
+	*id = MSG_EVT_BCN_RESEND;
+
+	return MACSUCCESS;
+}
+
+static u32 get_tsf32_togl_rpt_event(struct mac_ax_adapter *adapter,
+				    struct rtw_c2h_info *c2h,
+				    enum phl_msg_evt_id *id,
+				    u8 *c2h_info)
+{
+	*id = MSG_EVT_TSF32_TOG;
+
+	return MACSUCCESS;
+}
+
+static u32 get_fw_rx_dbg_event(struct mac_ax_adapter *adapter,
+			       struct rtw_c2h_info *c2h,
+			       enum phl_msg_evt_id *id,
+			       u8 *c2h_info)
+{
+	*id = MSG_EVT_DBG_RX_DUMP;
+
+	return MACSUCCESS;
+}
+
+static u32 get_bcn_csa_event(struct mac_ax_adapter *adapter,
+			     struct rtw_c2h_info *c2h,
+			     enum phl_msg_evt_id *id,
+			     u8 *c2h_info)
+{
+	*id = MSG_EVT_CSA_COUNTDOWN_ZERO;
+
+	return MACSUCCESS;
+}
+
+static u32 get_scanofld_event(struct mac_ax_adapter *adapter, struct rtw_c2h_info *c2h,
+			      enum phl_msg_evt_id *id, u8 *c2h_info)
+{
+#if SCANOFLD_RSP_EVT_PARSE
+	struct fwcmd_scanofld_rsp *pkg;
+	struct mac_ax_scanofld_rsp *rsp;
+	struct mac_ax_scanofld_chrpt chrpt_struct;
+	u32 chrpt_size_h_dw;
+	u32 *chrpt;
+	u32 *chrpt_in;
+	u32 sh;
+	u32 chidx;
+
+	pkg = (struct fwcmd_scanofld_rsp *)c2h->content;
+	rsp = (struct mac_ax_scanofld_rsp *)c2h_info;
+	chrpt_in = (u32 *)(c2h->content + sizeof(struct fwcmd_scanofld_rsp));
+
+	chrpt_size_h_dw = sizeof(struct mac_ax_scanofld_chrpt) / sizeof(u32);
+
+	PLTFM_MEMSET(rsp, 0, sizeof(struct mac_ax_scanofld_rsp));
+
+	pkg->dword0 = le32_to_cpu(pkg->dword0);
+	pkg->dword1 = le32_to_cpu(pkg->dword1);
+	pkg->dword2 = le32_to_cpu(pkg->dword2);
+	pkg->dword3 = le32_to_cpu(pkg->dword3);
+
+	rsp->pri_ch = GET_FIELD(pkg->dword0, FWCMD_C2H_SCANOFLD_RSP_PRI_CH);
+	rsp->notify_reason = GET_FIELD(pkg->dword0, FWCMD_C2H_SCANOFLD_RSP_NOTIFY_REASON);
+	rsp->status = GET_FIELD(pkg->dword0, FWCMD_C2H_SCANOFLD_RSP_STATUS);
+	rsp->ch_band = GET_FIELD(pkg->dword3, FWCMD_C2H_SCANOFLD_RSP_CH_BAND);
+	rsp->band = pkg->dword3 & FWCMD_C2H_SCANOFLD_RSP_BAND;
+	PLTFM_MSG_TRACE("[scnofld][rsp][%d]: Reason %d, ch %d (band %d), status %d\n",
+			rsp->band, rsp->notify_reason, rsp->pri_ch, rsp->ch_band, rsp->status);
+	switch (rsp->notify_reason) {
+	case MAC_AX_SCAN_END_SCAN_NOTIFY:
+		PLTFM_MUTEX_LOCK(&adapter->scanofld_info.fw_chlist_state_lock);
+		adapter->scanofld_info.fw_chlist_busy[rsp->band] = 0;
+		PLTFM_MUTEX_UNLOCK(&adapter->scanofld_info.fw_chlist_state_lock);
+		adapter->scanofld_info.fw_scan_busy[rsp->band] = 0;
+		fallthrough;
+
+	case MAC_AX_SCAN_GET_RPT_NOTIFY:
+		rsp->scanned_round = GET_FIELD(pkg->dword0, FWCMD_C2H_SCANOFLD_RSP_SCANNED_ROUND);
+		rsp->spent_low = pkg->dword1;
+		rsp->spent_high = pkg->dword2;
+		rsp->air_density = GET_FIELD(pkg->dword3, FWCMD_C2H_SCANOFLD_RSP_AIR_DENSITY);
+		rsp->actual_period = GET_FIELD(pkg->dword0, FWCMD_C2H_SCANOFLD_RSP_ACTUAL_PERIOD);
+		rsp->tx_fail_cnt = GET_FIELD(pkg->dword3, FWCMD_C2H_SCANOFLD_RSP_TX_FAIL_CNT);
+		rsp->num_ch_rpt = GET_FIELD(pkg->dword3, FWCMD_C2H_SCANOFLD_RSP_NUM_CH_RPT);
+		rsp->ch_rpt_size = GET_FIELD(pkg->dword3, FWCMD_C2H_SCANOFLD_RSP_CH_RPT_SIZE);
+
+		PLTFM_MSG_TRACE("[scnofld][rsp][%d][end] scan %d rnd in %llu us, last slt %d us\n",
+				rsp->band, rsp->scanned_round,
+				((u64)rsp->spent_high << 32) + rsp->spent_low, rsp->actual_period);
+		PLTFM_MSG_TRACE("[scnofld][rsp][%d][end] airDense %d, txFail %d\n",
+				rsp->band, rsp->air_density, rsp->tx_fail_cnt);
+		PLTFM_MSG_TRACE("[scnofld][rsp][%d][end] %d ch rpt (size %d)\n",
+				rsp->band, rsp->num_ch_rpt, rsp->ch_rpt_size);
+
+		if (!rsp->num_ch_rpt || !rsp->ch_rpt_size)
+			break;
+
+		for (chidx = 0; chidx < rsp->num_ch_rpt; chidx++) {
+			chrpt = (u32 *)&chrpt_struct;
+			for (sh = 0; sh < chrpt_size_h_dw; sh++) {
+				*chrpt_in = le32_to_cpu(*chrpt_in);
+				PLTFM_MEMCPY(chrpt++, chrpt_in++, sizeof(u32));
+			}
+			chrpt_in += (rsp->ch_rpt_size - chrpt_size_h_dw);
+			PLTFM_MSG_TRACE("[scnofld][rsp][%d][end] ch %d, rx %d, txfail %x, hit %d\n",
+					rsp->band, chrpt_struct.pri_ch, chrpt_struct.rx_cnt,
+					chrpt_struct.tx_fail, chrpt_struct.parsed);
+		}
+		break;
+
+	case MAC_AX_SCAN_LEAVE_CH_NOTIFY:
+		rsp->actual_period = GET_FIELD(pkg->dword0,
+					       FWCMD_C2H_SCANOFLD_RSP_ACTUAL_PERIOD);
+		rsp->tx_fail_cnt = GET_FIELD(pkg->dword3,
+					     FWCMD_C2H_SCANOFLD_RSP_TX_FAIL_CNT);
+		PLTFM_MSG_TRACE("[scnofld][rsp][%d][leave] pd %d, txfail %d\n",
+				rsp->band, rsp->actual_period, rsp->tx_fail_cnt);
+		break;
+
+	default:
+		break;
+	}
+#endif //SCANOFLD_RSP_EVT_PARSE
+#if SCANOFLD_RSP_EVT_ID
+	*id = MSG_EVT_SCANOFLD;
+#endif //SCANOFLD_RSP_EVT_ID
+	return MACSUCCESS;
+}
+
+static u32 get_usr_txrpt_info_event(struct mac_ax_adapter *adapter,
+				    struct rtw_c2h_info *c2h,
+				    enum phl_msg_evt_id *id,
+				    u8 *c2h_info)
+{
+	*id = MSG_EVT_USR_TX_RPT;
+
+	c2h_info = c2h->content;
+
+	return MACSUCCESS;
+}
+
+static struct c2h_event_id_proc event_proc[] = {
+	/* cat, class, func, hdl */
+	{FWCMD_C2H_CAT_MAC, FWCMD_C2H_CL_MISC,
+	 FWCMD_C2H_FUNC_WPS_RPT, get_wps_rpt_event_id},
+	{FWCMD_C2H_CAT_MAC, FWCMD_C2H_CL_FW_OFLD,
+	 FWCMD_C2H_FUNC_BEACON_RESEND, get_bcn_resend_event},
+	{FWCMD_C2H_CAT_MAC, FWCMD_C2H_CL_FW_OFLD,
+	 FWCMD_C2H_FUNC_TSF32_TOGL_RPT, get_tsf32_togl_rpt_event},
+	{FWCMD_C2H_CAT_MAC, FWCMD_C2H_CL_MISC,
+	 FWCMD_C2H_FUNC_CCXRPT, get_ccxrpt_event},
+	{FWCMD_C2H_CAT_MAC, FWCMD_C2H_CL_FW_DBG,
+	 FWCMD_C2H_FUNC_RX_DBG, get_fw_rx_dbg_event},
+	{FWCMD_C2H_CAT_MAC, FWCMD_C2H_CL_FW_INFO,
+	 FWCMD_C2H_FUNC_BCN_CNT, get_bcn_stats_event},
+	{FWCMD_C2H_CAT_MAC, FWCMD_C2H_CL_FW_INFO,
+	 FWCMD_C2H_FUNC_BCN_CSAZERO, get_bcn_csa_event},
+	{FWCMD_C2H_CAT_MAC, FWCMD_C2H_CL_FW_OFLD,
+	 FWCMD_C2H_FUNC_SCANOFLD_RSP, get_scanofld_event},
+	{FWCMD_C2H_CAT_MAC, FWCMD_C2H_CL_FW_OFLD,
+	 FWCMD_C2H_FUNC_WIFI_SENSING_CSI_TX_RESULT, get_sensing_csi_event},
+	{FWCMD_C2H_CAT_MAC, FWCMD_C2H_CL_FW_OFLD,
+	 FWCMD_C2H_FUNC_BCNERLYNTFY, get_bcn_erly_event},
+	{FWCMD_C2H_CAT_MAC, FWCMD_C2H_CL_FW_OFLD,
+	 FWCMD_C2H_FUNC_USR_TX_RPT_INFO, get_usr_txrpt_info_event},
+	{FWCMD_C2H_CAT_NULL, FWCMD_C2H_CL_NULL,
+	 FWCMD_C2H_FUNC_NULL, NULL},
+};
+
+u32 mac_get_c2h_event(struct mac_ax_adapter *adapter,
+		      struct rtw_c2h_info *c2h,
+		      enum phl_msg_evt_id *id,
+		      u8 *c2h_info)
+{
+	struct c2h_event_id_proc *proc;
+	u32 (*hdl)(struct mac_ax_adapter *adapter, struct rtw_c2h_info *c2h,
+		   enum phl_msg_evt_id *id, u8 *c2h_info) = NULL;
+
+	/*for C2H ack bit no need to process*/
+	if (c2h->type_done_ack == 1 || c2h->type_rec_ack == 1)
+		return MACSUCCESS;
+
+	proc = event_proc;
+	while (proc->cat != FWCMD_C2H_CAT_NULL) {
+		if (proc->cat == c2h->c2h_cat &&
+		    proc->cls == c2h->c2h_class &&
+		    proc->func == c2h->c2h_func) {
+			hdl = proc->hdl;
+			return hdl(adapter, c2h, id, c2h_info);
+		}
+		proc++;
+	}
+
+	return MACSUCCESS;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd.h
new file mode 100644
index 000000000000..705a8f2098c2
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd.h
@@ -0,0 +1,850 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_FW_CMD_H_
+#define _MAC_AX_FW_CMD_H_
+
+#include "../type.h"
+#include "../fw_ax/inc_hdr/fwcmd_intf.h"
+#include "fwcmd_intf_f2p.h"
+#include "fwcmd_intf_f2p_v1.h"
+#include "trx_desc.h"
+#include "fwofld.h"
+#include "p2p.h"
+#include "flash.h"
+#include "dbg_cmd.h"
+
+#define FWCMD_HDR_LEN		8
+#define C2HREG_HDR_LEN 2
+#define H2CREG_HDR_LEN 2
+#define C2HREG_CONTENT_LEN 14
+#define H2CREG_CONTENT_LEN 14
+#define C2HREG_LEN (C2HREG_HDR_LEN + C2HREG_CONTENT_LEN)
+#define H2CREG_LEN (H2CREG_HDR_LEN + H2CREG_CONTENT_LEN)
+
+#define H2C_CMD_LEN		64
+#define H2C_DATA_LEN		256
+#define H2C_LONG_DATA_LEN	2048
+
+#define SET_FWCMD_ID(_t, _ca, _cl, _f)                                         \
+		(SET_WORD(_t, H2C_HDR_DEL_TYPE) | SET_WORD(_ca, H2C_HDR_CAT) | \
+		 SET_WORD(_cl, H2C_HDR_CLASS) | SET_WORD(_f, H2C_HDR_FUNC))
+#define GET_FWCMD_TYPE(id)	(GET_FIELD(id, C2H_HDR_DEL_TYPE))
+#define GET_FWCMD_CAT(id)	(GET_FIELD(id, C2H_HDR_CAT))
+#define GET_FWCMD_CLASS(id)	(GET_FIELD(id, C2H_HDR_CLASS))
+#define GET_FWCMD_FUNC(id)	(GET_FIELD(id, C2H_HDR_FUNC))
+
+#define FWCMD_TYPE_H2C	0
+#define FWCMD_TYPE_C2H	1
+
+#define FWCMD_C2H_CL_NULL		0xFF
+#define FWCMD_C2H_FUNC_NULL		0xFF
+#define FWCMD_C2H_CAT_NULL		0xFF
+
+/**
+ * @struct h2c_buf_head
+ * @brief h2c_buf_head
+ *
+ * @var h2c_buf_head::next
+ * Please Place Description here.
+ * @var h2c_buf_head::prev
+ * Please Place Description here.
+ * @var h2c_buf_head::pool
+ * Please Place Description here.
+ * @var h2c_buf_head::size
+ * Please Place Description here.
+ * @var h2c_buf_head::qlen
+ * Please Place Description here.
+ * @var h2c_buf_head::suspend
+ * Please Place Description here.
+ * @var h2c_buf_head::lock
+ * Please Place Description here.
+ */
+struct h2c_buf_head {
+	/* keep first */
+	struct h2c_buf *next;
+	struct h2c_buf *prev;
+	u8 *pool;
+	u32 size;
+	u32 qlen;
+	u8 suspend;
+	mac_ax_mutex lock;
+};
+
+/**
+ * @struct fwcmd_wkb_head
+ * @brief fwcmd_wkb_head
+ *
+ * @var fwcmd_wkb_head::next
+ * Please Place Description here.
+ * @var fwcmd_wkb_head::prev
+ * Please Place Description here.
+ * @var fwcmd_wkb_head::qlen
+ * Please Place Description here.
+ * @var fwcmd_wkb_head::lock
+ * Please Place Description here.
+ */
+struct fwcmd_wkb_head {
+	/* keep first */
+	struct h2c_buf *next;
+	struct h2c_buf *prev;
+	u32 qlen;
+	mac_ax_mutex lock;
+};
+
+/**
+ * @struct h2c_buf
+ * @brief h2c_buf
+ *
+ * @var h2c_buf::next
+ * Please Place Description here.
+ * @var h2c_buf::prev
+ * Please Place Description here.
+ * @var h2c_buf::_class_
+ * Please Place Description here.
+ * @var h2c_buf::id
+ * Please Place Description here.
+ * @var h2c_buf::master
+ * Please Place Description here.
+ * @var h2c_buf::len
+ * Please Place Description here.
+ * @var h2c_buf::head
+ * Please Place Description here.
+ * @var h2c_buf::end
+ * Please Place Description here.
+ * @var h2c_buf::data
+ * Please Place Description here.
+ * @var h2c_buf::tail
+ * Please Place Description here.
+ * @var h2c_buf::hdr_len
+ * Please Place Description here.
+ * @var h2c_buf::flags
+ * Please Place Description here.
+ * @var h2c_buf::h2c_seq
+ * Please Place Description here.
+ */
+struct h2c_buf {
+	/* keep first */
+	struct h2c_buf *next;
+	struct h2c_buf *prev;
+	enum h2c_buf_class _class_;
+	u32 id;
+	u8 master;
+	u32 len;
+	u8 *head;
+	u8 *end;
+	u8 *data;
+	u8 *tail;
+	u32 hdr_len;
+#define H2CB_FLAGS_FREED	BIT(0)
+	u32 flags;
+	u8 h2c_seq;
+};
+
+/**
+ * @struct c2h_proc_class
+ * @brief c2h_proc_class
+ *
+ * @var c2h_proc_class::id
+ * Please Place Description here.
+ * @var c2h_proc_class::handler
+ * Please Place Description here.
+ */
+struct c2h_proc_class {
+	u16 id;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info);
+};
+
+struct fw_status_proc_class {
+	u16 id;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len);
+};
+
+/**
+ * @struct c2h_proc_func
+ * @brief c2h_proc_func
+ *
+ * @var c2h_proc_func::id
+ * Please Place Description here.
+ * @var c2h_proc_func::handler
+ * Please Place Description here.
+ */
+struct c2h_proc_func {
+	u16 id;
+	u32 (*handler)(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		       struct rtw_c2h_info *info);
+};
+
+/**
+ * @struct mac_ax_c2hreg_info
+ * @brief mac_ax_c2hreg_info
+ *
+ * @var mac_ax_c2hreg_info::id
+ * Please Place Description here.
+ * @var mac_ax_c2hreg_info::total_len
+ * Please Place Description here.
+ * @var mac_ax_c2hreg_info::content
+ * Please Place Description here.
+ * @var mac_ax_c2hreg_info::c2hreg
+ * Please Place Description here.
+ */
+
+struct mac_ax_c2hreg_info {
+	u8 id;
+	u8 content_len;
+	u8 *content;
+	u8 c2hreg[C2HREG_LEN];
+};
+
+struct mac_ax_c2hreg_cont {
+	u8 id;
+	u8 content_len;
+	struct fwcmd_c2hreg c2h_content;
+};
+
+struct mac_ax_c2hreg_poll {
+	u8 polling_id;
+	u32 retry_cnt;
+	u32 retry_wait_us;
+	struct mac_ax_c2hreg_cont c2hreg_cont;
+};
+
+struct mac_ax_h2creg_info {
+	u8 id;
+	u8 content_len;
+	struct fwcmd_h2creg h2c_content;
+};
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+/**
+ * @brief h2cb_init
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 h2cb_init(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief h2cb_exit
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 h2cb_exit(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief h2cb_alloc
+ *
+ * @param *adapter
+ * @param buf_class
+ * @return Please Place Description here.
+ * @retval  rtw_h2c_pkt
+ */
+#if MAC_AX_PHL_H2C
+struct rtw_h2c_pkt *h2cb_alloc(struct mac_ax_adapter *adapter,
+			       enum rtw_h2c_pkt_type buf_class);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief h2cb_free
+ *
+ * @param *adapter
+ * @param *h2cb
+ * @return Please Place Description here.
+ * @retval void
+ */
+void h2cb_free(struct mac_ax_adapter *adapter, struct rtw_h2c_pkt *h2cb);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief h2cb_push
+ *
+ * @param *h2cb
+ * @param len
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 *h2cb_push(struct rtw_h2c_pkt *h2cb, u32 len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief h2cb_pull
+ *
+ * @param *h2cb
+ * @param len
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 *h2cb_pull(struct rtw_h2c_pkt *h2cb, u32 len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief h2cb_put
+ *
+ * @param *h2cb
+ * @param len
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 *h2cb_put(struct rtw_h2c_pkt *h2cb, u32 len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief h2c_pkt_set_hdr
+ *
+ * @param *adapter
+ * @param *h2cb
+ * @param type
+ * @param cat
+ * @param _class_
+ * @param func
+ * @param rack
+ * @param dack
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 h2c_pkt_set_hdr(struct mac_ax_adapter *adapter, struct rtw_h2c_pkt *h2cb,
+		    u8 type, u8 cat, u8 _class_, u8 func, u16 rack, u16 dack);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief h2c_pkt_set_hdr_fwdl
+ *
+ * @param *adapter
+ * @param *h2cb
+ * @param type
+ * @param cat
+ * @param _class_
+ * @param func
+ * @param rack
+ * @param dack
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 h2c_pkt_set_hdr_fwdl(struct mac_ax_adapter *adapter,
+			 struct rtw_h2c_pkt *h2cb, u8 type, u8 cat, u8 _class_,
+			 u8 func, u16 rack, u16 dack);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief h2c_pkt_set_cmd
+ *
+ * @param *adapter
+ * @param *h2cb
+ * @param *cmd
+ * @param len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 h2c_pkt_set_cmd(struct mac_ax_adapter *adapter, struct rtw_h2c_pkt *h2cb,
+		    u8 *cmd, u32 len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief h2c_pkt_build_txd
+ *
+ * @param *adapter
+ * @param *h2cb
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 h2c_pkt_build_txd(struct mac_ax_adapter *adapter, struct rtw_h2c_pkt *h2cb);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief h2c_agg_enqueue
+ *
+ * @param *adapter
+ * @param *h2cb
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 h2c_agg_enqueue(struct mac_ax_adapter *adapter, struct rtw_h2c_pkt *h2cb);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief h2cb_alloc
+ *
+ * @param *adapter
+ * @param buf_class
+ * @return Please Place Description here.
+ * @retval  h2c_buf
+ */
+#else
+struct h2c_buf *h2cb_alloc(struct mac_ax_adapter *adapter,
+			   enum h2c_buf_class buf_class);
+/**
+ * @}
+ * @}
+ */
+void h2cb_free(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb);
+u8 *h2cb_push(struct h2c_buf *h2cb, u32 len);
+u8 *h2cb_pull(struct h2c_buf *h2cb, u32 len);
+u8 *h2cb_put(struct h2c_buf *h2cb, u32 len);
+u32 h2c_pkt_set_hdr(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb,
+		    u8 type, u8 cat, u8 _class_, u8 func, u16 rack, u16 dack);
+u32 h2c_pkt_set_hdr_fwdl(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb,
+			 u8 type, u8 cat, u8 _class_, u8 func, u16 rack,
+			 u16 dack);
+u32 h2c_pkt_set_cmd(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb,
+		    u8 *cmd, u32 len);
+u32 h2c_pkt_build_txd(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb);
+u32 h2c_agg_enqueue(struct mac_ax_adapter *adapter, h2c_buf *h2cb);
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief fwcmd_wq_enqueue
+ *
+ * @param *adapter
+ * @param *h2cb
+ * @return Please Place Description here.
+ * @retval u32
+ */
+#endif
+u32 fwcmd_wq_enqueue(struct mac_ax_adapter *adapter, struct h2c_buf *h2cb);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief fwcmd_wq_dequeue
+ *
+ * @param *adapter
+ * @param id
+ * @return Please Place Description here.
+ * @retval  h2c_buf
+ */
+struct h2c_buf *fwcmd_wq_dequeue(struct mac_ax_adapter *adapter, u32 id);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief fwcmd_wq_idle
+ *
+ * @param *adapter
+ * @param id
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 fwcmd_wq_idle(struct mac_ax_adapter *adapter, u32 id);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup C2H
+ * @{
+ */
+
+/**
+ * @brief mac_process_c2h
+ *
+ * @param *adapter
+ * @param *buf
+ * @param len
+ * @param *ret
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_process_c2h(struct mac_ax_adapter *adapter, u8 *buf, u32 len,
+		    u8 *ret);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup C2H
+ * @{
+ */
+
+/**
+ * @brief c2h_field_parsing
+ *
+ * @param *hdr
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 c2h_field_parsing(struct fwcmd_hdr *hdr, struct rtw_c2h_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup C2H
+ * @{
+ */
+
+/**
+ * @brief mac_fw_log_cfg
+ *
+ * @param *adapter
+ * @param *log_cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_fw_log_cfg(struct mac_ax_adapter *adapter,
+		   struct mac_ax_fw_log *log_cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup Beacon
+ * @{
+ */
+
+/**
+ * @brief mac_send_bcn_h2c
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_send_bcn_h2c(struct mac_ax_adapter *adapter,
+		     struct mac_ax_bcn_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief mac_host_getpkt_h2c
+ *
+ * @param *adapter
+ * @param macid
+ * @param pkttype
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_host_getpkt_h2c(struct mac_ax_adapter *adapter, u8 macid, u8 pkttype);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief mac_outsrc_h2c_common
+ *
+ * @param *adapter
+ * @param *hdr
+ * @param *pvalue
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_outsrc_h2c_common(struct mac_ax_adapter *adapter,
+			  struct rtw_g6_h2c_hdr *hdr, u32 *pvalue);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup Beacon
+ * @{
+ */
+
+/**
+ * @brief mac_ie_cam_upd
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_ie_cam_upd(struct mac_ax_adapter *adapter,
+		   struct mac_ax_ie_cam_cmd_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief h2c_end_flow
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 h2c_end_flow(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup H2C
+ * @{
+ */
+
+/**
+ * @brief mac_send_h2creg
+ *
+ * @param *adapter
+ * @param *content
+ * @param len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_send_h2creg(struct mac_ax_adapter *adapter, u32 *content, u8 len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup C2H
+ * @{
+ */
+
+/**
+ * @brief mac_process_c2hreg
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_process_c2hreg(struct mac_ax_adapter *adapter,
+		       struct mac_ax_c2hreg_info *info);
+/**
+ * @}
+ * @}
+ */
+
+u32 proc_msg_reg(struct mac_ax_adapter *adapter,
+		 struct mac_ax_h2creg_info *h2c,
+		 struct mac_ax_c2hreg_poll *c2h);
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup C2H
+ * @{
+ */
+
+/**
+ * @brief mac_get_c2h_event
+ *
+ * Get the phl_msg_evt_id from C2H packet
+ *
+ * @param *adapter
+ * @param *c2h
+ * @param *id
+ * @return Return 0 when getting event ID successfully.
+ * @retval u32
+ */
+
+u32 mac_get_c2h_event(struct mac_ax_adapter *adapter,
+		      struct rtw_c2h_info *c2h,
+		      enum phl_msg_evt_id *id,
+		      u8 *c2h_info);
+
+/**
+ * @}
+ * @}
+ */
+
+u32 mac_notify_fw_dbcc(struct mac_ax_adapter *adapter, u8 en);
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd_intf_f2p.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd_intf_f2p.h
new file mode 100644
index 000000000000..6362d6118269
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd_intf_f2p.h
@@ -0,0 +1,520 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+ #ifndef _MAC_AX_FWCMD_INTF_F2P_H_
+#define _MAC_AX_FWCMD_INTF_F2P_H_
+
+/* f2p test cmd para*/
+#define FWCMD_F2PTEST_ULBW_SH		0
+#define FWCMD_F2PTEST_ULBW_MSK		0x3
+#define FWCMD_F2PTEST_GILTF_SH		2
+#define FWCMD_F2PTEST_GILTF_MSK		0x3
+#define FWCMD_F2PTEST_NUMLTF_SH		4
+#define FWCMD_F2PTEST_NUMLTF_MSK	0x7
+#define FWCMD_F2PTEST_ULSTBC_SH		7
+#define FWCMD_F2PTEST_ULSTBC_MSK	0x1
+#define FWCMD_F2PTEST_DPLR_SH		8
+#define FWCMD_F2PTEST_DPLR_MSK		0x1
+#define FWCMD_F2PTEST_TXPWR_SH		9
+#define FWCMD_F2PTEST_TXPWR_MSK		0x3F
+#define FWCMD_F2PTEST_USERNUM_SH	16
+#define FWCMD_F2PTEST_USERNUM_MSK	0xF
+#define FWCMD_F2PTEST_PKTNUM_SH		20
+#define FWCMD_F2PTEST_PKTNUM_MSK	0xF
+#define FWCMD_F2PTEST_BITMAP_SH		24
+#define FWCMD_F2PTEST_BITMAP_MSK	0xFF
+
+#define FWCMD_F2PTEST_AID12_SH		0
+#define FWCMD_F2PTEST_AID12_MSK		0xFFF
+#define FWCMD_F2PTEST_ULMCS_SH		12
+#define FWCMD_F2PTEST_ULMCS_MSK		0xF
+#define FWCMD_F2PTEST_MACID_SH		16
+#define FWCMD_F2PTEST_MACID_MSK		0xFF
+#define FWCMD_F2PTEST_RUPOS_SH		24
+#define FWCMD_F2PTEST_RUPOS_MSK		0xFF
+
+#define FWCMD_F2PTEST_ULFEC_SH		0
+#define FWCMD_F2PTEST_ULFEC_MSK		0x1
+#define FWCMD_F2PTEST_ULDCM_SH		1
+#define FWCMD_F2PTEST_ULDCM_MSK		0x1
+#define FWCMD_F2PTEST_SS_ALLOC_SH	2
+#define FWCMD_F2PTEST_SS_ALLOC_MSK	0x3F
+#define FWCMD_F2PTEST_UL_TGTRSSI_SH	8
+#define FWCMD_F2PTEST_UL_TGTRSSI_MSK	0x7F
+
+#define FWCMD_F2PTEST_PREF_AC_SH	0
+#define FWCMD_F2PTEST_PREF_AC_MSK	0x3
+
+#define FWCMD_F2PTEST_DATARATE_SH	0
+#define FWCMD_F2PTEST_DATARATE_MSK	0x1FF
+#define FWCMD_F2PTEST_MULPORT_SH	9
+#define FWCMD_F2PTEST_MULPORT_MSK	0x7
+#define FWCMD_F2PTEST_PWR_OFSET_SH	12
+#define FWCMD_F2PTEST_PWR_OFSET_MSK	0x7
+#define FWCMD_F2PTEST_MODE_SH		16
+#define FWCMD_F2PTEST_MODE_MSK		0x3
+#define FWCMD_F2PTEST_TYPE_SH		18
+#define FWCMD_F2PTEST_TYPE_MSK		0x3F
+#define FWCMD_F2PTEST_SIGB_LEN_SH		24
+#define FWCMD_F2PTEST_SIGB_LEN_MSK		0xFF
+
+#define FWCMD_F2PTEST_TXCMD_ADDR_SH	0
+#define FWCMD_F2PTEST_TXCMD_ADDR_MSK	0xFF
+#define FWCMD_F2PTEST_SIGB_ADDR_SH	8
+#define FWCMD_F2PTEST_SIGB_ADDR_MSK	0xFF
+
+/* f2p_wd*/
+/* dword0 */
+#define F2P_WD_CMD_QSEL_SH		0
+#define F2P_WD_CMD_QSEL_MSK		0x3f
+#define F2P_WD_LS			BIT(10)
+#define F2P_WD_FS			BIT(11)
+#define F2P_WD_TOTAL_NUMBER_SH		12
+#define F2P_WD_TOTAL_NUMBER_MSK		0xf
+#define F2P_WD_SEQ_SH			16
+#define F2P_WD_SEQ_MSK			0xff
+#define F2P_WD_LENGTH_SH		24
+#define F2P_WD_LENGTH_MSK		0xff
+
+/* f2p_tx_cmd*/
+/* dword0 */
+#define F2P_CMD_TYPE_SH			0
+#define F2P_CMD_TYPE_MSK		0xff
+#define F2P_CMD_SUB_TYPE_SH		8
+#define F2P_CMD_SUB_TYPE_MSK		0xff
+#define F2P_DL_USER_NUM_SH		16
+#define F2P_DL_USER_NUM_MSK		0x1f
+#define F2P_BW_SH			21
+#define F2P_BW_MSK			0x3
+#define F2P_TX_POWER_SH			23
+#define F2P_TX_POWER_MSK		0x1ff
+
+/* dword1 */
+#define F2P_FW_DEFINE_SH		0
+#define F2P_FW_DEFINE_MSK		0xffff
+#define F2P_SS_SEL_MODE_SH		16
+#define F2P_SS_SEL_MODE_MSK		0x3
+#define F2P_NEXT_QSEL_SH		18
+#define F2P_NEXT_QSEL_MSK		0x3f
+#define F2P_TWT_GROUP_SH		24
+#define F2P_TWT_GROUP_MSK		0xf
+#define F2P_DIS_CHK_SLP			BIT(28)
+#define F2P_RU_MU_2_SU			BIT(29)
+#define F2P_DL_T_PE_SH			30
+#define F2P_DL_T_PE_MSK			0x3
+
+/* dword2 */
+#define F2P_SIGB_CH1_LEN_SH		0
+#define F2P_SIGB_CH1_LEN_MSK		0xff
+#define F2P_SIGB_CH2_LEN_SH		8
+#define F2P_SIGB_CH2_LEN_MSK		0xff
+#define F2P_SIGB_SYM_NUM_SH		16
+#define F2P_SIGB_SYM_NUM_MSK		0x3f
+#define F2P_SIGB_CH2_OFS_SH		22
+#define F2P_SIGB_CH2_OFS_MSK		0x1f
+#define F2P_DIS_HTP_ACK			BIT(27)
+#define F2P_TX_TIME_REF_SH		28
+#define F2P_TX_TIME_REF_MSK		0x3
+#define F2P_PRI_USER_IDX_SH		30
+#define F2P_PRI_USER_IDX_MSK		0x3
+
+/* dword3 */
+#define F2P_AMPDU_MAX_TXTIME_SH		0
+#define F2P_AMPDU_MAX_TXTIME_MSK	0x3fff
+#define F2P_GROUP_ID_SH			16
+#define F2P_GROUP_ID_MSK		0x3f
+#define F2P_TWT_CHK_EN			BIT(28)
+#define F2P_TWT_PORT_ID_SH		29
+#define F2P_TWT_PORT_ID_MSK		0x7
+
+/* dword4 */
+#define F2P_TWT_START_TIME_SH		0
+#define F2P_TWT_START_TIME_MSK		0xffffffff
+
+/* dword5 */
+#define F2P_TWT_END_TIME_SH		0
+#define F2P_TWT_END_TIME_MSK		0xffffffff
+
+/* dword6 */
+#define F2P_APEP_LEN_SH			0
+#define F2P_APEP_LEN_MSK		0xfff
+#define F2P_TRI_PAD_SH			12
+#define F2P_TRI_PAD_MSK			0x3
+#define F2P_UL_T_PE_SH			14
+#define F2P_UL_T_PE_MSK			0x3
+#define F2P_RF_GAIN_IDX_SH		16
+#define F2P_RF_GAIN_IDX_MSK		0x3ff
+#define F2P_FIXED_GAIN_EN		BIT(26)
+#define F2P_UL_GI_LTF_SH		27
+#define F2P_UL_GI_LTF_MSK		0x7
+#define F2P_UL_DOPPLER			BIT(30)
+#define F2P_UL_STBC			BIT(31)
+
+/* dword7 */
+#define F2P_UL_MID_PER			BIT(0)
+#define F2P_UL_CQI_RRP_TRI		BIT(1)
+#define F2P_SIGB_DCM			BIT(16)
+#define F2P_SIGB_COMP			BIT(17)
+#define F2P_DOPPLER			BIT(18)
+#define F2P_STBC			BIT(19)
+#define F2P_MID_PER			BIT(20)
+#define F2P_GI_LTF_SIZE_SH		21
+#define F2P_GI_LTF_SIZE_MSK		0x7
+#define F2P_SIGB_MCS_SH			24
+#define F2P_SIGB_MCS_MSK		0x7
+
+/* dword8 */
+#define F2P_MACID_U0_SH			0
+#define F2P_MACID_U0_MSK		0xff
+#define F2P_AC_TYPE_U0_SH		8
+#define F2P_AC_TYPE_U0_MSK		0x3
+#define F2P_MU_STA_POS_U0_SH		10
+#define F2P_MU_STA_POS_U0_MSK		0x3
+#define F2P_DL_RATE_IDX_U0_SH		12
+#define F2P_DL_RATE_IDX_U0_MSK		0x1ff
+#define F2P_TX_CMD_DL_DCM_EN_U0		BIT(21)
+#define F2P_RU_ALO_IDX_U0_SH		24
+#define F2P_RU_ALO_IDX_U0_MSK		0xff
+
+/* dword9 */
+#define F2P_PWR_BOOST_U0_SH		0
+#define F2P_PWR_BOOST_U0_MSK		0x1f
+#define F2P_AGG_BMP_ALO_U0_SH		5
+#define F2P_AGG_BMP_ALO_U0_MSK		0x7
+#define F2P_AMPDU_MAX_NUM_U0_SH		8
+#define F2P_AMPDU_MAX_NUM_U0_MSK	0xff
+#define F2P_USER_DEFINE_U0_SH		16
+#define F2P_USER_DEFINE_U0_MSK		0xff
+#define F2P_USER_DEFINE_EXT_U0_SH	24
+#define F2P_USER_DEFINE_EXT_U0_MSK	0xff
+
+/* dword10 */
+#define F2P_UL_ADDR_IDX_U0_SH		0
+#define F2P_UL_ADDR_IDX_U0_MSK		0xff
+#define F2P_UL_DCM_U0			BIT(8)
+#define F2P_UL_FEC_COD_U0		BIT(9)
+#define F2P_UL_RU_RATE_U0_SH		10
+#define F2P_UL_RU_RATE_U0_MSK		0x7f
+#define F2P_UL_RU_ALO_IDX_U0_SH		24
+#define F2P_UL_RU_ALO_IDX_U0_MSK	0xff
+
+/* dword11 */
+
+/* dword12 */
+#define F2P_MACID_U1_SH			0
+#define F2P_MACID_U1_MSK		0xff
+#define F2P_AC_TYPE_U1_SH		8
+#define F2P_AC_TYPE_U1_MSK		0x3
+#define F2P_MU_STA_POS_U1_SH		10
+#define F2P_MU_STA_POS_U1_MSK		0x3
+#define F2P_DL_RATE_IDX_U1_SH		12
+#define F2P_DL_RATE_IDX_U1_MSK		0x1ff
+#define F2P_TX_CMD_DL_DCM_EN_U1		BIT(21)
+#define F2P_RU_ALO_IDX_U1_SH		24
+#define F2P_RU_ALO_IDX_U1_MSK		0xff
+
+/* dword13 */
+#define F2P_PWR_BOOST_U1_SH		0
+#define F2P_PWR_BOOST_U1_MSK		0x1f
+#define F2P_AGG_BMP_ALO_U1_SH		5
+#define F2P_AGG_BMP_ALO_U1_MSK		0x7
+#define F2P_AMPDU_MAX_NUM_U1_SH		8
+#define F2P_AMPDU_MAX_NUM_U1_MSK	0xff
+#define F2P_USER_DEFINE_U1_SH		16
+#define F2P_USER_DEFINE_U1_MSK		0xff
+#define F2P_USER_DEFINE_EXT_U1_SH	24
+#define F2P_USER_DEFINE_EXT_U1_MSK	0xff
+
+/* dword14 */
+#define F2P_UL_ADDR_IDX_U1_SH		0
+#define F2P_UL_ADDR_IDX_U1_MSK		0xff
+#define F2P_UL_DCM_U1			BIT(8)
+#define F2P_UL_FEC_COD_U1		BIT(9)
+#define F2P_UL_RU_RATE_U1_SH		10
+#define F2P_UL_RU_RATE_U1_MSK		0x7f
+#define F2P_UL_RU_ALO_IDX_U1_SH		24
+#define F2P_UL_RU_ALO_IDX_U1_MSK	0xff
+
+/* dword15 */
+
+/* dword16 */
+#define F2P_MACID_U2_SH			0
+#define F2P_MACID_U2_MSK		0xff
+#define F2P_AC_TYPE_U2_SH		8
+#define F2P_AC_TYPE_U2_MSK		0x3
+#define F2P_MU_STA_POS_U2_SH		10
+#define F2P_MU_STA_POS_U2_MSK		0x3
+#define F2P_DL_RATE_IDX_U2_SH		12
+#define F2P_DL_RATE_IDX_U2_MSK		0x1ff
+#define F2P_TX_CMD_DL_DCM_EN_U2		BIT(21)
+#define F2P_RU_ALO_IDX_U2_SH		24
+#define F2P_RU_ALO_IDX_U2_MSK		0xff
+
+/* dword17 */
+#define F2P_PWR_BOOST_U2_SH		0
+#define F2P_PWR_BOOST_U2_MSK		0x1f
+#define F2P_AGG_BMP_ALO_U2_SH		5
+#define F2P_AGG_BMP_ALO_U2_MSK		0x7
+#define F2P_AMPDU_MAX_NUM_U2_SH		8
+#define F2P_AMPDU_MAX_NUM_U2_MSK	0xff
+#define F2P_USER_DEFINE_U2_SH		16
+#define F2P_USER_DEFINE_U2_MSK		0xff
+#define F2P_USER_DEFINE_EXT_U2_SH	24
+#define F2P_USER_DEFINE_EXT_U2_MSK	0xff
+
+/* dword18 */
+#define F2P_UL_ADDR_IDX_U2_SH		0
+#define F2P_UL_ADDR_IDX_U2_MSK		0xff
+#define F2P_UL_DCM_U2			BIT(8)
+#define F2P_UL_FEC_COD_U2		BIT(9)
+#define F2P_UL_RU_RATE_U2_SH		10
+#define F2P_UL_RU_RATE_U2_MSK		0x7f
+#define F2P_UL_RU_ALO_IDX_U2_SH		24
+#define F2P_UL_RU_ALO_IDX_U2_MSK	0xff
+
+/* dword19 */
+
+/* dword20 */
+#define F2P_MACID_U3_SH			0
+#define F2P_MACID_U3_MSK		0xff
+#define F2P_AC_TYPE_U3_SH		8
+#define F2P_AC_TYPE_U3_MSK		0x3
+#define F2P_MU_STA_POS_U3_SH		10
+#define F2P_MU_STA_POS_U3_MSK		0x3
+#define F2P_DL_RATE_IDX_U3_SH		12
+#define F2P_DL_RATE_IDX_U3_MSK		0x1ff
+#define F2P_TX_CMD_DL_DCM_EN_U3		BIT(21)
+#define F2P_RU_ALO_IDX_U3_SH		24
+#define F2P_RU_ALO_IDX_U3_MSK		0xff
+
+/* dword21 */
+#define F2P_PWR_BOOST_U3_SH		0
+#define F2P_PWR_BOOST_U3_MSK		0x1f
+#define F2P_AGG_BMP_ALO_U3_SH		5
+#define F2P_AGG_BMP_ALO_U3_MSK		0x7
+#define F2P_AMPDU_MAX_NUM_U3_SH		8
+#define F2P_AMPDU_MAX_NUM_U3_MSK	0xff
+#define F2P_USER_DEFINE_U3_SH		16
+#define F2P_USER_DEFINE_U3_MSK		0xff
+#define F2P_USER_DEFINE_EXT_U3_SH	24
+#define F2P_USER_DEFINE_EXT_U3_MSK	0xff
+
+/* dword22 */
+#define F2P_UL_ADDR_IDX_U3_SH		0
+#define F2P_UL_ADDR_IDX_U3_MSK		0xff
+#define F2P_UL_DCM_U3			BIT(8)
+#define F2P_UL_FEC_COD_U3		BIT(9)
+#define F2P_UL_RU_RATE_U3_SH		10
+#define F2P_UL_RU_RATE_U3_MSK		0x7f
+#define F2P_UL_RU_ALO_IDX_U3_SH		24
+#define F2P_UL_RU_ALO_IDX_U3_MSK	0xff
+
+/* dword23 */
+
+/* dword24 */
+#define F2P_PKT_ID_0_SH			0
+#define F2P_PKT_ID_0_MSK		0xfff
+#define F2P_VALID_0			BIT(15)
+#define F2P_UL_USER_NUM_0_SH		16
+#define F2P_UL_USER_NUM_0_MSK		0xf
+
+/* dword25 */
+#define F2P_PKT_ID_1_SH			0
+#define F2P_PKT_ID_1_MSK		0xfff
+#define F2P_VALID_1			BIT(15)
+#define F2P_UL_USER_NUM_1_SH		16
+#define F2P_UL_USER_NUM_1_MSK		0xf
+
+/* dword26 */
+#define F2P_PKT_ID_2_SH			0
+#define F2P_PKT_ID_2_MSK		0xfff
+#define F2P_VALID_2			BIT(15)
+#define F2P_UL_USER_NUM_2_SH		16
+#define F2P_UL_USER_NUM_2_MSK		0xf
+
+/* dword27 */
+#define F2P_PKT_ID_3_SH			0
+#define F2P_PKT_ID_3_MSK		0xfff
+#define F2P_VALID_3			BIT(15)
+#define F2P_UL_USER_NUM_3_SH		16
+#define F2P_UL_USER_NUM_3_MSK		0xf
+
+/* dword28 */
+#define F2P_PKT_ID_4_SH			0
+#define F2P_PKT_ID_4_MSK		0xfff
+#define F2P_VALID_4			BIT(15)
+#define F2P_UL_USER_NUM_4_SH		16
+#define F2P_UL_USER_NUM_4_MSK		0xf
+
+/* dword29 */
+#define F2P_PKT_ID_5_SH			0
+#define F2P_PKT_ID_5_MSK		0xfff
+#define F2P_VALID_5			BIT(15)
+#define F2P_UL_USER_NUM_5_SH		16
+#define F2P_UL_USER_NUM_5_MSK		0xf
+
+/**
+ * @struct fwcmd_test_para
+ * @brief fwcmd_test_para
+ *
+ * @var fwcmd_test_para::dword0
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword1
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword2
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword3
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword4
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword5
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword6
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword7
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword8
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte9
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte10
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte11
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte12
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword13
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword14
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword15
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword16
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword17
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword18
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword19
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword20
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword21
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword22
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword23
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword24
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword25
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword26
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword27
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword28
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword29
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword30
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword31
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword32
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword33
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword34
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword35
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword36
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword37
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword38
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword39
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword40
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword41
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword42
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword43
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword44
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword45
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte46
+ * Please Place Description here.
+ */
+
+struct fwcmd_test_para {
+#define MAX_SIGB_LEN 64
+	u32 dword0;
+	u32 dword1;
+	u32 dword2;
+	u32 dword3;
+	u32 dword4;
+	u32 dword5;
+	u32 dword6;
+	u32 dword7;
+	u32 dword8;
+	u8 byte9;
+	u8 byte10;
+	u8 byte11;
+	u8 byte12;
+	u32 dword13;
+	u32 dword14;
+	u32 dword15;
+	u32 dword16;
+	u32 dword17;
+	u32 dword18;
+	u32 dword19;
+	u32 dword20;
+	u32 dword21;
+	u32 dword22;
+	u32 dword23;
+	u32 dword24;
+	u32 dword25;
+	u32 dword26;
+	u32 dword27;
+	u32 dword28;
+	u32 dword29;
+	u32 dword30;
+	u32 dword31;
+	u32 dword32;
+	u32 dword33;
+	u32 dword34;
+	u32 dword35;
+	u32 dword36;
+	u32 dword37;
+	u32 dword38;
+	u32 dword39;
+	u32 dword40;
+	u32 dword41;
+	u32 dword42;
+	u32 dword43;
+	u32 dword44;
+	u32 dword45;
+	u8 byte46[MAX_SIGB_LEN];
+};
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd_intf_f2p_v1.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd_intf_f2p_v1.h
new file mode 100644
index 000000000000..f420c93c9084
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwcmd_intf_f2p_v1.h
@@ -0,0 +1,262 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_FWCMD_INTF_F2P_V1_H_
+#define _MAC_AX_FWCMD_INTF_F2P_V1_H_
+
+/**
+ * @struct fwcmd_test_para_v1
+ * @brief fwcmd_test_para_v1
+ *
+ * @var fwcmd_test_para::dword0
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword1
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword2
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword3
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword4
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword5
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword6
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword7
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword8
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword9
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword10
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword11
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword12
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword13
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword14
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword15
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword16
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword17_0
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword17_1
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword17_2
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword17_3
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword18_0
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword18_1
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword18_2
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword18_3
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword19
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword20
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword21
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword22
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword23
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword24
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword25
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword26
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword27
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword28
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword29
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword30
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword31
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword32
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword33
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword34
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword35
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword36
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword37
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword38
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword39
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword40
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword41
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword42
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword43
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword44
+ * Please Place Description here.
+ * @var fwcmd_test_para::dword45
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte46
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte47
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte48
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte49
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte50
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte51
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte52
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte53
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte54
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte55
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte56
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte57
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte58
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte59
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte60
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte61
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte62
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte63
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte64
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte65
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte66
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte67
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte68
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte69
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte70
+ * Please Place Description here.
+ * @var fwcmd_test_para::byte71
+ * Please Place Description here.
+ */
+struct fwcmd_test_para_v1 {
+	u32 dword0;
+	u32 dword1;
+	u32 dword2;
+	u32 dword3;
+	u32 dword4;
+	u32 dword5;
+	u32 dword6;
+	u32 dword7;
+	u32 dword8;
+	u32 dword9;
+	u32 dword10;
+	u32 dword11;
+	u32 dword12;
+	u32 dword13;
+	u32 dword14;
+	u32 dword15;
+	u32 dword16;
+	u8 dword17_0;
+	u8 dword17_1;
+	u8 dword17_2;
+	u8 dword17_3;
+	u8 dword18_0;
+	u8 dword18_1;
+	u8 dword18_2;
+	u8 dword18_3;
+	u32 dword19;
+	u32 dword20;
+	u32 dword21;
+	u32 dword22;
+	u32 dword23;
+	u32 dword24;
+	u32 dword25;
+	u32 dword26;
+	u32 dword27;
+	u32 dword28;
+	u32 dword29;
+	u32 dword30;
+	u32 dword31;
+	u32 dword32;
+	u32 dword33;
+	u32 dword34;
+	u32 dword35;
+	u32 dword36;
+	u32 dword37;
+	u32 dword38;
+	u32 dword39;
+	u32 dword40;
+	u32 dword41;
+	u32 dword42;
+	u32 dword43;
+	u32 dword44;
+	u32 dword45;
+	u32 dword46;
+	u32 dword47;
+	u32 dword48;
+	u32 dword49;
+	u32 dword50;
+	u32 dword51;
+	u32 dword52;
+	u32 dword53;
+	u32 dword54;
+	u32 dword55;
+	u32 dword56;
+	u32 dword57;
+	u32 dword58;
+	u32 dword59;
+	u32 dword60;
+	u32 dword61;
+	u32 dword62;
+	u32 dword63;
+	u32 dword64;
+	u32 dword65;
+	u32 dword66;
+	u32 dword67;
+	u32 dword68;
+	u32 dword69;
+	u32 dword70;
+	u32 dword71;
+};
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwdl.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwdl.c
new file mode 100644
index 000000000000..938ce244e0ca
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwdl.c
@@ -0,0 +1,2060 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "fwdl.h"
+#define SUPPORT_52BP 1
+static inline void fwhdr_section_parser(struct mac_ax_adapter *adapter,
+					struct fwhdr_section_t *section,
+					struct fwhdr_section_info *info)
+{
+	u32 hdr_val;
+	u32 section_len;
+
+	hdr_val = le32_to_cpu(section->dword1);
+	section_len = GET_FIELD(hdr_val, SECTION_INFO_SEC_SIZE);
+	if (hdr_val & SECTION_INFO_CHECKSUM)
+		section_len += FWDL_SECTION_CHKSUM_LEN;
+	info->type = GET_FIELD(hdr_val, SECTION_INFO_SECTIONTYPE);
+	if (info->type == FWDL_SECURITY_SECTION_TYPE)
+		info->mssc = le32_to_cpu(section->dword2);
+	else
+		info->mssc = 0;
+	info->len = section_len;
+	info->redl = (hdr_val & SECTION_INFO_REDL) ? 1 : 0;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		info->dladdr = (GET_FIELD(le32_to_cpu(section->dword0),
+		SECTION_INFO_SEC_DL_ADDR)) & 0x1FFFFFFF;
+	} else {
+		info->dladdr = (GET_FIELD(le32_to_cpu(section->dword0),	SECTION_INFO_SEC_DL_ADDR));
+	}
+}
+
+static inline u32 fwhdr_hdr_parser(struct mac_ax_adapter *adapter, struct fwhdr_hdr_t *hdr,
+				   struct fw_bin_info *info)
+{
+	u32 hdr_val;
+	u32 val32;
+
+	hdr_val = le32_to_cpu(hdr->dword6);
+	info->section_num = GET_FIELD(hdr_val, FWHDR_SEC_NUM);
+
+	hdr_val = le32_to_cpu(hdr->dword3);
+	info->hdr_len = GET_FIELD(hdr_val, FWHDR_FWHDR_SZ);
+
+	/* fill HALMAC information */
+	hdr_val = le32_to_cpu(hdr->dword7);
+	hdr_val = SET_CLR_WORD(hdr_val, FWDL_SECTION_PER_PKT_LEN,
+			       FWHDR_FW_PART_SZ);
+	info->dynamic_hdr_en = GET_FIELD(hdr_val, FWHDR_FW_DYN_HDR);
+	hdr->dword7 = cpu_to_le32(hdr_val);
+
+	if (info->dynamic_hdr_en) {
+		info->dynamic_hdr_len = info->hdr_len - (FWHDR_HDR_LEN +
+							 info->section_num * FWHDR_SECTION_LEN);
+		val32 = le32_to_cpu(*(u32 *)(((u8 *)hdr) +
+					     (FWHDR_HDR_LEN +
+					      info->section_num * FWHDR_SECTION_LEN)));
+		if (val32 != info->dynamic_hdr_len) {
+			PLTFM_MSG_ERR("[ERR]%s Dynamic Header Len miss match\n", __func__);
+			PLTFM_MSG_ERR("[ERR]Recorded Len (0x%X) != Calculated Len (0x%X)\n", val32,
+				      info->dynamic_hdr_len);
+			return MACCMP;
+		}
+		PLTFM_MSG_TRACE("[TRACE]%s:FW Use Dynamic Header:0x%X\n", __func__,
+				info->dynamic_hdr_en);
+		PLTFM_MSG_TRACE("[TRACE]%s:FW Dynamic Header Len:0x%X\n", __func__, val32);
+	} else {
+		val32 = FWHDR_HDR_LEN + info->section_num * FWHDR_SECTION_LEN;
+		if (val32 != info->hdr_len) {
+			PLTFM_MSG_ERR("[ERR]%s Static Header Len miss match\n", __func__);
+			PLTFM_MSG_ERR("[ERR]Recorded Len (0x%X) != Calculated Len (0x%X)\n", val32,
+				      info->hdr_len);
+			return MACCMP;
+		}
+		info->dynamic_hdr_len = 0;
+	}
+
+	hdr_val = le32_to_cpu(hdr->dword2);
+	info->git_idx = GET_FIELD(hdr_val, FWHDR_COMMITID);
+	return MACSUCCESS;
+}
+
+static u32 get_ple_base(struct mac_ax_adapter *adapter)
+{
+	u32 chip_id;
+	u32 ple_base = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	chip_id = GET_FIELD(MAC_REG_R32(R_AX_SYS_CHIPINFO), B_AX_HW_ID);
+
+	switch (chip_id) {
+#ifdef MAC_8852A_SUPPORT
+	case RTL8852A_ID:
+		ple_base = FWDL_PLE_BASE_ADDR_8852A;
+		break;
+#endif
+#ifdef MAC_8852B_SUPPORT
+	case RTL8852B_ID:
+		ple_base = FWDL_PLE_BASE_ADDR_8852B;
+		break;
+#endif
+#ifdef MAC_8852C_SUPPORT
+	case RTL8852C_ID:
+		ple_base = FWDL_PLE_BASE_ADDR_8852C;
+		break;
+#endif
+#ifdef MAC_8192XB_SUPPORT
+	case RTL8192XB_ID:
+		ple_base = FWDL_PLE_BASE_ADDR_8192XB;
+		break;
+#endif
+#ifdef MAC_8851B_SUPPORT
+	case RTL8851B_ID:
+		ple_base = FWDL_PLE_BASE_ADDR_8851B;
+		break;
+#endif
+#ifdef MAC_8851E_SUPPORT
+	case RTL8851E_ID:
+		ple_base = FWDL_PLE_BASE_ADDR_8851E;
+		break;
+#endif
+#ifdef MAC_8852D_SUPPORT
+	case RTL8852D_ID:
+		ple_base = FWDL_PLE_BASE_ADDR_8852D;
+		break;
+#endif
+	default:
+		PLTFM_MSG_ERR("[ERR]%s: invalid chip\n", __func__);
+		ple_base = 0;
+		break;
+	}
+	return ple_base;
+}
+
+static s8 __mss_index(struct mac_ax_adapter *adapter)
+{
+	s8 ret = 0;
+	u8 externalPN = 0;
+	u8 customer = 0;
+	u8 serialNum = 0;
+	u8 b1;
+	u8 b2;
+	u8 i;
+	enum mac_ax_efuse_bank bank = MAC_AX_EFUSE_BANK_WIFI;
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+
+	if (ops->read_efuse(adapter, EFUSE_EXTERNALPN_ADDR, 1, &b1, bank) != 0) {
+		PLTFM_MSG_ERR("[ERR]%s: Read efuse 0x5EC failed.\n", __func__);
+		return -1;
+	}
+	if (ops->read_efuse(adapter, EFUSE_CUSTOMER_ADDR, 1, &b2, bank) != 0) {
+		PLTFM_MSG_ERR("[ERR]%s: Read efuse 0x5ED failed.\n", __func__);
+		return -1;
+	}
+	b1 = le32_to_cpu(b1);
+	b2 = le32_to_cpu(b2);
+	externalPN = 0xFF - GET_FIELD(b1, EFUSE_EXTERNALPN);
+	customer = 0xF - GET_FIELD(b2, EFUSE_CUSTOMER);
+	serialNum = 0x7 - GET_FIELD(b2, EFUSE_SERIALNUM);
+	PLTFM_MSG_ALWAYS("[DBG]%s: External PN %x\n", __func__, externalPN);
+	PLTFM_MSG_ALWAYS("[DBG]%s: customer %x\n", __func__, customer);
+	PLTFM_MSG_ALWAYS("[DBG]%s: Serial Num %x\n", __func__, serialNum);
+	for (i = 0; i < OTP_KEY_INFO_NUM; i++) {
+		if (externalPN == otp_key_info_externalPN[i] &&
+		    customer == otp_key_info_customer[i] &&
+		    serialNum == otp_key_info_serialNum[i]) {
+			ret = (s8)i;
+			break;
+		}
+	}
+	PLTFM_MSG_ALWAYS("[DBG]%s: ret %d\n", __func__, ret);
+	return ret;
+}
+
+static u32 fwhdr_parser(struct mac_ax_adapter *adapter, u8 *fw, u32 len,
+			struct fw_bin_info *info)
+{
+	u32 i;
+	u8 *fw_end = fw + len;
+	u8 *bin_ptr;
+	struct fwhdr_section_info *cur_section_info;
+	u32 ret;
+	u32 fwdl_ple_base;
+	enum DLE_RSVD_INFO dle_info;
+	u8 *mss_start;
+	u8 *mss_selected;
+	s8 mss_idx;
+
+	if (!info) {
+		PLTFM_MSG_ERR("[ERR]%s: *info = NULL\n", __func__);
+		return MACNPTR;
+	} else if (!fw) {
+		PLTFM_MSG_ERR("[ERR]%s: *fw = NULL\n", __func__);
+		return MACNOITEM;
+	} else if (!len) {
+		PLTFM_MSG_ERR("[ERR]%s: len = 0\n", __func__);
+		return MACBUFSZ;
+	}
+
+	fwdl_ple_base = get_ple_base(adapter);
+	ret = fwhdr_hdr_parser(adapter, (struct fwhdr_hdr_t *)fw, info);
+	if (ret)
+		return ret;
+	bin_ptr = fw + info->hdr_len;
+
+	/* jump to section header */
+	fw += FWHDR_HDR_LEN;
+	cur_section_info = info->section_info;
+	info->is_fw_use_ple = 0;
+	for (i = 0; i < info->section_num; i++) {
+		fwhdr_section_parser(adapter, (struct fwhdr_section_t *)fw,
+				     cur_section_info);
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+			if (cur_section_info->type == FWDL_SECURITY_SECTION_TYPE) {
+				cur_section_info->len = 2048;
+				((struct fwhdr_section_t *)fw)->dword1 = 0x09000800; //0x800 = 2048
+			}
+		}
+		cur_section_info->addr = bin_ptr;
+		bin_ptr += cur_section_info->len;
+		if (cur_section_info->dladdr == fwdl_ple_base)
+			info->is_fw_use_ple = 1;
+		if (cur_section_info->type == FWDL_SECURITY_SECTION_TYPE &&
+			cur_section_info->mssc > 0) {
+			fw_end -= (cur_section_info->mssc * FWDL_SECURITY_SIGLEN);
+			mss_start = cur_section_info->addr + FWDL_SECURITY_SECTION_CONSTANT;
+			mss_idx = __mss_index(adapter);
+			if (mss_idx < 0) {
+				PLTFM_MSG_ERR("[ERR]%s:", __func__);
+				PLTFM_MSG_ERR("Failed to get secure info offset\n");
+				return MACFWBIN;
+			}
+			mss_selected = bin_ptr + (mss_idx * FWDL_SECURITY_SIGLEN);
+			PLTFM_MEMCPY(mss_start, mss_selected, FWDL_SECURITY_SIGLEN);
+			if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+				// Workaround for 1344 workaround,
+				// Secure Boot CAN NOT have 1344 workaround
+				// Assuming if mss_idx>0, than we are in secure boot.
+				// Sub 1088 (1344-256) from cur_section_info->len
+				if (mss_idx > 0) {
+					//cur_section_info->len should be 960
+					cur_section_info->len = 960;
+					//0x3C0=960
+					((struct fwhdr_section_t *)fw)->dword1 = 0x090003C0;
+				}
+			}
+		}
+		fw += FWHDR_SECTION_LEN;
+		cur_section_info++;
+	}
+
+	ret = get_dle_rsvd_info(adapter, (enum DLE_RSVD_INFO *)&dle_info);
+	if (ret != MACSUCCESS)
+		return ret;
+	// Check DLE reserved quota for FW
+	if (dle_info != DLE_RSVD_INFO_FW && info->is_fw_use_ple) {
+		PLTFM_MSG_ERR("[ERR]%s: ", __func__);
+		PLTFM_MSG_ERR("fw try to download something to ple illegally\n");
+		return MACFWBIN;
+	}
+
+	if (fw_end != bin_ptr) {
+		PLTFM_MSG_ERR("[ERR]%s: ", __func__);
+		PLTFM_MSG_ERR("fw bin size (0x%x) != fw size in fwhdr (0x%x)\n",
+			      len, (u32)(bin_ptr - fw));
+		return MACFWBIN;
+	}
+
+	return MACSUCCESS;
+}
+
+static inline u32 update_fw_ver(struct mac_ax_adapter *adapter,
+				struct fwhdr_hdr_t *hdr)
+{
+	u32 hdr_val;
+	struct mac_ax_fw_info *info = &adapter->fw_info;
+
+	hdr_val = le32_to_cpu(hdr->dword1);
+	info->major_ver = GET_FIELD(hdr_val, FWHDR_MAJORVER);
+	info->minor_ver = GET_FIELD(hdr_val, FWHDR_MINORVER);
+	info->sub_ver = GET_FIELD(hdr_val, FWHDR_SUBVERSION);
+	info->sub_idx = GET_FIELD(hdr_val, FWHDR_SUBINDEX);
+
+	hdr_val = le32_to_cpu(hdr->dword5);
+	info->build_year = GET_FIELD(hdr_val, FWHDR_YEAR);
+
+	hdr_val = le32_to_cpu(hdr->dword4);
+	info->build_mon = GET_FIELD(hdr_val, FWHDR_MONTH);
+	info->build_date = GET_FIELD(hdr_val, FWHDR_DATE);
+	info->build_hour = GET_FIELD(hdr_val, FWHDR_HOUR);
+	info->build_min = GET_FIELD(hdr_val, FWHDR_MIN);
+
+	info->h2c_seq = 0;
+	info->rec_seq = 0;
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_dynamic_hdr_ax(struct mac_ax_adapter *adapter, u8 *fw, u32 fw_len)
+{
+	u32 ret = MACSUCCESS;
+	struct fw_bin_info info;
+	u32 dynamic_hdr_len = 0;
+	u32 dynamic_hdr_count = 0;
+	u16 dynamic_section_len = 0;
+	u8 dynamic_section_type = 0;
+	u32 val32 = 0;
+	u32 total_len = 0;
+	u8 *dynamic_hdr_content;
+	u8 *content;
+
+	adapter->fw_info.cap_size = 0;
+	PLTFM_MEMSET(adapter->fw_info.cap_buff, 0, MAC_WLANFW_CAP_MAX_SIZE);
+
+	if (!fw) {
+		PLTFM_MSG_ERR("[ERR]%s: FW == NULL\n", __func__);
+		return MACNOFW;
+	}
+	ret = fwhdr_hdr_parser(adapter, (struct fwhdr_hdr_t *)fw, &info);
+	if (ret)
+		return ret;
+	if (!info.dynamic_hdr_en) {
+		PLTFM_MSG_TRACE("[TRACE]%s: WCPU Dynamic Header Disabled\n", __func__);
+		return MACSUCCESS;
+	}
+	PLTFM_MSG_TRACE("[TRACE]%s: WCPU Dynamic Header Enabled\n", __func__);
+	dynamic_hdr_content = fw + (FWHDR_HDR_LEN + info.section_num * FWHDR_SECTION_LEN);
+	dynamic_hdr_len = le32_to_cpu(*(u32 *)dynamic_hdr_content);
+	dynamic_hdr_count = le32_to_cpu(*(u32 *)(dynamic_hdr_content + 4));
+	dynamic_hdr_content += 8;
+	total_len += 8;
+	PLTFM_MSG_TRACE("[TRACE]%s: dynamic_hdr_len:0x%X\n", __func__, dynamic_hdr_len);
+	PLTFM_MSG_TRACE("[TRACE]%s: dynamic_hdr_count:0x%X\n", __func__, dynamic_hdr_count);
+	// Check Dynamic Header length match first, so we won't need to malloc and free if failed.
+	for (val32 = 0; val32 < dynamic_hdr_count; val32++) {
+		dynamic_section_len = le16_to_cpu(*(u16 *)(dynamic_hdr_content));
+		dynamic_section_type = *(u8 *)(dynamic_hdr_content + 2);
+		PLTFM_MSG_TRACE("[TRACE]%s: Dynamic Hdr Section %d Len:0x%X\n", __func__,
+				val32, dynamic_section_len);
+		PLTFM_MSG_TRACE("[TRACE]%s: Dynamic Hdr Section %d Type:0x%X\n", __func__,
+				val32, dynamic_section_type);
+		total_len += dynamic_section_len;
+		dynamic_hdr_content += dynamic_section_len;
+	}
+	if (total_len % 16)
+		total_len += (16 - (total_len % 16));
+	if (total_len != dynamic_hdr_len) {
+		PLTFM_MSG_ERR("[ERR]%s: Dynamic Hdr Len Compare Fail:0x%X!=0x%X\n",
+			      __func__, total_len, dynamic_hdr_len);
+		return MACCMP;
+	}
+	// Restore dynamic_hdr_content, reparsing from dynamic head again
+	dynamic_hdr_content = fw + (FWHDR_HDR_LEN + info.section_num * FWHDR_SECTION_LEN);
+	dynamic_hdr_content += 8;
+	for (val32 = 0; val32 < dynamic_hdr_count; val32++) {
+		dynamic_section_len = le16_to_cpu(*(u16 *)(dynamic_hdr_content));
+		dynamic_section_type = *(u8 *)(dynamic_hdr_content + 2);
+		content = dynamic_hdr_content + 4;
+		//switch CPU
+		switch (dynamic_section_type) {
+		case FWDL_DYNAMIC_HDR_FWCAP:
+			if (dynamic_section_len - 4 > MAC_WLANFW_CAP_MAX_SIZE) {
+				PLTFM_MSG_ERR("[ERR]%s: Dynamic Hdr Len 0x%X Exceed Fix Len 0x%X\n",
+					      __func__, dynamic_section_len - 4,
+					      MAC_WLANFW_CAP_MAX_SIZE);
+				return MACNOBUF;
+			}
+			PLTFM_MEMCPY(adapter->fw_info.cap_buff, content, dynamic_section_len - 4);
+			adapter->fw_info.cap_size = dynamic_section_len - 4;
+			break;
+		case FWDL_DYNAMIC_HDR_NOUSE:
+		case FWDL_DYNAMIC_HDR_MAX:
+		default:
+			PLTFM_MSG_ERR("[ERR]%s: Dynamic Hdr Type Unused or Undefind:0x%X\n",
+				      __func__, dynamic_section_type);
+			return MACNOITEM;
+		}
+		dynamic_hdr_content += dynamic_section_len;
+	}
+
+	return ret;
+}
+
+static u32 __fwhdr_download(struct mac_ax_adapter *adapter,
+			    u8 *fw, u32 hdr_len, u8 redl)
+{
+	u8 *buf;
+	u32 ret = 0;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb) {
+		PLTFM_MSG_ERR("[ERR]%s: h2cb_alloc fail\n", __func__);
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cb, hdr_len);
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]%s: h2cb_put fail\n", __func__);
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	PLTFM_MEMCPY(buf, fw, hdr_len);
+
+	if (redl) {
+		ret = h2c_pkt_set_hdr_fwdl(adapter, h2cb,
+					   FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+					   FWCMD_H2C_CL_FWDL,
+					   FWCMD_H2C_FUNC_FWHDR_REDL, 0, 0);
+	} else {
+		ret = h2c_pkt_set_hdr_fwdl(adapter, h2cb,
+					   FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+					   FWCMD_H2C_CL_FWDL,
+					   FWCMD_H2C_FUNC_FWHDR_DL, 0, 0);
+	}
+
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: set h2c hdr fail\n", __func__);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: build h2c txd fail\n", __func__);
+		goto fail;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: PLTFM_TX fail\n", __func__);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	PLTFM_MSG_ERR("[ERR]%s ret: %d\n", __func__, ret);
+
+	return ret;
+}
+
+#if MAC_AX_PHL_H2C
+static u32 __sections_build_txd(struct mac_ax_adapter *adapter,
+				struct rtw_h2c_pkt *h2cb)
+{
+	u8 *buf;
+	u32 ret;
+	u32 txd_len;
+	struct rtw_t_meta_data info = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+
+	info.type = RTW_PHL_PKT_TYPE_FWDL;
+	info.pktlen = (u16)h2cb->data_len;
+	txd_len = ops->txdesc_len(adapter, &info);
+
+	buf = h2cb_push(h2cb, txd_len);
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]%s: h2cb_push fail\n", __func__);
+		return MACNPTR;
+	}
+
+	ret = ops->build_txdesc(adapter, &info, buf, txd_len);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: ", __func__);
+		PLTFM_MSG_ERR("build_txdesc fail\n");
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 __sections_push(struct rtw_h2c_pkt *h2cb)
+{
+#define section_push_len 8
+	h2cb->vir_data -= section_push_len;
+	h2cb->vir_tail -= section_push_len;
+
+	return MACSUCCESS;
+}
+
+#else
+static u32 __sections_build_txd(struct mac_ax_adapter *adapter,
+				struct h2c_buf *h2cb)
+{
+	u8 *buf;
+	u32 ret;
+	u32 txd_len;
+	struct rtw_t_meta_data info;
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+
+	info.type = RTW_PHL_PKT_TYPE_FWDL;
+	info.pktlen = (u16)h2cb->len;
+	txd_len = ops->txdesc_len(adapter, &info);
+
+	buf = h2cb_push(h2cb, txd_len);
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]%s: h2cb_push fail\n", __func__);
+		return MACNPTR;
+	}
+
+	ret = ops->build_txdesc(adapter, &info, buf, txd_len);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: ", __func__);
+		PLTFM_MSG_ERR("mac_build_txdesc fail\n");
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+#endif
+static u32 __sections_download(struct mac_ax_adapter *adapter,
+			       struct fwhdr_section_info *info)
+{
+	u8 *section = info->addr;
+	u32 residue_len = info->len;
+	u32 pkt_len;
+	u8 *buf;
+	u32 ret = 0;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+
+	while (residue_len) {
+		if (residue_len >= FWDL_SECTION_PER_PKT_LEN)
+			pkt_len = FWDL_SECTION_PER_PKT_LEN;
+		else
+			pkt_len = residue_len;
+
+		h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+		if (!h2cb) {
+			PLTFM_MSG_ERR("[ERR]%s: ", __func__);
+			PLTFM_MSG_ERR("h2cb_alloc fail\n");
+			return MACNPTR;
+		}
+		#if MAC_AX_PHL_H2C
+		__sections_push(h2cb);
+		#endif
+		buf = h2cb_put(h2cb, pkt_len);
+		if (!buf) {
+			PLTFM_MSG_ERR("[ERR]%s: ", __func__);
+			PLTFM_MSG_ERR("h2cb_put fail\n");
+			ret = MACNOBUF;
+			goto fail;
+		}
+
+		PLTFM_MEMCPY(buf, section, pkt_len);
+
+		ret = __sections_build_txd(adapter, h2cb);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s: ", __func__);
+			PLTFM_MSG_ERR("__sections_build_txd fail\n");
+			goto fail;
+		}
+		#if MAC_AX_PHL_H2C
+		ret = PLTFM_TX(h2cb);
+		#else
+		ret = PLTFM_TX(h2cb->data, h2cb->len);
+		#endif
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s: PLTFM_TX fail\n", __func__);
+			goto fail;
+		}
+
+		h2cb_free(adapter, h2cb);
+
+		section += pkt_len;
+		residue_len -= pkt_len;
+	}
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	PLTFM_MSG_ERR("[ERR]%s ret: %d\n", __func__, ret);
+
+	return ret;
+}
+
+static u32 __write_memory(struct mac_ax_adapter *adapter,
+			  u8 *buffer, u32 addr, u32 len)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 *content = NULL;
+	u32 dl_size;
+	u32 target_addr, write_addr;
+	u32 seg_size, seg_bytes;
+	u32 val32;
+	u32 index = 0;
+	u32 ret = MACSUCCESS;
+
+	if (adapter->hw_info->is_sec_ic) {
+		PLTFM_MSG_ERR("[ERR]security mode ind accees\n");
+		PLTFM_MSG_ERR("[ERR]Abort %s.\n", __func__);
+		return MACIOERRINSEC;
+	}
+
+	PLTFM_MSG_WARN("%s ind access start\n", __func__);
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+	adapter->hw_info->ind_aces_cnt++;
+
+	MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, addr);
+	MAC_REG_W32(R_AX_INDIR_ACCESS_ENTRY, 0xAAAAAAAA);
+	MAC_REG_W32(R_AX_INDIR_ACCESS_ENTRY + 4, 0xBBBBBBBB);
+
+	val32 = MAC_REG_R32(R_AX_INDIR_ACCESS_ENTRY);
+	if (val32 != 0xAAAAAAAA) {
+		ret = MACMEMRO;
+		goto ind_aces_end;
+	}
+
+	val32 = MAC_REG_R32(R_AX_INDIR_ACCESS_ENTRY + 4);
+	if (val32 != 0xBBBBBBBB) {
+		ret = MACMEMRO;
+		goto ind_aces_end;
+	}
+
+ind_aces_end:
+	adapter->hw_info->ind_aces_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->ind_access_lock);
+	PLTFM_MSG_WARN("%s ind access end\n", __func__);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	content = (u8 *)PLTFM_MALLOC(len);
+	if (!content) {
+		PLTFM_MSG_ERR("[ERR]%s: malloc fail\n", __func__);
+		return MACNOBUF;
+	}
+
+	PLTFM_MEMCPY(content, buffer, len);
+
+	dl_size = len;
+	target_addr = addr;
+
+	PLTFM_MSG_WARN("%s ind access trg 0x%X start\n", __func__, target_addr);
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+	adapter->hw_info->ind_aces_cnt++;
+	while (dl_size != 0) {
+		MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, target_addr);
+		write_addr = R_AX_INDIR_ACCESS_ENTRY;
+
+		if (dl_size >= ROMDL_SEG_LEN)
+			seg_size = ROMDL_SEG_LEN;
+		else
+			seg_size = dl_size;
+
+		seg_bytes = seg_size;
+
+		while (seg_bytes != 0) {
+			val32 = *((u32 *)(content + index));
+			MAC_REG_W32(write_addr,
+				    cpu_to_le32(val32));
+
+			seg_bytes -= 4;
+			write_addr += 4;
+			index += 4;
+		}
+
+		target_addr += seg_size;
+		dl_size -= seg_size;
+	}
+	adapter->hw_info->ind_aces_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->ind_access_lock);
+	PLTFM_MSG_WARN("%s ind access trg 0x%X end\n", __func__, target_addr);
+
+	PLTFM_FREE(content, len);
+
+	return MACSUCCESS;
+}
+
+static u32 fwdl_phase0(struct mac_ax_adapter *adapter)
+{
+	u32 cnt = FWDL_WAIT_CNT;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	PLTFM_MSG_TRACE("[TRACE]%s:Start.\n", __func__);
+	if (adapter->sm.fwdl != MAC_AX_FWDL_CPU_ON) {
+		PLTFM_MSG_ERR("[ERR]%s: state != CPU_ON\n", __func__);
+		return MACPROCERR;
+	}
+
+	while (--cnt) {
+		if (MAC_REG_R8(R_AX_WCPU_FW_CTRL) & B_AX_H2C_PATH_RDY)
+			break;
+		PLTFM_DELAY_US(1);
+	}
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR]%s: poll 0x1E0[1] = 1 fail\n", __func__);
+		return MACPOLLTO;
+	}
+
+	adapter->sm.fwdl = MAC_AX_FWDL_H2C_PATH_RDY;
+	PLTFM_MSG_TRACE("[TRACE]%s:End.\n", __func__);
+
+	return MACSUCCESS;
+}
+
+static u32 fwdl_phase1(struct mac_ax_adapter *adapter,
+		       u8 *fw, u32 hdr_len, u8 redl)
+{
+	u32 ret;
+	u32 cnt = FWDL_WAIT_CNT;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	PLTFM_MSG_TRACE("[TRACE]%s:Start.\n", __func__);
+	if (adapter->sm.fwdl != MAC_AX_FWDL_H2C_PATH_RDY) {
+		PLTFM_MSG_ERR("[ERR]%s: state != H2C_PATH_RDY\n", __func__);
+		return MACPROCERR;
+	}
+
+	ret = __fwhdr_download(adapter, fw, hdr_len, redl);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: __fwhdr_download fail\n", __func__);
+		return ret;
+	}
+
+	while (--cnt) {
+		if (MAC_REG_R8(R_AX_WCPU_FW_CTRL) & B_AX_FWDL_PATH_RDY)
+			break;
+		PLTFM_DELAY_US(1);
+	}
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR]%s: poll 0x1E0[2] = 1 fail\n", __func__);
+		return MACPOLLTO;
+	}
+
+	MAC_REG_W32(R_AX_HALT_H2C_CTRL, 0);
+	MAC_REG_W32(R_AX_HALT_C2H_CTRL, 0);
+
+	adapter->sm.fwdl = MAC_AX_FWDL_PATH_RDY;
+	PLTFM_MSG_TRACE("[TRACE]%s:End.\n", __func__);
+
+	return MACSUCCESS;
+}
+
+static u32 check_fw_rdy(struct mac_ax_adapter *adapter)
+{
+	u32 pre_val8;
+	u32 val8 = FWDL_INITIAL_STATE;
+	u32 cnt = FWDL_WAIT_CNT;
+	u32 pre_bootstep = 0, cur_bootstep = 0, pre_secure_step = 0, cur_secure_step = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+#if defined(MAC_8852A_SUPPORT) || defined(MAC_8852B_SUPPORT) || defined(MAC_8851B_SUPPORT)
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		pre_bootstep = GET_FIELD(MAC_REG_R32(R_AX_BOOT_DBG), B_AX_BOOT_STATUS);
+		pre_secure_step = GET_FIELD(MAC_REG_R32(R_AX_BOOT_DBG), B_AX_SECUREBOOT_STATUS);
+	}
+#endif
+#if defined(MAC_8852C_SUPPORT) || defined(MAC_8192XB_SUPPORT) || \
+defined(MAC_8851E_SUPPORT) || defined(MAC_8852D_SUPPORT)
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		pre_bootstep = GET_FIELD(MAC_REG_R32(R_AX_BOOT_DBG_V1), B_AX_BOOT_STATUS);
+		pre_secure_step = GET_FIELD(MAC_REG_R32(R_AX_BOOT_DBG_V1), B_AX_SECUREBOOT_STATUS);
+	}
+#endif
+	pre_val8 = GET_FIELD(MAC_REG_R8(R_AX_WCPU_FW_CTRL),
+			     B_AX_WCPU_FWDL_STS);
+
+	while (--cnt) {
+#if defined(MAC_8852A_SUPPORT) || defined(MAC_8852B_SUPPORT) || defined(MAC_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			cur_bootstep = GET_FIELD(MAC_REG_R32(R_AX_BOOT_DBG), B_AX_BOOT_STATUS);
+			cur_secure_step = GET_FIELD(MAC_REG_R32(R_AX_BOOT_DBG),
+						    B_AX_SECUREBOOT_STATUS);
+		}
+#endif
+#if defined(MAC_8852C_SUPPORT) || defined(MAC_8192XB_SUPPORT) || \
+defined(MAC_8851E_SUPPORT) || defined(MAC_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			cur_bootstep = GET_FIELD(MAC_REG_R32(R_AX_BOOT_DBG_V1), B_AX_BOOT_STATUS);
+			cur_secure_step = GET_FIELD(MAC_REG_R32(R_AX_BOOT_DBG_V1),
+						    B_AX_SECUREBOOT_STATUS);
+		}
+#endif
+		val8 = GET_FIELD(MAC_REG_R8(R_AX_WCPU_FW_CTRL),
+				 B_AX_WCPU_FWDL_STS);
+		if (cur_bootstep != pre_bootstep) {
+			PLTFM_MSG_TRACE("[TRACE]%s: BOOTSTEP 0x%x -> 0x%x\n",
+					__func__, pre_bootstep, cur_bootstep);
+			pre_bootstep = cur_bootstep;
+		}
+		if (cur_secure_step != pre_secure_step) {
+			PLTFM_MSG_TRACE("[TRACE]%s: SECURE_STEP 0x%x -> 0x%x\n",
+					__func__, pre_secure_step, cur_secure_step);
+			pre_secure_step = cur_secure_step;
+		}
+		if (val8 != pre_val8) {
+			PLTFM_MSG_TRACE("[TRACE]%s: 0x1E0[7:5] 0x%x -> 0x%x\n",
+					__func__, pre_val8, val8);
+			pre_val8 = val8;
+		}
+		if (val8 == FWDL_WCPU_FW_INIT_RDY) {
+			break;
+		} else if (val8 == FWDL_CHECKSUM_FAIL) {
+			PLTFM_MSG_ERR("[ERR]%s: FWDL_DISPATCHER_CHECKSUM_FAIL\n", __func__);
+			PLTFM_MSG_ERR("[ERR]%s: 0x1E0[7:5] last value = %d\n", __func__, val8);
+			return MACFWCHKSUM;
+		} else if (val8 == FWDL_SECURITY_FAIL) {
+			PLTFM_MSG_ERR("[ERR]%s: FWDL_SECURITY_FAIL\n", __func__);
+			PLTFM_MSG_ERR("[ERR]%s: 0x1E0[7:5] last value = %d\n", __func__, val8);
+			return MACFWSECBOOT;
+		} else if (val8 == FWDL_CUT_NOT_MATCH) {
+			PLTFM_MSG_ERR("[ERR]%s: FWDL_CUT_NOT_MATCH\n", __func__);
+			PLTFM_MSG_ERR("[ERR]%s: 0x1E0[7:5] last value = %d\n", __func__, val8);
+			return MACFWCUT;
+		}
+		PLTFM_DELAY_US(1);
+	}
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR]%s: Polling 0x1E0[7:5] == 7 Timeout\n", __func__);
+		PLTFM_MSG_ERR("[ERR]%s: 0x1E0[7:5] last value = %d\n", __func__, val8);
+		return MACPOLLTO;
+	}
+
+	adapter->sm.fwdl = MAC_AX_FWDL_INIT_RDY;
+
+	return MACSUCCESS;
+}
+
+static u32 fwdl_phase2(struct mac_ax_adapter *adapter, u8 *fw,
+		       struct fw_bin_info *info, u8 redl)
+{
+	u32 ret;
+	u32 section_num = info->section_num;
+	struct fwhdr_section_info *section_info = info->section_info;
+
+	PLTFM_MSG_TRACE("[TRACE]%s:Start.\n", __func__);
+	if (adapter->sm.fwdl != MAC_AX_FWDL_PATH_RDY) {
+		PLTFM_MSG_ERR("[ERR]%s: state != FWDL_PATH_RDY\n", __func__);
+		return MACPROCERR;
+	}
+	PLTFM_MSG_TRACE("[TRACE]%s:Section Download Start.\n", __func__);
+	while (section_num > 0) {
+		PLTFM_MSG_TRACE("[TRACE]%s:Remain Section Count:%d\n", __func__, section_num);
+		if (!redl) {
+			ret = __sections_download(adapter, section_info);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s: ", __func__);
+				PLTFM_MSG_ERR("__sections_download fail\n");
+				return ret;
+			}
+		} else {
+			if (section_info->redl) {
+				ret = __sections_download(adapter,
+							  section_info);
+				if (ret) {
+					PLTFM_MSG_ERR("[ERR]%s: ", __func__);
+					PLTFM_MSG_ERR("__sections_download ");
+					PLTFM_MSG_ERR("fail\n");
+					return ret;
+				}
+			}
+		}
+		section_info++;
+		section_num--;
+	}
+	PLTFM_MSG_TRACE("[TRACE]%s:Section Send End.\n", __func__);
+	PLTFM_DELAY_MS(5);
+	PLTFM_MSG_TRACE("[TRACE]%s:Polling 0x1E0[7:5] = 7 Start\n", __func__);
+	ret = check_fw_rdy(adapter);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: check_fw_rdy fail\n", __func__);
+		return ret;
+	}
+	PLTFM_MSG_TRACE("[TRACE]%s:Polling 0x1E0[7:5] = 7 End\n", __func__);
+	PLTFM_MSG_TRACE("[TRACE]%s:End.\n", __func__);
+	return MACSUCCESS;
+}
+
+static void fwdl_fail_dump(struct mac_ax_adapter *adapter,
+			   struct fw_bin_info *info, u32 ret)
+{
+	u32 val32;
+	u16 val16, index;
+	u8 chip_id;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+#if MAC_AX_FEATURE_DBGPKG
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	struct mac_ax_dbgpkg dbg_val = {0};
+	struct mac_ax_dbgpkg_en dbg_en = {0};
+#endif
+
+	chip_id = adapter->hw_info->chip_id;
+	PLTFM_MSG_ERR("[ERR]fwdl ret = %d\n", ret);
+	val32 = MAC_REG_R32(R_AX_WCPU_FW_CTRL);
+	PLTFM_MSG_ERR("[ERR]fwdl 0x1E0 = 0x%x\n", val32);
+
+#if defined(MAC_8852A_SUPPORT) || defined(MAC_8852B_SUPPORT) || defined(MAC_8851B_SUPPORT)
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		val16 = MAC_REG_R16(R_AX_BOOT_DBG + 2);
+		PLTFM_MSG_ERR("[ERR]fwdl 0x83F2 = 0x%x\n", val16);
+	}
+
+#elif defined(MAC_8852C_SUPPORT) || defined(MAC_8192XB_SUPPORT) || \
+defined(MAC_8851E_SUPPORT) || defined(MAC_8852D_SUPPORT)
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		val16 = MAC_REG_R16(R_AX_BOOT_DBG_V1 + 2);
+		PLTFM_MSG_ERR("[ERR]fwdl 0x78F2 = 0x%x\n", val16);
+	}
+#else
+#error Chip not define
+#endif
+	val32 = MAC_REG_R32(R_AX_UDM3);
+	PLTFM_MSG_ERR("[ERR]fwdl 0x1FC = 0x%x\n", val32);
+
+	val32 = info->git_idx;
+	PLTFM_MSG_ERR("[ERR]fw git idx = 0x%x\n", val32);
+
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->dbg_port_lock);
+	adapter->hw_info->dbg_port_cnt++;
+	if (adapter->hw_info->dbg_port_cnt != 1) {
+		PLTFM_MSG_ERR("[ERR]fwdl fail dump lock cnt %d\n",
+			      adapter->hw_info->dbg_port_cnt);
+		goto end;
+	}
+
+	MAC_REG_W32(R_AX_DBG_CTRL, 0xf200f2);
+	val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+	val32 = SET_CLR_WORD(val32, 0x1, B_AX_SEL_0XC0);
+	MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+
+	for (index = 0; index < 15; index++) {
+		switch (chip_id) {
+#if defined(MAC_8852A_SUPPORT) || defined(MAC_8852B_SUPPORT) || defined(MAC_8851B_SUPPORT)
+		case RTL8852A_ID:
+		case RTL8852B_ID:
+		case RTL8851B_ID:
+			val32 = MAC_REG_R32(R_AX_DBG_PORT_SEL);
+			break;
+#endif
+#if defined(MAC_8852C_SUPPORT) || defined(MAC_8192XB_SUPPORT) || \
+defined(MAC_8851E_SUPPORT) || defined(MAC_8852D_SUPPORT)
+		case RTL8852C_ID:
+		case RTL8192XB_ID:
+		case RTL8851E_ID:
+		case RTL8852D_ID:
+			val32 = MAC_REG_R32(R_AX_WLCPU_PORT_PC);
+			break;
+#endif
+		default:
+			val32 = 0xEAEAEAEA;
+			PLTFM_MSG_ERR("Unknown Chip ID.\n");
+			break;
+		}
+		PLTFM_MSG_ERR("[ERR]fw PC = 0x%x\n", val32);
+		PLTFM_DELAY_US(10);
+	}
+
+	//unknown purpose dump, disable
+	//mac_dump_ple_dbg_page(adapter, 0);
+
+	pltfm_dbg_dump(adapter);
+end:
+#if MAC_AX_FEATURE_DBGPKG
+	dbg_en.ss_dbg = 0;
+	dbg_en.dle_dbg = 0;
+	dbg_en.dmac_dbg = 0;
+	dbg_en.cmac_dbg = 0;
+	dbg_en.mac_dbg_port = 0;
+	dbg_en.plersvd_dbg = 0;
+	mac_ops->dbg_status_dump(adapter, &dbg_val, &dbg_en);
+#endif
+	adapter->hw_info->dbg_port_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->dbg_port_lock);
+}
+
+u32 mac_fwredl(struct mac_ax_adapter *adapter, u8 *fw, u32 len)
+{
+	u32 val32;
+	u32 ret;
+	struct fw_bin_info info;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	//FWREDL funtion is available only on 8852B
+	if (!(is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	      is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))) {
+		PLTFM_MSG_ERR("%s: FWREDL is available only on 8852B/8851B\n",
+			      __func__);
+		return MACSUCCESS;
+	}
+
+	ret = fwhdr_parser(adapter, fw, len, &info);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: fwhdr_parser fail\n", __func__);
+		goto fwdl_err;
+	}
+
+	if (!info.is_fw_use_ple) {
+		PLTFM_MSG_WARN("[WARN]%s: no need to redownload\n", __func__);
+		return MACSUCCESS;
+	}
+	ret = update_fw_ver(adapter, (struct fwhdr_hdr_t *)fw);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: update_fw_ver fail\n", __func__);
+		goto fwdl_err;
+	}
+
+	val32 = MAC_REG_R32(R_AX_WCPU_FW_CTRL);
+	val32 &= ~(B_AX_WCPU_FWDL_EN | B_AX_H2C_PATH_RDY | B_AX_FWDL_PATH_RDY);
+	val32 = SET_CLR_WORD(val32, FWDL_INITIAL_STATE,
+			     B_AX_WCPU_FWDL_STS);
+	MAC_REG_W32(R_AX_WCPU_FW_CTRL, val32);
+
+	adapter->sm.fwdl = MAC_AX_FWDL_H2C_PATH_RDY;
+
+	ret = fwdl_phase1(adapter, fw, info.hdr_len - info.dynamic_hdr_len, 1);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: fwdl_phase1 fail\n", __func__);
+		goto fwdl_err;
+	}
+
+	ret = fwdl_phase2(adapter, fw, &info, 1);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: fwdl_phase2 fail\n", __func__);
+		goto fwdl_err;
+	}
+
+	mac_scanofld_reset_state(adapter);
+	return MACSUCCESS;
+
+fwdl_err:
+	fwdl_fail_dump(adapter, &info, ret);
+
+	return ret;
+}
+
+u32 mac_fwdl(struct mac_ax_adapter *adapter, u8 *fw, u32 len)
+{
+	u8 retry_cnt;
+	u32 ret;
+	struct fw_bin_info info;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = 0;
+	retry_cnt = 0;
+	MAC_REG_W32(R_AX_UDM1, 0);
+	if (!fw) {
+		PLTFM_MSG_ERR("[ERR]%s: no fw\n", __func__);
+		ret = MACNOFW;
+		PLTFM_MEMSET(&info, 0, sizeof(struct fw_bin_info));
+		return ret;
+	}
+	/* Move this fuinction outside the retry loop may be buggy.
+	 * Since we've reed efuse in this function.
+	 */
+	ret = fwhdr_parser(adapter, fw, len, &info);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: fwhdr_parser fail\n", __func__);
+		return ret;
+	}
+
+	ret = update_fw_ver(adapter, (struct fwhdr_hdr_t *)fw);
+	if (ret)
+		return ret;
+
+	// FWDL retry, for 025 temp workaround
+	while (retry_cnt < FWDL_TRY_CNT) {
+		ret = fwdl_phase0(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s: fwdl_phase0 fail\n", __func__);
+			goto fwdl_err;
+		}
+
+		ret = fwdl_phase1(adapter, fw, info.hdr_len - info.dynamic_hdr_len, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s: fwdl_phase1 fail\n", __func__);
+			goto fwdl_err;
+		}
+
+		ret = fwdl_phase2(adapter, fw, &info, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s: fwdl_phase2 fail\n", __func__);
+			goto fwdl_err;
+		}
+
+		ret = mac_get_dynamic_hdr_ax(adapter, fw, len);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s: mac_get_dynamic_hdr_ax fail\n", __func__);
+			goto fwdl_err;
+		}
+
+		return MACSUCCESS;
+
+fwdl_err:
+		retry_cnt++;
+		PLTFM_MSG_ERR("[ERR]%s: Retry FWDL count %d\n", __func__, retry_cnt);
+		// At most retry 2 times
+		if (retry_cnt < FWDL_TRY_CNT) {
+			ret = mac_disable_cpu(adapter);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("[ERR]%s: mac_disable_cpu fail\n", __func__);
+				fwdl_fail_dump(adapter, &info, ret);
+				return ret;
+			}
+
+			ret = mac_enable_cpu(adapter, AX_BOOT_REASON_PWR_ON, 1);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("[ERR]%s: mac_enable_cpu fail\n", __func__);
+				fwdl_fail_dump(adapter, &info, ret);
+				return ret;
+			}
+			MAC_REG_W32(R_AX_UDM1, retry_cnt);
+		} else {
+			break;
+		}
+	}
+
+	fwdl_fail_dump(adapter, &info, ret);
+
+	return ret;
+}
+
+u32 mac_enable_cpu(struct mac_ax_adapter *adapter, u8 boot_reason, u8 dlfw)
+{
+	u32 val32, ret;
+	u16 val16;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (MAC_REG_R32(R_AX_PLATFORM_ENABLE) & B_AX_WCPU_EN)
+		return MACCPUSTATE;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_IDLE) {
+		PLTFM_MSG_ERR("[ERR]%s: state != FWDL_IDLE\n", __func__);
+		return MACPROCERR;
+	}
+
+	// Monitor PLE queue
+	{
+		u32 ple_que_ch0_empty, ple_que_ch1_empty;
+
+		MAC_REG_W32(R_AX_PLE_DBG_FUN_INTF_CTL, 0x80070000);
+		val32 = MAC_REG_R32(R_AX_PLE_DBG_FUN_INTF_DATA);
+		PLTFM_MSG_ALWAYS("[TRACE]Set R_AX_PLE_DBG_FUN_INTF_CTL to  0x80070000");
+		PLTFM_MSG_ALWAYS("[TRACE]R_AX_PLE_DBG_FUN_INTF_DATA = 0x%x\n", val32);
+
+		ple_que_ch0_empty = (val32 & (1 << 8));
+		ple_que_ch1_empty = (val32 & (1 << 9));
+		if (ple_que_ch0_empty == 0) {
+			PLTFM_MSG_ERR("PLE queue for PAXIDMA ch0 is not empty\n");
+			//return MACWQBUSY;
+		}
+		if (ple_que_ch1_empty == 0) {
+			PLTFM_MSG_ERR("PLE queue for PAXIDMA ch1 is not empty\n");
+			//return MACWQBUSY;
+		}
+	}
+
+	//FW cannot support too much log. Reset R_AX_LDM for FW debug config
+	MAC_REG_W32(R_AX_LDM, 0);
+
+	//Default open the debug mode
+	val32 = MAC_REG_R32(R_AX_UDM0);
+	//val32 |= BIT(0);
+	//MAC_REG_W32(R_AX_UDM0, val32);
+
+	//Clear SER status
+	MAC_REG_W32(R_AX_HALT_H2C_CTRL, 0);
+	MAC_REG_W32(R_AX_HALT_C2H_CTRL, 0);
+	MAC_REG_W32(R_AX_HALT_H2C, 0);
+	MAC_REG_W32(R_AX_HALT_C2H, 0);
+	//Clear SER status end
+
+	// write 1 clear for R_AX_HISR0(HALT_C2H ISR)
+	val32 = MAC_REG_R32(R_AX_HISR0);
+	MAC_REG_W32(R_AX_HISR0, val32);
+
+	MAC_REG_W32(R_AX_SYS_CLK_CTRL,
+		    MAC_REG_R32(R_AX_SYS_CLK_CTRL) | B_AX_CPU_CLK_EN);
+
+	val32 = MAC_REG_R32(R_AX_WCPU_FW_CTRL);
+	val32 &= ~(B_AX_WCPU_FWDL_EN | B_AX_H2C_PATH_RDY | B_AX_FWDL_PATH_RDY);
+	val32 = SET_CLR_WORD(val32, FWDL_INITIAL_STATE,
+			     B_AX_WCPU_FWDL_STS);
+
+	if (dlfw)
+		val32 |= B_AX_WCPU_FWDL_EN;
+
+	MAC_REG_W32(R_AX_WCPU_FW_CTRL, val32);
+
+	val16 = MAC_REG_R16(R_AX_BOOT_REASON);
+	val16 = SET_CLR_WORD(val16, boot_reason, B_AX_BOOT_REASON);
+	MAC_REG_W16(R_AX_BOOT_REASON, val16);
+
+	//Set IDMEM share mode to default value because NIC/NICCE use different mode
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+		val32 = MAC_REG_R32(R_AX_SEC_CTRL);
+		val32 = SET_CLR_WORD(val32, 0x2, B_AX_SEC_IDMEM_SIZE_CONFIG);
+		MAC_REG_W32(R_AX_SEC_CTRL, val32);
+	}
+
+	val32 = MAC_REG_R32(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W32(R_AX_PLATFORM_ENABLE, val32 | B_AX_WCPU_EN);
+
+	adapter->sm.fwdl = MAC_AX_FWDL_CPU_ON;
+
+	if (!dlfw) {
+		PLTFM_DELAY_MS(5);
+
+		ret = check_fw_rdy(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s: ", __func__);
+			PLTFM_MSG_ERR("check_fw_rdy fail\n");
+			return ret;
+		}
+	}
+
+    // Prevent sequence number in HALMAC and FW mismatching
+	reset_lps_seq_num(adapter);
+
+	return MACSUCCESS;
+}
+
+u32 mac_disable_cpu(struct mac_ax_adapter *adapter)
+{
+	u32 val32;
+
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	adapter->sm.fwdl = MAC_AX_FWDL_IDLE;
+	//todo: need to check cpu in safe state before reset CPU
+
+	val32 = MAC_REG_R32(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W32(R_AX_PLATFORM_ENABLE, val32 & ~B_AX_WCPU_EN);
+
+	val32 = MAC_REG_R32(R_AX_WCPU_FW_CTRL);
+	val32 &= ~(B_AX_WCPU_FWDL_EN | B_AX_H2C_PATH_RDY | B_AX_FWDL_PATH_RDY);
+	MAC_REG_W32(R_AX_WCPU_FW_CTRL, val32);
+
+	val32 = MAC_REG_R32(R_AX_SYS_CLK_CTRL);
+	MAC_REG_W32(R_AX_SYS_CLK_CTRL, val32 & ~B_AX_CPU_CLK_EN);
+
+	/* Disable WDT by Reset CPU CR
+	 * Reset B_AX_APB_WRAP_EN will reset all CPU Local CR.
+	 * Although reset B_AX_PLATFORM_EN will have same effect.
+	 * This redundant flow represent as an explicit point,
+	 * where we've reseted CPU Local CR, including WDT.
+	 *
+	 * After 52C, Disable WCPU Will Also Disable WDT
+	 * So only 52A, 52B and 51B need to reset B_AX_APB_WRAP_EN
+	 */
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		val32 = MAC_REG_R32(R_AX_PLATFORM_ENABLE);
+		MAC_REG_W32(R_AX_PLATFORM_ENABLE, val32 & ~B_AX_APB_WRAP_EN);
+
+		val32 = MAC_REG_R32(R_AX_PLATFORM_ENABLE);
+		MAC_REG_W32(R_AX_PLATFORM_ENABLE, val32 | B_AX_APB_WRAP_EN);
+	}
+
+	adapter->sm.plat = MAC_AX_PLAT_OFF;
+
+	if (chk_patch_pcie_hang(adapter)) {
+		val32 = MAC_REG_R32(R_AX_PLATFORM_ENABLE);
+		MAC_REG_W32(R_AX_PLATFORM_ENABLE, val32 & ~B_AX_PLATFORM_EN);
+
+		val32 = MAC_REG_R32(R_AX_PLATFORM_ENABLE);
+		MAC_REG_W32(R_AX_PLATFORM_ENABLE, val32 | B_AX_PLATFORM_EN);
+	}
+
+	adapter->sm.plat = MAC_AX_PLAT_ON;
+
+	return MACSUCCESS;
+}
+
+u32 mac_romdl(struct mac_ax_adapter *adapter, u8 *ROM, u32 ROM_addr, u32 len)
+{
+	u8 *content = NULL;
+	u32 val32, ret;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = mac_disable_cpu(adapter);
+	if (ret)
+		return ret;
+
+	if (!ROM)
+		return MACNOITEM;
+
+	val32 = MAC_REG_R32(R_AX_SEC_CTRL);
+
+	if (val32 & BIT(0)) {
+		ret = __write_memory(adapter, ROM, ROM_addr, len);
+		if (ret)
+			return ret;
+	} else {
+		PLTFM_MSG_ERR("[ERR]%s: __write_memory fail\n", __func__);
+		return MACSECUREON;
+	}
+
+	PLTFM_FREE(content, len);
+
+	return MACSUCCESS;
+}
+
+u32 mac_ram_boot(struct mac_ax_adapter *adapter, u8 *fw, u32 len)
+{
+	u32 addr;
+	u32 ret = 0, section_num = 1;
+	struct fw_bin_info info = {0};
+	struct fwhdr_section_info *section_info;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (adapter->hw_info->is_sec_ic) {
+		PLTFM_MSG_ERR("[ERR]security mode ind accees\n");
+		PLTFM_MSG_ERR("[ERR]Abort %s.\n", __func__);
+		return MACIOERRINSEC;
+	}
+
+	ret = mac_disable_cpu(adapter);
+	if (ret)
+		goto fwdl_err;
+
+	ret = fwhdr_parser(adapter, fw, len, &info);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: fwhdr_parser fail\n", __func__);
+		goto fwdl_err;
+	}
+
+	ret = update_fw_ver(adapter, (struct fwhdr_hdr_t *)fw);
+	if (ret)
+		goto fwdl_err;
+
+	section_num = info.section_num;
+	section_info = info.section_info;
+
+	while (section_num > 0) {
+		ret = __write_memory(adapter, section_info->addr,
+				     section_info->dladdr, section_info->len);
+		if (ret)
+			goto fwdl_err;
+
+		section_info++;
+		section_num--;
+	}
+
+	addr = (0xb8003000 + R_AX_CPU_BOOT_ADDR) & 0x1FFFFFFF;
+	PLTFM_MSG_WARN("%s ind access 0x%X start\n", __func__, addr);
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+	adapter->hw_info->ind_aces_cnt++;
+	MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, addr);
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		MAC_REG_W32(R_AX_INDIR_ACCESS_ENTRY, 0xB8970000);
+	} else {
+		MAC_REG_W32(R_AX_INDIR_ACCESS_ENTRY, 0x20100000);
+	}
+	adapter->hw_info->ind_aces_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->ind_access_lock);
+	PLTFM_MSG_WARN("%s ind access 0x%X end\n", __func__, addr);
+
+	ret = mac_enable_cpu(adapter, AX_BOOT_REASON_PWR_ON, 0);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: mac_enable_cpu fail\n", __func__);
+		goto fwdl_err;
+	}
+
+	PLTFM_DELAY_MS(10);
+
+	ret = check_fw_rdy(adapter);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: check_fw_rdy fail\n", __func__);
+		goto fwdl_err;
+	}
+	return MACSUCCESS;
+
+fwdl_err:
+	fwdl_fail_dump(adapter, &info, ret);
+
+	return ret;
+}
+
+u32 mac_enable_fw(struct mac_ax_adapter *adapter, enum rtw_fw_type cat)
+{
+	u32 ret = MACSUCCESS;
+#if defined(PHL_FEATURE_AP) || defined(PHL_FEATURE_NIC)
+	u32 chip_id, cv;
+	u32 fw_len = 0;
+	u8 *fw = NULL;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	enum DLE_RSVD_INFO dle_info;
+
+	chip_id = GET_FIELD(MAC_REG_R32(R_AX_SYS_CHIPINFO), B_AX_HW_ID);
+	cv = GET_FIELD(MAC_REG_R32(R_AX_SYS_CFG1), B_AX_CHIP_VER);
+
+	ret = get_dle_rsvd_info(adapter, (enum DLE_RSVD_INFO *)&dle_info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s: ", __func__);
+		return ret;
+	}
+
+	PLTFM_MSG_ALWAYS("Downloading Chip HW ID: %d\n", chip_id);
+
+	ret = mac_query_fw_buff(adapter, cat, &fw, &fw_len);
+
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s: fw selection fail\n", __func__);
+		return ret;
+	}
+
+	ret = mac_disable_cpu(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s: mac_disable_cpu fail\n", __func__);
+		return ret;
+	}
+
+	/* _patch_otp_power_issue checks whether OTP arbiter switchs to WLAN. */
+	/* If return err, print log but not return ret. */
+	/* Re-DLFW executed by following mac_fwdl_ax can handle this issue. */
+	if (chk_patch_otp_power_issue(adapter)) {
+		ret = _patch_otp_power_issue(adapter);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_WARN("[WARN]%s: _patch_otp_power_issue fail\n", __func__);
+	}
+
+	ret = mac_enable_cpu(adapter, AX_BOOT_REASON_PWR_ON, 1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s: mac_enable_cpu fail\n", __func__);
+		return ret;
+	}
+
+	ret = mac_fwdl(adapter, fw, fw_len);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s: mac_enable_cpu fail\n", __func__);
+		return ret;
+	}
+	mac_scanofld_reset_state(adapter);
+
+#endif /* #if defined(PHL_FEATURE_AP) || defined(PHL_FEATURE_NIC) */
+	return ret;
+}
+
+u32 mac_query_fw_buff(struct mac_ax_adapter *adapter, enum rtw_fw_type cat, u8 **fw, u32 *fw_len)
+{
+	u32 ret = MACSUCCESS;
+#if defined(PHL_FEATURE_AP) || defined(PHL_FEATURE_NIC)
+	u32 chip_id, cv;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	enum DLE_RSVD_INFO dle_info;
+
+	chip_id = GET_FIELD(MAC_REG_R32(R_AX_SYS_CHIPINFO), B_AX_HW_ID);
+	cv = GET_FIELD(MAC_REG_R32(R_AX_SYS_CFG1), B_AX_CHIP_VER);
+
+	ret = get_dle_rsvd_info(adapter, (enum DLE_RSVD_INFO *)&dle_info);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	PLTFM_MSG_ALWAYS("Query Chip HW ID: %d\n", chip_id);
+	switch (chip_id) {
+#ifdef MAC_8852A_SUPPORT
+	case RTL8852A_ID:
+		switch (cv) {
+#ifdef MAC_FW_8852A_U2
+		case FWDL_CBV:
+			switch (cat) {
+#ifdef PHL_FEATURE_AP
+#ifdef MAC_FW_CATEGORY_AP
+			case RTW_FW_AP:
+				*fw_len = array_length_8852a_u2_ap;
+				*fw = array_8852a_u2_ap;
+				break;
+#endif /*MAC_FW_CATEGORY_AP*/
+#endif /*PHL_FEATURE_AP*/
+#ifdef PHL_FEATURE_NIC
+#ifdef MAC_FW_CATEGORY_NIC
+			case RTW_FW_NIC:
+				*fw_len = array_length_8852a_u2_nic;
+				*fw = array_8852a_u2_nic;
+				break;
+#endif /*MAC_FW_CATEGORY_NIC*/
+#ifdef CONFIG_WOWLAN
+#ifdef MAC_FW_CATEGORY_WOWLAN
+			case RTW_FW_WOWLAN:
+				*fw_len = array_length_8852a_u2_wowlan;
+				*fw = array_8852a_u2_wowlan;
+				break;
+#endif /*MAC_FW_CATEGORY_WOWLAN*/
+#endif /*CONFIG_WOWLAN*/
+#endif /*PHL_FEATURE_NIC*/
+			default:
+				PLTFM_MSG_ERR("[ERR]%s: no cat\n", __func__);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+			}
+			break;
+#endif /*MAC_FW_8852A_U2*/
+#ifdef MAC_FW_8852A_U3
+		case FWDL_CCV:
+			// fall through
+		default:
+			switch (cat) {
+#ifdef PHL_FEATURE_AP
+#ifdef MAC_FW_CATEGORY_AP
+			case RTW_FW_AP:
+				*fw_len = array_length_8852a_u3_ap;
+				*fw = array_8852a_u3_ap;
+				break;
+#endif /*MAC_FW_CATEGORY_AP*/
+#endif /*PHL_FEATURE_AP*/
+#ifdef PHL_FEATURE_NIC
+#ifdef MAC_FW_CATEGORY_NIC
+			case RTW_FW_NIC:
+				*fw_len = array_length_8852a_u3_nic;
+				*fw = array_8852a_u3_nic;
+				break;
+#endif /*MAC_FW_CATEGORY_NIC*/
+#ifdef CONFIG_WOWLAN
+#ifdef MAC_FW_CATEGORY_WOWLAN
+			case RTW_FW_WOWLAN:
+				*fw_len = array_length_8852a_u3_wowlan;
+				*fw = array_8852a_u3_wowlan;
+				break;
+#endif /*MAC_FW_CATEGORY_WOWLAN*/
+#endif /*CONFIG_WOWLAN*/
+#endif /*PHL_FEATURE_NIC*/
+			default:
+				PLTFM_MSG_ERR("[ERR]%s: no cat\n", __func__);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+			}
+			break;
+#endif /*MAC_FW_8852A_U3*/
+		}
+		break;
+#endif /*MAC_8852A_SUPPORT*/
+#ifdef MAC_8852B_SUPPORT
+	case RTL8852B_ID:
+		switch (cv) {
+#ifdef MAC_FW_8852B_U2
+		case FWDL_CBV:
+			switch (cat) {
+#ifdef PHL_FEATURE_AP
+#ifdef MAC_FW_CATEGORY_AP
+			case RTW_FW_AP:
+				PLTFM_MSG_ERR("[ERR]%s: 8852b does not have ap image\n", __func__);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+#endif /*MAC_FW_CATEGORY_AP*/
+#endif /*PHL_FEATURE_AP*/
+#ifdef PHL_FEATURE_NIC
+#ifdef MAC_FW_CATEGORY_NICCE
+			case RTW_FW_NIC_CE:
+				*fw_len = array_length_8852b_u2_nicce;
+				*fw = array_8852b_u2_nicce;
+				break;
+#endif /*MAC_FW_CATEGORY_NICCE*/
+
+#ifdef MAC_FW_CATEGORY_NIC
+			case RTW_FW_NIC:
+				if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852B) {
+					if (dle_info == DLE_RSVD_INFO_FW) {
+						PLTFM_MSG_WARN("PLE FW is not in use\n");
+					    // disable PLE FW temporarily
+					    // *fw_len = array_length_8852b_u2_nic_ple;
+					    // *fw = array_8852b_u2_nic_ple;
+						*fw_len = array_length_8852b_u2_nic;
+						*fw = array_8852b_u2_nic;
+					} else {
+						*fw_len = array_length_8852b_u2_nic;
+						*fw = array_8852b_u2_nic;
+					}
+				} else if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852BP) {
+#if (SUPPORT_52BP && defined(MAC_FW_CATEGORY_NIC_BPLUS))
+					*fw_len = array_length_8852b_u2_nic_bplus;
+					*fw = array_8852b_u2_nic_bplus;
+#else
+					PLTFM_MSG_ERR("Not support 52BP\n");
+					*fw_len = 0;
+					*fw = 0;
+					ret = MACNOFW;
+#endif /* (SUPPORT_52BP && defined(MAC_FW_CATEGORY_NIC_BPLUS))*/
+				}
+				break;
+#endif /*MAC_FW_CATEGORY_NIC*/
+
+#ifdef CONFIG_WOWLAN
+#ifdef MAC_FW_CATEGORY_WOWLAN
+			case RTW_FW_WOWLAN:
+				if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852B) {
+					*fw_len = array_length_8852b_u2_wowlan;
+					*fw = array_8852b_u2_wowlan;
+				} else if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852BP) {
+#if (SUPPORT_52BP && defined(MAC_FW_CATEGORY_WOWLAN_BPLUS))
+					*fw_len = array_length_8852b_u2_wowlan_bplus;
+					*fw = array_8852b_u2_wowlan_bplus;
+#else
+					PLTFM_MSG_ERR("Not support 52BP\n");
+					*fw_len = 0;
+					*fw = 0;
+					ret = MACNOFW;
+#endif /*(SUPPORT_52BP && defined(MAC_FW_CATEGORY_WOWLAN_BPLUS)*/
+				}
+				break;
+#endif /*MAC_FW_CATEGORY_WOWLAN*/
+#endif /*CONFIG_WOWLAN*/
+#endif /*PHL_FEATURE_NIC*/
+			default:
+				PLTFM_MSG_ERR("[ERR]%s: no cat\n", __func__);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+			}
+			break;
+#endif /*MAC_FW_8852B_U2*/
+#ifdef MAC_FW_8852B_U3
+		case FWDL_CCV:
+			// fall through
+		default:
+			PLTFM_MSG_WARN("[WARN]%s: 8852B Fall Back to C Cut FW\n", __func__);
+			switch (cat) {
+#ifdef PHL_FEATURE_AP
+#ifdef MAC_FW_CATEGORY_AP
+			case RTW_FW_AP:
+				PLTFM_MSG_ERR("[ERR]%s: 8852b does not have ap image\n", __func__);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+#endif /*MAC_FW_CATEGORY_AP*/
+#endif /*PHL_FEATURE_AP*/
+#ifdef PHL_FEATURE_NIC
+#ifdef MAC_FW_CATEGORY_NICCE
+			case RTW_FW_NIC_CE:
+				*fw_len = array_length_8852b_u3_nicce;
+				*fw = array_8852b_u3_nicce;
+				break;
+#endif /*MAC_FW_CATEGORY_NICCE*/
+
+#ifdef MAC_FW_CATEGORY_NIC
+			case RTW_FW_NIC:
+				if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852B) {
+					*fw_len = array_length_8852b_u3_nic;
+					*fw = array_8852b_u3_nic;
+				} else if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852BP) {
+#if (SUPPORT_52BP && defined(MAC_FW_CATEGORY_NIC_BPLUS))
+					*fw_len = array_length_8852b_u3_nic_bplus;
+					*fw = array_8852b_u3_nic_bplus;
+#else
+					PLTFM_MSG_ERR("Not support 52BP\n");
+					*fw_len = 0;
+					*fw = 0;
+					ret = MACNOFW;
+#endif /*(SUPPORT_52BP && defined(MAC_FW_CATEGORY_NIC_BPLUS))*/
+				}
+				break;
+#endif /*MAC_FW_CATEGORY_NIC*/
+
+#ifdef CONFIG_WOWLAN
+#ifdef MAC_FW_CATEGORY_WOWLAN
+			case RTW_FW_WOWLAN:
+				if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852B) {
+					*fw_len = array_length_8852b_u3_wowlan;
+					*fw = array_8852b_u3_wowlan;
+				} else if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852BP) {
+#if (SUPPORT_52BP && defined(MAC_FW_CATEGORY_WOWLAN_BPLUS))
+					*fw_len = array_length_8852b_u3_wowlan_bplus;
+					*fw = array_8852b_u3_wowlan_bplus;
+#else
+					PLTFM_MSG_ERR("Not support 52BP\n");
+					*fw_len = 0;
+					*fw = 0;
+					ret = MACNOFW;
+#endif
+				}
+				break;
+#endif /*MAC_FW_CATEGORY_WOWLAN*/
+#endif /*CONFIG_WOWLAN*/
+#endif /*PHL_FEATURE_NIC*/
+			default:
+				PLTFM_MSG_ERR("[ERR]%s: no cat\n", __func__);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+			}
+			break;
+#endif /*MAC_FW_8852B_U3*/
+		}
+		break;
+#endif /*MAC_8852B_SUPPORT*/
+#ifdef MAC_8852C_SUPPORT
+	case RTL8852C_ID:
+		switch (cv) {
+#ifdef MAC_FW_8852C_U1
+		case FWDL_CAV:
+			switch (cat) {
+#ifdef PHL_FEATURE_AP
+#ifdef MAC_FW_CATEGORY_AP
+			case RTW_FW_AP:
+				*fw_len = array_length_8852c_u1_ap;
+				*fw = array_8852c_u1_ap;
+				break;
+#endif /*MAC_FW_CATEGORY_AP*/
+#endif /*PHL_FEATURE_AP*/
+#ifdef PHL_FEATURE_NIC
+#ifdef MAC_FW_CATEGORY_NIC
+			case RTW_FW_NIC:
+				*fw_len = array_length_8852c_u1_nic;
+				*fw = array_8852c_u1_nic;
+				break;
+#endif /*MAC_FW_CATEGORY_NIC*/
+#ifdef CONFIG_WOWLAN
+#ifdef MAC_FW_CATEGORY_WOWLAN
+			case RTW_FW_WOWLAN:
+				*fw_len = array_length_8852c_u1_wowlan;
+				*fw = array_8852c_u1_wowlan;
+				break;
+#endif /*MAC_FW_CATEGORY_WOWLAN*/
+#endif /*CONFIG_WOWLAN*/
+#endif /*PHL_FEATURE_NIC*/
+			default:
+				PLTFM_MSG_ERR("[ERR]%s: no cat\n", __func__);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+				}
+				break;
+#endif /*MAC_FW_8852C_U1*/
+#ifdef MAC_FW_8852C_U2
+		case FWDL_CBV:
+			// fall through
+		default:
+			switch (cat) {
+#ifdef PHL_FEATURE_AP
+#ifdef MAC_FW_CATEGORY_AP
+			case RTW_FW_AP:
+				*fw_len = array_length_8852c_u2_ap;
+				*fw = array_8852c_u2_ap;
+				break;
+#endif /*MAC_FW_CATEGORY_AP*/
+#endif /*PHL_FEATURE_AP*/
+#ifdef PHL_FEATURE_NIC
+#ifdef MAC_FW_CATEGORY_NIC
+			case RTW_FW_NIC:
+				*fw_len = array_length_8852c_u2_nic;
+				*fw = array_8852c_u2_nic;
+				break;
+#endif /*MAC_FW_CATEGORY_NIC*/
+#ifdef CONFIG_WOWLAN
+#ifdef MAC_FW_CATEGORY_WOWLAN
+			case RTW_FW_WOWLAN:
+				*fw_len = array_length_8852c_u2_wowlan;
+				*fw = array_8852c_u2_wowlan;
+				break;
+#endif /*#ifdef MAC_FW_CATEGORY_WOWLAN*/
+#endif /*CONFIG_WOWLAN*/
+#endif /*PHL_FEATURE_NIC*/
+			default:
+				PLTFM_MSG_ERR("[ERR]%s: no cat\n", __func__);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+			}
+			break;
+#endif /*MAC_FW_8852C_U2*/
+		}
+		break;
+#endif /*MAC_8852C_SUPPORT*/
+#ifdef MAC_8192XB_SUPPORT
+	case RTL8192XB_ID:
+		switch (cv) {
+#ifdef MAC_FW_8192XB_U1
+		case FWDL_CAV:
+			switch (cat) {
+#ifdef PHL_FEATURE_AP
+#ifdef MAC_FW_CATEGORY_AP
+			case RTW_FW_AP:
+				*fw_len = array_length_8192xb_u1_ap;
+				*fw = array_8192xb_u1_ap;
+				break;
+#endif /*MAC_FW_CATEGORY_AP*/
+#endif /*PHL_FEATURE_AP*/
+#ifdef PHL_FEATURE_NIC
+#ifdef MAC_FW_CATEGORY_NIC
+			case RTW_FW_NIC:
+				*fw_len = array_length_8192xb_u1_nic;
+				*fw = array_8192xb_u1_nic;
+				break;
+#endif /*MAC_FW_CATEGORY_NIC*/
+
+#ifdef CONFIG_WOWLAN
+#ifdef MAC_FW_CATEGORY_WOWLAN
+			case RTW_FW_WOWLAN:
+				*fw_len = array_length_8192xb_u1_wowlan;
+				*fw = array_8192xb_u1_wowlan;
+				break;
+#endif /*MAC_FW_CATEGORY_WOWLAN*/
+#endif /*CONFIG_WOWLAN*/
+#endif /*PHL_FEATURE_NIC*/
+			default:
+				PLTFM_MSG_ERR("[ERR]%s: no cat\n", __func__);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+			}
+			break;
+#endif /*MAC_FW_8192XB_U1*/
+#ifdef MAC_FW_8192XB_U2
+		case FWDL_CBV:
+			// fall through
+		default:
+			switch (cat) {
+#ifdef PHL_FEATURE_AP
+#ifdef MAC_FW_CATEGORY_AP
+			case RTW_FW_AP:
+				*fw_len = array_length_8192xb_u2_ap;
+				*fw = array_8192xb_u2_ap;
+				break;
+#endif /*MAC_FW_CATEGORY_AP*/
+#endif /*PHL_FEATURE_AP*/
+#ifdef PHL_FEATURE_NIC
+#ifdef MAC_FW_CATEGORY_NIC
+			case RTW_FW_NIC:
+				*fw_len = array_length_8192xb_u2_nic;
+				*fw = array_8192xb_u2_nic;
+				break;
+#endif /*MAC_FW_CATEGORY_NIC*/
+
+#ifdef CONFIG_WOWLAN
+#ifdef MAC_FW_CATEGORY_WOWLAN
+			case RTW_FW_WOWLAN:
+				*fw_len = array_length_8192xb_u2_wowlan;
+				*fw = array_8192xb_u2_wowlan;
+				break;
+#endif /*MAC_FW_CATEGORY_WOWLAN*/
+#endif /*CONFIG_WOWLAN*/
+#endif /*PHL_FEATURE_NIC*/
+			default:
+				PLTFM_MSG_ERR("[ERR]%s: no cat\n", __func__);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+			}
+			break;
+#endif /*MAC_FW_8192XB_U2*/
+		}
+		break;
+#endif /*MAC_8192XB_SUPPORT*/
+#ifdef MAC_8851B_SUPPORT
+	case RTL8851B_ID:
+		switch (cv) {
+#ifdef MAC_FW_8851B_U1
+		case FWDL_CAV:
+			// fall through
+		default:
+			switch (cat) {
+#ifdef PHL_FEATURE_AP
+#ifdef MAC_FW_CATEGORY_AP
+			case RTW_FW_AP:
+				PLTFM_MSG_ERR("[ERR]%s: 8851b does not have ap image\n", __func__);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+#endif /*MAC_FW_CATEGORY_AP*/
+#endif /*PHL_FEATURE_AP*/
+#ifdef PHL_FEATURE_NIC
+#ifdef MAC_FW_CATEGORY_NIC
+			case RTW_FW_NIC:
+				if (dle_info == DLE_RSVD_INFO_FW) {
+#ifdef MAC_FW_CATEGORY_NIC_PLE
+					PLTFM_MSG_WARN("PLE FW is not in use\n");
+					// disable PLE FW temporarily
+					//#ifdef MAC_FW_CATEGORY_NIC_PLE
+					// *fw_len = array_length_8851b_u1_nic_ple;
+					// *fw = array_8851b_u1_nic_ple;
+					//#endif //MAC_FW_CATEGORY_NIC_PLE
+					*fw_len = array_length_8851b_u1_nic;
+					*fw = array_8851b_u1_nic;
+#else
+					*fw_len = array_length_8851b_u1_nic;
+					*fw = array_8851b_u1_nic;
+#endif
+				} else {
+					*fw_len = array_length_8851b_u1_nic;
+					*fw = array_8851b_u1_nic;
+				}
+				break;
+#endif /*MAC_FW_CATEGORY_NIC*/
+#ifdef CONFIG_WOWLAN
+#ifdef MAC_FW_CATEGORY_WOWLAN
+			case RTW_FW_WOWLAN:
+				*fw_len = array_length_8851b_u1_wowlan;
+				*fw = array_8851b_u1_wowlan;
+				break;
+#endif /*#ifdef MAC_FW_CATEGORY_WOWLAN*/
+#endif /*CONFIG_WOWLAN*/
+#endif /*PHL_FEATURE_NIC*/
+			default:
+				PLTFM_MSG_ERR("[ERR]%s: no cat\n", __func__);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+			}
+			break;
+#endif /*MAC_FW_8851B_U1*/
+		}
+		break;
+#endif /*MAC_8851B_SUPPORT*/
+
+#ifdef MAC_8851E_SUPPORT
+	case RTL8851E_ID:
+		switch (cv) {
+#ifdef MAC_FW_8851E_U1
+		case FWDL_CAV:
+			// fall through
+		default:
+			switch (cat) {
+#ifdef PHL_FEATURE_AP
+#ifdef MAC_FW_CATEGORY_AP
+			case RTW_FW_AP:
+				*fw_len = array_length_8851e_u1_ap;
+				*fw = array_8851e_u1_ap;
+				break;
+#endif /*MAC_FW_CATEGORY_AP*/
+#endif /*PHL_FEATURE_AP*/
+#ifdef PHL_FEATURE_NIC
+#ifdef MAC_FW_CATEGORY_NIC
+			case RTW_FW_NIC:
+				*fw_len = array_length_8851e_u1_nic;
+				*fw = array_8851e_u1_nic;
+				break;
+#endif /*MAC_FW_CATEGORY_NIC*/
+#ifdef CONFIG_WOWLAN
+#ifdef MAC_FW_CATEGORY_WOWLAN
+			case RTW_FW_WOWLAN:
+				*fw_len = array_length_8851e_u1_wowlan;
+				*fw = array_8851e_u1_wowlan;
+				break;
+#endif /*MAC_FW_CATEGORY_WOWLAN*/
+#endif /*CONFIG_WOWLAN*/
+#endif /*PHL_FEATURE_NIC*/
+			default:
+				PLTFM_MSG_ERR("[ERR]%s: no cat:%d\n", __func__, cat);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+			}
+			break;
+#endif /*MAC_FW_8851E_U1*/
+		}
+		break;
+#endif /*MAC_8851E_SUPPORT*/
+
+#ifdef MAC_8852D_SUPPORT
+	case RTL8852D_ID:
+		switch (cv) {
+#ifdef MAC_FW_8852D_U1
+		case FWDL_CAV:
+			// fall through
+		default:
+			switch (cat) {
+#ifdef PHL_FEATURE_AP
+#ifdef MAC_FW_CATEGORY_AP
+			case RTW_FW_AP:
+				*fw_len = array_length_8852d_u1_ap;
+				*fw = array_8852d_u1_ap;
+				break;
+#endif /*MAC_FW_CATEGORY_AP*/
+#endif /*PHL_FEATURE_AP*/
+#ifdef PHL_FEATURE_NIC
+#ifdef MAC_FW_CATEGORY_NIC
+			case RTW_FW_NIC:
+				*fw_len = array_length_8852d_u1_nic;
+				*fw = array_8852d_u1_nic;
+				break;
+#endif /*MAC_FW_CATEGORY_NIC*/
+#ifdef CONFIG_WOWLAN
+#ifdef MAC_FW_CATEGORY_WOWLAN
+			case RTW_FW_WOWLAN:
+				*fw_len = array_length_8852d_u1_wowlan;
+				*fw = array_8852d_u1_wowlan;
+				break;
+#endif /*MAC_FW_CATEGORY_WOWLAN*/
+#endif /*CONFIG_WOWLAN*/
+#endif /*PHL_FEATURE_NIC*/
+			default:
+				PLTFM_MSG_ERR("[ERR]%s: no cat:%d\n", __func__, cat);
+				*fw_len = 0;
+				fw = 0;
+				ret = MACNOFW;
+				break;
+			}
+			break;
+#endif /*MAC_FW_8852D_U1*/
+		}
+		break;
+#endif /*MAC_8852D_SUPPORT*/
+
+	default:
+		PLTFM_MSG_ERR("[ERR]%s: invalid chip\n", __func__);
+		*fw_len = 0;
+		fw = 0;
+		ret = MACNOFW;
+		break;
+	}
+
+#endif /* #if defined(PHL_FEATURE_AP) || defined(PHL_FEATURE_NIC) */
+	return ret;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwdl.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwdl.h
new file mode 100644
index 000000000000..247fe9cbfc6f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwdl.h
@@ -0,0 +1,541 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_FWDL_H_
+#define _MAC_AX_FWDL_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+#include "trx_desc.h"
+#include "trxcfg.h"
+#include "dle.h"
+#include "hci_fc.h"
+#include "power_saving.h"
+#include "otpkeysinfo.h"
+
+#if MAC_AX_PCIE_SUPPORT
+#include "_pcie.h"
+#endif
+
+#ifdef MAC_8852A_SUPPORT
+#include "../fw_ax/rtl8852a/hal8852a_fw.h"
+#endif
+#ifdef MAC_8852B_SUPPORT
+#include "../fw_ax/rtl8852b/hal8852b_fw.h"
+#endif
+#ifdef MAC_8852C_SUPPORT
+#include "../fw_ax/rtl8852c/hal8852c_fw.h"
+#endif
+#ifdef MAC_8192XB_SUPPORT
+#include "../fw_ax/rtl8192xb/hal8192xb_fw.h"
+#endif
+#ifdef MAC_8851B_SUPPORT
+#include "../fw_ax/rtl8851b/hal8851b_fw.h"
+#endif
+#ifdef MAC_8851E_SUPPORT
+#include "../fw_ax/rtl8851e/hal8851e_fw.h"
+#endif
+#ifdef MAC_8852D_SUPPORT
+#include "../fw_ax/rtl8852d/hal8852d_fw.h"
+#endif
+
+#ifdef MAC_8852A_SUPPORT
+#define FWDL_PLE_BASE_ADDR_8852A 0xB8760000
+#endif
+#ifdef MAC_8852B_SUPPORT
+#define FWDL_PLE_BASE_ADDR_8852B 0xB8718000
+#endif
+#ifdef MAC_8852C_SUPPORT
+#define FWDL_PLE_BASE_ADDR_8852C 0xB8760000
+#endif
+#ifdef MAC_8192XB_SUPPORT
+#define FWDL_PLE_BASE_ADDR_8192XB 0xB8760000
+#endif
+#ifdef MAC_8851B_SUPPORT
+#define FWDL_PLE_BASE_ADDR_8851B 0xB8718000
+#endif
+#ifdef MAC_8851E_SUPPORT
+#define FWDL_PLE_BASE_ADDR_8851E 0xB8760000
+#endif
+#ifdef MAC_8852D_SUPPORT
+#define FWDL_PLE_BASE_ADDR_8852D 0xB8760000
+#endif
+
+#define FWHDR_HDR_LEN (sizeof(struct fwhdr_hdr_t))
+#define FWHDR_SECTION_LEN (sizeof(struct fwhdr_section_t))
+
+#define ROMDL_SEG_LEN 0x40000
+
+#define AX_BOOT_REASON_PWR_ON 0
+#define AX_BOOT_REASON_WDT 1
+#define AX_BOOT_REASON_LPS 2
+
+#define RTL8852A_ID 0x50
+#define RTL8852B_ID 0x51
+#define RTL8852C_ID 0x52
+#define RTL8192XB_ID 0x53
+#define RTL8851B_ID 0x54
+#define RTL8851E_ID 0x55
+#define RTL8852D_ID 0x56
+
+#define RTL8852A_ROM_ADDR 0x18900000
+#define RTL8852B_ROM_ADDR 0x18900000
+#define RTL8852C_ROM_ADDR 0x20000000
+#define RTL8192XB_ROM_ADDR 0x20000000
+#define RTL8851B_ROM_ADDR 0x18900000
+#define RTL8851E_ROM_ADDR 0x20000000
+#define RTL8852D_ROM_ADDR 0x20000000
+#define FWDL_WAIT_CNT 400000
+#define FWDL_SECTION_MAX_NUM 6
+#define FWDL_SECURITY_SECTION_CONSTANT (64 + (FWDL_SECTION_MAX_NUM * 32 * 2))
+#define FWDL_SECURITY_SECTION_TYPE 9
+#define FWDL_SECURITY_SIGLEN 512
+#define FWDL_SECTION_CHKSUM_LEN	8
+#define FWDL_SECTION_PER_PKT_LEN 2020
+#define FWDL_TRY_CNT 3
+
+#define WDT_CTRL_ALL_DIS 0
+
+struct fwhdr_section_info {
+	u8 redl;
+	u8 *addr;
+	u32 len;
+	u32 dladdr;
+	u32 mssc;
+	u8 type;
+};
+
+struct fw_bin_info {
+	u8 section_num;
+	u32 hdr_len;
+	u32 git_idx;
+	u32 is_fw_use_ple;
+	u8 dynamic_hdr_en;
+	u32 dynamic_hdr_len;
+	struct fwhdr_section_info section_info[FWDL_SECTION_MAX_NUM];
+};
+
+struct hw_info {
+	u8 chip;
+	u8 cut;
+	u8 category;
+};
+
+struct fwld_info {
+	u32 len;
+	u8 *fw;
+};
+
+/**
+ * @struct fwhdr_hdr_t
+ * @brief fwhdr_hdr_t
+ *
+ * @var fwhdr_hdr_t::dword0
+ * Please Place Description here.
+ * @var fwhdr_hdr_t::dword1
+ * Please Place Description here.
+ * @var fwhdr_hdr_t::dword2
+ * Please Place Description here.
+ * @var fwhdr_hdr_t::dword3
+ * Please Place Description here.
+ * @var fwhdr_hdr_t::dword4
+ * Please Place Description here.
+ * @var fwhdr_hdr_t::dword5
+ * Please Place Description here.
+ * @var fwhdr_hdr_t::dword6
+ * Please Place Description here.
+ * @var fwhdr_hdr_t::dword7
+ * Please Place Description here.
+ */
+struct fwhdr_hdr_t {
+	u32 dword0;
+	u32 dword1;
+	u32 dword2;
+	u32 dword3;
+	u32 dword4;
+	u32 dword5;
+	u32 dword6;
+	u32 dword7;
+};
+
+/**
+ * @struct fwhdr_section_t
+ * @brief fwhdr_section_t
+ *
+ * @var fwhdr_section_t::dword0
+ * Please Place Description here.
+ * @var fwhdr_section_t::dword1
+ * Please Place Description here.
+ * @var fwhdr_section_t::dword2
+ * Please Place Description here.
+ * @var fwhdr_section_t::dword3
+ * Please Place Description here.
+ */
+struct fwhdr_section_t {
+	u32 dword0;
+	u32 dword1;
+	u32 dword2;
+	u32 dword3;
+};
+
+/**
+ * @enum fw_dl_status
+ *
+ * @brief fw_dl_status
+ *
+ * @var fw_dl_status::FWDL_INITIAL_STATE
+ * Please Place Description here.
+ * @var fw_dl_status::FWDL_FWDL_ONGOING
+ * Please Place Description here.
+ * @var fw_dl_status::FWDL_CHECKSUM_FAIL
+ * Please Place Description here.
+ * @var fw_dl_status::FWDL_SECURITY_FAIL
+ * Please Place Description here.
+ * @var fw_dl_status::FWDL_CUT_NOT_MATCH
+ * Please Place Description here.
+ * @var fw_dl_status::FWDL_RSVD0
+ * Please Place Description here.
+ * @var fw_dl_status::FWDL_WCPU_FWDL_RDY
+ * Please Place Description here.
+ * @var fw_dl_status::FWDL_WCPU_FW_INIT_RDY
+ * Please Place Description here.
+ */
+enum fw_dl_status {
+	FWDL_INITIAL_STATE = 0,
+	FWDL_FWDL_ONGOING = 1,
+	FWDL_CHECKSUM_FAIL = 2,
+	FWDL_SECURITY_FAIL = 3,
+	FWDL_CUT_NOT_MATCH = 4,
+	FWDL_RSVD0 = 5,
+	FWDL_WCPU_FWDL_RDY = 6,
+	FWDL_WCPU_FW_INIT_RDY = 7
+};
+
+/**
+ * @enum fw_dl_cv
+ *
+ * @brief fw_dl_cv
+ *
+ * @var fw_dl_chip_cut::FWDL_CAV
+ * Please Place Description here.
+ * @var fw_dl_chip_cut::FWDL_CBV
+ * Please Place Description here.
+ * @var fw_dl_chip_cut::FWDL_CCV
+ * Please Place Description here.
+ * @var fw_dl_chip_cut::FWDL_CDV
+ * Please Place Description here.
+ * @var fw_dl_chip_cut::FWDL_CEV
+ * Please Place Description here.
+ * @var fw_dl_chip_cut::FWDL_CFV
+ * Please Place Description here.
+ * @var fw_dl_chip_cut::FWDL_CGV
+ * Please Place Description here.
+ * @var fw_dl_chip_cut::FWDL_CHV
+ * Please Place Description here.
+ * @var fw_dl_chip_cut::FWDL_CIV
+ * Please Place Description here.
+ */
+enum fw_dl_cv {
+	FWDL_CAV = 0,
+	FWDL_CBV = 1,
+	FWDL_CCV,
+	FWDL_CDV,
+	FWDL_CEV,
+	FWDL_CFV,
+	FWDL_CGV,
+	FWDL_CHV,
+	FWDL_CIV,
+};
+
+/**
+ * @enum fwdl_dynamic_hdr_type
+ *
+ * @brief fwdl_dynamic_hdr_type
+ *
+ * @var fwdl_dynamic_hdr_type::FWDL_DYNAMIC_HDR_NOUSE
+ * Please Place Description here.
+ * @var fwdl_dynamic_hdr_type::FWDL_DYNAMIC_HDR_FWCAP
+ * Please Place Description here.
+ * @var fwdl_dynamic_hdr_type::FWDL_DYNAMIC_HDR_MAX
+ * Please Place Description here.
+ */
+enum fwdl_dynamic_hdr_type {
+	FWDL_DYNAMIC_HDR_NOUSE = 0,
+	FWDL_DYNAMIC_HDR_FWCAP = 1,
+	FWDL_DYNAMIC_HDR_MAX
+};
+
+/* === FW header === */
+/* dword0 */
+#define FWHDR_CUTID_SH 0
+#define FWHDR_CUTID_MSK 0xff
+#define FWHDR_CHIPID_SH 8
+#define FWHDR_CHIPID_MSK 0xffffff
+
+/* dword1 */
+#define FWHDR_MAJORVER_SH 0
+#define FWHDR_MAJORVER_MSK 0xff
+#define FWHDR_MINORVER_SH 8
+#define FWHDR_MINORVER_MSK 0xff
+#define FWHDR_SUBVERSION_SH 16
+#define FWHDR_SUBVERSION_MSK 0xff
+#define FWHDR_SUBINDEX_SH 24
+#define FWHDR_SUBINDEX_MSK 0xff
+
+/* dword2 */
+#define FWHDR_COMMITID_SH 0
+#define FWHDR_COMMITID_MSK 0xffffffff
+
+/* dword3 */
+#define FWHDR_SEC_HDR_OFFSET_SH 0
+#define FWHDR_SEC_HDR_OFFSET_MSK 0xff
+#define FWHDR_SEC_HDR_SZ_SH 8
+#define FWHDR_SEC_HDR_SZ_MSK 0xff
+#define FWHDR_FWHDR_SZ_SH 16
+#define FWHDR_FWHDR_SZ_MSK 0xff
+#define FWHDR_FWHDR_VER_SH 24
+#define FWHDR_FWHDR_VER_MSK 0xff
+
+/* dword4 */
+#define FWHDR_MONTH_SH 0
+#define FWHDR_MONTH_MSK 0xff
+#define FWHDR_DATE_SH 8
+#define FWHDR_DATE_MSK 0xff
+#define FWHDR_HOUR_SH 16
+#define FWHDR_HOUR_MSK 0xff
+#define FWHDR_MIN_SH 24
+#define FWHDR_MIN_MSK 0xff
+
+/* dword5 */
+#define FWHDR_YEAR_SH 0
+#define FWHDR_YEAR_MSK 0xffff
+
+/* dword6 */
+#define FWHDR_IMAGEFROM_SH 0
+#define FWHDR_IMAGEFROM_MSK 0x3
+#define FWHDR_BOOTFROM_SH 4
+#define FWHDR_BOOTFROM_MSK 0x3
+#define FWHDR_ROM_ONLY BIT(6)
+#define FWHDR_FW_TYPE BIT(7)
+#define FWHDR_SEC_NUM_SH 8
+#define FWHDR_SEC_NUM_MSK 0xff
+#define FWHDR_HCI_TYPE_SH 16
+#define FWHDR_HCI_TYPE_MSK 0xf
+#define FWHDR_NET_TYPE_SH 20
+#define FWHDR_NET_TYPE_MSK 0xf
+
+/* dword7 */
+#define FWHDR_FW_PART_SZ_SH 0
+#define FWHDR_FW_PART_SZ_MSK 0xffff
+#define FWHDR_FW_DYN_HDR_SH 16
+#define FWHDR_FW_DYN_HDR_MSK 0x1
+#define FWHDR_CMD_VER_SH 24
+#define FWHDR_CMD_VER_MSK 0xff
+
+/* === Section header === */
+/* dword0 */
+#define SECTION_INFO_SEC_DL_ADDR_SH 0
+#define SECTION_INFO_SEC_DL_ADDR_MSK 0xffffffff
+
+/* dword1 */
+#define SECTION_INFO_SEC_SIZE_SH 0
+#define SECTION_INFO_SEC_SIZE_MSK 0xffffff
+#define SECTION_INFO_SECTIONTYPE_SH 24
+#define SECTION_INFO_SECTIONTYPE_MSK 0xf
+#define SECTION_INFO_CHECKSUM BIT(28)
+#define SECTION_INFO_REDL BIT(29)
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Download
+ * @{
+ */
+/**
+ * @brief mac_fwredl
+ *
+ * @param *adapter
+ * @param *fw
+ * @param len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_fwredl(struct mac_ax_adapter *adapter, u8 *fw, u32 len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Download
+ * @{
+ */
+
+/**
+ * @brief mac_fwdl
+ *
+ * @param *adapter
+ * @param *fw
+ * @param len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_fwdl(struct mac_ax_adapter *adapter, u8 *fw, u32 len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Download
+ * @{
+ */
+
+/**
+ * @brief mac_enable_cpu
+ *
+ * @param *adapter
+ * @param boot_reason
+ * @param dlfw
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_enable_cpu(struct mac_ax_adapter *adapter, u8 boot_reason, u8 dlfw);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Download
+ * @{
+ */
+
+/**
+ * @brief mac_disable_cpu
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_disable_cpu(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Download
+ * @{
+ */
+
+/**
+ * @brief mac_romdl
+ *
+ * @param *adapter
+ * @param *rom
+ * @param romaddr
+ * @param len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_romdl(struct mac_ax_adapter *adapter, u8 *rom, u32 romaddr, u32 len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Download
+ * @{
+ */
+
+/**
+ * @brief mac_ram_boot
+ *
+ * @param *adapter
+ * @param *fw
+ * @param len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_ram_boot(struct mac_ax_adapter *adapter, u8 *fw, u32 len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Download
+ * @{
+ */
+
+/**
+ * @brief mac_enable_fw
+ *
+ * @param *adapter
+ * @param cat
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_enable_fw(struct mac_ax_adapter *adapter, enum rtw_fw_type cat);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_query_fw_buff
+ *
+ * @param *adapter
+ * @param cat
+ * @param **fw
+ * @param *fw_len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_query_fw_buff(struct mac_ax_adapter *adapter, enum rtw_fw_type cat, u8 **fw, u32 *fw_len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_get_dynamic_hdr_ax
+ *
+ * @param *adapter
+ * @param *fw
+ * @param fw_len
+ * @retval u32
+ */
+u32 mac_get_dynamic_hdr_ax(struct mac_ax_adapter *adapter, u8 *fw, u32 fw_len);
+/**
+ * @}
+ * @}
+ */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwofld.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwofld.c
new file mode 100644
index 000000000000..6e9d98ba5d7d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwofld.c
@@ -0,0 +1,3673 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "fwdl.h"
+#include "fwofld.h"
+
+static u32 get_io_ofld_cap(struct mac_ax_adapter *adapter, u32 *val)
+{
+	*val |= FW_CAP_IO_OFLD;
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_fw_cap(struct mac_ax_adapter *adapter, u32 *val)
+{
+	*val = 0;
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACFWNONRDY;
+
+	get_io_ofld_cap(adapter, val);
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_wlanfw_cap(struct mac_ax_adapter *adapter, struct rtw_wcpu_cap_t *wcpu_cap)
+{
+	u32 offset = 0;
+	u32 cap_len;
+	u32 defined_cap_len;
+	u32 len_to_cp;
+	u32 sizeof_cur_blk;
+	struct mac_wlanfw_cap_hdr *cap_hdr;
+	u32 size = adapter->fw_info.cap_size;
+	u8 *content = adapter->fw_info.cap_buff;
+	u8 mod_id;
+	u8 mod_idx;
+	u8 *target_addr;
+
+	PLTFM_MEMSET(wcpu_cap, 0, sizeof(struct rtw_wcpu_cap_t));
+	if (size > MAC_WLANFW_CAP_MAX_SIZE) {
+		PLTFM_MSG_ERR("[FwCap] Size (%d) exceeds def (%d)", size, MAC_WLANFW_CAP_MAX_SIZE);
+		return MACBUFSZ;
+	}
+	while (offset < size) {
+		sizeof_cur_blk = *content;
+		content++;
+		offset++;
+		if (sizeof_cur_blk < sizeof(struct mac_wlanfw_cap_hdr)) {
+			content += sizeof_cur_blk;
+			offset += sizeof_cur_blk;
+			continue;
+		}
+		cap_hdr = (struct mac_wlanfw_cap_hdr *)content;
+		PLTFM_MSG_TRACE("[FwCap] magic_code (%x), num_mods (%d)\n",
+				cap_hdr->magic_code, cap_hdr->num_mods);
+		if (cap_hdr->magic_code != MAC_WLANFW_CAP_MAGIC_CODE) {
+			content += sizeof_cur_blk;
+			offset += sizeof_cur_blk;
+			continue;
+		}
+		content += sizeof(struct mac_wlanfw_cap_hdr);
+		sizeof_cur_blk -= sizeof(struct mac_wlanfw_cap_hdr);
+
+		for (mod_idx = 0; mod_idx < cap_hdr->num_mods; mod_idx++) {
+			if (sizeof_cur_blk < 2) {
+				PLTFM_MSG_ERR("[FwCap] No enough space for modId and capLen\n");
+				PLTFM_MEMSET(wcpu_cap, 0, sizeof(struct rtw_wcpu_cap_t));
+				return MACNOITEM;
+			}
+			mod_id = *content++;
+			cap_len = ((u32)*content++) * 4;
+			sizeof_cur_blk -= 2;
+			PLTFM_MSG_TRACE("[FwCap] mod (%x), capLen (%d) byte\n", mod_id, cap_len);
+			if (cap_len > sizeof_cur_blk) {
+				PLTFM_MSG_ERR("[FwCap] No enough space for mod (%x) * %d Byte\n",
+					      mod_id, cap_len);
+				PLTFM_MEMSET(wcpu_cap, 0, sizeof(struct rtw_wcpu_cap_t));
+				return MACNOITEM;
+			}
+
+			switch (mod_id) {
+			case MAC_WLANFW_MAC_CAP_SUBID:
+				defined_cap_len = sizeof(wcpu_cap->mac_ofld_cap);
+				target_addr = (u8 *)&wcpu_cap->mac_ofld_cap;
+				break;
+			case MAC_WLANFW_BB_CAP_SUBID:
+				defined_cap_len = sizeof(wcpu_cap->bb_ofld_cap);
+				target_addr = (u8 *)&wcpu_cap->bb_ofld_cap;
+				break;
+			case MAC_WLANFW_RF_CAP_SUBID:
+				defined_cap_len = sizeof(wcpu_cap->rf_ofld_cap);
+				target_addr = (u8 *)&wcpu_cap->rf_ofld_cap;
+				break;
+			case MAC_WLANFW_BTC_CAP_SUBID:
+				defined_cap_len = sizeof(wcpu_cap->btc_ofld_cap);
+				target_addr = (u8 *)&wcpu_cap->btc_ofld_cap;
+				break;
+			default:
+				PLTFM_MSG_ERR("[FwCap] Unknown modId (%x), abort\n", mod_id);
+				PLTFM_MEMSET(wcpu_cap, 0, sizeof(struct rtw_wcpu_cap_t));
+				return MACNOITEM;
+			}
+			len_to_cp = (cap_len < defined_cap_len) ? cap_len : defined_cap_len;
+			PLTFM_MSG_TRACE("[FwCap] cp %d bytes\n", len_to_cp);
+			PLTFM_MEMCPY(target_addr, content, len_to_cp);
+			content += cap_len;
+			sizeof_cur_blk -= cap_len;
+		}
+		wcpu_cap->valid = 1;
+		return MACSUCCESS;
+	}
+	PLTFM_MSG_WARN("[FwCap] wcpu cap not found.\n");
+	return MACSUCCESS;
+}
+
+static inline void mac_pkt_ofld_set_bitmap(u8 *bitmap, u16 index)
+{
+	bitmap[index >> 3] |= (1 << (index & 7));
+}
+
+static inline void mac_pkt_ofld_unset_bitmap(struct mac_ax_adapter *adapter, u8 *bitmap, u16 index)
+{
+	if (index == PKT_OFLD_NOT_EXISTS_ID) {
+		PLTFM_MSG_ERR("pktofld id %d is for NOT_EXISTS and shouldn't be unset\n",
+			      PKT_OFLD_NOT_EXISTS_ID);
+		return;
+	}
+	bitmap[index >> 3] &= ~(1 << (index & 7));
+}
+
+static inline u8 mac_pkt_ofld_get_bitmap(u8 *bitmap, u16 index)
+{
+	if (index == PKT_OFLD_NOT_EXISTS_ID)
+		return 1;
+	return bitmap[index / 8] & (1 << (index & 7)) ? 1 : 0;
+}
+
+u32 mac_reset_fwofld_state(struct mac_ax_adapter *adapter, u8 op)
+{
+	switch (op) {
+	case FW_OFLD_OP_DUMP_EFUSE:
+		adapter->sm.efuse_ofld = MAC_AX_OFLD_H2C_IDLE;
+		break;
+
+	case FW_OFLD_OP_PACKET_OFLD:
+		PLTFM_MSG_TRACE("%s: set pktofld st to idle and clear occupied ids\n", __func__);
+		adapter->sm.pkt_ofld = MAC_AX_OFLD_H2C_IDLE;
+		PLTFM_MEMSET(adapter->pkt_ofld_info.id_bitmap, 0, (PKT_OFLD_MAX_COUNT >> 3));
+		mac_pkt_ofld_set_bitmap(adapter->pkt_ofld_info.id_bitmap, PKT_OFLD_NOT_EXISTS_ID);
+		adapter->pkt_ofld_info.last_op = PKT_OFLD_OP_MAX;
+		adapter->pkt_ofld_info.free_id_count = PKT_OFLD_MAX_VALID_ID_NUM;
+		adapter->pkt_ofld_info.used_id_count = 1;
+		break;
+
+	case FW_OFLD_OP_READ_OFLD:
+		adapter->sm.read_request = MAC_AX_OFLD_REQ_IDLE;
+		adapter->sm.read_h2c = MAC_AX_OFLD_H2C_IDLE;
+		break;
+
+	case FW_OFLD_OP_WRITE_OFLD:
+		adapter->sm.write_request = MAC_AX_OFLD_REQ_IDLE;
+		adapter->sm.write_h2c = MAC_AX_OFLD_H2C_IDLE;
+		break;
+
+	case FW_OFLD_OP_CONF_OFLD:
+		adapter->sm.conf_request = MAC_AX_OFLD_REQ_IDLE;
+		adapter->sm.conf_h2c = MAC_AX_OFLD_H2C_IDLE;
+		break;
+	case FW_OFLD_OP_CH_SWITCH:
+		adapter->sm.ch_switch = MAC_AX_OFLD_H2C_IDLE;
+		break;
+
+	default:
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_check_fwofld_done(struct mac_ax_adapter *adapter, u8 op)
+{
+	struct mac_ax_pkt_ofld_info *ofld_info = &adapter->pkt_ofld_info;
+
+	switch (op) {
+	case FW_OFLD_OP_DUMP_EFUSE:
+		if (adapter->sm.efuse_ofld == MAC_AX_OFLD_H2C_IDLE)
+			return MACSUCCESS;
+		break;
+
+	case FW_OFLD_OP_PACKET_OFLD:
+		if (ofld_info->last_op == PKT_OFLD_OP_READ) {
+			if (adapter->sm.pkt_ofld == MAC_AX_OFLD_H2C_DONE)
+				return MACSUCCESS;
+		} else {
+			if (adapter->sm.pkt_ofld == MAC_AX_OFLD_H2C_IDLE)
+				return MACSUCCESS;
+		}
+		break;
+	case FW_OFLD_OP_READ_OFLD:
+		if (adapter->sm.read_h2c == MAC_AX_OFLD_H2C_DONE)
+			return MACSUCCESS;
+		break;
+	case FW_OFLD_OP_WRITE_OFLD:
+		if (adapter->sm.write_h2c == MAC_AX_OFLD_H2C_IDLE)
+			return MACSUCCESS;
+		break;
+	case FW_OFLD_OP_CONF_OFLD:
+		if (adapter->sm.conf_h2c == MAC_AX_OFLD_H2C_IDLE)
+			return MACSUCCESS;
+		break;
+	case FW_OFLD_OP_CH_SWITCH:
+		if (adapter->sm.ch_switch == MAC_AX_OFLD_H2C_IDLE ||
+		    adapter->sm.ch_switch == MAC_AX_CH_SWITCH_GET_RPT)
+			return MACSUCCESS;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return MACPROCBUSY;
+}
+
+static u32 cnv_write_ofld_state(struct mac_ax_adapter *adapter, u8 dest)
+{
+	u8 state;
+
+	state = adapter->sm.write_request;
+
+	if (state > MAC_AX_OFLD_REQ_CLEANED)
+		return MACPROCERR;
+
+	if (dest == MAC_AX_OFLD_REQ_IDLE) {
+		if (state != MAC_AX_OFLD_REQ_H2C_SENT)
+			return MACPROCERR;
+	} else if (dest == MAC_AX_OFLD_REQ_CLEANED) {
+		if (state == MAC_AX_OFLD_REQ_H2C_SENT)
+			return MACPROCERR;
+	} else if (dest == MAC_AX_OFLD_REQ_CREATED) {
+		if (state == MAC_AX_OFLD_REQ_IDLE ||
+		    state == MAC_AX_OFLD_REQ_H2C_SENT)
+			return MACPROCERR;
+	} else if (dest == MAC_AX_OFLD_REQ_H2C_SENT) {
+		if (state != MAC_AX_OFLD_REQ_CREATED)
+			return MACPROCERR;
+	}
+
+	adapter->sm.write_request = dest;
+
+	return MACSUCCESS;
+}
+
+u32 mac_clear_write_request(struct mac_ax_adapter *adapter)
+{
+	if (adapter->sm.write_request == MAC_AX_OFLD_REQ_H2C_SENT)
+		return MACPROCERR;
+
+	if (cnv_write_ofld_state(adapter, MAC_AX_OFLD_REQ_CLEANED)
+	    != MACSUCCESS)
+		return MACPROCERR;
+
+	PLTFM_FREE(adapter->write_ofld_info.buf,
+		   adapter->write_ofld_info.buf_size);
+	adapter->write_ofld_info.buf = NULL;
+	adapter->write_ofld_info.buf_wptr = NULL;
+	adapter->write_ofld_info.last_req = NULL;
+	adapter->write_ofld_info.buf_size = 0;
+	adapter->write_ofld_info.avl_buf_size = 0;
+	adapter->write_ofld_info.used_size = 0;
+	adapter->write_ofld_info.req_num = 0;
+
+	return MACSUCCESS;
+}
+
+u32 mac_add_write_request(struct mac_ax_adapter *adapter,
+			  struct mac_ax_write_req *req, u8 *value, u8 *mask)
+{
+	struct mac_ax_write_ofld_info *ofld_info = &adapter->write_ofld_info;
+	struct fwcmd_write_ofld_req *write_ptr;
+	u32 data_len = 0;
+	u8 state;
+
+	state = adapter->sm.write_request;
+
+	if (!(state == MAC_AX_OFLD_REQ_CREATED ||
+	      state == MAC_AX_OFLD_REQ_CLEANED)) {
+		return MACPROCERR;
+	}
+
+	if (!ofld_info->buf) {
+		ofld_info->buf = (u8 *)PLTFM_MALLOC(WRITE_OFLD_MAX_LEN);
+		if (!ofld_info->buf)
+			return MACNPTR;
+		ofld_info->buf_wptr = ofld_info->buf;
+		ofld_info->buf_size = WRITE_OFLD_MAX_LEN;
+		ofld_info->avl_buf_size = WRITE_OFLD_MAX_LEN;
+		ofld_info->used_size = 0;
+		ofld_info->req_num = 0;
+	}
+
+	data_len = sizeof(struct mac_ax_write_req);
+	data_len += req->value_len;
+	if (req->mask_en == 1)
+		data_len += req->value_len;
+
+	if (ofld_info->avl_buf_size < data_len)
+		return MACNOBUF;
+
+	if (!value)
+		return MACNPTR;
+
+	if (req->mask_en == 1 && !mask)
+		return MACNPTR;
+
+	if (cnv_write_ofld_state(adapter,
+				 MAC_AX_OFLD_REQ_CREATED) != MACSUCCESS)
+		return MACPROCERR;
+
+	if (ofld_info->req_num != 0)
+		ofld_info->last_req->ls = 0;
+
+	ofld_info->last_req = (struct mac_ax_write_req *)ofld_info->buf_wptr;
+
+	req->ls = 1;
+
+	write_ptr = (struct fwcmd_write_ofld_req *)ofld_info->buf_wptr;
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD(req->value_len,
+			     FWCMD_H2C_WRITE_OFLD_REQ_VALUE_LEN) |
+		    SET_WORD(req->ofld_id,
+			     FWCMD_H2C_WRITE_OFLD_REQ_OFLD_ID) |
+		    SET_WORD(req->entry_num,
+			     FWCMD_H2C_WRITE_OFLD_REQ_ENTRY_NUM) |
+		    req->polling | req->mask_en | req->ls
+	);
+
+	write_ptr->dword1 =
+	cpu_to_le32(SET_WORD(req->offset,
+			     FWCMD_H2C_WRITE_OFLD_REQ_OFFSET)
+	);
+
+	ofld_info->buf_wptr += sizeof(struct mac_ax_write_req);
+	ofld_info->avl_buf_size -= sizeof(struct mac_ax_write_req);
+	ofld_info->used_size += sizeof(struct mac_ax_write_req);
+
+	PLTFM_MEMCPY(ofld_info->buf_wptr, value, req->value_len);
+
+	ofld_info->buf_wptr += req->value_len;
+	ofld_info->avl_buf_size -= req->value_len;
+	ofld_info->used_size += req->value_len;
+
+	if (req->mask_en == 1) {
+		PLTFM_MEMCPY(ofld_info->buf_wptr, mask, req->value_len);
+		ofld_info->buf_wptr += req->value_len;
+		ofld_info->avl_buf_size -= req->value_len;
+		ofld_info->used_size += req->value_len;
+	}
+
+	ofld_info->req_num++;
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_ofld(struct mac_ax_adapter *adapter)
+{
+	u8 *buf;
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct mac_ax_write_ofld_info *ofld_info = &adapter->write_ofld_info;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	if (ofld_info->used_size + FWCMD_HDR_LEN > READ_OFLD_MAX_LEN)
+		return MACBUFSZ;
+
+	if (adapter->sm.write_h2c != MAC_AX_OFLD_H2C_IDLE)
+		return MACPROCERR;
+
+	if (adapter->sm.write_request != MAC_AX_OFLD_REQ_CREATED)
+		return MACPROCERR;
+
+	if (cnv_write_ofld_state(adapter,
+				 MAC_AX_OFLD_REQ_H2C_SENT) != MACSUCCESS)
+		return MACPROCERR;
+
+	adapter->sm.write_h2c = MAC_AX_OFLD_H2C_SENDING;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, ofld_info->used_size);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	PLTFM_MEMCPY(buf, ofld_info->buf, ofld_info->used_size);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_WRITE_OFLD,
+			      1, 1);
+
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %d\n", ret);
+		adapter->sm.write_request = MAC_AX_OFLD_REQ_IDLE;
+		adapter->sm.write_h2c = MAC_AX_OFLD_H2C_IDLE;
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	if (cnv_write_ofld_state(adapter, MAC_AX_OFLD_REQ_IDLE) != MACSUCCESS)
+		return MACPROCERR;
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 cnv_conf_ofld_state(struct mac_ax_adapter *adapter, u8 dest)
+{
+	u8 state;
+
+	state = adapter->sm.conf_request;
+
+	if (state > MAC_AX_OFLD_REQ_CLEANED)
+		return MACPROCERR;
+
+	if (dest == MAC_AX_OFLD_REQ_IDLE) {
+		if (state != MAC_AX_OFLD_REQ_H2C_SENT)
+			return MACPROCERR;
+	} else if (dest == MAC_AX_OFLD_REQ_CLEANED) {
+		if (state == MAC_AX_OFLD_REQ_H2C_SENT)
+			return MACPROCERR;
+	} else if (dest == MAC_AX_OFLD_REQ_CREATED) {
+		if (state == MAC_AX_OFLD_REQ_IDLE ||
+		    state == MAC_AX_OFLD_REQ_H2C_SENT)
+			return MACPROCERR;
+	} else if (dest == MAC_AX_OFLD_REQ_H2C_SENT) {
+		if (state != MAC_AX_OFLD_REQ_CREATED)
+			return MACPROCERR;
+	}
+
+	adapter->sm.conf_request = dest;
+
+	return MACSUCCESS;
+}
+
+u32 mac_clear_conf_request(struct mac_ax_adapter *adapter)
+{
+	if (adapter->sm.conf_request == MAC_AX_OFLD_REQ_H2C_SENT)
+		return MACPROCERR;
+
+	if (cnv_conf_ofld_state(adapter, MAC_AX_OFLD_REQ_CLEANED) !=
+	    MACSUCCESS)
+		return MACPROCERR;
+
+	PLTFM_FREE(adapter->conf_ofld_info.buf,
+		   adapter->conf_ofld_info.buf_size);
+	adapter->conf_ofld_info.buf = NULL;
+	adapter->conf_ofld_info.buf_wptr = NULL;
+	adapter->conf_ofld_info.buf_size = 0;
+	adapter->conf_ofld_info.avl_buf_size = 0;
+	adapter->conf_ofld_info.used_size = 0;
+	adapter->conf_ofld_info.req_num = 0;
+
+	return MACSUCCESS;
+}
+
+u32 mac_add_conf_request(struct mac_ax_adapter *adapter,
+			 struct mac_ax_conf_ofld_req *req)
+{
+	struct mac_ax_conf_ofld_info *ofld_info = &adapter->conf_ofld_info;
+	struct fwcmd_conf_ofld_req_cmd *write_ptr;
+	u8 state;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	state = adapter->sm.conf_request;
+
+	if (!(state == MAC_AX_OFLD_REQ_CREATED ||
+	      state == MAC_AX_OFLD_REQ_CLEANED)) {
+		return MACPROCERR;
+	}
+
+	if (!ofld_info->buf) {
+		ofld_info->buf = (u8 *)PLTFM_MALLOC(CONF_OFLD_MAX_LEN);
+		if (!ofld_info->buf)
+			return MACNPTR;
+		ofld_info->buf_wptr = ofld_info->buf;
+		ofld_info->buf_size = CONF_OFLD_MAX_LEN;
+		ofld_info->avl_buf_size = CONF_OFLD_MAX_LEN;
+		ofld_info->used_size = 0;
+		ofld_info->req_num = 0;
+	}
+
+	if (ofld_info->avl_buf_size < sizeof(struct mac_ax_conf_ofld_req))
+		return MACNOBUF;
+
+	if (cnv_conf_ofld_state(adapter, MAC_AX_OFLD_REQ_CREATED) != MACSUCCESS)
+		return MACPROCERR;
+
+	write_ptr = (struct fwcmd_conf_ofld_req_cmd *)ofld_info->buf_wptr;
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD(req->device,
+			     FWCMD_H2C_CONF_OFLD_REQ_CMD_DEVICE)
+	);
+
+	write_ptr->dword1 =
+	cpu_to_le32(SET_WORD(req->req.hioe.hioe_op,
+			     FWCMD_H2C_CONF_OFLD_REQ_CMD_HIOE_OP) |
+		    SET_WORD(req->req.hioe.inst_type,
+			     FWCMD_H2C_CONF_OFLD_REQ_CMD_INST_TYPE) |
+		    SET_WORD(req->req.hioe.data_mode,
+			     FWCMD_H2C_CONF_OFLD_REQ_CMD_DATA_MODE)
+	);
+
+	write_ptr->dword2 = cpu_to_le32(req->req.hioe.param0.register_addr);
+
+	write_ptr->dword3 =
+	cpu_to_le32(SET_WORD(req->req.hioe.param1.byte_data_h,
+			     FWCMD_H2C_CONF_OFLD_REQ_CMD_BYTE_DATA_H) |
+		    SET_WORD(req->req.hioe.param2.byte_data_l,
+			     FWCMD_H2C_CONF_OFLD_REQ_CMD_BYTE_DATA_L)
+	);
+
+	ofld_info->buf_wptr += sizeof(struct mac_ax_conf_ofld_req);
+	ofld_info->avl_buf_size -= sizeof(struct mac_ax_conf_ofld_req);
+	ofld_info->used_size += sizeof(struct mac_ax_conf_ofld_req);
+
+	ofld_info->req_num++;
+
+	return MACSUCCESS;
+}
+
+u32 mac_conf_ofld(struct mac_ax_adapter *adapter)
+{
+	u8 *buf;
+	u32 ret;
+	struct fwcmd_conf_ofld *write_ptr;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct mac_ax_conf_ofld_info *ofld_info = &adapter->conf_ofld_info;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	if (ofld_info->used_size + FWCMD_HDR_LEN > CONF_OFLD_MAX_LEN)
+		return MACBUFSZ;
+
+	if (adapter->sm.conf_h2c != MAC_AX_OFLD_H2C_IDLE)
+		return MACPROCERR;
+
+	if (adapter->sm.conf_request != MAC_AX_OFLD_REQ_CREATED)
+		return MACPROCERR;
+
+	if (cnv_conf_ofld_state(adapter,
+				MAC_AX_OFLD_REQ_H2C_SENT) != MACSUCCESS)
+		return MACPROCERR;
+
+	adapter->sm.conf_h2c = MAC_AX_OFLD_H2C_SENDING;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_conf_ofld_hdr));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	write_ptr = (struct fwcmd_conf_ofld *)buf;
+
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD(ofld_info->req_num,
+			     FWCMD_H2C_CONF_OFLD_PATTERN_COUNT));
+
+	buf = h2cb_put(h2cb, ofld_info->used_size);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	PLTFM_MEMCPY(buf, ofld_info->buf, ofld_info->used_size);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_CONF_OFLD,
+			      1, 1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %d\n", ret);
+		adapter->sm.conf_request = MAC_AX_OFLD_REQ_IDLE;
+		adapter->sm.conf_h2c = MAC_AX_OFLD_H2C_IDLE;
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	if (cnv_conf_ofld_state(adapter, MAC_AX_OFLD_REQ_IDLE) != MACSUCCESS)
+		return MACPROCERR;
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_read_pkt_ofld(struct mac_ax_adapter *adapter, u8 id)
+{
+	u8 *buf;
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_packet_ofld *write_ptr;
+	struct mac_ax_pkt_ofld_info *ofld_info = &adapter->pkt_ofld_info;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	if (id == PKT_OFLD_NOT_EXISTS_ID)
+		return MACNOITEM;
+
+	if (mac_pkt_ofld_get_bitmap(ofld_info->id_bitmap, id) == 0)
+		return MACNOITEM;
+
+	if (adapter->sm.pkt_ofld != MAC_AX_OFLD_H2C_IDLE)
+		return MACPROCERR;
+
+	adapter->sm.pkt_ofld = MAC_AX_OFLD_H2C_SENDING;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_pkt_ofld_hdr));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	write_ptr = (struct fwcmd_packet_ofld *)buf;
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD(id, FWCMD_H2C_PACKET_OFLD_PKT_IDX) |
+		    SET_WORD(PKT_OFLD_OP_READ, FWCMD_H2C_PACKET_OFLD_PKT_OP)
+	);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_PACKET_OFLD,
+			      1, 1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %d\n", ret);
+		adapter->sm.pkt_ofld = MAC_AX_OFLD_H2C_IDLE;
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	ofld_info->last_op = PKT_OFLD_OP_READ;
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_del_pkt_ofld(struct mac_ax_adapter *adapter, u8 id)
+{
+	u8 *buf;
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_packet_ofld *write_ptr;
+	struct mac_ax_pkt_ofld_info *ofld_info = &adapter->pkt_ofld_info;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	if (id == PKT_OFLD_NOT_EXISTS_ID)
+		return MACNOITEM;
+
+	if (mac_pkt_ofld_get_bitmap(ofld_info->id_bitmap, id) == 0)
+		return MACNOITEM;
+
+	if (ofld_info->used_id_count == 0)
+		return MACNOITEM;
+
+	if (adapter->sm.pkt_ofld != MAC_AX_OFLD_H2C_IDLE)
+		return MACPROCERR;
+
+	adapter->sm.pkt_ofld = MAC_AX_OFLD_H2C_SENDING;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_pkt_ofld_hdr));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	write_ptr = (struct fwcmd_packet_ofld *)buf;
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD(id, FWCMD_H2C_PACKET_OFLD_PKT_IDX) |
+		    SET_WORD(PKT_OFLD_OP_DEL, FWCMD_H2C_PACKET_OFLD_PKT_OP)
+	);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_PACKET_OFLD,
+			      1, 1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %d\n", ret);
+		adapter->sm.pkt_ofld = MAC_AX_OFLD_H2C_IDLE;
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	ofld_info->last_op = PKT_OFLD_OP_DEL;
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_add_pkt_ofld(struct mac_ax_adapter *adapter, u8 *pkt, u16 len, u8 *id)
+{
+	u8 *buf;
+	u16 alloc_id;
+	u32 ret;
+	u32 sizeof_pkt_ofld_hdr = sizeof(struct mac_ax_pkt_ofld_hdr);
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_packet_ofld *write_ptr;
+	struct mac_ax_pkt_ofld_info *ofld_info = &adapter->pkt_ofld_info;
+	enum h2c_buf_class h2cb_type;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	if (ofld_info->free_id_count == 0)
+		return MACNOBUF;
+
+	if (adapter->sm.pkt_ofld != MAC_AX_OFLD_H2C_IDLE)
+		return MACPROCERR;
+
+	adapter->sm.pkt_ofld = MAC_AX_OFLD_H2C_SENDING;
+
+	for (alloc_id = 0; alloc_id < PKT_OFLD_MAX_COUNT - 1; alloc_id++) {
+		if (mac_pkt_ofld_get_bitmap(ofld_info->id_bitmap,
+					    alloc_id) == 0)
+			break;
+	}
+	if (alloc_id == PKT_OFLD_NOT_EXISTS_ID)
+		return MACNOBUF;
+
+	PLTFM_MSG_TRACE("pkt ofld add. alloc_id: %d, free cnt: %d, use cnt: %d\n",
+			alloc_id, ofld_info->free_id_count,
+			ofld_info->used_id_count);
+
+	if (len + sizeof_pkt_ofld_hdr <= (H2C_CMD_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_CMD;
+		PLTFM_MSG_TRACE("pkt ofld size %d, using CMD Q\n", len);
+	} else if (len + sizeof_pkt_ofld_hdr <= (H2C_DATA_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_DATA;
+		PLTFM_MSG_TRACE("pkt ofld size %d, using DATA Q\n", len);
+	} else if (len + sizeof_pkt_ofld_hdr <= (H2C_LONG_DATA_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_LONG_DATA;
+		PLTFM_MSG_TRACE("pkt ofld size %d, using LDATA Q\n", len);
+	} else {
+		PLTFM_MSG_ERR("pkt ofld size %d, exceed LDATA Q size, abort\n", len);
+		return MACBUFSZ;
+	}
+	h2cb = h2cb_alloc(adapter, h2cb_type);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_pkt_ofld_hdr));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	write_ptr = (struct fwcmd_packet_ofld *)buf;
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD((u8)alloc_id, FWCMD_H2C_PACKET_OFLD_PKT_IDX) |
+		    SET_WORD(PKT_OFLD_OP_ADD, FWCMD_H2C_PACKET_OFLD_PKT_OP) |
+		    SET_WORD(len, FWCMD_H2C_PACKET_OFLD_PKT_LENGTH)
+	);
+
+	*id = (u8)alloc_id;
+
+	buf = h2cb_put(h2cb, len);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	PLTFM_MEMCPY(buf, pkt, len);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_PACKET_OFLD,
+			      1, 1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %d\n", ret);
+		adapter->sm.pkt_ofld = MAC_AX_OFLD_H2C_IDLE;
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	ofld_info->last_op = PKT_OFLD_OP_ADD;
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_pkt_ofld_packet(struct mac_ax_adapter *adapter,
+			u8 **pkt_buf, u16 *pkt_len, u8 *pkt_id)
+{
+	struct mac_ax_pkt_ofld_pkt *pkt_info = &adapter->pkt_ofld_pkt;
+	*pkt_buf = NULL;
+
+	if (adapter->sm.pkt_ofld != MAC_AX_OFLD_H2C_DONE)
+		return MACPROCERR;
+
+	*pkt_buf = (u8 *)PLTFM_MALLOC(pkt_info->pkt_len);
+	if (!*pkt_buf)
+		return MACBUFALLOC;
+
+	PLTFM_MEMCPY(*pkt_buf, pkt_info->pkt, pkt_info->pkt_len);
+
+	*pkt_len = pkt_info->pkt_len;
+	*pkt_id = pkt_info->pkt_id;
+
+	adapter->sm.pkt_ofld = MAC_AX_OFLD_H2C_IDLE;
+
+	return MACSUCCESS;
+}
+
+u32 mac_dump_efuse_ofld(struct mac_ax_adapter *adapter, u32 efuse_size,
+			u8 type)
+{
+	u32 ret, size;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct mac_ax_efuse_ofld_info *ofld_info = &adapter->efuse_ofld_info;
+	u8 *buf;
+	struct fwcmd_dump_efuse *write_ptr;
+	u8 is_hidden = 0, is_dav = 0;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	if (adapter->sm.efuse_ofld != MAC_AX_OFLD_H2C_IDLE)
+		return MACPROCERR;
+
+	adapter->sm.efuse_ofld = MAC_AX_OFLD_H2C_SENDING;
+
+	size = efuse_size;
+	if (!ofld_info->buf) {
+		ofld_info->buf = (u8 *)PLTFM_MALLOC(size);
+		if (!ofld_info->buf)
+			return MACBUFALLOC;
+	}
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_pkt_ofld_hdr));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	if (type == DUMP_OFLD_TYPE_HIDDEN)
+		is_hidden = 1;
+	if (type == DUMP_OFLD_TYPE_DAV)
+		is_dav = 1;
+
+	write_ptr = (struct fwcmd_dump_efuse *)buf;
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD(efuse_size, FWCMD_H2C_DUMP_EFUSE_DUMP_SIZE) |
+		    (is_hidden ? FWCMD_H2C_DUMP_EFUSE_IS_HIDDEN : 0) |
+		    (is_dav ? FWCMD_H2C_DUMP_EFUSE_IS_DAV : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_DUMP_EFUSE,
+			      1, 0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx\n");
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+	return ret;
+}
+
+u32 mac_efuse_ofld_map(struct mac_ax_adapter *adapter, u8 *efuse_map,
+		       u32 efuse_size)
+{
+	u32 size = efuse_size;
+	struct mac_ax_efuse_ofld_info *ofld_info = &adapter->efuse_ofld_info;
+
+	if (adapter->sm.efuse_ofld != MAC_AX_OFLD_H2C_DONE)
+		return MACPROCERR;
+
+	PLTFM_MEMCPY(efuse_map, ofld_info->buf, size);
+
+	adapter->sm.efuse_ofld = MAC_AX_OFLD_H2C_IDLE;
+
+	return MACSUCCESS;
+}
+
+static u32 cnv_read_ofld_state(struct mac_ax_adapter *adapter, u8 dest)
+{
+	u8 state;
+
+	state = adapter->sm.read_request;
+
+	if (state > MAC_AX_OFLD_REQ_CLEANED)
+		return MACPROCERR;
+
+	if (dest == MAC_AX_OFLD_REQ_IDLE) {
+		if (state != MAC_AX_OFLD_REQ_H2C_SENT)
+			return MACPROCERR;
+	} else if (dest == MAC_AX_OFLD_REQ_CLEANED) {
+		if (state == MAC_AX_OFLD_REQ_H2C_SENT)
+			return MACPROCERR;
+	} else if (dest == MAC_AX_OFLD_REQ_CREATED) {
+		if (state == MAC_AX_OFLD_REQ_IDLE ||
+		    state == MAC_AX_OFLD_REQ_H2C_SENT)
+			return MACPROCERR;
+	} else if (dest == MAC_AX_OFLD_REQ_H2C_SENT) {
+		if (state != MAC_AX_OFLD_REQ_CREATED)
+			return MACPROCERR;
+	}
+
+	adapter->sm.read_request = dest;
+
+	return MACSUCCESS;
+}
+
+u32 mac_clear_read_request(struct mac_ax_adapter *adapter)
+{
+	if (adapter->sm.read_request == MAC_AX_OFLD_REQ_H2C_SENT)
+		return MACPROCERR;
+
+	if (cnv_read_ofld_state(adapter, MAC_AX_OFLD_REQ_CLEANED)
+	    != MACSUCCESS)
+		return MACPROCERR;
+
+	PLTFM_FREE(adapter->read_ofld_info.buf,
+		   adapter->read_ofld_info.buf_size);
+	adapter->read_ofld_info.buf = NULL;
+	adapter->read_ofld_info.buf_wptr = NULL;
+	adapter->read_ofld_info.last_req = NULL;
+	adapter->read_ofld_info.buf_size = 0;
+	adapter->read_ofld_info.avl_buf_size = 0;
+	adapter->read_ofld_info.used_size = 0;
+	adapter->read_ofld_info.req_num = 0;
+
+	return MACSUCCESS;
+}
+
+u32 mac_add_read_request(struct mac_ax_adapter *adapter,
+			 struct mac_ax_read_req *req)
+{
+	struct mac_ax_read_ofld_info *ofld_info = &adapter->read_ofld_info;
+	struct fwcmd_read_ofld_req *write_ptr;
+	u8 state;
+
+	state = adapter->sm.read_request;
+
+	if (!(state == MAC_AX_OFLD_REQ_CREATED ||
+	      state == MAC_AX_OFLD_REQ_CLEANED)) {
+		return MACPROCERR;
+	}
+
+	if (!ofld_info->buf) {
+		ofld_info->buf = (u8 *)PLTFM_MALLOC(READ_OFLD_MAX_LEN);
+		if (!ofld_info->buf)
+			return MACNPTR;
+		ofld_info->buf_wptr = ofld_info->buf;
+		ofld_info->buf_size = READ_OFLD_MAX_LEN;
+		ofld_info->avl_buf_size = READ_OFLD_MAX_LEN;
+		ofld_info->used_size = 0;
+		ofld_info->req_num = 0;
+	}
+
+	if (ofld_info->avl_buf_size < sizeof(struct mac_ax_read_req))
+		return MACNOBUF;
+
+	if (cnv_read_ofld_state(adapter, MAC_AX_OFLD_REQ_CREATED) != MACSUCCESS)
+		return MACPROCERR;
+
+	if (ofld_info->req_num != 0)
+		ofld_info->last_req->ls = 0;
+
+	ofld_info->last_req = (struct mac_ax_read_req *)ofld_info->buf_wptr;
+
+	req->ls = 1;
+
+	write_ptr = (struct fwcmd_read_ofld_req *)ofld_info->buf_wptr;
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD(req->value_len,
+			     FWCMD_H2C_READ_OFLD_REQ_VALUE_LEN) |
+		    SET_WORD(req->ofld_id,
+			     FWCMD_H2C_READ_OFLD_REQ_OFLD_ID) |
+		    SET_WORD(req->entry_num,
+			     FWCMD_H2C_READ_OFLD_REQ_ENTRY_NUM) | req->ls
+	);
+
+	write_ptr->dword1 =
+	cpu_to_le32(SET_WORD(req->offset,
+			     FWCMD_H2C_READ_OFLD_REQ_OFFSET)
+	);
+
+	ofld_info->buf_wptr += sizeof(struct mac_ax_read_req);
+	ofld_info->avl_buf_size -= sizeof(struct mac_ax_read_req);
+	ofld_info->used_size += sizeof(struct mac_ax_read_req);
+	ofld_info->req_num++;
+
+	return MACSUCCESS;
+}
+
+u32 mac_read_ofld(struct mac_ax_adapter *adapter)
+{
+	u8 *buf;
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct mac_ax_read_ofld_info *ofld_info = &adapter->read_ofld_info;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	if (ofld_info->used_size + FWCMD_HDR_LEN > READ_OFLD_MAX_LEN)
+		return MACBUFSZ;
+
+	if (adapter->sm.read_h2c != MAC_AX_OFLD_H2C_IDLE)
+		return MACPROCERR;
+
+	if (adapter->sm.read_request != MAC_AX_OFLD_REQ_CREATED)
+		return MACPROCERR;
+
+	if (cnv_read_ofld_state(adapter,
+				MAC_AX_OFLD_REQ_H2C_SENT) != MACSUCCESS)
+		return MACPROCERR;
+
+	adapter->sm.read_h2c = MAC_AX_OFLD_H2C_SENDING;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, ofld_info->used_size);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	PLTFM_MEMCPY(buf, ofld_info->buf, ofld_info->used_size);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_READ_OFLD,
+			      1, 1);
+
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %d\n", ret);
+		adapter->sm.read_request = MAC_AX_OFLD_REQ_IDLE;
+		adapter->sm.read_h2c = MAC_AX_OFLD_H2C_IDLE;
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	if (cnv_read_ofld_state(adapter, MAC_AX_OFLD_REQ_IDLE) != MACSUCCESS)
+		return MACPROCERR;
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_read_ofld_value(struct mac_ax_adapter *adapter,
+			u8 **val_buf, u16 *val_len)
+{
+	struct mac_ax_read_ofld_value *value_info = &adapter->read_ofld_value;
+	*val_buf = NULL;
+
+	if (adapter->sm.read_h2c != MAC_AX_OFLD_H2C_DONE)
+		return MACPROCERR;
+
+	*val_buf = (u8 *)PLTFM_MALLOC(value_info->len);
+	if (!*val_buf)
+		return MACBUFALLOC;
+
+	PLTFM_MEMCPY(*val_buf, value_info->buf, value_info->len);
+
+	*val_len = value_info->len;
+
+	adapter->sm.read_h2c = MAC_AX_OFLD_H2C_IDLE;
+
+	return MACSUCCESS;
+}
+
+u32 mac_general_pkt_ids(struct mac_ax_adapter *adapter,
+			struct mac_ax_general_pkt_ids *ids)
+{
+	u8 *buf;
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_general_pkt *write_ptr;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_general_pkt_ids));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	write_ptr = (struct fwcmd_general_pkt *)buf;
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD(ids->macid, FWCMD_H2C_GENERAL_PKT_MACID) |
+		    SET_WORD(ids->probersp, FWCMD_H2C_GENERAL_PKT_PROBRSP_ID) |
+		    SET_WORD(ids->pspoll, FWCMD_H2C_GENERAL_PKT_PSPOLL_ID) |
+		    SET_WORD(ids->nulldata, FWCMD_H2C_GENERAL_PKT_NULL_ID)
+	);
+
+	write_ptr->dword1 =
+	cpu_to_le32(SET_WORD(ids->qosnull, FWCMD_H2C_GENERAL_PKT_QOS_NULL_ID) |
+		    SET_WORD(ids->cts2self, FWCMD_H2C_GENERAL_PKT_CTS2SELF_ID) |
+		    SET_WORD(ids->probereq, FWCMD_H2C_GENERAL_PKT_PROBREQ_ID) |
+		    SET_WORD(ids->apcsa, FWCMD_H2C_GENERAL_PKT_APCSA_ID)
+	);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_INFO,
+			      FWCMD_H2C_FUNC_GENERAL_PKT,
+			      1, 1);
+	if (ret)
+		goto fail;
+
+	// Return MACSUCCESS if h2c aggregation is enabled and enqueued successfully.
+	// The H2C shall be sent by mac_h2c_agg_tx.
+	ret = h2c_agg_enqueue(adapter, h2cb);
+	if (ret == MACSUCCESS)
+		return MACSUCCESS;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %d\n", ret);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 base_offset_to_h2c(struct mac_ax_adapter *adapter, u32 *base_offset,
+			      enum rtw_mac_src_cmd_ofld *src, enum rtw_mac_rf_path *rf_path)
+{
+#define BASE_BITS 0x00FF0000
+#define MAC_BASE_OFFSET (0x18600000 & BASE_BITS)
+#define BB_BASE_OFFSET (0x18610000 & BASE_BITS)
+#define RF_ADIE_BASE_OFFSET (BB_BASE_OFFSET | BIT(23))
+#define RF_PATH_B_BASE_OFFSET 0x1000
+	u32 ret = MACSUCCESS;
+
+	switch (*base_offset & BASE_BITS) {
+	case MAC_BASE_OFFSET:
+		*src = RTW_MAC_MAC_CMD_OFLD;
+		*rf_path = RTW_MAC_RF_PATH_A;
+		break;
+	case BB_BASE_OFFSET:
+		*src = RTW_MAC_BB_CMD_OFLD;
+		*rf_path = RTW_MAC_RF_PATH_A;
+		break;
+	case (RF_ADIE_BASE_OFFSET | RF_PATH_B_BASE_OFFSET):
+		*src = RTW_MAC_RF_CMD_OFLD;
+		*rf_path = RTW_MAC_RF_PATH_A;
+		break;
+	case (RF_ADIE_BASE_OFFSET & ~RF_PATH_B_BASE_OFFSET):
+		*src = RTW_MAC_RF_CMD_OFLD;
+		*rf_path = RTW_MAC_RF_PATH_B;
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR] wrong base_offset: %x\n", *base_offset);
+		ret = MACHWNOSUP;
+		break;
+	}
+	*base_offset &= ~BASE_BITS;
+	return ret;
+#undef BASE_BITS
+#undef MAC_BASE_OFFSET
+#undef BB_BASE_OFFSET
+#undef RF_DDIE_BASE_OFFSET
+#undef RF_PATH_B_BASE_OFFSET
+}
+
+static u32 gen_base_offset(struct mac_ax_adapter *adapter, enum rtw_mac_src_cmd_ofld src,
+			   enum rtw_mac_rf_path rf_path, u32 *base_offset)
+{
+#define BASE_BITS 0x00FF0000
+#define MAC_BASE_OFFSET (0x18600000 & BASE_BITS)
+#define BB_BASE_OFFSET (0x18610000 & BASE_BITS)
+#define RF_ADIE_BASE_OFFSET (BB_BASE_OFFSET | BIT(23))
+#define RF_PATH_B_BASE_OFFSET 0x1000
+	u32 ret = MACSUCCESS;
+
+	switch (src) {
+	case RTW_MAC_MAC_CMD_OFLD:
+		*base_offset = MAC_BASE_OFFSET;
+		break;
+	case RTW_MAC_BB_CMD_OFLD:
+		*base_offset = BB_BASE_OFFSET;
+		break;
+	case RTW_MAC_RF_CMD_OFLD:
+		*base_offset = RF_ADIE_BASE_OFFSET;
+		switch (rf_path) {
+		case RTW_MAC_RF_PATH_A:
+			*base_offset &= ~RF_PATH_B_BASE_OFFSET;
+			break;
+		case RTW_MAC_RF_PATH_B:
+			*base_offset |= RF_PATH_B_BASE_OFFSET;
+			break;
+		default:
+			PLTFM_MSG_ERR("[ERR] wrong path: %d\n", rf_path);
+			ret = MACHWNOSUP;
+			break;
+		}
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR] wrong src: %d\n", src);
+		ret = MACHWNOSUP;
+		break;
+	}
+	return ret;
+#undef BASE_BITS
+#undef MAC_BASE_OFFSET
+#undef BB_BASE_OFFSET
+#undef RF_DDIE_BASE_OFFSET
+#undef RF_PATH_B_BASE_OFFSET
+}
+
+static u32 add_cmd_v1(struct mac_ax_adapter *adapter, struct rtw_mac_cmd_v1 *cmd)
+{
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+	struct fwcmd_cmd_ofld_v1 *write_ptr;
+	u32 base_offset;
+	u32 ret;
+	u16 total_len = CMD_OFLD_V1_SIZE;
+
+	/* initialize */
+	if (!ofld_info->buf) {
+		ofld_info->buf = (u8 *)PLTFM_MALLOC(CMD_OFLD_MAX_LEN);
+		if (!ofld_info->buf)
+			return MACBUFALLOC;
+		ofld_info->buf_wptr = ofld_info->buf;
+		ofld_info->last_wptr = NULL;
+		ofld_info->buf_size = CMD_OFLD_MAX_LEN;
+		ofld_info->avl_buf_size = CMD_OFLD_MAX_LEN;
+		ofld_info->used_size = 0;
+		ofld_info->cmd_num = 0;
+		ofld_info->accu_delay = 0;
+	}
+
+	write_ptr = (struct fwcmd_cmd_ofld_v1 *)ofld_info->buf_wptr;
+
+	ret = gen_base_offset(adapter, cmd->src0, cmd->rf_path0, &base_offset);
+	if (ret != MACSUCCESS)
+		return ret;
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD(cmd->type, FWCMD_H2C_CMD_OFLD_V1_TYPE) |
+		    (cmd->lc ? FWCMD_H2C_CMD_OFLD_V1_LC : 0) |
+		    SET_WORD(((u32)cmd->offset0) + base_offset, FWCMD_H2C_CMD_OFLD_V1_OFFSET0)
+	);
+
+	ret = gen_base_offset(adapter, cmd->src1, cmd->rf_path1, &base_offset);
+	if (ret != MACSUCCESS)
+		return ret;
+	write_ptr->dword1 =
+	cpu_to_le32(SET_WORD(((u32)cmd->offset1) + base_offset, FWCMD_H2C_CMD_OFLD_V1_OFFSET1) |
+		    SET_WORD(ofld_info->cmd_num, FWCMD_H2C_CMD_OFLD_V1_CMD_NUM));
+	write_ptr->dword2 =
+	cpu_to_le32(SET_WORD(cmd->mask0, FWCMD_H2C_CMD_OFLD_V1_MASK0));
+	write_ptr->dword3 =
+	cpu_to_le32(SET_WORD(cmd->value, FWCMD_H2C_CMD_OFLD_V1_VALUE));
+
+	ofld_info->last_ver = MAC_AX_CMD_OFLD_V1;
+	ofld_info->last_wptr = ofld_info->buf_wptr;
+	ofld_info->buf_wptr += total_len;
+	ofld_info->avl_buf_size -= total_len;
+	ofld_info->used_size += total_len;
+	ofld_info->cmd_num++;
+	if (cmd->type == RTW_MAC_DELAY_OFLD)
+		ofld_info->accu_delay += cmd->value;
+
+	return MACSUCCESS;
+}
+
+static u32 add_cmd(struct mac_ax_adapter *adapter, struct rtw_mac_cmd *cmd)
+{
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+	u16 total_len = CMD_OFLD_SIZE;
+	struct fwcmd_cmd_ofld *write_ptr;
+	enum rtw_mac_src_cmd_ofld src = cmd->src;
+
+	if (!ofld_info->buf) {
+		ofld_info->buf = (u8 *)PLTFM_MALLOC(CMD_OFLD_MAX_LEN);
+		if (!ofld_info->buf)
+			return MACBUFALLOC;
+		ofld_info->buf_wptr = ofld_info->buf;
+		ofld_info->last_wptr = NULL;
+		ofld_info->buf_size = CMD_OFLD_MAX_LEN;
+		ofld_info->avl_buf_size = CMD_OFLD_MAX_LEN;
+		ofld_info->used_size = 0;
+		ofld_info->cmd_num = 0;
+		ofld_info->accu_delay = 0;
+	}
+
+	write_ptr = (struct fwcmd_cmd_ofld *)ofld_info->buf_wptr;
+
+	src = cmd->src == RTW_MAC_RF_DDIE_CMD_OFLD ? RTW_MAC_RF_CMD_OFLD : cmd->src;
+
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD(src, FWCMD_H2C_CMD_OFLD_SRC) |
+		    SET_WORD(cmd->type, FWCMD_H2C_CMD_OFLD_TYPE) |
+		    (cmd->lc ? FWCMD_H2C_CMD_OFLD_LC : 0) |
+		    SET_WORD(cmd->rf_path, FWCMD_H2C_CMD_OFLD_PATH) |
+		    SET_WORD(cmd->offset, FWCMD_H2C_CMD_OFLD_OFFSET) |
+		    SET_WORD(ofld_info->cmd_num, FWCMD_H2C_CMD_OFLD_CMD_NUM)
+	);
+	/* TODO: change FWCMD_H2C_CMD_OFLD_OFFSET to FWCMD_H2C_CMD_OFLD_BASE_OFFSET */
+	write_ptr->dword1 =
+	cpu_to_le32(SET_WORD(cmd->id, FWCMD_H2C_CMD_OFLD_ID) |
+		    SET_WORD(cmd->src == RTW_MAC_RF_DDIE_CMD_OFLD ? 1 : 0,
+			     FWCMD_H2C_CMD_OFLD_OFFSET)
+	);
+
+	write_ptr->dword2 =
+	cpu_to_le32(SET_WORD(cmd->value, FWCMD_H2C_CMD_OFLD_VALUE));
+	write_ptr->dword3 =
+	cpu_to_le32(SET_WORD(cmd->mask, FWCMD_H2C_CMD_OFLD_MASK));
+
+	ofld_info->last_ver = MAC_AX_CMD_OFLD;
+	ofld_info->last_wptr = ofld_info->buf_wptr;
+	ofld_info->buf_wptr += total_len;
+	ofld_info->avl_buf_size -= total_len;
+	ofld_info->used_size += total_len;
+	ofld_info->cmd_num++;
+	if (cmd->type == RTW_MAC_DELAY_OFLD)
+		ofld_info->accu_delay += cmd->value;
+
+	return MACSUCCESS;
+}
+
+static u32 chk_cmd_ofld_reg(struct mac_ax_adapter *adapter)
+{
+#define MAC_AX_CMD_OFLD_POLL_CNT 1000
+#define MAC_AX_CMD_OFLD_POLL_US 50
+	struct mac_ax_c2hreg_poll c2h;
+	struct fwcmd_c2hreg *c2h_content;
+	u32 ret, result, i, cmd_num;
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+	u8 *cmd;
+
+	c2h.polling_id = FWCMD_C2HREG_FUNC_IO_OFLD_RESULT;
+	c2h.retry_cnt = MAC_AX_CMD_OFLD_POLL_CNT;
+	c2h.retry_wait_us = MAC_AX_CMD_OFLD_POLL_US;
+	ret = proc_msg_reg(adapter, NULL, &c2h);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: fail to wait FW done(%d)\n", __func__, ret);
+		return ret;
+	}
+
+	c2h_content = &c2h.c2hreg_cont.c2h_content;
+	result = GET_FIELD(c2h_content->dword0,
+			   FWCMD_C2HREG_IO_OFLD_RESULT_RET);
+	if (result) {
+		cmd_num = GET_FIELD(c2h_content->dword0,
+				    FWCMD_C2HREG_IO_OFLD_RESULT_CMD_NUM);
+		cmd = ofld_info->buf + cmd_num * CMD_OFLD_SIZE;
+		PLTFM_MSG_ERR("%s: fail to finish IO offload\n", __func__);
+		PLTFM_MSG_ERR("fail offset = %x\n", c2h_content->dword1);
+		PLTFM_MSG_ERR("exp val = %x\n", c2h_content->dword2);
+		PLTFM_MSG_ERR("read val = %x\n", c2h_content->dword3);
+		PLTFM_MSG_ERR("fail cmd num = %d\n", cmd_num);
+		for (i = 0; i < CMD_OFLD_SIZE; i += 4)
+			PLTFM_MSG_ERR("%x\n", *((u32 *)(cmd + i)));
+
+		return MACFIOOFLD;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 chk_cmd_ofld_pkt(struct mac_ax_adapter *adapter)
+{
+	u32 cnt = MAC_AX_CMD_OFLD_POLL_CNT;
+	struct mac_ax_state_mach *sm = &adapter->sm;
+	struct mac_ax_drv_stats *drv_stats = &adapter->drv_stats;
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+
+	while (--cnt) {
+		if (sm->cmd_state == MAC_AX_CMD_OFLD_RCVD)
+			break;
+		if (drv_stats->drv_rm)
+			return MACDRVRM;
+		PLTFM_DELAY_US(MAC_AX_CMD_OFLD_POLL_US);
+	}
+
+	PLTFM_MSG_TRACE("%s: cnt = %d, us = %d\n",
+			__func__, cnt, MAC_AX_CMD_OFLD_POLL_US);
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("%s: polling timeout\n", __func__);
+		return MACPOLLTO;
+	}
+
+	if (ofld_info->result) {
+		PLTFM_MSG_ERR("%s: ofld FAIL!!!\n", __func__);
+		return MACFIOOFLD;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 chk_cmd_ofld(struct mac_ax_adapter *adapter, u8 rx_ok)
+{
+	u32 ret;
+
+	if (rx_ok)
+		ret = chk_cmd_ofld_pkt(adapter);
+	else
+		ret = chk_cmd_ofld_reg(adapter);
+
+	return ret;
+}
+
+static u32 h2c_buf_to_cmd_ofld(struct mac_ax_adapter *adapter, struct fwcmd_cmd_ofld *h2c_content,
+			       struct rtw_mac_cmd *cmd, u8 *cmd_num)
+{
+	u16 base_offset;
+
+	if (!cmd || !cmd_num) {
+		PLTFM_MSG_ERR("[ERR][CMD_OFLD] cmd = NULL or cmd_num = NULL");
+		return MACNPTR;
+	}
+
+	cmd->src = (enum rtw_mac_src_cmd_ofld)GET_FIELD(h2c_content->dword0,
+							FWCMD_H2C_CMD_OFLD_SRC);
+	cmd->type = (enum rtw_mac_cmd_type_ofld)GET_FIELD(h2c_content->dword0,
+							  FWCMD_H2C_CMD_OFLD_TYPE);
+	cmd->lc = (h2c_content->dword0 & FWCMD_H2C_CMD_OFLD_LC) ? 1 : 0;
+	cmd->rf_path = (enum rtw_mac_rf_path)GET_FIELD(h2c_content->dword0,
+						       FWCMD_H2C_CMD_OFLD_PATH);
+	cmd->offset = GET_FIELD(h2c_content->dword0, FWCMD_H2C_CMD_OFLD_OFFSET);
+	*cmd_num = GET_FIELD(h2c_content->dword0, FWCMD_H2C_CMD_OFLD_CMD_NUM);
+
+	cmd->id = GET_FIELD(h2c_content->dword1, FWCMD_H2C_CMD_OFLD_ID);
+	base_offset = GET_FIELD(h2c_content->dword1, FWCMD_H2C_CMD_OFLD_BASE_OFFSET);
+	if (base_offset) {
+		if (cmd->src != RTW_MAC_RF_CMD_OFLD) {
+			PLTFM_MSG_ERR("[ERR][CMD_OFLD]BASE_OFFSET = %d, while src = %d",
+				      base_offset, cmd->src);
+		} else {
+			cmd->src = RTW_MAC_RF_DDIE_CMD_OFLD;
+		}
+	}
+
+	cmd->value = GET_FIELD(h2c_content->dword2, FWCMD_H2C_CMD_OFLD_VALUE);
+	cmd->mask = GET_FIELD(h2c_content->dword3, FWCMD_H2C_CMD_OFLD_MASK);
+
+	return MACSUCCESS;
+}
+
+static u32 h2c_buf_to_cmd_ofld_v1(struct mac_ax_adapter *adapter,
+				  struct fwcmd_cmd_ofld_v1 *h2c_content,
+				  struct rtw_mac_cmd_v1 *cmd, u8 *cmd_num)
+{
+	u32 offset;
+
+	if (!cmd || !cmd_num) {
+		PLTFM_MSG_ERR("[ERR][CMD_OFLD_V1] cmd = NULL or cmd_num = NULL");
+		return MACNPTR;
+	}
+
+	cmd->type = (enum rtw_mac_cmd_type_ofld)GET_FIELD(h2c_content->dword0,
+							  FWCMD_H2C_CMD_OFLD_V1_TYPE);
+	cmd->lc = (h2c_content->dword0 & FWCMD_H2C_CMD_OFLD_V1_LC) ? 1 : 0;
+	offset = GET_FIELD(h2c_content->dword0, FWCMD_H2C_CMD_OFLD_V1_OFFSET0);
+	base_offset_to_h2c(adapter, &offset, &cmd->src0, &cmd->rf_path0);
+	cmd->offset0 = (u16)offset;
+	offset = GET_FIELD(h2c_content->dword1, FWCMD_H2C_CMD_OFLD_V1_OFFSET1);
+	base_offset_to_h2c(adapter, &offset, &cmd->src1, &cmd->rf_path1);
+	cmd->offset1 = (u16)offset;
+
+	*cmd_num = GET_FIELD(h2c_content->dword1, FWCMD_H2C_CMD_OFLD_V1_CMD_NUM);
+	cmd->mask0 = GET_FIELD(h2c_content->dword2, FWCMD_H2C_CMD_OFLD_V1_MASK0);
+	cmd->value = GET_FIELD(h2c_content->dword3, FWCMD_H2C_CMD_OFLD_V1_VALUE);
+
+	return MACSUCCESS;
+}
+
+static u32 dump_cmd_ofld(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+	struct fwcmd_cmd_ofld *content = (struct fwcmd_cmd_ofld *)ofld_info->buf;
+	struct rtw_mac_cmd cmd;
+	u8 cmd_num;
+	u32 ret;
+
+	while (content <= (struct fwcmd_cmd_ofld *)ofld_info->last_wptr) {
+		ret = h2c_buf_to_cmd_ofld(adapter, content, &cmd, &cmd_num);
+		if (ret != MACSUCCESS)
+			return ret;
+		if (content > (struct fwcmd_cmd_ofld *)ofld_info->buf)
+			PLTFM_MSG_ERR("[ERR][CMD_OFLD] ========\n");
+		switch (cmd.src) {
+		case RTW_MAC_BB_CMD_OFLD:
+			PLTFM_MSG_ERR("Plese check with BB owner");
+			break;
+		case RTW_MAC_RF_CMD_OFLD:
+			PLTFM_MSG_ERR("Plese check with RF owner");
+			break;
+		case RTW_MAC_MAC_CMD_OFLD:
+			PLTFM_MSG_ERR("Plese check with MAC owner");
+			break;
+		case RTW_MAC_RF_DDIE_CMD_OFLD:
+			PLTFM_MSG_ERR("Plese check with RF owner");
+			break;
+		case RTW_MAC_OTHER_CMD_OFLD:
+			PLTFM_MSG_ERR("Plese check with MAC owner");
+			break;
+		default:
+			PLTFM_MSG_ERR("Plese check with MAC owner");
+		}
+		PLTFM_MSG_ERR("[ERR][CMD_OFLD] src = %d, type = %d, lc = %hu\n",
+			      cmd.src, cmd.type, cmd.lc);
+		PLTFM_MSG_ERR("[ERR][CMD_OFLD] rf_path = %d, cmd_num = %hu\n",
+			      cmd.rf_path, cmd_num);
+		PLTFM_MSG_ERR("[ERR][CMD_OFLD] offset = 0x%hx, id = 0x%hx\n",
+			      cmd.offset, cmd.id);
+		PLTFM_MSG_ERR("[ERR][CMD_OFLD] value = 0x%x, mask = 0x%x\n",
+			      cmd.value, cmd.mask);
+		content++;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 dump_cmd_ofld_v1(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+	struct fwcmd_cmd_ofld_v1 *content = (struct fwcmd_cmd_ofld_v1 *)ofld_info->buf;
+	struct rtw_mac_cmd_v1 cmd;
+	u8 cmd_num;
+	u32 ret;
+
+	while (content <= (struct fwcmd_cmd_ofld_v1 *)ofld_info->last_wptr) {
+		ret = h2c_buf_to_cmd_ofld_v1(adapter, content, &cmd, &cmd_num);
+		if (ret != MACSUCCESS)
+			return ret;
+		if (content > (struct fwcmd_cmd_ofld_v1 *)ofld_info->buf)
+			PLTFM_MSG_ERR("[ERR][CMD_OFLD_V1] ========\n");
+		switch (cmd.src0) {
+		case RTW_MAC_BB_CMD_OFLD:
+			PLTFM_MSG_ERR("Plese check with BB owner");
+			break;
+		case RTW_MAC_RF_CMD_OFLD:
+			PLTFM_MSG_ERR("Plese check with RF owner");
+			break;
+		case RTW_MAC_MAC_CMD_OFLD:
+			PLTFM_MSG_ERR("Plese check with MAC owner");
+			break;
+		case RTW_MAC_RF_DDIE_CMD_OFLD:
+			PLTFM_MSG_ERR("Plese check with RF owner");
+			break;
+		case RTW_MAC_OTHER_CMD_OFLD:
+			PLTFM_MSG_ERR("Plese check with MAC owner");
+			break;
+		default:
+			PLTFM_MSG_ERR("Plese check with MAC owner");
+		}
+		PLTFM_MSG_ERR("[ERR][CMD_OFLD_V1] src0=%d, rf_path0=%d, src1=%d, rf_path1=%d\n",
+			      cmd.src0, cmd.rf_path0, cmd.src1, cmd.rf_path1);
+		PLTFM_MSG_ERR("[ERR][CMD_OFLD_V1] type = %d, lc = %hu, cmd_num = %hu\n",
+			      cmd.type, cmd.lc, cmd_num);
+		PLTFM_MSG_ERR("[ERR][CMD_OFLD_V1] offset0 = 0x%hx, offset1 = 0x%hx\n",
+			      cmd.offset0, cmd.offset1);
+		PLTFM_MSG_ERR("[ERR][CMD_OFLD_V1] mask0 = 0x%x, value = 0x%x\n",
+			      cmd.mask0, cmd.value);
+		content++;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 dump_cmd_ofld_h2c(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+	u32 ret = MACNOTSUP;
+
+	if (ofld_info->last_ver == MAC_AX_CMD_OFLD)
+		ret = dump_cmd_ofld(adapter);
+	else if (ofld_info->last_ver == MAC_AX_CMD_OFLD_V1)
+		ret = dump_cmd_ofld_v1(adapter);
+
+	return ret;
+}
+
+static u32 proc_cmd_ofld(struct mac_ax_adapter *adapter, u8 func)
+{
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+	u8 *buffer;
+	struct mac_ax_state_mach *sm = &adapter->sm;
+
+	PLTFM_MSG_TRACE("%s===>\n", __func__);
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buffer = h2cb_put(h2cb, ofld_info->used_size);
+	if (!buffer) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	PLTFM_MEMCPY(buffer, ofld_info->buf, ofld_info->used_size);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, func,
+			      0, 0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	sm->cmd_state = MAC_AX_CMD_OFLD_SENDING;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx\n");
+		goto fail;
+	}
+
+	if (ofld_info->accu_delay)
+		PLTFM_DELAY_US(ofld_info->accu_delay);
+
+	ret = chk_cmd_ofld(adapter, adapter->drv_stats.rx_ok);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: check IO offload fail\n", __func__);
+		dump_cmd_ofld_h2c(adapter);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+	PLTFM_FREE(ofld_info->buf, CMD_OFLD_MAX_LEN);
+	ofld_info->buf = NULL;
+
+	PLTFM_MSG_TRACE("%s<===\n", __func__);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+	PLTFM_FREE(ofld_info->buf, CMD_OFLD_MAX_LEN);
+	ofld_info->buf = NULL;
+
+	return ret;
+}
+
+static u32 cmd_ofld(struct mac_ax_adapter *adapter)
+{
+	u8 func;
+	u8 rx_ok = adapter->drv_stats.rx_ok;
+
+	func = rx_ok ? FWCMD_H2C_FUNC_CMD_OFLD_PKT :
+		FWCMD_H2C_FUNC_CMD_OFLD_REG;
+	return proc_cmd_ofld(adapter, func);
+}
+
+static u32 cmd_ofld_v1(struct mac_ax_adapter *adapter)
+{
+	u8 func;
+	u8 rx_ok = adapter->drv_stats.rx_ok;
+
+	func = rx_ok ? FWCMD_H2C_FUNC_CMD_OFLD_V1_PKT :
+		FWCMD_H2C_FUNC_CMD_OFLD_V1_REG;
+	return proc_cmd_ofld(adapter, func);
+}
+
+u32 mac_cmd_ofld(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+	struct mac_ax_state_mach *sm = &adapter->sm;
+	u32 ret = MACSUCCESS;
+
+	if (!ofld_info->buf) {
+		PLTFM_MSG_ERR("%s: ofld_info->buf is null\n", __func__);
+		return MACNPTR;
+	}
+
+	PLTFM_MUTEX_LOCK(&ofld_info->cmd_ofld_lock);
+	if (sm->cmd_state != MAC_AX_CMD_OFLD_IDLE) {
+		PLTFM_MSG_ERR("%s: IO offload is busy\n", __func__);
+		PLTFM_MUTEX_UNLOCK(&ofld_info->cmd_ofld_lock);
+		return MACPROCERR;
+	}
+	sm->cmd_state = MAC_AX_CMD_OFLD_PROC;
+	PLTFM_MUTEX_UNLOCK(&ofld_info->cmd_ofld_lock);
+
+	if (ofld_info->last_ver == MAC_AX_CMD_OFLD)
+		ret = cmd_ofld(adapter);
+	else if (ofld_info->last_ver == MAC_AX_CMD_OFLD_V1)
+		ret = cmd_ofld_v1(adapter);
+
+	PLTFM_MUTEX_LOCK(&ofld_info->cmd_ofld_lock);
+	sm->cmd_state = MAC_AX_CMD_OFLD_IDLE;
+	PLTFM_MUTEX_UNLOCK(&ofld_info->cmd_ofld_lock);
+
+	return ret;
+}
+
+static u32 ofld_incompatible_full_cmd(struct mac_ax_adapter *adapter, enum cmd_ofld_ver crnt_ver)
+{
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+	u32 ret = MACSUCCESS;
+
+	if (!ofld_info->buf)
+		return ret;
+	/* full or incompatible */
+	if (ofld_info->avl_buf_size < CMD_OFLD_V1_SIZE ||
+	    (ofld_info->last_ver != crnt_ver && ofld_info->avl_buf_size < WRITE_OFLD_MAX_LEN)) {
+		if (!ofld_info->last_wptr) {
+			PLTFM_MSG_ERR("%s: wrong pointer\n", __func__);
+			return MACNPTR;
+		}
+		if (ofld_info->last_ver == MAC_AX_CMD_OFLD) {
+			*ofld_info->last_wptr = *ofld_info->last_wptr |
+				FWCMD_H2C_CMD_OFLD_LC;
+			ret = cmd_ofld(adapter);
+		} else if (ofld_info->last_ver == MAC_AX_CMD_OFLD_V1) {
+			*ofld_info->last_wptr = *ofld_info->last_wptr |
+				FWCMD_H2C_CMD_OFLD_V1_LC;
+			ret = cmd_ofld_v1(adapter);
+		} else {
+			PLTFM_MSG_ERR("%s: unrecognized cmd ver\n", __func__);
+			return MACNOTSUP;
+		}
+		if (ret)
+			PLTFM_MSG_ERR("%s: send IO offload fail\n", __func__);
+	}
+	return ret;
+}
+
+u32 mac_add_cmd_ofld(struct mac_ax_adapter *adapter, struct rtw_mac_cmd *cmd)
+{
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+	struct mac_ax_state_mach *sm = &adapter->sm;
+	u32 ret = MACSUCCESS;
+
+	if (cmd->type !=  RTW_MAC_DELAY_OFLD &&
+	    (cmd->src != RTW_MAC_RF_CMD_OFLD && cmd->src != RTW_MAC_RF_DDIE_CMD_OFLD) &&
+	    cmd->offset & (4 - 1))
+		return MACBADDR;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	PLTFM_MUTEX_LOCK(&ofld_info->cmd_ofld_lock);
+	if (sm->cmd_state != MAC_AX_CMD_OFLD_IDLE) {
+		PLTFM_MSG_ERR("%s: IO offload is busy\n", __func__);
+		PLTFM_MUTEX_UNLOCK(&ofld_info->cmd_ofld_lock);
+		return MACPROCERR;
+	}
+	sm->cmd_state = MAC_AX_CMD_OFLD_PROC;
+	PLTFM_MUTEX_UNLOCK(&ofld_info->cmd_ofld_lock);
+
+	ret = ofld_incompatible_full_cmd(adapter, MAC_AX_CMD_OFLD);
+	if (ret != MACSUCCESS)
+		goto END;
+
+	ret = add_cmd(adapter, cmd);
+	if (ret)
+		goto END;
+
+	if (!cmd->lc)
+		goto END;
+
+	ret = cmd_ofld(adapter);
+
+END:
+	PLTFM_MUTEX_LOCK(&ofld_info->cmd_ofld_lock);
+	sm->cmd_state = MAC_AX_CMD_OFLD_IDLE;
+	PLTFM_MUTEX_UNLOCK(&ofld_info->cmd_ofld_lock);
+
+	return ret;
+}
+
+u32 mac_add_cmd_ofld_v1(struct mac_ax_adapter *adapter, struct rtw_mac_cmd_v1 *cmd)
+{
+	struct mac_ax_cmd_ofld_info *ofld_info = &adapter->cmd_ofld_info;
+	struct mac_ax_state_mach *sm = &adapter->sm;
+	u32 ret = MACSUCCESS;
+
+	if (cmd->type != RTW_MAC_DELAY_OFLD &&
+	    ((cmd->src0 != RTW_MAC_RF_CMD_OFLD && cmd->src0 != RTW_MAC_RF_DDIE_CMD_OFLD &&
+	     cmd->offset0 & (4 - 1)) ||
+	     (cmd->src1 != RTW_MAC_RF_CMD_OFLD && cmd->src1 != RTW_MAC_RF_DDIE_CMD_OFLD &&
+	     cmd->offset1 & (4 - 1))))
+		return MACBADDR;
+	else if (cmd->type == RTW_MAC_MOVE_OFLD &&
+		 (cmd->mask0 >> shift_mask(cmd->mask0)) != (cmd->value >> shift_mask(cmd->value))) {
+		PLTFM_MSG_ERR("cmd->mask0: %x, cmd->value: %x\n", cmd->mask0, cmd->value);
+		return MACBADDR;
+	}
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	PLTFM_MUTEX_LOCK(&ofld_info->cmd_ofld_lock);
+	if (sm->cmd_state != MAC_AX_CMD_OFLD_IDLE) {
+		PLTFM_MSG_ERR("%s: IO offload is busy\n", __func__);
+		PLTFM_MUTEX_UNLOCK(&ofld_info->cmd_ofld_lock);
+		return MACPROCERR;
+	}
+	sm->cmd_state = MAC_AX_CMD_OFLD_PROC;
+	PLTFM_MUTEX_UNLOCK(&ofld_info->cmd_ofld_lock);
+
+	ret = ofld_incompatible_full_cmd(adapter, MAC_AX_CMD_OFLD_V1);
+	if (ret != MACSUCCESS)
+		goto END;
+
+	ret = add_cmd_v1(adapter, cmd);
+	if (ret)
+		goto END;
+
+	if (!cmd->lc)
+		goto END;
+
+	ret = cmd_ofld_v1(adapter);
+
+END:
+	PLTFM_MUTEX_LOCK(&ofld_info->cmd_ofld_lock);
+	sm->cmd_state = MAC_AX_CMD_OFLD_IDLE;
+	PLTFM_MUTEX_UNLOCK(&ofld_info->cmd_ofld_lock);
+
+	return ret;
+}
+
+u32 write_mac_reg_ofld(struct mac_ax_adapter *adapter,
+		       u16 offset, u32 mask, u32 val, u8 lc)
+{
+	struct rtw_mac_cmd cmd = {RTW_MAC_MAC_CMD_OFLD, RTW_MAC_WRITE_OFLD,
+		0, RTW_MAC_RF_PATH_A, 0, 0, 0, 0};
+
+	cmd.offset = offset;
+	cmd.mask = mask;
+	cmd.value = val;
+	cmd.lc = lc;
+
+	return mac_add_cmd_ofld(adapter, &cmd);
+}
+
+u32 poll_mac_reg_ofld(struct mac_ax_adapter *adapter,
+		      u16 offset, u32 mask, u32 val, u8 lc)
+{
+	struct rtw_mac_cmd cmd = {RTW_MAC_MAC_CMD_OFLD, RTW_MAC_COMPARE_OFLD,
+		0, RTW_MAC_RF_PATH_A, 0, 0, 0, 0};
+
+	cmd.offset = offset;
+	cmd.mask = mask;
+	cmd.value = val;
+	cmd.lc = lc;
+
+	return mac_add_cmd_ofld(adapter, &cmd);
+}
+
+u32 delay_ofld(struct mac_ax_adapter *adapter,
+	       u32 val, u8 lc)
+{
+	struct rtw_mac_cmd cmd = {RTW_MAC_MAC_CMD_OFLD, RTW_MAC_DELAY_OFLD,
+		0, RTW_MAC_RF_PATH_A, 0, 0, 0, 0};
+
+	cmd.value = val;
+	cmd.lc = lc;
+
+	return mac_add_cmd_ofld(adapter, &cmd);
+}
+
+u32 write_mac_reg_ofld_v1(struct mac_ax_adapter *adapter,
+			  u16 offset, u32 mask, u32 val, u8 lc)
+{
+	struct rtw_mac_cmd_v1 cmd = {
+		RTW_MAC_MAC_CMD_OFLD, /* src0 */
+		RTW_MAC_RF_PATH_A, /* rf_path0 */
+		RTW_MAC_MAC_CMD_OFLD, /* src1 */
+		RTW_MAC_RF_PATH_A, /* rf_path1 */
+		RTW_MAC_WRITE_OFLD, /* type */
+		0,
+		0, 0, 0, 0};
+
+	cmd.lc = lc;
+	cmd.offset0 = offset;
+	cmd.mask0 = mask;
+	cmd.value = val;
+
+	return mac_add_cmd_ofld_v1(adapter, &cmd);
+}
+
+u32 poll_mac_reg_ofld_v1(struct mac_ax_adapter *adapter,
+			 u16 offset, u32 mask, u32 val, u8 lc)
+{
+	struct rtw_mac_cmd_v1 cmd = {
+		RTW_MAC_MAC_CMD_OFLD, /* src0 */
+		RTW_MAC_RF_PATH_A, /* rf_path0 */
+		RTW_MAC_MAC_CMD_OFLD, /* src1 */
+		RTW_MAC_RF_PATH_A, /* rf_path1 */
+		RTW_MAC_COMPARE_OFLD, /* type */
+		0,
+		0, 0, 0, 0};
+
+	cmd.lc = lc;
+	cmd.offset0 = offset;
+	cmd.mask0 = mask;
+	cmd.value = val;
+
+	return mac_add_cmd_ofld_v1(adapter, &cmd);
+}
+
+u32 delay_ofld_v1(struct mac_ax_adapter *adapter,
+		  u32 val)
+{
+	struct rtw_mac_cmd_v1 cmd = {
+		RTW_MAC_MAC_CMD_OFLD, /* src0 */
+		RTW_MAC_RF_PATH_A, /* rf_path0 */
+		RTW_MAC_MAC_CMD_OFLD, /* src1 */
+		RTW_MAC_RF_PATH_A, /* rf_path1 */
+		RTW_MAC_DELAY_OFLD, /* type */
+		0, /*lc*/
+		0, 0, 0, 0};
+
+	cmd.value = val;
+
+	return mac_add_cmd_ofld_v1(adapter, &cmd);
+}
+
+u32 move_mac_reg_ofld(struct mac_ax_adapter *adapter,
+		      u16 offset0, u16 offset1, u32 mask0, u32 mask1, u8 lc)
+{
+	struct rtw_mac_cmd_v1 cmd = {
+		RTW_MAC_MAC_CMD_OFLD, /* src0 */
+		RTW_MAC_RF_PATH_A, /* rf_path0 */
+		RTW_MAC_MAC_CMD_OFLD, /* src1 */
+		RTW_MAC_RF_PATH_A, /* rf_path1 */
+		RTW_MAC_MOVE_OFLD, /* type */
+		0, /*lc*/
+		0, 0, 0, 0};
+
+	cmd.lc = lc;
+	cmd.offset0 = offset0;
+	cmd.offset1 = offset1;
+	cmd.mask0 = mask0;
+	cmd.value = mask1;
+
+	return mac_add_cmd_ofld_v1(adapter, &cmd);
+}
+
+u32 mac_ccxrpt_parsing(struct mac_ax_adapter *adapter, u8 *buf, struct mac_ax_ccxrpt *info)
+{
+	u32 val_d0;
+	u32 val_d3;
+	u32 dword0 = *((u32 *)buf);
+	u32 dword3 = *((u32 *)(buf + 12));
+
+	val_d0 = le32_to_cpu(dword0);
+	val_d3 = le32_to_cpu(dword3);
+	info->tx_state = GET_FIELD(val_d0, TXCCXRPT_TX_STATE);
+	info->sw_define = GET_FIELD(val_d0, TXCCXRPT_SW_DEFINE);
+	info->macid = GET_FIELD(val_d0, TXCCXRPT_MACID);
+	info->pkt_ok_num = GET_FIELD(val_d3, TXCCXRPT_PKT_OK_NUM);
+	info->data_txcnt = GET_FIELD(val_d3, TXCCXRPT_DATA_TX_CNT);
+
+	return MACSUCCESS;
+}
+
+static inline u8 scanofld_ch_list_len(struct scan_chinfo_list *list)
+{
+	return list->size;
+}
+
+static inline void scanofld_ch_list_init(struct scan_chinfo_list *list)
+{
+	list->head = NULL;
+	list->tail = NULL;
+	list->size = 0;
+}
+
+static inline u32 scanofld_ch_list_insert_head(struct mac_ax_adapter *adapter,
+					       struct scan_chinfo_list *list,
+					       struct mac_ax_scanofld_chinfo *chinfo)
+{
+	struct scanofld_chinfo_node *node;
+
+	node = (struct scanofld_chinfo_node *)PLTFM_MALLOC(sizeof(struct scanofld_chinfo_node));
+	if (!node)
+		return MACNOBUF;
+	node->next = list->head;
+	if (list->size == 0)
+		list->tail = node;
+	list->size++;
+	list->head = node;
+	node->chinfo = chinfo;
+	return MACSUCCESS;
+}
+
+static inline u32 scanofld_ch_list_insert_tail(struct mac_ax_adapter *adapter,
+					       struct scan_chinfo_list *list,
+					       struct mac_ax_scanofld_chinfo *chinfo)
+{
+	struct scanofld_chinfo_node *node;
+
+	node = (struct scanofld_chinfo_node *)PLTFM_MALLOC(sizeof(struct scanofld_chinfo_node));
+
+	if (!node)
+		return MACNOBUF;
+	if (list->size == 0)
+		list->head = node;
+	else
+		list->tail->next = node;
+
+	list->tail = node;
+	node->chinfo = chinfo;
+	node->next = NULL;
+	list->size++;
+	return MACSUCCESS;
+}
+
+static inline void scanofld_ch_node_print(struct mac_ax_adapter *adapter,
+					  struct scanofld_chinfo_node *curr_node, u8 i)
+{
+	struct mac_ax_scanofld_chinfo *chinfo = curr_node->chinfo;
+
+	PLTFM_MSG_TRACE("[scnofld][CH %d] - DWORD 0:%x\n", i, *((u32 *)(chinfo)));
+	PLTFM_MSG_TRACE("[scnofld][CH %d] -- period (%d) dwell (%d)\n", i,
+			chinfo->period, chinfo->dwell_time);
+	PLTFM_MSG_TRACE("[scnofld][CH %d] -- cent (%d) pri (%d)\n", i,
+			chinfo->central_ch, chinfo->pri_ch);
+	PLTFM_MSG_TRACE("[scnofld][CH %d] - DWORD 1:%x\n", i, *((u32 *)(chinfo) + 1));
+	PLTFM_MSG_TRACE("[scnofld][CH %d] -- bw (%d) notiDwell (%d)\n", i,
+			chinfo->bw, chinfo->c2h_notify_dwell);
+	PLTFM_MSG_TRACE("[scnofld][CH %d] -- noti preT (%d) postT (%d) enter (%d) leave (%d)\n",
+			i, chinfo->c2h_notify_preTX, chinfo->c2h_notify_postTX,
+			chinfo->c2h_notify_enterCH, chinfo->c2h_notify_leaveCH);
+	PLTFM_MSG_TRACE("[scnofld][CH %d] -- numAddtionPkt = %d\n", i, chinfo->num_addition_pkt);
+	PLTFM_MSG_TRACE("[scnofld][CH %d] -- tx (%d) pause (%d) band (%d) probeID (%d) dfs (%d)\n",
+			i, chinfo->tx_pkt, chinfo->pause_tx_data,
+			chinfo->ch_band, chinfo->probe_req_pkt_id, chinfo->dfs_ch);
+	PLTFM_MSG_TRACE("[scnofld][CH %d] -- null (%d) randSeq (%d) cfgPwr (%d) txProbe (%d)\n", i,
+			chinfo->tx_null, chinfo->rand_seq_num, chinfo->cfg_tx_pwr,
+			chinfo->tx_probe_req);
+	PLTFM_MSG_TRACE("[scnofld][CH %d] - DWORD 2:%x\n", i, *((u32 *)(chinfo) + 2));
+	PLTFM_MSG_TRACE("[scnofld][CH %d] -- (%d)(%d)(%d)(%d)\n", i,
+			chinfo->additional_pkt_id[0], chinfo->additional_pkt_id[1],
+			chinfo->additional_pkt_id[2], chinfo->additional_pkt_id[3]);
+	PLTFM_MSG_TRACE("[scnofld][CH %d] - DWORD 3:%x\n", i, *((u32 *)(chinfo) + 3));
+	PLTFM_MSG_TRACE("[scnofld][CH %d] -- (%d)(%d)(%d)(%d)\n", i,
+			chinfo->additional_pkt_id[4], chinfo->additional_pkt_id[5],
+			chinfo->additional_pkt_id[6], chinfo->additional_pkt_id[7]);
+	PLTFM_MSG_TRACE("[scnofld][CH %d] - DWORD 4:%x\n", i, *((u32 *)(chinfo) + 4));
+	PLTFM_MSG_TRACE("[scnofld][CH %d] -- pwrIdx (%d), chkpt (%d), additional_acking (%x)\n", i,
+			chinfo->tx_pwr_idx, chinfo->chkpt_timer, chinfo->additional_pkt_acking);
+	PLTFM_MSG_TRACE("[scnofld][CH %d] - DWORD 5:%x\n", i, *((u32 *)(chinfo) + 5));
+	PLTFM_MSG_TRACE("[scnofld][CH %d] -- prob template (%d) ssid(%x)\n", i,
+			chinfo->fw_probe0_tplt_id, chinfo->fw_probe0_ssids);
+}
+
+static inline void scanofld_ch_list_print(struct mac_ax_adapter *adapter,
+					  struct scan_chinfo_list *list, u8 verbose)
+{
+	struct scanofld_chinfo_node *curr_node = list->head;
+	u8 i = 0;
+
+	PLTFM_MSG_TRACE("[scnofld][CH List] len = %d\n", list->size);
+
+	if (!verbose)
+		return;
+
+	PLTFM_MSG_TRACE("[scnofld]------------------------------------------\n");
+	while (curr_node) {
+		scanofld_ch_node_print(adapter, curr_node, i);
+		PLTFM_MSG_TRACE("\n");
+		curr_node = curr_node->next;
+		i++;
+	}
+	PLTFM_MSG_TRACE("[scnofld]------------------------------------------\n");
+}
+
+void mac_scanofld_ch_list_clear(struct mac_ax_adapter *adapter,
+				struct scan_chinfo_list *list)
+{
+	struct scanofld_chinfo_node *curr_node = list->head;
+	struct scanofld_chinfo_node *tmp;
+
+	while (curr_node) {
+		tmp = curr_node;
+		curr_node = curr_node->next;
+		PLTFM_FREE(tmp->chinfo, sizeof(struct mac_ax_scanofld_chinfo));
+		PLTFM_FREE(tmp, sizeof(struct scanofld_chinfo_node));
+		list->size--;
+	}
+	list->head = NULL;
+	list->tail = NULL;
+	scanofld_ch_list_print(adapter, list, 0);
+}
+
+void mac_scanofld_reset_state(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_scanofld_info *scanofld_info;
+	u8 band_idx;
+
+	scanofld_info = &adapter->scanofld_info;
+
+	PLTFM_MUTEX_LOCK(&scanofld_info->drv_chlist_state_lock);
+	for (band_idx = 0; band_idx < MAC_AX_BAND_NUM; band_idx++)
+		scanofld_info->drv_chlist_busy[band_idx] = 0;
+	PLTFM_MUTEX_UNLOCK(&scanofld_info->drv_chlist_state_lock);
+
+	PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+	for (band_idx = 0; band_idx < MAC_AX_BAND_NUM; band_idx++)
+		scanofld_info->fw_chlist_busy[band_idx] = 0;
+	PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+
+	for (band_idx = 0; band_idx < MAC_AX_BAND_NUM; band_idx++)
+		scanofld_info->fw_scan_busy[band_idx] = 0;
+
+	PLTFM_MSG_TRACE("[scnofld] Reset all state to 0\n");
+}
+
+u32 mac_add_scanofld_ch(struct mac_ax_adapter *adapter, struct mac_ax_scanofld_chinfo *chinfo,
+			u8 send_h2c, u8 clear_after_send, u8 band)
+{
+	struct mac_ax_scanofld_info *scanofld_info;
+	struct scan_chinfo_list *list;
+	struct scanofld_chinfo_node *curr_node;
+	struct mac_ax_scanofld_chinfo *tmp;
+	u32 ret;
+	u8 list_size;
+	u8 *buf8;
+	u32 *buf32;
+	u32 *chinfo32;
+	u8 chinfo_dword;
+	struct fwcmd_add_scanofld_ch *pkt;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cbuf;
+	#else
+	struct h2c_buf *h2cbuf;
+	#endif
+
+	if (chinfo->period == 0 || chinfo->pri_ch == 0 || chinfo->central_ch == 0 ||
+	    chinfo->ch_band >= CHSW_CHBAND_MAX) {
+		PLTFM_MSG_ERR("[scnofld][add] period (%d) pri (%d) cent (%d) band (%d) bad val\n",
+			      chinfo->period, chinfo->pri_ch,
+			      chinfo->central_ch, chinfo->ch_band);
+		return MACFUNCINPUT;
+	}
+
+	scanofld_info = &adapter->scanofld_info;
+	PLTFM_MSG_TRACE("[scnofld][add][%d] ==> drv_chlist_busy=%d, fw_chlist_busy=%d\n", band,
+			scanofld_info->drv_chlist_busy[band], scanofld_info->fw_chlist_busy[band]);
+	PLTFM_MUTEX_LOCK(&scanofld_info->drv_chlist_state_lock);
+	if (scanofld_info->drv_chlist_busy[band]) {
+		PLTFM_MSG_TRACE("[scnofld][add][%d] Halmac scan list busy, abort adding.\n", band);
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->drv_chlist_state_lock);
+		return MACPROCBUSY;
+	}
+	scanofld_info->drv_chlist_busy[band] = 1;
+	PLTFM_MUTEX_UNLOCK(&scanofld_info->drv_chlist_state_lock);
+
+	ret = MACSUCCESS;
+	if (chinfo->dfs_ch && chinfo->period < MAC_AX_BCN_INTERVAL_DEFAULT) {
+		PLTFM_MSG_WARN("[scnofld][add][%d] Period (%d) might be too short for a DFS ch\n",
+			       band, chinfo->period);
+	}
+
+	if (!scanofld_info->list[band]) {
+		list = (struct scan_chinfo_list *)PLTFM_MALLOC(sizeof(struct scan_chinfo_list));
+		scanofld_info->list[band] = list;
+		scanofld_ch_list_init(adapter->scanofld_info.list[band]);
+	}
+	list = scanofld_info->list[band];
+
+	tmp = (struct mac_ax_scanofld_chinfo *)PLTFM_MALLOC(sizeof(struct mac_ax_scanofld_chinfo));
+	PLTFM_MEMCPY(tmp, chinfo, sizeof(struct mac_ax_scanofld_chinfo));
+	ret = scanofld_ch_list_insert_tail(adapter, list, tmp);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&scanofld_info->drv_chlist_state_lock);
+		scanofld_info->drv_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->drv_chlist_state_lock);
+		return ret;
+	}
+	scanofld_ch_list_print(adapter, list, send_h2c);
+
+	if (!send_h2c) {
+		PLTFM_MUTEX_LOCK(&scanofld_info->drv_chlist_state_lock);
+		scanofld_info->drv_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->drv_chlist_state_lock);
+		return ret;
+	}
+
+	PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+	if (scanofld_info->fw_chlist_busy[band]) {
+		PLTFM_MSG_TRACE("[scnofld][add][%d] FW scan list busy, abort sending.\n", band);
+		PLTFM_MUTEX_LOCK(&scanofld_info->drv_chlist_state_lock);
+		scanofld_info->drv_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->drv_chlist_state_lock);
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+		if (clear_after_send) {
+			PLTFM_MSG_TRACE("[scnofld][add] clear halmac ch list\n");
+			mac_scanofld_ch_list_clear(adapter, list);
+		}
+		return MACPROCBUSY;
+	}
+	adapter->scanofld_info.fw_chlist_busy[band] = 1;
+	PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+
+	list_size = scanofld_ch_list_len(list);
+	if (list_size == 0) {
+		PLTFM_MUTEX_LOCK(&scanofld_info->drv_chlist_state_lock);
+		scanofld_info->drv_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->drv_chlist_state_lock);
+		PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+		if (clear_after_send) {
+			PLTFM_MSG_TRACE("[scnofld][add] clear halmac ch list\n");
+			mac_scanofld_ch_list_clear(adapter, list);
+		}
+		return MACNOITEM;
+	}
+
+	h2cbuf = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cbuf) {
+		PLTFM_MUTEX_LOCK(&scanofld_info->drv_chlist_state_lock);
+		scanofld_info->drv_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->drv_chlist_state_lock);
+		PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+		if (clear_after_send) {
+			PLTFM_MSG_TRACE("[scnofld][add] clear halmac ch list\n");
+			mac_scanofld_ch_list_clear(adapter, list);
+		}
+		return MACNPTR;
+	}
+
+	buf8 = h2cb_put(h2cbuf,
+			sizeof(struct fwcmd_add_scanofld_ch) +
+			list_size * sizeof(struct mac_ax_scanofld_chinfo));
+	if (!buf8) {
+		PLTFM_MUTEX_LOCK(&scanofld_info->drv_chlist_state_lock);
+		scanofld_info->drv_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->drv_chlist_state_lock);
+		PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+		if (clear_after_send) {
+			PLTFM_MSG_TRACE("[scnofld][add] clear halmac ch list\n");
+			mac_scanofld_ch_list_clear(adapter, list);
+		}
+		return MACNOBUF;
+	}
+
+	pkt = (struct fwcmd_add_scanofld_ch *)buf8;
+	pkt->dword0 = cpu_to_le32(SET_WORD(list_size, FWCMD_H2C_ADD_SCANOFLD_CH_NUM_OF_CH) |
+				  SET_WORD(sizeof(struct mac_ax_scanofld_chinfo) / 4,
+					   FWCMD_H2C_ADD_SCANOFLD_CH_SIZE_OF_CHINFO) |
+				  (band ? FWCMD_H2C_ADD_SCANOFLD_CH_BAND : 0));
+	buf32 = (u32 *)(buf8 + sizeof(struct fwcmd_add_scanofld_ch));
+	curr_node = list->head;
+	while (curr_node) {
+		chinfo32 = (u32 *)(curr_node->chinfo);
+		for (chinfo_dword = 0;
+		     chinfo_dword < (sizeof(struct mac_ax_scanofld_chinfo) / 4);
+		     chinfo_dword++) {
+			*buf32 = cpu_to_le32(*chinfo32);
+			buf32++;
+			chinfo32++;
+		}
+		curr_node = curr_node->next;
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cbuf, FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_ADD_SCANOFLD_CH, 1, 1);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&scanofld_info->drv_chlist_state_lock);
+		scanofld_info->drv_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->drv_chlist_state_lock);
+		PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+		if (clear_after_send) {
+			PLTFM_MSG_TRACE("[scnofld][add] clear halmac ch list\n");
+			mac_scanofld_ch_list_clear(adapter, list);
+		}
+		return ret;
+	}
+	ret = h2c_pkt_build_txd(adapter, h2cbuf);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&scanofld_info->drv_chlist_state_lock);
+		scanofld_info->drv_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->drv_chlist_state_lock);
+		PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_chlist_busy[band] = 0;
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+		if (clear_after_send) {
+			PLTFM_MSG_TRACE("[scnofld][add] clear halmac ch list\n");
+			mac_scanofld_ch_list_clear(adapter, list);
+		}
+		return ret;
+	}
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cbuf);
+	#else
+	ret = PLTFM_TX(h2cbuf->data, h2cbuf->len);
+	#endif
+
+	if (clear_after_send) {
+		PLTFM_MSG_TRACE("[scnofld][add][%d] clear halmac ch list\n", band);
+		mac_scanofld_ch_list_clear(adapter, list);
+	}
+
+	PLTFM_MUTEX_LOCK(&scanofld_info->drv_chlist_state_lock);
+	scanofld_info->drv_chlist_busy[band] = 0;
+	PLTFM_MUTEX_UNLOCK(&scanofld_info->drv_chlist_state_lock);
+
+	h2cb_free(adapter, h2cbuf);
+	if (ret)
+		return ret;
+	h2c_end_flow(adapter);
+	PLTFM_MSG_TRACE("[scnofld][add][%d] <== drv_chlist_busy=%d, fw_chlist_busy=%d\n", band,
+			scanofld_info->drv_chlist_busy[band], scanofld_info->fw_chlist_busy[band]);
+	return ret;
+}
+
+u32 mac_scanofld(struct mac_ax_adapter *adapter, struct mac_ax_scanofld_param *scanParam)
+{
+	u8 *buf;
+	u8 *byte;
+	u32 ret;
+	u32 ssids_lv_size;
+	u32 short_ssids_size;
+	u32 bssids_size;
+	u32 total_h2c_size;
+	u8 i;
+	struct mac_ax_scanofld_info *scanofld_info;
+	struct fwcmd_scanofld *pkt;
+	enum h2c_buf_class h2cb_type;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cbuf;
+	#else
+	struct h2c_buf *h2cbuf;
+	#endif
+	u8 band;
+
+	band = (u8)scanParam->band;
+	ssids_lv_size = 0;
+	short_ssids_size = 0;
+	bssids_size = 0;
+	scanofld_info = &adapter->scanofld_info;
+	ret = MACSUCCESS;
+
+	if ((scanParam->target_ch_ch_band >= CHSW_CHBAND_MAX ||
+	     scanParam->target_central_ch == 0 ||
+	     scanParam->target_pri_ch == 0) && scanParam->target_ch_mode) {
+		PLTFM_MSG_ERR("[scnofld][cfg][%d] TGT cent (%d) pri (%d) band (%d) bad val\n", band,
+			      scanParam->target_central_ch, scanParam->target_pri_ch,
+			      scanParam->target_ch_ch_band);
+		return MACFUNCINPUT;
+	}
+
+	PLTFM_MSG_TRACE("[scnofld][cfg][%d] op=%d (%d), fw_scan_busy=%d, fw_chlist_busy=%d\n", band,
+			scanParam->operation, !!(scanParam->operation),
+			scanofld_info->fw_scan_busy[band], scanofld_info->fw_chlist_busy[band]);
+
+	PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+	scanofld_info->last_fw_chlist_busy[band] = scanofld_info->fw_chlist_busy[band];
+	PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+	scanofld_info->last_fw_scan_busy[band] = scanofld_info->fw_scan_busy[band];
+
+	if (scanParam->operation != MAC_AX_SCAN_OP_GETRPT) {
+		if (!!(scanParam->operation) && scanofld_info->fw_scan_busy[band]) {
+			PLTFM_MSG_TRACE("[scnofld][cfg][%d] Cant start scanning while scanning\n",
+					band);
+			return MACPROCBUSY;
+		}
+		PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+		if (!!(scanParam->operation) && scanofld_info->fw_chlist_busy[band]) {
+			PLTFM_MSG_TRACE("[scnofld][cfg][%d] Cant start scan when fw chlist busy\n",
+					band);
+			PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+			return MACPROCBUSY;
+		}
+
+		scanofld_info->fw_chlist_busy[band] = (u8)!!(scanParam->operation);
+		scanofld_info->fw_scan_busy[band] = (u8)!!(scanParam->operation);
+
+		PLTFM_MSG_TRACE("[scnofld][cfg][%d] fw_chlist_busy = %d, fw_scan_busy=%d\n", band,
+				scanofld_info->fw_chlist_busy[band],
+				scanofld_info->fw_scan_busy[band]);
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+	} else if (!scanofld_info->fw_scan_busy[band]) {
+		PLTFM_MSG_TRACE("[scnofld][cfg][%d] Cant get rpt when fw is not scanning\n", band);
+		return MACPROCERR;
+	}
+
+	PLTFM_MSG_TRACE("[scnofld][cfg][%d] macid (%d) port (%d) phy_band (%d)\n", band,
+			scanParam->macid, scanParam->port_id, scanParam->band);
+	PLTFM_MSG_TRACE("[scnofld][cfg][%d] op (%d) tgt_mode (%d) start_mode (%d) scan_type (%d)\n",
+			band, scanParam->operation, scanParam->target_ch_mode,
+			scanParam->start_mode, scanParam->scan_type);
+	if (scanParam->target_ch_mode) {
+		PLTFM_MSG_TRACE("[scnofld][cfg][tgt][%d] bw (%d) pri (%d) cent (%d) band (%d)\n",
+				band, scanParam->target_ch_bw, scanParam->target_pri_ch,
+				scanParam->target_central_ch, scanParam->target_ch_ch_band);
+		PLTFM_MSG_TRACE("[scnofld][cfg][tgt][%d] #pkts (%d) [%d, %d, %d, %d]\n", band,
+				scanParam->target_num_pkts,
+				scanParam->target_ch_pkt[0], scanParam->target_ch_pkt[1],
+				scanParam->target_ch_pkt[2], scanParam->target_ch_pkt[3]);
+	}
+	PLTFM_MSG_TRACE("[scnofld][cfg][%d] norm_pd (%d) norm_cy (%d) slow_pd (%d)\n", band,
+			scanParam->norm_pd, scanParam->norm_cy, scanParam->slow_pd);
+
+	for (i = 0; i < scanParam->numssid; i++)
+		ssids_lv_size += (1 + scanParam->ssid[i].len);
+
+	short_ssids_size = scanParam->numshortssid * SCANOFLD_SHORTSSID_LEN;
+	bssids_size = scanParam->numbssid * SCANOFLD_BSSID_LEN;
+
+	total_h2c_size = sizeof(struct fwcmd_scanofld) + ssids_lv_size;
+	total_h2c_size += (short_ssids_size + bssids_size);
+	if (total_h2c_size <= (H2C_CMD_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_CMD;
+		PLTFM_MSG_TRACE("[scnofld] size %d, using CMD Q\n", total_h2c_size);
+	} else if (total_h2c_size <= (H2C_DATA_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_DATA;
+		PLTFM_MSG_TRACE("[scnofld] size %d, using DATA Q\n", total_h2c_size);
+	} else if (total_h2c_size <= (H2C_LONG_DATA_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_LONG_DATA;
+		PLTFM_MSG_TRACE("[scnofld] size %d, using LDATA Q\n", total_h2c_size);
+	} else {
+		PLTFM_MSG_ERR("[scnofld] size %d, exceed LDATA Q size, abort\n", total_h2c_size);
+		return MACBUFSZ;
+	}
+
+	h2cbuf = h2cb_alloc(adapter, h2cb_type);
+	if (!h2cbuf) {
+		PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_chlist_busy[band] = scanofld_info->last_fw_chlist_busy[band];
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_scan_busy[band] = scanofld_info->last_fw_scan_busy[band];
+
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cbuf, total_h2c_size);
+	if (!buf) {
+		PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_chlist_busy[band] = scanofld_info->last_fw_chlist_busy[band];
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_scan_busy[band] = scanofld_info->last_fw_scan_busy[band];
+
+		h2cb_free(adapter, h2cbuf);
+		return MACNOBUF;
+	}
+
+	pkt = (struct fwcmd_scanofld *)buf;
+	pkt->dword0 = cpu_to_le32(SET_WORD(scanParam->macid, FWCMD_H2C_SCANOFLD_MACID) |
+				  SET_WORD(scanParam->norm_cy, FWCMD_H2C_SCANOFLD_NORM_CY) |
+				  SET_WORD(scanParam->port_id, FWCMD_H2C_SCANOFLD_PORT_ID) |
+				  (scanParam->band ? FWCMD_H2C_SCANOFLD_BAND : 0) |
+				  SET_WORD(scanParam->operation, FWCMD_H2C_SCANOFLD_OPERATION) |
+				  SET_WORD(scanParam->target_ch_ch_band,
+					   FWCMD_H2C_SCANOFLD_TARGET_CH_CH_BAND));
+	pkt->dword1 = cpu_to_le32((scanParam->c2h_end ? FWCMD_H2C_SCANOFLD_C2H_NOTIFY_END : 0) |
+				  (scanParam->target_ch_mode ?
+				   FWCMD_H2C_SCANOFLD_TARGET_CH_MODE : 0) |
+				  (scanParam->start_mode ?
+				   FWCMD_H2C_SCANOFLD_START_MODE : 0) |
+				  SET_WORD(scanParam->scan_type, FWCMD_H2C_SCANOFLD_SCAN_TYPE) |
+				  SET_WORD(scanParam->target_ch_bw,
+					   FWCMD_H2C_SCANOFLD_TARGET_CH_BW) |
+				  SET_WORD(scanParam->target_pri_ch,
+					   FWCMD_H2C_SCANOFLD_TARGET_PRI_CH) |
+				  SET_WORD(scanParam->target_central_ch,
+					   FWCMD_H2C_SCANOFLD_TARGET_CENTRAL_CH) |
+				  SET_WORD(scanParam->target_num_pkts,
+					   FWCMD_H2C_SCANOFLD_TARGET_NUM_PKTS));
+	pkt->dword2 = cpu_to_le32(SET_WORD(scanParam->norm_pd, FWCMD_H2C_SCANOFLD_NORM_PD) |
+				  SET_WORD(scanParam->slow_pd, FWCMD_H2C_SCANOFLD_SLOW_PD));
+	pkt->dword3 = cpu_to_le32(scanParam->tsf_high);
+	pkt->dword4 = cpu_to_le32(scanParam->tsf_low);
+	pkt->dword5 = cpu_to_le32(SET_WORD(scanParam->target_ch_pkt[0],
+					   FWCMD_H2C_SCANOFLD_TARGET_CH_PKT0) |
+				  SET_WORD(scanParam->target_ch_pkt[1],
+					   FWCMD_H2C_SCANOFLD_TARGET_CH_PKT1) |
+				  SET_WORD(scanParam->target_ch_pkt[2],
+					   FWCMD_H2C_SCANOFLD_TARGET_CH_PKT2) |
+				  SET_WORD(scanParam->target_ch_pkt[3],
+					   FWCMD_H2C_SCANOFLD_TARGET_CH_PKT3));
+	pkt->dword6 = cpu_to_le32(SET_WORD(scanParam->numssid, FWCMD_H2C_SCANOFLD_NUMSSID) |
+				  SET_WORD(scanParam->numshortssid,
+					   FWCMD_H2C_SCANOFLD_NUMSHORTSSID) |
+				  SET_WORD(scanParam->numbssid, FWCMD_H2C_SCANOFLD_NUMBSSID));
+
+	byte = buf + sizeof(struct fwcmd_scanofld);
+	for (i = 0; i < scanParam->numssid; i++) {
+		*(byte++) = (u8)scanParam->ssid[i].len;
+		PLTFM_MEMCPY(byte, scanParam->ssid[i].content, scanParam->ssid[i].len);
+		byte += scanParam->ssid[i].len;
+	}
+	for (i = 0; i < scanParam->numshortssid; i++) {
+		PLTFM_MEMCPY(byte, scanParam->short_ssid[i], SCANOFLD_SHORTSSID_LEN);
+		byte += SCANOFLD_SHORTSSID_LEN;
+	}
+	for (i = 0; i < scanParam->numbssid; i++) {
+		PLTFM_MEMCPY(byte, scanParam->bssid[i], SCANOFLD_BSSID_LEN);
+		byte += SCANOFLD_BSSID_LEN;
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cbuf, FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_SCANOFLD, 1,
+			      scanParam->operation != MAC_AX_SCAN_OP_GETRPT);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_chlist_busy[band] = scanofld_info->last_fw_chlist_busy[band];
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_scan_busy[band] = scanofld_info->last_fw_scan_busy[band];
+
+		h2cb_free(adapter, h2cbuf);
+		return ret;
+	}
+	ret = h2c_pkt_build_txd(adapter, h2cbuf);
+	if (ret) {
+		PLTFM_MUTEX_LOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_chlist_busy[band] = scanofld_info->last_fw_chlist_busy[band];
+		PLTFM_MUTEX_UNLOCK(&scanofld_info->fw_chlist_state_lock);
+		scanofld_info->fw_scan_busy[band] = scanofld_info->last_fw_scan_busy[band];
+
+		h2cb_free(adapter, h2cbuf);
+		return ret;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cbuf);
+	#else
+	ret = PLTFM_TX(h2cbuf->data, h2cbuf->len);
+	#endif
+	h2cb_free(adapter, h2cbuf);
+	if (ret)
+		return ret;
+	h2c_end_flow(adapter);
+	return ret;
+}
+
+u32 mac_scanofld_fw_busy(struct mac_ax_adapter *adapter, u8 band)
+{
+	if (adapter->scanofld_info.fw_scan_busy[band])
+		return MACPROCBUSY;
+	else
+		return MACSUCCESS;
+}
+
+u32 mac_scanofld_chlist_busy(struct mac_ax_adapter *adapter, u8 band)
+{
+	if (adapter->scanofld_info.drv_chlist_busy[band] ||
+	    adapter->scanofld_info.fw_chlist_busy[band])
+		return MACPROCBUSY;
+	else
+		return MACSUCCESS;
+}
+
+u32 mac_scanofld_hst_ctrl(struct mac_ax_adapter *adapter, u8 pri_ch, u8 ch_band,
+			  enum mac_ax_scanofld_ctrl op, u8 band)
+{
+	u8 *buf;
+	u32 ret;
+	struct fwcmd_scanofld_drv_ctrl *pkt;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cbuf;
+	#else
+	struct h2c_buf *h2cbuf;
+	#endif
+
+	ret = MACSUCCESS;
+
+	h2cbuf = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cbuf)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cbuf, sizeof(struct fwcmd_scanofld_drv_ctrl));
+	if (!buf) {
+		h2cb_free(adapter, h2cbuf);
+		return MACNOBUF;
+	}
+
+	pkt = (struct fwcmd_scanofld_drv_ctrl *)buf;
+	pkt->dword0 = cpu_to_le32(SET_WORD(pri_ch, FWCMD_H2C_SCANOFLD_DRV_CTRL_PRI_CH) |
+				  SET_WORD(ch_band, FWCMD_H2C_SCANOFLD_DRV_CTRL_CH_BAND) |
+				  SET_WORD(op, FWCMD_H2C_SCANOFLD_DRV_CTRL_CMD) |
+				  (band ? FWCMD_H2C_SCANOFLD_DRV_CTRL_BAND : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cbuf, FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_SCANOFLD_DRV_CTRL, 0, 0);
+	if (ret) {
+		h2cb_free(adapter, h2cbuf);
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cbuf);
+	if (ret) {
+		h2cb_free(adapter, h2cbuf);
+		return ret;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cbuf);
+	#else
+	ret = PLTFM_TX(h2cbuf->data, h2cbuf->len);
+	#endif
+	h2cb_free(adapter, h2cbuf);
+	if (ret)
+		return ret;
+	h2c_end_flow(adapter);
+	return ret;
+}
+
+u32 get_ccxrpt_event(struct mac_ax_adapter *adapter,
+		     struct rtw_c2h_info *c2h,
+		     enum phl_msg_evt_id *id, u8 *c2h_info)
+{
+	struct mac_ax_ccxrpt *info;
+	u32 val_d0, val_d3;
+	u32 dword0 = *((u32 *)c2h->content);
+	u32 dword3 = *((u32 *)(c2h->content + 12));
+
+	info = (struct mac_ax_ccxrpt *)c2h_info;
+	val_d0 = le32_to_cpu(dword0);
+	val_d3 = le32_to_cpu(dword3);
+	info->tx_state = GET_FIELD(val_d0, TXCCXRPT_TX_STATE);
+	info->sw_define = GET_FIELD(val_d0, TXCCXRPT_SW_DEFINE);
+	info->macid = GET_FIELD(val_d0, TXCCXRPT_MACID);
+	info->pkt_ok_num = GET_FIELD(val_d3, TXCCXRPT_PKT_OK_NUM);
+	info->data_txcnt = GET_FIELD(val_d3, TXCCXRPT_DATA_TX_CNT);
+
+	if (info->tx_state)
+		*id = MSG_EVT_CCX_REPORT_TX_FAIL;
+	else
+		*id = MSG_EVT_CCX_REPORT_TX_OK;
+
+	return MACSUCCESS;
+}
+
+u32 pktofld_self_test(struct mac_ax_adapter *adapter)
+{
+	u32 poll_cnt, ret;
+	u16 pkt_len, i;
+	u8 pkt_id, state;
+	u8 *pkt;
+
+	pkt_len = 16;
+	pkt = (u8 *)PLTFM_MALLOC(pkt_len);
+	for (i = 0; i < pkt_len; i++)
+		pkt[i] = 15 - i;
+
+	ret = mac_add_pkt_ofld(adapter, pkt, pkt_len, &pkt_id);
+	if (ret != 0) {
+		PLTFM_FREE(pkt, pkt_len);
+		pkt = NULL;
+		PLTFM_MSG_ERR("Packet ofld self test fail at ADD\n");
+		return ret;
+	}
+	PLTFM_FREE(pkt, pkt_len);
+	pkt = NULL;
+
+	for (poll_cnt = 1000; poll_cnt > 0; poll_cnt--) {
+		state = adapter->sm.pkt_ofld;
+		if (state == MAC_AX_OFLD_H2C_IDLE)
+			break;
+		PLTFM_DELAY_MS(1);
+	}
+	if (poll_cnt == 0) {
+		PLTFM_MSG_ERR("Packet ofld self test timeout at ADD\n");
+		return MACPOLLTO;
+	}
+
+	ret = mac_read_pkt_ofld(adapter, pkt_id);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("Packet ofld self test fail at READ\n");
+		return ret;
+	}
+
+	for (poll_cnt = 1000; poll_cnt > 0; poll_cnt--) {
+		state = adapter->sm.pkt_ofld;
+		if (state == MAC_AX_OFLD_H2C_DONE)
+			break;
+		PLTFM_DELAY_MS(1);
+	}
+	if (poll_cnt == 0) {
+		PLTFM_MSG_ERR("Packet ofld self test timout at READ\n");
+		return MACPOLLTO;
+	}
+
+	ret = mac_pkt_ofld_packet(adapter, &pkt, &pkt_len, &pkt_id);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("Packet ofld self test fail at READOUT\n");
+		return ret;
+	}
+	for (i = 0; i < pkt_len; i++) {
+		if (pkt[i] != (15 - i)) {
+			PLTFM_FREE(pkt, pkt_len);
+			pkt = NULL;
+			PLTFM_MSG_ERR("Packet ofld self test fail at READOUT (Byte %d)\n", i);
+			return MACCMP;
+		}
+	}
+	PLTFM_FREE(pkt, pkt_len);
+	pkt = NULL;
+
+	ret = mac_del_pkt_ofld(adapter, pkt_id);
+	if (ret != 0) {
+		PLTFM_MSG_ERR("Packet ofld self test fail at DEL\n");
+		return ret;
+	}
+	for (poll_cnt = 1000; poll_cnt > 0; poll_cnt--) {
+		state = adapter->sm.pkt_ofld;
+		if (state == MAC_AX_OFLD_H2C_IDLE)
+			break;
+		PLTFM_DELAY_MS(1);
+	}
+	if (poll_cnt == 0) {
+		PLTFM_MSG_ERR("Packet ofld self test timout at DEL\n");
+		return MACPOLLTO;
+	}
+	PLTFM_MSG_TRACE("Packet ofld self test pass\n");
+
+	return MACSUCCESS;
+}
+
+u32 mac_ch_switch_ofld(struct mac_ax_adapter *adapter, struct mac_ax_ch_switch_parm parm)
+{
+	u32 ret;
+	u8 *buf;
+	struct fwcmd_ch_switch *pkt;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cbuf;
+	#else
+	struct h2c_buf *h2cbuf;
+	#endif
+	if (adapter->sm.ch_switch != MAC_AX_OFLD_H2C_IDLE &&
+	    adapter->sm.ch_switch != MAC_AX_CH_SWITCH_GET_RPT)
+		return MACPROCBUSY;
+	adapter->sm.ch_switch = MAC_AX_OFLD_H2C_SENDING;
+	h2cbuf = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cbuf) {
+		adapter->sm.ch_switch = MAC_AX_OFLD_H2C_IDLE;
+		return MACNOBUF;
+	}
+	buf = h2cb_put(h2cbuf, sizeof(struct fwcmd_ch_switch));
+	if (!buf) {
+		adapter->sm.ch_switch = MAC_AX_OFLD_H2C_IDLE;
+		return MACNOBUF;
+	}
+	pkt = (struct fwcmd_ch_switch *)buf;
+	pkt->dword0 = cpu_to_le32(SET_WORD(parm.pri_ch, FWCMD_H2C_CH_SWITCH_PRI_CH) |
+				  SET_WORD(parm.central_ch, FWCMD_H2C_CH_SWITCH_CENTRAL_CH) |
+				  SET_WORD(parm.bw, FWCMD_H2C_CH_SWITCH_BW) |
+				  SET_WORD(parm.ch_band, FWCMD_H2C_CH_SWITCH_CH_BAND) |
+				  (parm.band ? FWCMD_H2C_CH_SWITCH_BAND : 0) |
+				  (parm.reload_rf ? FWCMD_H2C_CH_SWITCH_RELOAD_RF : 0));
+	ret = h2c_pkt_set_hdr(adapter, h2cbuf, FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_CH_SWITCH, 1, 0);
+	if (ret) {
+		adapter->sm.ch_switch = MAC_AX_OFLD_H2C_IDLE;
+		return ret;
+	}
+	ret = h2c_pkt_build_txd(adapter, h2cbuf);
+	if (ret) {
+		adapter->sm.ch_switch = MAC_AX_OFLD_H2C_IDLE;
+		return ret;
+	}
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cbuf);
+	#else
+	ret = PLTFM_TX(h2cbuf->data, h2cbuf->len);
+	#endif
+	h2cb_free(adapter, h2cbuf);
+	if (ret) {
+		adapter->sm.ch_switch = MAC_AX_OFLD_H2C_IDLE;
+		return ret;
+	}
+	h2c_end_flow(adapter);
+	return ret;
+}
+
+u32 mac_get_ch_switch_rpt(struct mac_ax_adapter *adapter, struct mac_ax_ch_switch_rpt *rpt)
+{
+	struct mac_ax_state_mach *sm = &adapter->sm;
+
+	if (sm->ch_switch != MAC_AX_CH_SWITCH_GET_RPT)
+		return MACPROCERR;
+	PLTFM_MEMCPY(rpt, &adapter->ch_switch_rpt, sizeof(struct mac_ax_ch_switch_rpt));
+	sm->ch_switch = MAC_AX_OFLD_H2C_IDLE;
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_bcn_filter(struct mac_ax_adapter *adapter, struct mac_ax_bcn_fltr cfg)
+{
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buffer;
+	struct fwcmd_cfg_bcnfltr *write_ptr;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buffer = h2cb_put(h2cb, sizeof(struct fwcmd_cfg_bcnfltr));
+	if (!buffer) {
+		h2cb_free(adapter, h2cb);
+		return MACNOBUF;
+	}
+
+	write_ptr = (struct fwcmd_cfg_bcnfltr *)buffer;
+	write_ptr->dword0 = cpu_to_le32((cfg.mon_rssi ? FWCMD_H2C_CFG_BCNFLTR_MON_RSSI : 0) |
+					(cfg.mon_bcn ? FWCMD_H2C_CFG_BCNFLTR_MON_BCN : 0) |
+					(cfg.mon_tp ? FWCMD_H2C_CFG_BCNFLTR_MON_TP : 0) |
+					SET_WORD(cfg.tp_thld, FWCMD_H2C_CFG_BCNFLTR_TP_THLD) |
+					SET_WORD(cfg.bcn_loss_cnt,
+						 FWCMD_H2C_CFG_BCNFLTR_BCN_LOSS_CNT) |
+					SET_WORD(cfg.rssi_hys, FWCMD_H2C_CFG_BCNFLTR_RSSI_HYS) |
+					SET_WORD(cfg.rssi_thld, FWCMD_H2C_CFG_BCNFLTR_RSSI_THLD) |
+					SET_WORD(cfg.macid, FWCMD_H2C_CFG_BCNFLTR_MACID));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb, FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_CFG_BCNFLTR,
+			      0, 0);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	h2cb_free(adapter, h2cb);
+	return MACSUCCESS;
+}
+
+u32 mac_bcn_filter_rssi(struct mac_ax_adapter *adapter, u8 macid, u8 size, u8 *rssi)
+{
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buffer;
+	u32 *buffer_32;
+	u32 *rssi_32;
+	struct fwcmd_ofld_rssi *write_ptr;
+	u8 append_size;
+	u8 sh;
+
+	if (size == 0)
+		return MACSETVALERR;
+
+	append_size = (size + 3) & (~0x3);
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buffer = h2cb_put(h2cb, sizeof(struct fwcmd_ofld_rssi) + append_size);
+	if (!buffer) {
+		h2cb_free(adapter, h2cb);
+		return MACNOBUF;
+	}
+
+	write_ptr = (struct fwcmd_ofld_rssi *)buffer;
+	write_ptr->dword0 = cpu_to_le32(SET_WORD(macid, FWCMD_H2C_OFLD_RSSI_MACID) |
+					SET_WORD(size, FWCMD_H2C_OFLD_RSSI_NUM_RSSI));
+
+	rssi_32 = (u32 *)rssi;
+	buffer_32 = ((u32 *)buffer) + 1;
+	for (sh = 0; sh < (append_size >> 2) ; sh++)
+		*(buffer_32 + sh) = cpu_to_le32(*(rssi_32 + sh));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb, FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_OFLD_RSSI,
+			      0, 0);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	h2cb_free(adapter, h2cb);
+	return MACSUCCESS;
+}
+
+u32 mac_bcn_filter_tp(struct mac_ax_adapter *adapter, u8 macid, u16 tx, u16 rx)
+{
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buffer;
+	struct fwcmd_ofld_tp *write_ptr;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buffer = h2cb_put(h2cb, sizeof(struct fwcmd_ofld_tp));
+	if (!buffer) {
+		h2cb_free(adapter, h2cb);
+		return MACNOBUF;
+	}
+
+	write_ptr = (struct fwcmd_ofld_tp *)buffer;
+	write_ptr->dword0 = cpu_to_le32(SET_WORD(tx, FWCMD_H2C_OFLD_TP_TXTP) |
+					SET_WORD(rx, FWCMD_H2C_OFLD_TP_RXTP) |
+					SET_WORD(macid, FWCMD_H2C_OFLD_TP_MACID));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb, FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_OFLD_TP,
+			      0, 0);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	h2cb_free(adapter, h2cb);
+	return MACSUCCESS;
+}
+
+u32 mac_host_efuse_rec(struct mac_ax_adapter *adapter, u32 host_id, u32 efuse_val)
+{
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_host_efuse_rec *hdr;
+	u32 ret = MACSUCCESS;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_host_efuse_rec *)h2cb_put(h2cb,
+		sizeof(struct fwcmd_host_efuse_rec));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(host_id, FWCMD_H2C_HOST_EFUSE_REC_HOST_ID));
+	hdr->dword1 =
+		cpu_to_le32(SET_WORD(efuse_val, FWCMD_H2C_HOST_EFUSE_REC_EFUSE_VAL));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_HOST_EFUSE_REC,
+			      0,
+			      0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_cfg_sensing_csi(struct mac_ax_adapter *adapter, struct rtw_hal_mac_sensing_csi_param *para)
+{
+	struct sensing_csi_info *csi_info = &adapter->csi_info;
+	struct mac_ax_state_mach *sm = &adapter->sm;
+	u8 *buf;
+	u32 ret;
+	u32 *pkt_id_dword;
+	u8 id_size = 0;
+	u8 *id_array = NULL;
+	u32 i;
+	struct fwcmd_wifi_sensing_csi *pkt;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cbuf;
+#else
+	struct h2c_buf *h2cbuf;
+#endif
+
+	PLTFM_MSG_TRACE("[csi] macid=%d, en=%d, period=%d\n",
+			para->macid, para->en, para->period);
+	PLTFM_MSG_TRACE("[csi] retry_cnt=%d, rate=%d, pkt_num=%d\n",
+			para->retry_cnt, para->rate, para->pkt_num);
+	for (i = 0; i < para->pkt_num; i++)
+		PLTFM_MSG_TRACE("[csi] pkt_id[%d]=%d\n", i, para->pkt_id[i]);
+
+	PLTFM_MUTEX_LOCK(&csi_info->state_lock);
+	if (sm->sensing_csi_st != MAC_AX_SENSING_CSI_IDLE) {
+		PLTFM_MSG_ERR("[WARN][csi][Cfg] H2C is sent before!\n");
+		PLTFM_MUTEX_UNLOCK(&csi_info->state_lock);
+	}
+	sm->sensing_csi_st = MAC_AX_SENSING_CSI_SENDING;
+	PLTFM_MUTEX_UNLOCK(&csi_info->state_lock);
+
+	if (csi_info->start_cmd_send || csi_info->stop_cmd_send)
+		PLTFM_MSG_ERR("[ERR][csi][Cfg] state machine error!\n");
+
+	if (para->pkt_num) {
+		id_size = (para->pkt_num & (~0x3)) + 4;
+
+		id_array = (u8 *)PLTFM_MALLOC(id_size);
+		if (!id_array) {
+			PLTFM_MSG_ERR("[ERR][csi] id_array malloc fail!\n");
+			PLTFM_MUTEX_LOCK(&csi_info->state_lock);
+			sm->sensing_csi_st = MAC_AX_SENSING_CSI_IDLE;
+			PLTFM_MUTEX_UNLOCK(&csi_info->state_lock);
+			return MACNPTR;
+		}
+		PLTFM_MEMSET(id_array, 0, id_size);
+		PLTFM_MEMCPY(id_array, para->pkt_id, id_size);
+	}
+
+	h2cbuf = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cbuf) {
+		PLTFM_MSG_ERR("[ERR][csi] h2cbuf malloc fail!\n");
+		PLTFM_FREE(id_array, id_size);
+		PLTFM_MUTEX_LOCK(&csi_info->state_lock);
+		sm->sensing_csi_st = MAC_AX_SENSING_CSI_IDLE;
+		PLTFM_MUTEX_UNLOCK(&csi_info->state_lock);
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cbuf, sizeof(struct fwcmd_wifi_sensing_csi) + id_size);
+	if (!buf) {
+		h2cb_free(adapter, h2cbuf);
+		PLTFM_FREE(id_array, id_size);
+		PLTFM_MUTEX_LOCK(&csi_info->state_lock);
+		sm->sensing_csi_st = MAC_AX_SENSING_CSI_IDLE;
+		PLTFM_MUTEX_UNLOCK(&csi_info->state_lock);
+		return MACNOBUF;
+	}
+
+	pkt = (struct fwcmd_wifi_sensing_csi *)buf;
+	pkt->dword0 = cpu_to_le32(SET_WORD(para->macid, FWCMD_H2C_WIFI_SENSING_CSI_MACID) |
+				  (para->en ? FWCMD_H2C_WIFI_SENSING_CSI_EN : 0) |
+				  SET_WORD(para->period, FWCMD_H2C_WIFI_SENSING_CSI_PERIOD));
+	pkt->dword1 = cpu_to_le32(SET_WORD(para->retry_cnt, FWCMD_H2C_WIFI_SENSING_CSI_RETRY_CNT) |
+				  SET_WORD(para->rate, FWCMD_H2C_WIFI_SENSING_CSI_RATE) |
+				  SET_WORD(para->pkt_num, FWCMD_H2C_WIFI_SENSING_CSI_PKT_NUM));
+
+	pkt_id_dword = (u32 *)(buf + sizeof(struct fwcmd_wifi_sensing_csi));
+	for (i = 0; i < id_size; i += 4) {
+		*pkt_id_dword = cpu_to_le32(*(u32 *)(id_array + i));
+		pkt_id_dword++;
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cbuf,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_WIFI_SENSING_CSI,
+			      0,
+			      1);
+	if (ret) {
+		h2cb_free(adapter, h2cbuf);
+		PLTFM_FREE(id_array, id_size);
+		PLTFM_MUTEX_LOCK(&csi_info->state_lock);
+		sm->sensing_csi_st = MAC_AX_SENSING_CSI_IDLE;
+		PLTFM_MUTEX_UNLOCK(&csi_info->state_lock);
+		return ret;
+	}
+	ret = h2c_pkt_build_txd(adapter, h2cbuf);
+	if (ret) {
+		h2cb_free(adapter, h2cbuf);
+		PLTFM_FREE(id_array, id_size);
+		PLTFM_MUTEX_LOCK(&csi_info->state_lock);
+		sm->sensing_csi_st = MAC_AX_SENSING_CSI_IDLE;
+		PLTFM_MUTEX_UNLOCK(&csi_info->state_lock);
+		return ret;
+	}
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cbuf);
+#else
+	ret = PLTFM_TX(h2cbuf->data, h2cbuf->len);
+#endif
+	h2cb_free(adapter, h2cbuf);
+	PLTFM_FREE(id_array, id_size);
+	if (ret)
+		return ret;
+	h2c_end_flow(adapter);
+
+	if (para->en)
+		csi_info->start_cmd_send = 1;
+	else
+		csi_info->stop_cmd_send = 1;
+
+	return ret;
+}
+
+u32 mac_chk_sensing_csi_done(struct mac_ax_adapter *adapter, u8 chk_state)
+{
+	struct sensing_csi_info *csi_info = &adapter->csi_info;
+	struct mac_ax_state_mach *sm = &adapter->sm;
+
+	PLTFM_MUTEX_LOCK(&csi_info->state_lock);
+	if (sm->sensing_csi_st != MAC_AX_SENSING_CSI_IDLE) {
+		PLTFM_MUTEX_UNLOCK(&csi_info->state_lock);
+		return MACPROCBUSY;
+	}
+	PLTFM_MUTEX_UNLOCK(&csi_info->state_lock);
+
+	if (chk_state != csi_info->func_en)
+		return MACCMP;
+	else
+		return MACSUCCESS;
+}
+
+u32 get_sensing_csi_event(struct mac_ax_adapter *adapter,
+			  struct rtw_c2h_info *c2h,
+			  enum phl_msg_evt_id *id, u8 *c2h_info)
+{
+	struct rtw_hal_mac_sensing_csi_tx_result *info;
+	u32 val_d0;
+	u32 dword0 = *((u32 *)c2h->content);
+	u32 val_tmp;
+	u8 i;
+
+	info = (struct rtw_hal_mac_sensing_csi_tx_result *)c2h_info;
+	val_d0 = le32_to_cpu(dword0);
+	info->macid = GET_FIELD(val_d0, FWCMD_C2H_WIFI_SENSING_CSI_TX_RESULT_MACID);
+	info->num = GET_FIELD(val_d0, FWCMD_C2H_WIFI_SENSING_CSI_TX_RESULT_NUM);
+	info->seq_num = GET_FIELD(val_d0, FWCMD_C2H_WIFI_SENSING_CSI_TX_RESULT_SEQ_NUM);
+
+	if (info->num > RTW_PHL_SOFTAP_MAX_CLIENT_NUM)
+		return MACBUFSZ;
+
+	for (i = 0; i < info->num; i++) {
+		val_tmp = le32_to_cpu(*((u32 *)(c2h->content + 4 + i)));
+		PLTFM_MEMCPY(&info->tx_rpt[i], &val_tmp, 4);
+	}
+
+	*id = MSG_EVT_CSI_TX_RESULT;
+
+	return MACSUCCESS;
+}
+
+u32 mac_fwcpumgenq_test(struct mac_ax_adapter *adapter, u8 macid, u16 len, u8 *pkt)
+{
+	u8 *buf;
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_cpumgenq_test *write_ptr;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_cpumgenq_test));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto end;
+	}
+
+	write_ptr = (struct fwcmd_cpumgenq_test *)buf;
+	write_ptr->dword0 =
+	cpu_to_le32(SET_WORD(len, FWCMD_H2C_CPUMGENQ_TEST_PKTLEN) |
+		    SET_WORD(macid, FWCMD_H2C_CPUMGENQ_TEST_MACID));
+	buf = h2cb_put(h2cb, len);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto end;
+	}
+
+	PLTFM_MEMCPY(buf, pkt, len);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_TEST,
+			      FWCMD_H2C_CL_FW_AUTO_TEST, FWCMD_H2C_FUNC_CPUMGENQ_TEST,
+			      0, 0);
+	if (ret)
+		goto end;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto end;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %d\n", ret);
+		goto end;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	ret = MACSUCCESS;
+end:
+	h2cb_free(adapter, h2cb);
+	return ret;
+}
+
+u32 mac_cfg_bcn_early_rpt(struct mac_ax_adapter *adapter, u8 band, u8 port, u8 en)
+{
+	u32 ret;
+	u8 *buf;
+	struct fwcmd_bcnerlyrpt *pkt;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cbuf;
+	#else
+	struct h2c_buf *h2cbuf;
+	#endif
+	h2cbuf = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cbuf)
+		return MACNOBUF;
+	buf = h2cb_put(h2cbuf, sizeof(struct fwcmd_bcnerlyrpt));
+	if (!buf)
+		return MACNOBUF;
+	pkt = (struct fwcmd_bcnerlyrpt *)buf;
+	pkt->dword0 = cpu_to_le32(SET_WORD(port, FWCMD_H2C_BCNERLYRPT_PORT) |
+				  (band ? FWCMD_H2C_BCNERLYRPT_BAND : 0) |
+				  (en ? FWCMD_H2C_BCNERLYRPT_CONTROL : 0));
+	ret = h2c_pkt_set_hdr(adapter, h2cbuf, FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_BCNERLYRPT, 0, 0);
+	if (ret)
+		return ret;
+	ret = h2c_pkt_build_txd(adapter, h2cbuf);
+	if (ret)
+		return ret;
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cbuf);
+	#else
+	ret = PLTFM_TX(h2cbuf->data, h2cbuf->len);
+	#endif
+	h2cb_free(adapter, h2cbuf);
+	if (ret)
+		return ret;
+	h2c_end_flow(adapter);
+	return ret;
+}
+
+u32 get_bcn_erly_event(struct mac_ax_adapter *adapter, struct rtw_c2h_info *c2h,
+		       enum phl_msg_evt_id *id, u8 *c2h_info)
+{
+	struct mac_ax_bcn_erly_rpt *info;
+	u32 val_d0;
+	u32 dword0 = *((u32 *)c2h->content);
+
+	info = (struct mac_ax_bcn_erly_rpt *)c2h_info;
+	val_d0 = le32_to_cpu(dword0);
+	info->band = (val_d0 & FWCMD_C2H_BCNERLYNTFY_BAND) ? 1 : 0;
+	info->port = (u8)GET_FIELD(val_d0, FWCMD_C2H_BCNERLYNTFY_PORT);
+	*id = MSG_EVT_BCN_EARLY_REPORT;
+	PLTFM_MSG_TRACE("[BCNErlyRpt] band %d, port %d\n", info->band, info->port);
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_sta_csa(struct mac_ax_adapter *adapter,
+		    struct rtw_hal_mac_sta_csa *parm)
+{
+	u8 *sm_state = &adapter->sm.sta_csa_st;
+	u8 *sm_ret = &adapter->sm.sta_csa_ret;
+	u32 ret;
+
+	u32 total_h2c_size = sizeof(struct fwcmd_sta_csa);
+	u32 size_of_chinfo = sizeof(struct fwcmd_sta_csa_chinfo);
+	u32 dw_of_chinfo = size_of_chinfo / 4;
+	u8 num_of_chinfo = parm->num_supported_ch;
+	u8 chinfo_idx;
+	struct rtw_hal_mac_sta_csa_ch ch;
+
+	enum h2c_buf_class h2cb_type;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cbuf;
+	#else
+	struct h2c_buf *h2cbuf;
+	#endif
+	struct fwcmd_sta_csa *csa;
+	struct fwcmd_sta_csa_chinfo *chinfo;
+	u8 *buf8;
+
+	if (*sm_state != MAC_AX_STA_CSA_IDLE) {
+		PLTFM_MSG_ERR("[STACSA] sm err. curr st(%d) ret(%d)\n", *sm_state, *sm_ret);
+		return MACPROCBUSY;
+	}
+	if (parm->en && !num_of_chinfo) {
+		PLTFM_MSG_ERR("[STACSA] enable but no chinfo \n");
+		return MACCMP;
+	}
+	*sm_state = MAC_AX_STA_CSA_SENDING;
+
+	total_h2c_size +=  size_of_chinfo * num_of_chinfo;
+	if (total_h2c_size <= (H2C_CMD_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_CMD;
+		PLTFM_MSG_TRACE("[STACSA] size %d, using CMD Q\n", total_h2c_size);
+	} else if (total_h2c_size <= (H2C_DATA_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_DATA;
+		PLTFM_MSG_TRACE("[STACSA] size %d, using DATA Q\n", total_h2c_size);
+	} else if (total_h2c_size <= (H2C_LONG_DATA_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_LONG_DATA;
+		PLTFM_MSG_TRACE("[STACSA] size %d, using LDATA Q\n", total_h2c_size);
+	} else {
+		PLTFM_MSG_ERR("[STACSA] size %d, exceed LDATA Q size, abort\n", total_h2c_size);
+		return MACBUFSZ;
+	}
+
+	h2cbuf = h2cb_alloc(adapter, h2cb_type);
+	if (!h2cbuf) {
+		*sm_state = MAC_AX_STA_CSA_IDLE;
+		PLTFM_MSG_ERR("[STACSA] alloc h2cb fail\n");
+		return MACNPTR;
+	}
+
+	buf8 = h2cb_put(h2cbuf, total_h2c_size);
+	if (!buf8) {
+		h2cb_free(adapter, h2cbuf);
+		*sm_state = MAC_AX_STA_CSA_IDLE;
+		PLTFM_MSG_ERR("[STACSA] put h2cb fail\n");
+		return MACNOBUF;
+	}
+
+	csa = (struct fwcmd_sta_csa *)buf8;
+	csa->dword0 = cpu_to_le32((parm->en ? FWCMD_H2C_STA_CSA_STA_CSA_EN : 0) |
+				  SET_WORD(dw_of_chinfo, FWCMD_H2C_STA_CSA_SIZE_OF_CHINFO) |
+				  SET_WORD(num_of_chinfo, FWCMD_H2C_STA_CSA_NUM_OF_CHINFO) |
+				  SET_WORD(parm->macid, FWCMD_H2C_STA_CSA_MACID) |
+				  SET_WORD(parm->max_ap_gone_time,
+				  	   FWCMD_H2C_STA_CSA_MAX_AP_GONE_TIME));
+
+	chinfo = (struct fwcmd_sta_csa_chinfo *)(buf8 + sizeof(struct fwcmd_sta_csa));
+	for (chinfo_idx = 0; chinfo_idx < num_of_chinfo; chinfo_idx++) {
+		ch = parm->chlist[chinfo_idx];
+		chinfo->dword0 = cpu_to_le32(SET_WORD(ch.pri_ch, FWCMD_H2C_STA_CSA_CHINFO_PRI_CH) |
+					     SET_WORD(ch.supported_bw,
+					     	      FWCMD_H2C_STA_CSA_CHINFO_SUPPORTED_BW));
+		chinfo->dword1 = cpu_to_le32(ch.rf0);
+		chinfo->dword2 = cpu_to_le32(ch.rf1);
+		chinfo->dword3 = cpu_to_le32(ch.rf2);
+		chinfo->dword4 = cpu_to_le32(ch.rf3);
+		chinfo++;
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cbuf, FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC, FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_STA_CSA, 1, 1);
+	if (ret) {
+		h2cb_free(adapter, h2cbuf);
+		*sm_state = MAC_AX_STA_CSA_IDLE;
+		PLTFM_MSG_ERR("[STACSA] h2c_pkt_set_hdr fail (%d)\n", ret);
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cbuf);
+	if (ret) {
+		h2cb_free(adapter, h2cbuf);
+		*sm_state = MAC_AX_STA_CSA_IDLE;
+		PLTFM_MSG_ERR("[STACSA] h2c_pkt_build_txd fail(%d)\n", ret);
+		return ret;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cbuf);
+	#else
+	ret = PLTFM_TX(h2cbuf->data, h2cbuf->len);
+	#endif
+	if (ret) {
+		h2cb_free(adapter, h2cbuf);
+		PLTFM_MSG_ERR("[STACSA] PLTFM_TX fail(%d)\n", ret);
+		*sm_state = MAC_AX_STA_CSA_IDLE;
+		return ret;
+	}
+
+	h2cb_free(adapter, h2cbuf);
+	h2c_end_flow(adapter);
+	return MACSUCCESS;
+}
+
+u32 mac_check_sta_csa_cfg(struct mac_ax_adapter *adapter, u8 *fw_ret)
+{
+	if (adapter->sm.sta_csa_st == MAC_AX_STA_CSA_IDLE) {
+		*fw_ret = adapter->sm.sta_csa_ret;
+		return MACSUCCESS;
+	}
+	return MACPROCBUSY;
+}
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwofld.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwofld.h
new file mode 100644
index 000000000000..5d3295750ac6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/fwofld.h
@@ -0,0 +1,1407 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_FW_OFLD_H_
+#define _MAC_AX_FW_OFLD_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+#include "fwofld.h"
+#include "trx_desc.h"
+#include "common.h"
+
+#define READ_OFLD_MAX_LEN 2000
+#define WRITE_OFLD_MAX_LEN 2000
+#define CONF_OFLD_MAX_LEN 2000
+#define CMD_OFLD_MAX_LEN 2000
+
+#define CONF_OFLD_RESTORE 0
+#define CONF_OFLD_BACKUP 1
+
+#if MAC_AX_8852A_SUPPORT
+#include "mac_8852a/mac_txccxrpt.h"
+#endif
+#if MAC_AX_8852B_SUPPORT
+#include "mac_8852b/mac_txccxrpt.h"
+#endif
+#if MAC_AX_8852C_SUPPORT
+#include "mac_8852c/mac_txccxrpt.h"
+#endif
+#if MAC_AX_8192XB_SUPPORT
+#include "mac_8192xb/mac_txccxrpt.h"
+#endif
+#if MAC_AX_8851B_SUPPORT
+#include "mac_8851b/mac_txccxrpt.h"
+#endif
+#if MAC_AX_8851E_SUPPORT
+#include "mac_8851e/mac_txccxrpt.h"
+#endif
+#if MAC_AX_8852D_SUPPORT
+#include "mac_8852d/mac_txccxrpt.h"
+#endif
+
+#define CMD_OFLD_SIZE sizeof(struct fwcmd_cmd_ofld)
+#define CMD_OFLD_V1_SIZE sizeof(struct fwcmd_cmd_ofld_v1)
+
+/* Generate 8-bit mask for a 4-byte alignment offset */
+#define GET_W8_MSK(offset) \
+	(0xFF << ((offset) & 0x3 ? (8 * ((offset) & 0x3)) : 0))
+
+/* Generate 16-bit mask for a 4-byte alignment offset */
+#define GET_W16_MSK(offset) \
+	(0xFFFF << ((offset) & 0x2 ? 16 : 0))
+
+#define MAC_REG_W8_OFLD(offset, val, lc) \
+	write_mac_reg_ofld(adapter, offset & 0xFFFC, GET_W8_MSK(offset), val, lc)
+
+#define MAC_REG_W16_OFLD(offset, val, lc) \
+	write_mac_reg_ofld(adapter, offset & 0xFFFD, GET_W16_MSK(offset), val, lc)
+
+#define MAC_REG_W32_OFLD(offset, val, lc) \
+	write_mac_reg_ofld(adapter, offset, 0xFFFFFFFF, val, lc)
+
+#define MAC_REG_W_OFLD(offset, mask, val, lc) \
+	write_mac_reg_ofld(adapter, offset, mask, val, lc)
+
+#define MAC_REG_W_OFLD2(offset, mask, val, lc) \
+	write_mac_reg_ofld(adapter, offset, mask, val >> shift_mask(mask), lc)
+
+#define MAC_REG_P_OFLD(offset, mask, val, lc) \
+	poll_mac_reg_ofld(adapter, offset, mask, val, lc)
+
+#define MAC_REG_P_OFLD2(offset, mask, val, lc) \
+	poll_mac_reg_ofld(adapter, offset, mask, val >> shift_mask(mask), lc)
+
+#define DELAY_OFLD(val, lc) \
+	delay_ofld(adapter, val, lc)
+#define CMD_OFLD \
+	mac_cmd_ofld(adapter)
+/**
+ * @enum PKT_OFLD_OP
+ *
+ * @brief PKT_OFLD_OP
+ *
+ * @var PKT_OFLD_OP::PKT_OFLD_OP_ADD
+ * Please Place Description here.
+ * @var PKT_OFLD_OP::PKT_OFLD_OP_DEL
+ * Please Place Description here.
+ * @var PKT_OFLD_OP::PKT_OFLD_OP_READ
+ * Please Place Description here.
+ * @var PKT_OFLD_OP::PKT_OFLD_OP_MAX
+ * Please Place Description here.
+ */
+enum PKT_OFLD_OP {
+	PKT_OFLD_OP_ADD = 0,
+	PKT_OFLD_OP_DEL = 1,
+	PKT_OFLD_OP_READ = 2,
+	PKT_OFLD_OP_MAX
+};
+
+/**
+ * @enum FW_OFLD_OP
+ *
+ * @brief FW_OFLD_OP
+ *
+ * @var FW_OFLD_OP::FW_OFLD_OP_DUMP_EFUSE
+ * Please Place Description here.
+ * @var FW_OFLD_OP::FW_OFLD_OP_PACKET_OFLD
+ * Please Place Description here.
+ * @var FW_OFLD_OP::FW_OFLD_OP_READ_OFLD
+ * Please Place Description here.
+ * @var FW_OFLD_OP::FW_OFLD_OP_WRITE_OFLD
+ * Please Place Description here.
+ * @var FW_OFLD_OP::FW_OFLD_OP_CONF_OFLD
+ * Please Place Description here.
+ * @var FW_OFLD_OP::FW_OFLD_OP_MAX
+ * Please Place Description here.
+ */
+enum FW_OFLD_OP {
+	FW_OFLD_OP_DUMP_EFUSE = 0,
+	FW_OFLD_OP_PACKET_OFLD = 1,
+	FW_OFLD_OP_READ_OFLD = 2,
+	FW_OFLD_OP_WRITE_OFLD = 3,
+	FW_OFLD_OP_CONF_OFLD = 4,
+	FW_OFLD_OP_CH_SWITCH = 5,
+	FW_OFLD_OP_MAX
+};
+
+/**
+ * @enum CHSW_BW
+ *
+ * @brief CHSW_BW
+ *
+ * @var CHSW_BW::CHSW_BW_20
+ * Please Place Description here.
+ * @var CHSW_BW::CHSW_BW_40
+ * Please Place Description here.
+ * @var CHSW_BW::CHSW_BW_80
+ * Please Place Description here.
+ * @var CHSW_BW::CHSW_BW_160
+ * Please Place Description here.
+ * @var CHSW_BW::CHSW_BW_80_80
+ * Please Place Description here.
+ * @var CHSW_BW::CHSW_BW_5
+ * Please Place Description here.
+ * @var CHSW_BW::CHSW_BW_10
+ * Please Place Description here.
+ * @var CHSW_BW::CHSW_BW_MAX
+ * Please Place Description here.
+ */
+enum CHSW_BW {
+	CHSW_BW_20 = 0,
+	CHSW_BW_40 = 1,
+	CHSW_BW_80 = 2,
+	CHSW_BW_160 = 3,
+	CHSW_BW_80_80 = 4,
+	CHSW_BW_5 = 5,
+	CHSW_BW_10 = 6,
+	CHSW_BW_MAX
+};
+
+/**
+ * @enum CHSW_CHBAND
+ *
+ * @brief CHSW_CHBAND
+ *
+ * @var CHSW_CHBAND::CHSW_CHBAND_24G
+ * Please Place Description here.
+ * @var CHSW_CHBAND::CHSW_CHBAND_5G
+ * Please Place Description here.
+ * @var CHSW_CHBAND::CHSW_CHBAND_6G
+ * Please Place Description here.
+ * @var CHSW_CHBAND::CHSW_CHBAND_MAX
+ * Please Place Description here.
+ */
+enum CHSW_CHBAND {
+	CHSW_CHBAND_24G = 0,
+	CHSW_CHBAND_5G = 1,
+	CHSW_CHBAND_6G = 2,
+	CHSW_CHBAND_MAX
+};
+
+/**
+ * @enum CHSW_STATUS_CODE
+ *
+ * @brief CHSW_STATUS_CODE
+ *
+ * @var CHSW_STATUS_CODE::CHSW_OK
+ * Please Place Description here.
+ * @var CHSW_STATUS_CODE::CHSW_NOT_COMPILED_ERR
+ * Please Place Description here.
+ * @var CHSW_STATUS_CODE::CHSW_STOPSER_FAIL_WARN
+ * Please Place Description here.
+ * @var CHSW_STATUS_CODE::CHSW_BB_CTRL_BW_CH_FAIL_ERR
+ * Please Place Description here.
+ * @var CHSW_STATUS_CODE::CHSW_RF_RELOAD_FAIL_WARN
+ * Please Place Description here.
+ * @var CHSW_STATUS_CODE::CHSW_STARTSER_FAIL_WARN
+ * Please Place Description here.
+ * @var CHSW_STATUS_CODE::CHSW_MAX
+ * Please Place Description here.
+ */
+enum CHSW_STATUS_CODE {
+	CHSW_OK = 0,
+	CHSW_NOT_COMPILED_ERR = 1,
+	CHSW_STOPSER_FAIL_WARN = 2,
+	CHSW_BB_CTRL_BW_CH_FAIL_ERR = 3,
+	CHSW_RF_RELOAD_FAIL_WARN = 4,
+	CHSW_STARTSER_FAIL_WARN = 5,
+	CHSW_MAX
+};
+
+/**
+ * @struct mac_ax_conf_ofld_hdr
+ * @brief mac_ax_conf_ofld_hdr
+ *
+ * @var mac_ax_conf_ofld_hdr::pattern_count
+ * Please Place Description here.
+ * @var mac_ax_conf_ofld_hdr::rsvd
+ * Please Place Description here.
+ */
+struct mac_ax_conf_ofld_hdr {
+	u16 pattern_count;
+	u16 rsvd;
+};
+
+/**
+ * @struct mac_ax_pkt_ofld_hdr
+ * @brief mac_ax_pkt_ofld_hdr
+ *
+ * @var mac_ax_pkt_ofld_hdr::pkt_idx
+ * Please Place Description here.
+ * @var mac_ax_pkt_ofld_hdr::pkt_op
+ * Please Place Description here.
+ * @var mac_ax_pkt_ofld_hdr::rsvd
+ * Please Place Description here.
+ * @var mac_ax_pkt_ofld_hdr::pkt_len
+ * Please Place Description here.
+ */
+struct mac_ax_pkt_ofld_hdr {
+	u8 pkt_idx;
+	u8 pkt_op:3;
+	u8 rsvd:5;
+	u16 pkt_len;
+};
+
+/**
+ * @struct scanofld_chinfo_node
+ * @brief scanofld_chinfo_node
+ *
+ * @var scanofld_chinfo_node::next
+ * Point to next node.
+ * @var scanofld_chinfo_node::chinfo
+ * Content of this node.
+ */
+struct scanofld_chinfo_node {
+	struct scanofld_chinfo_node *next;
+	struct mac_ax_scanofld_chinfo *chinfo;
+};
+
+/**
+ * @struct scan_chinfo_list
+ * @brief scan_chinfo_list
+ *
+ * @var scan_chinfo_head::head
+ * Point to first node.
+ * @var scan_chinfo_head::tail
+ * Point to last node.
+ * @var scan_chinfo_head::size
+ * Size of the list
+ */
+struct scan_chinfo_list {
+	struct scanofld_chinfo_node *head;
+	struct scanofld_chinfo_node *tail;
+	u8 size;
+};
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+/**
+ * @brief mac_get_wlanfw_cap
+ *
+ * @param *adapter
+ * @param size
+ * @param buf
+ * @param mac_cap
+ * @param outsrc_cap
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_wlanfw_cap(struct mac_ax_adapter *adapter, struct rtw_wcpu_cap_t *wcpu_cap);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+/**
+ * @brief mac_reset_fwofld_state
+ *
+ * @param *adapter
+ * @param op
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_reset_fwofld_state(struct mac_ax_adapter *adapter, u8 op);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_check_fwofld_done
+ *
+ * @param *adapter
+ * @param op
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_fwofld_done(struct mac_ax_adapter *adapter, u8 op);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_clear_write_request
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_clear_write_request(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_add_write_request
+ *
+ * @param *adapter
+ * @param *req
+ * @param *value
+ * @param *mask
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_add_write_request(struct mac_ax_adapter *adapter,
+			  struct mac_ax_write_req *req,
+			  u8 *value, u8 *mask);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_write_ofld
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_ofld(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_clear_conf_request
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_clear_conf_request(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_add_conf_request
+ *
+ * @param *adapter
+ * @param *req
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_add_conf_request(struct mac_ax_adapter *adapter,
+			 struct mac_ax_conf_ofld_req *req);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_conf_ofld
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_conf_ofld(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_read_pkt_ofld
+ *
+ * @param *adapter
+ * @param id
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_pkt_ofld(struct mac_ax_adapter *adapter, u8 id);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_del_pkt_ofld
+ *
+ * @param *adapter
+ * @param id
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_del_pkt_ofld(struct mac_ax_adapter *adapter, u8 id);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_add_pkt_ofld
+ *
+ * @param *adapter
+ * @param *pkt
+ * @param len
+ * @param *id
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_add_pkt_ofld(struct mac_ax_adapter *adapter, u8 *pkt, u16 len, u8 *id);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_pkt_ofld_packet
+ *
+ * @param *adapter
+ * @param **pkt_buf
+ * @param *pkt_len
+ * @param *pkt_id
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_pkt_ofld_packet(struct mac_ax_adapter *adapter,
+			u8 **pkt_buf, u16 *pkt_len, u8 *pkt_id);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_dump_efuse_ofld
+ *
+ * @param *adapter
+ * @param efuse_size
+ * @param type
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dump_efuse_ofld(struct mac_ax_adapter *adapter, u32 efuse_size,
+			u8 type);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_efuse_ofld_map
+ *
+ * @param *adapter
+ * @param *efuse_map
+ * @param efuse_size
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_efuse_ofld_map(struct mac_ax_adapter *adapter, u8 *efuse_map,
+		       u32 efuse_size);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_clear_read_request
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_clear_read_request(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_add_read_request
+ *
+ * @param *adapter
+ * @param *req
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_add_read_request(struct mac_ax_adapter *adapter,
+			 struct mac_ax_read_req *req);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_read_ofld
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_ofld(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_read_ofld_value
+ *
+ * @param *adapter
+ * @param **val_buf
+ * @param *val_len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_ofld_value(struct mac_ax_adapter *adapter,
+			u8 **val_buf, u16 *val_len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_general_pkt_ids
+ *
+ * @param *adapter
+ * @param *ids
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_general_pkt_ids(struct mac_ax_adapter *adapter,
+			struct mac_ax_general_pkt_ids *ids);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_cmd_ofld
+ *
+ * This is the function for FW IO offload.
+ * Users could call the function to add write BB/RF/MAC REG command.
+ * When the aggregated commands are full or the command is last,
+ * FW would receive a H2C containing aggreated IO command.
+ *
+ * @param *adapter
+ * @return 0 for success. Others are fail.
+ * @retval u32
+ */
+u32 mac_cmd_ofld(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_add_cmd_ofld
+ *
+ * This is the function for FW IO offload.
+ * Users could call the function to add write BB/RF/MAC REG command.
+ * When the aggregated commands are full or the command is last,
+ * FW would receive a H2C containing aggreated IO command.
+ *
+ * @param *adapter
+ * @param *cmd
+ * @return 0 for success. Others are fail.
+ * @retval u32
+ */
+u32 mac_add_cmd_ofld(struct mac_ax_adapter *adapter, struct rtw_mac_cmd *cmd);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_add_cmd_ofld_v1
+ *
+ * This is the function for FW IO offload.
+ * Users could call the function to add write/move BB/RF/MAC REG command.
+ * When the aggregated commands are full or the command is last,
+ * FW would receive a H2C containing aggreated IO command.
+ *
+ * @param *adapter
+ * @param *cmd
+ * @return 0 for success. Others are fail.
+ * @retval u32
+ */
+u32 mac_add_cmd_ofld_v1(struct mac_ax_adapter *adapter, struct rtw_mac_cmd_v1 *cmd);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_get_fw_cap
+ *
+ * @param *adapter
+ * @param *val
+ * @return This function would set FW capability in *val.
+ * return fail while FW is NOT ready
+ * @retval u32
+ */
+u32 mac_get_fw_cap(struct mac_ax_adapter *adapter, u32 *val);
+/**
+ * @}
+ * @}
+ */
+
+u32 write_mac_reg_ofld(struct mac_ax_adapter *adapter,
+		       u16 offset, u32 mask, u32 val, u8 lc);
+
+u32 poll_mac_reg_ofld(struct mac_ax_adapter *adapter,
+		      u16 offset, u32 mask, u32 val, u8 lc);
+
+u32 delay_ofld(struct mac_ax_adapter *adapter, u32 val, u8 lc);
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief write_mac_reg_ofld_v1
+ *
+ * @param *adapter
+ * @param offset
+ * @param mask
+ * @param val
+ * @param lc
+ * @return fail while FW is NOT ready
+ * @retval u32
+ */
+u32 write_mac_reg_ofld_v1(struct mac_ax_adapter *adapter,
+			  u16 offset, u32 mask, u32 val, u8 lc);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief poll_mac_reg_ofld_v1
+ *
+ * @param *adapter
+ * @param offset
+ * @param mask
+ * @param val
+ * @param lc
+ * @return fail while FW is NOT ready
+ * @retval u32
+ */
+u32 poll_mac_reg_ofld_v1(struct mac_ax_adapter *adapter,
+			 u16 offset, u32 mask, u32 val, u8 lc);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief delay_ofld_v1
+ *
+ * @param *adapter
+ * @param val
+ * @return fail while FW is NOT ready
+ * @retval u32
+ */
+u32 delay_ofld_v1(struct mac_ax_adapter *adapter, u32 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief move_mac_reg_ofld
+ *
+ * @param *adapter
+ * @param offset0
+ * @param offset1
+ * @param mask0
+ * @param mask1
+ * @param lc
+ * @return fail while FW is NOT ready
+ * @retval u32
+ */
+u32 move_mac_reg_ofld(struct mac_ax_adapter *adapter,
+		      u16 offset0, u16 offset1, u32 mask0, u32 mask1, u8 lc);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @brief mac_ccxrpt_parsing
+ *
+ * @param *adapter
+ * @param *buf
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_ccxrpt_parsing(struct mac_ax_adapter *adapter,
+		       u8 *buf, struct mac_ax_ccxrpt *info);
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_scanofld_ch_list_clear
+ *
+ * Clear the scan list
+
+ * @param *adapter
+ * @param *list
+ * @return void
+ * @retval void
+ */
+void mac_scanofld_ch_list_clear(struct mac_ax_adapter *adapter,
+				struct scan_chinfo_list *list);
+
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_add_scanofld_ch
+ *
+ * Add a chinfo to scanlist.
+ * Note that the user-allocated chinfo must not be free.
+ * halmac will handle the free process
+ *
+ * @param *adapter
+ * @param *chinfo
+ * @param send_h2C send scanlist to fw after adding or not
+ * @param clear_after_send clear halmac scanlist after sending or not(available when sendH2C is set)
+ * @param band
+ * @return 0 for success. Others are fail.
+ * @retval u32
+ */
+u32 mac_add_scanofld_ch(struct mac_ax_adapter *adapter, struct mac_ax_scanofld_chinfo *chinfo,
+			u8 send_h2C, u8 clear_after_send, u8 band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_scanofld
+ *
+ * Start scanofld
+ *
+ * @param *adapter
+ * @param *scanParam
+ * @return 0 for success. Others are fail.
+ * @retval u32
+ */
+void mac_scanofld_reset_state(struct mac_ax_adapter *adapter);
+
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_scanofld
+ *
+ * Start scanofld
+ *
+ * @param *adapter
+ * @param *scanParam
+ * @return 0 for success. Others are fail.
+ * @retval u32
+ */
+u32 mac_scanofld(struct mac_ax_adapter *adapter, struct mac_ax_scanofld_param *scanParam);
+
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_scanofld_fw_busy
+ *
+ * Check whether FW is scanning or not
+ *
+ * @param *adapter
+ * @param band
+ * @return 0 for idle. Others are busy.
+ * @retval u32
+ */
+u32 mac_scanofld_fw_busy(struct mac_ax_adapter *adapter, u8 band);
+
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_scanofld_chlist_busy
+ *
+ * check whether halmac chlist or fw chlist are busy or not
+ *
+ * @param *adapter
+ * @param band
+ * @return 0 for idle. Others are busy.
+ * @retval u32
+ */
+u32 mac_scanofld_chlist_busy(struct mac_ax_adapter *adapter, u8 band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+/**
+ * @brief mac_scanofld_hst_ctrl
+ *
+ * check whether halmac chlist or fw chlist are busy or not
+ *
+ * @param *adapter
+ * @param pri_ch
+ * @param ch_band
+ * @param op
+ * @param band
+ * @return 0 for idle. Others are busy.
+ * @retval u32
+ */
+u32 mac_scanofld_hst_ctrl(struct mac_ax_adapter *adapter, u8 pri_ch, u8 ch_band,
+			  enum mac_ax_scanofld_ctrl op, u8 band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief get_ccxrpt_event
+ *
+ * ccxrpt event from fw to PHL notify
+ *
+ * @param *adapter
+ * @param *rtw_c2h_info
+ * @param *phl_msg_evt_id
+ * @param *c2h_info
+ * @return 0 for success.
+ * @retval c2h_info for c2hrpt buff
+ */
+u32 get_ccxrpt_event(struct mac_ax_adapter *adapter,
+		     struct rtw_c2h_info *c2h,
+		     enum phl_msg_evt_id *id, u8 *c2h_info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief pktofld_self_test
+ *
+ * ccxrpt event from fw to PHL notify
+ *
+ * @param *adapter
+ * @return 0 for success.
+ * @retval self test result
+ */
+u32 pktofld_self_test(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief ch_switch_ofld
+ *
+ * ch switch offload
+ *
+ * @param *adapter
+ * @param parm
+ * @return 0 for success.
+ * @retval ch switch offload h2c status
+ */
+u32 mac_ch_switch_ofld(struct mac_ax_adapter *adapter, struct mac_ax_ch_switch_parm parm);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_get_ch_switch_rpt
+ *
+ * get channel switch offload report
+ *
+ * @param *adapter
+ * @param parm
+ * @return 0 for success.
+ * @retval ch switch offload h2c status
+ */
+u32 mac_get_ch_switch_rpt(struct mac_ax_adapter *adapter, struct mac_ax_ch_switch_rpt *rpt);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_bcn_filter
+ *
+ * config bcn filter
+ *
+ * @param *adapter
+ * @param cfg
+ * @return 0 for success.
+ * @retval
+ */
+u32 mac_cfg_bcn_filter(struct mac_ax_adapter *adapter, struct mac_ax_bcn_fltr cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+/**
+ * @brief mac_cfg_bcn_early_rpt
+ *
+ * get channel switch offload report
+ *
+ * @param *adapter
+ * @param band
+ * @param port
+ * @param en
+ * @return 0 for success.
+ * @retval
+ */
+u32 mac_cfg_bcn_early_rpt(struct mac_ax_adapter *adapter, u8 band, u8 port, u8 en);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_bcn_filter_rssi
+ *
+ * offload rssi to fw for bcn filter
+ *
+ * @param *adapter
+ * @param macid
+ * @param size
+ * @param rssi
+ * @return 0 for success.
+ * @retval
+ */
+u32 mac_bcn_filter_rssi(struct mac_ax_adapter *adapter, u8 macid, u8 size, u8 *rssi);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_bcn_filter_tp
+ *
+ * offload tp to fw for bcn filter
+ *
+ * @param *adapter
+ * @param macid
+ * @param tx
+ * @param rx
+ * @return 0 for success.
+ * @retval
+ */
+u32 mac_bcn_filter_tp(struct mac_ax_adapter *adapter, u8 macid, u16 tx, u16 rx);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Firmware
+ * @{
+ * @addtogroup FW_Offload
+ * @{
+ */
+
+/**
+ * @brief mac_host_efuse_rec
+ *
+ * Check whether FW is scanning or not
+ *
+ * @param *adapter
+ * @param macid
+ * @param tx
+ * @return 0 for success
+ * @retval u32
+ */
+
+u32 mac_host_efuse_rec(struct mac_ax_adapter *adapter, u32 host_id, u32 efuse_val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_cfg_sensing_csi
+ *
+ * Offload WiFi sensing CSI to FW
+ *
+ * @param *adapter
+ * @param rtw_hal_mac_sensing_csi_param
+ * @return 0 for success.
+ * @retval
+ */
+u32 mac_cfg_sensing_csi(struct mac_ax_adapter *adapter,
+			struct rtw_hal_mac_sensing_csi_param *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_chk_sensing_csi_done
+ *
+ * Check WiFi sensing CSI status
+ *
+ * @param *adapter
+ * @param chk_state
+ * @return 0 for success.
+ * @retval
+ */
+u32 mac_chk_sensing_csi_done(struct mac_ax_adapter *adapter, u8 chk_state);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief get_sensing_csi_event
+ *
+ * sensing csi event from fw to PHL notify
+ *
+ * @param *adapter
+ * @param *rtw_c2h_info
+ * @param *phl_msg_evt_id
+ * @param *c2h_info
+ * @return 0 for success.
+ * @retval c2h_info for c2hrpt buff
+ */
+u32 get_sensing_csi_event(struct mac_ax_adapter *adapter,
+			  struct rtw_c2h_info *c2h,
+			  enum phl_msg_evt_id *id, u8 *c2h_info);
+/**
+ * @}
+ * @}
+ */
+
+u32 mac_fwcpumgenq_test(struct mac_ax_adapter *adapter, u8 macid, u16 len, u8 *pkt);
+
+/**
+ * @brief get_bcn_erly_event
+ *
+ * get channel switch offload report
+ *
+ * @param *adapter
+ * @param c2h
+ * @param id
+ * @param c2h_info
+ * @return 0 for success.
+ * @retval
+ */
+u32 get_bcn_erly_event(struct mac_ax_adapter *adapter, struct rtw_c2h_info *c2h,
+		       enum phl_msg_evt_id *id, u8 *c2h_info);
+/**
+ * @}
+ * @}
+ */
+
+u32 mac_cfg_sta_csa(struct mac_ax_adapter *adapter,
+		    struct rtw_hal_mac_sta_csa *parm);
+
+u32 mac_check_sta_csa_cfg(struct mac_ax_adapter *adapter, u8 *fw_ret);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/gpio.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/gpio.c
new file mode 100644
index 000000000000..34e10536bd15
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/gpio.c
@@ -0,0 +1,851 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "gpio.h"
+
+u32 mac_sel_uart_tx_pin(struct mac_ax_adapter *adapter,
+			enum mac_ax_uart_tx_pin uart_pin)
+{
+	struct mac_ax_intf_ops *ops = adapter->ops->intf_ops;
+	struct mac_ax_gpio_info *info = &adapter->gpio_info;
+	u8 val = MAC_REG_R8(R_AX_CAL_TIMER + 3);
+	u32 ret = MACSUCCESS;
+
+	switch (uart_pin) {
+	case MAC_AX_UART_TX_GPIO5:
+		val |= BIT(6);
+		if (!info->uart_tx_gpio5)
+			PLTFM_MSG_WARN("Pinmux function is not switched\n");
+		break;
+	case MAC_AX_UART_TX_GPIO7:
+		val &= ~(BIT(7) | BIT(6));
+		if (!info->uart_tx_gpio7)
+			PLTFM_MSG_WARN("Pinmux function is not switched\n");
+		break;
+	case MAC_AX_UART_TX_GPIO8:
+		val |= BIT(7);
+		if (!info->uart_tx_gpio8)
+			PLTFM_MSG_WARN("Pinmux function is not switched\n");
+		break;
+	case MAC_AX_UART_TX_GPIO5_GPIO8:
+		val |= (BIT(6) | BIT(7));
+		if (!info->uart_tx_gpio8 || !info->uart_tx_gpio5)
+			PLTFM_MSG_WARN("Pinmux function is not switched\n");
+		break;
+	default:
+		PLTFM_MSG_ERR("Wrong UART GPIO\n");
+		ret = MACNOITEM;
+		break;
+	}
+
+	MAC_REG_W8(R_AX_CAL_TIMER + 3, val);
+
+	return ret;
+}
+
+u32 mac_sel_uart_rx_pin(struct mac_ax_adapter *adapter,
+			enum mac_ax_uart_rx_pin uart_pin)
+{
+	struct mac_ax_intf_ops *ops = adapter->ops->intf_ops;
+	struct mac_ax_gpio_info *info = &adapter->gpio_info;
+	u8 val = MAC_REG_R8(R_AX_CAL_TIMER + 3);
+	u32 ret = MACSUCCESS;
+
+	switch (uart_pin) {
+	case MAC_AX_UART_RX_GPIO6:
+		val &= ~BIT(5);
+		if (!info->uart_rx_gpio6)
+			PLTFM_MSG_WARN("Pinmux function is not switched\n");
+		break;
+	case MAC_AX_UART_RX_GPIO14:
+		val |= BIT(5);
+		if (!info->uart_rx_gpio14)
+			PLTFM_MSG_WARN("Pinmux function is not switched\n");
+		break;
+	default:
+		PLTFM_MSG_ERR("Wrong UART GPIO\n");
+		ret = MACNOITEM;
+		break;
+	}
+
+	MAC_REG_W8(R_AX_CAL_TIMER + 3, val);
+
+	return ret;
+}
+
+u32 mac_pinmux_switch(struct mac_ax_adapter *adapter,
+		      enum mac_ax_gpio_func gpio_func,
+		      const struct mac_ax_pinmux_list *list,
+		      u32 list_size, u32 gpio_id)
+{
+	struct mac_ax_intf_ops *ops = adapter->ops->intf_ops;
+	enum pinmux_name pinmux;
+	struct mac_ax_pinmux_list const *cur_list;
+	u32 i;
+	u8 val;
+
+	switch (gpio_func) {
+	case MAC_AX_GPIO_SW_IO_0:
+	case MAC_AX_GPIO_SW_IO_1:
+	case MAC_AX_GPIO_SW_IO_2:
+	case MAC_AX_GPIO_SW_IO_3:
+	case MAC_AX_GPIO_SW_IO_4:
+	case MAC_AX_GPIO_SW_IO_5:
+	case MAC_AX_GPIO_SW_IO_6:
+	case MAC_AX_GPIO_SW_IO_7:
+	case MAC_AX_GPIO_SW_IO_8:
+	case MAC_AX_GPIO_SW_IO_9:
+	case MAC_AX_GPIO_SW_IO_10:
+	case MAC_AX_GPIO_SW_IO_11:
+	case MAC_AX_GPIO_SW_IO_12:
+	case MAC_AX_GPIO_SW_IO_13:
+	case MAC_AX_GPIO_SW_IO_14:
+	case MAC_AX_GPIO_SW_IO_15:
+		pinmux = MAC_AX_SW_IO;
+		break;
+	case MAC_AX_GPIO_UART_TX_GPIO5:
+	case MAC_AX_GPIO_UART_TX_GPIO7:
+	case MAC_AX_GPIO_UART_TX_GPIO8:
+		pinmux = MAC_AX_WL_UART_TX;
+		break;
+	case MAC_AX_GPIO_UART_RX_GPIO6:
+	case MAC_AX_GPIO_UART_RX_GPIO14:
+		pinmux = MAC_AX_WL_UART_RX;
+		break;
+	default:
+		PLTFM_MSG_ERR("Wrong GPIO function\n");
+		return MACNOITEM;
+	}
+
+	cur_list = list;
+	for (i = 0; i < list_size; i++) {
+		val = MAC_REG_R8(cur_list->offset);
+		val &= ~(cur_list->msk);
+
+		if (pinmux == cur_list->func) {
+			val |= (cur_list->value & cur_list->msk);
+			MAC_REG_W8(cur_list->offset, val);
+			break;
+		}
+
+		val |= (~cur_list->value & cur_list->msk);
+		MAC_REG_W8(cur_list->offset, val);
+
+		cur_list++;
+	}
+
+	if (i ==  list_size) {
+		PLTFM_MSG_ERR("Get pinmux function error\n");
+		return MACNOITEM;
+	}
+
+	switch (pinmux) {
+	case MAC_AX_WL_UART_TX:
+	case MAC_AX_WL_UART_RX:
+		val = MAC_REG_R8(R_AX_WCPU_FW_CTRL + 3);
+		MAC_REG_W8(R_AX_WCPU_FW_CTRL + 3, val | BIT(7));
+		break;
+	default:
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_pinmux_record(struct mac_ax_adapter *adapter,
+		      enum mac_ax_gpio_func func, u8 val)
+{
+	struct mac_ax_gpio_info *info = &adapter->gpio_info;
+
+	switch (func) {
+	case MAC_AX_GPIO_SW_IO_0:
+		info->sw_io_0 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_1:
+		info->sw_io_1 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_2:
+		info->sw_io_2 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_3:
+		info->sw_io_3 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_4:
+		info->sw_io_4 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_5:
+		info->sw_io_5 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_6:
+		info->sw_io_6 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_7:
+		info->sw_io_7 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_8:
+		info->sw_io_8 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_9:
+		info->sw_io_9 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_10:
+		info->sw_io_10 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_11:
+		info->sw_io_11 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_12:
+		info->sw_io_12 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_13:
+		info->sw_io_13 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_14:
+		info->sw_io_14 = val;
+		break;
+	case MAC_AX_GPIO_SW_IO_15:
+		info->sw_io_15 = val;
+		break;
+	case MAC_AX_GPIO_UART_TX_GPIO5:
+		info->uart_tx_gpio5 = val;
+		break;
+	case MAC_AX_GPIO_UART_TX_GPIO7:
+		info->uart_tx_gpio7 = val;
+		break;
+	case MAC_AX_GPIO_UART_TX_GPIO8:
+		info->uart_tx_gpio8 = val;
+		break;
+	case MAC_AX_GPIO_UART_RX_GPIO6:
+		info->uart_rx_gpio6 = val;
+		break;
+	case MAC_AX_GPIO_UART_RX_GPIO14:
+		info->uart_rx_gpio14 = val;
+		break;
+	default:
+		PLTFM_MSG_ERR("Wrong GPIO function\n");
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_pinmux_status(struct mac_ax_adapter *adapter,
+		      enum mac_ax_gpio_func func)
+{
+	struct mac_ax_gpio_info *info = &adapter->gpio_info;
+	u32 ret = MACSUCCESS;
+
+	switch (func) {
+	case MAC_AX_GPIO_SW_IO_0:
+		if (info->sw_io_0)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_1:
+		if (info->sw_io_1)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_2:
+		if (info->sw_io_2)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_3:
+		if (info->sw_io_3)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_4:
+		if (info->sw_io_4)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_5:
+		if (info->sw_io_5 || info->uart_tx_gpio5 ||
+		    info->uart_tx_gpio7 || info->uart_tx_gpio8)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_UART_TX_GPIO5:
+		if (info->sw_io_5 || info->uart_tx_gpio5)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_6:
+		if (info->sw_io_6 || info->uart_rx_gpio6 ||
+		    info->uart_rx_gpio14)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_UART_RX_GPIO6:
+		if (info->sw_io_6 || info->uart_rx_gpio6)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_7:
+		if (info->sw_io_7 || info->uart_tx_gpio5 ||
+		    info->uart_tx_gpio7 || info->uart_tx_gpio8)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_UART_TX_GPIO7:
+		if (info->sw_io_7 || info->uart_tx_gpio7)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_8:
+		if (info->sw_io_8 || info->uart_tx_gpio5 ||
+		    info->uart_tx_gpio7 || info->uart_tx_gpio8)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_UART_TX_GPIO8:
+		if (info->sw_io_8 || info->uart_tx_gpio8)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_9:
+		if (info->sw_io_9)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_10:
+		if (info->sw_io_10)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_11:
+		if (info->sw_io_11)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_12:
+		if (info->sw_io_12)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_13:
+		if (info->sw_io_13)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_14:
+		if (info->sw_io_14 || info->uart_rx_gpio6 ||
+		    info->uart_rx_gpio14)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_UART_RX_GPIO14:
+		if (info->sw_io_14 || info->uart_rx_gpio14)
+			goto GPIO_USED;
+		break;
+	case MAC_AX_GPIO_SW_IO_15:
+		if (info->sw_io_15)
+			goto GPIO_USED;
+		break;
+	default:
+		ret = MACNOITEM;
+		PLTFM_MSG_ERR("Wrong GPIO function\n");
+	}
+
+	return ret;
+GPIO_USED:
+	ret = MACGPIOUSED;
+	return ret;
+}
+
+u32 mac_pinmux_free_func(struct mac_ax_adapter *adapter,
+			 enum mac_ax_gpio_func func)
+{
+	return mac_pinmux_record(adapter, func, 0);
+}
+
+u8 get_led_gpio(u8 led_id)
+{
+/* LED 0 -> GPIO8 */
+	switch (led_id) {
+	case 0:
+		return 8;
+	default:
+		return 0xFF;
+	}
+}
+
+u32 mac_set_led_mode(struct mac_ax_adapter *adapter,
+		     enum mac_ax_led_mode mode, u8 led_id)
+{
+#define LED_MODE_SW_CTRL 0
+#define LED_MODE_AON 1
+#define LED_MODE_TRX_ON 2
+#define LED_MODE_TRX_OFF 3
+#define LED_MODE_TX_ON 4
+#define LED_MODE_TX_OFF 5
+#define LED_MODE_RX_ON 6
+#define LED_MODE_RX_OFF 7
+	struct mac_ax_intf_ops *ops = adapter->ops->intf_ops;
+	struct mac_ax_ops *mac_ops = adapter->ops;
+	u32 val, ret;
+	u8 tmp, gpio;
+
+	gpio = get_led_gpio(led_id);
+	if (gpio == 0xFF) {
+		PLTFM_MSG_ERR("%s: Wrong LED ID: %d", __func__, led_id);
+		ret = MACNOITEM;
+		goto END;
+	}
+
+	val = MAC_REG_R32(R_AX_LED_CFG);
+
+	switch (mode) {
+	case MAC_AX_LED_MODE_TRX_ON:
+		tmp = LED_MODE_TRX_ON;
+		break;
+	case MAC_AX_LED_MODE_TX_ON:
+		tmp = LED_MODE_TX_ON;
+		break;
+	case MAC_AX_LED_MODE_RX_ON:
+		tmp = LED_MODE_RX_ON;
+		break;
+	case MAC_AX_LED_MODE_SW_CTRL_OD:
+		/* use SW IO to control LED */
+		ret = mac_set_sw_gpio_mode(adapter,
+					   RTW_AX_SW_IO_MODE_OUTPUT_OD, 8);
+		if (ret)
+			PLTFM_MSG_ERR("%s: config SW GPIO fail: %d",
+				      __func__, ret);
+		goto END;
+	case MAC_AX_LED_MODE_SW_CTRL_PP:
+		/* use SW IO to control LED */
+		ret = mac_set_sw_gpio_mode(adapter,
+					   RTW_AX_SW_IO_MODE_OUTPUT_PP, 8);
+		if (ret)
+			PLTFM_MSG_ERR("%s: config SW GPIO fail: %d",
+				      __func__, ret);
+		goto END;
+	default:
+		PLTFM_MSG_ERR("%s: Wrong LED mode: %d", __func__, mode);
+		return MACNOITEM;
+	}
+
+	ret = mac_ops->set_gpio_func(adapter, RTW_MAC_GPIO_WL_LED, gpio);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: Config LED pinmux fail", __func__);
+		goto END;
+	}
+
+	val = SET_CLR_WORD(val, tmp, B_AX_LED2CM);
+	val = val & ~(B_AX_LED2_EN);
+	MAC_REG_W32(R_AX_LED_CFG, val);
+
+END:
+	return ret;
+}
+
+u32 mac_led_ctrl(struct mac_ax_adapter *adapter,
+		 u8 high, u8 led_id)
+{
+	u32 ret = MACSUCCESS;
+	u8 gpio;
+
+	gpio = get_led_gpio(led_id);
+	if (gpio == 0xFF) {
+		PLTFM_MSG_ERR("%s: Wrong LED ID: %d", __func__, led_id);
+		ret = MACNOITEM;
+		goto END;
+	}
+
+	/* use SW IO to control LED */
+	ret = mac_sw_gpio_ctrl(adapter, high, gpio);
+
+END:
+	return ret;
+}
+
+u32 _mac_set_sw_gpio_mode(struct mac_ax_adapter *adapter,
+			  u8 output, u8 gpio)
+{
+	struct mac_ax_intf_ops *ops = adapter->ops->intf_ops;
+	u32 reg;
+	u16 val16;
+	u8 in_out;
+
+	if (gpio <= 7) {
+		reg = R_AX_GPIO_PIN_CTRL + 2;
+	} else if (gpio >= 8 && gpio <= 15) {
+		reg = R_AX_GPIO_EXT_CTRL + 2;
+		gpio = gpio - 8;
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	} else if (gpio >= 16 && gpio <= 18 &&
+		   (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))) {
+		reg = R_AX_GPIO_16_TO_18_EXT_CTRL + 2;
+		gpio = gpio - 16;
+#endif
+	} else {
+		PLTFM_MSG_ERR("%s: Wrong GPIO num: %d", __func__, gpio);
+		return MACNOITEM;
+	}
+
+	in_out = (output == 0) ? 0 : 1;
+
+	val16 = MAC_REG_R16(reg);
+	val16 = (val16 & ~((u16)BIT(gpio) | (u16)BIT(gpio + 8))) |
+		      (u16)(in_out << gpio) | (u16)(in_out << gpio << 8);
+	MAC_REG_W16(reg, val16);
+
+	return MACSUCCESS;
+}
+
+u32 mac_set_sw_gpio_mode(struct mac_ax_adapter *adapter,
+			 enum rtw_gpio_mode mode, u8 gpio)
+{
+	struct mac_ax_ops *mac_ops = adapter->ops;
+	struct mac_ax_gpio_info *gpio_info = &adapter->gpio_info;
+	u32 ret;
+
+	ret = mac_ops->set_gpio_func(adapter, RTW_MAC_GPIO_SW_IO, gpio);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: Config SW IO pinmux fail", __func__);
+		return ret;
+	}
+
+	switch (mode) {
+	case RTW_AX_SW_IO_MODE_INPUT:
+		ret = _mac_set_sw_gpio_mode(adapter, 0, gpio);
+		break;
+	case RTW_AX_SW_IO_MODE_OUTPUT_OD:
+		ret = _mac_set_sw_gpio_mode(adapter, 0, gpio);
+		gpio_info->sw_io_output[gpio] = MAC_AX_SW_IO_OUT_OD;
+		break;
+	case RTW_AX_SW_IO_MODE_OUTPUT_PP:
+		ret = _mac_set_sw_gpio_mode(adapter, 1, gpio);
+		gpio_info->sw_io_output[gpio] = MAC_AX_SW_IO_OUT_PP;
+		break;
+	default:
+		PLTFM_MSG_ERR("%s: Wrong SW GPIO mode: %d", __func__, mode);
+		ret = MACNOITEM;
+		break;
+	}
+
+	return ret;
+}
+
+u32 mac_sw_gpio_ctrl(struct mac_ax_adapter *adapter,
+		     u8 high, u8 gpio)
+{
+	struct mac_ax_intf_ops *ops = adapter->ops->intf_ops;
+	struct mac_ax_gpio_info *gpio_info = &adapter->gpio_info;
+	u32 reg, ret;
+	u8 ctrl, val8;
+
+	if (gpio >= MAC_AX_GPIO_NUM) {
+		PLTFM_MSG_ERR("%s: Wrong GPIO num: %d", __func__, gpio);
+		ret = MACNOITEM;
+		goto END;
+	}
+
+	if (high && gpio_info->sw_io_output[gpio] == MAC_AX_SW_IO_OUT_OD) {
+		ret = _mac_set_sw_gpio_mode(adapter, 0, gpio);
+	} else {
+		ret = _mac_set_sw_gpio_mode(adapter, 1, gpio);
+		if (ret) {
+			PLTFM_MSG_ERR("%s: Set GPIO mode fail\n", __func__);
+			goto END;
+		}
+
+		if (gpio <= 7) {
+			reg = R_AX_GPIO_PIN_CTRL + 1;
+		} else if (gpio >= 8 && gpio <= 15) {
+			reg = R_AX_GPIO_EXT_CTRL + 1;
+			gpio = gpio - 8;
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		} else if (gpio >= 16 && gpio <= 18 &&
+			   (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+			    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+			    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+			    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))) {
+			reg = R_AX_GPIO_16_TO_18_EXT_CTRL + 1;
+			gpio = gpio - 16;
+#endif
+		} else {
+			PLTFM_MSG_ERR("%s: Wrong GPIO num: %d", __func__, gpio);
+			return MACNOITEM;
+		}
+
+		ctrl = (high == 0) ? 0 : 1;
+
+		val8 = MAC_REG_R8(reg);
+		val8 = (val8 & ~((u8)BIT(gpio))) | (u8)(ctrl << gpio);
+		MAC_REG_W8(reg, val8);
+	}
+
+END:
+	return ret;
+}
+
+enum rtw_mac_gfunc mac_get_gpio_status(struct mac_ax_adapter *adapter,
+				       const struct mac_ax_pin_list *list)
+{
+	struct mac_ax_intf_ops *ops = adapter->ops->intf_ops;
+	u8 val;
+	enum rtw_mac_gfunc curr = RTW_MAC_GPIO_INVALID;
+
+	while (list && list->func != RTW_MAC_GPIO_LAST) {
+		/* first fit list*/
+		if (curr != list->func &&
+		    list->offset >= R_AX_GPIO0_7_FUNC_SEL &&
+		    list->offset <= R_AX_EECS_EESK_FUNC_SEL) {
+			curr = list->func;
+			val = MAC_REG_R8(list->offset);
+			if ((val & list->msk) == list->value)
+				return list->func;
+		}
+		list++;
+	}
+
+	return RTW_MAC_GPIO_INVALID;
+}
+
+u32 mac_cfg_wps(struct mac_ax_adapter *adapter,
+		struct mac_ax_cfg_wps *wps)
+{
+	u32 ret;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_cfg_wps *ptr;
+	struct mac_ax_gpio_info *info = &adapter->gpio_info;
+
+	if (wps->gpio > RTW_MAC_GPIO_MAX) {
+		PLTFM_MSG_ERR("%s: Wrong GPIO num: %d", __func__, wps->gpio);
+		return MACGPIONUM;
+	}
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	ptr = (struct fwcmd_cfg_wps *)h2cb_put(h2cb, sizeof(*ptr));
+	if (!ptr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+	PLTFM_MEMSET(ptr, 0, sizeof(*ptr));
+
+	ptr->dword0 = cpu_to_le32((wps->en ? FWCMD_H2C_CFG_WPS_EN : 0) |
+				  SET_WORD(wps->gpio,
+					   FWCMD_H2C_CFG_WPS_GPIO) |
+				  SET_WORD(wps->interval,
+					   FWCMD_H2C_CFG_WPS_INTL));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MISC,
+			      FWCMD_H2C_FUNC_CFG_WPS,
+			      0,
+			      0);
+
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]platform tx\n");
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	if (info->status[wps->gpio] != RTW_MAC_GPIO_DFLT &&
+	    info->status[wps->gpio] != RTW_MAC_GPIO_SW_IO)
+		PLTFM_MSG_WARN("The gpio%d is %d\n",
+			       wps->gpio, info->status[wps->gpio]);
+
+	info->status[wps->gpio] = RTW_MAC_GPIO_SW_IO;
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_get_gpio_val(struct mac_ax_adapter *adapter, u8 gpio, u8 *val)
+{
+	struct mac_ax_intf_ops *ops = adapter->ops->intf_ops;
+	u32 reg;
+
+	if (gpio <= 7) {
+		reg = R_AX_GPIO_PIN_CTRL;
+	} else if (gpio >= 8 && gpio <= 15) {
+		reg = R_AX_GPIO_EXT_CTRL;
+		gpio = gpio - 8;
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	} else if (gpio >= 16 && gpio <= 18 &&
+		   (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))) {
+		reg = R_AX_GPIO_16_TO_18_EXT_CTRL;
+		gpio = gpio - 16;
+#endif
+	} else {
+		PLTFM_MSG_ERR("%s: Wrong GPIO num: %d", __func__, gpio);
+		return MACNOITEM;
+	}
+
+	*val = !!(MAC_REG_R8(reg) & BIT(gpio));
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_wl_dis_gpio(struct mac_ax_adapter *adapter, u8 *gpio)
+{
+#define MAC_AX_HCI_SEL_SDIO_UART 0
+#define MAC_AX_HCI_SEL_USB_MULT 1
+#define MAC_AX_HCI_SEL_PCIE_UART 2
+#define MAC_AX_HCI_SEL_PCIE_USB 3
+#define MAC_AX_HCI_SEL_SDIO_MULT 4
+#define MAC_AX_HCI_SEL_RSVD 5
+#define MAC_AX_HCI_SEL_PCIE_GEN1_UART 6
+#define MAC_AX_HCI_SEL_PCIE_GEN1_USB 7
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val;
+
+	val = MAC_REG_R32(R_AX_SYS_STATUS1);
+	val = GET_FIELD(val, B_AX_HCI_SEL_V4);
+
+#if MAC_AX_8852A_SUPPORT
+	/* In AP, */
+	/*   MAC_AX_HCI_SEL_PCIE_UART and MAC_AX_HCI_SEL_SDIO_UART */
+	/*   are only supported in 2G eFEM, not in 5G/5G 6G*/
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+		switch (val) {
+#ifdef PHL_FEATURE_AP
+		case MAC_AX_HCI_SEL_PCIE_UART:
+		case MAC_AX_HCI_SEL_SDIO_UART:
+			*gpio = 9;
+			break;
+#else
+		case MAC_AX_HCI_SEL_USB_MULT:
+		case MAC_AX_HCI_SEL_PCIE_UART:
+		case MAC_AX_HCI_SEL_PCIE_USB:
+			*gpio = 9;
+			break;
+		case MAC_AX_HCI_SEL_SDIO_UART:
+			*gpio = 15;
+			break;
+#endif
+		default:
+			PLTFM_MSG_ERR("%s: Wrong HCI\n", __func__);
+			return MACNOITEM;
+		}
+	}
+#endif
+
+#if MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		switch (val) {
+		case MAC_AX_HCI_SEL_USB_MULT:
+		case MAC_AX_HCI_SEL_PCIE_UART:
+		case MAC_AX_HCI_SEL_PCIE_USB:
+		case MAC_AX_HCI_SEL_PCIE_GEN1_UART:
+		case MAC_AX_HCI_SEL_PCIE_GEN1_USB:
+			*gpio = 9;
+			break;
+		case MAC_AX_HCI_SEL_SDIO_UART:
+		case MAC_AX_HCI_SEL_SDIO_MULT:
+			*gpio = 15;
+			break;
+		default:
+			PLTFM_MSG_ERR("%s: Wrong HCI\n", __func__);
+			return MACNOITEM;
+		}
+	}
+#endif
+
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		switch (val) {
+		case MAC_AX_HCI_SEL_PCIE_USB:
+		case MAC_AX_HCI_SEL_PCIE_GEN1_UART:
+		case MAC_AX_HCI_SEL_PCIE_GEN1_USB:
+			*gpio = 9;
+			break;
+		case MAC_AX_HCI_SEL_SDIO_UART:
+		case MAC_AX_HCI_SEL_SDIO_MULT:
+			*gpio = 17;
+			break;
+		default:
+			PLTFM_MSG_ERR("%s: Wrong HCI\n", __func__);
+			return MACNOITEM;
+		}
+	}
+#endif
+
+#if MAC_AX_8192XB_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) {
+		switch (val) {
+		case MAC_AX_HCI_SEL_USB_MULT: /* USB */
+		case MAC_AX_HCI_SEL_PCIE_USB: /* PCIE */
+			*gpio = 9;
+			break;
+		case MAC_AX_HCI_SEL_SDIO_MULT: /* SDIO */
+			*gpio = 15;
+			break;
+		default:
+			PLTFM_MSG_ERR("%s: Wrong HCI\n", __func__);
+			return MACNOITEM;
+		}
+	}
+#endif
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_wl_dis_val(struct mac_ax_adapter *adapter, u8 *val)
+{
+	u8 gpio;
+	u32 ret;
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+
+	ret = mac_get_wl_dis_gpio(adapter, &gpio);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: Get WL_DIS GPIO fail\n", __func__);
+		return ret;
+	}
+
+	ret = ops->set_sw_gpio_mode(adapter, RTW_AX_SW_IO_MODE_INPUT, gpio);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: Set SW output mode fail\n", __func__);
+		return ret;
+	}
+
+	return ops->get_gpio_val(adapter, gpio, val);
+}
+
+u32 mac_get_uart_fw_dbg_gpio(struct mac_ax_adapter *adapter, u8 *uart_tx_gpio, u8 *uart_rx_gpio)
+{
+	if (adapter->gpio_info.uart_tx_gpio == 0xFF &&
+	    adapter->gpio_info.uart_rx_gpio == 0xFF) {
+		/* not initialized*/
+		return MACNOTSUP;
+	}
+
+	*uart_tx_gpio = adapter->gpio_info.uart_tx_gpio;
+	*uart_rx_gpio = adapter->gpio_info.uart_rx_gpio;
+
+	return MACSUCCESS;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/gpio.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/gpio.h
new file mode 100644
index 000000000000..74de059d7f57
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/gpio.h
@@ -0,0 +1,340 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_GPIO_H_
+#define _MAC_AX_GPIO_H_
+
+#include "../type.h"
+#include "gpio_cmd.h"
+
+#define DFLT_GPIO_STATE \
+	{RTW_MAC_GPIO_DFLT, RTW_MAC_GPIO_DFLT, RTW_MAC_GPIO_DFLT, \
+	 RTW_MAC_GPIO_DFLT, RTW_MAC_GPIO_DFLT, RTW_MAC_GPIO_DFLT, \
+	 RTW_MAC_GPIO_DFLT, RTW_MAC_GPIO_DFLT, RTW_MAC_GPIO_DFLT, \
+	 RTW_MAC_GPIO_DFLT, RTW_MAC_GPIO_DFLT, RTW_MAC_GPIO_DFLT, \
+	 RTW_MAC_GPIO_DFLT, RTW_MAC_GPIO_DFLT, RTW_MAC_GPIO_DFLT, \
+	 RTW_MAC_GPIO_DFLT, RTW_MAC_GPIO_DFLT, RTW_MAC_GPIO_DFLT, \
+	 RTW_MAC_GPIO_DFLT}
+
+#define DFLT_SW_IO_MODE \
+	{0, 0, 0, 0, \
+	 0, 0, 0, 0, \
+	 0, 0, 0, 0, \
+	 0, 0, 0, 0}
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+/**
+ * @brief mac_sel_uart_tx_pin
+ *
+ * @param *adapter
+ * @param uart_pin
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_sel_uart_tx_pin(struct mac_ax_adapter *adapter,
+			enum mac_ax_uart_tx_pin uart_pin);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+
+/**
+ * @brief mac_pinmux_status
+ *
+ * @param *adapter
+ * @param func
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_pinmux_status(struct mac_ax_adapter *adapter,
+		      enum mac_ax_gpio_func func);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+
+/**
+ * @brief mac_pinmux_free_func
+ *
+ * @param *adapter
+ * @param func
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_pinmux_free_func(struct mac_ax_adapter *adapter,
+			 enum mac_ax_gpio_func func);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+
+/**
+ * @brief mac_pinmux_record
+ *
+ * @param *adapter
+ * @param func
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_pinmux_record(struct mac_ax_adapter *adapter,
+		      enum mac_ax_gpio_func func, u8 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+
+/**
+ * @brief mac_pinmux_switch
+ *
+ * @param *adapter
+ * @param gpio_func
+ * @param *list
+ * @param list_size
+ * @param gpio_id
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_pinmux_switch(struct mac_ax_adapter *adapter,
+		      enum mac_ax_gpio_func gpio_func,
+		      const struct mac_ax_pinmux_list *list,
+		      u32 list_size, u32 gpio_id);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+
+/**
+ * @brief mac_sel_uart_rx_pin
+ *
+ * @param *adapter
+ * @param uart_pin
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_sel_uart_rx_pin(struct mac_ax_adapter *adapter,
+			enum mac_ax_uart_rx_pin uart_pin);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+
+/**
+ * @brief mac_set_led_mode
+ *
+ * @param *adapter
+ * @param mode
+ * @param led_id
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_led_mode(struct mac_ax_adapter *adapter,
+		     enum mac_ax_led_mode mode, u8 led_id);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+
+/**
+ * @brief mac_led_ctrl
+ *
+ * @param *adapter
+ * @param high
+ * @param led_id
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_led_ctrl(struct mac_ax_adapter *adapter,
+		 u8 high, u8 led_id);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+
+/**
+ * @brief mac_sw_gpio_ctrl
+ *
+ * @param *adapter
+ * @param high
+ * @param gpio
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_sw_gpio_ctrl(struct mac_ax_adapter *adapter,
+		     u8 high, u8 gpio);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+
+/**
+ * @brief mac_set_sw_gpio_mode
+ *
+ * @param *adapter
+ * @param mode
+ * @param gpio
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_sw_gpio_mode(struct mac_ax_adapter *adapter,
+			 enum rtw_gpio_mode mode, u8 gpio);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+
+/**
+ * @brief mac_get_gpio_status
+ *
+ * @param *adapter
+ * @param *list
+ * @return Please Place Description here.
+ * @retval  rtw_mac_gfunc
+ */
+enum rtw_mac_gfunc mac_get_gpio_status(struct mac_ax_adapter *adapter,
+				       const struct mac_ax_pin_list *list);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_wps
+ *
+ * WPS is a driver feature to detect button pressed or released.
+ * In HW view, the feature is to check the GPIO input value is 0->1 or 1->0
+ * We use FW to detect GPIO val.
+ * In a specified interval, if FW detects value changed, it will send a C2H
+ *
+ * @param *adapter
+ * @param *wps
+ * @return 0 for succcess, others for fail
+ * @retval u32
+ */
+u32 mac_cfg_wps(struct mac_ax_adapter *adapter,
+		struct mac_ax_cfg_wps *wps);
+/**
+ * @}
+ * @}
+ */
+u32 mac_get_gpio_val(struct mac_ax_adapter *adapter, u8 gpio, u8 *val);
+u32 mac_get_wl_dis_val(struct mac_ax_adapter *adapter, u8 *val);
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup GPIO
+ * @{
+ */
+
+/**
+ * @brief mac_get_uart_fw_dbg_gpio
+ *
+ * @param *adapter
+ * @param uart_tx_pin
+ * @param uart_rx_pin
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_uart_fw_dbg_gpio(struct mac_ax_adapter *adapter, u8 *uart_tx_gpio, u8 *uart_rx_gpio);
+/**
+ * @}
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/gpio_cmd.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/gpio_cmd.h
new file mode 100644
index 000000000000..41eee5c55152
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/gpio_cmd.h
@@ -0,0 +1,321 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_GPIO_CMD_H_
+#define _MAC_AX_GPIO_CMD_H_
+
+#include "../type.h"
+
+#define MAC_AX_GPIO_MIN 0
+#define RTW_MAC_GPIO_MAX 17
+
+/**
+ * @enum pinmux_name
+ *
+ * @brief pinmux_name
+ *
+ * @var pinmux_name::MAC_AX_WL_HWPDN
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BT_HWPDN
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_SWGPIO
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_WL_HW_EXTWOL
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_SIC
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BT_SFALSH
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_WL_SFALSH
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_WL_LED
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_WL_SDIO_INT
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BT_SDIO_INT
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_UART
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BT_JTAG
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_WL_JTAG
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_LTE_UART
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_LTE_3W
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BT_GPIO16
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_WL_OSC
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BT_OSC
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_GPIO13_14_WL_CTRL_EN
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BT_RF
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_DBG_GNT
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BT_3DDLS_A
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BT_3DDLS_B
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BT_GPIO18
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BT_PTA
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_WL_PTA
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_WL_UART_TX
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_WL_UART_RX
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_WLMAC_DBG
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_WLPHY_DBG
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BT_DBG
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_MAILBOX_3W
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_MAILBOX_1W
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_PAON_LNAON_2G_S0
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_RFE_WLBT_FUNC_0
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_PAON_LNAON_2G_S1
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_RFE_WLBT_FUNC_1
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_PAON_LNAON_5G_S0
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_RFE_WLBT_FUNC_2
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_PAON_LNAON_5G_S1
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_RFE_WLBT_FUNC_3
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BANDSEL_5_6G
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_RFE_WLBT_FUNC_4
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BANDSEL_5G
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_RFE_WLBT_FUNC_5
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_PAON_LNAON_6G_S1
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_RFE_WLBT_FUNC_7
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_BANDSEL_5G_G7G6
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_RFE_WLBT_FUNC_8
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_EXT_XTAL_CLK
+ * Please Place Description here.
+ * @var pinmux_name::MAC_AX_SW_IO
+ * Please Place Description here.
+ */
+enum pinmux_name {
+	MAC_AX_WL_HWPDN,
+	MAC_AX_BT_HWPDN,
+	MAC_AX_SWGPIO,
+	MAC_AX_WL_HW_EXTWOL,
+	MAC_AX_SIC,
+	MAC_AX_BT_SFALSH,
+	MAC_AX_WL_SFALSH,
+	MAC_AX_WL_LED,
+	MAC_AX_WL_SDIO_INT,
+	MAC_AX_BT_SDIO_INT,
+	MAC_AX_UART,
+	MAC_AX_BT_JTAG,
+	MAC_AX_WL_JTAG,
+	MAC_AX_LTE_UART,
+	MAC_AX_LTE_3W,
+	MAC_AX_BT_GPIO16,
+	MAC_AX_WL_OSC,
+	MAC_AX_BT_OSC,
+	MAC_AX_GPIO13_14_WL_CTRL_EN,
+	MAC_AX_BT_RF,
+	MAC_AX_DBG_GNT,
+	MAC_AX_BT_3DDLS_A,
+	MAC_AX_BT_3DDLS_B,
+	MAC_AX_BT_GPIO18,
+	MAC_AX_BT_PTA,
+	MAC_AX_WL_PTA,
+	MAC_AX_WL_UART_TX,
+	MAC_AX_WL_UART_RX,
+	MAC_AX_WLMAC_DBG,
+	MAC_AX_WLPHY_DBG,
+	MAC_AX_BT_DBG,
+	MAC_AX_MAILBOX_3W,
+	MAC_AX_MAILBOX_1W,
+	MAC_AX_PAON_LNAON_2G_S0,
+	MAC_AX_RFE_WLBT_FUNC_0,
+	MAC_AX_PAON_LNAON_2G_S1,
+	MAC_AX_RFE_WLBT_FUNC_1,
+	MAC_AX_PAON_LNAON_5G_S0,
+	MAC_AX_RFE_WLBT_FUNC_2,
+	MAC_AX_PAON_LNAON_5G_S1,
+	MAC_AX_RFE_WLBT_FUNC_3,
+	MAC_AX_BANDSEL_5_6G,
+	MAC_AX_RFE_WLBT_FUNC_4,
+	MAC_AX_BANDSEL_5G,
+	MAC_AX_RFE_WLBT_FUNC_5,
+	MAC_AX_PAON_LNAON_6G_S1,
+	MAC_AX_RFE_WLBT_FUNC_7,
+	MAC_AX_BANDSEL_5G_G7G6,
+	MAC_AX_RFE_WLBT_FUNC_8,
+	MAC_AX_EXT_XTAL_CLK,
+	MAC_AX_SW_IO,
+};
+
+/**
+ * @enum pinmux_gpio
+ *
+ * @brief pinmux_gpio
+ *
+ * @var pinmux_gpio::MAC_AX_GPIO0
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO1
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO2
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO3
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO4
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO5
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO6
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO7
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO8
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO9
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO10
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO11
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO12
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO13
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO14
+ * Please Place Description here.
+ * @var pinmux_gpio::MAC_AX_GPIO15
+ * Please Place Description here.
+ */
+enum pinmux_gpio {
+	MAC_AX_GPIO0,
+	MAC_AX_GPIO1,
+	MAC_AX_GPIO2,
+	MAC_AX_GPIO3,
+	MAC_AX_GPIO4,
+	MAC_AX_GPIO5,
+	MAC_AX_GPIO6,
+	MAC_AX_GPIO7,
+	MAC_AX_GPIO8,
+	MAC_AX_GPIO9,
+	MAC_AX_GPIO10,
+	MAC_AX_GPIO11,
+	MAC_AX_GPIO12,
+	MAC_AX_GPIO13,
+	MAC_AX_GPIO14,
+	MAC_AX_GPIO15,
+};
+
+/**
+ * @enum pinmux_gpio_type
+ *
+ * @brief pinmux_gpio_type
+ *
+ * @var pinmux_gpio_type::MAC_AX_GPIO_IN
+ * Please Place Description here.
+ * @var pinmux_gpio_type::MAC_AX_GPIO_OUT
+ * Please Place Description here.
+ * @var pinmux_gpio_type::MAC_AX_GPIO_IN_OUT
+ * Please Place Description here.
+ */
+enum pinmux_gpio_type {
+	MAC_AX_GPIO_IN,
+	MAC_AX_GPIO_OUT,
+	MAC_AX_GPIO_IN_OUT,
+};
+
+/**
+ * @struct mac_ax_pinmux_list
+ * @brief mac_ax_pinmux_list
+ *
+ * @var mac_ax_pinmux_list::func
+ * Please Place Description here.
+ * @var mac_ax_pinmux_list::id
+ * Please Place Description here.
+ * @var mac_ax_pinmux_list::type
+ * Please Place Description here.
+ * @var mac_ax_pinmux_list::offset
+ * Please Place Description here.
+ * @var mac_ax_pinmux_list::msk
+ * Please Place Description here.
+ * @var mac_ax_pinmux_list::value
+ * Please Place Description here.
+ */
+struct mac_ax_pinmux_list {
+	enum pinmux_name func;
+	enum pinmux_gpio id;
+	enum pinmux_gpio_type type;
+	u32 offset;
+	u8 msk;
+	u8 value;
+};
+
+/**
+ * @struct mac_ax_pin_list
+ * @brief mac_ax_pin_list
+ *
+ * @var mac_ax_pin_list::func
+ * Please Place Description here.
+ * @var mac_ax_pin_list::offset
+ * Please Place Description here.
+ * @var mac_ax_pin_list::msk
+ * Please Place Description here.
+ * @var mac_ax_pin_list::value
+ * Please Place Description here.
+ */
+struct mac_ax_pin_list {
+	enum rtw_mac_gfunc func;
+	u32 offset;
+	u8 msk;
+	u8 value;
+};
+
+/**
+ * @struct mac_ax_gpio_func_list
+ * @brief mac_ax_gpio_func_list
+ *
+ * @var mac_ax_gpio_func_list::func
+ * Please Place Description here.
+ * @var mac_ax_gpio_func_list::list
+ * Please Place Description here.
+ */
+struct mac_ax_gpio_func_list {
+	enum rtw_mac_gfunc func;
+	struct mac_ax_pin_list *list;
+};
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/h2c_agg.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/h2c_agg.c
new file mode 100644
index 000000000000..8bbad04d4513
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/h2c_agg.c
@@ -0,0 +1,243 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2020 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+#include "h2c_agg.h"
+
+static u32 mac_h2c_agg_tx_single_normal_h2c(struct mac_ax_adapter *adapter, u8 *h2cb)
+{
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *tx_h2cb = (struct rtw_h2c_pkt *)h2cb;
+#else
+	struct h2c_buf *tx_h2cb = (struct h2c_buf *)h2cb;
+#endif
+	u32 ret = MACSUCCESS;
+
+	ret = h2c_pkt_build_txd(adapter, tx_h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(tx_h2cb);
+#else
+	ret = PLTFM_TX(tx_h2cb->data, tx_h2cb->len);
+	if (ret)
+		goto fail;
+	h2cb_free(adapter, tx_h2cb);
+#endif
+
+fail:
+	return ret;
+}
+
+static u32 mac_h2c_agg_tx_single_agg_h2c(struct mac_ax_adapter *adapter, u8 *agg_h2cb)
+{
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *tx_h2cb = (struct rtw_h2c_pkt *)agg_h2cb;
+#else
+	struct h2c_buf *tx_h2cb = (struct h2c_buf *)agg_h2cb;
+#endif
+	u32 ret = MACSUCCESS;
+
+	ret = h2c_pkt_set_hdr(adapter,
+			      tx_h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_H2C_AGG,
+			      0,
+			      0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, tx_h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(tx_h2cb);
+#else
+	ret = PLTFM_TX(tx_h2cb->data, tx_h2cb->len);
+	if (ret)
+		goto fail;
+	h2cb_free(adapter, tx_h2cb);
+#endif
+
+fail:
+	return ret;
+}
+
+void mac_h2c_agg_enable(struct mac_ax_adapter *adapter, u8 enable)
+{
+	PLTFM_MUTEX_LOCK(&adapter->h2c_agg_info.h2c_agg_lock);
+	adapter->h2c_agg_info.h2c_agg_en = enable;
+	PLTFM_MUTEX_UNLOCK(&adapter->h2c_agg_info.h2c_agg_lock);
+}
+
+u32 mac_h2c_agg_tx(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *agg_h2cb = NULL;
+	struct rtw_h2c_pkt *cur_h2cb = NULL;
+#else
+	struct h2c_buf *agg_h2cb = NULL;
+	struct h2c_buf *cur_h2cb = NULL;
+#endif
+	struct mac_ax_h2c_agg_node *cur_agg_node = NULL;
+	struct mac_ax_h2c_agg_node *tmp_agg_node = NULL;
+	u32 agg_len = 0;
+	u32 cur_h2cb_len = 0;
+	u32 cur_sub_h2c_len = 0;
+	u32 cur_sub_h2c_len_swap = 0;
+	u32 next_h2cb_len = 0;
+	u32 ret = MACSUCCESS;
+	u8 *cur_h2cb_data = NULL;
+	u8 *buf = NULL;
+
+	PLTFM_MUTEX_LOCK(&adapter->h2c_agg_info.h2c_agg_lock);
+
+	if (!adapter->h2c_agg_info.h2c_agg_queue_head)
+		goto fail;
+
+	cur_agg_node = adapter->h2c_agg_info.h2c_agg_queue_head;
+	agg_h2cb = NULL;
+	agg_len = 0;
+
+	while (cur_agg_node) {
+#if MAC_AX_PHL_H2C
+		cur_h2cb = (struct rtw_h2c_pkt *)cur_agg_node->h2c_pkt;
+		cur_h2cb_len = cur_h2cb->data_len;
+		cur_h2cb_data = cur_h2cb->vir_data;
+		next_h2cb_len = (!cur_agg_node->next ? 0 :
+						((struct rtw_h2c_pkt *)
+						(cur_agg_node->next->h2c_pkt))->data_len);
+#else
+		cur_h2cb = (struct h2c_buf *)cur_agg_node->h2c_pkt;
+		cur_h2cb_len = cur_h2cb->len;
+		cur_h2cb_data = cur_h2cb->data;
+		next_h2cb_len = (!cur_agg_node->next ? 0 :
+						((struct h2c_buf *)
+						(cur_agg_node->next->h2c_pkt))->len);
+#endif
+
+		if (!agg_h2cb) {
+			if (!H2C_PKT_AGGREGATABLE(cur_h2cb_len) ||
+			    !cur_agg_node->next ||
+			    (cur_agg_node->next &&
+			    !H2C_PKT_AGGREGATABLE(next_h2cb_len))) {
+				ret = mac_h2c_agg_tx_single_normal_h2c(adapter, (u8 *)cur_h2cb);
+				if (ret) {
+					PLTFM_MSG_ERR("tx normal h2c pkt fail\n");
+					goto fail;
+				}
+
+				tmp_agg_node = cur_agg_node;
+				cur_agg_node = cur_agg_node->next;
+				adapter->h2c_agg_info.h2c_agg_queue_head = cur_agg_node;
+				PLTFM_FREE(tmp_agg_node, sizeof(struct mac_ax_h2c_agg_node));
+				continue;
+			}
+
+			agg_h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+			if (!agg_h2cb) {
+				PLTFM_MSG_ERR("allocate agg_h2c fail\n");
+				ret = MACNOBUF;
+				goto fail;
+			}
+			agg_len = WD_BODY_LEN + FWCMD_HDR_LEN;
+		}
+
+		cur_sub_h2c_len = ALIGN_4_BYTE(cur_h2cb_len);
+
+		buf = h2cb_put(agg_h2cb, cur_sub_h2c_len + H2C_AGG_SUB_HDR_LEN);
+		if (!buf) {
+			PLTFM_MSG_ERR("creat sub_h2c_buf in agg_h2cb get fail\n");
+			ret = MACNOITEM;
+			goto fail;
+		}
+
+		cur_sub_h2c_len_swap = cpu_to_le32(cur_sub_h2c_len);
+		PLTFM_MEMCPY(buf, &cur_sub_h2c_len_swap, H2C_AGG_SUB_HDR_LEN);
+		PLTFM_MEMCPY(buf + H2C_AGG_SUB_HDR_LEN, cur_h2cb_data, cur_h2cb_len);
+		agg_len = agg_len + cur_sub_h2c_len + H2C_AGG_SUB_HDR_LEN;
+
+		tmp_agg_node = cur_agg_node;
+		cur_agg_node = cur_agg_node->next;
+		adapter->h2c_agg_info.h2c_agg_queue_head = cur_agg_node;
+		PLTFM_FREE(tmp_agg_node, sizeof(struct mac_ax_h2c_agg_node));
+
+#if MAC_AX_PHL_H2C
+		PLTFM_RECYCLE_H2C(cur_h2cb);
+#else
+		h2cb_free(adapter, cur_h2cb);
+#endif
+
+		if (!cur_agg_node ||
+		    ((agg_len + ALIGN_4_BYTE(next_h2cb_len) +
+		    H2C_AGG_SUB_HDR_LEN) >= H2C_LONG_DATA_LEN)) {
+			ret = mac_h2c_agg_tx_single_agg_h2c(adapter, (u8 *)agg_h2cb);
+			if (ret) {
+				PLTFM_MSG_ERR("tx normal agg_h2c pkt fail\n");
+				goto fail;
+			}
+			agg_h2cb = NULL;
+			agg_len = 0;
+		}
+	}
+
+fail:
+	if (ret) {
+		PLTFM_MSG_ERR("h2c agg error handle\n");
+
+		mac_h2c_agg_flush(adapter);
+
+		if (agg_h2cb) {
+#if MAC_AX_PHL_H2C
+			PLTFM_RECYCLE_H2C((struct rtw_h2c_pkt *)agg_h2cb);
+#else
+			h2cb_free(adapter, agg_h2cb);
+#endif
+		}
+	} else {
+		adapter->h2c_agg_info.h2c_agg_queue_head = NULL;
+		adapter->h2c_agg_info.h2c_agg_queue_last = NULL;
+		adapter->h2c_agg_info.h2c_agg_pkt_num = 0;
+	}
+	PLTFM_MUTEX_UNLOCK(&adapter->h2c_agg_info.h2c_agg_lock);
+	return ret;
+}
+
+void mac_h2c_agg_flush(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_h2c_agg_node *cur_agg_node = NULL;
+	struct mac_ax_h2c_agg_node *tmp_agg_node = NULL;
+
+	PLTFM_MUTEX_LOCK(&adapter->h2c_agg_info.h2c_agg_lock);
+	cur_agg_node = adapter->h2c_agg_info.h2c_agg_queue_head;
+
+	while (cur_agg_node) {
+#if MAC_AX_PHL_H2C
+		PLTFM_RECYCLE_H2C((struct rtw_h2c_pkt *)cur_agg_node->h2c_pkt);
+#else
+		h2cb_free(adapter, (struct h2c_buf *)cur_agg_node->h2c_pkt);
+#endif
+		tmp_agg_node = cur_agg_node;
+		cur_agg_node = cur_agg_node->next;
+		PLTFM_FREE(tmp_agg_node, sizeof(struct mac_ax_h2c_agg_node));
+	}
+
+	adapter->h2c_agg_info.h2c_agg_queue_head = NULL;
+	adapter->h2c_agg_info.h2c_agg_queue_last = NULL;
+	adapter->h2c_agg_info.h2c_agg_pkt_num = 0;
+	PLTFM_MUTEX_UNLOCK(&adapter->h2c_agg_info.h2c_agg_lock);
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/h2c_agg.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/h2c_agg.h
new file mode 100644
index 000000000000..e036844796d4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/h2c_agg.h
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2017 Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *****************************************************************************/
+#ifndef _H2C_AGG_H_
+#define _H2C_AGG_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+#include "../fw_ax/inc_hdr/fwcmd_intf.h"
+
+#define ALIGN_4_BYTE(len) ((len + 0x3) & ~(0x3))
+#define H2C_AGG_SUB_HDR_LEN sizeof(u32)
+#define H2C_PKT_AGGREGATABLE(len) ((ALIGN_4_BYTE(len) + \
+								   WD_BODY_LEN + FWCMD_HDR_LEN + \
+								   H2C_AGG_SUB_HDR_LEN) \
+								  < H2C_LONG_DATA_LEN)
+
+void mac_h2c_agg_flush(struct mac_ax_adapter *adapter);
+u32 mac_h2c_agg_tx(struct mac_ax_adapter *adapter);
+void mac_h2c_agg_enable(struct mac_ax_adapter *adapter, u8 enable);
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hci_fc.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hci_fc.c
new file mode 100644
index 000000000000..8daa882c05bc
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hci_fc.c
@@ -0,0 +1,2427 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "hci_fc.h"
+#include "mac_priv.h"
+
+static u32 chcfg_size = sizeof(struct mac_ax_hfc_ch_cfg) * MAC_AX_DMA_CH_NUM;
+
+static u32 chinfo_size = sizeof(struct mac_ax_hfc_ch_info) * MAC_AX_DMA_CH_NUM;
+
+#if MAC_AX_PCIE_SUPPORT
+#ifdef PHL_FEATURE_AP
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_8852a[] = {
+	{16, 3712, grp_0}, /* ACH 0 */
+	{16, 3712, grp_0}, /* ACH 1 */
+	{16, 3712, grp_0}, /* ACH 2 */
+	{16, 3712, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{16, 3712, grp_0}, /* B0MGQ */
+	{16, 3712, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+#else // for NiC mode use
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_8852a[] = {
+	{16, 3276, grp_0}, /* ACH 0 */
+	{16, 3276, grp_0}, /* ACH 1 */
+	{16, 3276, grp_0}, /* ACH 2 */
+	{16, 3276, grp_0}, /* ACH 3 */
+	{8, 3284, grp_0}, /* ACH 4 */
+	{8, 3284, grp_0}, /* ACH 5 */
+	{8, 3284, grp_0}, /* ACH 6 */
+	{8, 3284, grp_0}, /* ACH 7 */
+	{16, 3276, grp_0}, /* B0MGQ */
+	{16, 3276, grp_0}, /* B0HIQ */
+	{8, 3284, grp_0}, /* B1MGQ */
+	{8, 3284, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+#endif
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_8852b[] = {
+	{5, 341, grp_0}, /* ACH 0 */
+	{5, 341, grp_0}, /* ACH 1 */
+	{4, 342, grp_0}, /* ACH 2 */
+	{4, 342, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{4, 342, grp_0}, /* B0MGQ */
+	{4, 342, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_8852b_turbo[] = {
+	{16, 742, grp_0}, /* ACH 0 */
+	{16, 742, grp_0}, /* ACH 1 */
+	{16, 742, grp_0}, /* ACH 2 */
+	{16, 742, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{15, 743, grp_0}, /* B0MGQ */
+	{15, 743, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_8851b[] = {
+	{5, 343, grp_0}, /* ACH 0 */
+	{5, 343, grp_0}, /* ACH 1 */
+	{5, 343, grp_0}, /* ACH 2 */
+	{5, 343, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{4, 344, grp_0}, /* B0MGQ */
+	{4, 344, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_8851b_turbo[] = {
+	{16, 742, grp_0}, /* ACH 0 */
+	{16, 742, grp_0}, /* ACH 1 */
+	{16, 742, grp_0}, /* ACH 2 */
+	{16, 742, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{15, 743, grp_0}, /* B0MGQ */
+	{15, 743, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+#ifdef PHL_FEATURE_AP
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_scc_8852c[] = {
+	{26, 3098, grp_0}, /* ACH 0 */
+	{26, 3098, grp_0}, /* ACH 1 */
+	{26, 3098, grp_0}, /* ACH 2 */
+	{26, 3098, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{26, 3098, grp_0}, /* B0MGQ */
+	{26, 3098, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_scc_8851e[] = {
+	{26, 3098, grp_0}, /* ACH 0 */
+	{26, 3098, grp_0}, /* ACH 1 */
+	{26, 3098, grp_0}, /* ACH 2 */
+	{26, 3098, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{26, 3098, grp_0}, /* B0MGQ */
+	{26, 3098, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_scc_8852d[] = {
+	{26, 3098, grp_0}, /* ACH 0 */
+	{26, 3098, grp_0}, /* ACH 1 */
+	{26, 3098, grp_0}, /* ACH 2 */
+	{26, 3098, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{26, 3098, grp_0}, /* B0MGQ */
+	{26, 3098, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+#else // for NiC mode use
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_scc_8852c[] = {
+	{13, 1614, grp_0}, /* ACH 0 */
+	{13, 1614, grp_0}, /* ACH 1 */
+	{13, 1614, grp_0}, /* ACH 2 */
+	{13, 1614, grp_0}, /* ACH 3 */
+	{13, 1614, grp_1}, /* ACH 4 */
+	{13, 1614, grp_1}, /* ACH 5 */
+	{13, 1614, grp_1}, /* ACH 6 */
+	{13, 1614, grp_1}, /* ACH 7 */
+	{13, 1614, grp_0}, /* B0MGQ */
+	{13, 1614, grp_0}, /* B0HIQ */
+	{13, 1614, grp_1}, /* B1MGQ */
+	{13, 1614, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_scc_8851e[] = {
+	{13, 1614, grp_0}, /* ACH 0 */
+	{13, 1614, grp_0}, /* ACH 1 */
+	{13, 1614, grp_0}, /* ACH 2 */
+	{13, 1614, grp_0}, /* ACH 3 */
+	{13, 1614, grp_1}, /* ACH 4 */
+	{13, 1614, grp_1}, /* ACH 5 */
+	{13, 1614, grp_1}, /* ACH 6 */
+	{13, 1614, grp_1}, /* ACH 7 */
+	{13, 1614, grp_0}, /* B0MGQ */
+	{13, 1614, grp_0}, /* B0HIQ */
+	{13, 1614, grp_1}, /* B1MGQ */
+	{13, 1614, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_scc_8852d[] = {
+	{13, 1614, grp_0}, /* ACH 0 */
+	{13, 1614, grp_0}, /* ACH 1 */
+	{13, 1614, grp_0}, /* ACH 2 */
+	{13, 1614, grp_0}, /* ACH 3 */
+	{13, 1614, grp_1}, /* ACH 4 */
+	{13, 1614, grp_1}, /* ACH 5 */
+	{13, 1614, grp_1}, /* ACH 6 */
+	{13, 1614, grp_1}, /* ACH 7 */
+	{13, 1614, grp_0}, /* B0MGQ */
+	{13, 1614, grp_0}, /* B0HIQ */
+	{13, 1614, grp_1}, /* B1MGQ */
+	{13, 1614, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+#endif
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_dbcc_8852c[] = {
+	{12, 1609, grp_0}, /* ACH 0 */
+	{12, 1609, grp_0}, /* ACH 1 */
+	{12, 1609, grp_0}, /* ACH 2 */
+	{12, 1609, grp_0}, /* ACH 3 */
+	{12, 1609, grp_1}, /* ACH 4 */
+	{12, 1609, grp_1}, /* ACH 5 */
+	{12, 1609, grp_1}, /* ACH 6 */
+	{12, 1609, grp_1}, /* ACH 7 */
+	{12, 1609, grp_0}, /* B0MGQ */
+	{12, 1609, grp_0}, /* B0HIQ */
+	{12, 1609, grp_1}, /* B1MGQ */
+	{12, 1609, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_dbcc_8851e[] = {
+	{12, 1609, grp_0}, /* ACH 0 */
+	{12, 1609, grp_0}, /* ACH 1 */
+	{12, 1609, grp_0}, /* ACH 2 */
+	{12, 1609, grp_0}, /* ACH 3 */
+	{12, 1609, grp_1}, /* ACH 4 */
+	{12, 1609, grp_1}, /* ACH 5 */
+	{12, 1609, grp_1}, /* ACH 6 */
+	{12, 1609, grp_1}, /* ACH 7 */
+	{12, 1609, grp_0}, /* B0MGQ */
+	{12, 1609, grp_0}, /* B0HIQ */
+	{12, 1609, grp_1}, /* B1MGQ */
+	{12, 1609, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_dbcc_8852d[] = {
+	{12, 1609, grp_0}, /* ACH 0 */
+	{12, 1609, grp_0}, /* ACH 1 */
+	{12, 1609, grp_0}, /* ACH 2 */
+	{12, 1609, grp_0}, /* ACH 3 */
+	{12, 1609, grp_1}, /* ACH 4 */
+	{12, 1609, grp_1}, /* ACH 5 */
+	{12, 1609, grp_1}, /* ACH 6 */
+	{12, 1609, grp_1}, /* ACH 7 */
+	{12, 1609, grp_0}, /* B0MGQ */
+	{12, 1609, grp_0}, /* B0HIQ */
+	{12, 1609, grp_1}, /* B1MGQ */
+	{12, 1609, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_scc_8192xb[] = {
+	{26, 3098, grp_0}, /* ACH 0 */
+	{26, 3098, grp_0}, /* ACH 1 */
+	{26, 3098, grp_0}, /* ACH 2 */
+	{26, 3098, grp_0}, /* ACH 3 */
+	{0, 0, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{0, 0, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{26, 3098, grp_0}, /* B0MGQ */
+	{26, 3098, grp_0}, /* B0HIQ */
+	{0, 0, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_wd128_8852b[] = {
+	{256, 1792, grp_0}, /* ACH 0 */
+	{256, 1792, grp_0}, /* ACH 1 */
+	{256, 1792, grp_0}, /* ACH 2 */
+	{256, 1792, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{256, 1792, grp_0}, /* B0MGQ */
+	{256, 1792, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_wd128_8851b[] = {
+	{256, 1792, grp_0}, /* ACH 0 */
+	{256, 1792, grp_0}, /* ACH 1 */
+	{256, 1792, grp_0}, /* ACH 2 */
+	{256, 1792, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{256, 1792, grp_0}, /* B0MGQ */
+	{256, 1792, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_stf_8852a[] = {
+	{8, 256, grp_0}, /* ACH 0 */
+	{8, 256, grp_0}, /* ACH 1 */
+	{8, 256, grp_0}, /* ACH 2 */
+	{8, 256, grp_0}, /* ACH 3 */
+	{8, 256, grp_1}, /* ACH 4 */
+	{8, 256, grp_1}, /* ACH 5 */
+	{8, 256, grp_1}, /* ACH 6 */
+	{8, 256, grp_1}, /* ACH 7 */
+	{8, 256, grp_0}, /* B0MGQ */
+	{8, 256, grp_0}, /* B0HIQ */
+	{8, 256, grp_1}, /* B1MGQ */
+	{8, 256, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_stf_8852b[] = {
+	{27, 204, grp_0}, /* ACH 0 */
+	{27, 204, grp_0}, /* ACH 1 */
+	{27, 204, grp_0}, /* ACH 2 */
+	{27, 204, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{11, 204, grp_0}, /* B0MGQ */
+	{11, 204, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_stf_8851b[] = {
+	{27, 204, grp_0}, /* ACH 0 */
+	{27, 204, grp_0}, /* ACH 1 */
+	{27, 204, grp_0}, /* ACH 2 */
+	{27, 204, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{11, 204, grp_0}, /* B0MGQ */
+	{11, 204, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_scc_stf_8852c[] = {
+	{2, 108, grp_0}, /* ACH 0 */
+	{2, 108, grp_0}, /* ACH 1 */
+	{2, 108, grp_0}, /* ACH 2 */
+	{2, 108, grp_0}, /* ACH 3 */
+	{2, 108, grp_1}, /* ACH 4 */
+	{2, 108, grp_1}, /* ACH 5 */
+	{2, 108, grp_1}, /* ACH 6 */
+	{2, 108, grp_1}, /* ACH 7 */
+	{2, 108, grp_0}, /* B0MGQ */
+	{2, 108, grp_0}, /* B0HIQ */
+	{2, 108, grp_1}, /* B1MGQ */
+	{2, 108, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_scc_stf_8851e[] = {
+	{2, 108, grp_0}, /* ACH 0 */
+	{2, 108, grp_0}, /* ACH 1 */
+	{2, 108, grp_0}, /* ACH 2 */
+	{2, 108, grp_0}, /* ACH 3 */
+	{2, 108, grp_1}, /* ACH 4 */
+	{2, 108, grp_1}, /* ACH 5 */
+	{2, 108, grp_1}, /* ACH 6 */
+	{2, 108, grp_1}, /* ACH 7 */
+	{2, 108, grp_0}, /* B0MGQ */
+	{2, 108, grp_0}, /* B0HIQ */
+	{2, 108, grp_1}, /* B1MGQ */
+	{2, 108, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_scc_stf_8852d[] = {
+	{2, 108, grp_0}, /* ACH 0 */
+	{2, 108, grp_0}, /* ACH 1 */
+	{2, 108, grp_0}, /* ACH 2 */
+	{2, 108, grp_0}, /* ACH 3 */
+	{2, 108, grp_1}, /* ACH 4 */
+	{2, 108, grp_1}, /* ACH 5 */
+	{2, 108, grp_1}, /* ACH 6 */
+	{2, 108, grp_1}, /* ACH 7 */
+	{2, 108, grp_0}, /* B0MGQ */
+	{2, 108, grp_0}, /* B0HIQ */
+	{2, 108, grp_1}, /* B1MGQ */
+	{2, 108, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_dbcc_stf_8852c[] = {
+	{2, 76, grp_0}, /* ACH 0 */
+	{2, 76, grp_0}, /* ACH 1 */
+	{2, 76, grp_0}, /* ACH 2 */
+	{2, 76, grp_0}, /* ACH 3 */
+	{2, 76, grp_1}, /* ACH 4 */
+	{2, 76, grp_1}, /* ACH 5 */
+	{2, 76, grp_1}, /* ACH 6 */
+	{2, 76, grp_1}, /* ACH 7 */
+	{2, 76, grp_0}, /* B0MGQ */
+	{2, 76, grp_0}, /* B0HIQ */
+	{2, 76, grp_1}, /* B1MGQ */
+	{2, 76, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_dbcc_stf_8851e[] = {
+	{2, 76, grp_0}, /* ACH 0 */
+	{2, 76, grp_0}, /* ACH 1 */
+	{2, 76, grp_0}, /* ACH 2 */
+	{2, 76, grp_0}, /* ACH 3 */
+	{2, 76, grp_1}, /* ACH 4 */
+	{2, 76, grp_1}, /* ACH 5 */
+	{2, 76, grp_1}, /* ACH 6 */
+	{2, 76, grp_1}, /* ACH 7 */
+	{2, 76, grp_0}, /* B0MGQ */
+	{2, 76, grp_0}, /* B0HIQ */
+	{2, 76, grp_1}, /* B1MGQ */
+	{2, 76, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_dbcc_stf_8852d[] = {
+	{2, 76, grp_0}, /* ACH 0 */
+	{2, 76, grp_0}, /* ACH 1 */
+	{2, 76, grp_0}, /* ACH 2 */
+	{2, 76, grp_0}, /* ACH 3 */
+	{2, 76, grp_1}, /* ACH 4 */
+	{2, 76, grp_1}, /* ACH 5 */
+	{2, 76, grp_1}, /* ACH 6 */
+	{2, 76, grp_1}, /* ACH 7 */
+	{2, 76, grp_0}, /* B0MGQ */
+	{2, 76, grp_0}, /* B0HIQ */
+	{2, 76, grp_1}, /* B1MGQ */
+	{2, 76, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_scc_stf_8192xb[] = {
+	{4, 216, grp_0}, /* ACH 0 */
+	{4, 216, grp_0}, /* ACH 1 */
+	{4, 216, grp_0}, /* ACH 2 */
+	{4, 216, grp_0}, /* ACH 3 */
+	{0, 0, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{0, 0, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{2, 108, grp_0}, /* B0MGQ */
+	{2, 108, grp_0}, /* B0HIQ */
+	{4, 216, grp_1}, /* B1MGQ */
+	{4, 216, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_sutp_8852a[] = {
+	{128, 256, grp_0}, /* ACH 0 */
+	{0, 0, grp_1}, /* ACH 1 */
+	{0, 0, grp_1}, /* ACH 2 */
+	{0, 0, grp_1}, /* ACH 3 */
+	{0, 0, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{0, 0, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{0, 0, grp_1}, /* B0MGQ */
+	{0, 0, grp_1}, /* B0HIQ */
+	{0, 0, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_bcn_test_8852a[] = {
+	{128, 1833, grp_0}, /* ACH 0 */
+	{128, 1833, grp_0}, /* ACH 1 */
+	{128, 1833, grp_0}, /* ACH 2 */
+	{128, 1833, grp_0}, /* ACH 3 */
+	{128, 1833, grp_1}, /* ACH 4 */
+	{128, 1833, grp_1}, /* ACH 5 */
+	{128, 1833, grp_1}, /* ACH 6 */
+	{128, 1833, grp_1}, /* ACH 7 */
+	{32, 1833, grp_0}, /* B0MGQ */
+	{128, 1833, grp_0}, /* B0HIQ */
+	{32, 1833, grp_1}, /* B1MGQ */
+	{128, 1833, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_la_8852a[] = {
+	{64, 586, grp_0}, /* ACH 0 */
+	{64, 586, grp_0}, /* ACH 1 */
+	{64, 586, grp_0}, /* ACH 2 */
+	{64, 586, grp_0}, /* ACH 3 */
+	{64, 586, grp_1}, /* ACH 4 */
+	{64, 586, grp_1}, /* ACH 5 */
+	{64, 586, grp_1}, /* ACH 6 */
+	{64, 586, grp_1}, /* ACH 7 */
+	{32, 586, grp_0}, /* B0MGQ */
+	{64, 586, grp_0}, /* B0HIQ */
+	{32, 586, grp_1}, /* B1MGQ */
+	{64, 586, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_la_8852b[] = {
+	{10, 200, grp_0}, /* ACH 0 */
+	{10, 200, grp_0}, /* ACH 1 */
+	{10, 200, grp_0}, /* ACH 2 */
+	{10, 200, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{4, 200, grp_0}, /* B0MGQ */
+	{4, 200, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_la_8851b[] = {
+	{10, 200, grp_0}, /* ACH 0 */
+	{10, 200, grp_0}, /* ACH 1 */
+	{10, 200, grp_0}, /* ACH 2 */
+	{10, 200, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{4, 200, grp_0}, /* B0MGQ */
+	{4, 200, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_la_8852c[] = {
+	{64, 586, grp_0}, /* ACH 0 */
+	{64, 586, grp_0}, /* ACH 1 */
+	{64, 586, grp_0}, /* ACH 2 */
+	{64, 586, grp_0}, /* ACH 3 */
+	{64, 586, grp_1}, /* ACH 4 */
+	{64, 586, grp_1}, /* ACH 5 */
+	{64, 586, grp_1}, /* ACH 6 */
+	{64, 586, grp_1}, /* ACH 7 */
+	{32, 586, grp_0}, /* B0MGQ */
+	{64, 586, grp_0}, /* B0HIQ */
+	{32, 586, grp_1}, /* B1MGQ */
+	{64, 586, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_la_8851e[] = {
+	{64, 586, grp_0}, /* ACH 0 */
+	{64, 586, grp_0}, /* ACH 1 */
+	{64, 586, grp_0}, /* ACH 2 */
+	{64, 586, grp_0}, /* ACH 3 */
+	{64, 586, grp_1}, /* ACH 4 */
+	{64, 586, grp_1}, /* ACH 5 */
+	{64, 586, grp_1}, /* ACH 6 */
+	{64, 586, grp_1}, /* ACH 7 */
+	{32, 586, grp_0}, /* B0MGQ */
+	{64, 586, grp_0}, /* B0HIQ */
+	{32, 586, grp_1}, /* B1MGQ */
+	{64, 586, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_la_8852d[] = {
+	{64, 586, grp_0}, /* ACH 0 */
+	{64, 586, grp_0}, /* ACH 1 */
+	{64, 586, grp_0}, /* ACH 2 */
+	{64, 586, grp_0}, /* ACH 3 */
+	{64, 586, grp_1}, /* ACH 4 */
+	{64, 586, grp_1}, /* ACH 5 */
+	{64, 586, grp_1}, /* ACH 6 */
+	{64, 586, grp_1}, /* ACH 7 */
+	{32, 586, grp_0}, /* B0MGQ */
+	{64, 586, grp_0}, /* B0HIQ */
+	{32, 586, grp_1}, /* B1MGQ */
+	{64, 586, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_pcie_la_8192xb[] = {
+	{64, 1172, grp_0}, /* ACH 0 */
+	{64, 1172, grp_0}, /* ACH 1 */
+	{64, 1172, grp_0}, /* ACH 2 */
+	{64, 1172, grp_0}, /* ACH 3 */
+	{0, 0, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{0, 0, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{32, 1172, grp_0}, /* B0MGQ */
+	{64, 1172, grp_0}, /* B0HIQ */
+	{0, 0, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* FWCMDQ */
+};
+
+#ifdef PHL_FEATURE_AP
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_8852a = {
+	3792, /* Group 0 */
+	0, /* Group 1 */
+	3792, /* Public Max */
+	0 /* WP threshold */
+};
+#else //for nic mode use
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_8852a = {
+	3792, /* Group 0 */
+	0, /* Group 1 */
+	3792, /* Public Max */
+	0 /* WP threshold */
+};
+#endif
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_8852b = {
+	446, /* Group 0 */
+	0, /* Group 1 */
+	446, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_8852b_turbo = {
+	958, /* Group 0 */
+	0, /* Group 1 */
+	958, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_8851b = {
+	448, /* Group 0 */
+	0, /* Group 1 */
+	448, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_8851b_turbo = {
+	958, /* Group 0 */
+	0, /* Group 1 */
+	958, /* Public Max */
+	0 /* WP threshold */
+};
+
+#ifdef PHL_FEATURE_AP
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_scc_8852c = {
+	3228, /* Group 0 */
+	0, /* Group 1 */
+	3228, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_scc_8851e = {
+	3228, /* Group 0 */
+	0, /* Group 1 */
+	3228, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_scc_8852d = {
+	3228, /* Group 0 */
+	0, /* Group 1 */
+	3228, /* Public Max */
+	0 /* WP threshold */
+};
+#else //for nic mode use
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_scc_8852c = {
+	1614, /* Group 0 */
+	1614, /* Group 1 */
+	3228, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_scc_8851e = {
+	1614, /* Group 0 */
+	1614, /* Group 1 */
+	3228, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_scc_8852d = {
+	1614, /* Group 0 */
+	1614, /* Group 1 */
+	3228, /* Public Max */
+	0 /* WP threshold */
+};
+#endif
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_dbcc_8852c = {
+	1609, /* Group 0 */
+	1609, /* Group 1 */
+	3218, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_dbcc_8851e = {
+	1609, /* Group 0 */
+	1609, /* Group 1 */
+	3218, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_dbcc_8852d = {
+	1609, /* Group 0 */
+	1609, /* Group 1 */
+	3218, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_scc_8192xb = {
+	3228, /* Group 0 */
+	0, /* Group 1 */
+	3228, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_wd128_8852b = {
+	1792, /* Group 0 */
+	0, /* Group 1 */
+	1792, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_wd128_8851b = {
+	1792, /* Group 0 */
+	0, /* Group 1 */
+	1792, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_stf_8852a = {
+	256, /* Group 0 */
+	256, /* Group 1 */
+	512, /* Public Max */
+	104 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_stf_8852b = {
+	204, /* Group 0 */
+	0, /* Group 1 */
+	204, /* Public Max */
+	104 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_stf_8851b = {
+	204, /* Group 0 */
+	0, /* Group 1 */
+	204, /* Public Max */
+	104 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_scc_stf_8852c = {
+	108, /* Group 0 */
+	108, /* Group 1 */
+	216, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_dbcc_stf_8852c = {
+	76, /* Group 0 */
+	76, /* Group 1 */
+	152, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_scc_stf_8851e = {
+	108, /* Group 0 */
+	108, /* Group 1 */
+	216, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_dbcc_stf_8851e = {
+	76, /* Group 0 */
+	76, /* Group 1 */
+	152, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_scc_stf_8852d = {
+	108, /* Group 0 */
+	108, /* Group 1 */
+	216, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_dbcc_stf_8852d = {
+	76, /* Group 0 */
+	76, /* Group 1 */
+	152, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_scc_stf_8192xb = {
+	216, /* Group 0 */
+	0, /* Group 1 */
+	216, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_sutp_8852a = {
+	256, /* Group 0 */
+	0, /* Group 1 */
+	256, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_bcn_test_8852a = {
+	1833, /* Group 0 */
+	1833, /* Group 1 */
+	3666, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_la_8852a = {
+	586, /* Group 0 */
+	586, /* Group 1 */
+	1172, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_la_8852b = {
+	200, /* Group 0 */
+	0, /* Group 1 */
+	200, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_la_8851b = {
+	200, /* Group 0 */
+	0, /* Group 1 */
+	200, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_la_8852c = {
+	586, /* Group 0 */
+	586, /* Group 1 */
+	1172, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_la_8851e = {
+	586, /* Group 0 */
+	586, /* Group 1 */
+	1172, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_la_8852d = {
+	586, /* Group 0 */
+	586, /* Group 1 */
+	1172, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_pcie_la_8192xb = {
+	1172, /* Group 0 */
+	0, /* Group 1 */
+	1172, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie = {
+	2, /*CH 0-11 pre-cost */
+	40, /*H2C pre-cost */
+	0, /* WP CH 0-7 pre-cost */
+	0, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_wd128 = {
+	2, /*CH 0-11 pre-cost */
+	40, /*H2C pre-cost */
+	0, /* WP CH 0-7 pre-cost */
+	0, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_stf = {
+	1, /*CH 0-11 pre-cost */
+	40, /*H2C pre-cost */
+	64, /* WP CH 0-7 pre-cost */
+	64, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X2 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_stf_8852c = {
+	1, /*CH 0-11 pre-cost */
+	40, /*H2C pre-cost */
+	48, /* WP CH 0-7 pre-cost */
+	48, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_dlfw_8852c = {
+	0, /*CH 0-11 pre-cost */
+	256, /*H2C pre-cost */
+	0, /* WP CH 0-7 pre-cost */
+	0, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_la_8852c = {
+	2, /*CH 0-11 pre-cost */
+	40, /*H2C pre-cost */
+	0, /* WP CH 0-7 pre-cost */
+	0, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_stf_8851e = {
+	1, /*CH 0-11 pre-cost */
+	40, /*H2C pre-cost */
+	48, /* WP CH 0-7 pre-cost */
+	48, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_dlfw_8851e = {
+	0, /*CH 0-11 pre-cost */
+	256, /*H2C pre-cost */
+	0, /* WP CH 0-7 pre-cost */
+	0, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_la_8851e = {
+	2, /*CH 0-11 pre-cost */
+	40, /*H2C pre-cost */
+	0, /* WP CH 0-7 pre-cost */
+	0, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_stf_8852d = {
+	1, /*CH 0-11 pre-cost */
+	40, /*H2C pre-cost */
+	48, /* WP CH 0-7 pre-cost */
+	48, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_dlfw_8852d = {
+	0, /*CH 0-11 pre-cost */
+	256, /*H2C pre-cost */
+	0, /* WP CH 0-7 pre-cost */
+	0, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_la_8852d = {
+	2, /*CH 0-11 pre-cost */
+	40, /*H2C pre-cost */
+	0, /* WP CH 0-7 pre-cost */
+	0, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_stf_8192xb = {
+	1, /*CH 0-11 pre-cost */
+	40, /*H2C pre-cost */
+	48, /* WP CH 0-7 pre-cost */
+	48, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_dlfw_8192xb = {
+	0, /*CH 0-11 pre-cost */
+	256, /*H2C pre-cost */
+	0, /* WP CH 0-7 pre-cost */
+	0, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_pcie_la_8192xb = {
+	2, /*CH 0-11 pre-cost */
+	40, /*H2C pre-cost */
+	0, /* WP CH 0-7 pre-cost */
+	0, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+
+#endif
+
+#if MAC_AX_USB_SUPPORT
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_dbcc[] = {
+	{22, 212, grp_0}, /* ACH 0 */
+	{0, 0, grp_0}, /* ACH 1 */
+	{22, 212, grp_0}, /* ACH 2 */
+	{0, 0, grp_0}, /* ACH 3 */
+	{22, 212, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{22, 212, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{22, 212, grp_0}, /* B0MGQ */
+	{0, 0, grp_0}, /* B0HIQ */
+	{22, 212, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_dbcc = {
+	256, /* Group 0 */
+	256, /* Group 1 */
+	512, /* Public Max */
+	104 /* WP threshold */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_dbcc_8852c[] = {
+	{24, 164, grp_0}, /* ACH 0 */
+	{0, 0, grp_0}, /* ACH 1 */
+	{24, 164, grp_0}, /* ACH 2 */
+	{0, 0, grp_0}, /* ACH 3 */
+	{24, 164, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{24, 164, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{24, 164, grp_0}, /* B0MGQ */
+	{0, 0, grp_0}, /* B0HIQ */
+	{24, 164, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_dbcc_8852c = {
+	164, /* Group 0 */
+	164, /* Group 1 */
+	328, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_dbcc_8851e[] = {
+	{24, 164, grp_0}, /* ACH 0 */
+	{0, 0, grp_0}, /* ACH 1 */
+	{24, 164, grp_0}, /* ACH 2 */
+	{0, 0, grp_0}, /* ACH 3 */
+	{24, 164, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{24, 164, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{24, 164, grp_0}, /* B0MGQ */
+	{0, 0, grp_0}, /* B0HIQ */
+	{24, 164, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_dbcc_8851e = {
+	164, /* Group 0 */
+	164, /* Group 1 */
+	328, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_dbcc_8852d[] = {
+	{24, 164, grp_0}, /* ACH 0 */
+	{0, 0, grp_0}, /* ACH 1 */
+	{24, 164, grp_0}, /* ACH 2 */
+	{0, 0, grp_0}, /* ACH 3 */
+	{24, 164, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{24, 164, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{24, 164, grp_0}, /* B0MGQ */
+	{0, 0, grp_0}, /* B0HIQ */
+	{24, 164, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_dbcc_8852d = {
+	164, /* Group 0 */
+	164, /* Group 1 */
+	328, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_scc_8852a[] = {
+	{22, 402, grp_0}, /* ACH 0 */
+	{0, 0, grp_0}, /* ACH 1 */
+	{22, 402, grp_0}, /* ACH 2 */
+	{0, 0, grp_0}, /* ACH 3 */
+	{22, 402, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{22, 402, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{22, 402, grp_0}, /* B0MGQ */
+	{0, 0, grp_0}, /* B0HIQ */
+	{22, 402, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_scc_8852b[] = {
+	{18, 152, grp_0}, /* ACH 0 */
+	{18, 152, grp_0}, /* ACH 1 */
+	{18, 152, grp_0}, /* ACH 2 */
+	{18, 152, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{18, 152, grp_0}, /* B0MGQ */
+	{18, 152, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_scc_turbo_8852b[] = {
+	{18, 210, grp_0}, /* ACH 0 */
+	{18, 210, grp_0}, /* ACH 1 */
+	{18, 210, grp_0}, /* ACH 2 */
+	{18, 210, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{18, 210, grp_0}, /* B0MGQ */
+	{18, 210, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_scc_8851b[] = {
+	{18, 152, grp_0}, /* ACH 0 */
+	{18, 152, grp_0}, /* ACH 1 */
+	{18, 152, grp_0}, /* ACH 2 */
+	{18, 152, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{18, 152, grp_0}, /* B0MGQ */
+	{18, 152, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_scc_turbo_8851b[] = {
+	{18, 210, grp_0}, /* ACH 0 */
+	{18, 210, grp_0}, /* ACH 1 */
+	{18, 210, grp_0}, /* ACH 2 */
+	{18, 210, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{18, 210, grp_0}, /* B0MGQ */
+	{18, 210, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_scc_8852c[] = {
+	{18, 344, grp_0}, /* ACH 0 */
+	{0, 0, grp_0}, /* ACH 1 */
+	{18, 344, grp_0}, /* ACH 2 */
+	{0, 0, grp_0}, /* ACH 3 */
+	{18, 344, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{18, 344, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{18, 344, grp_0}, /* B0MGQ */
+	{0, 0, grp_0}, /* B0HIQ */
+	{18, 344, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_scc_8851e[] = {
+	{18, 156, grp_0}, /* ACH 0 */
+	{0, 0, grp_0}, /* ACH 1 */
+	{18, 156, grp_0}, /* ACH 2 */
+	{0, 0, grp_0}, /* ACH 3 */
+	{0, 0, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{0, 0, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{18, 156, grp_0}, /* B0MGQ */
+	{0, 0, grp_0}, /* B0HIQ */
+	{0, 0, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_scc_8852d[] = {
+	{18, 344, grp_0}, /* ACH 0 */
+	{0, 0, grp_0}, /* ACH 1 */
+	{18, 344, grp_0}, /* ACH 2 */
+	{0, 0, grp_0}, /* ACH 3 */
+	{18, 344, grp_0}, /* ACH 4 */
+	{0, 0, grp_0}, /* ACH 5 */
+	{18, 344, grp_0}, /* ACH 6 */
+	{0, 0, grp_0}, /* ACH 7 */
+	{18, 344, grp_0}, /* B0MGQ */
+	{0, 0, grp_0}, /* B0HIQ */
+	{18, 344, grp_0}, /* B1MGQ */
+	{0, 0, grp_0}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_scc_8852a = {
+	512, /* Group 0 */
+	0, /* Group 1 */
+	512, /* Public Max */
+	104 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_scc_8852b = {
+	152, /* Group 0 */
+	0, /* Group 1 */
+	152, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_scc_turbo_8852b = {
+	210, /* Group 0 */
+	0, /* Group 1 */
+	210, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_scc_8851b = {
+	152, /* Group 0 */
+	0, /* Group 1 */
+	152, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_scc_turbo_8851b = {
+	210, /* Group 0 */
+	0, /* Group 1 */
+	210, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_scc_8852c = {
+	344, /* Group 0 */
+	0, /* Group 1 */
+	344, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_scc_8851e = {
+	156, /* Group 0 */
+	0, /* Group 1 */
+	156, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_scc_8852d = {
+	344, /* Group 0 */
+	0, /* Group 1 */
+	344, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_usb_8852a = {
+	11, /*CH 0-11 pre-cost */
+	32, /*H2C pre-cost */
+	76, /* WP CH 0-7 pre-cost */
+	25, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X2 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_usb_8852b = {
+	9, /*CH 0-11 pre-cost */
+	32, /*H2C pre-cost */
+	64, /* WP CH 0-7 pre-cost */
+	24, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X2 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_usb_8851b = {
+	9, /*CH 0-11 pre-cost */
+	32, /*H2C pre-cost */
+	64, /* WP CH 0-7 pre-cost */
+	24, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X2 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_usb_8852c = {
+	9, /*CH 0-11 pre-cost */
+	32, /*H2C pre-cost */
+	48, /* WP CH 0-7 pre-cost */
+	48, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X2 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_usb_8851e = {
+	9, /*CH 0-11 pre-cost */
+	32, /*H2C pre-cost */
+	64, /* WP CH 0-7 pre-cost */
+	24, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X2 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_usb_8852d = {
+	9, /*CH 0-11 pre-cost */
+	32, /*H2C pre-cost */
+	48, /* WP CH 0-7 pre-cost */
+	48, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X2, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X2, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X2 /* WP CH 8-11 full condition */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_la_8852a[] = {
+	{22, 84, grp_0}, /* ACH 0 */
+	{0, 0, grp_0}, /* ACH 1 */
+	{22, 84, grp_0}, /* ACH 2 */
+	{0, 0, grp_0}, /* ACH 3 */
+	{22, 84, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{22, 84, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{22, 84, grp_0}, /* B0MGQ */
+	{0, 0, grp_0}, /* B0HIQ */
+	{22, 84, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_la_8852a = {
+	128, /* Group 0 */
+	128, /* Group 1 */
+	256, /* Public Max */
+	104 /* WP threshold */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_usb_la_8852b[] = {
+	{18, 112, grp_0}, /* ACH 0 */
+	{0, 0, grp_0}, /* ACH 1 */
+	{18, 112, grp_0}, /* ACH 2 */
+	{0, 0, grp_0}, /* ACH 3 */
+	{18, 112, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{18, 112, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{18, 112, grp_0}, /* B0MGQ */
+	{0, 0, grp_0}, /* B0HIQ */
+	{18, 112, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{0, 0, 0} /* FWCMDQ */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_usb_la_8852b = {
+	112, /* Group 0 */
+	0, /* Group 1 */
+	112, /* Public Max */
+	0 /* WP threshold */
+};
+#endif
+
+#if MAC_AX_SDIO_SUPPORT
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_sdio_8852a[] = {
+	{2, 490, grp_0}, /* ACH 0 */
+	{2, 490, grp_0}, /* ACH 1 */
+	{2, 490, grp_0}, /* ACH 2 */
+	{2, 490, grp_0}, /* ACH 3 */
+	{2, 490, grp_0}, /* ACH 4 */
+	{2, 490, grp_0}, /* ACH 5 */
+	{2, 490, grp_0}, /* ACH 6 */
+	{2, 490, grp_0}, /* ACH 7 */
+	{2, 490, grp_0}, /* B0MGQ */
+	{2, 490, grp_0}, /* B0HIQ */
+	{2, 490, grp_0}, /* B1MGQ */
+	{2, 490, grp_0}, /* B1HIQ */
+	{40, 0, 0} /* H2CQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_sdio_8852b[] = {
+	{2, 102, grp_0}, /* ACH 0 */
+	{2, 102, grp_0}, /* ACH 1 */
+	{2, 102, grp_0}, /* ACH 2 */
+	{2, 102, grp_0}, /* ACH 3 */
+	{0, 0, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{0, 0, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{2, 102, grp_0}, /* B0MGQ */
+	{2, 102, grp_0}, /* B0HIQ */
+	{0, 0, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* H2CQ */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_sdio_8851b[] = {
+	{2, 102, grp_0}, /* ACH 0 */
+	{2, 102, grp_0}, /* ACH 1 */
+	{2, 102, grp_0}, /* ACH 2 */
+	{2, 102, grp_0}, /* ACH 3 */
+	{0, 0, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{0, 0, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{2, 102, grp_0}, /* B0MGQ */
+	{2, 102, grp_0}, /* B0HIQ */
+	{0, 0, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* H2CQ */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_sdio_8852a = {
+	512, /* Group 0 */
+	0, /* Group 1 */
+	512, /* Public Max */
+	104 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_sdio_8852b = {
+	112, /* Group 0 */
+	0, /* Group 1 */
+	112, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_sdio_8851b = {
+	112, /* Group 0 */
+	0, /* Group 1 */
+	112, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_dbcc_sdio_8852a[] = {
+	{2, 246, grp_0}, /* ACH 0 */
+	{2, 246, grp_0}, /* ACH 1 */
+	{2, 246, grp_0}, /* ACH 2 */
+	{2, 246, grp_0}, /* ACH 3 */
+	{2, 246, grp_1}, /* ACH 4 */
+	{2, 246, grp_1}, /* ACH 5 */
+	{2, 246, grp_1}, /* ACH 6 */
+	{2, 246, grp_1}, /* ACH 7 */
+	{2, 246, grp_0}, /* B0MGQ */
+	{2, 246, grp_0}, /* B0HIQ */
+	{2, 246, grp_1}, /* B1MGQ */
+	{2, 246, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* H2CQ */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_dbcc_sdio_8852a = {
+	256, /* Group 0 */
+	256, /* Group 1 */
+	512, /* Public Max */
+	104 /* WP threshold */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_la_sdio_8852a[] = {
+	{2, 54, grp_0}, /* ACH 0 */
+	{2, 54, grp_0}, /* ACH 1 */
+	{2, 54, grp_0}, /* ACH 2 */
+	{2, 54, grp_0}, /* ACH 3 */
+	{2, 54, grp_1}, /* ACH 4 */
+	{2, 54, grp_1}, /* ACH 5 */
+	{2, 54, grp_1}, /* ACH 6 */
+	{2, 54, grp_1}, /* ACH 7 */
+	{2, 54, grp_0}, /* B0MGQ */
+	{2, 54, grp_0}, /* B0HIQ */
+	{2, 54, grp_1}, /* B1MGQ */
+	{2, 54, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* H2CQ */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_la_sdio_8852a = {
+	64, /* Group 0 */
+	64, /* Group 1 */
+	128, /* Public Max */
+	104 /* WP threshold */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_la_sdio_8852b[] = {
+	{2, 102, grp_0}, /* ACH 0 */
+	{2, 102, grp_0}, /* ACH 1 */
+	{2, 102, grp_0}, /* ACH 2 */
+	{2, 102, grp_0}, /* ACH 3 */
+	{0, 0, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{0, 0, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{2, 102, grp_0}, /* B0MGQ */
+	{2, 102, grp_0}, /* B0HIQ */
+	{0, 0, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* H2CQ */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_la_sdio_8852b = {
+	112, /* Group 0 */
+	0, /* Group 1 */
+	112, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_ch_cfg hfc_chcfg_la_sdio_8851b[] = {
+	{2, 102, grp_0}, /* ACH 0 */
+	{2, 102, grp_0}, /* ACH 1 */
+	{2, 102, grp_0}, /* ACH 2 */
+	{2, 102, grp_0}, /* ACH 3 */
+	{0, 0, grp_1}, /* ACH 4 */
+	{0, 0, grp_1}, /* ACH 5 */
+	{0, 0, grp_1}, /* ACH 6 */
+	{0, 0, grp_1}, /* ACH 7 */
+	{2, 102, grp_0}, /* B0MGQ */
+	{2, 102, grp_0}, /* B0HIQ */
+	{0, 0, grp_1}, /* B1MGQ */
+	{0, 0, grp_1}, /* B1HIQ */
+	{40, 0, 0} /* H2CQ */
+};
+
+static struct mac_ax_hfc_pub_cfg hfc_pubcfg_la_sdio_8851b = {
+	112, /* Group 0 */
+	0, /* Group 1 */
+	112, /* Public Max */
+	0 /* WP threshold */
+};
+
+static struct mac_ax_hfc_prec_cfg hfc_preccfg_sdio = {
+	1, /*CH 0-11 pre-cost */
+	40, /*H2C pre-cost */
+	0, /* WP CH 0-7 pre-cost */
+	0, /* WP CH 8-11 pre-cost */
+	MAC_AX_HFC_FULL_COND_X1, /* CH 0-11 full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* H2C full condition */
+	MAC_AX_HFC_FULL_COND_X1, /* WP CH 0-7 full condition */
+	MAC_AX_HFC_FULL_COND_X1 /* WP CH 8-11 full condition */
+};
+#endif
+
+u32 hfc_reset_param(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_hfc_param *param;
+	struct mac_ax_hfc_ch_cfg *ch_cfg, *ch_cfg_ini;
+	struct mac_ax_hfc_ch_info *ch_info;
+	struct mac_ax_hfc_pub_cfg *pub_cfg, *pub_cfg_ini;
+	struct mac_ax_hfc_pub_info *pub_info;
+	struct mac_ax_hfc_prec_cfg *prec_cfg, *prec_cfg_ini;
+	u8 ch;
+
+	param = adapter->hfc_param;
+	ch_cfg = param->ch_cfg;
+	ch_info = param->ch_info;
+	pub_cfg = param->pub_cfg;
+	pub_info = param->pub_info;
+	prec_cfg = param->prec_cfg;
+
+	switch (adapter->hw_info->intf) {
+#if MAC_AX_SDIO_SUPPORT
+	case MAC_AX_INTF_SDIO:
+		param->en = 0;
+		param->mode = MAC_AX_HCIFC_SDIO;
+		prec_cfg_ini = &hfc_preccfg_sdio;
+
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+				ch_cfg_ini = hfc_chcfg_sdio_8852a;
+				pub_cfg_ini = &hfc_pubcfg_sdio_8852a;
+				break;
+			case MAC_AX_QTA_DBCC:
+				ch_cfg_ini = hfc_chcfg_dbcc_sdio_8852a;
+				pub_cfg_ini = &hfc_pubcfg_dbcc_sdio_8852a;
+				break;
+			case MAC_AX_QTA_DLFW:
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				break;
+			case MAC_AX_QTA_LAMODE:
+				ch_cfg_ini = hfc_chcfg_la_sdio_8852a;
+				pub_cfg_ini = &hfc_pubcfg_la_sdio_8852a;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+			case MAC_AX_QTA_SCC_TURBO:
+				ch_cfg_ini = hfc_chcfg_sdio_8852b;
+				pub_cfg_ini = &hfc_pubcfg_sdio_8852b;
+				break;
+			case MAC_AX_QTA_DLFW:
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				break;
+			case MAC_AX_QTA_LAMODE:
+				ch_cfg_ini = hfc_chcfg_la_sdio_8852b;
+				pub_cfg_ini = &hfc_pubcfg_la_sdio_8852b;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+			case MAC_AX_QTA_SCC_TURBO:
+				ch_cfg_ini = hfc_chcfg_sdio_8851b;
+				pub_cfg_ini = &hfc_pubcfg_sdio_8851b;
+				break;
+			case MAC_AX_QTA_DLFW:
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				break;
+			case MAC_AX_QTA_LAMODE:
+				ch_cfg_ini = hfc_chcfg_la_sdio_8851b;
+				pub_cfg_ini = &hfc_pubcfg_la_sdio_8851b;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else {
+			return MACCHIPID;
+		}
+		break;
+#endif
+#if MAC_AX_USB_SUPPORT
+	case MAC_AX_INTF_USB:
+		param->en = 0;
+		param->mode = MAC_AX_HCIFC_STF;
+
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+				ch_cfg_ini = hfc_chcfg_usb_scc_8852a;
+				pub_cfg_ini = &hfc_pubcfg_usb_scc_8852a;
+				prec_cfg_ini = &hfc_preccfg_usb_8852a;
+				break;
+			case MAC_AX_QTA_DBCC:
+				ch_cfg_ini = hfc_chcfg_usb_dbcc;
+				pub_cfg_ini = &hfc_pubcfg_usb_dbcc;
+				prec_cfg_ini = &hfc_preccfg_usb_8852a;
+				break;
+			case MAC_AX_QTA_DLFW:
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_usb_8852a;
+				break;
+			case MAC_AX_QTA_LAMODE:
+				ch_cfg_ini = hfc_chcfg_usb_la_8852a;
+				pub_cfg_ini = &hfc_pubcfg_usb_la_8852a;
+				prec_cfg_ini = &hfc_preccfg_usb_8852a;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+				ch_cfg_ini = hfc_chcfg_usb_scc_8852b;
+				pub_cfg_ini = &hfc_pubcfg_usb_scc_8852b;
+				prec_cfg_ini = &hfc_preccfg_usb_8852b;
+				break;
+			case MAC_AX_QTA_SCC_TURBO:
+				ch_cfg_ini = hfc_chcfg_usb_scc_turbo_8852b;
+				pub_cfg_ini = &hfc_pubcfg_usb_scc_turbo_8852b;
+				prec_cfg_ini = &hfc_preccfg_usb_8852b;
+				break;
+			case MAC_AX_QTA_DLFW:
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_usb_8852b;
+				break;
+			case MAC_AX_QTA_LAMODE:
+				ch_cfg_ini = hfc_chcfg_usb_la_8852b;
+				pub_cfg_ini = &hfc_pubcfg_usb_la_8852b;
+				prec_cfg_ini = &hfc_preccfg_usb_8852b;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+				ch_cfg_ini = hfc_chcfg_usb_scc_8851b;
+				pub_cfg_ini = &hfc_pubcfg_usb_scc_8851b;
+				prec_cfg_ini = &hfc_preccfg_usb_8851b;
+				break;
+			case MAC_AX_QTA_SCC_TURBO:
+				ch_cfg_ini = hfc_chcfg_usb_scc_turbo_8851b;
+				pub_cfg_ini = &hfc_pubcfg_usb_scc_turbo_8851b;
+				prec_cfg_ini = &hfc_preccfg_usb_8851b;
+				break;
+			case MAC_AX_QTA_DLFW:
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_usb_8851b;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+				ch_cfg_ini = hfc_chcfg_usb_scc_8852c;
+				pub_cfg_ini = &hfc_pubcfg_usb_scc_8852c;
+				prec_cfg_ini = &hfc_preccfg_usb_8852c;
+				break;
+			case MAC_AX_QTA_DBCC:
+				ch_cfg_ini = hfc_chcfg_usb_dbcc_8852c;
+				pub_cfg_ini = &hfc_pubcfg_usb_dbcc_8852c;
+				prec_cfg_ini = &hfc_preccfg_usb_8852c;
+				break;
+			case MAC_AX_QTA_DLFW:
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_usb_8852c;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+				ch_cfg_ini = hfc_chcfg_usb_scc_8852c;
+				pub_cfg_ini = &hfc_pubcfg_usb_scc_8852c;
+				prec_cfg_ini = &hfc_preccfg_usb_8852c;
+				break;
+			case MAC_AX_QTA_DBCC:
+				ch_cfg_ini = hfc_chcfg_usb_dbcc;
+				pub_cfg_ini = &hfc_pubcfg_usb_dbcc;
+				prec_cfg_ini = &hfc_preccfg_usb_8852c;
+				break;
+			case MAC_AX_QTA_DLFW:
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_usb_8852c;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+				ch_cfg_ini = hfc_chcfg_usb_scc_8851e;
+				pub_cfg_ini = &hfc_pubcfg_usb_scc_8851e;
+				prec_cfg_ini = &hfc_preccfg_usb_8851e;
+				break;
+			case MAC_AX_QTA_DBCC:
+				ch_cfg_ini = hfc_chcfg_usb_dbcc_8851e;
+				pub_cfg_ini = &hfc_pubcfg_usb_dbcc_8851e;
+				prec_cfg_ini = &hfc_preccfg_usb_8851e;
+				break;
+			case MAC_AX_QTA_DLFW:
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_usb_8851e;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+				ch_cfg_ini = hfc_chcfg_usb_scc_8852d;
+				pub_cfg_ini = &hfc_pubcfg_usb_scc_8852d;
+				prec_cfg_ini = &hfc_preccfg_usb_8852d;
+				break;
+			case MAC_AX_QTA_DBCC:
+				ch_cfg_ini = hfc_chcfg_usb_dbcc_8852d;
+				pub_cfg_ini = &hfc_pubcfg_usb_dbcc_8852d;
+				prec_cfg_ini = &hfc_preccfg_usb_8852d;
+				break;
+			case MAC_AX_QTA_DLFW:
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_usb_8852d;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else {
+			return MACCHIPID;
+		}
+		break;
+#endif
+#if MAC_AX_PCIE_SUPPORT
+	case MAC_AX_INTF_PCIE:
+		param->en = 0;
+
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_DBCC:
+			case MAC_AX_QTA_SCC:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_8852a;
+				pub_cfg_ini = &hfc_pubcfg_pcie_8852a;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_DBCC_STF:
+			case MAC_AX_QTA_SCC_STF:
+				param->mode = MAC_AX_HCIFC_STF;
+				ch_cfg_ini = hfc_chcfg_pcie_stf_8852a;
+				pub_cfg_ini = &hfc_pubcfg_pcie_stf_8852a;
+				prec_cfg_ini = &hfc_preccfg_pcie_stf;
+				break;
+			case MAC_AX_QTA_SU_TP:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_sutp_8852a;
+				pub_cfg_ini = &hfc_pubcfg_pcie_sutp_8852a;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_DLFW:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_LAMODE:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_la_8852a;
+				pub_cfg_ini = &hfc_pubcfg_pcie_la_8852a;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_8852b;
+				pub_cfg_ini = &hfc_pubcfg_pcie_8852b;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_SCC_TURBO:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_8852b_turbo;
+				pub_cfg_ini = &hfc_pubcfg_pcie_8852b_turbo;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_SCC_STF:
+				param->mode = MAC_AX_HCIFC_STF;
+				ch_cfg_ini = hfc_chcfg_pcie_stf_8852b;
+				pub_cfg_ini = &hfc_pubcfg_pcie_stf_8852b;
+				prec_cfg_ini = &hfc_preccfg_pcie_stf;
+				break;
+			case MAC_AX_QTA_DLFW:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_LAMODE:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_la_8852b;
+				pub_cfg_ini = &hfc_pubcfg_pcie_la_8852b;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_8851b;
+				pub_cfg_ini = &hfc_pubcfg_pcie_8851b;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_SCC_TURBO:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_8851b_turbo;
+				pub_cfg_ini = &hfc_pubcfg_pcie_8851b_turbo;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_SCC_STF:
+				param->mode = MAC_AX_HCIFC_STF;
+				ch_cfg_ini = hfc_chcfg_pcie_stf_8851b;
+				pub_cfg_ini = &hfc_pubcfg_pcie_stf_8851b;
+				prec_cfg_ini = &hfc_preccfg_pcie_stf;
+				break;
+			case MAC_AX_QTA_DLFW:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_LAMODE:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_la_8851b;
+				pub_cfg_ini = &hfc_pubcfg_pcie_la_8851b;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_DBCC:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_dbcc_8852c;
+				pub_cfg_ini = &hfc_pubcfg_pcie_dbcc_8852c;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_SCC:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_scc_8852c;
+				pub_cfg_ini = &hfc_pubcfg_pcie_scc_8852c;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_SCC_STF:
+				param->mode = MAC_AX_HCIFC_STF;
+				ch_cfg_ini = hfc_chcfg_pcie_scc_stf_8852c;
+				pub_cfg_ini = &hfc_pubcfg_pcie_scc_stf_8852c;
+				prec_cfg_ini = &hfc_preccfg_pcie_stf_8852c;
+				break;
+			case MAC_AX_QTA_DBCC_STF:
+				param->mode = MAC_AX_HCIFC_STF;
+				ch_cfg_ini = hfc_chcfg_pcie_dbcc_stf_8852c;
+				pub_cfg_ini = &hfc_pubcfg_pcie_dbcc_stf_8852c;
+				prec_cfg_ini = &hfc_preccfg_pcie_stf_8852c;
+				break;
+			case MAC_AX_QTA_DLFW:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_pcie_dlfw_8852c;
+				break;
+			case MAC_AX_QTA_LAMODE:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_la_8852c;
+				pub_cfg_ini = &hfc_pubcfg_pcie_la_8852c;
+				prec_cfg_ini = &hfc_preccfg_pcie_la_8852c;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_SCC:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_scc_8192xb;
+				pub_cfg_ini = &hfc_pubcfg_pcie_scc_8192xb;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_SCC_STF:
+				param->mode = MAC_AX_HCIFC_STF;
+				ch_cfg_ini = hfc_chcfg_pcie_scc_stf_8192xb;
+				pub_cfg_ini = &hfc_pubcfg_pcie_scc_stf_8192xb;
+				prec_cfg_ini = &hfc_preccfg_pcie_stf_8192xb;
+				break;
+			case MAC_AX_QTA_DLFW:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_pcie_dlfw_8192xb;
+				break;
+			case MAC_AX_QTA_LAMODE:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_la_8192xb;
+				pub_cfg_ini = &hfc_pubcfg_pcie_la_8192xb;
+				prec_cfg_ini = &hfc_preccfg_pcie_la_8192xb;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_DBCC:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_dbcc_8851e;
+				pub_cfg_ini = &hfc_pubcfg_pcie_dbcc_8851e;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_SCC:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_scc_8851e;
+				pub_cfg_ini = &hfc_pubcfg_pcie_scc_8851e;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_SCC_STF:
+				param->mode = MAC_AX_HCIFC_STF;
+				ch_cfg_ini = hfc_chcfg_pcie_scc_stf_8851e;
+				pub_cfg_ini = &hfc_pubcfg_pcie_scc_stf_8851e;
+				prec_cfg_ini = &hfc_preccfg_pcie_stf_8851e;
+				break;
+			case MAC_AX_QTA_DBCC_STF:
+				param->mode = MAC_AX_HCIFC_STF;
+				ch_cfg_ini = hfc_chcfg_pcie_dbcc_stf_8851e;
+				pub_cfg_ini = &hfc_pubcfg_pcie_dbcc_stf_8851e;
+				prec_cfg_ini = &hfc_preccfg_pcie_stf_8851e;
+				break;
+			case MAC_AX_QTA_DLFW:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_pcie_dlfw_8851e;
+				break;
+			case MAC_AX_QTA_LAMODE:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_la_8851e;
+				pub_cfg_ini = &hfc_pubcfg_pcie_la_8851e;
+				prec_cfg_ini = &hfc_preccfg_pcie_la_8851e;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			switch (adapter->dle_info.qta_mode) {
+			case MAC_AX_QTA_DBCC:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_dbcc_8852d;
+				pub_cfg_ini = &hfc_pubcfg_pcie_dbcc_8852d;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_SCC:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_scc_8852d;
+				pub_cfg_ini = &hfc_pubcfg_pcie_scc_8852d;
+				prec_cfg_ini = &hfc_preccfg_pcie;
+				break;
+			case MAC_AX_QTA_SCC_STF:
+				param->mode = MAC_AX_HCIFC_STF;
+				ch_cfg_ini = hfc_chcfg_pcie_scc_stf_8852d;
+				pub_cfg_ini = &hfc_pubcfg_pcie_scc_stf_8852d;
+				prec_cfg_ini = &hfc_preccfg_pcie_stf_8852d;
+				break;
+			case MAC_AX_QTA_DBCC_STF:
+				param->mode = MAC_AX_HCIFC_STF;
+				ch_cfg_ini = hfc_chcfg_pcie_dbcc_stf_8852d;
+				pub_cfg_ini = &hfc_pubcfg_pcie_dbcc_stf_8852d;
+				prec_cfg_ini = &hfc_preccfg_pcie_stf_8852d;
+				break;
+			case MAC_AX_QTA_DLFW:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = NULL;
+				pub_cfg_ini = NULL;
+				prec_cfg_ini = &hfc_preccfg_pcie_dlfw_8852d;
+				break;
+			case MAC_AX_QTA_LAMODE:
+				param->mode = MAC_AX_HCIFC_POH;
+				ch_cfg_ini = hfc_chcfg_pcie_la_8852d;
+				pub_cfg_ini = &hfc_pubcfg_pcie_la_8852d;
+				prec_cfg_ini = &hfc_preccfg_pcie_la_8852d;
+				break;
+			default:
+				return MACHFCCH011QTA;
+			}
+		} else {
+			return MACCHIPID;
+		}
+		break;
+#endif
+	default:
+		return MACINTF;
+	}
+
+	if (pub_cfg_ini) {
+		pub_cfg->group0 = pub_cfg_ini->group0;
+		pub_cfg->group1 = pub_cfg_ini->group1;
+		pub_cfg->pub_max = pub_cfg_ini->pub_max;
+		pub_cfg->wp_thrd = pub_cfg_ini->wp_thrd;
+	}
+
+	pub_info->g0_used = 0;
+	pub_info->g1_used = 0;
+	pub_info->pub_aval = 0;
+	pub_info->wp_aval = 0;
+
+	if (pub_cfg_ini) {
+		prec_cfg->ch011_prec = prec_cfg_ini->ch011_prec;
+		prec_cfg->h2c_prec = prec_cfg_ini->h2c_prec;
+		prec_cfg->wp_ch07_prec = prec_cfg_ini->wp_ch07_prec;
+		prec_cfg->wp_ch811_prec = prec_cfg_ini->wp_ch811_prec;
+		prec_cfg->ch011_full_cond = prec_cfg_ini->ch011_full_cond;
+		prec_cfg->h2c_full_cond = prec_cfg_ini->h2c_full_cond;
+		prec_cfg->wp_ch07_full_cond = prec_cfg_ini->wp_ch07_full_cond;
+		prec_cfg->wp_ch811_full_cond = prec_cfg_ini->wp_ch811_full_cond;
+
+		adapter->hw_info->sw_amsdu_max_size = prec_cfg->wp_ch07_prec *
+						      HFC_PAGE_UNIT;
+	}
+
+	if (ch_cfg_ini) {
+		for (ch = MAC_AX_DMA_ACH0; ch < MAC_AX_DMA_CH_NUM; ch++) {
+			ch_cfg[ch].min = ch_cfg_ini[ch].min;
+			ch_cfg[ch].max = ch_cfg_ini[ch].max;
+			ch_cfg[ch].grp = ch_cfg_ini[ch].grp;
+			ch_info[ch].aval = 0;
+			ch_info[ch].used = 0;
+		}
+	}
+	return MACSUCCESS;
+}
+
+static inline u32 hfc_ch_cfg_chk(struct mac_ax_adapter *adapter, u8 ch)
+{
+	struct mac_ax_hfc_ch_cfg *ch_cfg = adapter->hfc_param->ch_cfg;
+	struct mac_ax_hfc_pub_cfg *pub_cfg = adapter->hfc_param->pub_cfg;
+	struct mac_ax_hfc_prec_cfg *prec_cfg = adapter->hfc_param->prec_cfg;
+
+	if (ch >= MAC_AX_DMA_CH_NUM)
+		return MACINTF;
+
+	if ((ch_cfg[ch].min && ch_cfg[ch].min < prec_cfg->ch011_prec) ||
+	    ch_cfg[ch].max > pub_cfg->pub_max)
+		return MACHFCCH011QTA;
+	if (ch_cfg[ch].grp >= grp_num)
+		return MACHFCCH011GRP;
+
+	return MACSUCCESS;
+}
+
+static inline u32 hfc_pub_info_chk(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_hfc_pub_cfg *cfg = adapter->hfc_param->pub_cfg;
+	struct mac_ax_hfc_pub_info *info = adapter->hfc_param->pub_info;
+
+	if (info->g0_used + info->g1_used + info->pub_aval != cfg->pub_max) {
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A))
+			return MACSUCCESS;
+		else
+			return MACHFCPUBINFO;
+	}
+
+	return MACSUCCESS;
+}
+
+static inline u32 hfc_pub_cfg_chk(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_hfc_param *param = adapter->hfc_param;
+	struct mac_ax_hfc_pub_cfg *pub_cfg = param->pub_cfg;
+
+	if (pub_cfg->group0 + pub_cfg->group1 > pub_cfg->pub_max)
+		return MACHFCPUBQTA;
+
+	return MACSUCCESS;
+}
+
+u32 hfc_ch_ctrl(struct mac_ax_adapter *adapter, u8 ch)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret = MACSUCCESS;
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret)
+		return ret;
+
+	ret = hfc_ch_cfg_chk(adapter, ch);
+	if (ret)
+		return ret;
+
+	ret = p_ops->set_fc_page_ctrl_reg(adapter, ch);
+
+	return ret;
+}
+
+u32 hfc_upd_ch_info(struct mac_ax_adapter *adapter, u8 ch)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret = MACSUCCESS;
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret)
+		return ret;
+
+	ret = p_ops->get_fc_page_info(adapter, ch);
+
+	return ret;
+}
+
+u32 hfc_pub_ctrl(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret = MACSUCCESS;
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret)
+		return ret;
+
+	ret = hfc_pub_cfg_chk(adapter);
+	if (ret)
+		return ret;
+
+	ret = p_ops->set_fc_pubpg(adapter);
+
+	return MACSUCCESS;
+}
+
+u32 hfc_upd_mix_info(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_hfc_param *param = adapter->hfc_param;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret;
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret)
+		return ret;
+
+	ret = p_ops->get_fc_mix_info(adapter);
+	if (ret)
+		return ret;
+
+	ret = hfc_pub_info_chk(adapter);
+	if (param->en && ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 hfc_init(struct mac_ax_adapter *adapter, u8 rst, u8 en, u8 h2c_en)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u8 ch;
+	u32 ret = 0;
+
+	if (rst)
+		ret = hfc_reset_param(adapter);
+	if (ret)
+		return ret;
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret)
+		return ret;
+
+	ret = p_ops->set_fc_func_en(adapter, 0, 0);
+	if (ret)
+		return ret;
+
+	if (!en && h2c_en) {
+		ret = p_ops->set_fc_h2c(adapter);
+		if (ret)
+			return ret;
+		ret = p_ops->set_fc_func_en(adapter, en, h2c_en);
+		return ret;
+	}
+
+	for (ch = MAC_AX_DMA_ACH0; ch < MAC_AX_DMA_H2C; ch++) {
+#if MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT || MAC_AX_8192XB_SUPPORT
+		if ((is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		     is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		     is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) &&
+		    (ch == MAC_AX_DMA_ACH4 || ch == MAC_AX_DMA_ACH5 ||
+		     ch == MAC_AX_DMA_ACH6 || ch == MAC_AX_DMA_ACH7 ||
+		     ch == MAC_AX_DMA_B1MG || ch == MAC_AX_DMA_B1HI))
+			continue;
+#endif
+
+#if MAC_AX_8851E_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) &&
+		    (ch == MAC_AX_DMA_ACH1 || ch == MAC_AX_DMA_ACH3 ||
+		     ch == MAC_AX_DMA_ACH4 || ch == MAC_AX_DMA_ACH5 ||
+		     ch == MAC_AX_DMA_ACH6 || ch == MAC_AX_DMA_ACH7 ||
+		     ch == MAC_AX_DMA_B1MG || ch == MAC_AX_DMA_B1HI))
+			continue;
+#endif
+
+		ret = hfc_ch_ctrl(adapter, ch);
+		if (ret)
+			return ret;
+	}
+
+	ret = hfc_pub_ctrl(adapter);
+	if (ret)
+		return ret;
+
+	ret = p_ops->set_fc_mix_cfg(adapter);
+	if (ret)
+		return ret;
+
+	if (en || h2c_en) {
+		ret = p_ops->set_fc_func_en(adapter, en, h2c_en);
+		if (ret)
+			return ret;
+		PLTFM_DELAY_US(10);
+	}
+	for (ch = MAC_AX_DMA_ACH0; ch < MAC_AX_DMA_H2C; ch++) {
+#if MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT || MAC_AX_8192XB_SUPPORT
+		if ((is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		     is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		     is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) &&
+		    (ch == MAC_AX_DMA_ACH4 || ch == MAC_AX_DMA_ACH5 ||
+		     ch == MAC_AX_DMA_ACH6 || ch == MAC_AX_DMA_ACH7 ||
+		     ch == MAC_AX_DMA_B1MG || ch == MAC_AX_DMA_B1HI))
+			continue;
+#endif
+
+#if MAC_AX_8851E_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) &&
+		    (ch == MAC_AX_DMA_ACH1 || ch == MAC_AX_DMA_ACH3 ||
+		     ch == MAC_AX_DMA_ACH4 || ch == MAC_AX_DMA_ACH5 ||
+		     ch == MAC_AX_DMA_ACH6 || ch == MAC_AX_DMA_ACH7 ||
+		     ch == MAC_AX_DMA_B1MG || ch == MAC_AX_DMA_B1HI))
+			continue;
+#endif
+
+		ret = hfc_upd_ch_info(adapter, ch);
+		if (ret)
+			return ret;
+	}
+	ret = hfc_upd_mix_info(adapter);
+	return ret;
+}
+
+u32 hfc_info_init(struct mac_ax_adapter *adapter)
+{
+	adapter->hfc_param =
+		(struct mac_ax_hfc_param *)
+		PLTFM_MALLOC(sizeof(struct mac_ax_hfc_param));
+
+	adapter->hfc_param->ch_cfg =
+		(struct mac_ax_hfc_ch_cfg *)PLTFM_MALLOC(chcfg_size);
+
+	adapter->hfc_param->ch_info =
+		(struct mac_ax_hfc_ch_info *)PLTFM_MALLOC(chinfo_size);
+
+	adapter->hfc_param->pub_cfg =
+		(struct mac_ax_hfc_pub_cfg *)
+		PLTFM_MALLOC(sizeof(struct mac_ax_hfc_pub_cfg));
+
+	adapter->hfc_param->pub_info =
+		(struct mac_ax_hfc_pub_info *)
+		PLTFM_MALLOC(sizeof(struct mac_ax_hfc_pub_info));
+
+	adapter->hfc_param->prec_cfg =
+		(struct mac_ax_hfc_prec_cfg *)
+		PLTFM_MALLOC(sizeof(struct mac_ax_hfc_prec_cfg));
+
+	adapter->hfc_param->en = 0;
+	adapter->hfc_param->h2c_en = 0;
+	adapter->hfc_param->mode = 0;
+
+	return MACSUCCESS;
+}
+
+u32 hfc_info_exit(struct mac_ax_adapter *adapter)
+{
+	PLTFM_FREE(adapter->hfc_param->prec_cfg,
+		   sizeof(struct mac_ax_hfc_prec_cfg));
+
+	PLTFM_FREE(adapter->hfc_param->pub_info,
+		   sizeof(struct mac_ax_hfc_pub_info));
+
+	PLTFM_FREE(adapter->hfc_param->pub_cfg,
+		   sizeof(struct mac_ax_hfc_pub_cfg));
+
+	PLTFM_FREE(adapter->hfc_param->ch_info, chinfo_size);
+	PLTFM_FREE(adapter->hfc_param->ch_cfg, chcfg_size);
+	PLTFM_FREE(adapter->hfc_param, sizeof(struct mac_ax_hfc_param));
+
+	return MACSUCCESS;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hci_fc.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hci_fc.h
new file mode 100644
index 000000000000..bb6b59b91dd4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hci_fc.h
@@ -0,0 +1,155 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_HCIFC_H_
+#define _MAC_AX_HCIFC_H_
+
+#include "../type.h"
+#include "trxcfg.h"
+#include "../mac_ax.h"
+
+#define HFC_PAGE_UNIT 64
+
+/**
+ * @enum mac_ax_hfc_full_cond
+ *
+ * @brief mac_ax_hfc_full_cond
+ *
+ * @var mac_ax_hfc_full_cond::MAC_AX_HFC_FULL_COND_X1
+ * Please Place Description here.
+ * @var mac_ax_hfc_full_cond::MAC_AX_HFC_FULL_COND_X2
+ * Please Place Description here.
+ * @var mac_ax_hfc_full_cond::MAC_AX_HFC_FULL_COND_X3
+ * Please Place Description here.
+ * @var mac_ax_hfc_full_cond::MAC_AX_HFC_FULL_COND_X4
+ * Please Place Description here.
+ */
+enum mac_ax_hfc_full_cond {
+	MAC_AX_HFC_FULL_COND_X1 = 0,
+	MAC_AX_HFC_FULL_COND_X2,
+	MAC_AX_HFC_FULL_COND_X3,
+	MAC_AX_HFC_FULL_COND_X4
+};
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup HCI_FlowControl
+ * @{
+ */
+/**
+ * @brief hfc_ch_ctrl
+ *
+ * @param *adapter
+ * @param ch
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 hfc_ch_ctrl(struct mac_ax_adapter *adapter, u8 ch);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup HCI_FlowControl
+ * @{
+ */
+
+/**
+ * @brief hfc_upd_ch_info
+ *
+ * @param *adapter
+ * @param ch
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 hfc_upd_ch_info(struct mac_ax_adapter *adapter, u8 ch);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup HCI_FlowControl
+ * @{
+ */
+
+/**
+ * @brief hfc_pub_ctrl
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 hfc_pub_ctrl(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup HCI_FlowControl
+ * @{
+ */
+
+/**
+ * @brief hfc_upd_mix_info
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 hfc_upd_mix_info(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup HCI_FlowControl
+ * @{
+ */
+
+/**
+ * @brief hfc_init
+ *
+ * @param *adapter
+ * @param rst
+ * @param en
+ * @param h2c_en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 hfc_init(struct mac_ax_adapter *adapter, u8 rst, u8 en, u8 h2c_en);
+/**
+ * @}
+ * @}
+ */
+
+u32 hfc_info_init(struct mac_ax_adapter *adapter);
+
+u32 hfc_info_exit(struct mac_ax_adapter *adapter);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hdr_conv.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hdr_conv.c
new file mode 100644
index 000000000000..8af2191c0171
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hdr_conv.c
@@ -0,0 +1,643 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "hdr_conv.h"
+
+#if MAC_AX_FW_REG_OFLD
+u32 mac_hdr_conv_en(struct mac_ax_adapter *adapter, u8 en_hdr_conv)
+{
+			u32 ret = 0;
+			u8 *buf;
+#if MAC_AX_PHL_H2C
+			struct rtw_h2c_pkt *h2cb;
+#else
+			struct h2c_buf *h2cb;
+#endif
+			struct mac_ax_en_hdr_conv *content;
+
+			h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+			if (!h2cb)
+				return MACNPTR;
+
+			buf = h2cb_put(h2cb, sizeof(struct mac_ax_en_hdr_conv));
+			if (!buf) {
+				ret = MACNOBUF;
+				goto fail;
+			}
+
+			content = (struct mac_ax_en_hdr_conv *)buf;
+			content->enable = en_hdr_conv;
+
+			ret = h2c_pkt_set_hdr(adapter, h2cb,
+					      FWCMD_TYPE_H2C,
+					      FWCMD_H2C_CAT_MAC,
+					      FWCMD_H2C_CL_FW_OFLD,
+					      FWCMD_H2C_FUNC_EN_MAC_HDR_CONV,
+					      0,
+					      1);
+
+			if (ret)
+				goto fail;
+
+			ret = h2c_pkt_build_txd(adapter, h2cb);
+			if (ret)
+				goto fail;
+
+#if MAC_AX_PHL_H2C
+			ret = PLTFM_TX(h2cb);
+#else
+			ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+fail:
+			h2cb_free(adapter, h2cb);
+
+			return ret;
+}
+#else
+u32 mac_hdr_conv_en(struct mac_ax_adapter *adapter, u8 en_hdr_conv)
+{
+	u32 val;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (en_hdr_conv) {
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			val = MAC_REG_R32(R_AX_HDR_SHCUT_SETTING);
+			val |= (B_AX_MAC_MPDU_PROC_EN |
+				B_AX_SHCUT_LLC_WR_LOCK |
+				B_AX_SHCUT_PARSE_DASA);
+			MAC_REG_W32(R_AX_HDR_SHCUT_SETTING, val);
+			return MACSUCCESS;
+		}
+#endif
+#if (MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT || MAC_AX_1115E_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D) ||
+		    is_chip_id(adapter, MAC_BE_CHIP_ID_1115E)) {
+			val = MAC_REG_R32(R_AX_HDR_SHCUT_SETTING);
+			val |= (B_AX_TX_MAC_MPDU_PROC_EN |
+				B_AX_TX_HW_ACK_POLICY_EN);
+			MAC_REG_W32(R_AX_HDR_SHCUT_SETTING, val);
+			return MACSUCCESS;
+		}
+#endif
+	} else {
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			val = MAC_REG_R32(R_AX_HDR_SHCUT_SETTING);
+			val &= (~(B_AX_MAC_MPDU_PROC_EN |
+				  B_AX_SHCUT_LLC_WR_LOCK |
+				  B_AX_SHCUT_PARSE_DASA));
+			MAC_REG_W32(R_AX_HDR_SHCUT_SETTING, val);
+			return MACSUCCESS;
+		}
+#endif
+#if (MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT || MAC_AX_1115E_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D) ||
+		    is_chip_id(adapter, MAC_BE_CHIP_ID_1115E)) {
+			val = MAC_REG_R32(R_AX_HDR_SHCUT_SETTING);
+			val &= (~(B_AX_TX_MAC_MPDU_PROC_EN |
+				  B_AX_TX_HW_ACK_POLICY_EN));
+			MAC_REG_W32(R_AX_HDR_SHCUT_SETTING, val);
+			return MACSUCCESS;
+		}
+#endif
+	}
+	return MACNOTSUP;
+}
+#endif
+
+u32 mac_hdr_conv_tx_macid_en(struct mac_ax_adapter *adapter,
+			     u8 macid, struct mac_ax_hdr_conv_dctl_cfg hdr_conv_dctl_cfg)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		info.vlan_tag_valid = hdr_conv_dctl_cfg.vlan_tag_valid;
+		info.qos_field_h_en = hdr_conv_dctl_cfg.qos_field_h_en;
+		info.qos_field_h = hdr_conv_dctl_cfg.qos_field_h;
+		info.mhdr_len = hdr_conv_dctl_cfg.mhdr_len;
+
+		mask.vlan_tag_valid = HW_HDR_CONV_VLANTAG_VALID_ENABLE;
+		mask.qos_field_h_en = HW_HDR_CONV_QOS_FIELD_ENABLE;
+		mask.qos_field_h = FWCMD_H2C_DCTRL_QOS_FIELD_H_MSK;
+		mask.mhdr_len = FWCMD_H2C_DCTRL_V1_MHDR_LEN_MSK;
+		ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 1);
+		return ret;
+	} else {
+		return MACNOTSUP;
+	}
+}
+
+u32 mac_hdr_conv_tx_set_eth_type(struct mac_ax_adapter *adapter,
+				 u8 eth_type_idx, u16 eth_type)
+{
+	u32 ret = MACNOTSUP;
+	u32 val = 0;
+	u32 reg = 0;
+	u32 msk = 0;
+	u32 sh = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (eth_type_idx) {
+	case R_AX_ETH_TYPE_IDX_0:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_ETH_TYPE0;
+			msk = B_AX_SHUT_ETH_TYPE0_MSK;
+			sh = B_AX_SHUT_ETH_TYPE0_SH;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	case R_AX_ETH_TYPE_IDX_1:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_ETH_TYPE0;
+			msk = B_AX_SHUT_ETH_TYPE1_MSK;
+			sh = B_AX_SHUT_ETH_TYPE1_SH;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	case R_AX_ETH_TYPE_IDX_2:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_ETH_TYPE1;
+			msk = B_AX_SHUT_ETH_TYPE2_MSK;
+			sh = B_AX_SHUT_ETH_TYPE2_SH;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	default:
+		ret = MACNOITEM;
+	}
+
+	if (ret == MACSUCCESS) {
+		val = MAC_REG_R32(reg);
+		val = val & ~(msk << sh);
+		val = val | ((eth_type & msk) << sh);
+		MAC_REG_W32(reg, val);
+	}
+
+	return ret;
+}
+
+u32 mac_hdr_conv_tx_get_eth_type(struct mac_ax_adapter *adapter,
+				 u8 eth_type_idx, u16 *eth_type)
+{
+	u32 ret = MACNOTSUP;
+	u32 val = 0;
+	u32 reg = 0;
+	u32 msk = 0;
+	u32 sh = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (eth_type_idx) {
+	case R_AX_ETH_TYPE_IDX_0:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_ETH_TYPE0;
+			msk = B_AX_SHUT_ETH_TYPE0_MSK;
+			sh = B_AX_SHUT_ETH_TYPE0_SH;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	case R_AX_ETH_TYPE_IDX_1:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_ETH_TYPE0;
+			msk = B_AX_SHUT_ETH_TYPE1_MSK;
+			sh = B_AX_SHUT_ETH_TYPE1_SH;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	case R_AX_ETH_TYPE_IDX_2:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_ETH_TYPE1;
+			msk = B_AX_SHUT_ETH_TYPE2_MSK;
+			sh = B_AX_SHUT_ETH_TYPE2_SH;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	default:
+		ret = MACNOITEM;
+	}
+
+	if (ret == MACSUCCESS) {
+		val = MAC_REG_R32(reg);
+		*eth_type = (u16)((val & (msk << sh)) >> sh);
+	}
+
+	return ret;
+}
+
+u32 mac_hdr_conv_tx_set_oui(struct mac_ax_adapter *adapter,
+			    u8 oui_idx, u32 oui_val, u8 enable)
+{
+	u32 ret = MACNOTSUP;
+	u32 val = 0;
+	u32 reg = 0;
+	u32 msk = 0;
+	u32 sh = 0;
+	u32 en_bit = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (oui_idx) {
+	case R_AX_OUI_IDX_0:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_OUI0;
+			msk = B_AX_SHUT_ETH_OUI0_MSK;
+			sh = B_AX_SHUT_ETH_OUI0_SH;
+			en_bit = B_AX_SHUT_ENABLE_OUI0;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	case R_AX_OUI_IDX_1:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_OUI1;
+			msk = B_AX_SHUT_ETH_OUI1_MSK;
+			sh = B_AX_SHUT_ETH_OUI1_SH;
+			en_bit = B_AX_SHUT_ENABLE_OUI1;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	case R_AX_OUI_IDX_2:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_OUI2;
+			msk = B_AX_SHUT_ETH_OUI2_MSK;
+			sh = B_AX_SHUT_ETH_OUI2_SH;
+			en_bit = B_AX_SHUT_ENABLE_OUI2;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	case R_AX_OUI_IDX_3:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_OUI3;
+			msk = B_AX_SHUT_ETH_OUI3_MSK;
+			sh = B_AX_SHUT_ETH_OUI3_SH;
+			en_bit = B_AX_SHUT_ENABLE_OUI3;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	default:
+		ret = MACNOITEM;
+	}
+
+	if (ret == MACSUCCESS) {
+		val = MAC_REG_R32(reg);
+		val = val & ~(msk << sh);
+		val = val & ~en_bit;
+		val = val | ((oui_val & msk) << sh);
+		if (enable)
+			val = val | en_bit;
+		MAC_REG_W32(reg, val);
+	}
+	return ret;
+}
+
+u32 mac_hdr_conv_tx_get_oui(struct mac_ax_adapter *adapter,
+			    u8 oui_idx, u32 *oui_val, u8 *enable)
+{
+	u32 ret = MACNOTSUP;
+	u32 val = 0;
+	u32 reg = 0;
+	u32 msk = 0;
+	u32 sh = 0;
+	u32 en_bit = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (oui_idx) {
+	case R_AX_OUI_IDX_0:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_OUI0;
+			msk = B_AX_SHUT_ETH_OUI0_MSK;
+			sh = B_AX_SHUT_ETH_OUI0_SH;
+			en_bit = B_AX_SHUT_ENABLE_OUI0;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	case R_AX_OUI_IDX_1:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_OUI1;
+			msk = B_AX_SHUT_ETH_OUI1_MSK;
+			sh = B_AX_SHUT_ETH_OUI1_SH;
+			en_bit = B_AX_SHUT_ENABLE_OUI1;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	case R_AX_OUI_IDX_2:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_OUI2;
+			msk = B_AX_SHUT_ETH_OUI2_MSK;
+			sh = B_AX_SHUT_ETH_OUI2_SH;
+			en_bit = B_AX_SHUT_ENABLE_OUI2;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	case R_AX_OUI_IDX_3:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT  || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = R_AX_SHCUT_LLC_OUI3;
+			msk = B_AX_SHUT_ETH_OUI3_MSK;
+			sh = B_AX_SHUT_ETH_OUI3_SH;
+			en_bit = B_AX_SHUT_ENABLE_OUI3;
+			ret = MACSUCCESS;
+		}
+#endif
+	break;
+	default:
+		ret = MACNOITEM;
+	}
+
+	if (ret == MACSUCCESS) {
+		val = MAC_REG_R32(reg);
+		*oui_val = ((val & (msk << sh)) >> sh);
+		*enable = ((val & en_bit) ? R_AX_OUI_CFG_ENABLE : R_AX_OUI_CFG_DISABLE);
+	}
+	return ret;
+}
+
+u32 mac_hdr_conv_tx_vlan_tag_valid_en(struct mac_ax_adapter *adapter,
+				      u8 macid, u8 vlan_tag_valid_en)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		info.vlan_tag_valid = vlan_tag_valid_en;
+		mask.vlan_tag_valid = HW_HDR_CONV_VLANTAG_VALID_ENABLE;
+		ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 1);
+		return ret;
+	} else {
+		return MACNOTSUP;
+	}
+}
+
+u8 mac_hdr_conv_tx_get_vlan_tag_valid(struct mac_ax_adapter *adapter, u8 macid)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		mask.vlan_tag_valid = HW_HDR_CONV_VLANTAG_VALID_ENABLE;
+		ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 0);
+
+		if (ret != MACSUCCESS)
+			return 0;
+		else
+			return (u8)info.vlan_tag_valid;
+	} else {
+		return MACNOTSUP;
+	}
+}
+
+u32 mac_hdr_conv_tx_qos_field_en(struct mac_ax_adapter *adapter,
+				 u8 macid, u8 wlan_with_qosc_en, u8 qos_field_h)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	info.qos_field_h_en = wlan_with_qosc_en;
+	info.qos_field_h = qos_field_h;
+	mask.qos_field_h_en = HW_HDR_CONV_QOS_FIELD_ENABLE;
+	mask.qos_field_h = FWCMD_H2C_DCTRL_QOS_FIELD_H_MSK;
+	ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 1);
+
+	return ret;
+}
+
+u8 mac_hdr_conv_tx_get_qos_field_en(struct mac_ax_adapter *adapter, u8 macid)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	mask.qos_field_h_en = HW_HDR_CONV_QOS_FIELD_ENABLE;
+	ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 0);
+
+	if (ret != MACSUCCESS)
+		return 0;
+	else
+		return (u8)info.qos_field_h_en;
+}
+
+u8 mac_hdr_conv_tx_get_qos_field_h(struct mac_ax_adapter *adapter, u8 macid)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	mask.qos_field_h = FWCMD_H2C_DCTRL_QOS_FIELD_H_MSK;
+	ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 0);
+
+	if (ret != MACSUCCESS)
+		return 0;
+	else
+		return (u8)info.qos_field_h;
+}
+
+u32 mac_hdr_conv_tx_target_wlan_hdr_len(struct mac_ax_adapter *adapter,
+					u8 macid, u8 wlan_hdr_len)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	info.mhdr_len = wlan_hdr_len;
+	mask.mhdr_len = FWCMD_H2C_DCTRL_V1_MHDR_LEN_MSK;
+	ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 1);
+
+	return ret;
+}
+
+u8 mac_hdr_conv_tx_get_target_wlan_hdr_len(struct mac_ax_adapter *adapter, u8 macid)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	mask.mhdr_len = FWCMD_H2C_DCTRL_V1_MHDR_LEN_MSK;
+	ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 0);
+
+	if (ret != MACSUCCESS)
+		return 0;
+	else
+		return (u8)info.mhdr_len;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hdr_conv.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hdr_conv.h
new file mode 100644
index 000000000000..cad10b697fff
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hdr_conv.h
@@ -0,0 +1,299 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_HDR_CONV_H_
+#define _MAC_AX_HDR_CONV_H_
+
+#include "../type.h"
+
+#define HW_HDR_CONV_HTC_ORDER_ENABLE 0x1
+#define HW_HDR_CONV_VLANTAG_VALID_ENABLE 0x1
+#define HW_HDR_CONV_QOS_FIELD_ENABLE 0x1
+
+enum {
+	R_AX_ETH_TYPE_IDX_0 = 0,
+	R_AX_ETH_TYPE_IDX_1 = 1,
+	R_AX_ETH_TYPE_IDX_2 = 2,
+};
+
+enum {
+	R_AX_OUI_IDX_0 = 0,
+	R_AX_OUI_IDX_1 = 1,
+	R_AX_OUI_IDX_2 = 2,
+	R_AX_OUI_IDX_3 = 3,
+};
+
+enum {
+	R_AX_OUI_CFG_DISABLE = 0,
+	R_AX_OUI_CFG_ENABLE = 1,
+};
+
+/**
+ * @struct mac_ax_en_hdr_conv
+ * @brief mac_ax_en_hdr_conv
+ *
+ * @var mac_ax_en_hdr_conv::enable
+ * Please Place Description here.
+ * @var mac_ax_en_hdr_conv::rsvd0
+ * Please Place Description here.
+ */
+struct mac_ax_en_hdr_conv {
+	u32 enable: 1;
+	u32 rsvd0: 31;
+};
+
+/**
+ * @brief mac_hdr_conv_tx_set_eth_type
+ *
+ * @param adapter
+ * @param eth_type_idx
+ * @param eth_type
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hdr_conv_tx_set_eth_type(struct mac_ax_adapter *adapter,
+				 u8 eth_type_idx, u16 eth_type);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_get_eth_type
+ *
+ * @param adapter
+ * @param eth_type_idx
+ * @param *eth_type
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hdr_conv_tx_get_eth_type(struct mac_ax_adapter *adapter,
+				 u8 eth_type_idx, u16 *eth_type);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_set_oui
+ *
+ * @param adapter
+ * @param oui_idx
+ * @param oui_val
+ * @param enable
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hdr_conv_tx_set_oui(struct mac_ax_adapter *adapter,
+			    u8 oui_idx, u32 oui_val, u8 enable);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_get_oui
+ *
+ * @param adapter
+ * @param oui_idx
+ * @param *oui_val
+ * @param *enable
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hdr_conv_tx_get_oui(struct mac_ax_adapter *adapter,
+			    u8 oui_idx, u32 *oui_val, u8 *enable);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_en
+ *
+ * @param adapter
+ * @param en_tx_hdr_conv
+ */
+u32 mac_hdr_conv_en(struct mac_ax_adapter *adapter, u8 en_hdr_conv);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_macid_en
+ *
+ * @param adapter
+ * @param macid
+ * @param dctl_hdr_conv_cfg
+ */
+u32 mac_hdr_conv_tx_macid_en(struct mac_ax_adapter *adapter,
+			     u8 macid, struct mac_ax_hdr_conv_dctl_cfg hdr_conv_dctl_cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_vlan_tag_valid_en
+ *
+ * @param adapter
+ * @param macid
+ * @param vlan_tag_valid_en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hdr_conv_tx_vlan_tag_valid_en(struct mac_ax_adapter *adapter,
+				      u8 macid, u8 vlan_tag_valid_en);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_get_vlan_tag_valid
+ *
+ * @param adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 mac_hdr_conv_tx_get_vlan_tag_valid(struct mac_ax_adapter *adapter, u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_qos_field_en
+ *
+ * @param adapter
+ * @param macid
+ * @param wlan_with_qosc_en
+ * @param qos_field_h
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hdr_conv_tx_qos_field_en(struct mac_ax_adapter *adapter,
+				 u8 macid, u8 wlan_with_qosc_en, u8 qos_field_h);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_get_qos_field_en
+ *
+ * @param adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 mac_hdr_conv_tx_get_qos_field_en(struct mac_ax_adapter *adapter, u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_get_qos_field_h
+ *
+ * @param adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 mac_hdr_conv_tx_get_qos_field_h(struct mac_ax_adapter *adapter, u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_htc_en
+ *
+ * @param adapter
+ * @param macid
+ * @param wlan_with_htc_en
+ * @param htc_lb
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hdr_conv_tx_htc_en(struct mac_ax_adapter *adapter,
+			   u8 macid, u8 wlan_with_htc_en, u8 htc_lb);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_get_htc_en
+ *
+ * @param adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 mac_hdr_conv_tx_get_htc_en(struct mac_ax_adapter *adapter, u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_get_htc_lb
+ *
+ * @param adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 mac_hdr_conv_tx_get_htc_lb(struct mac_ax_adapter *adapter, u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_target_wlan_hdr_len
+ *
+ * @param adapter
+ * @param macid
+ * @param wlan_hdr_len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hdr_conv_tx_target_wlan_hdr_len(struct mac_ax_adapter *adapter,
+					u8 macid, u8 wlan_hdr_len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_hdr_conv_tx_get_target_wlan_hdr_len
+ *
+ * @param adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 mac_hdr_conv_tx_get_target_wlan_hdr_len(struct mac_ax_adapter *adapter, u8 macid);
+/**
+ * @}
+ * @}
+ */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw.c
new file mode 100644
index 000000000000..581afb241e4e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw.c
@@ -0,0 +1,3683 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "hw.h"
+#include "coex.h"
+#include "twt.h"
+#include "fwofld.h"
+#include "mac_priv.h"
+#include "trxcfg.h"
+#include "common.h"
+
+static struct mac_ax_host_rpr_cfg rpr_cfg_poh = {
+	121, /* agg */
+	255, /* tmr */
+	0, /* agg_def */
+	0, /* tmr_def */
+	0, /* rsvd */
+	MAC_AX_FUNC_EN, /* txok_en */
+	MAC_AX_FUNC_EN, /* rty_lmt_en */
+	MAC_AX_FUNC_EN, /* lft_drop_en */
+	MAC_AX_FUNC_EN /* macid_drop_en */
+};
+
+static struct mac_ax_host_rpr_cfg rpr_cfg_stf = {
+	121, /* agg */
+	255, /* tmr */
+	0, /* agg_def */
+	0, /* tmr_def */
+	0, /* rsvd */
+	MAC_AX_FUNC_DIS, /* txok_en */
+	MAC_AX_FUNC_DIS, /* rty_lmt_en */
+	MAC_AX_FUNC_DIS, /* lft_drop_en */
+	MAC_AX_FUNC_DIS /* macid_drop_en */
+};
+
+static struct mac_ax_drv_wdt_ctrl wdt_ctrl_def = {
+	MAC_AX_PCIE_DISABLE,
+	MAC_AX_PCIE_ENABLE
+};
+
+static void get_delay_tx_cfg(struct mac_ax_adapter *adapter,
+			     struct mac_ax_delay_tx_cfg *cfg);
+static void set_delay_tx_cfg(struct mac_ax_adapter *adapter,
+			     struct mac_ax_delay_tx_cfg *cfg);
+
+struct mac_ax_hw_info *mac_get_hw_info(struct mac_ax_adapter *adapter)
+{
+	return adapter->hw_info->done ? adapter->hw_info : NULL;
+}
+
+u32 get_block_tx_sel_msk(enum mac_ax_block_tx_sel src, u32 *msk)
+{
+	switch (src) {
+	case MAC_AX_CCA:
+		*msk = B_AX_CCA_EN;
+		break;
+	case MAC_AX_SEC20_CCA:
+		*msk = B_AX_SEC20_EN;
+		break;
+	case MAC_AX_SEC40_CCA:
+		*msk = B_AX_SEC40_EN;
+		break;
+	case MAC_AX_SEC80_CCA:
+		*msk = B_AX_SEC80_EN;
+		break;
+	case MAC_AX_EDCCA:
+		*msk = B_AX_EDCCA_EN;
+		break;
+	case MAC_AX_BTCCA:
+		*msk = B_AX_BTCCA_EN;
+		break;
+	case MAC_AX_TX_NAV:
+		*msk = B_AX_TX_NAV_EN;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 cfg_block_tx(struct mac_ax_adapter *adapter,
+		 enum mac_ax_block_tx_sel src, u8 band, u8 en)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val, msk, ret;
+	u32 reg = band == 0 ? R_AX_CCA_CFG_0 : R_AX_CCA_CFG_0_C1;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: CMAC%d is NOT enabled\n", __func__, band);
+		return ret;
+	}
+
+	ret = get_block_tx_sel_msk(src, &msk);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: %d is NOT supported\n", __func__, src);
+		return ret;
+	}
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = MAC_REG_W_OFLD((u16)reg, msk,
+				     en ? 1 : 0, 1);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("%s: write offload fail %d",
+				      __func__, ret);
+
+		return ret;
+	}
+#endif
+	val = MAC_REG_R32(reg);
+
+	if (en)
+		val = val | msk;
+	else
+		val = val & ~msk;
+	MAC_REG_W32(reg, val);
+
+	return MACSUCCESS;
+}
+
+u32 get_block_tx(struct mac_ax_adapter *adapter,
+		 enum mac_ax_block_tx_sel src, u8 band, u8 *en)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val, msk, ret;
+	u32 reg = band == 0 ? R_AX_CCA_CFG_0 : R_AX_CCA_CFG_0_C1;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: CMAC%d is NOT enabled", __func__, band);
+		return ret;
+	}
+
+	val = MAC_REG_R32(reg);
+
+	ret = get_block_tx_sel_msk(src, &msk);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: %d is NOT supported\n", __func__, src);
+		return ret;
+	}
+
+	*en = !!(val & msk);
+
+	return MACSUCCESS;
+}
+
+u32 set_enable_bb_rf(struct mac_ax_adapter *adapter, u8 enable)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 value32, ret;
+	u8 value8;
+	u8 wl_rfc_s0 = 0;
+	u8 wl_rfc_s1 = 0;
+
+	if (enable == 1) {
+		value8 = MAC_REG_R8(R_AX_SYS_FUNC_EN);
+		value8 |= B_AX_FEN_BBRSTB | B_AX_FEN_BB_GLB_RSTN;
+		MAC_REG_W8(R_AX_SYS_FUNC_EN, value8);
+#if MAC_AX_8852A_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 |= B_AX_WLRF1_CTRL_7 | B_AX_WLRF1_CTRL_1 |
+				   B_AX_WLRF_CTRL_7 | B_AX_WLRF_CTRL_1;
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+
+			value8 = PHYREG_SET_ALL_CYCLE;
+			MAC_REG_W8(R_AX_PHYREG_SET, value8);
+			ret = MACSUCCESS;
+		}
+#endif
+#if MAC_AX_8852B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+			/* 0x200[18:17] = 2'b01 */
+			value32 = MAC_REG_R32(R_AX_SPS_DIG_ON_CTRL0);
+			value32 = SET_CLR_WORD(value32, 0x1, B_AX_REG_ZCDC_H);
+			MAC_REG_W32(R_AX_SPS_DIG_ON_CTRL0, value32);
+
+			/* RDC KS/BB suggest : write 1 then write 0 then write 1 */
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 | B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 & ~B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 | B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+
+			wl_rfc_s0 = 0xC7;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, wl_rfc_s0,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			wl_rfc_s1 = 0xC7;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, wl_rfc_s1,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			#if defined(CONFIG_RTL8852BP)
+				value8 = 0xd;
+				ret = mac_write_xtal_si(adapter, XTAL3, value8,
+							FULL_BIT_MASK);
+				if (ret) {
+					PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+					return ret;
+				}
+			#endif	//#if defined(CONFIG_RTL8852BP)
+
+			value8 = PHYREG_SET_XYN_CYCLE;
+			MAC_REG_W8(R_AX_PHYREG_SET, value8);
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C)) {
+			/* 0x200[18:17] = 2'b01 */
+			value32 = MAC_REG_R32(R_AX_SPS_DIG_ON_CTRL0);
+			value32 = SET_CLR_WORD(value32, 0x1, B_AX_REG_ZCDC_H);
+			MAC_REG_W32(R_AX_SPS_DIG_ON_CTRL0, value32);
+
+			/* RDC KS/BB suggest : write 1 then write 0 then write 1 */
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 | B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 & ~B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 | B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+
+			// for ADC PWR setting
+			value32 = MAC_REG_R32(R_AX_AFE_OFF_CTRL1);
+			value32 = (value32 & ~LDO2PW_LDO_VSEL);
+			value32 |= SET_WORD(0x1, B_AX_S0_LDO_VSEL_F) |
+				   SET_WORD(0x1, B_AX_S1_LDO_VSEL_F);
+			MAC_REG_W32(R_AX_AFE_OFF_CTRL1, value32);
+
+			value8 = 0x7;
+			ret = mac_write_xtal_si(adapter, XTAL0, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0x6c;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0xc7;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0xc7;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0xd;
+			ret = mac_write_xtal_si(adapter, XTAL3, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+		}
+#endif
+#if MAC_AX_8192XB_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) {
+			/* RDC KS/BB suggest : write 1 then write 0 then write 1 */
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 | B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 & ~B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 | B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+
+			value8 = 0x7;
+			ret = mac_write_xtal_si(adapter, XTAL0, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0x6c;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0xc7;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0xc7;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0xf;
+			ret = mac_write_xtal_si(adapter, XTAL3, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+		}
+#endif
+#if MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			/* RDC KS/BB suggest : write 1 then write 0 then write 1 */
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 | B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 & ~B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 | B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+
+			wl_rfc_s0 = 0xC7;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, wl_rfc_s0,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			wl_rfc_s1 = 0xC7;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, wl_rfc_s1,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = PHYREG_SET_XYN_CYCLE;
+			MAC_REG_W8(R_AX_PHYREG_SET, value8);
+		}
+#endif
+#if MAC_AX_8851E_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E)) {
+			/* 0x200[18:17] = 2'b01 */
+			value32 = MAC_REG_R32(R_AX_SPS_DIG_ON_CTRL0);
+			value32 = SET_CLR_WORD(value32, 0x1, B_AX_REG_ZCDC_H);
+			MAC_REG_W32(R_AX_SPS_DIG_ON_CTRL0, value32);
+
+			/* RDC KS/BB suggest : write 1 then write 0 then write 1 */
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 | B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 & ~B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 | B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+
+			// for ADC PWR setting
+			value32 = MAC_REG_R32(R_AX_AFE_OFF_CTRL1);
+			value32 = (value32 & ~LDO2PW_LDO_VSEL);
+			value32 |= SET_WORD(0x1, B_AX_S0_LDO_VSEL_F) |
+				   SET_WORD(0x1, B_AX_S1_LDO_VSEL_F);
+			MAC_REG_W32(R_AX_AFE_OFF_CTRL1, value32);
+
+			value8 = 0x7;
+			ret = mac_write_xtal_si(adapter, XTAL0, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0x6c;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0xc7;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0xc7;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0xd;
+			ret = mac_write_xtal_si(adapter, XTAL3, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+		}
+#endif
+#if MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			/* 0x200[18:17] = 2'b01 */
+			value32 = MAC_REG_R32(R_AX_SPS_DIG_ON_CTRL0);
+			value32 = SET_CLR_WORD(value32, 0x1, B_AX_REG_ZCDC_H);
+			MAC_REG_W32(R_AX_SPS_DIG_ON_CTRL0, value32);
+
+			/* RDC KS/BB suggest : write 1 then write 0 then write 1 */
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 | B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 & ~B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 | B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+
+			// for ADC PWR setting
+			value32 = MAC_REG_R32(R_AX_AFE_OFF_CTRL1);
+			value32 = (value32 & ~LDO2PW_LDO_VSEL);
+			value32 |= SET_WORD(0x1, B_AX_S0_LDO_VSEL_F) |
+				   SET_WORD(0x1, B_AX_S1_LDO_VSEL_F);
+			MAC_REG_W32(R_AX_AFE_OFF_CTRL1, value32);
+
+			value8 = 0x7;
+			ret = mac_write_xtal_si(adapter, XTAL0, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0x6c;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0xc7;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0xc7;
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			value8 = 0xd;
+			ret = mac_write_xtal_si(adapter, XTAL3, value8,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+		}
+#endif
+		adapter->sm.bb0_func = MAC_AX_FUNC_ON;
+	} else {
+		adapter->sm.bb0_func = MAC_AX_FUNC_OFF;
+
+		if (!is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 = (value32 & ~B_AX_AFC_AFEDIG);
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+		}
+
+		value8 = MAC_REG_R8(R_AX_SYS_FUNC_EN);
+		value8 &= (~(B_AX_FEN_BBRSTB | B_AX_FEN_BB_GLB_RSTN));
+		MAC_REG_W8(R_AX_SYS_FUNC_EN, value8);
+#if MAC_AX_8852A_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+			value32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+			value32 &= (~(B_AX_WLRF1_CTRL_7 | B_AX_WLRF1_CTRL_1 |
+				      B_AX_WLRF_CTRL_7 | B_AX_WLRF_CTRL_1));
+			MAC_REG_W32(R_AX_WLRF_CTRL, value32);
+		}
+#endif
+#if MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			ret = mac_read_xtal_si(adapter, XTAL_SI_WL_RFC_S0, &wl_rfc_s0);
+			if (ret) {
+				PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+				return ret;
+			}
+			wl_rfc_s0 = (wl_rfc_s0 & 0xF8);
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, wl_rfc_s0,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+
+			ret = mac_read_xtal_si(adapter, XTAL_SI_WL_RFC_S1, &wl_rfc_s1);
+			if (ret) {
+				PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+				return ret;
+			}
+			wl_rfc_s1 = (wl_rfc_s1 & 0xF8);
+			ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, wl_rfc_s1,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			return MACSUCCESS;
+		}
+#endif
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 set_append_fcs(struct mac_ax_adapter *adapter, u8 enable)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 value8;
+
+	value8 = MAC_REG_R8(R_AX_MPDU_PROC);
+	value8 = enable == 1 ? value8 | B_AX_APPEND_FCS :
+			value8 & ~B_AX_APPEND_FCS;
+	MAC_REG_W8(R_AX_MPDU_PROC, value8);
+
+	return MACSUCCESS;
+}
+
+static u32 set_accept_icverr(struct mac_ax_adapter *adapter, u8 enable)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 value8;
+
+	value8 = MAC_REG_R8(R_AX_MPDU_PROC);
+	value8 = enable == 1 ? (value8 | B_AX_A_ICV_ERR) :
+			(value8 & ~B_AX_A_ICV_ERR);
+	MAC_REG_W8(R_AX_MPDU_PROC, value8);
+
+	return MACSUCCESS;
+}
+
+u32 set_gt3_timer(struct mac_ax_adapter *adapter,
+		  struct mac_ax_gt3_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = (cfg->count_en ? B_AX_GT_COUNT_EN : 0) |
+		  (cfg->mode ? B_AX_GT_MODE : 0) |
+		  (cfg->gt3_en ? B_AX_GT_EN : 0) |
+		  (cfg->sort_en ? B_AX_GT_SORT_EN : 0) |
+		  SET_WORD(cfg->timeout, B_AX_GT_DATA);
+
+	switch (adapter->hw_info->chip_id) {
+	case MAC_AX_CHIP_ID_8852A:
+	case MAC_AX_CHIP_ID_8852B:
+	case MAC_AX_CHIP_ID_8851B:
+		MAC_REG_W32(R_AX_GT3_CTRL, val32);
+		break;
+	default:
+		MAC_REG_W32(R_AX_GT3_CTRL_V1, val32);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 set_cctl_rty_limit(struct mac_ax_adapter *adapter,
+		       struct mac_ax_cctl_rty_lmt_cfg *cfg)
+{
+#define DFLT_DATA_RTY_LIMIT 32
+#define DFLT_RTS_RTY_LIMIT 15
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+	struct rtw_hal_mac_ax_cctl_info info;
+	struct rtw_hal_mac_ax_cctl_info mask;
+
+	u32 data_rty, rts_rty;
+
+	PLTFM_MEMSET(&mask, 0, sizeof(struct rtw_hal_mac_ax_cctl_info));
+	PLTFM_MEMSET(&info, 0, sizeof(struct rtw_hal_mac_ax_cctl_info));
+
+	data_rty = cfg->data_lmt_val == 0 ?
+		DFLT_DATA_RTY_LIMIT : cfg->data_lmt_val;
+	rts_rty = cfg->rts_lmt_val == 0 ?
+		DFLT_RTS_RTY_LIMIT : cfg->rts_lmt_val;
+	info.data_txcnt_lmt_sel = cfg->data_lmt_sel;
+	info.data_tx_cnt_lmt = data_rty;
+	info.rts_txcnt_lmt_sel = cfg->rts_lmt_sel;
+	info.rts_txcnt_lmt = rts_rty;
+
+	mask.data_txcnt_lmt_sel = TXCNT_LMT_MSK;
+	mask.data_tx_cnt_lmt = FWCMD_H2C_CCTRL_DATA_TX_CNT_LMT_MSK;
+	mask.rts_txcnt_lmt_sel = TXCNT_LMT_MSK;
+	mask.rts_txcnt_lmt = FWCMD_H2C_CCTRL_RTS_TXCNT_LMT_MSK;
+
+	mops->upd_cctl_info(adapter, &info, &mask, cfg->macid, TBL_WRITE_OP);
+
+	return MACSUCCESS;
+}
+
+u32 set_data_rty_limit(struct mac_ax_adapter *adapter,
+		       struct mac_ax_rty_lmt *rty)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = MACSUCCESS;
+	struct mac_role_tbl *role;
+	u32 offset_l, offset_s;
+	u8 band = HW_BAND_0;
+
+	if (rty->macid != MACID_NONE) {
+		role = mac_role_srch(adapter, rty->macid);
+		if (!role) {
+			PLTFM_MSG_ERR("%s: The MACID%d does not exist\n",
+				      __func__, rty->macid);
+			return MACNOITEM;
+		}
+
+		if (role->info.c_info.data_txcnt_lmt_sel) {
+			PLTFM_MSG_ERR("%s: MACID%d follow CMAC_TBL setting\n",
+				      __func__, rty->macid);
+		}
+
+		band = role->info.wmm < 2 ? 0 : 1;
+		offset_l = band == 0 ? R_AX_TXCNT + 2 : R_AX_TXCNT_C1 + 2;
+		offset_s = band == 0 ? R_AX_TXCNT + 3 : R_AX_TXCNT_C1 + 3;
+		ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+		if (ret == MACSUCCESS) {
+			MAC_REG_W8(offset_l, rty->tx_cnt);
+			MAC_REG_W8(offset_s, rty->short_tx_cnt);
+		}
+	} else {
+		ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+		if (ret == MACSUCCESS) {
+			MAC_REG_W8(R_AX_TXCNT + 2, rty->tx_cnt);
+			MAC_REG_W8(R_AX_TXCNT + 3, rty->short_tx_cnt);
+		}
+	}
+
+	return ret;
+}
+
+u32 get_data_rty_limit(struct mac_ax_adapter *adapter,
+		       struct mac_ax_rty_lmt *rty)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = MACSUCCESS;
+	struct mac_role_tbl *role;
+	u32 offset_l, offset_s;
+	u8 band;
+
+	role = mac_role_srch(adapter, rty->macid);
+	if (!role) {
+		PLTFM_MSG_ERR("%s: The MACID%d does not exist\n",
+			      __func__, rty->macid);
+		return MACNOITEM;
+	}
+
+	if (role->info.c_info.data_txcnt_lmt_sel) {
+		rty->tx_cnt = (u8)role->info.c_info.data_tx_cnt_lmt;
+	} else {
+		band = role->info.wmm < 2 ? 0 : 1;
+		offset_l = band == 0 ? R_AX_TXCNT + 2 : R_AX_TXCNT_C1 + 2;
+		offset_s = band == 0 ? R_AX_TXCNT + 3 : R_AX_TXCNT_C1 + 3;
+		ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+		if (ret == MACSUCCESS) {
+			rty->tx_cnt = MAC_REG_R8(offset_l);
+			rty->short_tx_cnt = MAC_REG_R8(offset_s);
+		}
+	}
+
+	return ret;
+}
+
+u32 set_bacam_mode(struct mac_ax_adapter *adapter, u8 mode_sel)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = MAC_REG_R32(R_AX_RESPBA_CAM_CTRL) & (~B_AX_BACAM_ENT_CFG);
+
+	if (mode_sel)
+		MAC_REG_W32(R_AX_RESPBA_CAM_CTRL, val32 | B_AX_BACAM_ENT_CFG);
+	else
+		MAC_REG_W32(R_AX_RESPBA_CAM_CTRL, val32);
+	return MACSUCCESS;
+#else
+	return MACHWNOSUP;
+#endif
+}
+
+u32 set_xtal_aac(struct mac_ax_adapter *adapter, u8 aac_mode)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+#if MAC_AX_8852A_SUPPORT
+	u8 val8;
+
+	val8 = MAC_REG_R8(R_AX_XTAL_ON_CTRL2);
+	val8 &= ~(0x30);
+	val8 |= ((aac_mode & B_AX_AAC_MODE_MSK) << B_AX_AAC_MODE_SH);
+	MAC_REG_W8(R_AX_XTAL_ON_CTRL2, val8);
+#else
+	PLTFM_MSG_ERR("non Support IC for xtal acc\n");
+#endif
+
+	return MACSUCCESS;
+}
+
+u32 set_rxd_zld_en(struct mac_ax_adapter *adapter, u8 enable)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret;
+
+	ret = check_mac_en(adapter, MAC_AX_BAND_0, MAC_AX_CMAC_SEL);
+	if (ret)
+		return ret;
+
+	if (enable) {
+		val32 = MAC_REG_R32(R_AX_ZLENDEL_COUNT);
+		val32 |= B_AX_RXD_DELI_EN;
+		MAC_REG_W32(R_AX_ZLENDEL_COUNT, val32);
+	} else {
+		val32 = MAC_REG_R32(R_AX_ZLENDEL_COUNT);
+		val32 &= ~B_AX_RXD_DELI_EN;
+		MAC_REG_W32(R_AX_ZLENDEL_COUNT, val32);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 set_partial_pld_mode(struct mac_ax_adapter *adapter, u8 enable)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	if (enable) {
+		val32 = MAC_REG_R32(R_AX_SEC_ENG_CTRL);
+		val32 |= B_AX_TX_PARTIAL_MODE;
+		MAC_REG_W32(R_AX_SEC_ENG_CTRL, val32);
+	} else {
+		val32 = MAC_REG_R32(R_AX_SEC_ENG_CTRL);
+		val32 &= ~B_AX_TX_PARTIAL_MODE;
+		MAC_REG_W32(R_AX_SEC_ENG_CTRL, val32);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 set_nav_padding(struct mac_ax_adapter *adapter,
+		    struct mac_ax_nav_padding *nav)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_txop = nav->band ? R_AX_PTCL_NAV_PROT_LEN_C1 : R_AX_PTCL_NAV_PROT_LEN;
+	u32 reg_cnt = nav->band ? R_AX_PROT_C1 : R_AX_PROT;
+	u32 ret;
+	u8 val8;
+#if MAC_AX_FW_REG_OFLD
+	u16 tmp;
+#endif
+
+	ret = check_mac_en(adapter, nav->band, MAC_AX_CMAC_SEL);
+	if (ret)
+		return ret;
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		tmp = nav->nav_pad_en ? nav->nav_padding : 0;
+		ret = MAC_REG_W16_OFLD((u16)reg_txop,
+				       tmp, 0);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s: write offload fail %d",
+				      __func__, ret);
+			return ret;
+		}
+		ret = MAC_REG_W16_OFLD((u16)reg_cnt,
+				       tmp, 0);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s: write offload fail %d",
+				      __func__, ret);
+			return ret;
+		}
+		ret = MAC_REG_W_OFLD((u16)reg_cnt, B_AX_NAV_OVER_TXOP_EN,
+				     nav->over_txop_en ? 1 : 0, 1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s: write offload fail %d",
+				      __func__, ret);
+			return ret;
+		}
+
+		return MACSUCCESS;
+	}
+#endif
+
+	if (nav->nav_pad_en) {
+		MAC_REG_W16(reg_txop, nav->nav_padding);
+		MAC_REG_W16(reg_cnt, nav->nav_padding);
+		val8 = MAC_REG_R8(reg_cnt + 2);
+		if (nav->over_txop_en)
+			val8 |= BIT(0);
+		else
+			val8 &= ~BIT(0);
+		MAC_REG_W8(reg_cnt + 2, val8);
+	} else {
+		MAC_REG_W16(reg_txop, 0);
+		MAC_REG_W16(reg_cnt, 0);
+	}
+
+	return MACSUCCESS;
+}
+
+static void set_delay_tx_cfg(struct mac_ax_adapter *adapter,
+			     struct mac_ax_delay_tx_cfg *cfg)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_SS_CTRL);
+	SET_CLR_WORD(val32, cfg->en, B_AX_SS_DELAY_TX_BAND_SEL);
+	MAC_REG_W32(R_AX_SS_CTRL, val32);
+
+	val32 = SET_WORD(cfg->vovi_to_b0, B_AX_SS_VOVI_TO_0) |
+		SET_WORD(cfg->bebk_to_b0, B_AX_SS_BEBK_TO_0) |
+		SET_WORD(cfg->vovi_to_b1, B_AX_SS_VOVI_TO_1) |
+		SET_WORD(cfg->bebk_to_b1, B_AX_SS_BEBK_TO_1);
+	MAC_REG_W32(R_AX_SS_DELAYTX_TO, val32);
+
+	val32 = SET_WORD(cfg->vovi_len_b0, B_AX_SS_VOVI_LEN_THR_0) |
+		SET_WORD(cfg->bebk_len_b0, B_AX_SS_BEBK_LEN_THR_0) |
+		SET_WORD(cfg->vovi_len_b1, B_AX_SS_VOVI_LEN_THR_1) |
+		SET_WORD(cfg->bebk_len_b1, B_AX_SS_BEBK_LEN_THR_1);
+	MAC_REG_W32(R_AX_SS_DELAYTX_LEN_THR, val32);
+}
+
+u32 set_core_swr_volt(struct mac_ax_adapter *adapter,
+		      enum mac_ax_core_swr_volt volt_sel)
+{
+	u8 i, j, adjust = 0;
+	s8 sign = 0, v, val8;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val8 = adapter->hw_info->core_swr_volt_sel - volt_sel;
+	if (val8 == 0) {
+		return MACSUCCESS;
+	} else if (val8 > 0) {
+		adjust = adapter->hw_info->core_swr_volt_sel - volt_sel;
+		sign = -1;
+	} else {
+		adjust = volt_sel - adapter->hw_info->core_swr_volt_sel;
+		sign = 1;
+	}
+
+	for (i = 0; i < adjust; i++) {
+		val8 = MAC_REG_R8(R_AX_SPS_DIG_ON_CTRL0);
+		v = GET_FIELD(val8, B_AX_VOL_L1);
+		v += sign;
+		if (v < CORE_SWR_VOLT_MIN)
+			v = CORE_SWR_VOLT_MIN;
+		else if (v > CORE_SWR_VOLT_MAX)
+			v = CORE_SWR_VOLT_MAX;
+
+		val8 = SET_CLR_WORD(val8, v, B_AX_VOL_L1);
+		MAC_REG_W8(R_AX_SPS_DIG_ON_CTRL0, val8);
+		for (j = 0; j < POLL_SWR_VOLT_CNT; j++)
+			PLTFM_DELAY_US(POLL_SWR_VOLT_US);
+	}
+
+	if (volt_sel == MAC_AX_SWR_NORM) {
+		val8 = MAC_REG_R8(R_AX_SPS_DIG_ON_CTRL0);
+		val8 = SET_CLR_WORD(val8, adapter->hw_info->core_swr_volt,
+				    B_AX_VOL_L1);
+		MAC_REG_W8(R_AX_SPS_DIG_ON_CTRL0, val8);
+	}
+
+	adapter->hw_info->core_swr_volt_sel = volt_sel;
+
+	return MACSUCCESS;
+}
+
+u32 set_pcie_driving_mponly(struct mac_ax_adapter *adapter,
+			    enum mac_ax_pcie_driving_ctrl drving_ctrl)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (adapter->env == DUT_ENV_FPGA || adapter->env == DUT_ENV_PXP)
+			return MACSUCCESS;
+		MAC_REG_W16(RAC_DIRECT_OFFSET_G1 + RAC_ANA20 * 2, drving_ctrl);
+		MAC_REG_W16(RAC_DIRECT_OFFSET_G1 + RAC_ANA21 * 2, PCIE_5G6G_PER_GEN1GEN2_ANA21_VAL);
+		MAC_REG_W16(RAC_DIRECT_OFFSET_G1 + RAC_ANA23 * 2, PCIE_5G6G_PER_GEN1GEN2_ANA23_VAL);
+		MAC_REG_W16(RAC_DIRECT_OFFSET_G1 + RAC_ANA2F * 2, PCIE_5G6G_PER_GEN1GEN2_ANA2F_VAL);
+
+		MAC_REG_W16(RAC_DIRECT_OFFSET_G2 + RAC_ANA20 * 2, drving_ctrl);
+		MAC_REG_W16(RAC_DIRECT_OFFSET_G2 + RAC_ANA21 * 2, PCIE_5G6G_PER_GEN1GEN2_ANA21_VAL);
+		MAC_REG_W16(RAC_DIRECT_OFFSET_G2 + RAC_ANA23 * 2, PCIE_5G6G_PER_GEN1GEN2_ANA23_VAL);
+		MAC_REG_W16(RAC_DIRECT_OFFSET_G2 + RAC_ANA2F * 2, PCIE_5G6G_PER_GEN1GEN2_ANA2F_VAL);
+
+		PLTFM_MSG_WARN("[MAC] Adjust PCIe drving only for MP use\n");
+#endif
+	}
+
+	return MACSUCCESS;
+}
+
+u32 set_macid_pause(struct mac_ax_adapter *adapter,
+		    struct mac_ax_macid_pause_cfg *cfg)
+{
+	u32 val32;
+	u8 macid_sh = cfg->macid & (32 - 1);
+	u8 macid_grp = cfg->macid >> 5;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret;
+	struct mac_ax_macid_pause_grp grp = {{0}};
+
+	ret = check_mac_en(adapter, MAC_AX_BAND_0, MAC_AX_CMAC_SEL);
+	if (ret)
+		return ret;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		if (cfg->pause) {
+			switch (macid_grp) {
+			case 0:
+				val32 = MAC_REG_R32(R_AX_MACID_SLEEP_0);
+				MAC_REG_W32(R_AX_MACID_SLEEP_0,
+					    val32 | BIT(macid_sh));
+				val32 = MAC_REG_R32(R_AX_SS_MACID_PAUSE_0);
+				MAC_REG_W32(R_AX_SS_MACID_PAUSE_0,
+					    val32 | BIT(macid_sh));
+				break;
+			case 1:
+				val32 = MAC_REG_R32(R_AX_MACID_SLEEP_1);
+				MAC_REG_W32(R_AX_MACID_SLEEP_1,
+					    val32 | BIT(macid_sh));
+				val32 = MAC_REG_R32(R_AX_SS_MACID_PAUSE_1);
+				MAC_REG_W32(R_AX_SS_MACID_PAUSE_1,
+					    val32 | BIT(macid_sh));
+				break;
+			case 2:
+				val32 = MAC_REG_R32(R_AX_MACID_SLEEP_2);
+				MAC_REG_W32(R_AX_MACID_SLEEP_2,
+					    val32 | BIT(macid_sh));
+				val32 = MAC_REG_R32(R_AX_SS_MACID_PAUSE_2);
+				MAC_REG_W32(R_AX_SS_MACID_PAUSE_2,
+					    val32 | BIT(macid_sh));
+				break;
+			case 3:
+				val32 = MAC_REG_R32(R_AX_MACID_SLEEP_3);
+				MAC_REG_W32(R_AX_MACID_SLEEP_3,
+					    val32 | BIT(macid_sh));
+				val32 = MAC_REG_R32(R_AX_SS_MACID_PAUSE_3);
+				MAC_REG_W32(R_AX_SS_MACID_PAUSE_3,
+					    val32 | BIT(macid_sh));
+				break;
+			default:
+				break;
+			}
+		} else {
+			switch (macid_grp) {
+			case 0:
+				val32 = MAC_REG_R32(R_AX_MACID_SLEEP_0);
+				MAC_REG_W32(R_AX_MACID_SLEEP_0,
+					    val32 & ~(BIT(macid_sh)));
+				val32 = MAC_REG_R32(R_AX_SS_MACID_PAUSE_0);
+				MAC_REG_W32(R_AX_SS_MACID_PAUSE_0,
+					    val32 & ~(BIT(macid_sh)));
+				break;
+			case 1:
+				val32 = MAC_REG_R32(R_AX_MACID_SLEEP_1);
+				MAC_REG_W32(R_AX_MACID_SLEEP_1,
+					    val32 & ~(BIT(macid_sh)));
+				val32 = MAC_REG_R32(R_AX_SS_MACID_PAUSE_1);
+				MAC_REG_W32(R_AX_SS_MACID_PAUSE_1,
+					    val32 & ~(BIT(macid_sh)));
+				break;
+			case 2:
+				val32 = MAC_REG_R32(R_AX_MACID_SLEEP_2);
+				MAC_REG_W32(R_AX_MACID_SLEEP_2,
+					    val32 & ~(BIT(macid_sh)));
+				val32 = MAC_REG_R32(R_AX_SS_MACID_PAUSE_2);
+				MAC_REG_W32(R_AX_SS_MACID_PAUSE_2,
+					    val32 & ~(BIT(macid_sh)));
+				break;
+			case 3:
+				val32 = MAC_REG_R32(R_AX_MACID_SLEEP_3);
+				MAC_REG_W32(R_AX_MACID_SLEEP_3,
+					    val32 & ~(BIT(macid_sh)));
+				val32 = MAC_REG_R32(R_AX_SS_MACID_PAUSE_3);
+				MAC_REG_W32(R_AX_SS_MACID_PAUSE_3,
+					    val32 & ~(BIT(macid_sh)));
+				break;
+			default:
+				break;
+			}
+		}
+	} else {
+		grp.mask_grp[macid_grp] = BIT(macid_sh);
+		grp.pause_grp[macid_grp] = cfg->pause << macid_sh;
+
+		ret = macid_pause(adapter, &grp);
+
+		if (ret)
+			return ret;
+	}
+	return MACSUCCESS;
+}
+
+u32 set_cctl_preld(struct mac_ax_adapter *adapter,
+		   struct mac_ax_cctl_preld_cfg *cfg)
+{
+#if MAC_AX_PCIE_SUPPORT
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+	struct rtw_hal_mac_ax_cctl_info info;
+	struct rtw_hal_mac_ax_cctl_info mask;
+
+	PLTFM_MEMSET(&mask, 0, sizeof(struct rtw_hal_mac_ax_cctl_info));
+	PLTFM_MEMSET(&info, 0, sizeof(struct rtw_hal_mac_ax_cctl_info));
+
+	info.preld_en = cfg->en;
+	mask.preld_en = 1;
+
+	mops->upd_cctl_info(adapter, &info, &mask, cfg->macid, TBL_WRITE_OP);
+
+	return MACSUCCESS;
+#else
+	return MACPROCERR;
+#endif
+}
+
+u32 macid_pause(struct mac_ax_adapter *adapter,
+		struct mac_ax_macid_pause_grp *grp)
+{
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	struct fwcmd_macid_pause *para;
+
+	ret = check_mac_en(adapter, MAC_AX_BAND_0, MAC_AX_CMAC_SEL);
+	if (ret)
+		return ret;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_macid_pause));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	para = (struct fwcmd_macid_pause *)buf;
+
+	para->dword0 =
+	cpu_to_le32(SET_WORD(grp->pause_grp[0],
+			     FWCMD_H2C_MACID_PAUSE_PAUSE_GRP_1));
+	para->dword1 =
+	cpu_to_le32(SET_WORD(grp->pause_grp[1],
+			     FWCMD_H2C_MACID_PAUSE_PAUSE_GRP_2));
+	para->dword2 =
+	cpu_to_le32(SET_WORD(grp->pause_grp[2],
+			     FWCMD_H2C_MACID_PAUSE_PAUSE_GRP_3));
+	para->dword3 =
+	cpu_to_le32(SET_WORD(grp->pause_grp[3],
+			     FWCMD_H2C_MACID_PAUSE_PAUSE_GRP_4));
+	para->dword4 =
+	cpu_to_le32(SET_WORD(grp->mask_grp[0],
+			     FWCMD_H2C_MACID_PAUSE_MASK_GRP_1));
+	para->dword5 =
+	cpu_to_le32(SET_WORD(grp->mask_grp[1],
+			     FWCMD_H2C_MACID_PAUSE_MASK_GRP_2));
+	para->dword6 =
+	cpu_to_le32(SET_WORD(grp->mask_grp[2],
+			     FWCMD_H2C_MACID_PAUSE_MASK_GRP_3));
+	para->dword7 =
+	cpu_to_le32(SET_WORD(grp->mask_grp[3],
+			     FWCMD_H2C_MACID_PAUSE_MASK_GRP_4));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_MACID_PAUSE,
+			      1, 0);
+	if (ret)
+		goto fail;
+
+	// Return MACSUCCESS if h2c aggregation is enabled and enqueued successfully.
+	// The H2C shall be sent by mac_h2c_agg_tx.
+	ret = h2c_agg_enqueue(adapter, h2cb);
+	if (ret == MACSUCCESS)
+		return MACSUCCESS;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx\n");
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+	return ret;
+}
+
+static u32 poll_macid_pause_sleep_done_ack(struct mac_ax_adapter *adapter)
+{
+#define RETRY_WAIT_PKT_US 50
+#define MACID_PAUSE_SLEEP_WAIT_PKT_CNT 20000
+	u32 cnt;
+
+	cnt = TX_PAUSE_WAIT_PKT_CNT;
+	while (--cnt) {
+		if (adapter->sm.macid_pause_sleep == MAC_AX_OFLD_H2C_DONE)
+			break;
+		PLTFM_DELAY_US(RETRY_WAIT_PKT_US);
+	}
+	adapter->sm.macid_pause_sleep = MAC_AX_OFLD_H2C_IDLE;
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR]macid_pause_sleep DONE ACK timeout\n");
+		return MACPROCERR;
+	}
+	return MACSUCCESS;
+}
+
+u32 macid_pause_sleep(struct mac_ax_adapter *adapter,
+		      struct mac_ax_macid_pause_sleep_grp *grp)
+{
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	struct fwcmd_macid_pause_sleep *para;
+
+	ret = check_mac_en(adapter, MAC_AX_BAND_0, MAC_AX_CMAC_SEL);
+	if (ret)
+		return ret;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_ERR("[ERR]%s fw not ready\n", __func__);
+		return MACNOFW;
+	}
+
+	if (adapter->sm.macid_pause_sleep != MAC_AX_OFLD_H2C_IDLE) {
+		PLTFM_MSG_ERR("[ERR]%s state machine not MAC_AX_OFLD_H2C_IDLE\n", __func__);
+		return MACPROCERR;
+	}
+
+	adapter->sm.macid_pause_sleep = MAC_AX_OFLD_H2C_SENDING;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_macid_pause_sleep));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	para = (struct fwcmd_macid_pause_sleep *)buf;
+
+	para->dword0 =
+	cpu_to_le32(SET_WORD(grp->pause_grp[0],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_PAUSE_GRP_EN_1));
+	para->dword1 =
+	cpu_to_le32(SET_WORD(grp->pause_grp[1],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_PAUSE_GRP_EN_2));
+	para->dword2 =
+	cpu_to_le32(SET_WORD(grp->pause_grp[2],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_PAUSE_GRP_EN_3));
+	para->dword3 =
+	cpu_to_le32(SET_WORD(grp->pause_grp[3],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_PAUSE_GRP_EN_4));
+	para->dword4 =
+	cpu_to_le32(SET_WORD(grp->pause_grp_mask[0],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_PAUSE_GRP_MASK_1));
+	para->dword5 =
+	cpu_to_le32(SET_WORD(grp->pause_grp_mask[1],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_PAUSE_GRP_MASK_2));
+	para->dword6 =
+	cpu_to_le32(SET_WORD(grp->pause_grp_mask[2],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_PAUSE_GRP_MASK_3));
+	para->dword7 =
+	cpu_to_le32(SET_WORD(grp->pause_grp_mask[3],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_PAUSE_GRP_MASK_4));
+
+	para->dword8 =
+	cpu_to_le32(SET_WORD(grp->sleep_grp[0],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_SLEEP_GRP_EN_1));
+	para->dword9 =
+	cpu_to_le32(SET_WORD(grp->sleep_grp[1],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_SLEEP_GRP_EN_2));
+	para->dword10 =
+	cpu_to_le32(SET_WORD(grp->sleep_grp[2],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_SLEEP_GRP_EN_3));
+	para->dword11 =
+	cpu_to_le32(SET_WORD(grp->sleep_grp[3],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_SLEEP_GRP_EN_4));
+	para->dword12 =
+	cpu_to_le32(SET_WORD(grp->sleep_grp_mask[0],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_SLEEP_GRP_MASK_1));
+	para->dword13 =
+	cpu_to_le32(SET_WORD(grp->sleep_grp_mask[1],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_SLEEP_GRP_MASK_2));
+	para->dword14 =
+	cpu_to_le32(SET_WORD(grp->sleep_grp_mask[2],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_SLEEP_GRP_MASK_3));
+	para->dword15 =
+	cpu_to_le32(SET_WORD(grp->sleep_grp_mask[3],
+			     FWCMD_H2C_MACID_PAUSE_SLEEP_SLEEP_GRP_MASK_4));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD, FWCMD_H2C_FUNC_MACID_PAUSE_SLEEP,
+			      0, 1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx\n");
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return poll_macid_pause_sleep_done_ack(adapter);
+fail:
+	h2cb_free(adapter, h2cb);
+	return ret;
+}
+
+static u32 enable_macid_pause_sleep(struct mac_ax_adapter *adapter,
+				    u8 macid, u8 enable, u32 *grp_reg)
+{
+#define MACID_PAUSE_SH 5
+#define MACID_PAUSE_MSK 0x1F
+	u32 val32;
+	u8 macid_sh, macid_grp;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	macid_sh = macid & MACID_PAUSE_MSK;
+	macid_grp = macid >> MACID_PAUSE_SH;
+	if (macid_grp >= 4) {
+		PLTFM_MSG_ERR("%s: unexpected macid %x\n",
+			      __func__, macid);
+		return MACNOTSUP;
+	}
+	val32 = MAC_REG_R32(grp_reg[macid_grp]);
+	if (enable)
+		MAC_REG_W32(grp_reg[macid_grp], val32 | BIT(macid_sh));
+	else
+		MAC_REG_W32(grp_reg[macid_grp], val32 & ~(BIT(macid_sh)));
+
+	return MACSUCCESS;
+#undef MACID_PAUSE_SH
+#undef MACID_PAUSE_MSK
+}
+
+u32 set_macid_pause_sleep(struct mac_ax_adapter *adapter,
+			  struct mac_ax_macid_pause_sleep_cfg *cfg)
+{
+#define MACID_PAUSE_SH 5
+#define MACID_PAUSE_MSK 0x1F
+	u8 macid_sh;
+	u8 macid_grp;
+	u32 ret;
+	struct mac_ax_macid_pause_sleep_grp grp = {{0}};
+	u32 pause_reg[4] = {
+		R_AX_SS_MACID_PAUSE_0, R_AX_SS_MACID_PAUSE_1,
+		R_AX_SS_MACID_PAUSE_2, R_AX_SS_MACID_PAUSE_3
+	};
+	u32 sleep_reg[4] = {
+		R_AX_MACID_SLEEP_0, R_AX_MACID_SLEEP_1,
+		R_AX_MACID_SLEEP_2, R_AX_MACID_SLEEP_3
+	};
+
+	ret = check_mac_en(adapter, MAC_AX_BAND_0, MAC_AX_CMAC_SEL);
+	if (ret)
+		return ret;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		ret = enable_macid_pause_sleep(adapter, cfg->macid, cfg->pause, pause_reg);
+		if (ret) {
+			PLTFM_MSG_ERR("%s: setting pause failed: %d\n",
+				      __func__, ret);
+			return ret;
+		}
+		ret = enable_macid_pause_sleep(adapter, cfg->macid, cfg->sleep, sleep_reg);
+		if (ret) {
+			PLTFM_MSG_ERR("%s: setting sleep failed: %d\n",
+				      __func__, ret);
+			return ret;
+		}
+	} else {
+		macid_sh = cfg->macid & MACID_PAUSE_MSK;
+		macid_grp = cfg->macid >> MACID_PAUSE_SH;
+
+		grp.pause_grp_mask[macid_grp] = BIT(macid_sh);
+		grp.pause_grp[macid_grp] = (cfg->pause ? 1 : 0) << macid_sh;
+
+		grp.sleep_grp_mask[macid_grp] = BIT(macid_sh);
+		grp.sleep_grp[macid_grp] = (cfg->sleep ? 1 : 0) << macid_sh;
+
+		ret = macid_pause_sleep(adapter, &grp);
+
+		if (ret)
+			return ret;
+	}
+	return MACSUCCESS;
+#undef MACID_PAUSE_SH
+#undef MACID_PAUSE_MSK
+}
+
+u32 set_ss_quota_mode(struct mac_ax_adapter *adapter,
+		      struct mac_ax_ss_quota_mode_ctrl *ctrl)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32_wmm, val32_ul, ret;
+
+	val32_wmm = MAC_REG_R32(R_AX_SS_DL_QUOTA_CTRL);
+	val32_ul = MAC_REG_R32(R_AX_SS_UL_QUOTA_CTRL);
+	switch (ctrl->wmm) {
+	case MAC_AX_SS_WMM0:
+		if (ctrl->mode == MAC_AX_SS_QUOTA_MODE_CNT)
+			MAC_REG_W32(R_AX_SS_DL_QUOTA_CTRL,
+				    val32_wmm | B_AX_SS_QUOTA_MODE_0);
+		else
+			MAC_REG_W32(R_AX_SS_DL_QUOTA_CTRL,
+				    val32_wmm & ~B_AX_SS_QUOTA_MODE_0);
+		break;
+	case MAC_AX_SS_WMM1:
+		if (ctrl->mode == MAC_AX_SS_QUOTA_MODE_CNT)
+			MAC_REG_W32(R_AX_SS_DL_QUOTA_CTRL,
+				    val32_wmm | B_AX_SS_QUOTA_MODE_1);
+		else
+			MAC_REG_W32(R_AX_SS_DL_QUOTA_CTRL,
+				    val32_wmm & ~B_AX_SS_QUOTA_MODE_1);
+		break;
+	case MAC_AX_SS_WMM2:
+		if (ctrl->mode == MAC_AX_SS_QUOTA_MODE_CNT)
+			MAC_REG_W32(R_AX_SS_DL_QUOTA_CTRL,
+				    val32_wmm | B_AX_SS_QUOTA_MODE_2);
+		else
+			MAC_REG_W32(R_AX_SS_DL_QUOTA_CTRL,
+				    val32_wmm & ~B_AX_SS_QUOTA_MODE_2);
+		break;
+	case MAC_AX_SS_WMM3:
+		if (ctrl->mode == MAC_AX_SS_QUOTA_MODE_CNT)
+			MAC_REG_W32(R_AX_SS_DL_QUOTA_CTRL,
+				    val32_wmm | B_AX_SS_QUOTA_MODE_3);
+		else
+			MAC_REG_W32(R_AX_SS_DL_QUOTA_CTRL,
+				    val32_wmm & ~B_AX_SS_QUOTA_MODE_3);
+		break;
+	case MAC_AX_SS_UL:
+		if (ctrl->mode == MAC_AX_SS_QUOTA_MODE_CNT)
+			MAC_REG_W32(R_AX_SS_UL_QUOTA_CTRL,
+				    val32_ul | B_AX_SS_QUOTA_MODE_UL);
+		else
+			MAC_REG_W32(R_AX_SS_UL_QUOTA_CTRL,
+				    val32_ul & ~B_AX_SS_QUOTA_MODE_UL);
+		break;
+	}
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		switch (ctrl->wmm) {
+		case MAC_AX_SS_WMM0:
+		case MAC_AX_SS_WMM1:
+		case MAC_AX_SS_UL:
+			ret = check_mac_en(adapter, 0, MAC_AX_CMAC_SEL);
+			if (ret != MACSUCCESS)
+				return ret;
+			if (ctrl->mode == MAC_AX_SS_QUOTA_MODE_TIME) {
+				ret = MAC_REG_W_OFLD(R_AX_PTCL_ATM,
+						     B_AX_ATM_AIRTIME_EN, 1, 1);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("%s: config fail\n",
+						      __func__);
+					return ret;
+				}
+			}
+			break;
+		case MAC_AX_SS_WMM2:
+		case MAC_AX_SS_WMM3:
+			ret = check_mac_en(adapter, 1, MAC_AX_CMAC_SEL);
+			if (ret != MACSUCCESS)
+				return ret;
+			if (ctrl->mode == MAC_AX_SS_QUOTA_MODE_TIME) {
+				ret = MAC_REG_W_OFLD(R_AX_PTCL_ATM_C1,
+						     B_AX_ATM_AIRTIME_EN, 1, 1);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("%s: config fail\n",
+						      __func__);
+					return ret;
+				}
+			}
+			break;
+		}
+
+		return MACSUCCESS;
+	}
+#endif
+
+	switch (ctrl->wmm) {
+	case MAC_AX_SS_WMM0:
+	case MAC_AX_SS_WMM1:
+	case MAC_AX_SS_UL:
+		ret = check_mac_en(adapter, 0, MAC_AX_CMAC_SEL);
+		if (ret != MACSUCCESS)
+			return ret;
+		val32_wmm = MAC_REG_R32(R_AX_PTCL_ATM);
+		if (ctrl->mode == MAC_AX_SS_QUOTA_MODE_TIME)
+			MAC_REG_W32(R_AX_PTCL_ATM,
+				    val32_wmm | B_AX_ATM_AIRTIME_EN);
+		break;
+	case MAC_AX_SS_WMM2:
+	case MAC_AX_SS_WMM3:
+		ret = check_mac_en(adapter, 1, MAC_AX_CMAC_SEL);
+		if (ret != MACSUCCESS)
+			return ret;
+		val32_wmm = MAC_REG_R32(R_AX_PTCL_ATM_C1);
+		if (ctrl->mode == MAC_AX_SS_QUOTA_MODE_TIME)
+			MAC_REG_W32(R_AX_PTCL_ATM_C1,
+				    val32_wmm | B_AX_ATM_AIRTIME_EN);
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 ss_set_quotasetting(struct mac_ax_adapter *adapter,
+			struct mac_ax_ss_quota_setting *para)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 cnt = 1000;
+
+	if (para->ul_dl == mac_ax_issue_ul) {
+		val32 = (B_AX_SS_OWN |
+			SET_WORD(SS_W_QUOTA_SETTING, B_AX_SS_CMD_SEL) |
+			BIT(23) | SET_WORD(para->val, B_AX_SS_VALUE) |
+			para->macid);
+		MAC_REG_W32(R_AX_SS_SRAM_CTRL_1, val32);
+	} else {
+		val32 = (B_AX_SS_OWN |
+			SET_WORD(SS_W_QUOTA_SETTING, B_AX_SS_CMD_SEL) |
+			SET_WORD(para->ac_type, B_AX_SS_AC) |
+			SET_WORD(para->val, B_AX_SS_VALUE) | para->macid);
+		MAC_REG_W32(R_AX_SS_SRAM_CTRL_1, val32);
+	}
+
+	while (--cnt) {
+		val32 = MAC_REG_R32(R_AX_SS_SRAM_CTRL_1);
+		if ((val32 & B_AX_SS_OWN) == 0)
+			break;
+		PLTFM_DELAY_US(1);
+	}
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("SS Set quota setting fail!!\n");
+		return MACPOLLTO;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 scheduler_set_prebkf(struct mac_ax_adapter *adapter,
+			 struct mac_ax_prebkf_setting *para)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg, val32;
+#if MAC_AX_FW_REG_OFLD
+	u32 ret;
+#endif
+
+	reg = para->band == MAC_AX_BAND_1 ? R_AX_PREBKF_CFG_0_C1 :
+			    R_AX_PREBKF_CFG_0;
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = MAC_REG_W_OFLD((u16)reg, B_AX_PREBKF_TIME_MSK, para->val,
+				     1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s: config fail\n", __func__);
+			return ret;
+		}
+
+		return MACSUCCESS;
+	}
+#endif
+	val32 = MAC_REG_R32(reg);
+	val32 = SET_CLR_WORD(val32, para->val, B_AX_PREBKF_TIME);
+	MAC_REG_W32(reg, val32);
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_tx_cnt(struct mac_ax_adapter *adapter,
+		   struct mac_ax_tx_cnt *cnt)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 txcnt_addr;
+	u32 val32;
+	u16 val16;
+	u8 sel;
+
+	if (cnt->band != 0 && cnt->band != 1)
+		return MACNOITEM;
+	if (check_mac_en(adapter, cnt->band, MAC_AX_CMAC_SEL))
+		return MACHWNOTEN;
+	txcnt_addr = (cnt->band == MAC_AX_BAND_0) ?
+		      R_AX_TX_PPDU_CNT : R_AX_TX_PPDU_CNT_C1;
+	for (sel = 0; sel < MAC_AX_TX_ALLTYPE; sel++) {
+		val16 = MAC_REG_R16(txcnt_addr);
+		val16 = SET_CLR_WORD(val16, sel, B_AX_PPDU_CNT_IDX);
+		MAC_REG_W16(txcnt_addr, val16);
+		PLTFM_DELAY_US(1000);
+		val32 = MAC_REG_R32(txcnt_addr);
+		cnt->txcnt[sel] = GET_FIELD(val32, B_AX_TX_PPDU_CNT);
+	}
+	return MACSUCCESS;
+}
+
+u32 cfg_wdt_isr_rst(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+
+	val = val & ~B_AX_APB_WRAP_EN;
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val);
+
+	val = val | B_AX_APB_WRAP_EN;
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val);
+
+	return MACSUCCESS;
+}
+
+u32 mac_clr_tx_cnt(struct mac_ax_adapter *adapter,
+		   struct mac_ax_tx_cnt *cnt)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u16 txcnt_addr;
+	u16 val16;
+	u16 to;
+	u8 i;
+
+	if (cnt->band != 0 && cnt->band != 1)
+		return MACNOITEM;
+	if (check_mac_en(adapter, cnt->band, MAC_AX_CMAC_SEL))
+		return MACHWNOTEN;
+	if (cnt->sel > MAC_AX_TX_ALLTYPE)
+		return MACNOITEM;
+
+	txcnt_addr = (cnt->band == MAC_AX_BAND_0) ?
+		      R_AX_TX_PPDU_CNT : R_AX_TX_PPDU_CNT_C1;
+
+#if MAC_AX_FW_REG_OFLD
+	u32 ret;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		for (i = 0; i < MAC_AX_TX_ALLTYPE; i++) {
+			if (cnt->sel == MAC_AX_TX_ALLTYPE || i == cnt->sel) {
+				ret = MAC_REG_W_OFLD(txcnt_addr,
+						     B_AX_PPDU_CNT_RIDX_MSK <<
+						     B_AX_PPDU_CNT_RIDX_SH,
+						     i, 0);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("%s: write offload fail;"
+						      "offset: %u, ret: %u\n",
+						      __func__, txcnt_addr, ret);
+					return ret;
+				}
+				ret = MAC_REG_W_OFLD(txcnt_addr, B_AX_RST_PPDU_CNT,
+						     1, 0);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("%s: write offload fail;"
+						      "offset: %u, ret: %u\n",
+						      __func__, txcnt_addr, ret);
+					return ret;
+				}
+				ret = MAC_REG_P_OFLD(txcnt_addr, B_AX_RST_PPDU_CNT, 0,
+						     (cnt->sel != MAC_AX_TX_ALLTYPE ||
+						     i == MAC_AX_TX_ALLTYPE - 1) ?
+						     1 : 0);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("%s: poll offload fail;"
+						      "offset: %u, ret: %u\n",
+						      __func__, txcnt_addr, ret);
+					return ret;
+				}
+			}
+		}
+		return MACSUCCESS;
+	}
+#endif
+	to = 1000;
+	for (i = 0; i < MAC_AX_TX_ALLTYPE; i++) {
+		if (cnt->sel == MAC_AX_TX_ALLTYPE || i == cnt->sel) {
+			val16 = MAC_REG_R16(txcnt_addr);
+			val16 = SET_CLR_WORD(val16, i, B_AX_PPDU_CNT_RIDX) |
+					     B_AX_RST_PPDU_CNT;
+			MAC_REG_W16(txcnt_addr, val16);
+			while (to--) {
+				val16 = MAC_REG_R16(txcnt_addr);
+				if (!(val16 & B_AX_RST_PPDU_CNT))
+					break;
+				PLTFM_DELAY_US(5);
+			}
+			if (to == 0)
+				return MACPOLLTO;
+		}
+	}
+	return MACSUCCESS;
+}
+
+u32 mac_set_adapter_info(struct mac_ax_adapter *adapter,
+			 struct mac_ax_adapter_info *set)
+{
+#ifdef RTW_WKARD_GET_PROCESSOR_ID
+	adapter->hw_info->adpt_info.cust_proc_id.proc_id.proc_id_h =
+		set->cust_proc_id.proc_id.proc_id_h;
+	adapter->hw_info->adpt_info.cust_proc_id.proc_id.proc_id_l =
+		set->cust_proc_id.proc_id.proc_id_l;
+	adapter->hw_info->adpt_info.cust_proc_id.customer_id =
+		set->cust_proc_id.customer_id;
+	memcpy(set->cust_proc_id.base_board_id,
+	       adapter->hw_info->adpt_info.cust_proc_id.base_board_id, BASE_BOARD_ID_LEN);
+#endif
+	return MACSUCCESS;
+}
+
+u32 mac_set_hw_value(struct mac_ax_adapter *adapter,
+		     enum mac_ax_hw_id hw_id, void *val)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret = MACSUCCESS;
+
+	if (!val) {
+		PLTFM_MSG_ERR("[ERR]: the parameter is NULL in %s\n", __func__);
+		return MACNPTR;
+	}
+
+	switch (hw_id) {
+	case MAC_AX_HW_SETTING:
+		break;
+	case MAC_AX_HW_SET_ID_PAUSE:
+		ret = set_macid_pause(adapter,
+				      (struct mac_ax_macid_pause_cfg *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_SET_MULTI_ID_PAUSE:
+		ret = macid_pause(adapter,
+				  (struct mac_ax_macid_pause_grp *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_SET_ID_PAUSE_SLEEP:
+		ret = set_macid_pause_sleep(adapter,
+					    (struct mac_ax_macid_pause_sleep_cfg *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_SET_MULTI_ID_PAUSE_SLEEP:
+		ret = macid_pause_sleep(adapter,
+					(struct mac_ax_macid_pause_sleep_grp *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_SET_SCH_TXEN_CFG:
+		ret = set_hw_sch_tx_en(adapter,
+				       (struct mac_ax_sch_tx_en_cfg *)val);
+		break;
+	case MAC_AX_HW_SET_AMPDU_CFG:
+		ret = set_hw_ampdu_cfg(adapter, (struct mac_ax_ampdu_cfg *)val);
+		break;
+	case MAC_AX_HW_SET_USR_EDCA_PARAM:
+		ret =
+		set_hw_usr_edca_param(adapter,
+				      (struct mac_ax_usr_edca_param *)val);
+		break;
+	case MAC_AX_HW_SET_USR_TX_RPT_CFG:
+		ret =
+		set_hw_usr_tx_rpt_cfg(adapter,
+				      (struct mac_ax_usr_tx_rpt_cfg *)val);
+		break;
+	case MAC_AX_HW_SET_EDCA_PARAM:
+		ret = set_hw_edca_param(adapter,
+					(struct mac_ax_edca_param *)val);
+		break;
+	case MAC_AX_HW_SET_EDCCA_PARAM:
+		ret = set_hw_edcca_param(adapter,
+					 (struct mac_ax_edcca_param *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_SET_MUEDCA_PARAM:
+		ret = set_hw_muedca_param(adapter,
+					  (struct mac_ax_muedca_param *)val);
+		break;
+	case MAC_AX_HW_SET_MUEDCA_CTRL:
+		ret = set_hw_muedca_ctrl(adapter,
+					 (struct mac_ax_muedca_cfg *)val);
+		break;
+	case MAC_AX_HW_SET_TBPPDU_CTRL:
+		ret = set_hw_tb_ppdu_ctrl(adapter,
+					  (struct mac_ax_tb_ppdu_ctrl *)val);
+		break;
+	case MAC_AX_HW_SET_HOST_RPR:
+		set_host_rpr(adapter, (struct mac_ax_host_rpr_cfg *)val);
+		break;
+	case MAC_AX_HW_SET_DELAYTX_CFG:
+		set_delay_tx_cfg(adapter, (struct mac_ax_delay_tx_cfg *)val);
+		break;
+	case MAC_AX_HW_SET_BW_CFG:
+		ret = cfg_mac_bw(adapter, (struct mac_ax_cfg_bw *)val);
+		break;
+	case MAC_AX_HW_SET_CH_BUSY_STAT_CFG:
+		ret = set_hw_ch_busy_cnt(adapter,
+					 (struct mac_ax_ch_busy_cnt_cfg *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_SET_LIFETIME_CFG:
+		ret = set_hw_lifetime_cfg(adapter,
+					  (struct mac_ax_lifetime_cfg *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_EN_BB_RF:
+		ret = set_enable_bb_rf(adapter, *(u8 *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_SET_APP_FCS:
+		set_append_fcs(adapter, *(u8 *)val);
+		break;
+	case MAC_AX_HW_SET_RX_ICVERR:
+		set_accept_icverr(adapter, *(u8 *)val);
+		break;
+	case MAC_AX_HW_SET_CCTL_RTY_LMT:
+		set_cctl_rty_limit(adapter,
+				   (struct mac_ax_cctl_rty_lmt_cfg *)val);
+		break;
+	case MAC_AX_HW_SET_COEX_GNT:
+		ret = p_ops->cfg_gnt(adapter, (struct mac_ax_coex_gnt *)val);
+		break;
+	case MAC_AX_HW_SET_SCOREBOARD:
+		mac_cfg_sb(adapter, *(u32 *)val);
+		break;
+	case MAC_AX_HW_SET_POLLUTED:
+		mac_cfg_plt(adapter, (struct mac_ax_plt *)val);
+		break;
+	case MAC_AX_HW_SET_COEX_CTRL:
+		p_ops->cfg_ctrl_path(adapter, *(u32 *)val);
+		break;
+	case MAC_AX_HW_SET_CLR_TX_CNT:
+		ret = mac_clr_tx_cnt(adapter, (struct mac_ax_tx_cnt *)val);
+		break;
+	case MAC_AX_HW_SET_SLOT_TIME:
+		mac_set_slot_time(adapter, *(enum mac_ax_slot_time *)val);
+		break;
+	case MAC_AX_HW_SET_XTAL_AAC_MODE:
+		set_xtal_aac(adapter, *(u8 *)val);
+		break;
+	case MAC_AX_HW_SET_NAV_PADDING:
+		ret = set_nav_padding(adapter, (struct mac_ax_nav_padding *)val);
+		break;
+	case MAC_AX_HW_SET_MAX_TX_TIME:
+		ret = mac_set_cctl_max_tx_time(adapter,
+					       (struct mac_ax_max_tx_time *)
+					       val);
+		break;
+	case MAC_AX_HW_SET_SS_QUOTA_MODE:
+		ret = set_ss_quota_mode(adapter,
+					(struct mac_ax_ss_quota_mode_ctrl *)val);
+		break;
+	case MAC_AX_HW_SET_SS_QUOTA_SETTING:
+		ret = ss_set_quotasetting(adapter,
+					  (struct mac_ax_ss_quota_setting *)val);
+		break;
+	case MAC_AX_HW_SET_SCHE_PREBKF:
+		ret = scheduler_set_prebkf(adapter,
+					   (struct mac_ax_prebkf_setting *)val);
+		break;
+	case MAC_AX_HW_SET_WDT_ISR_RST:
+		ret = cfg_wdt_isr_rst(adapter);
+		break;
+	case MAC_AX_HW_SET_RESP_ACK:
+		ret = set_mac_resp_ack(adapter, (u32 *)val);
+		break;
+	case MAC_AX_HW_SET_HW_RTS_TH:
+		ret = mac_set_hw_rts_th(adapter,
+					(struct mac_ax_hw_rts_th *)val);
+		break;
+	case MAC_AX_HW_SET_TX_RU26_TB:
+		ret = mac_set_tx_ru26_tb(adapter, *(u8 *)val);
+		break;
+	case MAC_AX_HW_SET_BACAM_MODE_SEL:
+		ret = set_bacam_mode(adapter, *(u8 *)val);
+		break;
+	case MAC_AX_HW_SET_CORE_SWR_VOLT:
+		ret = set_core_swr_volt(adapter,
+					*(enum mac_ax_core_swr_volt *)val);
+		break;
+	case MAC_AX_HW_SET_PARTIAL_PLD_MODE:
+		ret = set_partial_pld_mode(adapter, *(u8 *)val);
+		break;
+	case MAC_AX_HW_SET_GT3_TIMER:
+		ret = set_gt3_timer(adapter,
+				    (struct mac_ax_gt3_cfg *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_SET_RRSR_CFG:
+		ret = p_ops->set_rrsr_cfg(adapter,
+					  (struct mac_ax_rrsr_cfg *)val);
+		break;
+	case MAC_AX_HW_SET_CTS_RRSR_CFG:
+		ret = p_ops->set_cts_rrsr_cfg(adapter,
+					      (struct mac_ax_cts_rrsr_cfg *)val);
+		break;
+	case MAC_AX_HW_SET_ADAPTER:
+		ret = mac_set_adapter_info(adapter,
+					   (struct mac_ax_adapter_info *)val);
+		break;
+	case MAC_AX_HW_SET_RESP_ACK_CHK_CCA:
+		ret = _patch_rsp_ack(adapter, (struct mac_ax_resp_chk_cca *)val);
+		break;
+	case MAC_AX_HW_SET_SIFS_R2T_T2T:
+		ret =
+		set_hw_sifs_r2t_t2t(adapter,
+				    (struct mac_ax_sifs_r2t_t2t_ctrl *)val);
+		break;
+	case MAC_AX_HW_SET_RXD_ZLD_EN:
+		ret = set_rxd_zld_en(adapter, *(u8 *)val);
+		break;
+	case MAC_AX_HW_SET_SER_DBG_LVL:
+		ret = mac_dbg_log_lvl_adjust(adapter, (struct mac_debug_log_lvl *)val);
+		break;
+	case MAC_AX_HW_SET_DATA_RTY_LMT:
+		ret = set_data_rty_limit(adapter, (struct mac_ax_rty_lmt *)val);
+		break;
+	case MAC_AX_HW_SET_CTS2SELF:
+		ret = set_cts2self(adapter, (struct mac_ax_cts2self_cfg *)val);
+		break;
+#if MAC_AX_SDIO_SUPPORT
+	case MAC_AX_HW_SDIO_INFO:
+		set_info_sdio(adapter, (struct mac_ax_sdio_info *)val);
+		break;
+	case MAC_AX_HW_SDIO_TX_MODE:
+		ret = p_ops->tx_mode_cfg_sdio(adapter,
+					      *(enum mac_ax_sdio_tx_mode *)val);
+		break;
+	case MAC_AX_HW_SDIO_RX_AGG:
+		p_ops->rx_agg_cfg_sdio(adapter, (struct mac_ax_rx_agg_cfg *)val);
+		break;
+	case MAC_AX_HW_SDIO_TX_AGG:
+		ret = tx_agg_cfg_sdio(adapter,
+				      (struct mac_ax_sdio_txagg_cfg *)val);
+		break;
+	case MAC_AX_HW_SDIO_AVAL_PAGE:
+		p_ops->aval_page_cfg_sdio(adapter, (struct mac_ax_aval_page_cfg *)val);
+		break;
+	case MAC_AX_HW_SDIO_MON_WT:
+		p_ops->set_wt_cfg_sdio(adapter, *(u8 *)val);
+		break;
+#endif
+#if MAC_AX_PCIE_SUPPORT
+	case MAC_AX_HW_PCIE_CFGSPC_SET:
+		ret = cfgspc_set_pcie(adapter,
+				      (struct mac_ax_pcie_cfgspc_param *)val);
+		break;
+	case MAC_AX_HW_PCIE_RST_BDRAM:
+		ret = p_ops->rst_bdram_pcie(adapter, *(u8 *)val);
+		break;
+	case MAX_AX_HW_PCIE_LTR_SW_TRIGGER:
+		ret = p_ops->ltr_sw_trigger(adapter,
+					    *(enum mac_ax_pcie_ltr_sw_ctrl *)val);
+		break;
+	case MAX_AX_HW_PCIE_MIT:
+		ret = p_ops->trx_mit_pcie(adapter,
+					  (struct mac_ax_pcie_trx_mitigation *)val);
+		break;
+	case MAX_AX_HW_PCIE_L2_LEAVE:
+		ret = set_pcie_l2_leave(adapter, *(u8 *)val);
+		break;
+	case MAC_AX_HW_SET_CCTL_PRELD:
+		set_cctl_preld(adapter, (struct mac_ax_cctl_preld_cfg *)val);
+		break;
+	case MAC_AX_HW_PCIE_DRIVING_MPONLY:
+		set_pcie_driving_mponly(adapter, *(enum mac_ax_pcie_driving_ctrl *)val);
+		break;
+#endif
+	default:
+		return MACNOITEM;
+	}
+
+	return ret;
+}
+
+u32 get_macid_pause(struct mac_ax_adapter *adapter,
+		    struct mac_ax_macid_pause_cfg *cfg)
+{
+	u32 val32 = 0;
+	u8 macid_grp = cfg->macid >> 5;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret;
+
+	ret = check_mac_en(adapter, MAC_AX_BAND_0, MAC_AX_CMAC_SEL);
+	if (ret)
+		return ret;
+
+	switch (macid_grp) {
+	case 0:
+		val32 = MAC_REG_R32(R_AX_SS_MACID_PAUSE_0) |
+			MAC_REG_R32(R_AX_MACID_SLEEP_0);
+		break;
+	case 1:
+		val32 = MAC_REG_R32(R_AX_SS_MACID_PAUSE_1) |
+			MAC_REG_R32(R_AX_MACID_SLEEP_1);
+		break;
+	case 2:
+		val32 = MAC_REG_R32(R_AX_SS_MACID_PAUSE_2) |
+			MAC_REG_R32(R_AX_MACID_SLEEP_2);
+		break;
+	case 3:
+		val32 = MAC_REG_R32(R_AX_SS_MACID_PAUSE_3) |
+			MAC_REG_R32(R_AX_MACID_SLEEP_3);
+		break;
+	default:
+		break;
+	}
+	cfg->pause = (u8)((val32 & BIT(cfg->macid & (32 - 1))) ? 1 : 0);
+
+	return MACSUCCESS;
+}
+
+u32 get_ss_wmm_tbl(struct mac_ax_adapter *adapter,
+		   struct mac_ax_ss_wmm_tbl_ctrl *ctrl)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_SS_CTRL);
+	switch (ctrl->wmm) {
+	case 0:
+		ctrl->wmm_mapping =
+		(enum mac_ax_ss_wmm_tbl)GET_FIELD(val32, B_AX_SS_WMM_SEL_0);
+		break;
+	case 1:
+		ctrl->wmm_mapping =
+		(enum mac_ax_ss_wmm_tbl)GET_FIELD(val32, B_AX_SS_WMM_SEL_1);
+		break;
+	case 2:
+		ctrl->wmm_mapping =
+		(enum mac_ax_ss_wmm_tbl)GET_FIELD(val32, B_AX_SS_WMM_SEL_2);
+		break;
+	case 3:
+		ctrl->wmm_mapping =
+		(enum mac_ax_ss_wmm_tbl)GET_FIELD(val32, B_AX_SS_WMM_SEL_3);
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+static void get_delay_tx_cfg(struct mac_ax_adapter *adapter,
+			     struct mac_ax_delay_tx_cfg *cfg)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_SS_CTRL);
+	cfg->en =
+		(enum mac_ax_delay_tx_en)GET_FIELD(val32,
+						   B_AX_SS_DELAY_TX_BAND_SEL);
+
+	val32 = MAC_REG_R32(R_AX_SS_DELAYTX_TO);
+	cfg->vovi_to_b0 = GET_FIELD(val32, B_AX_SS_VOVI_TO_0);
+	cfg->bebk_to_b0 = GET_FIELD(val32, B_AX_SS_BEBK_TO_0);
+	cfg->vovi_to_b1 = GET_FIELD(val32, B_AX_SS_VOVI_TO_1);
+	cfg->bebk_to_b1 = GET_FIELD(val32, B_AX_SS_BEBK_TO_1);
+
+	val32 = MAC_REG_R32(R_AX_SS_DELAYTX_LEN_THR);
+	cfg->vovi_len_b0 = GET_FIELD(val32, B_AX_SS_VOVI_LEN_THR_0);
+	cfg->bebk_len_b0 = GET_FIELD(val32, B_AX_SS_BEBK_LEN_THR_0);
+	cfg->vovi_len_b1 = GET_FIELD(val32, B_AX_SS_VOVI_LEN_THR_1);
+	cfg->bebk_len_b1 = GET_FIELD(val32, B_AX_SS_BEBK_LEN_THR_1);
+}
+
+static u32 get_append_fcs(struct mac_ax_adapter *adapter, u8 *enable)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	*enable = MAC_REG_R8(R_AX_MPDU_PROC) & B_AX_APPEND_FCS ? 1 : 0;
+
+	return MACSUCCESS;
+}
+
+static u32 get_accept_icverr(struct mac_ax_adapter *adapter, u8 *enable)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	*enable = MAC_REG_R8(R_AX_MPDU_PROC) & B_AX_A_ICV_ERR ? 1 : 0;
+
+	return MACSUCCESS;
+}
+
+u32 get_bacam_mode(struct mac_ax_adapter *adapter, u8 *mode_sel)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	*mode_sel = MAC_REG_R8(R_AX_RESPBA_CAM_CTRL) & B_AX_BACAM_ENT_CFG ? 1 : 0;
+
+	return MACSUCCESS;
+#else
+	return MACHWNOSUP;
+#endif
+}
+
+u32 get_pwr_state(struct mac_ax_adapter *adapter, enum mac_ax_mac_pwr_st *st)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val;
+
+	val = GET_FIELD(MAC_REG_R32(R_AX_IC_PWR_STATE), B_AX_WLMAC_PWR_STE);
+
+	if (val == MAC_AX_MAC_OFF) {
+		*st = MAC_AX_MAC_OFF;
+		adapter->mac_pwr_info.pwr_in_lps = 0;
+		adapter->sm.fw_rst = MAC_AX_FW_RESET_IDLE;
+		adapter->sm.pwr = MAC_AX_PWR_OFF;
+		adapter->sm.mac_rdy = MAC_AX_MAC_NOT_RDY;
+		PLTFM_MSG_WARN("WL MAC is in off state.\n");
+	} else if (val == MAC_AX_MAC_ON) {
+		*st = MAC_AX_MAC_ON;
+	} else if (val == MAC_AX_MAC_LPS) {
+		*st = MAC_AX_MAC_LPS;
+	} else {
+		PLTFM_MSG_ERR("Unexpected MAC state = 0x%X\n", val);
+		return MACPWRSTAT;
+	}
+
+	return MACSUCCESS;
+}
+
+void get_dflt_nav(struct mac_ax_adapter *adapter, u16 *nav)
+{
+	/* data NAV is consist of SIFS and ACK/BA time */
+	/* currently, we use SIFS + 64-bitmap BA as default NAV */
+	/* we use OFDM-6M to estimate BA time */
+	/* BA time = PLCP header(20us) + 32 bytes/data_rate */
+	*nav = 63;
+}
+
+u32 mac_get_hw_value(struct mac_ax_adapter *adapter,
+		     enum mac_ax_hw_id hw_id, void *val)
+{
+	u32 ret = MACSUCCESS;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	if (!val) {
+		PLTFM_MSG_ERR("[ERR]: the parameter is NULL in %s\n", __func__);
+		return MACNPTR;
+	}
+
+	switch (hw_id) {
+	case MAC_AX_HW_MAPPING:
+		break;
+	case MAC_AX_HW_GET_EFUSE_SIZE:
+		*(u32 *)val = adapter->hw_info->efuse_size +
+			      adapter->hw_info->dav_efuse_size;
+		break;
+	case MAC_AX_HW_GET_LOGICAL_EFUSE_SIZE:
+		*(u32 *)val = adapter->hw_info->log_efuse_size +
+			      adapter->hw_info->dav_log_efuse_size;
+		break;
+	case MAC_AX_HW_GET_LIMIT_LOG_EFUSE_SIZE:
+		switch (adapter->hw_info->intf) {
+		case MAC_AX_INTF_PCIE:
+			*(u32 *)val = adapter->hw_info->limit_efuse_size_pcie;
+			break;
+		case MAC_AX_INTF_USB:
+			*(u32 *)val = adapter->hw_info->limit_efuse_size_usb;
+			break;
+		case MAC_AX_INTF_SDIO:
+			*(u32 *)val = adapter->hw_info->limit_efuse_size_sdio;
+			break;
+		default:
+			*(u32 *)val = adapter->hw_info->log_efuse_size;
+			break;
+		}
+		*(u32 *)val += adapter->hw_info->dav_log_efuse_size;
+		break;
+	case MAC_AX_HW_GET_BT_EFUSE_SIZE:
+		*(u32 *)val = adapter->hw_info->bt_efuse_size;
+		break;
+	case MAC_AX_HW_GET_BT_LOGICAL_EFUSE_SIZE:
+		*(u32 *)val = adapter->hw_info->bt_log_efuse_size;
+		break;
+	case MAC_AX_HW_GET_EFUSE_MASK_SIZE:
+		*(u32 *)val = (adapter->hw_info->log_efuse_size +
+			       adapter->hw_info->dav_log_efuse_size) >> 4;
+		break;
+	case MAC_AX_HW_GET_LIMIT_EFUSE_MASK_SIZE:
+		switch (adapter->hw_info->intf) {
+		case MAC_AX_INTF_PCIE:
+			*(u32 *)val = adapter->hw_info->limit_efuse_size_pcie;
+			break;
+		case MAC_AX_INTF_USB:
+			*(u32 *)val = adapter->hw_info->limit_efuse_size_usb;
+			break;
+		case MAC_AX_INTF_SDIO:
+			*(u32 *)val = adapter->hw_info->limit_efuse_size_sdio;
+			break;
+		default:
+			*(u32 *)val = adapter->hw_info->log_efuse_size;
+			break;
+		}
+		*(u32 *)val += adapter->hw_info->dav_log_efuse_size;
+		*(u32 *)val = *(u32 *)val >> 4;
+		break;
+	case MAC_AX_HW_GET_BT_EFUSE_MASK_SIZE:
+		*(u32 *)val = adapter->hw_info->bt_log_efuse_size >> 4;
+		break;
+	case MAC_AX_HW_GET_DAV_LOG_EFUSE_SIZE:
+		*(u32 *)val = adapter->hw_info->dav_log_efuse_size;
+		break;
+	case MAC_AX_HW_GET_EFUSE_VERSION_SIZE:
+		*(u32 *)val = adapter->hw_info->efuse_version_size;
+		break;
+	case MAC_AX_HW_GET_ID_PAUSE:
+		ret = get_macid_pause(adapter,
+				      (struct mac_ax_macid_pause_cfg *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_GET_SCH_TXEN_STATUS:
+		ret = get_hw_sch_tx_en(adapter,
+				       (struct mac_ax_sch_tx_en_cfg *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_GET_EDCA_PARAM:
+		ret = get_hw_edca_param(adapter,
+					(struct mac_ax_edca_param *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_GET_TBPPDU_CTRL:
+		ret = get_hw_tb_ppdu_ctrl(adapter,
+					  (struct mac_ax_tb_ppdu_ctrl *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_GET_DELAYTX_CFG:
+		get_delay_tx_cfg(adapter, (struct mac_ax_delay_tx_cfg *)val);
+		break;
+	case MAC_AX_HW_GET_SS_WMM_TBL:
+		ret = get_ss_wmm_tbl(adapter,
+				     (struct mac_ax_ss_wmm_tbl_ctrl *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_GET_CH_STAT_CNT:
+		ret = get_hw_ch_stat_cnt(adapter,
+					 (struct mac_ax_ch_stat_cnt *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_GET_LIFETIME_CFG:
+		ret = get_hw_lifetime_cfg(adapter,
+					  (struct mac_ax_lifetime_cfg *)val);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case MAC_AX_HW_GET_APP_FCS:
+		get_append_fcs(adapter, (u8 *)val);
+		break;
+	case MAC_AX_HW_GET_RX_ICVERR:
+		get_accept_icverr(adapter, (u8 *)val);
+		break;
+	case MAC_AX_HW_GET_PWR_STATE:
+		get_pwr_state(adapter, (enum mac_ax_mac_pwr_st *)val);
+		break;
+	case MAC_AX_HW_GET_SCOREBOARD:
+		*(u32 *)val = MAC_REG_R32(R_AX_SCOREBOARD);
+		break;
+	case MAC_AX_HW_GET_BACAM_MODE_SEL:
+		get_bacam_mode(adapter, (u8 *)val);
+		break;
+#if MAC_AX_SDIO_SUPPORT
+	case MAC_AX_HW_SDIO_TX_AGG_SIZE:
+		*(u16 *)val = adapter->sdio_info.tx_align_size;
+		break;
+	case MAC_AX_HW_GET_SDIO_RX_REQ_LEN:
+		ret = p_ops->get_sdio_rx_req_len(adapter, (u32 *)val);
+		break;
+	case MAC_AX_HW_GET_SDIO_LPS_FLG:
+		*(u8 *)val = adapter->mac_pwr_info.pwr_in_lps;
+		break;
+#endif
+	case MAC_AX_HW_GET_WAKE_REASON:
+		ret = get_wake_reason(adapter, (u8 *)val);
+		if (ret != 0)
+			return ret;
+		break;
+	case MAC_AX_HW_GET_COEX_GNT:
+		ret = p_ops->get_gnt(adapter, (struct mac_ax_coex_gnt *)val);
+		break;
+	case MAC_AX_HW_GET_COEX_CTRL:
+		p_ops->get_ctrl_path(adapter, (u32 *)val);
+		break;
+	case MAC_AX_HW_GET_TX_CNT:
+		ret = mac_get_tx_cnt(adapter, (struct mac_ax_tx_cnt *)val);
+		if (ret != 0)
+			return ret;
+		break;
+	case MAC_AX_HW_GET_TSF:
+		ret = mac_get_tsf(adapter, (struct mac_ax_port_tsf *)val);
+		break;
+	case MAC_AX_HW_GET_FREERUN_CNT:
+		ret = mac_get_freerun(adapter, (struct mac_ax_freerun *)val);
+		break;
+	case MAC_AX_HW_GET_MAX_TX_TIME:
+		ret = mac_get_max_tx_time(adapter,
+					  (struct mac_ax_max_tx_time *)val);
+		break;
+	case MAC_AX_HW_GET_POLLUTED_CNT:
+		mac_get_bt_polt_cnt(adapter, (struct mac_ax_bt_polt_cnt *)val);
+		break;
+	case MAC_AX_HW_GET_DATA_RTY_LMT:
+		get_data_rty_limit(adapter, (struct mac_ax_rty_lmt *)val);
+		break;
+	case MAC_AX_HW_GET_DFLT_NAV:
+		get_dflt_nav(adapter, (u16 *)val);
+		break;
+	case MAC_AX_HW_GET_FW_CAP:
+		ret = mac_get_fw_cap(adapter, (u32 *)val);
+		break;
+	case MAC_AX_HW_GET_RRSR_CFG:
+		ret = p_ops->get_rrsr_cfg(adapter,
+					  (struct mac_ax_rrsr_cfg *)val);
+		break;
+	case MAC_AX_HW_GET_CTS_RRSR_CFG:
+		ret = p_ops->get_cts_rrsr_cfg(adapter,
+					  (struct mac_ax_cts_rrsr_cfg *)val);
+		break;
+	case MAC_AX_HW_GET_USB_STS:
+		ret = ops->get_rx_state(adapter, (u32 *)val);
+		break;
+	case MAC_AX_HW_GET_WD_PAGE_NUM:
+		*(u32 *)val = (u32)adapter->dle_info.hif_min;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return ret;
+}
+
+u32 cfg_mac_bw(struct mac_ax_adapter *adapter, struct mac_ax_cfg_bw *cfg)
+{
+	u32 value32 = 0;
+	u8 value8 = 0;
+	u8 chk_val8 = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct rtw_hal_com_t *hal_com =
+		(struct rtw_hal_com_t *)adapter->drv_adapter;
+
+	u8 txsc20 = 0, txsc40 = 0, txsc80 = 0;
+
+	switch (cfg->cbw) {
+	case CHANNEL_WIDTH_160:
+		txsc80 = rtw_hal_bb_get_txsc(hal_com, cfg->pri_ch,
+					     cfg->central_ch, cfg->cbw,
+					     CHANNEL_WIDTH_80);
+		fallthrough;
+	case CHANNEL_WIDTH_80:
+		txsc40 = rtw_hal_bb_get_txsc(hal_com, cfg->pri_ch,
+					     cfg->central_ch, cfg->cbw,
+					     CHANNEL_WIDTH_40);
+		fallthrough;
+	case CHANNEL_WIDTH_40:
+		txsc20 = rtw_hal_bb_get_txsc(hal_com, cfg->pri_ch,
+					     cfg->central_ch, cfg->cbw,
+					     CHANNEL_WIDTH_20);
+		break;
+	case CHANNEL_WIDTH_10:
+		value32 = MAC_REG_R32(R_AX_AFE_CTRL1);
+		value32 = value32 | B_AX_CMAC_CLK_SEL;
+		MAC_REG_W32(R_AX_AFE_CTRL1, value32);
+		MAC_REG_W8(R_AX_SLOTTIME_CFG, SLOTTIME_10M);
+		MAC_REG_W8(R_AX_RSP_CHK_SIG, ACK_TO_10M);
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			MAC_REG_W8(R_AX_TSF_32K_SEL, US_TIME_10M);
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			MAC_REG_W8(R_AX_TSF_32K_SEL_V1, US_TIME_10M);
+		}
+#endif
+		break;
+	case CHANNEL_WIDTH_5:
+		value32 = MAC_REG_R32(R_AX_AFE_CTRL1);
+		value32 = value32 | B_AX_CMAC_CLK_SEL;
+		MAC_REG_W32(R_AX_AFE_CTRL1, value32);
+		MAC_REG_W8(R_AX_SLOTTIME_CFG, SLOTTIME_5M);
+		MAC_REG_W8(R_AX_RSP_CHK_SIG, ACK_TO_5M);
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			MAC_REG_W8(R_AX_TSF_32K_SEL, US_TIME_5M);
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			MAC_REG_W8(R_AX_TSF_32K_SEL_V1, US_TIME_5M);
+		}
+#endif
+		break;
+	default:
+		break;
+	}
+
+#if MAC_AX_FW_REG_OFLD
+	u32 ret;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		if (cfg->band) {//BAND1
+			value8 = MAC_REG_R8(R_AX_WMAC_RFMOD_C1);
+			chk_val8 = MAC_REG_R8(R_AX_TXRATE_CHK_C1);
+		} else {//BAND0
+			value8 = MAC_REG_R8(R_AX_WMAC_RFMOD);
+			chk_val8 = MAC_REG_R8(R_AX_TXRATE_CHK);
+		}
+		value8 = value8 & (~(BIT(0) | BIT(1)));
+		chk_val8 = chk_val8 & (~(BIT(0) | BIT(1)));
+
+		switch (cfg->cbw) {
+		case CHANNEL_WIDTH_160:
+			value8 = value8 | BIT(1) | BIT(0);
+			value32 = txsc20 | (txsc40 << 4) | (txsc80 << 8); //TXSC_160M;
+			break;
+		case CHANNEL_WIDTH_80:
+			value8 = value8 | BIT(1);
+			value32 = txsc20 | (txsc40 << 4); //TXSC_80M;
+			break;
+		case CHANNEL_WIDTH_40:
+			value8 = value8 | BIT(0);
+			value32 = txsc20; //TXSC_40M;
+			break;
+		case CHANNEL_WIDTH_20:
+			value32 = 0; //TXSC_20M;
+			break;
+		case CHANNEL_WIDTH_10:
+			value32 = 0; //TXSC_20M;
+			break;
+		case CHANNEL_WIDTH_5:
+			value32 = 0; //TXSC_20M;
+			break;
+		default:
+			break;
+		}
+
+		if (cfg->pri_ch >= CHANNEL_5G)
+			chk_val8 |= B_AX_CHECK_CCK_EN | B_AX_RTS_LIMIT_IN_OFDM6;
+
+		if (cfg->band) {//BAND1
+			ret = MAC_REG_W_OFLD(R_AX_WMAC_RFMOD_C1, B_AX_WMAC_RFMOD_MSK,
+					     value8, 0);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s: config fail\n", __func__);
+				return ret;
+			}
+			ret = MAC_REG_W_OFLD(R_AX_TXRATE_CHK_C1, 0x3, chk_val8,
+					     0);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s: config fail\n", __func__);
+				return ret;
+			}
+			ret = MAC_REG_W32_OFLD(R_AX_TX_SUB_CARRIER_VALUE_C1,
+					       value32, 1);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s: config fail\n", __func__);
+				return ret;
+			}
+		} else {
+			ret = MAC_REG_W_OFLD(R_AX_WMAC_RFMOD, B_AX_WMAC_RFMOD_MSK,
+					     value8, 0);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s: config fail\n", __func__);
+				return ret;
+			}
+			ret = MAC_REG_W_OFLD(R_AX_TXRATE_CHK, 0x3, chk_val8, 0);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s: config fail\n", __func__);
+				return ret;
+			}
+			ret = MAC_REG_W32_OFLD(R_AX_TX_SUB_CARRIER_VALUE,
+					       value32, 1);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s: config fail\n", __func__);
+				return ret;
+			}
+		}
+
+	return MACSUCCESS;
+	}
+#endif
+	if (cfg->band) {//BAND1
+		value8 = MAC_REG_R8(R_AX_WMAC_RFMOD_C1);
+		chk_val8 = MAC_REG_R8(R_AX_TXRATE_CHK_C1);
+	} else {//BAND0
+		value8 = MAC_REG_R8(R_AX_WMAC_RFMOD);
+		chk_val8 = MAC_REG_R8(R_AX_TXRATE_CHK);
+	}
+	value8 = value8 & (~(BIT(0) | BIT(1)));
+	chk_val8 = chk_val8 & (~(BIT(0) | BIT(1) | BIT(4)));
+
+	switch (cfg->cbw) {
+	case CHANNEL_WIDTH_160:
+		value8 = value8 | BIT(1) | BIT(0);
+		value32 = txsc20 | (txsc40 << 4) | (txsc80 << 8); //TXSC_160M;
+		break;
+	case CHANNEL_WIDTH_80:
+		value8 = value8 | BIT(1);
+		value32 = txsc20 | (txsc40 << 4); //TXSC_80M;
+		break;
+	case CHANNEL_WIDTH_40:
+		value8 = value8 | BIT(0);
+		value32 = txsc20; //TXSC_40M;
+		break;
+	case CHANNEL_WIDTH_20:
+		value32 = 0; //TXSC_20M;
+		break;
+	case CHANNEL_WIDTH_10:
+		value32 = 0; //TXSC_20M;
+		break;
+	case CHANNEL_WIDTH_5:
+		value32 = 0; //TXSC_20M;
+		break;
+	default:
+		break;
+	}
+
+	/*Setting for CCK rate in 5G/6G Channel protection*/
+	if (cfg->pri_ch >= CHANNEL_5G) // remove after phl setting band_type
+		chk_val8 |= B_AX_CHECK_CCK_EN | B_AX_RTS_LIMIT_IN_OFDM6;
+
+	if (cfg->band_type == BAND_ON_24G)
+		chk_val8 |= B_AX_BAND_MODE;
+	else if (cfg->band_type == BAND_ON_5G)
+		chk_val8 |= B_AX_CHECK_CCK_EN | B_AX_RTS_LIMIT_IN_OFDM6;
+	else if (cfg->band_type == BAND_ON_6G)
+		chk_val8 |= B_AX_CHECK_CCK_EN | B_AX_RTS_LIMIT_IN_OFDM6;
+	else
+		PLTFM_MSG_ERR("[ERR]band_type = %d\n", cfg->band_type);
+
+	if (cfg->band) {//BAND1
+		MAC_REG_W8(R_AX_WMAC_RFMOD_C1, value8);
+		MAC_REG_W8(R_AX_TXRATE_CHK_C1, chk_val8);
+		MAC_REG_W32(R_AX_TX_SUB_CARRIER_VALUE_C1, value32);
+	} else {
+		MAC_REG_W8(R_AX_WMAC_RFMOD, value8);
+		MAC_REG_W8(R_AX_TXRATE_CHK, chk_val8);
+		MAC_REG_W32(R_AX_TX_SUB_CARRIER_VALUE, value32);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_xtal_si(struct mac_ax_adapter *adapter,
+		      u8 offset, u8 val, u8 bitmask)
+{
+	u32 cnt = 0;
+	u32 write_val = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	cnt = XTAL_SI_POLLING_CNT;
+	write_val = SET_CLR_WORD(write_val, offset, B_AX_WL_XTAL_SI_ADDR);
+	write_val = SET_CLR_WORD(write_val, val, B_AX_WL_XTAL_SI_DATA);
+	write_val = SET_CLR_WORD(write_val, bitmask, B_AX_WL_XTAL_SI_BITMASK);
+	write_val = SET_CLR_WORD(write_val, XTAL_SI_NORMAL_WRITE,
+				 B_AX_WL_XTAL_SI_MODE);
+	write_val = (write_val | B_AX_WL_XTAL_SI_CMD_POLL);
+	MAC_REG_W32(R_AX_WLAN_XTAL_SI_CTRL, write_val);
+
+	while ((MAC_REG_R32(R_AX_WLAN_XTAL_SI_CTRL) & B_AX_WL_XTAL_SI_CMD_POLL)
+						== B_AX_WL_XTAL_SI_CMD_POLL) {
+		if (!cnt) {
+			PLTFM_MSG_ERR("[ERR]xtal si not ready(W)\n");
+			return MACPOLLTO;
+		}
+		cnt--;
+		PLTFM_DELAY_US(XTAL_SI_POLLING_DLY_US);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_read_xtal_si(struct mac_ax_adapter *adapter,
+		     u8 offset, u8 *val)
+{
+	u32 cnt = 0;
+	u32 write_val = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	cnt = XTAL_SI_POLLING_CNT;
+	write_val = SET_CLR_WORD(write_val, offset, B_AX_WL_XTAL_SI_ADDR);
+	write_val = SET_CLR_WORD(write_val, 0x00, B_AX_WL_XTAL_SI_DATA);
+	write_val = SET_CLR_WORD(write_val, 0x00, B_AX_WL_XTAL_SI_BITMASK);
+	write_val = SET_CLR_WORD(write_val, XTAL_SI_NORMAL_READ,
+				 B_AX_WL_XTAL_SI_MODE);
+	write_val = (write_val | B_AX_WL_XTAL_SI_CMD_POLL);
+	MAC_REG_W32(R_AX_WLAN_XTAL_SI_CTRL, write_val);
+
+	while ((MAC_REG_R32(R_AX_WLAN_XTAL_SI_CTRL) & B_AX_WL_XTAL_SI_CMD_POLL)
+						== B_AX_WL_XTAL_SI_CMD_POLL) {
+		if (!cnt) {
+			PLTFM_MSG_ERR("[ERR]xtal_si not ready(R)\n");
+			return MACPOLLTO;
+		}
+		cnt--;
+		PLTFM_DELAY_US(XTAL_SI_POLLING_DLY_US);
+	}
+
+	*val = MAC_REG_R8(R_AX_WLAN_XTAL_SI_CTRL + 1);
+
+	return MACSUCCESS;
+}
+
+u32 set_host_rpr(struct mac_ax_adapter *adapter,
+		 struct mac_ax_host_rpr_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_host_rpr_cfg *def_cfg;
+	enum mac_ax_host_rpr_mode mode;
+	u8 is_poh;
+	u32 val32, nval32;
+	u32 ret = MACSUCCESS;
+
+	if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+		ret = is_qta_poh(adapter, adapter->dle_info.qta_mode, &is_poh);
+		if (ret) {
+			PLTFM_MSG_ERR("is qta poh check fail %d\n", ret);
+			return ret;
+		}
+		def_cfg = is_poh ? &rpr_cfg_poh : &rpr_cfg_stf;
+		mode = is_poh ? MAC_AX_RPR_MODE_POH : MAC_AX_RPR_MODE_STF;
+	} else {
+		def_cfg = &rpr_cfg_stf;
+		mode = MAC_AX_RPR_MODE_STF;
+	}
+
+	val32 = MAC_REG_R32(R_AX_WDRLS_CFG);
+	nval32 = SET_CLR_WORD(val32, mode, B_AX_WDRLS_MODE);
+	if (nval32 != val32)
+		MAC_REG_W32(R_AX_WDRLS_CFG, nval32);
+
+	val32 = MAC_REG_R32(R_AX_RLSRPT0_CFG0);
+	nval32 = val32;
+	if ((cfg->txok_en == MAC_AX_FUNC_DEF &&
+	     def_cfg->txok_en == MAC_AX_FUNC_EN) ||
+	    cfg->txok_en == MAC_AX_FUNC_EN)
+		nval32 |= B_WDRLS_FLTR_TXOK;
+	else
+		nval32 &= ~B_WDRLS_FLTR_TXOK;
+	if ((cfg->rty_lmt_en == MAC_AX_FUNC_DEF &&
+	     def_cfg->rty_lmt_en == MAC_AX_FUNC_EN) ||
+	    cfg->rty_lmt_en == MAC_AX_FUNC_EN)
+		nval32 |= B_WDRLS_FLTR_RTYLMT;
+	else
+		nval32 &= ~B_WDRLS_FLTR_RTYLMT;
+	if ((cfg->lft_drop_en == MAC_AX_FUNC_DEF &&
+	     def_cfg->lft_drop_en == MAC_AX_FUNC_EN) ||
+	    cfg->lft_drop_en == MAC_AX_FUNC_EN)
+		nval32 |= B_WDRLS_FLTR_LIFTIM;
+	else
+		nval32 &= ~B_WDRLS_FLTR_LIFTIM;
+	if ((cfg->macid_drop_en == MAC_AX_FUNC_DEF &&
+	     def_cfg->macid_drop_en == MAC_AX_FUNC_EN) ||
+	    cfg->macid_drop_en == MAC_AX_FUNC_EN)
+		nval32 |= B_WDRLS_FLTR_MACID;
+	else
+		nval32 &= ~B_WDRLS_FLTR_MACID;
+	if (nval32 != val32)
+		MAC_REG_W32(R_AX_RLSRPT0_CFG0, nval32);
+
+	val32 = MAC_REG_R32(R_AX_RLSRPT0_CFG1);
+	nval32 = SET_CLR_WORD(val32, (cfg->agg_def ? def_cfg->agg : cfg->agg),
+			      B_AX_RLSRPT0_AGGNUM);
+	nval32 = SET_CLR_WORD(nval32, (cfg->tmr_def ? def_cfg->tmr : cfg->tmr),
+			      B_AX_RLSRPT0_TO);
+	if (nval32 != val32)
+		MAC_REG_W32(R_AX_RLSRPT0_CFG1, nval32);
+
+	return ret;
+}
+
+u32 set_l2_status(struct mac_ax_adapter *adapter)
+{
+	adapter->sm.l2_st = MAC_AX_L2_EN;
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_pwr_ofst_mode(struct mac_ax_adapter *adapter,
+			    u8 band, struct rtw_tpu_info *tpu)
+{
+#if	MAC_USB_IO_ACC_ON
+#else
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+#endif
+	u32 cr = (band == HW_BAND_0) ? R_AX_PWR_RATE_OFST_CTRL :
+		 R_AX_PWR_RATE_OFST_CTRL_C1;
+	u32 val32 = 0, ret = 0;
+	s8 *tmp = &tpu->pwr_ofst_mode[0];
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret  != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+#if	MAC_USB_IO_ACC_ON
+	val32 |= NIB_2_DW(0, 0, 0, tmp[4], tmp[3], tmp[2], tmp[1], tmp[0]);
+	ret = MAC_REG_W_OFLD((u16)cr, 0xFFFFF, val32, 1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: config fail\n", __func__);
+		return ret;
+	}
+#else
+	val32 = MAC_REG_R32(cr) & ~0xFFFFF;
+	val32 |= NIB_2_DW(0, 0, 0, tmp[4], tmp[3], tmp[2], tmp[1], tmp[0]);
+	MAC_REG_W32(cr, val32);
+#endif
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_pwr_ofst_bw(struct mac_ax_adapter *adapter,
+			  u8 band, struct rtw_tpu_info *tpu)
+{
+#if	MAC_USB_IO_ACC_ON
+#else
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+#endif
+	u32 cr = (band == HW_BAND_0) ? R_AX_PWR_LMT_CTRL :
+		 R_AX_PWR_LMT_CTRL_C1;
+	u32 val32 = 0, ret = 0;
+	s8 *tmp = &tpu->pwr_ofst_bw[0];
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+#if	MAC_USB_IO_ACC_ON
+	val32 |= NIB_2_DW(0, 0, 0, tmp[4], tmp[3], tmp[2], tmp[1], tmp[0]);
+	ret = MAC_REG_W_OFLD((u16)cr, 0xFFFFF, val32, 1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: config fail\n", __func__);
+		return ret;
+	}
+#else
+	val32 = MAC_REG_R32(cr) & ~0xFFFFF;
+	val32 |= NIB_2_DW(0, 0, 0, tmp[4], tmp[3], tmp[2], tmp[1], tmp[0]);
+	MAC_REG_W32(cr, val32);
+#endif
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_pwr_ref_reg(struct mac_ax_adapter *adapter,
+			  u8 band, struct rtw_tpu_info *tpu)
+{
+#if	MAC_USB_IO_ACC_ON
+#else
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+#endif
+	u32 cr = (band == HW_BAND_0) ? R_AX_PWR_RATE_CTRL :
+		 R_AX_PWR_RATE_CTRL_C1;
+	u32 val32 = 0, ret = 0;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+#if	MAC_USB_IO_ACC_ON
+	val32 |= (((tpu->ref_pow_ofdm & 0x1ff) << 9) |
+		 ((tpu->ref_pow_cck & 0x1ff)));
+	ret = MAC_REG_W_OFLD((u16)cr, 0xFFFFC00, val32, 1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: config fail\n", __func__);
+		return ret;
+	}
+#else
+	val32 = MAC_REG_R32(cr) & ~0xFFFFC00;
+	val32 |= (((tpu->ref_pow_ofdm & 0x1ff) << 19) |
+		 ((tpu->ref_pow_cck & 0x1ff) << 10));
+	MAC_REG_W32(cr, val32);
+#endif
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_pwr_limit_en(struct mac_ax_adapter *adapter,
+			   u8 band, struct rtw_tpu_info *tpu)
+{
+#if	MAC_USB_IO_ACC_ON
+#else
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+#endif
+	u32 val32 = 0, ret = 0, cr = 0;
+
+	cr = (band == HW_BAND_0) ? R_AX_PWR_LMT_CTRL :
+	      R_AX_PWR_LMT_CTRL_C1;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+#if	MAC_USB_IO_ACC_ON
+	if (tpu->pwr_lmt_en)
+		val32 =  3;
+	ret = MAC_REG_W_OFLD((u16)cr, 0x300000, val32, 0);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: config fail\n", __func__);
+		return ret;
+	}
+
+	val32 = 0;
+	cr = (band == HW_BAND_0) ? R_AX_PWR_RU_LMT_CTRL : R_AX_PWR_RU_LMT_CTRL_C1;
+	if (tpu->pwr_lmt_en)
+		val32 =  1;
+	ret = MAC_REG_W_OFLD((u16)cr, 0x40000, val32, 1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: config fail\n", __func__);
+		return ret;
+	}
+#else
+	cr = (band == HW_BAND_0) ? R_AX_PWR_LMT_CTRL :
+	      R_AX_PWR_LMT_CTRL_C1;
+	val32 = 0;
+
+	val32 = MAC_REG_R32(cr) & ~0x300000;
+	if (tpu->pwr_lmt_en)
+		val32 |=  0x300000;
+	MAC_REG_W32(cr, val32);
+
+	cr = (band == HW_BAND_0) ? R_AX_PWR_RU_LMT_CTRL : R_AX_PWR_RU_LMT_CTRL_C1;
+		val32 = MAC_REG_R32(cr) & ~BIT18;
+	if (tpu->pwr_lmt_en)
+		val32 |=  BIT18;
+	MAC_REG_W32(cr, val32);
+#endif
+
+	return MACSUCCESS;
+}
+
+u32 mac_read_pwr_reg(struct mac_ax_adapter *adapter, u8 band,
+		     const u32 offset, u32 *val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret;
+	u32 access_offset = offset;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret  != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+	if (offset < R_AX_PWR_RATE_CTRL || offset > 0xFFFF) {
+		PLTFM_MSG_ERR("[ERR]offset exceed pwr ctrl reg %x\n", offset);
+		return MACBADDR;
+	}
+
+	if (band == MAC_AX_BAND_1)
+		access_offset = offset | BIT13;
+
+	ret = mac_check_access(adapter, access_offset);
+	if (ret)
+		return ret;
+
+	*val = MAC_REG_R32(access_offset);
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_msk_pwr_reg(struct mac_ax_adapter *adapter, u8 band,
+			  const u32 offset, u32 mask, u32 val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = MACSUCCESS;
+	u32 access_offset = offset;
+	u32 ori_val = 0;
+	u8 shift;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret  != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+	if (offset < R_AX_PWR_RATE_CTRL || offset > 0xFFFF) {
+		PLTFM_MSG_ERR("[ERR]offset exceed pwr ctrl reg %x\n", offset);
+		return MACBADDR;
+	}
+
+	if (band == MAC_AX_BAND_1)
+		access_offset = offset | BIT13;
+
+	ret = mac_check_access(adapter, access_offset);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]check access in %x\n", access_offset);
+		return ret;
+	}
+
+#if MAC_USB_IO_ACC_ON
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = MAC_REG_W_OFLD((u16)access_offset, mask, val, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__,
+				      access_offset);
+			return ret;
+		}
+
+		return MACSUCCESS;
+	}
+#endif
+
+	if (mask != 0xffffffff) {
+		shift = shift_mask(mask);
+		ori_val = MAC_REG_R32(access_offset);
+		val = ((ori_val) & (~mask)) | (((val << shift)) & mask);
+	}
+	MAC_REG_W32(access_offset, val);
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_pwr_reg(struct mac_ax_adapter *adapter, u8 band,
+		      const u32 offset, u32 val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = MACSUCCESS;
+	u32 access_offset = offset;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret  != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+	if (offset < R_AX_PWR_RATE_CTRL || offset > 0xFFFF) {
+		PLTFM_MSG_ERR("[ERR]offset exceed pwr ctrl reg %x\n", offset);
+		return MACBADDR;
+	}
+
+	if (band == MAC_AX_BAND_1)
+		access_offset = offset | BIT13;
+
+	ret = mac_check_access(adapter, access_offset);
+	if (ret)
+		return ret;
+
+#if MAC_USB_IO_ACC_ON
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = MAC_REG_W32_OFLD((u16)access_offset, val, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__,
+				      access_offset);
+			return ret;
+		}
+
+		return MACSUCCESS;
+	}
+#endif
+
+	MAC_REG_W32(access_offset, val);
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_pwr_limit_rua_reg(struct mac_ax_adapter *adapter,
+				u8 band, struct rtw_tpu_info *tpu)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret;
+	u16 cr = (band == HW_BAND_0) ? R_AX_PWR_RU_LMT_TABLE0 :
+		 R_AX_PWR_RU_LMT_TABLE0_C1;
+	s8 *tmp;
+	u8 i, j;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret  != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+#if MAC_USB_IO_ACC_ON
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		for (i = 0; i < HAL_MAX_PATH; i++) {
+			/*RU 26*/
+			tmp = &tpu->pwr_lmt_ru[i][0][0];
+			ret = MAC_REG_W32_OFLD((u16)cr, BT_2_DW(tmp[3], tmp[2],
+								tmp[1], tmp[0]),
+								0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+			cr += 4;
+			ret = MAC_REG_W32_OFLD((u16)cr, BT_2_DW(tmp[7], tmp[6],
+								tmp[5], tmp[4]),
+								0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+			cr += 4;
+
+			/*RU 52*/
+			tmp = &tpu->pwr_lmt_ru[i][1][0];
+			ret = MAC_REG_W32_OFLD((u16)cr, BT_2_DW(tmp[3], tmp[2],
+								tmp[1], tmp[0]),
+								0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+			cr += 4;
+			ret = MAC_REG_W32_OFLD((u16)cr, BT_2_DW(tmp[7], tmp[6],
+								tmp[5], tmp[4]),
+								0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+			cr += 4;
+
+			/*RU 106*/
+			tmp = &tpu->pwr_lmt_ru[i][2][0];
+			ret = MAC_REG_W32_OFLD((u16)cr, BT_2_DW(tmp[3], tmp[2],
+								tmp[1], tmp[0]),
+								0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+			cr += 4;
+			ret = MAC_REG_W32_OFLD((u16)cr, BT_2_DW(tmp[7], tmp[6],
+								tmp[5], tmp[4]),
+								1);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+			cr += 4;
+		}
+
+		return MACSUCCESS;
+	}
+#endif
+
+	for (i = 0; i < HAL_MAX_PATH; i++) {
+		for (j = 0; j < TPU_SIZE_RUA; j++) {
+			tmp = &tpu->pwr_lmt_ru[i][j][0];
+			MAC_REG_W32(cr, BT_2_DW(tmp[3], tmp[2], tmp[1], tmp[0]));
+			cr += 4;
+			MAC_REG_W32(cr, BT_2_DW(tmp[7], tmp[6], tmp[5], tmp[4]));
+			cr += 4;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_pwr_limit_reg(struct mac_ax_adapter *adapter,
+			    u8 band, struct rtw_tpu_pwr_imt_info *tpu)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 base = (band == HW_BAND_0) ? R_AX_PWR_RATE_CTRL :
+		   R_AX_PWR_RATE_CTRL_C1;
+	u32 ss_ofst = 0;
+	u32 ret;
+	u16 cr = 0;
+	s8 *tmp, *tmp_1;
+	u8 i, j;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret  != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+#if MAC_USB_IO_ACC_ON
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		for (i = 0; i < HAL_MAX_PATH; i++) {
+			tmp = &tpu->pwr_lmt_cck_20m[i][0];
+			tmp_1 = &tpu->pwr_lmt_cck_40m[i][0];
+			cr = (base | PWR_LMT_CCK_OFFSET) + ss_ofst;
+			ret = MAC_REG_W32_OFLD(cr, BT_2_DW(tmp_1[1], tmp_1[0],
+							   tmp[1], tmp[0]), 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+
+			tmp = &tpu->pwr_lmt_lgcy_20m[i][0];
+			tmp_1 = &tpu->pwr_lmt_20m[i][0][0];
+			cr = (base | PWR_LMT_LGCY_OFFSET) + ss_ofst;
+			ret = MAC_REG_W32_OFLD(cr, BT_2_DW(tmp_1[1], tmp_1[0],
+							   tmp[1], tmp[0]), 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+
+			cr = (base | PWR_LMT_TBL2_OFFSET) + ss_ofst;
+			for (j = 1; j <= 5; j += 2) {
+				tmp = &tpu->pwr_lmt_20m[i][j][0];
+				tmp_1 = &tpu->pwr_lmt_20m[i][j + 1][0];
+				ret = MAC_REG_W32_OFLD(cr, BT_2_DW(tmp_1[1], tmp_1[0],
+								   tmp[1], tmp[0]), 0);
+				if (ret) {
+					PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+						      __func__, cr);
+					return ret;
+				}
+				cr += 4;
+			}
+
+			tmp = &tpu->pwr_lmt_20m[i][7][0];
+			tmp_1 = &tpu->pwr_lmt_40m[i][0][0];
+			cr = (base | PWR_LMT_TBL5_OFFSET) + ss_ofst;
+			ret = MAC_REG_W32_OFLD(cr, BT_2_DW(tmp_1[1], tmp_1[0],
+							   tmp[1], tmp[0]), 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+
+			tmp = &tpu->pwr_lmt_40m[i][1][0];
+			tmp_1 = &tpu->pwr_lmt_40m[i][2][0];
+			cr = (base | PWR_LMT_TBL6_OFFSET) + ss_ofst;
+			ret = MAC_REG_W32_OFLD(cr, BT_2_DW(tmp_1[1], tmp_1[0],
+							   tmp[1], tmp[0]), 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+
+			tmp = &tpu->pwr_lmt_40m[i][3][0];
+			tmp_1 = &tpu->pwr_lmt_80m[i][0][0];
+			cr = (base | PWR_LMT_TBL7_OFFSET) + ss_ofst;
+			ret = MAC_REG_W32_OFLD(cr, BT_2_DW(tmp_1[1], tmp_1[0],
+							   tmp[1], tmp[0]), 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+
+			tmp = &tpu->pwr_lmt_80m[i][1][0];
+			tmp_1 = &tpu->pwr_lmt_160m[i][0];
+			cr = (base | PWR_LMT_TBL8_OFFSET) + ss_ofst;
+			ret = MAC_REG_W32_OFLD(cr, BT_2_DW(tmp_1[1], tmp_1[0],
+							   tmp[1], tmp[0]), 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+
+			tmp = &tpu->pwr_lmt_40m_0p5[i][0];
+			tmp_1 = &tpu->pwr_lmt_40m_2p5[i][0];
+			cr = (base | PWR_LMT_TBL9_OFFSET) + ss_ofst;
+			ret = MAC_REG_W32_OFLD(cr, BT_2_DW(tmp_1[1], tmp_1[0],
+							   tmp[1], tmp[0]), 1);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+
+			ss_ofst += PWR_LMT_TBL_UNIT;
+		}
+
+		return MACSUCCESS;
+	}
+#endif
+
+	for (i = 0; i < HAL_MAX_PATH; i++) {
+		tmp = &tpu->pwr_lmt_cck_20m[i][0];
+		tmp_1 = &tpu->pwr_lmt_cck_40m[i][0];
+		cr = (base | PWR_LMT_CCK_OFFSET) + ss_ofst;
+		MAC_REG_W32(cr, BT_2_DW(tmp_1[1], tmp_1[0], tmp[1], tmp[0]));
+
+		tmp = &tpu->pwr_lmt_lgcy_20m[i][0];
+		tmp_1 = &tpu->pwr_lmt_20m[i][0][0];
+		cr = (base | PWR_LMT_LGCY_OFFSET) + ss_ofst;
+		MAC_REG_W32(cr, BT_2_DW(tmp_1[1], tmp_1[0], tmp[1], tmp[0]));
+
+		cr = (base | PWR_LMT_TBL2_OFFSET) + ss_ofst;
+		for (j = 1; j <= 5; j += 2) {
+			tmp = &tpu->pwr_lmt_20m[i][j][0];
+			tmp_1 = &tpu->pwr_lmt_20m[i][j + 1][0];
+			MAC_REG_W32(cr, BT_2_DW(tmp_1[1], tmp_1[0], tmp[1],
+						tmp[0]));
+			cr += 4;
+		}
+
+		tmp = &tpu->pwr_lmt_20m[i][7][0];
+		tmp_1 = &tpu->pwr_lmt_40m[i][0][0];
+		cr = (base | PWR_LMT_TBL5_OFFSET) + ss_ofst;
+		MAC_REG_W32(cr, BT_2_DW(tmp_1[1], tmp_1[0], tmp[1], tmp[0]));
+
+		tmp = &tpu->pwr_lmt_40m[i][1][0];
+		tmp_1 = &tpu->pwr_lmt_40m[i][2][0];
+		cr = (base | PWR_LMT_TBL6_OFFSET) + ss_ofst;
+		MAC_REG_W32(cr, BT_2_DW(tmp_1[1], tmp_1[0], tmp[1], tmp[0]));
+
+		tmp = &tpu->pwr_lmt_40m[i][3][0];
+		tmp_1 = &tpu->pwr_lmt_80m[i][0][0];
+		cr = (base | PWR_LMT_TBL7_OFFSET) + ss_ofst;
+		MAC_REG_W32(cr, BT_2_DW(tmp_1[1], tmp_1[0], tmp[1], tmp[0]));
+
+		tmp = &tpu->pwr_lmt_80m[i][1][0];
+		tmp_1 = &tpu->pwr_lmt_160m[i][0];
+		cr = (base | PWR_LMT_TBL8_OFFSET) + ss_ofst;
+		MAC_REG_W32(cr, BT_2_DW(tmp_1[1], tmp_1[0], tmp[1], tmp[0]));
+
+		tmp = &tpu->pwr_lmt_40m_0p5[i][0];
+		tmp_1 = &tpu->pwr_lmt_40m_2p5[i][0];
+		cr = (base | PWR_LMT_TBL9_OFFSET) + ss_ofst;
+		MAC_REG_W32(cr, BT_2_DW(tmp_1[1], tmp_1[0], tmp[1], tmp[0]));
+
+		ss_ofst += PWR_LMT_TBL_UNIT;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_pwr_by_rate_reg(struct mac_ax_adapter *adapter,
+			      u8 band, struct rtw_tpu_pwr_by_rate_info *tpu)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 base = (band == HW_BAND_0) ? R_AX_PWR_RATE_CTRL :
+		   R_AX_PWR_RATE_CTRL_C1;
+	u32 ret;
+	u32 ss_ofst = 0;
+	u16 cr = 0;
+	s8 *tmp;
+	u8 i, j;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret  != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+#if MAC_USB_IO_ACC_ON
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		for (i = 0; i <= 8; i += 4) {
+			tmp = &tpu->pwr_by_rate_lgcy[i];
+			cr = (base | PWR_BY_RATE_LGCY_OFFSET) + i;
+			ret = MAC_REG_W32_OFLD(cr, BT_2_DW(tmp[3], tmp[2],
+							   tmp[1], tmp[0]), 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+		}
+
+		for (i = 0; i < HAL_MAX_PATH; i++) {
+			for (j = 0; j <= 12; j += 4) {
+				tmp = &tpu->pwr_by_rate[i][j];
+				cr = (base | PWR_BY_RATE_OFFSET) + j + ss_ofst;
+				ret = MAC_REG_W32_OFLD(cr, BT_2_DW(tmp[3], tmp[2], tmp[1],
+								   tmp[0]), 0);
+				if (ret) {
+					PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+						      __func__, cr);
+					return ret;
+				}
+			}
+			ss_ofst += 0x10; /*16*/
+		}
+
+		return MACSUCCESS;
+	}
+#endif
+
+	for (i = 0; i <= 8; i += 4) {
+		tmp = &tpu->pwr_by_rate_lgcy[i];
+		cr = (base | PWR_BY_RATE_LGCY_OFFSET) + i;
+		MAC_REG_W32(cr, BT_2_DW(tmp[3], tmp[2], tmp[1], tmp[0]));
+	}
+
+	for (i = 0; i < HAL_MAX_PATH; i++) {
+		for (j = 0; j <= 12; j += 4) {
+			tmp = &tpu->pwr_by_rate[i][j];
+			cr = (base | PWR_BY_RATE_OFFSET) + j + ss_ofst;
+			MAC_REG_W32(cr, BT_2_DW(tmp[3], tmp[2], tmp[1],
+						tmp[0]));
+		}
+		ss_ofst += 0x10; /*16*/
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_read_xcap_reg(struct mac_ax_adapter *adapter, u8 sc_xo, u32 *val)
+{
+#if MAC_AX_8852A_SUPPORT
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (sc_xo) {
+		*val = (MAC_REG_R32(R_AX_XTAL_ON_CTRL0) >> B_AX_XTAL_SC_XO_SH) &
+		      B_AX_XTAL_SC_XO_MSK;
+	} else {
+		*val = (MAC_REG_R32(R_AX_XTAL_ON_CTRL0) >> B_AX_XTAL_SC_XI_SH) &
+		      B_AX_XTAL_SC_XI_MSK;
+	}
+#else
+	PLTFM_MSG_ERR("non Support IC for read_xcap_reg\n");
+#endif
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_xcap_reg(struct mac_ax_adapter *adapter, u8 sc_xo, u32 val)
+{
+#if MAC_AX_8852A_SUPPORT
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	if (sc_xo) {
+		val32 = MAC_REG_R32(R_AX_XTAL_ON_CTRL0);
+		val32 &= ~(0xFE0000);
+		val32 |= ((val & B_AX_XTAL_SC_XO_MSK) << B_AX_XTAL_SC_XO_SH);
+		MAC_REG_W32(R_AX_XTAL_ON_CTRL0, val32);
+	} else {
+		val32 = MAC_REG_R32(R_AX_XTAL_ON_CTRL0);
+		val32 &= ~(0x1FC00);
+		val32 = val32 | ((val & B_AX_XTAL_SC_XI_MSK) <<
+				 B_AX_XTAL_SC_XI_SH);
+		MAC_REG_W32(R_AX_XTAL_ON_CTRL0, val32);
+	}
+#else
+	PLTFM_MSG_ERR("non Support IC for write_xcap_reg\n");
+#endif
+
+	return MACSUCCESS;
+}
+
+u32 mac_read_xcap_reg_dav(struct mac_ax_adapter *adapter, u8 sc_xo, u32 *val)
+{
+	u8 xtal_si_value;
+	u32 ret;
+
+	if (sc_xo) {
+		ret = mac_read_xtal_si(adapter, XTAL_SI_XTAL_SC_XO, &xtal_si_value);
+
+		if (ret) {
+			PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+			return ret;
+		}
+		*val = xtal_si_value;
+	} else {
+		ret = mac_read_xtal_si(adapter, XTAL_SI_XTAL_SC_XI, &xtal_si_value);
+
+		if (ret) {
+			PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+			return ret;
+		}
+		*val = xtal_si_value;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_xcap_reg_dav(struct mac_ax_adapter *adapter, u8 sc_xo, u32 val)
+{
+	u8 xtal_si_value;
+	u32 ret;
+#ifdef MAC_8851B_SUPPORT
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_value;
+#endif
+
+	xtal_si_value = (u8)val;
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+#ifdef MAC_8851B_SUPPORT
+		if (sc_xo) {
+			reg_value = MAC_REG_R32(R_AX_XTAL_ON_CTRL3);
+			reg_value = SET_CLR_WORD(reg_value, val, B_AX_XTAL_SC_XO_A_BLOCK);
+			MAC_REG_W32(R_AX_XTAL_ON_CTRL3, reg_value);
+		} else {
+			reg_value = MAC_REG_R32(R_AX_XTAL_ON_CTRL3);
+			reg_value = SET_CLR_WORD(reg_value, val, B_AX_XTAL_SC_XI_A_BLOCK);
+			MAC_REG_W32(R_AX_XTAL_ON_CTRL3, reg_value);
+		}
+#endif
+	} else {
+		if (sc_xo) {
+			ret = mac_write_xtal_si(adapter, XTAL_SI_XTAL_SC_XO, xtal_si_value,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+		} else {
+			ret = mac_write_xtal_si(adapter, XTAL_SI_XTAL_SC_XI, xtal_si_value,
+						FULL_BIT_MASK);
+			if (ret) {
+				PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+				return ret;
+			}
+		}
+	}
+	return MACSUCCESS;
+}
+
+u32 mac_write_bbrst_reg(struct mac_ax_adapter *adapter, u8 val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val8;
+
+	val8 = MAC_REG_R8(R_AX_SYS_FUNC_EN);
+	if (val)
+		MAC_REG_W8(R_AX_SYS_FUNC_EN, val8 | B_AX_FEN_BBRSTB);
+	else
+		MAC_REG_W8(R_AX_SYS_FUNC_EN, val8 & (~B_AX_FEN_BBRSTB));
+
+	return MACSUCCESS;
+}
+
+static inline u32 _get_addr_range(struct mac_ax_adapter *adapter, u32 addr)
+{
+	u32 addr_idx;
+
+#define IOCHKRANG(chip) do { \
+		if (ADDR_IS_AON_##chip(addr)) \
+			addr_idx = ADDR_AON; \
+		else if (ADDR_IS_HCI_##chip(addr)) \
+			addr_idx = ADDR_HCI; \
+		else if (ADDR_IS_DMAC_##chip(addr)) \
+			addr_idx = ADDR_DMAC; \
+		else if (ADDR_IS_CMAC0_##chip(addr)) \
+			addr_idx = ADDR_CMAC0; \
+		else if (ADDR_IS_CMAC1_##chip(addr)) \
+			addr_idx = ADDR_CMAC1; \
+		else if (ADDR_IS_BB0_##chip(addr)) \
+			addr_idx = ADDR_BB0; \
+		else if (ADDR_IS_BB1_##chip(addr)) \
+			addr_idx = ADDR_BB1; \
+		else if (ADDR_IS_RF_##chip(addr)) \
+			addr_idx = ADDR_RF; \
+		else if (ADDR_IS_IND_ACES_##chip(addr)) \
+			addr_idx = ADDR_IND_ACES; \
+		else if (ADDR_IS_RSVD_##chip(addr)) \
+			addr_idx = ADDR_RSVD; \
+		else if (ADDR_IS_PON_##chip(addr)) \
+			addr_idx = ADDR_PON; \
+		else \
+			addr_idx = ADDR_INVALID; \
+	} while (0)
+
+	switch (adapter->hw_info->chip_id) {
+	case MAC_AX_CHIP_ID_8852A:
+		IOCHKRANG(8852A);
+		break;
+	case MAC_AX_CHIP_ID_8852B:
+		IOCHKRANG(8852B);
+		break;
+	case MAC_AX_CHIP_ID_8852C:
+		IOCHKRANG(8852C);
+		break;
+	case MAC_AX_CHIP_ID_8192XB:
+		IOCHKRANG(8192XB);
+		break;
+	case MAC_AX_CHIP_ID_8851B:
+		IOCHKRANG(8851B);
+		break;
+	case MAC_AX_CHIP_ID_8851E:
+		IOCHKRANG(8851E);
+		break;
+	case MAC_AX_CHIP_ID_8852D:
+		IOCHKRANG(8852D);
+		break;
+	default:
+		addr_idx = ADDR_INVALID;
+		break;
+	}
+
+#undef IOCHKRANG
+	return addr_idx;
+}
+
+u32 mac_io_chk_access(struct mac_ax_adapter *adapter, u32 offset)
+{
+	switch (_get_addr_range(adapter, offset)) {
+	case ADDR_AON:
+	case ADDR_HCI:
+		return MACSUCCESS;
+	case ADDR_PON:
+		break;
+	case ADDR_DMAC:
+		if (adapter->sm.dmac_func != MAC_AX_FUNC_ON)
+			return MACIOERRDMAC;
+		break;
+	case ADDR_CMAC0:
+		if (adapter->sm.cmac0_func != MAC_AX_FUNC_ON)
+			return MACIOERRCMAC0;
+		break;
+	case ADDR_CMAC1:
+		if (adapter->sm.cmac1_func != MAC_AX_FUNC_ON)
+			return MACIOERRCMAC1;
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+			return MACHWNOSUP;
+		break;
+	case ADDR_BB0:
+#if CHK_BBRF_IO
+		if (adapter->sm.bb0_func != MAC_AX_FUNC_ON)
+			return MACIOERRBB0;
+#endif
+		break;
+	case ADDR_BB1:
+#if CHK_BBRF_IO
+		if (adapter->sm.bb1_func != MAC_AX_FUNC_ON)
+			return MACIOERRBB1;
+#endif
+		break;
+	case ADDR_RF:
+#if CHK_BBRF_IO
+		if (adapter->sm.bb0_func != MAC_AX_FUNC_ON &&
+		    adapter->sm.bb1_func != MAC_AX_FUNC_ON)
+			return MACIOERRRF;
+#endif
+		break;
+	case ADDR_IND_ACES:
+		if (adapter->hw_info->is_sec_ic) {
+			PLTFM_MSG_ERR("[ERR]security mode ind aces\n");
+			return MACIOERRIND;
+		}
+
+		if (adapter->hw_info->ind_aces_cnt > 1)
+			PLTFM_MSG_ERR("[ERR]ind aces cnt %d ovf\n",
+				      adapter->hw_info->ind_aces_cnt);
+		if (adapter->hw_info->ind_aces_cnt != 1)
+			return MACIOERRIND;
+		break;
+	case ADDR_RSVD:
+		return MACIOERRRSVD;
+	case ADDR_INVALID:
+		return MACHWNOSUP;
+	}
+
+	if (adapter->sm.pwr != MAC_AX_PWR_ON)
+		return MACIOERRPWR;
+
+	if (adapter->sm.plat != MAC_AX_PLAT_ON)
+		return MACIOERRPLAT;
+
+	if (adapter->sm.io_st == MAC_AX_IO_ST_HANG)
+		return MACIOERRISH;
+
+	if ((adapter->sm.fw_rst == MAC_AX_FW_RESET_RECV_DONE ||
+	     adapter->sm.fw_rst == MAC_AX_FW_RESET_PROCESS) &&
+	    ADDR_NOT_ALLOW_SERL1(offset))
+		return MACIOERRSERL1;
+
+	if (adapter->sm.fw_rst == MAC_AX_FW_RESET_IDLE &&
+	    adapter->mac_pwr_info.pwr_in_lps && ADDR_NOT_ALLOW_LPS(offset))
+		return MACIOERRLPS;
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_bt_dis(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	return !!(MAC_REG_R32(R_AX_WL_BT_PWR_CTRL) & B_AX_BT_DISN_EN);
+}
+
+u32 mac_set_bt_dis(struct mac_ax_adapter *adapter, u8 en)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val;
+
+	val = MAC_REG_R32(R_AX_WL_BT_PWR_CTRL);
+	val = en ? val | B_AX_BT_DISN_EN : val & ~B_AX_BT_DISN_EN;
+	MAC_REG_W32(R_AX_WL_BT_PWR_CTRL, val);
+
+	return MACSUCCESS;
+}
+
+u32 mac_watchdog(struct mac_ax_adapter *adapter,
+		 struct mac_ax_wdt_param *wdt_param)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_drv_wdt_ctrl *ctrl_def = &wdt_ctrl_def;
+	u32 ret = MACSUCCESS;
+
+#if MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if ((is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	     is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) &&
+	    wdt_param->drv_ctrl.autok_wdt_ctrl != MAC_AX_PCIE_IGNORE &&
+	    (wdt_param->drv_ctrl.autok_wdt_ctrl != MAC_AX_PCIE_DEFAULT ||
+	     (ctrl_def->autok_wdt_ctrl != MAC_AX_PCIE_IGNORE &&
+	      ctrl_def->autok_wdt_ctrl != MAC_AX_PCIE_DEFAULT))) {
+		ret = ops->pcie_autok_counter_avg(adapter);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+
+	if ((is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	     is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) &&
+	    wdt_param->drv_ctrl.tp_wdt_ctrl != MAC_AX_PCIE_IGNORE &&
+	    (wdt_param->drv_ctrl.tp_wdt_ctrl != MAC_AX_PCIE_DEFAULT ||
+	     (ctrl_def->tp_wdt_ctrl != MAC_AX_PCIE_IGNORE &&
+	      ctrl_def->tp_wdt_ctrl != MAC_AX_PCIE_DEFAULT))) {
+		ret = ops->tp_adjust(adapter, wdt_param->tp);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+#endif
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_freerun(struct mac_ax_adapter *adapter,
+		    struct mac_ax_freerun *freerun)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_l, reg_h, ret;
+
+	ret = check_mac_en(adapter, freerun->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	reg_l = freerun->band == MAC_AX_BAND_0 ? R_AX_FREERUN_CNT_LOW : R_AX_FREERUN_CNT_LOW_C1;
+	reg_h = freerun->band == MAC_AX_BAND_0 ? R_AX_FREERUN_CNT_HIGH : R_AX_FREERUN_CNT_HIGH_C1;
+	freerun->freerun_l = MAC_REG_R32(reg_l);
+	freerun->freerun_h = MAC_REG_R32(reg_h);
+
+	return MACSUCCESS;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw.h
new file mode 100644
index 000000000000..28897506982a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw.h
@@ -0,0 +1,1344 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_HW_H_
+#define _MAC_AX_HW_H_
+
+#define BT_2_DW(B3, B2, B1, B0)	\
+	(((B3) << 24) | ((B2) << 16) | ((B1) << 8) | (B0))
+
+#define NIB_2_DW(B7, B6, B5, B4, B3, B2, B1, B0)	\
+	((((B7) & 0xf) << 28) | (((B6) & 0xf) << 24) | \
+	(((B5) & 0xf) << 20) | (((B4) & 0xf) << 16) | \
+	(((B3) & 0xf) << 12) | (((B2) & 0xf) << 8) | \
+	(((B1) & 0xf) << 4) | ((B0) & 0xf))
+
+#include "../type.h"
+#include "status.h"
+#include "wowlan.h"
+#include "tblupd.h"
+#include "ser.h"
+#include "../pcie_reg.h"
+
+#if MAC_AX_SDIO_SUPPORT
+#include "_sdio.h"
+#endif
+
+#if MAC_AX_PCIE_SUPPORT
+#include "_pcie.h"
+#endif
+
+#if MAC_AX_USB_SUPPORT
+#if MAC_AX_8852A_SUPPORT
+#include "mac_8852a/_usb_8852a.h"
+#endif
+#if MAC_AX_8852B_SUPPORT
+#include "mac_8852b/_usb_8852b.h"
+#endif
+#if MAC_AX_8852C_SUPPORT
+#include "mac_8852c/_usb_8852c.h"
+#endif
+#if MAC_AX_8851B_SUPPORT
+#include "mac_8851b/_usb_8851b.h"
+#endif
+#if MAC_AX_8851E_SUPPORT
+#include "mac_8851e/_usb_8851e.h"
+#endif
+#if MAC_AX_8852D_SUPPORT
+#include "mac_8852d/_usb_8852d.h"
+#endif
+#endif
+/*--------------------Define -------------------------------------------*/
+
+#define BITS_WLRF_CTRL 0x82
+#define BITS_WLRF1_CTRL 0x8200
+#define PHYREG_SET_ALL_CYCLE 0xC
+#define PHYREG_SET_XYN_CYCLE 0xE
+#define PHYREG_SET_X_CYCLE 0x4
+#define PHYREG_SET_N_CYCLE 0x2
+#define PHYREG_SET_Y_CYCLE 0x1
+
+#define TXSC_80M 0x91
+#define TXSC_40M 0x1
+#define TXSC_20M 0x0
+
+#define TBL_READ_OP 0x0
+#define TBL_WRITE_OP 0x1
+#define TXCNT_LMT_MSK 0x1
+
+#define CHANNEL_5G 34
+
+#define CR_TXCNT_MSK 0x7FFFFFFF
+
+/*For XTAL_SI */
+#define XTAL_SI_POLLING_CNT 1000
+#define XTAL_SI_POLLING_DLY_US 50
+#define XTAL_SI_NORMAL_WRITE 0x00
+#define XTAL_SI_NORMAL_READ 0x01
+#define XTAL_SI_XTAL_SC_XI 0x04
+#define XTAL_SI_XTAL_SC_XO 0x05
+#define XTAL_SI_XTAL_DRV 0x15
+#define XTAL_SI_XTAL_XMD_2 0x24
+#define XTAL_SI_XTAL_XMD_4 0x26
+#define XTAL_SI_CV 0x41
+#define XTAL0 0x0
+#define XTAL3 0x3
+#define XTAL_SI_WL_RFC_S0 0x80
+#define XTAL_SI_WL_RFC_S1 0x81
+#define XTAL_SI_ANAPAR_WL 0x90
+#define XTAL_SI_GNT_CTRL 0x91
+#define XTAL_SI_SRAM_CTRL 0xA1
+#define FULL_BIT_MASK 0xFF
+
+/*For ADC LDO setting*/
+#define LDO2PW_LDO_VSEL 0x3600000
+
+/* For TXPWR Usage*/
+#define PWR_BY_RATE_LGCY_OFFSET 0XC0
+#define PWR_BY_RATE_OFFSET 0XCC
+
+#define PWR_LMT_CCK_OFFSET 0XEC
+#define PWR_LMT_LGCY_OFFSET 0XF0
+#define PWR_LMT_TBL2_OFFSET 0XF4
+#define PWR_LMT_TBL5_OFFSET 0X100
+#define PWR_LMT_TBL6_OFFSET 0X104
+#define PWR_LMT_TBL7_OFFSET 0X108
+#define PWR_LMT_TBL8_OFFSET 0X10C
+#define PWR_LMT_TBL9_OFFSET 0X110
+
+#define PWR_LMT_TBL_UNIT 0X28
+#define PWR_BY_RATE_TBL_UNIT 0XF
+
+#define POLL_SWR_VOLT_CNT 2
+#define POLL_SWR_VOLT_US 50
+#define CORE_SWR_VOLT_MAX 0xE
+#define CORE_SWR_VOLT_MIN 0x8
+
+/* For SS SRAM access*/
+#define SS_R_QUOTA_SETTING  0
+#define SS_W_QUOTA_SETTING  1
+#define SS_R_QUOTA          2
+#define SS_W_QUOTA          3
+#define SS_R_TX_LEN         5
+#define SS_R_DL_MURU_DIS    8
+#define SS_W_DL_MURU_DIS    9
+#define SS_R_UL_TBL         10
+#define SS_W_UL_TBL         11
+#define SS_R_BSR_LEN        12
+#define SS_W_BSR_LEN        13
+
+#define SS_QUOTA_SETTING_MSK    0xF
+#define SS_MACID_SH		8
+
+/* WDRLS filter map */
+#define B_WDRLS_FLTR_TXOK BIT(24)
+#define B_WDRLS_FLTR_RTYLMT BIT(25)
+#define B_WDRLS_FLTR_LIFTIM BIT(26)
+#define B_WDRLS_FLTR_MACID BIT(27)
+
+#define MAC_AX_DRV_INFO_SIZE_0 0
+#define MAC_AX_DRV_INFO_SIZE_16 1
+#define MAC_AX_DRV_INFO_SIZE_32 2
+#define MAC_AX_DRV_INFO_SIZE_48 3
+#define MAC_AX_DRV_INFO_SIZE_64 4
+#define MAC_AX_DRV_INFO_SIZE_80 5
+
+#define CHK_BBRF_IO 0
+
+/* Narrow BW*/
+#define US_TIME_10M     0x50
+#define US_TIME_5M      0x40
+#define SLOTTIME_10M    0xD
+#define SLOTTIME_5M     0x15
+#define ACK_TO_10M      0x80
+#define ACK_TO_5M       0xFF
+
+#define MACID_NONE 0xFF
+
+#define PCIE_5G6G_PER_GEN1GEN2_ANA21_VAL 0x3700
+#define PCIE_5G6G_PER_GEN1GEN2_ANA23_VAL 0xFB66
+#define PCIE_5G6G_PER_GEN1GEN2_ANA2F_VAL 0x3008
+
+/*--------------------Define Enum---------------------------------------*/
+
+/**
+ * @enum tx_tf_info
+ *
+ * @brief tx_tf_info
+ *
+ * @var tx_tf_info::USER_INFO0_SEL
+ * Please Place Description here.
+ * @var tx_tf_info::USER_INFO1_SEL
+ * Please Place Description here.
+ * @var tx_tf_info::USER_INFO2_SEL
+ * Please Place Description here.
+ * @var tx_tf_info::USER_INFO3_SEL
+ * Please Place Description here.
+ * @var tx_tf_info::COMMON_INFO_SEL
+ * Please Place Description here.
+ */
+enum tx_tf_info {
+	USER_INFO0_SEL		= 0,
+	USER_INFO1_SEL		= 1,
+	USER_INFO2_SEL		= 2,
+	USER_INFO3_SEL		= 3,
+	COMMON_INFO_SEL		= 4,
+};
+
+enum addr_rang_idx {
+	ADDR_AON = 0,
+	ADDR_HCI,
+	ADDR_PON,
+	ADDR_DMAC,
+	ADDR_CMAC0,
+	ADDR_CMAC1,
+	ADDR_BB0,
+	ADDR_BB1,
+	ADDR_RF,
+	ADDR_IND_ACES,
+	ADDR_RSVD,
+
+	/* keep last */
+	ADDR_LAST,
+	ADDR_MAX = ADDR_LAST,
+	ADDR_INVALID = ADDR_LAST
+};
+
+/*--------------------Define MACRO--------------------------------------*/
+#define ADDR_IS_AON_8852A(addr) ((addr) <= 0x4FF ? 1 : 0)
+#define ADDR_IS_AON_8852B(addr) ((addr) <= 0x4FF ? 1 : 0)
+#define ADDR_IS_AON_8852C(addr) ((addr) <= 0x4FF ? 1 : 0)
+#define ADDR_IS_AON_8192XB(addr) ((addr) <= 0x4FF ? 1 : 0)
+#define ADDR_IS_AON_8851B(addr) ((addr) <= 0x4FF ? 1 : 0)
+#define ADDR_IS_AON_8851E(addr) ((addr) <= 0x4FF ? 1 : 0)
+#define ADDR_IS_AON_8852D(addr) ((addr) <= 0x4FF ? 1 : 0)
+
+#define ADDR_IS_HCI_8852A(addr) \
+	((addr) >= 0x1000 && (addr) <= 0x1FFF ? 1 : 0)
+#define ADDR_IS_HCI_8852B(addr) \
+	((addr) >= 0x1000 && (addr) <= 0x1FFF ? 1 : 0)
+#define ADDR_IS_HCI_8852C(addr) \
+	(((addr) >= 0x2000 && (addr) <= 0x63FF) || \
+	 ((addr) >= 0x7C00 && (addr) <= 0x7FFF) ? 1 : 0)
+#define ADDR_IS_HCI_8192XB(addr) \
+	(((addr) >= 0x2000 && (addr) <= 0x63FF) || \
+	 ((addr) >= 0x7C00 && (addr) <= 0x7FFF) ? 1 : 0)
+#define ADDR_IS_HCI_8851B(addr) \
+	((addr) >= 0x1000 && (addr) <= 0x1FFF ? 1 : 0)
+#define ADDR_IS_HCI_8851E(addr) \
+	(((addr) >= 0x2000 && (addr) <= 0x63FF) || \
+	 ((addr) >= 0x7C00 && (addr) <= 0x7FFF) ? 1 : 0)
+#define ADDR_IS_HCI_8852D(addr) \
+	(((addr) >= 0x2000 && (addr) <= 0x63FF) || \
+	 ((addr) >= 0x7C00 && (addr) <= 0x7FFF) ? 1 : 0)
+
+#define ADDR_IS_PON_8852A(addr) \
+	(((addr) >= 0x400 && (addr) <= 0xFFF) || \
+	 ((addr) >= 0x8000 && (addr) <= 0x8407) || \
+	 ((addr) >= 0xC000 && (addr) <= 0xC007) || \
+	 ((addr) >= 0xE000 && (addr) <= 0xE007) ? 1 : 0)
+#define ADDR_IS_PON_8852B(addr) \
+	(((addr) >= 0x400 && (addr) <= 0xFFF) || \
+	 ((addr) >= 0x8000 && (addr) <= 0x8407) || \
+	 ((addr) >= 0xC000 && (addr) <= 0xC007) ? 1 : 0)
+#define ADDR_IS_PON_8852C(addr) \
+	(((addr) >= 0x400 && (addr) <= 0xFFF) || \
+	 ((addr) >= 0x7000 && (addr) <= 0x7BFF) || \
+	 ((addr) >= 0x8000 && (addr) <= 0x8407) || \
+	 ((addr) >= 0xC000 && (addr) <= 0xC007) || \
+	 ((addr) >= 0xE000 && (addr) <= 0xE007) ? 1 : 0)
+#define ADDR_IS_PON_8192XB(addr) \
+	(((addr) >= 0x400 && (addr) <= 0xFFF) || \
+	 ((addr) >= 0x7000 && (addr) <= 0x7BFF) || \
+	 ((addr) >= 0x8000 && (addr) <= 0x8407) || \
+	 ((addr) >= 0xC000 && (addr) <= 0xC007) || \
+	 ((addr) >= 0xE000 && (addr) <= 0xE007) ? 1 : 0)
+#define ADDR_IS_PON_8851B(addr) \
+	(((addr) >= 0x400 && (addr) <= 0xFFF) || \
+	 ((addr) >= 0x8000 && (addr) <= 0x8407) || \
+	 ((addr) >= 0xC000 && (addr) <= 0xC007) ? 1 : 0)
+#define ADDR_IS_PON_8851E(addr) \
+	(((addr) >= 0x400 && (addr) <= 0xFFF) || \
+	 ((addr) >= 0x7000 && (addr) <= 0x7BFF) || \
+	 ((addr) >= 0x8000 && (addr) <= 0x8407) || \
+	 ((addr) >= 0xC000 && (addr) <= 0xC007) || \
+	 ((addr) >= 0xE000 && (addr) <= 0xE007) ? 1 : 0)
+#define ADDR_IS_PON_8852D(addr) \
+	(((addr) >= 0x400 && (addr) <= 0xFFF) || \
+	 ((addr) >= 0x7000 && (addr) <= 0x7BFF) || \
+	 ((addr) >= 0x8000 && (addr) <= 0x8407) || \
+	 ((addr) >= 0xC000 && (addr) <= 0xC007) || \
+	 ((addr) >= 0xE000 && (addr) <= 0xE007) ? 1 : 0)
+
+#define ADDR_IS_DMAC_8852A(addr) \
+	((addr) >= 0x8408 && (addr) <= 0xBFFF ? 1 : 0)
+#define ADDR_IS_DMAC_8852B(addr) \
+	((addr) >= 0x8408 && (addr) <= 0xBFFF ? 1 : 0)
+#define ADDR_IS_DMAC_8852C(addr) \
+	(((addr) >= 0x1000 && (addr) <= 0x1FFF) || \
+	 ((addr) >= 0x8408 && (addr) <= 0xBFFF) ? 1 : 0)
+#define ADDR_IS_DMAC_8192XB(addr) \
+	(((addr) >= 0x1000 && (addr) <= 0x1FFF) || \
+	 ((addr) >= 0x8408 && (addr) <= 0xBFFF) ? 1 : 0)
+#define ADDR_IS_DMAC_8851B(addr) \
+	((addr) >= 0x8408 && (addr) <= 0xBFFF ? 1 : 0)
+#define ADDR_IS_DMAC_8851E(addr) \
+	(((addr) >= 0x1000 && (addr) <= 0x1FFF) || \
+	 ((addr) >= 0x8408 && (addr) <= 0xBFFF) ? 1 : 0)
+#define ADDR_IS_DMAC_8852D(addr) \
+	(((addr) >= 0x1000 && (addr) <= 0x1FFF) || \
+	 ((addr) >= 0x8408 && (addr) <= 0xBFFF) ? 1 : 0)
+
+#define ADDR_IS_CMAC0_8852A(addr) \
+	((addr) >= 0xC008 && (addr) <= 0xDFFF ? 1 : 0)
+#define ADDR_IS_CMAC0_8852B(addr) \
+	((addr) >= 0xC008 && (addr) <= 0xDFFF ? 1 : 0)
+#define ADDR_IS_CMAC0_8852C(addr) \
+	((addr) >= 0xC008 && (addr) <= 0xDFFF ? 1 : 0)
+#define ADDR_IS_CMAC0_8192XB(addr) \
+	((addr) >= 0xC008 && (addr) <= 0xDFFF ? 1 : 0)
+#define ADDR_IS_CMAC0_8851B(addr) \
+	((addr) >= 0xC008 && (addr) <= 0xDFFF ? 1 : 0)
+#define ADDR_IS_CMAC0_8851E(addr) \
+	((addr) >= 0xC008 && (addr) <= 0xDFFF ? 1 : 0)
+#define ADDR_IS_CMAC0_8852D(addr) \
+	((addr) >= 0xC008 && (addr) <= 0xDFFF ? 1 : 0)
+
+#define ADDR_IS_CMAC1_8852A(addr) \
+	((addr) >= 0xE008 && (addr) <= 0xFFFF ? 1 : 0)
+#define ADDR_IS_CMAC1_8852B(addr) \
+	((addr) >= 0xE008 && (addr) <= 0xFFFF ? 0 : 0)
+#define ADDR_IS_CMAC1_8852C(addr) \
+	((addr) >= 0xE008 && (addr) <= 0xFFFF ? 1 : 0)
+#define ADDR_IS_CMAC1_8192XB(addr) \
+	((addr) >= 0xE008 && (addr) <= 0xFFFF ? 1 : 0)
+#define ADDR_IS_CMAC1_8851B(addr) \
+	((addr) >= 0xE008 && (addr) <= 0xFFFF ? 0 : 0)
+#define ADDR_IS_CMAC1_8851E(addr) \
+	((addr) >= 0xE008 && (addr) <= 0xFFFF ? 1 : 0)
+#define ADDR_IS_CMAC1_8852D(addr) \
+	((addr) >= 0xE008 && (addr) <= 0xFFFF ? 1 : 0)
+
+#define ADDR_IS_BB0_8852A(addr) \
+	(((addr) >= 0x10000 && (addr) <= 0x125FF) || \
+	 ((addr) >= 0x12E00 && (addr) <= 0x138FF) || \
+	 ((addr) >= 0x13C00 && (addr) <= 0x15FFF) || \
+	 ((addr) >= 0x17000 && (addr) <= 0x17FFF) ? 1 : 0)
+#define ADDR_IS_BB0_8852B(addr) \
+	(((addr) >= 0x10000 && (addr) <= 0x125FF) || \
+	 ((addr) >= 0x12E00 && (addr) <= 0x138FF) || \
+	 ((addr) >= 0x13C00 && (addr) <= 0x15FFF) || \
+	 ((addr) >= 0x17000 && (addr) <= 0x17FFF) ? 1 : 0)
+#define ADDR_IS_BB0_8852C(addr) \
+	(((addr) >= 0x10000 && (addr) <= 0x125FF) || \
+	 ((addr) >= 0x12E00 && (addr) <= 0x138FF) || \
+	 ((addr) >= 0x13C00 && (addr) <= 0x15FFF) || \
+	 ((addr) >= 0x17000 && (addr) <= 0x17FFF) ? 1 : 0)
+#define ADDR_IS_BB0_8192XB(addr) \
+	(((addr) >= 0x10000 && (addr) <= 0x125FF) || \
+	 ((addr) >= 0x12E00 && (addr) <= 0x138FF) || \
+	 ((addr) >= 0x13C00 && (addr) <= 0x15FFF) || \
+	 ((addr) >= 0x17000 && (addr) <= 0x17FFF) ? 1 : 0)
+#define ADDR_IS_BB0_8851B(addr) \
+	(((addr) >= 0x10000 && (addr) <= 0x125FF) || \
+	 ((addr) >= 0x12E00 && (addr) <= 0x138FF) || \
+	 ((addr) >= 0x13C00 && (addr) <= 0x15FFF) || \
+	 ((addr) >= 0x17000 && (addr) <= 0x17FFF) ? 1 : 0)
+#define ADDR_IS_BB0_8851E(addr) \
+	(((addr) >= 0x10000 && (addr) <= 0x125FF) || \
+	 ((addr) >= 0x12E00 && (addr) <= 0x138FF) || \
+	 ((addr) >= 0x13C00 && (addr) <= 0x15FFF) || \
+	 ((addr) >= 0x17000 && (addr) <= 0x17FFF) ? 1 : 0)
+#define ADDR_IS_BB0_8852D(addr) \
+	(((addr) >= 0x10000 && (addr) <= 0x125FF) || \
+	 ((addr) >= 0x12E00 && (addr) <= 0x138FF) || \
+	 ((addr) >= 0x13C00 && (addr) <= 0x15FFF) || \
+	 ((addr) >= 0x17000 && (addr) <= 0x17FFF) ? 1 : 0)
+
+#define ADDR_IS_BB1_8852A(addr) \
+	(((addr) >= 0x12600 && (addr) <= 0x12DFF) || \
+	 ((addr) >= 0x13900 && (addr) <= 0x13BFF) || \
+	 ((addr) >= 0x16000 && (addr) <= 0x16FFF) ? 1 : 0)
+#define ADDR_IS_BB1_8852B(addr) \
+	(((addr) >= 0x12600 && (addr) <= 0x12DFF) || \
+	 ((addr) >= 0x13900 && (addr) <= 0x13BFF) || \
+	 ((addr) >= 0x16000 && (addr) <= 0x16FFF) ? 1 : 0)
+#define ADDR_IS_BB1_8852C(addr) \
+	(((addr) >= 0x12600 && (addr) <= 0x12DFF) || \
+	 ((addr) >= 0x13900 && (addr) <= 0x13BFF) || \
+	 ((addr) >= 0x16000 && (addr) <= 0x16FFF) ? 1 : 0)
+#define ADDR_IS_BB1_8192XB(addr) \
+	(((addr) >= 0x12600 && (addr) <= 0x12DFF) || \
+	 ((addr) >= 0x13900 && (addr) <= 0x13BFF) || \
+	 ((addr) >= 0x16000 && (addr) <= 0x16FFF) ? 1 : 0)
+#define ADDR_IS_BB1_8851B(addr) \
+	(((addr) >= 0x12600 && (addr) <= 0x12DFF) || \
+	 ((addr) >= 0x13900 && (addr) <= 0x13BFF) || \
+	 ((addr) >= 0x16000 && (addr) <= 0x16FFF) ? 1 : 0)
+#define ADDR_IS_BB1_8851E(addr) \
+	(((addr) >= 0x12600 && (addr) <= 0x12DFF) || \
+	 ((addr) >= 0x13900 && (addr) <= 0x13BFF) || \
+	 ((addr) >= 0x16000 && (addr) <= 0x16FFF) ? 1 : 0)
+#define ADDR_IS_BB1_8852D(addr) \
+	(((addr) >= 0x12600 && (addr) <= 0x12DFF) || \
+	 ((addr) >= 0x13900 && (addr) <= 0x13BFF) || \
+	 ((addr) >= 0x16000 && (addr) <= 0x16FFF) ? 1 : 0)
+
+#define ADDR_IS_RF_8852A(addr) \
+	((addr) >= 0x18000 && (addr) <= 0x1DFFF ? 1 : 0)
+#define ADDR_IS_RF_8852B(addr) \
+	((addr) >= 0x18000 && (addr) <= 0x1FFFF ? 1 : 0)
+#define ADDR_IS_RF_8852C(addr) \
+	((addr) >= 0x18000 && (addr) <= 0x1FFFF ? 1 : 0)
+#define ADDR_IS_RF_8192XB(addr) \
+	((addr) >= 0x18000 && (addr) <= 0x1FFFF ? 1 : 0)
+#define ADDR_IS_RF_8851B(addr) \
+	((addr) >= 0x18000 && (addr) <= 0x1FFFF ? 1 : 0)
+#define ADDR_IS_RF_8851E(addr) \
+	((addr) >= 0x18000 && (addr) <= 0x1FFFF ? 1 : 0)
+#define ADDR_IS_RF_8852D(addr) \
+	((addr) >= 0x18000 && (addr) <= 0x1FFFF ? 1 : 0)
+
+#define ADDR_IS_IND_ACES_8852A(addr) \
+	((addr) >= 0x40000 && (addr) <= 0x7FFFF ? 1 : 0)
+#define ADDR_IS_IND_ACES_8852B(addr) \
+	((addr) >= 0x40000 && (addr) <= 0x7FFFF ? 1 : 0)
+#define ADDR_IS_IND_ACES_8852C(addr) \
+	((addr) >= 0x40000 && (addr) <= 0x7FFFF ? 1 : 0)
+#define ADDR_IS_IND_ACES_8192XB(addr) \
+	((addr) >= 0x40000 && (addr) <= 0x7FFFF ? 1 : 0)
+#define ADDR_IS_IND_ACES_8851B(addr) \
+	((addr) >= 0x40000 && (addr) <= 0x7FFFF ? 1 : 0)
+#define ADDR_IS_IND_ACES_8851E(addr) \
+	((addr) >= 0x40000 && (addr) <= 0x7FFFF ? 1 : 0)
+#define ADDR_IS_IND_ACES_8852D(addr) \
+	((addr) >= 0x40000 && (addr) <= 0x7FFFF ? 1 : 0)
+
+#define ADDR_IS_RSVD_8852A(addr) \
+	(((addr) >= 0x2000 && (addr) <= 0x7FFF) || \
+	 ((addr) >= 0x1E000 && (addr) <= 0x3FFFF) || \
+	 (addr) >= 0x80000 ? 1 : 0)
+#define ADDR_IS_RSVD_8852B(addr) \
+	(((addr) >= 0x2000 && (addr) <= 0x7FFF) || \
+	 ((addr) >= 0x20000 && (addr) <= 0x3FFFF) || \
+	 (addr) >= 0x80000 ? 1 : 0)
+#define ADDR_IS_RSVD_8852C(addr) \
+	(((addr) >= 0x6400 && (addr) <= 0x6FFF) || \
+	 ((addr) >= 0x20000 && (addr) <= 0x3FFFF) || \
+	 (addr) >= 0x80000 ? 1 : 0)
+#define ADDR_IS_RSVD_8192XB(addr) \
+	(((addr) >= 0x6400 && (addr) <= 0x6FFF) || \
+	 ((addr) >= 0x20000 && (addr) <= 0x3FFFF) || \
+	 (addr) >= 0x80000 ? 1 : 0)
+#define ADDR_IS_RSVD_8851B(addr) \
+	(((addr) >= 0x2000 && (addr) <= 0x7FFF) || \
+	 ((addr) >= 0x20000 && (addr) <= 0x3FFFF) || \
+	 (addr) >= 0x80000 ? 1 : 0)
+#define ADDR_IS_RSVD_8851E(addr) \
+	(((addr) >= 0x6400 && (addr) <= 0x6FFF) || \
+	 ((addr) >= 0x20000 && (addr) <= 0x3FFFF) || \
+	 (addr) >= 0x80000 ? 1 : 0)
+#define ADDR_IS_RSVD_8852D(addr) \
+	(((addr) >= 0x6400 && (addr) <= 0x6FFF) || \
+	 ((addr) >= 0x20000 && (addr) <= 0x3FFFF) || \
+	 (addr) >= 0x80000 ? 1 : 0)
+
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+#define ADDR_NOT_ALLOW_SERL1(addr) \
+	((addr) != R_AX_SER_DBG_INFO && (addr) != R_AX_HCI_FUNC_EN && \
+	 (addr) != R_AX_HD0IMR && (addr) != R_AX_HD0ISR ? 1 : 0)
+#define ADDR_NOT_ALLOW_LPS(addr) ((addr) != R_AX_CPWM ? 1 : 0)
+#else // (MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT)
+#define ADDR_NOT_ALLOW_SERL1(addr) \
+	((addr) != R_AX_SER_DBG_INFO && (addr) != R_AX_HCI_FUNC_EN_V1 && \
+	 (addr) != R_AX_HD0IMR_V1 && (addr) != R_AX_HD0ISR_V1 ? 1 : 0)
+#define ADDR_NOT_ALLOW_LPS(addr) ((addr) != R_AX_CPWM_V1 ? 1 : 0)
+#endif
+
+/*--------------------Define Struct-------------------------------------*/
+
+/*--------------------Function declaration------------------------------*/
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+/**
+ * @brief mac_get_hw_info
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval  mac_ax_hw_info
+ */
+struct mac_ax_hw_info *mac_get_hw_info(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_set_hw_value
+ *
+ * @param *adapter
+ * @param hw_id
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_hw_value(struct mac_ax_adapter *adapter,
+		     enum mac_ax_hw_id hw_id, void *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_get_hw_value
+ *
+ * @param *adapter
+ * @param hw_id
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_hw_value(struct mac_ax_adapter *adapter,
+		     enum mac_ax_hw_id hw_id, void *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_xtal_si
+ *
+ * @param *adapter
+ * @param offset
+ * @param val
+ * @param bitmask
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_xtal_si(struct mac_ax_adapter *adapter,
+		      u8 offset, u8 val, u8 bitmask);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_read_xtal_si
+ *
+ * @param *adapter
+ * @param offset
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_xtal_si(struct mac_ax_adapter *adapter,
+		     u8 offset, u8 *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief set_host_rpr
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_host_rpr(struct mac_ax_adapter *adapter,
+		 struct mac_ax_host_rpr_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_read_pwr_reg
+ *
+ * @param *adapter
+ * @param band
+ * @param offset
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_l2_status(struct mac_ax_adapter *adapter);
+u32 mac_read_pwr_reg(struct mac_ax_adapter *adapter, u8 band,
+		     const u32 offset, u32 *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_pwr_reg
+ *
+ * @param *adapter
+ * @param band
+ * @param offset
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_pwr_reg(struct mac_ax_adapter *adapter, u8 band,
+		      const u32 offset, u32 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_msk_pwr_reg
+ *
+ * @param *adapter
+ * @param band
+ * @param offset
+ * @param mask
+ * @param val
+ * @return write tx power reg with mask value into fw
+ * @retval u32
+ */
+u32 mac_write_msk_pwr_reg(struct mac_ax_adapter *adapter, u8 band,
+			  const u32 offset, u32 mask, u32 val);
+
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_pwr_ofst_mode
+ *
+ * @param *adapter
+ * @param band
+ * @param *tpu
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_pwr_ofst_mode(struct mac_ax_adapter *adapter,
+			    u8 band, struct rtw_tpu_info *tpu);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_pwr_ofst_bw
+ *
+ * @param *adapter
+ * @param band
+ * @param *tpu
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_pwr_ofst_bw(struct mac_ax_adapter *adapter,
+			  u8 band, struct rtw_tpu_info *tpu);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_pwr_ref_reg
+ *
+ * @param *adapter
+ * @param band
+ * @param *tpu
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_pwr_ref_reg(struct mac_ax_adapter *adapter,
+			  u8 band, struct rtw_tpu_info *tpu);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_pwr_limit_en
+ *
+ * @param *adapter
+ * @param band
+ * @param *tpu
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_pwr_limit_en(struct mac_ax_adapter *adapter,
+			   u8 band, struct rtw_tpu_info *tpu);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_pwr_limit_rua_reg
+ *
+ * @param *adapter
+ * @param band
+ * @param *tpu
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_pwr_limit_rua_reg(struct mac_ax_adapter *adapter,
+				u8 band, struct rtw_tpu_info *tpu);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_pwr_limit_reg
+ *
+ * @param *adapter
+ * @param band
+ * @param *tpu
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_pwr_limit_reg(struct mac_ax_adapter *adapter,
+			    u8 band, struct rtw_tpu_pwr_imt_info *tpu);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_pwr_by_rate_reg
+ *
+ * @param *adapter
+ * @param band
+ * @param *tpu
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_pwr_by_rate_reg(struct mac_ax_adapter *adapter,
+			      u8 band, struct rtw_tpu_pwr_by_rate_info *tpu);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/** * @brief mac_read_xcap_reg
+ *
+ * @param *adapter
+ * @param sc_xo
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_xcap_reg(struct mac_ax_adapter *adapter, u8 sc_xo, u32 *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_xcap_reg
+ *
+ * @param *adapter
+ * @param sc_xo
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_xcap_reg(struct mac_ax_adapter *adapter, u8 sc_xo, u32 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_bbrst_reg
+ *
+ * @param *adapter
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_xcap_reg_dav(struct mac_ax_adapter *adapter, u8 sc_xo, u32 *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_xcap_reg
+ *
+ * @param *adapter
+ * @param sc_xo
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_xcap_reg_dav(struct mac_ax_adapter *adapter, u8 sc_xo, u32 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_write_bbrst_reg
+ *
+ * @param *adapter
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_write_bbrst_reg(struct mac_ax_adapter *adapter, u8 val);
+/**
+ * @}
+ * @}
+ */
+
+/** * @brief set_macid_pause
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_macid_pause(struct mac_ax_adapter *adapter,
+		    struct mac_ax_macid_pause_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief macid_pause
+ *
+ * @param *adapter
+ * @param *grp
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 macid_pause(struct mac_ax_adapter *adapter,
+		struct mac_ax_macid_pause_grp *grp);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/** * @brief set_macid_pause_sleep
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_macid_pause_sleep(struct mac_ax_adapter *adapter,
+			  struct mac_ax_macid_pause_sleep_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief macid_pause_sleep
+ *
+ * @param *adapter
+ * @param *grp
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 macid_pause_sleep(struct mac_ax_adapter *adapter,
+		      struct mac_ax_macid_pause_sleep_grp *grp);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief get_macid_pause
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_macid_pause(struct mac_ax_adapter *adapter,
+		    struct mac_ax_macid_pause_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief get_ss_wmm_tbl
+ *
+ * @param *adapter
+ * @param *ctrl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_ss_wmm_tbl(struct mac_ax_adapter *adapter,
+		   struct mac_ax_ss_wmm_tbl_ctrl *ctrl);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief set_enable_bb_rf
+ *
+ * @param *adapter
+ * @param enable
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_enable_bb_rf(struct mac_ax_adapter *adapter, u8 enable);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief set_cctl_rty_limit
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_cctl_rty_limit(struct mac_ax_adapter *adapter,
+		       struct mac_ax_cctl_rty_lmt_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief cfg_mac_bw
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cfg_mac_bw(struct mac_ax_adapter *adapter,
+	       struct mac_ax_cfg_bw *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief get_ss_quota_mode
+ *
+ * @param *adapter
+ * @param *ctrl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_ss_quota_mode(struct mac_ax_adapter *adapter,
+		      struct mac_ax_ss_quota_mode_ctrl *ctrl);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief set_ss_quota_mode
+ *
+ * @param *adapter
+ * @param *ctrl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_ss_quota_mode(struct mac_ax_adapter *adapter,
+		      struct mac_ax_ss_quota_mode_ctrl *ctrl);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief ss_get_quotasetting
+ *
+ * @param *adapter
+ * @param *para
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ss_get_quotasetting(struct mac_ax_adapter *adapter,
+			struct mac_ax_ss_quota_setting *para);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief ss_set_quotasetting
+ *
+ * @param *adapter
+ * @param *para
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ss_set_quotasetting(struct mac_ax_adapter *adapter,
+			struct mac_ax_ss_quota_setting *para);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief scheduler_set_prebkf
+ *
+ * @param *adapter
+ * @param *para
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 scheduler_set_prebkf(struct mac_ax_adapter *adapter,
+			 struct mac_ax_prebkf_setting *para);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief set_bacam_mode
+ *
+ * @param *adapter
+ * @param mode_sel
+ * @return Set the R_AX_RESPBA_CAM_CTRL bit 4 to be 0 or 1 which decide the
+ * option mode in BA CAM.
+ * @retval u32
+ */
+u32 set_bacam_mode(struct mac_ax_adapter *adapter, u8 mode_sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief scheduler_set_prebkf
+ *
+ * @param *adapter
+ * @param *mode_sel
+ * @return Get the option mode from R_AX_RESPBA_CAM_CTRL bit 4 in the BA CAM.
+ * @retval u32
+ */
+u32 get_bacam_mode(struct mac_ax_adapter *adapter, u8 *mode_sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_io_chk_access
+ *
+ * @param *adapter
+ * @param offset
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_io_chk_access(struct mac_ax_adapter *adapter, u32 offset);
+/**
+ * @}
+ * @}
+ */
+
+u32 mac_get_bt_dis(struct mac_ax_adapter *adapter);
+
+u32 mac_set_bt_dis(struct mac_ax_adapter *adapter, u8 en);
+
+/**
+ * @brief mac_watchdog
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @param *wdt_param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_watchdog(struct mac_ax_adapter *adapter,
+		 struct mac_ax_wdt_param *wdt_param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup HW_Related
+ * @{
+ */
+
+/**
+ * @brief mac_get_freerun
+ *
+ * @param *adapter
+ * @param *freerun
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_freerun(struct mac_ax_adapter *adapter,
+		    struct mac_ax_freerun *freerun);
+
+/**
+ * @}
+ * @}
+ */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw_seq.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw_seq.c
new file mode 100644
index 000000000000..ee93b1d68dac
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw_seq.c
@@ -0,0 +1,278 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "hw_seq.h"
+
+#if MAC_AX_FW_REG_OFLD
+u32 mac_set_hwseq_reg(struct mac_ax_adapter *adapter,
+		      u8 idx,
+		      u16 val)
+{
+	u32 ret = 0;
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct mac_ax_set_hwseq_reg *content;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_set_hwseq_reg));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	content = (struct mac_ax_set_hwseq_reg *)buf;
+
+	content->reg_idx = idx;
+	content->seq_val = val;
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_SET_HWSEQ_REG,
+			      0,
+			      1);
+
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+#else
+u32 mac_set_hwseq_reg(struct mac_ax_adapter *adapter,
+		      u8 idx,
+		      u16 val)
+{
+	u32 reg_val;
+	u32 ret = MACNOTSUP;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (idx) {
+	case R_AX_HW_SEQ_0:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			reg_val = MAC_REG_R32(R_AX_HW_SEQ_0_1);
+			reg_val &= ~((u32)B_AX_HW_SEQ0_MSK << B_AX_HW_SEQ0_SH);
+			reg_val |= (val << B_AX_HW_SEQ0_SH);
+			MAC_REG_W32(R_AX_HW_SEQ_0_1, reg_val);
+			ret = MACSUCCESS;
+		}
+#endif
+#if (MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT || MAC_AX_1115E_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D) ||
+		    is_chip_id(adapter, MAC_BE_CHIP_ID_1115E)) {
+			reg_val = MAC_REG_R32(R_AX_CMAC_HWSSN01);
+			reg_val &= ~((u32)B_AX_HW_CMAC_SSN0_MSK << B_AX_HW_CMAC_SSN0_SH);
+			reg_val |= (val << B_AX_HW_CMAC_SSN0_SH);
+			MAC_REG_W32(R_AX_CMAC_HWSSN01, reg_val);
+			ret = MACSUCCESS;
+		}
+#endif
+		break;
+	case R_AX_HW_SEQ_1:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			reg_val = MAC_REG_R32(R_AX_HW_SEQ_0_1);
+			reg_val &= ~((u32)B_AX_HW_SEQ1_MSK << B_AX_HW_SEQ1_SH);
+			reg_val |= (val << B_AX_HW_SEQ1_SH);
+			MAC_REG_W32(R_AX_HW_SEQ_0_1, reg_val);
+			ret = MACSUCCESS;
+		}
+#endif
+#if (MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT || MAC_AX_1115E_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D) ||
+		    is_chip_id(adapter, MAC_BE_CHIP_ID_1115E)) {
+			reg_val = MAC_REG_R32(R_AX_CMAC_HWSSN01);
+			reg_val &= ~((u32)B_AX_HW_CMAC_SSN1_MSK << B_AX_HW_CMAC_SSN1_SH);
+			reg_val |= (val << B_AX_HW_CMAC_SSN1_SH);
+			MAC_REG_W32(R_AX_CMAC_HWSSN01, reg_val);
+			ret = MACSUCCESS;
+		}
+#endif
+		break;
+	case R_AX_HW_SEQ_2:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			reg_val = MAC_REG_R32(R_AX_HW_SEQ_2_3);
+			reg_val &= ~((u32)B_AX_HW_SEQ2_MSK << B_AX_HW_SEQ2_SH);
+			reg_val |= (val << B_AX_HW_SEQ2_SH);
+			MAC_REG_W32(R_AX_HW_SEQ_2_3, reg_val);
+			ret = MACSUCCESS;
+		}
+#endif
+#if (MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT || MAC_AX_1115E_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D) ||
+		    is_chip_id(adapter, MAC_BE_CHIP_ID_1115E)) {
+			reg_val = MAC_REG_R32(R_AX_CMAC_HWSSN23);
+			reg_val &= ~((u32)B_AX_HW_CMAC_SSN2_MSK << B_AX_HW_CMAC_SSN2_SH);
+			reg_val |= (val << B_AX_HW_CMAC_SSN2_SH);
+			MAC_REG_W32(R_AX_CMAC_HWSSN23, reg_val);
+			ret = MACSUCCESS;
+		}
+#endif
+		break;
+	case R_AX_HW_SEQ_3:
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			reg_val = MAC_REG_R32(R_AX_HW_SEQ_2_3);
+			reg_val &= ~((u32)B_AX_HW_SEQ3_MSK << B_AX_HW_SEQ3_SH);
+			reg_val |= (val << B_AX_HW_SEQ3_SH);
+			MAC_REG_W32(R_AX_HW_SEQ_2_3, reg_val);
+			ret = MACSUCCESS;
+		}
+#endif
+#if (MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT || MAC_AX_1115E_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D) ||
+		    is_chip_id(adapter, MAC_BE_CHIP_ID_1115E)) {
+			reg_val = MAC_REG_R32(R_AX_CMAC_HWSSN23);
+			reg_val &= ~((u32)B_AX_HW_CMAC_SSN3_MSK << B_AX_HW_CMAC_SSN3_SH);
+			reg_val |= (val << B_AX_HW_CMAC_SSN3_SH);
+			MAC_REG_W32(R_AX_CMAC_HWSSN23, reg_val);
+			ret = MACSUCCESS;
+		}
+#endif
+		break;
+	default:
+		ret = MACNOITEM;
+	}
+	return ret;
+}
+#endif
+
+u32 mac_set_hwseq_dctrl(struct mac_ax_adapter *adapter,
+			u8 macid,
+			struct mac_ax_dctl_seq_cfg *seq_info)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	info.seq0 = seq_info->seq0_val;
+	info.seq1 = seq_info->seq1_val;
+	info.seq2 = seq_info->seq2_val;
+	info.seq3 = seq_info->seq3_val;
+	info.hw_exseq_macid = seq_info->hw_exseq_macid;
+	mask.seq0 = FWCMD_H2C_DCTRL_SEQ0_MSK;
+	mask.seq1 = FWCMD_H2C_DCTRL_SEQ1_MSK;
+	mask.seq2 = FWCMD_H2C_DCTRL_SEQ2_MSK;
+	mask.seq3 = FWCMD_H2C_DCTRL_SEQ3_MSK;
+	mask.hw_exseq_macid = FWCMD_H2C_DCTRL_V1_HW_EXSEQ_MACID_MSK;
+	ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 1);
+
+	return ret;
+}
+
+u32 mac_get_hwseq_cfg(struct mac_ax_adapter *adapter,
+		      u8 macid, u8 ref_sel,
+		      struct mac_ax_dctl_seq_cfg *seq_info)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *a_ops = adapter_to_mac_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = 0;
+
+	if (ref_sel) {
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			seq_info->seq0_val = (MAC_REG_R32(R_AX_HW_SEQ_0_1) >> B_AX_HW_SEQ0_SH)
+					    & B_AX_HW_SEQ0_MSK;
+			seq_info->seq1_val = (MAC_REG_R32(R_AX_HW_SEQ_0_1) >> B_AX_HW_SEQ1_SH)
+					    & B_AX_HW_SEQ1_MSK;
+			seq_info->seq2_val = (MAC_REG_R32(R_AX_HW_SEQ_2_3) >> B_AX_HW_SEQ2_SH)
+					    & B_AX_HW_SEQ2_MSK;
+			seq_info->seq3_val = (MAC_REG_R32(R_AX_HW_SEQ_2_3) >> B_AX_HW_SEQ3_SH)
+					    & B_AX_HW_SEQ3_MSK;
+			return MACSUCCESS;
+			}
+#endif
+#if (MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT || MAC_AX_1115E_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D) ||
+		    is_chip_id(adapter, MAC_BE_CHIP_ID_1115E)) {
+			seq_info->seq0_val = (MAC_REG_R32(R_AX_CMAC_HWSSN01) >>
+					      B_AX_HW_CMAC_SSN0_SH) & B_AX_HW_CMAC_SSN0_MSK;
+			seq_info->seq1_val = (MAC_REG_R32(R_AX_CMAC_HWSSN01) >>
+					      B_AX_HW_CMAC_SSN1_SH) & B_AX_HW_CMAC_SSN1_MSK;
+			seq_info->seq2_val = (MAC_REG_R32(R_AX_CMAC_HWSSN23) >>
+					      B_AX_HW_CMAC_SSN2_SH) & B_AX_HW_CMAC_SSN2_MSK;
+			seq_info->seq3_val = (MAC_REG_R32(R_AX_CMAC_HWSSN23) >>
+					      B_AX_HW_CMAC_SSN3_SH) & B_AX_HW_CMAC_SSN3_MSK;
+			return MACSUCCESS;
+		}
+#endif
+	} else {
+		ret = a_ops->upd_dctl_info(adapter, &info, &mask, macid, 0);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		seq_info->seq0_val = info.seq0;
+		seq_info->seq1_val = info.seq1;
+		seq_info->seq2_val = info.seq2;
+		seq_info->seq3_val = info.seq3;
+		seq_info->hw_exseq_macid = info.hw_exseq_macid;
+		return MACSUCCESS;
+	}
+	return MACNOTSUP;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw_seq.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw_seq.h
new file mode 100644
index 000000000000..e4465d191033
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hw_seq.h
@@ -0,0 +1,116 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_HW_SEQ_H_
+#define _MAC_AX_HW_SEQ_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+
+enum {
+	R_AX_HW_SEQ_0 = 0,
+	R_AX_HW_SEQ_1 = 1,
+	R_AX_HW_SEQ_2 = 2,
+	R_AX_HW_SEQ_3 = 3,
+};
+
+/**
+ * @struct mac_ax_set_hwseq_reg
+ * @brief mac_ax_set_hwseq_reg
+ *
+ * @var mac_ax_set_hwseq_reg::reg_idx
+ * Please Place Description here.
+ * @var mac_ax_set_hwseq_reg::seq_val
+ * Please Place Description here.
+ * @var mac_ax_set_hwseq_reg::rsvd0
+ * Please Place Description here.
+ */
+struct mac_ax_set_hwseq_reg {
+	u32 reg_idx: 2;
+	u32 seq_val: 12;
+	u32 rsvd0: 18;
+};
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_ShortCut
+ * @{
+ */
+/**
+ * @brief mac_set_hwseq_reg
+ *
+ * @param *adapter
+ * @param idx
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_hwseq_reg(struct mac_ax_adapter *adapter,
+		      u8 idx,
+		      u16 val);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_ShortCut
+ * @{
+ */
+/**
+ * @brief mac_set_hwseq_dctrl
+ *
+ * @param *adapter
+ * @param macid
+ * @param mac_ax_dctl_seq_cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_hwseq_dctrl(struct mac_ax_adapter *adapter,
+			u8 macid,
+			struct mac_ax_dctl_seq_cfg *seq_info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_ShortCut
+ * @{
+ */
+/**
+ * @brief mac_get_hwseq_cfg
+ *
+ * @param *adapter
+ * @param macid
+ * @param ref_sel 0:dmac_tbl; 1:CR
+ * @param mac_ax_dctl_seq_cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_hwseq_cfg(struct mac_ax_adapter *adapter,
+		      u8 macid, u8 ref_sel,
+		      struct mac_ax_dctl_seq_cfg *seq_info);
+/**
+ * @}
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hwamsdu.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hwamsdu.c
new file mode 100644
index 000000000000..a51a55018063
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hwamsdu.c
@@ -0,0 +1,256 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "hwamsdu.h"
+
+#if MAC_AX_FW_REG_OFLD
+u32 mac_enable_cut_hwamsdu(struct mac_ax_adapter *adapter,
+			   u8 enable,
+			   u8 low_th,
+			   u16 high_th,
+			   enum mac_ax_ex_shift aligned)
+{
+	u32 ret = 0;
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct mac_ax_en_amsdu_cut *content;
+
+	if (chk_patch_cut_amsdu_rls_ple_issue(adapter) == (u32)PATCH_ENABLE)
+		return MACNOTSUP;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_en_amsdu_cut));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	content = (struct mac_ax_en_amsdu_cut *)buf;
+	content->enable = enable;
+	content->low_th = low_th;
+	content->high_th = high_th;
+	content->aligned = aligned;
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_AMSDU_CUT_REG,
+			      0,
+			      1);
+
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_enable_hwmasdu(struct mac_ax_adapter *adapter,
+		       u8 enable,
+		       enum mac_ax_amsdu_pkt_num max_num,
+		       u8 en_single_amsdu,
+		       u8 en_last_amsdu_padding)
+
+{
+	u32 ret = 0;
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct mac_ax_en_hwamsdu *content;
+
+	if (chk_patch_txamsdu_rls_wd_issue(adapter) == (u32)PATCH_ENABLE)
+		return MACNOTSUP;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_en_hwamsdu));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	content = (struct mac_ax_en_hwamsdu *)buf;
+	content->enable = enable;
+	content->max_num = max_num;
+	content->en_single_amsdu = en_single_amsdu;
+	content->en_last_amsdu_padding = en_last_amsdu_padding;
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_HWAMSDU_REG,
+			      0,
+			      1);
+
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+#else
+
+u32 mac_enable_hwamsdu(struct mac_ax_adapter *adapter,
+		       u8 enable,
+		       enum mac_ax_amsdu_pkt_num max_num,
+		       u8 en_single_amsdu,
+		       u8 en_last_amsdu_padding)
+{
+	u32 val;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (chk_patch_txamsdu_rls_wd_issue(adapter) == (u32)PATCH_ENABLE)
+		return MACNOTSUP;
+
+	if (max_num >= MAC_AX_AMSDU_AGG_NUM_MAX)
+		return MACNOITEM;
+
+	//HW AMSDU register
+	val = MAC_REG_R32(R_AX_HWAMSDU_CTRL);
+	val = (SET_CLR_WORD(val, max_num, B_AX_MAX_AMSDU_NUM) |
+	       B_AX_HWAMSDU_EN);
+	if (!enable)
+		val &= ~B_AX_HWAMSDU_EN;
+	MAC_REG_W32(R_AX_HWAMSDU_CTRL, val);
+
+	MAC_REG_W32(R_AX_HWAMSDU_CTRL, (MAC_REG_R32(R_AX_HWAMSDU_CTRL) &
+		    (~B_AX_SINGLE_AMSDU)) |
+		    (en_single_amsdu ? B_AX_SINGLE_AMSDU : 0));
+
+	MAC_REG_W32(R_AX_DMAC_TABLE_CTRL, (MAC_REG_R32(R_AX_DMAC_TABLE_CTRL) &
+		    (~B_AX_HWAMSDU_PADDING_MODE)) |
+		    (en_last_amsdu_padding ? B_AX_HWAMSDU_PADDING_MODE : 0));
+
+	return MACSUCCESS;
+}
+#endif
+
+u32 mac_hwamsdu_fwd_search_en(struct mac_ax_adapter *adapter, u8 enable)
+{
+	u32 val;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		val = MAC_REG_R32(R_AX_HWAMSDU_CTRL);
+		if (!enable)
+			val &= ~B_AX_AMSDU_FS_ENABLE;
+		else
+			val |= B_AX_AMSDU_FS_ENABLE;
+
+		MAC_REG_W32(R_AX_HWAMSDU_CTRL, val);
+		return MACSUCCESS;
+	} else {
+		return MACNOTSUP;
+	}
+}
+
+u32 mac_hwamsdu_macid_en(struct mac_ax_adapter *adapter, u8 macid, u8 enable)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	info.sta_amsdu_en = enable;
+	mask.sta_amsdu_en = HW_AMSDU_MACID_ENABLE;
+	ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 1);
+
+	return ret;
+}
+
+u8 mac_hwamsdu_get_macid_en(struct mac_ax_adapter *adapter, u8 macid)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	mask.sta_amsdu_en = HW_AMSDU_MACID_ENABLE;
+	ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 0);
+
+	if (ret != MACSUCCESS)
+		return 0;
+	else
+		return (u8)info.sta_amsdu_en;
+}
+
+u32 mac_hwamsdu_max_len(struct mac_ax_adapter *adapter, u8 macid, u8 amsdu_max_len)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	info.amsdu_max_length = amsdu_max_len;
+	mask.amsdu_max_length = FWCMD_H2C_DCTRL_AMSDU_MAX_LEN_MSK;
+	ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 1);
+
+	return ret;
+}
+
+u8 mac_hwamsdu_get_max_len(struct mac_ax_adapter *adapter, u8 macid)
+{
+	struct mac_ax_dctl_info info = {0};
+	struct mac_ax_dctl_info mask = {0};
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	u32 ret = 0;
+
+	mask.amsdu_max_length = FWCMD_H2C_DCTRL_AMSDU_MAX_LEN_MSK;
+	ret = ops->upd_dctl_info(adapter, &info, &mask, macid, 0);
+
+	if (ret != MACSUCCESS)
+		return 0;
+	else
+		return (u8)info.amsdu_max_length;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hwamsdu.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hwamsdu.h
new file mode 100644
index 000000000000..ccd56245a40d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/hwamsdu.h
@@ -0,0 +1,171 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_HWAMSDU_H_
+#define _MAC_AX_HWAMSDU_H_
+
+#include "../type.h"
+#include "../mac_ax.h"
+
+#define MAX_LENGTH_ENUM 7
+#define HW_AMSDU_MACID_ENABLE 0x1
+
+/**
+ * @struct mac_ax_en_amsdu_cut
+ * @brief mac_ax_en_amsdu_cut
+ *
+ * @var mac_ax_en_amsdu_cut::enable
+ * Please Place Description here.
+ * @var mac_ax_en_amsdu_cut::low_th
+ * Please Place Description here.
+ * @var mac_ax_en_amsdu_cut::high_th
+ * Please Place Description here.
+ * @var mac_ax_en_amsdu_cut::aligned
+ * Please Place Description here.
+ * @var mac_ax_en_amsdu_cut::rsvd0
+ * Please Place Description here.
+ */
+struct mac_ax_en_amsdu_cut {
+	/* dword0 */
+	u32 enable: 1;
+	u32 low_th: 8;
+	u32 high_th: 16;
+	u32 aligned: 2;
+	u32 rsvd0: 5;
+};
+
+/**
+ * @struct mac_ax_en_hwamsdu
+ * @brief mac_ax_en_hwamsdu
+ *
+ * @var mac_ax_en_hwamsdu::enable
+ * Please Place Description here.
+ * @var mac_ax_en_hwamsdu::max_num
+ * Please Place Description here.
+ * @var mac_ax_en_hwamsdu::en_single_amsdu
+ * Please Place Description here.
+ * @var mac_ax_en_hwamsdu::en_last_amsdu_padding
+ * Please Place Description here.
+ * @var mac_ax_en_hwamsdu::rsvd0
+ * Please Place Description here.
+ */
+struct mac_ax_en_hwamsdu {
+	/* dword0 */
+	u32 enable: 1;
+	u32 max_num: 2;
+	u32 en_single_amsdu:1;
+	u32 en_last_amsdu_padding:1;
+	u32 rsvd0: 27;
+};
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_ShortCut
+ * @{
+ */
+
+/**
+ * @brief mac_enable_hwmasdu
+ *
+ * @param *adapter
+ * @param enable
+ * @param max_num
+ * @param en_single_amsdu
+ * @param en_last_amsdu_padding
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_enable_hwamsdu(struct mac_ax_adapter *adapter,
+		       u8 enable,
+		       enum mac_ax_amsdu_pkt_num max_num,
+		       u8 en_single_amsdu,
+		       u8 en_last_amsdu_padding);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @brief mac_hwamsdu_fwd_search_en
+ *
+ * @param *adapter
+ * @param enable
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hwamsdu_fwd_search_en(struct mac_ax_adapter *adapter, u8 enable);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @brief mac_enable_hwmasdu
+ *
+ * @param *adapter
+ * @param macid
+ * @param enable
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hwamsdu_macid_en(struct mac_ax_adapter *adapter, u8 macid, u8 enable);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @brief mac_enable_hwmasdu
+ *
+ * @param *adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 mac_hwamsdu_get_macid_en(struct mac_ax_adapter *adapter, u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_enable_hwmasdu
+ *
+ * @param *adapter
+ * @param macid
+ * @param amsdu_max_len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hwamsdu_max_len(struct mac_ax_adapter *adapter, u8 macid, u8 amsdu_max_len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_enable_hwmasdu
+ *
+ * @param *adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 mac_hwamsdu_get_max_len(struct mac_ax_adapter *adapter, u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/init.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/init.c
new file mode 100644
index 000000000000..17f6c06285e6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/init.c
@@ -0,0 +1,913 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "init.h"
+#include "security_cam.h"
+#include "hw.h"
+#include "mac_priv.h"
+#if MAC_AX_PCIE_SUPPORT
+#include "_pcie.h"
+#endif
+
+u32 mac_set_dut_env_mode(struct mac_ax_adapter *adapter, enum rtw_mac_env_mode env_mode)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	adapter->env = env_mode;
+	val32 = MAC_REG_R32(R_AX_WCPU_FW_CTRL);
+	val32 = SET_CLR_WORD(val32, (u8)env_mode, B_AX_FW_ENV);
+	MAC_REG_W32(R_AX_WCPU_FW_CTRL, val32);
+
+	return MACSUCCESS;
+}
+
+static void _mp_core_swr_volt(struct mac_ax_adapter *adapter, u8 init)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	enum mac_ax_core_swr_volt v;
+	u8 val8;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))
+		return;
+
+	if (init) {
+		val8 = MAC_REG_R8(R_AX_SPS_DIG_ON_CTRL0);
+		adapter->hw_info->core_swr_volt = GET_FIELD(val8, B_AX_VOL_L1);
+	} else {
+		v = MAC_AX_SWR_NORM;
+		mac_ops->set_hw_value(adapter, MAC_AX_HW_SET_CORE_SWR_VOLT, &v);
+	}
+}
+
+#if MAC_AX_PCIE_SUPPORT
+static u32 clr_pcie_avoid_pldr_polling_fail(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret = MACSUCCESS;
+
+	if (!(is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	      is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	      is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)))
+		return MACSUCCESS;
+
+	ret = p_ops->ctrl_trxdma_pcie(adapter, MAC_AX_PCIE_DISABLE,
+				      MAC_AX_PCIE_DISABLE, MAC_AX_PCIE_DISABLE);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("Disable pcie dma all %d\n", ret);
+		return ret;
+	}
+
+	ret = ops->clr_idx_all(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("Clear idx all %d\n", ret);
+		return ret;
+	}
+
+	ret = p_ops->poll_dma_all_idle_pcie(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("Poll dma all %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_NEW_HALMAC_INTERFACE
+struct mac_ax_adapter *get_mac_ax_adapter(enum mac_ax_intf intf,
+					  u8 chip_id, u8 cv,
+					  void *phl_adapter, void *drv_adapter,
+					  struct mac_ax_pltfm_cb *pltfm_cb)
+{
+	struct mac_ax_adapter *adapter = NULL;
+
+	switch (chip_id) {
+#if MAC_AX_8852A_SUPPORT
+	case MAC_AX_CHIP_ID_8852A:
+		adapter = get_mac_8852a_adapter(intf, cv, phl_adapter,
+						drv_adapter, pltfm_cb);
+		break;
+#endif
+	default:
+		return NULL;
+	}
+
+	return adapter;
+}
+#else
+struct mac_ax_adapter *get_mac_ax_adapter(enum mac_ax_intf intf,
+					  u8 chip_id, u8 cv,
+					  void *drv_adapter,
+					  struct mac_ax_pltfm_cb *pltfm_cb)
+{
+	struct mac_ax_adapter *adapter = NULL;
+
+	switch (chip_id) {
+#if MAC_AX_8852A_SUPPORT
+	case MAC_AX_CHIP_ID_8852A:
+		adapter = get_mac_8852a_adapter(intf, cv, drv_adapter,
+						pltfm_cb);
+		break;
+#endif
+#if MAC_AX_8852B_SUPPORT
+	case MAC_AX_CHIP_ID_8852B:
+		adapter = get_mac_8852b_adapter(intf, cv, drv_adapter,
+						pltfm_cb);
+		break;
+#endif
+#if MAC_AX_8852C_SUPPORT
+	case MAC_AX_CHIP_ID_8852C:
+		adapter = get_mac_8852c_adapter(intf, cv, drv_adapter,
+						pltfm_cb);
+		break;
+#endif
+#if MAC_AX_8192XB_SUPPORT
+	case MAC_AX_CHIP_ID_8192XB:
+		adapter = get_mac_8192xb_adapter(intf, cv, drv_adapter,
+						 pltfm_cb);
+		break;
+#endif
+#if MAC_AX_8851B_SUPPORT
+	case MAC_AX_CHIP_ID_8851B:
+		adapter = get_mac_8851b_adapter(intf, cv, drv_adapter,
+						pltfm_cb);
+		break;
+#endif
+#if MAC_AX_8851E_SUPPORT
+	case MAC_AX_CHIP_ID_8851E:
+		adapter = get_mac_8851e_adapter(intf, cv, drv_adapter,
+						pltfm_cb);
+		break;
+#endif
+#if MAC_AX_8852D_SUPPORT
+	case MAC_AX_CHIP_ID_8852D:
+		adapter = get_mac_8852d_adapter(intf, cv, drv_adapter,
+						pltfm_cb);
+		break;
+#endif
+#if MAC_AX_1115E_SUPPORT
+	case MAC_BE_CHIP_ID_1115E:
+		adapter = get_mac_1115e_adapter(intf, cv, drv_adapter,
+						pltfm_cb);
+		break;
+#endif
+
+	default:
+		return NULL;
+	}
+
+	return adapter;
+}
+#endif
+
+u32 hci_func_en(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, reg;
+	u32 ret = MACSUCCESS;
+
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT)
+	reg = R_AX_HCI_FUNC_EN;
+#else
+	reg = R_AX_HCI_FUNC_EN_V1;
+#endif
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		val32 = MAC_REG_R32(reg) |
+			B_AX_HCI_TXDMA_EN | B_AX_HCI_RXDMA_EN;
+		MAC_REG_W32(reg, val32);
+	} else {
+		val32 = MAC_REG_R32(reg) |
+			B_AX_HCI_TXDMA_EN | B_AX_HCI_RXDMA_EN;
+		MAC_REG_W32(reg, val32);
+	}
+	return ret;
+}
+
+u32 dmac_pre_init(struct mac_ax_adapter *adapter, enum mac_ax_qta_mode mode, u8 fwdl)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret;
+
+	ret = p_ops->dmac_func_pre_en(adapter);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: dmac func pre en %d\n", __func__, ret);
+		return ret;
+	}
+
+	if (!fwdl)
+		return MACSUCCESS;
+
+	ret = dle_init(adapter, MAC_AX_QTA_DLFW, mode);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]DLE pre init %d\n", ret);
+		return ret;
+	}
+
+	ret = hfc_init(adapter, 1, 0, 1);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]HCI FC pre init %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+u32 cmac_func_en(struct mac_ax_adapter *adapter, u8 band, u8 en)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32_func_en = 0;
+	u32 val32_ck_en = 0;
+	u32 val32_c1pc_en = 0;
+	u32 addrl_func_en[] = {R_AX_CMAC_FUNC_EN, R_AX_CMAC_FUNC_EN_C1};
+	u32 addrl_ck_en[] = {R_AX_CK_EN, R_AX_CK_EN_C1};
+
+	val32_func_en = B_AX_CMAC_EN | B_AX_CMAC_TXEN | B_AX_CMAC_RXEN |
+			B_AX_PHYINTF_EN | B_AX_CMAC_DMA_EN | B_AX_PTCLTOP_EN |
+			B_AX_SCHEDULER_EN | B_AX_TMAC_EN | B_AX_RMAC_EN |
+			B_AX_CMAC_CRPRT;
+	val32_ck_en = B_AX_CMAC_CKEN | B_AX_PHYINTF_CKEN | B_AX_CMAC_DMA_CKEN |
+		      B_AX_PTCLTOP_CKEN | B_AX_SCHEDULER_CKEN | B_AX_TMAC_CKEN |
+		      B_AX_RMAC_CKEN;
+	val32_c1pc_en = B_AX_R_SYM_WLCMAC1_PC_EN |
+			B_AX_R_SYM_WLCMAC1_P1_PC_EN |
+			B_AX_R_SYM_WLCMAC1_P2_PC_EN |
+			B_AX_R_SYM_WLCMAC1_P3_PC_EN |
+			B_AX_R_SYM_WLCMAC1_P4_PC_EN;
+
+	if (band >= MAC_AX_BAND_NUM) {
+		PLTFM_MSG_ERR("band %d invalid\n", band);
+		return MACFUNCINPUT;
+	}
+
+	if (en) {
+		if (band == MAC_AX_BAND_1) {
+			MAC_REG_W32(R_AX_AFE_CTRL1,
+				    MAC_REG_R32(R_AX_AFE_CTRL1) |
+				    val32_c1pc_en);
+			MAC_REG_W32(R_AX_SYS_ISO_CTRL_EXTEND,
+				    MAC_REG_R32(R_AX_SYS_ISO_CTRL_EXTEND) &
+				    ~B_AX_R_SYM_ISO_CMAC12PP);
+			MAC_REG_W32(R_AX_SYS_ISO_CTRL_EXTEND,
+				    MAC_REG_R32(R_AX_SYS_ISO_CTRL_EXTEND) |
+				    B_AX_CMAC1_FEN);
+		}
+		MAC_REG_W32(addrl_ck_en[band],
+			    MAC_REG_R32(addrl_ck_en[band]) | val32_ck_en);
+		MAC_REG_W32(addrl_func_en[band],
+			    MAC_REG_R32(addrl_func_en[band]) | val32_func_en);
+	} else {
+		MAC_REG_W32(addrl_func_en[band],
+			    MAC_REG_R32(addrl_func_en[band]) & ~val32_func_en);
+		MAC_REG_W32(addrl_ck_en[band],
+			    MAC_REG_R32(addrl_ck_en[band]) & ~val32_ck_en);
+		if (band == MAC_AX_BAND_1) {
+			MAC_REG_W32(R_AX_SYS_ISO_CTRL_EXTEND,
+				    MAC_REG_R32(R_AX_SYS_ISO_CTRL_EXTEND) &
+				    ~B_AX_CMAC1_FEN);
+			MAC_REG_W32(R_AX_SYS_ISO_CTRL_EXTEND,
+				    MAC_REG_R32(R_AX_SYS_ISO_CTRL_EXTEND) |
+				    B_AX_R_SYM_ISO_CMAC12PP);
+			MAC_REG_W32(R_AX_AFE_CTRL1,
+				    MAC_REG_R32(R_AX_AFE_CTRL1) &
+				    ~val32_c1pc_en);
+		}
+	}
+
+	if (band == MAC_AX_BAND_0)
+		adapter->sm.cmac0_func = en ? MAC_AX_FUNC_ON : MAC_AX_FUNC_OFF;
+	else
+		adapter->sm.cmac1_func = en ? MAC_AX_FUNC_ON : MAC_AX_FUNC_OFF;
+
+	return MACSUCCESS;
+}
+
+u32 chip_func_en(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	u32 val32;
+	u32 ret = MACSUCCESS;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		/* patch for OCP */
+		val32 = MAC_REG_R32(R_AX_SPS_DIG_ON_CTRL0);
+		val32 |= SET_WOR2(B_AX_OCP_L1_MSK, B_AX_OCP_L1_SH,
+				  B_AX_OCP_L1_MSK);
+		MAC_REG_W32(R_AX_SPS_DIG_ON_CTRL0, val32);
+	}
+
+	return ret;
+}
+
+u32 mac_sys_init(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret;
+	u8 sec_mode;
+
+	ret = p_ops->dmac_func_en(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]DMAC en %d\n", ret);
+		return ret;
+	}
+
+	ret = p_ops->cmac_func_en(adapter, MAC_AX_BAND_0, MAC_AX_FUNC_EN);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC %d en %d %d\n",
+			      MAC_AX_BAND_0, MAC_AX_FUNC_EN, ret);
+		return ret;
+	}
+
+	ret = chip_func_en(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]chip en %d\n", ret);
+		return ret;
+	}
+
+	ret = mac_chk_sec_rec(adapter, &sec_mode);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]chk_sec_rec %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+u32 mac_hal_init(struct mac_ax_adapter *adapter,
+		 struct mac_ax_trx_info *trx_info,
+		 struct mac_ax_fwdl_info *fwdl_info,
+		 struct mac_ax_intf_info *intf_info)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+#if MAC_AX_FEATURE_DBGPKG
+	struct mac_ax_dbgpkg dbg_val = {0};
+	struct mac_ax_dbgpkg_en dbg_en = {0};
+#endif
+	u32 ret;
+	u32 rom_addr;
+	u8 fwdl_en;
+	u32 val32;
+
+	ret = mac_set_dut_env_mode(adapter, trx_info->env_mode);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]mac_set_dut_env_mode\n");
+		goto end;
+	}
+
+	_mp_core_swr_volt(adapter, 1);
+
+	ret = mac_ops->pwr_switch(adapter, 1);
+	if (ret == MACALRDYON) {
+		ret = mac_ops->pwr_switch(adapter, 0);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]pwr_switch 0 fail %d\n", ret);
+			goto end;
+		}
+		ret = mac_ops->pwr_switch(adapter, 1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]pwr_switch 0->1 fail %d\n", ret);
+			goto end;
+		}
+	}
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]pwr_switch 1 fail %d\n", ret);
+		goto end;
+	}
+#if MAC_AX_PCIE_SUPPORT
+	if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+		ret = clr_pcie_avoid_pldr_polling_fail(adapter);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]clr_pcie_avoid_pldr_polling_fail %d\n", ret);
+			goto end;
+		}
+	}
+#endif
+	ret = hci_func_en(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]hci_func_en %d\n", ret);
+		goto end;
+	}
+
+	fwdl_en = fwdl_info->fw_en &&
+		  (fwdl_info->dlrom_en || fwdl_info->dlram_en) ? 1 : 0;
+	ret = dmac_pre_init(adapter, trx_info->qta_mode, fwdl_en);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]fwdl_pre_init %d\n", ret);
+		goto end;
+	}
+
+	ret = ops->intf_pre_init(adapter, intf_info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]intf_pre_init %d\n", ret);
+		goto end;
+	}
+
+	if (fwdl_info->fw_en) {
+		if (fwdl_info->dlrom_en) {
+			switch (hw_info->chip_id) {
+			case MAC_AX_CHIP_ID_8852A:
+				rom_addr = RTL8852A_ROM_ADDR;
+				break;
+			case MAC_AX_CHIP_ID_8852B:
+				rom_addr = RTL8852B_ROM_ADDR;
+				break;
+			case MAC_AX_CHIP_ID_8852C:
+				rom_addr = RTL8852C_ROM_ADDR;
+				break;
+			case MAC_AX_CHIP_ID_8192XB:
+				rom_addr = RTL8192XB_ROM_ADDR;
+				break;
+			case MAC_AX_CHIP_ID_8851B:
+				rom_addr = RTL8851B_ROM_ADDR;
+				break;
+			case MAC_AX_CHIP_ID_8851E:
+				rom_addr = RTL8851E_ROM_ADDR;
+				break;
+			case MAC_AX_CHIP_ID_8852D:
+				rom_addr = RTL8852D_ROM_ADDR;
+				break;
+			default:
+				PLTFM_MSG_ERR("[ERR]chip id\n");
+				return MACNOITEM;
+			}
+			ret = mac_ops->romdl(adapter,
+					     fwdl_info->rom_buff,
+					     rom_addr,
+					     fwdl_info->rom_size);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("[ERR]romdl %d\n", ret);
+				goto end;
+			}
+		}
+		/*WDT reset host_en*/
+		val32 = MAC_REG_R32(R_AX_SYS_CFG5);
+		val32 &= (~(B_AX_WDT_WAKE_PCIE_EN | B_AX_WDT_WAKE_USB_EN));
+		MAC_REG_W32(R_AX_SYS_CFG5, val32);
+		/*add WDT paltform_en CR setting*/
+		val32 = MAC_REG_R32(R_AX_WCPU_FW_CTRL);
+		if (fwdl_info->wdt_plt_rst_en == 1)
+			val32 |= B_AX_WDT_PLT_RST_EN;
+		else
+			val32 &= ~(B_AX_WDT_PLT_RST_EN);
+		MAC_REG_W32(R_AX_WCPU_FW_CTRL, val32);
+
+		if (fwdl_info->dlram_en) {
+			if (fwdl_info->fw_from_hdr) {
+				ret = mac_ops->enable_fw(adapter,
+							 fwdl_info->fw_cat);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("[ERR]enable_fw %d\n",
+						      ret);
+					goto end;
+				}
+			} else {
+				ret = mac_ops->enable_cpu(adapter, 0,
+							  fwdl_info->dlram_en);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("[ERR]enable_cpu %d\n",
+						      ret);
+					goto end;
+				}
+
+				ret = mac_ops->fwdl(adapter,
+						    fwdl_info->ram_buff,
+						    fwdl_info->ram_size);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("[ERR]fwdl %d\n", ret);
+					goto end;
+				}
+			}
+		}
+	}
+
+	ret = set_enable_bb_rf(adapter, MAC_AX_FUNC_EN);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]set_enable_bb_rf %d\n", ret);
+		goto end;
+	}
+
+	ret = mac_ops->sys_init(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]sys_init %d\n", ret);
+		goto end;
+	}
+
+	ret = mac_ops->trx_init(adapter, trx_info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]trx_init %d\n", ret);
+		goto end;
+	}
+
+	adapter->sm.mac_rdy = MAC_AX_MAC_RDY;
+
+	ret = mac_ops->feat_init(adapter, trx_info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]feat_init %d\n", ret);
+		goto end;
+	}
+
+	ret = ops->intf_init(adapter, intf_info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]intf_init %d\n", ret);
+		goto end;
+	}
+
+	ret = mac_ops->gpio_init(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]gpio_init %d\n", ret);
+		goto end;
+	}
+
+end:
+	if (ret != MACSUCCESS) {
+		adapter->sm.mac_rdy = MAC_AX_MAC_INIT_ERR;
+		PLTFM_MSG_ERR("[ERR]hal_init fail %d\n", ret);
+#if MAC_AX_FEATURE_DBGPKG
+		dbg_en.ss_dbg = 1;
+		dbg_en.dle_dbg = 1;
+		dbg_en.dmac_dbg = 1;
+		dbg_en.cmac_dbg = 1;
+		dbg_en.mac_dbg_port = 1;
+		dbg_en.plersvd_dbg = 1;
+		mac_ops->dbg_status_dump(adapter, &dbg_val, &dbg_en);
+#endif
+	} else {
+		adapter->sm.mac_rdy = MAC_AX_MAC_RDY;
+	}
+
+	return ret;
+}
+
+u32 mac_hal_deinit(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	struct mac_ax_intf_ops *intf_ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+#if MAC_AX_FEATURE_DBGPKG
+	struct mac_ax_dbgpkg dbg_val = {0};
+	struct mac_ax_dbgpkg_en dbg_en = {0};
+#endif
+	u32 ret;
+
+	adapter->sm.mac_rdy = MAC_AX_MAC_NOT_RDY;
+
+	_mp_core_swr_volt(adapter, 1);
+
+	ret = rst_port_info(adapter, MAC_AX_BAND_0);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]reset port info %d\n", ret);
+		return ret;
+	}
+
+	if (!(is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	      is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))) {
+		ret = rst_port_info(adapter, MAC_AX_BAND_1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]reset port info %d\n", ret);
+			return ret;
+		}
+	}
+
+	ret = rst_p2p_info(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]reset p2p info %d\n", ret);
+		return ret;
+	}
+
+	ret = rst_dbcc_info(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]reset dbcc info %d\n", ret);
+		return ret;
+	}
+
+	ret = p_ops->free_sec_info_tbl(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]remove security info tbl\n");
+		return ret;
+	}
+
+	ret = mac_remove_role_by_band(adapter, MAC_AX_BAND_0, 1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]remove band0 role fail\n");
+		return ret;
+	}
+
+	ret = mac_remove_role_by_band(adapter, MAC_AX_BAND_1, 1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]remove band0 role fail\n");
+		return ret;
+	}
+
+	ret = intf_ops->intf_deinit(adapter, NULL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]intf deinit\n");
+		goto end;
+	}
+
+	ret = ops->pwr_switch(adapter, 0);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]pwr switch off\n");
+		goto end;
+	}
+
+	ret = mac_rst_drv_info(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]rst driver info\n");
+		goto end;
+	}
+
+end:
+	if (ret != MACSUCCESS) {
+		adapter->sm.mac_rdy = MAC_AX_MAC_DEINIT_ERR;
+		PLTFM_MSG_ERR("[ERR]hal_deinit fail %d\n", ret);
+#if MAC_AX_FEATURE_DBGPKG
+		dbg_en.ss_dbg = 1;
+		dbg_en.dle_dbg = 1;
+		dbg_en.dmac_dbg = 1;
+		dbg_en.cmac_dbg = 1;
+		dbg_en.mac_dbg_port = 1;
+		dbg_en.plersvd_dbg = 1;
+		ops->dbg_status_dump(adapter, &dbg_val, &dbg_en);
+#endif
+	}
+
+	return ret;
+}
+
+u32 mac_hal_fast_init(struct mac_ax_adapter *adapter,
+		      struct mac_ax_trx_info *trx_info,
+		      struct mac_ax_fwdl_info *fwdl_info,
+		      struct mac_ax_intf_info *intf_info)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+#if MAC_AX_FEATURE_DBGPKG
+	struct mac_ax_dbgpkg dbg_val = {0};
+	struct mac_ax_dbgpkg_en dbg_en = {0};
+#endif
+	u32 rom_addr;
+	u32 ret;
+	u8 fwdl_en;
+
+	ret = mac_ops->pwr_switch(adapter, 1);
+	if (ret == MACALRDYON) {
+		ret = mac_ops->pwr_switch(adapter, 0);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]pwr_switch 0 fail %d\n", ret);
+			goto end;
+		}
+		ret = mac_ops->pwr_switch(adapter, 1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]pwr_switch 0->1 fail %d\n", ret);
+			goto end;
+		}
+	}
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]pwr_switch 1 fail %d\n", ret);
+		goto end;
+	}
+#if MAC_AX_PCIE_SUPPORT
+	if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+		ret = clr_pcie_avoid_pldr_polling_fail(adapter);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]clr_pcie_avoid_pldr_polling_fail %d\n", ret);
+			goto end;
+		}
+	}
+#endif
+	ret = hci_func_en(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]hci_func_en %d\n", ret);
+		goto end;
+	}
+
+	fwdl_en = fwdl_info->fw_en &&
+		  (fwdl_info->dlrom_en || fwdl_info->dlram_en) ? 1 : 0;
+	ret = dmac_pre_init(adapter, trx_info->qta_mode, fwdl_en);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]fwdl_pre_init %d\n", ret);
+		goto end;
+	}
+
+	ret = ops->intf_pre_init(adapter, intf_info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]intf_pre_init %d\n", ret);
+		goto end;
+	}
+
+	if (fwdl_info->fw_en) {
+		if (fwdl_info->dlrom_en) {
+			switch (hw_info->chip_id) {
+			case MAC_AX_CHIP_ID_8852A:
+				rom_addr = RTL8852A_ROM_ADDR;
+				break;
+			case MAC_AX_CHIP_ID_8852B:
+				rom_addr = RTL8852B_ROM_ADDR;
+				break;
+			case MAC_AX_CHIP_ID_8852C:
+				rom_addr = RTL8852C_ROM_ADDR;
+				break;
+			case MAC_AX_CHIP_ID_8192XB:
+				rom_addr = RTL8192XB_ROM_ADDR;
+				break;
+			case MAC_AX_CHIP_ID_8851B:
+				rom_addr = RTL8851B_ROM_ADDR;
+				break;
+			case MAC_AX_CHIP_ID_8851E:
+				rom_addr = RTL8851E_ROM_ADDR;
+				break;
+			case MAC_AX_CHIP_ID_8852D:
+				rom_addr = RTL8852D_ROM_ADDR;
+				break;
+			default:
+				PLTFM_MSG_ERR("[ERR]chip id\n");
+				return MACNOITEM;
+			}
+			ret = mac_ops->romdl(adapter,
+					     fwdl_info->rom_buff,
+					     rom_addr,
+					     fwdl_info->rom_size);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("[ERR]romdl %d\n", ret);
+				goto end;
+			}
+		}
+
+		if (fwdl_info->dlram_en) {
+			if (fwdl_info->fw_from_hdr) {
+				ret = mac_ops->enable_fw(adapter,
+							 fwdl_info->fw_cat);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("[ERR]enable_fw %d\n",
+						      ret);
+					goto end;
+				}
+			} else {
+				ret = mac_ops->enable_cpu(adapter, 0,
+							  fwdl_info->dlram_en);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("[ERR]enable_cpu %d\n",
+						      ret);
+					goto end;
+				}
+
+				ret = mac_ops->fwdl(adapter,
+						    fwdl_info->ram_buff,
+						    fwdl_info->ram_size);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("[ERR]fwdl %d\n", ret);
+					goto end;
+				}
+			}
+		}
+	}
+
+end:
+	if (ret != MACSUCCESS) {
+		adapter->sm.mac_rdy = MAC_AX_MAC_FINIT_ERR;
+		PLTFM_MSG_ERR("[ERR]hal_fast_init fail %d\n", ret);
+#if MAC_AX_FEATURE_DBGPKG
+		dbg_en.ss_dbg = 1;
+		dbg_en.dle_dbg = 1;
+		dbg_en.dmac_dbg = 1;
+		dbg_en.cmac_dbg = 1;
+		dbg_en.mac_dbg_port = 1;
+		dbg_en.plersvd_dbg = 1;
+		mac_ops->dbg_status_dump(adapter, &dbg_val, &dbg_en);
+#endif
+	} else {
+		adapter->sm.mac_rdy = MAC_AX_MAC_RDY;
+	}
+
+	return ret;
+}
+
+u32 mac_hal_fast_deinit(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_ops *ops = adapter_to_mac_ops(adapter);
+	struct mac_ax_intf_ops *intf_ops = adapter_to_intf_ops(adapter);
+#if MAC_AX_FEATURE_DBGPKG
+	struct mac_ax_dbgpkg dbg_val = {0};
+	struct mac_ax_dbgpkg_en dbg_en = {0};
+#endif
+	u32 ret;
+
+	adapter->sm.mac_rdy = MAC_AX_MAC_NOT_RDY;
+
+	ret = intf_ops->intf_deinit(adapter, NULL);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]intf deinit\n");
+		goto end;
+	}
+
+	ret = ops->pwr_switch(adapter, 0);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]pwr switch off\n");
+		goto end;
+	}
+end:
+	if (ret != MACSUCCESS) {
+		adapter->sm.mac_rdy = MAC_AX_MAC_FDEINIT_ERR;
+		PLTFM_MSG_ERR("[ERR]hal_fast_deinit fail %d\n", ret);
+#if MAC_AX_FEATURE_DBGPKG
+		dbg_en.ss_dbg = 1;
+		dbg_en.dle_dbg = 1;
+		dbg_en.dmac_dbg = 1;
+		dbg_en.cmac_dbg = 1;
+		dbg_en.mac_dbg_port = 1;
+		dbg_en.plersvd_dbg = 1;
+		ops->dbg_status_dump(adapter, &dbg_val, &dbg_en);
+#endif
+	}
+
+	return ret;
+}
+
+u32 mac_ax_init_state(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_state_mach sm = MAC_AX_DFLT_SM;
+
+	adapter->sm = sm;
+	adapter->fw_info.h2c_seq = 0;
+	adapter->fw_info.rec_seq = 0;
+
+	return MACSUCCESS;
+}
+
+u32 mix_info_init(struct mac_ax_adapter *adapter)
+{
+	PLTFM_MUTEX_INIT(&adapter->fw_info.seq_lock);
+	PLTFM_MUTEX_INIT(&adapter->fw_info.msg_reg);
+	PLTFM_MUTEX_INIT(&adapter->flash_info.lock);
+	PLTFM_MUTEX_INIT(&adapter->hw_info->ind_access_lock);
+	PLTFM_MUTEX_INIT(&adapter->hw_info->lte_rlock);
+	PLTFM_MUTEX_INIT(&adapter->hw_info->lte_wlock);
+	PLTFM_MUTEX_INIT(&adapter->hw_info->dbg_port_lock);
+	PLTFM_MUTEX_INIT(&adapter->cmd_ofld_info.cmd_ofld_lock);
+	PLTFM_MUTEX_INIT(&adapter->hw_info->err_set_lock);
+	PLTFM_MUTEX_INIT(&adapter->hw_info->err_get_lock);
+	PLTFM_MUTEX_INIT(&adapter->h2c_agg_info.h2c_agg_lock);
+#if MAC_AX_PCIE_SUPPORT
+	PLTFM_MUTEX_INIT(&adapter->hw_info->dbi_lock);
+	PLTFM_MUTEX_INIT(&adapter->hw_info->mdio_lock);
+#endif
+	PLTFM_MUTEX_INIT(&adapter->scanofld_info.drv_chlist_state_lock);
+	PLTFM_MUTEX_INIT(&adapter->scanofld_info.fw_chlist_state_lock);
+	PLTFM_MUTEX_INIT(&adapter->csi_info.state_lock);
+	adapter->hw_info->ind_aces_cnt = 0;
+	adapter->hw_info->dbg_port_cnt = 0;
+
+	return MACSUCCESS;
+}
+
+u32 mix_info_exit(struct mac_ax_adapter *adapter)
+{
+	PLTFM_MUTEX_DEINIT(&adapter->fw_info.seq_lock);
+	PLTFM_MUTEX_DEINIT(&adapter->fw_info.msg_reg);
+	PLTFM_MUTEX_DEINIT(&adapter->flash_info.lock);
+	PLTFM_MUTEX_DEINIT(&adapter->hw_info->ind_access_lock);
+	PLTFM_MUTEX_DEINIT(&adapter->hw_info->lte_rlock);
+	PLTFM_MUTEX_DEINIT(&adapter->hw_info->lte_wlock);
+	PLTFM_MUTEX_DEINIT(&adapter->hw_info->dbg_port_lock);
+	PLTFM_MUTEX_DEINIT(&adapter->cmd_ofld_info.cmd_ofld_lock);
+	PLTFM_MUTEX_DEINIT(&adapter->hw_info->err_set_lock);
+	PLTFM_MUTEX_DEINIT(&adapter->hw_info->err_get_lock);
+	PLTFM_MUTEX_DEINIT(&adapter->h2c_agg_info.h2c_agg_lock);
+#if MAC_AX_PCIE_SUPPORT
+	PLTFM_MUTEX_DEINIT(&adapter->hw_info->dbi_lock);
+	PLTFM_MUTEX_DEINIT(&adapter->hw_info->mdio_lock);
+#endif
+	PLTFM_MUTEX_DEINIT(&adapter->scanofld_info.drv_chlist_state_lock);
+	PLTFM_MUTEX_DEINIT(&adapter->scanofld_info.fw_chlist_state_lock);
+	PLTFM_MUTEX_DEINIT(&adapter->csi_info.state_lock);
+	adapter->hw_info->ind_aces_cnt = 0;
+	adapter->hw_info->dbg_port_cnt = 0;
+
+	return MACSUCCESS;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/init.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/init.h
new file mode 100644
index 000000000000..b13821ccb1d4
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/init.h
@@ -0,0 +1,273 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_INIT_H_
+#define _MAC_AX_INIT_H_
+
+#include "../type.h"
+#if MAC_AX_8852A_SUPPORT
+#include "mac_8852a/init_8852a.h"
+#endif
+#if MAC_AX_8852B_SUPPORT
+#include "mac_8852b/init_8852b.h"
+#endif
+#if MAC_AX_8852C_SUPPORT
+#include "mac_8852c/init_8852c.h"
+#endif
+#if MAC_AX_8192XB_SUPPORT
+#include "mac_8192xb/init_8192xb.h"
+#endif
+#if MAC_AX_8851B_SUPPORT
+#include "mac_8851b/init_8851b.h"
+#endif
+#if MAC_AX_8851E_SUPPORT
+#include "mac_8851e/init_8851e.h"
+#endif
+#if MAC_AX_8852D_SUPPORT
+#include "mac_8852d/init_8852d.h"
+#endif
+#if MAC_AX_1115E_SUPPORT
+#include "mac_1115e/init_1115e.h"
+#endif
+
+#include "role.h"
+#include "fwdl.h"
+#include "mport.h"
+#include "phy_rpt.h"
+#if MAC_AX_PCIE_SUPPORT
+#include "_pcie.h"
+#endif
+/*--------------------Define -------------------------------------------*/
+/*--------------------Define Enum---------------------------------------*/
+/*--------------------Define Struct-------------------------------------*/
+
+#ifdef CONFIG_NEW_HALMAC_INTERFACE
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup System
+ * @{
+ */
+
+/**
+ * @brief get_mac_ax_adapter
+ *
+ * @param intf
+ * @param chip_id
+ * @param cv
+ * @param *phl_adapter
+ * @param *drv_adapter
+ * @param *pltfm_cb
+ * @return Please Place Description here.
+ * @retval  mac_ax_adapter
+ */
+struct mac_ax_adapter *get_mac_ax_adapter(enum mac_ax_intf intf,
+					  u8 chip_id, u8 cv,
+					  void *phl_adapter, void *drv_adapter,
+					  struct mac_ax_pltfm_cb *pltfm_cb);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup System
+ * @{
+ */
+
+/**
+ * @brief get_mac_ax_adapter
+ *
+ * @param intf
+ * @param chip_id
+ * @param cv
+ * @param *drv_adapter
+ * @param *pltfm_cb
+ * @return Please Place Description here.
+ * @retval  mac_ax_adapter
+ */
+#else
+struct mac_ax_adapter *get_mac_ax_adapter(enum mac_ax_intf intf,
+					  u8 chip_id, u8 cv,
+					  void *drv_adapter,
+					  struct mac_ax_pltfm_cb *pltfm_cb);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup System
+ * @{
+ */
+
+/**
+ * @brief cmac_func_en
+ *
+ * @param *adapter
+ * @param band
+ * @param en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+#endif
+u32 cmac_func_en(struct mac_ax_adapter *adapter, u8 band, u8 en);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup System
+ * @{
+ */
+
+/**
+ * @brief mac_sys_init
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_sys_init(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup System
+ * @{
+ */
+
+/**
+ * @brief mac_hal_init
+ *
+ * @param *adapter
+ * @param *trx_info
+ * @param *fwdl_info
+ * @param *intf_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hal_init(struct mac_ax_adapter *adapter,
+		 struct mac_ax_trx_info *trx_info,
+		 struct mac_ax_fwdl_info *fwdl_info,
+		 struct mac_ax_intf_info *intf_info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup System
+ * @{
+ */
+
+/**
+ * @brief mac_hal_fast_init
+ *
+ * @param *adapter
+ * @param *trx_info
+ * @param *fwdl_info
+ * @param *intf_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hal_fast_init(struct mac_ax_adapter *adapter,
+		      struct mac_ax_trx_info *trx_info,
+		      struct mac_ax_fwdl_info *fwdl_info,
+		      struct mac_ax_intf_info *intf_info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup System
+ * @{
+ */
+
+/**
+ * @brief mac_hal_fast_deinit
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hal_fast_deinit(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup System
+ * @{
+ */
+
+/**
+ * @brief mac_hal_deinit
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_hal_deinit(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup System
+ * @{
+ */
+
+/**
+ * @brief mac_ax_init_state
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_ax_init_state(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+u32 mix_info_init(struct mac_ax_adapter *adapter);
+u32 mix_info_exit(struct mac_ax_adapter *adapter);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/la_mode.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/la_mode.c
new file mode 100644
index 000000000000..8756e73a068e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/la_mode.c
@@ -0,0 +1,188 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "la_mode.h"
+
+u32 mac_lamode_cfg(struct mac_ax_adapter *adapter,
+		   struct mac_ax_la_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = MAC_REG_R32(R_AX_DMAC_FUNC_EN);
+	val32 |= B_AX_BBRPT_EN;
+	MAC_REG_W32(R_AX_DMAC_FUNC_EN, val32);
+
+	val32 = MAC_REG_R32(R_AX_DMAC_CLK_EN);
+	val32 |= B_AX_BBRPT_CLK_EN;
+	MAC_REG_W32(R_AX_DMAC_CLK_EN, val32);
+
+	val32 = MAC_REG_R32(R_AX_LA_CFG);
+	val32 &= ~BITS_AX_LA_CFG;
+	val32 |= ((cfg->la_func_en ? B_AX_LA_FEN : 0) |
+		  (cfg->la_restart_en ? B_AX_LA_RESTART_EN : 0) |
+		  (cfg->la_timeout_en ? B_AX_LA_TO_EN : 0) |
+		  SET_WORD(cfg->la_timeout_val, B_AX_LA_TO_VAL) |
+		  SET_WORD(cfg->la_tgr_tu_sel, B_AX_LA_TRIG_TU_SEL) |
+		  SET_WORD(cfg->la_tgr_time_val, B_AX_LA_TRIG_TIME_VAL));
+	MAC_REG_W32(R_AX_LA_CFG, val32);
+
+	if (cfg->la_data_loss_imr)
+		MAC_REG_W8(R_AX_LA_ERRFLAG, BIT0);
+
+	return MACSUCCESS;
+}
+
+u32 mac_lamode_buf_cfg(struct mac_ax_adapter *adapter,
+		       struct mac_ax_la_buf_param *param)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	u32 val32;
+
+	val32 = MAC_REG_R32(R_AX_LA_CFG);
+	val32 = SET_CLR_WORD(val32, param->la_buf_sel, B_AX_LA_BUF_SEL);
+	if (param->la_buf_sel == LA_BUF_SEL_256K) { /* la buf 256K */
+		val32 = SET_CLR_WORD(val32, LA_SIZE_256K_BUF_BNDY, B_AX_LA_BUF_BNDY);
+		param->start_addr = LA_SIZE_256K_BUF_BNDY * DLE_BLOCK_SIZE;
+		param->end_addr = DLE_BUF_BNDY_8852A;
+	} else if (param->la_buf_sel == LA_BUF_SEL_192K) { /* la buf 192K */
+		val32 = SET_CLR_WORD(val32, LA_SIZE_192K_BUF_BNDY, B_AX_LA_BUF_BNDY);
+		param->start_addr = LA_SIZE_192K_BUF_BNDY * DLE_BLOCK_SIZE;
+		param->end_addr = DLE_BUF_BNDY_8852A;
+	} else if (param->la_buf_sel == LA_BUF_SEL_128K) { /* la buf 128K */
+		switch (hw_info->chip_id) {
+#if MAC_AX_8852A_SUPPORT /*temp setting, will move to per IC files later*/
+		case MAC_AX_CHIP_ID_8852A:
+			PLTFM_MSG_ERR("[ERR]8852A Non support buf sel %d\n",
+				      param->la_buf_sel);
+			break;
+#endif
+#ifdef MAC_AX_8852B_SUPPORT /*temp setting, will move to per IC files later*/
+		case MAC_AX_CHIP_ID_8852B:
+			val32 = SET_CLR_WORD(val32, LA_SIZE_128K_BUF_BNDY_8852B,
+					     B_AX_LA_BUF_BNDY);
+			param->start_addr = LA_SIZE_128K_BUF_BNDY_8852B *
+					    DLE_BLOCK_SIZE;
+			param->end_addr = DLE_BUF_BNDY_8852B;
+			break;
+#endif
+#ifdef MAC_AX_8852C_SUPPORT
+		case MAC_AX_CHIP_ID_8852C:
+			val32 = SET_CLR_WORD(val32, LA_SIZE_256K_BUF_BNDY,
+					     B_AX_LA_BUF_BNDY);
+			param->start_addr = LA_SIZE_256K_BUF_BNDY * DLE_BLOCK_SIZE;
+			param->end_addr = LA_BUF_END_8852C_128K;
+			break;
+#endif
+#ifdef MAC_AX_8192XB_SUPPORT
+		case MAC_AX_CHIP_ID_8192XB:
+			val32 = SET_CLR_WORD(val32, LA_SIZE_256K_BUF_BNDY,
+					     B_AX_LA_BUF_BNDY);
+			param->start_addr = LA_SIZE_256K_BUF_BNDY * DLE_BLOCK_SIZE;
+			param->end_addr = LA_BUF_END_8192XB_128K;
+			break;
+#endif
+#ifdef MAC_AX_8851B_SUPPORT /*temp setting, will move to per IC files later*/
+		case MAC_AX_CHIP_ID_8851B:
+			val32 = SET_CLR_WORD(val32, LA_SIZE_128K_BUF_BNDY_8851B,
+					     B_AX_LA_BUF_BNDY);
+			param->start_addr = LA_SIZE_128K_BUF_BNDY_8851B *
+					    DLE_BLOCK_SIZE;
+			param->end_addr = DLE_BUF_BNDY_8851B;
+			break;
+#endif
+#ifdef MAC_AX_8851E_SUPPORT
+		case MAC_AX_CHIP_ID_8851E:
+			val32 = SET_CLR_WORD(val32, LA_SIZE_256K_BUF_BNDY,
+					     B_AX_LA_BUF_BNDY);
+			param->start_addr = LA_SIZE_256K_BUF_BNDY * DLE_BLOCK_SIZE;
+			param->end_addr = LA_BUF_END_8851E_128K;
+			break;
+#endif
+#ifdef MAC_AX_8852D_SUPPORT
+		case MAC_AX_CHIP_ID_8852D:
+			val32 = SET_CLR_WORD(val32, LA_SIZE_256K_BUF_BNDY,
+					     B_AX_LA_BUF_BNDY);
+			param->start_addr = LA_SIZE_256K_BUF_BNDY * DLE_BLOCK_SIZE;
+			param->end_addr = LA_BUF_END_8852D_128K;
+			break;
+#endif
+		default:
+			PLTFM_MSG_ERR("[ERR]Non support 128K buffer sel\n");
+			break;
+		}
+	} else if (param->la_buf_sel == LA_BUF_SEL_64K) { /* la buf 64K */
+		val32 |= SET_WORD(LA_SIZE_128K_BUF_BNDY_8852B,
+				  B_AX_LA_BUF_BNDY);
+		param->start_addr = LA_SIZE_128K_BUF_BNDY_8852B *
+				    DLE_BLOCK_SIZE;
+		param->end_addr = DLE_BUF_BNDY_8852B;
+	} else {
+		PLTFM_MSG_ERR("[ERR]Non support buf sel %d\n",
+			      param->la_buf_sel);
+	}
+
+	MAC_REG_W32(R_AX_LA_CFG, val32);
+
+	return MACSUCCESS;
+}
+
+u32 mac_lamode_trigger(struct mac_ax_adapter *adapter, u8 tgr)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 count = 3000;
+	u8 val8;
+
+	if (tgr) {
+		val8 = MAC_REG_R8(R_AX_LA_CFG);
+		MAC_REG_W8(R_AX_LA_CFG, val8 | B_AX_LA_TRIG_START);
+	}
+
+	val8 = MAC_REG_R8(R_AX_LA_CFG);
+	while (--count) {
+		if (!(val8 & B_AX_LA_TRIG_START))
+			break;
+		PLTFM_DELAY_MS(1);
+	}
+	if (!count)
+		return MACPOLLTO;
+
+	return MACSUCCESS;
+}
+
+struct mac_ax_la_status mac_get_lamode_st(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	struct mac_ax_la_status info;
+
+	info.la_buf_wptr = 0;
+	info.la_buf_rndup_ind = 0;
+	info.la_sw_fsmst = 0;
+	info.la_data_loss = 0;
+
+	val32 = MAC_REG_R32(R_AX_LA_STATUS);
+	info.la_sw_fsmst = (val32 >> B_AX_LA_SW_FSMST_SH) &
+			    B_AX_LA_SW_FSMST_MSK;
+	info.la_buf_wptr = (val32 >> B_AX_LA_BUF_WPTR_SH) &
+			    B_AX_LA_BUF_WPTR_MSK;
+	info.la_buf_rndup_ind = (val32 & B_AX_LA_BUF_RNDUP) ? 1 : 0;
+
+	val32 = MAC_REG_R32(R_AX_LA_ERRFLAG);
+	info.la_data_loss = (val32 & B_AX_LA_ISR_DATA_LOSS_ERR) ? 1 : 0;
+
+	return info;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/la_mode.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/la_mode.h
new file mode 100644
index 000000000000..7c918933a9fc
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/la_mode.h
@@ -0,0 +1,140 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_LA_MODE_H_
+#define _MAC_AX_LA_MODE_H_
+
+#include "../type.h"
+#include "../mac_ax.h"
+
+/*--------------------Define ----------------------------------------*/
+#define BITS_AX_LA_BUF_CFG 0xFFF00
+#define BITS_AX_LA_CFG 0xFFF000FF
+#define LA_SIZE_192K_BUF_BNDY 0x20
+#define LA_SIZE_256K_BUF_BNDY 0x18
+
+#define LA_BUF_SEL_256K 0x3
+#define LA_BUF_SEL_192K 0x2
+#define LA_BUF_SEL_128K 0x1
+#define LA_BUF_SEL_64K 0x0
+
+#define DLE_BLOCK_SIZE 0x2000
+#define DLE_BUF_BNDY_8852A 0x70000
+#define DLE_BUF_BNDY_8852B 0x20000
+#define DLE_BUF_BNDY_8851B 0x20000
+#define LA_BUF_END_8852C_256K 0x70000
+#define LA_BUF_END_8852C_128K 0x50000
+#define LA_BUF_END_8192XB_256K 0x70000
+#define LA_BUF_END_8192XB_128K 0x50000
+#define LA_BUF_END_8851E_256K 0x70000
+#define LA_BUF_END_8851E_128K 0x50000
+#define LA_BUF_END_8852D_256K 0x70000
+#define LA_BUF_END_8852D_128K 0x50000
+#define LA_SIZE_128K_BUF_BNDY_8852B 0x8
+#define LA_SIZE_128K_BUF_BNDY_8851B 0x8
+
+/*--------------------Define Enum------------------------------------*/
+/*--------------------Define MACRO----------------------------------*/
+/*--------------------Define Struct-----------------------------------*/
+/*--------------------Export global variable----------------------------*/
+/*--------------------Function declaration-----------------------------*/
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BB_Related
+ * @{
+ */
+/**
+ * @brief mac_lamode_cfg
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_lamode_cfg(struct mac_ax_adapter *adapter,
+		   struct mac_ax_la_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BB_Related
+ * @{
+ */
+
+/**
+ * @brief mac_lamode_trigger
+ *
+ * @param *adapter
+ * @param tgr
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_lamode_trigger(struct mac_ax_adapter *adapter, u8 tgr);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BB_Related
+ * @{
+ */
+
+/**
+ * @brief mac_lamode_buf_cfg
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_lamode_buf_cfg(struct mac_ax_adapter *adapter,
+		       struct mac_ax_la_buf_param *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BB_Related
+ * @{
+ */
+
+/**
+ * @brief mac_get_lamode_st
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval  mac_ax_la_status
+ */
+struct mac_ax_la_status mac_get_lamode_st
+			(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_pcie_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_pcie_8852b.c
new file mode 100644
index 000000000000..2746a8ed1bf7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_pcie_8852b.c
@@ -0,0 +1,1867 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "_pcie_8852b.h"
+
+#if MAC_AX_8852B_SUPPORT
+
+#if MAC_AX_PCIE_SUPPORT
+
+static struct mac_ax_intf_info intf_info_def_8852b = {
+	MAC_AX_BD_TRUNC,
+	MAC_AX_BD_TRUNC,
+	MAC_AX_RXBD_PKT,
+	MAC_AX_TAG_MULTI,
+	MAC_AX_TX_BURST_2048B,
+	MAC_AX_RX_BURST_128B,
+	MAC_AX_WD_DMA_INTVL_256NS,
+	MAC_AX_WD_DMA_INTVL_256NS,
+	MAC_AX_TAG_NUM_8,
+	0,
+	NULL,
+	NULL,
+	0,
+	NULL,
+	MAC_AX_PCIE_ENABLE,
+	MAC_AX_LBC_TMR_2MS,
+	MAC_AX_PCIE_DISABLE,
+	MAC_AX_PCIE_DISABLE,
+	MAC_AX_IO_RCY_ANA_TMR_6MS
+};
+
+static struct mac_ax_pcie_ltr_param pcie_ltr_param_def_8852b = {
+	0,
+	0,
+	MAC_AX_PCIE_ENABLE,
+	MAC_AX_PCIE_ENABLE,
+	MAC_AX_PCIE_LTR_SPC_500US,
+	MAC_AX_PCIE_LTR_IDLE_TIMER_3_2MS,
+	{MAC_AX_PCIE_ENABLE, 0x28},
+	{MAC_AX_PCIE_ENABLE, 0x28},
+	{MAC_AX_PCIE_ENABLE, 0x90039003},
+	{MAC_AX_PCIE_ENABLE, 0x880b880b}
+};
+
+static struct mac_ax_pcie_cfgspc_param pcie_cfgspc_param_def_8852b = {
+	0,
+	0,
+	MAC_AX_PCIE_DISABLE,
+	MAC_AX_PCIE_ENABLE,
+	MAC_AX_PCIE_ENABLE,
+	MAC_AX_PCIE_ENABLE,
+	MAC_AX_PCIE_ENABLE,
+	MAC_AX_PCIE_CLKDLY_500US,
+	MAC_AX_PCIE_L0SDLY_4US,
+	MAC_AX_PCIE_L1DLY_16US
+};
+
+struct txbd_ram mac_bdram_tbl_8852b[] = {
+		/* ACH0_QUEUE_IDX_8852BE */ {0, 5, 2},
+		/* ACH1_QUEUE_IDX_8852BE */ {5, 5, 2},
+		/* ACH2_QUEUE_IDX_8852BE */ {10, 5, 2},
+		/* ACH3_QUEUE_IDX_8852BE */ {15, 5, 2},
+		/* MGQ_B0_QUEUE_IDX_8852BE */ {20, 4, 1},
+		/* HIQ_B0_QUEUE_IDX_8852BE */ {24, 4, 1},
+		/* FWCMD_QUEUE_IDX_8852BE */ {28, 4, 1}
+};
+
+static u32 chk_stus_l1ss(struct mac_ax_adapter *adapter, u8 *val)
+{
+	u16 cap_val;
+	u8 stus_val;
+	u8 sup_val;
+	u32 ret;
+	u8 val8_1, val8_2;
+
+	ret = dbi_r8_pcie(adapter, PCIE_L1SS_CAP + 1, &val8_1);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = dbi_r8_pcie(adapter, PCIE_L1SS_CAP, &val8_2);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	cap_val = (u16)((val8_1 << 8) | val8_2);
+
+	ret = dbi_r8_pcie(adapter, PCIE_L1SS_SUP, &sup_val);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = dbi_r8_pcie(adapter, PCIE_L1SS_STS, &stus_val);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (cap_val == PCIE_L1SS_ID &&
+	    (sup_val & PCIE_BIT_L1SSSUP) &&
+	    (sup_val & PCIE_L1SS_MASK) != 0 &&
+	    (stus_val & PCIE_L1SS_MASK) != 0)
+		*val = 1;
+	else
+		*val = 0;
+
+	return ret;
+}
+
+static u32 update_clkdly(struct mac_ax_adapter *adapter, u8 *val,
+			 enum mac_ax_pcie_clkdly ctrl,
+			 enum mac_ax_pcie_clkdly def_ctrl)
+{
+	u8 tmp;
+
+	if (ctrl == MAC_AX_PCIE_CLKDLY_IGNORE ||
+	    def_ctrl == MAC_AX_PCIE_CLKDLY_IGNORE)
+		return MACSUCCESS;
+
+	tmp = (u8)((ctrl == MAC_AX_PCIE_CLKDLY_DEF) ? def_ctrl : ctrl);
+	switch (tmp) {
+	case MAC_AX_PCIE_CLKDLY_0:
+		*val = PCIE_CLKDLY_HW_0;
+		break;
+
+	case MAC_AX_PCIE_CLKDLY_30US:
+		*val = PCIE_CLKDLY_HW_30US;
+		break;
+
+	case MAC_AX_PCIE_CLKDLY_50US:
+		*val = PCIE_CLKDLY_HW_50US;
+		break;
+
+	case MAC_AX_PCIE_CLKDLY_100US:
+		*val = PCIE_CLKDLY_HW_100US;
+		break;
+
+	case MAC_AX_PCIE_CLKDLY_150US:
+		*val = PCIE_CLKDLY_HW_150US;
+		break;
+
+	case MAC_AX_PCIE_CLKDLY_200US:
+		*val = PCIE_CLKDLY_HW_200US;
+		break;
+	case MAC_AX_PCIE_CLKDLY_300US:
+		*val = PCIE_CLKDLY_HW_300US;
+		break;
+	case MAC_AX_PCIE_CLKDLY_400US:
+		*val = PCIE_CLKDLY_HW_400US;
+		break;
+	case MAC_AX_PCIE_CLKDLY_500US:
+		*val = PCIE_CLKDLY_HW_500US;
+		break;
+	case MAC_AX_PCIE_CLKDLY_1MS:
+		*val = PCIE_CLKDLY_HW_1MS;
+		break;
+	case MAC_AX_PCIE_CLKDLY_3MS:
+		*val = PCIE_CLKDLY_HW_3MS;
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR]CLKDLY wt val illegal!\n");
+		return MACSTCAL;
+	}
+	return MACSUCCESS;
+}
+
+static u32 update_aspmdly(struct mac_ax_adapter *adapter, u8 *val,
+			  struct mac_ax_pcie_cfgspc_param *param,
+			  struct mac_ax_pcie_cfgspc_param *param_def)
+{
+	u8 l1mask = PCIE_ASPMDLY_MASK << SHFT_L1DLY;
+	u8 l0smask = PCIE_ASPMDLY_MASK << SHFT_L0SDLY;
+	u8 l1updval = param->l1dly_ctrl;
+	u8 l0supdval = param->l0sdly_ctrl;
+	u8 l1defval = param_def->l1dly_ctrl;
+	u8 l0sdefval = param_def->l0sdly_ctrl;
+	u8 tmp;
+	u8 hwval;
+
+	if (l1updval != MAC_AX_PCIE_L1DLY_IGNORE) {
+		tmp = (l1updval == MAC_AX_PCIE_L1DLY_DEF) ? l1defval : l1updval;
+		switch (tmp) {
+		case MAC_AX_PCIE_L1DLY_16US:
+			hwval = PCIE_L1DLY_HW_16US;
+			break;
+
+		case MAC_AX_PCIE_L1DLY_32US:
+			hwval = PCIE_L1DLY_HW_32US;
+			break;
+
+		case MAC_AX_PCIE_L1DLY_64US:
+			hwval = PCIE_L1DLY_HW_64US;
+			break;
+
+		case MAC_AX_PCIE_L1DLY_INFI:
+			hwval = PCIE_L1DLY_HW_INFI;
+			break;
+
+		default:
+			PLTFM_MSG_ERR("[ERR]L1DLY wt val illegal!\n");
+			return MACSTCAL;
+		}
+
+		tmp = (hwval << SHFT_L1DLY) & l1mask;
+		*val = (*val & ~(l1mask)) | tmp;
+	}
+
+	if (l0supdval != MAC_AX_PCIE_L0SDLY_IGNORE) {
+		tmp = (l0supdval == MAC_AX_PCIE_L0SDLY_DEF) ?
+		       l0sdefval : l0supdval;
+		switch (tmp) {
+		case MAC_AX_PCIE_L0SDLY_1US:
+			hwval = PCIE_L0SDLY_HW_1US;
+			break;
+
+		case MAC_AX_PCIE_L0SDLY_2US:
+			hwval = PCIE_L0SDLY_HW_2US;
+			break;
+
+		case MAC_AX_PCIE_L0SDLY_3US:
+			hwval = PCIE_L0SDLY_HW_3US;
+			break;
+
+		case MAC_AX_PCIE_L0SDLY_4US:
+			hwval = PCIE_L0SDLY_HW_4US;
+			break;
+
+		case MAC_AX_PCIE_L0SDLY_5US:
+			hwval = PCIE_L0SDLY_HW_5US;
+			break;
+
+		case MAC_AX_PCIE_L0SDLY_6US:
+			hwval = PCIE_L0SDLY_HW_6US;
+			break;
+
+		case MAC_AX_PCIE_L0SDLY_7US:
+			hwval = PCIE_L0SDLY_HW_7US;
+			break;
+
+		default:
+			PLTFM_MSG_ERR("[ERR]L0SDLY wt val illegal!\n");
+			return MACSTCAL;
+		}
+		tmp = (hwval << SHFT_L0SDLY) & l0smask;
+		*val = (*val & ~(l0smask)) | tmp;
+	}
+
+	return MACSUCCESS;
+}
+
+struct mac_ax_intf_info *
+get_pcie_info_def_8852b(struct mac_ax_adapter *adapter)
+{
+	return &intf_info_def_8852b;
+}
+
+struct txbd_ram *
+get_bdram_tbl_pcie_8852b(struct mac_ax_adapter *adapter)
+{
+	return mac_bdram_tbl_8852b;
+}
+
+u32 mio_w32_pcie_8852b(struct mac_ax_adapter *adapter, u16 addr, u32 value)
+{
+	return MACNOTSUP;
+}
+
+u32 mio_r32_pcie_8852b(struct mac_ax_adapter *adapter, u16 addr, u32 *val)
+{
+	return MACNOTSUP;
+}
+
+u32 get_txbd_reg_pcie_8852b(struct mac_ax_adapter *adapter, u8 dma_ch, u32 *reg,
+			    enum pcie_bd_ctrl_type type)
+{
+	*reg = MAC_AX_R32_FF;
+
+	switch (dma_ch) {
+	case MAC_AX_DMA_ACH0:
+		switch (type) {
+		case PCIE_BD_CTRL_DESC_L:
+			*reg = R_AX_ACH0_TXBD_DESA_L;
+			break;
+		case PCIE_BD_CTRL_DESC_H:
+			*reg = R_AX_ACH0_TXBD_DESA_H;
+			break;
+		case PCIE_BD_CTRL_NUM:
+			*reg = R_AX_ACH0_TXBD_NUM;
+			break;
+		case PCIE_BD_CTRL_IDX:
+			*reg = R_AX_ACH0_TXBD_IDX;
+			break;
+		case PCIE_BD_CTRL_BDRAM:
+			*reg = R_AX_ACH0_BDRAM_CTRL_V2;
+			break;
+		default:
+			PLTFM_MSG_ERR("TXBD reg type%d invalid\n", type);
+			return MACFUNCINPUT;
+		}
+		break;
+	case MAC_AX_DMA_ACH1:
+		switch (type) {
+		case PCIE_BD_CTRL_DESC_L:
+			*reg = R_AX_ACH1_TXBD_DESA_L;
+			break;
+		case PCIE_BD_CTRL_DESC_H:
+			*reg = R_AX_ACH1_TXBD_DESA_H;
+			break;
+		case PCIE_BD_CTRL_NUM:
+			*reg = R_AX_ACH1_TXBD_NUM;
+			break;
+		case PCIE_BD_CTRL_IDX:
+			*reg = R_AX_ACH1_TXBD_IDX;
+			break;
+		case PCIE_BD_CTRL_BDRAM:
+			*reg = R_AX_ACH1_BDRAM_CTRL_V2;
+			break;
+		default:
+			PLTFM_MSG_ERR("TXBD reg type%d invalid\n", type);
+			return MACFUNCINPUT;
+		}
+		break;
+	case MAC_AX_DMA_ACH2:
+		switch (type) {
+		case PCIE_BD_CTRL_DESC_L:
+			*reg = R_AX_ACH2_TXBD_DESA_L;
+			break;
+		case PCIE_BD_CTRL_DESC_H:
+			*reg = R_AX_ACH2_TXBD_DESA_H;
+			break;
+		case PCIE_BD_CTRL_NUM:
+			*reg = R_AX_ACH2_TXBD_NUM;
+			break;
+		case PCIE_BD_CTRL_IDX:
+			*reg = R_AX_ACH2_TXBD_IDX;
+			break;
+		case PCIE_BD_CTRL_BDRAM:
+			*reg = R_AX_ACH2_BDRAM_CTRL_V2;
+			break;
+		default:
+			PLTFM_MSG_ERR("TXBD reg type%d invalid\n", type);
+			return MACFUNCINPUT;
+		}
+		break;
+	case MAC_AX_DMA_ACH3:
+		switch (type) {
+		case PCIE_BD_CTRL_DESC_L:
+			*reg = R_AX_ACH3_TXBD_DESA_L;
+			break;
+		case PCIE_BD_CTRL_DESC_H:
+			*reg = R_AX_ACH3_TXBD_DESA_H;
+			break;
+		case PCIE_BD_CTRL_NUM:
+			*reg = R_AX_ACH3_TXBD_NUM;
+			break;
+		case PCIE_BD_CTRL_IDX:
+			*reg = R_AX_ACH3_TXBD_IDX;
+			break;
+		case PCIE_BD_CTRL_BDRAM:
+			*reg = R_AX_ACH3_BDRAM_CTRL_V2;
+			break;
+		default:
+			PLTFM_MSG_ERR("TXBD reg type%d invalid\n", type);
+			return MACFUNCINPUT;
+		}
+		break;
+	case MAC_AX_DMA_B0MG:
+		switch (type) {
+		case PCIE_BD_CTRL_DESC_L:
+			*reg = R_AX_CH8_TXBD_DESA_L;
+			break;
+		case PCIE_BD_CTRL_DESC_H:
+			*reg = R_AX_CH8_TXBD_DESA_H;
+			break;
+		case PCIE_BD_CTRL_NUM:
+			*reg = R_AX_CH8_TXBD_NUM;
+			break;
+		case PCIE_BD_CTRL_IDX:
+			*reg = R_AX_CH8_TXBD_IDX;
+			break;
+		case PCIE_BD_CTRL_BDRAM:
+			*reg = R_AX_CH8_BDRAM_CTRL_V2;
+			break;
+		default:
+			PLTFM_MSG_ERR("TXBD reg type%d invalid\n", type);
+			return MACFUNCINPUT;
+		}
+		break;
+	case MAC_AX_DMA_B0HI:
+		switch (type) {
+		case PCIE_BD_CTRL_DESC_L:
+			*reg = R_AX_CH9_TXBD_DESA_L;
+			break;
+		case PCIE_BD_CTRL_DESC_H:
+			*reg = R_AX_CH9_TXBD_DESA_H;
+			break;
+		case PCIE_BD_CTRL_NUM:
+			*reg = R_AX_CH9_TXBD_NUM;
+			break;
+		case PCIE_BD_CTRL_IDX:
+			*reg = R_AX_CH9_TXBD_IDX;
+			break;
+		case PCIE_BD_CTRL_BDRAM:
+			*reg = R_AX_CH9_BDRAM_CTRL_V2;
+			break;
+		default:
+			PLTFM_MSG_ERR("TXBD reg type%d invalid\n", type);
+			return MACFUNCINPUT;
+		}
+		break;
+	case MAC_AX_DMA_H2C:
+		switch (type) {
+		case PCIE_BD_CTRL_DESC_L:
+			*reg = R_AX_CH12_TXBD_DESA_L;
+			break;
+		case PCIE_BD_CTRL_DESC_H:
+			*reg = R_AX_CH12_TXBD_DESA_H;
+			break;
+		case PCIE_BD_CTRL_NUM:
+			*reg = R_AX_CH12_TXBD_NUM;
+			break;
+		case PCIE_BD_CTRL_IDX:
+			*reg = R_AX_CH12_TXBD_IDX;
+			break;
+		case PCIE_BD_CTRL_BDRAM:
+			*reg = R_AX_CH12_BDRAM_CTRL_V2;
+			break;
+		default:
+			PLTFM_MSG_ERR("TXBD reg type%d invalid\n", type);
+			return MACFUNCINPUT;
+		}
+		break;
+	case MAC_AX_DMA_ACH4:
+	case MAC_AX_DMA_ACH5:
+	case MAC_AX_DMA_ACH6:
+	case MAC_AX_DMA_ACH7:
+	case MAC_AX_DMA_B1MG:
+	case MAC_AX_DMA_B1HI:
+		return MACNOTSUP;
+	default:
+		PLTFM_MSG_ERR("[ERR] TXBD num CH%d invalid\n", dma_ch);
+		return MACFUNCINPUT;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 set_txbd_reg_pcie_8852b(struct mac_ax_adapter *adapter, u8 dma_ch,
+			    enum pcie_bd_ctrl_type type, u32 val0, u32 val1, u32 val2)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret, reg, val32;
+	u16 val16;
+
+	ret = p_ops->get_txbd_reg_pcie(adapter, dma_ch, &reg, type);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("get txbd%d reg type%d %d\n", dma_ch, type, ret);
+		return ret;
+	}
+
+	switch (type) {
+	case PCIE_BD_CTRL_DESC_L:
+	case PCIE_BD_CTRL_DESC_H:
+		MAC_REG_W32(reg, val0);
+		break;
+	case PCIE_BD_CTRL_NUM:
+		val16 = MAC_REG_R16(reg);
+		val16 = SET_CLR_WORD(val16, val0, B_AX_ACH0_DESC_NUM);
+		MAC_REG_W16(reg, val16);
+		break;
+	case PCIE_BD_CTRL_IDX:
+		val16 = MAC_REG_R16(reg);
+		val16 = SET_CLR_WORD(val16, val0, B_AX_ACH0_HOST_IDX);
+		MAC_REG_W16(reg, val16);
+		break;
+	case PCIE_BD_CTRL_BDRAM:
+		val32 = MAC_REG_R32(reg);
+		val32 = SET_CLR_WORD(val32, val0, B_AX_ACH0_BDRAM_SIDX_V2);
+		val32 = SET_CLR_WORD(val32, val1, B_AX_ACH0_BDRAM_MAX_V2);
+		val32 = SET_CLR_WORD(val32, val2, B_AX_ACH0_BDRAM_MIN_V2);
+		MAC_REG_W32(reg, val32);
+		break;
+	default:
+		PLTFM_MSG_ERR("TXBD reg type%d invalid\n", type);
+		return MACFUNCINPUT;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 get_rxbd_reg_pcie_8852b(struct mac_ax_adapter *adapter, u8 dma_ch, u32 *reg,
+			    enum pcie_bd_ctrl_type type)
+{
+	*reg = MAC_AX_R32_FF;
+
+	switch (dma_ch) {
+	case MAC_AX_RX_CH_RXQ:
+		switch (type) {
+		case PCIE_BD_CTRL_DESC_L:
+			*reg = R_AX_RXQ_RXBD_DESA_L;
+			break;
+		case PCIE_BD_CTRL_DESC_H:
+			*reg = R_AX_RXQ_RXBD_DESA_H;
+			break;
+		case PCIE_BD_CTRL_NUM:
+			*reg = R_AX_RXQ_RXBD_NUM;
+			break;
+		case PCIE_BD_CTRL_IDX:
+			*reg = R_AX_RXQ_RXBD_IDX;
+			break;
+		case PCIE_BD_CTRL_BDRAM:
+		default:
+			PLTFM_MSG_ERR("RXBD reg type%d invalid\n", type);
+			return MACFUNCINPUT;
+		}
+		break;
+	case MAC_AX_RX_CH_RPQ:
+		switch (type) {
+		case PCIE_BD_CTRL_DESC_L:
+			*reg = R_AX_RPQ_RXBD_DESA_L;
+			break;
+		case PCIE_BD_CTRL_DESC_H:
+			*reg = R_AX_RPQ_RXBD_DESA_H;
+			break;
+		case PCIE_BD_CTRL_NUM:
+			*reg = R_AX_RPQ_RXBD_NUM;
+			break;
+		case PCIE_BD_CTRL_IDX:
+			*reg = R_AX_RPQ_RXBD_IDX;
+			break;
+		case PCIE_BD_CTRL_BDRAM:
+		default:
+			PLTFM_MSG_ERR("RXBD reg type%d invalid\n", type);
+			return MACFUNCINPUT;
+		}
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR] RXBD CH%d invalid\n", dma_ch);
+		return MACFUNCINPUT;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 set_rxbd_reg_pcie_8852b(struct mac_ax_adapter *adapter, u8 dma_ch,
+			    enum pcie_bd_ctrl_type type, u32 val0, u32 val1, u32 val2)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret, reg;
+	u16 val16;
+
+	ret = p_ops->get_rxbd_reg_pcie(adapter, dma_ch, &reg, type);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("get rxbd%d reg type%d %d\n", dma_ch, type, ret);
+		return ret;
+	}
+
+	switch (type) {
+	case PCIE_BD_CTRL_DESC_L:
+	case PCIE_BD_CTRL_DESC_H:
+		MAC_REG_W32(reg, val0);
+		break;
+	case PCIE_BD_CTRL_NUM:
+		val16 = MAC_REG_R16(reg);
+		val16 = SET_CLR_WORD(val16, val0, B_AX_RXQ_DESC_NUM);
+		MAC_REG_W16(reg, val16);
+		break;
+	case PCIE_BD_CTRL_IDX:
+		val16 = MAC_REG_R16(reg);
+		val16 = SET_CLR_WORD(val16, val0, B_AX_RXQ_HOST_IDX);
+		MAC_REG_W16(reg, val16);
+		break;
+	case PCIE_BD_CTRL_BDRAM:
+	default:
+		PLTFM_MSG_ERR("RXBD reg type%d invalid\n", type);
+		return MACFUNCINPUT;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 pcie_cfgspc_write_8852b(struct mac_ax_adapter *adapter,
+			    struct mac_ax_pcie_cfgspc_param *param)
+{
+#ifdef RTW_WKARD_GET_PROCESSOR_ID
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+#endif
+	struct mac_ax_pcie_cfgspc_param *param_def = &pcie_cfgspc_param_def_8852b;
+	u8 l1_val, aspm_val, l1ss_val, clk_val, tmp8, val8;
+	u32 ret = MACSUCCESS;
+
+	ret = dbi_r8_pcie(adapter, PCIE_L1_CTRL, &l1_val);
+	if (ret != MACSUCCESS)
+		return ret;
+	ret = dbi_r8_pcie(adapter, PCIE_ASPM_CTRL, &aspm_val);
+	if (ret != MACSUCCESS)
+		return ret;
+	ret = dbi_r8_pcie(adapter, PCIE_L1SS_CTRL, &l1ss_val);
+	if (ret != MACSUCCESS)
+		return ret;
+	ret = dbi_r8_pcie(adapter, PCIE_CLK_CTRL, &clk_val);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (l1_val == 0xFF || aspm_val == 0xFF || l1ss_val == 0xFF ||
+	    clk_val == 0xFF) {
+		PLTFM_MSG_ERR("[ERR] PCIE CFG reg read 0xFF!\n");
+		return MACCMP;
+	}
+
+	ret = dbi_r8_pcie(adapter, PCIE_L1_STS, &tmp8);
+	if (ret != MACSUCCESS)
+		return ret;
+	if (((tmp8 & PCIE_BIT_STS_L0S) && param->l0s_ctrl ==
+	    MAC_AX_PCIE_DEFAULT) || (param->l0s_ctrl != MAC_AX_PCIE_DEFAULT &&
+	    param->l0s_ctrl != MAC_AX_PCIE_IGNORE))
+		update_pcie_func_u8(&aspm_val, PCIE_BIT_L0S,
+				    param->l0s_ctrl, param_def->l0s_ctrl);
+
+	if (((tmp8 & PCIE_BIT_STS_L1) && param->l1_ctrl ==
+	    MAC_AX_PCIE_DEFAULT) || (param->l1_ctrl != MAC_AX_PCIE_DEFAULT &&
+	    param->l1_ctrl != MAC_AX_PCIE_IGNORE))
+		update_pcie_func_u8(&l1_val, PCIE_BIT_L1,
+				    param->l1_ctrl, param_def->l1_ctrl);
+	update_pcie_func_u8(&l1_val, PCIE_BIT_WAKE,
+			    param->wake_ctrl, param_def->wake_ctrl);
+	update_pcie_func_u8(&l1_val, PCIE_BIT_CLK,
+			    param->crq_ctrl, param_def->crq_ctrl);
+	ret = chk_stus_l1ss(adapter, &val8);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] PCIE chk_stus_l1ss\n");
+		return ret;
+	}
+
+	if ((val8 && param->l1ss_ctrl == MAC_AX_PCIE_DEFAULT) ||
+	    (param->l1ss_ctrl != MAC_AX_PCIE_DEFAULT &&
+	     param->l1ss_ctrl != MAC_AX_PCIE_IGNORE))
+		update_pcie_func_u8(&l1ss_val, PCIE_BIT_L1SS,
+				    param->l1ss_ctrl, param_def->l1ss_ctrl);
+
+	ret = update_clkdly(adapter, &clk_val, param->clkdly_ctrl,
+			    param_def->clkdly_ctrl);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = update_aspmdly(adapter, &aspm_val, param, param_def);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (param->clkdly_ctrl != MAC_AX_PCIE_CLKDLY_IGNORE) {
+#ifdef RTW_WKARD_GET_PROCESSOR_ID
+		ret = p_ops->chk_proc_long_ldy_pcie(adapter, &tmp8);
+		if (ret != MACSUCCESS)
+			return ret;
+		if (tmp8 == PROC_SHORT_DLY)
+			clk_val = PCIE_CLKDLY_HW_50US;
+#endif
+		ret = dbi_w8_pcie(adapter, PCIE_CLK_CTRL, clk_val);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+
+	if (param->l0s_ctrl != MAC_AX_PCIE_IGNORE ||
+	    param->l1dly_ctrl != MAC_AX_PCIE_L1DLY_IGNORE ||
+	    param->l0sdly_ctrl != MAC_AX_PCIE_L0SDLY_IGNORE) {
+		ret = dbi_w8_pcie(adapter, PCIE_ASPM_CTRL, aspm_val);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+	if (param->l1_ctrl != MAC_AX_PCIE_IGNORE ||
+	    param->wake_ctrl != MAC_AX_PCIE_IGNORE ||
+	    param->crq_ctrl != MAC_AX_PCIE_IGNORE) {
+		ret = dbi_w8_pcie(adapter, PCIE_L1_CTRL, l1_val);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+	if (param->l1ss_ctrl != MAC_AX_PCIE_IGNORE) {
+		ret = dbi_w8_pcie(adapter, PCIE_L1SS_CTRL, l1ss_val);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+
+	return ret;
+}
+
+u32 pcie_cfgspc_read_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_pcie_cfgspc_param *param)
+{
+	u8 l1_val;
+	u8 aspm_val;
+	u8 l1ss_val;
+	u8 clk_val;
+	u8 l0smask;
+	u8 l1mask;
+	u32 ret;
+
+	ret = dbi_r8_pcie(adapter, PCIE_L1_CTRL, &l1_val);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = dbi_r8_pcie(adapter, PCIE_ASPM_CTRL, &aspm_val);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = dbi_r8_pcie(adapter, PCIE_L1SS_CTRL, &l1ss_val);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = dbi_r8_pcie(adapter, PCIE_CLK_CTRL, &clk_val);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (l1_val == 0xFF || aspm_val == 0xFF ||
+	    l1ss_val == 0xFF || clk_val == 0xFF) {
+		PLTFM_MSG_ERR("[ERR] (2nd)PCIE CFG reg read 0xFF!\n");
+		return MACCMP;
+	}
+
+	param->l0s_ctrl = GET_PCIE_FUNC_STUS(aspm_val, PCIE_BIT_L0S);
+	param->l1_ctrl = GET_PCIE_FUNC_STUS(l1_val, PCIE_BIT_L1);
+	param->l1ss_ctrl = GET_PCIE_FUNC_STUS(l1ss_val, PCIE_BIT_L1SS);
+	param->wake_ctrl = GET_PCIE_FUNC_STUS(l1_val, PCIE_BIT_WAKE);
+	param->crq_ctrl = GET_PCIE_FUNC_STUS(l1_val, PCIE_BIT_CLK);
+
+	switch (clk_val) {
+	case PCIE_CLKDLY_HW_0:
+		param->clkdly_ctrl = MAC_AX_PCIE_CLKDLY_0;
+		break;
+
+	case PCIE_CLKDLY_HW_30US:
+		param->clkdly_ctrl = MAC_AX_PCIE_CLKDLY_30US;
+		break;
+
+	case PCIE_CLKDLY_HW_50US:
+		param->clkdly_ctrl = MAC_AX_PCIE_CLKDLY_50US;
+		break;
+
+	case PCIE_CLKDLY_HW_100US:
+		param->clkdly_ctrl = MAC_AX_PCIE_CLKDLY_100US;
+		break;
+
+	case PCIE_CLKDLY_HW_150US:
+		param->clkdly_ctrl = MAC_AX_PCIE_CLKDLY_150US;
+		break;
+
+	case PCIE_CLKDLY_HW_200US:
+		param->clkdly_ctrl = MAC_AX_PCIE_CLKDLY_200US;
+		break;
+
+	default:
+		param->clkdly_ctrl = MAC_AX_PCIE_CLKDLY_R_ERR;
+		break;
+	}
+
+	l0smask = PCIE_ASPMDLY_MASK << SHFT_L0SDLY;
+	l1mask = PCIE_ASPMDLY_MASK << SHFT_L1DLY;
+
+	switch ((aspm_val & l0smask) >> SHFT_L0SDLY) {
+	case PCIE_L0SDLY_HW_1US:
+		param->l0sdly_ctrl = MAC_AX_PCIE_L0SDLY_1US;
+		break;
+
+	case PCIE_L0SDLY_HW_3US:
+		param->l0sdly_ctrl = MAC_AX_PCIE_L0SDLY_3US;
+		break;
+
+	case PCIE_L0SDLY_HW_5US:
+		param->l0sdly_ctrl = MAC_AX_PCIE_L0SDLY_5US;
+		break;
+
+	case PCIE_L0SDLY_HW_7US:
+		param->l0sdly_ctrl = MAC_AX_PCIE_L0SDLY_7US;
+		break;
+
+	default:
+		param->l0sdly_ctrl = MAC_AX_PCIE_L0SDLY_R_ERR;
+		break;
+	}
+
+	switch ((aspm_val & l1mask) >> SHFT_L1DLY) {
+	case PCIE_L1DLY_HW_16US:
+		param->l1dly_ctrl = MAC_AX_PCIE_L1DLY_16US;
+		break;
+
+	case PCIE_L1DLY_HW_32US:
+		param->l1dly_ctrl = MAC_AX_PCIE_L1DLY_32US;
+		break;
+
+	case PCIE_L1DLY_HW_64US:
+		param->l1dly_ctrl = MAC_AX_PCIE_L1DLY_64US;
+		break;
+
+	case PCIE_L1DLY_HW_INFI:
+		param->l1dly_ctrl = MAC_AX_PCIE_L1DLY_INFI;
+		break;
+
+	default:
+		param->l1dly_ctrl = MAC_AX_PCIE_L1DLY_R_ERR;
+		break;
+	}
+
+	return ret;
+}
+
+u32 pcie_ltr_write_8852b(struct mac_ax_adapter *adapter,
+			 struct mac_ax_pcie_ltr_param *param)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ltr_ctrl0, ltr_ctrl1, ltr_idle_ltcy, ltr_act_ltcy;
+	u32 status = MACSUCCESS;
+	struct mac_ax_pcie_ltr_param *param_def = &pcie_ltr_param_def_8852b;
+	u32 val32;
+	enum mac_ax_pcie_func_ctrl ctrl;
+
+	ltr_ctrl0 = MAC_REG_R32(R_AX_LTR_CTRL_0);
+	ltr_ctrl1 = MAC_REG_R32(R_AX_LTR_CTRL_1);
+	ltr_idle_ltcy = MAC_REG_R32(R_AX_LTR_IDLE_LATENCY);
+	ltr_act_ltcy = MAC_REG_R32(R_AX_LTR_ACTIVE_LATENCY);
+
+	if (ltr_ctrl0 == MAC_AX_R32_FF || ltr_ctrl0 == MAC_AX_R32_EA ||
+	    ltr_ctrl1 == MAC_AX_R32_FF || ltr_ctrl1 == MAC_AX_R32_EA ||
+	    ltr_idle_ltcy == MAC_AX_R32_FF || ltr_idle_ltcy == MAC_AX_R32_EA ||
+	    ltr_act_ltcy == MAC_AX_R32_FF || ltr_act_ltcy == MAC_AX_R32_EA) {
+		PLTFM_MSG_ERR("[ERR] LTR reg read nothing!\n");
+		return MACCMP;
+	}
+
+	if (!(param_def->ltr_ctrl == MAC_AX_PCIE_IGNORE ||
+	      param->ltr_ctrl == MAC_AX_PCIE_IGNORE ||
+	      param_def->ltr_ctrl == MAC_AX_PCIE_DEFAULT)) {
+		ctrl = param->ltr_ctrl == MAC_AX_PCIE_DEFAULT ?
+		       param_def->ltr_ctrl : param->ltr_ctrl;
+		ltr_ctrl0 = ctrl == MAC_AX_PCIE_ENABLE ?
+			    (ltr_ctrl0 | B_AX_LTR_EN) :
+			    (ltr_ctrl0 & ~B_AX_LTR_EN);
+	}
+
+	if (!(param_def->ltr_hw_ctrl == MAC_AX_PCIE_IGNORE ||
+	      param->ltr_hw_ctrl == MAC_AX_PCIE_IGNORE ||
+	      param_def->ltr_hw_ctrl == MAC_AX_PCIE_DEFAULT)) {
+		ctrl = param->ltr_hw_ctrl == MAC_AX_PCIE_DEFAULT ?
+		       param_def->ltr_hw_ctrl : param->ltr_hw_ctrl;
+		ltr_ctrl0 = ctrl == MAC_AX_PCIE_ENABLE ?
+			    (ltr_ctrl0 | B_AX_LTR_HW_EN | B_AX_LTR_WD_NOEMP_CHK) :
+			    (ltr_ctrl0 & ~(B_AX_LTR_HW_EN | B_AX_LTR_WD_NOEMP_CHK));
+	}
+
+	if (!(param_def->ltr_spc_ctrl == MAC_AX_PCIE_LTR_SPC_IGNORE ||
+	      param->ltr_spc_ctrl == MAC_AX_PCIE_LTR_SPC_IGNORE ||
+	      param_def->ltr_spc_ctrl == MAC_AX_PCIE_LTR_SPC_DEF)) {
+		val32 = param->ltr_spc_ctrl == MAC_AX_PCIE_LTR_SPC_DEF ?
+			param_def->ltr_spc_ctrl : param->ltr_spc_ctrl;
+		ltr_ctrl0 = SET_CLR_WORD(ltr_ctrl0, val32, B_AX_LTR_SPACE_IDX);
+	}
+
+	if (!(param_def->ltr_idle_timer_ctrl ==
+	      MAC_AX_PCIE_LTR_IDLE_TIMER_IGNORE ||
+	      param->ltr_idle_timer_ctrl ==
+	      MAC_AX_PCIE_LTR_IDLE_TIMER_IGNORE ||
+	      param_def->ltr_idle_timer_ctrl ==
+	      MAC_AX_PCIE_LTR_IDLE_TIMER_DEF)) {
+		val32 = param->ltr_idle_timer_ctrl ==
+			MAC_AX_PCIE_LTR_IDLE_TIMER_DEF ?
+			param_def->ltr_idle_timer_ctrl :
+			param->ltr_idle_timer_ctrl;
+		ltr_ctrl0 = SET_CLR_WORD(ltr_ctrl0, val32,
+					 B_AX_LTR_IDLE_TIMER_IDX);
+	}
+
+	if (!(param_def->ltr_rx0_th_ctrl.ctrl == MAC_AX_PCIE_IGNORE ||
+	      param->ltr_rx0_th_ctrl.ctrl == MAC_AX_PCIE_IGNORE ||
+	      param_def->ltr_rx0_th_ctrl.ctrl == MAC_AX_PCIE_DEFAULT)) {
+		val32 = param->ltr_rx0_th_ctrl.ctrl == MAC_AX_PCIE_DEFAULT ?
+			param_def->ltr_rx0_th_ctrl.val :
+			param->ltr_rx0_th_ctrl.val;
+		ltr_ctrl1 = SET_CLR_WORD(ltr_ctrl1, val32, B_AX_LTR_RX0_TH);
+	}
+
+	if (!(param_def->ltr_rx1_th_ctrl.ctrl == MAC_AX_PCIE_IGNORE ||
+	      param->ltr_rx1_th_ctrl.ctrl == MAC_AX_PCIE_IGNORE ||
+	      param_def->ltr_rx1_th_ctrl.ctrl == MAC_AX_PCIE_DEFAULT)) {
+		val32 = param->ltr_rx1_th_ctrl.ctrl == MAC_AX_PCIE_DEFAULT ?
+			param_def->ltr_rx1_th_ctrl.val :
+			param->ltr_rx1_th_ctrl.val;
+		ltr_ctrl1 = SET_CLR_WORD(ltr_ctrl1, val32, B_AX_LTR_RX1_TH);
+	}
+
+	if (!(param_def->ltr_idle_lat_ctrl.ctrl == MAC_AX_PCIE_IGNORE ||
+	      param->ltr_idle_lat_ctrl.ctrl == MAC_AX_PCIE_IGNORE ||
+	      param_def->ltr_idle_lat_ctrl.ctrl == MAC_AX_PCIE_DEFAULT)) {
+		val32 = param->ltr_idle_lat_ctrl.ctrl == MAC_AX_PCIE_DEFAULT ?
+			param_def->ltr_idle_lat_ctrl.val :
+			param->ltr_idle_lat_ctrl.val;
+		ltr_idle_ltcy =
+			SET_CLR_WORD(ltr_idle_ltcy, val32, B_AX_LTR_IDLE_LTCY);
+	}
+
+	if (!(param_def->ltr_act_lat_ctrl.ctrl == MAC_AX_PCIE_IGNORE ||
+	      param->ltr_act_lat_ctrl.ctrl == MAC_AX_PCIE_IGNORE ||
+	      param_def->ltr_act_lat_ctrl.ctrl == MAC_AX_PCIE_DEFAULT)) {
+		val32 = param->ltr_act_lat_ctrl.ctrl == MAC_AX_PCIE_DEFAULT ?
+			param_def->ltr_act_lat_ctrl.val :
+			param->ltr_act_lat_ctrl.val;
+		ltr_act_ltcy =
+			SET_CLR_WORD(ltr_act_ltcy, val32, B_AX_LTR_ACT_LTCY);
+	}
+
+	MAC_REG_W32(R_AX_LTR_CTRL_0, ltr_ctrl0);
+	MAC_REG_W32(R_AX_LTR_CTRL_1, ltr_ctrl1);
+	MAC_REG_W32(R_AX_LTR_IDLE_LATENCY, ltr_idle_ltcy);
+	MAC_REG_W32(R_AX_LTR_ACTIVE_LATENCY, ltr_act_ltcy);
+
+	return status;
+}
+
+u32 pcie_ltr_read_8852b(struct mac_ax_adapter *adapter,
+			struct mac_ax_pcie_ltr_param *param)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 status = MACSUCCESS;
+	u32 ltr_ctrl0, ltr_ctrl1, ltr_idle_ltcy, ltr_act_ltcy;
+
+	ltr_ctrl0 = MAC_REG_R32(R_AX_LTR_CTRL_0);
+	ltr_ctrl1 = MAC_REG_R32(R_AX_LTR_CTRL_1);
+	ltr_idle_ltcy = MAC_REG_R32(R_AX_LTR_IDLE_LATENCY);
+	ltr_act_ltcy = MAC_REG_R32(R_AX_LTR_ACTIVE_LATENCY);
+
+	if (ltr_ctrl0 == MAC_AX_R32_FF || ltr_ctrl0 == MAC_AX_R32_EA ||
+	    ltr_ctrl1 == MAC_AX_R32_FF || ltr_ctrl1 == MAC_AX_R32_EA ||
+	    ltr_idle_ltcy == MAC_AX_R32_FF || ltr_idle_ltcy == MAC_AX_R32_EA ||
+	    ltr_act_ltcy == MAC_AX_R32_FF || ltr_act_ltcy == MAC_AX_R32_EA) {
+		PLTFM_MSG_ERR("[ERR] LTR reg read nothing!\n");
+		return MACCMP;
+	}
+
+	param->ltr_ctrl = ltr_ctrl0 & B_AX_LTR_EN ?
+			  MAC_AX_PCIE_ENABLE : MAC_AX_PCIE_DISABLE;
+
+	param->ltr_hw_ctrl = ltr_ctrl0 & B_AX_LTR_HW_EN ?
+			     MAC_AX_PCIE_ENABLE : MAC_AX_PCIE_DISABLE;
+
+	param->ltr_spc_ctrl =
+		(enum mac_ax_pcie_ltr_spc)
+		GET_FIELD(ltr_ctrl0, B_AX_LTR_SPACE_IDX);
+	param->ltr_idle_timer_ctrl =
+		(enum mac_ax_pcie_ltr_idle_timer)
+		GET_FIELD(ltr_ctrl0, B_AX_LTR_IDLE_TIMER_IDX);
+
+	param->ltr_rx0_th_ctrl.val =
+		(u16)GET_FIELD(ltr_ctrl1, B_AX_LTR_RX0_TH);
+	param->ltr_rx1_th_ctrl.val =
+		(u16)GET_FIELD(ltr_ctrl1, B_AX_LTR_RX1_TH);
+	param->ltr_idle_lat_ctrl.val =
+		GET_FIELD(ltr_idle_ltcy, B_AX_LTR_IDLE_LTCY);
+	param->ltr_act_lat_ctrl.val =
+		GET_FIELD(ltr_act_ltcy, B_AX_LTR_ACT_LTCY);
+
+	return status;
+}
+
+u32 ltr_sw_trigger_8852b(struct mac_ax_adapter *adapter,
+			 enum mac_ax_pcie_ltr_sw_ctrl ctrl)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = MAC_REG_R32(R_AX_LTR_CTRL_0);
+
+	if (val32 & B_AX_LTR_HW_EN) {
+		PLTFM_MSG_ERR("[ERR]LTR HW mode running\n");
+		return MACPROCERR;
+	} else if (!(val32 & B_AX_LTR_EN)) {
+		PLTFM_MSG_ERR("[ERR]LTR not enable\n");
+		return MACHWNOTEN;
+	}
+
+	switch (ctrl) {
+	case MAC_AX_PCIE_LTR_SW_ACT:
+		MAC_REG_W32(R_AX_LTR_CTRL_0, val32 | B_AX_APP_LTR_ACT);
+		break;
+	case MAC_AX_PCIE_LTR_SW_IDLE:
+		MAC_REG_W32(R_AX_LTR_CTRL_0, val32 | B_AX_APP_LTR_IDLE);
+		break;
+	default:
+		PLTFM_MSG_ERR("Invalid input for %s\n", __func__);
+		return MACFUNCINPUT;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 get_avail_txbd_8852b(struct mac_ax_adapter *adapter, u8 ch_idx,
+			 u16 *host_idx, u16 *hw_idx, u16 *avail_txbd)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = MACSUCCESS, reg = 0, tmp32;
+	u16 bndy = adapter->pcie_info.txbd_bndy;
+	u8 tx_dma_ch = 0;
+
+	tx_dma_ch = MAC_AX_DMA_ACH0 + ch_idx;
+
+	ret = p_ops->get_txbd_reg_pcie(adapter, tx_dma_ch, &reg, PCIE_BD_CTRL_IDX);
+	if (ret != MACSUCCESS) {
+		*avail_txbd = 0;
+		return ret;
+	}
+
+	tmp32 = MAC_REG_R32(reg);
+	*host_idx = (u16)GET_FIELD(tmp32, B_AX_ACH0_HOST_IDX);
+	*hw_idx = (u16)GET_FIELD(tmp32, B_AX_ACH0_HW_IDX);
+	*avail_txbd = calc_avail_wptr(*hw_idx, *host_idx, bndy);
+	PLTFM_MSG_TRACE("%s: ", __func__);
+	PLTFM_MSG_TRACE("dma_ch %d, host_idx %d, hw_idx %d avail_txbd %d\n",
+			ch_idx, *host_idx, *hw_idx, avail_txbd);
+
+	return MACSUCCESS;
+}
+
+u32 get_avail_rxbd_8852b(struct mac_ax_adapter *adapter, u8 ch_idx,
+			 u16 *host_idx, u16 *hw_idx, u16 *avail_rxbd)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = MACSUCCESS, reg = 0, tmp32;
+	u16 bndy;
+	u8 rx_dma_ch = 0;
+
+	rx_dma_ch = MAC_AX_RX_CH_RXQ + ch_idx;
+
+	if (rx_dma_ch == MAC_AX_RX_CH_RXQ) {
+		bndy = adapter->pcie_info.rxbd_bndy;
+	} else if (rx_dma_ch == MAC_AX_RX_CH_RPQ) {
+		bndy = adapter->pcie_info.rpbd_bndy;
+	} else {
+		PLTFM_MSG_ERR("Unkwown rx_dma_ch: %d\n", rx_dma_ch);
+		return MACFUNCINPUT;
+	}
+
+	ret = p_ops->get_rxbd_reg_pcie(adapter, rx_dma_ch, &reg, PCIE_BD_CTRL_IDX);
+	if (ret != MACSUCCESS) {
+		*avail_rxbd = 0;
+		return ret;
+	}
+
+	tmp32 = MAC_REG_R32(reg);
+	*host_idx = (u16)GET_FIELD(tmp32, B_AX_RXQ_HOST_IDX);
+	*hw_idx = (u16)GET_FIELD(tmp32, B_AX_RXQ_HW_IDX);
+	*avail_rxbd = calc_avail_rptr(*host_idx, *hw_idx, bndy);
+
+	return MACSUCCESS;
+}
+
+u32 get_io_stat_pcie_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_io_stat *out_st)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, to_addr;
+
+	val32 = MAC_REG_R32(R_AX_LBC_WATCHDOG);
+	if (val32 & B_AX_LBC_FLAG) {
+		adapter->sm.io_st = MAC_AX_IO_ST_HANG;
+		to_addr = GET_FIELD(val32, B_AX_LBC_ADDR);
+		PLTFM_MSG_ERR("[ERR]pcie io timeout addr 0x%X\n", to_addr);
+		if (out_st) {
+			out_st->to_flag = 1;
+			out_st->io_st = adapter->sm.io_st;
+			out_st->addr = to_addr;
+		}
+		MAC_REG_W32(R_AX_LBC_WATCHDOG, val32);
+	} else if (out_st) {
+		out_st->to_flag = 0;
+		out_st->io_st = adapter->sm.io_st;
+		out_st->addr = 0;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 ctrl_hci_dma_en_pcie_8852b(struct mac_ax_adapter *adapter,
+			       enum mac_ax_pcie_func_ctrl txen,
+			       enum mac_ax_pcie_func_ctrl rxen)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg = R_AX_HCI_FUNC_EN;
+	u32 rval = MAC_REG_R32(reg);
+
+	if (txen == MAC_AX_PCIE_ENABLE)
+		rval |= B_AX_HCI_TXDMA_EN;
+	else if (txen == MAC_AX_PCIE_DISABLE)
+		rval &= ~B_AX_HCI_TXDMA_EN;
+
+	if (rxen == MAC_AX_PCIE_ENABLE)
+		rval |= B_AX_HCI_RXDMA_EN;
+	else if (rxen == MAC_AX_PCIE_DISABLE)
+		rval &= ~B_AX_HCI_RXDMA_EN;
+
+	MAC_REG_W32(reg, rval);
+
+	return MACSUCCESS;
+}
+
+u32 ctrl_trxdma_pcie_8852b(struct mac_ax_adapter *adapter,
+			   enum mac_ax_pcie_func_ctrl txen,
+			   enum mac_ax_pcie_func_ctrl rxen,
+			   enum mac_ax_pcie_func_ctrl ioen)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_init = R_AX_PCIE_INIT_CFG1;
+	u32 val_init = MAC_REG_R32(reg_init);
+	u32 reg_stop1 = R_AX_PCIE_DMA_STOP1;
+	u32 val_stop1 = MAC_REG_R32(reg_stop1);
+
+	if (txen == MAC_AX_PCIE_ENABLE)
+		val_init |= B_AX_TXHCI_EN;
+	else if (txen == MAC_AX_PCIE_DISABLE)
+		val_init &= ~B_AX_TXHCI_EN;
+
+	if (rxen == MAC_AX_PCIE_ENABLE)
+		val_init |= B_AX_RXHCI_EN;
+	else if (rxen == MAC_AX_PCIE_DISABLE)
+		val_init &= ~B_AX_RXHCI_EN;
+
+	if (ioen == MAC_AX_PCIE_ENABLE)
+		val_stop1 &= ~B_AX_STOP_PCIEIO;
+	else if (ioen == MAC_AX_PCIE_DISABLE)
+		val_stop1 |= B_AX_STOP_PCIEIO;
+
+	MAC_REG_W32(reg_init, val_init);
+	MAC_REG_W32(reg_stop1, val_stop1);
+
+	return MACSUCCESS;
+}
+
+u32 ctrl_txdma_ch_pcie_8852b(struct mac_ax_adapter *adapter,
+			     struct mac_ax_txdma_ch_map *ch_map)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_stop1 = R_AX_PCIE_DMA_STOP1;
+	u32 val32;
+
+	val32 = MAC_REG_R32(reg_stop1);
+	if (ch_map->ch0 == MAC_AX_PCIE_ENABLE)
+		val32 &= ~B_AX_STOP_ACH0;
+	else if (ch_map->ch0 == MAC_AX_PCIE_DISABLE)
+		val32 |= B_AX_STOP_ACH0;
+
+	if (ch_map->ch1 == MAC_AX_PCIE_ENABLE)
+		val32 &= ~B_AX_STOP_ACH1;
+	else if (ch_map->ch1 == MAC_AX_PCIE_DISABLE)
+		val32 |= B_AX_STOP_ACH1;
+
+	if (ch_map->ch2 == MAC_AX_PCIE_ENABLE)
+		val32 &= ~B_AX_STOP_ACH2;
+	else if (ch_map->ch2 == MAC_AX_PCIE_DISABLE)
+		val32 |= B_AX_STOP_ACH2;
+
+	if (ch_map->ch3 == MAC_AX_PCIE_ENABLE)
+		val32 &= ~B_AX_STOP_ACH3;
+	else if (ch_map->ch3 == MAC_AX_PCIE_DISABLE)
+		val32 |= B_AX_STOP_ACH3;
+
+	if (ch_map->ch8 == MAC_AX_PCIE_ENABLE)
+		val32 &= ~B_AX_STOP_CH8;
+	else if (ch_map->ch8 == MAC_AX_PCIE_DISABLE)
+		val32 |= B_AX_STOP_CH8;
+
+	if (ch_map->ch9 == MAC_AX_PCIE_ENABLE)
+		val32 &= ~B_AX_STOP_CH9;
+	else if (ch_map->ch9 == MAC_AX_PCIE_DISABLE)
+		val32 |= B_AX_STOP_CH9;
+
+	if (ch_map->ch12 == MAC_AX_PCIE_ENABLE)
+		val32 &= ~B_AX_STOP_CH12;
+	else if (ch_map->ch12 == MAC_AX_PCIE_DISABLE)
+		val32 |= B_AX_STOP_CH12;
+	MAC_REG_W32(reg_stop1, val32);
+
+	return MACSUCCESS;
+}
+
+u32 set_pcie_speed_8852b(struct mac_ax_adapter *adapter,
+			 enum mac_ax_pcie_phy set_speed)
+{
+	u32 ret;
+	u32 support_gen;
+	u32 cnt;
+	u32 poll_val32;
+	u8 link_speed;
+
+	if  (!(set_speed == MAC_AX_PCIE_PHY_GEN1 || set_speed == MAC_AX_PCIE_PHY_GEN2)) {
+		PLTFM_MSG_ERR("[ERR]Do not support that speed!\n");
+		return MACFUNCINPUT;
+	}
+
+	ret = dbi_r32_pcie(adapter, PCIE_CAPABILITY_SPEED, &support_gen);
+	if (ret != MACSUCCESS)
+		return ret;
+	support_gen = GET_FIEL2(support_gen, PCIE_SUPPORT_GEN_SH, PCIE_LINK_SPEED_BITS_MSK);
+
+	if (support_gen == MAC_AX_PCIE_PHY_GEN1) {
+		if (set_speed == MAC_AX_PCIE_PHY_GEN1) {
+			ret = MACSUCCESS;
+		} else {
+			PLTFM_MSG_ERR("[ERR]Do not support that gen!\n");
+			ret = MACFUNCINPUT;
+		}
+	} else if (support_gen == MAC_AX_PCIE_PHY_GEN2) {
+		ret = get_pcie_speed_8852b(adapter, &link_speed);
+		if (link_speed == set_speed) {
+			ret = MACSUCCESS;
+		} else {
+			ret = dbi_w32_pcie(adapter, PCIE_LINK_CHANGE_SPEED, set_speed);
+			if (ret != MACSUCCESS)
+				return ret;
+			ret = dbi_r32_pcie(adapter, PCIE_FTS, &poll_val32);
+			if (ret != MACSUCCESS)
+				return ret;
+			ret = dbi_w32_pcie(adapter, PCIE_FTS, poll_val32 | PCIE_POLLING_BIT);
+			if (ret != MACSUCCESS)
+				return ret;
+
+			cnt = PCIE_POLL_SPEED_CHANGE_CNT;
+			while (cnt) {
+				ret = dbi_r32_pcie(adapter, PCIE_FTS, &poll_val32);
+				if (ret != MACSUCCESS)
+					return ret;
+				if (!(poll_val32 & PCIE_POLLING_BIT))
+					break;
+				cnt--;
+				PLTFM_DELAY_US(PCIE_POLL_IO_IDLE_DLY_US);
+			}
+			if (!cnt) {
+				PLTFM_MSG_ERR("[ERR]PCIE polling timeout\n");
+				return MACPOLLTO;
+			}
+		}
+	} else {
+		PLTFM_MSG_ERR("[ERR]Do Not support that speed gen!\n");
+		ret = MACFUNCINPUT;
+	}
+
+	return ret;
+}
+
+u32 get_pcie_speed_8852b(struct mac_ax_adapter *adapter,
+			 u8 *speed)
+{
+	u32 ret;
+	u32 val32;
+
+	ret = dbi_r32_pcie(adapter, PCIE_LINK_SPEED_32BIT, &val32);
+	if (ret != MACSUCCESS)
+		return ret;
+	val32 = GET_FIEL2(val32, PCIE_LINK_SPEED_SH, PCIE_LINK_SPEED_BITS_MSK);
+
+	if (val32 == MAC_AX_PCIE_PHY_GEN1) {
+		*speed = MAC_AX_PCIE_PHY_GEN1;
+	} else if (val32 == MAC_AX_PCIE_PHY_GEN2) {
+		*speed = MAC_AX_PCIE_PHY_GEN2;
+	} else {
+		ret = MACFUNCINPUT;
+		PLTFM_MSG_ERR("[ERR]Do not support that speed!\n");
+	}
+
+	return ret;
+}
+
+u32 ctrl_wpdma_pcie_8852b(struct mac_ax_adapter *adapter,
+			  enum mac_ax_pcie_func_ctrl wpen)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_stop1 = R_AX_PCIE_DMA_STOP1;
+	u32 val32;
+
+	val32 = MAC_REG_R32(reg_stop1);
+	if (wpen == MAC_AX_PCIE_ENABLE)
+		val32 &= ~B_AX_STOP_WPDMA;
+	else if (wpen == MAC_AX_PCIE_DISABLE)
+		val32 |= B_AX_STOP_WPDMA;
+	MAC_REG_W32(reg_stop1, val32);
+
+	return MACSUCCESS;
+}
+
+u32 poll_io_idle_pcie_8852b(struct mac_ax_adapter *adapter)
+{
+#define B_IO_BUSY (B_AX_PCIEIO_BUSY | B_AX_PCIEIO_TX_BUSY | B_AX_PCIEIO_RX_BUSY)
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_busy1 = R_AX_PCIE_DMA_BUSY1;
+	u32 val32;
+	u32 cnt;
+
+	cnt = PCIE_POLL_IO_IDLE_CNT;
+	while (cnt) {
+		val32 = MAC_REG_R32(reg_busy1);
+		if (!(val32 & B_IO_BUSY))
+			break;
+		cnt--;
+		PLTFM_DELAY_US(PCIE_POLL_IO_IDLE_DLY_US);
+	}
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR]PCIE dmach busy1 0x%X\n", val32);
+		return MACPOLLTO;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 poll_txdma_ch_idle_pcie_8852b(struct mac_ax_adapter *adapter,
+				  struct mac_ax_txdma_ch_map *ch_map)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_busy1 = R_AX_PCIE_DMA_BUSY1;
+	u32 val32 = 0, rval32, cnt;
+
+	if (ch_map->ch0 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_ACH0_BUSY;
+
+	if (ch_map->ch1 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_ACH1_BUSY;
+
+	if (ch_map->ch2 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_ACH2_BUSY;
+
+	if (ch_map->ch3 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_ACH3_BUSY;
+
+	if (ch_map->ch8 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_CH8_BUSY;
+
+	if (ch_map->ch9 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_CH9_BUSY;
+
+	if (ch_map->ch12 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_CH12_BUSY;
+
+	cnt = PCIE_POLL_DMACH_IDLE_CNT;
+	while (cnt) {
+		rval32 = MAC_REG_R32(reg_busy1);
+		if (!(rval32 & val32))
+			break;
+		cnt--;
+		PLTFM_DELAY_US(PCIE_POLL_DMACH_IDLE_DLY_US);
+	}
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR]PCIE dmach busy1 0x%X\n", rval32);
+		return MACPOLLTO;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 poll_rxdma_ch_idle_pcie_8852b(struct mac_ax_adapter *adapter,
+				  struct mac_ax_rxdma_ch_map *ch_map)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_busy1 = R_AX_PCIE_DMA_BUSY1;
+	u32 val32 = 0, rval32, cnt;
+
+	if (ch_map->rxq == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_RXQ_BUSY;
+	if (ch_map->rpq == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_RPQ_BUSY;
+
+	cnt = PCIE_POLL_DMACH_IDLE_CNT;
+	while (cnt) {
+		rval32 = MAC_REG_R32(reg_busy1);
+		if (!(rval32 & val32))
+			break;
+		cnt--;
+		PLTFM_DELAY_US(PCIE_POLL_DMACH_IDLE_DLY_US);
+	}
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR]PCIE dmach busy1 0x%X\n", rval32);
+		return MACPOLLTO;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 poll_dma_all_idle_pcie_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_txdma_ch_map txch_map;
+	struct mac_ax_rxdma_ch_map rxch_map;
+	u32 ret;
+
+	txch_map.ch0 = MAC_AX_PCIE_ENABLE;
+	txch_map.ch1 = MAC_AX_PCIE_ENABLE;
+	txch_map.ch2 = MAC_AX_PCIE_ENABLE;
+	txch_map.ch3 = MAC_AX_PCIE_ENABLE;
+	txch_map.ch8 = MAC_AX_PCIE_ENABLE;
+	txch_map.ch9 = MAC_AX_PCIE_ENABLE;
+	txch_map.ch12 = MAC_AX_PCIE_ENABLE;
+	ret = poll_txdma_ch_idle_pcie_8852b(adapter, &txch_map);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]PCIE poll txdma all ch idle %d\n", ret);
+		return ret;
+	}
+
+	rxch_map.rxq = MAC_AX_PCIE_ENABLE;
+	rxch_map.rpq = MAC_AX_PCIE_ENABLE;
+	ret = poll_rxdma_ch_idle_pcie_8852b(adapter, &rxch_map);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]PCIE poll rxdma all ch idle %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+u32 clr_idx_ch_pcie_8852b(struct mac_ax_adapter *adapter,
+			  struct mac_ax_txdma_ch_map *txch_map,
+			  struct mac_ax_rxdma_ch_map *rxch_map)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_clr_tx1 = R_AX_TXBD_RWPTR_CLR1;
+	u32 reg_clr_rx = R_AX_RXBD_RWPTR_CLR;
+	u32 val32 = 0;
+
+	if (txch_map->ch0 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_CLR_ACH0_IDX;
+
+	if (txch_map->ch1 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_CLR_ACH1_IDX;
+
+	if (txch_map->ch2 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_CLR_ACH2_IDX;
+
+	if (txch_map->ch3 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_CLR_ACH3_IDX;
+
+	if (txch_map->ch8 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_CLR_CH8_IDX;
+
+	if (txch_map->ch9 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_CLR_CH9_IDX;
+
+	if (txch_map->ch12 == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_CLR_CH12_IDX;
+
+	MAC_REG_W32(reg_clr_tx1, val32);
+
+	val32 = 0;
+	if (rxch_map->rxq == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_CLR_RXQ_IDX;
+	if (rxch_map->rpq == MAC_AX_PCIE_ENABLE)
+		val32 |= B_AX_CLR_RPQ_IDX;
+
+	MAC_REG_W32(reg_clr_rx, val32);
+
+	return MACSUCCESS;
+}
+
+u32 rst_bdram_pcie_8852b(struct mac_ax_adapter *adapter, u8 val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_init = R_AX_PCIE_INIT_CFG1;
+	u32 reg_ps = R_AX_PCIE_PS_CTRL;
+	u32 cnt, val32;
+
+	MAC_REG_W32(reg_init, MAC_REG_R32(reg_init) | B_AX_RST_BDRAM);
+
+	MAC_REG_W32(reg_ps, MAC_REG_R32(reg_ps) | B_AX_PCIE_FORCE_L0);
+
+	cnt = PCIE_POLL_BDRAM_RST_CNT;
+	while (cnt) {
+		val32 = MAC_REG_R32(reg_init);
+		if (!(val32 & B_AX_RST_BDRAM))
+			break;
+		cnt--;
+		PLTFM_DELAY_US(PCIE_POLL_BDRAM_RST_DLY_US);
+	}
+
+	MAC_REG_W32(reg_ps, MAC_REG_R32(reg_ps) & ~B_AX_PCIE_FORCE_L0);
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR]rst bdram timeout 0x%X\n", val32);
+		return MACPOLLTO;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 trx_mit_pcie_8852b(struct mac_ax_adapter *adapter,
+		       struct mac_ax_pcie_trx_mitigation *mit_info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 tmr_unit = 0;
+	u32 value32 = 0;
+
+	if (mit_info->txch_map->ch0 == MAC_AX_PCIE_ENABLE)
+		value32 |= B_AX_TXMIT_ACH0_SEL;
+	else if (mit_info->txch_map->ch0 == MAC_AX_PCIE_DISABLE)
+		value32 &= ~B_AX_TXMIT_ACH0_SEL;
+
+	if (mit_info->txch_map->ch1 == MAC_AX_PCIE_ENABLE)
+		value32 |= B_AX_TXMIT_ACH1_SEL;
+	else if (mit_info->txch_map->ch1 == MAC_AX_PCIE_DISABLE)
+		value32 &= ~B_AX_TXMIT_ACH1_SEL;
+
+	if (mit_info->txch_map->ch2 == MAC_AX_PCIE_ENABLE)
+		value32 |= B_AX_TXMIT_ACH2_SEL;
+	else if (mit_info->txch_map->ch2 == MAC_AX_PCIE_DISABLE)
+		value32 &= ~B_AX_TXMIT_ACH2_SEL;
+
+	if (mit_info->txch_map->ch3 == MAC_AX_PCIE_ENABLE)
+		value32 |= B_AX_TXMIT_ACH3_SEL;
+	else if (mit_info->txch_map->ch3 == MAC_AX_PCIE_DISABLE)
+		value32 &= ~B_AX_TXMIT_ACH3_SEL;
+
+	if (mit_info->txch_map->ch8 == MAC_AX_PCIE_ENABLE)
+		value32 |= B_AX_TXMIT_CH8_SEL;
+	else if (mit_info->txch_map->ch8 == MAC_AX_PCIE_DISABLE)
+		value32 &= ~B_AX_TXMIT_CH8_SEL;
+
+	if (mit_info->txch_map->ch9 == MAC_AX_PCIE_ENABLE)
+		value32 |= B_AX_TXMIT_CH9_SEL;
+	else if (mit_info->txch_map->ch9 == MAC_AX_PCIE_DISABLE)
+		value32 &= ~B_AX_TXMIT_CH9_SEL;
+
+	if (mit_info->txch_map->ch12 == MAC_AX_PCIE_ENABLE)
+		value32 |= B_AX_TXMIT_CH12_SEL;
+	else if (mit_info->txch_map->ch12 == MAC_AX_PCIE_DISABLE)
+		value32 &= ~B_AX_TXMIT_CH12_SEL;
+
+	switch (mit_info->tx_timer_unit) {
+	case MAC_AX_MIT_64US:
+		tmr_unit = 0;
+		break;
+	case MAC_AX_MIT_128US:
+		tmr_unit = 1;
+		break;
+	case MAC_AX_MIT_256US:
+		tmr_unit = 2;
+		break;
+	case MAC_AX_MIT_512US:
+		tmr_unit = 3;
+		break;
+	default:
+		PLTFM_MSG_WARN("[WARN]Set TX MIT timer unit fail\n");
+		break;
+	}
+
+	value32 = SET_CLR_WORD(value32, tmr_unit, B_AX_TXTIMER_UNIT);
+	value32 = SET_CLR_WORD(value32, mit_info->tx_counter, B_AX_TXCOUNTER_MATCH);
+	value32 = SET_CLR_WORD(value32, mit_info->tx_timer, B_AX_TXTIMER_MATCH);
+	MAC_REG_W32(R_AX_INT_MIT_TX, value32);
+
+	value32 = 0;
+	if (mit_info->rxch_map->rxq == MAC_AX_PCIE_ENABLE)
+		value32 |= B_AX_RXMIT_RXP2_SEL;
+	else if (mit_info->rxch_map->rxq == MAC_AX_PCIE_DISABLE)
+		value32 &= ~B_AX_RXMIT_RXP2_SEL;
+
+	if (mit_info->rxch_map->rpq == MAC_AX_PCIE_ENABLE)
+		value32 |= B_AX_RXMIT_RXP1_SEL;
+	else if (mit_info->rxch_map->rpq == MAC_AX_PCIE_DISABLE)
+		value32 &= ~B_AX_RXMIT_RXP1_SEL;
+
+	switch (mit_info->rx_timer_unit) {
+	case MAC_AX_MIT_64US:
+		tmr_unit = 0;
+		break;
+	case MAC_AX_MIT_128US:
+		tmr_unit = 1;
+		break;
+	case MAC_AX_MIT_256US:
+		tmr_unit = 2;
+		break;
+	case MAC_AX_MIT_512US:
+		tmr_unit = 3;
+		break;
+	default:
+		PLTFM_MSG_WARN("[WARN]Set RX MIT timer unit fail\n");
+		break;
+	}
+
+	value32 = SET_CLR_WORD(value32, tmr_unit, B_AX_RXTIMER_UNIT);
+	value32 = SET_CLR_WORD(value32, mit_info->rx_counter, B_AX_RXCOUNTER_MATCH);
+	value32 = SET_CLR_WORD(value32, mit_info->rx_timer, B_AX_RXTIMER_MATCH);
+	MAC_REG_W32(R_AX_INT_MIT_RX, value32);
+
+	return MACSUCCESS;
+}
+
+u32 mode_op_pcie_8852b(struct mac_ax_adapter *adapter,
+		       struct mac_ax_intf_info *intf_info)
+{
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	enum mac_ax_rxbd_mode *rxbd_mode = (&intf_info->rxbd_mode);
+	enum mac_ax_tag_mode *tag_mode = (&intf_info->tag_mode);
+	enum mac_ax_multi_tag_num *multi_tag_num = (&intf_info->multi_tag_num);
+	enum mac_ax_wd_dma_intvl *wd_dma_idle_intvl =
+		(&intf_info->wd_dma_idle_intvl);
+	enum mac_ax_wd_dma_intvl *wd_dma_act_intvl =
+		(&intf_info->wd_dma_act_intvl);
+	enum mac_ax_tx_burst *tx_burst = &intf_info->tx_burst;
+	enum mac_ax_rx_burst *rx_burst = &intf_info->rx_burst;
+	struct mac_ax_intf_info *intf_info_def;
+	u32 reg_init1 = R_AX_PCIE_INIT_CFG1;
+	u32 reg_init2 = R_AX_PCIE_INIT_CFG2;
+	u32 reg_exp = R_AX_PCIE_EXP_CTRL;
+	u32 val32_init1, val32_init2, val32_exp;
+
+	intf_info_def = p_ops->get_pcie_info_def(adapter);
+	if (!intf_info_def) {
+		PLTFM_MSG_ERR("%s: NULL intf_info\n", __func__);
+		return MACNPTR;
+	}
+
+	if (intf_info->rxbd_mode == MAC_AX_RXBD_DEF)
+		rxbd_mode = (&intf_info_def->rxbd_mode);
+	if (intf_info->tx_burst == MAC_AX_TX_BURST_DEF)
+		tx_burst = &intf_info_def->tx_burst;
+	if (intf_info->rx_burst == MAC_AX_RX_BURST_DEF)
+		rx_burst = &intf_info_def->rx_burst;
+	if (intf_info->tag_mode == MAC_AX_TAG_DEF)
+		tag_mode = (&intf_info_def->tag_mode);
+	if (intf_info->multi_tag_num == MAC_AX_TAG_NUM_DEF)
+		multi_tag_num = (&intf_info_def->multi_tag_num);
+	if (intf_info->wd_dma_act_intvl == MAC_AX_WD_DMA_INTVL_DEF)
+		wd_dma_act_intvl = (&intf_info_def->wd_dma_act_intvl);
+	if (intf_info->wd_dma_idle_intvl == MAC_AX_WD_DMA_INTVL_DEF)
+		wd_dma_idle_intvl = (&intf_info_def->wd_dma_idle_intvl);
+
+	val32_init1 = MAC_REG_R32(reg_init1);
+	val32_init2 = MAC_REG_R32(reg_init2);
+	val32_exp = MAC_REG_R32(reg_exp);
+
+	if ((*rxbd_mode) == MAC_AX_RXBD_PKT) {
+		val32_init1 &= ~B_AX_RXBD_MODE;
+	} else if ((*rxbd_mode) == MAC_AX_RXBD_SEP) {
+		if (intf_info->rx_sep_append_len > B_AX_PCIE_RX_APPLEN_MSK) {
+			PLTFM_MSG_ERR("rx sep app len %d\n",
+				      intf_info->rx_sep_append_len);
+			return MACFUNCINPUT;
+		}
+
+		val32_init1 |= B_AX_RXBD_MODE;
+		val32_init2 = SET_CLR_WORD(val32_init2, intf_info->rx_sep_append_len,
+					   B_AX_PCIE_RX_APPLEN);
+	}
+
+	val32_init1 = SET_CLR_WORD(val32_init1, *tx_burst, B_AX_PCIE_MAX_TXDMA);
+	val32_init1 = SET_CLR_WORD(val32_init1, *rx_burst, B_AX_PCIE_MAX_RXDMA);
+
+	if ((*tag_mode) == MAC_AX_TAG_SGL)
+		val32_init1 &= ~B_AX_LATENCY_CONTROL;
+	else if ((*tag_mode) == MAC_AX_TAG_MULTI)
+		val32_init1 |= B_AX_LATENCY_CONTROL;
+
+	val32_exp = SET_CLR_WORD(val32_exp, *multi_tag_num, B_AX_MAX_TAG_NUM);
+
+	val32_init2 = SET_CLR_WORD(val32_init2, *wd_dma_idle_intvl, B_AX_WD_ITVL_IDLE);
+	val32_init2 = SET_CLR_WORD(val32_init2, *wd_dma_act_intvl, B_AX_WD_ITVL_ACT);
+
+	MAC_REG_W32(reg_init1, val32_init1);
+	MAC_REG_W32(reg_init2, val32_init2);
+	MAC_REG_W32(reg_exp, val32_exp);
+
+	return MACSUCCESS;
+}
+
+u32 get_err_flag_pcie_8852b(struct mac_ax_adapter *adapter,
+			    struct mac_ax_pcie_err_info *out_info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32 = MAC_REG_R32(R_AX_DBG_ERR_FLAG);
+
+	out_info->txbd_len_zero = (val32 & B_AX_PCIE_TXBD_LEN0) ? 1 : 0;
+	out_info->tx_stuck = (val32 & B_AX_TX_STUCK) ? 1 : 0;
+	out_info->rx_stuck = (val32 & B_AX_RX_STUCK) ? 1 : 0;
+
+	return MACSUCCESS;
+}
+
+static u32 get_target_8852b(struct mac_ax_adapter *adapter, u16 *target,
+			    enum mac_ax_pcie_phy phy_rate)
+{
+	u16 tmp_u16, count;
+	u16 tar;
+	u32 ret = MACSUCCESS;
+
+	/* Enable counter */
+	ret = mdio_r16_pcie(adapter, RAC_CTRL_PPR_V1, phy_rate, &tmp_u16);
+	if (ret != MACSUCCESS)
+		return ret;
+	ret = mdio_w16_pcie(adapter, RAC_CTRL_PPR_V1, tmp_u16 & ~BAC_AUTOK_ONCE_EN,
+			    phy_rate);
+	if (ret != MACSUCCESS)
+		return ret;
+	ret = mdio_w16_pcie(adapter, RAC_CTRL_PPR_V1, tmp_u16 | BAC_AUTOK_ONCE_EN,
+			    phy_rate);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = mdio_r16_pcie(adapter, RAC_CTRL_PPR_V1, phy_rate, &tar);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	count = PCIE_POLL_AUTOK_CNT;
+	while (count && (tar & BAC_AUTOK_ONCE_EN)) {
+		ret = mdio_r16_pcie(adapter, RAC_CTRL_PPR_V1, phy_rate, &tar);
+		if (ret != MACSUCCESS)
+			return ret;
+		count--;
+		PLTFM_DELAY_US(PCIE_POLL_AUTOK_DLY_US);
+	}
+
+	if (!count) {
+		PLTFM_MSG_ERR("[ERR]AutoK get target timeout: %X\n", tar);
+		return MACPOLLTO;
+	}
+
+	tar = tar & BAC_AUTOK_HW_TAR_MSK;
+	if (tar == 0 || tar == BAC_AUTOK_HW_TAR_MSK) {
+		PLTFM_MSG_ERR("[ERR]Get target failed.\n");
+		return MACHWERR;
+	}
+
+	*target = tar;
+	return MACSUCCESS;
+}
+
+u32 mac_auto_refclk_cal_pcie_8852b(struct mac_ax_adapter *adapter,
+				   enum mac_ax_pcie_func_ctrl en)
+{
+	u8 bdr_ori, val8;
+	u16 tmp_u16;
+	u16 mgn_set;
+	u16 tar;
+	u8 l1_flag = 0;
+	u32 ret = MACSUCCESS;
+	enum mac_ax_pcie_phy phy_rate = MAC_AX_PCIE_PHY_GEN1;
+
+	if (adapter->env == DUT_ENV_FPGA || adapter->env == DUT_ENV_PXP)
+		return MACSUCCESS;
+
+#if (INTF_INTGRA_HOSTREF_V1 <= INTF_INTGRA_MINREF_V1)
+	PLTFM_MSG_ERR("[ERR]INTF_INTGRA_MINREF_V1 define fail\n");
+	return MACCMP;
+#endif
+	ret = dbi_r8_pcie(adapter, PCIE_PHY_RATE, &val8);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dbi_r8_pcie 0x%x\n", PCIE_PHY_RATE);
+		return ret;
+	}
+
+	if ((val8 & (BIT1 | BIT0)) == 0x1) {
+		phy_rate = MAC_AX_PCIE_PHY_GEN1;
+	} else if ((val8 & (BIT1 | BIT0)) == 0x2) {
+		phy_rate = MAC_AX_PCIE_PHY_GEN2;
+	} else {
+		PLTFM_MSG_ERR("[ERR]PCIe PHY rate not support\n");
+		return MACHWNOSUP;
+	}
+
+	/* Disable L1BD */
+	ret = dbi_r8_pcie(adapter, PCIE_L1_CTRL, &bdr_ori);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dbi_r8_pcie 0x%X\n", PCIE_L1_CTRL);
+		return ret;
+	}
+
+	if (bdr_ori & PCIE_BIT_L1) {
+		ret = dbi_w8_pcie(adapter, PCIE_L1_CTRL,
+				  bdr_ori & ~(PCIE_BIT_L1));
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]dbi_w8_pcie 0x%X\n", PCIE_L1_CTRL);
+			return ret;
+		}
+		l1_flag = 1;
+	}
+
+	/* Disable function */
+	ret = mdio_r16_pcie(adapter, RAC_CTRL_PPR_V1, phy_rate, &tmp_u16);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]mdio_r16_pcie 0x%X\n", RAC_CTRL_PPR_V1);
+		goto end;
+	}
+
+	if (tmp_u16 & BAC_AUTOK_EN) {
+		ret = mdio_w16_pcie(adapter, RAC_CTRL_PPR_V1,
+				    tmp_u16 & ~(BAC_AUTOK_EN), phy_rate);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]mdio_w16_pcie 0x%X\n",
+				      RAC_CTRL_PPR_V1);
+			goto end;
+		}
+	}
+
+	if (en != MAC_AX_PCIE_ENABLE)
+		goto end;
+
+	/* Set div */
+	ret = mdio_r16_pcie(adapter, RAC_CTRL_PPR_V1, phy_rate, &tmp_u16);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]mdio_r16_pcie 0x%X\n", RAC_CTRL_PPR_V1);
+		goto end;
+	}
+
+	tmp_u16 = SET_CLR_WOR2(tmp_u16, PCIE_AUTOK_DIV_2048, BAC_AUTOK_DIV_SH,
+			       BAC_AUTOK_DIV_MSK);
+	ret = mdio_w16_pcie(adapter, RAC_CTRL_PPR_V1, tmp_u16, phy_rate);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]mdio_w16_pcie 0x%X\n", RAC_CTRL_PPR_V1);
+		goto end;
+	}
+
+	/*  Obtain div and margin */
+	ret = get_target_8852b(adapter, &tar, phy_rate);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]1st get target fail %d\n", ret);
+		goto end;
+	}
+
+	mgn_set = PCIE_AUTOK_MGN;
+
+	ret = mdio_w16_pcie(adapter, RAC_SET_PPR_V1, (tar & BAC_AUTOK_TAR_MSK) |
+			    (mgn_set << BAC_AUTOK_MGN_SH), phy_rate);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]mdio_w16_pcie 0x%X\n", RAC_SET_PPR_V1);
+		goto end;
+	}
+
+	/* Enable function */
+	ret = mdio_r16_pcie(adapter, RAC_CTRL_PPR_V1, phy_rate, &tmp_u16);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]mdio_r16_pcie 0x%X\n", RAC_CTRL_PPR_V1);
+		goto end;
+	}
+	ret = mdio_w16_pcie(adapter, RAC_CTRL_PPR_V1, tmp_u16 | BAC_AUTOK_EN,
+			    phy_rate);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]mdio_w16_pcie 0x%X\n", RAC_CTRL_PPR_V1);
+		goto end;
+	}
+
+end:
+	/* Set L1BD to ori */
+	if (l1_flag == 1) {
+		ret = dbi_w8_pcie(adapter, PCIE_L1_CTRL, bdr_ori);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]dbi_w8_pcie 0x%X\n", PCIE_L1_CTRL);
+			return ret;
+		}
+	}
+	PLTFM_MSG_TRACE("[TRACE]%s: <==\n", __func__);
+
+	return ret;
+}
+
+#endif /* #if MAC_AX_PCIE_SUPPORT */
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_pcie_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_pcie_8852b.h
new file mode 100644
index 000000000000..f25cf854ed29
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_pcie_8852b.h
@@ -0,0 +1,741 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_PCIE_8852B_H_
+#define _MAC_AX_PCIE_8852B_H_
+
+#include "../_pcie.h"
+#include "../mac_priv.h"
+#if MAC_AX_8852B_SUPPORT
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief get_pcie_info_def_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval struct mac_ax_intf_info *
+ */
+struct mac_ax_intf_info *
+get_pcie_info_def_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief get_bdram_tbl_pcie_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval struct mac_ax_intf_info *
+ */
+struct txbd_ram *
+get_bdram_tbl_pcie_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief mio_w32_pcie_8852b
+ *
+ * @param *adapter
+ * @param addr
+ * @param value
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mio_w32_pcie_8852b(struct mac_ax_adapter *adapter, u16 addr, u32 value);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief mio_r32_pcie_8852b
+ *
+ * @param *adapter
+ * @param addr
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mio_r32_pcie_8852b(struct mac_ax_adapter *adapter, u16 addr, u32 *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief get_txbd_reg_pcie_8852b
+ *
+ * @param *adapter
+ * @param dma_ch
+ * @param *reg
+ * @param type
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_txbd_reg_pcie_8852b(struct mac_ax_adapter *adapter, u8 dma_ch, u32 *reg,
+			    enum pcie_bd_ctrl_type type);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief set_txbd_reg_pcie_8852b
+ *
+ * @param *adapter
+ * @param dma_ch
+ * @param type
+ * @param val0
+ * @param val1
+ * @param val2
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_txbd_reg_pcie_8852b(struct mac_ax_adapter *adapter, u8 dma_ch,
+			    enum pcie_bd_ctrl_type type, u32 val0, u32 val1, u32 val2);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief get_rxbd_reg_pcie_8852b
+ *
+ * @param *adapter
+ * @param dma_ch
+ * @param *reg
+ * @param type
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_rxbd_reg_pcie_8852b(struct mac_ax_adapter *adapter, u8 dma_ch, u32 *reg,
+			    enum pcie_bd_ctrl_type type);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief set_rxbd_reg_pcie_8852b
+ *
+ * @param *adapter
+ * @param dma_ch
+ * @param type
+ * @param val0
+ * @param val1
+ * @param val2
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_rxbd_reg_pcie_8852b(struct mac_ax_adapter *adapter, u8 dma_ch,
+			    enum pcie_bd_ctrl_type type, u32 val0, u32 val1, u32 val2);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief pcie_cfgspc_write_8852b
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 pcie_cfgspc_write_8852b(struct mac_ax_adapter *adapter,
+			    struct mac_ax_pcie_cfgspc_param *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief pcie_cfgspc_read_8852b
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 pcie_cfgspc_read_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_pcie_cfgspc_param *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief pcie_ltr_write_8852b
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 pcie_ltr_write_8852b(struct mac_ax_adapter *adapter,
+			 struct mac_ax_pcie_ltr_param *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief pcie_ltr_read_8852b
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 pcie_ltr_read_8852b(struct mac_ax_adapter *adapter,
+			struct mac_ax_pcie_ltr_param *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief ltr_sw_trigger_8852b
+ *
+ * @param *adapter
+ * @param ctrl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ltr_sw_trigger_8852b(struct mac_ax_adapter *adapter,
+			 enum mac_ax_pcie_ltr_sw_ctrl ctrl);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief get_avail_txbd_8852b
+ *
+ * @param *adapter
+ * @param ch_idx
+ * @param *host_idx
+ * @param *hw_idx
+ * @param *avail_txbd
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_avail_txbd_8852b(struct mac_ax_adapter *adapter, u8 ch_idx,
+			 u16 *host_idx, u16 *hw_idx, u16 *avail_txbd);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief get_avail_rxbd_8852b
+ *
+ * @param *adapter
+ * @param ch_idx
+ * @param *host_idx
+ * @param *hw_idx
+ * @param *avail_rxbd
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_avail_rxbd_8852b(struct mac_ax_adapter *adapter, u8 ch_idx,
+			 u16 *host_idx, u16 *hw_idx, u16 *avail_rxbd);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief get_io_stat_pcie_8852b
+ *
+ * @param *adapter
+ * @param out_st
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_io_stat_pcie_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_io_stat *out_st);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief ctrl_hci_dma_en_pcie_8852b
+ *
+ * @param *adapter
+ * @param txen
+ * @param rxen
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ctrl_hci_dma_en_pcie_8852b(struct mac_ax_adapter *adapter,
+			       enum mac_ax_pcie_func_ctrl txen,
+			       enum mac_ax_pcie_func_ctrl rxen);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief ctrl_trxdma_pcie_8852b
+ *
+ * @param *adapter
+ * @param txen
+ * @param rxen
+ * @param ioen
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ctrl_trxdma_pcie_8852b(struct mac_ax_adapter *adapter,
+			   enum mac_ax_pcie_func_ctrl txen,
+			   enum mac_ax_pcie_func_ctrl rxen,
+			   enum mac_ax_pcie_func_ctrl ioen);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief ctrl_txdma_ch_pcie_8852b
+ *
+ * @param *adapter
+ * @param *ch_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ctrl_txdma_ch_pcie_8852b(struct mac_ax_adapter *adapter,
+			     struct mac_ax_txdma_ch_map *ch_map);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief ctrl_wpdma_pcie_8852b
+ *
+ * @param *adapter
+ * @param wpen
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ctrl_wpdma_pcie_8852b(struct mac_ax_adapter *adapter,
+			  enum mac_ax_pcie_func_ctrl wpen);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief poll_io_idle_pcie_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 poll_io_idle_pcie_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief poll_txdma_ch_idle_pcie_8852b
+ *
+ * @param *adapter
+ * @param *ch_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 poll_txdma_ch_idle_pcie_8852b(struct mac_ax_adapter *adapter,
+				  struct mac_ax_txdma_ch_map *ch_map);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief poll_rxdma_ch_idle_pcie_8852b
+ *
+ * @param *adapter
+ * @param *ch_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 poll_rxdma_ch_idle_pcie_8852b(struct mac_ax_adapter *adapter,
+				  struct mac_ax_rxdma_ch_map *ch_map);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief poll_dma_all_idle_pcie_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 poll_dma_all_idle_pcie_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief clr_idx_ch_pcie_8852b
+ *
+ * @param *adapter
+ * @param *txch_map
+ * @param *rxch_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 clr_idx_ch_pcie_8852b(struct mac_ax_adapter *adapter,
+			  struct mac_ax_txdma_ch_map *txch_map,
+			  struct mac_ax_rxdma_ch_map *rxch_map);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief rst_bdram_pcie_8852b
+ *
+ * @param *adapter
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 rst_bdram_pcie_8852b(struct mac_ax_adapter *adapter, u8 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief trx_mit_pcie_8852b
+ *
+ * @param *adapter
+ * @param *mit_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 trx_mit_pcie_8852b(struct mac_ax_adapter *adapter,
+		       struct mac_ax_pcie_trx_mitigation *mit_info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief mode_op_pcie_8852b
+ *
+ * @param *adapter
+ * @param *intf_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mode_op_pcie_8852b(struct mac_ax_adapter *adapter,
+		       struct mac_ax_intf_info *intf_info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief get_err_flag_pcie_8852b
+ *
+ * @param *adapter
+ * @param *out_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_err_flag_pcie_8852b(struct mac_ax_adapter *adapter,
+			    struct mac_ax_pcie_err_info *out_info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_auto_refclk_cal_pcie_8852b
+ *
+ * @param *adapter
+ * @param en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_auto_refclk_cal_pcie_8852b(struct mac_ax_adapter *adapter,
+				   enum mac_ax_pcie_func_ctrl en);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief set_pcie_speed_8852b
+ *
+ * @param *adapter
+ * @param speed
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_pcie_speed_8852b(struct mac_ax_adapter *adapter,
+			 enum mac_ax_pcie_phy speed);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+/**
+ * @brief get_pcie_speed_8852b
+ *
+ * @param *adapter
+ * @param *speed
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_pcie_speed_8852b(struct mac_ax_adapter *adapter,
+			 u8 *speed);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup PCIE
+ * @{
+ */
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_sdio_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_sdio_8852b.c
new file mode 100644
index 000000000000..17ac26e7204b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_sdio_8852b.c
@@ -0,0 +1,622 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "_sdio_8852b.h"
+#include "../mac_priv.h"
+
+#if MAC_AX_8852B_SUPPORT
+#if MAC_AX_SDIO_SUPPORT
+u32 get_sdio_rx_req_len_8852b(struct mac_ax_adapter *adapter, u32 *rx_req_len)
+{
+	u8 pwr_state;
+	u32 val32;
+
+	pwr_state = pwr_state_chk_sdio(adapter);
+
+	if (pwr_state == SDIO_PWR_OFF && adapter->mac_pwr_info.pwr_in_lps != 1) {
+		*rx_req_len = 0;
+		PLTFM_MSG_ERR("[ERR]get_sdio_rx_req_len when power off\n");
+		return MACPWRSTAT;
+	}
+
+	val32 = PLTFM_SDIO_CMD53_R32(R_AX_SDIO_RX_REQ_LEN);
+	*rx_req_len = GET_FIELD(val32, B_AX_RX_REQ_LEN);
+
+	return MACSUCCESS;
+}
+
+u32 sdio_pre_init_8852b(struct mac_ax_adapter *adapter, void *param)
+{
+	u16 val16;
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_HCI_OPT_CTRL);
+	MAC_REG_W32(R_AX_HCI_OPT_CTRL, val32 | B_AX_SDIO_DATA_PAD_SMT);
+
+	val32 = MAC_REG_R32(R_AX_SDIO_TX_CTRL) & ~(B_AX_CMD53_TX_FORMAT);
+	MAC_REG_W32(R_AX_SDIO_TX_CTRL, val32 | B_AX_RXINT_READ_MASK_DIS);
+	adapter->sdio_info.tx_mode = MAC_AX_SDIO_TX_MODE_AGG;
+	adapter->sdio_info.tx_seq = 1;
+
+	val16 = MAC_REG_R16(R_AX_SDIO_BUS_CTRL);
+	MAC_REG_W16(R_AX_SDIO_BUS_CTRL, val16 | B_AX_EN_RPT_TXCRC);
+
+	return MACSUCCESS;
+}
+
+u32 tx_mode_cfg_sdio_8852b(struct mac_ax_adapter *adapter,
+			   enum mac_ax_sdio_tx_mode mode)
+{
+	u16 val16;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val16 = MAC_REG_R16(R_AX_SDIO_TX_CTRL);
+
+	if (mode == MAC_AX_SDIO_TX_MODE_AGG) {
+		MAC_REG_W16(R_AX_SDIO_TX_CTRL, val16 & ~(B_AX_CMD53_TX_FORMAT));
+	} else if (mode == MAC_AX_SDIO_TX_MODE_DUMMY_BLOCK ||
+		   mode == MAC_AX_SDIO_TX_MODE_DUMMY_AUTO) {
+		if ((val16 & B_AX_CMD53_W_MIX) == 0) {
+			MAC_REG_W16(R_AX_SDIO_TX_CTRL,
+				    val16 | B_AX_CMD53_TX_FORMAT);
+		} else {
+			if ((val16 & B_AX_CMD53_TX_FORMAT) == 0)
+				return MACSDIOMIXMODE;
+			else
+				return MACSDIOSEQERR;
+		}
+	} else {
+		PLTFM_MSG_ERR("[ERR]sdio tx mode = %d\n", mode);
+		return MACNOITEM;
+	}
+
+	adapter->sdio_info.tx_mode = mode;
+
+	return MACSUCCESS;
+}
+
+u32 get_int_latency_sdio_8852b(struct mac_ax_adapter *adapter)
+{
+	u32 free_cnt, free_cnt2;
+	u32 int_start;
+	u32 int_latency = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	int_start = MAC_REG_R32(R_AX_SDIO_MONITOR);
+	free_cnt = MAC_REG_R32(R_AX_FREERUN_CNT_LOW);
+	free_cnt2 = MAC_REG_R32(R_AX_FREERUN_CNT_LOW);
+	int_latency = free_cnt - int_start - (free_cnt2 - free_cnt);
+
+	return int_latency;
+}
+
+u32 get_clk_cnt_sdio_8852b(struct mac_ax_adapter *adapter, u32 *cnt)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = MAC_REG_R32(R_AX_SDIO_MONITOR_2);
+	if (GET_FIELD(val32, B_AX_SDIO_CLK_MONITOR) == 0)
+		*cnt = GET_FIELD(val32, B_AX_SDIO_CLK_CNT);
+	else
+		return MACNOITEM;
+
+	return MACSUCCESS;
+}
+
+u32 set_wt_cfg_sdio_8852b(struct mac_ax_adapter *adapter, u8 en)
+{
+	u32 reg = R_AX_SDIO_MONITOR_2 + 2;
+
+	if (en)
+		PLTFM_SDIO_CMD52_W8(reg, BIT(7));
+	else
+		PLTFM_SDIO_CMD52_W8(reg, 0);
+
+	return MACSUCCESS;
+}
+
+u32 set_clk_mon_sdio_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_sdio_clk_mon_cfg *cfg)
+{
+	u32 reg = R_AX_SDIO_MONITOR_2 + 2;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	p_ops->set_wt_cfg_sdio(adapter, 0);
+
+	switch (cfg->mon) {
+	case MAC_AX_SDIO_CLK_MON_SHORT:
+		PLTFM_SDIO_CMD52_W8(reg, BIT(5));
+		break;
+	case MAC_AX_SDIO_CLK_MON_LONG:
+		PLTFM_SDIO_CMD52_W8(reg, BIT(6));
+		break;
+	case MAC_AX_SDIO_CLK_MON_USER_DEFINE:
+		MAC_REG_W32(R_AX_SDIO_MONITOR_2,
+			    cfg->cycle & B_AX_SDIO_CLK_CNT_MSK);
+		PLTFM_SDIO_CMD52_W8(reg, BIT(5) | BIT(6));
+		break;
+	default:
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 leave_suspend_sdio_8852b(struct mac_ax_adapter *adapter)
+{
+	u8 val8;
+	u32 cnt;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val8 = MAC_REG_R8(R_AX_SDIO_BUS_CTRL + 2);
+	MAC_REG_W8(R_AX_SDIO_BUS_CTRL + 2, val8 & ~(BIT(0)));
+
+	cnt = 10000;
+	while (!(MAC_REG_R8(R_AX_SDIO_BUS_CTRL + 2) & BIT(1))) {
+		cnt--;
+		if (cnt == 0)
+			return MACLSUS;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 sdio_pwr_switch_8852b(void *vadapter,
+			  u8 pre_switch, u8 on)
+{
+	struct mac_ax_adapter *adapter = (struct mac_ax_adapter *)vadapter;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (pre_switch == PWR_PRE_SWITCH) {
+		adapter->sdio_info.rpwm_bak = MAC_REG_R32(R_AX_SDIO_HIMR);
+		MAC_REG_W32(R_AX_SDIO_HIMR, 0);
+		adapter->mac_pwr_info.pwr_seq_proc = 1;
+	} else if (pre_switch == PWR_POST_SWITCH) {
+		if (on)
+			adapter->sdio_info.tx_seq = 1;
+		adapter->mac_pwr_info.pwr_seq_proc = 0;
+	} else if (pre_switch == PWR_END_SWITCH) {
+		MAC_REG_W32(R_AX_SDIO_HIMR, adapter->sdio_info.rpwm_bak);
+	}
+
+	return MACSUCCESS;
+}
+
+u8 r_indir_cmd52_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u8 count = 0;
+	u32 dw_adr = adr & 0xFFFFFFFC;
+	u8 dw_sh = adr & (4 - 1);
+	u32 val = CMAC_CLK_ALLEN;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	union {
+		__le32 dword;
+		u8 byte[4];
+	} val32 = { 0x00000000 };
+
+	if (!(adr >= R_AX_CMAC_FUNC_EN && adr <= R_AX_CMAC_REG_END))
+		return p_ops->_r_indir_cmd52_sdio(adapter, adr);
+
+	while (count < MAC_REG_POOL_COUNT) {
+		val32.byte[0] = p_ops->_r_indir_cmd52_sdio(adapter, dw_adr);
+		val32.byte[1] =
+			PLTFM_SDIO_CMD52_R8(R_AX_SDIO_INDIRECT_DATA + 1);
+		val32.byte[2] =
+			PLTFM_SDIO_CMD52_R8(R_AX_SDIO_INDIRECT_DATA + 2);
+		val32.byte[3] =
+			PLTFM_SDIO_CMD52_R8(R_AX_SDIO_INDIRECT_DATA + 3);
+
+		if (le32_to_cpu(val32.dword) != MAC_AX_R32_DEAD)
+			break;
+
+		PLTFM_MSG_ERR("[ERR]addr 0x%x = 0xdeadbeef\n", dw_adr);
+
+		PLTFM_SDIO_CMD52_W8(R_AX_CK_EN, (u8)val);
+		PLTFM_SDIO_CMD52_W8(R_AX_CK_EN + 1, (u8)(val >> 8));
+		PLTFM_SDIO_CMD52_W8(R_AX_CK_EN + 2, (u8)(val >> 16));
+		PLTFM_SDIO_CMD52_W8(R_AX_CK_EN + 3, (u8)(val >> 24));
+
+		count++;
+	}
+
+	return val32.byte[dw_sh];
+}
+
+u8 _r_indir_cmd52_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u8 tmp;
+	u32 cnt;
+
+	PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_ADDR, (u8)adr);
+	PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_ADDR + 1, (u8)(adr >> 8));
+	PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_ADDR + 2, (u8)(adr >> 16));
+	PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_ADDR + 3,
+			    (u8)((adr | B_AX_INDIRECT_RDY) >> 24));
+	PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_CTRL, (u8)B_AX_INDIRECT_REG_R);
+
+	cnt = SDIO_WAIT_CNT;
+	do {
+		tmp = PLTFM_SDIO_CMD52_R8(R_AX_SDIO_INDIRECT_ADDR + 3);
+		cnt--;
+	} while (((tmp & BIT(7)) == 0) && (cnt > 0));
+
+	if (((tmp & BIT(7)) == 0) && cnt == 0)
+		PLTFM_MSG_ERR("[ERR]sdio indirect CMD52 read\n");
+
+	return PLTFM_SDIO_CMD52_R8(R_AX_SDIO_INDIRECT_DATA);
+}
+
+u32 _r_indir_cmd53_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u8 val[12] = {0};
+	u32 cnt, i;
+
+	union {
+		__le32 dword;
+		u8 byte[4];
+	} value32 = { 0x00000000 };
+
+	for (i = 0; i < 3; i++)
+		*(val + i) = (u8)(adr >> (i << 3));
+	*(val + 3) = (u8)((adr | B_AX_INDIRECT_RDY) >> 24);
+	*(val + 8) = (u8)(B_AX_INDIRECT_REG_R);
+	PLTFM_SDIO_CMD53_WN(R_AX_SDIO_INDIRECT_ADDR, sizeof(val), val);
+
+	cnt = SDIO_WAIT_CNT;
+	do {
+		PLTFM_SDIO_CMD53_RN(R_AX_SDIO_INDIRECT_ADDR + 3, 8, val);
+		cnt--;
+	} while (((val[0] & BIT(7)) == 0) && (cnt > 0));
+
+	if (((val[0] & BIT(7)) == 0) && cnt == 0)
+		PLTFM_MSG_ERR("[ERR]sdio indirect CMD53 read\n");
+
+	value32.byte[0] = val[1];
+	value32.byte[1] = val[2];
+	value32.byte[2] = val[3];
+	value32.byte[3] = val[4];
+
+	return le32_to_cpu(value32.dword);
+}
+
+u32 r16_indir_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u8 pwr_state;
+	union {
+		__le32 dword;
+		u8 byte[4];
+	} val32 = { 0x00000000 };
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	pwr_state = pwr_state_chk_sdio(adapter);
+
+	if (pwr_state == SDIO_PWR_OFF) {
+		val32.byte[0] = p_ops->r_indir_cmd52_sdio(adapter, adr);
+		val32.byte[1] =
+			PLTFM_SDIO_CMD52_R8(R_AX_SDIO_INDIRECT_DATA + 1);
+		return  le32_to_cpu(val32.dword);
+	}
+
+	return r_indir_cmd53_sdio(adapter, adr);
+}
+
+u32 r32_indir_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr)
+{
+	u8 pwr_state;
+	union {
+		__le32 dword;
+		u8 byte[4];
+	} val32 = { 0x00000000 };
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	pwr_state = pwr_state_chk_sdio(adapter);
+
+	if (pwr_state == SDIO_PWR_OFF) {
+		val32.byte[0] = p_ops->r_indir_cmd52_sdio(adapter, adr);
+		val32.byte[1] =
+			PLTFM_SDIO_CMD52_R8(R_AX_SDIO_INDIRECT_DATA + 1);
+		val32.byte[2] =
+			PLTFM_SDIO_CMD52_R8(R_AX_SDIO_INDIRECT_DATA + 2);
+		val32.byte[3] =
+			PLTFM_SDIO_CMD52_R8(R_AX_SDIO_INDIRECT_DATA + 3);
+		return le32_to_cpu(val32.dword);
+	}
+
+	return r_indir_cmd53_sdio(adapter, adr);
+}
+
+void w_indir_cmd52_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr, u32 val,
+			      enum sdio_io_size size)
+{
+	u8 tmp;
+	u32 cnt;
+
+	PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_ADDR, (u8)adr);
+	PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_ADDR + 1, (u8)(adr >> 8));
+	PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_ADDR + 2, (u8)(adr >> 16));
+	PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_ADDR + 3,
+			    (u8)((adr | B_AX_INDIRECT_RDY) >> 24));
+	switch (size) {
+	case SDIO_IO_BYTE:
+		PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_DATA, (u8)val);
+		PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_CTRL,
+				    (u8)(B_AX_INDIRECT_REG_W));
+		break;
+	case SDIO_IO_WORD:
+		PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_DATA, (u8)val);
+		PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_DATA + 1,
+				    (u8)(val >> 8));
+		PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_CTRL,
+				    (u8)(B_AX_INDIRECT_REG_W | 0x1));
+		break;
+	case SDIO_IO_DWORD:
+		PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_DATA, (u8)val);
+		PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_DATA + 1,
+				    (u8)(val >> 8));
+		PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_DATA + 2,
+				    (u8)(val >> 16));
+		PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_DATA + 3,
+				    (u8)(val >> 24));
+		PLTFM_SDIO_CMD52_W8(R_AX_SDIO_INDIRECT_CTRL,
+				    (u8)(B_AX_INDIRECT_REG_W | 0x2));
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR]invalid IO size\n");
+		break;
+	}
+
+	cnt = SDIO_WAIT_CNT;
+	do {
+		tmp = PLTFM_SDIO_CMD52_R8(R_AX_SDIO_INDIRECT_ADDR + 3);
+		cnt--;
+	} while (((tmp & BIT(7)) == 0) && (cnt > 0));
+
+	if (((tmp & BIT(7)) == 0) && cnt == 0)
+		PLTFM_MSG_ERR("[ERR]sdio indirect CMD52 write\n");
+}
+
+void w_indir_cmd53_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr, u32 val,
+			      enum sdio_io_size size)
+{
+	u8 value[12] = {0};
+	u8 tmp;
+	u32 cnt, i;
+
+	switch (size) {
+	case SDIO_IO_BYTE:
+		*(value + 8) = (u8)B_AX_INDIRECT_REG_W;
+		break;
+	case SDIO_IO_WORD:
+		*(value + 8) = (u8)(B_AX_INDIRECT_REG_W | 0x1);
+		break;
+	case SDIO_IO_DWORD:
+		*(value + 8) = (u8)(B_AX_INDIRECT_REG_W | 0x2);
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR]invalid IO size\n");
+		break;
+	}
+
+	for (i = 0; i < 3; i++)
+		*(value + i) = (u8)(adr >> (i << 3));
+	*(value + 3) = (u8)((adr | B_AX_INDIRECT_RDY) >> 24);
+	for (i = 0; i < 4; i++)
+		*(value + i + 4) = (u8)(val >> (i << 3));
+	PLTFM_SDIO_CMD53_WN(R_AX_SDIO_INDIRECT_ADDR, sizeof(value), value);
+
+	cnt = SDIO_WAIT_CNT;
+	do {
+		tmp = PLTFM_SDIO_CMD52_R8(R_AX_SDIO_INDIRECT_ADDR + 3);
+		cnt--;
+	} while (((tmp & BIT(7)) == 0) && (cnt > 0));
+
+	if (((tmp & BIT(7)) == 0) && cnt == 0)
+		PLTFM_MSG_ERR("[ERR]sdio indirect CMD53 read\n");
+}
+
+void ud_fs_8852b(struct mac_ax_adapter *adapter)
+{
+	u8 val[28] = {0};
+	u32 fs0, fs1, fs2, fs3, fs4, fs5, fs6;
+	struct mac_ax_hfc_ch_info *ch_info = adapter->hfc_param->ch_info;
+	struct mac_ax_hfc_pub_info *pub_info = adapter->hfc_param->pub_info;
+
+	PLTFM_SDIO_CMD53_RN(R_AX_SDIO_TXPG_WP, sizeof(val), val);
+
+	fs0 = le32_to_cpu(*(u32 *)(val));
+	fs1 = le32_to_cpu(*(u32 *)(val + 4));
+	fs2 = le32_to_cpu(*(u32 *)(val + 8));
+	fs3 = le32_to_cpu(*(u32 *)(val + 12));
+	fs4 = le32_to_cpu(*(u32 *)(val + 16));
+	fs5 = le32_to_cpu(*(u32 *)(val + 20));
+	fs6 = le32_to_cpu(*(u32 *)(val + 24));
+
+	ch_info[MAC_AX_DMA_H2C].aval = GET_FIELD(fs0, B_AX_SDIO_ACH12_AVAL_PG);
+	pub_info->wp_aval = GET_FIELD(fs0, B_AX_SDIO_WP_AVAL_PG);
+	ch_info[MAC_AX_DMA_ACH0].used = GET_FIELD(fs1, B_AX_SDIO_ACH0_USE_PG);
+	ch_info[MAC_AX_DMA_ACH1].used = GET_FIELD(fs1, B_AX_SDIO_ACH1_USE_PG);
+	ch_info[MAC_AX_DMA_ACH2].used = GET_FIELD(fs2, B_AX_SDIO_ACH2_USE_PG);
+	ch_info[MAC_AX_DMA_ACH3].used = GET_FIELD(fs2, B_AX_SDIO_ACH3_USE_PG);
+	ch_info[MAC_AX_DMA_ACH4].used = GET_FIELD(fs3, B_AX_SDIO_ACH4_USE_PG);
+	ch_info[MAC_AX_DMA_ACH5].used = GET_FIELD(fs3, B_AX_SDIO_ACH5_USE_PG);
+	ch_info[MAC_AX_DMA_ACH6].used = GET_FIELD(fs4, B_AX_SDIO_ACH6_USE_PG);
+	ch_info[MAC_AX_DMA_ACH7].used = GET_FIELD(fs4, B_AX_SDIO_ACH7_USE_PG);
+	ch_info[MAC_AX_DMA_B0MG].used = GET_FIELD(fs5, B_AX_SDIO_ACH8_USE_PG);
+	ch_info[MAC_AX_DMA_B0HI].used = GET_FIELD(fs5, B_AX_SDIO_ACH9_USE_PG);
+	ch_info[MAC_AX_DMA_B1MG].used = GET_FIELD(fs6, B_AX_SDIO_ACH10_USE_PG);
+	ch_info[MAC_AX_DMA_B1HI].used = GET_FIELD(fs6, B_AX_SDIO_ACH11_USE_PG);
+}
+
+void rx_agg_cfg_sdio_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_rx_agg_cfg *cfg)
+{
+	u8 size;
+	u8 timeout;
+	u8 agg_en;
+	u8 pkt_num;
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (cfg->mode == MAC_AX_RX_AGG_MODE_DMA)
+		agg_en = 1;
+	else
+		agg_en = 0;
+
+	if (cfg->thold.drv_define == 0) {
+		size = 0xFF;
+		timeout = 0x01;
+		pkt_num = 0;
+	} else {
+		size = cfg->thold.size;
+		timeout = cfg->thold.timeout;
+		pkt_num = cfg->thold.pkt_num;
+	}
+
+	val32 = MAC_REG_R32(R_AX_RXAGG_0);
+	MAC_REG_W32(R_AX_RXAGG_0, (agg_en ? B_AX_RXAGG_EN : 0) |
+		    B_AX_RXAGG_DMA_STORE | (val32 & B_AX_RXAGG_SW_EN) |
+		    SET_WORD(pkt_num, B_AX_RXAGG_PKTNUM_TH) |
+		    SET_WORD(timeout, B_AX_RXAGG_TIMEOUT_TH) |
+		    SET_WORD(size, B_AX_RXAGG_LEN_TH));
+#define	SMALL_PKT_SIZE	1 /* 64 Byte */
+#define	SMALL_PKT_NUM	6
+	val32 = MAC_REG_R32(R_AX_RXAGG_1);
+	val32 = SET_CLR_WORD(val32, SMALL_PKT_SIZE, B_AX_RXAGG_SML_PKT_SIZE);
+	val32 = SET_CLR_WORD(val32, SMALL_PKT_NUM, B_AX_RXAGG_SML_PKTNUM_TH);
+	MAC_REG_W32(R_AX_RXAGG_1, val32);
+}
+
+void aval_page_cfg_sdio_8852b(struct mac_ax_adapter *adapter,
+			      struct mac_ax_aval_page_cfg *cfg)
+{
+	u32 val32;
+	struct mac_sdio_ch_thr ch_thr;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (cfg->ch_dma) {
+	case 0:
+		ch_thr.thr = R_AX_ACH0_THR;
+		ch_thr.intrpt_en = B_AX_ACH0_INTRPT_EN;
+		ch_thr.wp_sh = B_AX_ACH0_THR_WP_SH;
+		ch_thr.wp_msk = B_AX_ACH0_THR_WP_MSK;
+		ch_thr.wd_sh = B_AX_ACH0_THR_WD_SH;
+		ch_thr.wd_msk = B_AX_ACH0_THR_WD_MSK;
+		break;
+	case 1:
+		ch_thr.thr = R_AX_ACH1_THR;
+		ch_thr.intrpt_en = B_AX_ACH1_INTRPT_EN;
+		ch_thr.wp_sh = B_AX_ACH1_THR_WP_SH;
+		ch_thr.wp_msk = B_AX_ACH1_THR_WP_MSK;
+		ch_thr.wd_sh = B_AX_ACH1_THR_WD_SH;
+		ch_thr.wd_msk = B_AX_ACH1_THR_WD_MSK;
+		break;
+	case 2:
+		ch_thr.thr = R_AX_ACH2_THR;
+		ch_thr.intrpt_en = B_AX_ACH2_INTRPT_EN;
+		ch_thr.wp_sh = B_AX_ACH2_THR_WP_SH;
+		ch_thr.wp_msk = B_AX_ACH2_THR_WP_MSK;
+		ch_thr.wd_sh = B_AX_ACH2_THR_WD_SH;
+		ch_thr.wd_msk = B_AX_ACH2_THR_WD_MSK;
+		break;
+	case 3:
+		ch_thr.thr = R_AX_ACH3_THR;
+		ch_thr.intrpt_en = B_AX_ACH3_INTRPT_EN;
+		ch_thr.wp_sh = B_AX_ACH3_THR_WP_SH;
+		ch_thr.wp_msk = B_AX_ACH3_THR_WP_MSK;
+		ch_thr.wd_sh = B_AX_ACH3_THR_WD_SH;
+		ch_thr.wd_msk = B_AX_ACH3_THR_WD_MSK;
+		break;
+	case 4:
+		ch_thr.thr = R_AX_ACH4_THR;
+		ch_thr.intrpt_en = B_AX_ACH4_INTRPT_EN;
+		ch_thr.wp_sh = B_AX_ACH4_THR_WP_SH;
+		ch_thr.wp_msk = B_AX_ACH4_THR_WP_MSK;
+		ch_thr.wd_sh = B_AX_ACH4_THR_WD_SH;
+		ch_thr.wd_msk = B_AX_ACH4_THR_WD_MSK;
+		break;
+	case 5:
+		ch_thr.thr = R_AX_ACH5_THR;
+		ch_thr.intrpt_en = B_AX_ACH5_INTRPT_EN;
+		ch_thr.wp_sh = B_AX_ACH5_THR_WP_SH;
+		ch_thr.wp_msk = B_AX_ACH5_THR_WP_MSK;
+		ch_thr.wd_sh = B_AX_ACH5_THR_WD_SH;
+		ch_thr.wd_msk = B_AX_ACH5_THR_WD_MSK;
+		break;
+	case 6:
+		ch_thr.thr = R_AX_ACH6_THR;
+		ch_thr.intrpt_en = B_AX_ACH6_INTRPT_EN;
+		ch_thr.wp_sh = B_AX_ACH6_THR_WP_SH;
+		ch_thr.wp_msk = B_AX_ACH6_THR_WP_MSK;
+		ch_thr.wd_sh = B_AX_ACH6_THR_WD_SH;
+		ch_thr.wd_msk = B_AX_ACH6_THR_WD_MSK;
+		break;
+	case 7:
+		ch_thr.thr = R_AX_ACH7_THR;
+		ch_thr.intrpt_en = B_AX_ACH7_INTRPT_EN;
+		ch_thr.wp_sh = B_AX_ACH7_THR_WP_SH;
+		ch_thr.wp_msk = B_AX_ACH7_THR_WP_MSK;
+		ch_thr.wd_sh = B_AX_ACH7_THR_WD_SH;
+		ch_thr.wd_msk = B_AX_ACH7_THR_WD_MSK;
+		break;
+	case 8:
+		ch_thr.thr = R_AX_CH8_THR;
+		ch_thr.intrpt_en = B_AX_CH8_INTRPT_EN;
+		ch_thr.wp_sh = B_AX_CH8_THR_WP_SH;
+		ch_thr.wp_msk = B_AX_CH8_THR_WP_MSK;
+		ch_thr.wd_sh = B_AX_CH8_THR_WD_SH;
+		ch_thr.wd_msk = B_AX_CH8_THR_WD_MSK;
+		break;
+	case 9:
+		ch_thr.thr = R_AX_CH9_THR;
+		ch_thr.intrpt_en = B_AX_CH9_INTRPT_EN;
+		ch_thr.wp_sh = B_AX_CH9_THR_WP_SH;
+		ch_thr.wp_msk = B_AX_CH9_THR_WP_MSK;
+		ch_thr.wd_sh = B_AX_CH9_THR_WD_SH;
+		ch_thr.wd_msk = B_AX_CH9_THR_WD_MSK;
+		break;
+	case 10:
+		ch_thr.thr = R_AX_CH10_THR;
+		ch_thr.intrpt_en = B_AX_CH10_INTRPT_EN;
+		ch_thr.wp_sh = B_AX_CH10_THR_WP_SH;
+		ch_thr.wp_msk = B_AX_CH10_THR_WP_MSK;
+		ch_thr.wd_sh = B_AX_CH10_THR_WD_SH;
+		ch_thr.wd_msk = B_AX_CH10_THR_WD_MSK;
+		break;
+	case 11:
+		ch_thr.thr = R_AX_CH11_THR;
+		ch_thr.intrpt_en = B_AX_CH11_INTRPT_EN;
+		ch_thr.wp_sh = B_AX_CH11_THR_WP_SH;
+		ch_thr.wp_msk = B_AX_CH11_THR_WP_MSK;
+		ch_thr.wd_sh = B_AX_CH11_THR_WD_SH;
+		ch_thr.wd_msk = B_AX_CH11_THR_WD_MSK;
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR]invalid channel number\n");
+		return;
+	}
+
+	val32 = ((cfg->thold_wd & ch_thr.wd_msk) << ch_thr.wd_sh) |
+		((cfg->thold_wp & ch_thr.wp_msk) << ch_thr.wp_sh);
+	if (cfg->en)
+		val32 |= ch_thr.intrpt_en;
+	else
+		val32 &= ~ch_thr.intrpt_en;
+	MAC_REG_W32(ch_thr.thr, val32);
+}
+
+#endif /*MAC_AX_SDIO_SUPPORT*/
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_sdio_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_sdio_8852b.h
new file mode 100644
index 000000000000..a758d279427c
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_sdio_8852b.h
@@ -0,0 +1,352 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_SDIO_8852B_H_
+#define _MAC_AX_SDIO_8852B_H_
+
+#include "../_sdio.h"
+
+#if MAC_AX_8852B_SUPPORT
+#if MAC_AX_SDIO_SUPPORT
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief get_sdio_rx_req_len
+ *
+ * @param *adapter
+ * @param *rx_req_len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_sdio_rx_req_len_8852b(struct mac_ax_adapter *adapter, u32 *rx_req_len);
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief r_indir_cmd52_sdio_8852b
+ *
+ * @param *adapter
+ * @param adr
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 r_indir_cmd52_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr);
+
+/**
+ * @brief _r_indir_cmd52_sdio_8852b
+ *
+ * @param *adapter
+ * @param adr
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 _r_indir_cmd52_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr);
+
+/**
+ * @brief _r_indir_cmd53_sdio_8852b
+ *
+ * @param *adapter
+ * @param adr
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 _r_indir_cmd53_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr);
+
+/**
+ * @brief r16_indir_sdio_8852b
+ *
+ * @param *adapter
+ * @param adr
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 r16_indir_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr);
+
+/**
+ * @brief r32_indir_sdio_8852b
+ *
+ * @param *adapter
+ * @param adr
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 r32_indir_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr);
+
+/**
+ * @brief w_indir_cmd52_sdio_8852b
+ *
+ * @param *adapter
+ * @param adr
+ * @param val
+ * @param size
+ * @return Please Place Description here.
+ * @retval void
+ */
+void w_indir_cmd52_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr, u32 val,
+			      enum sdio_io_size size);
+
+/**
+ * @brief w_indir_cmd53_sdio_8852b
+ *
+ * @param *adapter
+ * @param adr
+ * @param val
+ * @param size
+ * @return Please Place Description here.
+ * @retval void
+ */
+void w_indir_cmd53_sdio_8852b(struct mac_ax_adapter *adapter, u32 adr, u32 val,
+			      enum sdio_io_size size);
+
+/**
+ * @brief ud_fs_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval void
+ */
+void ud_fs_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief sdio_pre_init_8852b
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 sdio_pre_init_8852b(struct mac_ax_adapter *adapter, void *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief tx_mode_cfg_sdio
+ *
+ * @param *adapter
+ * @param mode
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 tx_mode_cfg_sdio_8852b(struct mac_ax_adapter *adapter,
+			   enum mac_ax_sdio_tx_mode mode);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief leave_suspend_sdio_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 leave_suspend_sdio_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief get_int_latency_sdio_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_int_latency_sdio_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief get_clk_cnt_sdio_8852b
+ *
+ * @param *adapter
+ * @param *cnt
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_clk_cnt_sdio_8852b(struct mac_ax_adapter *adapter, u32 *cnt);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief set_wt_cfg_sdio_8852b
+ *
+ * @param *adapter
+ * @param en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_wt_cfg_sdio_8852b(struct mac_ax_adapter *adapter, u8 en);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief set_clk_mon_sdio_8852b
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_clk_mon_sdio_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_sdio_clk_mon_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief sdio_pwr_switch_8852b
+ *
+ * @param *vadapter
+ * @param pre_switch
+ * @param on
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 sdio_pwr_switch_8852b(void *vadapter, u8 pre_switch, u8 on);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief rx_agg_cfg_sdio_8852b
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval void
+ */
+void rx_agg_cfg_sdio_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_rx_agg_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup SDIO
+ * @{
+ */
+
+/**
+ * @brief aval_page_cfg_sdio_8852b
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval void
+ */
+void aval_page_cfg_sdio_8852b(struct mac_ax_adapter *adapter,
+			      struct mac_ax_aval_page_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+#endif /*MAC_AX_SDIO_SUPPORT*/
+#endif /* MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_usb_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_usb_8852b.c
new file mode 100644
index 000000000000..6948d93c1683
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_usb_8852b.c
@@ -0,0 +1,620 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "_usb_8852b.h"
+#include "../../mac_ax.h"
+#if MAC_AX_8852B_SUPPORT
+
+#if MAC_AX_USB_SUPPORT
+
+u8 reg_read8_usb_8852b(struct mac_ax_adapter *adapter, u32 addr)
+{
+	u8 offset, count = 0;
+	u32 val;
+
+	offset = addr % MAC_REG_OFFSET;
+	val = PLTFM_REG_R32(addr - offset);
+	if (addr >= R_AX_CMAC_FUNC_EN && addr < R_AX_CMAC_REG_END) {
+		while (count < MAC_REG_POOL_COUNT) {
+			if (val != MAC_AX_R32_DEAD)
+				break;
+
+			PLTFM_MSG_ERR("[ERR]addr 0x%x = 0xdeadbeef\n", addr + offset);
+			PLTFM_REG_W32(R_AX_CK_EN, CMAC_CLK_ALLEN);
+			val = PLTFM_REG_R32(addr);
+			count++;
+		}
+	}
+
+	return (u8)(val >> (offset * MAC_REG_OFFSET_SH));
+}
+
+void reg_write8_usb_8852b(struct mac_ax_adapter *adapter, u32 addr, u8 val)
+{
+	PLTFM_REG_W8(addr, val);
+}
+
+u16 reg_read16_usb_8852b(struct mac_ax_adapter *adapter, u32 addr)
+{
+	u8 offset, count = 0;
+	u32 val;
+
+	offset = addr % MAC_REG_OFFSET;
+	val = PLTFM_REG_R32(addr - offset);
+	if (addr >= R_AX_CMAC_FUNC_EN && addr < R_AX_CMAC_REG_END) {
+		while (count < MAC_REG_POOL_COUNT) {
+			if (val != MAC_AX_R32_DEAD)
+				break;
+
+			PLTFM_MSG_ERR("[ERR]addr 0x%x = 0xdeadbeef\n", addr + offset);
+			PLTFM_REG_W32(R_AX_CK_EN, CMAC_CLK_ALLEN);
+			val = PLTFM_REG_R32(addr);
+			count++;
+		}
+	}
+
+	return (u16)(val >> (offset * MAC_REG_OFFSET_SH));
+}
+
+void reg_write16_usb_8852b(struct mac_ax_adapter *adapter, u32 addr, u16 val)
+{
+	PLTFM_REG_W16(addr, val);
+}
+
+u32 reg_read32_usb_8852b(struct mac_ax_adapter *adapter, u32 addr)
+{
+	u8 count = 0;
+	u32 val = PLTFM_REG_R32(addr);
+
+	if (addr >= R_AX_CMAC_FUNC_EN && addr < R_AX_CMAC_REG_END) {
+		while (count < MAC_REG_POOL_COUNT) {
+			if (val != MAC_AX_R32_DEAD)
+				break;
+
+			PLTFM_MSG_ERR("[ERR]addr 0x%x = 0xdeadbeef\n", addr);
+			PLTFM_REG_W32(R_AX_CK_EN, CMAC_CLK_ALLEN);
+			val = PLTFM_REG_R32(addr);
+			count++;
+		}
+	}
+
+	return val;
+}
+
+void reg_write32_usb_8852b(struct mac_ax_adapter *adapter, u32 addr, u32 val)
+{
+	PLTFM_REG_W32(addr, val);
+}
+
+u8 get_bulkout_id_8852b(struct mac_ax_adapter *adapter, u8 ch_dma, u8 mode)
+{
+	u8 bulkout_id = 0;
+
+	if (mode == 0 && adapter->usb_info.ep5 && adapter->usb_info.ep6 &&
+	    adapter->usb_info.ep12) {
+		switch (ch_dma) {
+		case MAC_AX_DMA_ACH0:
+			bulkout_id = BULKOUTID3;
+			break;
+		case MAC_AX_DMA_ACH1:
+			bulkout_id = BULKOUTID4;
+			break;
+		case MAC_AX_DMA_ACH2:
+			bulkout_id = BULKOUTID5;
+			break;
+		case MAC_AX_DMA_ACH3:
+			bulkout_id = BULKOUTID6;
+			break;
+		case MAC_AX_DMA_B0MG:
+			bulkout_id = BULKOUTID0;
+			break;
+		case MAC_AX_DMA_B0HI:
+			bulkout_id = BULKOUTID1;
+			break;
+		case MAC_AX_DMA_H2C:
+			bulkout_id = BULKOUTID2;
+			break;
+		default:
+			return USBEPMAPERR;
+		}
+	} else if ((mode == 1) && adapter->usb_info.ep5 &&
+			adapter->usb_info.ep6 && adapter->usb_info.ep12) {
+		switch (ch_dma) {
+		case MAC_AX_DMA_ACH0:
+			bulkout_id = BULKOUTID2;
+			break;
+		case MAC_AX_DMA_ACH1:
+			bulkout_id = BULKOUTID3;
+			break;
+		case MAC_AX_DMA_ACH2:
+			bulkout_id = BULKOUTID4;
+			break;
+		case MAC_AX_DMA_ACH3:
+			bulkout_id = BULKOUTID5;
+			break;
+		case MAC_AX_DMA_B0MG:
+		case MAC_AX_DMA_B0HI:
+			bulkout_id = BULKOUTID0;
+			break;
+		case MAC_AX_DMA_H2C:
+			bulkout_id = BULKOUTID2;
+			break;
+		default:
+			bulkout_id = USBEPMAPERR;
+		}
+	} else {
+		bulkout_id = USBEPMAPERR;
+	}
+	return bulkout_id;
+}
+
+u32 usb_pre_init_8852b(struct mac_ax_adapter *adapter, void *param)
+{
+	u32 val32 = 0;
+
+	val32 = PLTFM_REG_R32(R_AX_USB_HOST_REQUEST_2) | B_AX_R_USBIO_MODE;
+	PLTFM_REG_W32(R_AX_USB_HOST_REQUEST_2, val32);
+	// fix USB IO hang suggest by chihhanli@realtek.com
+	val32 = PLTFM_REG_R32(R_AX_USB_WLAN0_1) & ~B_AX_USBRX_RST & ~B_AX_USBTX_RST;
+	PLTFM_REG_W32(R_AX_USB_WLAN0_1, val32);
+
+	val32 = PLTFM_REG_R32(R_AX_HCI_FUNC_EN);
+	val32 &= ~B_AX_HCI_RXDMA_EN;
+	val32 &= ~B_AX_HCI_TXDMA_EN;
+	PLTFM_REG_W32(R_AX_HCI_FUNC_EN, val32);
+	val32 |= B_AX_HCI_RXDMA_EN;
+	val32 |= B_AX_HCI_TXDMA_EN;
+	PLTFM_REG_W32(R_AX_HCI_FUNC_EN, val32);
+	// fix USB TRX hang suggest by chihhanli@realtek.com
+
+	val32 = PLTFM_REG_R32(R_AX_USB_ENDPOINT_3);
+	if ((val32 & B_AX_BULKOUT0) == B_AX_BULKOUT0)
+		adapter->usb_info.ep5 = ENABLE;
+	if ((val32 & B_AX_BULKOUT1) == B_AX_BULKOUT1)
+		adapter->usb_info.ep6 = ENABLE;
+	if (((PLTFM_REG_R32(R_AX_USB_ENDPOINT_3) >> B_AX_AC_BULKOUT_SH) &
+		B_AX_AC_BULKOUT_MSK) == 1)
+		adapter->usb_info.ep10 = ENABLE;
+	if (((PLTFM_REG_R32(R_AX_USB_ENDPOINT_3) >> B_AX_AC_BULKOUT_SH) &
+		B_AX_AC_BULKOUT_MSK) == 2) {
+		adapter->usb_info.ep10 = ENABLE;
+		adapter->usb_info.ep11 = ENABLE;
+	}
+	if (((PLTFM_REG_R32(R_AX_USB_ENDPOINT_3) >> B_AX_AC_BULKOUT_SH) &
+		B_AX_AC_BULKOUT_MSK) == 3) {
+		adapter->usb_info.ep10 = ENABLE;
+		adapter->usb_info.ep11 = ENABLE;
+		adapter->usb_info.ep12 = ENABLE;
+	}
+	return MACSUCCESS;
+}
+
+u32 usb_init_8852b(struct mac_ax_adapter *adapter, void *param)
+{
+	u32 val32;
+	u8 val8;
+
+	adapter->usb_info.max_bulkout_wd_num = (u8)GET_FIELD
+		(PLTFM_REG_R32(R_AX_CH_PAGE_CTRL), B_AX_PREC_PAGE_CH011);
+	adapter->usb_info.max_dma_txagg_msk = AX_TXD_CH_DMA_MSK;
+
+	val32 = PLTFM_REG_R32(R_AX_USB3_MAC_NPI_CONFIG_INTF_0);
+	val32 &= ~B_AX_SSPHY_LFPS_FILTER;
+	PLTFM_REG_W32(R_AX_USB3_MAC_NPI_CONFIG_INTF_0, val32);
+
+	/* else if (is_cv(adapter, CBV) &&
+	 *    is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+	 *	val32 = PLTFM_REG_R32(R_AX_USB3_MAC_LINK_0);
+	 *	val32 &= ~B_AX_R_DIS_USB3_U1_EN;
+	 *	val32 &= ~B_AX_R_DIS_USB3_U2_EN;
+	 *	PLTFM_REG_W32(R_AX_USB3_MAC_LINK_0, val32);
+	 *} else {
+	 *	val32 = PLTFM_REG_R32(R_AX_USB3_MAC_LINK_0);
+	 *	val32 |= B_AX_R_DIS_USB3_U1_EN;
+	 *	val32 |= B_AX_R_DIS_USB3_U2_EN;
+	 *	PLTFM_REG_W32(R_AX_USB3_MAC_LINK_0, val32);
+	 *}
+	 */
+	val32 = get_usb_mode(adapter);
+	if (val32 == MAC_AX_USB3)
+		PLTFM_REG_W8(R_AX_RXDMA_SETTING, USB3_BULKSIZE);
+	else if (val32 == MAC_AX_USB2)
+		PLTFM_REG_W8(R_AX_RXDMA_SETTING, USB2_BULKSIZE);
+	else if (val32 == MAC_AX_USB11)
+		PLTFM_REG_W8(R_AX_RXDMA_SETTING, USB11_BULKSIZE);
+	else
+		return MACHWNOSUP;
+
+	val8 = PLTFM_REG_R8(R_AX_USB_ENDPOINT_0);
+	val8 = SET_CLR_WORD(val8, EP5, B_AX_EP_IDX);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_0, val8);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_2 + 1, NUMP);
+	val8 = PLTFM_REG_R8(R_AX_USB_ENDPOINT_0);
+	val8 = SET_CLR_WORD(val8, EP6, B_AX_EP_IDX);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_0, val8);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_2 + 1, NUMP);
+	val8 = PLTFM_REG_R8(R_AX_USB_ENDPOINT_0);
+	val8 = SET_CLR_WORD(val8, EP7, B_AX_EP_IDX);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_0, val8);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_2 + 1, NUMP);
+	val8 = PLTFM_REG_R8(R_AX_USB_ENDPOINT_0);
+	val8 = SET_CLR_WORD(val8, EP9, B_AX_EP_IDX);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_0, val8);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_2 + 1, NUMP);
+	val8 = PLTFM_REG_R8(R_AX_USB_ENDPOINT_0);
+	val8 = SET_CLR_WORD(val8, EP10, B_AX_EP_IDX);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_0, val8);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_2 + 1, NUMP);
+	val8 = PLTFM_REG_R8(R_AX_USB_ENDPOINT_0);
+	val8 = SET_CLR_WORD(val8, EP11, B_AX_EP_IDX);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_0, val8);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_2 + 1, NUMP);
+	val8 = PLTFM_REG_R8(R_AX_USB_ENDPOINT_0);
+	val8 = SET_CLR_WORD(val8, EP12, B_AX_EP_IDX);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_0, val8);
+	PLTFM_REG_W8(R_AX_USB_ENDPOINT_2 + 1, NUMP);
+	return MACSUCCESS;
+}
+
+u32 usb_deinit_8852b(struct mac_ax_adapter *adapter, void *param)
+{
+	return MACSUCCESS;
+}
+
+u32 read_usb2phy_para_8852b(struct mac_ax_adapter *adapter, u16 offset)
+{
+	u32 value32 = 0;
+	u8 rdata = 0;
+
+	value32 = SET_CLR_WORD(value32, offset - phyoffset,
+			       B_AX_USB_SIE_INTF_ADDR);
+	value32 |= B_AX_USB_REG_SEL;
+	value32 |= B_AX_USB_REG_EN;
+	value32 |= B_AX_USB_REG_STATUS;
+	PLTFM_REG_W32(R_AX_USB_SIE_INTF, value32);
+
+	while (PLTFM_REG_R32(R_AX_USB_SIE_INTF) & B_AX_USB_REG_EN)
+		;
+
+	rdata = GET_FIELD(PLTFM_REG_R32(R_AX_USB_SIE_INTF),
+			  B_AX_USB_SIE_INTF_RD);
+
+	//DD-Yingli suggest that shall clear it if read operation is done.
+	PLTFM_REG_W32(R_AX_USB_SIE_INTF, 0);
+	return rdata;
+}
+
+u32 write_usb2phy_para_8852b(struct mac_ax_adapter *adapter, u16 offset, u8 val)
+{
+	u32 value32 = 0;
+
+	value32 = SET_CLR_WORD(value32, val, B_AX_USB_SIE_INTF_WD);
+	value32 = SET_CLR_WORD(value32, offset, B_AX_USB_SIE_INTF_ADDR);
+	value32 |= B_AX_USB_REG_SEL;
+	value32 |= B_AX_USB_WRITE_EN;
+	value32 |= B_AX_USB_REG_EN;
+	value32 |= B_AX_USB_REG_STATUS;
+
+	PLTFM_REG_W32(R_AX_USB_SIE_INTF, value32);
+	while (PLTFM_REG_R32(R_AX_USB_SIE_INTF) & B_AX_USB_REG_EN)
+		;
+
+	//DD-Yingli suggest that shall clear it if write operation is done.
+	PLTFM_REG_W32(R_AX_USB_SIE_INTF, 0);
+
+	return MACSUCCESS;
+}
+
+u32 static polling_usb_sie_ready(struct mac_ax_adapter *adapter)
+{
+#define MAC_AX_POLL_SIE_CNT 1000
+#define MAC_AX_POLL_SIE_WAIT_US 50
+	u32 cnt = MAC_AX_POLL_SIE_CNT;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	while (cnt--) {
+		if (!(MAC_REG_R32(R_AX_USB_SIE_INTF) & B_AX_USB_REG_EN))
+			return MACSUCCESS;
+		PLTFM_DELAY_US(MAC_AX_POLL_SIE_WAIT_US);
+	}
+
+	PLTFM_MSG_ERR("%s: polling SIE timeout\n", __func__);
+
+	return MACPOLLTO;
+}
+
+u32 read_usb3phy_para_8852b(struct mac_ax_adapter *adapter, u16 offset, u8 b_sel)
+{
+	u32 value32 = 0, ret;
+	u16 rdata = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	value32 = SET_CLR_WORD(value32, offset + USBPHYOFFSET,
+			       B_AX_USB_SIE_INTF_ADDR);
+	value32 |= B_AX_USB_REG_SEL;
+	value32 |= B_AX_USB_REG_SEL;
+	value32 |= B_AX_USB_REG_EN;
+	if (b_sel)
+		value32 |= B_AX_USB_PHY_BYTE_SEL;
+
+	MAC_REG_W32(R_AX_USB_SIE_INTF, value32);
+	ret = polling_usb_sie_ready(adapter);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("%s: polling timeout\n");
+	rdata = GET_FIELD(PLTFM_REG_R32(R_AX_USB_SIE_INTF),
+			  B_AX_USB_SIE_INTF_RD);
+
+	return rdata;
+}
+
+u32 write_usb3phy_para_8852b(struct mac_ax_adapter *adapter,
+			     u16 offset, u8 b_sel, u8 val)
+{
+	u32 value32 = 0, ret;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	value32 = SET_CLR_WORD(value32, val, B_AX_USB_SIE_INTF_WD);
+	value32 = SET_CLR_WORD(value32, offset + USBPHYOFFSET,
+			       B_AX_USB_SIE_INTF_ADDR);
+	value32 |= B_AX_USB_REG_SEL;
+	value32 |= B_AX_USB_REG_SEL;
+	value32 |= B_AX_USB_WRITE_EN;
+	value32 |= B_AX_USB_REG_EN;
+	if (b_sel)
+		value32 |= B_AX_USB_PHY_BYTE_SEL;
+	MAC_REG_W32(R_AX_USB_SIE_INTF, value32);
+
+	ret = polling_usb_sie_ready(adapter);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("%s: polling timeout\n");
+
+	return ret;
+}
+
+u32 u2u3_switch_8852b(struct mac_ax_adapter *adapter)
+{
+	u32 ret = 0;
+
+	PLTFM_REG_W8(R_AX_PAD_CTRL2 + 1, USB_SWITCH_DELAY);
+	ret = get_usb_mode(adapter);
+	if (ret == MAC_AX_USB2)
+		PLTFM_REG_W8(R_AX_PAD_CTRL2 + 2, U2SWITCHU3);
+	else if (ret == MAC_AX_USB3)
+		PLTFM_REG_W8(R_AX_PAD_CTRL2 + 2, U3SWITCHU2);
+	else
+		PLTFM_REG_W8(R_AX_PAD_CTRL2 + 2, U2SWITCHU3);
+
+	return MACSUCCESS;
+}
+
+u32 get_usb_support_ability_8852b(struct mac_ax_adapter *adapter)
+{
+	u32 u2force = 0;
+	u32 u3force = 0;
+
+	u2force = PLTFM_REG_R32(R_AX_USB_HOST_REQUEST_2) &
+		  B_AX_R_FORCE_U3MAC_HS_MODE;
+	u3force = PLTFM_REG_R32(R_AX_PAD_CTRL2) &
+		  B_AX_USB3_USB2_TRANSITION;
+
+	if (u2force == B_AX_R_FORCE_U3MAC_HS_MODE)
+		return FORCEUSB2MODE;
+	else if (u3force == B_AX_USB3_USB2_TRANSITION)
+		return SWITCHMODE;
+	else
+		return FORCEUSB3MODE;
+}
+
+u32 usb_tx_agg_cfg_8852b(struct mac_ax_adapter *adapter,
+			 struct mac_ax_usb_tx_agg_cfg *agg)
+{
+	u32 dw1 = ((struct wd_body_usb_8852b *)agg->pkt)->dword1;
+
+	((struct wd_body_usb_8852b *)agg->pkt)->dword1 =
+		SET_CLR_WORD(dw1, agg->agg_num, AX_TXD_DMA_TXAGG_NUM);
+	return MACSUCCESS;
+}
+
+u32 usb_rx_agg_cfg_8852b(struct mac_ax_adapter *adapter,
+			 struct mac_ax_rx_agg_cfg *cfg)
+{
+	u8 size;
+	u8 timeout;
+	u8 agg_en;
+	u8 agg_mode;
+	u8 pkt_num;
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	/* size unit was 4k in 8852A|B|51B */
+#define COMPAT_RX_AGG_UNIT 4
+	if (cfg->mode == MAC_AX_RX_AGG_MODE_DMA) {
+		agg_en = ENABLE;
+		agg_mode = ENABLE;
+	} else if (cfg->mode == MAC_AX_RX_AGG_MODE_USB) {
+		agg_en = ENABLE;
+		agg_mode = DISABLE;
+	} else {
+		agg_en = DISABLE;
+		agg_mode = DISABLE;
+	}
+
+	if (cfg->thold.drv_define == 0) {
+		/* unit: 4k */
+		size = RXAGGSIZE;
+		timeout = RXAGGTO;
+		pkt_num = 0;
+	} else {
+		size = cfg->thold.size / COMPAT_RX_AGG_UNIT;
+		timeout = cfg->thold.timeout;
+		pkt_num = cfg->thold.pkt_num;
+	}
+
+	val32 = MAC_REG_R32(R_AX_RXAGG_0);
+	MAC_REG_W32(R_AX_RXAGG_0, (agg_en ? B_AX_RXAGG_EN : 0) |
+		    (agg_mode ? B_AX_RXAGG_DMA_STORE : 0) |
+		    (val32 & B_AX_RXAGG_SW_EN) |
+		    SET_WORD(pkt_num, B_AX_RXAGG_PKTNUM_TH) |
+		    SET_WORD(timeout, B_AX_RXAGG_TIMEOUT_TH) |
+		    SET_WORD(size, B_AX_RXAGG_LEN_TH));
+#undef COMPAT_RX_AGG_UNIT
+
+	return MACSUCCESS;
+}
+
+u32 usb_pwr_switch_8852b(void *vadapter, u8 pre_switch, u8 on)
+{
+	return MACSUCCESS;
+}
+
+u32 set_usb_wowlan_8852b(struct mac_ax_adapter *adapter,
+			 enum mac_ax_wow_ctrl w_c)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (w_c == MAC_AX_WOW_ENTER) {
+		PLTFM_REG_W32(R_AX_USB2_LPM_0, PLTFM_REG_R32(R_AX_USB2_LPM_0) |
+			      B_AX_USB_SUS_WAKEUP_EN);
+		MAC_REG_W32(R_AX_RSV_CTRL, MAC_REG_R32(R_AX_RSV_CTRL) |
+			    B_AX_WLOCK_1C_BIT6);
+		MAC_REG_W32(R_AX_RSV_CTRL, MAC_REG_R32(R_AX_RSV_CTRL) |
+			    B_AX_R_DIS_PRST);
+		MAC_REG_W32(R_AX_RSV_CTRL, MAC_REG_R32(R_AX_RSV_CTRL) &
+			    ~B_AX_WLOCK_1C_BIT6);
+	} else if (w_c == MAC_AX_WOW_LEAVE) {
+		MAC_REG_W32(R_AX_RSV_CTRL, MAC_REG_R32(R_AX_RSV_CTRL) |
+			    B_AX_WLOCK_1C_BIT6);
+		MAC_REG_W32(R_AX_RSV_CTRL, MAC_REG_R32(R_AX_RSV_CTRL) &
+			    ~B_AX_R_DIS_PRST);
+		MAC_REG_W32(R_AX_RSV_CTRL, MAC_REG_R32(R_AX_RSV_CTRL) &
+			    ~B_AX_WLOCK_1C_BIT6);
+	} else {
+		PLTFM_MSG_ERR("[ERR] Invalid WoWLAN input.\n");
+		return MACFUNCINPUT;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 usb_get_txagg_num_8852b(struct mac_ax_adapter *adapter, u8 band)
+{
+	u32 quotanum = band ? adapter->dle_info.c1_tx_max : adapter->dle_info.c0_tx_max;
+
+	return quotanum * PLE_PAGE_SIZE / (PINGPONG * (SINGLE_MSDU_SIZE + SEC_FCS_SIZE));
+}
+
+u32 usb_get_rx_state_8852b(struct mac_ax_adapter *adapter, u32 *val)
+{
+	u8 rxdma_cnt, ep_cnt, curr_rxdma_cnt, curr_ep_cnt;
+	*val = 0;
+	rxdma_cnt = GET_FIELD(PLTFM_REG_R32(R_AX_USB_DEBUG_1), B_AX_RXDMA_DMA_COUNTER);
+	ep_cnt = GET_FIELD(PLTFM_REG_R32(R_AX_USB_DEBUG_1), B_AX_RXDMA_ENDPOINT_COUNTER);
+	PLTFM_DELAY_MS(RX_POLLING_PERIOD);
+	curr_rxdma_cnt = GET_FIELD(PLTFM_REG_R32(R_AX_USB_DEBUG_1), B_AX_RXDMA_DMA_COUNTER);
+	curr_ep_cnt = GET_FIELD(PLTFM_REG_R32(R_AX_USB_DEBUG_1), B_AX_RXDMA_ENDPOINT_COUNTER);
+	if (curr_rxdma_cnt == rxdma_cnt)
+		return MACRXDMAHANG;
+	else if (curr_ep_cnt == ep_cnt)
+		return MACUSBRXHANG;
+	else
+		return MACSUCCESS;
+}
+
+u32 usb_ep_cfg_8852b(struct mac_ax_adapter *adapter, struct mac_ax_usb_ep *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ep_cfg, cnt, ep_sts;
+
+	if (!cfg)
+		return MACNPTR;
+	ep_cfg = MAC_REG_R32(R_AX_USB_ENDPOINT_3);
+	ep_sts = ep_cfg;
+	if (cfg->ep4) {
+		ep_cfg |= B_AX_EP4_RX_PAUSE;
+		ep_sts |= (B_AX_EP4_RX_PAUSE | B_AX_EP4_PAUSE_STATE);
+	} else {
+		ep_cfg &= ~B_AX_EP4_RX_PAUSE;
+		ep_sts &= (~B_AX_EP4_RX_PAUSE & ~B_AX_EP4_PAUSE_STATE);
+	}
+	if (cfg->ep5) {
+		ep_cfg |= B_AX_EP5_TX_PAUSE;
+		ep_sts |= (B_AX_EP5_TX_PAUSE | B_AX_EP5_PAUSE_STATE);
+	} else {
+		ep_cfg &= ~B_AX_EP5_TX_PAUSE;
+		ep_sts &= (~B_AX_EP5_TX_PAUSE & ~B_AX_EP5_PAUSE_STATE);
+	}
+	if (cfg->ep6) {
+		ep_cfg |= B_AX_EP6_TX_PAUSE;
+		ep_sts |= (B_AX_EP6_TX_PAUSE | B_AX_EP6_PAUSE_STATE);
+	} else {
+		ep_cfg &= ~B_AX_EP6_TX_PAUSE;
+		ep_sts &= (~B_AX_EP6_TX_PAUSE & ~B_AX_EP6_PAUSE_STATE);
+	}
+	if (cfg->ep7) {
+		ep_cfg |= B_AX_EP7_TX_PAUSE;
+		ep_sts |= (B_AX_EP7_TX_PAUSE | B_AX_EP7_PAUSE_STATE);
+	} else {
+		ep_cfg &= ~B_AX_EP7_TX_PAUSE_V1;
+		ep_sts &= (~B_AX_EP7_TX_PAUSE & ~B_AX_EP7_PAUSE_STATE);
+	}
+	if (cfg->ep8) {
+		ep_cfg |= B_AX_EP8_RX_PAUSE;
+		ep_sts |= (B_AX_EP8_RX_PAUSE | B_AX_EP8_PAUSE_STATE);
+	} else {
+		ep_cfg &= ~B_AX_EP8_RX_PAUSE;
+		ep_sts &= (~B_AX_EP8_RX_PAUSE & ~B_AX_EP8_PAUSE_STATE);
+	}
+	if (cfg->ep9) {
+		ep_cfg |= B_AX_EP9_TX_PAUSE;
+		ep_sts |= (B_AX_EP9_TX_PAUSE | B_AX_EP9_PAUSE_STATE);
+	} else {
+		ep_cfg &= ~B_AX_EP9_TX_PAUSE;
+		ep_sts &= (~B_AX_EP9_TX_PAUSE & ~B_AX_EP9_PAUSE_STATE);
+	}
+	if (cfg->ep10) {
+		ep_cfg |= B_AX_EP10_TX_PAUSE;
+		ep_sts |= (B_AX_EP10_TX_PAUSE | B_AX_EP10_PAUSE_STATE);
+	} else {
+		ep_cfg &= ~B_AX_EP10_TX_PAUSE;
+		ep_sts &= (~B_AX_EP10_TX_PAUSE & ~B_AX_EP10_PAUSE_STATE);
+	}
+	if (cfg->ep11) {
+		ep_cfg |= B_AX_EP11_TX_PAUSE;
+		ep_sts |= (B_AX_EP11_TX_PAUSE | B_AX_EP11_PAUSE_STATE);
+	} else {
+		ep_cfg &= ~B_AX_EP11_TX_PAUSE;
+		ep_sts &= (~B_AX_EP11_TX_PAUSE & ~B_AX_EP11_PAUSE_STATE);
+	}
+	if (cfg->ep12) {
+		ep_cfg |= B_AX_EP12_TX_PAUSE;
+		ep_sts |= (B_AX_EP12_TX_PAUSE | B_AX_EP12_PAUSE_STATE);
+	} else {
+		ep_cfg &= ~B_AX_EP12_TX_PAUSE;
+		ep_sts &= (~B_AX_EP12_TX_PAUSE & ~B_AX_EP12_PAUSE_STATE);
+	}
+	MAC_REG_W32(R_AX_USB_ENDPOINT_3, ep_cfg);
+
+	cnt = 2000;
+	while (cnt--) {
+		if (ep_sts == PLTFM_REG_R32(R_AX_USB_ENDPOINT_3))
+			break;
+		PLTFM_DELAY_US(1);
+	}
+	if (cnt == 0)
+		return MACUSBPAUSEERR;
+
+	return MACSUCCESS;
+}
+#endif /* #if MAC_AX_USB_SUPPORT */
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_usb_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_usb_8852b.h
new file mode 100644
index 000000000000..a85012725ac6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/_usb_8852b.h
@@ -0,0 +1,538 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_USB_8852B_H_
+#define _MAC_AX_USB_8852B_H_
+
+#include "../../type.h"
+#include "../_usb.h"
+#if MAC_AX_8852B_SUPPORT
+
+/**
+ * @struct wd_body_usb
+ * @brief wd_body_usb
+ *
+ * @var wd_body_usb::dword0
+ * Please Place Description here.
+ * @var wd_body_usb::dword1
+ * Please Place Description here.
+ * @var wd_body_usb::dword2
+ * Please Place Description here.
+ * @var wd_body_usb::dword3
+ * Please Place Description here.
+ * @var wd_body_usb::dword4
+ * Please Place Description here.
+ * @var wd_body_usb::dword5
+ * Please Place Description here.
+ */
+struct wd_body_usb_8852b {
+	u32 dword0;
+	u32 dword1;
+	u32 dword2;
+	u32 dword3;
+	u32 dword4;
+	u32 dword5;
+};
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup BasicIO
+ * @{
+ */
+/**
+ * @brief reg_read8_usb_8852b
+ *
+ * @param *adapter
+ * @param addr
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 reg_read8_usb_8852b(struct mac_ax_adapter *adapter, u32 addr);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup BasicIO
+ * @{
+ */
+
+/**
+ * @brief reg_write8_usb_8852b
+ *
+ * @param *adapter
+ * @param addr
+ * @param val
+ * @return Please Place Description here.
+ * @retval void
+ */
+void reg_write8_usb_8852b(struct mac_ax_adapter *adapter,
+			  u32 addr, u8 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup BasicIO
+ * @{
+ */
+
+/**
+ * @brief reg_read16_usb_8852b
+ *
+ * @param *adapter
+ * @param addr
+ * @return Please Place Description here.
+ * @retval u16
+ */
+u16 reg_read16_usb_8852b(struct mac_ax_adapter *adapter, u32 addr);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup BasicIO
+ * @{
+ */
+
+/**
+ * @brief reg_write16_usb_8852b
+ *
+ * @param *adapter
+ * @param addr
+ * @param val
+ * @return Please Place Description here.
+ * @retval void
+ */
+void reg_write16_usb_8852b(struct mac_ax_adapter *adapter, u32 addr, u16 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup BasicIO
+ * @{
+ */
+
+/**
+ * @brief reg_read32_usb_8852b
+ *
+ * @param *adapter
+ * @param addr
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 reg_read32_usb_8852b(struct mac_ax_adapter *adapter, u32 addr);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup BasicIO
+ * @{
+ */
+
+/**
+ * @brief reg_write32_usb_8852b
+ *
+ * @param *adapter
+ * @param addr
+ * @param val
+ * @return Please Place Description here.
+ * @retval void
+ */
+void reg_write32_usb_8852b(struct mac_ax_adapter *adapter, u32 addr, u32 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief get_bulkout_id_8852b
+ *
+ * @param *adapter
+ * @param ch_dma
+ * @param mode
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 get_bulkout_id_8852b(struct mac_ax_adapter *adapter, u8 ch_dma, u8 mode);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief usb_pre_init_8852b
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 usb_pre_init_8852b(struct mac_ax_adapter *adapter, void *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief usb_init_8852b
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 usb_init_8852b(struct mac_ax_adapter *adapter, void *param);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief usb_deinit_8852b
+ *
+ * @param *adapter
+ * @param *param
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 usb_deinit_8852b(struct mac_ax_adapter *adapter, void *param);
+
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief read_usb2phy_para_8852b
+ *
+ * @param *adapter
+ * @param offset
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 read_usb2phy_para_8852b(struct mac_ax_adapter *adapter, u16 offset);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief write_usb2phy_para_8852b
+ *
+ * @param *adapter
+ * @param offset
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 write_usb2phy_para_8852b(struct mac_ax_adapter *adapter, u16 offset, u8 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief read_usb3phy_para_8852b
+ *
+ * @param *adapter
+ * @param offset
+ * @param b_sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 read_usb3phy_para_8852b(struct mac_ax_adapter *adapter,
+			    u16 offset, u8 b_sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief write_usb3phy_para_8852b
+ *
+ * @param *adapter
+ * @param offset
+ * @param b_sel
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 write_usb3phy_para_8852b(struct mac_ax_adapter *adapter, u16 offset,
+			     u8 b_sel, u8 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief u2u3_switch_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 u2u3_switch_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+ /**
+  * @addtogroup HCI
+  * @{
+  * @addtogroup USB
+  * @{
+  */
+
+/**
+ * @brief get_usb_support_ability_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_usb_support_ability_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief usb_tx_agg_cfg_8852b
+ *
+ * @param *adapter
+ * @param *agg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 usb_tx_agg_cfg_8852b(struct mac_ax_adapter *adapter,
+			 struct mac_ax_usb_tx_agg_cfg *agg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief usb_rx_agg_cfg_8852b
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 usb_rx_agg_cfg_8852b(struct mac_ax_adapter *adapter,
+			 struct mac_ax_rx_agg_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief usb_pwr_switch_8852b
+ *
+ * @param *vadapter
+ * @param pre_switch
+ * @param on
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 usb_pwr_switch_8852b(void *vadapter,
+			 u8 pre_switch, u8 on);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief set_usb_wowlan_8852b
+ *
+ * @param *adapter
+ * @param w_c
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_usb_wowlan_8852b(struct mac_ax_adapter *adapter,
+			 enum mac_ax_wow_ctrl w_c);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief usb_get_txagg_num_88852b
+ *
+ * @param *adapter
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 usb_get_txagg_num_8852b(struct mac_ax_adapter *adapter, u8 band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup HCI
+ * @{
+ * @addtogroup USB
+ * @{
+ */
+
+/**
+ * @brief usb_get_rx_state_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 usb_get_rx_state_8852b(struct mac_ax_adapter *adapter, u32 *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief usb_ep_cfg_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @param *cfg
+ */
+u32 usb_ep_cfg_8852b(struct mac_ax_adapter *adapter, struct mac_ax_usb_ep *cfg);
+/**
+ * @}
+ * @}
+ */
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/cmac_tx_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/cmac_tx_8852b.c
new file mode 100644
index 000000000000..9a1ae5ceeed7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/cmac_tx_8852b.c
@@ -0,0 +1,136 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "cmac_tx_8852b.h"
+#include "../cmac_tx.h"
+#include "../../mac_reg.h"
+#if MAC_AX_8852B_SUPPORT
+
+#define PTCL_TXQ_TB		16
+
+#define TX_EN_CTRL_ALL		0xFFFF
+
+u32 macid_idle_ck_8852b(struct mac_ax_adapter *adapter,
+			struct mac_role_tbl *role)
+{
+	u32 cnt;
+	u8 val8;
+	u32 ret;
+	u8 band;
+	u32 val32;
+	u8 macid;
+	u8 txq;
+	u32 poll_addr;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	band = role->info.band;
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	poll_addr = R_AX_PTCL_TX_CTN_SEL;
+
+	val8 = MAC_REG_R8(poll_addr);
+	if (val8 & B_AX_PTCL_TX_ON_STAT)
+		tx_on_dly(adapter, band);
+	else
+		return MACSUCCESS;
+
+	macid = role->macid;
+
+	cnt = PTCL_IDLE_POLL_CNT;
+	while (--cnt) {
+		val8 = MAC_REG_R8(poll_addr);
+		txq = GET_FIELD(val8, B_AX_PTCL_TX_QUEUE_IDX);
+		if ((val8 & B_AX_PTCL_TX_ON_STAT) && (val8 & B_AX_PTCL_DROP)) {
+			PLTFM_DELAY_US(SW_CVR_DUR_US);
+		} else if ((val8 & B_AX_PTCL_TX_ON_STAT) &&
+			   txq != PTCL_TXQ_HIQ && txq != PTCL_TXQ_BCNQ &&
+			   txq != PTCL_TXQ_MG0 && txq != PTCL_TXQ_MG1 &&
+			   txq != PTCL_TXQ_MG2 && txq != PTCL_TXQ_TB) {
+			PLTFM_DELAY_US(SW_CVR_DUR_US);
+			val32 = MAC_REG_R32(R_AX_PTCL_TX_MACID_0);
+			if (macid == GET_FIELD(val32, B_AX_TX_MACID_0) ||
+			    macid == GET_FIELD(val32, B_AX_TX_MACID_1) ||
+			    macid == GET_FIELD(val32, B_AX_TX_MACID_2) ||
+			    macid == GET_FIELD(val32, B_AX_TX_MACID_3))
+				PLTFM_DELAY_US(SW_CVR_DUR_US);
+			else
+				break;
+		} else {
+			break;
+		}
+	}
+	PLTFM_MSG_ALWAYS("%s: cnt %d, band %d, 0x%x\n", __func__, cnt, band, val8);
+	if (!cnt)
+		return MACPOLLTXIDLE;
+
+	return MACSUCCESS;
+}
+
+u32 stop_sch_tx_8852b(struct mac_ax_adapter *adapter, enum sch_tx_sel sel,
+		      struct mac_ax_sch_tx_en_cfg *bak)
+{
+	struct mac_ax_sch_tx_en_cfg cfg;
+	u32 ret;
+
+	ret = get_hw_sch_tx_en(adapter, bak);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	cfg.band = bak->band;
+	u16_2_sch(adapter, &cfg.tx_en_mask, 0);
+	u16_2_sch(adapter, &cfg.tx_en, 0);
+
+	switch (sel) {
+	case SCH_TX_SEL_ALL:
+		u16_2_sch(adapter, &cfg.tx_en, 0);
+		u16_2_sch(adapter, &cfg.tx_en_mask, TX_EN_CTRL_ALL);
+		ret = set_hw_sch_tx_en(adapter, &cfg);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case SCH_TX_SEL_HIQ:
+		cfg.tx_en.hi = 0;
+		cfg.tx_en_mask.hi = 1;
+		ret = set_hw_sch_tx_en(adapter, &cfg);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case SCH_TX_SEL_MG0:
+		cfg.tx_en.mg0 = 0;
+		cfg.tx_en_mask.mg0 = 1;
+		ret = set_hw_sch_tx_en(adapter, &cfg);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	case SCH_TX_SEL_MACID:
+		u16_2_sch(adapter, &cfg.tx_en, 0);
+		u16_2_sch(adapter, &cfg.tx_en_mask, TX_EN_CTRL_ALL);
+		cfg.tx_en_mask.mg1 = 0;
+		cfg.tx_en_mask.mg2 = 0;
+		cfg.tx_en_mask.hi = 0;
+		cfg.tx_en_mask.bcn = 0;
+		ret = set_hw_sch_tx_en(adapter, &cfg);
+		if (ret != MACSUCCESS)
+			return ret;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/cmac_tx_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/cmac_tx_8852b.h
new file mode 100644
index 000000000000..dc0cefea162d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/cmac_tx_8852b.h
@@ -0,0 +1,29 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_CMAC_TX_8852B_H_
+#define _MAC_AX_CMAC_TX_8852B_H_
+
+#include "../../mac_def.h"
+#include "../mac_priv.h"
+#if MAC_AX_8852B_SUPPORT
+
+u32 macid_idle_ck_8852b(struct mac_ax_adapter *adapter,
+			struct mac_role_tbl *role);
+u32 stop_sch_tx_8852b(struct mac_ax_adapter *adapter, enum sch_tx_sel sel,
+		      struct mac_ax_sch_tx_en_cfg *bak);
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/coex_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/coex_8852b.c
new file mode 100644
index 000000000000..0b4c644a4316
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/coex_8852b.c
@@ -0,0 +1,399 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "coex_8852b.h"
+#include "../../mac_reg.h"
+#include "../hw.h"
+
+#if MAC_AX_8852B_SUPPORT
+
+#define MAC_AX_RTK_RATE 5
+
+#define MAC_AX_BT_MODE_0_3 0
+#define MAC_AX_BT_MODE_2 2
+
+#define MAC_AX_CSR_DELAY 0
+#define MAC_AX_CSR_PRI_TO 5
+#define MAC_AX_CSR_TRX_TO 4
+
+#define MAC_AX_CSR_RATE 80
+
+#define MAC_AX_SB_DRV_MSK 0xFFFFFF
+#define MAC_AX_SB_DRV_SH 0
+#define MAC_AX_SB_FW_MSK 0x7F
+#define MAC_AX_SB_FW_SH 24
+
+#define MAC_AX_BTGS1_NOTIFY BIT(0)
+
+u32 coex_mac_init_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = mac_write_lte_8852b(adapter, R_AX_LTECOEX_CTRL, 0);
+	u8 val = MAC_REG_R8(R_AX_SYS_SDIO_CTRL + 3);
+
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("Write LTE REG fail\n");
+		return ret;
+	}
+
+	ret = mac_write_lte_8852b(adapter, R_AX_LTECOEX_CTRL_2, 0);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("Write LTE REG fail\n");
+		return ret;
+	}
+
+	MAC_REG_W8(R_AX_SYS_SDIO_CTRL + 3, val | BIT(2));
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_lte_8852b(struct mac_ax_adapter *adapter,
+			const u32 offset, u32 val)
+{
+	u32 cnt;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+#if MAC_AX_FW_REG_OFLD
+	u32 ret;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		cnt = 1000;
+		while ((MAC_REG_R8(R_AX_LTE_CTRL + 3) & BIT(5)) == 0) {
+			if (cnt == 0) {
+				PLTFM_MSG_ERR("[ERR]lte not ready(W)\n");
+				return MACPOLLTO;
+			}
+			cnt--;
+			PLTFM_DELAY_US(50);
+		}
+
+		PLTFM_MUTEX_LOCK(&adapter->hw_info->lte_rlock);
+
+		MAC_REG_W32(R_AX_LTE_WDATA, val);
+		MAC_REG_W32(R_AX_LTE_CTRL, 0xC00F0000 | offset);
+
+		PLTFM_MUTEX_UNLOCK(&adapter->hw_info->lte_rlock);
+
+	} else {
+		ret = MAC_REG_P_OFLD(R_AX_LTE_CTRL, B_AX_LTE_RDY, 1, 0);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		ret = MAC_REG_W32_OFLD(R_AX_LTE_WDATA, val, 0);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		ret = MAC_REG_W32_OFLD(R_AX_LTE_WDATA, 0xC00F0000 | offset, 1);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+#else
+	cnt = 1000;
+	while ((MAC_REG_R8(R_AX_LTE_CTRL + 3) & BIT(5)) == 0) {
+		if (cnt == 0) {
+			PLTFM_MSG_ERR("[ERR]lte not ready(W)\n");
+			return MACPOLLTO;
+		}
+		cnt--;
+		PLTFM_DELAY_US(50);
+	}
+
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->lte_rlock);
+
+	MAC_REG_W32(R_AX_LTE_WDATA, val);
+	MAC_REG_W32(R_AX_LTE_CTRL, 0xC00F0000 | offset);
+
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->lte_rlock);
+#endif
+	return MACSUCCESS;
+}
+
+u32 mac_read_lte_8852b(struct mac_ax_adapter *adapter,
+		       const u32 offset, u32 *val)
+{
+	u32 cnt;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	cnt = 1000;
+	while ((MAC_REG_R8(R_AX_LTE_CTRL + 3) & BIT(5)) == 0) {
+		if (cnt == 0) {
+			PLTFM_MSG_ERR("[ERR]lte not ready(W)\n");
+			break;
+		}
+		cnt--;
+		PLTFM_DELAY_US(50);
+	}
+
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->lte_rlock);
+
+	MAC_REG_W32(R_AX_LTE_CTRL, 0x800F0000 | offset);
+	*val = MAC_REG_R32(R_AX_LTE_RDATA);
+
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->lte_rlock);
+
+	return MACSUCCESS;
+}
+
+void _patch_hi_pri_resp_tx_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val;
+
+	val = MAC_REG_R8(R_AX_TRXPTCL_RESP_0 + 3);
+	MAC_REG_W8(R_AX_TRXPTCL_RESP_0 + 3, val & ~BIT(1));
+}
+
+u32 mac_coex_init_8852b(struct mac_ax_adapter *adapter,
+			struct mac_ax_coex *coex)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val;
+	u16 val16;
+	u32 ret, val32;
+
+	val = MAC_REG_R8(R_AX_GPIO_MUXCFG);
+	MAC_REG_W8(R_AX_GPIO_MUXCFG, val | B_AX_ENBT);
+
+	switch (coex->direction) {
+	case MAC_AX_COEX_INNER:
+		val = MAC_REG_R8(R_AX_GPIO_MUXCFG + 1);
+		val = (val & ~BIT(2)) | BIT(1);
+		MAC_REG_W8(R_AX_GPIO_MUXCFG + 1, val);
+		break;
+	case MAC_AX_COEX_OUTPUT:
+		val = MAC_REG_R8(R_AX_GPIO_MUXCFG + 1);
+		val = val | BIT(1) | BIT(0);
+		MAC_REG_W8(R_AX_GPIO_MUXCFG + 1, val);
+		break;
+	case MAC_AX_COEX_INPUT:
+		val = MAC_REG_R8(R_AX_GPIO_MUXCFG + 1);
+		val = val & ~(BIT(2) | BIT(1));
+		MAC_REG_W8(R_AX_GPIO_MUXCFG + 1, val);
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	val = MAC_REG_R8(R_AX_BT_COEX_CFG_2 + 1);
+	MAC_REG_W8(R_AX_BT_COEX_CFG_2 + 1, val | BIT(0));
+
+	val = MAC_REG_R8(R_AX_CSR_MODE);
+	MAC_REG_W8(R_AX_CSR_MODE, val | B_AX_STATIS_BT_EN | B_AX_WL_ACT_MSK);
+
+	val = MAC_REG_R8(R_AX_CSR_MODE + 2);
+	MAC_REG_W8(R_AX_CSR_MODE + 2, val | BIT(0));
+
+	if (chk_patch_hi_pri_resp_tx(adapter))
+		_patch_hi_pri_resp_tx_8852b(adapter);
+
+	val16 = MAC_REG_R16(R_AX_CCA_CFG_0);
+	val16 = (val16 | B_AX_BTCCA_EN) & ~B_AX_BTCCA_BRK_TXOP_EN;
+	MAC_REG_W16(R_AX_CCA_CFG_0, val16);
+
+	ret = mac_read_lte_8852b(adapter, R_AX_LTE_SW_CFG_2, &val32);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: Read LTE fail!\n", __func__);
+		return ret;
+	}
+	val32 = val32 & B_AX_WL_RX_CTRL;
+	ret = mac_write_lte_8852b(adapter, R_AX_LTE_SW_CFG_2, val32);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: Write LTE fail!\n", __func__);
+		return ret;
+	}
+
+	switch (coex->pta_mode) {
+	case MAC_AX_COEX_RTK_MODE:
+		val = MAC_REG_R8(R_AX_GPIO_MUXCFG);
+		val = SET_CLR_WORD(val, MAC_AX_BT_MODE_0_3,
+				   B_AX_BTMODE);
+		MAC_REG_W8(R_AX_GPIO_MUXCFG, val);
+
+		val = MAC_REG_R8(R_AX_TDMA_MODE);
+		MAC_REG_W8(R_AX_TDMA_MODE, val | B_AX_RTK_BT_ENABLE);
+
+		val = MAC_REG_R8(R_AX_BT_COEX_CFG_5);
+		val = SET_CLR_WORD(val, MAC_AX_RTK_RATE,
+				   B_AX_BT_RPT_SAMPLE_RATE);
+		MAC_REG_W8(R_AX_BT_COEX_CFG_5, val);
+		break;
+	case MAC_AX_COEX_CSR_MODE:
+		val = MAC_REG_R8(R_AX_GPIO_MUXCFG);
+		val = SET_CLR_WORD(val, MAC_AX_BT_MODE_2, B_AX_BTMODE);
+		MAC_REG_W8(R_AX_GPIO_MUXCFG, val);
+
+		val16 = MAC_REG_R16(R_AX_CSR_MODE);
+		val16 = SET_CLR_WORD(val16, MAC_AX_CSR_PRI_TO,
+				     B_AX_BT_PRI_DETECT_TO);
+		val16 = SET_CLR_WORD(val16, MAC_AX_CSR_TRX_TO,
+				     B_AX_BT_TRX_INIT_DETECT);
+		val16 = SET_CLR_WORD(val16, MAC_AX_CSR_DELAY,
+				     B_AX_BT_STAT_DELAY);
+		val16 = val16 | B_AX_ENHANCED_BT;
+		MAC_REG_W16(R_AX_CSR_MODE, val16);
+
+		MAC_REG_W8(R_AX_BT_COEX_CFG_2, MAC_AX_CSR_RATE);
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_gnt_8852b(struct mac_ax_adapter *adapter,
+		      struct mac_ax_coex_gnt *gnt_cfg)
+{
+	u32 val, ret, status;
+	struct mac_ax_gnt *gnt;
+
+	ret = mac_read_lte_8852b(adapter, R_AX_LTE_SW_CFG_1, &val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read LTE fail!\n");
+		return ret;
+	}
+
+	ret = mac_read_lte_8852b(adapter, R_AX_LTECOEX_STATUS, &status);
+	if (ret) {
+		PLTFM_MSG_ERR("Read LTE fail!\n");
+		return ret;
+	}
+
+	gnt = &gnt_cfg->band0;
+	gnt->gnt_bt_sw_en = !!(val & B_AX_GNT_BT_RFC_S0_SW_CTRL);
+	gnt->gnt_bt = !!(status & B_AX_GNT_BT_RFC_S0_STA);
+	gnt->gnt_wl_sw_en = !!(val & B_AX_GNT_WL_RFC_S0_SW_CTRL);
+	gnt->gnt_wl = !!(status & B_AX_GNT_WL_RFC_S0_STA);
+
+	gnt = &gnt_cfg->band1;
+	gnt->gnt_bt_sw_en = !!(val & B_AX_GNT_BT_RFC_S1_SW_CTRL);
+	gnt->gnt_bt = !!(status & B_AX_GNT_BT_RFC_S1_STA);
+	gnt->gnt_wl_sw_en = !!(val & B_AX_GNT_WL_RFC_S1_SW_CTRL);
+	gnt->gnt_wl = !!(status & B_AX_GNT_WL_RFC_S1_STA);
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_gnt_8852b(struct mac_ax_adapter *adapter,
+		      struct mac_ax_coex_gnt *gnt_cfg)
+{
+	u32 val, ret;
+
+	ret = mac_read_lte_8852b(adapter, R_AX_LTE_SW_CFG_1, &val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read LTE fail!\n");
+		return ret;
+	}
+	val = (gnt_cfg->band0.gnt_bt ? (B_AX_GNT_BT_RFC_S0_SW_VAL |
+		 B_AX_GNT_BT_BB_S0_SW_VAL) : 0) |
+		(gnt_cfg->band0.gnt_bt_sw_en ?
+		 (B_AX_GNT_BT_RFC_S0_SW_CTRL |
+		  B_AX_GNT_BT_BB_S0_SW_CTRL) : 0) |
+		(gnt_cfg->band0.gnt_wl ? (B_AX_GNT_WL_RFC_S0_SW_VAL |
+					  B_AX_GNT_WL_BB_S0_SW_VAL) : 0) |
+		(gnt_cfg->band0.gnt_wl_sw_en ?
+		 (B_AX_GNT_WL_RFC_S0_SW_CTRL |
+		  B_AX_GNT_WL_BB_S0_SW_CTRL) : 0) |
+		(gnt_cfg->band1.gnt_bt ? (B_AX_GNT_BT_RFC_S1_SW_VAL |
+					  B_AX_GNT_BT_BB_S1_SW_VAL) : 0) |
+		(gnt_cfg->band1.gnt_bt_sw_en ?
+		 (B_AX_GNT_BT_RFC_S1_SW_CTRL |
+		  B_AX_GNT_BT_BB_S1_SW_CTRL) : 0) |
+		(gnt_cfg->band1.gnt_wl ? (B_AX_GNT_WL_RFC_S1_SW_VAL |
+					  B_AX_GNT_WL_BB_S1_SW_VAL) : 0) |
+		(gnt_cfg->band1.gnt_wl_sw_en ?
+		 (B_AX_GNT_WL_RFC_S1_SW_CTRL |
+		  B_AX_GNT_WL_BB_S1_SW_CTRL) : 0);
+	ret = mac_write_lte_8852b(adapter, R_AX_LTE_SW_CFG_1, val);
+	if (ret) {
+		PLTFM_MSG_ERR("Write LTE fail!\n");
+		return ret;
+	}
+
+	ret = mac_read_lte_8852b(adapter, R_AX_LTE_SW_CFG_2, &val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read LTE fail!\n");
+		return ret;
+	}
+	val = val & B_AX_WL_RX_CTRL ? B_AX_WL_RX_CTRL : 0 |
+		((gnt_cfg->band0.gnt_bt_sw_en || gnt_cfg->band1.gnt_bt_sw_en) ?
+		 (B_AX_GNT_BT_TX_SW_CTRL | B_AX_GNT_BT_RX_SW_CTRL) : 0) |
+		((gnt_cfg->band0.gnt_bt ||  gnt_cfg->band1.gnt_bt) ?
+		 (B_AX_GNT_BT_TX_SW_VAL | B_AX_GNT_BT_RX_SW_VAL) : 0) |
+		((gnt_cfg->band0.gnt_wl_sw_en || gnt_cfg->band1.gnt_wl_sw_en) ?
+		 (B_AX_GNT_WL_TX_SW_CTRL | B_AX_GNT_WL_RX_SW_CTRL) : 0) |
+		((gnt_cfg->band0.gnt_wl ||  gnt_cfg->band1.gnt_wl) ?
+		 (B_AX_GNT_WL_TX_SW_VAL | B_AX_GNT_WL_RX_SW_VAL) : 0);
+
+	ret = mac_write_lte_8852b(adapter, R_AX_LTE_SW_CFG_2, val);
+	if (ret) {
+		PLTFM_MSG_ERR("Write LTE fail!\n");
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_read_coex_reg_8852b(struct mac_ax_adapter *adapter,
+			    const u32 offset, u32 *val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (offset > 0xFF) {
+		PLTFM_MSG_ERR("[ERR]offset exceed coex reg\n");
+		return MACBADDR;
+	}
+
+	*val = MAC_REG_R32(R_AX_BTC_CFG + offset);
+
+	return MACSUCCESS;
+}
+
+u32 mac_write_coex_reg_8852b(struct mac_ax_adapter *adapter,
+			     const u32 offset, const u32 val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (offset > 0xFF) {
+		PLTFM_MSG_ERR("[ERR]offset exceed coex reg\n");
+		return MACBADDR;
+	}
+
+	MAC_REG_W32(R_AX_BTC_CFG + offset, val);
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_ctrl_path_8852b(struct mac_ax_adapter *adapter, u32 wl)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val = MAC_REG_R8(R_AX_SYS_SDIO_CTRL + 3);
+
+	val = wl ? val | BIT(2) : val & ~BIT(2);
+	MAC_REG_W8(R_AX_SYS_SDIO_CTRL + 3, val);
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_ctrl_path_8852b(struct mac_ax_adapter *adapter, u32 *wl)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val = MAC_REG_R8(R_AX_SYS_SDIO_CTRL + 3);
+
+	*wl = !!(val & BIT(2));
+
+	return MACSUCCESS;
+}
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/coex_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/coex_8852b.h
new file mode 100644
index 000000000000..4341489ce473
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/coex_8852b.h
@@ -0,0 +1,272 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_COEX_8852B_H_
+#define _MAC_AX_COEX_8852B_H_
+
+#include "../../mac_def.h"
+#if MAC_AX_8852B_SUPPORT
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @brief mac_coex_init
+ *
+ * @param *adapter
+ * @param *coex
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_coex_init_8852b(struct mac_ax_adapter *adapter,
+			struct mac_ax_coex *coex);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_gnt
+ *
+ * @param *adapter
+ * @param *gnt_cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_cfg_gnt_8852b(struct mac_ax_adapter *adapter,
+		      struct mac_ax_coex_gnt *gnt_cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @brief mac_get_gnt
+ *
+ * @param *adapter
+ * @param *gnt_cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_get_gnt_8852b(struct mac_ax_adapter *adapter,
+		      struct mac_ax_coex_gnt *gnt_cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_plt
+ *
+ * @param *adapter
+ * @param *plt
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_cfg_plt_8852b(struct mac_ax_adapter *adapter, struct mac_ax_plt *plt);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @brief mac_write_coex_reg
+ *
+ * @param *adapter
+ * @param offset
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_write_coex_reg_8852b(struct mac_ax_adapter *adapter,
+			     const u32 offset, const u32 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @brief mac_read_coex_reg
+ *
+ * @param *adapter
+ * @param offset
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_read_coex_reg_8852b(struct mac_ax_adapter *adapter,
+			    const u32 offset, u32 *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_ctrl_path
+ *
+ * @param *adapter
+ * @param wl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_cfg_ctrl_path_8852b(struct mac_ax_adapter *adapter, u32 wl);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BTCoex
+ * @{
+ */
+
+/**
+ * @brief mac_get_ctrl_path
+ *
+ * @param *adapter
+ * @param *wl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_get_ctrl_path_8852b(struct mac_ax_adapter *adapter, u32 *wl);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup LTE_COEX
+ * @{
+ */
+
+/**
+ * @brief mac_write_lte_8852a
+ *
+ * @param *adapter
+ * @param offset
+ * @param val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_write_lte_8852b(struct mac_ax_adapter *adapter,
+			const u32 offset, u32 val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup LTE_COEX
+ * @{
+ */
+
+/**
+ * @brief mac_read_lte_8852a
+ *
+ * @param *adapter
+ * @param offset
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_lte_8852b(struct mac_ax_adapter *adapter,
+		       const u32 offset, u32 *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup Init
+ * @{
+ */
+
+/**
+ * @brief coex_mac_init_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 coex_mac_init_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dbgpkg_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dbgpkg_8852b.c
new file mode 100644
index 000000000000..a0d6cc19c925
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dbgpkg_8852b.c
@@ -0,0 +1,3215 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "../dbgpkg.h"
+#include "dbgpkg_8852b.h"
+
+#if MAC_AX_8852B_SUPPORT
+/* For dbg port */
+static struct mac_ax_dbg_port_info dbg_port_ptcl_c0 = {
+	R_AX_PTCL_DBG,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_PTCL_DBG_SEL_SH,
+	B_AX_PTCL_DBG_SEL_MSK,
+	0x00,
+	0x3F,
+	1,
+	R_AX_PTCL_DBG_INFO,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_PTCL_DBG_INFO_SH,
+	B_AX_PTCL_DBG_INFO_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_sch_c0 = {
+	R_AX_SCH_DBG_SEL,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_SCH_DBG_SEL_SH,
+	B_AX_SCH_DBG_SEL_MSK,
+	0x00,
+	0x2F,
+	1,
+	R_AX_SCH_DBG,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_SCHEDULER_DBG_SH,
+	B_AX_SCHEDULER_DBG_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_tmac_c0 = {
+	R_AX_MACTX_DBG_SEL_CNT,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_DBGSEL_MACTX_SH,
+	B_AX_DBGSEL_MACTX_MSK,
+	0x00,
+	0x19,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_rmac_c0 = {
+	R_AX_RX_DEBUG_SELECT,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_DEBUG_SEL_SH,
+	B_AX_DEBUG_SEL_MSK,
+	0x00,
+	0x58,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_rmacst_c0 = {
+	R_AX_RX_STATE_MONITOR,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STATE_SEL_SH,
+	B_AX_STATE_SEL_MSK,
+	0x00,
+	0x17,
+	1,
+	R_AX_RX_STATE_MONITOR,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffffL
+};
+
+static struct mac_ax_dbg_port_info dbg_port_rmac_plcp_c0 = {
+	R_AX_RMAC_PLCP_MON,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_PCLP_MON_SEL_SH,
+	B_AX_PCLP_MON_SEL_MSK,
+	0x0,
+	0xF,
+	1,
+	R_AX_RMAC_PLCP_MON,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffffL
+};
+
+static struct mac_ax_dbg_port_info dbg_port_trxptcl_c0 = {
+	R_AX_DBGSEL_TRXPTCL,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_DBGSEL_TRXPTCL_SH,
+	B_AX_DBGSEL_TRXPTCL_MSK,
+	0x08,
+	0x10,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_tx_infol_c0 = {
+	R_AX_WMAC_TX_CTRL_DEBUG,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_TX_CTRL_DEBUG_SEL_SH,
+	B_AX_TX_CTRL_DEBUG_SEL_MSK,
+	0x00,
+	0x07,
+	1,
+	R_AX_WMAC_TX_INFO0_DEBUG,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_TX_CTRL_INFO_P0_SH,
+	B_AX_TX_CTRL_INFO_P0_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_tx_infoh_c0 = {
+	R_AX_WMAC_TX_CTRL_DEBUG,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_TX_CTRL_DEBUG_SEL_SH,
+	B_AX_TX_CTRL_DEBUG_SEL_MSK,
+	0x00,
+	0x07,
+	1,
+	R_AX_WMAC_TX_INFO1_DEBUG,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_TX_CTRL_INFO_P1_SH,
+	B_AX_TX_CTRL_INFO_P1_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txtf_infol_c0 = {
+	R_AX_WMAC_TX_TF_INFO_0,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_WMAC_TX_TF_INFO_SEL_SH,
+	B_AX_WMAC_TX_TF_INFO_SEL_MSK,
+	0x00,
+	0x04,
+	1,
+	R_AX_WMAC_TX_TF_INFO_1,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_WMAC_TX_TF_INFO_P0_SH,
+	B_AX_WMAC_TX_TF_INFO_P0_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txtf_infoh_c0 = {
+	R_AX_WMAC_TX_TF_INFO_0,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_WMAC_TX_TF_INFO_SEL_SH,
+	B_AX_WMAC_TX_TF_INFO_SEL_MSK,
+	0x00,
+	0x04,
+	1,
+	R_AX_WMAC_TX_TF_INFO_2,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_WMAC_TX_TF_INFO_P1_SH,
+	B_AX_WMAC_TX_TF_INFO_P1_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_cmac_dma0_c0 = {
+	R_AX_RXDMA_CTRL_0,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_RXDMA_FIFO_DBG_SEL_SH,
+	0x3F,
+	0x00,
+	0x3F,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_cmac_dma1_c0 = {
+	R_AX_TXDMA_DBG,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_TXDMA_DBG_SEL_SH,
+	B_AX_TXDMA_DBG_SEL_MSK,
+	0x00,
+	0x03,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wde_bufmgn_ctl = {
+	R_AX_WDE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0,
+	0x101,
+	0x101,
+	R_AX_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wde_bufmgn_arb = {
+	R_AX_WDE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0xE0E,
+	0xE0E,
+	0x101,
+	R_AX_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wde_quemgn_ctl = {
+	R_AX_WDE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0x1010,
+	0x1111,
+	0x101,
+	R_AX_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wde_quemgn_info = {
+	R_AX_WDE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0x1414,
+	0x1414,
+	0x101,
+	R_AX_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wde_quemgn_arb = {
+	R_AX_WDE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0x1E1E,
+	0x1E1E,
+	0x101,
+	R_AX_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wde_portif0 = {
+	R_AX_WDE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0x8080,
+	0x8282,
+	0x101,
+	R_AX_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wde_portif1 = {
+	R_AX_WDE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0x9090,
+	0x9292,
+	0x101,
+	R_AX_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wde_portif3 = {
+	R_AX_WDE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0xB0B0,
+	0xB2B2,
+	0x101,
+	R_AX_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wde_portif4 = {
+	R_AX_WDE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0xC0C0,
+	0xC2C2,
+	0x101,
+	R_AX_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wde_portif6 = {
+	R_AX_WDE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0xE0E0,
+	0xE2E2,
+	0x101,
+	R_AX_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wde_portif7 = {
+	R_AX_WDE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0xF0F0,
+	0xF2F2,
+	0x101,
+	R_AX_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_ple_bufmgn_ctl = {
+	R_AX_PLE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0,
+	0x101,
+	0x101,
+	R_AX_PLE_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_ple_bufmgn_arb = {
+	R_AX_PLE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0xE0E,
+	0xE0E,
+	0x101,
+	R_AX_PLE_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_ple_quemgn_ctl = {
+	R_AX_PLE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0x1010,
+	0x1111,
+	0x101,
+	R_AX_PLE_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_ple_quemgn_info = {
+	R_AX_PLE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0x1414,
+	0x1414,
+	0x101,
+	R_AX_PLE_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_ple_quemgn_arb = {
+	R_AX_PLE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0x1E1E,
+	0x1E1E,
+	0x101,
+	R_AX_PLE_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_ple_portif0 = {
+	R_AX_PLE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0x8080,
+	0x8282,
+	0x101,
+	R_AX_PLE_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_ple_portif1 = {
+	R_AX_PLE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0x9090,
+	0x9292,
+	0x101,
+	R_AX_PLE_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_ple_portif2 = {
+	R_AX_PLE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0xA0A0,
+	0xA2A2,
+	0x101,
+	R_AX_PLE_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_ple_portif3 = {
+	R_AX_PLE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0xB0B0,
+	0xB2B2,
+	0x101,
+	R_AX_PLE_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_ple_portif4 = {
+	R_AX_PLE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0xC0C0,
+	0xC2C2,
+	0x101,
+	R_AX_PLE_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_ple_portif5 = {
+	R_AX_PLE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0xD0D0,
+	0xD2D2,
+	0x101,
+	R_AX_PLE_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_ple_portif6 = {
+	R_AX_PLE_DBG_CTL,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xFFFF,
+	0xE0E0,
+	0xE2E2,
+	0x101,
+	R_AX_PLE_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xFFFFFFFF
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wdrls_ctl = {
+	R_AX_DBG_CTL_WDRLS,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xffff,
+	0,
+	0,
+	0x101,
+	R_AX_DBG_OUT_WDRLS,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wdrls_rptgen0 = {
+	R_AX_DBG_CTL_WDRLS,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xffff,
+	0x808,
+	0x909,
+	0x101,
+	R_AX_DBG_OUT_WDRLS,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wdrls_rptgen1 = {
+	R_AX_DBG_CTL_WDRLS,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xffff,
+	0xC0C,
+	0xD0D,
+	0x101,
+	R_AX_DBG_OUT_WDRLS,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wdrls_pledchn0 = {
+	R_AX_DBG_CTL_WDRLS,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xffff,
+	0x1010,
+	0x1818,
+	0x404,
+	R_AX_DBG_OUT_WDRLS,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_wdrls_pledchn1 = {
+	R_AX_DBG_CTL_WDRLS,
+	MAC_AX_BYTE_SEL_2,
+	0,
+	0xffff,
+	0x1919,
+	0x1B1B,
+	0x101,
+	R_AX_DBG_OUT_WDRLS,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txpktctrl_fetpkt = {
+	R_AX_DBG_CTL_TXPKT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+	0,
+	0x10001,
+	0x10001,
+	R_AX_TPC_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txpktctrl_b0_cmdpsr = {
+	R_AX_DBG_CTL_TXPKT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+	0x800080,
+	0x810081,
+	0x10001,
+	R_AX_TPC_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txpktctrl_b0_cmacdmaif = {
+	R_AX_DBG_CTL_TXPKT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+	0x880088,
+	0x880088,
+	0x10001,
+	R_AX_TPC_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txpktctrl_b0_unit0_0 = {
+	R_AX_DBG_CTL_TXPKT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+	0x1000100,
+	0x1020102,
+	0x10001,
+	R_AX_TPC_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txpktctrl_b0_unit0_1 = {
+	R_AX_DBG_CTL_TXPKT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+	0x1080108,
+	0x10D010D,
+	0x10001,
+	R_AX_TPC_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txpktctrl_b0_unit1_0 = {
+	R_AX_DBG_CTL_TXPKT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+	0x1100110,
+	0x1120112,
+	0x10001,
+	R_AX_TPC_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txpktctrl_b0_unit1_1 = {
+	R_AX_DBG_CTL_TXPKT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+	0x1180118,
+	0x11D011D,
+	0x10001,
+	R_AX_TPC_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txpktctrl_b0_unit2_0 = {
+	R_AX_DBG_CTL_TXPKT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+	0x1200120,
+	0x1220122,
+	0x10001,
+	R_AX_TPC_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txpktctrl_b0_unit2_1 = {
+	R_AX_DBG_CTL_TXPKT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+	0x1280128,
+	0x12D012D,
+	0x10001,
+	R_AX_TPC_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txpktctrl_b0_unit3_0 = {
+	R_AX_DBG_CTL_TXPKT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+	0x1300130,
+	0x1320132,
+	0x10001,
+	R_AX_TPC_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_txpktctrl_b0_unit3_1 = {
+	R_AX_DBG_CTL_TXPKT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+	0x1380138,
+	0x13D013D,
+	0x10001,
+	R_AX_TPC_DBG_OUT,
+	MAC_AX_BYTE_SEL_4,
+	0,
+	0xffffffff,
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pktinfo = {
+	R_AX_DBG_FUN_INTF_CTL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DFI_DATA_SH,
+	B_AX_DFI_DATA_MSK,
+	0x80000000,
+	0x8000017f,
+	1,
+	R_AX_DBG_FUN_INTF_DATA,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DFI_DATA_SH,
+	B_AX_DFI_DATA_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_txdma = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x03,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_rxdma = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x04,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_cvt = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x01,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_emac04 = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x05,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_emac5 = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x00,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_emac6 = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x00,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_emac7 = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x00,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_pnp_io = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x05,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_emac814 = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x06,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_emac15 = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x00,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_emac16 = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x00,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_emac17 = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x00,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_pcie_emac18 = {
+	R_AX_PCIE_DBG_CTRL,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_PCIE_DBG_SEL_SH,
+	B_AX_PCIE_DBG_SEL_MSK,
+	0x00,
+	0x00,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb2_phy = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x00,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb2_sie = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x04,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb2_utmi = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x01,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb2_sie_mmu = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x03,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb2_sie_pce = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x03,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb2_utmi_if = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x00,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb_wltx = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x04,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb_wlrx = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x0D,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb3 = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x0E,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb_setup = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x01,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb_wltx_dma = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x09,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb_wlrx_dma = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x0F,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb_ainst = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x02,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb_misc = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x01,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb_bttx = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x07,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_usb2_bt = {
+	R_AX_STC_INT_CS,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_STC_INT_REALTIME_CS_SH,
+	B_AX_STC_INT_REALTIME_CS_MSK,
+	0x00,
+	0x01,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_hdt_tx0_5 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0xD,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_hdt_tx6 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x5,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_hdt_tx7 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x9,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_hdt_tx8 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x3,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_hdt_tx9_C = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x1,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_hdt_txD = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x0,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_cdt_tx0 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0xB,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_cdt_tx1 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x4,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_cdt_tx3 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x8,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_cdt_tx4 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x7,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_cdt_tx5_8 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x1,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_cdt_tx9 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x3,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_hdt_rx0 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x8,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_hdt_rx1_2 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x0,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_hdt_rx3 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_2,
+	B_AX_DISPATCHER_DBG_SEL_SH,
+	B_AX_DISPATCHER_DBG_SEL_MSK,
+	0x0,
+	0x6,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_cdt_rx_p0_0 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_DISPATCHER_CH_SEL_SH,
+	B_AX_DISPATCHER_CH_SEL_MSK,
+	0x0,
+	0x3,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_cdt_rx_p1 = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_DISPATCHER_CH_SEL_SH,
+	B_AX_DISPATCHER_CH_SEL_MSK,
+	0x8,
+	0xE,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_stf_ctrl = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_DISPATCHER_CH_SEL_SH,
+	B_AX_DISPATCHER_CH_SEL_MSK,
+	0x0,
+	0x5,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_addr_ctrl = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_DISPATCHER_CH_SEL_SH,
+	B_AX_DISPATCHER_CH_SEL_MSK,
+	0x0,
+	0x6,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_wde_intf = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_DISPATCHER_CH_SEL_SH,
+	B_AX_DISPATCHER_CH_SEL_MSK,
+	0x0,
+	0xF,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_ple_intf = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_DISPATCHER_CH_SEL_SH,
+	B_AX_DISPATCHER_CH_SEL_MSK,
+	0x0,
+	0x9,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_dspt_flow_ctrl = {
+	R_AX_DISPATCHER_DBG_PORT,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_DISPATCHER_CH_SEL_SH,
+	B_AX_DISPATCHER_CH_SEL_MSK,
+	0x0,
+	0x3,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_axi_txdma_ctrl = {
+	R_AX_INDIR_ACCESS_ENTRY + R_PL_AXIDMA_DBG_CTRL,
+	MAC_AX_BYTE_SEL_4,
+	B_PL_AXIDMA_DBG_SEL_SH,
+	0x3F,
+	0x0,
+	0x1B,
+	9,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_axi_rxdma_ctrl = {
+	R_AX_INDIR_ACCESS_ENTRY + R_PL_AXIDMA_DBG_CTRL,
+	MAC_AX_BYTE_SEL_4,
+	B_PL_AXIDMA_DBG_SEL_SH,
+	0x3F,
+	0x0,
+	0x36,
+	9,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_axi_mst_wlan = {
+	R_AX_INDIR_ACCESS_ENTRY + R_PL_AXIDMA_DBG_CTRL,
+	MAC_AX_BYTE_SEL_4,
+	B_PL_AXIDMA_DBG_SEL_SH,
+	0x3F,
+	0x0,
+	0,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_axi_int_wlan = {
+	R_AX_INDIR_ACCESS_ENTRY + R_PL_AXIDMA_DBG_CTRL,
+	MAC_AX_BYTE_SEL_4,
+	B_PL_AXIDMA_DBG_SEL_SH,
+	0x3F,
+	0x0,
+	0,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_axi_page_fc = {
+	R_AX_INDIR_ACCESS_ENTRY + R_PL_AXIDMA_DBG_CTRL,
+	MAC_AX_BYTE_SEL_4,
+	B_PL_AXIDMA_DBG_SEL_SH,
+	0x3F,
+	0x0,
+	0,
+	1,
+	R_AX_DBG_PORT_SEL,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_DEBUG_ST_SH,
+	B_AX_DEBUG_ST_MSK
+};
+
+static struct mac_ax_dbg_port_info dbg_port_sta_sch = {
+	R_AX_SS_DBG_3,
+	MAC_AX_BYTE_SEL_1,
+	B_AX_SS_TOP_DBG_SEL_SH,
+	B_AX_SS_TOP_DBG_SEL_MSK,
+	0x00,
+	0x10,
+	1,
+	R_AX_SS_DBG_INFO,
+	MAC_AX_BYTE_SEL_4,
+	B_AX_SS_DBG_INFO_SH,
+	B_AX_SS_DBG_INFO_MSK
+};
+
+u32 tx_dbg_dump_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret;
+	u32 i;
+
+	PLTFM_MSG_ALWAYS("R_AX_CMAC_MACID_DROP_0=0x%x\n",
+			 MAC_REG_R32(R_AX_CMAC_MACID_DROP_0));
+
+	PLTFM_MSG_ALWAYS("R_AX_MBSSID_DROP_0=0x%x\n",
+			 MAC_REG_R32(R_AX_MBSSID_DROP_0));
+
+	PLTFM_MSG_ALWAYS("R_AX_MACID_SLEEP_0=0x%x\n",
+			 MAC_REG_R32(R_AX_MACID_SLEEP_0));
+
+	PLTFM_MSG_ALWAYS("R_AX_MACID_SLEEP_1=0x%x\n",
+			 MAC_REG_R32(R_AX_MACID_SLEEP_1));
+
+	PLTFM_MSG_ALWAYS("R_AX_MACID_SLEEP_2=0x%x\n",
+			 MAC_REG_R32(R_AX_MACID_SLEEP_2));
+
+	PLTFM_MSG_ALWAYS("R_AX_MACID_SLEEP_3=0x%x\n",
+			 MAC_REG_R32(R_AX_MACID_SLEEP_3));
+
+	PLTFM_MSG_ALWAYS("R_AX_SS_MACID_PAUSE_0=0x%x\n",
+			 MAC_REG_R32(R_AX_SS_MACID_PAUSE_0));
+
+	PLTFM_MSG_ALWAYS("R_AX_SS_MACID_PAUSE_1=0x%x\n",
+			 MAC_REG_R32(R_AX_SS_MACID_PAUSE_1));
+
+	PLTFM_MSG_ALWAYS("R_AX_SS_MACID_PAUSE_2=0x%x\n",
+			 MAC_REG_R32(R_AX_SS_MACID_PAUSE_2));
+
+	PLTFM_MSG_ALWAYS("R_AX_SS_MACID_PAUSE_3=0x%x\n",
+			 MAC_REG_R32(R_AX_SS_MACID_PAUSE_3));
+
+	PLTFM_MSG_ALWAYS("R_AX_CTN_TXEN=0x%x\n",
+			 MAC_REG_R32(R_AX_CTN_TXEN));
+
+	PLTFM_MSG_ALWAYS("R_AX_PTCL_COMMON_SETTING_0=0x%x\n",
+			 MAC_REG_R32(R_AX_PTCL_COMMON_SETTING_0));
+
+	PLTFM_MSG_ALWAYS("R_AX_MAC_LOOPBACK=0x%x\n",
+			 MAC_REG_R32(R_AX_MAC_LOOPBACK));
+
+	ret = dbg_port_dump(adapter, MAC_AX_DBG_PORT_SEL_PTCL_C0);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("PTCL_C0 dbg port dump %d\n", ret);
+
+	ret = dbg_port_dump(adapter, MAC_AX_DBG_PORT_SEL_SCH_C0);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("SCH_C0 dbg port dump %d\n", ret);
+
+	PLTFM_MSG_ALWAYS("R_AX_DLE_EMPTY0=0x%x\n",
+			 MAC_REG_R32(R_AX_DLE_EMPTY0));
+
+	PLTFM_MSG_ALWAYS("R_AX_DLE_EMPTY1=0x%x\n",
+			 MAC_REG_R32(R_AX_DLE_EMPTY1));
+
+	for (i = 0; i < TRX_CNT_REPT_CNT; i++) {
+#if MAC_AX_PCIE_SUPPORT
+		if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+			PLTFM_MSG_ALWAYS("R_AX_PCIE_MIO_INTF=0x%x\n",
+					 MAC_REG_R32(R_AX_PCIE_MIO_INTF));
+
+			PLTFM_MSG_ALWAYS("R_AX_PCIE_MIO_INTD=0x%x\n",
+					 MAC_REG_R32(R_AX_PCIE_MIO_INTD));
+
+			PLTFM_MSG_ALWAYS("R_AX_PCIE_INIT_CFG1=0x%x\n",
+					 MAC_REG_R32(R_AX_PCIE_INIT_CFG1));
+
+			PLTFM_MSG_ALWAYS("R_AX_PCIE_DMA_STOP1=0x%x\n",
+					 MAC_REG_R32(R_AX_PCIE_DMA_STOP1));
+
+			PLTFM_MSG_ALWAYS("R_AX_PCIE_DMA_BUSY1=0x%x\n",
+					 MAC_REG_R32(R_AX_PCIE_DMA_BUSY1));
+
+			PLTFM_MSG_ALWAYS("R_AX_PCIE_DBG_CTRL=0x%x\n",
+					 MAC_REG_R32(R_AX_PCIE_DBG_CTRL));
+
+			PLTFM_MSG_ALWAYS("R_AX_DBG_ERR_FLAG=0x%x\n",
+					 MAC_REG_R32(R_AX_DBG_ERR_FLAG));
+
+			PLTFM_MSG_ALWAYS("R_AX_LBC_WATCHDOG=0x%x\n",
+					 MAC_REG_R32(R_AX_LBC_WATCHDOG));
+
+			PLTFM_MSG_ALWAYS("R_AX_ACH0_TXBD_IDX=0x%x\n",
+					 MAC_REG_R32(R_AX_ACH0_TXBD_IDX));
+
+			PLTFM_MSG_ALWAYS("R_AX_ACH1_TXBD_IDX=0x%x\n",
+					 MAC_REG_R32(R_AX_ACH1_TXBD_IDX));
+
+			PLTFM_MSG_ALWAYS("R_AX_ACH2_TXBD_IDX=0x%x\n",
+					 MAC_REG_R32(R_AX_ACH2_TXBD_IDX));
+
+			PLTFM_MSG_ALWAYS("R_AX_ACH3_TXBD_IDX=0x%x\n",
+					 MAC_REG_R32(R_AX_ACH3_TXBD_IDX));
+
+			PLTFM_MSG_ALWAYS("R_AX_ACH4_TXBD_IDX=0x%x\n",
+					 MAC_REG_R32(R_AX_ACH4_TXBD_IDX));
+
+			PLTFM_MSG_ALWAYS("R_AX_ACH5_TXBD_IDX=0x%x\n",
+					 MAC_REG_R32(R_AX_ACH5_TXBD_IDX));
+
+			PLTFM_MSG_ALWAYS("R_AX_ACH6_TXBD_IDX=0x%x\n",
+					 MAC_REG_R32(R_AX_ACH6_TXBD_IDX));
+
+			PLTFM_MSG_ALWAYS("R_AX_ACH7_TXBD_IDX=0x%x\n",
+					 MAC_REG_R32(R_AX_ACH7_TXBD_IDX));
+
+			PLTFM_MSG_ALWAYS("R_AX_CH8_TXBD_IDX=0x%x\n",
+					 MAC_REG_R32(R_AX_CH8_TXBD_IDX));
+
+			PLTFM_MSG_ALWAYS("R_AX_CH9_TXBD_IDX=0x%x\n",
+					 MAC_REG_R32(R_AX_CH9_TXBD_IDX));
+
+			PLTFM_MSG_ALWAYS("R_AX_CH12_TXBD_IDX=0x%x\n",
+					 MAC_REG_R32(R_AX_CH12_TXBD_IDX));
+		}
+#endif
+		/* TMAC TX COUNTER */
+		ret = tx_cnt_dump(adapter, MAC_AX_BAND_0, 1);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ALWAYS("[ERR]tx cnt dump err %d\n", ret);
+
+		pltfm_dbg_dump(adapter);
+
+		PLTFM_DELAY_US(TRX_CNT_REPT_DLY_US);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 crit_dbg_dump_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	PLTFM_MSG_ALWAYS("R_AX_SYS_ISO_CTRL=0x%x\n",
+			 MAC_REG_R16(R_AX_SYS_ISO_CTRL));
+
+	PLTFM_MSG_ALWAYS("R_AX_SYS_FUNC_EN=0x%x\n",
+			 MAC_REG_R16(R_AX_SYS_FUNC_EN));
+
+	PLTFM_MSG_ALWAYS("R_AX_SYS_PW_CTRL=0x%x\n",
+			 MAC_REG_R32(R_AX_SYS_PW_CTRL));
+
+	PLTFM_MSG_ALWAYS("R_AX_SYS_CLK_CTRL=0x%x\n",
+			 MAC_REG_R16(R_AX_SYS_CLK_CTRL));
+
+	PLTFM_MSG_ALWAYS("R_AX_SYS_EEPROM_CTRL=0x%x\n",
+			 MAC_REG_R16(R_AX_SYS_WL_EFUSE_CTRL));
+
+	PLTFM_MSG_ALWAYS("R_AX_DBG_CTRL=0x%x\n",
+			 MAC_REG_R32(R_AX_DBG_CTRL));
+
+	PLTFM_MSG_ALWAYS("R_AX_PLATFORM_ENABLE=0x%x\n",
+			 MAC_REG_R32(R_AX_PLATFORM_ENABLE));
+
+	PLTFM_MSG_ALWAYS("R_AX_WLLPS_CTRL=0x%x\n",
+			 MAC_REG_R32(R_AX_WLLPS_CTRL));
+
+	PLTFM_MSG_ALWAYS("R_AX_WLRESUME_CTRL=0x%x\n",
+			 MAC_REG_R32(R_AX_WLRESUME_CTRL));
+
+	PLTFM_MSG_ALWAYS("R_AX_DBG_PORT_SEL=0x%x\n",
+			 MAC_REG_R32(R_AX_DBG_PORT_SEL));
+
+	PLTFM_MSG_ALWAYS("R_AX_HALT_H2C_CTRL=0x%x\n",
+			 MAC_REG_R32(R_AX_HALT_H2C_CTRL));
+
+	PLTFM_MSG_ALWAYS("R_AX_HALT_H2C=0x%x\n",
+			 MAC_REG_R32(R_AX_HALT_H2C));
+
+	PLTFM_MSG_ALWAYS("R_AX_HALT_C2H_CTRL=0x%x\n",
+			 MAC_REG_R32(R_AX_HALT_C2H_CTRL));
+
+	PLTFM_MSG_ALWAYS("R_AX_HALT_C2H=0x%x\n",
+			 MAC_REG_R32(R_AX_HALT_C2H));
+
+	PLTFM_MSG_ALWAYS("R_AX_SYS_CFG5=0x%x\n",
+			 MAC_REG_R32(R_AX_SYS_CFG5));
+
+	PLTFM_MSG_ALWAYS("R_AX_WCPU_FW_CTRL=0x%x\n",
+			 MAC_REG_R32(R_AX_WCPU_FW_CTRL));
+
+	PLTFM_MSG_ALWAYS("R_AX_RPWM=0x%x\n",
+			 MAC_REG_R16(R_AX_RPWM));
+
+	PLTFM_MSG_ALWAYS("R_AX_BOOT_REASON=0x%x\n",
+			 MAC_REG_R16(R_AX_BOOT_REASON));
+
+	PLTFM_MSG_ALWAYS("R_AX_LDM=0x%x\n",
+			 MAC_REG_R32(R_AX_LDM));
+
+	PLTFM_MSG_ALWAYS("R_AX_UDM0=0x%x\n",
+			 MAC_REG_R32(R_AX_UDM0));
+
+	PLTFM_MSG_ALWAYS("R_AX_UDM1=0x%x\n",
+			 MAC_REG_R32(R_AX_UDM1));
+
+	PLTFM_MSG_ALWAYS("R_AX_UDM2=0x%x\n",
+			 MAC_REG_R32(R_AX_UDM2));
+
+	PLTFM_MSG_ALWAYS("R_AX_UDM3=0x%x\n",
+			 MAC_REG_R32(R_AX_UDM3));
+
+	PLTFM_MSG_ALWAYS("R_AX_IC_PWR_STATE=0x%x\n",
+			 MAC_REG_R32(R_AX_IC_PWR_STATE));
+
+	if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+		PLTFM_MSG_ALWAYS("R_AX_PCIE_MIO_INTF=0x%x\n",
+				 MAC_REG_R32(R_AX_PCIE_MIO_INTF));
+
+		PLTFM_MSG_ALWAYS("R_AX_PCIE_MIO_INTD=0x%x\n",
+				 MAC_REG_R32(R_AX_PCIE_MIO_INTD));
+
+		PLTFM_MSG_ALWAYS("R_AX_PCIE_INIT_CFG1=0x%x\n",
+				 MAC_REG_R32(R_AX_PCIE_INIT_CFG1));
+
+		PLTFM_MSG_ALWAYS("R_AX_PCIE_DMA_STOP1=0x%x\n",
+				 MAC_REG_R32(R_AX_PCIE_DMA_STOP1));
+
+		PLTFM_MSG_ALWAYS("R_AX_PCIE_DMA_BUSY1=0x%x\n",
+				 MAC_REG_R32(R_AX_PCIE_DMA_BUSY1));
+
+		PLTFM_MSG_ALWAYS("R_AX_PCIE_DBG_CTRL=0x%x\n",
+				 MAC_REG_R32(R_AX_PCIE_DBG_CTRL));
+
+		PLTFM_MSG_ALWAYS("R_AX_DBG_ERR_FLAG=0x%x\n",
+				 MAC_REG_R32(R_AX_DBG_ERR_FLAG));
+
+		PLTFM_MSG_ALWAYS("R_AX_LBC_WATCHDOG=0x%x\n",
+				 MAC_REG_R32(R_AX_LBC_WATCHDOG));
+
+		PLTFM_MSG_ALWAYS("R_AX_ACH0_TXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH0_TXBD_IDX));
+
+		PLTFM_MSG_ALWAYS("R_AX_ACH1_TXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH1_TXBD_IDX));
+
+		PLTFM_MSG_ALWAYS("R_AX_ACH2_TXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH2_TXBD_IDX));
+
+		PLTFM_MSG_ALWAYS("R_AX_ACH3_TXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH3_TXBD_IDX));
+
+		PLTFM_MSG_ALWAYS("R_AX_ACH4_TXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH4_TXBD_IDX));
+
+		PLTFM_MSG_ALWAYS("R_AX_ACH5_TXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH5_TXBD_IDX));
+
+		PLTFM_MSG_ALWAYS("R_AX_ACH6_TXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH6_TXBD_IDX));
+
+		PLTFM_MSG_ALWAYS("R_AX_ACH7_TXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_ACH7_TXBD_IDX));
+
+		PLTFM_MSG_ALWAYS("R_AX_CH8_TXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_CH8_TXBD_IDX));
+
+		PLTFM_MSG_ALWAYS("R_AX_CH9_TXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_CH9_TXBD_IDX));
+
+		PLTFM_MSG_ALWAYS("R_AX_CH12_TXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_CH12_TXBD_IDX));
+
+		PLTFM_MSG_ALWAYS("R_AX_RXQ_RXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_RXQ_RXBD_IDX));
+
+		PLTFM_MSG_ALWAYS("R_AX_RPQ_RXBD_IDX=0x%x\n",
+				 MAC_REG_R32(R_AX_RPQ_RXBD_IDX));
+	}
+
+	return MACSUCCESS;
+}
+
+u32 cmac_dbg_dump_8852b(struct mac_ax_adapter *adapter, enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret, reg;
+
+	if (band == MAC_AX_BAND_1 && is_chip_id(adapter, MAC_AX_CHIP_ID_8852B))
+		return MACSUCCESS;
+
+	adapter->sm.l2_st = MAC_AX_L2_DIS;
+	/* Func/Clk band 0 */
+	if (band == MAC_AX_BAND_0) {
+		reg = R_AX_CMAC_FUNC_EN;
+		PLTFM_MSG_ALWAYS("B%d R_AX_CMAC_FUNC_EN=0x%x\n", band,
+				 MAC_REG_R32(reg));
+
+		reg = R_AX_CK_EN;
+		PLTFM_MSG_ALWAYS("B%d R_AX_CK_EN=0x%x\n", band,
+				 MAC_REG_R32(reg));
+	}
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] check cmac en %d\n", ret);
+		return ret;
+	}
+
+	/* Func/Clk band 1 */
+	if (band == MAC_AX_BAND_1) {
+		reg = R_AX_CMAC_FUNC_EN_C1;
+		PLTFM_MSG_ALWAYS("B%d R_AX_CMAC_FUNC_EN=0x%x\n", band,
+				 MAC_REG_R32(reg));
+
+		reg = R_AX_CK_EN_C1;
+		PLTFM_MSG_ALWAYS("B%d R_AX_CK_EN=0x%x\n", band,
+				 MAC_REG_R32(reg));
+	}
+
+	/* Error IMR/ISR & Flag */
+	reg = band == MAC_AX_BAND_1 ? R_AX_CMAC_ERR_IMR_C1 : R_AX_CMAC_ERR_IMR;
+	PLTFM_MSG_ALWAYS("B%d R_AX_CMAC_ERR_IMR=0x%x\n", band, MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ? R_AX_CMAC_ERR_ISR_C1 : R_AX_CMAC_ERR_ISR;
+	PLTFM_MSG_ALWAYS("B%d R_AX_CMAC_ERR_ISR=0x%x\n", band, MAC_REG_R32(reg));
+
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_SCHEDULE_ERR_IMR_C1 : R_AX_SCHEDULE_ERR_IMR;
+	PLTFM_MSG_ALWAYS("[0]B%d R_AX_SCHEDULE_ERR_IMR=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_SCHEDULE_ERR_ISR_C1 : R_AX_SCHEDULE_ERR_ISR;
+	PLTFM_MSG_ALWAYS("[0]B%d R_AX_SCHEDULE_ERR_ISR=0x%x\n", band,
+			 MAC_REG_R32(reg));
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_PTCL_IMR0_C1 : R_AX_PTCL_IMR0;
+	PLTFM_MSG_ALWAYS("[1]B%d R_AX_PTCL_IMR0=0x%x\n", band, MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ? R_AX_PTCL_ISR0_C1 : R_AX_PTCL_ISR0;
+	PLTFM_MSG_ALWAYS("[1]B%d R_AX_PTCL_ISR0=0x%x\n", band, MAC_REG_R32(reg));
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_DLE_CTRL_C1 : R_AX_DLE_CTRL;
+	PLTFM_MSG_ALWAYS("[3]B%d R_AX_DLE_CTRL=0x%x\n", band, MAC_REG_R32(reg));
+
+	reg = band == MAC_AX_BAND_1 ?
+	      R_AX_PHYINFO_ERR_IMR_C1 : R_AX_PHYINFO_ERR_IMR;
+	PLTFM_MSG_ALWAYS("[4]B%d R_AX_PHYINFO_ERR_IMR=0x%x\n", band,
+			 MAC_REG_R32(reg));
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_TXPWR_IMR_C1 : R_AX_TXPWR_IMR;
+	PLTFM_MSG_ALWAYS("[5]B%d R_AX_TXPWR_IMR=0x%x\n", band, MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ? R_AX_TXPWR_ISR_C1 : R_AX_TXPWR_ISR;
+	PLTFM_MSG_ALWAYS("[5]B%d R_AX_TXPWR_ISR=0x%x\n", band, MAC_REG_R32(reg));
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_RMAC_ERR_ISR_C1 : R_AX_RMAC_ERR_ISR;
+	PLTFM_MSG_ALWAYS("[6]B%d R_AX_RMAC_ERR_ISR=0x%x\n", band,
+			 MAC_REG_R32(reg));
+
+	reg = band == MAC_AX_BAND_1 ?
+		      R_AX_TMAC_ERR_IMR_ISR_C1 : R_AX_TMAC_ERR_IMR_ISR;
+	PLTFM_MSG_ALWAYS("[7]B%d R_AX_TMAC_ERR_IMR_ISR=0x%x\n", band,
+			 MAC_REG_R32(reg));
+
+	/* CMAC DMA */
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_RXDMA_ERR_FLG_0_C1 : R_AX_RXDMA_ERR_FLG_0;
+	PLTFM_MSG_ALWAYS("B%d R_AX_RXDMA_ERR_FLG_0=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_RXDMA_ERR_FLG_1_C1 : R_AX_RXDMA_ERR_FLG_1;
+	PLTFM_MSG_ALWAYS("B%d R_AX_RXDMA_ERR_FLG_1=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_RXDMA_PKT_INFO_0_C1 : R_AX_RXDMA_PKT_INFO_0;
+	PLTFM_MSG_ALWAYS("B%d R_AX_RXDMA_PKT_INFO_0=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_RXDMA_PKT_INFO_1_C1 : R_AX_RXDMA_PKT_INFO_1;
+	PLTFM_MSG_ALWAYS("B%d R_AX_RXDMA_PKT_INFO_1=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_RXDMA_PKT_INFO_2_C1 : R_AX_RXDMA_PKT_INFO_2;
+	PLTFM_MSG_ALWAYS("B%d R_AX_RXDMA_PKT_INFO_2=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_RXDMA_PKT_INFO_3_C1 : R_AX_RXDMA_PKT_INFO_3;
+	PLTFM_MSG_ALWAYS("B%d R_AX_RXDMA_PKT_INFO_3=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_RXDMA_PKT_INFO_4_C1 : R_AX_RXDMA_PKT_INFO_4;
+	PLTFM_MSG_ALWAYS("B%d R_AX_RXDMA_PKT_INFO_4=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_TXDMA_FIFO_INFO_0_C1 : R_AX_TXDMA_FIFO_INFO_0;
+	PLTFM_MSG_ALWAYS("B%d R_AX_TXDMA_FIFO_INFO_0=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_TXDMA_FIFO_INFO_1_C1 : R_AX_TXDMA_FIFO_INFO_1;
+	PLTFM_MSG_ALWAYS("B%d R_AX_TXDMA_FIFO_INFO_1=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_TXDMA_FIFO_INFO_2_C1 : R_AX_TXDMA_FIFO_INFO_2;
+	PLTFM_MSG_ALWAYS("B%d R_AX_TXDMA_FIFO_INFO_2=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ? R_AX_TXDMA_DBG_C1 : R_AX_TXDMA_DBG;
+	PLTFM_MSG_ALWAYS("B%d R_AX_TXDMA_DBG=0x%x\n", band, MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_TXDMA_RU_INFO_0_C1 : R_AX_TXDMA_RU_INFO_0;
+	PLTFM_MSG_ALWAYS("B%d R_AX_TXDMA_RU_INFO_0=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_TXDMA_RU_INFO_1_C1 : R_AX_TXDMA_RU_INFO_1;
+	PLTFM_MSG_ALWAYS("B%d R_AX_TXDMA_RU_INFO_1=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_TXDMA_RU_INFO_2_C1 : R_AX_TXDMA_RU_INFO_2;
+	PLTFM_MSG_ALWAYS("B%d R_AX_TXDMA_RU_INFO_2=0x%x\n", band,
+			 MAC_REG_R32(reg));
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_TXDMA_RU_INFO_3_C1 : R_AX_TXDMA_RU_INFO_3;
+	PLTFM_MSG_ALWAYS("B%d R_AX_TXDMA_RU_INFO_3=0x%x\n", band,
+			 MAC_REG_R32(reg));
+
+	/* TMAC */
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_MACTX_DBG_SEL_CNT_C1 : R_AX_MACTX_DBG_SEL_CNT;
+	PLTFM_MSG_ALWAYS("B%d R_AX_MACTX_DBG_SEL_CNT=0x%x\n", band,
+			 MAC_REG_R32(reg));
+
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_WMAC_TX_CTRL_DEBUG_C1 : R_AX_WMAC_TX_CTRL_DEBUG;
+	PLTFM_MSG_ALWAYS("B%d R_AX_WMAC_TX_CTRL_DEBUG=0x%x\n", band,
+			 MAC_REG_R32(reg));
+
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_WMAC_TX_INFO0_DEBUG_C1 : R_AX_WMAC_TX_INFO0_DEBUG;
+	PLTFM_MSG_ALWAYS("B%d R_AX_WMAC_TX_INFO0_DEBUG=0x%x\n", band,
+			 MAC_REG_R32(reg));
+
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_WMAC_TX_INFO1_DEBUG_C1 : R_AX_WMAC_TX_INFO1_DEBUG;
+	PLTFM_MSG_ALWAYS("B%d R_AX_WMAC_TX_INFO1_DEBUG=0x%x\n", band,
+			 MAC_REG_R32(reg));
+
+	/* TMAC TX COUNTER */
+	ret = tx_cnt_dump(adapter, band, TRX_CNT_REPT_CNT);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ALWAYS("[ERR]tx cnt dump err %d\n", ret);
+
+	/* TRX PTCL */
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_MAC_LOOPBACK_COUNT_C1 : R_AX_MAC_LOOPBACK_COUNT;
+	PLTFM_MSG_ALWAYS("B%d R_AX_MAC_LOOPBACK_COUNT=0x%x\n", band,
+			 MAC_REG_R32(reg));
+
+	/* RMAC */
+	reg = band == MAC_AX_BAND_1 ? R_AX_RCR_C1 : R_AX_RCR;
+	PLTFM_MSG_ALWAYS("B%d R_AX_RCR=0x%x\n", band, MAC_REG_R16(reg));
+
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_DLK_PROTECT_CTL_C1 : R_AX_DLK_PROTECT_CTL;
+	PLTFM_MSG_ALWAYS("B%d R_AX_DLK_PROTECT_CTL=0x%x\n", band, MAC_REG_R16(reg));
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_PPDU_STAT_C1 : R_AX_PPDU_STAT;
+	PLTFM_MSG_ALWAYS("B%d R_AX_PPDU_STAT=0x%x\n", band, MAC_REG_R16(reg));
+
+	reg = band == MAC_AX_BAND_1 ?
+			 R_AX_PPDU_STAT_ERR_C1 : R_AX_PPDU_STAT_ERR;
+	PLTFM_MSG_ALWAYS("B%d R_AX_PPDU_STAT_ERR=0x%x\n", band, MAC_REG_R16(reg));
+
+	/* RMAC RX COUNTER */
+	ret = rx_cnt_dump(adapter, band, TRX_CNT_REPT_CNT);
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ALWAYS("[ERR]rx cnt dump err %d\n", ret);
+
+	adapter->sm.l2_st = MAC_AX_L2_EN;
+
+	return MACSUCCESS;
+}
+
+u32 dmac_dbg_dump_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret;
+
+	/* Func/Clk */
+	PLTFM_MSG_ALWAYS("R_AX_DMAC_FUNC_EN=0x%x\n",
+			 MAC_REG_R32(R_AX_DMAC_FUNC_EN));
+	PLTFM_MSG_ALWAYS("R_AX_DMAC_CLK_EN=0x%x\n",
+			 MAC_REG_R32(R_AX_DMAC_CLK_EN));
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ALWAYS("[ERR] check dmac en %d\n", ret);
+		return ret;
+	}
+	/* Common */
+	PLTFM_MSG_ALWAYS("R_AX_SER_DBG_INFO=0x%x\n",
+			 MAC_REG_R32(R_AX_SER_DBG_INFO));
+	PLTFM_MSG_ALWAYS("R_AX_DLE_EMPTY0=0x%x\n",
+			 MAC_REG_R32(R_AX_DLE_EMPTY0));
+	PLTFM_MSG_ALWAYS("R_AX_DLE_EMPTY1=0x%x\n",
+			 MAC_REG_R32(R_AX_DLE_EMPTY1));
+	/* Error IMR/ISR & Flag */
+	PLTFM_MSG_ALWAYS("R_AX_DMAC_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_DMAC_ERR_IMR));
+	PLTFM_MSG_ALWAYS("R_AX_DMAC_ERR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_DMAC_ERR_ISR));
+	PLTFM_MSG_ALWAYS("[0]R_AX_WDRLS_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_WDRLS_ERR_IMR));
+	PLTFM_MSG_ALWAYS("[0]R_AX_WDRLS_ERR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_WDRLS_ERR_ISR));
+	PLTFM_MSG_ALWAYS("[1]R_AX_SEC_ERR_IMR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_SEC_DEBUG));
+	PLTFM_MSG_ALWAYS("[2.1]R_AX_MPDU_TX_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_MPDU_TX_ERR_IMR));
+	PLTFM_MSG_ALWAYS("[2.1]R_AX_MPDU_TX_ERR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_MPDU_TX_ERR_ISR));
+	PLTFM_MSG_ALWAYS("[2.2]R_AX_MPDU_RX_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_MPDU_RX_ERR_IMR));
+	PLTFM_MSG_ALWAYS("[2.2]R_AX_MPDU_RX_ERR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_MPDU_RX_ERR_ISR));
+	PLTFM_MSG_ALWAYS("[3]R_AX_STA_SCHEDULER_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_STA_SCHEDULER_ERR_IMR));
+	PLTFM_MSG_ALWAYS("[3]R_AX_STA_SCHEDULER_ERR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_STA_SCHEDULER_ERR_ISR));
+	PLTFM_MSG_ALWAYS("[4]R_AX_WDE_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_WDE_ERR_IMR));
+	PLTFM_MSG_ALWAYS("[4]R_AX_WDE_ERR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_WDE_ERR_ISR));
+	PLTFM_MSG_ALWAYS("[5.1]R_AX_TXPKTCTL_ERR_IMR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_TXPKTCTL_ERR_IMR_ISR));
+	PLTFM_MSG_ALWAYS("[5.2]R_AX_TXPKTCTL_ERR_IMR_ISR_B1=0x%x\n",
+			 MAC_REG_R32(R_AX_TXPKTCTL_ERR_IMR_ISR_B1));
+	PLTFM_MSG_ALWAYS("[6]R_AX_PLE_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_PLE_ERR_IMR));
+	PLTFM_MSG_ALWAYS("[6]R_AX_PLE_ERR_FLAG_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_PLE_ERR_FLAG_ISR));
+	PLTFM_MSG_ALWAYS("[7]R_AX_PKTIN_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_PKTIN_ERR_IMR));
+	PLTFM_MSG_ALWAYS("[7]R_AX_PKTIN_ERR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_PKTIN_ERR_ISR));
+	PLTFM_MSG_ALWAYS("[8.1]R_AX_OTHER_DISPATCHER_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_OTHER_DISPATCHER_ERR_IMR));
+	PLTFM_MSG_ALWAYS("[8.1]R_AX_OTHER_DISPATCHER_ERR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_OTHER_DISPATCHER_ERR_ISR));
+	PLTFM_MSG_ALWAYS("[8.2]R_AX_HOST_DISPATCHER_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_HOST_DISPATCHER_ERR_IMR));
+	PLTFM_MSG_ALWAYS("[8.2]R_AX_HOST_DISPATCHER_ERR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_HOST_DISPATCHER_ERR_ISR));
+	PLTFM_MSG_ALWAYS("[8.3]R_AX_CPU_DISPATCHER_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_CPU_DISPATCHER_ERR_IMR));
+	PLTFM_MSG_ALWAYS("[8.3]R_AX_CPU_DISPATCHER_ERR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_CPU_DISPATCHER_ERR_ISR));
+	PLTFM_MSG_ALWAYS("[10]R_AX_CPUIO_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_CPUIO_ERR_IMR));
+	PLTFM_MSG_ALWAYS("[10]R_AX_CPUIO_ERR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_CPUIO_ERR_ISR));
+	PLTFM_MSG_ALWAYS("[11.1]R_AX_BBRPT_COM_ERR_IMR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_BBRPT_COM_ERR_IMR_ISR));
+	PLTFM_MSG_ALWAYS("[11.2]R_AX_BBRPT_CHINFO_ERR_IMR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_BBRPT_CHINFO_ERR_IMR_ISR));
+	PLTFM_MSG_ALWAYS("[11.3]R_AX_BBRPT_DFS_ERR_IMR_ISR=0x%x\n",
+			 MAC_REG_R32(R_AX_BBRPT_DFS_ERR_IMR_ISR));
+	PLTFM_MSG_ALWAYS("[11.4]R_AX_LA_ERRFLAG=0x%x\n",
+			 MAC_REG_R32(R_AX_LA_ERRFLAG));
+	PLTFM_MSG_ALWAYS("R_AX_HCI_FC_ERR_FLAG=0x%x\n",
+			 MAC_REG_R32(R_AX_HCI_FC_ERR_FLAG));
+
+	/* Dispatcher */
+	PLTFM_MSG_ALWAYS("R_AX_DISPATCHER_GLOBAL_SETTING_0=0x%x\n",
+			 MAC_REG_R32(R_AX_DISPATCHER_GLOBAL_SETTING_0));
+	PLTFM_MSG_ALWAYS("R_AX_TX_ADDRESS_INFO_MODE_SETTING=0x%x\n",
+			 MAC_REG_R32(R_AX_TX_ADDRESS_INFO_MODE_SETTING));
+	PLTFM_MSG_ALWAYS("R_AX_CPU_PORT_DEBUG_SETTING=0x%x\n",
+			 MAC_REG_R32(R_AX_CPU_PORT_DEBUG_SETTING));
+	PLTFM_MSG_ALWAYS("R_AX_HDP_DBG_INFO_4=0x%x\n",
+			 MAC_REG_R32(R_AX_HDP_DBG_INFO_4));
+	/* PKTIN */
+	PLTFM_MSG_ALWAYS("R_AX_PKTIN_SETTING=0x%x\n",
+			 MAC_REG_R32(R_AX_PKTIN_SETTING));
+	/* MPDU Proc */
+	PLTFM_MSG_ALWAYS("R_AX_TX_PTK_CNT=0x%x\n",
+			 MAC_REG_R32(R_AX_TX_PTK_CNT));
+	PLTFM_MSG_ALWAYS("R_AX_MPDU_TX_ERRFLAG=0x%x\n",
+			 MAC_REG_R32(R_AX_MPDU_TX_ERR_ISR));
+	PLTFM_MSG_ALWAYS("R_AX_MPDU_TX_ERRFLAG_MSK=0x%x\n",
+			 MAC_REG_R32(R_AX_MPDU_TX_ERR_IMR));
+	PLTFM_MSG_ALWAYS("R_AX_MPDU_RX_PKTCNT=0x%x\n",
+			 MAC_REG_R32(R_AX_MPDU_RX_PKTCNT));
+	PLTFM_MSG_ALWAYS("R_AX_MPDU_DROP_PKTCNT=0x%x\n",
+			 MAC_REG_R32(R_AX_MPDU_DROP_PKTCNT));
+	/* STA SCH */
+	PLTFM_MSG_ALWAYS("R_AX_SS_CTRL=0x%x\n", MAC_REG_R32(R_AX_SS_CTRL));
+	PLTFM_MSG_ALWAYS("R_AX_SS_DBG_0=0x%x\n", MAC_REG_R32(R_AX_SS_DBG_0));
+	PLTFM_MSG_ALWAYS("R_AX_SS_DBG_1=0x%x\n", MAC_REG_R32(R_AX_SS_DBG_1));
+	PLTFM_MSG_ALWAYS("R_AX_SS_DBG_2=0x%x\n", MAC_REG_R32(R_AX_SS_DBG_2));
+	PLTFM_MSG_ALWAYS("R_AX_SS_DBG_3=0x%x\n", MAC_REG_R32(R_AX_SS_DBG_3));
+
+	return MACSUCCESS;
+}
+
+u32 ss_stat_chk_8852b(struct mac_ax_adapter *adapter)
+{
+	u32 val32 = 0;
+	u32 r_val32;
+	u8 fw_vld;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (adapter->hw_info->chip_id) {
+	case MAC_AX_CHIP_ID_8852A:
+		fw_vld = SS_FW_SUPPORT_8852A;
+		break;
+	case MAC_AX_CHIP_ID_8852B:
+		fw_vld = SS_FW_SUPPORT_8852B;
+		break;
+	default:
+		fw_vld = 0;
+		break;
+	}
+
+	r_val32 = MAC_REG_R32(R_AX_SS_DBG_3);
+	if (r_val32 & B_AX_SS_HW_DECR_LEN_UDN)
+		val32 |= SS_TX_HW_LEN_UDN;
+	if (r_val32 & B_AX_SS_SW_DECR_LEN_UDN)
+		val32 |= SS_TX_SW_LEN_UDN;
+	if (r_val32 & B_AX_SS_HW_ADD_LEN_OVF)
+		val32 |= SS_TX_HW_LEN_OVF;
+
+	r_val32 = MAC_REG_R32(R_AX_SS_DBG_2);
+	if (fw_vld) {
+		if (GET_FIELD(r_val32, B_AX_SS_FWTX_STAT) != 1)
+			val32 |= SS_STAT_FWTX;
+	}
+	if (GET_FIELD(r_val32, B_AX_SS_RPTA_STAT) != 1)
+		val32 |= SS_STAT_RPTA;
+	if (GET_FIELD(r_val32, B_AX_SS_WDEA_STAT) != 1)
+		val32 |= SS_STAT_WDEA;
+	if (GET_FIELD(r_val32, B_AX_SS_PLEA_STAT) != 1)
+		val32 |= SS_STAT_PLEA;
+
+	r_val32 = MAC_REG_R32(R_AX_SS_DBG_1);
+	if (GET_FIELD(r_val32, B_AX_SS_ULRU_STAT) > 1)
+		val32 |= SS_STAT_ULRU;
+	if (GET_FIELD(r_val32, B_AX_SS_DLTX_STAT) > 1)
+		val32 |= SS_STAT_DLTX;
+
+	return val32;
+}
+
+u32 tx_flow_ptcl_dbg_port_8852b(struct mac_ax_adapter *adapter, u8 band)
+{
+	u8 i;
+	u16 val16;
+	u32 ret = MACSUCCESS;
+	struct mac_ax_dbg_port_info info;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ALWAYS("[ERR] check cmac en %d\n", ret);
+		return ret;
+	}
+	info = dbg_port_ptcl_c0;
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->dbg_port_lock);
+	adapter->hw_info->dbg_port_cnt++;
+	if (adapter->hw_info->dbg_port_cnt != 1) {
+		PLTFM_MSG_ERR("[ERR]dbg port sel %x lock cnt %d\n",
+			      info.sel_addr, adapter->hw_info->dbg_port_cnt);
+		ret = MACCMP;
+		goto err;
+	}
+
+	val16 = MAC_REG_R16(info.sel_addr);
+	val16 |= B_AX_PTCL_DBG_EN;
+	MAC_REG_W16(info.sel_addr, val16);
+	PLTFM_MSG_ALWAYS("Sel addr = 0x%X\n", info.sel_addr);
+	PLTFM_MSG_ALWAYS("Read addr = 0x%X\n", info.rd_addr);
+
+	info.srt = PTCL_SEL_FSM_0;
+	info.end = PTCL_SEL_FSM_1;
+	for (i = 0; i < PTCL_DBG_DMP_CNT; i++)
+		print_dbg_port(adapter, &info);
+
+	info.srt = PTCL_SEL_PHY_DBG;
+	info.end = PTCL_SEL_PHY_DBG;
+	for (i = 0; i < PTCL_DBG_DMP_CNT; i++)
+		print_dbg_port(adapter, &info);
+
+err:
+	adapter->hw_info->dbg_port_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->dbg_port_lock);
+	return ret;
+}
+
+u32 tx_flow_sch_dbg_port_8852b(struct mac_ax_adapter *adapter, u8 band)
+{
+	u8 i;
+	u32 val32, ret = MACSUCCESS;
+	struct mac_ax_dbg_port_info info;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ALWAYS("[ERR] check cmac en %d\n", ret);
+		return ret;
+	}
+
+	info = dbg_port_sch_c0;
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->dbg_port_lock);
+	adapter->hw_info->dbg_port_cnt++;
+	if (adapter->hw_info->dbg_port_cnt != 1) {
+		PLTFM_MSG_ERR("[ERR]dbg port sel %x lock cnt %d\n",
+			      info.sel_addr, adapter->hw_info->dbg_port_cnt);
+		ret = MACCMP;
+		goto err;
+	}
+
+	val32 = MAC_REG_R32(info.sel_addr);
+	val32 |= B_AX_SCH_DBG_EN;
+	MAC_REG_W32(info.sel_addr, val32);
+
+	info.srt = SCH_SEL_PREBKF_DBG_1;
+	info.end = SCH_SEL_TX_NAV_ABORT_DBG;
+
+	PLTFM_MSG_ALWAYS("Sel addr = 0x%X\n", info.sel_addr);
+	PLTFM_MSG_ALWAYS("Read addr = 0x%X\n", info.rd_addr);
+
+	for (i = 0; i < SCH_DBG_DMP_CNT; i++)
+		print_dbg_port(adapter, &info);
+
+err:
+	adapter->hw_info->dbg_port_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->dbg_port_lock);
+	return ret;
+}
+
+u32 dbg_port_sel_8852b(struct mac_ax_adapter *adapter,
+		       struct mac_ax_dbg_port_info **info, u32 sel)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u16 val16;
+	u8 val8, index;
+	u32 ret = MACSUCCESS;
+
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->dbg_port_lock);
+	adapter->hw_info->dbg_port_cnt++;
+
+	if (adapter->hw_info->dbg_port_cnt != 1) {
+		PLTFM_MSG_ERR("[ERR]dbg port sel %d lock cnt %d\n", sel,
+			      adapter->hw_info->dbg_port_cnt);
+		ret = MACCMP;
+		goto err;
+	}
+
+	switch (sel) {
+	case MAC_AX_DBG_PORT_SEL_PTCL_C0:
+		*info = &dbg_port_ptcl_c0;
+		val16 = MAC_REG_R16(R_AX_PTCL_DBG);
+		val16 |= B_AX_PTCL_DBG_EN;
+		MAC_REG_W16(R_AX_PTCL_DBG, val16);
+		PLTFM_MSG_ALWAYS("Enable PTCL C0 dbgport.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_SCH_C0:
+		*info = &dbg_port_sch_c0;
+		val32 = MAC_REG_R32(R_AX_SCH_DBG_SEL);
+		val32 |= B_AX_SCH_DBG_EN;
+		MAC_REG_W32(R_AX_SCH_DBG_SEL, val32);
+		PLTFM_MSG_ALWAYS("Enable SCH C0 dbgport.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TMAC_C0:
+		*info = &dbg_port_tmac_c0;
+		val32 = MAC_REG_R32(R_AX_DBGSEL_TRXPTCL);
+		val32 = SET_CLR_WORD(val32, TRXPTRL_DBG_SEL_TMAC,
+				     B_AX_DBGSEL_TRXPTCL);
+		MAC_REG_W32(R_AX_DBGSEL_TRXPTCL, val32);
+
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, TMAC_DBG_SEL_C0, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, TMAC_DBG_SEL_C0, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+
+		val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+		val32 = SET_CLR_WORD(val32, MAC_DBG_SEL, B_AX_SEL_0XC0);
+		MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+		PLTFM_MSG_ALWAYS("Enable TMAC C0 dbgport.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_RMAC_C0:
+		*info = &dbg_port_rmac_c0;
+		val32 = MAC_REG_R32(R_AX_DBGSEL_TRXPTCL);
+		val32 = SET_CLR_WORD(val32, TRXPTRL_DBG_SEL_RMAC,
+				     B_AX_DBGSEL_TRXPTCL);
+		MAC_REG_W32(R_AX_DBGSEL_TRXPTCL, val32);
+
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, RMAC_DBG_SEL_C0, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, RMAC_DBG_SEL_C0, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+
+		val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+		val32 = SET_CLR_WORD(val32, MAC_DBG_SEL, B_AX_SEL_0XC0);
+		MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+
+		val8 = MAC_REG_R8(R_AX_DBGSEL_TRXPTCL);
+		val8 = (u8)(SET_CLR_WORD(val8, RMAC_CMAC_DBG_SEL,
+					 B_AX_DBGSEL_TRXPTCL));
+		MAC_REG_W8(R_AX_DBGSEL_TRXPTCL, val8);
+		PLTFM_MSG_ALWAYS("Enable RMAC C0 dbgport.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_RMACST_C0:
+		*info = &dbg_port_rmacst_c0;
+		PLTFM_MSG_ALWAYS("Enable RMAC state C0 dbgport.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_RMAC_PLCP_C0:
+		*info = &dbg_port_rmac_plcp_c0;
+		PLTFM_MSG_ALWAYS("Enable RMAC PLCP C0 dbgport.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TRXPTCL_C0:
+		*info = &dbg_port_trxptcl_c0;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, TRXPTCL_DBG_SEL_C0, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, TRXPTCL_DBG_SEL_C0, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+
+		val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+		val32 = SET_CLR_WORD(val32, MAC_DBG_SEL, B_AX_SEL_0XC0);
+		MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+		PLTFM_MSG_ALWAYS("Enable TRXPTCL C0 dbgport.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TX_INFOL_C0:
+		*info = &dbg_port_tx_infol_c0;
+		val32 = MAC_REG_R32(R_AX_TCR1);
+		val32 |= B_AX_TCR_FORCE_READ_TXDFIFO;
+		MAC_REG_W32(R_AX_TCR1, val32);
+		PLTFM_MSG_ALWAYS("Enable tx infol dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TX_INFOH_C0:
+		*info = &dbg_port_tx_infoh_c0;
+		val32 = MAC_REG_R32(R_AX_TCR1);
+		val32 |= B_AX_TCR_FORCE_READ_TXDFIFO;
+		MAC_REG_W32(R_AX_TCR1, val32);
+		PLTFM_MSG_ALWAYS("Enable tx infoh dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXTF_INFOL_C0:
+		*info = &dbg_port_txtf_infol_c0;
+		val32 = MAC_REG_R32(R_AX_TCR1);
+		val32 |= B_AX_TCR_FORCE_READ_TXDFIFO;
+		MAC_REG_W32(R_AX_TCR1, val32);
+		PLTFM_MSG_ALWAYS("Enable tx tf infol dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXTF_INFOH_C0:
+		*info = &dbg_port_txtf_infoh_c0;
+		val32 = MAC_REG_R32(R_AX_TCR1);
+		val32 |= B_AX_TCR_FORCE_READ_TXDFIFO;
+		MAC_REG_W32(R_AX_TCR1, val32);
+		PLTFM_MSG_ALWAYS("Enable tx tf infoh dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_CMAC_DMA0_C0:
+		*info = &dbg_port_cmac_dma0_c0;
+
+		val32 = MAC_REG_R32(R_AX_TXDMA_DBG) | B_AX_TXDMA_DBG_EN;
+		MAC_REG_W32(R_AX_TXDMA_DBG, val32);
+
+		val32 = MAC_REG_R32(R_AX_RXDMA_CTRL_0) | B_AX_RXDMA_DBGOUT_EN;
+		MAC_REG_W32(R_AX_RXDMA_CTRL_0, val32);
+
+		val32 = MAC_REG_R32(R_AX_DLE_CTRL) | B_AX_DMA_DBG_SEL;
+		MAC_REG_W32(R_AX_DLE_CTRL, val32);
+
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, CMAC_DMA_DBG_SEL_C0, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, CMAC_DMA_DBG_SEL_C0, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+
+		PLTFM_MSG_ALWAYS("Enable cmac0 dma0 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_CMAC_DMA1_C0:
+		*info = &dbg_port_cmac_dma1_c0;
+
+		val32 = MAC_REG_R32(R_AX_TXDMA_DBG) | B_AX_TXDMA_DBG_EN;
+		MAC_REG_W32(R_AX_TXDMA_DBG, val32);
+
+		val32 = MAC_REG_R32(R_AX_RXDMA_CTRL_0) | B_AX_RXDMA_DBGOUT_EN;
+		MAC_REG_W32(R_AX_RXDMA_CTRL_0, val32);
+
+		val32 = MAC_REG_R32(R_AX_DLE_CTRL) & ~B_AX_DMA_DBG_SEL;
+		MAC_REG_W32(R_AX_DLE_CTRL, val32);
+
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, CMAC_DMA_DBG_SEL_C0, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, CMAC_DMA_DBG_SEL_C0, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+
+		PLTFM_MSG_ALWAYS("Enable cmac0 dma1 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_BUFMGN_CTL:
+		*info = &dbg_port_wde_bufmgn_ctl;
+		PLTFM_MSG_ALWAYS("Enable wde bufmgn ctl dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_BUFMGN_ARB:
+		*info = &dbg_port_wde_bufmgn_arb;
+		PLTFM_MSG_ALWAYS("Enable wde bufmgn arb dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_QUEMGN_CTL:
+		*info = &dbg_port_wde_quemgn_ctl;
+		PLTFM_MSG_ALWAYS("Enable wde quemgn ctl dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_QUEMGN_INFO:
+		*info = &dbg_port_wde_quemgn_info;
+		PLTFM_MSG_ALWAYS("Enable wde quemgn info dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_QUEMGN_ARB:
+		*info = &dbg_port_wde_quemgn_arb;
+		PLTFM_MSG_ALWAYS("Enable wde quemgn arb dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_PORT0:
+		*info = &dbg_port_wde_portif0;
+		PLTFM_MSG_ALWAYS("Enable wde port 0 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_PORT1:
+		*info = &dbg_port_wde_portif1;
+		PLTFM_MSG_ALWAYS("Enable wde port 1 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_PORT3:
+		*info = &dbg_port_wde_portif3;
+		PLTFM_MSG_ALWAYS("Enable wde port 3 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_PORT4:
+		*info = &dbg_port_wde_portif4;
+		PLTFM_MSG_ALWAYS("Enable wde port 4 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_PORT6:
+		*info = &dbg_port_wde_portif6;
+		PLTFM_MSG_ALWAYS("Enable wde port 6 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDE_PORT7:
+		*info = &dbg_port_wde_portif7;
+		PLTFM_MSG_ALWAYS("Enable wde port 7 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_BUFMGN_CTL:
+		*info = &dbg_port_ple_bufmgn_ctl;
+		PLTFM_MSG_ALWAYS("Enable ple bufmgn ctl dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_BUFMGN_ARB:
+		*info = &dbg_port_ple_bufmgn_ctl;
+		PLTFM_MSG_ALWAYS("Enable ple bufmgn arb dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_QUEMGN_CTL:
+		*info = &dbg_port_ple_quemgn_ctl;
+		PLTFM_MSG_ALWAYS("Enable ple quemgn ctl dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_QUEMGN_INFO:
+		*info = &dbg_port_ple_quemgn_info;
+		PLTFM_MSG_ALWAYS("Enable ple quemgn info dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_QUEMGN_ARB:
+		*info = &dbg_port_ple_quemgn_arb;
+		PLTFM_MSG_ALWAYS("Enable ple quemgn arb dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT0:
+		*info = &dbg_port_ple_portif0;
+		PLTFM_MSG_ALWAYS("Enable ple port 0 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT1:
+		*info = &dbg_port_ple_portif1;
+		PLTFM_MSG_ALWAYS("Enable ple port 1_0 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT2:
+		*info = &dbg_port_ple_portif2;
+		PLTFM_MSG_ALWAYS("Enable ple port 2 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT3:
+		*info = &dbg_port_ple_portif3;
+		PLTFM_MSG_ALWAYS("Enable ple port 3 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT4:
+		*info = &dbg_port_ple_portif4;
+		PLTFM_MSG_ALWAYS("Enable ple port 4 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT5:
+		*info = &dbg_port_ple_portif5;
+		PLTFM_MSG_ALWAYS("Enable ple port 5 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PLE_PORT6:
+		*info = &dbg_port_ple_portif6;
+		PLTFM_MSG_ALWAYS("Enable ple port 6 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDRLS_CTL:
+		*info = &dbg_port_wdrls_ctl;
+		PLTFM_MSG_ALWAYS("Enable wdrls ctl dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDRLS_RPTGEN0:
+		*info = &dbg_port_wdrls_rptgen0;
+		PLTFM_MSG_ALWAYS("Enable wdrls rptgen0 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDRLS_RPTGEN1:
+		*info = &dbg_port_wdrls_rptgen1;
+		PLTFM_MSG_ALWAYS("Enable wdrls rptgen1 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDRLS_PLED_CH0:
+		*info = &dbg_port_wdrls_pledchn0;
+		PLTFM_MSG_ALWAYS("Enable wdrls pledchn0 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_WDRLS_PLED_CH1:
+		*info = &dbg_port_wdrls_pledchn1;
+		PLTFM_MSG_ALWAYS("Enable wdrls pledchn1 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_FETPKT:
+		*info = &dbg_port_txpktctrl_fetpkt;
+		PLTFM_MSG_ALWAYS("Enable txpktctrl fetpkt dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_CMDPSR:
+		*info = &dbg_port_txpktctrl_b0_cmdpsr;
+		PLTFM_MSG_ALWAYS("Enable txpktctrl b0 cmdpsr dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_CMACDMAIF:
+		*info = &dbg_port_txpktctrl_b0_cmacdmaif;
+		PLTFM_MSG_ALWAYS("Enable txpktctrl b0 cmacdmaif dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT0_0:
+		*info = &dbg_port_txpktctrl_b0_unit0_0;
+		PLTFM_MSG_ALWAYS("Enable txpktctrl b0 unit0_0 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT0_1:
+		*info = &dbg_port_txpktctrl_b0_unit0_1;
+		PLTFM_MSG_ALWAYS("Enable txpktctrl b0 unit0_1 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PKTINFO:
+		*info = &dbg_port_pktinfo;
+		PLTFM_MSG_ALWAYS("Enable pktinfo dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_TXDMA:
+		*info = &dbg_port_pcie_txdma;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_TXDMA_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_TXDMA_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie txdma dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_RXDMA:
+		*info = &dbg_port_pcie_rxdma;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_RXDMA_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_RXDMA_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie rxdma dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_CVT:
+		*info = &dbg_port_pcie_cvt;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_CVT_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_CVT_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie cvt dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC04:
+		*info = &dbg_port_pcie_emac04;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC04_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC04_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie emac 0-4 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC5:
+		*info = &dbg_port_pcie_emac5;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC5_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC5_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie emac 5 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC6:
+		*info = &dbg_port_pcie_emac6;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC6_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC6_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie emac 6 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC7:
+		*info = &dbg_port_pcie_emac7;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC7_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC7_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie emac 7 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_PNP_IO:
+		*info = &dbg_port_pcie_pnp_io;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_PNP_IO_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_PNP_IO_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie p np io dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC814:
+		*info = &dbg_port_pcie_emac814;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC814_DBG_SEL,
+				     B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC814_DBG_SEL,
+				     B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie emac 8-14 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC15:
+		*info = &dbg_port_pcie_emac15;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC15_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC15_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie emac 15 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC16:
+		*info = &dbg_port_pcie_emac16;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC16_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC16_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie emac 16 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC17:
+		*info = &dbg_port_pcie_emac17;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC17_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC17_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie emac 17 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_PCIE_EMAC18:
+		*info = &dbg_port_pcie_emac18;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC18_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PCIE_EMAC18_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable pcie emac 18 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_PHY:
+		*info = &dbg_port_usb2_phy;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB2_PHY_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB2_PHY_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB2_PHY dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_SIE:
+		*info = &dbg_port_usb2_sie;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB2_SIE_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB2_SIE_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB2_SIE dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_UTMI:
+		*info = &dbg_port_usb2_utmi;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB2_UTMI_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB2_UTMI_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB2_UTMI dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_SIE_MMU:
+		*info = &dbg_port_usb2_sie_mmu;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB2_SIE_MMU_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB2_SIE_MMU_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB2_SIE_MMU dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_SIE_PCE:
+		*info = &dbg_port_usb2_sie_pce;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB2_SIE_PCE_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB2_SIE_PCE_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB2_SIE_PCE dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_UTMI_IF:
+		*info = &dbg_port_usb2_utmi_if;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB2_UTMI_IF_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB2_UTMI_IF_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB2_UTMI_IF dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_WLTX:
+		*info = &dbg_port_usb_wltx;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB_WLTX_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB_WLTX_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB_WLTX dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_WLRX:
+		*info = &dbg_port_usb_wlrx;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB_WLRX_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB_WLRX_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB_WLRX dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB3:
+		*info = &dbg_port_usb3;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB3_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB3_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB3 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_SETUP:
+		*info = &dbg_port_usb_setup;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB_SETUP_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB_SETUP_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB_SETUP dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_WLTX_DMA:
+		*info = &dbg_port_usb_wltx_dma;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB_WLTXDMA_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB_WLTXDMA_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB_WLTX_DMA dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_WLRX_DMA:
+		*info = &dbg_port_usb_wlrx_dma;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB_WLRXDMA_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB_WLRXDMA_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB_WLRX_DMA dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_AINST:
+		*info = &dbg_port_usb_ainst;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB_AINST_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB_AINST_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB_AINST_DMA dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_MISC:
+		*info = &dbg_port_usb_misc;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB_MISC_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB_MISC_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB_MISC dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB_BTTX:
+		*info = &dbg_port_usb_bttx;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB_BTTX_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB_BTTX_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB_BTTX dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_USB2_BT:
+		*info = &dbg_port_usb2_bt;
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, USB2_BT_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, USB2_BT_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_ALWAYS("Enable USB2_BT dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX0:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX1:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX2:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX3:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX4:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX5:
+		if (sel == MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX0) {
+			val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, DISPATCHER_DBG_SEL,
+					     B_AX_DBG_SEL0);
+			MAC_REG_W32(R_AX_DBG_CTRL, val32);
+
+			val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+			val32 = SET_CLR_WORD(val32, MAC_DBG_SEL, B_AX_SEL_0XC0);
+			MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+		}
+		*info = &dbg_port_dspt_hdt_tx0_5;
+		index = (u8)(sel - MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX0);
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 0, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, index, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher hdt tx%x dump.\n", index);
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX6:
+		*info = &dbg_port_dspt_hdt_tx6;
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 0, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, 6, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher hdt tx6 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX7:
+		*info = &dbg_port_dspt_hdt_tx7;
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 0, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, 7, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher hdt tx7 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX8:
+		*info = &dbg_port_dspt_hdt_tx8;
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 0, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, 8, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher hdt tx8 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX9:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXA:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXB:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXC:
+		*info = &dbg_port_dspt_hdt_tx9_C;
+		index = (u8)(sel + 9 - MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX9);
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 0, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, index, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher hdt tx%x dump.\n", index);
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXD:
+		*info = &dbg_port_dspt_hdt_txD;
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 0, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, 0xD, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher hdt txD dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX0:
+		*info = &dbg_port_dspt_cdt_tx0;
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 1, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, 0, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher cdt tx0 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX1:
+		*info = &dbg_port_dspt_cdt_tx1;
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 1, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, 1, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher cdt tx1 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX3:
+		*info = &dbg_port_dspt_cdt_tx3;
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 1, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, 3, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher cdt tx3 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX4:
+		*info = &dbg_port_dspt_cdt_tx4;
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 1, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, 4, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher cdt tx4 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX5:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX6:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX7:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX8:
+		*info = &dbg_port_dspt_cdt_tx5_8;
+		index = (u8)(sel + 5 - MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX5);
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 1, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, index, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher cdt tx%x dump.\n", index);
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_TX9:
+		*info = &dbg_port_dspt_cdt_tx9;
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 1, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, 9, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher cdt tx9 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX0:
+		*info = &dbg_port_dspt_hdt_rx0;
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 2, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, 0, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher hdt rx0 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX1:
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX2:
+		*info = &dbg_port_dspt_hdt_rx1_2;
+		index = (u8)(sel + 1 - MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX1);
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 2, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, index, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher hdt rx%x dump.\n", index);
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX3:
+		*info = &dbg_port_dspt_hdt_rx3;
+		val16 = MAC_REG_R16((*info)->sel_addr);
+		val16 = SET_CLR_WORD(val16, 2, B_AX_DISPATCHER_INTN_SEL);
+		val16 = SET_CLR_WORD(val16, 3, B_AX_DISPATCHER_CH_SEL);
+		MAC_REG_W16((*info)->sel_addr, val16);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher hdt rx3 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0:
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0_0:
+		*info = &dbg_port_dspt_cdt_rx_p0_0;
+		val8 = MAC_REG_R8((*info)->sel_addr);
+		val8 = SET_CLR_WORD(val8, 3, B_AX_DISPATCHER_INTN_SEL);
+		MAC_REG_W8((*info)->sel_addr, val8);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher cdt rx part0 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P1:
+		*info = &dbg_port_dspt_cdt_rx_p1;
+		val8 = MAC_REG_R8((*info)->sel_addr);
+		val8 = SET_CLR_WORD(val8, 3, B_AX_DISPATCHER_INTN_SEL);
+		MAC_REG_W8((*info)->sel_addr, val8);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher cdt rx part1 dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_STF_CTRL:
+		*info = &dbg_port_dspt_stf_ctrl;
+		val8 = MAC_REG_R8((*info)->sel_addr);
+		val8 = SET_CLR_WORD(val8, 4, B_AX_DISPATCHER_INTN_SEL);
+		MAC_REG_W8((*info)->sel_addr, val8);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher stf control dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_ADDR_CTRL:
+		*info = &dbg_port_dspt_addr_ctrl;
+		val8 = MAC_REG_R8((*info)->sel_addr);
+		val8 = SET_CLR_WORD(val8, 5, B_AX_DISPATCHER_INTN_SEL);
+		MAC_REG_W8((*info)->sel_addr, val8);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher addr control dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_WDE_INTF:
+		*info = &dbg_port_dspt_wde_intf;
+		val8 = MAC_REG_R8((*info)->sel_addr);
+		val8 = SET_CLR_WORD(val8, 6, B_AX_DISPATCHER_INTN_SEL);
+		MAC_REG_W8((*info)->sel_addr, val8);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher wde interface dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_PLE_INTF:
+		*info = &dbg_port_dspt_ple_intf;
+		val8 = MAC_REG_R8((*info)->sel_addr);
+		val8 = SET_CLR_WORD(val8, 7, B_AX_DISPATCHER_INTN_SEL);
+		MAC_REG_W8((*info)->sel_addr, val8);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher ple interface dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_DSPT_FLOW_CTRL:
+		*info = &dbg_port_dspt_flow_ctrl;
+		val8 = MAC_REG_R8((*info)->sel_addr);
+		val8 = SET_CLR_WORD(val8, 8, B_AX_DISPATCHER_INTN_SEL);
+		MAC_REG_W8((*info)->sel_addr, val8);
+		PLTFM_MSG_ALWAYS("Enable Dispatcher flow control dump.\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_AXI_TXDMA_CTRL:
+		*info = &dbg_port_axi_txdma_ctrl;
+		val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+		val32 = SET_CLR_WORD(val32, MAC_DBG_SEL, B_AX_SEL_0XC0);
+		MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PAXIDMA_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PAXIDMA_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_WARN("%s ind access sel %d start\n", __func__, sel);
+		PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+		adapter->hw_info->ind_aces_cnt++;
+		MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, AXIDMA_BASE_ADDR);
+		val32 = MAC_REG_R32((*info)->sel_addr);
+		val32 = SET_CLR_WORD(val32, 0, B_AX_AXIDMA_INT_SEL);
+		MAC_REG_W32((*info)->sel_addr, val32);
+		PLTFM_MSG_ALWAYS("Enable AXIDMA TXDMA CTRL dump\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_AXI_RXDMA_CTRL:
+		*info = &dbg_port_axi_rxdma_ctrl;
+		val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+		val32 = SET_CLR_WORD(val32, MAC_DBG_SEL, B_AX_SEL_0XC0);
+		MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PAXIDMA_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PAXIDMA_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_WARN("%s ind access sel %d start\n", __func__, sel);
+		PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+		adapter->hw_info->ind_aces_cnt++;
+		MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, AXIDMA_BASE_ADDR);
+		val32 = MAC_REG_R32((*info)->sel_addr);
+		val32 = SET_CLR_WORD(val32, 1, B_AX_AXIDMA_INT_SEL);
+		MAC_REG_W32((*info)->sel_addr, val32);
+		PLTFM_MSG_ALWAYS("Enable AXIDMA RXDMA CTRL dump\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_AXI_MST_WLAN:
+		*info = &dbg_port_axi_mst_wlan;
+		val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+		val32 = SET_CLR_WORD(val32, MAC_DBG_SEL, B_AX_SEL_0XC0);
+		MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PAXIDMA_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PAXIDMA_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_WARN("%s ind access sel %d start\n", __func__, sel);
+		PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+		adapter->hw_info->ind_aces_cnt++;
+		MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, AXIDMA_BASE_ADDR);
+		val32 = MAC_REG_R32((*info)->sel_addr);
+		val32 = SET_CLR_WORD(val32, 2, B_AX_AXIDMA_INT_SEL);
+		MAC_REG_W32((*info)->sel_addr, val32);
+		PLTFM_MSG_ALWAYS("Enable AXIDMA MST WLAN dump\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_AXI_INT_WLAN:
+		*info = &dbg_port_axi_int_wlan;
+		val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+		val32 = SET_CLR_WORD(val32, MAC_DBG_SEL, B_AX_SEL_0XC0);
+		MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PAXIDMA_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PAXIDMA_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_WARN("%s ind access sel %d start\n", __func__, sel);
+		PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+		adapter->hw_info->ind_aces_cnt++;
+		MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, AXIDMA_BASE_ADDR);
+		val32 = MAC_REG_R32((*info)->sel_addr);
+		val32 = SET_CLR_WORD(val32, 3, B_AX_AXIDMA_INT_SEL);
+		MAC_REG_W32((*info)->sel_addr, val32);
+		PLTFM_MSG_ALWAYS("Enable AXIDMA INT WLAN dump\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_AXI_PAGE_FLOW_CTRL:
+		*info = &dbg_port_axi_page_fc;
+		val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+		val32 = SET_CLR_WORD(val32, MAC_DBG_SEL, B_AX_SEL_0XC0);
+		MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+		val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+		val32 = SET_CLR_WORD(val32, PAXIDMA_DBG_SEL, B_AX_DBG_SEL0);
+		val32 = SET_CLR_WORD(val32, PAXIDMA_DBG_SEL, B_AX_DBG_SEL1);
+		MAC_REG_W32(R_AX_DBG_CTRL, val32);
+		PLTFM_MSG_WARN("%s ind access sel %d start\n", __func__, sel);
+		PLTFM_MUTEX_LOCK(&adapter->hw_info->ind_access_lock);
+		adapter->hw_info->ind_aces_cnt++;
+		MAC_REG_W32(R_AX_FILTER_MODEL_ADDR, AXIDMA_BASE_ADDR);
+		val32 = MAC_REG_R32((*info)->sel_addr);
+		val32 = SET_CLR_WORD(val32, 4, B_AX_AXIDMA_INT_SEL);
+		MAC_REG_W32((*info)->sel_addr, val32);
+		PLTFM_MSG_ALWAYS("Enable AXIDMA PAGE FLOW CTRL dump\n");
+		break;
+	case MAC_AX_DBG_PORT_SEL_STA_SCH:
+		*info = &dbg_port_sta_sch;
+		PLTFM_MSG_ALWAYS("Enable STA_SCH dbgport.\n");
+		break;
+	default:
+		PLTFM_MSG_ALWAYS("Dbg port select err\n");
+		*info = NULL;
+		ret = MACDBGPORTSEL;
+		goto err;
+	}
+
+	return MACSUCCESS;
+err:
+	if (ret == MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dbg port sel has no err code\n");
+		ret = MACPROCERR;
+	}
+	adapter->hw_info->dbg_port_cnt--;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->dbg_port_lock);
+	return ret;
+}
+
+u32 dbg_port_sel_rst_8852b(struct mac_ax_adapter *adapter, u32 sel)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	switch (sel) {
+	case MAC_AX_DBG_PORT_SEL_TX_INFOL_C0:
+	case MAC_AX_DBG_PORT_SEL_TX_INFOH_C0:
+	case MAC_AX_DBG_PORT_SEL_TXTF_INFOL_C0:
+	case MAC_AX_DBG_PORT_SEL_TXTF_INFOH_C0:
+		val32 = MAC_REG_R32(R_AX_TCR1);
+		val32 &= ~B_AX_TCR_FORCE_READ_TXDFIFO;
+		MAC_REG_W32(R_AX_TCR1, val32);
+		break;
+	case MAC_AX_DBG_PORT_SEL_AXI_TXDMA_CTRL:
+	case MAC_AX_DBG_PORT_SEL_AXI_RXDMA_CTRL:
+	case MAC_AX_DBG_PORT_SEL_AXI_MST_WLAN:
+	case MAC_AX_DBG_PORT_SEL_AXI_INT_WLAN:
+	case MAC_AX_DBG_PORT_SEL_AXI_PAGE_FLOW_CTRL:
+		adapter->hw_info->ind_aces_cnt--;
+		PLTFM_MUTEX_UNLOCK(&adapter->hw_info->ind_access_lock);
+		PLTFM_MSG_WARN("%s ind access sel %d end\n", __func__, sel);
+		break;
+	default:
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+u8 is_dbg_port_not_valid_8852b(struct mac_ax_adapter *adapter, u32 dbg_sel)
+{
+	if (adapter->hw_info->intf != MAC_AX_INTF_PCIE &&
+	    dbg_sel >= MAC_AX_DBG_PORT_SEL_PCIE_TXDMA &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_PCIE_EMAC18)
+		return 1;
+	if (adapter->hw_info->intf != MAC_AX_INTF_USB &&
+	    dbg_sel >= MAC_AX_DBG_PORT_SEL_USB2_PHY &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_USB2_BT)
+		return 1;
+	if (check_mac_en(adapter, 0, MAC_AX_DMAC_SEL) != MACSUCCESS &&
+	    dbg_sel >= MAC_AX_DBG_PORT_SEL_WDE_BUFMGN_CTL &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_PRELD_B1)
+		return 1;
+	if (dbg_sel >= MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B0_UNIT1_0 &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_TXPKTCTRL_B1_UNIT0_1)
+		return 1;
+	if (dbg_sel >= MAC_AX_DBG_PORT_SEL_MPDUINFO_B0 &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_PRELD_B1)
+		return 1;
+	if (check_mac_en(adapter, 0, MAC_AX_DMAC_SEL) != MACSUCCESS &&
+	    dbg_sel >= MAC_AX_DBG_PORT_SEL_DSPT_HDT_TX0 &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_DSPT_FLOW_CTRL)
+		return 1;
+	if (check_mac_en(adapter, MAC_AX_BAND_0, MAC_AX_CMAC_SEL) != MACSUCCESS &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_CMAC_DMA1_C0)
+		return 1;
+	if (dbg_sel >= MAC_AX_DBG_PORT_SEL_PTCL_C1 &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_TXTF_INFOH_C1)
+		return 1;
+	if ((adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY ||
+	     adapter->hw_info->is_sec_ic) &&
+	    dbg_sel >= MAC_AX_DBG_PORT_SEL_AXI_TXDMA_CTRL &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_AXI_PAGE_FLOW_CTRL)
+		return 1;
+	if (dbg_sel >= MAC_AX_DBG_PORT_SEL_PAXI_TXDMA &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_HAXI_INT)
+		return 1;
+	if (check_mac_en(adapter, 0, MAC_AX_DMAC_SEL) != MACSUCCESS &&
+	    dbg_sel == MAC_AX_DBG_PORT_SEL_STA_SCH)
+		return 1;
+
+	if (dbg_sel >= MAC_AX_DBG_PORT_SEL_DSPT_CDT_TXA &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_DSPT_CDT_TXC)
+		return 1;
+	if (dbg_sel >= MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXE &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_DSPT_HDT_TXF)
+		return 1;
+	if (dbg_sel >= MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX4 &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_DSPT_HDT_RX5)
+		return 1;
+	if (dbg_sel >= MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0_1 &&
+	    dbg_sel <= MAC_AX_DBG_PORT_SEL_DSPT_CDT_RX_P0_2)
+		return 1;
+
+	return 0;
+}
+
+#endif /* MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dbgpkg_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dbgpkg_8852b.h
new file mode 100644
index 000000000000..fad6dd9933c0
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dbgpkg_8852b.h
@@ -0,0 +1,163 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_DBGPKG_8852B_H_
+#define _MAC_AX_DBGPKG_8852B_H_
+
+#include "../../mac_def.h"
+
+#if MAC_AX_8852B_SUPPORT
+
+/**
+ * @brief tx_dbg_dump_8852a
+ * mac tx_dbg_dump_8852a
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 tx_dbg_dump_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief crit_dbg_dump_8852b
+ * mac crit_dbg_dump_8852b
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 crit_dbg_dump_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief cmac_dbg_dump_8852b
+ * mac cmac_dbg_dump_8852b
+ * @param *adapter
+ * @param *band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmac_dbg_dump_8852b(struct mac_ax_adapter *adapter, enum mac_ax_band band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief dmac_dbg_dump_8852b
+ * mac dmac_dbg_dump_8852b
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dmac_dbg_dump_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief dbg_port_sel_8852b
+ * mac debug port sel 8852b
+ * @param *adapter
+ * @param *mac_ax_dbg_port_info
+ * @param *sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dbg_port_sel_8852b(struct mac_ax_adapter *adapter,
+		       struct mac_ax_dbg_port_info **info, u32 sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief dbg_port_sel_rst_8852b
+ * mac debug port sel rst 8852b
+ * @param *adapter
+ * @param sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dbg_port_sel_rst_8852b(struct mac_ax_adapter *adapter, u32 sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief tx_flow_ptcl_dbg_port_8852b
+ * mac tx_flow_ptcl_dbg_port_8852b
+ * @param *adapter
+ * @param u8 band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 tx_flow_ptcl_dbg_port_8852b(struct mac_ax_adapter *adapter, u8 band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief tx_flow_sch_dbg_port_8852b
+ * mac tx_flow_sch_dbg_port_8852b
+ * @param *adapter
+ * @param u8 band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 tx_flow_sch_dbg_port_8852b(struct mac_ax_adapter *adapter, u8 band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief ss_stat_chk_8852b
+ * mac ss_stat_chk
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ss_stat_chk_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief is_dbg_port_not_valid_8852b
+ *
+ * @param *adapter
+ * @param dbg_sel
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 is_dbg_port_not_valid_8852b(struct mac_ax_adapter *adapter, u32 dbg_sel);
+/**
+ * @}
+ * @}
+ */
+
+#endif /* MAC_AX_8852B_SUPPORT */
+#endif /* _MAC_AX_DBGPKG_8852B_H_ */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dle_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dle_8852b.c
new file mode 100644
index 000000000000..a3e51506c966
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dle_8852b.c
@@ -0,0 +1,658 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "dle_8852b.h"
+
+#if MAC_AX_8852B_SUPPORT
+
+static struct mac_ax_dle_dfi_info dle_dfi_wde_bufmgn_freepg = {
+	0,
+	1,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_wde_bufmgn_quota = {
+	0,
+	4,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_wde_bufmgn_pagellt = {
+	0,
+	0xFFF,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_wde_bufmgn_pktinfo = {
+	0,
+	0xFFF,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_wde_quemgn_prepkt = {
+	0,
+	0xFFF,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_wde_quemgn_nxtpkt = {
+	0,
+	0xFFF,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_wde_quemgn_qlnktbl = {
+	0,
+	0x453,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_wde_quemgn_qempty = {
+	0,
+	0x11,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_ple_bufmgn_freepg = {
+	0,
+	1,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_ple_bufmgn_quota = {
+	0,
+	0xB,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_ple_bufmgn_pagellt = {
+	0,
+	0xDBF,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_ple_bufmgn_pktinfo = {
+	0,
+	0xDBF,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_ple_quemgn_prepkt = {
+	0,
+	0xDBF,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_ple_quemgn_nxtpkt = {
+	0,
+	0xDBF,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_ple_quemgn_qlnktbl = {
+	0,
+	0x41,
+	1
+};
+
+static struct mac_ax_dle_dfi_info dle_dfi_ple_quemgn_qempty = {
+	0,
+	1,
+	1
+};
+
+u32 dle_dfi_sel_8852b(struct mac_ax_adapter *adapter,
+		      struct mac_ax_dle_dfi_info **info,
+		      u32 *target, u32 sel)
+{
+	switch (sel) {
+	case MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_FREEPG:
+		*info = &dle_dfi_wde_bufmgn_freepg;
+		*target = DLE_DFI_TYPE_FREEPG;
+		PLTFM_MSG_ALWAYS("Dump debug port WDE BUFMGN FREEPG:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_QUOTA:
+		*info = &dle_dfi_wde_bufmgn_quota;
+		*target = DLE_DFI_TYPE_QUOTA;
+		PLTFM_MSG_ALWAYS("Dump debug port WDE BUFMGN QUOTA:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_PAGELLT:
+		*info = &dle_dfi_wde_bufmgn_pagellt;
+		*target = DLE_DFI_TYPE_PAGELLT;
+		PLTFM_MSG_ALWAYS("Dump debug port WDE BUFMGN PAGELLT:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_BUFMGN_PKTINFO:
+		*info = &dle_dfi_wde_bufmgn_pktinfo;
+		*target = DLE_DFI_TYPE_PKTINFO;
+		PLTFM_MSG_ALWAYS("Dump debug port WDE BUFMGN PKTINFO:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_PREPKT:
+		*info = &dle_dfi_wde_quemgn_prepkt;
+		*target = DLE_DFI_TYPE_PREPKTLLT;
+		PLTFM_MSG_ALWAYS("Dump debug port WDE QUEMGN PREPKT:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_NXTPKT:
+		*info = &dle_dfi_wde_quemgn_nxtpkt;
+		*target = DLE_DFI_TYPE_NXTPKTLLT;
+		PLTFM_MSG_ALWAYS("Dump debug port WDE QUEMGN NXTPKT:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_QLNKTBL:
+		*info = &dle_dfi_wde_quemgn_qlnktbl;
+		*target = DLE_DFI_TYPE_QLNKTBL;
+		PLTFM_MSG_ALWAYS("Dump debug port WDE QUEMGN QLNKTBL:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_WDE_QUEMGN_QEMPTY:
+		*info = &dle_dfi_wde_quemgn_qempty;
+		*target = DLE_DFI_TYPE_QEMPTY;
+		PLTFM_MSG_ALWAYS("Dump debug port WDE QUEMGN QEMPTY:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_FREEPG:
+		*info = &dle_dfi_ple_bufmgn_freepg;
+		*target = DLE_DFI_TYPE_FREEPG;
+		PLTFM_MSG_ALWAYS("Dump debug port PLE BUFMGN FREEPG:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_QUOTA:
+		*info = &dle_dfi_ple_bufmgn_quota;
+		*target = DLE_DFI_TYPE_QUOTA;
+		PLTFM_MSG_ALWAYS("Dump debug port PLE BUFMGN QUOTA:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_PAGELLT:
+		*info = &dle_dfi_ple_bufmgn_pagellt;
+		*target = DLE_DFI_TYPE_PAGELLT;
+		PLTFM_MSG_ALWAYS("Dump debug port PLE BUFMGN PAGELLT:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_BUFMGN_PKTINFO:
+		*info = &dle_dfi_ple_bufmgn_pktinfo;
+		*target = DLE_DFI_TYPE_PKTINFO;
+		PLTFM_MSG_ALWAYS("Dump debug port PLE BUFMGN PKTINFO:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_PREPKT:
+		*info = &dle_dfi_ple_quemgn_prepkt;
+		*target = DLE_DFI_TYPE_PREPKTLLT;
+		PLTFM_MSG_ALWAYS("Dump debug port PLE QUEMGN PREPKT:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_NXTPKT:
+		*info = &dle_dfi_ple_quemgn_nxtpkt;
+		*target = DLE_DFI_TYPE_NXTPKTLLT;
+		PLTFM_MSG_ALWAYS("Dump debug port PLE QUEMGN NXTPKT:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_QLNKTBL:
+		*info = &dle_dfi_ple_quemgn_qlnktbl;
+		*target = DLE_DFI_TYPE_QLNKTBL;
+		PLTFM_MSG_ALWAYS("Dump debug port PLE QUEMGN QLNKTBL:\n");
+		break;
+	case MAC_AX_DLE_DFI_SEL_PLE_QUEMGN_QEMPTY:
+		*info = &dle_dfi_ple_quemgn_qempty;
+		*target = DLE_DFI_TYPE_QEMPTY;
+		PLTFM_MSG_ALWAYS("Dump debug port PLE QUEMGN QEMPTY:\n");
+		break;
+	default:
+		PLTFM_MSG_ALWAYS("dle dfi select err\n");
+		*info = NULL;
+		return MACDBGPORTSEL;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 dle_dfi_ctrl_8852b(struct mac_ax_adapter *adapter, struct dle_dfi_ctrl_t *ctrl_p)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 cnt, ctrl_reg, data_reg, ctrl_data;
+
+	switch (ctrl_p->type) {
+	case DLE_CTRL_TYPE_WDE:
+		ctrl_reg = R_AX_WDE_DBG_FUN_INTF_CTL;
+		data_reg = R_AX_WDE_DBG_FUN_INTF_DATA;
+		ctrl_data = SET_WORD(ctrl_p->target,
+				     B_AX_WDE_DFI_TRGSEL) |
+			    SET_WORD(ctrl_p->addr, B_AX_WDE_DFI_ADDR) |
+			    B_AX_WDE_DFI_ACTIVE;
+		break;
+	case DLE_CTRL_TYPE_PLE:
+		ctrl_reg = R_AX_PLE_DBG_FUN_INTF_CTL;
+		data_reg = R_AX_PLE_DBG_FUN_INTF_DATA;
+		ctrl_data = SET_WORD(ctrl_p->target,
+				     B_AX_PLE_DFI_TRGSEL) |
+			    SET_WORD(ctrl_p->addr, B_AX_PLE_DFI_ADDR) |
+			    B_AX_PLE_DFI_ACTIVE;
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR] dfi ctrl type %d\n", ctrl_p->type);
+		return MACFUNCINPUT;
+	}
+
+	MAC_REG_W32(ctrl_reg, ctrl_data);
+
+	cnt = DLE_DFI_WAIT_CNT;
+	while (cnt && MAC_REG_R32(ctrl_reg) & B_AX_WDE_DFI_ACTIVE) {
+		PLTFM_DELAY_US(DLE_DFI_WAIT_US);
+		cnt--;
+	}
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR] dle dfi ctrl 0x%X set 0x%X timeout\n",
+			      ctrl_reg, ctrl_data);
+		return MACPOLLTO;
+	}
+
+	ctrl_p->out_data = MAC_REG_R32(data_reg);
+
+	switch (ctrl_p->target) {
+	case DLE_DFI_TYPE_FREEPG:
+		switch (ctrl_p->addr) {
+		case DFI_TYPE_FREEPG_IDX:
+			ctrl_p->u.freepg.free_headpg =
+				GET_FIELD(ctrl_p->out_data, B_AX_DLE_FREE_HEADPG);
+			ctrl_p->u.freepg.free_tailpg =
+				GET_FIELD(ctrl_p->out_data, B_AX_DLE_FREE_TAILPG);
+			break;
+		case DFI_TYPE_FREEPG_PUBNUM:
+			ctrl_p->u.freepg.pub_pgnum =
+				GET_FIELD(ctrl_p->out_data, B_AX_DLE_PUB_PGNUM);
+			break;
+		default:
+			PLTFM_MSG_ERR("dle dfi ctrl tar%d addr%d mismatch\n",
+				      ctrl_p->target, ctrl_p->addr);
+			return MACFUNCINPUT;
+		}
+		break;
+	case DLE_DFI_TYPE_QUOTA:
+		ctrl_p->u.quota.rsv_pgnum =
+			GET_FIELD(ctrl_p->out_data, B_AX_DLE_RSV_PGNUM);
+		ctrl_p->u.quota.use_pgnum =
+			GET_FIELD(ctrl_p->out_data, B_AX_DLE_USE_PGNUM);
+		break;
+	case DLE_DFI_TYPE_QEMPTY:
+		ctrl_p->u.qempty.qempty =
+			GET_FIELD(ctrl_p->out_data, B_AX_DLE_QEMPTY_GRP);
+		break;
+	default:
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 dle_is_txq_empty_8852b(struct mac_ax_adapter *adapter, u8 *val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, rval32;
+
+	val32 = B_AX_WDE_EMPTY_QUE_CMAC0_ALL_AC | B_AX_WDE_EMPTY_QUE_CMAC0_MBH |
+		B_AX_WDE_EMPTY_QUE_CMAC1_MBH | B_AX_WDE_EMPTY_QUE_CMAC0_WMM0 |
+		B_AX_WDE_EMPTY_QUE_CMAC0_WMM1 | B_AX_WDE_EMPTY_QUE_OTHERS |
+		B_AX_PLE_EMPTY_QUE_DMAC_MPDU_TX | B_AX_PLE_EMPTY_QTA_DMAC_H2C |
+		B_AX_PLE_EMPTY_QUE_DMAC_SEC_TX | B_AX_WDE_EMPTY_QUE_DMAC_PKTIN |
+		B_AX_WDE_EMPTY_QTA_DMAC_HIF | B_AX_WDE_EMPTY_QTA_DMAC_WLAN_CPU |
+		B_AX_WDE_EMPTY_QTA_DMAC_PKTIN | B_AX_WDE_EMPTY_QTA_DMAC_CPUIO |
+		B_AX_PLE_EMPTY_QTA_DMAC_B0_TXPL |
+		B_AX_PLE_EMPTY_QTA_DMAC_B1_TXPL |
+		B_AX_PLE_EMPTY_QTA_DMAC_MPDU_TX |
+		B_AX_PLE_EMPTY_QTA_DMAC_CPUIO |
+		B_AX_WDE_EMPTY_QTA_DMAC_DATA_CPU |
+		B_AX_PLE_EMPTY_QTA_DMAC_WLAN_CPU;
+
+	rval32 = MAC_REG_R32(R_AX_DLE_EMPTY0);
+	if (val32 != (rval32 & val32)) {
+		*val = DLE_QUEUE_NONEMPTY;
+		PLTFM_MSG_TRACE("[TRACE]TXQ non empty 0x%X\n", rval32);
+	} else {
+		*val = DLE_QUEUE_EMPTY;
+		PLTFM_MSG_TRACE("[TRACE]TXQ empty 0x%X\n", rval32);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 dle_is_rxq_empty_8852b(struct mac_ax_adapter *adapter, u8 *val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, rval32;
+
+	val32 = B_AX_WDE_EMPTY_QUE_DMAC_WDRLS | B_AX_PLE_EMPTY_QUE_DMAC_SEC_RX |
+		B_AX_PLE_EMPTY_QUE_DMAC_MPDU_RX | B_AX_PLE_EMPTY_QUE_DMAC_HDP |
+		B_AX_PLE_EMPTY_QUE_DMAC_PLRLS | B_AX_PLE_EMPTY_QUE_DMAC_CPUIO |
+		B_AX_PLE_EMPTY_QTA_DMAC_C2H | B_AX_PLE_EMPTY_QTA_CMAC0_DMA_RX |
+		B_AX_PLE_EMPTY_QTA_CMAC1_DMA_RX |
+		B_AX_PLE_EMPTY_QTA_CMAC1_DMA_BBRPT |
+		B_AX_PLE_EMPTY_QTA_DMAC_WDRLS;
+
+	rval32 = MAC_REG_R32(R_AX_DLE_EMPTY1);
+	if (val32 != (rval32 & val32)) {
+		*val = DLE_QUEUE_NONEMPTY;
+		PLTFM_MSG_TRACE("[TRACE] RXQ non empty 0x%X\n", rval32);
+	} else {
+		*val = DLE_QUEUE_EMPTY;
+		PLTFM_MSG_TRACE("[TRACE] RXQ empty 0x%X\n", rval32);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_is_txq_empty_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_tx_queue_empty *val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct dle_dfi_qempty_t qempty;
+	u32 val32, val32_emp0, ret;
+	u32 i, j, qnum;
+
+	PLTFM_MEMSET(val, 0xFF, sizeof(struct mac_ax_tx_queue_empty));
+
+	qempty.dle_type = DLE_CTRL_TYPE_WDE;
+	qnum = WDE_QEMPTY_ACQ_NUM_8852B;
+	for (i = 0; i < qnum; i++) {
+		qempty.grpsel = i;
+		ret = dle_dfi_qempty(adapter, &qempty);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]dle dfi acq empty %d\n", ret);
+			return ret;
+		}
+		for (j = 0 ; j < QEMP_ACQ_GRP_MACID_NUM; j++) {
+			val32 = GET_FIEL2(qempty.qempty,
+					  j * QEMP_ACQ_GRP_QSEL_SH,
+					  QEMP_ACQ_GRP_QSEL_MASK);
+			if (val32 != QEMP_ACQ_GRP_QSEL_MASK)
+				val->macid_txq_empty[i] &= ~BIT(j);
+		}
+	}
+
+	qempty.grpsel = WDE_QEMPTY_MGQ_SEL_8852B;
+	ret = dle_dfi_qempty(adapter, &qempty);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]dle dfi mgq empty %d\n", ret);
+		return ret;
+	}
+	if (!(qempty.qempty & B_CMAC0_MGQ_NORMAL))
+		val->band0_mgnt_empty = 0;
+
+	if (is_curr_dbcc(adapter) && !(qempty.qempty & B_CMAC1_MGQ_NORMAL))
+		val->band1_mgnt_empty = 0;
+
+	val32 = B_CMAC0_MGQ_NO_PWRSAV | B_CMAC0_CPUMGQ;
+	if (is_curr_dbcc(adapter))
+		val32 |= B_CMAC1_MGQ_NO_PWRSAV | B_CMAC1_CPUMGQ;
+	if ((qempty.qempty & val32) != val32)
+		val->fw_txq_empty = 0;
+
+	val32 = B_AX_WDE_EMPTY_QTA_DMAC_WLAN_CPU |
+		B_AX_WDE_EMPTY_QTA_DMAC_DATA_CPU |
+		B_AX_PLE_EMPTY_QTA_DMAC_WLAN_CPU;
+	val32_emp0 = MAC_REG_R32(R_AX_DLE_EMPTY0);
+	if (val32 != (val32_emp0 & val32))
+		val->fw_txq_empty = 0;
+
+	if (!(val32_emp0 & B_AX_PLE_EMPTY_QTA_DMAC_H2C))
+		val->h2c_empty = 0;
+
+	val32 = B_AX_WDE_EMPTY_QUE_OTHERS | B_AX_PLE_EMPTY_QUE_DMAC_MPDU_TX |
+		B_AX_WDE_EMPTY_QTA_DMAC_CPUIO | B_AX_PLE_EMPTY_QTA_DMAC_CPUIO |
+		B_AX_WDE_EMPTY_QUE_DMAC_PKTIN | B_AX_WDE_EMPTY_QTA_DMAC_HIF |
+		B_AX_PLE_EMPTY_QUE_DMAC_SEC_TX | B_AX_WDE_EMPTY_QTA_DMAC_PKTIN |
+		B_AX_PLE_EMPTY_QTA_DMAC_B0_TXPL |
+		B_AX_PLE_EMPTY_QTA_DMAC_B1_TXPL |
+		B_AX_PLE_EMPTY_QTA_DMAC_MPDU_TX;
+
+	if (val32 != (val32_emp0 & val32))
+		val->others_empty = 0;
+
+	return MACSUCCESS;
+}
+
+u32 mac_is_rxq_empty_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_rx_queue_empty *val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, val32_emp1;
+
+	PLTFM_MEMSET(val, 0xFF, sizeof(struct mac_ax_rx_queue_empty));
+
+	val32_emp1 = MAC_REG_R32(R_AX_DLE_EMPTY1);
+	if (!(val32_emp1 & B_AX_PLE_EMPTY_QTA_CMAC0_DMA_RX))
+		val->band0_rxq_empty = 0;
+
+	if (!(val32_emp1 & B_AX_PLE_EMPTY_QTA_CMAC1_DMA_RX))
+		val->band1_rxq_empty = 0;
+
+	if (!(val32_emp1 & B_AX_PLE_EMPTY_QTA_DMAC_C2H))
+		val->c2h_empty = 0;
+
+	val32 = B_AX_WDE_EMPTY_QUE_DMAC_WDRLS | B_AX_PLE_EMPTY_QUE_DMAC_SEC_RX |
+		B_AX_PLE_EMPTY_QUE_DMAC_MPDU_RX | B_AX_PLE_EMPTY_QUE_DMAC_HDP |
+		B_AX_PLE_EMPTY_QUE_DMAC_PLRLS | B_AX_PLE_EMPTY_QUE_DMAC_CPUIO |
+		B_AX_PLE_EMPTY_QTA_CMAC1_DMA_BBRPT |
+		B_AX_PLE_EMPTY_QTA_DMAC_WDRLS;
+
+	if (val32 != (val32_emp1 & val32))
+		val->others_empty = 0;
+
+	return MACSUCCESS;
+}
+
+u32 preload_cfg_set_8852b(struct mac_ax_adapter *adapter, enum mac_ax_band band,
+			  struct mac_ax_preld_cfg *cfg)
+{
+	return MACSUCCESS;
+}
+
+u32 preload_init_set_8852b(struct mac_ax_adapter *adapter, enum mac_ax_band band,
+			   enum mac_ax_qta_mode mode)
+{
+	return MACSUCCESS;
+}
+
+u32 dle_func_en_8852b(struct mac_ax_adapter *adapter, u8 en)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = MAC_REG_R32(R_AX_DMAC_FUNC_EN);
+	if (en == MAC_AX_FUNC_EN)
+		val32 |= (B_AX_DLE_WDE_EN | B_AX_DLE_PLE_EN);
+	else if (en == MAC_AX_FUNC_DIS)
+		val32 &= ~(B_AX_DLE_WDE_EN | B_AX_DLE_PLE_EN);
+	else
+		return MACSUCCESS;
+	MAC_REG_W32(R_AX_DMAC_FUNC_EN, val32);
+
+	return MACSUCCESS;
+}
+
+u32 dle_clk_en_8852b(struct mac_ax_adapter *adapter, u8 en)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = MAC_REG_R32(R_AX_DMAC_CLK_EN);
+	if (en == MAC_AX_FUNC_EN)
+		val32 |= (B_AX_DLE_WDE_CLK_EN | B_AX_DLE_PLE_CLK_EN);
+	else if (en == MAC_AX_FUNC_DIS)
+		val32 &= ~(B_AX_DLE_WDE_CLK_EN | B_AX_DLE_PLE_CLK_EN);
+	else
+		return MACSUCCESS;
+	MAC_REG_W32(R_AX_DMAC_CLK_EN, val32);
+
+	return MACSUCCESS;
+}
+
+u32 dle_mix_cfg_8852b(struct mac_ax_adapter *adapter, struct dle_mem_t *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct dle_size_t *size_cfg;
+	u32 val32, bound;
+
+	val32 = MAC_REG_R32(R_AX_WDE_PKTBUF_CFG);
+	bound = 0;
+	size_cfg = cfg->wde_size;
+
+	switch (size_cfg->pge_size) {
+	default:
+	case MAC_AX_WDE_PG_64:
+		val32 = SET_CLR_WORD(val32, S_AX_WDE_PAGE_SEL_64,
+				     B_AX_WDE_PAGE_SEL);
+		break;
+	case MAC_AX_WDE_PG_128:
+		val32 = SET_CLR_WORD(val32, S_AX_WDE_PAGE_SEL_128,
+				     B_AX_WDE_PAGE_SEL);
+		break;
+	case MAC_AX_WDE_PG_256:
+		PLTFM_MSG_ERR("[ERR]WDE DLE doesn't support 256 byte!\n");
+		return MACHWNOSUP;
+	}
+
+	val32 = SET_CLR_WORD(val32, bound, B_AX_WDE_START_BOUND);
+	val32 = SET_CLR_WORD(val32, size_cfg->lnk_pge_num,
+			     B_AX_WDE_FREE_PAGE_NUM);
+	MAC_REG_W32(R_AX_WDE_PKTBUF_CFG, val32);
+
+	val32 = MAC_REG_R32(R_AX_PLE_PKTBUF_CFG);
+	bound = (size_cfg->lnk_pge_num + size_cfg->unlnk_pge_num)
+		* size_cfg->pge_size / DLE_BOUND_UNIT;
+	size_cfg = cfg->ple_size;
+
+	switch (size_cfg->pge_size) {
+	default:
+	case MAC_AX_PLE_PG_64:
+		PLTFM_MSG_ERR("[ERR]PLE DLE doesn't support 64 byte!\n");
+		return MACHWNOSUP;
+	case MAC_AX_PLE_PG_128:
+		val32 = SET_CLR_WORD(val32, S_AX_PLE_PAGE_SEL_128,
+				     B_AX_PLE_PAGE_SEL);
+		break;
+	case MAC_AX_PLE_PG_256:
+		val32 = SET_CLR_WORD(val32, S_AX_PLE_PAGE_SEL_256,
+				     B_AX_PLE_PAGE_SEL);
+		break;
+	}
+
+	val32 = SET_CLR_WORD(val32, bound, B_AX_PLE_START_BOUND);
+	val32 = SET_CLR_WORD(val32, size_cfg->lnk_pge_num,
+			     B_AX_PLE_FREE_PAGE_NUM);
+	MAC_REG_W32(R_AX_PLE_PKTBUF_CFG, val32);
+
+	return MACSUCCESS;
+}
+
+u32 wde_quota_cfg_8852b(struct mac_ax_adapter *adapter,
+			struct wde_quota_t *min_cfg,
+			struct wde_quota_t *max_cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = SET_WORD(min_cfg->hif, B_AX_WDE_Q0_MIN_SIZE) |
+		SET_WORD(max_cfg->hif, B_AX_WDE_Q0_MAX_SIZE);
+	MAC_REG_W32(R_AX_WDE_QTA0_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->wcpu, B_AX_WDE_Q1_MIN_SIZE) |
+		SET_WORD(max_cfg->wcpu, B_AX_WDE_Q1_MAX_SIZE);
+	MAC_REG_W32(R_AX_WDE_QTA1_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->pkt_in, B_AX_WDE_Q3_MIN_SIZE) |
+		SET_WORD(max_cfg->pkt_in, B_AX_WDE_Q3_MAX_SIZE);
+	MAC_REG_W32(R_AX_WDE_QTA3_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->cpu_io, B_AX_WDE_Q4_MIN_SIZE) |
+		SET_WORD(max_cfg->cpu_io, B_AX_WDE_Q4_MAX_SIZE);
+	MAC_REG_W32(R_AX_WDE_QTA4_CFG, val32);
+
+	return MACSUCCESS;
+}
+
+u32 ple_quota_cfg_8852b(struct mac_ax_adapter *adapter,
+			struct ple_quota_t *min_cfg,
+			struct ple_quota_t *max_cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = SET_WORD(min_cfg->cma0_tx, B_AX_PLE_Q0_MIN_SIZE) |
+		SET_WORD(max_cfg->cma0_tx, B_AX_PLE_Q0_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA0_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->cma1_tx, B_AX_PLE_Q1_MIN_SIZE) |
+		SET_WORD(max_cfg->cma1_tx, B_AX_PLE_Q1_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA1_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->c2h, B_AX_PLE_Q2_MIN_SIZE) |
+		SET_WORD(max_cfg->c2h, B_AX_PLE_Q2_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA2_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->h2c, B_AX_PLE_Q3_MIN_SIZE) |
+		SET_WORD(max_cfg->h2c, B_AX_PLE_Q3_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA3_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->wcpu, B_AX_PLE_Q4_MIN_SIZE) |
+		SET_WORD(max_cfg->wcpu, B_AX_PLE_Q4_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA4_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->mpdu_proc, B_AX_PLE_Q5_MIN_SIZE) |
+		SET_WORD(max_cfg->mpdu_proc, B_AX_PLE_Q5_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA5_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->cma0_dma, B_AX_PLE_Q6_MIN_SIZE) |
+		SET_WORD(max_cfg->cma0_dma, B_AX_PLE_Q6_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA6_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->cma1_dma, B_AX_PLE_Q7_MIN_SIZE) |
+		SET_WORD(max_cfg->cma1_dma, B_AX_PLE_Q7_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA7_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->bb_rpt, B_AX_PLE_Q8_MIN_SIZE) |
+		SET_WORD(max_cfg->bb_rpt, B_AX_PLE_Q8_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA8_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->wd_rel, B_AX_PLE_Q9_MIN_SIZE) |
+		SET_WORD(max_cfg->wd_rel, B_AX_PLE_Q9_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA9_CFG, val32);
+
+	val32 = SET_WORD(min_cfg->cpu_io, B_AX_PLE_Q10_MIN_SIZE) |
+		SET_WORD(max_cfg->cpu_io, B_AX_PLE_Q10_MAX_SIZE);
+	MAC_REG_W32(R_AX_PLE_QTA10_CFG, val32);
+
+	return MACSUCCESS;
+}
+
+u32 chk_dle_rdy_8852b(struct mac_ax_adapter *adapter, enum DLE_CTRL_TYPE type)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32 = 0, reg, rdy_bit, cnt;
+
+	if (type == DLE_CTRL_TYPE_WDE) {
+		reg = R_AX_WDE_INI_STATUS;
+		rdy_bit = B_AX_WDE_Q_MGN_INI_RDY | B_AX_WDE_BUF_MGN_INI_RDY;
+	} else if (type == DLE_CTRL_TYPE_PLE) {
+		reg = R_AX_PLE_INI_STATUS;
+		rdy_bit = B_AX_PLE_Q_MGN_INI_RDY | B_AX_PLE_BUF_MGN_INI_RDY;
+	} else {
+		return MACFUNCINPUT;
+	}
+
+	cnt = DLE_WAIT_CNT;
+	while (cnt--) {
+		val32 = MAC_REG_R32(reg);
+		if ((val32 & rdy_bit) == rdy_bit)
+			break;
+		PLTFM_DELAY_US(DLE_WAIT_US);
+	}
+
+	if (!++cnt) {
+		PLTFM_MSG_ERR("[ERR]DLE%d cfg ready timeout 0x%X\n", type, val32);
+		return MACPOLLTO;
+	}
+
+	return MACSUCCESS;
+}
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dle_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dle_8852b.h
new file mode 100644
index 000000000000..b808516fca9d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/dle_8852b.h
@@ -0,0 +1,333 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_DLE_8852B_H_
+#define _MAC_AX_DLE_8852B_H_
+
+#include "../dle.h"
+
+#if MAC_AX_8852B_SUPPORT
+
+/*--------------------Define ----------------------------------------*/
+
+/*--------------------Define Enum------------------------------------*/
+
+/*--------------------Define MACRO----------------------------------*/
+
+/*--------------------Define Struct-----------------------------------*/
+
+/*--------------------Export global variable----------------------------*/
+
+/*--------------------Function declaration-----------------------------*/
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+
+/**
+ * @brief dle_dfi_sel_8852b
+ *
+ * @param *adapter
+ * @param **info
+ * @param *target
+ * @param sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dle_dfi_sel_8852b(struct mac_ax_adapter *adapter,
+		      struct mac_ax_dle_dfi_info **info,
+		      u32 *target, u32 sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief dle_dfi_ctrl_8852b
+ *
+ * @param *adapter
+ * @param *ctrl_p
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dle_dfi_ctrl_8852b(struct mac_ax_adapter *adapter, struct dle_dfi_ctrl_t *ctrl_p);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief dle_is_txq_empty_8852b
+ *
+ * @param *adapter
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dle_is_txq_empty_8852b(struct mac_ax_adapter *adapter, u8 *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief dle_is_rxq_empty_8852b
+ *
+ * @param *adapter
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dle_is_rxq_empty_8852b(struct mac_ax_adapter *adapter, u8 *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief mac_is_txq_empty_8852b
+ *
+ * @param *adapter
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_is_txq_empty_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_tx_queue_empty *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief mac_is_rxq_empty_8852b
+ *
+ * @param *adapter
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_is_rxq_empty_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_rx_queue_empty *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief preload_cfg_set_8852b
+ *
+ * @param *adapter
+ * @param band
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 preload_cfg_set_8852b(struct mac_ax_adapter *adapter, enum mac_ax_band band,
+			  struct mac_ax_preld_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief preload_init_set_8852b
+ *
+ * @param *adapter
+ * @param band
+ * @param mode
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 preload_init_set_8852b(struct mac_ax_adapter *adapter, enum mac_ax_band band,
+			   enum mac_ax_qta_mode mode);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief dle_func_en_8852b
+ *
+ * @param *adapter
+ * @param en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dle_func_en_8852b(struct mac_ax_adapter *adapter, u8 en);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief dle_clk_en_8852b
+ *
+ * @param *adapter
+ * @param en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dle_clk_en_8852b(struct mac_ax_adapter *adapter, u8 en);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief dle_mix_cfg_8852b
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dle_mix_cfg_8852b(struct mac_ax_adapter *adapter, struct dle_mem_t *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief wde_quota_cfg_8852b
+ *
+ * @param *adapter
+ * @param *min_cfg
+ * @param *max_cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 wde_quota_cfg_8852b(struct mac_ax_adapter *adapter,
+			struct wde_quota_t *min_cfg,
+			struct wde_quota_t *max_cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief ple_quota_cfg_8852b
+ *
+ * @param *adapter
+ * @param *min_cfg
+ * @param *max_cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 ple_quota_cfg_8852b(struct mac_ax_adapter *adapter,
+			struct ple_quota_t *min_cfg,
+			struct ple_quota_t *max_cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup DLE
+ * @{
+ */
+/**
+ * @brief chk_dle_rdy_8852b
+ *
+ * @param *adapter
+ * @param type
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 chk_dle_rdy_8852b(struct mac_ax_adapter *adapter, enum DLE_CTRL_TYPE type);
+/**
+ * @}
+ * @}
+ */
+#endif
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/efuse_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/efuse_8852b.c
new file mode 100644
index 000000000000..6d5785bec87d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/efuse_8852b.c
@@ -0,0 +1,139 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "efuse_8852b.h"
+
+#if MAC_AX_8852B_SUPPORT
+
+u32 switch_efuse_bank_8852b(struct mac_ax_adapter *adapter,
+			    enum mac_ax_efuse_bank bank)
+{
+	struct mac_ax_efuse_param *efuse_param = &adapter->efuse_param;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	struct mac_bank_efuse_info *bank_efuse_info = &adapter->efuse_param.bank_efuse_info;
+	enum rtw_dv_sel dv_sel = adapter->efuse_param.dv_sel;
+
+	switch (bank) {
+	case MAC_AX_EFUSE_BANK_WIFI:
+		if (dv_sel == DAV) {
+			bank_efuse_info->phy_map = &efuse_param->dav_efuse_map;
+			bank_efuse_info->log_map =
+				&efuse_param->dav_log_efuse_map;
+			bank_efuse_info->phy_map_valid =
+				&efuse_param->dav_efuse_map_valid;
+			bank_efuse_info->log_map_valid =
+				&efuse_param->dav_log_efuse_map_valid;
+			bank_efuse_info->efuse_end =
+				&efuse_param->dav_efuse_end;
+			bank_efuse_info->phy_map_size =
+				&hw_info->dav_efuse_size;
+			bank_efuse_info->log_map_size =
+				&hw_info->dav_log_efuse_size;
+			bank_efuse_info->efuse_start =
+				&hw_info->dav_efuse_start_addr;
+			break;
+		}
+
+		bank_efuse_info->phy_map = &efuse_param->efuse_map;
+		bank_efuse_info->log_map = &efuse_param->log_efuse_map;
+		bank_efuse_info->phy_map_valid = &efuse_param->efuse_map_valid;
+		bank_efuse_info->log_map_valid =
+			&efuse_param->log_efuse_map_valid;
+		bank_efuse_info->efuse_end = &efuse_param->efuse_end;
+		bank_efuse_info->phy_map_size = &hw_info->efuse_size;
+		bank_efuse_info->log_map_size = &hw_info->log_efuse_size;
+		bank_efuse_info->efuse_start = &hw_info->wl_efuse_start_addr;
+		break;
+	case MAC_AX_EFUSE_BANK_BT:
+		bank_efuse_info->phy_map = &efuse_param->bt_efuse_map;
+		bank_efuse_info->log_map = &efuse_param->bt_log_efuse_map;
+		bank_efuse_info->phy_map_valid =
+			&efuse_param->bt_efuse_map_valid;
+		bank_efuse_info->log_map_valid =
+			&efuse_param->bt_log_efuse_map_valid;
+		bank_efuse_info->efuse_end = &efuse_param->bt_efuse_end;
+		bank_efuse_info->phy_map_size = &hw_info->bt_efuse_size;
+		bank_efuse_info->log_map_size = &hw_info->bt_log_efuse_size;
+		bank_efuse_info->efuse_start = &hw_info->bt_efuse_start_addr;
+		break;
+	default:
+		return MACEFUSEBANK;
+	}
+
+	return MACSUCCESS;
+}
+
+void enable_efuse_sw_pwr_cut_8852b(struct mac_ax_adapter *adapter,
+				   bool is_write)
+{
+	u16 val16;
+	u8 val8;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	enum rtw_dv_sel dv_sel = adapter->efuse_param.dv_sel;
+
+	if (dv_sel == DDV) {
+		if (is_write)
+			MAC_REG_W8(R_AX_PMC_DBG_CTRL2 + 3, UNLOCK_CODE);
+
+		val8 = MAC_REG_R8(R_AX_PMC_DBG_CTRL2);
+		MAC_REG_W8(R_AX_PMC_DBG_CTRL2, val8 | B_AX_SYSON_DIS_PMCR_AX_WRMSK);
+
+		val16 = MAC_REG_R16(R_AX_SYS_ISO_CTRL);
+		MAC_REG_W16(R_AX_SYS_ISO_CTRL, val16 | BIT(B_AX_PWC_EV2EF_SH));
+		PLTFM_DELAY_US(1000);
+
+		val16 = MAC_REG_R16(R_AX_SYS_ISO_CTRL);
+		MAC_REG_W16(R_AX_SYS_ISO_CTRL,
+			    val16 | BIT(B_AX_PWC_EV2EF_SH + 1));
+
+		val16 = MAC_REG_R16(R_AX_SYS_ISO_CTRL);
+		MAC_REG_W16(R_AX_SYS_ISO_CTRL, val16 & ~(B_AX_ISO_EB2CORE));
+	} else {
+		enable_efuse_pwr_cut_dav(adapter, is_write);
+	}
+}
+
+void disable_efuse_sw_pwr_cut_8852b(struct mac_ax_adapter *adapter,
+				    bool is_write)
+{
+	u16 value16;
+	u8 value8;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	enum rtw_dv_sel dv_sel = adapter->efuse_param.dv_sel;
+
+	if (dv_sel == DDV) {
+		value16 = MAC_REG_R16(R_AX_SYS_ISO_CTRL);
+		MAC_REG_W16(R_AX_SYS_ISO_CTRL,
+			    value16 | B_AX_ISO_EB2CORE);
+
+		value16 = MAC_REG_R16(R_AX_SYS_ISO_CTRL);
+		MAC_REG_W16(R_AX_SYS_ISO_CTRL,
+			    value16 & ~(BIT(B_AX_PWC_EV2EF_SH + 1)));
+
+		PLTFM_DELAY_US(1000);
+
+		value16 = MAC_REG_R16(R_AX_SYS_ISO_CTRL);
+		MAC_REG_W16(R_AX_SYS_ISO_CTRL,
+			    value16 & ~(BIT(B_AX_PWC_EV2EF_SH)));
+		if (is_write)
+			MAC_REG_W8(R_AX_PMC_DBG_CTRL2 + 3, 0x00);
+
+		value8 = MAC_REG_R8(R_AX_PMC_DBG_CTRL2);
+		MAC_REG_W8(R_AX_PMC_DBG_CTRL2, value8 & ~B_AX_SYSON_DIS_PMCR_AX_WRMSK);
+	} else {
+		disable_efuse_pwr_cut_dav(adapter, is_write);
+	}
+}
+
+#endif /* MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/efuse_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/efuse_8852b.h
new file mode 100644
index 000000000000..5e4b2dbffbca
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/efuse_8852b.h
@@ -0,0 +1,82 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_EFUSE_8852B_H_
+#define _MAC_AX_EFUSE_8852B_H_
+
+#include "../efuse.h"
+
+#if MAC_AX_8852B_SUPPORT
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief switch_efuse_bank_8852b
+ *
+ * @param *adapter
+ * @param bank
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 switch_efuse_bank_8852b(struct mac_ax_adapter *adapter,
+			    enum mac_ax_efuse_bank bank);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief enable_efuse_sw_pwr_cut_8852b
+ *
+ * @param *adapter
+ * @param is_write
+ * @return Please Place Description here.
+ * @retval void
+ */
+void enable_efuse_sw_pwr_cut_8852b(struct mac_ax_adapter *adapter,
+				   bool is_write);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Efuse
+ * @{
+ */
+
+/**
+ * @brief disable_efuse_sw_pwr_cut_8852b
+ *
+ * @param *adapter
+ * @param is_write
+ * @return Please Place Description here.
+ * @retval void
+ */
+void disable_efuse_sw_pwr_cut_8852b(struct mac_ax_adapter *adapter,
+				    bool is_write);
+/**
+ * @}
+ */
+
+#endif /* MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/fwcmd_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/fwcmd_8852b.c
new file mode 100644
index 000000000000..ad958d69030d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/fwcmd_8852b.c
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "../../type.h"
+#include "../mac_priv.h"
+#if MAC_AX_8852B_SUPPORT
+
+static struct mac_ax_h2creg_offset h2creg_offset = {
+	R_AX_H2CREG_DATA0, /* data0 */
+	R_AX_H2CREG_DATA1, /* data1 */
+	R_AX_H2CREG_DATA2, /* data2 */
+	R_AX_H2CREG_DATA3, /* data3 */
+	R_AX_H2CREG_CTRL, /* ctrl */
+};
+
+static struct mac_ax_c2hreg_offset c2hreg_offset = {
+	R_AX_C2HREG_DATA0, /* data0 */
+	R_AX_C2HREG_DATA1, /* data1 */
+	R_AX_C2HREG_DATA2, /* data2 */
+	R_AX_C2HREG_DATA3, /* data3 */
+	R_AX_C2HREG_CTRL, /* ctrl */
+};
+
+struct mac_ax_h2creg_offset *
+get_h2creg_offset_8852b(struct mac_ax_adapter *adapter)
+{
+	return &h2creg_offset;
+}
+
+struct mac_ax_c2hreg_offset *
+get_c2hreg_offset_8852b(struct mac_ax_adapter *adapter)
+{
+	return &c2hreg_offset;
+}
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/fwcmd_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/fwcmd_8852b.h
new file mode 100644
index 000000000000..ad4718b38d86
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/fwcmd_8852b.h
@@ -0,0 +1,29 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#ifndef _MAC_AX_FW_CMD_8852B_H_
+#define _MAC_AX_FW_CMD_8852B_H_
+
+#include "../../mac_def.h"
+#if MAC_AX_8852B_SUPPORT
+
+struct mac_ax_h2creg_offset *
+get_h2creg_offset_8852b(struct mac_ax_adapter *adapter);
+
+struct mac_ax_c2hreg_offset *
+get_c2hreg_offset_8852b(struct mac_ax_adapter *adapter);
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/gpio_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/gpio_8852b.c
new file mode 100644
index 000000000000..971681da96db
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/gpio_8852b.c
@@ -0,0 +1,1950 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "../gpio_cmd.h"
+#include "../gpio.h"
+#include "../../mac_reg.h"
+#include "gpio_8852b.h"
+#if MAC_AX_8852B_SUPPORT
+
+/* GPIO0 definition */
+#define GPIO0_BT_GPIO0_8852B	\
+	{MAC_AX_SWGPIO, MAC_AX_GPIO0, MAC_AX_GPIO_IN_OUT, \
+	 0x66, BIT(2) | BIT(1) | BIT(0), BIT(2)}
+#define GPIO0_BT_SDIO_INT_8852B	\
+	{MAC_AX_BT_SDIO_INT, MAC_AX_GPIO0, MAC_AX_GPIO_OUT, \
+	 0x4F, BIT(5), BIT(5)}
+#define GPIO0_USIN_8852B	\
+	{MAC_AX_SWGPIO, MAC_AX_GPIO0, MAC_AX_GPIO_IN, \
+	 0x66, BIT(6), BIT(6)}
+#define GPIO0_BT_ANT_SW0_8852B	\
+	{MAC_AX_BT_RF, MAC_AX_GPIO0, MAC_AX_GPIO_OUT, \
+	 0x4F, BIT(6), BIT(6)}
+#define GPIO0_BT_ACT_8852B	\
+	{MAC_AX_BT_PTA, MAC_AX_GPIO0, MAC_AX_GPIO_IN_OUT, \
+	 0x41, BIT(1), BIT(1)}
+#define GPIO0_WL_ACT_8852B	\
+	{MAC_AX_WL_PTA, MAC_AX_GPIO0, MAC_AX_GPIO_IN_OUT, \
+	 0x41, BIT(2), BIT(2)}
+#define GPIO0_WLMAC_DBG_GPIO0_8852B	\
+	{MAC_AX_WLMAC_DBG, MAC_AX_GPIO0, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(0)}
+#define GPIO0_WLPHY_DBG_GPIO0_8852B	\
+	{MAC_AX_WLPHY_DBG, MAC_AX_GPIO0, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1)}
+#define GPIO0_BT_DBG_GPIO0_8852B	\
+	{MAC_AX_BT_DBG, MAC_AX_GPIO0, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1) | BIT(0)}
+#define GPIO0_PAON_2G_S0_8852B	\
+	{MAC_AX_PAON_LNAON_2G_S0, MAC_AX_GPIO0, MAC_AX_GPIO_IN, \
+	 0x142, BIT(0), BIT(0)}
+#define GPIO0_WL_RFE_CTRL0_0_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_0, MAC_AX_GPIO0, MAC_AX_GPIO_IN, \
+	 0x142, BIT(1), BIT(1)}
+#define GPIO0_PAON_5G_S0_8852B	\
+	{MAC_AX_PAON_LNAON_5G_S0, MAC_AX_GPIO0, MAC_AX_GPIO_IN, \
+	 0x142, BIT(4), BIT(4)}
+#define GPIO0_WL_RFE_CTRL0_1_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_2, MAC_AX_GPIO0, MAC_AX_GPIO_IN, \
+	 0x142, BIT(5), BIT(5)}
+#define GPIO0_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO0, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO1 definition */
+#define GPIO1_BT_GPIO1_8852B	\
+	{MAC_AX_SWGPIO, MAC_AX_GPIO1, MAC_AX_GPIO_IN_OUT, \
+	 0x66, BIT(2) | BIT(1) | BIT(0), BIT(2)}
+#define GPIO1_USOUT_8852B	\
+	{MAC_AX_UART, MAC_AX_GPIO1, MAC_AX_GPIO_OUT, \
+	 0x66, BIT(6), BIT(6)}
+#define GPIO1_BT_ANT_SW1_8852B	\
+	{MAC_AX_BT_RF, MAC_AX_GPIO1, MAC_AX_GPIO_OUT, \
+	 0x4F, BIT(6), BIT(6)}
+#define GPIO1_BT_3DD_SYNC_8852B	\
+	{MAC_AX_BT_3DDLS_A, MAC_AX_GPIO1, MAC_AX_GPIO_IN, \
+	 0x22, BIT(2), BIT(2)}
+#define GPIO1_WL_CK_8852B	\
+	{MAC_AX_BT_PTA, MAC_AX_GPIO1, MAC_AX_GPIO_OUT, \
+	 0x41, BIT(1), BIT(1)}
+#define GPIO1_BT_CK_8852B	\
+	{MAC_AX_WL_PTA, MAC_AX_GPIO1, MAC_AX_GPIO_OUT, \
+	 0x41, BIT(2), BIT(2)}
+#define GPIO1_WLMAC_DBG_GPIO1_8852B	\
+	{MAC_AX_WLMAC_DBG, MAC_AX_GPIO1, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(0)}
+#define GPIO1_WLPHY_DBG_GPIO1_8852B	\
+	{MAC_AX_WLPHY_DBG, MAC_AX_GPIO1, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1)}
+#define GPIO1_BT_DBG_GPIO1_8852B	\
+	{MAC_AX_BT_DBG, MAC_AX_GPIO1, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1) | BIT(0)}
+#define GPIO1_LNAON_2G_S0_8852B	\
+	{MAC_AX_PAON_LNAON_2G_S0, MAC_AX_GPIO1, MAC_AX_GPIO_IN, \
+	 0x142, BIT(0), BIT(0)}
+#define GPIO1_WL_RFE_CTRL1_0_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_0, MAC_AX_GPIO1, MAC_AX_GPIO_IN, \
+	 0x142, BIT(1), BIT(1)}
+#define GPIO1_LNAON_5G_S0_8852B	\
+	{MAC_AX_PAON_LNAON_5G_S0, MAC_AX_GPIO1, MAC_AX_GPIO_IN, \
+	 0x142, BIT(4), BIT(4)}
+#define GPIO1_WL_RFE_CTRL1_1_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_2, MAC_AX_GPIO1, MAC_AX_GPIO_IN, \
+	 0x142, BIT(5), BIT(5)}
+#define GPIO1_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO1, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO2 definition */
+#define GPIO2_BT_GPIO2_8852B	\
+	{MAC_AX_SWGPIO, MAC_AX_GPIO2, MAC_AX_GPIO_IN_OUT, \
+	 0x66, BIT(2) | BIT(1) | BIT(0), BIT(2)}
+#define GPIO2_BT_WAKE_8852B	\
+	{MAC_AX_GPIO13_14_WL_CTRL_EN, MAC_AX_GPIO2, MAC_AX_GPIO_IN, \
+	 0x4E, BIT(6), BIT(6)}
+#define GPIO2_BT_ANT_SW2_8852B	\
+	{MAC_AX_BT_RF, MAC_AX_GPIO2, MAC_AX_GPIO_OUT, \
+	 0x4F, BIT(6), BIT(6)}
+#define GPIO2_WL_STATE_8852B	\
+	{MAC_AX_BT_PTA, MAC_AX_GPIO2, MAC_AX_GPIO_OUT, \
+	 0x41, BIT(1), BIT(1)}
+#define GPIO2_BT_STATE_8852B	\
+	{MAC_AX_WL_PTA, MAC_AX_GPIO2, MAC_AX_GPIO_OUT, \
+	 0x41, BIT(2), BIT(2)}
+#define GPIO2_WLMAC_DBG_GPIO2_8852B	\
+	{MAC_AX_WLMAC_DBG, MAC_AX_GPIO2, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(0)}
+#define GPIO2_WLPHY_DBG_GPIO2_8852B	\
+	{MAC_AX_WLPHY_DBG, MAC_AX_GPIO2, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1)}
+#define GPIO2_BT_DBG_GPIO2_8852B	\
+	{MAC_AX_BT_DBG, MAC_AX_GPIO2, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1) | BIT(0)}
+#define GPIO2_PAON_2G_S1_8852B	\
+	{MAC_AX_PAON_LNAON_2G_S1, MAC_AX_GPIO2, MAC_AX_GPIO_IN, \
+	 0x142, BIT(2), BIT(2)}
+#define GPIO2_WL_RFE_CTRL2_0_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_1, MAC_AX_GPIO2, MAC_AX_GPIO_IN, \
+	 0x142, BIT(3), BIT(3)}
+#define GPIO2_PAON_5G_S1_8852B	\
+	{MAC_AX_PAON_LNAON_5G_S1, MAC_AX_GPIO2, MAC_AX_GPIO_IN, \
+	 0x142, BIT(6), BIT(6)}
+#define GPIO2_WL_RFE_CTRL2_1_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_3, MAC_AX_GPIO2, MAC_AX_GPIO_IN, \
+	 0x142, BIT(7), BIT(7)}
+#define GPIO2_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO2, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO3 definition */
+#define GPIO3_BT_GPIO3_8852B	\
+	{MAC_AX_SWGPIO, MAC_AX_GPIO3, MAC_AX_GPIO_IN_OUT, \
+	 0x66, BIT(2) | BIT(1) | BIT(0), BIT(2)}
+#define GPIO3_UART_WAKE_8852B	\
+	{MAC_AX_GPIO13_14_WL_CTRL_EN, MAC_AX_GPIO3, MAC_AX_GPIO_OUT, \
+	 0x4E, BIT(6), BIT(6)}
+#define GPIO3_BT_ANT_SW3_8852B	\
+	{MAC_AX_BT_RF, MAC_AX_GPIO3, MAC_AX_GPIO_OUT, \
+	 0x4F, BIT(6), BIT(6)}
+#define GPIO3_WL_PRI_8852B	\
+	{MAC_AX_BT_PTA, MAC_AX_GPIO3, MAC_AX_GPIO_OUT, \
+	 0x41, BIT(1), BIT(1)}
+#define GPIO3_BT_PRI_8852B	\
+	{MAC_AX_WL_PTA, MAC_AX_GPIO3, MAC_AX_GPIO_OUT, \
+	 0x41, BIT(2), BIT(2)}
+#define GPIO3_WLMAC_DBG_GPIO3_8852B	\
+	{MAC_AX_WLMAC_DBG, MAC_AX_GPIO3, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(0)}
+#define GPIO3_WLPHY_DBG_GPIO3_8852B	\
+	{MAC_AX_WLPHY_DBG, MAC_AX_GPIO3, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1)}
+#define GPIO3_BT_DBG_GPIO3_8852B	\
+	{MAC_AX_BT_DBG, MAC_AX_GPIO3, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1) | BIT(0)}
+#define GPIO3_LNAON_2G_S1_8852B	\
+	{MAC_AX_PAON_LNAON_2G_S1, MAC_AX_GPIO3, MAC_AX_GPIO_IN, \
+	 0x142, BIT(2), BIT(2)}
+#define GPIO3_WL_RFE_CTRL3_0_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_1, MAC_AX_GPIO3, MAC_AX_GPIO_IN, \
+	 0x142, BIT(3), BIT(3)}
+#define GPIO3_LNAON_5G_S1_8852B	\
+	{MAC_AX_PAON_LNAON_5G_S1, MAC_AX_GPIO3, MAC_AX_GPIO_IN, \
+	 0x142, BIT(6), BIT(6)}
+#define GPIO3_WL_RFE_CTRL3_1_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_3, MAC_AX_GPIO3, MAC_AX_GPIO_IN, \
+	 0x142, BIT(7), BIT(7)}
+#define GPIO3_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO3, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO4 definition */
+#define GPIO4_BT_SPI0_8852B	\
+	{MAC_AX_BT_SFALSH, MAC_AX_GPIO4, MAC_AX_GPIO_IN_OUT, \
+	 0x66, BIT(4), BIT(4)}
+#define GPIO4_WL_SPI0_8852B	\
+	{MAC_AX_WL_SFALSH, MAC_AX_GPIO4, MAC_AX_GPIO_IN_OUT, \
+	 0x42, BIT(3), BIT(3)}
+#define GPIO4_BT_JTAG_TRST_8852B	\
+	{MAC_AX_BT_JTAG, MAC_AX_GPIO4, MAC_AX_GPIO_OUT, \
+	 0x67, BIT(0), BIT(0)}
+#define GPIO4_WL_JTAG_TRST_8852B	\
+	{MAC_AX_BT_JTAG, MAC_AX_GPIO4, MAC_AX_GPIO_OUT, \
+	 0x65, BIT(7), BIT(7)}
+#define GPIO4_DBG_GNT_WL_8852B	\
+	{MAC_AX_DBG_GNT, MAC_AX_GPIO4, MAC_AX_GPIO_OUT, \
+	 0x73, BIT(3), BIT(3)}
+#define GPIO4_WLMAC_DBG_GPIO4_8852B	\
+	{MAC_AX_WLMAC_DBG, MAC_AX_GPIO4, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(0)}
+#define GPIO4_WLPHY_DBG_GPIO4_8852B	\
+	{MAC_AX_WLPHY_DBG, MAC_AX_GPIO4, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1)}
+#define GPIO4_BT_DBG_GPIO4_8852B	\
+	{MAC_AX_BT_DBG, MAC_AX_GPIO4, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1) | BIT(0)}
+#define GPIO4_BANDSEL_5_6G_8852B	\
+	{MAC_AX_BANDSEL_5_6G, MAC_AX_GPIO4, MAC_AX_GPIO_IN, \
+	 0x143, BIT(4), BIT(4)}
+#define GPIO4_WL_RFE_CTRL4_0_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_4, MAC_AX_GPIO4, MAC_AX_GPIO_IN, \
+	 0x144, BIT(4), BIT(4)}
+#define GPIO4_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO4, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO5 definition */
+#define GPIO5_BT_SPI1_8852B	\
+	{MAC_AX_BT_SFALSH, MAC_AX_GPIO5, MAC_AX_GPIO_OUT, \
+	 0x66, BIT(4), BIT(4)}
+#define GPIO5_WL_SPI1_8852B	\
+	{MAC_AX_WL_SFALSH, MAC_AX_GPIO5, MAC_AX_GPIO_OUT, \
+	 0x42, BIT(3), BIT(3)}
+#define GPIO5_BT_JTAG_TDI_8852B	\
+	{MAC_AX_BT_JTAG, MAC_AX_GPIO5, MAC_AX_GPIO_IN, \
+	 0x67, BIT(0), BIT(0)}
+#define GPIO5_WL_JTAG_TDI_8852B	\
+	{MAC_AX_BT_JTAG, MAC_AX_GPIO5, MAC_AX_GPIO_IN, \
+	 0x65, BIT(7), BIT(7)}
+#define GPIO5_DBG_GNT_BT_8852B	\
+	{MAC_AX_DBG_GNT, MAC_AX_GPIO5, MAC_AX_GPIO_OUT, \
+	 0x73, BIT(3), BIT(3)}
+#define GPIO5_BT_GPIO18_8852B	\
+	{MAC_AX_BT_GPIO18, MAC_AX_GPIO5, MAC_AX_GPIO_IN_OUT, \
+	 0x67, BIT(1), BIT(1)}
+#define GPIO5_SOUT_8852B	\
+	{MAC_AX_WL_UART_TX, MAC_AX_GPIO5, MAC_AX_GPIO_OUT, \
+	 0x41, BIT(0), BIT(0)}
+#define GPIO5_WLMAC_DBG_GPIO5_8852B	\
+	{MAC_AX_WLMAC_DBG, MAC_AX_GPIO5, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(0)}
+#define GPIO5_WLPHY_DBG_GPIO5_8852B	\
+	{MAC_AX_WLPHY_DBG, MAC_AX_GPIO5, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1)}
+#define GPIO5_BT_DBG_GPIO5_8852B	\
+	{MAC_AX_BT_DBG, MAC_AX_GPIO5, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1) | BIT(0)}
+#define GPIO5_I2C_INT_3W_8852B	\
+	{MAC_AX_MAILBOX_3W, MAC_AX_GPIO5, MAC_AX_GPIO_IN, \
+	 0x4F, BIT(4), BIT(4)}
+#define GPIO5_I2C_INT_1W_8852B	\
+	{MAC_AX_MAILBOX_1W, MAC_AX_GPIO5, MAC_AX_GPIO_IN, \
+	 0x4F, BIT(7), BIT(7)}
+#define GPIO5_BANDSEL_5_6G_8852B	\
+	{MAC_AX_BANDSEL_5_6G, MAC_AX_GPIO5, MAC_AX_GPIO_IN, \
+	 0x143, BIT(4), BIT(4)}
+#define GPIO5_WL_RFE_CTRL5_0_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_4, MAC_AX_GPIO5, MAC_AX_GPIO_IN, \
+	 0x144, BIT(4), BIT(4)}
+#define GPIO5_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO5, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO6 definition */
+#define GPIO6_BT_SPI2_8852B	\
+	{MAC_AX_BT_SFALSH, MAC_AX_GPIO6, MAC_AX_GPIO_OUT, \
+	 0x66, BIT(4), BIT(4)}
+#define GPIO6_WL_SPI2_8852B	\
+	{MAC_AX_WL_SFALSH, MAC_AX_GPIO6, MAC_AX_GPIO_OUT, \
+	 0x42, BIT(3), BIT(3)}
+#define GPIO6_BT_JTAG_TDO_8852B	\
+	{MAC_AX_BT_JTAG, MAC_AX_GPIO6, MAC_AX_GPIO_OUT, \
+	 0x67, BIT(0), BIT(0)}
+#define GPIO6_WL_JTAG_TDO_8852B	\
+	{MAC_AX_BT_JTAG, MAC_AX_GPIO6, MAC_AX_GPIO_OUT, \
+	 0x65, BIT(7), BIT(7)}
+#define GPIO6_LTE_UART_IN_8852B	\
+	{MAC_AX_LTE_UART, MAC_AX_GPIO6, MAC_AX_GPIO_IN, \
+	 0x73, BIT(2), BIT(2)}
+#define GPIO6_LTE_3W_RX_IN_8852B	\
+	{MAC_AX_LTE_3W, MAC_AX_GPIO6, MAC_AX_GPIO_IN, \
+	 0x73, BIT(2), BIT(2)}
+#define GPIO6_BT_3DD_SYNC_8852B	\
+	{MAC_AX_BT_3DDLS_B, MAC_AX_GPIO6, MAC_AX_GPIO_IN, \
+	 0x67, BIT(1), BIT(1)}
+#define GPIO6_SIN_8852B	\
+	{MAC_AX_WL_UART_RX, MAC_AX_GPIO6, MAC_AX_GPIO_IN, \
+	 0x40, BIT(2), BIT(2)}
+#define GPIO6_WLMAC_DBG_GPIO6_8852B	\
+	{MAC_AX_WLMAC_DBG, MAC_AX_GPIO6, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(0)}
+#define GPIO6_WLPHY_DBG_GPIO6_8852B	\
+	{MAC_AX_WLPHY_DBG, MAC_AX_GPIO6, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1)}
+#define GPIO6_BT_DBG_GPIO6_8852B	\
+	{MAC_AX_BT_DBG, MAC_AX_GPIO6, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1) | BIT(0)}
+#define GPIO6_PAON_6G_S1_8852B	\
+	{MAC_AX_PAON_LNAON_6G_S1, MAC_AX_GPIO6, MAC_AX_GPIO_IN, \
+	 0x143, BIT(2), BIT(2)}
+#define GPIO6_WL_RFE_CTRL6_0_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_7, MAC_AX_GPIO6, MAC_AX_GPIO_IN, \
+	 0x144, BIT(4), BIT(4)}
+#define GPIO6_BANDSEL_5G_8852B	\
+	{MAC_AX_BANDSEL_5G, MAC_AX_GPIO6, MAC_AX_GPIO_IN, \
+	 0x143, BIT(2), BIT(2)}
+#define GPIO6_WL_RFE_CTRL6_1_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_8, MAC_AX_GPIO6, MAC_AX_GPIO_IN, \
+	 0x145, BIT(0), BIT(0)}
+#define GPIO6_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO6, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO7 definition */
+#define GPIO7_BT_SPI3_8852B	\
+	{MAC_AX_BT_SFALSH, MAC_AX_GPIO7, MAC_AX_GPIO_OUT, \
+	 0x66, BIT(4), BIT(4)}
+#define GPIO7_WL_SPI3_8852B	\
+	{MAC_AX_WL_SFALSH, MAC_AX_GPIO7, MAC_AX_GPIO_OUT, \
+	 0x42, BIT(3), BIT(3)}
+#define GPIO7_BT_JTAG_TMS_8852B	\
+	{MAC_AX_BT_JTAG, MAC_AX_GPIO7, MAC_AX_GPIO_IN, \
+	 0x67, BIT(0), BIT(0)}
+#define GPIO7_WL_JTAG_TMS_8852B	\
+	{MAC_AX_BT_JTAG, MAC_AX_GPIO7, MAC_AX_GPIO_IN, \
+	 0x65, BIT(7), BIT(7)}
+#define GPIO7_LTE_UART_OUT_8852B	\
+	{MAC_AX_LTE_UART, MAC_AX_GPIO7, MAC_AX_GPIO_IN, \
+	 0x73, BIT(2), BIT(2)}
+#define GPIO7_LTE_3W_TX_IN_8852B	\
+	{MAC_AX_LTE_3W, MAC_AX_GPIO7, MAC_AX_GPIO_IN, \
+	 0x73, BIT(2), BIT(2)}
+#define GPIO7_BT_GPIO16_8852B	\
+	{MAC_AX_BT_GPIO16, MAC_AX_GPIO7, MAC_AX_GPIO_IN_OUT, \
+	 0x67, BIT(2), BIT(2)}
+#define GPIO7_SOUT_8852B	\
+	{MAC_AX_WL_UART_TX, MAC_AX_GPIO7, MAC_AX_GPIO_OUT, \
+	 0x41, BIT(0), BIT(0)}
+#define GPIO7_WLMAC_DBG_GPIO7_8852B	\
+	{MAC_AX_WLMAC_DBG, MAC_AX_GPIO7, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(0)}
+#define GPIO7_WLPHY_DBG_GPIO7_8852B	\
+	{MAC_AX_WLPHY_DBG, MAC_AX_GPIO7, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1)}
+#define GPIO7_BT_DBG_GPIO7_8852B	\
+	{MAC_AX_BT_DBG, MAC_AX_GPIO7, MAC_AX_GPIO_OUT, \
+	 0x40, BIT(1) | BIT(0), BIT(1) | BIT(0)}
+#define GPIO7_LNAON_6G_S1_8852B	\
+	{MAC_AX_PAON_LNAON_6G_S1, MAC_AX_GPIO7, MAC_AX_GPIO_IN, \
+	 0x143, BIT(2), BIT(2)}
+#define GPIO7_WL_RFE_CTRL7_0_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_7, MAC_AX_GPIO7, MAC_AX_GPIO_IN, \
+	 0x144, BIT(4), BIT(4)}
+#define GPIO7_BANDSEL_5G_8852B	\
+	{MAC_AX_BANDSEL_5G, MAC_AX_GPIO7, MAC_AX_GPIO_IN, \
+	 0x143, BIT(2), BIT(2)}
+#define GPIO7_WL_RFE_CTRL7_1_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_8, MAC_AX_GPIO7, MAC_AX_GPIO_IN, \
+	 0x145, BIT(0), BIT(0)}
+#define GPIO7_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO7, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO8 definition */
+#define GPIO8_EXT_WOL_8852B	\
+	{MAC_AX_WL_HW_EXTWOL, MAC_AX_GPIO8, MAC_AX_GPIO_IN, \
+	 0x4A, BIT(0), BIT(0)}
+#define GPIO8_SICK_8852B	\
+	{MAC_AX_SIC, MAC_AX_GPIO8, MAC_AX_GPIO_IN, \
+	 0x41, BIT(4), BIT(4)}
+#define GPIO8_WL_LED_8852B	\
+	{MAC_AX_WL_LED, MAC_AX_GPIO8, MAC_AX_GPIO_IN, \
+	 0x4E, BIT(5), BIT(5)}
+#define GPIO8_SOUT_8852B	\
+	{MAC_AX_WL_UART_TX, MAC_AX_GPIO8, MAC_AX_GPIO_OUT, \
+	 0x41, BIT(0), BIT(0)}
+#define GPIO8_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO8, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO9 definition */
+#define GPIO9_DIS_WL_N_8852B	\
+	{MAC_AX_WL_HWPDN, MAC_AX_GPIO9, MAC_AX_GPIO_IN, \
+	 0x68, BIT(3), BIT(3)}
+#define GPIO9_EXT_WOL_8852B	\
+	{MAC_AX_WL_HW_EXTWOL, MAC_AX_GPIO9, MAC_AX_GPIO_IN, \
+	 0x4A, BIT(0), BIT(0)}
+#define GPIO9_USIN_8852B	\
+	{MAC_AX_UART, MAC_AX_GPIO9, MAC_AX_GPIO_IN, \
+	 0x66, BIT(6), BIT(6)}
+#define GPIO9_I2C_SD_8852B	\
+	{MAC_AX_MAILBOX_3W, MAC_AX_GPIO9, MAC_AX_GPIO_IN, \
+	 0x4F, BIT(4), BIT(4)}
+#define GPIO9_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO9, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO10 definition */
+#define GPIO10_WL_SDIO_INT_8852B	\
+	{MAC_AX_WL_SDIO_INT, MAC_AX_GPIO10, MAC_AX_GPIO_OUT, \
+	 0x72, BIT(2), BIT(2)}
+#define GPIO10_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO10, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO11 definition */
+#define GPIO11_DIS_BT_N_8852B	\
+	{MAC_AX_BT_HWPDN, MAC_AX_GPIO11, MAC_AX_GPIO_IN, \
+	 0x6A, BIT(3), BIT(3)}
+#define GPIO11_USOUT_8852B	\
+	{MAC_AX_UART, MAC_AX_GPIO11, MAC_AX_GPIO_OUT, \
+	 0x66, BIT(6), BIT(6)}
+#define GPIO11_BANDSEL_5G_G7G6_8852B	\
+	{MAC_AX_BANDSEL_5G_G7G6, MAC_AX_GPIO11, MAC_AX_GPIO_IN, \
+	 0x143, BIT(6), BIT(6)}
+#define GPIO11_WL_RFE_CTRL11_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_5, MAC_AX_GPIO11, MAC_AX_GPIO_IN, \
+	 0x144, BIT(5), BIT(5)}
+#define GPIO11_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO11, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO12 definition */
+#define GPIO12_USCTS_8852B	\
+	{MAC_AX_UART, MAC_AX_GPIO12, MAC_AX_GPIO_IN, \
+	 0x66, BIT(6), BIT(6)}
+#define GPIO12_LTE_PRI_OUT_8852B	\
+	{MAC_AX_LTE_3W, MAC_AX_GPIO12, MAC_AX_GPIO_OUT, \
+	 0x73, BIT(2), BIT(2)}
+#define GPIO12_I2C_CLK_8852B	\
+	{MAC_AX_MAILBOX_3W, MAC_AX_GPIO12, MAC_AX_GPIO_IN, \
+	 0x4F, BIT(4), BIT(4)}
+#define GPIO12_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO12, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO13 definition */
+#define GPIO13_BT_WAKE_8852B	\
+	{MAC_AX_GPIO13_14_WL_CTRL_EN, MAC_AX_GPIO13, MAC_AX_GPIO_IN, \
+	 0x4E, BIT(6), BIT(6)}
+#define GPIO13_BT_ANT_SW0_8852B	\
+	{MAC_AX_BT_RF, MAC_AX_GPIO13, MAC_AX_GPIO_OUT, \
+	 0x4F, BIT(6), BIT(6)}
+#define GPIO13_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO13, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO14 definition */
+#define GPIO14_UART_WAKE_8852B	\
+	{MAC_AX_GPIO13_14_WL_CTRL_EN, MAC_AX_GPIO14, MAC_AX_GPIO_IN, \
+	 0x4E, BIT(6), BIT(6)}
+#define GPIO14_BT_ANT_SW1_8852B	\
+	{MAC_AX_BT_RF, MAC_AX_GPIO14, MAC_AX_GPIO_OUT, \
+	 0x4F, BIT(6), BIT(6)}
+#define GPIO14_SIN_8852B	\
+	{MAC_AX_WL_UART_RX, MAC_AX_GPIO14, MAC_AX_GPIO_IN, \
+	 0x40, BIT(2), BIT(2)}
+#define GPIO14_BANDSEL_5G_G7G6_8852B	\
+	{MAC_AX_BANDSEL_5G_G7G6, MAC_AX_GPIO14, MAC_AX_GPIO_IN, \
+	 0x143, BIT(6), BIT(6)}
+#define GPIO14_WL_RFE_CTRL11_8852B	\
+	{MAC_AX_RFE_WLBT_FUNC_5, MAC_AX_GPIO14, MAC_AX_GPIO_IN, \
+	 0x144, BIT(5), BIT(5)}
+#define GPIO14_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO14, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+/* GPIO15 definition */
+#define GPIO15_EXT_XTAL_EN_8852B	\
+	{MAC_AX_EXT_XTAL_CLK, MAC_AX_GPIO15, MAC_AX_GPIO_IN, \
+	 0x66, BIT(7), BIT(7)}
+#define GPIO15_SW_IO_8852B	\
+	{MAC_AX_SW_IO, MAC_AX_GPIO15, MAC_AX_GPIO_IN_OUT, \
+	 0x40, BIT(1) | BIT(0), 0}
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO0_8852B[] = {
+	GPIO0_BT_GPIO0_8852B,
+	GPIO0_BT_SDIO_INT_8852B,
+	GPIO0_USIN_8852B,
+	GPIO0_BT_ANT_SW0_8852B,
+	GPIO0_BT_ACT_8852B,
+	GPIO0_WL_ACT_8852B,
+	GPIO0_WLMAC_DBG_GPIO0_8852B,
+	GPIO0_WLPHY_DBG_GPIO0_8852B,
+	GPIO0_BT_DBG_GPIO0_8852B,
+	GPIO0_PAON_2G_S0_8852B,
+	GPIO0_WL_RFE_CTRL0_0_8852B,
+	GPIO0_PAON_5G_S0_8852B,
+	GPIO0_WL_RFE_CTRL0_1_8852B,
+	GPIO0_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO1_8852B[] = {
+	GPIO1_BT_GPIO1_8852B,
+	GPIO1_USOUT_8852B,
+	GPIO1_BT_ANT_SW1_8852B,
+	GPIO1_BT_3DD_SYNC_8852B,
+	GPIO1_WL_CK_8852B,
+	GPIO1_BT_CK_8852B,
+	GPIO1_WLMAC_DBG_GPIO1_8852B,
+	GPIO1_WLPHY_DBG_GPIO1_8852B,
+	GPIO1_BT_DBG_GPIO1_8852B,
+	GPIO1_LNAON_2G_S0_8852B,
+	GPIO1_WL_RFE_CTRL1_0_8852B,
+	GPIO1_LNAON_5G_S0_8852B,
+	GPIO1_WL_RFE_CTRL1_1_8852B,
+	GPIO1_SW_IO_8852B,
+	GPIO1_BT_3DD_SYNC_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO2_8852B[] = {
+	GPIO2_BT_GPIO2_8852B,
+	GPIO2_BT_WAKE_8852B,
+	GPIO2_BT_ANT_SW2_8852B,
+	GPIO2_WL_STATE_8852B,
+	GPIO2_BT_STATE_8852B,
+	GPIO2_WLMAC_DBG_GPIO2_8852B,
+	GPIO2_WLPHY_DBG_GPIO2_8852B,
+	GPIO2_BT_DBG_GPIO2_8852B,
+	GPIO2_PAON_2G_S1_8852B,
+	GPIO2_WL_RFE_CTRL2_0_8852B,
+	GPIO2_PAON_5G_S1_8852B,
+	GPIO2_WL_RFE_CTRL2_1_8852B,
+	GPIO2_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO3_8852B[] = {
+	GPIO3_BT_GPIO3_8852B,
+	GPIO3_UART_WAKE_8852B,
+	GPIO3_BT_ANT_SW3_8852B,
+	GPIO3_WL_PRI_8852B,
+	GPIO3_BT_PRI_8852B,
+	GPIO3_WLMAC_DBG_GPIO3_8852B,
+	GPIO3_WLPHY_DBG_GPIO3_8852B,
+	GPIO3_BT_DBG_GPIO3_8852B,
+	GPIO3_LNAON_2G_S1_8852B,
+	GPIO3_WL_RFE_CTRL3_0_8852B,
+	GPIO3_LNAON_5G_S1_8852B,
+	GPIO3_WL_RFE_CTRL3_1_8852B,
+	GPIO3_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO4_8852B[] = {
+	GPIO4_BT_SPI0_8852B,
+	GPIO4_WL_SPI0_8852B,
+	GPIO4_BT_JTAG_TRST_8852B,
+	GPIO4_WL_JTAG_TRST_8852B,
+	GPIO4_DBG_GNT_WL_8852B,
+	GPIO4_WLMAC_DBG_GPIO4_8852B,
+	GPIO4_WLPHY_DBG_GPIO4_8852B,
+	GPIO4_BT_DBG_GPIO4_8852B,
+	GPIO4_BANDSEL_5_6G_8852B,
+	GPIO4_WL_RFE_CTRL4_0_8852B,
+	GPIO4_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO5_8852B[] = {
+	GPIO5_BT_SPI1_8852B,
+	GPIO5_WL_SPI1_8852B,
+	GPIO5_BT_JTAG_TDI_8852B,
+	GPIO5_WL_JTAG_TDI_8852B,
+	GPIO5_DBG_GNT_BT_8852B,
+	GPIO5_BT_GPIO18_8852B,
+	GPIO5_SOUT_8852B,
+	GPIO5_WLMAC_DBG_GPIO5_8852B,
+	GPIO5_WLPHY_DBG_GPIO5_8852B,
+	GPIO5_BT_DBG_GPIO5_8852B,
+	GPIO5_I2C_INT_3W_8852B,
+	GPIO5_I2C_INT_1W_8852B,
+	GPIO5_BANDSEL_5_6G_8852B,
+	GPIO5_WL_RFE_CTRL5_0_8852B,
+	GPIO5_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO6_8852B[] = {
+	GPIO6_BT_SPI2_8852B,
+	GPIO6_WL_SPI2_8852B,
+	GPIO6_BT_JTAG_TDO_8852B,
+	GPIO6_WL_JTAG_TDO_8852B,
+	GPIO6_LTE_UART_IN_8852B,
+	GPIO6_LTE_3W_RX_IN_8852B,
+	GPIO6_SIN_8852B,
+	GPIO6_WLMAC_DBG_GPIO6_8852B,
+	GPIO6_WLPHY_DBG_GPIO6_8852B,
+	GPIO6_BT_DBG_GPIO6_8852B,
+	GPIO6_PAON_6G_S1_8852B,
+	GPIO6_WL_RFE_CTRL6_0_8852B,
+	GPIO6_BANDSEL_5G_8852B,
+	GPIO6_WL_RFE_CTRL6_1_8852B,
+	GPIO6_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO7_8852B[] = {
+	GPIO7_BT_SPI3_8852B,
+	GPIO7_WL_SPI3_8852B,
+	GPIO7_BT_JTAG_TMS_8852B,
+	GPIO7_WL_JTAG_TMS_8852B,
+	GPIO7_LTE_UART_OUT_8852B,
+	GPIO7_LTE_3W_TX_IN_8852B,
+	GPIO7_BT_GPIO16_8852B,
+	GPIO7_SOUT_8852B,
+	GPIO7_WLMAC_DBG_GPIO7_8852B,
+	GPIO7_WLPHY_DBG_GPIO7_8852B,
+	GPIO7_BT_DBG_GPIO7_8852B,
+	GPIO7_LNAON_6G_S1_8852B,
+	GPIO7_WL_RFE_CTRL7_0_8852B,
+	GPIO7_BANDSEL_5G_8852B,
+	GPIO7_WL_RFE_CTRL7_1_8852B,
+	GPIO7_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO8_8852B[] = {
+	GPIO8_EXT_WOL_8852B,
+	GPIO8_SICK_8852B,
+	GPIO8_WL_LED_8852B,
+	GPIO8_SOUT_8852B,
+	GPIO8_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO9_8852B[] = {
+	GPIO9_DIS_WL_N_8852B,
+	GPIO9_EXT_WOL_8852B,
+	GPIO9_USIN_8852B,
+	GPIO9_I2C_SD_8852B,
+	GPIO9_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO10_8852B[] = {
+	GPIO10_WL_SDIO_INT_8852B,
+	GPIO10_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO11_8852B[] = {
+	GPIO11_DIS_BT_N_8852B,
+	GPIO11_USOUT_8852B,
+	GPIO11_BANDSEL_5G_G7G6_8852B,
+	GPIO11_WL_RFE_CTRL11_8852B,
+	GPIO11_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO12_8852B[] = {
+	GPIO12_USCTS_8852B,
+	GPIO12_LTE_PRI_OUT_8852B,
+	GPIO12_I2C_CLK_8852B,
+	GPIO12_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO13_8852B[] = {
+	GPIO13_BT_WAKE_8852B,
+	GPIO13_BT_ANT_SW0_8852B,
+	GPIO13_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO14_8852B[] = {
+	GPIO14_UART_WAKE_8852B,
+	GPIO14_BT_ANT_SW1_8852B,
+	GPIO14_SIN_8852B,
+	GPIO14_BANDSEL_5G_G7G6_8852B,
+	GPIO14_WL_RFE_CTRL11_8852B,
+	GPIO14_SW_IO_8852B,
+};
+
+static const struct mac_ax_pinmux_list PINMUX_LIST_GPIO15_8852B[] = {
+	GPIO15_EXT_XTAL_EN_8852B,
+	GPIO15_SW_IO_8852B,
+};
+
+#define PINMUX_GPIO0_BT_GPIO0_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D0, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(0)}
+#define PINMUX_GPIO0_LTE_UART_IN_PINEN_8852B \
+	{RTW_MAC_GPIO_LTE_UART, 0x2D0, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(1) | BIT(0)}
+#define PINMUX_GPIO0_LTE_UART_IN_FUNCEN_8852B \
+	{RTW_MAC_GPIO_LTE_UART, 0x73, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO0_LTE_UART_IN_DIS_8852B \
+	{RTW_MAC_GPIO_LTE_UART, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO0_LTE_3W_RX_IN_PINEN_8852B \
+	{RTW_MAC_GPIO_LTE_3W, 0x2D0, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2)}
+#define PINMUX_GPIO0_LTE_3W_RX_IN_FUNCEN_8852B \
+	{RTW_MAC_GPIO_LTE_3W, 0x73, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO0_LTE_3W_RX_IN_DIS_8852B \
+	{RTW_MAC_GPIO_LTE_3W, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO0_WL_ACT_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x2D0, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(0)}
+#define PINMUX_GPIO0_WL_ACT_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2)}
+#define PINMUX_GPIO0_BT_ACT_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x2D0, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(0)}
+#define PINMUX_GPIO0_BT_ACT_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2) | BIT(1)}
+#define PINMUX_GPIO0_DBG_GNT_WL_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG_GNT, 0x2D0, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1)}
+#define PINMUX_GPIO0_WL_JTAG_TRST_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D0, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO0_WL_JTAG_TRST_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x65, \
+	 BIT(7), BIT(7)}
+#define PINMUX_GPIO0_WL_JTAG_TRST_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO0_WL_JTAG_TRST_DIS_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D2, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO0_WL_RFE_CTRL0_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D0, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3)}
+#define PINMUX_GPIO0_DBG0_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D0, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1)}
+#define PINMUX_GPIO0_SW_IO0_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D0, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+
+#define PINMUX_GPIO1_BT_GPIO1_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D0, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(4)}
+#define PINMUX_GPIO1_LTE_UART_OUT_PINEN_8852B \
+	{RTW_MAC_GPIO_LTE_UART, 0x2D0, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(5) | BIT(4)}
+#define PINMUX_GPIO1_LTE_UART_OUT_FUNCEN_8852B \
+	{RTW_MAC_GPIO_LTE_UART, 0x73, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO1_LTE_3W_TX_IN_PINEN_8852B \
+	{RTW_MAC_GPIO_LTE_3W, 0x2D0, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6)}
+#define PINMUX_GPIO1_LTE_3W_TX_IN_FUNCEN_8852B \
+	{RTW_MAC_GPIO_LTE_3W, 0x73, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO1_LTE_3W_TX_IN_DIS_8852B \
+	{RTW_MAC_GPIO_LTE_3W, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO1_BT_CLK_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x2D0, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(4)}
+#define PINMUX_GPIO1_BT_CLK_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2)}
+#define PINMUX_GPIO1_WL_CLK_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x2D0, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(4)}
+#define PINMUX_GPIO1_WL_CLK_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2) | BIT(1)}
+#define PINMUX_GPIO1_DBG_GNT_BT_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG_GNT, 0x2D0, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5)}
+#define PINMUX_GPIO1_WL_JTAG_TDI_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D0, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO1_WL_JTAG_TDI_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x65, \
+	 BIT(7), BIT(7)}
+#define PINMUX_GPIO1_WL_JTAG_TDI_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO1_WL_JTAG_TDI_DIS_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D2, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO1_WL_RFE_CTRL1_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D0, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7)}
+#define PINMUX_GPIO1_DBG1_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D0, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5)}
+#define PINMUX_GPIO1_SW_IO1_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D0, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+
+#define PINMUX_GPIO2_WL_PD_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_PD, 0x2D1, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), 0}
+#define PINMUX_GPIO2_WL_PD_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_PD, 0x68, \
+	 BIT(0), BIT(0)}
+#define PINMUX_GPIO2_WL_PD_DIS_8852B \
+	{RTW_MAC_GPIO_WL_PD, 0x2D7, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO2_WL_PD_DIS_2_8852B \
+	{RTW_MAC_GPIO_WL_PD, 0x2D4, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO2_BT_GPIO2_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D1, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(0)}
+#define PINMUX_GPIO2_LTE_3W_PRI_OUT_PINEN_8852B \
+	{RTW_MAC_GPIO_LTE_3W, 0x2D1, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2)}
+#define PINMUX_GPIO2_LTE_3W_PRI_OUT_FUNCEN_8852B \
+	{RTW_MAC_GPIO_LTE_3W, 0x73, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO2_BT_STA_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x2D1, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(0)}
+#define PINMUX_GPIO2_BT_STA_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2)}
+#define PINMUX_GPIO2_WL_STA_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x2D1, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(0)}
+#define PINMUX_GPIO2_WL_STA_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2) | BIT(1)}
+#define PINMUX_GPIO2_DBG_GNT_WL_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG_GNT, 0x2D1, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1)}
+#define PINMUX_GPIO2_WL_JTAG_TDO_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D1, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO2_WL_JTAG_TDO_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x65, \
+	 BIT(7), BIT(7)}
+#define PINMUX_GPIO2_WL_JTAG_TDO_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO2_WL_JTAG_TDO_DIS_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO2_WL_RFE_CTRL2_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D1, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3)}
+#define PINMUX_GPIO2_DBG2_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D1, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1)}
+#define PINMUX_GPIO2_SW_IO02_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D1, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+
+#define PINMUX_GPIO3_BT_PD_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_PD, 0x2D1, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), 0}
+#define PINMUX_GPIO3_BT_PD_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_PD, 0x6A, \
+	 BIT(0), BIT(0)}
+#define PINMUX_GPIO3_BT_GPIO3_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D1, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(4)}
+#define PINMUX_GPIO3_BT_PRI_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x2D1, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(4)}
+#define PINMUX_GPIO3_BT_PRI_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2)}
+#define PINMUX_GPIO3_WL_PRI_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x2D1, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(4)}
+#define PINMUX_GPIO3_WL_PRI_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2) | BIT(1)}
+#define PINMUX_GPIO3_DBG_GNT_BT_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG_GNT, 0x2D1, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5)}
+#define PINMUX_GPIO3_WL_JTAG_TMS_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D1, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO3_WL_JTAG_TMS_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x65, \
+	 BIT(7), BIT(7)}
+#define PINMUX_GPIO3_WL_JTAG_TMS_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO3_WL_JTAG_TMS_DIS_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D4, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO3_WL_RFE_CTRL3_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D1, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7)}
+#define PINMUX_GPIO3_DBG3_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D1, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5)}
+#define PINMUX_GPIO3_SW_IO3_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D1, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+
+#define PINMUX_GPIO4_BT_GPIO4_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D2, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(0)}
+#define PINMUX_GPIO4_WL_FLASH0_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_FLASH, 0x2D2, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(1)}
+#define PINMUX_GPIO4_WL_FLASH0_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_FLASH, 0x42, \
+	 BIT(3), BIT(3)}
+#define PINMUX_GPIO4_BT_FLASH0_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_FLASH, 0x2D2, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(1)}
+#define PINMUX_GPIO4_BT_FLASH0_SECEN_8852B \
+	{RTW_MAC_GPIO_BT_FLASH, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO4_BT_FLASH0_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_FLASH, 0x66, \
+	 BIT(4), BIT(4)}
+#define PINMUX_GPIO4_WL_JTAG_TRST_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D2, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO4_WL_JTAG_TRST_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x65, \
+	 BIT(7), BIT(7)}
+#define PINMUX_GPIO4_WL_JTAG_TRST_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO4_WL_RFE_CTRL4_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D2, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3)}
+#define PINMUX_GPIO4_DBG4_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D2, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1)}
+#define PINMUX_GPIO4_SW_IO04_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D2, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+
+#define PINMUX_GPIO5_BT_GPIO5_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D2, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(4)}
+#define PINMUX_GPIO5_WL_FLASH1_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_FLASH, 0x2D2, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(5)}
+#define PINMUX_GPIO5_WL_FLASH1_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_FLASH, 0x42, \
+	 BIT(3), BIT(3)}
+#define PINMUX_GPIO5_BT_FLASH1_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_FLASH, 0x2D2, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(5)}
+#define PINMUX_GPIO5_BT_FLASH1_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_FLASH, 0x66, \
+	 BIT(4), BIT(4)}
+#define PINMUX_GPIO5_BT_FLASH1_SECEN_8852B \
+	{RTW_MAC_GPIO_BT_FLASH, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO5_MAILBOX_I2C_INT_PINEN_8852B \
+	{RTW_MAC_GPIO_MAILBOX, 0x2D2, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(4)}
+#define PINMUX_GPIO5_MAILBOX_I2C_INT_FUNCEN_8852B \
+	{RTW_MAC_GPIO_MAILBOX, 0x4F, \
+	 BIT(4), BIT(4)}
+#define PINMUX_GPIO5_XTAL_CLK_PINEN_8852B \
+	{RTW_MAC_GPIO_XTAL_CLK, 0x2D2, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5)}
+#define PINMUX_GPIO5_XTAL_CLK_FUNCEN_8852B \
+	{RTW_MAC_GPIO_XTAL_CLK, 0x4F, \
+	 BIT(5), BIT(5)}
+#define PINMUX_GPIO5_WL_JTAG_TDI_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D2, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO5_WL_JTAG_TDI_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x65, \
+	 BIT(7), BIT(7)}
+#define PINMUX_GPIO5_WL_JTAG_TDI_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO5_WL_RFE_CTRL5_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D2, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7)}
+#define PINMUX_GPIO5_DBG5_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D2, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5)}
+#define PINMUX_GPIO5_SW_IO5_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D2, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+
+#define PINMUX_GPIO6_BT_PD_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_PD, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), 0}
+#define PINMUX_GPIO6_BT_PD_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_PD, 0x6A, \
+	 BIT(0), BIT(0)}
+#define PINMUX_GPIO6_BT_GPIO6_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(0)}
+#define PINMUX_GPIO6_WL_FLASH2_PINEN_8852B	\
+	{RTW_MAC_GPIO_WL_FLASH, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(1)}
+#define PINMUX_GPIO6_WL_FLASH2_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_FLASH, 0x42, \
+	 BIT(3), BIT(3)}
+#define PINMUX_GPIO6_BT_FLASH2_PINEN_8852B	\
+	{RTW_MAC_GPIO_BT_FLASH, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(1)}
+#define PINMUX_GPIO6_BT_FLASH2_SECEN_8852B \
+	{RTW_MAC_GPIO_BT_FLASH, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO6_BT_FLASH2_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_FLASH, 0x66, \
+	 BIT(4), BIT(4)}
+#define PINMUX_GPIO6_LTE_UART_IN_PINEN_8852B	\
+	{RTW_MAC_GPIO_LTE_UART, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(1) | BIT(0)}
+#define PINMUX_GPIO6_LTE_UART_IN_FUNCEN_8852B \
+	{RTW_MAC_GPIO_LTE_UART, 0x73, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO6_LTE_3W_RX_IN_PINEN_8852B	\
+	{RTW_MAC_GPIO_LTE_3W, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2)}
+#define PINMUX_GPIO6_LTE_3W_RX_IN_FUNCEN_8852B \
+	{RTW_MAC_GPIO_LTE_3W, 0x73, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO6_MAILBOX_I2C_SD_PINEN_8852B \
+	{RTW_MAC_GPIO_MAILBOX, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(0)}
+#define PINMUX_GPIO6_MAILBOX_I2C_SD_FUNCEN_8852B \
+	{RTW_MAC_GPIO_MAILBOX, 0x4F, \
+	 BIT(4), BIT(4)}
+#define PINMUX_GPIO6_DBG_GNT_WL_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG_GNT, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1)}
+#define PINMUX_GPIO6_WL_JTAG_TDO_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO6_WL_JTAG_TDO_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x65, \
+	 BIT(7), BIT(7)}
+#define PINMUX_GPIO6_WL_JTAG_TDO_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO6_WL_RFE6_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3)}
+#define PINMUX_GPIO6_DBG_GPIO6_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1)}
+#define PINMUX_GPIO6_SW_IO6_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D3, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+
+#define PINMUX_GPIO7_BT_PD_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_PD, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), 0}
+#define PINMUX_GPIO7_BT_PD_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_PD, 0x6A, \
+	 BIT(0), BIT(0)}
+#define PINMUX_GPIO7_BT_GPIO7_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(4)}
+#define PINMUX_GPIO7_WL_FLASH3_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_FLASH, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(5)}
+#define PINMUX_GPIO7_WL_FLASH3_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_FLASH, 0x42, \
+	 BIT(3), BIT(3)}
+#define PINMUX_GPIO7_BT_FLASH3_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_FLASH, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(5)}
+#define PINMUX_GPIO7_BT_FLASH3_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_FLASH, 0x66, \
+	 BIT(4), BIT(4)}
+#define PINMUX_GPIO7_BT_FLASH3_SECEN_8852B \
+	{RTW_MAC_GPIO_BT_FLASH, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO7_LTE_UART_OUT_PINEN_8852B	\
+	{RTW_MAC_GPIO_LTE_UART, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(5) | BIT(4)}
+#define PINMUX_GPIO7_LTE_UART_OUT_FUNCEN_8852B \
+	{RTW_MAC_GPIO_LTE_UART, 0x73, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO7_LTE_3W_TX_IN_PINEN_8852B	\
+	{RTW_MAC_GPIO_LTE_3W, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6)}
+#define PINMUX_GPIO7_LTE_3W_TX_IN_FUNCEN_8852B \
+	{RTW_MAC_GPIO_LTE_3W, 0x73, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO7_MAILBOX_I2C_CLK_PINEN_8852B \
+	{RTW_MAC_GPIO_MAILBOX, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(4)}
+#define PINMUX_GPIO7_MAILBOX_I2C_CLK_FUNCEN_8852B \
+	{RTW_MAC_GPIO_MAILBOX, 0x4F, \
+	 BIT(4), BIT(4)}
+#define PINMUX_GPIO7_DBG_GNT_BT_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG_GNT, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5)}
+#define PINMUX_GPIO7_WL_JTAG_TMS_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO7_WL_JTAG_TMS_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x65, \
+	 BIT(7), BIT(7)}
+#define PINMUX_GPIO7_WL_JTAG_TMS_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO7_WL_RFE_CTRL7_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7)}
+#define PINMUX_GPIO7_DBG7_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5)}
+#define PINMUX_GPIO7_SW_IO7_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D3, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+
+#define PINMUX_GPIO8_EXT_WOL_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_EXTWOL, 0x2D4, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), 0}
+#define PINMUX_GPIO8_EXT_WOL_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_EXTWOL, 0x4A, \
+	 BIT(0), BIT(0)}
+#define PINMUX_GPIO8_BT_GPIO8_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D4, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(0)}
+#define PINMUX_GPIO8_SIC_CLK_PINEN_8852B	\
+	{RTW_MAC_GPIO_SIC, 0x2D4, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(1)}
+#define PINMUX_GPIO8_SIC_CLK_FUNCEN_8852B	\
+	{RTW_MAC_GPIO_SIC, 0x41, \
+	 BIT(4) | BIT(3), BIT(4) | BIT(3)}
+#define PINMUX_GPIO8_SIC_CLK_SECEN_8852B	\
+	{RTW_MAC_GPIO_SIC, 0xC00, \
+	 BIT(1), BIT(1)}
+#define PINMUX_GPIO8_MAILBOX_I2C_INT_PINEN_8852B \
+	{RTW_MAC_GPIO_MAILBOX, 0x2D4, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(0)}
+#define PINMUX_GPIO8_MAILBOX_I2C_INT_FUNCEN_8852B \
+	{RTW_MAC_GPIO_MAILBOX, 0x4F, \
+	 BIT(4), BIT(4)}
+#define PINMUX_GPIO8_WL_LED_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_LED, 0x2D4, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1)}
+#define PINMUX_GPIO8_WL_LED_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_LED, 0x4E, \
+	 BIT(5), BIT(5)}
+#define PINMUX_GPIO8_WL_UART_TX_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0x2D4, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO8_WL_UART_TX_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0x41, \
+	 BIT(0), BIT(0)}
+#define PINMUX_GPIO8_WL_UART_TX_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0xC00, \
+	 BIT(3), BIT(3)}
+#define PINMUX_GPIO8_WL_RFE8_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D4, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3)}
+#define PINMUX_GPIO8_DBG_GPIO8_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D4, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1)}
+#define PINMUX_GPIO8_SW_IO8_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D4, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+
+#define PINMUX_GPIO9_WL_PD_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_PD, 0x2D4, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), 0}
+#define PINMUX_GPIO9_BT_GPIO9_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D4, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(4)}
+#define PINMUX_GPIO9_MAILBOX_I2C_SD_PINEN_8852B \
+	{RTW_MAC_GPIO_MAILBOX, 0x2D4, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(4)}
+#define PINMUX_GPIO9_MAILBOX_I2C_SD_FUNCEN_8852B \
+	{RTW_MAC_GPIO_MAILBOX, 0x4F, \
+	 BIT(4), BIT(4)}
+#define PINMUX_GPIO9_DBG_GNT_WL_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG_GNT, 0x2D4, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5)}
+#define PINMUX_GPIO9_WL_UART_TX_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0x2D4, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO9_WL_UART_TX_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0x41, \
+	 BIT(0), BIT(0)}
+#define PINMUX_GPIO9_WL_UART_TX_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0xC00, \
+	 BIT(3), BIT(3)}
+#define PINMUX_GPIO9_WL_RFE_CTRL9_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D4, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7)}
+#define PINMUX_GPIO9_DBG9_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D4, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5)}
+#define PINMUX_GPIO9_SW_IO9_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D4, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+
+#define PINMUX_GPIO10_BT_GPIO10_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D5, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(0)}
+#define PINMUX_GPIO10_WL_SDIO_INT_PINEN_8852B	\
+	{RTW_MAC_GPIO_WL_SDIO_INT, 0x2D5, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(1)}
+#define PINMUX_GPIO10_WL_UART_RX_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_RX, 0x2D5, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO10_WL_UART_RX_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_RX, 0x40, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO10_WL_UART_RX_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_RX, 0xC00, \
+	 BIT(4), BIT(4)}
+#define PINMUX_GPIO10_WL_UART_RX_DIS_8852B \
+	{RTW_MAC_GPIO_WL_UART_RX, 0x2D5, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO10_WL_UART_RX_DIS_2_8852B \
+	{RTW_MAC_GPIO_WL_UART_RX, 0x2D7, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO10_WL_RFE10_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D5, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3)}
+#define PINMUX_GPIO10_DBG_GPIO10_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D5, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1)}
+#define PINMUX_GPIO10_SW_IO10_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D5, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+
+#define PINMUX_GPIO11_BT_PD_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_PD, 0x2D5, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), 0}
+#define PINMUX_GPIO11_BT_GPIO11_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D5, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(4)}
+#define PINMUX_GPIO11_MAILBOX_I2C_CLK_PINEN_8852B \
+	{RTW_MAC_GPIO_MAILBOX, 0x2D5, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(4)}
+#define PINMUX_GPIO11_MAILBOX_I2C_CLK_FUNCEN_8852B \
+	{RTW_MAC_GPIO_MAILBOX, 0x4F, \
+	 BIT(4), BIT(4)}
+#define PINMUX_GPIO11_DBG_GNT_BT_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG_GNT, 0x2D5, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5)}
+#define PINMUX_GPIO11_WL_UART_RX_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_RX, 0x2D5, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO11_WL_UART_RX_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_RX, 0xC00, \
+	 BIT(4), BIT(4)}
+#define PINMUX_GPIO11_WL_UART_RX_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_RX, 0x40, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO11_WL_UART_RX_DIS_8852B \
+	{RTW_MAC_GPIO_WL_UART_RX, 0x2D5, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO11_WL_UART_RX_DIS_2_8852B \
+	{RTW_MAC_GPIO_WL_UART_RX, 0x2D7, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO11_WL_RFE_CTRL11_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D5, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7)}
+#define PINMUX_GPIO11_DBG11_PINEN_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D5, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5)}
+#define PINMUX_GPIO11_SW_IO11_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D5, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+
+#define PINMUX_GPIO12_BT_GPIO12_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D6, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(0)}
+#define PINMUX_GPIO12_LTE_3W_PRI_OUT_PINEN_8852B	\
+	{RTW_MAC_GPIO_LTE_3W, 0x2D6, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(1)}
+#define PINMUX_GPIO12_LTE_3W_PRI_OUT_FUNCEN_8852B	\
+	{RTW_MAC_GPIO_LTE_3W, 0x73, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO12_WL_ACT_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x2D6, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(0)}
+#define PINMUX_GPIO12_WL_ACT_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2)}
+#define PINMUX_GPIO12_BT_ACT_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x2D6, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(0)}
+#define PINMUX_GPIO12_BT_ACT_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2) | BIT(1)}
+#define PINMUX_GPIO12_BT_ACT_DIS_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x2D0, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO12_DBG_GNT_WL_PINEN_8852B	\
+	{RTW_MAC_GPIO_DBG_GNT, 0x2D6, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1)}
+#define PINMUX_GPIO12_SOUT_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0x2D6, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO12_SOUT_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0xC00, \
+	 BIT(3), BIT(3)}
+#define PINMUX_GPIO12_SOUT_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0x41, \
+	 BIT(0), BIT(0)}
+#define PINMUX_GPIO12_WL_RFE12_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D6, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3)}
+#define PINMUX_GPIO12_DBG_GPIO12_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D6, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1)}
+#define PINMUX_GPIO12_SW_IO12_PINEN_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D6, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+
+#define PINMUX_GPIO13_BT_GPIO13_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D6, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(4)}
+#define PINMUX_GPIO13_WL_PTA_BT_CLK_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x2D6, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(4)}
+#define PINMUX_GPIO13_WL_PTA_BT_CLK_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2)}
+#define PINMUX_GPIO13_BT_PTA_WL_CLK_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x2D6, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(4)}
+#define PINMUX_GPIO13_BT_PTA_WL_CLK_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2) | BIT(1)}
+#define PINMUX_GPIO13_WL_UART_TX_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0x2D6, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO13_WL_UART_TX_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0xC00, \
+	 BIT(3), BIT(3)}
+#define PINMUX_GPIO13_WL_UART_TX_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0x41, \
+	 BIT(0), BIT(0)}
+#define PINMUX_GPIO13_WL_RFE_CTRL13_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D6, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7)}
+#define PINMUX_GPIO13_DBG13_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D6, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5)}
+#define PINMUX_GPIO13_SW_IO13_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D6, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+
+#define PINMUX_GPIO14_BT_GPIO14_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D7, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(0)}
+#define PINMUX_GPIO14_WL_PTA_BT_STA_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x2D7, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(0)}
+#define PINMUX_GPIO14_WL_PTA_BT_STA_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2)}
+#define PINMUX_GPIO14_BT_PTA_WL_STA_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x2D7, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(0)}
+#define PINMUX_GPIO14_BT_PTA_WL_STA_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2) | BIT(1)}
+#define PINMUX_GPIO14_WL_JTAG_CLK_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x2D7, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(2) | BIT(1) | BIT(0)}
+#define PINMUX_GPIO14_WL_JTAG_CLK_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0x65, \
+	 BIT(7), BIT(7)}
+#define PINMUX_GPIO14_WL_JTAG_CLK_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_JTAG, 0xC00, \
+	 BIT(2), BIT(2)}
+#define PINMUX_GPIO14_WL_RFE_CTRL13_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D7, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3)}
+#define PINMUX_GPIO14_DBG14_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D7, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1)}
+#define PINMUX_GPIO14_SW_IO14_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D7, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3) | BIT(2) | BIT(1) | BIT(0)}
+
+#define PINMUX_GPIO15_WL_PD_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_PD, 0x2D7, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), 0}
+#define PINMUX_GPIO15_BT_GPIO15_8852B \
+	{RTW_MAC_GPIO_BT_GPIO, 0x2D7, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(4)}
+#define PINMUX_GPIO15_WL_PTA_BT_CLK_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x2D7, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(4)}
+#define PINMUX_GPIO15_WL_PTA_BT_CLK_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2)}
+#define PINMUX_GPIO15_BT_PTA_WL_CLK_PINEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x2D7, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(4)}
+#define PINMUX_GPIO15_BT_PTA_WL_CLK_FUNCEN_8852B \
+	{RTW_MAC_GPIO_BT_PTA, 0x41, \
+	 BIT(2) | BIT(1), BIT(2) | BIT(1)}
+#define PINMUX_GPIO15_WL_UART_TX_PINEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0x2D7, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(6) | BIT(5) | BIT(4)}
+#define PINMUX_GPIO15_WL_UART_TX_SECEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0xC00, \
+	 BIT(3), BIT(3)}
+#define PINMUX_GPIO15_WL_UART_TX_FUNCEN_8852B \
+	{RTW_MAC_GPIO_WL_UART_TX, 0x41, \
+	 BIT(0), BIT(0)}
+#define PINMUX_GPIO15_WL_RFE_CTRL15_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D7, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7)}
+#define PINMUX_GPIO15_DBG15_8852B \
+	{RTW_MAC_GPIO_DBG, 0x2D7, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5)}
+#define PINMUX_GPIO15_SW_IO15_8852B \
+	{RTW_MAC_GPIO_SW_IO, 0x2D7, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7) | BIT(6) | BIT(5) | BIT(4)}
+
+#define PINMUX_GPIO16_WL_RFE_CTRL16_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D8, \
+	 BIT(3) | BIT(2) | BIT(1) | BIT(0), BIT(3)}
+
+#define PINMUX_GPIO17_WL_RFE_CTRL17_8852B \
+	{RTW_MAC_GPIO_WL_RFE_CTRL, 0x2D8, \
+	 BIT(7) | BIT(6) | BIT(5) | BIT(4), BIT(7)}
+
+#define PINMUX_GPIO_END_8852B \
+	{RTW_MAC_GPIO_INVALID, 0, 0, 0}
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO0_8852B[] = {
+	PINMUX_GPIO0_BT_GPIO0_PINEN_8852B,
+	PINMUX_GPIO0_LTE_UART_IN_PINEN_8852B,
+	PINMUX_GPIO0_LTE_UART_IN_FUNCEN_8852B,
+	PINMUX_GPIO0_LTE_UART_IN_DIS_8852B,
+	PINMUX_GPIO0_LTE_3W_RX_IN_PINEN_8852B,
+	PINMUX_GPIO0_LTE_3W_RX_IN_FUNCEN_8852B,
+	PINMUX_GPIO0_LTE_3W_RX_IN_DIS_8852B,
+	PINMUX_GPIO0_WL_ACT_PINEN_8852B,
+	PINMUX_GPIO0_WL_ACT_FUNCEN_8852B,
+	PINMUX_GPIO0_BT_ACT_PINEN_8852B,
+	PINMUX_GPIO0_BT_ACT_FUNCEN_8852B,
+	PINMUX_GPIO0_DBG_GNT_WL_PINEN_8852B,
+	PINMUX_GPIO0_WL_JTAG_TRST_PINEN_8852B,
+	PINMUX_GPIO0_WL_JTAG_TRST_FUNCEN_8852B,
+	PINMUX_GPIO0_WL_JTAG_TRST_SECEN_8852B,
+	PINMUX_GPIO0_WL_JTAG_TRST_DIS_8852B,
+	PINMUX_GPIO0_WL_RFE_CTRL0_PINEN_8852B,
+	PINMUX_GPIO0_DBG0_PINEN_8852B,
+	PINMUX_GPIO0_SW_IO0_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO1_8852B[] = {
+	PINMUX_GPIO1_BT_GPIO1_PINEN_8852B,
+	PINMUX_GPIO1_LTE_UART_OUT_PINEN_8852B,
+	PINMUX_GPIO1_LTE_UART_OUT_FUNCEN_8852B,
+	PINMUX_GPIO1_LTE_3W_TX_IN_PINEN_8852B,
+	PINMUX_GPIO1_LTE_3W_TX_IN_FUNCEN_8852B,
+	PINMUX_GPIO1_LTE_3W_TX_IN_DIS_8852B,
+	PINMUX_GPIO1_BT_CLK_PINEN_8852B,
+	PINMUX_GPIO1_BT_CLK_FUNCEN_8852B,
+	PINMUX_GPIO1_WL_CLK_PINEN_8852B,
+	PINMUX_GPIO1_WL_CLK_FUNCEN_8852B,
+	PINMUX_GPIO1_DBG_GNT_BT_PINEN_8852B,
+	PINMUX_GPIO1_WL_JTAG_TDI_PINEN_8852B,
+	PINMUX_GPIO1_WL_JTAG_TDI_FUNCEN_8852B,
+	PINMUX_GPIO1_WL_JTAG_TDI_SECEN_8852B,
+	PINMUX_GPIO1_WL_JTAG_TDI_DIS_8852B,
+	PINMUX_GPIO1_WL_RFE_CTRL1_PINEN_8852B,
+	PINMUX_GPIO1_DBG1_PINEN_8852B,
+	PINMUX_GPIO1_SW_IO1_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO2_8852B[] = {
+	PINMUX_GPIO2_WL_PD_PINEN_8852B,
+	PINMUX_GPIO2_WL_PD_FUNCEN_8852B,
+	PINMUX_GPIO2_WL_PD_DIS_8852B,
+	PINMUX_GPIO2_WL_PD_DIS_2_8852B,
+	PINMUX_GPIO2_BT_GPIO2_PINEN_8852B,
+	PINMUX_GPIO2_LTE_3W_PRI_OUT_PINEN_8852B,
+	PINMUX_GPIO2_LTE_3W_PRI_OUT_FUNCEN_8852B,
+	PINMUX_GPIO2_BT_STA_PINEN_8852B,
+	PINMUX_GPIO2_BT_STA_FUNCEN_8852B,
+	PINMUX_GPIO2_WL_STA_PINEN_8852B,
+	PINMUX_GPIO2_WL_STA_FUNCEN_8852B,
+	PINMUX_GPIO2_DBG_GNT_WL_PINEN_8852B,
+	PINMUX_GPIO2_WL_JTAG_TDO_PINEN_8852B,
+	PINMUX_GPIO2_WL_JTAG_TDO_FUNCEN_8852B,
+	PINMUX_GPIO2_WL_JTAG_TDO_SECEN_8852B,
+	PINMUX_GPIO2_WL_JTAG_TDO_DIS_8852B,
+	PINMUX_GPIO2_WL_RFE_CTRL2_PINEN_8852B,
+	PINMUX_GPIO2_DBG2_PINEN_8852B,
+	PINMUX_GPIO2_SW_IO02_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO3_8852B[] = {
+	PINMUX_GPIO3_BT_PD_PINEN_8852B,
+	PINMUX_GPIO3_BT_PD_FUNCEN_8852B,
+	PINMUX_GPIO3_BT_GPIO3_PINEN_8852B,
+	PINMUX_GPIO3_BT_PRI_PINEN_8852B,
+	PINMUX_GPIO3_BT_PRI_FUNCEN_8852B,
+	PINMUX_GPIO3_WL_PRI_PINEN_8852B,
+	PINMUX_GPIO3_WL_PRI_FUNCEN_8852B,
+	PINMUX_GPIO3_DBG_GNT_BT_PINEN_8852B,
+	PINMUX_GPIO3_WL_JTAG_TMS_PINEN_8852B,
+	PINMUX_GPIO3_WL_JTAG_TMS_FUNCEN_8852B,
+	PINMUX_GPIO3_WL_JTAG_TMS_SECEN_8852B,
+	PINMUX_GPIO3_WL_JTAG_TMS_DIS_8852B,
+	PINMUX_GPIO3_WL_RFE_CTRL3_PINEN_8852B,
+	PINMUX_GPIO3_DBG3_PINEN_8852B,
+	PINMUX_GPIO3_SW_IO3_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO4_8852B[] = {
+	PINMUX_GPIO4_BT_GPIO4_PINEN_8852B,
+	PINMUX_GPIO4_WL_FLASH0_PINEN_8852B,
+	PINMUX_GPIO4_WL_FLASH0_FUNCEN_8852B,
+	PINMUX_GPIO4_BT_FLASH0_PINEN_8852B,
+	PINMUX_GPIO4_BT_FLASH0_SECEN_8852B,
+	PINMUX_GPIO4_BT_FLASH0_FUNCEN_8852B,
+	PINMUX_GPIO4_WL_JTAG_TRST_PINEN_8852B,
+	PINMUX_GPIO4_WL_JTAG_TRST_FUNCEN_8852B,
+	PINMUX_GPIO4_WL_JTAG_TRST_SECEN_8852B,
+	PINMUX_GPIO4_WL_RFE_CTRL4_PINEN_8852B,
+	PINMUX_GPIO4_DBG4_PINEN_8852B,
+	PINMUX_GPIO4_SW_IO04_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO5_8852B[] = {
+	PINMUX_GPIO5_BT_GPIO5_PINEN_8852B,
+	PINMUX_GPIO5_WL_FLASH1_PINEN_8852B,
+	PINMUX_GPIO5_WL_FLASH1_FUNCEN_8852B,
+	PINMUX_GPIO5_BT_FLASH1_PINEN_8852B,
+	PINMUX_GPIO5_BT_FLASH1_FUNCEN_8852B,
+	PINMUX_GPIO5_BT_FLASH1_SECEN_8852B,
+	PINMUX_GPIO5_MAILBOX_I2C_INT_PINEN_8852B,
+	PINMUX_GPIO5_MAILBOX_I2C_INT_FUNCEN_8852B,
+	PINMUX_GPIO5_XTAL_CLK_PINEN_8852B,
+	PINMUX_GPIO5_XTAL_CLK_FUNCEN_8852B,
+	PINMUX_GPIO5_WL_JTAG_TDI_PINEN_8852B,
+	PINMUX_GPIO5_WL_JTAG_TDI_FUNCEN_8852B,
+	PINMUX_GPIO5_WL_JTAG_TDI_SECEN_8852B,
+	PINMUX_GPIO5_WL_RFE_CTRL5_PINEN_8852B,
+	PINMUX_GPIO5_DBG5_PINEN_8852B,
+	PINMUX_GPIO5_SW_IO5_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO6_8852B[] = {
+	PINMUX_GPIO6_BT_PD_PINEN_8852B,
+	PINMUX_GPIO6_BT_PD_FUNCEN_8852B,
+	PINMUX_GPIO6_BT_GPIO6_8852B,
+	PINMUX_GPIO6_WL_FLASH2_PINEN_8852B,
+	PINMUX_GPIO6_WL_FLASH2_FUNCEN_8852B,
+	PINMUX_GPIO6_BT_FLASH2_PINEN_8852B,
+	PINMUX_GPIO6_BT_FLASH2_SECEN_8852B,
+	PINMUX_GPIO6_BT_FLASH2_FUNCEN_8852B,
+	PINMUX_GPIO6_LTE_UART_IN_PINEN_8852B,
+	PINMUX_GPIO6_LTE_UART_IN_FUNCEN_8852B,
+	PINMUX_GPIO6_LTE_3W_RX_IN_PINEN_8852B,
+	PINMUX_GPIO6_LTE_3W_RX_IN_FUNCEN_8852B,
+	PINMUX_GPIO6_MAILBOX_I2C_SD_PINEN_8852B,
+	PINMUX_GPIO6_MAILBOX_I2C_SD_FUNCEN_8852B,
+	PINMUX_GPIO6_DBG_GNT_WL_PINEN_8852B,
+	PINMUX_GPIO6_WL_JTAG_TDO_PINEN_8852B,
+	PINMUX_GPIO6_WL_JTAG_TDO_FUNCEN_8852B,
+	PINMUX_GPIO6_WL_JTAG_TDO_SECEN_8852B,
+	PINMUX_GPIO6_WL_RFE6_8852B,
+	PINMUX_GPIO6_DBG_GPIO6_8852B,
+	PINMUX_GPIO6_SW_IO6_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO7_8852B[] = {
+	PINMUX_GPIO7_BT_PD_PINEN_8852B,
+	PINMUX_GPIO7_BT_PD_FUNCEN_8852B,
+	PINMUX_GPIO7_BT_GPIO7_PINEN_8852B,
+	PINMUX_GPIO7_WL_FLASH3_PINEN_8852B,
+	PINMUX_GPIO7_WL_FLASH3_FUNCEN_8852B,
+	PINMUX_GPIO7_BT_FLASH3_PINEN_8852B,
+	PINMUX_GPIO7_BT_FLASH3_FUNCEN_8852B,
+	PINMUX_GPIO7_BT_FLASH3_SECEN_8852B,
+	PINMUX_GPIO7_LTE_UART_OUT_PINEN_8852B,
+	PINMUX_GPIO7_LTE_UART_OUT_FUNCEN_8852B,
+	PINMUX_GPIO7_LTE_3W_TX_IN_PINEN_8852B,
+	PINMUX_GPIO7_LTE_3W_TX_IN_FUNCEN_8852B,
+	PINMUX_GPIO7_MAILBOX_I2C_CLK_PINEN_8852B,
+	PINMUX_GPIO7_MAILBOX_I2C_CLK_FUNCEN_8852B,
+	PINMUX_GPIO7_DBG_GNT_BT_PINEN_8852B,
+	PINMUX_GPIO7_WL_JTAG_TMS_PINEN_8852B,
+	PINMUX_GPIO7_WL_JTAG_TMS_FUNCEN_8852B,
+	PINMUX_GPIO7_WL_JTAG_TMS_SECEN_8852B,
+	PINMUX_GPIO7_WL_RFE_CTRL7_PINEN_8852B,
+	PINMUX_GPIO7_DBG7_PINEN_8852B,
+	PINMUX_GPIO7_SW_IO7_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO8_8852B[] = {
+	PINMUX_GPIO8_EXT_WOL_PINEN_8852B,
+	PINMUX_GPIO8_EXT_WOL_FUNCEN_8852B,
+	PINMUX_GPIO8_BT_GPIO8_8852B,
+	PINMUX_GPIO8_SIC_CLK_PINEN_8852B,
+	PINMUX_GPIO8_SIC_CLK_FUNCEN_8852B,
+	PINMUX_GPIO8_SIC_CLK_SECEN_8852B,
+	PINMUX_GPIO8_MAILBOX_I2C_INT_PINEN_8852B,
+	PINMUX_GPIO8_MAILBOX_I2C_INT_FUNCEN_8852B,
+	PINMUX_GPIO8_WL_LED_PINEN_8852B,
+	PINMUX_GPIO8_WL_LED_FUNCEN_8852B,
+	PINMUX_GPIO8_WL_UART_TX_PINEN_8852B,
+	PINMUX_GPIO8_WL_UART_TX_FUNCEN_8852B,
+	PINMUX_GPIO8_WL_UART_TX_SECEN_8852B,
+	PINMUX_GPIO8_WL_RFE8_8852B,
+	PINMUX_GPIO8_DBG_GPIO8_8852B,
+	PINMUX_GPIO8_SW_IO8_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO9_8852B[] = {
+	PINMUX_GPIO9_WL_PD_PINEN_8852B,
+	PINMUX_GPIO9_BT_GPIO9_PINEN_8852B,
+	PINMUX_GPIO9_MAILBOX_I2C_SD_PINEN_8852B,
+	PINMUX_GPIO9_MAILBOX_I2C_SD_FUNCEN_8852B,
+	PINMUX_GPIO9_DBG_GNT_WL_PINEN_8852B,
+	PINMUX_GPIO9_WL_UART_TX_PINEN_8852B,
+	PINMUX_GPIO9_WL_UART_TX_FUNCEN_8852B,
+	PINMUX_GPIO9_WL_UART_TX_SECEN_8852B,
+	PINMUX_GPIO9_WL_RFE_CTRL9_PINEN_8852B,
+	PINMUX_GPIO9_DBG9_PINEN_8852B,
+	PINMUX_GPIO9_SW_IO9_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO10_8852B[] = {
+	PINMUX_GPIO10_BT_GPIO10_8852B,
+	PINMUX_GPIO10_WL_SDIO_INT_PINEN_8852B,
+	PINMUX_GPIO10_WL_UART_RX_PINEN_8852B,
+	PINMUX_GPIO10_WL_UART_RX_FUNCEN_8852B,
+	PINMUX_GPIO10_WL_UART_RX_SECEN_8852B,
+	PINMUX_GPIO10_WL_UART_RX_DIS_8852B,
+	PINMUX_GPIO10_WL_UART_RX_DIS_2_8852B,
+	PINMUX_GPIO10_WL_RFE10_8852B,
+	PINMUX_GPIO10_DBG_GPIO10_8852B,
+	PINMUX_GPIO10_SW_IO10_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO11_8852B[] = {
+	PINMUX_GPIO11_BT_PD_PINEN_8852B,
+	PINMUX_GPIO11_BT_GPIO11_PINEN_8852B,
+	PINMUX_GPIO11_MAILBOX_I2C_CLK_PINEN_8852B,
+	PINMUX_GPIO11_MAILBOX_I2C_CLK_FUNCEN_8852B,
+	PINMUX_GPIO11_DBG_GNT_BT_PINEN_8852B,
+	PINMUX_GPIO11_WL_UART_RX_PINEN_8852B,
+	PINMUX_GPIO11_WL_UART_RX_SECEN_8852B,
+	PINMUX_GPIO11_WL_UART_RX_FUNCEN_8852B,
+	PINMUX_GPIO11_WL_UART_RX_DIS_8852B,
+	PINMUX_GPIO11_WL_UART_RX_DIS_2_8852B,
+	PINMUX_GPIO11_WL_RFE_CTRL11_PINEN_8852B,
+	PINMUX_GPIO11_DBG11_PINEN_8852B,
+	PINMUX_GPIO11_SW_IO11_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO12_8852B[] = {
+	PINMUX_GPIO12_BT_GPIO12_8852B,
+	PINMUX_GPIO12_LTE_3W_PRI_OUT_PINEN_8852B,
+	PINMUX_GPIO12_LTE_3W_PRI_OUT_FUNCEN_8852B,
+	PINMUX_GPIO12_WL_ACT_PINEN_8852B,
+	PINMUX_GPIO12_WL_ACT_FUNCEN_8852B,
+	PINMUX_GPIO12_BT_ACT_PINEN_8852B,
+	PINMUX_GPIO12_BT_ACT_FUNCEN_8852B,
+	PINMUX_GPIO12_BT_ACT_DIS_8852B,
+	PINMUX_GPIO12_DBG_GNT_WL_PINEN_8852B,
+	PINMUX_GPIO12_SOUT_PINEN_8852B,
+	PINMUX_GPIO12_SOUT_SECEN_8852B,
+	PINMUX_GPIO12_SOUT_FUNCEN_8852B,
+	PINMUX_GPIO12_WL_RFE12_8852B,
+	PINMUX_GPIO12_DBG_GPIO12_8852B,
+	PINMUX_GPIO12_SW_IO12_PINEN_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO13_8852B[] = {
+	PINMUX_GPIO13_BT_GPIO13_8852B,
+	PINMUX_GPIO13_WL_PTA_BT_CLK_PINEN_8852B,
+	PINMUX_GPIO13_WL_PTA_BT_CLK_FUNCEN_8852B,
+	PINMUX_GPIO13_BT_PTA_WL_CLK_PINEN_8852B,
+	PINMUX_GPIO13_BT_PTA_WL_CLK_FUNCEN_8852B,
+	PINMUX_GPIO13_WL_UART_TX_PINEN_8852B,
+	PINMUX_GPIO13_WL_UART_TX_SECEN_8852B,
+	PINMUX_GPIO13_WL_UART_TX_FUNCEN_8852B,
+	PINMUX_GPIO13_WL_RFE_CTRL13_8852B,
+	PINMUX_GPIO13_DBG13_8852B,
+	PINMUX_GPIO13_SW_IO13_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO14_8852B[] = {
+	PINMUX_GPIO14_BT_GPIO14_8852B,
+	PINMUX_GPIO14_WL_PTA_BT_STA_PINEN_8852B,
+	PINMUX_GPIO14_WL_PTA_BT_STA_FUNCEN_8852B,
+	PINMUX_GPIO14_BT_PTA_WL_STA_PINEN_8852B,
+	PINMUX_GPIO14_BT_PTA_WL_STA_FUNCEN_8852B,
+	PINMUX_GPIO14_WL_JTAG_CLK_PINEN_8852B,
+	PINMUX_GPIO14_WL_JTAG_CLK_FUNCEN_8852B,
+	PINMUX_GPIO14_WL_JTAG_CLK_SECEN_8852B,
+	PINMUX_GPIO14_WL_RFE_CTRL13_8852B,
+	PINMUX_GPIO14_DBG14_8852B,
+	PINMUX_GPIO14_SW_IO14_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO15_8852B[] = {
+	PINMUX_GPIO15_WL_PD_PINEN_8852B,
+	PINMUX_GPIO15_BT_GPIO15_8852B,
+	PINMUX_GPIO15_WL_PTA_BT_CLK_PINEN_8852B,
+	PINMUX_GPIO15_WL_PTA_BT_CLK_FUNCEN_8852B,
+	PINMUX_GPIO15_BT_PTA_WL_CLK_PINEN_8852B,
+	PINMUX_GPIO15_BT_PTA_WL_CLK_FUNCEN_8852B,
+	PINMUX_GPIO15_WL_UART_TX_PINEN_8852B,
+	PINMUX_GPIO15_WL_UART_TX_SECEN_8852B,
+	PINMUX_GPIO15_WL_UART_TX_FUNCEN_8852B,
+	PINMUX_GPIO15_WL_RFE_CTRL15_8852B,
+	PINMUX_GPIO15_DBG15_8852B,
+	PINMUX_GPIO15_SW_IO15_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO16_8852B[] = {
+	PINMUX_GPIO16_WL_RFE_CTRL16_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list PIN_LIST_GPIO17_8852B[] = {
+	PINMUX_GPIO17_WL_RFE_CTRL17_8852B,
+	PINMUX_GPIO_END_8852B,
+};
+
+static const struct mac_ax_pin_list *PIN_LIST_8852B[] = {
+	PIN_LIST_GPIO0_8852B, /* gpio0 */
+	PIN_LIST_GPIO1_8852B, /* gpio1 */
+	PIN_LIST_GPIO2_8852B, /* gpio2 */
+	PIN_LIST_GPIO3_8852B, /* gpio3 */
+	PIN_LIST_GPIO4_8852B, /* gpio4 */
+	PIN_LIST_GPIO5_8852B, /* gpio5 */
+	PIN_LIST_GPIO6_8852B, /* gpio6 */
+	PIN_LIST_GPIO7_8852B, /* gpio7 */
+	PIN_LIST_GPIO8_8852B, /* gpio8 */
+	PIN_LIST_GPIO9_8852B, /* gpio9 */
+	PIN_LIST_GPIO10_8852B, /* gpio10 */
+	PIN_LIST_GPIO11_8852B, /* gpio11 */
+	PIN_LIST_GPIO12_8852B, /* gpio12 */
+	PIN_LIST_GPIO13_8852B, /* gpio13 */
+	PIN_LIST_GPIO14_8852B, /* gpio14 */
+	PIN_LIST_GPIO15_8852B, /* gpio15 */
+	PIN_LIST_GPIO16_8852B, /* gpio16 */
+	PIN_LIST_GPIO17_8852B, /* gpio17 */
+};
+
+static u32 mac_get_pinmux_list_8852b(struct mac_ax_adapter *adapter,
+				     enum mac_ax_gpio_func func,
+				     const struct mac_ax_pinmux_list **list,
+				     u32 *list_size, u32 *gpio_id)
+{
+	switch (func) {
+	case MAC_AX_GPIO_SW_IO_0:
+		*list = PINMUX_LIST_GPIO0_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO0_8852B);
+		*gpio_id = MAC_AX_GPIO0;
+		break;
+	case MAC_AX_GPIO_SW_IO_1:
+		*list = PINMUX_LIST_GPIO1_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO1_8852B);
+		*gpio_id = MAC_AX_GPIO1;
+		break;
+	case MAC_AX_GPIO_SW_IO_2:
+		*list = PINMUX_LIST_GPIO2_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO2_8852B);
+		*gpio_id = MAC_AX_GPIO2;
+		break;
+	case MAC_AX_GPIO_SW_IO_3:
+		*list = PINMUX_LIST_GPIO3_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO3_8852B);
+		*gpio_id = MAC_AX_GPIO3;
+		break;
+	case MAC_AX_GPIO_SW_IO_4:
+		*list = PINMUX_LIST_GPIO4_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO4_8852B);
+		*gpio_id = MAC_AX_GPIO4;
+		break;
+	case MAC_AX_GPIO_SW_IO_5:
+	case MAC_AX_GPIO_UART_TX_GPIO5:
+		*list = PINMUX_LIST_GPIO5_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO5_8852B);
+		*gpio_id = MAC_AX_GPIO5;
+		break;
+	case MAC_AX_GPIO_SW_IO_6:
+	case MAC_AX_GPIO_UART_RX_GPIO6:
+		*list = PINMUX_LIST_GPIO6_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO6_8852B);
+		*gpio_id = MAC_AX_GPIO6;
+		break;
+	case MAC_AX_GPIO_SW_IO_7:
+	case MAC_AX_GPIO_UART_TX_GPIO7:
+		*list = PINMUX_LIST_GPIO7_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO7_8852B);
+		*gpio_id = MAC_AX_GPIO7;
+		break;
+	case MAC_AX_GPIO_SW_IO_8:
+	case MAC_AX_GPIO_UART_TX_GPIO8:
+		*list = PINMUX_LIST_GPIO8_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO8_8852B);
+		*gpio_id = MAC_AX_GPIO8;
+		break;
+	case MAC_AX_GPIO_SW_IO_9:
+		*list = PINMUX_LIST_GPIO9_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO9_8852B);
+		*gpio_id = MAC_AX_GPIO9;
+		break;
+	case MAC_AX_GPIO_SW_IO_10:
+		*list = PINMUX_LIST_GPIO10_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO10_8852B);
+		*gpio_id = MAC_AX_GPIO10;
+		break;
+	case MAC_AX_GPIO_SW_IO_11:
+		*list = PINMUX_LIST_GPIO11_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO11_8852B);
+		*gpio_id = MAC_AX_GPIO11;
+		break;
+	case MAC_AX_GPIO_SW_IO_12:
+		*list = PINMUX_LIST_GPIO12_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO12_8852B);
+		*gpio_id = MAC_AX_GPIO12;
+		break;
+	case MAC_AX_GPIO_SW_IO_13:
+		*list = PINMUX_LIST_GPIO13_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO13_8852B);
+		*gpio_id = MAC_AX_GPIO13;
+		break;
+	case MAC_AX_GPIO_SW_IO_14:
+	case MAC_AX_GPIO_UART_RX_GPIO14:
+		*list = PINMUX_LIST_GPIO14_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO14_8852B);
+		*gpio_id = MAC_AX_GPIO14;
+		break;
+	case MAC_AX_GPIO_SW_IO_15:
+		*list = PINMUX_LIST_GPIO15_8852B;
+		*list_size = ARRAY_SIZE(PINMUX_LIST_GPIO15_8852B);
+		*gpio_id = MAC_AX_GPIO15;
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_pinmux_set_func_8852b(struct mac_ax_adapter *adapter,
+			      enum mac_ax_gpio_func func)
+{
+	const struct mac_ax_pinmux_list *list = NULL;
+	u32 ret;
+	u32 gpio_id, list_size;
+
+	ret = mac_pinmux_status(adapter, func);
+	if (ret)
+		goto END;
+
+	ret = mac_get_pinmux_list_8852b(adapter, func, &list,
+					&list_size, &gpio_id);
+	if (ret)
+		goto END;
+
+	ret = mac_pinmux_switch(adapter, func, list, list_size, gpio_id);
+	if (ret)
+		goto END;
+
+	ret = mac_pinmux_record(adapter, func, 1);
+
+END:
+	return ret;
+}
+
+u32 mac_gpio_init_8852b(struct mac_ax_adapter *adapter)
+{
+	bool is_fpga = false;
+
+#if MAC_AX_FEATURE_HV
+	if (adapter->env == HV_AX_FPGA)
+		is_fpga = true;
+	else
+		is_fpga = false;
+#elif MAC_AX_FPGA_TEST
+	is_fpga = true;
+#endif
+	if (is_fpga) {
+		adapter->gpio_info.uart_tx_gpio = 13;
+		adapter->gpio_info.uart_rx_gpio = 11;
+	} else {
+		adapter->gpio_info.uart_tx_gpio = 12;
+		adapter->gpio_info.uart_rx_gpio = 11;
+	}
+	return MACSUCCESS;
+}
+
+u32 mac_set_gpio_func_8852b(struct mac_ax_adapter *adapter,
+			    enum rtw_mac_gfunc func, s8 gpio_cfg)
+{
+	const struct mac_ax_pin_list *list;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val, is_set = 0;
+	u8 gpio;
+
+	if (gpio_cfg < MAC_AX_GPIO_MIN || gpio_cfg > RTW_MAC_GPIO_MAX) {
+		PLTFM_MSG_ERR("The GPIO number is wrong: %d", gpio_cfg);
+		return MACGPIONUM;
+	}
+
+	gpio = gpio_cfg;
+	list = PIN_LIST_8852B[gpio];
+	while (list && list->func != RTW_MAC_GPIO_INVALID) {
+		if (list->func == func) {
+			val = MAC_REG_R8(list->offset);
+			val = (val & ~(list->msk)) | list->value;
+			MAC_REG_W8(list->offset, val);
+			is_set++;
+		}
+		list++;
+	}
+
+	if (!is_set) {
+		PLTFM_MSG_ERR("The GPIO function is NOT available in %d", gpio);
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_gpio_status_8852b(struct mac_ax_adapter *adapter,
+			      enum rtw_mac_gfunc *func, u8 gpio)
+{
+	if (gpio > RTW_MAC_GPIO_MAX) {
+		PLTFM_MSG_ERR("The GPIO number is wrong: %d", gpio);
+		return MACGPIONUM;
+	}
+
+	*func = mac_get_gpio_status(adapter, PIN_LIST_8852B[gpio]);
+
+	return MACSUCCESS;
+}
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/gpio_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/gpio_8852b.h
new file mode 100644
index 000000000000..1cd30a6bd1ed
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/gpio_8852b.h
@@ -0,0 +1,71 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_GPIO_8852B_H_
+#define _MAC_AX_GPIO_8852B_H_
+
+#include "../../type.h"
+#if MAC_AX_8852B_SUPPORT
+
+/**
+ * @brief mac_pinmux_set_func_8852b
+ *
+ * @param *adapter
+ * @param func
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_pinmux_set_func_8852b(struct mac_ax_adapter *adapter,
+			      enum mac_ax_gpio_func func);
+
+/**
+ * @brief mac_gpio_init_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_gpio_init_8852b(struct mac_ax_adapter *adapter);
+
+/**
+ * @brief mac_set_gpio_func_8852b
+ *
+ * @param *adapter
+ * @param func
+ * @param gpio
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_gpio_func_8852b(struct mac_ax_adapter *adapter,
+			    enum rtw_mac_gfunc func, s8 gpio);
+
+/**
+ * @brief mac_get_gpio_status_8852b
+ *
+ * @param *adapter
+ * @param *func
+ * @param gpio
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_get_gpio_status_8852b(struct mac_ax_adapter *adapter,
+			      enum rtw_mac_gfunc *func, u8 gpio);
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hci_fc_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hci_fc_8852b.c
new file mode 100644
index 000000000000..82ffde3357e5
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hci_fc_8852b.c
@@ -0,0 +1,292 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "hci_fc_8852b.h"
+#include "../../mac_reg.h"
+
+#if MAC_AX_8852B_SUPPORT
+
+u32 set_fc_page_ctrl_reg_8852b(struct mac_ax_adapter *adapter, u8 ch)
+{
+	struct mac_ax_hfc_ch_cfg *cfg = adapter->hfc_param->ch_cfg;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32 = 0;
+
+	switch (ch) {
+	case MAC_AX_DMA_ACH0:
+		val32 = SET_WORD(cfg[MAC_AX_DMA_ACH0].min, B_AX_ACH0_MIN_PG) |
+			SET_WORD(cfg[MAC_AX_DMA_ACH0].max, B_AX_ACH0_MAX_PG) |
+			(cfg[MAC_AX_DMA_ACH0].grp ? B_AX_ACH0_GRP : 0);
+		MAC_REG_W32(R_AX_ACH0_PAGE_CTRL, val32);
+		break;
+
+	case MAC_AX_DMA_ACH1:
+		val32 = SET_WORD(cfg[MAC_AX_DMA_ACH1].min, B_AX_ACH1_MIN_PG) |
+			SET_WORD(cfg[MAC_AX_DMA_ACH1].max, B_AX_ACH1_MAX_PG) |
+			(cfg[MAC_AX_DMA_ACH1].grp ? B_AX_ACH1_GRP : 0);
+		MAC_REG_W32(R_AX_ACH1_PAGE_CTRL, val32);
+		break;
+
+	case MAC_AX_DMA_ACH2:
+		val32 = SET_WORD(cfg[MAC_AX_DMA_ACH2].min, B_AX_ACH2_MIN_PG) |
+			 SET_WORD(cfg[MAC_AX_DMA_ACH2].max, B_AX_ACH2_MAX_PG) |
+			(cfg[MAC_AX_DMA_ACH2].grp ? B_AX_ACH2_GRP : 0);
+		MAC_REG_W32(R_AX_ACH2_PAGE_CTRL, val32);
+		break;
+
+	case MAC_AX_DMA_ACH3:
+		val32 = SET_WORD(cfg[MAC_AX_DMA_ACH3].min, B_AX_ACH3_MIN_PG) |
+			SET_WORD(cfg[MAC_AX_DMA_ACH3].max, B_AX_ACH3_MAX_PG) |
+			(cfg[MAC_AX_DMA_ACH3].grp ? B_AX_ACH3_GRP : 0);
+		MAC_REG_W32(R_AX_ACH3_PAGE_CTRL, val32);
+		break;
+
+	case MAC_AX_DMA_B0MG:
+		val32 = SET_WORD(cfg[MAC_AX_DMA_B0MG].min, B_AX_CH8_MIN_PG) |
+			SET_WORD(cfg[MAC_AX_DMA_B0MG].max, B_AX_CH8_MAX_PG) |
+			(cfg[MAC_AX_DMA_B0MG].grp ? B_AX_CH8_GRP : 0);
+		MAC_REG_W32(R_AX_CH8_PAGE_CTRL, val32);
+		break;
+
+	case MAC_AX_DMA_B0HI:
+		val32 = SET_WORD(cfg[MAC_AX_DMA_B0HI].min, B_AX_CH9_MIN_PG) |
+			SET_WORD(cfg[MAC_AX_DMA_B0HI].max, B_AX_CH9_MAX_PG) |
+			(cfg[MAC_AX_DMA_B0HI].grp ? B_AX_CH9_GRP : 0);
+		MAC_REG_W32(R_AX_CH9_PAGE_CTRL, val32);
+		break;
+
+	case MAC_AX_DMA_H2C:
+		break;
+
+	default:
+		PLTFM_MSG_ERR("%s wrong input: %d\n", __func__, ch);
+		return MACTXCHDMA;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 get_fc_page_info_8852b(struct mac_ax_adapter *adapter, u8 ch)
+{
+	struct mac_ax_hfc_ch_info *info = adapter->hfc_param->ch_info;
+	struct mac_ax_hfc_ch_cfg *cfg = adapter->hfc_param->ch_cfg;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	switch (ch) {
+	case MAC_AX_DMA_ACH0:
+		val32 = MAC_REG_R32(R_AX_ACH0_PAGE_INFO);
+		info[MAC_AX_DMA_ACH0].aval =
+			GET_FIELD(val32, B_AX_ACH0_AVAL_PG);
+		info[MAC_AX_DMA_ACH0].used =
+			GET_FIELD(val32, B_AX_ACH0_USE_PG);
+		break;
+
+	case MAC_AX_DMA_ACH1:
+		val32 = MAC_REG_R32(R_AX_ACH1_PAGE_INFO);
+		info[MAC_AX_DMA_ACH1].aval =
+			GET_FIELD(val32, B_AX_ACH1_AVAL_PG);
+		info[MAC_AX_DMA_ACH1].used =
+			GET_FIELD(val32, B_AX_ACH1_USE_PG);
+		break;
+
+	case MAC_AX_DMA_ACH2:
+		val32 = MAC_REG_R32(R_AX_ACH2_PAGE_INFO);
+		info[MAC_AX_DMA_ACH2].aval =
+			GET_FIELD(val32, B_AX_ACH2_AVAL_PG);
+		info[MAC_AX_DMA_ACH2].used =
+			GET_FIELD(val32, B_AX_ACH2_USE_PG);
+		break;
+
+	case MAC_AX_DMA_ACH3:
+		val32 = MAC_REG_R32(R_AX_ACH3_PAGE_INFO);
+		info[MAC_AX_DMA_ACH3].aval =
+			GET_FIELD(val32, B_AX_ACH3_AVAL_PG);
+		info[MAC_AX_DMA_ACH3].used =
+			GET_FIELD(val32, B_AX_ACH3_USE_PG);
+		break;
+
+	case MAC_AX_DMA_B0MG:
+		val32 = MAC_REG_R32(R_AX_CH8_PAGE_INFO);
+		info[MAC_AX_DMA_B0MG].aval =
+			GET_FIELD(val32, B_AX_CH8_AVAL_PG);
+		info[MAC_AX_DMA_B0MG].used =
+			GET_FIELD(val32, B_AX_CH8_USE_PG);
+		break;
+
+	case MAC_AX_DMA_B0HI:
+		val32 = MAC_REG_R32(R_AX_CH9_PAGE_INFO);
+		info[MAC_AX_DMA_B0HI].aval =
+			GET_FIELD(val32, B_AX_CH9_AVAL_PG);
+		info[MAC_AX_DMA_B0HI].used =
+			GET_FIELD(val32, B_AX_CH9_USE_PG);
+		break;
+
+	case MAC_AX_DMA_H2C:
+		val32 = MAC_REG_R32(R_AX_CH12_PAGE_INFO);
+		info[MAC_AX_DMA_H2C].aval =
+			GET_FIELD(val32, B_AX_CH12_AVAL_PG);
+		info[MAC_AX_DMA_H2C].used =
+			cfg[MAC_AX_DMA_H2C].min - info[MAC_AX_DMA_H2C].aval;
+		break;
+
+	default:
+		PLTFM_MSG_ERR("%s wrong input: %d\n", __func__, ch);
+		return MACTXCHDMA;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 set_fc_pubpg_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_hfc_pub_cfg *cfg = adapter->hfc_param->pub_cfg;
+	u32 val32;
+
+	val32 = SET_WORD(cfg->group0, B_AX_PUBPG_G0) |
+		SET_WORD(cfg->group1, B_AX_PUBPG_G1);
+	MAC_REG_W32(R_AX_PUB_PAGE_CTRL1, val32);
+
+	val32 = SET_WORD(cfg->wp_thrd, B_AX_WP_THRD);
+	MAC_REG_W32(R_AX_WP_PAGE_CTRL2, val32);
+
+	return MACSUCCESS;
+}
+
+u32 get_fc_mix_info_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_hfc_param *param = adapter->hfc_param;
+	struct mac_ax_hfc_pub_cfg *pub_cfg = param->pub_cfg;
+	struct mac_ax_hfc_prec_cfg *prec_cfg = param->prec_cfg;
+	struct mac_ax_hfc_pub_info *info = param->pub_info;
+	u32 val32;
+
+	val32 = MAC_REG_R32(R_AX_PUB_PAGE_INFO1);
+	info->g0_used = GET_FIELD(val32, B_AX_G0_USE_PG);
+	info->g1_used = GET_FIELD(val32, B_AX_G1_USE_PG);
+
+	val32 = MAC_REG_R32(R_AX_PUB_PAGE_INFO3);
+	info->g0_aval = GET_FIELD(val32, B_AX_G0_AVAL_PG);
+	info->g1_aval = GET_FIELD(val32, B_AX_G1_AVAL_PG);
+	info->pub_aval =
+		GET_FIELD(MAC_REG_R32(R_AX_PUB_PAGE_INFO2), B_AX_PUB_AVAL_PG);
+	info->wp_aval =
+		GET_FIELD(MAC_REG_R32(R_AX_WP_PAGE_INFO1), B_AX_WP_AVAL_PG);
+
+	val32 = MAC_REG_R32(R_AX_HCI_FC_CTRL);
+	param->en = val32 & B_AX_HCI_FC_EN ? 1 : 0;
+	param->h2c_en = val32 & B_AX_HCI_FC_CH12_EN ? 1 : 0;
+	param->mode = GET_FIELD(val32, B_AX_HCI_FC_MODE);
+	prec_cfg->ch011_full_cond = GET_FIELD(val32, B_AX_HCI_FC_WD_FULL_COND);
+	prec_cfg->h2c_full_cond = GET_FIELD(val32, B_AX_HCI_FC_CH12_FULL_COND);
+	prec_cfg->wp_ch07_full_cond =
+		GET_FIELD(val32, B_AX_HCI_FC_WP_CH07_FULL_COND);
+	prec_cfg->wp_ch811_full_cond =
+		GET_FIELD(val32, B_AX_HCI_FC_WP_CH811_FULL_COND);
+
+	val32 = MAC_REG_R32(R_AX_CH_PAGE_CTRL);
+	prec_cfg->ch011_prec = GET_FIELD(val32, B_AX_PREC_PAGE_CH011);
+	prec_cfg->h2c_prec = GET_FIELD(val32, B_AX_PREC_PAGE_CH12);
+
+	val32 = MAC_REG_R32(R_AX_PUB_PAGE_CTRL2);
+	pub_cfg->pub_max = GET_FIELD(val32, B_AX_PUBPG_ALL);
+
+	val32 = MAC_REG_R32(R_AX_WP_PAGE_CTRL1);
+	prec_cfg->wp_ch07_prec = GET_FIELD(val32, B_AX_PREC_PAGE_WP_CH07);
+	prec_cfg->wp_ch811_prec = GET_FIELD(val32, B_AX_PREC_PAGE_WP_CH811);
+
+	val32 = MAC_REG_R32(R_AX_WP_PAGE_CTRL2);
+	pub_cfg->wp_thrd = GET_FIELD(val32, B_AX_WP_THRD);
+
+	val32 = MAC_REG_R32(R_AX_PUB_PAGE_CTRL1);
+	pub_cfg->group0 = GET_FIELD(val32, B_AX_PUBPG_G0);
+	pub_cfg->group1 = GET_FIELD(val32, B_AX_PUBPG_G1);
+
+	return MACSUCCESS;
+}
+
+u32 set_fc_h2c_8852b(struct mac_ax_adapter *adapter)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_hfc_param *param = adapter->hfc_param;
+	struct mac_ax_hfc_prec_cfg *prec_cfg = param->prec_cfg;
+
+	val32 = SET_WORD(prec_cfg->h2c_prec, B_AX_PREC_PAGE_CH12);
+
+	MAC_REG_W32(R_AX_CH_PAGE_CTRL, val32);
+
+	val32 = SET_CLR_WORD(MAC_REG_R32(R_AX_HCI_FC_CTRL),
+			     prec_cfg->h2c_full_cond,
+			     B_AX_HCI_FC_CH12_FULL_COND);
+	MAC_REG_W32((R_AX_HCI_FC_CTRL), val32);
+
+	return MACSUCCESS;
+}
+
+u32 set_fc_mix_cfg_8852b(struct mac_ax_adapter *adapter)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_hfc_param *param = adapter->hfc_param;
+	struct mac_ax_hfc_pub_cfg *pub_cfg = param->pub_cfg;
+	struct mac_ax_hfc_prec_cfg *prec_cfg = param->prec_cfg;
+
+	val32 = SET_WORD(prec_cfg->ch011_prec, B_AX_PREC_PAGE_CH011) |
+		SET_WORD(prec_cfg->h2c_prec, B_AX_PREC_PAGE_CH12);
+	MAC_REG_W32(R_AX_CH_PAGE_CTRL, val32);
+
+	val32 = SET_WORD(pub_cfg->pub_max, B_AX_PUBPG_ALL);
+	MAC_REG_W32(R_AX_PUB_PAGE_CTRL2, val32);
+
+	val32 = SET_WORD(prec_cfg->wp_ch07_prec, B_AX_PREC_PAGE_WP_CH07) |
+		SET_WORD(prec_cfg->wp_ch811_prec, B_AX_PREC_PAGE_WP_CH811);
+	MAC_REG_W32(R_AX_WP_PAGE_CTRL1, val32);
+
+	val32 = SET_CLR_WORD(MAC_REG_R32(R_AX_HCI_FC_CTRL),
+			     param->mode, B_AX_HCI_FC_MODE);
+	val32 = SET_CLR_WORD(val32, prec_cfg->ch011_full_cond,
+			     B_AX_HCI_FC_WD_FULL_COND);
+	val32 = SET_CLR_WORD(val32, prec_cfg->h2c_full_cond,
+			     B_AX_HCI_FC_CH12_FULL_COND);
+	val32 = SET_CLR_WORD(val32, prec_cfg->wp_ch07_full_cond,
+			     B_AX_HCI_FC_WP_CH07_FULL_COND);
+	val32 = SET_CLR_WORD(val32, prec_cfg->wp_ch811_full_cond,
+			     B_AX_HCI_FC_WP_CH811_FULL_COND);
+	MAC_REG_W32(R_AX_HCI_FC_CTRL, val32);
+
+	return MACSUCCESS;
+}
+
+u32 set_fc_func_en_8852b(struct mac_ax_adapter *adapter, u8 en, u8 h2c_en)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_hfc_param *param = adapter->hfc_param;
+
+	val32 = MAC_REG_R32(R_AX_HCI_FC_CTRL);
+	param->en = en ? 1 : 0;
+	param->h2c_en = h2c_en ? 1 : 0;
+	val32 = en ? (val32 | B_AX_HCI_FC_EN) : (val32 & ~B_AX_HCI_FC_EN);
+	val32 = h2c_en ? (val32 | B_AX_HCI_FC_CH12_EN) :
+			 (val32 & ~B_AX_HCI_FC_CH12_EN);
+	MAC_REG_W32(R_AX_HCI_FC_CTRL, val32);
+
+	return MACSUCCESS;
+}
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hci_fc_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hci_fc_8852b.h
new file mode 100644
index 000000000000..7f9d4197b765
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hci_fc_8852b.h
@@ -0,0 +1,122 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_HCI_FC_8852B_H_
+#define _MAC_AX_HCI_FC_8852B_H_
+
+#include "../../mac_def.h"
+#include "../mac_priv.h"
+
+#if MAC_AX_8852B_SUPPORT
+
+/**
+ * @brief set_fc_page_ctrl_reg_8852b
+ *
+ * @param *adapter
+ * @param ch
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_fc_page_ctrl_reg_8852b(struct mac_ax_adapter *adapter, u8 ch);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief get_fc_page_info_8852b
+ *
+ * @param *adapter
+ * @param ch
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_fc_page_info_8852b(struct mac_ax_adapter *adapter, u8 ch);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief set_fc_pubpg_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_fc_pubpg_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief get_fc_mix_info_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_fc_mix_info_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief set_fc_h2c_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_fc_h2c_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief set_fc_mix_cfg_8852b
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_fc_mix_cfg_8852b(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief set_fc_func_en_8852b
+ *
+ * @param *adapter
+ * @param en
+ * @param h2c_en
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_fc_func_en_8852b(struct mac_ax_adapter *adapter, u8 en, u8 h2c_en);
+/**
+ * @}
+ * @}
+ */
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hdr_conv_rx_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hdr_conv_rx_8852b.c
new file mode 100644
index 000000000000..3c216b7f796e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hdr_conv_rx_8852b.c
@@ -0,0 +1,29 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "hdr_conv_rx_8852b.h"
+
+#if MAC_AX_8852B_SUPPORT
+u32 mac_hdr_conv_rx_en_8852b(struct mac_ax_adapter *adapter,
+			     struct mac_ax_rx_hdr_conv_cfg *cfg)
+{
+	return MACNOTSUP;
+}
+
+u32 mac_hdr_conv_rx_en_driv_info_hdr_8852b(struct mac_ax_adapter *adapter,
+					   struct mac_ax_rx_driv_info_hdr_cfg *cfg)
+{
+	return MACNOTSUP;
+}
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hdr_conv_rx_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hdr_conv_rx_8852b.h
new file mode 100644
index 000000000000..142a6aa5f3c7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hdr_conv_rx_8852b.h
@@ -0,0 +1,43 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#ifndef _MAC_AX_HDR_CONV_RX_8852B_H_
+#define _MAC_AX_HDR_CONV_RX_8852B_H_
+
+#include "../../type.h"
+#include "../../mac_ax.h"
+#include "../../mac_def.h"
+
+/**
+ * @brief enable/disable RX MAC Header Conversion
+ *
+ * @param adapter pointer of mac ax adapter.
+ * @param cfg confihuration parameter.
+ * @return result of configuration.
+ * @retval u32
+ */
+u32 mac_hdr_conv_rx_en_8852b(struct mac_ax_adapter *adapter,
+			     struct mac_ax_rx_hdr_conv_cfg *cfg);
+/**
+ * @brief enable/disable driver info of RX MAC Header Conversion
+ *
+ * @param adapter pointer of mac ax adapter.
+ * @param cfg confihuration parameter.
+ * @return result of configuration.
+ * @retval u32
+ */
+u32 mac_hdr_conv_rx_en_driv_info_hdr_8852b(struct mac_ax_adapter *adapter,
+					   struct mac_ax_rx_driv_info_hdr_cfg *cfg);
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hwamsdu_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hwamsdu_8852b.c
new file mode 100644
index 000000000000..dbdd69201938
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hwamsdu_8852b.c
@@ -0,0 +1,68 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "hwamsdu_8852b.h"
+
+#if MAC_AX_8852B_SUPPORT
+
+u32 mac_enable_cut_hwamsdu_8852b(struct mac_ax_adapter *adapter,
+				 u8 enable,
+				 enum mac_ax_ex_shift aligned)
+{
+	//cut AMSDU
+	u32 val;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (chk_patch_cut_amsdu_rls_ple_issue(adapter) == (u32)PATCH_ENABLE)
+		return MACNOTSUP;
+
+	if (aligned > MAC_AX_BYTE_ALIGNED_8)
+		return MACNOITEM;
+
+	val = MAC_REG_R32(R_AX_CUT_AMSDU_CTRL);
+	if (!enable)
+		val &= ~B_AX_BIT_EN_CUT_AMSDU;
+	else
+		val |= B_AX_BIT_EN_CUT_AMSDU;
+	MAC_REG_W32(R_AX_CUT_AMSDU_CTRL, val);
+
+	val = MAC_REG_R32(R_AX_CUT_AMSDU_CTRL_2);
+	val = SET_CLR_WORD(val, aligned, B_AX_EXTRA_SHIFT);
+	MAC_REG_W32(R_AX_CUT_AMSDU_CTRL_2, val);
+
+	return MACSUCCESS;
+}
+
+u32 mac_cut_hwamsdu_chk_mpdu_len_en_8852b(struct mac_ax_adapter *adapter,
+					  u8 enable,
+					  u8 low_th,
+					  u16 high_th)
+{
+	u32 val;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val = MAC_REG_R32(R_AX_CUT_AMSDU_CTRL);
+	if (!enable)
+		val &= ~B_AX_BIT_CUT_AMSDU_CHKLEN_EN;
+	else
+		val |= B_AX_BIT_CUT_AMSDU_CHKLEN_EN;
+	val = SET_CLR_WORD(val, low_th, B_AX_BIT_CUT_AMSDU_CHKLEN_L_TH);
+	val = SET_CLR_WORD(val, high_th, B_AX_BIT_CUT_AMSDU_CHKLEN_H_TH);
+	MAC_REG_W32(R_AX_CUT_AMSDU_CTRL, val);
+
+	return MACSUCCESS;
+}
+
+#endif
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hwamsdu_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hwamsdu_8852b.h
new file mode 100644
index 000000000000..f6d70b7e1a8d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/hwamsdu_8852b.h
@@ -0,0 +1,52 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_HWAMSDU_8852B_H_
+#define _MAC_AX_HWAMSDU_8852B_H_
+
+#include "../hwamsdu.h"
+#include "../../type.h"
+#include "../../mac_ax.h"
+
+/**
+ * @brief mac_enable_cut_hwamsdu
+ *
+ * @param *adapter
+ * @param enable
+ * @param aligned
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_enable_cut_hwamsdu_8852b(struct mac_ax_adapter *adapter,
+				 u8 enable,
+				 enum mac_ax_ex_shift aligned);
+
+/**
+ * @brief mac_cut_hwamsdu_chk_mpdu_len_8852b
+ *
+ * @param *adapter
+ * @param enable
+ * @param low_th
+ * @param high_th
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cut_hwamsdu_chk_mpdu_len_en_8852b(struct mac_ax_adapter *adapter,
+					  u8 enable,
+					  u8 low_th,
+					  u16 high_th);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/init_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/init_8852b.c
new file mode 100644
index 000000000000..6e855d689907
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/init_8852b.c
@@ -0,0 +1,929 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "init_8852b.h"
+#include "../pwr.h"
+#include "../efuse.h"
+#include "../init.h"
+#include "../trxcfg.h"
+#include "pwr_seq_8852b.h"
+#include "pwr_seq_func_8852b.h"
+#include "../hw.h"
+#include "../security_cam.h"
+#include "../trx_desc.h"
+#include "../../feature_cfg.h"
+#include "../fwcmd.h"
+#include "../fwdl.h"
+#include "../fwofld.h"
+#include "../role.h"
+#include "../tblupd.h"
+#include "../rx_forwarding.h"
+#include "../rx_filter.h"
+#include "../phy_rpt.h"
+#include "../hwamsdu.h"
+#include "../status.h"
+#include "../hdr_conv.h"
+#include "../hw_seq.h"
+#include "gpio_8852b.h"
+#include "../gpio.h"
+#include "../cpuio.h"
+#include "../sounding.h"
+#include "../power_saving.h"
+#include "../wowlan.h"
+#include "../tcpip_checksum_offload.h"
+#include "../la_mode.h"
+#include "../dle.h"
+#include "../coex.h"
+#include "../mcc.h"
+#include "../twt.h"
+#include "../mport.h"
+#include "../p2p.h"
+#include "../flash.h"
+#include "../dbg_cmd.h"
+#include "../phy_misc.h"
+#include "../h2c_agg.h"
+#include "mac_priv_8852b.h"
+#include "../dbcc.h"
+#include "../beacon.h"
+#include "coex_8852b.h"
+#include "phy_rpt_8852b.h"
+#include "hwamsdu_8852b.h"
+#include "hdr_conv_rx_8852b.h"
+#include "dle_8852b.h"
+#include "../secure_boot.h"
+#include "../nan.h"
+
+#if MAC_AX_SDIO_SUPPORT
+#include "../_sdio.h"
+#include "_sdio_8852b.h"
+#endif
+#if MAC_AX_USB_SUPPORT
+#include "_usb_8852b.h"
+#endif
+#if MAC_AX_PCIE_SUPPORT
+#include "../_pcie.h"
+#include "_pcie_8852b.h"
+#endif
+#if MAC_AX_FEATURE_DBGPKG
+#include "../dbgpkg.h"
+#include "../dbgport_hw.h"
+#endif
+#if MAC_AX_8852B_SUPPORT
+
+#if MAC_AX_SDIO_SUPPORT
+static struct mac_ax_intf_ops mac8852b_sdio_ops = {
+	reg_read8_sdio, /* reg_read8 */
+	reg_write8_sdio, /* reg_write8 */
+	reg_read16_sdio, /* reg_read16 */
+	reg_write16_sdio, /* reg_write16 */
+	reg_read32_sdio, /* reg_read32 */
+	reg_write32_sdio, /* reg_write32 */
+	tx_allow_sdio, /* tx_allow_sdio */
+	tx_cmd_addr_sdio, /* tx_cmd_addr_sdio */
+	sdio_pre_init_8852b, /* intf_pre_init */
+	sdio_init, /* intf_init */
+	sdio_deinit, /* intf_init */
+	reg_read_n_sdio, /* reg_read_n_sdio */
+	NULL, /*get_bulkout_id*/
+	ltr_set_sdio, /* ltr_set_pcie */
+	NULL, /*u2u3_switch*/
+	NULL, /*get_usb_mode*/
+	NULL, /*get_usb_support_ability*/
+	NULL, /*usb_tx_agg_cfg*/
+	NULL, /*usb_rx_agg_cfg*/
+	set_sdio_wowlan, /*set_wowlan*/
+	ctrl_txdma_ch_sdio, /*ctrl_txdma_ch*/
+	clr_idx_all_sdio, /*clr_idx_all*/
+	poll_txdma_ch_idle_sdio, /*poll_txdma_ch_idle*/
+	poll_rxdma_ch_idle_sdio, /*poll_rxdma_ch_idle*/
+	set_pcie_speed_sdio, /*set_pcie_speed*/
+	get_pcie_speed_sdio, /*get_pcie_speed*/
+	ctrl_txhci_sdio, /*ctrl_txhci*/
+	ctrl_rxhci_sdio, /*ctrl_rxhci*/
+	ctrl_dma_io_sdio, /*ctrl_dma_io*/
+	get_io_stat_sdio, /* get_io_stat */
+	sdio_get_txagg_num, /*get_txagg_num*/
+	get_avail_txbd_sdio, /*get_avail_txbd*/
+	get_avail_rxbd_sdio, /*get_avail_rxbd*/
+	trigger_txdma_sdio, /*trigger_txdma*/
+	notify_rxdone_sdio, /*notify_rxdone*/
+	sdio_get_rx_state, /*get_usb_rx_state*/
+	dbcc_hci_ctrl_sdio, /* dbcc_hci_ctrl */
+	sdio_autok_counter_avg, /* pcie_autok_counter_avg */
+	sdio_tp_adjust, /* tp_adjust */
+};
+#endif
+
+#if MAC_AX_USB_SUPPORT
+static struct mac_ax_intf_ops mac8852b_usb_ops = {
+	reg_read8_usb_8852b, /* reg_read8 */
+	reg_write8_usb_8852b, /* reg_write8 */
+	reg_read16_usb_8852b, /* reg_read16 */
+	reg_write16_usb_8852b, /* reg_write16 */
+	reg_read32_usb_8852b, /* reg_read32 */
+	reg_write32_usb_8852b, /* reg_write32 */
+	NULL, /* tx_allow_sdio */
+	NULL, /* tx_cmd_addr_sdio */
+	usb_pre_init_8852b, /* intf_pre_init */
+	usb_init_8852b, /* intf_init */
+	usb_deinit_8852b, /* intf_init */
+	NULL, /* reg_read_n_sdio */
+	get_bulkout_id_8852b, /*get_bulkout_id*/
+	ltr_set_usb, /* ltr_set_pcie */
+	u2u3_switch_8852b, /*u2u3_switch*/
+	get_usb_mode, /*get_usb_mode*/
+	get_usb_support_ability_8852b,/*get_usb_support_ability*/
+	usb_tx_agg_cfg_8852b, /*usb_tx_agg_cfg*/
+	usb_rx_agg_cfg_8852b, /*usb_rx_agg_cfg*/
+	set_usb_wowlan_8852b, /*set_wowlan*/
+	ctrl_txdma_ch_usb, /*ctrl_txdma_ch*/
+	clr_idx_all_usb, /*clr_idx_all*/
+	poll_txdma_ch_idle_usb, /*poll_txdma_ch_idle*/
+	poll_rxdma_ch_idle_usb, /*poll_rxdma_ch_idle*/
+	set_pcie_speed_usb, /*set_pcie_speed*/
+	get_pcie_speed_usb, /*get_pcie_speed*/
+	ctrl_txhci_usb, /*ctrl_txhci*/
+	ctrl_rxhci_usb, /*ctrl_rxhci*/
+	ctrl_dma_io_usb, /*ctrl_dma_io*/
+	get_io_stat_usb, /* get_io_stat */
+	usb_get_txagg_num_8852b, /*get_txagg_num*/
+	get_avail_txbd_usb, /*get_avail_txbd*/
+	get_avail_rxbd_usb, /*get_avail_rxbd*/
+	trigger_txdma_usb, /*trigger_txdma*/
+	notify_rxdone_usb, /*notify_rxdone*/
+	usb_get_rx_state_8852b, /*get_usb_rx_state*/
+	dbcc_hci_ctrl_usb, /* dbcc_hci_ctrl */
+	usb_autok_counter_avg, /* pcie_autok_counter_avg */
+	usb_tp_adjust, /* tp_adjust */
+};
+#endif
+
+#if MAC_AX_PCIE_SUPPORT
+static struct mac_ax_intf_ops mac8852b_pcie_ops = {
+	reg_read8_pcie, /* reg_read8 */
+	reg_write8_pcie, /* reg_write8 */
+	reg_read16_pcie, /* reg_read16 */
+	reg_write16_pcie, /* reg_write16 */
+	reg_read32_pcie, /* reg_read32 */
+	reg_write32_pcie, /* reg_write32 */
+	NULL, /* tx_allow_sdio */
+	NULL, /* tx_cmd_addr_sdio */
+	pcie_pre_init, /* intf_pre_init */
+	pcie_init, /* intf_init */
+	pcie_deinit, /* intf_deinit */
+	NULL, /* reg_read_n_sdio */
+	NULL, /*get_bulkout_id*/
+	ltr_set_pcie, /* ltr_set_pcie */
+	NULL, /*u2u3_switch*/
+	NULL, /*get_usb_mode*/
+	NULL,/*get_usb_support_ability*/
+	NULL, /*usb_tx_agg_cfg*/
+	NULL, /*usb_rx_agg_cfg*/
+	set_pcie_wowlan, /*set_wowlan*/
+	ctrl_txdma_ch_pcie_8852b, /*ctrl_txdma_ch*/
+	clr_idx_all_pcie, /*clr_idx_all*/
+	poll_txdma_ch_idle_pcie_8852b, /*poll_txdma_ch_idle*/
+	poll_rxdma_ch_idle_pcie_8852b, /*poll_rxdma_ch_idle*/
+	set_pcie_speed_8852b, /*set_pcie_speed*/
+	get_pcie_speed_8852b, /*get_pcie_speed*/
+	ctrl_txhci_pcie, /*ctrl_txhci*/
+	ctrl_rxhci_pcie, /*ctrl_rxhci*/
+	ctrl_dma_io_pcie, /*ctrl_dma_io*/
+	get_io_stat_pcie_8852b, /* get_io_stat */
+	pcie_get_txagg_num, /*get_txagg_num*/
+	get_avail_txbd_8852b, /*get_avail_txbd*/
+	get_avail_rxbd_8852b, /*get_avail_rxbd*/
+	trigger_txdma_pcie, /*trigger_txdma*/
+	notify_rxdone_pcie, /*notify_rxdone*/
+	NULL, /*get_usb_rx_state*/
+	dbcc_hci_ctrl_pcie, /* dbcc_hci_ctrl */
+	pcie_autok_counter_avg, /* pcie_autok_counter_avg */
+	pcie_tp_adjust, /* tp_adjust */
+};
+#endif
+
+static struct mac_ax_ops mac8852b_ops = {
+	NULL, /* intf_ops */
+	/*System level*/
+	mac_hal_init, /* hal_init */
+	mac_hal_fast_init, /* hal_fast_init */
+	mac_hal_deinit, /* hal_deinit */
+	mac_hal_fast_deinit, /*hal_fast_deinit*/
+	mac_add_role, /* add_role */
+	mac_remove_role, /* remove_role */
+	mac_change_role, /* change_role */
+	mac_pwr_switch, /* pwr_switch */
+	mac_sys_init, /* sys_init */
+	mac_trx_init, /* init */
+	mac_feat_init, /*feature init */
+	mac_romdl, /* romdl */
+	mac_enable_cpu, /* enable_cpu */
+	mac_disable_cpu, /* disable_cpu */
+	mac_fwredl, /* fwredl */
+	mac_fwdl, /* fwdl */
+	mac_query_fw_buff, /* query_fw_buff */
+	mac_enable_fw, /* enable_fw */
+	mac_get_dynamic_hdr_ax, /* get_dynamic_hdr */
+	mac_lv1_rcvy, /* lv1_rcvy */
+	mac_get_macaddr,
+	mac_build_txdesc_8852b, /* build_txdesc */
+	mac_refill_txdesc_8852b, /*refill txdesc*/
+	mac_parse_rxdesc_8852b, /* parse_rxdesc */
+	mac_watchdog, /* watchdog */
+	/*FW offload related*/
+	mac_reset_fwofld_state,
+	mac_check_fwofld_done,
+	mac_read_pkt_ofld,
+	mac_del_pkt_ofld,
+	mac_add_pkt_ofld,
+	mac_pkt_ofld_packet,
+	mac_dump_efuse_ofld,
+	mac_efuse_ofld_map,
+	mac_upd_dctl_info, /*update dmac ctrl info*/
+	mac_upd_cctl_info, /*update cmac ctrl info*/
+	mac_ie_cam_upd, /* ie_cam_upd */
+	mac_twt_info_upd_h2c, /* twt info update h2c */
+	mac_twt_act_h2c, /* twt act h2c */
+	mac_twt_staanno_h2c, /* twt anno h2c */
+	mac_twt_wait_anno,
+	mac_host_getpkt_h2c,
+	mac_p2p_act_h2c, /* p2p_act_h2c */
+	mac_p2p_macid_ctrl_h2c, /* p2p_macid_ctrl_h2c */
+	mac_get_p2p_stat, /* get_p2p_stat */
+	mac_tsf32_togl_h2c, /* tsf32_togl_h2c */
+	mac_get_t32_togl_rpt, /* get_t32_togl_rpt */
+	mac_ccxrpt_parsing,
+	mac_host_efuse_rec,
+	mac_cfg_sensing_csi,
+	mac_chk_sensing_csi_done,
+	mac_calc_crc, /* calc_crc */
+	mac_bcn_ofld_ctrl, /* bcn_ofld_ctrl */
+	/*Association, de-association related*/
+	mac_sta_add_key, /* add station key */
+	mac_sta_del_key, /* del station key */
+	mac_sta_search_key_idx, /* search station key index */
+	mac_sta_hw_security_support, /* control hw security support */
+	mac_set_mu_table, /*set mu score table*/
+	mac_ss_dl_grp_upd, /* update SS dl group info*/
+	mac_ss_ul_grp_upd, /* update SS ul group info*/
+	mac_ss_ul_sta_upd, /* add sta into SS ul link*/
+	mac_bacam_avl_std_entry_idx, /*search available std entry idx in BA CAM*/
+	mac_bacam_info, /*update BA CAM info*/
+	/*TRX related*/
+	mac_txdesc_len_8852b, /* txdesc_len */
+	mac_upd_shcut_mhdr,/*update short cut mac header*/
+	mac_enable_hwamsdu, /* enable_hwmasdu */
+	mac_hwamsdu_fwd_search_en,
+	mac_hwamsdu_macid_en,
+	mac_hwamsdu_get_macid_en,
+	mac_hwamsdu_max_len,
+	mac_hwamsdu_get_max_len,
+	mac_enable_cut_hwamsdu_8852b, /* enable_cut_hwamsdu */
+	mac_cut_hwamsdu_chk_mpdu_len_en_8852b, /* enable cut-amsdu chk mpdu size*/
+	mac_hdr_conv_en, /* enable mac hdr conv */
+	mac_hdr_conv_tx_set_eth_type, /* set eth type */
+	mac_hdr_conv_tx_get_eth_type, /* get eth type */
+	mac_hdr_conv_tx_set_oui, /* get oui */
+	mac_hdr_conv_tx_get_oui, /* get oui */
+	mac_hdr_conv_tx_macid_en, /* enable mac hdr conv for specifical macid */
+	mac_hdr_conv_tx_vlan_tag_valid_en, /* enable vlantag valid */
+	mac_hdr_conv_tx_get_vlan_tag_valid, /* get vlantag valid*/
+	mac_hdr_conv_tx_qos_field_en, /* enable qos control field translation */
+	mac_hdr_conv_tx_get_qos_field_en, /* get qos control field translation */
+	mac_hdr_conv_tx_get_qos_field_h, /* setup qos control field bit 8-15*/
+	mac_hdr_conv_tx_target_wlan_hdr_len, /* setup target header length */
+	mac_hdr_conv_tx_get_target_wlan_hdr_len, /* get target header length */
+	mac_hdr_conv_rx_en_8852b, /* enable rx mac hdr conversion*/
+	mac_hdr_conv_rx_en_driv_info_hdr_8852b, /*en rx hdr conv driver info*/
+	mac_set_hwseq_reg, /* set hw seq by reg */
+	mac_set_hwseq_dctrl, /*for set hw seq content*/
+	mac_get_hwseq_cfg, /*for get hw seq content*/
+	mac_process_c2h, /* process_c2h */
+	mac_parse_dfs, /* parse_dfs */
+	mac_parse_ppdu, /* parse_ppdu */
+	mac_cfg_phy_rpt, /* cfg_phy_rpt */
+	mac_set_rx_forwarding, /*rx_forwarding */
+	mac_get_rx_fltr_opt, /* set rx fltr mac, pclp header opt */
+	mac_set_rx_fltr_opt, /* get rx fltr mac, pclp header opt */
+	mac_set_typ_fltr_opt, /* set machdr type fltr opt */
+	mac_set_typsbtyp_fltr_opt, /* set machdr typ subtyp fltr opt */
+	mac_set_typsbtyp_fltr_detail, /* set detail type subtype filter config*/
+	mac_get_cfg_addr_cam, /* get addrcam setting */
+	mac_get_cfg_addr_cam_dis, /* get addrcam disable default setting */
+	mac_cfg_addr_cam, /* config addrcam setting */
+	mac_cfg_addr_cam_dis, /* config addrcam disable default setting */
+	mac_sr_update, /* set sr parameter */
+	mac_two_nav_cfg,  /* config 2NAV hw setting */
+	mac_wde_pkt_drop, /* pkt_drop */
+	mac_send_bcn_h2c, /* send beacon h2c */
+	mac_tx_mode_sel, /*tx mode sel*/
+	mac_tcpip_chksum_ofd, /* tcpip_chksum_ofd */
+	mac_chk_rx_tcpip_chksum_ofd, /* chk_rx_tcpip_chksum_ofd */
+	mac_chk_allq_empty, /*chk_allq_empty*/
+	mac_is_txq_empty_8852b, /*is_txq_empty*/
+	mac_is_rxq_empty_8852b, /*is_rxq_empty*/
+	mac_parse_bcn_stats_c2h, /*parse tx bcn statistics*/
+	mac_tx_idle_poll, /*tx_idle_poll*/
+	mac_sifs_chk_cca_en, /* check cca in sifs enable/disable */
+	mac_patch_rx_rate_8852b, /*for patch rx rate*/
+	mac_get_wp_offset_8852b, /* wd offload for wp_offset, called while forming metadata */
+	/*frame exchange related*/
+	mac_upd_mudecision_para, /* upd_ba_infotbl */
+	mac_mu_sta_upd, /* upd_mu_sta */
+	mac_upd_ul_fixinfo, /* upd_ul_fixinfo */
+	mac_f2p_test_cmd, /*f2p test cmd para*/
+	NULL,
+	mac_snd_test_cmd, /* f2p test cmd para */
+	mac_set_fixmode_mib, /* set_fw_testmode */
+	mac_dumpwlanc,
+	mac_dumpwlans,
+	mac_dumpwland,
+	mac_ss_dl_rpt_cfg,
+	mac_set_bcn_ignore_edcca, /*set bcn ignore edcca*/
+	/*outsrcing related */
+	mac_outsrc_h2c_common, /* outsrc common h2c */
+	mac_read_pwr_reg, /* for read tx power reg*/
+	mac_write_pwr_reg, /* for write tx power reg*/
+	mac_write_msk_pwr_reg, /* for write tx power reg*/
+	mac_write_pwr_ofst_mode, /* for write tx power mode offset reg*/
+	mac_write_pwr_ofst_bw, /* for write tx power BW offset reg*/
+	mac_write_pwr_ref_reg, /* for write tx power ref reg*/
+	mac_write_pwr_limit_en, /* for write tx power limit enable reg*/
+	mac_write_pwr_limit_rua_reg, /* for write tx power limit rua reg*/
+	mac_write_pwr_limit_reg, /* for write tx power limit reg*/
+	mac_write_pwr_by_rate_reg, /* for write tx power by rate reg*/
+	mac_lamode_cfg, /*cfg la mode para*/
+	mac_lamode_trigger, /*trigger la mode start*/
+	mac_lamode_buf_cfg, /*la mode buf size cfg */
+	mac_get_lamode_st, /*get la mode status*/
+	mac_read_xcap_reg_dav, /*read xcap xo/xi reg*/
+	mac_write_xcap_reg_dav, /*write xcap xo/xi reg*/
+	mac_write_bbrst_reg, /*write bb rst reg*/
+	mac_tx_path_map_cfg, /*for BB control TX PATH*/
+	/*sounding related*/
+	mac_get_csi_buffer_index, /* get CSI buffer index */
+	mac_set_csi_buffer_index, /* set CSI buffer index */
+	mac_get_snd_sts_index, /* get MACID SND status */
+	mac_set_snd_sts_index, /* set SND status MACID */
+	mac_init_snd_mer,/* init SND MER */
+	mac_init_snd_mee,/* init SND MEE */
+	mac_csi_force_rate, /*CSI fix rate reg*/
+	mac_csi_rrsc, /*CSI RRSC*/
+	mac_set_snd_para, /*set sound parameter*/
+	mac_set_csi_para_reg, /*set reg csi para*/
+	mac_set_csi_para_cctl, /*set csi para in cmac ctrl info*/
+	mac_hw_snd_pause_release, /*HW SND pause release*/
+	mac_bypass_snd_sts, /*bypass SND status*/
+	mac_deinit_mee, /*deinit mee*/
+	mac_snd_sup, /*bf entry num and SU MU buffer num*/
+	mac_gidpos, /*VHT MU GID position setting*/
+	/*ps related*/
+	mac_cfg_lps, /*config LPS*/
+	mac_ps_pwr_state, /*set or check lps power state*/
+	mac_chk_leave_lps, /*check already leave protocol ps*/
+	mac_cfg_ips, /*config IPS*/
+	mac_chk_leave_ips, /*check already leave IPS protocol*/
+	mac_ps_notify_wake, /*send RPWM to wake up HW/FW*/
+	mac_cfg_ps_advance_parm, /*config advance parameter for power saving*/
+	mac_periodic_wake_cfg, /*config ips periodic wake*/
+	mac_req_pwr_lvl_cfg, /*config request power level*/
+	mac_lps_option_cfg, /*config request lps option*/
+	mac_tbtt_tuning_cfg, /*config tbtt tuning*/
+	/* Wowlan related*/
+	mac_cfg_wow_wake, /*config wowlan wake*/
+	mac_cfg_disconnect_det, /*config disconnect det*/
+	mac_cfg_keep_alive, /*config keep alive*/
+	mac_cfg_gtk_ofld, /*config gtk ofld*/
+	mac_cfg_arp_ofld, /*config arp ofld*/
+	mac_cfg_ndp_ofld, /*config ndp ofld*/
+	mac_cfg_realwow, /*config realwow*/
+	mac_cfg_nlo, /*config nlo*/
+	mac_cfg_dev2hst_gpio, /*config dev2hst gpio*/
+	mac_cfg_hst2dev_ctrl, /*config hst2dev ctrl*/
+	mac_cfg_wowcam_upd, /*config wowcam update*/
+	mac_get_wow_wake_rsn, /* Get wowlan wakeup reason with reset option */
+	mac_cfg_wow_sleep, /*config wowlan before sleep/after wake*/
+	mac_get_wow_fw_status, /*get wowlan fw status*/
+	mac_request_aoac_report, /* request_aoac_report */
+	mac_read_aoac_report, /* read_aoac_report */
+	mac_check_aoac_report_done, /* check_aoac_report_done */
+	mac_wow_stop_trx, /* wow_stop_trx */
+	mac_cfg_wow_auto_test, /* cfg_wow_auto_test */
+	mac_magic_waker_filter, /*magic_waker_filter*/
+	mac_tcp_keepalive, /*tcp_keepalive*/
+	/*system related*/
+	mac_dbcc_enable, /*enable / disable dbcc */
+	mac_dbcc_pre_cfg, /* dbcc_pre_cfg */
+	mac_dbcc_cfg, /* dbcc_cfg */
+	mac_dbcc_trx_ctrl, /* dbcc_trx_ctrl */
+	mac_port_cfg, /* cofig port para */
+	mac_port_init, /* init port para */
+	mac_enable_imr, /* enable CMAC/DMAC IMR */
+	mac_dump_efuse_map_wl_plus, /* dump_wl_efuse*/
+	mac_dump_efuse_map_bt, /* dump_bt_efuse */
+	mac_write_efuse_plus, /* write_wl_bt_efuse */
+	mac_read_efuse_plus, /* read_wl_bt_efuse */
+	mac_read_hidden_efuse, /* read_hidden_efuse */
+	mac_get_efuse_avl_size, /* get_available_efuse_size */
+	mac_get_efuse_avl_size_bt, /* get_available_efuse_size_bt */
+	mac_dump_log_efuse_plus, /* dump_logical_efuse */
+	mac_read_log_efuse_plus, /* read_logical_efuse */
+	mac_write_log_efuse_plus, /* write_logical_efuse */
+	mac_dump_log_efuse_bt, /* dump_logical_efuse_bt */
+	mac_read_log_efuse_bt, /* read_logical_efuse_bt */
+	mac_write_log_efuse_bt, /* write_logical_efuse_bt */
+	mac_pg_efuse_by_map_plus, /* program_efuse_map */
+	mac_pg_efuse_by_map_bt, /* program_efuse_map_bt */
+	mac_mask_log_efuse, /* mask_logical_efuse_map */
+	mac_pg_sec_data_by_map, /* program_secure_data_map */
+	mac_cmp_sec_data_by_map, /* compare_secure_data_map */
+	mac_get_efuse_info, /* get_efuse_info */
+	mac_set_efuse_info, /* set_efuse_info */
+	mac_read_hidden_rpt, /* read_efuse_hidden_report */
+	mac_check_efuse_autoload, /* check_efuse_autoload */
+	mac_pg_simulator_plus, /* efuse pg simulator */
+	mac_checksum_update, /* checksum update */
+	mac_checksum_rpt, /*report checksum comparison result*/
+	mac_disable_rf_ofld_by_info, /* Disable RF Offload */
+	mac_set_efuse_ctrl, /*set efuse ctrl 0x30 or 0xC30*/
+	mac_otp_test, /*efuse OTP test R/W to 0x7ff*/
+	mac_get_ft_status, /* get_mac_ft_status */
+	mac_fw_log_cfg, /* fw_log_cfg */
+	mac_pinmux_set_func_8852b, /* pinmux_set_func */
+	mac_pinmux_free_func, /* pinmux_free_func */
+	mac_sel_uart_tx_pin, /* sel_uart_tx_pin */
+	mac_sel_uart_rx_pin, /* sel_uart_rx_pin */
+	mac_gpio_init_8852b, /* gpio_init */
+	mac_set_gpio_func_8852b, /* set_gpio_func */
+	mac_get_gpio_val, /* get_gpio_val */
+	mac_get_uart_fw_dbg_gpio, /* get_uart_fw_dbg_gpio */
+	mac_get_hw_info, /* get_hw_info */
+	mac_set_hw_value, /* set_hw_value */
+	mac_get_hw_value, /* get_hw_value */
+	mac_get_err_status, /* get_err_status */
+	mac_set_err_status, /* set_err_status */
+	mac_general_pkt_ids, /*general_pkt_ids */
+	mac_coex_init_8852b, /* coex_init */
+	mac_read_coex_reg_8852b, /* coex_read */
+	mac_write_coex_reg_8852b, /* coex_write */
+	mac_trigger_cmac_err, /*trigger_cmac_err*/
+	mac_trigger_cmac1_err, /*trigger_cmac1_err*/
+	mac_trigger_dmac_err, /*trigger_dmac_err*/
+	mac_tsf_sync, /*tsf_sync*/
+	mac_read_xtal_si, /*read_xtal_si*/
+	mac_write_xtal_si, /*write_xtal_si*/
+	mac_io_chk_access, /* io_chk_access */
+	mac_ser_ctrl, /* ser_ctrl */
+	mac_chk_err_status, /* chk_ser_status */
+	mac_set_l0_dbg_mode, /* Set SER L0 to debug mode */
+	mac_set_l1_dbg_mode, /* Set SER L1 to debug mode */
+	mac_get_freerun, /* mac_get_freerun */
+	/* mcc */
+	mac_reset_mcc_group,
+	mac_reset_mcc_request,
+	mac_add_mcc, /* add_mcc */
+	mac_start_mcc, /* start_mcc */
+	mac_stop_mcc, /* stop_mcc */
+	mac_del_mcc_group, /* del_mcc_group */
+	mac_mcc_request_tsf, /* mcc_request_tsf */
+	mac_mcc_macid_bitmap, /* mcc_macid_bitmap */
+	mac_mcc_sync_enable, /* mcc_sync_enable */
+	mac_mcc_set_duration, /* mcc_set_duration */
+	mac_get_mcc_tsf_rpt,
+	mac_get_mcc_status_rpt,
+	mac_get_mcc_group,
+	mac_check_add_mcc_done,
+	mac_check_start_mcc_done,
+	mac_check_stop_mcc_done,
+	mac_check_del_mcc_group_done,
+	mac_check_mcc_request_tsf_done,
+	mac_check_mcc_macid_bitmap_done,
+	mac_check_mcc_sync_enable_done,
+	mac_check_mcc_set_duration_done,
+	/* not mcc */
+	mac_check_access,
+	mac_set_led_mode, /* set_led_mode */
+	mac_led_ctrl, /* led_ctrl */
+	mac_set_sw_gpio_mode, /* set_sw_gpio_mode */
+	mac_sw_gpio_ctrl, /* sw_gpio_ctrl */
+	mac_get_c2h_event, /* get_c2h_event */
+	mac_cfg_wps, /* cfg_wps */
+	mac_get_wl_dis_val, /* get_wl_dis_val */
+	mac_cfg_per_pkt_phy_rpt_8852b, /* cfg_per_pkt_phy_rpt */
+#if MAC_AX_FEATURE_DBGPKG
+	mac_fwcmd_lb, /* fwcmd_lb */
+	mac_mem_dump, /* sram mem dump */
+	mac_get_mem_size, /* get mem size */
+	mac_dbg_status_dump, /* mac dbg status dump */
+	mac_reg_dump, /* debug reg dump for MAC/BB/RF*/
+	mac_rx_cnt,
+	mac_dump_fw_rsvd_ple,
+	mac_fw_dbg_dump,
+	mac_event_notify,
+	mac_dbgport_hw_set, /* Set debug port for LA */
+#endif
+#if MAC_AX_FEATURE_HV
+	mac_ram_boot, /* ram_boot */
+	/*fw offload related*/
+	mac_clear_write_request, /* clear_write_request */
+	mac_add_write_request, /* add_write_request */
+	mac_write_ofld, /* write_ofld */
+	mac_clear_conf_request, /* clear_conf_request */
+	mac_add_conf_request, /* add_conf_request */
+	mac_conf_ofld, /* conf_ofld */
+	mac_clear_read_request, /* clear_read_request */
+	mac_add_read_request, /* add_read_request */
+	mac_read_ofld, /* read_ofld */
+	mac_read_ofld_value, /* read_ofld_value */
+#endif
+	mac_add_cmd_ofld, /* add_cmd_ofld */
+	mac_add_cmd_ofld_v1, /* add_cmd_ofld_v1 */
+	mac_cmd_ofld, /* cmd_ofld */
+	mac_flash_erase,
+	mac_flash_read,
+	mac_flash_write,
+	mac_fw_status_cmd, /* fw_status_cmd */
+	mac_tx_duty, /* tx_duty */
+	mac_tx_duty_stop, /* tx_duty _stop */
+	mac_fwc2h_ofdma_sts_parse, /* parse c2h fw sts */
+	mac_fw_ofdma_sts_en, /* send fw sts en to fw */
+	mac_get_phy_rpt_cfg, /* get_phy_rpt_cfg */
+#if MAC_AX_FEATURE_DBGCMD
+	mac_halmac_cmd, /* halmac_cmd */
+	mac_halmac_cmd_parser, /* halmac_cmd_parser */
+#endif
+	mac_fast_ch_sw,
+	mac_fast_ch_sw_done,
+	mac_get_fast_ch_sw_rpt,
+	mac_h2c_agg_enable,
+	mac_h2c_agg_flush,
+	mac_h2c_agg_tx,
+	mac_fw_dbg_dle_cfg,
+	mac_add_scanofld_ch,
+	mac_scanofld,
+	mac_scanofld_fw_busy,
+	mac_scanofld_chlist_busy,
+	mac_scanofld_hst_ctrl,
+#if MAC_AX_FEATURE_DBGDEC
+	mac_fw_log_set_array,
+	mac_fw_log_unset_array,
+#endif
+	mac_get_fw_status,
+	mac_role_sync,
+	mac_ch_switch_ofld,
+	mac_get_ch_switch_rpt,
+	mac_cfg_bcn_filter,
+	mac_bcn_filter_rssi,
+	mac_bcn_filter_tp,
+	mac_cfg_bcn_early_rpt,
+	/*Proxy related*/
+	mac_proxyofld,
+	mac_proxy_mdns_serv_pktofld,
+	mac_proxy_mdns_txt_pktofld,
+	mac_proxy_mdns,
+	mac_proxy_ptcl_pattern,
+	mac_check_proxy_done,
+	/*fw cap related*/
+	mac_get_wlanfw_cap,
+	/* NAN related */
+	mac_nan_act_schedule_req,
+	mac_nan_bcn_req,
+	mac_nan_func_ctrl,
+	mac_nan_pause_faw_tx,
+	mac_nan_de_info,
+	mac_nan_join_cluster,
+	mac_get_act_schedule_id,
+	mac_nan_get_cluster_info,
+	mac_check_cluster_info,
+	/*sta csa*/
+	mac_cfg_sta_csa,
+	mac_check_sta_csa_cfg,
+	/* MP security related */
+	mac_chk_sec_rec, /* mp_chk_sec_rec*/
+	mac_pg_sec_phy_wifi, /* mp_pg_sec_phy_wifi */
+	mac_cmp_sec_phy_wifi, /* mp_cmp_sec_phy_wifi */
+	mac_pg_sec_hid_wifi, /* mp_pg_sec_hid_wifi */
+	mac_cmp_sec_hid_wifi, /* mp_cmp_sec_hid_wifi */
+	mac_pg_sec_dis, /* mp_pg_sec_dis */
+	mac_cmp_sec_dis, /* mp_cmp_sec_dis */
+	mac_sic_dis, /* mp_sic_dis */
+	mac_chk_sic_dis, /* mp_chk_sic_dis */
+	mac_jtag_dis, /* mp_jtag_dis */
+	mac_chk_jtag_dis, /* mp_chk_jtag_dis */
+	mac_uart_tx_dis, /* mp_uart_tx_dis */
+	mac_chk_uart_tx_dis, /* mp_chk_uart_tx_dis */
+	mac_uart_rx_dis, /* mp_chk_uart_rx_dis */
+	mac_chk_uart_rx_dis, /* mp_chk_uart_rx_dis */
+};
+
+static struct mac_ax_hw_info mac8852b_hw_info = {
+	0, /* done */
+	MAC_AX_CHIP_ID_8852B, /* chip_id */
+	0xFF, /* cv */
+	0, /* acv */
+	0xFF, /* fv */
+	MAC_AX_INTF_INVALID, /* intf */
+	19, /* tx_ch_num */
+	10, /* tx_data_ch_num */
+	WD_BODY_LEN, /* wd_body_len */
+	WD_INFO_LEN, /* wd_info_len */
+	pwr_on_seq_8852b, /* pwr_on_seq */
+	pwr_off_seq_8852b, /* pwr_off_seq */
+	PWR_SEQ_VER_8852B, /* pwr_seq_ver */
+	196608, /* fifo_size */
+	32, /* macid_num */
+	5, /* port_num */
+	4, /* mbssid_num */
+	20, /* bssid_num */
+	1536, /* wl_efuse_size */
+	1216, /* wl_zone2_efuse_size */
+	2048, /* log_efuse_size */
+	1280, /* limit_efuse_size_PCIE */
+	1280, /* limit_efuse_size_USB */
+	1280, /* limit_efuse_size_SDIO */
+	512, /* bt_efuse_size */
+	1024, /* bt_log_efuse_size */
+	96, /* hidden_efuse_rf_size */
+	32, /*hidden_efuse_mac_size*/
+	4, /* sec_ctrl_efuse_size */
+	192, /* sec_data_efuse_size */
+	NULL, /* sec_cam_table_t pointer */
+	NULL, /* dctl_sec_info_t pointer */
+	32, /* ple_rsvd_space */
+	24, /* payload_desc_size */
+	8, /* efuse_version_size */
+	128, /* wl_efuse_size_DAV */
+	96, /* wl_zone2_efuse_size_DAV  */
+	32, /* hidden_efuse_size_DAV  */
+	16, /* log_efuse_size_DAV  */
+	0, /* wl_efuse_start_addr */
+	0, /* wl_efuse_start_addr_DAV  */
+	0x600, /* bt_efuse_start_addr */
+	0, /* wd_checksum_en */
+	0, /* sw_amsdu_max_size */
+	0, /* ind_aces_cnt */
+	0, /* dbg_port_cnt */
+	0, /* core_swr_volt */
+	0, /* is_sec_ic */
+	0x3F, /* sta_empty_flg */
+	{{{0}, {0}, 0}}, /* cust_proc_id */
+	MAC_AX_SWR_NORM, /* core_swr_volt_sel */
+	MAC_AX_DRV_INFO_NONE, /* cmac0_drv_info */
+	MAC_AX_DRV_INFO_NONE, /* cmac1_drv_info */
+};
+
+struct mac_ax_ft_status mac_8852b_ft_status[] = {
+	{MAC_AX_FT_DUMP_EFUSE, MAC_AX_STATUS_IDLE, NULL, 0},
+	{MAC_AX_FT_MAX, MAC_AX_STATUS_ERR, NULL, 0},
+};
+
+static struct mac_ax_adapter mac_8852b_adapter =  {
+	&mac8852b_ops, /* ops */
+	NULL, /* drv_adapter */
+	NULL, /* phl_adapter */
+	NULL, /* pltfm_cb */
+	MAC_AX_DFLT_SM, /* sm */
+	NULL, /* hw_info */
+	{0}, /* fw_info */
+	{{0}}, /* ser_info */
+	{0}, /* efuse_param */
+	{0}, /* mac_pwr_info */
+	mac_8852b_ft_status, /* ft_stat */
+	NULL, /* hfc_param */
+	{MAC_AX_QTA_SCC, 64, 128, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0}, /* dle_info */
+	{0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0,
+	 0xFF, 0xFF, DFLT_GPIO_STATE}, /* gpio_info */
+	NULL, /* role table */
+	{NULL, NULL, NULL, 0, 0, 0, 0}, /* read_ofld_info */
+	{0, 0, NULL}, /* read_ofld_value */
+	{NULL, NULL, NULL, 0, 0, 0, 0}, /* write_ofld_info */
+	{NULL}, /* efuse_ofld_info */
+	{NULL, NULL, 0, 0, 0, 0}, /* conf_ofld_info */
+	{PKT_OFLD_OP_MAX, PKT_OFLD_MAX_COUNT, 0, {0}}, /* pkt_ofld_info */
+	{0, 0, 0, NULL}, /* pkt_ofld_pkt */
+	{NULL, NULL, NULL, 0, 0, 0, 0, 0}, /* cmd_ofld_info */
+	{{{0}, {0}, {0}, {0}}}, /* mcc_group_info */
+	{NULL}, /* wowlan_info */
+	NULL, /* p2p_info */
+	NULL, /* t32_togl_rpt */
+	NULL, /* port_info */
+	{0}, /* struct mac_ax_int_stats stats */
+	{0}, /*h2c_agg_info*/
+	{0, 0}, /* struct mac_ax_drv_stats drv_stats */
+	{0}, /* csi_info */
+	{{0}, 0, 0, 0, 0, 0, 0, 0, {0}}, /* nan_info */
+	DUT_ENV_ASIC, /* env */
+#if MAC_AX_SDIO_SUPPORT
+	{MAC_AX_SDIO_4BYTE_MODE_DISABLE, MAC_AX_SDIO_TX_MODE_AGG,
+	MAC_AX_SDIO_SPEC_VER_2_00, MAC_AX_SDIO_OPN_MODE_BLOCK,
+	512, 1, 8, 0}, /* sdio_info */
+#endif
+#if MAC_AX_USB_SUPPORT
+	{0}, /* usb_info */
+#endif
+#if MAC_AX_PCIE_SUPPORT
+	{0}, /* pcie_info */
+#endif
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, NULL}, /*flash_info */
+	{0, 0}, /* fast_ch_sw_info */
+#if MAC_AX_FEATURE_HV
+	NULL, /*hv_ax_ops*/
+#endif
+#if MAC_AX_FEATURE_DBGCMD
+	{NULL}, /*fw_dbgcmd*/
+#endif
+#if MAC_AX_FEATURE_DBGDEC
+	NULL, /*fw_log_array*/
+	NULL,
+	0,
+#endif
+	{{NULL, NULL}}, /*scanofld_info*/
+	{0}, /*log_cfg*/
+	NULL, /* twt_info */
+	{0}, /*ch_switch_rpt*/
+	NULL, /* dbcc_info */
+	{0}, /* bn_fltr_rpt */
+	{0}, /* bcn_ignore_edcca */
+};
+
+#ifdef CONFIG_NEW_HALMAC_INTERFACE
+struct mac_ax_adapter *get_mac_8852b_adapter(enum mac_ax_intf intf,
+					     u8 cv, void *phl_adapter,
+					     void *drv_adapter,
+					     struct mac_ax_pltfm_cb *pltfm_cb)
+{
+	struct mac_ax_adapter *adapter = NULL;
+	struct mac_ax_mac_pwr_info *pwr_info;
+
+	adapter =
+	(struct mac_ax_adapter *)hal_mem_alloc(drv_adapter,
+		sizeof(struct mac_ax_adapter));
+	if (!adapter)
+		return NULL;
+
+	hal_mem_cpy(drv_adapter, adapter, &mac_8852b_adapter,
+		    sizeof(struct mac_ax_adapter));
+	pwr_info = &adapter->mac_pwr_info;
+
+	adapter->phl_adapter = phl_adapter;
+	adapter->drv_adapter = drv_adapter;
+	adapter->pltfm_cb = pltfm_cb;
+	adapter->hw_info->cv = cv;
+	adapter->hw_info->intf = intf;
+	adapter->hw_info->done = 1;
+
+	switch (intf) {
+#if MAC_AX_SDIO_SUPPORT
+	case MAC_AX_INTF_SDIO:
+		adapter->ops->intf_ops = &mac8852b_sdio_ops;
+		pwr_info->intf_pwr_switch = sdio_pwr_switch;
+		break;
+#endif
+#if MAC_AX_USB_SUPPORT
+	case MAC_AX_INTF_USB:
+		adapter->ops->intf_ops = &mac8852b_usb_ops;
+		pwr_info->intf_pwr_switch = usb_pwr_switch;
+		break;
+#endif
+#if MAC_AX_PCIE_SUPPORT
+	case MAC_AX_INTF_PCIE:
+		adapter->ops->intf_ops = &mac8852b_pcie_ops;
+		pwr_info->intf_pwr_switch = pcie_pwr_switch;
+		break;
+#endif
+	default:
+		return NULL;
+	}
+
+	return adapter;
+}
+#else
+struct mac_ax_adapter *get_mac_8852b_adapter(enum mac_ax_intf intf,
+					     u8 cv, void *drv_adapter,
+					     struct mac_ax_pltfm_cb *pltfm_cb)
+{
+	struct mac_ax_adapter *adapter = NULL;
+	struct mac_ax_hw_info *hw_info = NULL;
+	struct mac_ax_priv_ops **p;
+	struct mac_ax_mac_pwr_info *pwr_info;
+	u32 priv_size;
+
+	if (!pltfm_cb)
+		return NULL;
+
+	priv_size = get_mac_ax_priv_size();
+	adapter = (struct mac_ax_adapter *)pltfm_cb->rtl_malloc(drv_adapter,
+		sizeof(struct mac_ax_adapter) + priv_size);
+	if (!adapter) {
+		pltfm_cb->msg_print(drv_adapter, _PHL_ERR_, "Malloc adapter fail\n");
+		return NULL;
+	}
+
+	pltfm_cb->rtl_memcpy(drv_adapter, adapter, &mac_8852b_adapter,
+		     sizeof(struct mac_ax_adapter));
+
+	/*Alloc HW INFO */
+	hw_info = (struct mac_ax_hw_info *)pltfm_cb->rtl_malloc(drv_adapter,
+		sizeof(struct mac_ax_hw_info));
+
+	if (!hw_info) {
+		pltfm_cb->msg_print(drv_adapter, _PHL_ERR_, "Malloc hw info fail\n");
+		return NULL;
+	}
+
+	pltfm_cb->rtl_memcpy(drv_adapter, hw_info,
+			     &mac8852b_hw_info,
+			     sizeof(struct mac_ax_hw_info));
+
+	pwr_info = &adapter->mac_pwr_info;
+
+	adapter->drv_adapter = drv_adapter;
+	adapter->pltfm_cb = pltfm_cb;
+	adapter->hw_info = hw_info;
+	adapter->hw_info->cv = cv;
+	adapter->hw_info->intf = intf;
+	adapter->hw_info->done = 1;
+
+	p = get_priv(adapter);
+	*p = get_mac_8852b_priv_ops(intf);
+
+	switch (intf) {
+#if MAC_AX_SDIO_SUPPORT
+	case MAC_AX_INTF_SDIO:
+		adapter->ops->intf_ops = &mac8852b_sdio_ops;
+		break;
+#endif
+#if MAC_AX_USB_SUPPORT
+	case MAC_AX_INTF_USB:
+		adapter->ops->intf_ops = &mac8852b_usb_ops;
+		break;
+#endif
+#if MAC_AX_PCIE_SUPPORT
+	case MAC_AX_INTF_PCIE:
+		adapter->ops->intf_ops = &mac8852b_pcie_ops;
+		break;
+#endif
+	default:
+		return NULL;
+	}
+
+	return adapter;
+}
+#endif
+
+u32 dmac_func_en_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret = 0;
+
+	val32 = (B_AX_MAC_FUNC_EN | B_AX_DMAC_FUNC_EN | B_AX_MAC_SEC_EN |
+	 B_AX_DISPATCHER_EN | B_AX_DLE_CPUIO_EN | B_AX_PKT_IN_EN |
+	 B_AX_DMAC_TBL_EN | B_AX_PKT_BUF_EN | B_AX_STA_SCH_EN |
+	 B_AX_TXPKT_CTRL_EN | B_AX_WD_RLS_EN | B_AX_MPDU_PROC_EN |
+	 B_AX_DMAC_CRPRT);
+	MAC_REG_W32(R_AX_DMAC_FUNC_EN, val32);
+
+	val32 = (B_AX_MAC_SEC_CLK_EN | B_AX_DISPATCHER_CLK_EN |
+		 B_AX_DLE_CPUIO_CLK_EN | B_AX_PKT_IN_CLK_EN |
+		 B_AX_STA_SCH_CLK_EN | B_AX_TXPKT_CTRL_CLK_EN |
+		 B_AX_WD_RLS_CLK_EN | B_AX_BBRPT_CLK_EN);
+	MAC_REG_W32(R_AX_DMAC_CLK_EN, val32);
+
+	adapter->sm.dmac_func = MAC_AX_FUNC_ON;
+
+	return ret;
+}
+
+u32 dmac_func_pre_en_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = (B_AX_MAC_FUNC_EN | B_AX_DMAC_FUNC_EN |
+		 B_AX_DISPATCHER_EN | B_AX_PKT_BUF_EN);
+	MAC_REG_W32(R_AX_DMAC_FUNC_EN, val32);
+
+	val32 = (B_AX_DISPATCHER_CLK_EN);
+	MAC_REG_W32(R_AX_DMAC_CLK_EN, val32);
+
+	adapter->sm.dmac_func = MAC_AX_FUNC_ON;
+
+	return MACSUCCESS;
+}
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/init_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/init_8852b.h
new file mode 100644
index 000000000000..1547bccf50a1
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/init_8852b.h
@@ -0,0 +1,39 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_INIT_8852B_H_
+#define _MAC_AX_INIT_8852B_H_
+
+#include "../../type.h"
+#if MAC_AX_8852B_SUPPORT
+
+#ifdef CONFIG_NEW_HALMAC_INTERFACE
+struct mac_ax_adapter *get_mac_8852b_adapter(enum mac_ax_intf intf,
+					     u8 cv, void *phl_adapter,
+					     void *drv_adapter,
+					     struct mac_ax_pltfm_cb *pltfm_cb)
+#else
+struct mac_ax_adapter *get_mac_8852b_adapter(enum mac_ax_intf intf,
+					     u8 cv, void *drv_adapter,
+					     struct mac_ax_pltfm_cb *pltfm_cb);
+#endif
+
+u32 dmac_func_en_8852b(struct mac_ax_adapter *adapter);
+
+u32 dmac_func_pre_en_8852b(struct mac_ax_adapter *adapter);
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/mac_priv_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/mac_priv_8852b.c
new file mode 100644
index 000000000000..20e568ea3d8f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/mac_priv_8852b.c
@@ -0,0 +1,189 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "../mac_priv.h"
+#include "init_8852b.h"
+#include "pwr_seq_func_8852b.h"
+#include "cmac_tx_8852b.h"
+#include "fwcmd_8852b.h"
+#include "rrsr_8852b.h"
+#include "coex_8852b.h"
+#include "phy_rpt_8852b.h"
+#include "tblupd_8852b.h"
+#include "../tblupd.h"
+#include "dbgpkg_8852b.h"
+#include "efuse_8852b.h"
+#include "hci_fc_8852b.h"
+#include "dle_8852b.h"
+#if MAC_AX_PCIE_SUPPORT
+#include "_pcie_8852b.h"
+#endif
+#if MAC_AX_USB_SUPPORT
+#include "_usb_8852b.h"
+#endif
+#if MAC_AX_SDIO_SUPPORT
+#include "_sdio_8852b.h"
+#endif
+
+#if MAC_AX_8852B_SUPPORT
+
+static struct mac_ax_priv_ops mac8852b_priv_ops = {
+	NULL, /* pwr_off */
+	NULL, /* pwr_on */
+	NULL, /* intf_pwr_switch */
+	dmac_func_en_8852b, /* dmac_func_en */
+	dmac_func_pre_en_8852b, /* dmac_func_pre_en */
+	mac_init_cctl_info_8852b, /* init cmac table */
+	cmac_init, /*cmac module init*/
+	cmac_func_en,/* cmac_func_en */
+	macid_idle_ck_8852b, /* macid_idle_ck */
+	stop_sch_tx_8852b, /* stop_sch_tx */
+	switch_efuse_bank_8852b, /* switch_efuse_bank */
+	enable_efuse_sw_pwr_cut_8852b, /* enable_efuse_sw_pwr_cut */
+	disable_efuse_sw_pwr_cut_8852b, /* disable_efuse_sw_pwr_cut */
+	get_h2creg_offset_8852b, /* get_h2creg_offset */
+	get_c2hreg_offset_8852b, /* get_c2hreg_offset */
+	ser_imr_config, /*ser_imr_config , 52b 52a using same api*/
+	disconnect_flush_key, /* disconnect_flush_key */
+	sec_info_tbl_init, /* sec_info_tbl_init */
+	free_sec_info_tbl, /* free_sec_info_tbl */
+	mac_wowlan_secinfo, /* mac_wowlan_secinfo */
+	mac_get_rrsr_cfg_8852b, /*get RRSR related config*/
+	mac_set_rrsr_cfg_8852b, /*set RRSR related config*/
+	mac_get_cts_rrsr_cfg_8852b, /*get CTS RRSR related config*/
+	mac_set_cts_rrsr_cfg_8852b, /*set CTS RRSR related config*/
+	mac_cfg_gnt_8852b, /* cfg_ctrl_path*/
+	mac_cfg_ctrl_path_8852b, /* cfg_ctrl_path */
+	mac_get_gnt_8852b, /* get_gnt */
+	mac_get_ctrl_path_8852b, /* get_ctrl_path */
+	get_bbrpt_dle_cfg_8852b, /*get_bbrpt_dle_cfg*/
+	dbg_port_sel_8852b, /*for mac debug port*/
+	tx_flow_ptcl_dbg_port_8852b, /*for mac tx flow ptcl dbg*/
+	tx_flow_sch_dbg_port_8852b, /*for mac tx schdueler ptcl dbg*/
+	ss_stat_chk_8852b, /*for mac station scheduler check*/
+	dmac_dbg_dump_8852b, /*for dmac debug dump*/
+	cmac_dbg_dump_8852b, /*for cmac debug dump*/
+	crit_dbg_dump_8852b, /*for system critical debug dump*/
+	tx_dbg_dump_8852b, /*for tx flow debug dump*/
+	coex_mac_init_8852b, /* coex_mac_init */
+	set_fc_page_ctrl_reg_8852b, /* set_fc_page_ctrl_reg */
+	get_fc_page_info_8852b, /* get_fc_page_info */
+	set_fc_pubpg_8852b, /* set_fc_pubpg */
+	get_fc_mix_info_8852b, /* get_fc_mix_info */
+	set_fc_h2c_8852b, /* set_fc_h2c */
+	set_fc_mix_cfg_8852b, /* set_fc_mix_cfg */
+	set_fc_func_en_8852b, /* set_fc_func_en */
+	dle_dfi_ctrl_8852b, /* dle_dfi_ctrl */
+	dle_is_txq_empty_8852b, /* dle_is_txq_empty */
+	dle_is_rxq_empty_8852b, /* dle_is_rxq_empty */
+	preload_cfg_set_8852b, /* preload_cfg_set */
+	preload_init_set_8852b, /* preload_init_set */
+	dle_func_en_8852b, /* dle_func_en */
+	dle_clk_en_8852b, /* dle_clk_en */
+	dle_mix_cfg_8852b, /* dle_mix_cfg */
+	wde_quota_cfg_8852b, /* wde_quota_cfg */
+	ple_quota_cfg_8852b, /* ple_quota_cfg */
+	chk_dle_rdy_8852b, /* chk_dle_rdy */
+	is_dbg_port_not_valid_8852b, /* is_dbg_port_not_valid */
+	dbg_port_sel_rst_8852b, /* dbg_port_sel_rst */
+	dle_dfi_sel_8852b, /* dle_dfi_sel */
+	mac_bacam_init, /* bacam init */
+#if MAC_AX_PCIE_SUPPORT
+	get_pcie_info_def_8852b, /* get_pcie_info_def */
+	get_bdram_tbl_pcie_8852b, /* get_bdram_tbl_pcie */
+	mio_w32_pcie_8852b, /* mio_w32_pcie */
+	mio_r32_pcie_8852b, /* mio_r32_pcie */
+	get_txbd_reg_pcie_8852b, /* get_txbd_reg_pcie */
+	set_txbd_reg_pcie_8852b, /* set_txbd_reg_pcie */
+	get_rxbd_reg_pcie_8852b, /* get_rxbd_reg_pcie */
+	set_rxbd_reg_pcie_8852b, /* set_rxbd_reg_pcie */
+	ltr_sw_trigger_8852b, /* ltr_sw_trigger */
+	pcie_cfgspc_write_8852b, /* pcie_cfgspc_write */
+	pcie_cfgspc_read_8852b, /* pcie_cfgspc_read */
+	pcie_ltr_write_8852b, /* pcie_ltr_write */
+	pcie_ltr_read_8852b, /* pcie_ltr_read */
+	ctrl_hci_dma_en_pcie_8852b, /* ctrl_hci_dma_en_pcie */
+	ctrl_trxdma_pcie_8852b, /* ctrl_trxdma_pcie */
+	ctrl_wpdma_pcie_8852b, /* ctrl_wpdma_pcie */
+	poll_io_idle_pcie_8852b, /* poll_io_idle_pcie */
+	poll_dma_all_idle_pcie_8852b, /* poll_dma_all_idle_pcie */
+	clr_idx_ch_pcie_8852b, /* clr_idx_ch_pcie */
+	rst_bdram_pcie_8852b, /* rst_bdram_pcie */
+	trx_mit_pcie_8852b, /* trx_mit_pcie */
+	mode_op_pcie_8852b, /* mode_op_pcie */
+	get_err_flag_pcie_8852b, /* get_err_flag_pcie */
+	mac_auto_refclk_cal_pcie_8852b, /* mac_auto_refclk_cal_pcie */
+#ifdef RTW_WKARD_GET_PROCESSOR_ID
+	chk_proc_long_ldy, /* chk_proc_long_ldy_pcie */
+#endif
+	sync_trx_bd_idx_pcie, /* sync_trx_bd_idx */
+#endif
+#if MAC_AX_SDIO_SUPPORT
+	r_indir_cmd52_sdio_8852b, /* r_indir_cmd52_sdio */
+	_r_indir_cmd52_sdio_8852b, /* _r_indir_cmd52_sdio */
+	_r_indir_cmd53_sdio_8852b, /* _r_indir_cmd53_sdio */
+	r16_indir_sdio_8852b, /* r16_indir_sdio */
+	r32_indir_sdio_8852b, /* r32_indir_sdio */
+	w_indir_cmd52_sdio_8852b, /* w_indir_cmd52_sdio */
+	w_indir_cmd53_sdio_8852b, /* w_indir_cmd53_sdio */
+	ud_fs_8852b, /* ud_fs */
+	sdio_pre_init_8852b, /* sdio_pre_init */
+	tx_mode_cfg_sdio_8852b, /* tx_mode_cfg_sdio */
+	leave_suspend_sdio_8852b, /* leave_suspend_sdio */
+	get_int_latency_sdio_8852b, /* get_int_latency_sdio */
+	get_clk_cnt_sdio_8852b, /* get_clk_cnt_sdio */
+	set_wt_cfg_sdio_8852b, /* set_wt_cfg_sdio */
+	set_clk_mon_sdio_8852b, /* set_clk_mon_sdio */
+	sdio_pwr_switch_8852b, /* sdio_pwr_switch */
+	rx_agg_cfg_sdio_8852b, /* rx_agg_cfg_sdio */
+	aval_page_cfg_sdio_8852b, /* aval_page_cfg_sdio */
+	get_sdio_rx_req_len_8852b, /* get_sdio_rx_req_len */
+#endif
+#if MAC_AX_USB_SUPPORT
+	usb_ep_cfg_8852b, /* USB endpoint pause release */
+#endif
+};
+
+struct mac_ax_priv_ops *get_mac_8852b_priv_ops(enum mac_ax_intf intf)
+{
+	switch (intf) {
+#if MAC_AX_SDIO_SUPPORT
+	case MAC_AX_INTF_SDIO:
+		mac8852b_priv_ops.pwr_on = mac_pwr_on_sdio_8852b;
+		mac8852b_priv_ops.pwr_off = mac_pwr_off_sdio_8852b;
+		mac8852b_priv_ops.intf_pwr_switch = sdio_pwr_switch_8852b;
+		break;
+#endif
+#if MAC_AX_USB_SUPPORT
+	case MAC_AX_INTF_USB:
+		mac8852b_priv_ops.pwr_on = mac_pwr_on_usb_8852b;
+		mac8852b_priv_ops.pwr_off = mac_pwr_off_usb_8852b;
+		mac8852b_priv_ops.intf_pwr_switch = usb_pwr_switch_8852b;
+		break;
+#endif
+#if MAC_AX_PCIE_SUPPORT
+	case MAC_AX_INTF_PCIE:
+		mac8852b_priv_ops.pwr_on = mac_pwr_on_pcie_8852b;
+		mac8852b_priv_ops.pwr_off = mac_pwr_off_pcie_8852b;
+		mac8852b_priv_ops.intf_pwr_switch = pcie_pwr_switch;
+		break;
+#endif
+	default:
+		return NULL;
+	}
+
+	return &mac8852b_priv_ops;
+}
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/mac_priv_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/mac_priv_8852b.h
new file mode 100644
index 000000000000..a6421b7738af
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/mac_priv_8852b.h
@@ -0,0 +1,26 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_MAC_PRIV_8852B_H_
+#define _MAC_AX_MAC_PRIV_8852B_H_
+
+#include "../mac_priv.h"
+#if MAC_AX_8852B_SUPPORT
+
+struct mac_ax_priv_ops *get_mac_8852b_priv_ops(enum mac_ax_intf intf);
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/mac_txccxrpt.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/mac_txccxrpt.h
new file mode 100644
index 000000000000..a5e101afd6af
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/mac_txccxrpt.h
@@ -0,0 +1,146 @@
+#ifndef _MAC_TXCCXRPT_H_
+#define _MAC_TXCCXRPT_H_
+
+/* dword0 */
+#define TXCCXRPT_RPT_SEL_SH		0
+#define TXCCXRPT_RPT_SEL_MSK		0x1f
+#define TXCCXRPT_POLLUTED		BIT(5)
+#define TXCCXRPT_TX_STATE_SH		6
+#define TXCCXRPT_TX_STATE_MSK		0x3
+#define TXCCXRPT_SW_DEFINE_SH		8
+#define TXCCXRPT_SW_DEFINE_MSK		0xf
+#define TXCCXRPT_TRY_RATE		BIT(14)
+#define TXCCXRPT_FIXRATE		BIT(15)
+#define TXCCXRPT_MACID_SH		16
+#define TXCCXRPT_MACID_MSK		0x7f
+#define TXCCXRPT_QSEL_SH		24
+#define TXCCXRPT_QSEL_MSK		0x3f
+#define TXCCXRPT_TXOP_START		BIT(31)
+
+/* dword1 */
+#define TXCCXRPT_QUEUE_TIME_SH		0
+#define TXCCXRPT_QUEUE_TIME_MSK		0xffff
+#define TXCCXRPT_ACCTXTIME_SH		16
+#define TXCCXRPT_ACCTXTIME_MSK		0xff
+#define TXCCXRPT_BMC		BIT(29)
+#define TXCCXRPT_BITMAP_SHORT_SH		30
+#define TXCCXRPT_BITMAP_SHORT_MSK		0x3
+
+/* dword2 */
+#define TXCCXRPT_FINAL_RATE_SH		0
+#define TXCCXRPT_FINAL_RATE_MSK		0x1ff
+#define TXCCXRPT_FINAL_GI_LTF_SH		9
+#define TXCCXRPT_FINAL_GI_LTF_MSK		0x7
+#define TXCCXRPT_DATA_BW_SH		12
+#define TXCCXRPT_DATA_BW_MSK		0x3
+#define TXCCXRPT_MU2SU		BIT(14)
+#define TXCCXRPT_MU_LMT		BIT(15)
+#define TXCCXRPT_FINAL_RTS_RATE_SH		16
+#define TXCCXRPT_FINAL_RTS_RATE_MSK		0x1ff
+#define TXCCXRPT_FINAL_RTS_GI_LTF_SH		25
+#define TXCCXRPT_FINAL_RTS_GI_LTF_MSK		0x7
+#define TXCCXRPT_RTS_TX_STATE_SH		28
+#define TXCCXRPT_RTS_TX_STATE_MSK		0x3
+#define TXCCXRPT_COLLISION_HEAD		BIT(30)
+#define TXCCXRPT_COLLISION_TAIL		BIT(31)
+
+/* dword3 */
+#define TXCCXRPT_TOTAL_PKT_NUM_SH		0
+#define TXCCXRPT_TOTAL_PKT_NUM_MSK		0xff
+#define TXCCXRPT_DATA_TX_CNT_SH		8
+#define TXCCXRPT_DATA_TX_CNT_MSK		0x3f
+#define TXCCXRPT_BPRI		BIT(14)
+#define TXCCXRPT_BBAR		BIT(15)
+#define TXCCXRPT_PKT_OK_NUM_SH		16
+#define TXCCXRPT_PKT_OK_NUM_MSK		0xff
+#define TXCCXRPT_RTS_TX_COUNT_SH		24
+#define TXCCXRPT_RTS_TX_COUNT_MSK		0x3f
+
+/* dword4 */
+#define TXCCXRPT_INIT_RATE_SH		0
+#define TXCCXRPT_INIT_RATE_MSK		0x1ff
+#define TXCCXRPT_INIT_GI_LTF_SH		9
+#define TXCCXRPT_INIT_GI_LTF_MSK		0x7
+#define TXCCXRPT_PPDU_TYPE_SH		12
+#define TXCCXRPT_PPDU_TYPE_MSK		0x3
+#define TXCCXRPT_HE_TB_PPDU_FLAG		BIT(14)
+#define TXCCXRPT_PPDU_FST_RPT		BIT(15)
+#define TXCCXRPT_SU_TXPWR_SH		16
+#define TXCCXRPT_SU_TXPWR_MSK		0x3f
+#define TXCCXRPT_DIFF_PKT_NUM_SH		24
+#define TXCCXRPT_DIFF_PKT_NUM_MSK		0xf
+#define TXCCXRPT_USER_DEFINE_EXT_L_SH		28
+#define TXCCXRPT_USER_DEFINE_EXT_L_MSK		0xf
+
+/* dword5 */
+#define TXCCXRPT_USER_DEFINE_SH		0
+#define TXCCXRPT_USER_DEFINE_MSK		0xff
+#define TXCCXRPT_FW_DEFINE_SH		8
+#define TXCCXRPT_FW_DEFINE_MSK		0xff
+#define TXCCXRPT_TXPWR_PD_SH		16
+#define TXCCXRPT_TXPWR_PD_MSK		0x1f
+#define TXCCXRPT_BSR		BIT(21)
+#define TXCCXRPT_SR_RX_COUNT_SH		24
+#define TXCCXRPT_SR_RX_COUNT_MSK		0xf
+#define TXCCXRPT_USER_DEFINE_EXT_H_SH		28
+#define TXCCXRPT_USER_DEFINE_EXT_H_MSK		0xf
+
+struct mac_ccxrpt {
+	/* dword 0 */
+	u32 rpt_sel:5;
+	u32 polluted:1;
+	u32 tx_state:2;
+	u32 sw_define:4;
+	u32 rsvd0:2;
+	u32 try_rate:1;
+	u32 fixrate:1;
+	u32 macid:7;
+	u32 rsvd1:1;
+	u32 qsel:6;
+	u32 rsvd2:1;
+	u32 txop_start:1;
+	/* dword 1 */
+	u32 queue_time:16;
+	u32 acctxtime:8;
+	u32 rsvd3:5;
+	u32 bmc:1;
+	u32 bitmap_short:2;
+	/* dword 2 */
+	u32 final_rate:9;
+	u32 final_gi_ltf:3;
+	u32 data_bw:2;
+	u32 mu2su:1;
+	u32 mu_lmt:1;
+	u32 final_rts_rate:9;
+	u32 final_rts_gi_ltf:3;
+	u32 rts_tx_state:2;
+	u32 collision_head:1;
+	u32 collision_tail:1;
+	/* dword 3 */
+	u32 total_pkt_num:8;
+	u32 data_tx_cnt:6;
+	u32 bpri:1;
+	u32 bbar:1;
+	u32 pkt_ok_num:8;
+	u32 rts_tx_count:6;
+	u32 rsvd4:2;
+	/* dword 4 */
+	u32 init_rate:9;
+	u32 init_gi_ltf:3;
+	u32 ppdu_type:2;
+	u32 he_tb_ppdu_flag:1;
+	u32 ppdu_fst_rpt:1;
+	u32 su_txpwr:6;
+	u32 rsvd5:2;
+	u32 diff_pkt_num:4;
+	u32 user_define_ext_l:4;
+	/* dword 5 */
+	u32 user_define:8;
+	u32 fw_define:8;
+	u32 txpwr_pd:5;
+	u32 bsr:1;
+	u32 rsvd6:2;
+	u32 sr_rx_count:4;
+	u32 user_define_ext_h:4;
+};
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/phy_rpt_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/phy_rpt_8852b.c
new file mode 100644
index 000000000000..5c31c584b5bf
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/phy_rpt_8852b.c
@@ -0,0 +1,45 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "phy_rpt_8852b.h"
+
+#if MAC_AX_8852B_SUPPORT
+
+#define MAC_AX_DISP_QID_HOST 0x2
+#define MAC_AX_DISP_QID_WLCPU 0xB
+#define MAC_AX_DISP_PID_HOST 0x0
+#define MAC_AX_DISP_PID_WLCPU 0x0
+
+u32 get_bbrpt_dle_cfg_8852b(struct mac_ax_adapter *adapter,
+			    u8 is2wlcpu, u32 *port_id, u32 *queue_id)
+{
+	if (is2wlcpu) {
+		*port_id = MAC_AX_DISP_PID_WLCPU;
+		*queue_id = MAC_AX_DISP_QID_WLCPU;
+	} else {
+		*port_id = MAC_AX_DISP_PID_HOST;
+		*queue_id = MAC_AX_DISP_QID_HOST;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_per_pkt_phy_rpt_8852b(struct mac_ax_adapter *adapter,
+				  struct mac_ax_per_pkt_phy_rpt *rpt)
+{
+	return MACNOTSUP;
+}
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/phy_rpt_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/phy_rpt_8852b.h
new file mode 100644
index 000000000000..5175ef043727
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/phy_rpt_8852b.h
@@ -0,0 +1,30 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_PHY_RPT_8852B_H_
+#define _MAC_AX_PHY_RPT_8852B_H_
+
+#include "../../mac_def.h"
+#if MAC_AX_8852B_SUPPORT
+
+u32 get_bbrpt_dle_cfg_8852b(struct mac_ax_adapter *adapter,
+			    u8 is2wlcpu, u32 *port_id, u32 *queue_id);
+
+u32 mac_cfg_per_pkt_phy_rpt_8852b(struct mac_ax_adapter *adapter,
+				  struct mac_ax_per_pkt_phy_rpt *rpt);
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_8852b.c
new file mode 100644
index 000000000000..8d99cd59aa7b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_8852b.c
@@ -0,0 +1,1488 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "../pwr.h"
+#if MAC_AX_8852B_SUPPORT
+
+static struct mac_pwr_cfg mac_pwron_8852b[] = {
+	{0x1086,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_SDIO,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), 0},
+	{0x1086,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_SDIO,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(1), BIT(1)},
+	{0x0005,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(4) | BIT(3), 0},
+	{0x0005,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(7), 0},
+	{0x0005,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(2), 0},
+	{0x0006,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(1), BIT(1)},
+	{0x0006,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), BIT(0)},
+	{0x0005,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), BIT(0)},
+	{0x0005,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(0), 0},
+	{0x0088,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), BIT(0)},
+	{0x0071,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_PCIE,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(4), 0},
+	{0x0018,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(6), BIT(6)},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x40},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x40},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0018,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(5), BIT(5)},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x20},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x20},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x04},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x04},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x08},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x08},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x10},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x02},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x02},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0001,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), BIT(0)},
+	{0x0001,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(7), 0},
+	{0x0001,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(6), 0},
+	{0xFFFF,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 0,
+	 PWR_CMD_END, 0, 0},
+};
+
+static struct mac_pwr_cfg mac_pwroff_8852b[] = {
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x10},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x10},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x08},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x04},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x81},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x02},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0006,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), BIT(0)},
+	{0x0002,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(1), 0},
+	{0x0018,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(5), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x20},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0018,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(6), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x40},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0005,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(1), BIT(1)},
+	{0x0005,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(1), 0},
+	{0x0091,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_PCIE,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), 0},
+	{0x0005,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_PCIE,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(2), BIT(2)},
+	{0x0007,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_USB,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(4), 0},
+	{0x0007,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_SDIO,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(6) | BIT(4), 0},
+	{0x0005,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_USB | PWR_INTF_MSK_SDIO,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(4) | BIT(3), BIT(3)},
+	{0x1086,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_SDIO,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), BIT(0)},
+	{0x1086,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_SDIO,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(1), 0},
+	{0xFFFF,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 0,
+	 PWR_CMD_END, 0, 0},
+};
+
+/* Power on sequence */
+struct mac_pwr_cfg *pwr_on_seq_8852b[] = {
+	mac_pwron_8852b,
+	NULL
+};
+
+/* Power off sequence */
+struct mac_pwr_cfg *pwr_off_seq_8852b[] = {
+	mac_pwroff_8852b,
+	NULL
+};
+
+#if MAC_AX_FEATURE_HV
+
+static struct mac_pwr_cfg mac_carddisable_seq_8852b[] = {
+	{0xFFFF,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 0,
+	 PWR_CMD_END, 0, 0},
+};
+
+static struct mac_pwr_cfg mac_enterlps_seq_8852b[] = {
+	{0x0068,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(6), 0},
+	{0x8394,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(2), BIT(2)},
+	{0x8398,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0xC4},
+	{0x8399,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x04},
+	{0x839A,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x40},
+	{0x839B,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x8398,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x8399,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0xB4},
+	{0x839A,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x41},
+	{0x839B,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x8398,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x04},
+	{0x8399,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x839A,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x42},
+	{0x839B,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x8398,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x8399,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x839A,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x43},
+	{0x839B,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x8398,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x8399,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x7D},
+	{0x839A,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x44},
+	{0x839B,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x8398,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x8399,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x839A,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x45},
+	{0x839B,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x8398,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x8399,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x839A,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x48},
+	{0x839B,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x8398,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(2), BIT(2)},
+	{0x8398,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(1), BIT(1)},
+	{0x8399,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x839A,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x48},
+	{0x839B,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x8300,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), BIT(0)},
+	{0x8322,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), BIT(0)},
+	{0x8322,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(1), BIT(1)},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0xA1},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x02},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x02},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x10},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x10},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x08},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x04},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x81},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0018,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(5), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x20},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0018,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(6), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x40},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0090,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_SDIO,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0xB0},
+	{0x0091,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_SDIO,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0xA1},
+	{0x0092,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_SDIO,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0093,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_SDIO,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x04},
+	{0x0090,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_PCIE | PWR_INTF_MSK_USB,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0xB0},
+	{0x0091,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_PCIE | PWR_INTF_MSK_USB,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0xA1},
+	{0x0092,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_PCIE | PWR_INTF_MSK_USB,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x81},
+	{0x0093,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_PCIE | PWR_INTF_MSK_USB,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x04},
+	{0x0090,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), BIT(0)},
+	{0x0090,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(0), 0},
+	{0xFFFF,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 0,
+	 PWR_CMD_END, 0, 0},
+};
+
+static struct mac_pwr_cfg mac_leavelps_seq_8852b[] = {
+	{0x1083,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_SDIO,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(7), BIT(7)},
+	{0x10C1,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_PCIE,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(7), BIT(7)},
+	{0x1203,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_USB,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(7), BIT(7)},
+	{0x1E5,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), BIT(7)},
+	{0x10,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_DELAY, PWR_DELAY_MS, PWR_DELAY_MS},
+	{0x8322,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), 0},
+	{0x8322,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(1), 0},
+	{0x1083,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_SDIO,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(7), 0},
+	{0x10C1,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_PCIE,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(7), 0},
+	{0x1203,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_USB,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(7), 0},
+	{0x8304,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(0), BIT(0)},
+	{0x0018,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(6), BIT(6)},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x40},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x40},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0018,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, BIT(5), BIT(5)},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x20},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x20},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x04},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x04},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x08},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x08},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x10},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x81},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0xA1},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x02},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x02},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0x0270,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x90},
+	{0x0271,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x00},
+	{0x0272,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x01},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_WRITE, 0xFF, 0x80},
+	{0x0273,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 PWR_BASE_MAC,
+	 PWR_CMD_POLL, BIT(7), 0},
+	{0xFFFF,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 0,
+	 PWR_CMD_END, 0, 0},
+};
+
+static struct mac_pwr_cfg mac_ips_seq_8852b[] = {
+	{0xFFFF,
+	 PWR_CVALL_MSK,
+	 PWR_INTF_MSK_ALL,
+	 0,
+	 PWR_CMD_END, 0, 0},
+};
+
+struct mac_pwr_cfg *card_disable_seq_8852b[] = {
+	mac_carddisable_seq_8852b,
+	NULL
+};
+
+struct mac_pwr_cfg *enter_lps_seq_8852b[] = {
+	mac_enterlps_seq_8852b,
+	NULL
+};
+
+struct mac_pwr_cfg *leave_lps_seq_8852b[] = {
+	mac_leavelps_seq_8852b,
+	NULL
+};
+
+struct mac_pwr_cfg *ips_seq_8852b[] = {
+	mac_ips_seq_8852b,
+	NULL
+};
+
+#endif
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_8852b.h
new file mode 100644
index 000000000000..1a5baa38fc5d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_8852b.h
@@ -0,0 +1,32 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#ifndef _MAC_AX_PWR_SEQ_8852B_H_
+#define _MAC_AX_PWR_SEQ_8852B_H_
+
+#include "../../mac_def.h"
+#if MAC_AX_8852B_SUPPORT
+//#define PWR_SEQ_VER_8852B  000
+
+extern struct mac_pwr_cfg *pwr_on_seq_8852b[];
+extern struct mac_pwr_cfg *pwr_off_seq_8852b[];
+#if MAC_AX_FEATURE_HV
+extern struct mac_pwr_cfg *card_disable_seq_8852b[];
+extern struct mac_pwr_cfg *enter_lps_seq_8852b[];
+extern struct mac_pwr_cfg *leave_lps_seq_8852b[];
+extern struct mac_pwr_cfg *ips_seq_8852b[];
+#endif
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_func_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_func_8852b.c
new file mode 100644
index 000000000000..658db1192095
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_func_8852b.c
@@ -0,0 +1,3040 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "../pwr.h"
+#include "../pwr_seq_func.h"
+
+#if MAC_AX_8852B_SUPPORT
+
+#define SW_LPS_OPTION 0x0001A0B2
+#define PWR_K_CHK_OFFSET 0x5E9
+#define PWR_K_CHK_VALUE 0xAA
+
+u32 _patch_ck_buf_level(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u16 val16;
+
+	if (chk_patch_ck_buf_level(adapter) == PATCH_DISABLE)
+		return MACSUCCESS;
+
+	/* 0x7A[3:0] = 0xA and 0xCC[2]=1 */
+	val32 = MAC_REG_R32(R_AX_PMC_DBG_CTRL2);
+	MAC_REG_W32(R_AX_PMC_DBG_CTRL2, val32 |
+	B_AX_SYSON_DIS_PMCR_AX_WRMSK);
+
+	val16 = MAC_REG_R16(R_AX_HCI_LDO_CTRL);
+	val16 = SET_CLR_WORD(val16, 0xA, B_AX_R_AX_VADJ);
+	MAC_REG_W16(R_AX_HCI_LDO_CTRL, val16);
+
+	val32 = MAC_REG_R32(R_AX_PMC_DBG_CTRL2);
+	MAC_REG_W32(R_AX_PMC_DBG_CTRL2, val32 &
+	~B_AX_SYSON_DIS_PMCR_AX_WRMSK);
+
+	return MACSUCCESS;
+}
+
+u32 mac_pwr_on_sdio_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret;
+	//u8 xtal_si_val;
+	u8 pwr_k_chk_value = 0;
+	u8 val8;
+
+	/* 0x1086[0] = 0 == 0x1084[16] = 0 */
+	val32 = MAC_REG_R32(R_AX_SDIO_BUS_CTRL);
+	MAC_REG_W32(R_AX_SDIO_BUS_CTRL, val32 & ~B_AX_HCI_SUS_REQ);
+
+	/* polling 0x1086[1] = 1 */
+	ret = pwr_poll_u32(adapter, R_AX_SDIO_BUS_CTRL, B_AX_HCI_RESUME_RDY,
+			   B_AX_HCI_RESUME_RDY);
+	if (ret)
+		return ret;
+
+	/* 0x04[12:11] = 2'b00 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 & ~(B_AX_AFSM_WLSUS_EN |
+			B_AX_AFSM_PCIE_SUS_EN));
+
+	/* 0x04[18] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_DIS_WLBT_PDNSUSEN_SOPC);
+
+	/* 0x90[1] = 1 */
+	val32 = MAC_REG_R32(R_AX_WLLPS_CTRL);
+	MAC_REG_W32(R_AX_WLLPS_CTRL, val32 | B_AX_DIS_WLBT_LPSEN_LOPC);
+
+	/* 0x04[15] = 0 */
+	//val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	//MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 & ~B_AX_APDM_HPDN);
+
+	/* 0x04[10] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 & ~B_AX_APFM_SWLPS);
+
+	/* polling 0x04[17] = 1*/
+	ret = pwr_poll_u32(adapter, R_AX_SYS_PW_CTRL, B_AX_RDY_SYSPWR,
+			   B_AX_RDY_SYSPWR);
+	if (ret)
+		return ret;
+
+	/* 0x20[23] = 1*/
+	val32 = MAC_REG_R32(R_AX_AFE_LDO_CTRL);
+	MAC_REG_W32(R_AX_AFE_LDO_CTRL, val32 | B_AX_AON_OFF_PC_EN);
+
+	/* polling 0x20[23] = 1*/
+	ret = pwr_poll_u32(adapter, R_AX_AFE_LDO_CTRL, B_AX_AON_OFF_PC_EN,
+			   B_AX_AON_OFF_PC_EN);
+	if (ret)
+		return ret;
+
+	/* 0x400[1:0] = 2'b01 and 0x400[5:4] = 2'b11*/
+	val32 = MAC_REG_R32(R_AX_SPS_DIG_OFF_CTRL0);
+	val32 = SET_CLR_WORD(val32, 0x1, B_AX_C1_L1);
+	val32 = SET_CLR_WORD(val32, 0x3, B_AX_C3_L1);
+	MAC_REG_W32(R_AX_SPS_DIG_OFF_CTRL0, val32);
+
+	/* 0x04[16] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_EN_WLON);
+
+	/* 0x04[8] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_APFN_ONMAC);
+
+	/* polling 0x04[8] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_SYS_PW_CTRL, B_AX_APFN_ONMAC, 0);
+	if (ret)
+		return ret;
+
+	/* reset platform twice : 0x88[0] = 1->0->1->0 */
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 | B_AX_PLATFORM_EN);
+
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 & ~B_AX_PLATFORM_EN);
+
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 | B_AX_PLATFORM_EN);
+
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 & ~B_AX_PLATFORM_EN);
+
+	/* 0x88[0] = 1 */
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 | B_AX_PLATFORM_EN);
+
+	/* 0x18[6] = 1 */
+	/* XTAL_SI 0x90[6] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 | B_AX_SYM_PADPDN_WL_PTA_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x40, 0x40);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[5] = 1 */
+	/* XTAL_SI 0x90[5] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 | B_AX_SYM_PADPDN_WL_RFC_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x20, 0x20);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[2] = 0 then 0x90[3] = 0 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[2] = 1 then 0x90[3] = 1 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[4] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x10);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[0] = 0 then 0x90[1] = 0 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[0] = 1 then 0x90[1] = 1 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[7] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x80);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0xA1[1] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_SRAM_CTRL, 0, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852B) {
+		/* XTAL_SI 0x24[6:4] = 3'b000 */
+		ret = mac_write_xtal_si(adapter, XTAL_SI_XTAL_XMD_2, 0, 0x70);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+
+	if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852BP) {
+		/* XTAL_SI 0x24[6:4] = 3'b001 */
+		ret = mac_write_xtal_si(adapter, XTAL_SI_XTAL_XMD_2, 0x10, 0x70);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+
+		/* XTAL_SI 0x91[4] = 0 */
+		ret = mac_write_xtal_si(adapter, XTAL_SI_GNT_CTRL, 0x00, 0x10);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+
+	/* XTAL_SI 0x26[3:0] = 4'b0000 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_XTAL_XMD_4, 0, 0x0F);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0xCC[2] = 1 */
+	val32 = MAC_REG_R32(R_AX_PMC_DBG_CTRL2);
+	MAC_REG_W32(R_AX_PMC_DBG_CTRL2, val32 | B_AX_SYSON_DIS_PMCR_AX_WRMSK);
+
+	/* 0x00[8] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ISO_CTRL);
+	MAC_REG_W32(R_AX_SYS_ISO_CTRL, val32 | B_AX_ISO_EB2CORE);
+
+	/* 0x00[15] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ISO_CTRL);
+	MAC_REG_W32(R_AX_SYS_ISO_CTRL, val32 & ~(BIT(15)));
+
+	PLTFM_DELAY_MS(1);
+
+	/* 0x00[14] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ISO_CTRL);
+	MAC_REG_W32(R_AX_SYS_ISO_CTRL, val32 & ~(BIT(14)));
+
+	/* 0xCC[2] = 0 */
+	val32 = MAC_REG_R32(R_AX_PMC_DBG_CTRL2);
+	MAC_REG_W32(R_AX_PMC_DBG_CTRL2, val32 & ~B_AX_SYSON_DIS_PMCR_AX_WRMSK);
+
+	/* check power calibration is done or not */
+	ret = mac_read_efuse_plus(adapter, PWR_K_CHK_OFFSET, 0x1, &pwr_k_chk_value,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret)
+		PLTFM_MSG_ERR("%s: read efuse fail\n", __func__);
+
+	if (pwr_k_chk_value != PWR_K_CHK_VALUE) {
+		/* 0x200[3:0]=0x9, 0x200 [25:22]=0xA */
+		val32 = MAC_REG_R32(R_AX_SPS_DIG_ON_CTRL0);
+		val32 = SET_CLR_WORD(val32, 0x9, B_AX_VOL_L1);
+		val32 = SET_CLR_WORD(val32, 0xA, B_AX_VREFPFM_L);
+		MAC_REG_W32(R_AX_SPS_DIG_ON_CTRL0, val32);
+	}
+
+#if 1
+	adapter->sm.pwr = MAC_AX_PWR_ON;
+	adapter->sm.plat = MAC_AX_PLAT_ON;
+	adapter->sm.io_st = MAC_AX_IO_ST_NORM;
+
+	/*enable dmac , 0x8400*/
+	val32 = MAC_REG_R32(R_AX_DMAC_FUNC_EN);
+	MAC_REG_W32(R_AX_DMAC_FUNC_EN,
+		    val32 | B_AX_MAC_FUNC_EN |
+			B_AX_DMAC_FUNC_EN |
+			B_AX_MPDU_PROC_EN |
+			B_AX_WD_RLS_EN |
+			B_AX_DLE_WDE_EN |
+			B_AX_TXPKT_CTRL_EN |
+			B_AX_STA_SCH_EN |
+			B_AX_DLE_PLE_EN |
+			B_AX_PKT_BUF_EN |
+			B_AX_DMAC_TBL_EN |
+			B_AX_PKT_IN_EN |
+			B_AX_DLE_CPUIO_EN |
+			B_AX_DISPATCHER_EN |
+			B_AX_BBRPT_EN |
+			B_AX_MAC_SEC_EN |
+			B_AX_DMACREG_GCKEN);
+
+	adapter->sm.dmac_func = MAC_AX_FUNC_ON;
+
+	/*enable cmac , 0xC000*/
+	val32 = MAC_REG_R32(R_AX_CMAC_FUNC_EN);
+	MAC_REG_W32(R_AX_CMAC_FUNC_EN,
+		    val32 | B_AX_CMAC_EN |
+			B_AX_CMAC_TXEN |
+			B_AX_CMAC_RXEN |
+			B_AX_FORCE_CMACREG_GCKEN |
+			B_AX_PHYINTF_EN |
+			B_AX_CMAC_DMA_EN |
+			B_AX_PTCLTOP_EN |
+			B_AX_SCHEDULER_EN |
+			B_AX_TMAC_EN |
+			B_AX_RMAC_EN);
+
+	adapter->sm.cmac0_func = MAC_AX_FUNC_ON;
+#endif
+
+	/*0x2D8[7:4] = 4'b0001*/
+	val32 = MAC_REG_R32(R_AX_EECS_EESK_FUNC_SEL);
+	val32 = SET_CLR_WORD(val32, 0x1, B_AX_PINMUX_EESK_FUNC_SEL);
+	MAC_REG_W32(R_AX_EECS_EESK_FUNC_SEL, val32);
+
+	return MACSUCCESS;
+}
+
+u32 mac_pwr_on_usb_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret;
+	//u8 xtal_si_val;
+	u8 pwr_k_chk_value = 0;
+	u8 val8;
+
+	/* 0x04[12:11] = 2'b00 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 & ~(B_AX_AFSM_WLSUS_EN |
+			B_AX_AFSM_PCIE_SUS_EN));
+
+	/* 0x04[18] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_DIS_WLBT_PDNSUSEN_SOPC);
+
+	/* 0x90[1] = 1 */
+	val32 = MAC_REG_R32(R_AX_WLLPS_CTRL);
+	MAC_REG_W32(R_AX_WLLPS_CTRL, val32 | B_AX_DIS_WLBT_LPSEN_LOPC);
+
+	/* 0x04[15] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 & ~B_AX_APDM_HPDN);
+
+	/* 0x04[10] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 & ~B_AX_APFM_SWLPS);
+
+	/* polling 0x04[17] = 1*/
+	ret = pwr_poll_u32(adapter, R_AX_SYS_PW_CTRL, B_AX_RDY_SYSPWR,
+			   B_AX_RDY_SYSPWR);
+	if (ret)
+		return ret;
+
+	/* 0x20[23] = 1*/
+	val32 = MAC_REG_R32(R_AX_AFE_LDO_CTRL);
+	MAC_REG_W32(R_AX_AFE_LDO_CTRL, val32 | B_AX_AON_OFF_PC_EN);
+
+	/* polling 0x20[23] = 1*/
+	ret = pwr_poll_u32(adapter, R_AX_AFE_LDO_CTRL, B_AX_AON_OFF_PC_EN,
+			   B_AX_AON_OFF_PC_EN);
+	if (ret)
+		return ret;
+
+	/* 0x400[1:0] = 2'b01 and 0x400[5:4] = 2'b11*/
+	val32 = MAC_REG_R32(R_AX_SPS_DIG_OFF_CTRL0);
+	val32 = SET_CLR_WORD(val32, 0x1, B_AX_C1_L1);
+	val32 = SET_CLR_WORD(val32, 0x3, B_AX_C3_L1);
+	MAC_REG_W32(R_AX_SPS_DIG_OFF_CTRL0, val32);
+
+	/* 0x04[16] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_EN_WLON);
+
+	/* 0x04[8] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_APFN_ONMAC);
+
+	/* polling 0x04[8] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_SYS_PW_CTRL, B_AX_APFN_ONMAC, 0);
+	if (ret)
+		return ret;
+
+	/* reset platform twice : 0x88[0] = 1->0->1->0 */
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 | B_AX_PLATFORM_EN);
+
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 & ~B_AX_PLATFORM_EN);
+
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 | B_AX_PLATFORM_EN);
+
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 & ~B_AX_PLATFORM_EN);
+
+	/* 0x88[0] = 1 */
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 | B_AX_PLATFORM_EN);
+
+	/* 0x18[6] = 1 */
+	/* XTAL_SI 0x90[6] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 | B_AX_SYM_PADPDN_WL_PTA_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x40, 0x40);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[5] = 1 */
+	/* XTAL_SI 0x90[5] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 | B_AX_SYM_PADPDN_WL_RFC_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x20, 0x20);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[2] = 0 then 0x90[3] = 0 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[2] = 1 then 0x90[3] = 1 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[4] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x10);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[0] = 0 then 0x90[1] = 0 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[0] = 1 then 0x90[1] = 1 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[7] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x80);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0xA1[1] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_SRAM_CTRL, 0, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852B) {
+		/* XTAL_SI 0x24[6:4] = 3'b000 */
+		ret = mac_write_xtal_si(adapter, XTAL_SI_XTAL_XMD_2, 0, 0x70);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+
+	if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852BP) {
+		/* XTAL_SI 0x24[6:4] = 3'b001 */
+		ret = mac_write_xtal_si(adapter, XTAL_SI_XTAL_XMD_2, 0x10, 0x70);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+
+		/* XTAL_SI 0x91[4] = 0 */
+		ret = mac_write_xtal_si(adapter, XTAL_SI_GNT_CTRL, 0x00, 0x10);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+
+	/* XTAL_SI 0x26[3:0] = 4'b0000 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_XTAL_XMD_4, 0, 0x0F);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0xCC[2] = 1 */
+	val32 = MAC_REG_R32(R_AX_PMC_DBG_CTRL2);
+	MAC_REG_W32(R_AX_PMC_DBG_CTRL2, val32 | B_AX_SYSON_DIS_PMCR_AX_WRMSK);
+
+	/* 0x00[8] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ISO_CTRL);
+	MAC_REG_W32(R_AX_SYS_ISO_CTRL, val32 | B_AX_ISO_EB2CORE);
+
+	/* 0x00[15] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ISO_CTRL);
+	MAC_REG_W32(R_AX_SYS_ISO_CTRL, val32 & ~(BIT(15)));
+
+	PLTFM_DELAY_MS(1);
+
+	/* 0x00[14] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ISO_CTRL);
+	MAC_REG_W32(R_AX_SYS_ISO_CTRL, val32 & ~(BIT(14)));
+
+	/* 0xCC[2] = 0 */
+	val32 = MAC_REG_R32(R_AX_PMC_DBG_CTRL2);
+	MAC_REG_W32(R_AX_PMC_DBG_CTRL2, val32 & ~B_AX_SYSON_DIS_PMCR_AX_WRMSK);
+
+	/* check power calibration is done or not */
+	ret = mac_read_efuse_plus(adapter, PWR_K_CHK_OFFSET, 0x1, &pwr_k_chk_value,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret)
+		PLTFM_MSG_ERR("%s: read efuse fail\n", __func__);
+
+	if (pwr_k_chk_value != PWR_K_CHK_VALUE) {
+		/* 0x200[3:0]=0x9, 0x200 [25:22]=0xA */
+		val32 = MAC_REG_R32(R_AX_SPS_DIG_ON_CTRL0);
+		val32 = SET_CLR_WORD(val32, 0x9, B_AX_VOL_L1);
+		val32 = SET_CLR_WORD(val32, 0xA, B_AX_VREFPFM_L);
+		MAC_REG_W32(R_AX_SPS_DIG_ON_CTRL0, val32);
+	}
+
+#if 1
+	adapter->sm.pwr = MAC_AX_PWR_ON;
+	adapter->sm.plat = MAC_AX_PLAT_ON;
+	adapter->sm.io_st = MAC_AX_IO_ST_NORM;
+
+	/*enable dmac , 0x8400*/
+	val32 = MAC_REG_R32(R_AX_DMAC_FUNC_EN);
+	MAC_REG_W32(R_AX_DMAC_FUNC_EN,
+		    val32 | B_AX_MAC_FUNC_EN |
+			B_AX_DMAC_FUNC_EN |
+			B_AX_MPDU_PROC_EN |
+			B_AX_WD_RLS_EN |
+			B_AX_DLE_WDE_EN |
+			B_AX_TXPKT_CTRL_EN |
+			B_AX_STA_SCH_EN |
+			B_AX_DLE_PLE_EN |
+			B_AX_PKT_BUF_EN |
+			B_AX_DMAC_TBL_EN |
+			B_AX_PKT_IN_EN |
+			B_AX_DLE_CPUIO_EN |
+			B_AX_DISPATCHER_EN |
+			B_AX_BBRPT_EN |
+			B_AX_MAC_SEC_EN |
+			B_AX_DMACREG_GCKEN);
+
+	adapter->sm.dmac_func = MAC_AX_FUNC_ON;
+
+	/*enable cmac , 0xC000*/
+	val32 = MAC_REG_R32(R_AX_CMAC_FUNC_EN);
+	MAC_REG_W32(R_AX_CMAC_FUNC_EN,
+		    val32 | B_AX_CMAC_EN |
+			B_AX_CMAC_TXEN |
+			B_AX_CMAC_RXEN |
+			B_AX_FORCE_CMACREG_GCKEN |
+			B_AX_PHYINTF_EN |
+			B_AX_CMAC_DMA_EN |
+			B_AX_PTCLTOP_EN |
+			B_AX_SCHEDULER_EN |
+			B_AX_TMAC_EN |
+			B_AX_RMAC_EN);
+
+	adapter->sm.cmac0_func = MAC_AX_FUNC_ON;
+#endif
+
+	/*0x2D8[7:4] = 4'b0001*/
+	val32 = MAC_REG_R32(R_AX_EECS_EESK_FUNC_SEL);
+	val32 = SET_CLR_WORD(val32, 0x1, B_AX_PINMUX_EESK_FUNC_SEL);
+	MAC_REG_W32(R_AX_EECS_EESK_FUNC_SEL, val32);
+
+	return MACSUCCESS;
+}
+
+u32 mac_pwr_on_pcie_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret;
+	//u16 val16;
+	//u8 xtal_si_val;
+	u8 pwr_k_chk_value = 0;
+	u8 val8;
+
+	/* 0x04[12:11] = 2'b00 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 & ~(B_AX_AFSM_WLSUS_EN |
+			B_AX_AFSM_PCIE_SUS_EN));
+
+	/* 0x04[18] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_DIS_WLBT_PDNSUSEN_SOPC);
+
+	/* 0x90[1] = 1 */
+	val32 = MAC_REG_R32(R_AX_WLLPS_CTRL);
+	MAC_REG_W32(R_AX_WLLPS_CTRL, val32 | B_AX_DIS_WLBT_LPSEN_LOPC);
+
+	/* 0x04[15] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 & ~B_AX_APDM_HPDN);
+
+	/* 0x04[10] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 & ~B_AX_APFM_SWLPS);
+
+	/* polling 0x04[17] = 1*/
+	ret = pwr_poll_u32(adapter, R_AX_SYS_PW_CTRL, B_AX_RDY_SYSPWR,
+			   B_AX_RDY_SYSPWR);
+	if (ret)
+		return ret;
+
+	/* 0x20[23] = 1*/
+	val32 = MAC_REG_R32(R_AX_AFE_LDO_CTRL);
+	MAC_REG_W32(R_AX_AFE_LDO_CTRL, val32 | B_AX_AON_OFF_PC_EN);
+
+	/* polling 0x20[23] = 1*/
+	ret = pwr_poll_u32(adapter, R_AX_AFE_LDO_CTRL, B_AX_AON_OFF_PC_EN,
+			   B_AX_AON_OFF_PC_EN);
+	if (ret)
+		return ret;
+
+	/* 0x400[1:0] = 2'b01 and 0x400[5:4] = 2'b11*/
+	val32 = MAC_REG_R32(R_AX_SPS_DIG_OFF_CTRL0);
+	val32 = SET_CLR_WORD(val32, 0x1, B_AX_C1_L1);
+	val32 = SET_CLR_WORD(val32, 0x3, B_AX_C3_L1);
+	MAC_REG_W32(R_AX_SPS_DIG_OFF_CTRL0, val32);
+
+	/* 0x04[16] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_EN_WLON);
+
+	/* 0x04[8] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_APFN_ONMAC);
+
+	/* polling 0x04[8] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_SYS_PW_CTRL, B_AX_APFN_ONMAC, 0);
+	if (ret)
+		return ret;
+
+	/* reset platform twice : 0x88[0] = 1->0->1->0 */
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 | B_AX_PLATFORM_EN);
+
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 & ~B_AX_PLATFORM_EN);
+
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 | B_AX_PLATFORM_EN);
+
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 & ~B_AX_PLATFORM_EN);
+
+	/* 0x88[0] = 1 */
+	val8 = MAC_REG_R8(R_AX_PLATFORM_ENABLE);
+	MAC_REG_W8(R_AX_PLATFORM_ENABLE, val8 | B_AX_PLATFORM_EN);
+
+	/* 0x70[12] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_SDIO_CTRL);
+	MAC_REG_W32(R_AX_SYS_SDIO_CTRL, val32 & ~B_AX_PCIE_CALIB_EN);
+
+	/* 0x18[6] = 1 */
+	/* XTAL_SI 0x90[6] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 | B_AX_SYM_PADPDN_WL_PTA_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x40, 0x40);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[5] = 1 */
+	/* XTAL_SI 0x90[5] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 | B_AX_SYM_PADPDN_WL_RFC_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x20, 0x20);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[2] = 0 then 0x90[3] = 0 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[2] = 1 then 0x90[3] = 1 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[4] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x10);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[0] = 0 then 0x90[1] = 0 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[0] = 1 then 0x90[1] = 1 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[7] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x80);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0xA1[1] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_SRAM_CTRL, 0, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852B) {
+		/* XTAL_SI 0x24[6:4] = 3'b000 */
+		ret = mac_write_xtal_si(adapter, XTAL_SI_XTAL_XMD_2, 0, 0x70);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+
+	if (PLTFM_GET_CHIP_ID(void) == CHIP_WIFI6_8852BP) {
+		/* XTAL_SI 0x24[6:4] = 3'b001 */
+		ret = mac_write_xtal_si(adapter, XTAL_SI_XTAL_XMD_2, 0x10, 0x70);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+
+		/* XTAL_SI 0x91[4] = 0 */
+		ret = mac_write_xtal_si(adapter, XTAL_SI_GNT_CTRL, 0x00, 0x10);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+
+	/* XTAL_SI 0x26[3:0] = 4'b0000 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_XTAL_XMD_4, 0, 0x0F);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0xCC[2] = 1 */
+	val32 = MAC_REG_R32(R_AX_PMC_DBG_CTRL2);
+	MAC_REG_W32(R_AX_PMC_DBG_CTRL2, val32 | B_AX_SYSON_DIS_PMCR_AX_WRMSK);
+
+	/* 0x00[8] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ISO_CTRL);
+	MAC_REG_W32(R_AX_SYS_ISO_CTRL, val32 | B_AX_ISO_EB2CORE);
+
+	/* 0x00[15] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ISO_CTRL);
+	MAC_REG_W32(R_AX_SYS_ISO_CTRL, val32 & ~(BIT(15)));
+
+	PLTFM_DELAY_MS(1);
+
+	/* 0x00[14] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ISO_CTRL);
+	MAC_REG_W32(R_AX_SYS_ISO_CTRL, val32 & ~(BIT(14)));
+
+	/* 0xCC[2] = 0 */
+	val32 = MAC_REG_R32(R_AX_PMC_DBG_CTRL2);
+	MAC_REG_W32(R_AX_PMC_DBG_CTRL2, val32 & ~B_AX_SYSON_DIS_PMCR_AX_WRMSK);
+
+	/* check power calibration is done or not */
+	ret = mac_read_efuse_plus(adapter, PWR_K_CHK_OFFSET, 0x1, &pwr_k_chk_value,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret)
+		PLTFM_MSG_ERR("%s: read efuse fail\n", __func__);
+
+	if (pwr_k_chk_value != PWR_K_CHK_VALUE) {
+		/* 0x200[3:0]=0x9, 0x200 [25:22]=0xA */
+		val32 = MAC_REG_R32(R_AX_SPS_DIG_ON_CTRL0);
+		val32 = SET_CLR_WORD(val32, 0x9, B_AX_VOL_L1);
+		val32 = SET_CLR_WORD(val32, 0xA, B_AX_VREFPFM_L);
+		MAC_REG_W32(R_AX_SPS_DIG_ON_CTRL0, val32);
+
+		ret = _patch_ck_buf_level(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("_patch_ck_buf_level fail !\n");
+			return ret;
+		}
+	}
+
+#if 1
+	adapter->sm.pwr = MAC_AX_PWR_ON;
+	adapter->sm.plat = MAC_AX_PLAT_ON;
+	adapter->sm.io_st = MAC_AX_IO_ST_NORM;
+
+	/*enable dmac , 0x8400*/
+	val32 = MAC_REG_R32(R_AX_DMAC_FUNC_EN);
+	MAC_REG_W32(R_AX_DMAC_FUNC_EN,
+		    val32 | B_AX_MAC_FUNC_EN |
+			B_AX_DMAC_FUNC_EN |
+			B_AX_MPDU_PROC_EN |
+			B_AX_WD_RLS_EN |
+			B_AX_DLE_WDE_EN |
+			B_AX_TXPKT_CTRL_EN |
+			B_AX_STA_SCH_EN |
+			B_AX_DLE_PLE_EN |
+			B_AX_PKT_BUF_EN |
+			B_AX_DMAC_TBL_EN |
+			B_AX_PKT_IN_EN |
+			B_AX_DLE_CPUIO_EN |
+			B_AX_DISPATCHER_EN |
+			B_AX_BBRPT_EN |
+			B_AX_MAC_SEC_EN |
+			B_AX_DMACREG_GCKEN);
+
+	adapter->sm.dmac_func = MAC_AX_FUNC_ON;
+
+	/*enable cmac , 0xC000*/
+	val32 = MAC_REG_R32(R_AX_CMAC_FUNC_EN);
+	MAC_REG_W32(R_AX_CMAC_FUNC_EN,
+		    val32 | B_AX_CMAC_EN |
+			B_AX_CMAC_TXEN |
+			B_AX_CMAC_RXEN |
+			B_AX_FORCE_CMACREG_GCKEN |
+			B_AX_PHYINTF_EN |
+			B_AX_CMAC_DMA_EN |
+			B_AX_PTCLTOP_EN |
+			B_AX_SCHEDULER_EN |
+			B_AX_TMAC_EN |
+			B_AX_RMAC_EN);
+
+	adapter->sm.cmac0_func = MAC_AX_FUNC_ON;
+#endif
+
+	/*0x2D8[7:4] = 4'b0001*/
+	val32 = MAC_REG_R32(R_AX_EECS_EESK_FUNC_SEL);
+	val32 = SET_CLR_WORD(val32, 0x1, B_AX_PINMUX_EESK_FUNC_SEL);
+	MAC_REG_W32(R_AX_EECS_EESK_FUNC_SEL, val32);
+
+	return MACSUCCESS;
+}
+
+u32 mac_pwr_off_sdio_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u8 val8;
+	u32 ret;
+	//u8 xtal_si_val;
+
+	/* XTAL_SI 0x90[4] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x10, 0x10);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[3] = 1 then 0x90[2] = 1 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[3] = 0 then 0x90[2] = 0 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x80[0] = 0 and 0x81[0] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[7] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x80, 0x80);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[1] = 1 then 0x90[0] = 1 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[1] = 0 then 0x90[0] = 0 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x04[16] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_EN_WLON);
+
+	/* 0x2F0[17] = 0 */
+	val32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+	MAC_REG_W32(R_AX_WLRF_CTRL, val32 & ~B_AX_AFC_AFEDIG);
+
+	/* 0x02[1:0] = 0 */
+	val8 = MAC_REG_R8(R_AX_SYS_FUNC_EN);
+	MAC_REG_W8(R_AX_SYS_FUNC_EN, val8 & ~B_AX_FEN_BB_GLB_RSTN & ~B_AX_FEN_BBRSTB);
+
+	/* 0x18[5] = 0 */
+	/* XTAL_SI 0x90[5] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 & ~B_AX_SYM_PADPDN_WL_RFC_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x20);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[6] = 0 */
+	/* XTAL_SI 0x90[6] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 & ~B_AX_SYM_PADPDN_WL_PTA_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x40);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x04[9] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_APFM_OFFMAC);
+
+	/* polling 0x04[9] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_SYS_PW_CTRL, B_AX_APFM_OFFMAC, 0);
+	if (ret)
+		return ret;
+
+	/* 0x04[28][30] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 & ~B_AX_SOP_EDSWR &
+			~B_AX_SOP_EASWR);
+
+	//0x10[10]=1,  0x200[18:17] = 2'b11
+	val32 = MAC_REG_R32(R_AX_SYS_SWR_CTRL1);
+	MAC_REG_W32(R_AX_SYS_SWR_CTRL1, val32 | B_AX_SYM_CTRL_SPS_PWMFREQ);
+
+	val32 = MAC_REG_R32(R_AX_SPS_DIG_ON_CTRL0);
+	val32 = SET_CLR_WORD(val32, 0x3, B_AX_REG_ZCDC_H);
+	MAC_REG_W32(R_AX_SPS_DIG_ON_CTRL0, val32);
+
+	/* 0x04[12:11] = 2'b01 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, (val32 | B_AX_AFSM_WLSUS_EN) &
+			~B_AX_AFSM_PCIE_SUS_EN);
+
+	/* 0x1086[0] = 1 */
+	val32 = MAC_REG_R32(R_AX_SDIO_BUS_CTRL);
+	MAC_REG_W32(R_AX_SDIO_BUS_CTRL, val32 | B_AX_HCI_SUS_REQ);
+
+	#if 0
+	/* polling 0x1086[1] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_SDIO_BUS_CTRL, B_AX_HCI_RESUME_RDY, 0);
+	if (ret)
+		return ret;
+	#endif
+
+	return MACSUCCESS;
+}
+
+u32 mac_pwr_off_usb_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u8 val8;
+	u32 ret;
+	//u8 xtal_si_val;
+
+	/* XTAL_SI 0x90[4] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x10, 0x10);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[3] = 1 then 0x90[2] = 1 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[3] = 0 then 0x90[2] = 0 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x80[0] = 0 and 0x81[0] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[7] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x80, 0x80);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[1] = 1 then 0x90[0] = 1 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[1] = 0 then 0x90[0] = 0 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x04[16] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_EN_WLON);
+
+	/* 0x2F0[17] = 0 */
+	val32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+	MAC_REG_W32(R_AX_WLRF_CTRL, val32 & ~B_AX_AFC_AFEDIG);
+
+	/* 0x02[1:0] = 0 */
+	val8 = MAC_REG_R8(R_AX_SYS_FUNC_EN);
+	MAC_REG_W8(R_AX_SYS_FUNC_EN, val8 & ~B_AX_FEN_BB_GLB_RSTN & ~B_AX_FEN_BBRSTB);
+
+	/* 0x18[5] = 0 */
+	/* XTAL_SI 0x90[5] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 & ~B_AX_SYM_PADPDN_WL_RFC_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x20);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[6] = 0 */
+	/* XTAL_SI 0x90[6] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 & ~B_AX_SYM_PADPDN_WL_PTA_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x40);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x04[9] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_APFM_OFFMAC);
+
+	/* polling 0x04[9] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_SYS_PW_CTRL, B_AX_APFM_OFFMAC, 0);
+	if (ret)
+		return ret;
+
+	/* 0x04[28] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 & ~B_AX_SOP_EDSWR);
+
+	//0x10[10]=1,  0x200[18:17] = 2'b11
+	val32 = MAC_REG_R32(R_AX_SYS_SWR_CTRL1);
+	MAC_REG_W32(R_AX_SYS_SWR_CTRL1, val32 | B_AX_SYM_CTRL_SPS_PWMFREQ);
+
+	val32 = MAC_REG_R32(R_AX_SPS_DIG_ON_CTRL0);
+	val32 = SET_CLR_WORD(val32, 0x3, B_AX_REG_ZCDC_H);
+	MAC_REG_W32(R_AX_SPS_DIG_ON_CTRL0, val32);
+
+	/* 0x04[12:11] = 2'b01 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, (val32 | B_AX_AFSM_WLSUS_EN) &
+			~B_AX_AFSM_PCIE_SUS_EN);
+
+	return MACSUCCESS;
+}
+
+u32 mac_pwr_off_pcie_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u8 val8;
+	u32 ret;
+	//u8 xtal_si_val;
+
+	/* XTAL_SI 0x90[4] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x10, 0x10);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[3] = 1 then 0x90[2] = 1 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[3] = 0 then 0x90[2] = 0 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x80[0] = 0 and 0x81[0] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[7] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x80, 0x80);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[1] = 1 then 0x90[0] = 1 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[1] = 0 then 0x90[0] = 0 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x04[16] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_EN_WLON);
+
+	/* 0x2F0[17] = 0 */
+	val32 = MAC_REG_R32(R_AX_WLRF_CTRL);
+	MAC_REG_W32(R_AX_WLRF_CTRL, val32 & ~B_AX_AFC_AFEDIG);
+
+	/* 0x02[1:0] = 0 */
+	val8 = MAC_REG_R8(R_AX_SYS_FUNC_EN);
+	MAC_REG_W8(R_AX_SYS_FUNC_EN, val8 & ~B_AX_FEN_BB_GLB_RSTN & ~B_AX_FEN_BBRSTB);
+
+	/* 0x18[5] = 0 */
+	/* XTAL_SI 0x90[5] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 & ~B_AX_SYM_PADPDN_WL_RFC_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x20);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[6] = 0 */
+	/* XTAL_SI 0x90[6] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 & ~B_AX_SYM_PADPDN_WL_PTA_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x40);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x04[9] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_APFM_OFFMAC);
+
+	/* polling 0x04[9] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_SYS_PW_CTRL, B_AX_APFM_OFFMAC, 0);
+	if (ret)
+		return ret;
+
+	/* 0x91[0] = 0 == 0x90[8]=0 */
+	//val32 = MAC_REG_R32(R_AX_WLLPS_CTRL);
+	//MAC_REG_W32(R_AX_WLLPS_CTRL, val32 & ~B_AX_LPSOP_DSWR);
+
+	/* 0x90[31:0] = 0x00_01_A0_B2 */
+	MAC_REG_W32(R_AX_WLLPS_CTRL, SW_LPS_OPTION);
+
+	//0x10[10]=1,  0x200[18:17] = 2'b11
+	val32 = MAC_REG_R32(R_AX_SYS_SWR_CTRL1);
+	MAC_REG_W32(R_AX_SYS_SWR_CTRL1, val32 | B_AX_SYM_CTRL_SPS_PWMFREQ);
+
+	val32 = MAC_REG_R32(R_AX_SPS_DIG_ON_CTRL0);
+	val32 = SET_CLR_WORD(val32, 0x3, B_AX_REG_ZCDC_H);
+	MAC_REG_W32(R_AX_SPS_DIG_ON_CTRL0, val32);
+
+	/* 0x04[10] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL);
+	MAC_REG_W32(R_AX_SYS_PW_CTRL, val32 | B_AX_APFM_SWLPS);
+
+	return MACSUCCESS;
+}
+
+#if MAC_AX_FEATURE_HV
+u32 mac_enter_lps_sdio_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret;
+	//u8 xtal_si_val;
+
+	/* 0x280[6] = 1  */
+	val32 = MAC_REG_R32(R_AX_XTAL_ON_CTRL0);
+	MAC_REG_W32(R_AX_XTAL_ON_CTRL0, val32 | B_AX_EN_XBUF_DRV_LPS);
+
+	/* 0x68[6] = 0	*/
+	val32 = MAC_REG_R32(R_AX_WL_BT_PWR_CTRL);
+	MAC_REG_W32(R_AX_WL_BT_PWR_CTRL, val32 & ~B_AX_WLAN_32K_SEL);
+
+	/* 0x8394[2] = 1 */
+	val32 = MAC_REG_R32(R_AX_OSC_32K_CTRL);
+	MAC_REG_W32(R_AX_OSC_32K_CTRL, val32 | B_AX_CAL32K_XTAL_EN);
+
+	/* 0x8398[31:0] = 0x00_40_04_C4 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x004004C4);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x804004C4);
+
+	/* 0x8398[31:0] = 0x00_41_B4_00 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x0041B400);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x8041B400);
+
+	/* 0x8398[31:0] = 0x00_42_00_04 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00420004);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80420004);
+
+	/* 0x8398[31:0] = 0x00_43_00_00 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00430000);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80430000);
+
+	/* 0x8398[31:0] = 0x00_44_7D_00 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00447D00);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80447D00);
+
+	/* 0x8398[31:0] = 0x00_45_00_00 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00450000);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80450000);
+
+	/* 0x8398[31:0] = 0x00_48_00_01 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00480001);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80480001);
+
+	/* polling 0x8398[2] = 1 */
+	ret = pwr_poll_u32(adapter, R_AX_32K_CAL_REG0, BIT(2), BIT(2));
+	if (ret)
+		return ret;
+
+	/* 0x8398[1] = 1 */
+	val32 = MAC_REG_R32(R_AX_32K_CAL_REG0);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, val32 | BIT(1));
+
+	/* 0x8399[7:0] = 0x00 */
+	MAC_REG_W8(R_AX_32K_CAL_REG0 + 1, 0x00);
+
+	/* 0x839A[7:0] = 0x48 */
+	MAC_REG_W8(R_AX_32K_CAL_REG0 + 2, 0x48);
+
+	/* 0x839B[7:0] = 0x80 */
+	MAC_REG_W8(R_AX_32K_CAL_REG0 + 3, 0x80);
+
+	/* 0x8300[0] = 1 */
+	val32 = MAC_REG_R32(R_AX_FWD1IMR);
+	MAC_REG_W32(R_AX_FWD1IMR, val32 | B_AX_FS_RPWM_INT_EN);
+
+	/* 0x8322[0] = 1 == 0x8320[16] =1 */
+	val32 = MAC_REG_R32(R_AX_TSF_32K_SEL);
+	MAC_REG_W32(R_AX_TSF_32K_SEL, val32 | B_AX_CKSL_WLTSF);
+
+	/* polling 0x8322[1] = 1 */
+	ret = pwr_poll_u32(adapter, R_AX_TSF_32K_SEL, B_AX_TSF_CLK_STABLE,
+			   B_AX_TSF_CLK_STABLE);
+	if (ret)
+		return ret;
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[0] = 0 then 0x90[1] = 0 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[0] = 1 then 0x90[1] = 1 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[7] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x80);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0xA1[1] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_SRAM_CTRL, 0x02, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[4] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x10, 0x10);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[3] = 1 then 0x90[2] = 1 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[3] = 0 then 0x90[2] = 0 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x80[0] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x81[0] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[5] = 0 */
+	/* XTAL_SI 0x90[5] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 & ~B_AX_SYM_PADPDN_WL_RFC_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x20);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[6] = 0 */
+	/* XTAL_SI 0x90[6] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 & ~B_AX_SYM_PADPDN_WL_PTA_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x40);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x90[31:0] = 0x04_80_A1_B0 */
+	MAC_REG_W32(R_AX_WLLPS_CTRL, 0x0480A1B0);
+
+	/* 0x90[0] = 1 */
+	val32 = MAC_REG_R32(R_AX_WLLPS_CTRL);
+	MAC_REG_W32(R_AX_WLLPS_CTRL, val32 | B_AX_WL_LPS_EN);
+
+	/* polling 0x90[0] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_WLLPS_CTRL, B_AX_WL_LPS_EN, 0);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_enter_lps_usb_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret;
+	//u8 xtal_si_val;
+
+	/* 0x280[6] = 1  */
+	val32 = MAC_REG_R32(R_AX_XTAL_ON_CTRL0);
+	MAC_REG_W32(R_AX_XTAL_ON_CTRL0, val32 | B_AX_EN_XBUF_DRV_LPS);
+
+	/* 0x68[6] = 0	*/
+	val32 = MAC_REG_R32(R_AX_WL_BT_PWR_CTRL);
+	MAC_REG_W32(R_AX_WL_BT_PWR_CTRL, val32 & ~B_AX_WLAN_32K_SEL);
+
+	/* 0x8394[2] = 1 */
+	val32 = MAC_REG_R32(R_AX_OSC_32K_CTRL);
+	MAC_REG_W32(R_AX_OSC_32K_CTRL, val32 | B_AX_CAL32K_XTAL_EN);
+
+	/* 0x8398[31:0] = 0x00_40_04_C4 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x004004C4);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x804004C4);
+
+	/* 0x8398[31:0] = 0x00_41_B4_00 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x0041B400);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x8041B400);
+
+	/* 0x8398[31:0] = 0x00_42_00_04 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00420004);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80420004);
+
+	/* 0x8398[31:0] = 0x00_43_00_00 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00430000);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80430000);
+
+	/* 0x8398[31:0] = 0x00_44_7D_00 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00447D00);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80447D00);
+
+	/* 0x8398[31:0] = 0x00_45_00_00 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00450000);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80450000);
+
+	/* 0x8398[31:0] = 0x00_48_00_01 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00480001);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80480001);
+
+	/* polling 0x8398[2] = 1 */
+	ret = pwr_poll_u32(adapter, R_AX_32K_CAL_REG0, BIT(2), BIT(2));
+	if (ret)
+		return ret;
+
+	/* 0x8398[1] = 1 */
+	val32 = MAC_REG_R32(R_AX_32K_CAL_REG0);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, val32 | BIT(1));
+
+	/* 0x8399[7:0] = 0x00 */
+	MAC_REG_W8(R_AX_32K_CAL_REG0 + 1, 0x00);
+
+	/* 0x839A[7:0] = 0x48 */
+	MAC_REG_W8(R_AX_32K_CAL_REG0 + 2, 0x48);
+
+	/* 0x839B[7:0] = 0x80 */
+	MAC_REG_W8(R_AX_32K_CAL_REG0 + 3, 0x80);
+
+	/* 0x8300[0] = 1 */
+	val32 = MAC_REG_R32(R_AX_FWD1IMR);
+	MAC_REG_W32(R_AX_FWD1IMR, val32 | B_AX_FS_RPWM_INT_EN);
+
+	/* 0x8322[0] = 1 == 0x8320[16] =1 */
+	val32 = MAC_REG_R32(R_AX_TSF_32K_SEL);
+	MAC_REG_W32(R_AX_TSF_32K_SEL, val32 | B_AX_CKSL_WLTSF);
+
+	/* polling 0x8322[1] = 1 */
+	ret = pwr_poll_u32(adapter, R_AX_TSF_32K_SEL, B_AX_TSF_CLK_STABLE,
+			   B_AX_TSF_CLK_STABLE);
+	if (ret)
+		return ret;
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[0] = 0 then 0x90[1] = 0 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[0] = 1 then 0x90[1] = 1 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[7] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x80);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0xA1[1] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_SRAM_CTRL, 0x02, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[4] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x10, 0x10);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[3] = 1 then 0x90[2] = 1 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[3] = 0 then 0x90[2] = 0 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x80[0] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x81[0] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[5] = 0 */
+	/* XTAL_SI 0x90[5] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 & ~B_AX_SYM_PADPDN_WL_RFC_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x20);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[6] = 0 */
+	/* XTAL_SI 0x90[6] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 & ~B_AX_SYM_PADPDN_WL_PTA_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x40);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x90[31:0] = 0x04_81_A1_B0 */
+	MAC_REG_W32(R_AX_WLLPS_CTRL, 0x0481A1B0);
+
+	/* 0x90[0] = 1 */
+	val32 = MAC_REG_R32(R_AX_WLLPS_CTRL);
+	MAC_REG_W32(R_AX_WLLPS_CTRL, val32 | B_AX_WL_LPS_EN);
+
+	/* polling 0x90[0] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_WLLPS_CTRL, B_AX_WL_LPS_EN, 0);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_enter_lps_pcie_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret;
+	//u8 xtal_si_val;
+
+	/* 0x280[6] = 1  */
+	val32 = MAC_REG_R32(R_AX_XTAL_ON_CTRL0);
+	MAC_REG_W32(R_AX_XTAL_ON_CTRL0, val32 | B_AX_EN_XBUF_DRV_LPS);
+
+	/* 0x68[6] = 0  */
+	val32 = MAC_REG_R32(R_AX_WL_BT_PWR_CTRL);
+	MAC_REG_W32(R_AX_WL_BT_PWR_CTRL, val32 & ~B_AX_WLAN_32K_SEL);
+
+	/* 0x8394[2] = 1 */
+	val32 = MAC_REG_R32(R_AX_OSC_32K_CTRL);
+	MAC_REG_W32(R_AX_OSC_32K_CTRL, val32 | B_AX_CAL32K_XTAL_EN);
+
+	/* 0x8398[31:0] = 0x00_40_04_C4 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x004004C4);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x804004C4);
+
+	/* 0x8398[31:0] = 0x00_41_B4_00 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x0041B400);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x8041B400);
+
+	/* 0x8398[31:0] = 0x00_42_00_04 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00420004);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80420004);
+
+	/* 0x8398[31:0] = 0x00_43_00_00 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00430000);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80430000);
+
+	/* 0x8398[31:0] = 0x00_44_7D_00 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00447D00);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80447D00);
+
+	/* 0x8398[31:0] = 0x00_45_00_00 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00450000);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80450000);
+
+	/* 0x8398[31:0] = 0x00_48_00_01 then 0x8398[31] = 1 */
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x00480001);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, 0x80480001);
+
+	/* polling 0x8398[2] = 1 */
+	ret = pwr_poll_u32(adapter, R_AX_32K_CAL_REG0, BIT(2), BIT(2));
+	if (ret)
+		return ret;
+
+	/* 0x8398[1] = 1 */
+	val32 = MAC_REG_R32(R_AX_32K_CAL_REG0);
+	MAC_REG_W32(R_AX_32K_CAL_REG0, val32 | BIT(1));
+
+	/* 0x8399[7:0] = 0x00 */
+	MAC_REG_W8(R_AX_32K_CAL_REG0 + 1, 0x00);
+
+	/* 0x839A[7:0] = 0x48 */
+	MAC_REG_W8(R_AX_32K_CAL_REG0 + 2, 0x48);
+
+	/* 0x839B[7:0] = 0x80 */
+	MAC_REG_W8(R_AX_32K_CAL_REG0 + 3, 0x80);
+
+	/* 0x8300[0] = 1 */
+	val32 = MAC_REG_R32(R_AX_FWD1IMR);
+	MAC_REG_W32(R_AX_FWD1IMR, val32 | B_AX_FS_RPWM_INT_EN);
+
+	/* 0x8322[0] = 1 == 0x8320[16] =1 */
+	val32 = MAC_REG_R32(R_AX_TSF_32K_SEL);
+	MAC_REG_W32(R_AX_TSF_32K_SEL, val32 | B_AX_CKSL_WLTSF);
+
+	/* polling 0x8322[1] = 1 */
+	ret = pwr_poll_u32(adapter, R_AX_TSF_32K_SEL, B_AX_TSF_CLK_STABLE,
+			   B_AX_TSF_CLK_STABLE);
+	if (ret)
+		return ret;
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[0] = 0 then 0x90[1] = 0 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[0] = 1 then 0x90[1] = 1 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[7] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x80);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0xA1[1] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_SRAM_CTRL, 0x02, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[4] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x10, 0x10);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[3] = 1 then 0x90[2] = 1 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[3] = 0 then 0x90[2] = 0 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x80[0] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x81[0] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[5] = 0 */
+	/* XTAL_SI 0x90[5] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 & ~B_AX_SYM_PADPDN_WL_RFC_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x20);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[6] = 0 */
+	/* XTAL_SI 0x90[6] = 0 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 & ~B_AX_SYM_PADPDN_WL_PTA_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x40);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x90[31:0] = 0x04_81_A1_B0 */
+	MAC_REG_W32(R_AX_WLLPS_CTRL, 0x0481A1B0);
+
+	/* 0x90[0] = 1 */
+	val32 = MAC_REG_R32(R_AX_WLLPS_CTRL);
+	MAC_REG_W32(R_AX_WLLPS_CTRL, val32 | B_AX_WL_LPS_EN);
+
+	/* polling 0x90[0] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_WLLPS_CTRL, B_AX_WL_LPS_EN, 0);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_leave_lps_sdio_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret;
+	//u8 xtal_si_val;
+	u32 cnt = 320;
+
+	/* 0x1083[7] = 1 == 0x1080[31] = 1 */
+	val32 = MAC_REG_R32(R_AX_SDIO_HRPWM1);
+	MAC_REG_W32(R_AX_SDIO_HRPWM1, val32 | BIT(31));
+
+	/* polling 0x1E5[7] = 1 == 0x1E4[15] = 1 */
+	ret = pwr_poll_u32(adapter, R_AX_RPWM,
+			   B_AX_RPWM_TOGGLE, B_AX_RPWM_TOGGLE);
+	if (ret)
+		return ret;
+
+	/* delay 0x10 ms */
+	while (--cnt)
+		PLTFM_DELAY_US(50);
+
+	/* 0x8322[0] = 0 == 0x8320[16] = 0 */
+	val32 = MAC_REG_R32(R_AX_TSF_32K_SEL);
+	MAC_REG_W32(R_AX_TSF_32K_SEL, val32 & ~B_AX_CKSL_WLTSF);
+
+	/* polling 0x8322[1] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_TSF_32K_SEL, B_AX_TSF_CLK_STABLE, 0);
+	if (ret)
+		return ret;
+
+	/* 0x1083[7] = 0 == 0x1080[31] = 0 */
+	val32 = MAC_REG_R32(R_AX_SDIO_HRPWM1);
+	MAC_REG_W32(R_AX_SDIO_HRPWM1, val32 & ~(BIT(31)));
+
+	/* 0x8304[0] = 1 */
+	val32 = MAC_REG_R32(R_AX_FWD1ISR);
+	MAC_REG_W32(R_AX_FWD1ISR, val32 | B_AX_FS_RPWM_INT);
+
+	/* 0x18[6] = 1 */
+	/* XTAL_SI 0x90[6] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 | B_AX_SYM_PADPDN_WL_PTA_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x40, 0x40);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[5] = 1 */
+	/* XTAL_SI 0x90[5] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 | B_AX_SYM_PADPDN_WL_RFC_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x20, 0x20);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[2] = 0 then 0x90[3] = 0 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[2] = 1 then 0x90[3] = 1 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[4] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x10);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x80[0] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, 0x01, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x81[0] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, 0x01, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0xA1[1] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_SRAM_CTRL, 0, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[7] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x80, 0x80);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[1] = 1 then 0x90[0] = 1 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[1] = 0 then 0x90[0] = 0 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_leave_lps_usb_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret;
+	//u8 xtal_si_val;
+	u32 cnt = 320;
+
+	/* 0x1203[7] = 1 == 0x1200[31] = 1 */
+	val32 = MAC_REG_R32(R_AX_USB_D2F_F2D_INFO);
+	MAC_REG_W32(R_AX_USB_D2F_F2D_INFO, val32 | BIT(31));
+
+	/* polling 0x1E5[7] = 1 == 0x1E4[15] = 1 */
+	ret = pwr_poll_u32(adapter, R_AX_RPWM,
+			   B_AX_RPWM_TOGGLE, B_AX_RPWM_TOGGLE);
+	if (ret)
+		return ret;
+
+	/* delay 0x10 ms */
+	while (--cnt)
+		PLTFM_DELAY_US(50);
+
+	/* 0x8322[0] = 0 == 0x8320[16] = 0 */
+	val32 = MAC_REG_R32(R_AX_TSF_32K_SEL);
+	MAC_REG_W32(R_AX_TSF_32K_SEL, val32 & ~B_AX_CKSL_WLTSF);
+
+	/* polling 0x8322[1] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_TSF_32K_SEL, B_AX_TSF_CLK_STABLE, 0);
+	if (ret)
+		return ret;
+
+	/* 0x1203[7] = 0 == 0x1200[31] = 0 */
+	val32 = MAC_REG_R32(R_AX_USB_D2F_F2D_INFO);
+	MAC_REG_W32(R_AX_USB_D2F_F2D_INFO, val32 & ~(BIT(31)));
+
+	/* 0x8304[0] = 1 */
+	val32 = MAC_REG_R32(R_AX_FWD1ISR);
+	MAC_REG_W32(R_AX_FWD1ISR, val32 | B_AX_FS_RPWM_INT);
+
+	/* 0x18[6] = 1 */
+	/* XTAL_SI 0x90[6] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 | B_AX_SYM_PADPDN_WL_PTA_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x40, 0x40);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[5] = 1 */
+	/* XTAL_SI 0x90[5] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 | B_AX_SYM_PADPDN_WL_RFC_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x20, 0x20);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[2] = 0 then 0x90[3] = 0 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[2] = 1 then 0x90[3] = 1 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[4] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x10);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x80[0] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, 0x01, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x81[0] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, 0x01, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0xA1[1] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_SRAM_CTRL, 0, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[7] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x80, 0x80);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[1] = 1 then 0x90[0] = 1 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[1] = 0 then 0x90[0] = 0 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_leave_lps_pcie_8852b(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret;
+	//u8 xtal_si_val;
+	u32 cnt = 320;
+
+	/* 0x10C1[7] = 1 == 0x10C0[15] = 1 */
+	val32 = MAC_REG_R32(R_AX_PCIE_HRPWM);
+	MAC_REG_W32(R_AX_PCIE_HRPWM, val32 | BIT(15));
+
+	/* polling 0x1E5[7] = 1 == 0x1E4[15] = 1 */
+	ret = pwr_poll_u32(adapter, R_AX_RPWM,
+			   B_AX_RPWM_TOGGLE, B_AX_RPWM_TOGGLE);
+	if (ret)
+		return ret;
+
+	/* delay 0x10 ms */
+	while (--cnt)
+		PLTFM_DELAY_US(50);
+
+	/* 0x8322[0] = 0 == 0x8320[16] = 0 */
+	val32 = MAC_REG_R32(R_AX_TSF_32K_SEL);
+	MAC_REG_W32(R_AX_TSF_32K_SEL, val32 & ~B_AX_CKSL_WLTSF);
+
+	/* polling 0x8322[1] = 0 */
+	ret = pwr_poll_u32(adapter, R_AX_TSF_32K_SEL, B_AX_TSF_CLK_STABLE, 0);
+	if (ret)
+		return ret;
+
+	/* 0x10C1[7] = 0 */
+	val32 = MAC_REG_R32(R_AX_PCIE_HRPWM);
+	MAC_REG_W32(R_AX_PCIE_HRPWM, val32 & ~(BIT(15)));
+
+	/* 0x8304[0] = 1 */
+	val32 = MAC_REG_R32(R_AX_FWD1ISR);
+	MAC_REG_W32(R_AX_FWD1ISR, val32 | B_AX_FS_RPWM_INT);
+
+	/* 0x18[6] = 1 */
+	/* XTAL_SI 0x90[6] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 | B_AX_SYM_PADPDN_WL_PTA_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x40, 0x40);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* 0x18[5] = 1 */
+	/* XTAL_SI 0x90[5] = 1 */
+	val32 = MAC_REG_R32(R_AX_SYS_ADIE_PAD_PWR_CTRL);
+	MAC_REG_W32(R_AX_SYS_ADIE_PAD_PWR_CTRL, val32 | B_AX_SYM_PADPDN_WL_RFC_1P3);
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x20, 0x20);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[2] = 0 then 0x90[3] = 0 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[2] = 1 then 0x90[3] = 1 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x04, 0x04);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x08, 0x08);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[4] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x10);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x80[0] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S0, 0x01, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x81[0] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_WL_RFC_S1, 0x01, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0xA1[1] = 0 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_SRAM_CTRL, 0, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* XTAL_SI 0x90[7] = 1 */
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x80, 0x80);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	/* DAV CAV */
+	/* XTAL_SI 0x90[1] = 1 then 0x90[0] = 1 */
+	/* DAV after CBV */
+	/* XTAL_SI 0x90[1] = 0 then 0x90[0] = 0 */
+	#if 0
+	ret = mac_read_xtal_si(adapter, XTAL_SI_CV, &xtal_si_val);
+	if (ret) {
+		PLTFM_MSG_ERR("Read XTAL_SI fail!\n");
+		return ret;
+	}
+
+	xtal_si_val = (xtal_si_val & 0x0F);
+
+	if (xtal_si_val == CAV) {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x02, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0x01, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	} else {
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+		ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+		if (ret) {
+			PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+			return ret;
+		}
+	}
+	#endif
+
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x02);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+	ret = mac_write_xtal_si(adapter, XTAL_SI_ANAPAR_WL, 0, 0x01);
+	if (ret) {
+		PLTFM_MSG_ERR("Write XTAL_SI fail!\n");
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+#endif
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_func_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_func_8852b.h
new file mode 100644
index 000000000000..dde8940e73b0
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/pwr_seq_func_8852b.h
@@ -0,0 +1,43 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_PWR_SEQ_FUNC_8852B_H_
+#define _MAC_AX_PWR_SEQ_FUNC_8852B_H_
+
+#include "../../mac_def.h"
+#if MAC_AX_8852B_SUPPORT
+
+#define PWR_SEQ_VER_8852B  22
+
+u32 mac_pwr_on_sdio_8852b(struct mac_ax_adapter *adapter);
+u32 mac_pwr_on_usb_8852b(struct mac_ax_adapter *adapter);
+u32 mac_pwr_on_pcie_8852b(struct mac_ax_adapter *adapter);
+
+u32 mac_pwr_off_sdio_8852b(struct mac_ax_adapter *adapter);
+u32 mac_pwr_off_usb_8852b(struct mac_ax_adapter *adapter);
+u32 mac_pwr_off_pcie_8852b(struct mac_ax_adapter *adapter);
+#if MAC_AX_FEATURE_HV
+u32 mac_enter_lps_sdio_8852b(struct mac_ax_adapter *adapter);
+u32 mac_enter_lps_usb_8852b(struct mac_ax_adapter *adapter);
+u32 mac_enter_lps_pcie_8852b(struct mac_ax_adapter *adapter);
+
+u32 mac_leave_lps_sdio_8852b(struct mac_ax_adapter *adapter);
+u32 mac_leave_lps_usb_8852b(struct mac_ax_adapter *adapter);
+u32 mac_leave_lps_pcie_8852b(struct mac_ax_adapter *adapter);
+
+#endif /* #if MAC_AX_FEATURE_HV */
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/rrsr_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/rrsr_8852b.c
new file mode 100644
index 000000000000..f0a07edafc79
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/rrsr_8852b.c
@@ -0,0 +1,137 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "rrsr_8852b.h"
+#if MAC_AX_8852B_SUPPORT
+
+u32 mac_get_rrsr_cfg_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_rrsr_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, rrsr_ctl_0, rrsr_ctl_1;
+
+	val32 = check_mac_en(adapter, cfg->band, MAC_AX_CMAC_SEL);
+	if (val32 != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, cfg->band);
+		return val32;
+	}
+
+	rrsr_ctl_0 = MAC_REG_R32((cfg->band == MAC_AX_BAND_1) ?
+			    R_AX_TRXPTCL_RRSR_CTL_0_C1 : R_AX_TRXPTCL_RRSR_CTL_0);
+	cfg->rrsr_rate_en = GET_FIELD(rrsr_ctl_0, B_AX_WMAC_RESP_RATE_EN);
+	cfg->doppler_en = ((rrsr_ctl_0 & B_AX_WMAC_RESP_DOPPLEB_AX_EN) != 0);
+	cfg->dcm_en = ((rrsr_ctl_0 & B_AX_WMAC_RESP_DCM_EN) != 0);
+	cfg->cck_cfg = GET_FIELD(rrsr_ctl_0, B_AX_WMAC_RRSB_AX_CCK);
+	cfg->rsc = GET_FIELD(rrsr_ctl_0, B_AX_WMAC_RESP_RSC);
+	cfg->ref_rate_sel = ((rrsr_ctl_0 & B_AX_WMAC_RESP_REF_RATE_SEL) != 0);
+	cfg->ref_rate =  GET_FIELD(rrsr_ctl_0, B_AX_WMAC_RESP_REF_RATE);
+	cfg->ftm_rrsr_rate_en =  GET_FIELD(rrsr_ctl_0, B_AX_FTM_RRSR_RATE_EN);
+
+	rrsr_ctl_1 = MAC_REG_R32((cfg->band == MAC_AX_BAND_1) ?
+			    R_AX_TRXPTCL_RRSR_CTL_1_C1 : R_AX_TRXPTCL_RRSR_CTL_1);
+	cfg->ofdm_cfg = GET_FIELD(rrsr_ctl_1, B_AX_WMAC_RRSR_OFDM);
+	cfg->ht_cfg = GET_FIELD(rrsr_ctl_1, B_AX_WMAC_RRSR_HT);
+	cfg->vht_cfg = GET_FIELD(rrsr_ctl_1, B_AX_WMAC_RRSR_VHT);
+	cfg->he_cfg = GET_FIELD(rrsr_ctl_1, B_AX_WMAC_RRSR_HE);
+
+	return MACSUCCESS;
+}
+
+u32 mac_set_rrsr_cfg_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_rrsr_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, rrsr_ctl_0, rrsr_ctl_1;
+
+	val32 = check_mac_en(adapter, cfg->band, MAC_AX_CMAC_SEL);
+	if (val32 != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, cfg->band);
+		return val32;
+	}
+
+	rrsr_ctl_0 = SET_WORD(cfg->rrsr_rate_en, B_AX_WMAC_RESP_RATE_EN) |
+		     (cfg->doppler_en ? B_AX_WMAC_RESP_DOPPLEB_AX_EN : 0) |
+		     (cfg->dcm_en ? B_AX_WMAC_RESP_DCM_EN : 0) |
+		     SET_WORD(cfg->cck_cfg, B_AX_WMAC_RRSB_AX_CCK) |
+		     SET_WORD(cfg->rsc, B_AX_WMAC_RESP_RSC) |
+		     (cfg->ref_rate_sel ? B_AX_WMAC_RESP_REF_RATE_SEL : 0) |
+		     SET_WORD(cfg->ftm_rrsr_rate_en, B_AX_FTM_RRSR_RATE_EN) |
+		     SET_WORD(cfg->ref_rate, B_AX_WMAC_RESP_REF_RATE);
+
+	rrsr_ctl_1 = SET_WORD(cfg->ofdm_cfg, B_AX_WMAC_RRSR_OFDM) |
+		     SET_WORD(cfg->ht_cfg, B_AX_WMAC_RRSR_HT) |
+		     SET_WORD(cfg->vht_cfg, B_AX_WMAC_RRSR_VHT) |
+		     SET_WORD(cfg->he_cfg, B_AX_WMAC_RRSR_HE);
+
+	// add fw offload later
+	if (cfg->band == MAC_AX_BAND_0) {
+		MAC_REG_W32(R_AX_TRXPTCL_RRSR_CTL_0, rrsr_ctl_0);
+		MAC_REG_W32(R_AX_TRXPTCL_RRSR_CTL_1, rrsr_ctl_1);
+	} else {
+		MAC_REG_W32(R_AX_TRXPTCL_RRSR_CTL_0_C1, rrsr_ctl_0);
+		MAC_REG_W32(R_AX_TRXPTCL_RRSR_CTL_1_C1, rrsr_ctl_1);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_cts_rrsr_cfg_8852b(struct mac_ax_adapter *adapter,
+			       struct mac_ax_cts_rrsr_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = check_mac_en(adapter, cfg->band, MAC_AX_CMAC_SEL);
+	if (val32 != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, cfg->band);
+		return val32;
+	}
+
+	val32 = MAC_REG_R32((cfg->band == MAC_AX_BAND_1) ?
+			    R_AX_TRXPTCL_CTS_RRSR_C1 : R_AX_TRXPTCL_CTS_RRSR);
+	cfg->cts_rrsr_rsc = GET_FIELD(val32, B_AX_WMAC_CTS_RRSR_RSC);
+	cfg->cts_rrsr_opt = ((val32 & B_AX_WMAC_CTS_RESP_OPT) != 0);
+	cfg->cts_rrsr_cck_cfg = GET_FIELD(val32, B_AX_WMAC_CTS_RRSR_CCK);
+	cfg->cts_rrsr_ofdm_cfg = GET_FIELD(val32, B_AX_WMAC_CTS_RRSR_OFDM);
+
+	return MACSUCCESS;
+}
+
+u32 mac_set_cts_rrsr_cfg_8852b(struct mac_ax_adapter *adapter,
+			       struct mac_ax_cts_rrsr_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = check_mac_en(adapter, cfg->band, MAC_AX_CMAC_SEL);
+	if (val32 != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, cfg->band);
+		return val32;
+	}
+
+	val32 = SET_WORD(cfg->cts_rrsr_rsc, B_AX_WMAC_CTS_RRSR_RSC) |
+		(cfg->cts_rrsr_opt ? B_AX_WMAC_CTS_RESP_OPT : 0) |
+		SET_WORD(cfg->cts_rrsr_cck_cfg, B_AX_WMAC_CTS_RRSR_CCK) |
+		SET_WORD(cfg->cts_rrsr_ofdm_cfg, B_AX_WMAC_CTS_RRSR_OFDM);
+
+	// add fw offload later
+	if (cfg->band == MAC_AX_BAND_0)
+		MAC_REG_W32(R_AX_TRXPTCL_CTS_RRSR, val32);
+	else
+		MAC_REG_W32(R_AX_TRXPTCL_CTS_RRSR_C1, val32);
+
+	return MACSUCCESS;
+}
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/rrsr_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/rrsr_8852b.h
new file mode 100644
index 000000000000..ca94c1926624
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/rrsr_8852b.h
@@ -0,0 +1,109 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_RRSR_H_
+#define _MAC_AX_RRSR_H_
+#include "../../type.h"
+#if MAC_AX_8852B_SUPPORT
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup RRSR
+ * @{
+ */
+/**
+ * @brief mac_get_rrsr_cfg_8852b
+ *
+ * @param *adapter
+ * @param *mac_ax_rrsr_cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_rrsr_cfg_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_rrsr_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup RRSR
+ * @{
+ */
+/**
+ * @brief mac_set_rrsr_cfg_8852b
+ *
+ * @param *adapter
+ * @param *mac_ax_rrsr_cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_rrsr_cfg_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_rrsr_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup RRSR
+ * @{
+ */
+/**
+ * @brief mac_get_cts_rrsr_cfg_8852b
+ *
+ * @param *adapter
+ * @param mac_ax_cts_rrsr_cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_get_cts_rrsr_cfg_8852b(struct mac_ax_adapter *adapter,
+			       struct mac_ax_cts_rrsr_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup RRSR
+ * @{
+ */
+/**
+ * @brief mac_set_cts_rrsr_cfg_8852b
+ *
+ * @param *adapter
+ * @param mac_ax_cts_rrsr_cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_cts_rrsr_cfg_8852b(struct mac_ax_adapter *adapter,
+			       struct mac_ax_cts_rrsr_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/tblupd_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/tblupd_8852b.c
new file mode 100644
index 000000000000..9fbfa1e1713f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/tblupd_8852b.c
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "tblupd_8852b.h"
+
+#if MAC_AX_8852B_SUPPORT
+u32 mac_init_cctl_info_8852b(struct mac_ax_adapter *adapter, u8 macid)
+{
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+	struct rtw_hal_mac_ax_cctl_info info = {0x0};
+	struct rtw_hal_mac_ax_cctl_info mask;
+
+	// dword0
+	info.datarate = MAC_AX_OFDM6;
+	// dword1
+	info.data_rty_lowest_rate = MAC_AX_OFDM6;
+	info.rtsrate = MAC_AX_OFDM48;
+	info.rts_rty_lowest_rate = MAC_AX_OFDM6;
+	// dword5
+	info.resp_ref_rate = MAC_AX_OFDM54;
+	info.ntx_path_en = CCTL_NTX_PATH_EN_8852B;
+	info.path_map_b = CCTL_PATH_MAP_B;
+	info.path_map_c = CCTL_PATH_MAP_C;
+	info.path_map_d = CCTL_PATH_MAP_D;
+	// dword6
+	info.nominal_pkt_padding = CCTRL_NOMINAL_PKT_PADDING_16;
+	info.nominal_pkt_padding40 = CCTRL_NOMINAL_PKT_PADDING_16;
+	info.nominal_pkt_padding80 = CCTRL_NOMINAL_PKT_PADDING_16;
+	// dword7
+	info.nc = CCTRL_NC;
+	info.nr = CCTRL_NR;
+	info.cb = CCTRL_CB;
+	info.csi_para_en = 0x1;
+	info.csi_fix_rate = MAC_AX_OFDM54;
+
+	PLTFM_MEMSET(&mask, 0xFF, sizeof(struct rtw_hal_mac_ax_cctl_info));
+
+	return mops->upd_cctl_info(adapter, &info, &mask, macid, 1);
+}
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/tblupd_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/tblupd_8852b.h
new file mode 100644
index 000000000000..843749304b42
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/tblupd_8852b.h
@@ -0,0 +1,60 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _TABLEUPD_H2C_8852B_H_
+#define _TABLEUPD_H2C_8852B_H_
+
+#include "../../type.h"
+#include "../fwcmd.h"
+#if MAC_AX_8852B_SUPPORT
+/*--------------------Define MACRO--------------------------------------*/
+#define CCTL_NTX_PATH_EN_8852B		3
+#define CCTL_PATH_MAP_B			1
+#define CCTL_PATH_MAP_C			2
+#define CCTL_PATH_MAP_D			3
+#define CCTRL_NC			1
+#define CCTRL_NR			1
+#define CCTRL_CB			1
+#define CCTRL_NOMINAL_PKT_PADDING_0	0
+#define CCTRL_NOMINAL_PKT_PADDING_8	1
+#define CCTRL_NOMINAL_PKT_PADDING_16	2
+
+/*--------------------Define Enum---------------------------------------*/
+
+/*--------------------Define Struct-------------------------------------*/
+
+/**
+ * @addtogroup Role
+ * @{
+ * @addtogroup init
+ * @{
+ */
+
+/**
+ * @brief mac_init_cctl_info_8852b
+ *
+ * @param *adapter
+ * @param *macid
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_init_cctl_info_8852b(struct mac_ax_adapter *adapter, u8 macid);
+/**
+ * @}
+ * @}
+ */
+#endif /* MAC_AX_8852B_SUPPORT  */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/trx_desc_8852b.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/trx_desc_8852b.c
new file mode 100644
index 000000000000..697c314ac769
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/trx_desc_8852b.c
@@ -0,0 +1,669 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "trx_desc_8852b.h"
+#if MAC_AX_8852B_SUPPORT
+
+#define RXD_RPKT_TYPE_INVALID	0xFF
+#define TXD_AC_TYPE_MSK		0x3
+#define TXD_TID_IND_SH		2
+#define TID_MAX_NUM		8
+
+#define TID_0_QSEL 0
+#define TID_1_QSEL 1
+#define TID_2_QSEL 1
+#define TID_3_QSEL 0
+#define TID_4_QSEL 2
+#define TID_5_QSEL 2
+#define TID_6_QSEL 3
+#define TID_7_QSEL 3
+#define TID_0_IND 0
+#define TID_1_IND 0
+#define TID_2_IND 1
+#define TID_3_IND 1
+#define TID_4_IND 0
+#define TID_5_IND 1
+#define TID_6_IND 0
+#define TID_7_IND 1
+
+#define WP_OFFSET_UNIT_8852B 0x1
+#define SEC_HDR_SIZE_4B 0x4
+#define SEC_HDR_SIZE_8B 0x8
+#define HDR_SIZE_WLAN_MAX 0x24
+#define HDR_SIZE_802P3 0xE
+#define HDR_SIZE_LLC 0x8
+#define HDR_SIZE_AMSDU 0xE
+
+enum wd_info_pkt_type {
+	WD_INFO_PKT_NORMAL,
+
+	/* keep last */
+	WD_INFO_PKT_LAST,
+	WD_INFO_PKT_MAX = WD_INFO_PKT_LAST,
+};
+
+static u8 qsel_l[TID_MAX_NUM] = {
+	TID_0_QSEL, TID_1_QSEL, TID_2_QSEL, TID_3_QSEL,
+	TID_4_QSEL, TID_5_QSEL, TID_6_QSEL, TID_7_QSEL
+};
+
+static u8 tid_ind[TID_MAX_NUM] = {
+	TID_0_IND, TID_1_IND, TID_2_IND, TID_3_IND,
+	TID_4_IND, TID_5_IND, TID_6_IND, TID_7_IND
+};
+
+u32 mac_wd_checksum_8852b(struct mac_ax_adapter *adapter,
+			  struct rtw_t_meta_data *info, u8 *wddesc);
+
+u32 mac_txdesc_len_8852b(struct mac_ax_adapter *adapter,
+			 struct rtw_t_meta_data *info)
+{
+	u32 len;
+	enum rtw_packet_type pkt_type = info->type;
+
+	len = WD_BODY_LEN;
+
+	if (pkt_type != RTW_PHL_PKT_TYPE_H2C &&
+	    pkt_type != RTW_PHL_PKT_TYPE_FWDL &&
+	    info->wdinfo_en != 0)
+		len += WD_INFO_LEN;
+
+	return len;
+}
+
+static u32 txdes_proc_h2c_fwdl_8852b(struct mac_ax_adapter *adapter,
+				     struct rtw_t_meta_data *info, u8 *buf, u32 len)
+{
+	struct wd_body_t *wdb;
+	u32 ret = MACSUCCESS;
+
+	if (len != mac_txdesc_len_8852b(adapter, info)) {
+		PLTFM_MSG_ERR("[ERR] illegal len %d\n", len);
+		return MACBUFSZ;
+	}
+
+	if (info->pktlen > AX_TXD_TXPKTSIZE_MSK || !info->pktlen) {
+		PLTFM_MSG_ERR("[ERR] illegal txpktsize %d\n", info->pktlen);
+		return MACFUNCINPUT;
+	}
+
+	wdb = (struct wd_body_t *)buf;
+	wdb->dword0 = cpu_to_le32(SET_WORD(MAC_AX_DMA_H2C, AX_TXD_CH_DMA) |
+			(info->type == RTW_PHL_PKT_TYPE_FWDL ? AX_TXD_FWDL_EN : 0));
+	wdb->dword1 = 0;
+	wdb->dword2 = cpu_to_le32(SET_WORD(info->pktlen, AX_TXD_TXPKTSIZE));
+	wdb->dword3 = 0;
+	wdb->dword4 = 0;
+	wdb->dword5 = 0;
+
+	if (adapter->hw_info->wd_checksum_en) {
+		ret = mac_wd_checksum_8852b(adapter, info, buf);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] mac_wd_checksum %d\n", ret);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+#if MAC_AX_FEATURE_HV
+static u32 txdes_proc_hv_8852b(struct mac_ax_adapter *adapter,
+			       struct rtw_t_meta_data *info,
+			       struct wd_body_t *wdb,
+			       struct wd_info_t *wdi)
+{
+	struct hv_txpkt_info *hv_info = (struct hv_txpkt_info *)info->mac_priv;
+
+	wdb->dword0 |= cpu_to_le32((hv_info->chk_en ? AX_TXD_CHK_EN : 0));
+	wdi->dword3 |=
+		cpu_to_le32((hv_info->null_1 ? AX_TXD_NULL_1 : 0) |
+			    (hv_info->null_0 ? AX_TXD_NULL_0 : 0) |
+			    (hv_info->tri_frame ? AX_TXD_TRI_FRAME : 0) |
+			    (hv_info->ht_data_snd ? AX_TXD_HT_DATA_SND : 0));
+	wdi->dword5 |= cpu_to_le32(SET_WORD(hv_info->ndpa_dur, AX_TXD_NDPA_DURATION));
+
+	return MACSUCCESS;
+}
+#endif
+
+static u32 txdes_proc_data_8852b(struct mac_ax_adapter *adapter,
+				 struct rtw_t_meta_data *info, u8 *buf, u32 len)
+{
+	struct wd_body_t *wdb;
+	struct wd_info_t *wdi;
+	u8 wd_info_tmpl[WD_INFO_PKT_MAX][24] = {{0}};
+	u32 ret;
+	u8 qsel, dbcc_wmm;
+
+	if (len != mac_txdesc_len_8852b(adapter, info)) {
+		PLTFM_MSG_ERR("[ERR] illegal len %d\n", len);
+		return MACBUFSZ;
+	}
+
+	if (info->dma_ch > MAC_AX_DATA_CH11) {
+		PLTFM_MSG_ERR("[ERR] txd ch %d illegal\n", info->dma_ch);
+		return MACTXCHDMA;
+	}
+
+	if (info->pktlen > AX_TXD_TXPKTSIZE_MSK || !info->pktlen) {
+		PLTFM_MSG_ERR("[ERR] illegal txpktsize %d\n", info->pktlen);
+		return MACFUNCINPUT;
+	}
+
+	wdb = (struct wd_body_t *)buf;
+	if (adapter->hw_info->intf == MAC_AX_INTF_SDIO) {
+		wdb->dword0 =
+			cpu_to_le32(AX_TXD_STF_MODE);
+	} else if (adapter->hw_info->intf == MAC_AX_INTF_USB) {
+		wdb->dword0 =
+			cpu_to_le32(AX_TXD_STF_MODE |
+				    (info->usb_pkt_ofst ?
+				     AX_TXD_PKT_OFFSET : 0));
+	} else if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+		wdb->dword0 =
+			cpu_to_le32((info->wd_page_size ? AX_TXD_WD_PAGE : 0) |
+				    (adapter->dle_info.qta_mode ==
+				     MAC_AX_QTA_SCC_STF ||
+				     adapter->dle_info.qta_mode ==
+				     MAC_AX_QTA_DBCC_STF ?
+				     AX_TXD_STF_MODE : 0));
+	} else {
+		PLTFM_MSG_ERR("[ERR] unknown intf %d\n",
+			      adapter->hw_info->intf);
+		return MACINTF;
+	}
+
+	wdb->dword0 |=
+		cpu_to_le32(SET_WORD(info->hw_seq_mode,
+				     AX_TXD_EN_HWSEQ_MODE) |
+			    SET_WORD(info->hw_ssn_sel,
+				     AX_TXD_HW_SSN_SEL) |
+			    SET_WORD(info->hdr_len,
+				     AX_TXD_HDR_LLC_LEN) |
+			    SET_WORD(info->dma_ch, AX_TXD_CH_DMA) |
+			    (info->hw_amsdu ? AX_TXD_HWAMSDU : 0) |
+			    (info->smh_en ? AX_TXD_SMH_EN : 0) |
+			    (info->hw_sec_iv ? AX_TXD_HW_AES_IV : 0) |
+			    (info->wdinfo_en ? AX_TXD_WDINFO_EN : 0) |
+			    SET_WORD(info->wp_offset,
+				     AX_TXD_WP_OFFSET));
+	wdb->dword1 =
+		cpu_to_le32(SET_WORD(info->shcut_camid, AX_TXD_SHCUT_CAMID));
+	/* Get bb and qsel from qsel by according MAC ID */
+	if (info->macid < DBCC_WMM_LIST_SIZE)
+		dbcc_wmm = *(adapter->dbcc_info->dbcc_wmm_list + info->macid);
+	else
+		dbcc_wmm = MAC_AX_DBCC_WMM_INVALID;
+
+	if (info->dma_ch == MAC_AX_DATA_CH9 || info->dma_ch == MAC_AX_DATA_CH11)
+		qsel = info->band ? MAC_AX_HI1_SEL : MAC_AX_HI0_SEL;
+	else if (dbcc_wmm != MAC_AX_DBCC_WMM_INVALID)
+		qsel = (dbcc_wmm << 2) | qsel_l[info->tid];
+	else
+		qsel = (info->band << 3) | (info->wmm << 2) | qsel_l[info->tid];
+	wdb->dword2 =
+		cpu_to_le32(SET_WORD(info->pktlen, AX_TXD_TXPKTSIZE) |
+			    SET_WORD(qsel, AX_TXD_QSEL) |
+			    (tid_ind[info->tid] ? AX_TXD_TID_IND : 0) |
+			    SET_WORD(info->macid, AX_TXD_MACID));
+
+	wdb->dword3 = cpu_to_le32(SET_WORD(info->sw_seq,
+					   AX_TXD_WIFI_SEQ) |
+				  (info->ampdu_en ? AX_TXD_AGG_EN : 0) |
+				  ((info->bk || info->ack_ch_info) ?
+				    AX_TXD_BK : 0));
+	wdb->dword4 = 0;
+	wdb->dword5 = 0;
+
+	wdi = (struct wd_info_t *)wd_info_tmpl[WD_INFO_PKT_NORMAL];
+	wdi->dword0 =
+		cpu_to_le32((info->userate_sel ? AX_TXD_USERATE_SEL : 0) |
+			     SET_WORD(info->f_rate, AX_TXD_DATARATE) |
+			     SET_WORD(info->f_bw, AX_TXD_DATA_BW) |
+			     (info->data_bw_er ? AX_TXD_DATA_BW_ER : 0) |
+			     SET_WORD(info->f_gi_ltf, AX_TXD_GI_LTF) |
+			     (info->f_er ? AX_TXD_DATA_ER : 0) |
+			     (info->f_dcm ? AX_TXD_DATA_DCM : 0) |
+			     (info->f_stbc ? AX_TXD_DATA_STBC : 0) |
+			     (info->f_ldpc ? AX_TXD_DATA_LDPC : 0) |
+			     (info->dis_data_rate_fb ? AX_TXD_DISDATAFB : 0) |
+			     (info->dis_rts_rate_fb ? AX_TXD_DISRTSFB : 0) |
+			     SET_WORD(info->hal_port,
+				      AX_TXD_MULTIPORT_ID) |
+			     SET_WORD(info->mbssid, AX_TXD_MBSSID) |
+			     (info->ack_ch_info ? AX_TXD_ACK_CH_INFO : 0));
+
+	if (info->max_agg_num > 0)
+		info->max_agg_num -= 1;
+
+	wdi->dword1 =
+		cpu_to_le32(SET_WORD(info->max_agg_num, AX_TXD_MAX_AGG_NUM) |
+			    SET_WORD(info->data_tx_cnt_lmt, AX_TXD_DATA_TXCNT_LMT) |
+			    (info->data_tx_cnt_lmt_en ?
+			     AX_TXD_DATA_TXCNT_LMT_SEL : 0) |
+			    (info->bc || info->mc ? AX_TXD_BMC : 0) |
+			    (info->nav_use_hdr ? AX_TXD_NAVUSEHDR : 0) |
+			    (info->bc || info->mc ? AX_TXD_BMC : 0) |
+			    (info->a_ctrl_uph ? AX_TXD_A_CTRL_UPH : 0) |
+			    (info->a_ctrl_bsr ? AX_TXD_A_CTRL_BSR : 0) |
+			    (info->a_ctrl_cas ? AX_TXD_A_CTRL_CAS : 0) |
+			    SET_WORD(info->data_rty_lowest_rate,
+				     AX_TXD_DATA_RTY_LOWEST_RATE));
+	wdi->dword2 =
+		cpu_to_le32(SET_WORD(info->life_time_sel, AX_TXD_LIFETIME_SEL) |
+				SET_WORD(info->sec_type, AX_TXD_SECTYPE) |
+			    (info->sec_hw_enc ? AX_TXD_SEC_HW_ENC : 0) |
+			    SET_WORD(info->sec_cam_idx, AX_TXD_SEC_CAM_IDX) |
+			    SET_WORD(info->ampdu_density,
+				     AX_TXD_AMPDU_DENSITY));
+
+	wdi->dword3 =
+		cpu_to_le32((info->sifs_tx ? AX_TXD_SIFS_TX : 0) |
+			    SET_WORD(info->ndpa, AX_TXD_NDPA) |
+			    SET_WORD(info->snd_pkt_sel, AX_TXD_SND_PKT_SEL) |
+			    (info->rtt_en ? AX_TXD_RTT_EN : 0) |
+			    (info->spe_rpt ? AX_TXD_SPE_RPT : 0));
+
+	wdi->dword4 =
+		cpu_to_le32((info->rts_en ? AX_TXD_RTS_EN : 0) |
+			    (info->cts2self ? AX_TXD_CTS2SELF : 0) |
+			    SET_WORD(info->rts_cca_mode, AX_TXD_CCA_RTS) |
+			    (info->hw_rts_en ? AX_TXD_HW_RTS_EN : 0) |
+			    SET_WORD(info->sw_define, AX_TXD_SW_DEFINE));
+
+	wdi->dword5 = 0;
+
+#if MAC_AX_FEATURE_HV
+	txdes_proc_hv_8852b(adapter, info, wdb, wdi);
+#endif
+	if (info->wdinfo_en)
+		PLTFM_MEMCPY(buf + WD_BODY_LEN, (u8 *)wdi, WD_INFO_LEN);
+
+	if (adapter->hw_info->wd_checksum_en) {
+		ret = mac_wd_checksum_8852b(adapter, info, buf);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] mac_wd_checksum %d\n", ret);
+			return ret;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 txdes_proc_mgnt_8852b(struct mac_ax_adapter *adapter,
+				 struct rtw_t_meta_data *info, u8 *buf, u32 len)
+{
+	struct wd_body_t *wdb;
+	struct wd_info_t *wdi;
+	u8 wd_info_tmpl[WD_INFO_PKT_MAX][24] = {{0}};
+	u32 ret;
+
+	if (len != mac_txdesc_len_8852b(adapter, info)) {
+		PLTFM_MSG_ERR("[ERR] illegal len %d\n", len);
+		return MACBUFSZ;
+	}
+
+	if (info->pktlen > AX_TXD_TXPKTSIZE_MSK || !info->pktlen) {
+		PLTFM_MSG_ERR("[ERR] illegal txpktsize %d\n", info->pktlen);
+		return MACFUNCINPUT;
+	}
+
+	wdb = (struct wd_body_t *)buf;
+	if (adapter->hw_info->intf == MAC_AX_INTF_SDIO) {
+		wdb->dword0 =
+			cpu_to_le32(AX_TXD_STF_MODE);
+	} else if (adapter->hw_info->intf == MAC_AX_INTF_USB) {
+		wdb->dword0 =
+			cpu_to_le32(AX_TXD_STF_MODE |
+				    (info->usb_pkt_ofst ?
+				     AX_TXD_PKT_OFFSET : 0));
+	} else if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+		wdb->dword0 =
+			cpu_to_le32((info->wd_page_size ? AX_TXD_WD_PAGE : 0) |
+				    (adapter->dle_info.qta_mode ==
+				     MAC_AX_QTA_SCC_STF ||
+				     adapter->dle_info.qta_mode ==
+				     MAC_AX_QTA_DBCC_STF ?
+				     AX_TXD_STF_MODE : 0));
+	} else {
+		PLTFM_MSG_ERR("[ERR] unknown intf %d\n",
+			      adapter->hw_info->intf);
+		return MACINTF;
+	}
+
+	wdb->dword0 |=
+		cpu_to_le32(SET_WORD(info->hw_seq_mode,
+				     AX_TXD_EN_HWSEQ_MODE) |
+			    SET_WORD(info->hw_ssn_sel,
+				     AX_TXD_HW_SSN_SEL) |
+			    SET_WORD(info->hdr_len,
+				     AX_TXD_HDR_LLC_LEN) |
+			    (info->wdinfo_en ? AX_TXD_WDINFO_EN : 0));
+
+	wdb->dword0 |=
+		cpu_to_le32(SET_WORD((info->band ?
+				       MAC_AX_DMA_B1MG :
+				       MAC_AX_DMA_B0MG),
+				       AX_TXD_CH_DMA));
+
+	wdb->dword1 = 0;
+	/* Get bb and qsel from qsel by according MAC ID */
+	wdb->dword2 =
+		cpu_to_le32(SET_WORD(info->pktlen, AX_TXD_TXPKTSIZE) |
+			    SET_WORD((info->band ?
+				      MAC_AX_MG1_SEL : MAC_AX_MG0_SEL),
+				     AX_TXD_QSEL) |
+				     SET_WORD(info->macid, AX_TXD_MACID));
+	wdb->dword3 = cpu_to_le32(SET_WORD(info->sw_seq,
+					   AX_TXD_WIFI_SEQ) |
+				 (info->bk ? AX_TXD_BK : 0));
+	wdb->dword4 = 0;
+	wdb->dword5 = 0;
+
+	wdi = (struct wd_info_t *)wd_info_tmpl[WD_INFO_PKT_NORMAL];
+	wdi->dword0 =
+		cpu_to_le32((info->userate_sel ? AX_TXD_USERATE_SEL : 0) |
+			    SET_WORD(info->f_rate, AX_TXD_DATARATE) |
+			    SET_WORD(info->f_bw, AX_TXD_DATA_BW) |
+			    (info->data_bw_er ? AX_TXD_DATA_BW_ER : 0) |
+			    SET_WORD(info->f_gi_ltf, AX_TXD_GI_LTF) |
+			    (info->f_er ? AX_TXD_DATA_ER : 0) |
+			    (info->f_dcm ? AX_TXD_DATA_DCM : 0) |
+			    (info->f_stbc ? AX_TXD_DATA_STBC : 0) |
+			    (info->f_ldpc ? AX_TXD_DATA_LDPC : 0) |
+			    (info->dis_data_rate_fb ? AX_TXD_DISDATAFB : 0) |
+			    (info->dis_rts_rate_fb ? AX_TXD_DISRTSFB : 0) |
+			    SET_WORD(info->hal_port, AX_TXD_MULTIPORT_ID) |
+			    SET_WORD(info->mbssid, AX_TXD_MBSSID));
+
+	if (info->max_agg_num > 0)
+		info->max_agg_num -= 1;
+
+	wdi->dword1 =
+		cpu_to_le32(SET_WORD(info->max_agg_num, AX_TXD_MAX_AGG_NUM) |
+			    SET_WORD(info->data_tx_cnt_lmt, AX_TXD_DATA_TXCNT_LMT) |
+			    (info->data_tx_cnt_lmt_en ?
+			     AX_TXD_DATA_TXCNT_LMT_SEL : 0) |
+			    (info->bc || info->mc ? AX_TXD_BMC : 0) |
+			    (info->nav_use_hdr ? AX_TXD_NAVUSEHDR : 0));
+	wdi->dword2 =
+		cpu_to_le32(SET_WORD(info->life_time_sel, AX_TXD_LIFETIME_SEL) |
+			    SET_WORD(info->sec_type, AX_TXD_SECTYPE) |
+			    (info->sec_hw_enc ? AX_TXD_SEC_HW_ENC : 0) |
+			    SET_WORD(info->sec_cam_idx, AX_TXD_SEC_CAM_IDX) |
+			    SET_WORD(info->ampdu_density,
+				     AX_TXD_AMPDU_DENSITY));
+
+	wdi->dword3 =
+	    cpu_to_le32((info->sifs_tx ? AX_TXD_SIFS_TX : 0) |
+			    SET_WORD(info->ndpa, AX_TXD_NDPA) |
+			    SET_WORD(info->snd_pkt_sel, AX_TXD_SND_PKT_SEL) |
+			    (info->rtt_en ? AX_TXD_RTT_EN : 0) |
+			    (info->spe_rpt ? AX_TXD_SPE_RPT : 0));
+
+	wdi->dword4 =
+		cpu_to_le32((info->rts_en ? AX_TXD_RTS_EN : 0) |
+			    (info->cts2self ? AX_TXD_CTS2SELF : 0) |
+			    SET_WORD(info->rts_cca_mode, AX_TXD_CCA_RTS) |
+			    (info->hw_rts_en ? AX_TXD_HW_RTS_EN : 0) |
+			    SET_WORD(info->sw_define, AX_TXD_SW_DEFINE));
+
+	wdi->dword5 = 0;
+
+#if MAC_AX_FEATURE_HV
+	txdes_proc_hv_8852b(adapter, info, wdb, wdi);
+#endif
+	if (info->wdinfo_en)
+		PLTFM_MEMCPY(buf + WD_BODY_LEN, (u8 *)wdi, WD_INFO_LEN);
+
+	if (adapter->hw_info->wd_checksum_en) {
+		ret = mac_wd_checksum_8852b(adapter, info, buf);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] mac_wd_checksum %d\n", ret);
+			return ret;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+static struct txd_proc_type txdes_proc_mac_8852b[] = {
+	{RTW_PHL_PKT_TYPE_H2C, txdes_proc_h2c_fwdl_8852b},
+	{RTW_PHL_PKT_TYPE_FWDL, txdes_proc_h2c_fwdl_8852b},
+	{RTW_PHL_PKT_TYPE_DATA, txdes_proc_data_8852b},
+	{RTW_PHL_PKT_TYPE_MGNT, txdes_proc_mgnt_8852b},
+	{RTW_PHL_PKT_TYPE_MAX, NULL},
+};
+
+u32 mac_build_txdesc_8852b(struct mac_ax_adapter *adapter,
+			   struct rtw_t_meta_data *info, u8 *buf, u32 len)
+{
+	struct txd_proc_type *proc = txdes_proc_mac_8852b;
+	enum rtw_packet_type pkt_type = info->type;
+	u32 (*handler)(struct mac_ax_adapter *adapter,
+		       struct rtw_t_meta_data *info, u8 *buf, u32 len) = NULL;
+
+	for (; proc->type != RTW_PHL_PKT_TYPE_MAX; proc++) {
+		if (pkt_type == proc->type) {
+			handler = proc->handler;
+			break;
+		}
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]null type handler type: %X\n", proc->type);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, info, buf, len);
+}
+
+u32 mac_refill_txdesc_8852b(struct mac_ax_adapter *adapter,
+			    struct rtw_t_meta_data *txpkt_info,
+			    struct mac_ax_refill_info *mask,
+			    struct mac_ax_refill_info *info)
+{
+	u32 dw0 = ((struct wd_body_t *)info->pkt)->dword0;
+	u32 dw1 = ((struct wd_body_t *)info->pkt)->dword1;
+	u32 ret;
+
+	if (mask->packet_offset)
+		((struct wd_body_t *)info->pkt)->dword0 =
+			dw0 | (info->packet_offset ? AX_TXD_PKT_OFFSET : 0);
+
+	if (mask->agg_num == AX_TXD_DMA_TXAGG_NUM_MSK)
+		((struct wd_body_t *)info->pkt)->dword1 =
+			SET_CLR_WORD(dw1, info->agg_num, AX_TXD_DMA_TXAGG_NUM);
+
+	if (adapter->hw_info->wd_checksum_en) {
+		ret = mac_wd_checksum_8852b(adapter, txpkt_info, info->pkt);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] mac_wd_checksum %d\n", ret);
+			return ret;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 rxdes_parse_comm_8852b(struct mac_ax_adapter *adapter,
+				  struct mac_ax_rxpkt_info *info, u8 *buf)
+{
+	u32 hdr_val = le32_to_cpu(((struct rxd_short_t *)buf)->dword0);
+
+	info->rxdlen = hdr_val & AX_RXD_LONG_RXD ? RXD_LONG_LEN : RXD_SHORT_LEN;
+	info->pktsize = GET_FIELD(hdr_val, AX_RXD_RPKT_LEN);
+	info->shift = (u8)GET_FIELD(hdr_val, AX_RXD_SHIFT);
+	info->drvsize = (u8)GET_FIELD(hdr_val, AX_RXD_DRV_INFO_SIZE);
+
+	return MACSUCCESS;
+}
+
+static u32 rxdes_parse_wifi_8852b(struct mac_ax_adapter *adapter,
+				  struct mac_ax_rxpkt_info *info, u8 *buf, u32 len)
+{
+	u32 hdr_val;
+
+	info->type = MAC_AX_PKT_DATA;
+
+	hdr_val = le32_to_cpu(((struct rxd_short_t *)buf)->dword3);
+	info->u.data.crc_err = !!(hdr_val & AX_RXD_CRC32_ERR);
+	info->u.data.icv_err = !!(hdr_val & AX_RXD_ICV_ERR);
+
+	return MACSUCCESS;
+}
+
+static u32 rxdes_parse_c2h_8852b(struct mac_ax_adapter *adapter,
+				 struct mac_ax_rxpkt_info *info, u8 *buf, u32 len)
+{
+	info->type = MAC_AX_PKT_C2H;
+
+	return MACSUCCESS;
+}
+
+static u32 rxdes_parse_ch_info_8852b(struct mac_ax_adapter *adapter,
+				     struct mac_ax_rxpkt_info *info, u8 *buf, u32 len)
+{
+	info->type = MAC_AX_PKT_CH_INFO;
+
+	return MACSUCCESS;
+}
+
+static u32 rxdes_parse_dfs_8852b(struct mac_ax_adapter *adapter,
+				 struct mac_ax_rxpkt_info *info, u8 *buf, u32 len)
+{
+	info->type = MAC_AX_PKT_DFS;
+
+	return MACSUCCESS;
+}
+
+static u32 rxdes_parse_ppdu_8852b(struct mac_ax_adapter *adapter,
+				  struct mac_ax_rxpkt_info *info, u8 *buf, u32 len)
+{
+	u32 hdr_val = le32_to_cpu(((struct rxd_short_t *)buf)->dword0);
+
+	info->type = MAC_AX_PKT_PPDU;
+	info->u.ppdu.mac_info = !!(hdr_val & AX_RXD_MAC_INFO_VLD);
+
+	return MACSUCCESS;
+}
+
+static struct rxd_parse_type rxdes_parse_mac_8852b[] = {
+	{RXD_S_RPKT_TYPE_WIFI, rxdes_parse_wifi_8852b},
+	{RXD_S_RPKT_TYPE_C2H, rxdes_parse_c2h_8852b},
+	{RXD_S_RPKT_TYPE_PPDU, rxdes_parse_ppdu_8852b},
+	{RXD_S_RPKT_TYPE_CH_INFO, rxdes_parse_ch_info_8852b},
+	{RXD_S_RPKT_TYPE_DFS_RPT, rxdes_parse_dfs_8852b},
+	{RXD_RPKT_TYPE_INVALID, NULL},
+};
+
+u32 mac_parse_rxdesc_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_rxpkt_info *info, u8 *buf, u32 len)
+{
+	struct rxd_parse_type *parse = rxdes_parse_mac_8852b;
+	u8 rpkt_type;
+	u32 hdr_val;
+	u32 (*handler)(struct mac_ax_adapter *adapter,
+		       struct mac_ax_rxpkt_info *info, u8 *buf, u32 len) = NULL;
+
+	hdr_val = le32_to_cpu(((struct rxd_short_t *)buf)->dword0);
+	rpkt_type = (u8)GET_FIELD(hdr_val, AX_RXD_RPKT_TYPE);
+
+	rxdes_parse_comm_8852b(adapter, info, buf);
+
+	for (; parse->type != RXD_RPKT_TYPE_INVALID; parse++) {
+		if (rpkt_type == parse->type) {
+			handler = parse->handler;
+			break;
+		}
+	}
+
+	if (!handler) {
+		PLTFM_MSG_ERR("[ERR]null type handler type: %X\n", parse->type);
+		return MACNOITEM;
+	}
+
+	return handler(adapter, info, buf, len);
+}
+
+u32 mac_wd_checksum_8852b(struct mac_ax_adapter *adapter,
+			  struct rtw_t_meta_data *info, u8 *wddesc)
+{
+	u16 chksum = 0;
+	u32 wddesc_size;
+	u16 *data;
+	u32 i, dw4;
+
+	if (!wddesc) {
+		PLTFM_MSG_ERR("[ERR]null pointer\n");
+		return MACNPTR;
+	}
+
+	if (adapter->hw_info->wd_checksum_en != 1)
+		PLTFM_MSG_TRACE("[TRACE]chksum disable\n");
+
+	dw4 = ((struct wd_body_t *)wddesc)->dword4;
+
+	((struct wd_body_t *)wddesc)->dword4 =
+		SET_CLR_WORD(dw4, 0x0, AX_TXD_TXDESC_CHECKSUM);
+
+	data = (u16 *)(wddesc);
+	/*unit : 4 bytes*/
+	wddesc_size = mac_txdesc_len_8852b(adapter, info) >> 2;
+	for (i = 0; i < wddesc_size; i++)
+		chksum ^= (*(data + 2 * i) ^ *(data + (2 * i + 1)));
+
+	/* *(data + 2 * i) & *(data + (2 * i + 1) have endain issue*/
+	/* Process eniadn issue after checksum calculation */
+	((struct wd_body_t *)wddesc)->dword4 =
+		SET_CLR_WORD(dw4, (u16)(chksum), AX_TXD_TXDESC_CHECKSUM);
+	return MACSUCCESS;
+}
+
+u32 mac_patch_rx_rate_8852b(struct mac_ax_adapter *adapter,
+			    struct rtw_r_meta_data *info)
+{
+	return MACSUCCESS;
+}
+
+u32 mac_get_wp_offset_8852b(struct mac_ax_adapter *adapter,
+			    struct mac_txd_ofld_wp_offset *ofld_conf, u16 *val)
+{
+	u16 ret_val = 0;
+
+	if (ofld_conf->hw_amsdu_type == MAC_TXD_OFLD_HW_AMSDU_CONF_MISSING) {
+		PLTFM_MSG_ERR("missing configurations: HW AMSDU type\n");
+		return MACFUNCINPUT;
+	}
+	if (ofld_conf->hw_hdr_conv_type == MAC_TXD_OFLD_HW_HDR_CONV_CONF_MISSING) {
+		PLTFM_MSG_ERR("missing configurations: HW HDR CONV type\n");
+		return MACFUNCINPUT;
+	}
+
+	if (ofld_conf->hw_hdr_conv_type == MAC_TXD_OFLD_HW_HDR_CONV_ETHII_TO_WLAN)
+		ret_val += (HDR_SIZE_WLAN_MAX + HDR_SIZE_LLC - HDR_SIZE_802P3);
+	else if (ofld_conf->hw_hdr_conv_type == MAC_TXD_OFLD_HW_HDR_CONV_SNAP_TO_WLAN)
+		ret_val += (HDR_SIZE_WLAN_MAX - HDR_SIZE_802P3);
+
+	if (ofld_conf->hw_amsdu_type == MAC_TXD_OFLD_HW_AMSDU_ON)
+		ret_val += HDR_SIZE_AMSDU;
+
+	*val = (ret_val / WP_OFFSET_UNIT_8852B);
+
+	return MACSUCCESS;
+}
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/trx_desc_8852b.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/trx_desc_8852b.h
new file mode 100644
index 000000000000..69af97e7de0d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_8852b/trx_desc_8852b.h
@@ -0,0 +1,181 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_TRX_DESC_8852B_H_
+#define _MAC_AX_TRX_DESC_8852B_H_
+
+#include "../../type.h"
+#include "../role.h"
+#if MAC_AX_8852B_SUPPORT
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+/**
+ * @brief mac_txdesc_len_8852b
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_txdesc_len_8852b(struct mac_ax_adapter *adapter,
+			 struct rtw_t_meta_data *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_build_txdesc_8852b
+ *
+ * @param *adapter
+ * @param *info
+ * @param *buf
+ * @param len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_build_txdesc_8852b(struct mac_ax_adapter *adapter,
+			   struct rtw_t_meta_data *info, u8 *buf, u32 len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_refill_txdesc_8852b
+ *
+ * @param *adapter
+ * @param *txpkt_info
+ * @param *mask
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_refill_txdesc_8852b(struct mac_ax_adapter *adapter,
+			    struct rtw_t_meta_data *txpkt_info,
+			    struct mac_ax_refill_info *mask,
+			    struct mac_ax_refill_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_parse_rxdesc_8852b
+ *
+ * @param *adapter
+ * @param *info
+ * @param *buf
+ * @param len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_parse_rxdesc_8852b(struct mac_ax_adapter *adapter,
+			   struct mac_ax_rxpkt_info *info, u8 *buf, u32 len);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_wd_checksum_8852b
+ *
+ * @param *adapter
+ * @param *info
+ * @param *wddesc
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_wd_checksum_8852b(struct mac_ax_adapter *adapter,
+			  struct rtw_t_meta_data *info, u8 *wddesc);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_patch_rx_rate_8852b
+ *
+ * @param *adapter
+ * @param *rtw_r_meta_data
+ * @return For RMAC rate patch func
+ * @retval u32
+ */
+u32 mac_patch_rx_rate_8852b(struct mac_ax_adapter *adapter,
+			    struct rtw_r_meta_data *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_get_wp_offset_8852b
+ *
+ * @param *adapter
+ * @param *ofld_conf
+ * @param *val
+ * @return error code
+ * @retval u32
+ */
+u32 mac_get_wp_offset_8852b(struct mac_ax_adapter *adapter,
+			    struct mac_txd_ofld_wp_offset *ofld_conf, u16 *val);
+/**
+ * @}
+ * @}
+ */
+
+#endif /* #if MAC_AX_8852B_SUPPORT */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_ax_dfs.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_ax_dfs.h
new file mode 100644
index 000000000000..e7df7abb8307
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_ax_dfs.h
@@ -0,0 +1,28 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_DFS_H_
+#define _MAC_AX_DFS_H_
+
+/* dword0 */
+#define AX_DFS_DROP_NUM_SH		0
+#define AX_DFS_DROP_NUM_MSK		0xffff
+#define AX_DFS_MAX_CONT_DROP_SH		16
+#define AX_DFS_MAX_CONT_DROP_MSK		0xff
+#define AX_DFS_TOTAL_DROP_SH		24
+#define AX_DFS_TOTAL_DROP_MSK		0xff
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_ax_mac_info.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_ax_mac_info.h
new file mode 100644
index 000000000000..4835eaa2b725
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_ax_mac_info.h
@@ -0,0 +1,47 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_MAC_INFO_H_
+#define _MAC_AX_MAC_INFO_H_
+
+/* dword0 */
+#define AX_MAC_INFO_USR_NUM_SH		0
+#define AX_MAC_INFO_USR_NUM_MSK		0xf
+#define AX_MAC_INFO_FW_DEFINE_SH		8
+#define AX_MAC_INFO_FW_DEFINE_MSK		0xff
+#define AX_MAC_INFO_LSIG_LEN_SH		16
+#define AX_MAC_INFO_LSIG_LEN_MSK		0xfff
+#define AX_MAC_INFO_IS_TO_SELF		BIT(28)
+#define AX_MAC_INFO_RX_CNT_VLD		BIT(29)
+#define AX_MAC_INFO_LONG_RXD_SH		30
+#define AX_MAC_INFO_LONG_RXD_MSK		0x3
+
+/* dword1 */
+#define AX_MAC_INFO_SERVICE_SH		0
+#define AX_MAC_INFO_SERVICE_MSK		0xffff
+#define AX_MAC_INFO_PLCP_LEN_SH		16
+#define AX_MAC_INFO_PLCP_LEN_MSK		0xff
+
+/* dword2 */
+#define AX_MAC_INFO_MAC_ID_VALID		BIT(0)
+#define AX_MAC_INFO_HAS_DATA		BIT(1)
+#define AX_MAC_INFO_HAS_CTRL		BIT(2)
+#define AX_MAC_INFO_HAS_MGNT		BIT(3)
+#define AX_MAC_INFO_HAS_BCN		BIT(4)
+#define AX_MAC_INFO_MACID_SH		8
+#define AX_MAC_INFO_MACID_MSK		0xff
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_priv.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_priv.c
new file mode 100644
index 000000000000..bd919a63698e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_priv.c
@@ -0,0 +1,90 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "mac_priv.h"
+#if MAC_AX_8192XB_SUPPORT
+#include "mac_8192xb/mac_priv_8192xb.h"
+#endif
+#if MAC_AX_8852A_SUPPORT
+#include "mac_8852a/mac_priv_8852a.h"
+#endif
+#if MAC_AX_8852B_SUPPORT
+#include "mac_8852b/mac_priv_8852b.h"
+#endif
+#if MAC_AX_8852C_SUPPORT
+#include "mac_8852c/mac_priv_8852c.h"
+#endif
+#if MAC_AX_8851B_SUPPORT
+#include "mac_8851b/mac_priv_8851b.h"
+#endif
+#if MAC_AX_8851E_SUPPORT
+#include "mac_8851e/mac_priv_8851e.h"
+#endif
+#if MAC_AX_8852D_SUPPORT
+#include "mac_8852d/mac_priv_8852d.h"
+#endif
+
+u32 get_mac_ax_priv_size(void)
+{
+	return sizeof(struct mac_ax_priv_ops *);
+}
+
+struct mac_ax_priv_ops *mac_ax_get_priv_ops(struct mac_ax_adapter *adapter,
+					    enum mac_ax_intf intf)
+{
+	struct mac_ax_priv_ops *priv_ops = NULL;
+
+	switch (adapter->hw_info->chip_id) {
+#if MAC_AX_8852A_SUPPORT
+	case MAC_AX_CHIP_ID_8852A:
+		priv_ops = get_mac_8852a_priv_ops(intf);
+		break;
+#endif
+#if MAC_AX_8852B_SUPPORT
+	case MAC_AX_CHIP_ID_8852B:
+		priv_ops = get_mac_8852b_priv_ops(intf);
+		break;
+#endif
+#if MAC_AX_8852C_SUPPORT
+	case MAC_AX_CHIP_ID_8852C:
+		priv_ops = get_mac_8852c_priv_ops(intf);
+		break;
+#endif
+#if MAC_AX_8192XB_SUPPORT
+	case MAC_AX_CHIP_ID_8192XB:
+		priv_ops = get_mac_8192xb_priv_ops(intf);
+		break;
+#endif
+#if MAC_AX_8851B_SUPPORT
+	case MAC_AX_CHIP_ID_8851B:
+		priv_ops = get_mac_8851b_priv_ops(intf);
+		break;
+#endif
+#if MAC_AX_8851E_SUPPORT
+	case MAC_AX_CHIP_ID_8851E:
+		priv_ops = get_mac_8851e_priv_ops(intf);
+		break;
+#endif
+#if MAC_AX_8852D_SUPPORT
+	case MAC_AX_CHIP_ID_8852D:
+		priv_ops = get_mac_8852d_priv_ops(intf);
+		break;
+#endif
+	default:
+		return NULL;
+	}
+
+	return priv_ops;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_priv.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_priv.h
new file mode 100644
index 000000000000..f43da63d5ac0
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mac_priv.h
@@ -0,0 +1,256 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_MAC_PRIV_H_
+#define _MAC_AX_MAC_PRIV_H_
+
+#include "../mac_def.h"
+#include "cmac_tx.h"
+#if MAC_AX_SDIO_SUPPORT
+#include "_sdio.h"
+#endif
+
+#define get_priv(adapter) \
+	((struct mac_ax_priv_ops **)(((struct mac_ax_adapter *)(adapter) + 1)))
+
+#define adapter_to_priv_ops(adapter) \
+	(*(get_priv(adapter)))
+
+struct mac_ax_pcie_desa {
+	u32 high;
+	u32 low;
+};
+
+struct mac_ax_pcie_bd_desa_offset {
+	struct mac_ax_pcie_desa ach0;
+	struct mac_ax_pcie_desa ach1;
+	struct mac_ax_pcie_desa ach2;
+	struct mac_ax_pcie_desa ach3;
+	struct mac_ax_pcie_desa ach4;
+	struct mac_ax_pcie_desa ach5;
+	struct mac_ax_pcie_desa ach6;
+	struct mac_ax_pcie_desa ach7;
+	struct mac_ax_pcie_desa b0mg;
+	struct mac_ax_pcie_desa b0hi;
+	struct mac_ax_pcie_desa b1mg;
+	struct mac_ax_pcie_desa b1hi;
+	struct mac_ax_pcie_desa h2c;
+	struct mac_ax_pcie_desa rxq;
+	struct mac_ax_pcie_desa rpq;
+};
+
+struct mac_ax_h2creg_offset {
+	u32 data0;
+	u32 data1;
+	u32 data2;
+	u32 data3;
+	u32 ctrl;
+};
+
+struct mac_ax_c2hreg_offset {
+	u32 data0;
+	u32 data1;
+	u32 data2;
+	u32 data3;
+	u32 ctrl;
+};
+
+struct mac_ax_priv_ops {
+	/*init*/
+	u32 (*pwr_off)(struct mac_ax_adapter *adapter);
+	u32 (*pwr_on)(struct mac_ax_adapter *adapter);
+	u32 (*intf_pwr_switch)(void *vadapter,
+			       u8 pre_switch, u8 on);
+	u32 (*dmac_func_en)(struct mac_ax_adapter *adapter);
+	u32 (*dmac_func_pre_en)(struct mac_ax_adapter *adapter);
+	/*CMAC*/
+	u32 (*init_cctl_info)(struct mac_ax_adapter *adapter, u8 macid);
+	u32 (*cmac_init)(struct mac_ax_adapter *adapter,
+			 struct mac_ax_trx_info *info, enum mac_ax_band band);
+	u32 (*cmac_func_en)(struct mac_ax_adapter *adapter, u8 band, u8 en);
+	u32 (*macid_idle_ck)(struct mac_ax_adapter *adapter,
+			     struct mac_role_tbl *role);
+	u32 (*stop_sch_tx)(struct mac_ax_adapter *adapter, enum sch_tx_sel sel,
+			   struct mac_ax_sch_tx_en_cfg *bak);
+	/*EFUSE*/
+	u32 (*switch_efuse_bank)(struct mac_ax_adapter *adapter,
+				 enum mac_ax_efuse_bank bank);
+	void (*enable_efuse_sw_pwr_cut)(struct mac_ax_adapter *adapter,
+					bool is_write);
+	void (*disable_efuse_sw_pwr_cut)(struct mac_ax_adapter *adapter,
+					 bool is_write);
+	/*H2C*/
+	struct mac_ax_h2creg_offset *
+	(*get_h2creg_offset)(struct mac_ax_adapter *adapter);
+	struct mac_ax_c2hreg_offset *
+	(*get_c2hreg_offset)(struct mac_ax_adapter *adapter);
+	u32 (*ser_imr_config)(struct mac_ax_adapter *adapter, u8 band,
+			      enum mac_ax_hwmod_sel sel);
+	u32 (*disconnect_flush_key)(struct mac_ax_adapter *adapter,
+				    struct mac_role_tbl *role);
+	u32 (*sec_info_tbl_init)(struct mac_ax_adapter *adapter);
+	u32 (*free_sec_info_tbl)(struct mac_ax_adapter *adapter);
+	u32 (*mac_wowlan_secinfo)(struct mac_ax_adapter *adapter,
+				  struct mac_ax_sec_iv_info *sec_iv_info);
+	u32 (*get_rrsr_cfg)(struct mac_ax_adapter *adapter,
+			    struct mac_ax_rrsr_cfg *cfg);
+	u32 (*set_rrsr_cfg)(struct mac_ax_adapter *adapter,
+			    struct mac_ax_rrsr_cfg *cfg);
+	u32 (*get_cts_rrsr_cfg)(struct mac_ax_adapter *adapter,
+				struct mac_ax_cts_rrsr_cfg *cfg);
+	u32 (*set_cts_rrsr_cfg)(struct mac_ax_adapter *adapter,
+				struct mac_ax_cts_rrsr_cfg *cfg);
+	u32 (*cfg_gnt)(struct mac_ax_adapter *adapter,
+		       struct mac_ax_coex_gnt *gnt);
+	u32 (*cfg_ctrl_path)(struct mac_ax_adapter *adapter, u32 wl);
+	u32 (*get_gnt)(struct mac_ax_adapter *adapter,
+		       struct mac_ax_coex_gnt *gnt);
+	u32 (*get_ctrl_path)(struct mac_ax_adapter *adapter, u32 *wl);
+	u32 (*get_bbrpt_dle_cfg)(struct mac_ax_adapter *adapter,
+				 u8 is_wlan_cpu, u32 *port_id, u32 *queue_id);
+	u32 (*dbg_port_sel)(struct mac_ax_adapter *adapter,
+			    struct mac_ax_dbg_port_info **info, u32 sel);
+	u32 (*tx_flow_ptcl_dbg_port)(struct mac_ax_adapter *adapter, u8 band);
+	u32 (*tx_flow_sch_dbg_port)(struct mac_ax_adapter *adapter, u8 band);
+	u32 (*ss_stat_chk)(struct mac_ax_adapter *adapter);
+	/* Debug Dump*/
+	u32 (*dmac_dbg_dump)(struct mac_ax_adapter *adapter);
+	u32 (*cmac_dbg_dump)(struct mac_ax_adapter *adapter, enum mac_ax_band band);
+	u32 (*crit_dbg_dump)(struct mac_ax_adapter *adapter);
+	u32 (*tx_dbg_dump)(struct mac_ax_adapter *adapter);
+	u32 (*coex_mac_init)(struct mac_ax_adapter *adapter);
+	u32 (*set_fc_page_ctrl_reg)(struct mac_ax_adapter *adapter, u8 ch);
+	u32 (*get_fc_page_info)(struct mac_ax_adapter *adapter, u8 ch);
+	u32 (*set_fc_pubpg)(struct mac_ax_adapter *adapter);
+	u32 (*get_fc_mix_info)(struct mac_ax_adapter *adapter);
+	u32 (*set_fc_h2c)(struct mac_ax_adapter *adapter);
+	u32 (*set_fc_mix_cfg)(struct mac_ax_adapter *adapter);
+	u32 (*set_fc_func_en)(struct mac_ax_adapter *adapter, u8 en, u8 h2c_en);
+	u32 (*dle_dfi_ctrl)(struct mac_ax_adapter *adapter, struct dle_dfi_ctrl_t *ctrl_p);
+	u32 (*dle_is_txq_empty)(struct mac_ax_adapter *adapter, u8 *val);
+	u32 (*dle_is_rxq_empty)(struct mac_ax_adapter *adapter, u8 *val);
+	u32 (*preload_cfg_set)(struct mac_ax_adapter *adapter, enum mac_ax_band band,
+			       struct mac_ax_preld_cfg *cfg);
+	u32 (*preload_init_set)(struct mac_ax_adapter *adapter, enum mac_ax_band band,
+				enum mac_ax_qta_mode mode);
+	u32 (*dle_func_en)(struct mac_ax_adapter *adapter, u8 en);
+	u32 (*dle_clk_en)(struct mac_ax_adapter *adapter, u8 en);
+	u32 (*dle_mix_cfg)(struct mac_ax_adapter *adapter, struct dle_mem_t *cfg);
+	u32 (*wde_quota_cfg)(struct mac_ax_adapter *adapter,
+			     struct wde_quota_t *min_cfg,
+			     struct wde_quota_t *max_cfg);
+	u32 (*ple_quota_cfg)(struct mac_ax_adapter *adapter,
+			     struct ple_quota_t *min_cfg,
+			     struct ple_quota_t *max_cfg);
+	u32 (*chk_dle_rdy)(struct mac_ax_adapter *adapter, enum DLE_CTRL_TYPE type);
+	u8 (*is_dbg_port_not_valid)(struct mac_ax_adapter *adapter, u32 dbg_sel);
+	u32 (*dbg_port_sel_rst)(struct mac_ax_adapter *adapter, u32 sel);
+	u32 (*dle_dfi_sel)(struct mac_ax_adapter *adapter,
+			   struct mac_ax_dle_dfi_info **info,
+			   u32 *target, u32 sel);
+	u32 (*bacam_init)(struct mac_ax_adapter *adapter);
+#if MAC_AX_PCIE_SUPPORT
+	struct mac_ax_intf_info *
+	(*get_pcie_info_def)(struct mac_ax_adapter *adapter);
+	struct txbd_ram *
+	(*get_bdram_tbl_pcie)(struct mac_ax_adapter *adapter);
+	u32 (*mio_w32_pcie)(struct mac_ax_adapter *adapter, u16 addr, u32 value);
+	u32 (*mio_r32_pcie)(struct mac_ax_adapter *adapter, u16 addr, u32 *val);
+	u32 (*get_txbd_reg_pcie)(struct mac_ax_adapter *adapter, u8 dma_ch, u32 *reg,
+				 enum pcie_bd_ctrl_type type);
+	u32 (*set_txbd_reg_pcie)(struct mac_ax_adapter *adapter, u8 dma_ch,
+				 enum pcie_bd_ctrl_type type, u32 val0, u32 val1, u32 val2);
+	u32 (*get_rxbd_reg_pcie)(struct mac_ax_adapter *adapter, u8 dma_ch, u32 *reg,
+				 enum pcie_bd_ctrl_type type);
+	u32 (*set_rxbd_reg_pcie)(struct mac_ax_adapter *adapter, u8 dma_ch,
+				 enum pcie_bd_ctrl_type type, u32 val0, u32 val1, u32 val2);
+	u32 (*ltr_sw_trigger)(struct mac_ax_adapter *adapter,
+			      enum mac_ax_pcie_ltr_sw_ctrl ctrl);
+	u32 (*pcie_cfgspc_write)(struct mac_ax_adapter *adapter,
+				 struct mac_ax_pcie_cfgspc_param *param);
+	u32 (*pcie_cfgspc_read)(struct mac_ax_adapter *adapter,
+				struct mac_ax_pcie_cfgspc_param *param);
+	u32 (*pcie_ltr_write)(struct mac_ax_adapter *adapter,
+			      struct mac_ax_pcie_ltr_param *param);
+	u32 (*pcie_ltr_read)(struct mac_ax_adapter *adapter,
+			     struct mac_ax_pcie_ltr_param *param);
+	u32 (*ctrl_hci_dma_en_pcie)(struct mac_ax_adapter *adapter,
+				    enum mac_ax_pcie_func_ctrl txen,
+				    enum mac_ax_pcie_func_ctrl rxen);
+	u32 (*ctrl_trxdma_pcie)(struct mac_ax_adapter *adapter,
+				enum mac_ax_pcie_func_ctrl txen,
+				enum mac_ax_pcie_func_ctrl rxen,
+				enum mac_ax_pcie_func_ctrl ioen);
+	u32 (*ctrl_wpdma_pcie)(struct mac_ax_adapter *adapter,
+			       enum mac_ax_pcie_func_ctrl wpen);
+	u32 (*poll_io_idle_pcie)(struct mac_ax_adapter *adapter);
+	u32 (*poll_dma_all_idle_pcie)(struct mac_ax_adapter *adapter);
+	u32 (*clr_idx_ch_pcie)(struct mac_ax_adapter *adapter,
+			       struct mac_ax_txdma_ch_map *txch_map,
+			       struct mac_ax_rxdma_ch_map *rxch_map);
+	u32 (*rst_bdram_pcie)(struct mac_ax_adapter *adapter, u8 val);
+	u32 (*trx_mit_pcie)(struct mac_ax_adapter *adapter,
+			    struct mac_ax_pcie_trx_mitigation *mit_info);
+	u32 (*mode_op_pcie)(struct mac_ax_adapter *adapter,
+			    struct mac_ax_intf_info *intf_info);
+	u32 (*get_err_flag_pcie)(struct mac_ax_adapter *adapter,
+				 struct mac_ax_pcie_err_info *out_info);
+	u32 (*mac_auto_refclk_cal_pcie)(struct mac_ax_adapter *adapter,
+					enum mac_ax_pcie_func_ctrl en);
+	u32 (*sync_trx_bd_idx)(struct mac_ax_adapter *adapter);
+#ifdef RTW_WKARD_GET_PROCESSOR_ID
+	u32 (*chk_proc_long_ldy_pcie)(struct mac_ax_adapter *adapter, u8 *val);
+#endif
+#endif
+#if MAC_AX_SDIO_SUPPORT
+	u8 (*r_indir_cmd52_sdio)(struct mac_ax_adapter *adapter, u32 adr);
+	u8 (*_r_indir_cmd52_sdio)(struct mac_ax_adapter *adapter, u32 adr);
+	u32 (*_r_indir_cmd53_sdio)(struct mac_ax_adapter *adapter, u32 adr);
+	u32 (*r16_indir_sdio)(struct mac_ax_adapter *adapter, u32 adr);
+	u32 (*r32_indir_sdio)(struct mac_ax_adapter *adapter, u32 adr);
+	void (*w_indir_cmd52_sdio)(struct mac_ax_adapter *adapter, u32 adr,
+				   u32 val, enum sdio_io_size size);
+	void (*w_indir_cmd53_sdio)(struct mac_ax_adapter *adapter, u32 adr, u32 val,
+				   enum sdio_io_size size);
+	void (*ud_fs)(struct mac_ax_adapter *adapter);
+	u32 (*sdio_pre_init)(struct mac_ax_adapter *adapter, void *param);
+	u32 (*tx_mode_cfg_sdio)(struct mac_ax_adapter *adapter,
+				enum mac_ax_sdio_tx_mode mode);
+	u32 (*leave_suspend_sdio)(struct mac_ax_adapter *adapter);
+	u32 (*get_int_latency_sdio)(struct mac_ax_adapter *adapter);
+	u32 (*get_clk_cnt_sdio)(struct mac_ax_adapter *adapter, u32 *cnt);
+	u32 (*set_wt_cfg_sdio)(struct mac_ax_adapter *adapter, u8 en);
+	u32 (*set_clk_mon_sdio)(struct mac_ax_adapter *adapter,
+				struct mac_ax_sdio_clk_mon_cfg *cfg);
+	u32 (*sdio_pwr_switch)(void *vadapter, u8 pre_switch, u8 on);
+	void (*rx_agg_cfg_sdio)(struct mac_ax_adapter *adapter,
+				struct mac_ax_rx_agg_cfg *cfg);
+	void (*aval_page_cfg_sdio)(struct mac_ax_adapter *adapter,
+				   struct mac_ax_aval_page_cfg *cfg);
+	u32 (*get_sdio_rx_req_len)(struct mac_ax_adapter *adapter, u32 *rx_req_len);
+#endif
+#if MAC_AX_USB_SUPPORT
+	u32 (*usb_ep_cfg)(struct mac_ax_adapter *adapter,
+			  struct mac_ax_usb_ep *cfg);
+#endif
+};
+
+u32 get_mac_ax_priv_size(void);
+
+struct mac_ax_priv_ops *
+mac_ax_get_priv_ops(struct mac_ax_adapter *adapter, enum mac_ax_intf intf);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mcc.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mcc.c
new file mode 100644
index 000000000000..126bff95632e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mcc.c
@@ -0,0 +1,935 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "mcc.h"
+
+u32 mac_reset_mcc_group(struct mac_ax_adapter *adapter, u8 group)
+{
+	struct fwcmd_reset_mcc_group *ptr;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	u32 ret = 0;
+
+	if (group > MCC_GROUP_ID_MAX) {
+		PLTFM_MSG_ERR("[ERR]%s: invalid group: %d\n", __func__, group);
+		return MACNOITEM;
+	}
+
+	adapter->sm.mcc_group[group] = MAC_AX_MCC_EMPTY;
+	adapter->sm.mcc_request[group] = MAC_AX_MCC_REQ_IDLE;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C alloc fail\n", __func__);
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_reset_mcc_group));
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C put fail\n", __func__);
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	ptr = (struct fwcmd_reset_mcc_group *)buf;
+	ptr->dword0 =
+	cpu_to_le32(SET_WORD(group, FWCMD_H2C_RESET_MCC_GROUP_GROUP));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MCC,
+			      FWCMD_H2C_FUNC_RESET_MCC_GROUP, 0, 0);
+
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Set H2C HDR fail\n", __func__);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Build H2C TXD fail\n", __func__);
+		goto fail;
+	}
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: platform tx err: %d\n", __func__, ret);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_reset_mcc_request(struct mac_ax_adapter *adapter, u8 group)
+{
+	if (adapter->sm.mcc_request[group] != MAC_AX_MCC_REQ_FAIL) {
+		PLTFM_MSG_ERR("[ERR]%s: state != req fail\n", __func__);
+		return MACPROCERR;
+	}
+
+	if (group > MCC_GROUP_ID_MAX) {
+		PLTFM_MSG_ERR("[ERR]%s: invalid group: %d\n", __func__, group);
+		return MACNOITEM;
+	}
+
+	adapter->sm.mcc_request[group] = MAC_AX_MCC_REQ_IDLE;
+
+	return MACSUCCESS;
+}
+
+u32 mac_add_mcc(struct mac_ax_adapter *adapter, struct mac_ax_mcc_role *info)
+{
+	struct fwcmd_add_mcc *ptr;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	u32 ret = 0;
+
+	if (!(adapter->sm.mcc_group[info->group] == MAC_AX_MCC_EMPTY ||
+	      adapter->sm.mcc_group[info->group] == MAC_AX_MCC_ADD_DONE)) {
+		PLTFM_MSG_ERR("[ERR]%s: state != empty or add done\n",
+			      __func__);
+		return MACPROCERR;
+	}
+
+	adapter->sm.mcc_group[info->group] = MAC_AX_MCC_STATE_H2C_SENT;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C alloc fail\n", __func__);
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_add_mcc));
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C put fail\n", __func__);
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	ptr = (struct fwcmd_add_mcc *)buf;
+	ptr->dword0 =
+	cpu_to_le32(SET_WORD(info->macid, FWCMD_H2C_ADD_MCC_MACID) |
+		    SET_WORD(info->central_ch_seg0,
+			     FWCMD_H2C_ADD_MCC_CENTRAL_CH_SEG0) |
+		    SET_WORD(info->central_ch_seg1,
+			     FWCMD_H2C_ADD_MCC_CENTRAL_CH_SEG1) |
+		    SET_WORD(info->primary_ch, FWCMD_H2C_ADD_MCC_PRIMARY_CH));
+
+	ptr->dword1 =
+	cpu_to_le32((info->dis_tx_null ? FWCMD_H2C_ADD_MCC_DIS_TX_NULL : 0) |
+		    (info->dis_sw_retry ? FWCMD_H2C_ADD_MCC_DIS_SW_RETRY : 0) |
+		    (info->in_curr_ch ? FWCMD_H2C_ADD_MCC_IN_CURR_CH : 0) |
+		    SET_WORD(info->bandwidth, FWCMD_H2C_ADD_MCC_BANDWIDTH) |
+		    SET_WORD(info->group, FWCMD_H2C_ADD_MCC_GROUP) |
+		    SET_WORD(info->c2h_rpt, FWCMD_H2C_ADD_MCC_C2H_RPT) |
+		    SET_WORD(info->sw_retry_count,
+			     FWCMD_H2C_ADD_MCC_SW_RETRY_COUNT) |
+		    SET_WORD(info->tx_null_early,
+			     FWCMD_H2C_ADD_MCC_TX_NULL_EARLY) |
+		    (info->btc_in_2g ? FWCMD_H2C_ADD_MCC_BTC_IN_2G : 0) |
+		    (info->pta_en ? FWCMD_H2C_ADD_MCC_PTA_EN : 0) |
+		    (info->rfk_by_pass ? FWCMD_H2C_ADD_MCC_RFK_BY_PASS : 0) |
+		    SET_WORD(info->ch_band_type,
+			     FWCMD_H2C_ADD_MCC_CH_BAND_TYPE));
+
+	ptr->dword2 =
+	cpu_to_le32(SET_WORD(info->duration, FWCMD_H2C_ADD_MCC_DURATION));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MCC,
+			      FWCMD_H2C_FUNC_ADD_MCC, 0, 0);
+
+	ptr->dword3 =
+	cpu_to_le32((info->courtesy_en ? FWCMD_H2C_ADD_MCC_COURTESY_EN : 0) |
+		    SET_WORD(info->courtesy_num,
+			     FWCMD_H2C_ADD_MCC_COURTESY_NUM) |
+		    SET_WORD(info->courtesy_target,
+			     FWCMD_H2C_ADD_MCC_COURTESY_TARGET));
+
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Set H2C HDR fail\n", __func__);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Build H2C TXD fail\n", __func__);
+		goto fail;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: platform tx err: %d\n", __func__, ret);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_start_mcc(struct mac_ax_adapter *adapter,
+		  struct mac_ax_mcc_start *info)
+{
+	struct fwcmd_start_mcc *ptr;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	u32 ret = 0;
+	u32 group = info->group;
+
+	if (group > MCC_GROUP_ID_MAX) {
+		PLTFM_MSG_ERR("[ERR]%s: invalid group: %d\n", __func__, info->group);
+		return MACNOITEM;
+	}
+
+	if (adapter->sm.mcc_group[info->group] != MAC_AX_MCC_ADD_DONE) {
+		PLTFM_MSG_ERR("[ERR]%s: state != add done\n", __func__);
+		return MACPROCERR;
+	}
+
+	adapter->sm.mcc_group[info->group] = MAC_AX_MCC_STATE_H2C_SENT;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C alloc fail\n", __func__);
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_start_mcc));
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C put fail\n", __func__);
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	ptr = (struct fwcmd_start_mcc *)buf;
+	ptr->dword0 =
+	cpu_to_le32(SET_WORD(info->group, FWCMD_H2C_START_MCC_GROUP) |
+		    (info->btc_in_group ? FWCMD_H2C_START_MCC_BTC_IN_GROUP : 0) |
+		    SET_WORD(info->old_group_action,
+			     FWCMD_H2C_START_MCC_OLD_GROUP_ACTION) |
+		    SET_WORD(info->old_group, FWCMD_H2C_START_MCC_OLD_GROUP) |
+		    SET_WORD(info->notify_cnt, FWCMD_H2C_START_MCC_NOTIFY_CNT) |
+		    (info->notify_rxdbg_en ? FWCMD_H2C_START_MCC_NOTIFY_RXDBG_EN : 0) |
+		    SET_WORD(info->macid, FWCMD_H2C_START_MCC_MACID));
+
+	ptr->dword1 =
+	cpu_to_le32(SET_WORD(info->tsf_low, FWCMD_H2C_START_MCC_TSF_LOW));
+
+	ptr->dword2 =
+	cpu_to_le32(SET_WORD(info->tsf_high, FWCMD_H2C_START_MCC_TSF_HIGH));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MCC,
+			      FWCMD_H2C_FUNC_START_MCC, 0, 0);
+
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Set H2C HDR fail\n", __func__);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Build H2C TXD fail\n", __func__);
+		goto fail;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: platform tx err: %d\n", __func__, ret);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_stop_mcc(struct mac_ax_adapter *adapter, u8 group, u8 macid,
+		 u8 prev_groups)
+{
+	struct fwcmd_stop_mcc *ptr;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	u32 ret = 0;
+
+	if (group > MCC_GROUP_ID_MAX) {
+		PLTFM_MSG_ERR("[ERR]%s: invalid group: %d\n", __func__, group);
+		return MACNOITEM;
+	}
+
+	if (adapter->sm.mcc_group[group] != MAC_AX_MCC_START_DONE) {
+		PLTFM_MSG_ERR("[ERR]%s: state != start done\n", __func__);
+		return MACPROCERR;
+	}
+
+	adapter->sm.mcc_group[group] = MAC_AX_MCC_STATE_H2C_SENT;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C alloc fail\n", __func__);
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_stop_mcc));
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C put fail\n", __func__);
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	ptr = (struct fwcmd_stop_mcc *)buf;
+	ptr->dword0 =
+	cpu_to_le32(SET_WORD(group, FWCMD_H2C_STOP_MCC_GROUP) |
+		    SET_WORD(macid, FWCMD_H2C_STOP_MCC_MACID) |
+		    (prev_groups ? FWCMD_H2C_STOP_MCC_PREV_GROUPS : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MCC,
+			      FWCMD_H2C_FUNC_STOP_MCC, 0, 0);
+
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Set H2C HDR fail\n", __func__);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Build H2C TXD fail\n", __func__);
+		goto fail;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: platform tx err: %d\n", __func__, ret);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_del_mcc_group(struct mac_ax_adapter *adapter, u8 group,
+		      u8 prev_groups)
+{
+	struct fwcmd_del_mcc_group *ptr;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	u32 ret = 0;
+
+	if (group > MCC_GROUP_ID_MAX) {
+		PLTFM_MSG_ERR("[ERR]%s: invalid group: %d\n", __func__, group);
+		return MACNOITEM;
+	}
+
+	if (!(adapter->sm.mcc_group[group] == MAC_AX_MCC_ADD_DONE ||
+	      adapter->sm.mcc_group[group] == MAC_AX_MCC_STOP_DONE)) {
+		PLTFM_MSG_ERR("[ERR]%s: state != add or stop done\n",
+			      __func__);
+		return MACPROCERR;
+	}
+
+	adapter->sm.mcc_group[group] = MAC_AX_MCC_STATE_H2C_SENT;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C alloc fail\n", __func__);
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_del_mcc_group));
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C put fail\n", __func__);
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	ptr = (struct fwcmd_del_mcc_group *)buf;
+	ptr->dword0 =
+	cpu_to_le32(SET_WORD(group, FWCMD_H2C_DEL_MCC_GROUP_GROUP) |
+		    (prev_groups ? FWCMD_H2C_DEL_MCC_GROUP_PREV_GROUPS : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MCC,
+			      FWCMD_H2C_FUNC_DEL_MCC_GROUP, 0, 0);
+
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Set H2C HDR fail\n", __func__);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Build H2C TXD fail\n", __func__);
+		goto fail;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: platform tx err: %d\n", __func__, ret);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_mcc_request_tsf(struct mac_ax_adapter *adapter, u8 group,
+			u8 macid_x, u8 macid_y)
+{
+	struct fwcmd_mcc_req_tsf *ptr;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	u32 ret = 0;
+
+	if (group > MCC_GROUP_ID_MAX) {
+		PLTFM_MSG_ERR("[ERR]%s: invalid group: %d\n", __func__, group);
+		return MACNOITEM;
+	}
+
+	adapter->sm.mcc_request[group] = MAC_AX_MCC_REQ_H2C_SENT;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C alloc fail\n", __func__);
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_mcc_req_tsf));
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C put fail\n", __func__);
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	ptr = (struct fwcmd_mcc_req_tsf *)buf;
+	ptr->dword0 =
+	cpu_to_le32(SET_WORD(group, FWCMD_H2C_MCC_REQ_TSF_GROUP) |
+		    SET_WORD(macid_x, FWCMD_H2C_MCC_REQ_TSF_MACID_X) |
+		    SET_WORD(macid_y, FWCMD_H2C_MCC_REQ_TSF_MACID_Y));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MCC,
+			      FWCMD_H2C_FUNC_MCC_REQ_TSF, 0, 0);
+
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Set H2C HDR fail\n", __func__);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Build H2C TXD fail\n", __func__);
+		goto fail;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: platform tx err: %d\n", __func__, ret);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_mcc_macid_bitmap(struct mac_ax_adapter *adapter, u8 group,
+			 u8 macid, u8 *bitmap, u8 len)
+{
+	struct fwcmd_mcc_macid_bitmap *ptr;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	u32 ret = 0;
+
+	if (group > MCC_GROUP_ID_MAX) {
+		PLTFM_MSG_ERR("[ERR]%s: invalid group: %d\n", __func__, group);
+		return MACNOITEM;
+	}
+
+	adapter->sm.mcc_request[group] = MAC_AX_MCC_REQ_H2C_SENT;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C alloc fail\n", __func__);
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cb, len + 4);
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C put fail\n", __func__);
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	ptr = (struct fwcmd_mcc_macid_bitmap *)buf;
+	ptr->dword0 =
+	cpu_to_le32(SET_WORD(group, FWCMD_H2C_MCC_MACID_BITMAP_GROUP) |
+		    SET_WORD(macid, FWCMD_H2C_MCC_MACID_BITMAP_MACID) |
+		    SET_WORD(len, FWCMD_H2C_MCC_MACID_BITMAP_BITMAP_LENGTH));
+
+	PLTFM_MEMCPY((u8 *)ptr + sizeof(u32), bitmap, len);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MCC,
+			      FWCMD_H2C_FUNC_MCC_MACID_BITMAP, 0, 0);
+
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Set H2C HDR fail\n", __func__);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Build H2C TXD fail\n", __func__);
+		goto fail;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: platform tx error %d\n", __func__, ret);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_mcc_sync_enable(struct mac_ax_adapter *adapter, u8 group,
+			u8 source, u8 target, u8 offset)
+{
+	struct fwcmd_mcc_sync *ptr;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	u32 ret = 0;
+
+	if (group > MCC_GROUP_ID_MAX) {
+		PLTFM_MSG_ERR("[ERR]%s: invalid group: %d\n", __func__, group);
+		return MACNOITEM;
+	}
+
+	adapter->sm.mcc_request[group] = MAC_AX_MCC_REQ_H2C_SENT;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C alloc fail\n", __func__);
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_mcc_sync));
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C put fail\n", __func__);
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	ptr = (struct fwcmd_mcc_sync *)buf;
+	ptr->dword0 =
+	cpu_to_le32(SET_WORD(group, FWCMD_H2C_MCC_SYNC_GROUP) |
+		    SET_WORD(source, FWCMD_H2C_MCC_SYNC_MACID_SOURCE) |
+		    SET_WORD(target, FWCMD_H2C_MCC_SYNC_MACID_TARGET) |
+		    SET_WORD(offset, FWCMD_H2C_MCC_SYNC_SYNC_OFFSET));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MCC,
+			      FWCMD_H2C_FUNC_MCC_SYNC, 0, 0);
+
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Set H2C HDR fail\n", __func__);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Build H2C TXD fail\n", __func__);
+		goto fail;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: platform tx error %d\n", __func__, ret);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_mcc_set_duration(struct mac_ax_adapter *adapter,
+			 struct mac_ax_mcc_duration_info *info)
+{
+	struct fwcmd_mcc_set_duration *ptr;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	u32 ret = 0;
+
+	adapter->sm.mcc_request[info->group] = MAC_AX_MCC_REQ_H2C_SENT;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C alloc fail\n", __func__);
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_mcc_set_duration));
+	if (!buf) {
+		PLTFM_MSG_ERR("[ERR]%s: H2C put fail\n", __func__);
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	ptr = (struct fwcmd_mcc_set_duration *)buf;
+	ptr->dword0 =
+	cpu_to_le32(SET_WORD(info->group, FWCMD_H2C_MCC_SET_DURATION_GROUP) |
+		    (info->btc_in_group ?
+		     FWCMD_H2C_MCC_SET_DURATION_BTC_IN_GROUP : 0) |
+		    SET_WORD(info->start_macid,
+			     FWCMD_H2C_MCC_SET_DURATION_START_MACID) |
+		    SET_WORD(info->macid_x,
+			     FWCMD_H2C_MCC_SET_DURATION_MACID_X) |
+		    SET_WORD(info->macid_y,
+			     FWCMD_H2C_MCC_SET_DURATION_MACID_Y));
+	ptr->dword1 =
+	cpu_to_le32(SET_WORD(info->start_tsf_low,
+			     FWCMD_H2C_MCC_SET_DURATION_START_TSF_LOW));
+
+	ptr->dword2 =
+	cpu_to_le32(SET_WORD(info->start_tsf_high,
+			     FWCMD_H2C_MCC_SET_DURATION_START_TSF_HIGH));
+
+	ptr->dword3 =
+	cpu_to_le32(SET_WORD(info->duration_x,
+			     FWCMD_H2C_MCC_SET_DURATION_DURATION_X));
+
+	ptr->dword4 =
+	cpu_to_le32(SET_WORD(info->duration_y,
+			     FWCMD_H2C_MCC_SET_DURATION_DURATION_Y));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MCC,
+			      FWCMD_H2C_FUNC_MCC_SET_DURATION, 0, 0);
+
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Set H2C HDR fail\n", __func__);
+		goto fail;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: Build H2C TXD fail\n", __func__);
+		goto fail;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s: platform tx err %d\n", __func__, ret);
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_get_mcc_status_rpt(struct mac_ax_adapter *adapter,
+			   u8 group, u8 *status, u32 *tsf_high, u32 *tsf_low)
+{
+	struct mac_ax_mcc_group_info *mcc_info = &adapter->mcc_group_info;
+
+	if (adapter->sm.mcc_group[group] == MAC_AX_MCC_EMPTY) {
+		PLTFM_MSG_ERR("[ERR]%s: state = empty\n", __func__);
+		return MACPROCERR;
+	}
+
+	if (group > MCC_GROUP_ID_MAX) {
+		PLTFM_MSG_ERR("[ERR]%s: invalid group: %d\n", __func__, group);
+		return MACNOITEM;
+	}
+
+	*status = mcc_info->groups[group].rpt_status;
+	PLTFM_MSG_TRACE("[TRACE]%s: mcc status: %d\n", __func__, *status);
+
+	*tsf_high = mcc_info->groups[group].rpt_tsf_high;
+	*tsf_low = mcc_info->groups[group].rpt_tsf_low;
+
+	PLTFM_MSG_TRACE("[TRACE]%s: report tsf_high: 0x%x\n",
+			__func__, *tsf_high);
+	PLTFM_MSG_TRACE("[TRACE]%s: report tsf_low: 0x%x\n",
+			__func__, *tsf_low);
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_mcc_tsf_rpt(struct mac_ax_adapter *adapter, u8 group,
+			u32 *tsf_x_high, u32 *tsf_x_low,
+			u32 *tsf_y_high, u32 *tsf_y_low)
+{
+	struct mac_ax_mcc_group_info *mcc_info = &adapter->mcc_group_info;
+
+	if (group > MCC_GROUP_ID_MAX) {
+		PLTFM_MSG_ERR("[ERR]%s: invalid group: %d\n", __func__, group);
+		return MACNOITEM;
+	}
+
+	*tsf_x_high = mcc_info->groups[group].tsf_x_high;
+	*tsf_x_low = mcc_info->groups[group].tsf_x_low;
+	PLTFM_MSG_TRACE("[TRACE]%s: tsf_x_high: 0x%x\n", __func__, *tsf_x_high);
+	PLTFM_MSG_TRACE("[TRACE]%s: tsf_x_low: 0x%x\n", __func__, *tsf_x_low);
+
+	*tsf_y_high = mcc_info->groups[group].tsf_y_high;
+	*tsf_y_low += mcc_info->groups[group].tsf_y_low;
+	PLTFM_MSG_TRACE("[TRACE]%s: tsf_y_high: 0x%x\n", __func__, *tsf_y_high);
+	PLTFM_MSG_TRACE("[TRACE]%s: tsf_y_low: 0x%x\n", __func__, *tsf_y_low);
+
+	adapter->sm.mcc_request[group] = MAC_AX_MCC_REQ_IDLE;
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_mcc_group(struct mac_ax_adapter *adapter, u8 *pget_group)
+{
+	struct mac_ax_state_mach *sm = &adapter->sm;
+	u8 group_idx;
+
+	for (group_idx = 0; group_idx <= MCC_GROUP_ID_MAX; group_idx++) {
+		if (sm->mcc_group[group_idx] == MAC_AX_MCC_EMPTY) {
+			*pget_group = group_idx;
+			PLTFM_MSG_TRACE("[TRACE]%s: get mcc empty group %u\n",
+					__func__, *pget_group);
+			adapter->sm.mcc_group[group_idx] = MAC_AX_MCC_EMPTY;
+			adapter->sm.mcc_request[group_idx] = MAC_AX_MCC_REQ_IDLE;
+			return MACSUCCESS;
+		}
+	}
+	return MACMCCGPFL;
+}
+
+u32 mac_check_add_mcc_done(struct mac_ax_adapter *adapter, u8 group)
+{
+	PLTFM_MSG_TRACE("[TRACE]%s: group %d curr state: %d (%d)\n", __func__,
+			group, adapter->sm.mcc_group[group],
+			adapter->sm.mcc_group_state[group]);
+
+	if (adapter->sm.mcc_group[group] == MAC_AX_MCC_ADD_DONE)
+		return MACSUCCESS;
+	else
+		return MACPROCBUSY;
+}
+
+u32 mac_check_start_mcc_done(struct mac_ax_adapter *adapter, u8 group)
+{
+	PLTFM_MSG_TRACE("[TRACE]%s: group %d curr state: %d (%d)\n", __func__,
+			group, adapter->sm.mcc_group[group],
+			adapter->sm.mcc_group_state[group]);
+
+	if (adapter->sm.mcc_group[group] == MAC_AX_MCC_START_DONE)
+		return MACSUCCESS;
+	else
+		return MACPROCBUSY;
+}
+
+u32 mac_check_stop_mcc_done(struct mac_ax_adapter *adapter, u8 group)
+{
+	PLTFM_MSG_TRACE("[TRACE]%s: group %d curr state: %d (%d)\n", __func__,
+			group, adapter->sm.mcc_group[group],
+			adapter->sm.mcc_group_state[group]);
+
+	if (adapter->sm.mcc_group[group] == MAC_AX_MCC_STOP_DONE)
+		return MACSUCCESS;
+	else
+		return MACPROCBUSY;
+}
+
+u32 mac_check_del_mcc_group_done(struct mac_ax_adapter *adapter, u8 group)
+{
+	PLTFM_MSG_TRACE("[TRACE]%s: group %d curr state: %d (%d)\n", __func__,
+			group, adapter->sm.mcc_group[group],
+			adapter->sm.mcc_group_state[group]);
+
+	if (adapter->sm.mcc_group[group] == MAC_AX_MCC_EMPTY)
+		return MACSUCCESS;
+	else
+		return MACPROCBUSY;
+}
+
+u32 mac_check_mcc_request_tsf_done(struct mac_ax_adapter *adapter, u8 group)
+{
+	PLTFM_MSG_TRACE("[TRACE]%s: group %d curr req state: %d (%d)\n", __func__,
+			group, adapter->sm.mcc_request[group],
+			adapter->sm.mcc_request_state[group]);
+
+	if (adapter->sm.mcc_request[group] == MAC_AX_MCC_REQ_DONE)
+		return MACSUCCESS;
+	else
+		return MACPROCBUSY;
+}
+
+u32 mac_check_mcc_macid_bitmap_done(struct mac_ax_adapter *adapter, u8 group)
+{
+	PLTFM_MSG_TRACE("[TRACE]%s: group %d curr req state: %d (%d)\n", __func__,
+			group, adapter->sm.mcc_request[group],
+			adapter->sm.mcc_request_state[group]);
+
+	if (adapter->sm.mcc_request[group] == MAC_AX_MCC_REQ_IDLE)
+		return MACSUCCESS;
+	else
+		return MACPROCBUSY;
+}
+
+u32 mac_check_mcc_sync_enable_done(struct mac_ax_adapter *adapter, u8 group)
+{
+	PLTFM_MSG_TRACE("[TRACE]%s: group %d curr req state: %d (%d)\n", __func__,
+			group, adapter->sm.mcc_request[group],
+			adapter->sm.mcc_request_state[group]);
+
+	if (adapter->sm.mcc_request[group] == MAC_AX_MCC_REQ_IDLE)
+		return MACSUCCESS;
+	else
+		return MACPROCBUSY;
+}
+
+u32 mac_check_mcc_set_duration_done(struct mac_ax_adapter *adapter, u8 group)
+{
+	PLTFM_MSG_TRACE("[TRACE]%s: group %d curr req state: %d (%d)\n", __func__,
+			group, adapter->sm.mcc_request[group],
+			adapter->sm.mcc_request_state[group]);
+
+	if (adapter->sm.mcc_request[group] == MAC_AX_MCC_REQ_IDLE)
+		return MACSUCCESS;
+	else
+		return MACPROCBUSY;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mcc.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mcc.h
new file mode 100644
index 000000000000..b8d818b0e76b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mcc.h
@@ -0,0 +1,413 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_MCC_H_
+#define _MAC_AX_MCC_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+
+#define MCC_GROUP_ID_MAX 3
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+/**
+ * @brief mac_reset_mcc_group
+ *
+ * @param *adapter
+ * @param group
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_reset_mcc_group(struct mac_ax_adapter *adapter, u8 group);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_reset_mcc_request
+ *
+ * @param *adapter
+ * @param group
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_reset_mcc_request(struct mac_ax_adapter *adapter, u8 group);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_add_mcc
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_add_mcc(struct mac_ax_adapter *adapter, struct mac_ax_mcc_role *info);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_start_mcc
+ *
+ * @param *adapter
+ * @param group
+ * @param macid
+ * @param tsf_high
+ * @param tsf_low
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_start_mcc(struct mac_ax_adapter *adapter,
+		  struct mac_ax_mcc_start *info);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_stop_mcc
+ *
+ * @param *adapter
+ * @param group
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_stop_mcc(struct mac_ax_adapter *adapter, u8 group, u8 macid,
+		 u8 prev_groups);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_del_mcc_group
+ *
+ * @param *adapter
+ * @param group
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_del_mcc_group(struct mac_ax_adapter *adapter, u8 group,
+		      u8 prev_groups);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_mcc_request_tsf
+ *
+ * @param *adapter
+ * @param group
+ * @param macid_x
+ * @param macid_y
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_mcc_request_tsf(struct mac_ax_adapter *adapter, u8 group,
+			u8 macid_x, u8 macid_y);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_mcc_macid_bitmap
+ *
+ * @param *adapter
+ * @param group
+ * @param macid
+ * @param *bitmap
+ * @param len
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_mcc_macid_bitmap(struct mac_ax_adapter *adapter, u8 group,
+			 u8 macid, u8 *bitmap, u8 len);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_mcc_sync_enable
+ *
+ * @param *adapter
+ * @param group
+ * @param source
+ * @param target
+ * @param offset
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_mcc_sync_enable(struct mac_ax_adapter *adapter, u8 group,
+			u8 source, u8 target, u8 offset);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_mcc_set_duration
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_mcc_set_duration(struct mac_ax_adapter *adapter,
+			 struct mac_ax_mcc_duration_info *info);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_get_mcc_status_rpt
+ *
+ * @param *adapter
+ * @param group
+ * @param *status
+ * @param *tsf_high
+ * @param *tsf_low
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_mcc_status_rpt(struct mac_ax_adapter *adapter,
+			   u8 group, u8 *status, u32 *tsf_high, u32 *tsf_low);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_get_mcc_tsf_rpt
+ *
+ * @param *adapter
+ * @param group
+ * @param *tsf_x_high
+ * @param *tsf_x_low
+ * @param *tsf_y_high
+ * @param *tsf_y_low
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_mcc_tsf_rpt(struct mac_ax_adapter *adapter, u8 group,
+			u32 *tsf_x_high, u32 *tsf_x_low,
+			u32 *tsf_y_high, u32 *tsf_y_low);
+/**
+ * @}
+ */
+u32 mac_get_mcc_group(struct mac_ax_adapter *adapter, u8 *pget_group);
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_check_add_mcc_done
+ *
+ * @param *adapter
+ * @param group
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_add_mcc_done(struct mac_ax_adapter *adapter, u8 group);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_check_start_mcc_done
+ *
+ * @param *adapter
+ * @param group
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_start_mcc_done(struct mac_ax_adapter *adapter, u8 group);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_check_stop_mcc_done
+ *
+ * @param *adapter
+ * @param group
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_stop_mcc_done(struct mac_ax_adapter *adapter, u8 group);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_check_del_mcc_group_done
+ *
+ * @param *adapter
+ * @param group
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_del_mcc_group_done(struct mac_ax_adapter *adapter, u8 group);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_check_mcc_request_tsf_done
+ *
+ * @param *adapter
+ * @param group
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_mcc_request_tsf_done(struct mac_ax_adapter *adapter, u8 group);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_check_mcc_macid_bitmap_done
+ *
+ * @param *adapter
+ * @param group
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_mcc_macid_bitmap_done(struct mac_ax_adapter *adapter, u8 group);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_check_mcc_sync_enable_done
+ *
+ * @param *adapter
+ * @param group
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_mcc_sync_enable_done(struct mac_ax_adapter *adapter, u8 group);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup MCC
+ * @{
+ */
+
+/**
+ * @brief mac_check_mcc_set_duration_done
+ *
+ * @param *adapter
+ * @param group
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_mcc_set_duration_done(struct mac_ax_adapter *adapter, u8 group);
+/**
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mport.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mport.c
new file mode 100644
index 000000000000..66cb1f5851e0
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mport.c
@@ -0,0 +1,2756 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "mport.h"
+#include "../mac_ax.h"
+
+#define MAX_TSF_SOURCE_PORT 7
+#define MAX_TSF_TARGET_PORT 4
+#define MAX_TSF_SYNC_OFFSET 0x3FFFF
+
+static u32 cfg_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_PORT_CFG_P0, R_AX_PORT_CFG_P1, R_AX_PORT_CFG_P2,
+	 R_AX_PORT_CFG_P3, R_AX_PORT_CFG_P4},
+	{R_AX_PORT_CFG_P0_C1, R_AX_PORT_CFG_P1_C1, R_AX_PORT_CFG_P2_C1,
+	 R_AX_PORT_CFG_P3_C1, R_AX_PORT_CFG_P4_C1}
+};
+
+static u32 phb_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_TBTT_PROHIB_P0, R_AX_TBTT_PROHIB_P1, R_AX_TBTT_PROHIB_P1,
+	 R_AX_TBTT_PROHIB_P1, R_AX_TBTT_PROHIB_P1},
+	{R_AX_TBTT_PROHIB_P0_C1, R_AX_TBTT_PROHIB_P1_C1, R_AX_TBTT_PROHIB_P1_C1,
+	 R_AX_TBTT_PROHIB_P1_C1, R_AX_TBTT_PROHIB_P1_C1}
+};
+
+static u32 ctnarea_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_BCN_AREA_P0, R_AX_BCN_AREA_P1, R_AX_BCN_AREA_P1,
+	 R_AX_BCN_AREA_P1, R_AX_BCN_AREA_P1},
+	{R_AX_BCN_AREA_P0_C1, R_AX_BCN_AREA_P1_C1, R_AX_BCN_AREA_P1_C1,
+	 R_AX_BCN_AREA_P1_C1, R_AX_BCN_AREA_P1_C1}
+};
+
+static u32 mskarea_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_BCN_AREA_P0, R_AX_BCN_AREA_P1, R_AX_BCN_AREA_P2,
+	 R_AX_BCN_AREA_P3, R_AX_BCN_AREA_P4},
+	{R_AX_BCN_AREA_P0_C1, R_AX_BCN_AREA_P1_C1, R_AX_BCN_AREA_P2_C1,
+	 R_AX_BCN_AREA_P3_C1, R_AX_BCN_AREA_P4_C1}
+};
+
+static u32 tbttagg_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_TBTT_AGG_P0, R_AX_TBTT_AGG_P1, R_AX_TBTT_AGG_P2,
+	 R_AX_TBTT_AGG_P3, R_AX_TBTT_AGG_P4},
+	{R_AX_TBTT_AGG_P0_C1, R_AX_TBTT_AGG_P1_C1, R_AX_TBTT_AGG_P2_C1,
+	 R_AX_TBTT_AGG_P3_C1, R_AX_TBTT_AGG_P4_C1}
+};
+
+static u32 tbttery_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_TBTTERLYINT_CFG_P0, R_AX_TBTTERLYINT_CFG_P1,
+	 R_AX_TBTTERLYINT_CFG_P2, R_AX_TBTTERLYINT_CFG_P3,
+	 R_AX_TBTTERLYINT_CFG_P4},
+	{R_AX_TBTTERLYINT_CFG_P0_C1, R_AX_TBTTERLYINT_CFG_P1_C1,
+	 R_AX_TBTTERLYINT_CFG_P2_C1, R_AX_TBTTERLYINT_CFG_P3_C1,
+	 R_AX_TBTTERLYINT_CFG_P4_C1}
+};
+
+static u32 bcnspc_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_BCN_SPACE_CFG_P0, R_AX_BCN_SPACE_CFG_P1, R_AX_BCN_SPACE_CFG_P2,
+	 R_AX_BCN_SPACE_CFG_P3, R_AX_BCN_SPACE_CFG_P4},
+	{R_AX_BCN_SPACE_CFG_P0_C1, R_AX_BCN_SPACE_CFG_P1_C1,
+	 R_AX_BCN_SPACE_CFG_P2_C1, R_AX_BCN_SPACE_CFG_P3_C1,
+	 R_AX_BCN_SPACE_CFG_P4_C1}
+};
+
+static u32 tbttsht_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_TBTT_SHIFT_P0, R_AX_TBTT_SHIFT_P1, R_AX_TBTT_SHIFT_P2,
+	 R_AX_TBTT_SHIFT_P3, R_AX_TBTT_SHIFT_P4},
+	{R_AX_TBTT_SHIFT_P0_C1, R_AX_TBTT_SHIFT_P1_C1, R_AX_TBTT_SHIFT_P2_C1,
+	 R_AX_TBTT_SHIFT_P3_C1, R_AX_TBTT_SHIFT_P4_C1}
+};
+
+static u32 bcndrp_regl[MAC_AX_BAND_NUM] = {
+	R_AX_BCN_DROP_ALL0, R_AX_BCN_DROP_ALL0_C1
+};
+
+static u32 mbssid_drp_regl[MAC_AX_BAND_NUM] = {
+	R_AX_BCN_DROP_ALL0_P0MB, R_AX_BCN_DROP_ALL0_P0MB_C1
+};
+
+static u32 bcnpsr_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_BCN_PSR_RPT_P0, R_AX_BCN_PSR_RPT_P1, R_AX_BCN_PSR_RPT_P2,
+	 R_AX_BCN_PSR_RPT_P3, R_AX_BCN_PSR_RPT_P4},
+	{R_AX_BCN_PSR_RPT_P0_C1, R_AX_BCN_PSR_RPT_P1_C1, R_AX_BCN_PSR_RPT_P2_C1,
+	 R_AX_BCN_PSR_RPT_P3_C1, R_AX_BCN_PSR_RPT_P4_C1}
+};
+
+static u32 cnt_tmr_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_BCN_CNT_TMR_P0, R_AX_BCN_CNT_TMR_P1, R_AX_BCN_CNT_TMR_P2,
+	 R_AX_BCN_CNT_TMR_P3, R_AX_BCN_CNT_TMR_P4},
+	{R_AX_BCN_CNT_TMR_P0_C1, R_AX_BCN_CNT_TMR_P1_C1, R_AX_BCN_CNT_TMR_P2_C1,
+	 R_AX_BCN_CNT_TMR_P3_C1, R_AX_BCN_CNT_TMR_P4_C1}
+};
+
+static u32 hiq_win_port_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_P0MB_HGQ_WINDOW_CFG_0, R_AX_PORT_HGQ_WINDOW_CFG,
+	 R_AX_PORT_HGQ_WINDOW_CFG + 1, R_AX_PORT_HGQ_WINDOW_CFG + 2,
+	 R_AX_PORT_HGQ_WINDOW_CFG + 3},
+	{R_AX_P0MB_HGQ_WINDOW_CFG_0_C1, R_AX_PORT_HGQ_WINDOW_CFG_C1,
+	 R_AX_PORT_HGQ_WINDOW_CFG_C1 + 1, R_AX_PORT_HGQ_WINDOW_CFG_C1 + 2,
+	 R_AX_PORT_HGQ_WINDOW_CFG_C1 + 3}
+};
+
+static u32 hiq_win_mbid_regl[MAC_AX_BAND_NUM][MAC_AX_P0_MBID_MAX] = {
+	{R_AX_P0MB_HGQ_WINDOW_CFG_0, R_AX_P0MB_HGQ_WINDOW_CFG_0 + 1,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_0 + 2, R_AX_P0MB_HGQ_WINDOW_CFG_0 + 3,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_1, R_AX_P0MB_HGQ_WINDOW_CFG_1 + 1,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_1 + 2, R_AX_P0MB_HGQ_WINDOW_CFG_1 + 3,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_2, R_AX_P0MB_HGQ_WINDOW_CFG_2 + 1,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_2 + 2, R_AX_P0MB_HGQ_WINDOW_CFG_2 + 3,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_3, R_AX_P0MB_HGQ_WINDOW_CFG_3 + 1,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_3 + 2, R_AX_P0MB_HGQ_WINDOW_CFG_3 + 3},
+	{R_AX_P0MB_HGQ_WINDOW_CFG_0_C1, R_AX_P0MB_HGQ_WINDOW_CFG_0_C1 + 1,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_0_C1 + 2, R_AX_P0MB_HGQ_WINDOW_CFG_0_C1 + 3,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_1_C1, R_AX_P0MB_HGQ_WINDOW_CFG_1_C1 + 1,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_1_C1 + 2, R_AX_P0MB_HGQ_WINDOW_CFG_1_C1 + 3,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_2_C1, R_AX_P0MB_HGQ_WINDOW_CFG_2_C1 + 1,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_2_C1 + 2, R_AX_P0MB_HGQ_WINDOW_CFG_2_C1 + 3,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_3_C1, R_AX_P0MB_HGQ_WINDOW_CFG_3_C1 + 1,
+	 R_AX_P0MB_HGQ_WINDOW_CFG_3_C1 + 2, R_AX_P0MB_HGQ_WINDOW_CFG_3_C1 + 3}
+};
+
+static u32 dtim_prd_port_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_DTIM_CTRL_P0 + 1, R_AX_DTIM_CTRL_P1 + 1,
+	 R_AX_DTIM_CTRL_P2 + 1, R_AX_DTIM_CTRL_P3 + 1,
+	 R_AX_DTIM_CTRL_P4 + 1},
+	{R_AX_DTIM_CTRL_P0_C1 + 1, R_AX_DTIM_CTRL_P1_C1 + 1,
+	 R_AX_DTIM_CTRL_P2_C1 + 1, R_AX_DTIM_CTRL_P3_C1 + 1,
+	 R_AX_DTIM_CTRL_P4_C1 + 1}
+};
+
+static u32 dtim_prd_mbid_regl[MAC_AX_BAND_NUM][MAC_AX_P0_MBID_MAX] = {
+	{R_AX_DTIM_CTRL_P0 + 1, R_AX_DTIM_NUM0 + 1, R_AX_DTIM_NUM0 + 2,
+	 R_AX_DTIM_NUM0 + 3, R_AX_DTIM_NUM1, R_AX_DTIM_NUM1 + 1,
+	 R_AX_DTIM_NUM1 + 2, R_AX_DTIM_NUM1 + 3, R_AX_DTIM_NUM2,
+	 R_AX_DTIM_NUM2 + 1, R_AX_DTIM_NUM2 + 2, R_AX_DTIM_NUM2 + 3,
+	 R_AX_DTIM_NUM3, R_AX_DTIM_NUM3 + 1, R_AX_DTIM_NUM3 + 2,
+	 R_AX_DTIM_NUM3 + 3},
+	{R_AX_DTIM_CTRL_P0_C1 + 1, R_AX_DTIM_NUM0_C1 + 1, R_AX_DTIM_NUM0_C1 + 2,
+	 R_AX_DTIM_NUM0_C1 + 3, R_AX_DTIM_NUM1_C1, R_AX_DTIM_NUM1_C1 + 1,
+	 R_AX_DTIM_NUM1_C1 + 2, R_AX_DTIM_NUM1_C1 + 3, R_AX_DTIM_NUM2_C1,
+	 R_AX_DTIM_NUM2_C1 + 1, R_AX_DTIM_NUM2_C1 + 2, R_AX_DTIM_NUM2_C1 + 3,
+	 R_AX_DTIM_NUM3_C1, R_AX_DTIM_NUM3_C1 + 1, R_AX_DTIM_NUM3_C1 + 2,
+	 R_AX_DTIM_NUM3_C1 + 3}
+};
+
+static u32 dtim_switch[MAC_AX_BAND_NUM] = {
+	R_AX_MD_TSFT_STMP_CTL, R_AX_MD_TSFT_STMP_CTL_C1
+};
+
+static u32 hiq_nolmt_regl[MAC_AX_BAND_NUM] = {
+	R_AX_EN_HGQ_NOLIMIT, R_AX_EN_HGQ_NOLIMIT_C1
+};
+
+static u32 mbid_ctrl_regl[MAC_AX_BAND_NUM] = {
+	R_AX_MBSSID_CTRL, R_AX_MBSSID_CTRL_C1
+};
+
+static u32 bcn_early_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_BCNERLYINT_CFG_P0, R_AX_BCNERLYINT_CFG_P1,
+	R_AX_BCNERLYINT_CFG_P2, R_AX_BCNERLYINT_CFG_P3,
+	R_AX_BCNERLYINT_CFG_P4},
+	{R_AX_BCNERLYINT_CFG_P0_C1, R_AX_BCNERLYINT_CFG_P1_C1,
+	R_AX_BCNERLYINT_CFG_P2_C1, R_AX_BCNERLYINT_CFG_P3_C1,
+	R_AX_BCNERLYINT_CFG_P4_C1}
+};
+
+static u32 tsfl_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_TSFTR_LOW_P0, R_AX_TSFTR_LOW_P1, R_AX_TSFTR_LOW_P2,
+	 R_AX_TSFTR_LOW_P3, R_AX_TSFTR_LOW_P4},
+	{R_AX_TSFTR_LOW_P0_C1, R_AX_TSFTR_LOW_P1_C1, R_AX_TSFTR_LOW_P2_C1,
+	 R_AX_TSFTR_LOW_P3_C1, R_AX_TSFTR_LOW_P4_C1}
+};
+
+static u32 ptcl_dbg_regl[MAC_AX_BAND_NUM] = {
+	R_AX_PTCL_DBG, R_AX_PTCL_DBG_C1
+};
+
+static u32 bss_color_regl[MAC_AX_BAND_NUM][MAC_AX_PORT_NUM] = {
+	{R_AX_PTCL_BSS_COLOR_0,
+	R_AX_PTCL_BSS_COLOR_0,
+	R_AX_PTCL_BSS_COLOR_0,
+	R_AX_PTCL_BSS_COLOR_0,
+	R_AX_PTCL_BSS_COLOR_1},
+	{R_AX_PTCL_BSS_COLOR_0_C1,
+	R_AX_PTCL_BSS_COLOR_0_C1,
+	R_AX_PTCL_BSS_COLOR_0_C1,
+	R_AX_PTCL_BSS_COLOR_0_C1,
+	R_AX_PTCL_BSS_COLOR_1_C1}
+};
+
+static u32 ptcl_dbg_info_regl[MAC_AX_BAND_NUM] = {
+	R_AX_PTCL_DBG_INFO, R_AX_PTCL_DBG_INFO_C1
+};
+
+static u32 b_en_l[MAC_AX_PORT_NUM] = {
+	B_AX_PORT_FUNC_EN_P0, B_AX_PORT_FUNC_EN_P1, B_AX_PORT_FUNC_EN_P2,
+	B_AX_PORT_FUNC_EN_P3, B_AX_PORT_FUNC_EN_P4
+};
+
+static u32 b_txbcnrpt_l[MAC_AX_PORT_NUM] = {
+	B_AX_TXBCN_RPT_EN_P0, B_AX_TXBCN_RPT_EN_P1, B_AX_TXBCN_RPT_EN_P2,
+	B_AX_TXBCN_RPT_EN_P3, B_AX_TXBCN_RPT_EN_P4
+};
+
+static u32 b_rxbcnrpt_l[MAC_AX_PORT_NUM] = {
+	B_AX_RXBCN_RPT_EN_P0, B_AX_RXBCN_RPT_EN_P1, B_AX_RXBCN_RPT_EN_P2,
+	B_AX_RXBCN_RPT_EN_P3, B_AX_RXBCN_RPT_EN_P4
+};
+
+static u32 b_rxupd_l[MAC_AX_PORT_NUM] = {
+	B_AX_RX_BSSID_FIT_EN_P0, B_AX_RX_BSSID_FIT_EN_P1,
+	B_AX_RX_BSSID_FIT_EN_P2, B_AX_RX_BSSID_FIT_EN_P3,
+	B_AX_RX_BSSID_FIT_EN_P4
+};
+
+static u32 b_rxtsfupd_l[MAC_AX_PORT_NUM] = {
+	B_AX_TSF_UDT_EN_P0, B_AX_TSF_UDT_EN_P1, B_AX_TSF_UDT_EN_P2,
+	B_AX_TSF_UDT_EN_P3, B_AX_TSF_UDT_EN_P4
+};
+
+static u32 b_bcntxen_l[MAC_AX_PORT_NUM] = {
+	B_AX_BCNTX_EN_P0, B_AX_BCNTX_EN_P1, B_AX_BCNTX_EN_P2,
+	B_AX_BCNTX_EN_P3, B_AX_BCNTX_EN_P4
+};
+
+static u32 b_phben_l[MAC_AX_PORT_NUM] = {
+	B_AX_TBTT_PROHIB_EN_P0, B_AX_TBTT_PROHIB_EN_P1, B_AX_TBTT_PROHIB_EN_P2,
+	B_AX_TBTT_PROHIB_EN_P3, B_AX_TBTT_PROHIB_EN_P4
+};
+
+static u32 b_shten_l[MAC_AX_PORT_NUM] = {
+	B_AX_TBTT_UPD_SHIFT_SEL_P0, B_AX_TBTT_UPD_SHIFT_SEL_P1,
+	B_AX_TBTT_UPD_SHIFT_SEL_P2, B_AX_TBTT_UPD_SHIFT_SEL_P3,
+	B_AX_TBTT_UPD_SHIFT_SEL_P4
+};
+
+static u32 b_brken_l[MAC_AX_PORT_NUM] = {
+	B_AX_BRK_SETUP_P0, B_AX_BRK_SETUP_P1, B_AX_BRK_SETUP_P2,
+	B_AX_BRK_SETUP_P3, B_AX_BRK_SETUP_P4
+};
+
+static u32 b_rsttsf_l[MAC_AX_PORT_NUM] = {
+	B_AX_TSFTR_RST_P0, B_AX_TSFTR_RST_P1, B_AX_TSFTR_RST_P2,
+	B_AX_TSFTR_RST_P3, B_AX_TSFTR_RST_P4
+};
+
+static u32 b_drpall_l[MAC_AX_PORT_NUM] = {
+	B_AX_BCN_DROP_ALL_P0, B_AX_BCN_DROP_ALL_P1, B_AX_BCN_DROP_ALL_P2,
+	B_AX_BCN_DROP_ALL_P3, B_AX_BCN_DROP_ALL_P4
+};
+
+static u32 b_rptvld_l[MAC_AX_PORT_NUM] = {
+	B_AX_RPT_VALID_P0, B_AX_RPT_VALID_P1, B_AX_RPT_VALID_P2,
+	B_AX_RPT_VALID_P3, B_AX_RPT_VALID_P4
+};
+
+static u32 b_timerr_l[MAC_AX_PORT_NUM] = {
+	B_AX_TIM_ILEGAL_P0, B_AX_TIM_ILEGAL_P1, B_AX_TIM_ILEGAL_P2,
+	B_AX_TIM_ILEGAL_P3, B_AX_TIM_ILEGAL_P4
+};
+
+static u32 b_mbid_en_l[MAC_AX_P0_MBID_MAX - 1] = {
+	B_AX_P0MB1_EN, B_AX_P0MB2_EN, B_AX_P0MB3_EN, B_AX_P0MB4_EN,
+	B_AX_P0MB5_EN, B_AX_P0MB6_EN, B_AX_P0MB7_EN, B_AX_P0MB8_EN,
+	B_AX_P0MB9_EN, B_AX_P0MB10_EN, B_AX_P0MB11_EN, B_AX_P0MB12_EN,
+	B_AX_P0MB13_EN, B_AX_P0MB14_EN, B_AX_P0MB15_EN
+};
+
+static u32 b_mbid_drp_l[MAC_AX_P0_MBID_MAX - 1] = {
+	B_AX_BCN_DROP_ALL_P0MB1, B_AX_BCN_DROP_ALL_P0MB2,
+	B_AX_BCN_DROP_ALL_P0MB3, B_AX_BCN_DROP_ALL_P0MB4,
+	B_AX_BCN_DROP_ALL_P0MB5, B_AX_BCN_DROP_ALL_P0MB6,
+	B_AX_BCN_DROP_ALL_P0MB7, B_AX_BCN_DROP_ALL_P0MB8,
+	B_AX_BCN_DROP_ALL_P0MB9, B_AX_BCN_DROP_ALL_P0MB10,
+	B_AX_BCN_DROP_ALL_P0MB11, B_AX_BCN_DROP_ALL_P0MB12,
+	B_AX_BCN_DROP_ALL_P0MB13, B_AX_BCN_DROP_ALL_P0MB14,
+	B_AX_BCN_DROP_ALL_P0MB15
+};
+
+static u32 b_hiq_nolmt_mbid_l[MAC_AX_P0_MBID_MAX - 1] = {
+	B_AX_HIQ_NO_LMT_EN_P0_VAP1, B_AX_HIQ_NO_LMT_EN_P0_VAP2,
+	B_AX_HIQ_NO_LMT_EN_P0_VAP3, B_AX_HIQ_NO_LMT_EN_P0_VAP4,
+	B_AX_HIQ_NO_LMT_EN_P0_VAP5, B_AX_HIQ_NO_LMT_EN_P0_VAP6,
+	B_AX_HIQ_NO_LMT_EN_P0_VAP7, B_AX_HIQ_NO_LMT_EN_P0_VAP8,
+	B_AX_HIQ_NO_LMT_EN_P0_VAP9, B_AX_HIQ_NO_LMT_EN_P0_VAP10,
+	B_AX_HIQ_NO_LMT_EN_P0_VAP11, B_AX_HIQ_NO_LMT_EN_P0_VAP12,
+	B_AX_HIQ_NO_LMT_EN_P0_VAP13, B_AX_HIQ_NO_LMT_EN_P0_VAP14,
+	B_AX_HIQ_NO_LMT_EN_P0_VAP15
+};
+
+static u32 b_hiq_nolmt_port_l[MAC_AX_PORT_NUM] = {
+	B_AX_HIQ_NO_LMT_EN_P0_ROOT, B_AX_HIQ_NO_LMT_EN_P1,
+	B_AX_HIQ_NO_LMT_EN_P2, B_AX_HIQ_NO_LMT_EN_P3, B_AX_HIQ_NO_LMT_EN_P4
+};
+
+static u32 mbid_idx_l[MAC_AX_P0_MBID_MAX] = {
+	MAC_AX_P0_ROOT, MAC_AX_P0_MBID1, MAC_AX_P0_MBID2, MAC_AX_P0_MBID3,
+	MAC_AX_P0_MBID4, MAC_AX_P0_MBID5, MAC_AX_P0_MBID6, MAC_AX_P0_MBID7,
+	MAC_AX_P0_MBID8, MAC_AX_P0_MBID9, MAC_AX_P0_MBID10, MAC_AX_P0_MBID11,
+	MAC_AX_P0_MBID12, MAC_AX_P0_MBID13, MAC_AX_P0_MBID14, MAC_AX_P0_MBID15
+};
+
+static u32 t32_togl_rpt_size =
+	sizeof(struct mac_ax_t32_togl_rpt) * MAC_AX_BAND_NUM * MAC_AX_PORT_NUM;
+static u32 port_info_size =
+	sizeof(struct mac_ax_port_info) * MAC_AX_BAND_NUM * MAC_AX_PORT_NUM;
+
+u32 get_bp_idx(u8 band, u8 port)
+{
+	return (band * MAC_AX_BAND_NUM + port);
+}
+
+u32 _get_port_cfg(struct mac_ax_adapter *adapter,
+		  enum mac_ax_port_cfg_type type,
+		  struct mac_ax_port_cfg_para *para)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 mbssid_idx = para->mbssid_idx;
+	u8 port = para->port;
+	u8 band = para->band;
+	u32 val32;
+	u16 val16;
+
+	if (!is_curr_dbcc(adapter) && band == MAC_AX_BAND_1) {
+		PLTFM_MSG_ERR("%s invalid band idx %d\n", __func__, band);
+		return MACFUNCINPUT;
+	}
+
+	if (port >= adapter->hw_info->port_num) {
+		PLTFM_MSG_ERR("%s invalid port idx %d\n", __func__, port);
+		return MACPORTERR;
+	}
+
+	if (mbssid_idx >= adapter->hw_info->mbssid_num) {
+		PLTFM_MSG_ERR("%s invalid mbssid %d\n", __func__, mbssid_idx);
+		return MACFUNCINPUT;
+	}
+
+	switch (type) {
+	case MAC_AX_PCFG_NET_TYPE:
+		val32 = MAC_REG_R32(cfg_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			para->val = GET_FIELD(val32, B_AX_NET_TYPE_P0);
+			break;
+		case MAC_AX_PORT_1:
+			para->val = GET_FIELD(val32, B_AX_NET_TYPE_P1);
+			break;
+		case MAC_AX_PORT_2:
+			para->val = GET_FIELD(val32, B_AX_NET_TYPE_P2);
+			break;
+		case MAC_AX_PORT_3:
+			para->val = GET_FIELD(val32, B_AX_NET_TYPE_P3);
+			break;
+		case MAC_AX_PORT_4:
+			para->val = GET_FIELD(val32, B_AX_NET_TYPE_P4);
+			break;
+		}
+		break;
+
+	case MAC_AX_PCFG_FUNC_SW:
+		val32 = MAC_REG_R32(cfg_regl[band][port]);
+		if (val32 & b_en_l[port])
+			para->val = 1;
+		else
+			para->val = 0;
+		break;
+
+	case MAC_AX_PCFG_BCN_INTV:
+		val32 = MAC_REG_R32(bcnspc_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			para->val = mbssid_idx ?
+				    GET_FIELD(val32, B_AX_SUB_BCN_SPACE_P0) :
+				    GET_FIELD(val32, B_AX_BCN_SPACE_P0);
+			break;
+		case MAC_AX_PORT_1:
+			para->val = GET_FIELD(val32, B_AX_BCN_SPACE_P1);
+			break;
+		case MAC_AX_PORT_2:
+			para->val = GET_FIELD(val32, B_AX_BCN_SPACE_P2);
+			break;
+		case MAC_AX_PORT_3:
+			para->val = GET_FIELD(val32, B_AX_BCN_SPACE_P3);
+			break;
+		case MAC_AX_PORT_4:
+			para->val = GET_FIELD(val32, B_AX_BCN_SPACE_P4);
+			break;
+		}
+		break;
+
+	case MAC_AX_PCFG_BCN_HOLD_TIME:
+		val32 = MAC_REG_R32(phb_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			para->val = GET_FIELD(val32, B_AX_TBTT_HOLD_P0);
+			break;
+		case MAC_AX_PORT_1:
+		case MAC_AX_PORT_2:
+		case MAC_AX_PORT_3:
+		case MAC_AX_PORT_4:
+			para->val = GET_FIELD(val32, B_AX_TBTT_HOLD_P1);
+			break;
+		}
+		break;
+
+	case MAC_AX_PCFG_BCN_ERLY:
+		val32 = MAC_REG_R32(bcn_early_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			para->val = GET_FIELD(val32, B_AX_BCNERLY_P0);
+			break;
+		case MAC_AX_PORT_1:
+			para->val = GET_FIELD(val32, B_AX_BCNERLY_P1);
+			break;
+		case MAC_AX_PORT_2:
+			para->val = GET_FIELD(val32, B_AX_BCNERLY_P2);
+			break;
+		case MAC_AX_PORT_3:
+			para->val = GET_FIELD(val32, B_AX_BCNERLY_P3);
+			break;
+		case MAC_AX_PORT_4:
+			para->val = GET_FIELD(val32, B_AX_BCNERLY_P4);
+			break;
+		}
+		break;
+
+	case MAC_AX_PCFG_BCN_SETUP_TIME:
+		val32 = MAC_REG_R32(phb_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			para->val = GET_FIELD(val32, B_AX_TBTT_SETUP_P0);
+			break;
+		case MAC_AX_PORT_1:
+		case MAC_AX_PORT_2:
+		case MAC_AX_PORT_3:
+		case MAC_AX_PORT_4:
+			para->val = GET_FIELD(val32, B_AX_TBTT_SETUP_P1);
+			break;
+		}
+		break;
+
+	case MAC_AX_PCFG_TBTT_ERLY:
+		val16 = MAC_REG_R16(tbttery_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			para->val = GET_FIELD(val16, B_AX_TBTTERLY_P0);
+			break;
+		case MAC_AX_PORT_1:
+			para->val = GET_FIELD(val16, B_AX_TBTTERLY_P1);
+			break;
+		case MAC_AX_PORT_2:
+			para->val = GET_FIELD(val16, B_AX_TBTTERLY_P2);
+			break;
+		case MAC_AX_PORT_3:
+			para->val = GET_FIELD(val16, B_AX_TBTTERLY_P3);
+			break;
+		case MAC_AX_PORT_4:
+			para->val = GET_FIELD(val16, B_AX_TBTTERLY_P4);
+			break;
+		}
+		break;
+	case MAC_AX_PCFG_BCN_MASK_AREA:
+		val32 = MAC_REG_R32(mskarea_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			para->val = GET_FIELD(val32, B_AX_BCN_MSK_AREA_P0);
+			break;
+		case MAC_AX_PORT_1:
+			para->val = GET_FIELD(val32, B_AX_BCN_MSK_AREA_P1);
+			break;
+		case MAC_AX_PORT_2:
+			para->val = GET_FIELD(val32, B_AX_BCN_MSK_AREA_P2);
+			break;
+		case MAC_AX_PORT_3:
+			para->val = GET_FIELD(val32, B_AX_BCN_MSK_AREA_P3);
+			break;
+		case MAC_AX_PORT_4:
+			para->val = GET_FIELD(val32, B_AX_BCN_MSK_AREA_P4);
+			break;
+		}
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR] invalid get cfg type %d\n", type);
+		return MACPORTCFGTYPE;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 _port_cfg(struct mac_ax_adapter *adapter,
+		     enum mac_ax_port_cfg_type type,
+		     struct mac_ax_port_cfg_para *para)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 set_val = para->val;
+	u8 port = para->port;
+	u8 band = para->band;
+	u32 val32;
+	u32 w_val32 = MAC_AX_R32_DEAD;
+
+	if (!is_curr_dbcc(adapter) && band == MAC_AX_BAND_1) {
+		PLTFM_MSG_ERR("%s invalid band idx %d\n", __func__, band);
+		return MACFUNCINPUT;
+	}
+
+	if (port >= adapter->hw_info->port_num) {
+		PLTFM_MSG_ERR("%s invalid port idx %d\n", __func__, port);
+		return MACPORTERR;
+	}
+
+	switch (type) {
+	case MAC_AX_PCFG_NET_TYPE:
+		val32 = MAC_REG_R32(cfg_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_NET_TYPE_P0);
+			break;
+		case MAC_AX_PORT_1:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_NET_TYPE_P1);
+			break;
+		case MAC_AX_PORT_2:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_NET_TYPE_P2);
+			break;
+		case MAC_AX_PORT_3:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_NET_TYPE_P3);
+			break;
+		case MAC_AX_PORT_4:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_NET_TYPE_P4);
+			break;
+		}
+		if (w_val32 != val32 && val32 != MAC_AX_R32_DEAD)
+			MAC_REG_W32(cfg_regl[band][port], w_val32);
+		break;
+
+	default:
+		PLTFM_MSG_ERR("[ERR] invalid cfg type %d\n", type);
+		return MACPORTCFGTYPE;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 _bcn_setup_chk(struct mac_ax_adapter *adapter, u8 band, u8 port,
+			  u32 *set_val)
+{
+	struct mac_ax_port_cfg_para cfg_para;
+	struct mac_ax_port_info *pinfo_self, *pinfo_tmp;
+	u32 ret;
+	u32 up_lmt = 0xFFFFFFFF;
+	u8 port_idx;
+
+	pinfo_self = &adapter->port_info[get_bp_idx(band, port)];
+
+	if (port == MAC_AX_PORT_0 && pinfo_self->stat == PORT_ST_DIS)
+		return MACSUCCESS;
+
+	if (*set_val > B_AX_TBTT_SETUP_P0_MSK) {
+		PLTFM_MSG_ERR("[ERR] illegal bcn setup time %d\n", *set_val);
+		return MACFUNCINPUT;
+	}
+
+	for (port_idx = MAC_AX_PORT_0; port_idx < MAC_AX_PORT_NUM; port_idx++) {
+		pinfo_tmp = &adapter->port_info[get_bp_idx(band, port_idx)];
+		if (pinfo_tmp->stat == PORT_ST_DIS)
+			continue;
+		if (port != MAC_AX_PORT_0 && port_idx == MAC_AX_PORT_0)
+			continue;
+
+		cfg_para.band = band;
+		cfg_para.port = port_idx;
+		cfg_para.mbssid_idx = 0;
+		cfg_para.val = 0;
+		ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_ERLY, &cfg_para);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]get port cfg bcn erly fail %d\n",
+				      ret);
+			return ret;
+		}
+
+		if (cfg_para.val < up_lmt)
+			up_lmt = cfg_para.val;
+
+		if (port == MAC_AX_PORT_0)
+			break;
+	}
+
+	if (*set_val >= up_lmt) {
+		PLTFM_MSG_WARN("[WARN]setup time %d over hw limit\n", *set_val);
+		*set_val = up_lmt - 1;
+		return MACSETVALERR;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 _bcn_mask_chk(struct mac_ax_adapter *adapter, u8 band, u8 port,
+			 u32 *set_val)
+{
+	struct mac_ax_port_cfg_para cfg_para;
+	struct mac_ax_port_info *pinfo;
+	u32 ret;
+
+	pinfo = &adapter->port_info[get_bp_idx(band, port)];
+
+	if (pinfo->stat == PORT_ST_DIS)
+		return MACSUCCESS;
+
+	if (*set_val > B_AX_BCN_MSK_AREA_P0_MSK) {
+		PLTFM_MSG_ERR("[ERR] illegal mask area %d\n", *set_val);
+		return MACFUNCINPUT;
+	}
+
+	cfg_para.band = band;
+	cfg_para.port = port;
+	cfg_para.mbssid_idx = 0;
+	cfg_para.val = 0;
+	ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_HOLD_TIME, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]get port cfg bcn hold fail %d\n", ret);
+		return ret;
+	}
+	if (*set_val > cfg_para.val) {
+		PLTFM_MSG_WARN("[WARN]mask area %d over hw limit\n", *set_val);
+		*set_val = cfg_para.val;
+		return MACSETVALERR;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 _bcn_hold_chk(struct mac_ax_adapter *adapter, u8 band, u8 port,
+			 u32 *set_val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_port_cfg_para cfg_para;
+	struct mac_ax_port_info *pinfo_self, *pinfo_tmp;
+	u32 ret, bcn_erly, bcn_spc, val32;
+	u8 port_idx;
+	u32 low_lmt = 0, up_lmt = 0xFFFFFFFF;
+
+	pinfo_self = &adapter->port_info[get_bp_idx(band, port)];
+
+	if (port == MAC_AX_PORT_0 && pinfo_self->stat == PORT_ST_DIS)
+		return MACSUCCESS;
+
+	if (*set_val > B_AX_TBTT_HOLD_P0_MSK) {
+		PLTFM_MSG_ERR("[ERR] illegal hold time %d\n", *set_val);
+		return MACFUNCINPUT;
+	}
+
+	for (port_idx = MAC_AX_PORT_0; port_idx < MAC_AX_PORT_NUM; port_idx++) {
+		pinfo_tmp = &adapter->port_info[get_bp_idx(band, port_idx)];
+		if (pinfo_tmp->stat == PORT_ST_DIS)
+			continue;
+		if (port != MAC_AX_PORT_0 && port_idx == MAC_AX_PORT_0)
+			continue;
+
+		cfg_para.band = band;
+		cfg_para.port = port_idx;
+		cfg_para.mbssid_idx = 0;
+		ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_MASK_AREA,
+				    &cfg_para);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]get port cfg mask area fail %d\n",
+				      ret);
+			return ret;
+		}
+
+		if (cfg_para.val > low_lmt)
+			low_lmt = cfg_para.val;
+
+		ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_ERLY, &cfg_para);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]get port cfg bcn erly fail %d\n",
+				      ret);
+			return ret;
+		}
+		bcn_erly = cfg_para.val;
+
+		if (port == MAC_AX_PORT_0 &&
+		    GET_FIELD(MAC_REG_R32(mbid_ctrl_regl[band]), B_AX_P0MB_NUM))
+			cfg_para.mbssid_idx = 1;
+		else
+			cfg_para.mbssid_idx = 0;
+		ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_INTV, &cfg_para);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]get port cfg bcn intv fail %d\n",
+				      ret);
+			return ret;
+		}
+		bcn_spc = cfg_para.val;
+
+		val32 = bcn_spc * TU_TO_BCN_SET - bcn_erly;
+		if (val32 < up_lmt)
+			up_lmt = val32;
+
+		if (port == MAC_AX_PORT_0)
+			break;
+	}
+
+	if (*set_val < low_lmt) {
+		PLTFM_MSG_WARN("[WARN]hold time %d below hw limit\n", *set_val);
+		*set_val = low_lmt;
+		return MACSETVALERR;
+	}
+
+	if (*set_val >= up_lmt) {
+		PLTFM_MSG_WARN("[WARN]hold time %d over hw limit\n", *set_val);
+		*set_val = up_lmt - 1;
+		return MACSETVALERR;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 _bcn_erly_chk(struct mac_ax_adapter *adapter, u8 band, u8 port,
+			 u32 *set_val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_port_cfg_para cfg_para;
+	struct mac_ax_port_info *pinfo;
+	u32 ret, bcn_hold, bcn_spc, val32;
+
+	pinfo = &adapter->port_info[get_bp_idx(band, port)];
+
+	if (pinfo->stat == PORT_ST_DIS)
+		return MACSUCCESS;
+
+	if (*set_val > B_AX_BCNERLY_P0_MSK || !*set_val) {
+		PLTFM_MSG_ERR("[ERR] illegal bcn erly %d\n", *set_val);
+		return MACFUNCINPUT;
+	}
+
+	cfg_para.band = band;
+	cfg_para.port = port;
+	cfg_para.mbssid_idx = 0;
+	cfg_para.val = 0;
+	ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_SETUP_TIME, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]get port cfg bcn setup fail %d\n", ret);
+		return ret;
+	}
+	if (*set_val <= cfg_para.val) {
+		PLTFM_MSG_WARN("[WARN]bcn erly %d below hw limit\n", *set_val);
+		*set_val = cfg_para.val + 1;
+		return MACSETVALERR;
+	}
+
+	cfg_para.band = band;
+	cfg_para.port = port;
+	cfg_para.mbssid_idx = 0;
+	cfg_para.val = 0;
+	ret = _get_port_cfg(adapter, MAC_AX_PCFG_TBTT_ERLY, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]get port cfg tbtt erly fail %d\n", ret);
+		return ret;
+	}
+	val32 = cfg_para.val / BCN_SET_TO_US;
+	if (*set_val <= val32) {
+		PLTFM_MSG_WARN("[WARN]bcn erly %d below hw limit\n", *set_val);
+		*set_val = val32 + 1;
+		return MACSETVALERR;
+	}
+
+	cfg_para.band = band;
+	cfg_para.port = port;
+	if (port == MAC_AX_PORT_0 &&
+	    GET_FIELD(MAC_REG_R32(mbid_ctrl_regl[band]), B_AX_P0MB_NUM))
+		cfg_para.mbssid_idx = 1;
+	else
+		cfg_para.mbssid_idx = 0;
+	cfg_para.val = 0;
+	ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_INTV, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]get port cfg bcn intv fail %d\n", ret);
+		return ret;
+	}
+	bcn_spc = cfg_para.val;
+
+	cfg_para.band = band;
+	cfg_para.port = port;
+	cfg_para.mbssid_idx = 0;
+	cfg_para.val = 0;
+	ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_HOLD_TIME, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] get port cfg bcn hold fail %d\n", ret);
+		return ret;
+	}
+	bcn_hold = cfg_para.val;
+
+	val32 = bcn_spc * TU_TO_BCN_SET - bcn_hold;
+	if (*set_val >= val32) {
+		PLTFM_MSG_WARN("[WARN]bcn erly %d over hw limit\n", *set_val);
+		*set_val = val32 - 1;
+		return MACSETVALERR;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 _tbtt_erly_chk(struct mac_ax_adapter *adapter, u8 band, u8 port,
+			  u32 *set_val)
+{
+	struct mac_ax_port_cfg_para cfg_para;
+	struct mac_ax_port_info *pinfo;
+	u32 ret, val32;
+
+	pinfo = &adapter->port_info[get_bp_idx(band, port)];
+
+	if (pinfo->stat == PORT_ST_DIS)
+		return MACSUCCESS;
+
+	if (*set_val > B_AX_TBTTERLY_P0_MSK) {
+		PLTFM_MSG_ERR("[ERR] illegal tbtt erly %d\n", *set_val);
+		return MACFUNCINPUT;
+	}
+
+	cfg_para.band = band;
+	cfg_para.port = port;
+	cfg_para.mbssid_idx = 0;
+	cfg_para.val = 0;
+	ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_ERLY, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]get port cfg bcn erly fail %d\n", ret);
+		return ret;
+	}
+	val32 = cfg_para.val * BCN_SET_TO_US;
+	if (*set_val >= val32) {
+		PLTFM_MSG_WARN("[WARN] tbtt erly %d over hw limit\n", *set_val);
+		*set_val = val32 - 1;
+		return MACSETVALERR;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 _set_max_mbid_num(struct mac_ax_adapter *adapter,
+			     struct mac_ax_port_cfg_para *para)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_port_cfg_para cfg_para;
+	u8 port = para->port;
+	u8 band = para->band;
+	u32 mbid_num = para->mbssid_idx;
+	u32 ret;
+	u32 bcn_erly;
+	u32 hold_time;
+	u32 subspc;
+	u32 val32, w_val32;
+
+	if (mbid_num && !(mbid_num % 2))
+		mbid_num++;
+
+	cfg_para.band = band;
+	cfg_para.port = port;
+	cfg_para.mbssid_idx = 0;
+
+	ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_ERLY, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d get cfg bcn_erly fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+	bcn_erly = cfg_para.val;
+
+	ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_HOLD_TIME, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d get cfg hold_time fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+	hold_time = cfg_para.val;
+
+	subspc = para->val / (mbid_num + 1);
+	if (bcn_erly + hold_time > subspc * TU_TO_BCN_SET) {
+		PLTFM_MSG_ERR("[ERR] BcnSubspc not enough for erly and hold time\n");
+		para->val = (bcn_erly + hold_time) / TU_TO_BCN_SET * (mbid_num + 1);
+		return MACSUBSPCERR;
+	}
+
+	//set interval
+	cfg_para.val = para->val;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_INTV, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg bcn intv fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	//set mbssid num
+	val32 = MAC_REG_R32(mbid_ctrl_regl[band]);
+	w_val32 = SET_CLR_WORD(val32, mbid_num, B_AX_P0MB_NUM);
+	if (val32 != w_val32)
+		MAC_REG_W32(mbid_ctrl_regl[band], w_val32);
+
+	//set subspace
+	val32 = MAC_REG_R32(bcnspc_regl[band][MAC_AX_PORT_0]);
+	if (mbid_num)
+		w_val32 = SET_CLR_WORD(val32, subspc, B_AX_SUB_BCN_SPACE_P0);
+	else
+		w_val32 = SET_CLR_WORD(val32, 0, B_AX_SUB_BCN_SPACE_P0);
+	if (w_val32 != val32)
+		MAC_REG_W32(bcnspc_regl[band][MAC_AX_PORT_0], w_val32);
+
+	return MACSUCCESS;
+}
+
+static u32 port0_mbid_set(struct mac_ax_adapter *adapter, u8 band, u8 mbid_num,
+			  u8 mbid_max)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, w_val32, i;
+
+	val32 = MAC_REG_R32(mbid_ctrl_regl[band]);
+	w_val32 = SET_CLR_WORD(val32, mbid_num, B_AX_P0MB_NUM);
+
+	for (i = 0; i < mbid_max; i++) {
+		if (i >= (MAC_AX_P0_MBID_MAX - 1)) {
+			PLTFM_MSG_ERR("mbid en idx %d over array %d\n", i,
+				      MAC_AX_P0_MBID_MAX - 1);
+			return MACCMP;
+		}
+		w_val32 &= ~b_mbid_en_l[i];
+	}
+
+	if (w_val32 != val32)
+		MAC_REG_W32(mbid_ctrl_regl[band], w_val32);
+
+	return MACSUCCESS;
+}
+
+static u32 port0_subspc_set(struct mac_ax_adapter *adapter, u8 band,
+			    u8 mbid_num, u32 *bcn_erly, u32 *hold_time)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 subspc_u32;
+	u32 val32, w_val32;
+	u32 ret = MACSUCCESS;
+
+	val32 = MAC_REG_R32(bcnspc_regl[band][MAC_AX_PORT_0]);
+	subspc_u32 = mbid_num ?
+		     (GET_FIELD(val32, B_AX_BCN_SPACE_P0) / (mbid_num + 1)) : 0;
+	if (subspc_u32 > B_AX_SUB_BCN_SPACE_P0_MSK) {
+		subspc_u32 = B_AX_SUB_BCN_SPACE_P0_MSK;
+		PLTFM_MSG_WARN("[WARN] sub space set to max %d\n", subspc_u32);
+	}
+
+	w_val32 = SET_CLR_WORD(val32, subspc_u32, B_AX_SUB_BCN_SPACE_P0);
+	if (w_val32 != val32)
+		MAC_REG_W32(bcnspc_regl[band][MAC_AX_PORT_0], w_val32);
+
+	subspc_u32 *= TU_TO_BCN_SET;
+	if (mbid_num && (BCN_HOLD_DEF + BCN_ERLY_DEF) > subspc_u32) {
+		*bcn_erly = subspc_u32 * BCN_ERLY_RATIO / BCN_ITVL_RATIO;
+		*hold_time = subspc_u32 * BCN_HOLD_RATIO / BCN_ITVL_RATIO;
+	}
+
+	return ret;
+}
+
+u32 dly_port_tu(struct mac_ax_adapter *adapter, u8 band, u8 port, u32 dly_tu)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 cnt;
+	u32 ori_tsf;
+	u32 dly_us = dly_tu * TU_UNIT;
+
+	cnt = dly_tu * PORT_DLY_TU_CNT_LMT;
+	ori_tsf = MAC_REG_R32(tsfl_regl[band][port]);
+	PLTFM_DELAY_US(TU_UNIT);
+	do {
+		val32 = MAC_REG_R32(tsfl_regl[band][port]);
+		if ((val32 >= ori_tsf &&
+		     (val32 - ori_tsf) >= dly_us) ||
+		    (val32 < ori_tsf &&
+		     (ori_tsf - val32 + 1) >= dly_us))
+			break;
+
+		if (val32 == ori_tsf) {
+			PLTFM_MSG_ERR("B%dP%d tsf not running 0x%X\n",
+				      band, port, val32);
+			return MACHWERR;
+		}
+
+		PLTFM_DELAY_US(TU_UNIT);
+		cnt--;
+	} while (cnt);
+
+	if (!cnt)
+		return MACPOLLTO;
+
+	return MACSUCCESS;
+}
+
+u32 dly_port_us(struct mac_ax_adapter *adapter, u8 band, u8 port, u32 dly_us)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 cnt;
+	u32 ori_tsf;
+
+	cnt = dly_us * PORT_DLY_US_CNT_LMT;
+	ori_tsf = MAC_REG_R32(tsfl_regl[band][port]);
+	PLTFM_DELAY_US(10);
+	do {
+		val32 = MAC_REG_R32(tsfl_regl[band][port]);
+		if ((val32 >= ori_tsf &&
+		     (val32 - ori_tsf) >= dly_us) ||
+		    (val32 < ori_tsf &&
+		     (ori_tsf - val32 + 1) >= dly_us))
+			break;
+
+		if (val32 == ori_tsf) {
+			PLTFM_MSG_ERR("B%dP%d tsf not running 0x%X\n",
+				      band, port, val32);
+			return MACHWERR;
+		}
+
+		PLTFM_DELAY_US(10);
+		cnt--;
+	} while (cnt);
+
+	if (!cnt)
+		return MACPOLLTO;
+
+	return MACSUCCESS;
+}
+
+u32 rst_port_info(struct mac_ax_adapter *adapter, u8 band)
+{
+	u8 p_idx;
+
+	for (p_idx = MAC_AX_PORT_0; p_idx < MAC_AX_PORT_NUM; p_idx++)
+		PLTFM_MEMSET(&adapter->port_info[get_bp_idx(band, p_idx)], 0,
+			     sizeof(struct mac_ax_port_info));
+
+	return MACSUCCESS;
+}
+
+static u32 chk_bcnq_empty(struct mac_ax_adapter *adapter, u8 band, u8 port,
+			  u32 bcn_spc, u8 *empty)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 bcnq_num_sh, bcnq_num_msk;
+	u32 cnt, emp_cont_cnt;
+	u32 ret;
+
+	*empty = 1;
+
+	val32 = MAC_REG_R32(ptcl_dbg_regl[band]);
+	val32 = SET_CLR_WORD(val32, PTCL_DBG_BCNQ_NUM0, B_AX_PTCL_DBG_SEL);
+	MAC_REG_W32(ptcl_dbg_regl[band], val32);
+	PLTFM_DELAY_US(PTCL_DBG_DLY_US);
+
+	cnt = CHK_BCNQ_CNT * bcn_spc;
+	emp_cont_cnt = 0;
+	do {
+		val32 = MAC_REG_R32(ptcl_dbg_info_regl[band]);
+		bcnq_num_sh = port * 2;
+		bcnq_num_msk = 3;
+		val32 = GET_FIEL2(val32, bcnq_num_sh, bcnq_num_msk);
+
+		if (val32)
+			emp_cont_cnt = 0;
+		else
+			emp_cont_cnt++;
+
+		if (emp_cont_cnt >= BCNQ_EMP_CONT_CNT) {
+			if (port == MAC_AX_PORT_0)
+				break;
+			return MACSUCCESS;
+		}
+
+		ret = dly_port_tu(adapter, band, port, 1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] dly B%dP%d %d tu fail %d\n",
+				      band, port, 1, ret);
+			return ret;
+		}
+		cnt--;
+	} while (cnt);
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR] chk bcnq empty0 %d timeout\n", val32);
+		*empty = 0;
+		return MACPOLLTO;
+	}
+
+	val32 = MAC_REG_R32(ptcl_dbg_regl[band]);
+	val32 = SET_CLR_WORD(val32, PTCL_DBG_BCNQ_NUM1, B_AX_PTCL_DBG_SEL);
+	MAC_REG_W32(ptcl_dbg_regl[band], val32);
+	PLTFM_DELAY_US(PTCL_DBG_DLY_US);
+
+	cnt = CHK_BCNQ_CNT * bcn_spc;
+	emp_cont_cnt = 0;
+	do {
+		val32 = MAC_REG_R32(ptcl_dbg_info_regl[band]);
+
+		if (val32)
+			emp_cont_cnt = 0;
+		else
+			emp_cont_cnt++;
+
+		if (emp_cont_cnt >= BCNQ_EMP_CONT_CNT)
+			return MACSUCCESS;
+
+		ret = dly_port_tu(adapter, band, port, 1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] dly B%dP%d %d tu fail %d\n",
+				      band, port, 1, ret);
+			return ret;
+		}
+		cnt--;
+	} while (cnt);
+
+	PLTFM_MSG_ERR("[ERR] chk bcnq empty1 %d timeout\n", val32);
+	*empty = 0;
+	return MACPOLLTO;
+}
+
+static u32 fast_bcn_drop(struct mac_ax_adapter *adapter, u8 band, u8 port,
+			 struct mac_ax_port_info *pinfo)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_port_cfg_para cfg_para;
+	u32 ret = MACSUCCESS;
+	u32 port_drp_sel;
+	u32 mbid_drp_sel = 0;
+	u32 val32;
+	u32 bcn_spc;
+	u8 mbid_num;
+	u8 is_empty;
+	u32 i;
+
+	cfg_para.band = band;
+	cfg_para.port = port;
+	cfg_para.mbssid_idx = 0;
+
+	port_drp_sel = (port == MAC_AX_PORT_0 ? B_AX_BCN_DROP_ALL_P0 : 0) |
+		       (port == MAC_AX_PORT_1 ? B_AX_BCN_DROP_ALL_P1 : 0) |
+		       (port == MAC_AX_PORT_2 ? B_AX_BCN_DROP_ALL_P2 : 0) |
+		       (port == MAC_AX_PORT_3 ? B_AX_BCN_DROP_ALL_P3 : 0) |
+		       (port == MAC_AX_PORT_4 ? B_AX_BCN_DROP_ALL_P4 : 0);
+	val32 = MAC_REG_R32(bcndrp_regl[band]) | port_drp_sel;
+	MAC_REG_W32(bcndrp_regl[band], val32);
+
+	if (port == MAC_AX_PORT_0 && pinfo->mbssid_en_stat == MAC_AX_MBSSID_ENABLED) {
+		mbid_drp_sel = B_AX_BCN_DROP_ALL_P0MB1 |
+			       B_AX_BCN_DROP_ALL_P0MB2 |
+			       B_AX_BCN_DROP_ALL_P0MB3;
+		if (!(is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		      is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)))
+			mbid_drp_sel |= B_AX_BCN_DROP_ALL_P0MB4 |
+					B_AX_BCN_DROP_ALL_P0MB5 |
+					B_AX_BCN_DROP_ALL_P0MB6 |
+					B_AX_BCN_DROP_ALL_P0MB7 |
+					B_AX_BCN_DROP_ALL_P0MB8 |
+					B_AX_BCN_DROP_ALL_P0MB9 |
+					B_AX_BCN_DROP_ALL_P0MB10 |
+					B_AX_BCN_DROP_ALL_P0MB11 |
+					B_AX_BCN_DROP_ALL_P0MB12 |
+					B_AX_BCN_DROP_ALL_P0MB13 |
+					B_AX_BCN_DROP_ALL_P0MB14 |
+					B_AX_BCN_DROP_ALL_P0MB15;
+		val32 = MAC_REG_R32(mbssid_drp_regl[band]) | mbid_drp_sel;
+		MAC_REG_W32(mbssid_drp_regl[band], val32);
+	}
+
+	cfg_para.val = 1;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_SETUP_TIME, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] port cfg func setup time fail %d\n", ret);
+		return ret;
+	}
+
+	cfg_para.val = 0;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_MASK_AREA, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] port cfg func mask area fail %d\n", ret);
+		return ret;
+	}
+
+	cfg_para.val = 0;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_HOLD_TIME, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] port cfg func hold time fail %d\n", ret);
+		return ret;
+	}
+
+	cfg_para.val = 2;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_ERLY, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] port cfg func bcn early fail %d\n", ret);
+		return ret;
+	}
+
+	cfg_para.val = 1;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_TBTT_ERLY, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] port cfg tbtt early fail %d\n", ret);
+		return ret;
+	}
+
+	if (port == MAC_AX_PORT_0 && pinfo->mbssid_en_stat == MAC_AX_MBSSID_ENABLED) {
+		mbid_num = adapter->hw_info->mbssid_num - 1;
+		bcn_spc = (u32)(mbid_num + 1) * BCN_FAST_DRP_TBTT;
+
+		val32 = MAC_REG_R32(bcnspc_regl[band][MAC_AX_PORT_0]);
+		val32 = SET_CLR_WORD(val32, BCN_FAST_DRP_TBTT,
+				     B_AX_SUB_BCN_SPACE_P0);
+		MAC_REG_W32(bcnspc_regl[band][MAC_AX_PORT_0], val32);
+		val32 = SET_CLR_WORD(val32, bcn_spc, B_AX_BCN_SPACE_P0);
+		MAC_REG_W32(bcnspc_regl[band][MAC_AX_PORT_0], val32);
+
+		val32 = MAC_REG_R32(mbid_ctrl_regl[band]);
+		val32 = SET_CLR_WORD(val32, mbid_num, B_AX_P0MB_NUM);
+		for (i = 0; i < mbid_num; i++)
+			val32 |= b_mbid_en_l[i];
+		MAC_REG_W32(mbid_ctrl_regl[band], val32);
+
+	} else {
+		bcn_spc = BCN_FAST_DRP_TBTT;
+		cfg_para.val = bcn_spc;
+		ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_INTV, &cfg_para);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] port cfg func bcn intv fail %d\n",
+				      ret);
+			return ret;
+		}
+	}
+
+	cfg_para.val = 1;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_TX_SW, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] port cfg tx sw fail %d\n", ret);
+		return ret;
+	}
+
+	ret = chk_bcnq_empty(adapter, band, port, bcn_spc, &is_empty);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] chk bcnq empty fail %d\n", ret);
+		return ret;
+	}
+
+	val32 = MAC_REG_R32(bcndrp_regl[band]) & ~port_drp_sel;
+	MAC_REG_W32(bcndrp_regl[band], val32);
+
+	if (port == MAC_AX_PORT_0 && pinfo->mbssid_en_stat == MAC_AX_MBSSID_ENABLED) {
+		val32 = MAC_REG_R32(mbssid_drp_regl[band]) & ~mbid_drp_sel;
+		MAC_REG_W32(mbssid_drp_regl[band], val32);
+	}
+
+	val32 = MAC_REG_R32(cfg_regl[band][port]) & ~b_phben_l[port];
+	MAC_REG_W32(cfg_regl[band][port], val32);
+
+	ret = dly_port_tu(adapter, band, port, bcn_spc + 1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d dly %d tu fail %d\n",
+			      band, port, bcn_spc + 1, ret);
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 _patch_port_dis_flow(struct mac_ax_adapter *adapter, u8 band, u8 port,
+			 struct mac_ax_port_info *pinfo)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_port_cfg_para cfg_para;
+	u32 bcn_set_bk = MAC_AX_R32_DEAD;
+	u32 bcn_spc;
+	u32 val32;
+	u32 ret = MACSUCCESS;
+	u16 val16;
+	u8 patch_flag, phb_bkp_flag;
+
+	patch_flag = chk_patch_port_dis_flow(adapter) ? 1 : 0;
+	phb_bkp_flag = patch_flag && port != MAC_AX_PORT_0 ? 1 : 0;
+
+	if (phb_bkp_flag)
+		bcn_set_bk = MAC_REG_R32(phb_regl[band][port]);
+
+	if (pinfo->stat == PORT_ST_AP || pinfo->stat == PORT_ST_ADHOC) {
+		ret = fast_bcn_drop(adapter, band, port, pinfo);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] fast bcn drop fail %d\n",
+				      ret);
+			goto end;
+		}
+	}
+
+	if (patch_flag) {
+		cfg_para.band = band;
+		cfg_para.port = port;
+		cfg_para.mbssid_idx = 0;
+		cfg_para.val = 0;
+		ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_INTV, &cfg_para);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] get port cfg bcn intv fail %d\n",
+				      ret);
+			goto end;
+		}
+		bcn_spc = cfg_para.val;
+
+		val32 = MAC_REG_R32(phb_regl[band][port]);
+		val32 = SET_CLR_WORD(val32, 0, B_AX_TBTT_SETUP_P0);
+		val32 = SET_CLR_WORD(val32, 1, B_AX_TBTT_HOLD_P0);
+		MAC_REG_W32(phb_regl[band][port], val32);
+
+		val16 = MAC_REG_R16(tbttery_regl[band][port]);
+		val16 = SET_CLR_WORD(val16, 0, B_AX_TBTTERLY_P0);
+		MAC_REG_W16(tbttery_regl[band][port], val16);
+
+		val16 = MAC_REG_R16(bcn_early_regl[band][port]);
+		val16 = SET_CLR_WORD(val16, 0, B_AX_BCNERLY_P0);
+		MAC_REG_W16(bcn_early_regl[band][port], val16);
+
+		ret = dly_port_tu(adapter, band, port, bcn_spc + 1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]B%dP%d dly %d tu fail %d\n",
+				      band, port, bcn_spc, ret);
+			goto end;
+		}
+	}
+
+	if (port == MAC_AX_PORT_0 && pinfo->mbssid_en_stat == MAC_AX_MBSSID_ENABLED) {
+		ret = port0_mbid_set(adapter, band, 0, adapter->hw_info->mbssid_num - 1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]B%dP%d mbid set fail %d\n",
+				      band, port, ret);
+			return ret;
+		}
+	}
+
+	val32 = MAC_REG_R32(cfg_regl[band][port]) &
+		~(b_en_l[port] | b_brken_l[port]);
+	MAC_REG_W32(cfg_regl[band][port], val32);
+	val32 |= b_rsttsf_l[port];
+	MAC_REG_W32(cfg_regl[band][port], val32);
+	MAC_REG_W32(cnt_tmr_regl[band][port], 0);
+
+	pinfo->stat = PORT_ST_DIS;
+end:
+	if (phb_bkp_flag) {
+		if (bcn_set_bk != MAC_AX_R32_DEAD) {
+			MAC_REG_W32(phb_regl[band][port], bcn_set_bk);
+		} else {
+			PLTFM_MSG_ERR("[ERR]prev ret %d\n", ret);
+			PLTFM_MSG_ERR("[ERR]B%dP%d phb reg dead\n", band, port);
+			ret = MACCMP;
+		}
+	}
+
+	return ret;
+}
+
+u32 _patch_tbtt_shift_setval(struct mac_ax_adapter *adapter, u32 bcnspc,
+			     u32 *shift_val)
+{
+	if (!chk_patch_tbtt_shift_setval(adapter))
+		return MACSUCCESS;
+
+	if (!*shift_val)
+		return MACSUCCESS;
+
+	if (*shift_val >= bcnspc)
+		return MACCMP;
+
+	*shift_val = (bcnspc - *shift_val) | TBTT_SHIFT_OFST_MSB;
+
+	return MACSUCCESS;
+}
+
+u32 mac_port_cfg(struct mac_ax_adapter *adapter,
+		 enum mac_ax_port_cfg_type type,
+		 struct mac_ax_port_cfg_para *para)
+{
+	struct mac_ax_port_cfg_para cfg_para;
+	struct mac_ax_port_info *pinfo;
+	u8 band = para->band;
+	u8 port = para->port;
+
+#if 0 // MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+#if MAC_AX_PHL_H2C
+		struct rtw_h2c_pkt *h2cb;
+#else
+		struct h2c_buf *h2cb;
+#endif
+		struct fwcmd_port_cfg *hdr;
+		u32 ret = MACSUCCESS;
+		u32 cnt;
+
+		if (para->band >= MAC_AX_BAND_NUM) {
+			PLTFM_MSG_ERR("[ERR]invalid band %d\n", para->band);
+			return MACFUNCINPUT;
+		}
+
+		if (para->port >= MAC_AX_PORT_NUM) {
+			PLTFM_MSG_ERR("[ERR]invalid port %d\n", para->port);
+			return MACFUNCINPUT;
+		}
+
+		pinfo = &adapter->port_info[get_bp_idx(band, port)];
+
+		cnt = PORT_H2C_DLY_CNT;
+		while (pinfo->h2c_sm == MAC_AX_PORT_H2C_BUSY) {
+			cnt--;
+			if (!cnt) {
+				PLTFM_MSG_ERR("[ERR]B%dP%d port H2C busy\n",
+					      band, port);
+				return MACPROCBUSY;
+			}
+			PLTFM_DELAY_US(PORT_H2C_DLY_US);
+		}
+
+		if (pinfo->h2c_sm == MAC_AX_PORT_H2C_FAIL) {
+			PLTFM_MSG_ERR("[ERR]prev B%dP%d port H2C fail\n",
+				      band, port);
+			return MACPROCERR;
+		}
+
+		h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+		if (!h2cb)
+			return MACNPTR;
+
+		hdr = (struct fwcmd_port_cfg *)
+		      h2cb_put(h2cb, sizeof(struct fwcmd_port_cfg));
+		if (!hdr) {
+			ret = MACNOBUF;
+			goto fail;
+		}
+
+		hdr->dword0 =
+			cpu_to_le32(SET_WORD(type, FWCMD_H2C_PORT_CFG_TYPE) |
+				    SET_WORD(para->mbssid_idx,
+					     FWCMD_H2C_PORT_CFG_MBSSID_IDX) |
+				    SET_WORD(port, FWCMD_H2C_PORT_CFG_PORT) |
+				    (band ? FWCMD_H2C_PORT_CFG_BAND : 0));
+
+		hdr->dword1 =
+			cpu_to_le32(SET_WORD(para->val, FWCMD_H2C_PORT_CFG_VAL));
+
+		ret = h2c_pkt_set_hdr(adapter, h2cb,
+				      FWCMD_TYPE_H2C,
+				      FWCMD_H2C_CAT_MAC,
+				      FWCMD_H2C_CL_MPORT,
+				      FWCMD_H2C_FUNC_PORT_CFG,
+				      0,
+				      0);
+		if (ret)
+			goto fail;
+
+		ret = h2c_pkt_build_txd(adapter, h2cb);
+		if (ret)
+			goto fail;
+
+#if MAC_AX_PHL_H2C
+		ret = PLTFM_TX(h2cb);
+#else
+		ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+		if (ret)
+			goto fail;
+
+		h2cb_free(adapter, h2cb);
+
+		h2c_end_flow(adapter);
+
+		pinfo->h2c_sm = MAC_AX_PORT_H2C_BUSY;
+
+		return MACSUCCESS;
+fail:
+		h2cb_free(adapter, h2cb);
+
+		return ret;
+	}
+#endif
+
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 mbssid_idx = para->mbssid_idx;
+	u32 set_val = para->val;
+	u8 val8, w_val8;
+	u16 val16;
+	u16 w_val16 = MAC_AX_R16_DEAD;
+	u32 val32;
+	u32 w_val32 = MAC_AX_R32_DEAD;
+	struct mac_ax_pkt_drop_info info;
+	u8 mbid_max;
+	u8 i = 0, j = 0;
+	u32 ret = MACSUCCESS;
+
+	if (!is_curr_dbcc(adapter) && band == MAC_AX_BAND_1) {
+		PLTFM_MSG_ERR("%s invalid band idx %d\n", __func__, band);
+		return MACFUNCINPUT;
+	}
+
+	if (port >= adapter->hw_info->port_num) {
+		PLTFM_MSG_ERR("%s invalid port idx %d\n", __func__, port);
+		return MACPORTERR;
+	}
+
+	mbid_max = adapter->hw_info->mbssid_num - 1;
+	if (mbssid_idx > (u32)mbid_max) {
+		PLTFM_MSG_ERR("%s invalid mbssid %d\n", __func__, mbssid_idx);
+		return MACFUNCINPUT;
+	}
+
+	pinfo = &adapter->port_info[get_bp_idx(band, port)];
+
+	switch (type) {
+	case MAC_AX_PCFG_FUNC_SW:
+		if (set_val) {
+			PLTFM_MSG_ERR("[ERR] use port init to enable port\n");
+			return MACFUNCINPUT;
+		}
+
+		if (pinfo->stat == PORT_ST_DIS) {
+			PLTFM_MSG_WARN("[WARN]B%dP%d stat already disable\n",
+				       band, port);
+			break;
+		}
+
+		ret = _patch_port_dis_flow(adapter, band, port, pinfo);
+
+		if (ret == MACSUCCESS) {
+			j = (port == 0 && pinfo->mbssid_en_stat == MAC_AX_MBSSID_ENABLED) ?
+			     mbid_max : 0;
+			for (i = 0; i <= j; i++) {
+				info.band = band;
+				info.port = port;
+				info.mbssid = (u8)mbid_idx_l[i];
+				info.sel = info.mbssid ?
+					   MAC_AX_PKT_DROP_SEL_HIQ_MBSSID :
+					   MAC_AX_PKT_DROP_SEL_HIQ_PORT;
+				ret = adapter->ops->pkt_drop(adapter, &info);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("[ERR]B%dP%d mbid%d hiq drop %d\n",
+						      band, port, info.mbssid, ret);
+					break;
+				}
+			}
+		}
+		pinfo->mbssid_en_stat = MAC_AX_MBSSID_INIT;
+		break;
+
+	case MAC_AX_PCFG_TX_SW:
+		val32 = MAC_REG_R32(cfg_regl[band][port]);
+		w_val32 = set_val ? val32 | b_bcntxen_l[port] :
+				    val32 & ~b_bcntxen_l[port];
+		if (w_val32 != val32)
+			MAC_REG_W32(cfg_regl[band][port], w_val32);
+		break;
+
+	case MAC_AX_PCFG_TX_RPT:
+		val32 = MAC_REG_R32(cfg_regl[band][port]);
+		w_val32 = set_val ? val32 | b_txbcnrpt_l[port] :
+				    val32 & ~b_txbcnrpt_l[port];
+		if (w_val32 != val32)
+			MAC_REG_W32(cfg_regl[band][port], w_val32);
+		break;
+
+	case MAC_AX_PCFG_RX_SW:
+		val32 = MAC_REG_R32(cfg_regl[band][port]);
+		w_val32 = set_val ? val32 | b_rxupd_l[port] :
+				    val32 & ~b_rxupd_l[port];
+		if (w_val32 != val32)
+			MAC_REG_W32(cfg_regl[band][port], w_val32);
+		break;
+
+	case MAC_AX_PCFG_RX_RPT:
+		val32 = MAC_REG_R32(cfg_regl[band][port]);
+		w_val32 = set_val ? val32 | b_rxbcnrpt_l[port] :
+				    val32 & ~b_rxbcnrpt_l[port];
+		if (w_val32 != val32)
+			MAC_REG_W32(cfg_regl[band][port], w_val32);
+		break;
+
+	case MAC_AX_PCFG_RX_SYNC:
+		val32 = MAC_REG_R32(cfg_regl[band][port]);
+		w_val32 = set_val ? val32 | b_rxtsfupd_l[port] :
+				    val32 & ~b_rxtsfupd_l[port];
+		if (w_val32 != val32)
+			MAC_REG_W32(cfg_regl[band][port], w_val32);
+		break;
+
+	case MAC_AX_PCFG_BCN_PRCT:
+		val32 = MAC_REG_R32(cfg_regl[band][port]);
+		w_val32 = set_val ? val32 | b_phben_l[port] | b_brken_l[port] :
+				    val32 & ~(b_phben_l[port] |
+					      b_brken_l[port]);
+		if (w_val32 != val32)
+			MAC_REG_W32(cfg_regl[band][port], w_val32);
+		break;
+
+	case MAC_AX_PCFG_TBTT_AGG:
+		if (set_val > B_AX_TBTT_AGG_NUM_P0_MSK) {
+			PLTFM_MSG_ERR("[ERR] illegal tbtt agg %d\n", set_val);
+			return MACFUNCINPUT;
+		}
+
+		val16 = MAC_REG_R16(tbttagg_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			w_val16 = SET_CLR_WORD(val16, set_val,
+					       B_AX_TBTT_AGG_NUM_P0);
+			break;
+		case MAC_AX_PORT_1:
+			w_val16 = SET_CLR_WORD(val16, set_val,
+					       B_AX_TBTT_AGG_NUM_P1);
+			break;
+		case MAC_AX_PORT_2:
+			w_val16 = SET_CLR_WORD(val16, set_val,
+					       B_AX_TBTT_AGG_NUM_P2);
+			break;
+		case MAC_AX_PORT_3:
+			w_val16 = SET_CLR_WORD(val16, set_val,
+					       B_AX_TBTT_AGG_NUM_P3);
+			break;
+		case MAC_AX_PORT_4:
+			w_val16 = SET_CLR_WORD(val16, set_val,
+					       B_AX_TBTT_AGG_NUM_P4);
+			break;
+		}
+		if (w_val16 != val16 && w_val16 != MAC_AX_R16_DEAD)
+			MAC_REG_W16(tbttagg_regl[band][port], w_val16);
+		break;
+
+	case MAC_AX_PCFG_TBTT_SHIFT:
+		if (set_val > B_AX_TBTT_SHIFT_OFST_P0_MSK) {
+			PLTFM_MSG_ERR("[ERR] illegal tbtt shift %d\n", set_val);
+			return MACFUNCINPUT;
+		}
+
+		cfg_para.band = band;
+		cfg_para.port = port;
+		cfg_para.mbssid_idx = 0;
+		cfg_para.val = 0;
+		ret = _get_port_cfg(adapter, MAC_AX_PCFG_BCN_INTV, &cfg_para);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]get port cfg bcn intv fail %d\n", ret);
+			return ret;
+		}
+		if (set_val >= cfg_para.val) {
+			PLTFM_MSG_ERR("tbtt shift %d over bcn spc %d\n",
+				      set_val, cfg_para.val);
+			return MACCMP;
+		}
+
+		ret = _patch_tbtt_shift_setval(adapter, cfg_para.val, &set_val);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("patch tbtt shift fail %d\n", ret);
+			return ret;
+		}
+
+		val32 = MAC_REG_R32(tbttsht_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_TBTT_SHIFT_OFST_P0);
+			break;
+		case MAC_AX_PORT_1:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_TBTT_SHIFT_OFST_P1);
+			break;
+		case MAC_AX_PORT_2:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_TBTT_SHIFT_OFST_P2);
+			break;
+		case MAC_AX_PORT_3:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_TBTT_SHIFT_OFST_P3);
+			break;
+		case MAC_AX_PORT_4:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_TBTT_SHIFT_OFST_P4);
+			break;
+		}
+		if (w_val32 != val32 && val32 != MAC_AX_R32_DEAD)
+			MAC_REG_W32(tbttsht_regl[band][port], w_val32);
+		break;
+
+	case MAC_AX_PCFG_RST_TSF:
+		val32 = MAC_REG_R32(cfg_regl[band][port]);
+		val32 = val32 | b_rsttsf_l[port];
+		MAC_REG_W32(cfg_regl[band][port], val32);
+		break;
+
+	case MAC_AX_PCFG_RST_TPR:
+		val32 = MAC_REG_R32(bcnpsr_regl[band][port]);
+		val32 |= b_rptvld_l[port];
+		MAC_REG_W32(bcnpsr_regl[band][port], val32);
+		break;
+
+	case MAC_AX_PCFG_HIQ_WIN:
+		if (set_val > B_AX_HGQWND_0_MSK) {
+			PLTFM_MSG_ERR("[ERR] illegal hiq win %d\n", set_val);
+			return MACFUNCINPUT;
+		}
+
+		if (port == MAC_AX_PORT_0)
+			MAC_REG_W8(hiq_win_mbid_regl[band][mbssid_idx],
+				   (u8)set_val);
+		else
+			MAC_REG_W8(hiq_win_port_regl[band][port],
+				   (u8)set_val);
+		break;
+
+	case MAC_AX_PCFG_HIQ_DTIM:
+		if (set_val > B_AX_DTIM_NUM_P0_MSK) {
+			PLTFM_MSG_ERR("[ERR] illegal dtim prd %d\n", set_val);
+			return MACFUNCINPUT;
+		}
+
+		val8 = MAC_REG_R8(dtim_switch[band]);
+		w_val8 = val8 | B_AX_UPD_TIMIE | B_AX_UPD_HGQMD;
+		if (w_val8 != val8)
+			MAC_REG_W8(dtim_switch[band], w_val8);
+
+		if (port == MAC_AX_PORT_0)
+			MAC_REG_W8(dtim_prd_mbid_regl[band][mbssid_idx],
+				   (u8)set_val);
+		else
+			MAC_REG_W8(dtim_prd_port_regl[band][port],
+				   (u8)set_val);
+		break;
+
+	case MAC_AX_PCFG_HIQ_NOLIMIT:
+		val32 = MAC_REG_R32(hiq_nolmt_regl[band]);
+		if (port == MAC_AX_PORT_0 && mbssid_idx)
+			w_val32 = set_val ?
+				  val32 | b_hiq_nolmt_mbid_l[mbssid_idx - 1] :
+				  val32 & ~b_hiq_nolmt_mbid_l[mbssid_idx - 1];
+		else
+			w_val32 = set_val ?
+				  val32 | b_hiq_nolmt_port_l[port] :
+				  val32 & ~b_hiq_nolmt_port_l[port];
+		if (w_val32 != val32)
+			MAC_REG_W32(hiq_nolmt_regl[band], w_val32);
+		break;
+
+	case MAC_AX_PCFG_BCN_SETUP_TIME:
+		ret = _bcn_setup_chk(adapter, band, port, &para->val);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_WARN("[WARN]bcn setup chk %d\n", ret);
+			return ret;
+		}
+
+		val32 = MAC_REG_R32(phb_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_TBTT_SETUP_P0);
+			break;
+		case MAC_AX_PORT_1:
+		case MAC_AX_PORT_2:
+		case MAC_AX_PORT_3:
+		case MAC_AX_PORT_4:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_TBTT_SETUP_P1);
+			break;
+		}
+		if (w_val32 != val32 && val32 != MAC_AX_R32_DEAD)
+			MAC_REG_W32(phb_regl[band][port], w_val32);
+		break;
+
+	case MAC_AX_PCFG_BCN_HOLD_TIME:
+		ret = _bcn_hold_chk(adapter, band, port, &para->val);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_WARN("[WARN]bcn hold chk %d\n", ret);
+			return ret;
+		}
+
+		val32 = MAC_REG_R32(phb_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_TBTT_HOLD_P0);
+			break;
+		case MAC_AX_PORT_1:
+		case MAC_AX_PORT_2:
+		case MAC_AX_PORT_3:
+		case MAC_AX_PORT_4:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_TBTT_HOLD_P1);
+			break;
+		}
+
+		if (w_val32 != val32 && val32 != MAC_AX_R32_DEAD)
+			MAC_REG_W32(phb_regl[band][port], w_val32);
+		break;
+
+	case MAC_AX_PCFG_MBSSID_EN:
+		if (port != MAC_AX_PORT_0 || !mbssid_idx) {
+			PLTFM_MSG_ERR("[ERR] mbssid en invalid for P%d MB%d\n",
+				      port, mbssid_idx);
+			return MACFUNCINPUT;
+		}
+
+		val32 = MAC_REG_R32(mbid_ctrl_regl[band]);
+		if (mbssid_idx > GET_FIELD(val32, B_AX_P0MB_NUM)) {
+			PLTFM_MSG_ERR("[ERR] mbssid %d over %d\n", set_val,
+				      GET_FIELD(val32, B_AX_P0MB_NUM));
+			return MACFUNCINPUT;
+		}
+
+		w_val32 = set_val ? val32 | b_mbid_en_l[mbssid_idx - 1] :
+				    val32 & ~b_mbid_en_l[mbssid_idx - 1];
+
+		if (w_val32 != val32)
+			MAC_REG_W32(mbid_ctrl_regl[band], w_val32);
+
+		info.band = band;
+		info.port = port;
+		info.mbssid = (u8)mbssid_idx;
+		info.sel = set_val ? MAC_AX_PKT_DROP_SEL_REL_HIQ_MBSSID :
+				     MAC_AX_PKT_DROP_SEL_HIQ_MBSSID;
+		ret = adapter->ops->pkt_drop(adapter, &info);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] B%d P%d MB%d hiq drop %d\n",
+				      band, port, mbssid_idx, ret);
+			return ret;
+		}
+		pinfo->mbssid_en_stat = MAC_AX_MBSSID_ENABLED;
+		break;
+
+	case MAC_AX_PCFG_BCN_ERLY:
+		ret = _bcn_erly_chk(adapter, band, port, &para->val);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_WARN("[WARN]bcn erly chk %d\n", ret);
+			return ret;
+		}
+
+		val32 = MAC_REG_R32(bcn_early_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			w_val32 = SET_CLR_WORD(val32, set_val, B_AX_BCNERLY_P0);
+			break;
+		case MAC_AX_PORT_1:
+			w_val32 = SET_CLR_WORD(val32, set_val, B_AX_BCNERLY_P1);
+			break;
+		case MAC_AX_PORT_2:
+			w_val32 = SET_CLR_WORD(val32, set_val, B_AX_BCNERLY_P2);
+			break;
+		case MAC_AX_PORT_3:
+			w_val32 = SET_CLR_WORD(val32, set_val, B_AX_BCNERLY_P3);
+			break;
+		case MAC_AX_PORT_4:
+			w_val32 = SET_CLR_WORD(val32, set_val, B_AX_BCNERLY_P4);
+			break;
+		}
+
+		if (w_val32 != val32 && val32 != MAC_AX_R32_DEAD)
+			MAC_REG_W32(bcn_early_regl[band][port], w_val32);
+		break;
+
+	case MAC_AX_PCFG_BCN_MASK_AREA:
+		ret = _bcn_mask_chk(adapter, band, port, &para->val);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_WARN("[WARN]bcn mask chk %d\n", ret);
+			return ret;
+		}
+
+		val32 = MAC_REG_R32(mskarea_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BCN_MSK_AREA_P0);
+			break;
+		case MAC_AX_PORT_1:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BCN_MSK_AREA_P1);
+			break;
+		case MAC_AX_PORT_2:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BCN_MSK_AREA_P2);
+			break;
+		case MAC_AX_PORT_3:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BCN_MSK_AREA_P3);
+			break;
+		case MAC_AX_PORT_4:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BCN_MSK_AREA_P4);
+			break;
+		}
+
+		if (w_val32 != val32 && val32 != MAC_AX_R32_DEAD)
+			MAC_REG_W32(mskarea_regl[band][port], w_val32);
+		break;
+
+	case MAC_AX_PCFG_TBTT_ERLY:
+		ret = _tbtt_erly_chk(adapter, band, port, &para->val);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_WARN("[WARN]tbtt erly chk %d\n", ret);
+			return ret;
+		}
+
+		val16 = MAC_REG_R16(tbttery_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			w_val16 = SET_CLR_WORD(val16, set_val,
+					       B_AX_TBTTERLY_P0);
+			break;
+		case MAC_AX_PORT_1:
+			w_val16 = SET_CLR_WORD(val16, set_val,
+					       B_AX_TBTTERLY_P1);
+			break;
+		case MAC_AX_PORT_2:
+			w_val16 = SET_CLR_WORD(val16, set_val,
+					       B_AX_TBTTERLY_P2);
+			break;
+		case MAC_AX_PORT_3:
+			w_val16 = SET_CLR_WORD(val16, set_val,
+					       B_AX_TBTTERLY_P3);
+			break;
+		case MAC_AX_PORT_4:
+			w_val16 = SET_CLR_WORD(val16, set_val,
+					       B_AX_TBTTERLY_P4);
+			break;
+		}
+
+		if (w_val16 != val16 && w_val16 != MAC_AX_R16_DEAD)
+			MAC_REG_W16(tbttery_regl[band][port], w_val16);
+		break;
+
+	case MAC_AX_PCFG_BSS_CLR:
+		if (set_val > B_AX_BSS_COLOB_AX_PORT_0_MSK) {
+			PLTFM_MSG_ERR("[ERR] illegal bss color %d\n", set_val);
+			return MACFUNCINPUT;
+		}
+
+		val32 = MAC_REG_R32(bss_color_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BSS_COLOB_AX_PORT_0);
+			break;
+		case MAC_AX_PORT_1:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BSS_COLOB_AX_PORT_1);
+			break;
+		case MAC_AX_PORT_2:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BSS_COLOB_AX_PORT_2);
+			break;
+		case MAC_AX_PORT_3:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BSS_COLOB_AX_PORT_3);
+			break;
+		case MAC_AX_PORT_4:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BSS_COLOB_AX_PORT_4);
+			break;
+		}
+
+		if (w_val32 != val32 && val32 != MAC_AX_R32_DEAD)
+			MAC_REG_W32(bss_color_regl[band][port], w_val32);
+		break;
+
+	case MAC_AX_PCFG_BCN_DRP_ALL:
+		if (port == MAC_AX_PORT_0 && mbssid_idx &&
+		    pinfo->mbssid_en_stat == MAC_AX_MBSSID_ENABLED) {
+			val32 = MAC_REG_R32(mbssid_drp_regl[band]);
+			w_val32 = set_val ?
+				  val32 | b_mbid_drp_l[mbssid_idx - 1] :
+				  val32 & ~b_mbid_drp_l[mbssid_idx - 1];
+			if (w_val32 != val32)
+				MAC_REG_W32(mbssid_drp_regl[band], w_val32);
+		} else {
+			val32 = MAC_REG_R32(bcndrp_regl[band]);
+			w_val32 = set_val ? val32 | b_drpall_l[port] :
+					    val32 & ~b_drpall_l[port];
+			if (w_val32 != val32)
+				MAC_REG_W32(bcndrp_regl[band], w_val32);
+		}
+		break;
+
+	case MAC_AX_PCFG_MBSSID_NUM:
+		if (port != MAC_AX_PORT_0 || pinfo->stat != PORT_ST_AP) {
+			PLTFM_MSG_ERR("[ERR]port is not 0 or is not AP\n");
+			return MACPORTERR;
+		}
+		_set_max_mbid_num(adapter, para);
+		break;
+
+	case MAC_AX_PCFG_BCN_INTV:
+		if (set_val > B_AX_BCN_SPACE_P0_MSK || !set_val) {
+			PLTFM_MSG_ERR("[ERR] illegal bcn itvl %d\n", set_val);
+			return MACFUNCINPUT;
+		}
+
+		val32 = MAC_REG_R32(bcnspc_regl[band][port]);
+		switch (port) {
+		case MAC_AX_PORT_0:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BCN_SPACE_P0);
+			break;
+		case MAC_AX_PORT_1:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BCN_SPACE_P1);
+			break;
+		case MAC_AX_PORT_2:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BCN_SPACE_P2);
+			break;
+		case MAC_AX_PORT_3:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BCN_SPACE_P3);
+			break;
+		case MAC_AX_PORT_4:
+			w_val32 = SET_CLR_WORD(val32, set_val,
+					       B_AX_BCN_SPACE_P4);
+			break;
+		}
+		if (w_val32 != val32 && val32 != MAC_AX_R32_DEAD)
+			MAC_REG_W32(bcnspc_regl[band][port], w_val32);
+		break;
+
+	default:
+		PLTFM_MSG_ERR("[ERR] invalid cfg type %d\n", type);
+		return MACPORTCFGTYPE;
+	}
+
+	return ret;
+}
+
+u32 mac_port_init(struct mac_ax_adapter *adapter,
+		  struct mac_ax_port_init_para *para)
+{
+	struct mac_ax_port_info *pinfo;
+	u8 band = para->band_idx;
+	u8 port = para->port_idx;
+	u8 net_type = para->net_type;
+
+#if 0 // MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+#if MAC_AX_PHL_H2C
+		struct rtw_h2c_pkt *h2cb;
+#else
+		struct h2c_buf *h2cb;
+#endif
+		struct fwcmd_port_init *hdr;
+		u32 ret = MACSUCCESS;
+		u32 cnt;
+
+		if (band >= MAC_AX_BAND_NUM) {
+			PLTFM_MSG_ERR("[ERR]invalid band %d\n", band);
+			return MACFUNCINPUT;
+		}
+
+		if (port >= MAC_AX_PORT_NUM) {
+			PLTFM_MSG_ERR("[ERR]invalid port %d\n", port);
+			return MACFUNCINPUT;
+		}
+
+		pinfo = &adapter->port_info[get_bp_idx(band, port)];
+		if (pinfo->h2c_sm == MAC_AX_PORT_H2C_FAIL) {
+			PLTFM_MSG_ERR("[ERR]prev B%dP%d port H2C fail\n",
+				      band, port);
+			return MACPROCERR;
+		}
+
+		cnt = PORT_H2C_DLY_CNT;
+		while (pinfo->h2c_sm == MAC_AX_PORT_H2C_BUSY) {
+			cnt--;
+			if (!cnt) {
+				PLTFM_MSG_ERR("[ERR]B%dP%d port H2C busy\n",
+					      band, port);
+				return MACPROCBUSY;
+			}
+			PLTFM_DELAY_US(PORT_H2C_DLY_US);
+		}
+
+		h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+		if (!h2cb)
+			return MACNPTR;
+
+		hdr = (struct fwcmd_port_init *)
+		      h2cb_put(h2cb, sizeof(struct fwcmd_port_init));
+		if (!hdr) {
+			ret = MACNOBUF;
+			goto fail;
+		}
+
+		hdr->dword0 =
+			cpu_to_le32(SET_WORD(para->bss_color,
+					     FWCMD_H2C_PORT_INIT_BSS_COLOR) |
+				    SET_WORD(para->mbid_num,
+					     FWCMD_H2C_PORT_INIT_MBSSID_NUM) |
+				    SET_WORD(para->dtim_period,
+					     FWCMD_H2C_PORT_INIT_DTIM_PRD) |
+				    SET_WORD(net_type,
+					     FWCMD_H2C_PORT_INIT_NET_TYPE) |
+				    SET_WORD(port, FWCMD_H2C_PORT_INIT_PORT) |
+				    (band ? FWCMD_H2C_PORT_INIT_BAND : 0));
+
+		hdr->dword1 =
+			cpu_to_le32(SET_WORD(para->hiq_win,
+					     FWCMD_H2C_PORT_INIT_HIQ_WND) |
+				    SET_WORD(para->bcn_interval,
+					     FWCMD_H2C_PORT_INIT_BCN_ITVL));
+
+		ret = h2c_pkt_set_hdr(adapter, h2cb,
+				      FWCMD_TYPE_H2C,
+				      FWCMD_H2C_CAT_MAC,
+				      FWCMD_H2C_CL_MPORT,
+				      FWCMD_H2C_FUNC_PORT_INIT,
+				      0,
+				      0);
+		if (ret)
+			goto fail;
+
+		ret = h2c_pkt_build_txd(adapter, h2cb);
+		if (ret)
+			goto fail;
+
+#if MAC_AX_PHL_H2C
+		ret = PLTFM_TX(h2cb);
+#else
+		ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+		if (ret)
+			goto fail;
+
+		h2cb_free(adapter, h2cb);
+
+		h2c_end_flow(adapter);
+
+		pinfo->h2c_sm = MAC_AX_PORT_H2C_BUSY;
+
+		return MACSUCCESS;
+fail:
+		h2cb_free(adapter, h2cb);
+
+		return ret;
+	}
+#endif
+
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_port_cfg_para cfg_para;
+	struct mac_ax_pkt_drop_info info;
+	u8 mbid_num;
+	u8 mbid_max;
+	u8 i = 0;
+	u32 ret = MACSUCCESS;
+	u32 val32;
+	u32 bcn_erly = BCN_ERLY_DEF;
+	u32 hold_time = BCN_HOLD_DEF;
+
+	if (!is_curr_dbcc(adapter) && band == MAC_AX_BAND_1) {
+		PLTFM_MSG_ERR("%s invalid band idx %d\n", __func__, band);
+		return MACFUNCINPUT;
+	}
+
+	if (port >= adapter->hw_info->port_num) {
+		PLTFM_MSG_ERR("%s invalid port idx %d\n", __func__, port);
+		return MACPORTERR;
+	}
+
+	mbid_num = net_type == MAC_AX_NET_TYPE_AP && port == MAC_AX_BAND_0 ?
+		   para->mbid_num : 0;
+	mbid_max = adapter->hw_info->mbssid_num - 1;
+	if (mbid_num > mbid_max) {
+		PLTFM_MSG_ERR("%s invalid MBSSID number %d\n", __func__, mbid_num);
+		return MACFUNCINPUT;
+	}
+	if (mbid_num && !(mbid_num % 2))
+		mbid_num++;
+
+	pinfo = &adapter->port_info[get_bp_idx(band, port)];
+
+	if (mbid_num)
+		pinfo->mbssid_en_stat = MAC_AX_MBSSID_ENABLED;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]chk mac en %d\n", ret);
+		return ret;
+	}
+
+	cfg_para.band = band;
+	cfg_para.port = port;
+	cfg_para.mbssid_idx = 0;
+
+	if (pinfo->stat != PORT_ST_DIS) {
+		cfg_para.val = 0;
+		ret = mac_port_cfg(adapter, MAC_AX_PCFG_FUNC_SW, &cfg_para);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]B%dP%d cfg func sw 0 fail %d\n",
+				      band, port, ret);
+			return ret;
+		}
+	}
+
+	cfg_para.val = 0;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_TX_RPT, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg tx rpt fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	cfg_para.val = 0;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_RX_RPT, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg rx rpt fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	cfg_para.val = net_type;
+	ret = _port_cfg(adapter, MAC_AX_PCFG_NET_TYPE, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg net type fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	cfg_para.val = net_type == MAC_AX_NET_TYPE_NO_LINK ? 0 : 1;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_PRCT, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg bcn prct fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	cfg_para.val = (net_type == MAC_AX_NET_TYPE_INFRA ||
+			net_type == MAC_AX_NET_TYPE_ADHOC) ? 1 : 0;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_RX_SW, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg rx sw fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	cfg_para.val = (net_type == MAC_AX_NET_TYPE_INFRA ||
+			net_type == MAC_AX_NET_TYPE_ADHOC) ? 1 : 0;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_RX_SYNC, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg rx sync fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	cfg_para.val = (net_type == MAC_AX_NET_TYPE_AP ||
+			net_type == MAC_AX_NET_TYPE_ADHOC) ? 1 : 0;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_TX_SW, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg tx sw fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	cfg_para.val = (u32)para->bcn_interval;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_INTV, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg bcn intv fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	cfg_para.val = (u32)para->bss_color;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_BSS_CLR, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg bss_color fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	cfg_para.val = TBTT_AGG_DEF;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_TBTT_AGG, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg tbtt agg fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	for (i = 0; i <= mbid_num; i++) {
+		cfg_para.mbssid_idx = mbid_idx_l[i];
+		cfg_para.val = para->hiq_win;
+		ret = mac_port_cfg(adapter, MAC_AX_PCFG_HIQ_WIN, &cfg_para);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]B%dP%d mbid%d cfg hiq win %d\n",
+				      band, port, cfg_para.mbssid_idx, ret);
+			return ret;
+		}
+		cfg_para.val = (u32)para->dtim_period;
+		ret = mac_port_cfg(adapter, MAC_AX_PCFG_HIQ_DTIM, &cfg_para);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]B%dP%d mbid%d cfg hiq dtim %d\n",
+				      band, port, cfg_para.mbssid_idx, ret);
+			return ret;
+		}
+
+		info.band = band;
+		info.port = port;
+		info.mbssid = (u8)mbid_idx_l[i];
+		//enable mbssid hiq drop, disable port hiq drop
+		info.sel = info.mbssid ?
+			   MAC_AX_PKT_DROP_SEL_HIQ_MBSSID :
+			   MAC_AX_PKT_DROP_SEL_REL_HIQ_PORT;
+		ret = adapter->ops->pkt_drop(adapter, &info);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]B%dP%d mbid%d hiq drop %d\n",
+				      band, port, info.mbssid, ret);
+			return ret;
+		}
+	}
+
+	if (port == MAC_AX_PORT_0) {
+		ret = port0_subspc_set(adapter, band, mbid_num,
+				       &bcn_erly, &hold_time);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]B%dP%d subspc set fail %d\n",
+				      band, port, ret);
+			return ret;
+		}
+	}
+
+	cfg_para.val = hold_time;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_HOLD_TIME, &cfg_para);
+	if (ret == MACSETVALERR)
+		ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_HOLD_TIME,
+				   &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg hold time fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	cfg_para.val = BCN_MASK_DEF;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_MASK_AREA, &cfg_para);
+	if (ret == MACSETVALERR)
+		ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_MASK_AREA,
+				   &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg mask area fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	val32 = MAC_REG_R32(cfg_regl[band][port]) | b_en_l[port];
+	MAC_REG_W32(cfg_regl[band][port], val32);
+
+	switch (net_type) {
+	case MAC_AX_NET_TYPE_NO_LINK:
+		pinfo->stat = PORT_ST_NOLINK;
+		break;
+	case MAC_AX_NET_TYPE_ADHOC:
+		pinfo->stat = PORT_ST_ADHOC;
+		break;
+	case MAC_AX_NET_TYPE_INFRA:
+		pinfo->stat = PORT_ST_INFRA;
+		break;
+	case MAC_AX_NET_TYPE_AP:
+		pinfo->stat = PORT_ST_AP;
+		break;
+	}
+
+	ret = dly_port_us(adapter, band, port, BCN_ERLY_SET_DLY);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d dly %d us fail %d\n",
+			      band, port, BCN_ERLY_SET_DLY, ret);
+		return ret;
+	}
+
+	cfg_para.val = bcn_erly;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_ERLY, &cfg_para);
+	if (ret == MACSETVALERR)
+		ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_ERLY, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg bcn early fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	cfg_para.val = BCN_SETUP_DEF;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_SETUP_TIME, &cfg_para);
+	if (ret == MACSETVALERR)
+		ret = mac_port_cfg(adapter, MAC_AX_PCFG_BCN_SETUP_TIME,
+				   &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg setup time fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	cfg_para.val = TBTT_ERLY_DEF;
+	ret = mac_port_cfg(adapter, MAC_AX_PCFG_TBTT_ERLY, &cfg_para);
+	if (ret == MACSETVALERR)
+		ret = mac_port_cfg(adapter, MAC_AX_PCFG_TBTT_ERLY, &cfg_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]B%dP%d cfg tbtt early fail %d\n",
+			      band, port, ret);
+		return ret;
+	}
+
+	if (port == MAC_AX_PORT_0) {
+		ret = port0_mbid_set(adapter, band, mbid_num, mbid_max);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]B%dP%d mbid set fail %d\n",
+				      band, port, ret);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+u32 mac_tsf_sync(struct mac_ax_adapter *adapter, u8 from_port, u8 to_port,
+		 s32 sync_offset, enum mac_ax_tsf_sync_act action)
+{
+	u32 abs_sync_offset, val32, ret = MACSUCCESS;
+	u16 to_port_reg;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (from_port > MAX_TSF_SOURCE_PORT || to_port > MAX_TSF_TARGET_PORT ||
+	    from_port == to_port) {
+		PLTFM_MSG_ERR("[ERR] Invalid tsf_sync port.\n");
+		return MACFUNCINPUT;
+	}
+
+	abs_sync_offset = sync_offset > 0 ? sync_offset : -sync_offset;
+
+	if (abs_sync_offset > MAX_TSF_SYNC_OFFSET) {
+		PLTFM_MSG_ERR("[ERR] Invalid tsf_sync offset.\n");
+		return MACFUNCINPUT;
+	}
+
+	if (sync_offset < 0)
+		abs_sync_offset |= BIT18;
+
+	switch (to_port) {
+	case MAC_AX_PORT_0:
+		to_port_reg = R_AX_PORT_0_TSF_SYNC;
+		break;
+	case MAC_AX_PORT_1:
+		to_port_reg = R_AX_PORT_1_TSF_SYNC;
+		break;
+	case MAC_AX_PORT_2:
+		to_port_reg = R_AX_PORT_2_TSF_SYNC;
+		break;
+	case MAC_AX_PORT_3:
+		to_port_reg = R_AX_PORT_3_TSF_SYNC;
+		break;
+	case MAC_AX_PORT_4:
+		to_port_reg = R_AX_PORT_4_TSF_SYNC;
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR] Invalid tsf_sync input.\n");
+		return MACFUNCINPUT;
+	}
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = MAC_REG_W_OFLD(to_port_reg,
+				     B_AX_P0_TSFTR_SYNC_OFFSET_MSK <<
+				     B_AX_P0_TSFTR_SYNC_OFFSET_SH,
+				     abs_sync_offset, 0);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s: write offload fail;"
+				      "offset: %u, ret: %u\n",
+				      __func__, to_port_reg, ret);
+			return ret;
+		}
+		ret = MAC_REG_W_OFLD(to_port_reg,
+				     B_AX_P0_SYNC_PORT_SRC_SEL_MSK <<
+				     B_AX_P0_SYNC_PORT_SRC_SEL_SH,
+				     from_port, 1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s: write offload fail;"
+				      "offset: %u, ret: %u\n",
+				      __func__, to_port_reg, ret);
+			return ret;
+		}
+
+		switch (action) {
+		case MAC_AX_TSF_SYNC_NOW_ONCE:
+			ret = MAC_REG_W_OFLD(to_port_reg, B_AX_P0_SYNC_NOW_P,
+					     1, 1);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s: write offload fail;"
+					      "offset: %u, ret: %u\n",
+					      __func__, to_port_reg, ret);
+				return ret;
+			}
+			ret = MAC_REG_P_OFLD(to_port_reg, B_AX_P0_SYNC_NOW_P,
+					     0, 1);
+			break;
+		case MAC_AX_TSF_EN_SYNC_AUTO:
+			ret = MAC_REG_W_OFLD(to_port_reg, B_AX_P0_AUTO_SYNC,
+					     1, 1);
+			break;
+		case MAC_AX_TSF_DIS_SYNC_AUTO:
+			ret = MAC_REG_W_OFLD(to_port_reg, B_AX_P0_AUTO_SYNC,
+					     0, 1);
+			break;
+		default:
+			PLTFM_MSG_ERR("[ERR] Invalid tsf_sync input.\n");
+			return MACFUNCINPUT;
+		}
+
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("%s: write offload fail;"
+				      "offset: %u, ret: %u\n",
+				      __func__, to_port_reg, ret);
+			return ret;
+		}
+
+		return ret;
+	}
+#endif
+	val32 = MAC_REG_R32(to_port_reg);
+	val32 = SET_CLR_WORD(val32, abs_sync_offset, B_AX_P0_TSFTR_SYNC_OFFSET);
+	val32 = SET_CLR_WORD(val32, from_port, B_AX_P0_SYNC_PORT_SRC_SEL);
+	MAC_REG_W32(to_port_reg, val32);
+
+	switch (action) {
+	case MAC_AX_TSF_SYNC_NOW_ONCE:
+		MAC_REG_W32(to_port_reg, val32 | B_AX_P0_SYNC_NOW_P);
+		break;
+	case MAC_AX_TSF_EN_SYNC_AUTO:
+		MAC_REG_W32(to_port_reg, val32 | B_AX_P0_AUTO_SYNC);
+		break;
+	case MAC_AX_TSF_DIS_SYNC_AUTO:
+		MAC_REG_W32(to_port_reg, val32 & ~B_AX_P0_AUTO_SYNC);
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR] Invalid tsf_sync input.\n");
+		return MACFUNCINPUT;
+	}
+
+	return ret;
+}
+
+u32 mac_parse_bcn_stats_c2h(struct mac_ax_adapter *adapter,
+			    u8 *content, struct mac_ax_bcn_cnt *val)
+
+{
+	u32 *pdata, data0, data1;
+	u8 port_mbssid;
+
+	pdata = (u32 *)content;
+	data0 = le32_to_cpu(*pdata);
+	data1 = le32_to_cpu(*(pdata + 1));
+
+	port_mbssid = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_PORT_MBSSID_IDX);
+	if (port_mbssid < MAC_AX_P0_MBID_LAST) {
+		val->port = 0;
+		val->mbssid = port_mbssid;
+	} else {
+		val->port = port_mbssid -  MAC_AX_P0_MBID_LAST + 1;
+		val->mbssid = 0;
+	}
+	val->band = data0 & FWCMD_C2H_BCN_CNT_BAND_IDX ? 1 : 0;
+
+	val->cca_cnt = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_CCA_FAIL_CNT);
+	val->edcca_cnt = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_EDCCA_FAIL_CNT);
+	val->nav_cnt = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_NAV_FAIL_CNT);
+	val->txon_cnt = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_TXON_FAIL_CNT);
+	val->mac_cnt = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_MAC_FAIL_CNT);
+	val->others_cnt = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_OTHERS_FAIL_CNT);
+	val->lock_cnt = GET_FIELD(data1, FWCMD_C2H_BCN_CNT_LOCK_FAIL_CNT);
+	val->cmp_cnt = GET_FIELD(data1, FWCMD_C2H_BCN_CNT_CMP_FAIL_CNT);
+	val->invalid_cnt = GET_FIELD(data1, FWCMD_C2H_BCN_CNT_INVALID_FAIL_CNT);
+	val->srchend_cnt = GET_FIELD(data1, FWCMD_C2H_BCN_CNT_SRCHEND_FAIL_CNT);
+	val->ok_cnt = GET_FIELD(data1, FWCMD_C2H_BCN_CNT_OK_CNT);
+
+	return MACSUCCESS;
+}
+
+u32 get_bcn_stats_event(struct mac_ax_adapter *adapter,
+			struct rtw_c2h_info *c2h,
+			enum phl_msg_evt_id *id, u8 *c2h_info)
+{
+	struct mac_ax_bcn_cnt *info;
+	u32 *pdata, data0, data1;
+	u8 port_mbssid;
+
+	info = (struct mac_ax_bcn_cnt *)c2h_info;
+	pdata = (u32 *)c2h->content;
+	data0 = le32_to_cpu(*pdata);
+	data1 = le32_to_cpu(*(pdata + 1));
+
+	port_mbssid = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_PORT_MBSSID_IDX);
+	if (port_mbssid < MAC_AX_P0_MBID_LAST) {
+		info->port = 0;
+		info->mbssid = port_mbssid;
+	} else {
+		info->port = port_mbssid -  MAC_AX_P0_MBID_LAST + 1;
+		info->mbssid = 0;
+	}
+	info->band = data0 & FWCMD_C2H_BCN_CNT_BAND_IDX ? 1 : 0;
+
+	info->cca_cnt = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_CCA_FAIL_CNT);
+	info->edcca_cnt = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_EDCCA_FAIL_CNT);
+	info->nav_cnt = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_NAV_FAIL_CNT);
+	info->txon_cnt = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_TXON_FAIL_CNT);
+	info->mac_cnt = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_MAC_FAIL_CNT);
+	info->others_cnt = GET_FIELD(data0, FWCMD_C2H_BCN_CNT_OTHERS_FAIL_CNT);
+	info->lock_cnt = GET_FIELD(data1, FWCMD_C2H_BCN_CNT_LOCK_FAIL_CNT);
+	info->cmp_cnt = GET_FIELD(data1, FWCMD_C2H_BCN_CNT_CMP_FAIL_CNT);
+	info->invalid_cnt = GET_FIELD(data1, FWCMD_C2H_BCN_CNT_INVALID_FAIL_CNT);
+	info->srchend_cnt = GET_FIELD(data1, FWCMD_C2H_BCN_CNT_SRCHEND_FAIL_CNT);
+	info->ok_cnt = GET_FIELD(data1, FWCMD_C2H_BCN_CNT_OK_CNT);
+
+	*id = MSG_EVT_BCN_CNT_RPT;
+
+	return MACSUCCESS;
+}
+
+u32 mac_tsf32_togl_h2c(struct mac_ax_adapter *adapter,
+		       struct mac_ax_t32_togl_info *info)
+{
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_tsf32_togl *hdr;
+	u32 ret = MACSUCCESS;
+	u8 band = info->band;
+	u8 port = info->port;
+
+	if (!is_curr_dbcc(adapter) && band == MAC_AX_BAND_1) {
+		PLTFM_MSG_ERR("%s invalid band idx %d\n", __func__, band);
+		return MACFUNCINPUT;
+	}
+
+	if (port >= adapter->hw_info->port_num) {
+		PLTFM_MSG_ERR("%s invalid port idx %d\n", __func__, port);
+		return MACPORTERR;
+	}
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_tsf32_togl *)
+	      h2cb_put(h2cb, sizeof(struct fwcmd_tsf32_togl));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(port, FWCMD_H2C_TSF32_TOGL_PORT) |
+			    SET_WORD(info->early, FWCMD_H2C_TSF32_TOGL_EARLY) |
+			    (band ? FWCMD_H2C_TSF32_TOGL_BAND : 0) |
+			    (info->en ? FWCMD_H2C_TSF32_TOGL_EN : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_TSF32_TOGL,
+			      0,
+			      0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_get_t32_togl_rpt(struct mac_ax_adapter *adapter,
+			 struct mac_ax_t32_togl_rpt *ret_rpt)
+{
+	struct mac_ax_t32_togl_rpt *rpt;
+	u8 b_idx, p_idx;
+
+	for (b_idx = MAC_AX_BAND_0; b_idx < MAC_AX_BAND_NUM; b_idx++) {
+		for (p_idx = MAC_AX_PORT_0; p_idx < MAC_AX_PORT_NUM; p_idx++) {
+			rpt = &adapter->t32_togl_rpt[get_bp_idx(b_idx, p_idx)];
+			if (!rpt->valid)
+				continue;
+			PLTFM_MEMCPY(ret_rpt, rpt,
+				     sizeof(struct mac_ax_t32_togl_rpt));
+			rpt->valid = 0;
+			return MACSUCCESS;
+		}
+	}
+
+	PLTFM_MSG_WARN("[WARN]no tsf32 togl rpt find\n");
+	return MACNOITEM;
+}
+
+u32 mport_info_init(struct mac_ax_adapter *adapter)
+{
+	u8 b_idx, p_idx;
+	u32 idx;
+
+	adapter->t32_togl_rpt =
+		(struct mac_ax_t32_togl_rpt *)PLTFM_MALLOC(t32_togl_rpt_size);
+	adapter->port_info =
+		(struct mac_ax_port_info *)PLTFM_MALLOC(port_info_size);
+	for (b_idx = MAC_AX_BAND_0; b_idx < MAC_AX_BAND_NUM; b_idx++) {
+		for (p_idx = MAC_AX_PORT_0; p_idx < MAC_AX_PORT_NUM; p_idx++) {
+			idx = get_bp_idx(b_idx, p_idx);
+			PLTFM_MEMSET(&adapter->t32_togl_rpt[idx], 0,
+				     sizeof(struct mac_ax_t32_togl_rpt));
+			PLTFM_MEMSET(&adapter->port_info[idx], 0,
+				     sizeof(struct mac_ax_port_info));
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mport_info_exit(struct mac_ax_adapter *adapter)
+{
+	PLTFM_FREE(adapter->t32_togl_rpt, t32_togl_rpt_size);
+	PLTFM_FREE(adapter->port_info, port_info_size);
+
+	return MACSUCCESS;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mport.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mport.h
new file mode 100644
index 000000000000..0f45c6bae6ad
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/mport.h
@@ -0,0 +1,298 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_MPORT_H_
+#define _MAC_AX_MPORT_H_
+
+#include "../type.h"
+
+/*--------------------Define -------------------------------------------*/
+#define BCN_ERLY_DEF 160
+#define BCN_SETUP_DEF 4
+#define BCN_HOLD_DEF 400
+#define BCN_MASK_DEF 0
+#define TBTT_ERLY_DEF 5
+#define TBTT_AGG_DEF 1
+#define BCN_SET_TO_US 32
+#define TU_TO_BCN_SET (1024 / BCN_SET_TO_US)
+#define BCN_ERLY_SET_DLY 10
+
+#define PTCL_DBG_BCNQ_NUM0 8
+#define PTCL_DBG_BCNQ_NUM1 9
+#define PTCL_DBG_DLY_US 100
+
+#define TU_UNIT 1024
+#define MS_UNIT 1000
+#define PORT_DLY_TU_CNT_LMT 200
+#define PORT_DLY_US_CNT_LMT 200
+
+#define MAX_BCN_ITVL 0x639C
+
+#define CHK_BCNQ_CNT 200
+#define BCNQ_EMP_CONT_CNT 2
+
+#define LBK_PLCP_DLY_DEF 0x28
+#define LBK_PLCP_DLY_FPGA 0x46
+
+#define BCN_FAST_DRP_TBTT 1
+
+/* 50% hold time , 30% beacon early */
+#define BCN_ERLY_RATIO 3
+#define BCN_HOLD_RATIO 5
+#define BCN_ITVL_RATIO 10
+
+#define PORT_H2C_DLY_US 10
+#define PORT_H2C_DLY_CNT 20000
+
+#define TBTT_SHIFT_OFST_MSB 0x800
+
+/*--------------------Define MACRO--------------------------------------*/
+/*--------------------Define Enum---------------------------------------*/
+enum port_stat {
+	PORT_ST_DIS = 0,
+	PORT_ST_NOLINK,
+	PORT_ST_ADHOC,
+	PORT_ST_INFRA,
+	PORT_ST_AP,
+};
+
+enum C2H_MPORT_RET_CODE {
+	C2H_MPORT_RET_SUCCESS = 0,
+	C2H_MPORT_RET_PENDING,
+	C2H_MPORT_RET_BAND_ERR,
+	C2H_MPORT_RET_PORT_ERR,
+	C2H_MPORT_RET_MBID_ERR,
+	C2H_MPORT_RET_NO_CONTENT,
+	C2H_MPORT_RET_TSF32TOG_C2H_FAIL,
+	C2H_MPORT_RET_CFG_TYPE_ERR,
+	C2H_MPORT_RET_SET_CFG_ILEGAL_EN,
+	C2H_MPORT_RET_SET_CFG_ARDY_DIS,
+	C2H_MPORT_RET_INPUT_ILEGAL,
+	C2H_MPORT_RET_CHK_BELW_LMT,
+	C2H_MPORT_RET_CHK_OVER_LMT,
+	C2H_MPORT_RET_SUB_SPC_ERR,
+	C2H_MPORT_RET_POLL_TO,
+	C2H_MPORT_RET_TSF_NOT_RUN,
+	C2H_MPORT_RET_MALLOC_FAIL,
+	C2H_MPORT_RET_DEINIT_FAIL,
+	C2H_MPORT_RET_PKT_DROP,
+	C2H_MPORT_RET_ADD_PSTIMER,
+	C2H_MPORT_RET_CHK_BCNQ_TO,
+	C2H_MPORT_RET_CHK_BCNQ_FAIL,
+	C2H_MPORT_RET_SEND_C2H_INIT,
+	C2H_MPORT_RET_SEND_C2H_CFG,
+};
+
+/*--------------------Define Struct-------------------------------------*/
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup MultiPort
+ * @{
+ */
+/**
+ * @brief dly_port_tu
+ *
+ * @param *adapter
+ * @param band
+ * @param port
+ * @param dly_tu
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dly_port_tu(struct mac_ax_adapter *adapter, u8 band, u8 port, u32 dly_tu);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup MultiPort
+ * @{
+ */
+
+/**
+ * @brief dly_port_us
+ *
+ * @param *adapter
+ * @param band
+ * @param port
+ * @param dly_us
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dly_port_us(struct mac_ax_adapter *adapter, u8 band, u8 port, u32 dly_us);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup MultiPort
+ * @{
+ */
+
+/**
+ * @brief rst_port_info
+ *
+ * @param *adapter
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 rst_port_info(struct mac_ax_adapter *adapter, u8 band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup MultiPort
+ * @{
+ */
+
+/**
+ * @brief mac_port_cfg
+ *
+ * @param *adapter
+ * @param type
+ * @param *para
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_port_cfg(struct mac_ax_adapter *adapter,
+		 enum mac_ax_port_cfg_type type,
+		 struct mac_ax_port_cfg_para *para);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup MultiPort
+ * @{
+ */
+
+/**
+ * @brief mac_port_init
+ *
+ * @param *adapter
+ * @param *para
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_port_init(struct mac_ax_adapter *adapter,
+		  struct mac_ax_port_init_para *para);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup MultiPort
+ * @{
+ */
+
+/**
+ * @brief mac_tsf_sync
+ *
+ * @param *adapter
+ * @param from_port
+ * @param to_port
+ * @param sync_offset
+ * @param action
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_tsf_sync(struct mac_ax_adapter *adapter, u8 from_port, u8 to_port,
+		 s32 sync_offset, enum mac_ax_tsf_sync_act action);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup MultiPort
+ * @{
+ */
+
+/**
+ * @brief mac_parse_bcn_stats_c2h
+ *
+ * @param *adapter
+ * @param *content
+ * @param *val
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_parse_bcn_stats_c2h(struct mac_ax_adapter *adapter,
+			    u8 *content, struct mac_ax_bcn_cnt *val);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup MultiPort
+ * @{
+ */
+
+/**
+ * @brief get_bcn_stats_event
+ *
+ * @param *adapter
+ * @param *c2h
+ * @param *id
+ * @param *c2h_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_bcn_stats_event(struct mac_ax_adapter *adapter,
+			struct rtw_c2h_info *c2h,
+			enum phl_msg_evt_id *id, u8 *c2h_info);
+/**
+ * @}
+ * @}
+ */
+
+u32 mac_tsf32_togl_h2c(struct mac_ax_adapter *adapter,
+		       struct mac_ax_t32_togl_info *info);
+
+u32 mac_get_t32_togl_rpt(struct mac_ax_adapter *adapter,
+			 struct mac_ax_t32_togl_rpt *ret_rpt);
+
+u32 get_bp_idx(u8 band, u8 port);
+
+u32 mport_info_init(struct mac_ax_adapter *adapter);
+
+u32 mport_info_exit(struct mac_ax_adapter *adapter);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/nan.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/nan.c
new file mode 100644
index 000000000000..f3ef7ae24696
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/nan.c
@@ -0,0 +1,538 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2021 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "nan.h"
+
+u32 mac_get_act_schedule_id(struct mac_ax_adapter *adapter,
+			    struct mac_ax_act_ack_info *act_ack_info)
+{
+	struct mac_ax_act_ack_info *ack_info = &adapter->nan_info.nan_act_ack_info;
+
+	PLTFM_MEMCPY(act_ack_info, &adapter->nan_info.nan_act_ack_info,
+		     sizeof(struct mac_ax_act_ack_info));
+	PLTFM_MSG_TRACE("act ack id =  %d\n", ack_info->schedule_id);
+	return MACSUCCESS;
+}
+
+u32 mac_check_cluster_info(struct mac_ax_adapter *adapter, struct mac_ax_nan_info *cluster_info)
+{
+	struct mac_ax_nan_info *ack_cluster_info = &adapter->nan_info;
+
+	PLTFM_MEMCPY(cluster_info, &adapter->nan_info, sizeof(struct mac_ax_nan_info));
+	PLTFM_MSG_TRACE("info ambtt =  %d\n", ack_cluster_info->rpt_ambtt);
+	return MACSUCCESS;
+}
+
+u32 mac_nan_act_schedule_req(struct mac_ax_adapter *adapter, struct mac_ax_nan_sched_info *info)
+{
+	u32 ret = MACSUCCESS;
+
+    #if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+
+	struct fwcmd_act_schedule_req *hdr;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+    /*h2c access*/
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_act_schedule_req *)
+				h2cb_put(h2cb, sizeof(struct fwcmd_act_schedule_req));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(info->module_id, FWCMD_H2C_ACT_SCHEDULE_REQ_MODULE_ID) |
+			    SET_WORD(info->priority, FWCMD_H2C_ACT_SCHEDULE_REQ_PRIORITY) |
+			    SET_WORD(info->options, FWCMD_H2C_ACT_SCHEDULE_REQ_OPTIONS) |
+			    (info->faw_en ? FWCMD_H2C_ACT_SCHEDULE_REQ_FAW_EN : 0));
+
+	hdr->dword1 =
+		cpu_to_le32(SET_WORD(info->start_time, FWCMD_H2C_ACT_SCHEDULE_REQ_START_TIME));
+
+	hdr->dword2 =
+		cpu_to_le32(SET_WORD(info->duration, FWCMD_H2C_ACT_SCHEDULE_REQ_DURATION));
+
+	hdr->dword3 =
+		cpu_to_le32(SET_WORD(info->period, FWCMD_H2C_ACT_SCHEDULE_REQ_PERIOD));
+
+	hdr->dword4 =
+		cpu_to_le32(SET_WORD(info->tsf_idx, FWCMD_H2C_ACT_SCHEDULE_REQ_TSF_IDX) |
+			SET_WORD(info->channel, FWCMD_H2C_ACT_SCHEDULE_REQ_CHANNEL) |
+			SET_WORD(info->bw, FWCMD_H2C_ACT_SCHEDULE_REQ_BW) |
+			SET_WORD(info->primary_ch_idx, FWCMD_H2C_ACT_SCHEDULE_REQ_PRIMARY_CH_IDX));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_NAN,
+			      FWCMD_H2C_FUNC_ACT_SCHEDULE_REQ, 0, 0);
+
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_nan_bcn_req(struct mac_ax_adapter *adapter, struct mac_ax_nan_bcn *info)
+{
+	u32 ret = MACSUCCESS;
+
+    #if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+
+	struct fwcmd_bcn_req *hdr;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+    /*h2c access*/
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_bcn_req *)h2cb_put(h2cb, sizeof(struct fwcmd_bcn_req));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(info->module_id, FWCMD_H2C_BCN_REQ_MODULE_ID) |
+			    SET_WORD(info->bcn_intvl_ms, FWCMD_H2C_BCN_REQ_BCN_INTVL_MS) |
+			    SET_WORD(info->priority, FWCMD_H2C_BCN_REQ_PRIORITY));
+
+	hdr->dword1 =
+		cpu_to_le32(SET_WORD(info->bcn_offset_us, FWCMD_H2C_BCN_REQ_BCN_OFFSET_US));
+
+	hdr->dword2 =
+		cpu_to_le32(SET_WORD(info->cur_tbtt, FWCMD_H2C_BCN_REQ_CUR_TBTT));
+
+	hdr->dword3 =
+		cpu_to_le32(SET_WORD(info->cur_tbtt_fr, FWCMD_H2C_BCN_REQ_CUR_TBTT_FR));
+
+	hdr->dword4 =
+		cpu_to_le32(SET_WORD(info->prohibit_before_ms,
+				     FWCMD_H2C_BCN_REQ_PROHIBIT_BEFORE_MS) |
+			    SET_WORD(info->prohibit_after_ms, FWCMD_H2C_BCN_REQ_PROHIBIT_AFTER_MS) |
+			    SET_WORD(info->port_idx, FWCMD_H2C_BCN_REQ_PORT_IDX) |
+			    SET_WORD(info->options, FWCMD_H2C_BCN_REQ_OPTIONS));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_NAN,
+			      FWCMD_H2C_FUNC_BCN_REQ, 0, 1);
+
+		if (ret != MACSUCCESS)
+			goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_nan_func_ctrl(struct mac_ax_adapter *adapter, struct mac_ax_nan_func_info *info)
+{
+	u32 ret = MACSUCCESS;
+
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+
+	struct fwcmd_nan_func_ctrl *hdr;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+    /*h2c access*/
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_nan_func_ctrl *)h2cb_put(h2cb, sizeof(struct fwcmd_nan_func_ctrl));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(info->port_idx, FWCMD_H2C_NAN_FUNC_CTRL_PORT_IDX) |
+			SET_WORD(info->mac_id, FWCMD_H2C_NAN_FUNC_CTRL_MAC_ID) |
+			SET_WORD(info->master_pref, FWCMD_H2C_NAN_FUNC_CTRL_MASTER_PREF) |
+			SET_WORD(info->random_factor, FWCMD_H2C_NAN_FUNC_CTRL_RANDOM_FACTOR));
+
+	hdr->dword1 =
+		cpu_to_le32(SET_WORD(info->op_ch_24g, FWCMD_H2C_NAN_FUNC_CTRL_OP_CH_24G) |
+			SET_WORD(info->op_ch_5g, FWCMD_H2C_NAN_FUNC_CTRL_OP_CH_5G) |
+			SET_WORD(info->options, FWCMD_H2C_NAN_FUNC_CTRL_OPTIONS));
+
+	hdr->dword2 =
+		cpu_to_le32(SET_WORD(info->time_indicate_period,
+				     FWCMD_H2C_NAN_FUNC_CTRL_TIME_INDICATE_PERIOD) |
+			SET_WORD(info->cluster_id[0], FWCMD_H2C_NAN_FUNC_CTRL_NAN_CLUSTER_ID0) |
+			SET_WORD(info->cluster_id[1], FWCMD_H2C_NAN_FUNC_CTRL_NAN_CLUSTER_ID1) |
+			SET_WORD(info->cluster_id[2], FWCMD_H2C_NAN_FUNC_CTRL_NAN_CLUSTER_ID2));
+
+	hdr->dword3 =
+		cpu_to_le32(SET_WORD(info->cluster_id[3], FWCMD_H2C_NAN_FUNC_CTRL_NAN_CLUSTER_ID3) |
+			SET_WORD(info->cluster_id[4], FWCMD_H2C_NAN_FUNC_CTRL_NAN_CLUSTER_ID4) |
+			SET_WORD(info->cluster_id[5], FWCMD_H2C_NAN_FUNC_CTRL_NAN_CLUSTER_ID5) |
+			SET_WORD(info->rsvd, FWCMD_H2C_NAN_FUNC_CTRL_NAN_RSVD));
+
+	hdr->dword4 =
+		cpu_to_le32(SET_WORD(info->para_options, FWCMD_H2C_NAN_FUNC_CTRL_PARA_OPTIONS) |
+			SET_WORD(info->fw_test_para_1, FWCMD_H2C_NAN_FUNC_CTRL_NAN_FW_TEST_PARA_1) |
+			SET_WORD(info->fw_test_para_2, FWCMD_H2C_NAN_FUNC_CTRL_NAN_FW_TEST_PARA_2));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_NAN,
+			      FWCMD_H2C_FUNC_NAN_FUNC_CTRL, 0, 1);
+
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_nan_de_info(struct mac_ax_adapter *adapter, u8 status, u8 loc_bcast_sdf)
+{
+	u32 ret = MACSUCCESS;
+
+    #if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+
+	struct fwcmd_nan_de_info *hdr;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+    /*h2c access*/
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_nan_de_info *)h2cb_put(h2cb, sizeof(struct fwcmd_nan_de_info));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(status, FWCMD_H2C_NAN_DE_INFO_STATUS) |
+			    SET_WORD(loc_bcast_sdf, FWCMD_H2C_NAN_DE_INFO_LOC_BCAST_SDF));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,	FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_NAN,
+			      FWCMD_H2C_FUNC_NAN_FUNC_CTRL, 0, 1);
+
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_nan_join_cluster(struct mac_ax_adapter *adapter, u8 is_allow)
+{
+	u32 ret = MACSUCCESS;
+
+    #if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+
+	struct fwcmd_nan_join_cluster *hdr;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+    /*h2c access*/
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_nan_join_cluster *)
+			  h2cb_put(h2cb, sizeof(struct fwcmd_nan_join_cluster));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(is_allow, FWCMD_H2C_NAN_JOIN_CLUSTER_IS_ALLOW));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,	FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_NAN,
+			      FWCMD_H2C_FUNC_NAN_FUNC_CTRL, 0, 1);
+
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_nan_pause_faw_tx(struct mac_ax_adapter *adapter, u32 id_map)
+{
+	u32 ret = MACSUCCESS;
+
+    #if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+
+	struct fwcmd_pause_faw_tx *hdr;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+    /*h2c access*/
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_pause_faw_tx *)h2cb_put(h2cb, sizeof(struct fwcmd_pause_faw_tx));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(id_map, FWCMD_H2C_PAUSE_FAW_TX_ID_MAP));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_NAN,
+			      FWCMD_H2C_FUNC_NAN_FUNC_CTRL, 0, 1);
+
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_nan_get_cluster_info(struct mac_ax_adapter *adapter,
+			     struct mac_ax_nan_info *cluster_info)
+{
+	u32 ret = MACSUCCESS;
+
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+
+	struct fwcmd_nan_get_cluster_info *hdr;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	/*h2c access*/
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_nan_get_cluster_info *)
+		  h2cb_put(h2cb, sizeof(struct fwcmd_nan_get_cluster_info));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_NAN,
+			      FWCMD_H2C_FUNC_NAN_GET_CLUSTER_INFO, 0, 1);
+
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret != MACSUCCESS)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/nan.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/nan.h
new file mode 100644
index 000000000000..c52dea6aec4a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/nan.h
@@ -0,0 +1,125 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2021 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_NAN_H_
+#define _MAC_AX_NAN_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+
+/*--------------------Define ----------------------------------------*/
+#define FWCMD_H2C_NAN_FUNC_CTRL_NAN_RSVD_SH 24
+#define FWCMD_H2C_NAN_FUNC_CTRL_NAN_RSVD_MSK 0xff
+#define FWCMD_H2C_NAN_FUNC_CTRL_NAN_FW_TEST_PARA_1_SH 16
+#define FWCMD_H2C_NAN_FUNC_CTRL_NAN_FW_TEST_PARA_1_MSK 0xff
+#define FWCMD_H2C_NAN_FUNC_CTRL_NAN_FW_TEST_PARA_2_SH 24
+#define FWCMD_H2C_NAN_FUNC_CTRL_NAN_FW_TEST_PARA_2_MSK 0xff
+
+/*--------------------Define Struct-------------------------------------*/
+
+/*--------------------Funciton declaration----------------------------*/
+
+/**
+ * @brief mac_get_act_schedule_id
+ *
+ * @param *adapter
+ * @param *act_ack_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_act_schedule_id(struct mac_ax_adapter *adapter,
+			    struct mac_ax_act_ack_info *act_ack_info);
+
+/**
+ * @brief mac_check_cluster_info
+ *
+ * @param *adapter
+ * @param *mac_ax_nan_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_cluster_info(struct mac_ax_adapter *adapter, struct mac_ax_nan_info *cluster_info);
+
+/**
+ * @brief mac_nan_act_schedule_req
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_nan_act_schedule_req(struct mac_ax_adapter *adapter, struct mac_ax_nan_sched_info *info);
+
+/**
+ * @brief mac_nan_bcn_req
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_nan_bcn_req(struct mac_ax_adapter *adapter, struct mac_ax_nan_bcn *info);
+
+/**
+ * @brief mac_nan_func_ctrl
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_nan_func_ctrl(struct mac_ax_adapter *adapter, struct mac_ax_nan_func_info *info);
+
+/**
+ * @brief mac_nan_de_info
+ *
+ * @param *adapter
+ * @param status
+ * @param loc_bcast_sdf
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_nan_de_info(struct mac_ax_adapter *adapter, u8 status, u8 loc_bcast_sdf);
+
+/**
+ * @brief mac_nan_join_cluster
+ *
+ * @param *adapter
+ * @param is_allow
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_nan_join_cluster(struct mac_ax_adapter *adapter, u8 is_allow);
+
+/**
+ * @brief mac_nan_pause_faw_tx
+ *
+ * @param *adapter
+ * @param id_map
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_nan_pause_faw_tx(struct mac_ax_adapter *adapter, u32 id_map);
+
+/**
+ * @brief mac_nan_get_cluster_info
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_nan_get_cluster_info(struct mac_ax_adapter *adapter, struct mac_ax_nan_info *cluster_info);
+
+#endif
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/otpkeysinfo.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/otpkeysinfo.c
new file mode 100644
index 000000000000..7b3a81a35b2c
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/otpkeysinfo.c
@@ -0,0 +1,7 @@
+#include "otpkeysinfo.h"
+
+u8 otp_key_info_externalPN[OTP_KEY_INFO_NUM] = {0x0, 0x0};
+u8 otp_key_info_customer[OTP_KEY_INFO_NUM]   = {0x0, 0x1};
+u8 otp_key_info_serialNum[OTP_KEY_INFO_NUM]  = {0x0, 0x1};
+
+u32 otp_key_info_keyID[OTP_KEY_INFO_NUM] = {0x0, 0x1};
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/otpkeysinfo.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/otpkeysinfo.h
new file mode 100644
index 000000000000..764799e6938a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/otpkeysinfo.h
@@ -0,0 +1,22 @@
+#include "../type.h"
+#define OTP_KEY_INFO_NUM 2
+
+#define EFUSE_EXTERNALPN_DEFAULT 0xFF
+#define EFUSE_EXTERNALPN_ADDR  0x5EC
+#define EFUSE_EXTERNALPN_SH 0
+#define EFUSE_EXTERNALPN_MSK 0xff
+
+#define EFUSE_CUSTOMER_DEFAULT 0xF
+#define EFUSE_CUSTOMER_ADDR  0x5ED
+#define EFUSE_CUSTOMER_SH 0
+#define EFUSE_CUSTOMER_MSK 0xf
+
+#define EFUSE_SERIALNUM_DEFAULT 0x7
+#define EFUSE_SERIALNUM_ADDR  0x5ED
+#define EFUSE_SERIALNUM_SH 4
+#define EFUSE_SERIALNUM_MSK 0x7
+
+extern u8 otp_key_info_externalPN[OTP_KEY_INFO_NUM];
+extern u8 otp_key_info_customer[OTP_KEY_INFO_NUM];
+extern u8 otp_key_info_serialNum[OTP_KEY_INFO_NUM];
+extern u32 otp_key_info_keyID[OTP_KEY_INFO_NUM];
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/p2p.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/p2p.c
new file mode 100644
index 000000000000..762f9638370b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/p2p.c
@@ -0,0 +1,371 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "p2p.h"
+
+static u32 p2p_info_size = sizeof(struct mac_ax_p2p_info) * P2P_MAX_NUM;
+
+static u32 _get_valid_p2pid(struct mac_ax_adapter *adapter, u8 macid, u8 *p2pid)
+{
+	struct mac_ax_p2p_info *info = adapter->p2p_info;
+	u8 idx;
+
+	for (idx = 0; idx < P2P_MAX_NUM; idx++) {
+		if (info[idx].run && info[idx].macid == macid) {
+			PLTFM_MSG_ERR("[ERR]macid %d has running p2pid %d\n",
+				      macid, idx);
+			*p2pid = P2PID_INVALID;
+			return MACSUCCESS;
+		}
+	}
+
+	for (idx = 0; idx < P2P_MAX_NUM; idx++) {
+		if (!info[idx].run && !info[idx].wait_dack) {
+			*p2pid = idx;
+			return MACSUCCESS;
+		}
+	}
+
+	PLTFM_MSG_ERR("[ERR]no valid p2p\n");
+	*p2pid = P2PID_INVALID;
+	return MACHWNOSUP;
+}
+
+static u32 _get_macid_p2pid(struct mac_ax_adapter *adapter, u8 macid, u8 *p2pid)
+{
+	struct mac_ax_p2p_info *info = adapter->p2p_info;
+	u8 idx;
+
+	for (idx = 0; idx < P2P_MAX_NUM; idx++) {
+		if (info[idx].run && info[idx].macid == macid) {
+			*p2pid = idx;
+			return MACSUCCESS;
+		}
+	}
+
+	PLTFM_MSG_ERR("[ERR]no valid p2pid for macid %d\n", macid);
+	*p2pid = P2PID_INVALID;
+	return MACFUNCINPUT;
+}
+
+u32 get_wait_dack_p2pid(struct mac_ax_adapter *adapter, u8 *p2pid)
+{
+	struct mac_ax_p2p_info *info = adapter->p2p_info;
+	u8 idx;
+	u8 hit = 0;
+
+	for (idx = 0; idx < P2P_MAX_NUM; idx++) {
+		if (info[idx].wait_dack && !hit) {
+			*p2pid = idx;
+			hit = 1;
+		} else if (info[idx].wait_dack) {
+			PLTFM_MSG_ERR("[ERR]multiple wait dack p2p\n");
+			return MACPROCERR;
+		}
+	}
+
+	if (!hit)
+		*p2pid = P2PID_INVALID;
+
+	return MACSUCCESS;
+}
+
+u32 p2p_info_init(struct mac_ax_adapter *adapter)
+{
+	u32 i;
+
+	adapter->p2p_info =
+		(struct mac_ax_p2p_info *)PLTFM_MALLOC(p2p_info_size);
+	for (i = 0; i < P2P_MAX_NUM; i++)
+		PLTFM_MEMSET(&adapter->p2p_info[i], 0,
+			     sizeof(struct mac_ax_p2p_info));
+
+	return MACSUCCESS;
+}
+
+u32 p2p_info_exit(struct mac_ax_adapter *adapter)
+{
+	PLTFM_FREE(adapter->p2p_info, p2p_info_size);
+
+	return MACSUCCESS;
+}
+
+u32 rst_p2p_info(struct mac_ax_adapter *adapter)
+{
+	PLTFM_MEMSET(adapter->p2p_info, 0, p2p_info_size);
+
+	return MACSUCCESS;
+}
+
+u32 mac_p2p_act_h2c(struct mac_ax_adapter *adapter,
+		    struct mac_ax_p2p_act_info *info)
+{
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_p2p_act *hdr;
+	u32 ret = MACSUCCESS;
+	u8 p2pid;
+
+	if (info->noaid >= NOA_MAX_NUM) {
+		PLTFM_MSG_ERR("[ERR]invalid noaid %d\n", info->noaid);
+		return MACFUNCINPUT;
+	}
+
+	if (info->act == P2P_ACT_INIT) {
+		ret = _get_valid_p2pid(adapter, info->macid, &p2pid);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]get valid p2pid %d\n", ret);
+			return MACHWNOSUP;
+		}
+		if (p2pid == P2PID_INVALID) {
+			PLTFM_MSG_ERR("[ERR]get invalid p2pid\n");
+			return MACNOITEM;
+		}
+	} else {
+		ret = _get_macid_p2pid(adapter, info->macid, &p2pid);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]get macid %d p2pid %d\n",
+				      info->macid, ret);
+			return MACFUNCINPUT;
+		}
+		if (p2pid == P2PID_INVALID) {
+			PLTFM_MSG_ERR("[ERR]get macid p2pid shall ret err\n");
+			return MACCMP;
+		}
+	}
+
+	if (adapter->sm.p2p_stat == MAC_AX_P2P_ACT_BUSY) {
+		PLTFM_MSG_ERR("[ERR] p2p act h2c stat busy\n");
+		return MACPROCERR;
+	}
+	adapter->sm.p2p_stat = MAC_AX_P2P_ACT_BUSY;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_p2p_act *)
+	      h2cb_put(h2cb, sizeof(struct fwcmd_p2p_act));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(info->macid, FWCMD_H2C_P2P_ACT_MACID) |
+			    SET_WORD(p2pid, FWCMD_H2C_P2P_ACT_P2PID) |
+			    SET_WORD(info->noaid, FWCMD_H2C_P2P_ACT_NOAID) |
+			    SET_WORD(info->act, FWCMD_H2C_P2P_ACT_ACT) |
+			    (info->type ? FWCMD_H2C_P2P_ACT_TYPE : 0) |
+			    (info->all_slep ? FWCMD_H2C_P2P_ACT_ALL_SLEP : 0));
+
+	hdr->dword1 =
+		cpu_to_le32(SET_WORD(info->srt, FWCMD_H2C_P2P_ACT_SRT));
+
+	hdr->dword2 =
+		cpu_to_le32(SET_WORD(info->itvl, FWCMD_H2C_P2P_ACT_ITVL));
+
+	hdr->dword3 =
+		cpu_to_le32(SET_WORD(info->dur, FWCMD_H2C_P2P_ACT_DUR));
+
+	hdr->dword4 =
+		cpu_to_le32(SET_WORD(info->cnt, FWCMD_H2C_P2P_ACT_CNT) |
+			    SET_WORD(info->ctw, FWCMD_H2C_P2P_ACT_CTW));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PS,
+			      FWCMD_H2C_FUNC_P2P_ACT,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	if (info->act == P2P_ACT_INIT) {
+		adapter->p2p_info[p2pid].macid = info->macid;
+		adapter->p2p_info[p2pid].wait_init = 1;
+	}
+	if (info->act == P2P_ACT_TERM)
+		adapter->p2p_info[p2pid].wait_term = 1;
+
+	adapter->p2p_info[p2pid].wait_dack = 1;
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_p2p_macid_ctrl_h2c(struct mac_ax_adapter *adapter,
+			   struct mac_ax_p2p_macid_info *info)
+{
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_p2p_macid_ctrl *hdr;
+	u32 ret = MACSUCCESS;
+	u32 idx, bmap_ext_size, pldsize, bmap_srt_sh, bmap_last;
+	u32 bmap_idx_srt, bmap_idx_end, bmap_idx_diff;
+	u8 *curr_buf;
+	u8 p2pid;
+
+	if (info->ctrl_type >= P2P_MACID_CTRL_MAX) {
+		PLTFM_MSG_ERR("[ERR]p2p macid ctrl invalid ctrl type %d\n",
+			      info->ctrl_type);
+		return MACFUNCINPUT;
+	}
+
+	ret = _get_macid_p2pid(adapter, info->main_macid, &p2pid);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]get macid %d p2pid %d\n",
+			      info->main_macid, ret);
+		return MACFUNCINPUT;
+	}
+	if (p2pid == P2PID_INVALID) {
+		PLTFM_MSG_ERR("[ERR]get macid p2pid shall ret err\n");
+		return MACNOITEM;
+	}
+
+	bmap_idx_srt = 0;
+	for (idx = 0; idx < info->bmap_len; idx++) {
+		if (*(info->bitmap + idx))
+			break;
+		if (idx && !(idx & MACID_BMAP_BYTE_MSK))
+			bmap_idx_srt++;
+	}
+
+	bmap_idx_end = info->bmap_len >> MACID_BMAP_BYTE_SH;
+	bmap_last = info->bmap_len ? (info->bmap_len - 1) : 0;
+	for (idx = bmap_last; idx > 0; idx--) {
+		if (*(info->bitmap + idx))
+			break;
+		if (!(idx & MACID_BMAP_BYTE_MSK))
+			bmap_idx_end--;
+	}
+
+	if (bmap_idx_srt > bmap_idx_end) {
+		PLTFM_MSG_ERR("[ERR] p2p macid ctrl bitmap comp err\n");
+		return MACCMP;
+	}
+
+	bmap_idx_diff = bmap_idx_end - bmap_idx_srt;
+	bmap_ext_size = bmap_idx_diff << MACID_BMAP_BYTE_SH;
+
+	if (adapter->sm.p2p_stat == MAC_AX_P2P_ACT_BUSY) {
+		PLTFM_MSG_ERR("[ERR] p2p macid ctrl h2c stat busy\n");
+		return MACPROCERR;
+	}
+	adapter->sm.p2p_stat = MAC_AX_P2P_ACT_BUSY;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	pldsize = sizeof(struct fwcmd_p2p_macid_ctrl) + bmap_ext_size;
+	hdr = (struct fwcmd_p2p_macid_ctrl *)h2cb_put(h2cb, pldsize);
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(p2pid, FWCMD_H2C_P2P_MACID_CTRL_P2PID) |
+			    SET_WORD(info->ctrl_type,
+				     FWCMD_H2C_P2P_MACID_CTRL_CTRL_TYPE) |
+			    SET_WORD((bmap_idx_srt << MACID_BMAP_BIT_SH),
+				     FWCMD_H2C_P2P_MACID_CTRL_MACID_SRT) |
+			    SET_WORD((bmap_idx_diff + 1),
+				     FWCMD_H2C_P2P_MACID_CTRL_BMAP_LEN));
+
+	for (idx = 0; idx <= ((bmap_idx_diff + 1) << MACID_BMAP_BYTE_SH); idx++) {
+		bmap_srt_sh = (bmap_idx_srt << MACID_BMAP_BYTE_SH) + idx;
+		curr_buf = (u8 *)(&hdr->dword1) + idx;
+		if (bmap_srt_sh < info->bmap_len)
+			*curr_buf = *(info->bitmap + bmap_srt_sh);
+		else
+			*curr_buf = 0;
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PS,
+			      FWCMD_H2C_FUNC_P2P_MACID_CTRL,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	adapter->p2p_info[p2pid].wait_dack = 1;
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_get_p2p_stat(struct mac_ax_adapter *adapter)
+{
+	switch (adapter->sm.p2p_stat) {
+	case MAC_AX_P2P_ACT_IDLE:
+		return MACSUCCESS;
+	case MAC_AX_P2P_ACT_BUSY:
+		return MACPROCBUSY;
+	case MAC_AX_P2P_ACT_FAIL:
+	default:
+		return MACP2PSTFAIL;
+	}
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/p2p.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/p2p.h
new file mode 100644
index 000000000000..7a4fae5a45f9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/p2p.h
@@ -0,0 +1,118 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_P2P_H_
+#define _MAC_AX_P2P_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+
+/*--------------------Define -------------------------------------------*/
+#define P2P_MAX_NUM 2
+#define NOA_MAX_NUM 2
+#define P2PID_INVALID 0xFF
+
+#define MACID_BMAP_BYTE_SH 2 /* DWORD to Byte */
+#define MACID_BMAP_BYTE_MSK 0x3
+#define MACID_BMAP_BIT_SH 5 /* DWORD to bit */
+
+/*--------------------Define MACRO--------------------------------------*/
+/*--------------------Define Enum---------------------------------------*/
+enum P2P_ACT {
+	P2P_ACT_INIT = 0,
+	P2P_ACT_UPD,
+	P2P_ACT_RM,
+	P2P_ACT_TERM
+};
+
+enum P2P_MACID_CTRL_TYPE {
+	P2P_MACID_CTRL_JOIN = 0,
+	P2P_MACID_CTRL_CLR,
+	P2P_MACID_CTRL_CLR_ALL,
+	P2P_MACID_CTRL_MAX
+};
+
+/*--------------------Define Struct-------------------------------------*/
+
+/**
+ * @brief get_wait_dack_p2pid
+ *
+ * @param *adapter
+ * @param *p2pid
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_wait_dack_p2pid(struct mac_ax_adapter *adapter, u8 *p2pid);
+
+/**
+ * @brief p2p_info_init
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 p2p_info_init(struct mac_ax_adapter *adapter);
+
+/**
+ * @brief p2p_info_exit
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 p2p_info_exit(struct mac_ax_adapter *adapter);
+
+/**
+ * @brief rst_p2p_info
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 rst_p2p_info(struct mac_ax_adapter *adapter);
+
+/**
+ * @brief mac_p2p_act_h2c
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_p2p_act_h2c(struct mac_ax_adapter *adapter,
+		    struct mac_ax_p2p_act_info *info);
+
+/**
+ * @brief mac_p2p_macid_ctrl_h2c
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_p2p_macid_ctrl_h2c(struct mac_ax_adapter *adapter,
+			   struct mac_ax_p2p_macid_info *info);
+
+/**
+ * @brief mac_get_p2p_stat
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_p2p_stat(struct mac_ax_adapter *adapter);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_misc.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_misc.c
new file mode 100644
index 000000000000..92550cb5915a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_misc.c
@@ -0,0 +1,117 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "phy_misc.h"
+
+u32 mac_fast_ch_sw(struct mac_ax_adapter *adapter, struct mac_ax_fast_ch_sw_param *fast_ch_sw_param)
+{
+	u8 *buf;
+	u32 ret = MACSUCCESS;
+	struct fwcmd_fcs *pkt;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cbuf;
+	#else
+	struct h2c_buf *h2cbuf;
+	#endif
+
+	h2cbuf = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cbuf)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cbuf, sizeof(struct fwcmd_fcs));
+	if (!buf) {
+		PLTFM_MSG_ERR("[HM][H2C][FCS] ret = %d\n", MACNOBUF);
+		return MACNOBUF;
+	}
+	pkt = (struct fwcmd_fcs *)buf;
+	pkt->dword0 = cpu_to_le32(SET_WORD(fast_ch_sw_param->ap_port_id,
+					   FWCMD_H2C_FCS_AP_PORT_ID) |
+				  SET_WORD(fast_ch_sw_param->ch_idx,
+					   FWCMD_H2C_FCS_CH_IDX) |
+				  SET_WORD(fast_ch_sw_param->thermal_idx,
+					   FWCMD_H2C_FCS_THERMAL_IDX) |
+				  SET_WORD(fast_ch_sw_param->pause_rel_mode,
+					   FWCMD_H2C_FCS_PAUSE_REL_MODE) |
+				  SET_WORD(fast_ch_sw_param->con_sta_num,
+					   FWCMD_H2C_FCS_CON_STA_NUM) |
+				  (fast_ch_sw_param->band ? FWCMD_H2C_FCS_BAND : 0) |
+				  SET_WORD(fast_ch_sw_param->bandwidth,
+					   FWCMD_H2C_FCS_BANDWIDTH) |
+				  SET_WORD(fast_ch_sw_param->ch_band, FWCMD_H2C_FCS_CH_BAND));
+	pkt->dword1 = cpu_to_le32(SET_WORD(fast_ch_sw_param->pri_ch,
+					   FWCMD_H2C_FCS_PRI_CH) |
+				  SET_WORD(fast_ch_sw_param->central_ch,
+					   FWCMD_H2C_FCS_CENTRAL_CH));
+	pkt->dword2 = cpu_to_le32(fast_ch_sw_param->rel_pause_tsfl);
+	pkt->dword3 = cpu_to_le32(fast_ch_sw_param->rel_pause_tsfh);
+	pkt->dword4 = cpu_to_le32(fast_ch_sw_param->rel_pause_delay_time);
+	pkt->dword5 = cpu_to_le32(SET_WORD(fast_ch_sw_param->csa_pkt_id[0],
+					   FWCMD_H2C_FCS_CSA_PKT_ID0) |
+				  SET_WORD(fast_ch_sw_param->csa_pkt_id[1],
+					   FWCMD_H2C_FCS_CSA_PKT_ID1) |
+				  SET_WORD(fast_ch_sw_param->csa_pkt_id[2],
+					   FWCMD_H2C_FCS_CSA_PKT_ID2) |
+				  SET_WORD(fast_ch_sw_param->csa_pkt_id[3],
+					   FWCMD_H2C_FCS_CSA_PKT_ID3));
+	ret = h2c_pkt_set_hdr(adapter, h2cbuf,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FCS, FWCMD_H2C_FUNC_FCS, 1, 1);
+	if (ret) {
+		PLTFM_MSG_ERR("[HM][H2C][FCS] error when set hdr\n");
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cbuf);
+
+	if (ret) {
+		PLTFM_MSG_ERR("[HM][H2C][FCS] error when build txd\n");
+		return ret;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cbuf);
+	#else
+	ret = PLTFM_TX(h2cbuf->data, h2cbuf->len);
+	#endif
+
+	h2cb_free(adapter, h2cbuf);
+
+	if (ret) {
+		PLTFM_MSG_ERR("[HM][H2C][FCS] error when h2cb free\n");
+		return ret;
+	}
+	h2c_end_flow(adapter);
+	adapter->fast_ch_sw_info.busy = 1;
+	if (ret) {
+		PLTFM_MSG_ERR("[HM][H2C][FCS] error when h2c_end_flow\n");
+		return ret;
+	}
+	PLTFM_MSG_TRACE("[HM][H2C][FCS] ret = %d\n", ret);
+	return ret;
+}
+
+u32 mac_fast_ch_sw_done(struct mac_ax_adapter *adapter)
+{
+	if (adapter->fast_ch_sw_info.busy)
+		return MACPROCBUSY;
+	else
+		return MACSUCCESS;
+}
+
+u32 mac_get_fast_ch_sw_rpt(struct mac_ax_adapter *adapter, u32 *fast_ch_sw_status_code)
+{
+	*fast_ch_sw_status_code = adapter->fast_ch_sw_info.status;
+	return MACSUCCESS;
+}
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_misc.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_misc.h
new file mode 100644
index 000000000000..b4ecc3fbfb5b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_misc.h
@@ -0,0 +1,26 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_PHY_MISC_H_
+#define _MAC_AX_PHY_MISC_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+
+u32 mac_fast_ch_sw(struct mac_ax_adapter *adapter,
+		   struct mac_ax_fast_ch_sw_param *fast_ch_sw_param);
+u32 mac_fast_ch_sw_done(struct mac_ax_adapter *adapter);
+u32 mac_get_fast_ch_sw_rpt(struct mac_ax_adapter *adapter, u32 *fast_ch_sw_status_code);
+#endif // __MAC_AX_PHY_MISC_H_
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_rpt.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_rpt.c
new file mode 100644
index 000000000000..2e39851bb4a7
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_rpt.c
@@ -0,0 +1,733 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "phy_rpt.h"
+#include "mac_priv.h"
+
+#define MAC_AX_RX_CNT_SIZE 96
+#define MAC_AX_DISP_QID_HOST 0x2
+#define MAC_AX_DISP_QID_WLCPU 0xB
+#define MAC_AX_DFS_HDR_SIZE 8
+#define MAC_AX_DFS_RPT_SIZE 8
+#define MAC_AX_DFS_RPT_SIZE_SH 3
+#define MAC_AX_CH_INFO_BUF 0
+#define B_AX_CH_INFO_BUF_128 0
+#define B_AX_GET_CH_INFO_TO_DIS 0
+#define B_AX_GET_CH_INFO_TO_8 2
+#define B_AX_GET_CH_INFO_TO_28 7
+#define B_AX_CH_INFO_INTVL_DIS 0
+#define B_AX_CH_INFO_INTVL_1 1
+#define B_AX_CH_INFO_INTVL_2 2
+#define B_AX_CH_INFO_INTVL_4 4
+#define B_AX_CH_INFO_INTVL_7 7
+#define B_AX_CH_INFO_REQ_2 1
+#define B_AX_DFS_BUF_64 1
+
+#define MAC_AX_MAC_INFO_USE_SIZE 4
+struct mac_ax_mac_info_t {
+	u32 dword0;
+	u32 dword1;
+};
+
+struct mac_ax_dfs_hdr_t {
+	u32 dword0;
+	u32 dword1;
+};
+
+static u32 _patch_is_cfg_avl(struct mac_ax_adapter *adapter,
+			     struct mac_ax_phy_rpt_cfg *cfg,
+			     struct mac_ax_ppdu_stat *ppdu)
+{
+	if (cfg->dest == MAC_AX_PRPT_DEST_HOST && ppdu->dup2fw_en &&
+	    ppdu->dup2fw_len != 0) {
+		if (chk_patch_is_cfg_avl(adapter))
+			return MACFUNCINPUT;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 get_ppdu_status_cfg(struct mac_ax_adapter *adapter,
+			       struct mac_ax_phy_rpt_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_ppdu_stat *ppdu = &cfg->u.ppdu;
+	u32 reg = (ppdu->band) ? R_AX_PPDU_STAT_C1 : R_AX_PPDU_STAT;
+	u32 val, tmp;
+	u32 ret = 0;
+
+	ret = check_mac_en(adapter, ppdu->band, MAC_AX_CMAC_SEL);
+	if (ret) {
+		PLTFM_MSG_ERR("MAC%d is not ready\n", ppdu->band);
+		return ret;
+	}
+
+	val = MAC_REG_R32(R_AX_HW_RPT_FWD);
+	tmp = GET_FIELD(val, B_AX_FWD_PPDU_STAT);
+	cfg->dest = (tmp == MAC_AX_FWD_TO_HOST) ? MAC_AX_PRPT_DEST_HOST :
+			MAC_AX_PRPT_DEST_WLCPU;
+
+	val = MAC_REG_R32(R_AX_RX_PPDU_STATUS_FW_MODE);
+	ppdu->dup2fw_en = !!(val & B_AX_HDR_PPDU_ENQ_WLCPU_EN);
+	ppdu->dup2fw_len = GET_FIELD(val, B_AX_CDR_PPDU_2_WLCPU_LEN);
+
+	val = MAC_REG_R32(reg);
+	ppdu->bmp_append_info = val & (MAC_AX_PPDU_MAC_INFO |
+				       MAC_AX_PPDU_PLCP |
+				       MAC_AX_PPDU_RX_CNT);
+	ppdu->bmp_filter = val & (MAC_AX_PPDU_HAS_A1M |
+				  MAC_AX_PPDU_HAS_CRC_OK |
+				  MAC_AX_PPDU_HAS_DMA_OK);
+	cfg->en = !!(val & B_AX_PPDU_STAT_RPT_EN);
+
+	return MACSUCCESS;
+}
+
+static u32 cfg_ppdu_status(struct mac_ax_adapter *adapter,
+			   struct mac_ax_phy_rpt_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_ppdu_stat *ppdu = &cfg->u.ppdu;
+	u32 reg = (ppdu->band) ? R_AX_PPDU_STAT_C1 : R_AX_PPDU_STAT;
+	u32 val;
+	u32 ret = 0;
+
+	ret = check_mac_en(adapter, ppdu->band, MAC_AX_CMAC_SEL);
+	if (ret) {
+		PLTFM_MSG_ERR("MAC%d is not ready\n", ppdu->band);
+		goto END;
+	}
+
+	ret = _patch_is_cfg_avl(adapter, cfg, ppdu);
+	if (ret) {
+		PLTFM_MSG_ERR("The PPDU status config is INVALID\n");
+		goto END;
+	}
+
+	if (!cfg->en) {
+#if MAC_AX_FW_REG_OFLD
+		if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+			ret = MAC_REG_W_OFLD((u16)reg,
+					     B_AX_PPDU_STAT_RPT_EN,
+					     0, 1);
+			if (ret != MACSUCCESS)
+				PLTFM_MSG_ERR("%s: write offload fail %d",
+					      __func__, ret);
+			goto END;
+		}
+#endif
+		val = MAC_REG_R32(reg);
+		val = val & ~B_AX_PPDU_STAT_RPT_EN;
+		MAC_REG_W32(reg, val);
+		goto END;
+	}
+
+	val = MAC_REG_R32(R_AX_HW_RPT_FWD);
+	switch (cfg->dest) {
+	case MAC_AX_PRPT_DEST_HOST:
+		if (ppdu->dup2fw_en) {
+			MAC_REG_W32(R_AX_RX_PPDU_STATUS_FW_MODE,
+				    B_AX_HDR_PPDU_ENQ_WLCPU_EN |
+				    SET_WORD(ppdu->dup2fw_len,
+					     B_AX_CDR_PPDU_2_WLCPU_LEN));
+		}
+
+		val = SET_CLR_WORD(val, MAC_AX_FWD_TO_HOST, B_AX_FWD_PPDU_STAT);
+		break;
+	case MAC_AX_PRPT_DEST_WLCPU:
+		val = SET_CLR_WORD(val, MAC_AX_FWD_TO_WLAN_CPU,
+				   B_AX_FWD_PPDU_STAT);
+		break;
+	default:
+		PLTFM_MSG_ERR("Wrong PPDU status destination\n");
+		ret = MACFUNCINPUT;
+	}
+	MAC_REG_W32(R_AX_HW_RPT_FWD, val);
+
+	ppdu->bmp_append_info = ppdu->bmp_append_info &
+				(MAC_AX_PPDU_MAC_INFO |
+				 MAC_AX_PPDU_PLCP |
+				 MAC_AX_PPDU_RX_CNT);
+	ppdu->bmp_filter = ppdu->bmp_filter &
+			   (MAC_AX_PPDU_HAS_A1M |
+			    MAC_AX_PPDU_HAS_CRC_OK |
+			    MAC_AX_PPDU_HAS_DMA_OK);
+
+	val = B_AX_PPDU_STAT_RPT_EN |
+		ppdu->bmp_filter |
+		ppdu->bmp_append_info;
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = MAC_REG_W32_OFLD((u16)reg, val, 1);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("%s: write offload fail %d",
+				      __func__, ret);
+		goto END;
+	}
+#endif
+
+	MAC_REG_W32(reg, val);
+
+END:
+	return ret;
+}
+
+static u32 en_bbrpt(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val;
+
+	val = MAC_REG_R32(R_AX_DMAC_CLK_EN);
+	if (!(val & B_AX_BBRPT_CLK_EN)) {
+		val = val | B_AX_BBRPT_CLK_EN;
+		MAC_REG_W32(R_AX_DMAC_CLK_EN, val);
+	}
+
+	val = MAC_REG_R32(R_AX_DMAC_FUNC_EN);
+	if (!(val & B_AX_BBRPT_EN)) {
+		val = val | B_AX_BBRPT_EN;
+		MAC_REG_W32(R_AX_DMAC_FUNC_EN, val);
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 stop_ch_info(struct mac_ax_adapter *adapter, u32 ch_info_reg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val;
+	u32 count = 3000;
+#if MAC_AX_FW_REG_OFLD
+	u32 ret;
+#endif
+
+	val = MAC_REG_R8(R_AX_CH_INFO);
+
+	if (!(val & B_AX_CH_INFO_EN))
+		return MACSUCCESS;
+
+	MAC_REG_W8(R_AX_CH_INFO, val | B_AX_CH_INFO_STOP_REQ);
+	while (!(MAC_REG_R8(R_AX_CH_INFO) & B_AX_CH_INFO_STOP)) {
+		count--;
+		if (count == 0) {
+			PLTFM_MSG_ERR("Polling ch info idle timeout\n");
+			return MACPOLLTO;
+		}
+	}
+
+	val = MAC_REG_R8(R_AX_CH_INFO);
+	MAC_REG_W8(R_AX_CH_INFO, val | B_AX_CH_INFO_EN);
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = MAC_REG_W_OFLD((u16)ch_info_reg, B_AX_GET_CH_INFO_EN, 0, 1);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("%s: write offload fail %d",
+				      __func__, ret);
+		return ret;
+	}
+#endif
+
+	val = MAC_REG_R8(ch_info_reg);
+	MAC_REG_W8(ch_info_reg, val & ~B_AX_GET_CH_INFO_EN);
+
+	return MACSUCCESS;
+}
+
+static u32 get_ch_info_cfg(struct mac_ax_adapter *adapter,
+			   struct mac_ax_phy_rpt_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 reg, p_id, q_id;
+	u32 val;
+	u32 ret = 0;
+	struct mac_ax_ch_info *chif = &cfg->u.chif;
+	u8 band;
+
+	PLTFM_MEMSET(cfg, 0, sizeof(*cfg));
+
+	val = MAC_REG_R32(R_AX_CH_INFO);
+
+	cfg->en = !!(val & B_AX_CH_INFO_EN);
+	if (!cfg->en)
+		return MACSUCCESS;
+
+	band = !!(val & B_AX_CH_INFO_PHY);
+
+	ret = p_ops->get_bbrpt_dle_cfg(adapter,
+				       MAC_AX_PRPT_DEST_WLCPU,
+				       &p_id, &q_id);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: get bbrpt cfg fail\n", __func__);
+		return ret;
+	}
+
+	chif->seg_size = GET_FIELD(val, B_AX_CH_INFO_SEG);
+	chif->dis_to = GET_FIELD(val, B_AX_GET_CH_INFO_TO) ? 0 : 1;
+	cfg->dest = (p_id == GET_FIELD(val, B_AX_DFS_PRTID) &&
+		     q_id == GET_FIELD(val, B_AX_DFS_QID)) ?
+		MAC_AX_PRPT_DEST_WLCPU : MAC_AX_PRPT_DEST_HOST;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret) {
+		PLTFM_MSG_ERR("MAC%d is not ready\n", band);
+		return ret;
+	}
+
+	reg = (band == MAC_AX_BAND_0) ?
+		R_AX_CH_INFO_QRY : R_AX_CH_INFO_QRY_C1;
+
+	val = MAC_REG_R32(reg);
+	chif->trigger = GET_FIELD(val, B_AX_CH_INFO_MODE);
+	chif->macid = GET_FIELD(val, B_AX_CH_INFO_MACID);
+	chif->bmp_filter = (val & (B_AX_CH_INFO_CRC_FAIL |
+				   B_AX_CH_INFO_DATA_FRM |
+				   B_AX_CH_INFO_CTRL_FRM |
+				   B_AX_CH_INFO_MGNT_FRM)) >> 16;
+
+	return MACSUCCESS;
+}
+
+static u32 cfg_ch_info(struct mac_ax_adapter *adapter,
+		       struct mac_ax_phy_rpt_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 reg, p_id, q_id;
+	u32 val;
+	u32 ret = 0;
+	struct mac_role_tbl *role;
+	struct mac_ax_ch_info *chif = &cfg->u.chif;
+	u8 band;
+	u8 intvl;
+
+	role = mac_role_srch(adapter, chif->macid);
+	if (!role) {
+		PLTFM_MSG_ERR("[ERR]cannot find macid: %d\n", chif->macid);
+		ret = MACNOITEM;
+		goto END;
+	}
+	band = role->info.band;
+
+	en_bbrpt(adapter);
+
+	reg = (band == MAC_AX_BAND_0) ?
+		R_AX_CH_INFO_QRY : R_AX_CH_INFO_QRY_C1;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret) {
+		PLTFM_MSG_ERR("MAC%d is not ready\n", band);
+		goto END;
+	}
+
+	if (!cfg->en) {
+		ret = stop_ch_info(adapter, reg);
+		goto END;
+	}
+
+	ret = p_ops->get_bbrpt_dle_cfg(adapter,
+				       cfg->dest == MAC_AX_PRPT_DEST_WLCPU,
+				       &p_id, &q_id);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: get bbrpt cfg fail\n", __func__);
+		goto END;
+	}
+
+	switch (chif->seg_size) {
+	case MAC_AX_CH_IFNO_SEG_128:
+		intvl = B_AX_CH_INFO_INTVL_1;
+		break;
+	case MAC_AX_CH_IFNO_SEG_256:
+		intvl = B_AX_CH_INFO_INTVL_2;
+		break;
+	case MAC_AX_CH_IFNO_SEG_512:
+		intvl = B_AX_CH_INFO_INTVL_4;
+		break;
+	case MAC_AX_CH_IFNO_SEG_1024:
+		intvl = B_AX_CH_INFO_INTVL_7;
+		break;
+	default:
+		PLTFM_MSG_ERR("Wrong ch info segment\n");
+		ret = MACFUNCINPUT;
+		goto END;
+	}
+
+	MAC_REG_W8(R_AX_BBRPT_COEX_CFG, B_AX_BBRPT_COEX_EN);
+
+	MAC_REG_W32(R_AX_CH_INFO,
+		    SET_WORD(q_id, B_AX_CH_INFO_QID) |
+		    SET_WORD(p_id, B_AX_CH_INFO_PRTID) |
+		    SET_WORD(B_AX_CH_INFO_REQ_2, B_AX_CH_INFO_REQ) |
+		    SET_WORD(chif->seg_size, B_AX_CH_INFO_SEG) |
+		    SET_WORD(intvl, B_AX_CH_INFO_INTVL) |
+		    (chif->dis_to ?
+		     0 : SET_WORD(B_AX_GET_CH_INFO_TO_28,
+				  B_AX_GET_CH_INFO_TO)) |
+		    (band ? B_AX_CH_INFO_PHY : 0) |
+		    SET_WORD(B_AX_CH_INFO_BUF_128, B_AX_CH_INFO_BUF) |
+		    B_AX_CH_INFO_EN);
+
+	switch (chif->trigger) {
+	case MAC_AX_CH_INFO_MACID:
+	case MAC_AX_CH_INFO_ACK:
+		val = B_AX_GET_CH_INFO_EN |
+		      SET_WORD(MAC_AX_CH_INFO_MACID, B_AX_CH_INFO_MODE) |
+		      SET_WORD(chif->macid, B_AX_CH_INFO_MACID) |
+		      ((chif->bmp_filter << 16) & (B_AX_CH_INFO_CRC_FAIL |
+						   B_AX_CH_INFO_DATA_FRM |
+						   B_AX_CH_INFO_CTRL_FRM |
+						   B_AX_CH_INFO_MGNT_FRM));
+		break;
+	case MAC_AX_CH_INFO_NDP:
+		val = B_AX_GET_CH_INFO_EN |
+		      SET_WORD(chif->trigger, B_AX_CH_INFO_MODE) |
+		      SET_WORD(chif->macid, B_AX_CH_INFO_MACID);
+		break;
+	case MAC_AX_CH_INFO_SND:
+		val = B_AX_GET_CH_INFO_EN |
+		      SET_WORD(chif->trigger, B_AX_CH_INFO_MODE) |
+		      SET_WORD(chif->macid, B_AX_CH_INFO_MACID) |
+		      ((chif->bmp_filter << 16) & (B_AX_CH_INFO_CRC_FAIL |
+						   B_AX_CH_INFO_DATA_FRM |
+						   B_AX_CH_INFO_CTRL_FRM |
+						   B_AX_CH_INFO_MGNT_FRM));
+
+		break;
+	default:
+		PLTFM_MSG_ERR("Wrong channel info mode\n");
+		ret = MACFUNCINPUT;
+		goto END;
+	}
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = MAC_REG_W32_OFLD((u16)reg, val, 1);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("%s: write offload fail %d",
+				      __func__, ret);
+		return ret;
+	}
+#endif
+
+	MAC_REG_W32(reg, val);
+END:
+	return ret;
+}
+
+static u32 stop_dfs(struct mac_ax_adapter *adapter)
+{
+#define MAC_AX_PHY_RPT_CNT 3000
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val;
+	u32 count = MAC_AX_PHY_RPT_CNT;
+
+	val = MAC_REG_R8(R_AX_DFS_CFG0);
+	MAC_REG_W8(R_AX_DFS_CFG0, val | B_AX_STOP_DFS);
+	while (!(MAC_REG_R8(R_AX_DFS_CFG0) & B_AX_DFS_IN_STOP)) {
+		count--;
+		if (count == 0) {
+			PLTFM_MSG_ERR("Polling ch info idle timeout\n");
+			return MACPOLLTO;
+		}
+	}
+
+	MAC_REG_W8(R_AX_DFS_CFG0, val & ~B_AX_DFS_RPT_EN);
+
+	return MACSUCCESS;
+}
+
+static u32 get_dfs_cfg(struct mac_ax_adapter *adapter,
+		       struct mac_ax_phy_rpt_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_dfs *dfs = &cfg->u.dfs;
+	u32 ret = 0, val;
+	u32 p_id, q_id;
+
+	ret = p_ops->get_bbrpt_dle_cfg(adapter,
+				       MAC_AX_PRPT_DEST_WLCPU,
+				       &p_id, &q_id);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: get bbrpt cfg fail\n", __func__);
+		return ret;
+	}
+
+	val = MAC_REG_R32(R_AX_DFS_CFG0);
+	cfg->en = !!(val & B_AX_DFS_RPT_EN);
+	dfs->num_th = GET_FIELD(val, B_AX_DFS_NUM_TH);
+	dfs->en_timeout = GET_FIELD(val, B_AX_DFS_TIME_TH);
+	cfg->dest = (p_id == GET_FIELD(val, B_AX_DFS_PRTID) &&
+		     q_id == GET_FIELD(val, B_AX_DFS_QID)) ?
+		MAC_AX_PRPT_DEST_WLCPU : MAC_AX_PRPT_DEST_HOST;
+
+	return MACSUCCESS;
+}
+
+static u32 cfg_dfs(struct mac_ax_adapter *adapter,
+		   struct mac_ax_phy_rpt_cfg *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_dfs *dfs = &cfg->u.dfs;
+	u32 ret = 0, val;
+	u32 p_id, q_id, dfs_to = 0, num_th;
+
+	en_bbrpt(adapter);
+
+	if (!cfg->en) {
+		ret = stop_dfs(adapter);
+		goto END;
+	}
+
+	ret = p_ops->get_bbrpt_dle_cfg(adapter,
+				       cfg->dest == MAC_AX_PRPT_DEST_WLCPU,
+				       &p_id, &q_id);
+	if (ret) {
+		PLTFM_MSG_ERR("%s: get bbrpt cfg fail\n", __func__);
+		goto END;
+	}
+
+	if (dfs->en_timeout) {
+		switch (dfs->dfs_to) {
+		case MAC_AX_DFS_TO_20MS:
+		case MAC_AX_DFS_TO_40MS:
+		case MAC_AX_DFS_TO_80MS:
+			dfs_to = dfs->dfs_to;
+			break;
+		default:
+			PLTFM_MSG_ERR("Wrong DFS report timeout\n");
+			ret = MACFUNCINPUT;
+			goto END;
+		}
+	}
+
+	switch (dfs->num_th) {
+	case MAC_AX_DFS_TH_29:
+	case MAC_AX_DFS_TH_61:
+	case MAC_AX_DFS_TH_93:
+	case MAC_AX_DFS_TH_125:
+		num_th = dfs->num_th;
+		break;
+	default:
+		PLTFM_MSG_ERR("Wrong DFS report num threshold\n");
+		ret = MACFUNCINPUT;
+		goto END;
+	}
+
+	val = B_AX_DFS_RPT_EN |
+	      SET_WORD(B_AX_DFS_BUF_64, B_AX_DFS_BUF) |
+	      SET_WORD(num_th, B_AX_DFS_NUM_TH) |
+	      SET_WORD(dfs_to, B_AX_DFS_TIME_TH) |
+	      SET_WORD(q_id, B_AX_DFS_QID) |
+	      SET_WORD(p_id, B_AX_DFS_PRTID);
+
+	MAC_REG_W32(R_AX_DFS_CFG0, val);
+END:
+	return ret;
+}
+
+u32 mac_cfg_phy_rpt(struct mac_ax_adapter *adapter,
+		    struct mac_ax_phy_rpt_cfg *rpt)
+{
+	u32 (*handle)(struct mac_ax_adapter *adapter,
+		      struct mac_ax_phy_rpt_cfg *rpt);
+
+	switch (rpt->type) {
+	case MAC_AX_PPDU_STATUS:
+		handle = cfg_ppdu_status;
+		break;
+	case MAC_AX_CH_INFO:
+		handle = cfg_ch_info;
+		break;
+	case MAC_AX_DFS:
+		handle = cfg_dfs;
+		break;
+	default:
+		PLTFM_MSG_ERR("Wrong PHY report type\n");
+		return MACFUNCINPUT;
+	}
+
+	return handle(adapter, rpt);
+}
+
+u32 mac_get_phy_rpt_cfg(struct mac_ax_adapter *adapter,
+			struct mac_ax_phy_rpt_cfg *rpt)
+{
+	u32 (*handle)(struct mac_ax_adapter *adapter,
+		      struct mac_ax_phy_rpt_cfg *rpt);
+
+	switch (rpt->type) {
+	case MAC_AX_PPDU_STATUS:
+		handle = get_ppdu_status_cfg;
+		break;
+	case MAC_AX_CH_INFO:
+		handle = get_ch_info_cfg;
+		break;
+	case MAC_AX_DFS:
+		handle = get_dfs_cfg;
+		break;
+	default:
+		PLTFM_MSG_ERR("Wrong PHY report type\n");
+		return MACFUNCINPUT;
+	}
+
+	return handle(adapter, rpt);
+}
+
+static u32 parse_mac_info(struct mac_ax_adapter *adapter,
+			  u8 *buf, u32 len,
+			  struct mac_ax_ppdu_rpt *rpt)
+{
+	struct mac_ax_ppdu_usr *usr;
+	struct mac_ax_mac_info_t *macinfo;
+	u8 i;
+	u32 ret = MACSUCCESS;
+	u32 accu_size = sizeof(struct mac_ax_mac_info_t);
+	u32 val;
+	u8 *ptr;
+
+	macinfo = (struct mac_ax_mac_info_t *)buf;
+
+	/* dword0 */
+	val = le32_to_cpu(macinfo->dword0);
+	rpt->usr_num = (u8)GET_FIELD(val, AX_MAC_INFO_USR_NUM);
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			if (rpt->usr_num > MAC_MAX_4_USR) {
+				PLTFM_MSG_ERR("The user num in mac info is invalid\n");
+				ret = MACPARSEERR;
+				goto END;
+			}
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			if (rpt->usr_num > MAC_MAX_8_USR) {
+				PLTFM_MSG_ERR("The user num in mac info is invalid\n");
+				ret = MACPARSEERR;
+				goto END;
+			}
+		}
+#endif
+	rpt->fw_def = (u8)GET_FIELD(val, AX_MAC_INFO_FW_DEFINE);
+	rpt->lsig_len = (u16)GET_FIELD(val, AX_MAC_INFO_LSIG_LEN);
+	rpt->is_to_self = (val & AX_MAC_INFO_IS_TO_SELF) ? 1 : 0;
+	rpt->rx_cnt_size = val & AX_MAC_INFO_RX_CNT_VLD ?
+				MAC_AX_RX_CNT_SIZE : 0;
+
+	/* dowrd1 */
+	val = le32_to_cpu(macinfo->dword1);
+	rpt->service = (u16)GET_FIELD(val, AX_MAC_INFO_SERVICE);
+	rpt->plcp_size = (u8)GET_FIELD(val, AX_MAC_INFO_PLCP_LEN) * 8;
+
+	/* dword2 */
+	usr = rpt->usr;
+	ptr = (u8 *)(macinfo + 1);
+	for (i = 0; i < rpt->usr_num; i++, usr++) {
+		val = le32_to_cpu(*((u32 *)ptr));
+		usr->vld = (val & AX_MAC_INFO_MAC_ID_VALID) ? 1 : 0;
+		usr->has_data = (val & AX_MAC_INFO_HAS_DATA) ? 1 : 0;
+		usr->has_ctrl = (val & AX_MAC_INFO_HAS_CTRL) ? 1 : 0;
+		usr->has_mgnt = (val & AX_MAC_INFO_HAS_MGNT) ? 1 : 0;
+		usr->has_bcn = (val & AX_MAC_INFO_HAS_BCN) ? 1 : 0;
+		usr->macid = (u8)GET_FIELD(val, AX_MAC_INFO_MACID);
+		accu_size += MAC_AX_MAC_INFO_USE_SIZE;
+		ptr += MAC_AX_MAC_INFO_USE_SIZE;
+	}
+
+	/* 8-byte alignment */
+	accu_size += rpt->usr_num & BIT(0) ? MAC_AX_MAC_INFO_USE_SIZE : 0;
+	ptr += rpt->usr_num & BIT(0) ? MAC_AX_MAC_INFO_USE_SIZE : 0;
+	if (rpt->rx_cnt_size) {
+		rpt->rx_cnt_ptr = ptr;
+		accu_size += rpt->rx_cnt_size;
+		ptr += rpt->rx_cnt_size;
+	}
+
+	if (rpt->plcp_size) {
+		rpt->plcp_ptr = ptr;
+		accu_size += rpt->plcp_size;
+		ptr += rpt->plcp_size;
+	}
+
+	if (len > accu_size) {
+		rpt->phy_st_ptr = ptr;
+		rpt->phy_st_size = len - accu_size;
+	}
+END:
+	return ret;
+}
+
+u32 mac_parse_ppdu(struct mac_ax_adapter *adapter,
+		   u8 *buf, u32 ppdu_len, u8 mac_info,
+		   struct mac_ax_ppdu_rpt *rpt)
+{
+	u32 ret = MACSUCCESS;
+
+	PLTFM_MEMSET(rpt, 0, sizeof(struct mac_ax_ppdu_rpt));
+
+	if (mac_info) {
+		ret = parse_mac_info(adapter, buf, ppdu_len, rpt);
+	} else {
+		rpt->phy_st_ptr = buf;
+		rpt->phy_st_size = ppdu_len;
+	}
+
+	return ret;
+}
+
+u32 mac_parse_dfs(struct mac_ax_adapter *adapter,
+		  u8 *buf, u32 dfs_len, struct mac_ax_dfs_rpt *rpt)
+{
+	struct mac_ax_dfs_hdr_t *dfs;
+	u32 len;
+	u32 msk = BIT(MAC_AX_DFS_RPT_SIZE_SH) - 1;
+	u32 ret = 0;
+	u32 val;
+
+	dfs = (struct mac_ax_dfs_hdr_t *)buf;
+
+	/* dword0 */
+	val = le32_to_cpu(dfs->dword0);
+	rpt->drop_num = (u16)GET_FIELD(val, AX_DFS_DROP_NUM);
+	rpt->max_cont_drop = (u16)GET_FIELD(val, AX_DFS_MAX_CONT_DROP);
+
+	/* dword1 */
+	val = le32_to_cpu(dfs->dword1);
+	rpt->total_drop = (u16)GET_FIELD(val, AX_DFS_TOTAL_DROP);
+	len = dfs_len - MAC_AX_DFS_HDR_SIZE;
+	rpt->dfs_num = (u16)(len >> MAC_AX_DFS_RPT_SIZE_SH);
+	if (len & msk) {
+		PLTFM_MSG_ERR("The DFS report size is wrong\n");
+		ret = MACPARSEERR;
+	}
+	rpt->dfs_ptr = buf + MAC_AX_DFS_HDR_SIZE;
+
+	return ret;
+}
+
+u32 mac_rst_drv_info(struct mac_ax_adapter *adapter)
+{
+	adapter->hw_info->cmac0_drv_info = MAC_AX_DRV_INFO_NONE;
+	adapter->hw_info->cmac1_drv_info = MAC_AX_DRV_INFO_NONE;
+
+	return MACSUCCESS;
+}
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_rpt.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_rpt.h
new file mode 100644
index 000000000000..e5e3019aab1b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/phy_rpt.h
@@ -0,0 +1,144 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_PHY_RPT_H_
+#define _MAC_AX_PHY_RPT_H_
+
+#include "../type.h"
+#include "role.h"
+#include "trxcfg.h"
+
+#define MAC_MAX_4_USR	4
+#define MAC_MAX_8_USR	8
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BB_Related
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_phy_rpt
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_phy_rpt(struct mac_ax_adapter *adapter,
+		    struct mac_ax_phy_rpt_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BB_Related
+ * @{
+ */
+
+/**
+ * @brief mac_parse_ppdu
+ *
+ * @param *adapter
+ * @param *buf
+ * @param ppdu_len
+ * @param mac_info
+ * @param *rpt
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_parse_ppdu(struct mac_ax_adapter *adapter,
+		   u8 *buf, u32 ppdu_len, u8 mac_info,
+		   struct mac_ax_ppdu_rpt *rpt);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BB_Related
+ * @{
+ */
+
+/**
+ * @brief mac_parse_dfs
+ *
+ * @param *adapter
+ * @param *buf
+ * @param dfs_len
+ * @param *rpt
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_parse_dfs(struct mac_ax_adapter *adapter,
+		  u8 *buf, u32 dfs_len, struct mac_ax_dfs_rpt *rpt);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BB_Related
+ * @{
+ */
+
+/**
+ * @brief mac_get_phy_rpt_cfg
+ *
+ * @param *adapter
+ * @param *rpt
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_get_phy_rpt_cfg(struct mac_ax_adapter *adapter,
+			struct mac_ax_phy_rpt_cfg *rpt);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Common
+ * @{
+ * @addtogroup BB_Related
+ * @{
+ */
+
+/**
+ * @brief mac_rst_drv_info
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_rst_drv_info(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/power_saving.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/power_saving.c
new file mode 100644
index 000000000000..9ebfe44119a3
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/power_saving.c
@@ -0,0 +1,1548 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "power_saving.h"
+#include "coex.h"
+#include "mac_priv.h"
+
+#define RPWM_SEQ_NUM_MAX                3
+#define CPWM_SEQ_NUM_MAX                3
+
+//RPWM bit definition
+#define PS_RPWM_TOGGLE			BIT(15)
+#define PS_RPWM_ACK             BIT(14)
+#define PS_RPWM_SEQ_NUM_SH      12
+#define PS_RPWM_SEQ_NUM_MSK     0x3
+#define PS_RPWM_NOTIFY_WAKE     BIT(8)
+#define PS_RPWM_STATE_SH        0
+#define PS_RPWM_STATE_MSK       0x7
+
+//CPWM bit definition
+#define PS_CPWM_TOGGLE			BIT(15)
+#define PS_CPWM_ACK             BIT(14)
+#define PS_CPWM_SEQ_NUM_SH      12
+#define PS_CPWM_SEQ_NUM_MSK     0x3
+#define PS_CPWM_RSP_SEQ_NUM_SH  8
+#define PS_CPWM_RSP_SEQ_NUM_MSK 0x3
+#define PS_CPWM_STATE_SH        0
+#define PS_CPWM_STATE_MSK       0x7
+
+//(workaround) CPWM register is in OFF area
+//LPS debug message bit definition
+#define B_PS_LDM_32K_EN         BIT(31)
+#define B_PS_LDM_32K_EN_SH      31
+
+// Bcn rx rate
+#define R_RXBCNHIT_RATE R_AX_USER_DEFINED_0
+#define B_AX_BCN_RATE_SH 0
+#define B_AX_BCN_RATE_MSK 0xff
+#define B_AX_BCN_HIT_RATE_SH 8
+#define B_AX_BCN_HIT_RATE_MSK 0xff
+#define B_AX_BCN_NO_HIT_RATE_SH 16
+#define B_AX_BCN_NO_HIT_RATE_MSK 0xff
+#define B_AX_ROLE_IDX_SH 24
+#define B_AX_ROLE_IDX_MSK 0xff
+
+static u32 lps_status[4] = {0};
+static u32 ips_status[4] = {0};
+static u8 rpwm_seq_num = RPWM_SEQ_NUM_MAX;
+static u8 cpwm_seq_num = CPWM_SEQ_NUM_MAX;
+
+static u32 send_h2c_lps_parm(struct mac_ax_adapter *adapter,
+			     struct lps_parm *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_lps_parm *fwcmd_lps;
+	u32 ret = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_lps_parm));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_lps = (struct fwcmd_lps_parm *)buf;
+	fwcmd_lps->dword0 =
+	cpu_to_le32(SET_WORD(parm->macid, FWCMD_H2C_LPS_PARM_MACID) |
+		SET_WORD(parm->psmode, FWCMD_H2C_LPS_PARM_PSMODE) |
+		SET_WORD(parm->rlbm, FWCMD_H2C_LPS_PARM_RLBM) |
+		SET_WORD(parm->smartps, FWCMD_H2C_LPS_PARM_SMARTPS) |
+		SET_WORD(parm->awakeinterval,
+			 FWCMD_H2C_LPS_PARM_AWAKEINTERVAL));
+
+	fwcmd_lps->dword1 =
+	cpu_to_le32((parm->vouapsd ? FWCMD_H2C_LPS_PARM_VOUAPSD : 0) |
+		(parm->viuapsd ? FWCMD_H2C_LPS_PARM_VIUAPSD : 0) |
+		(parm->beuapsd ? FWCMD_H2C_LPS_PARM_BEUAPSD : 0) |
+		(parm->bkuapsd ? FWCMD_H2C_LPS_PARM_BKUAPSD : 0) |
+		SET_WORD(parm->lastrpwm, FWCMD_H2C_LPS_PARM_LASTRPWM) |
+		(parm->bcnnohit_en ? FWCMD_H2C_LPS_PARM_BCNNOHIT_EN : 0) |
+		(parm->nulltype ? FWCMD_H2C_LPS_PARM_NULLTYPE : 0) |
+		(parm->dyntxantnum_en ? FWCMD_H2C_LPS_PARM_DYNTXANTNUM_EN : 0) |
+		(parm->maxtxantnum ? FWCMD_H2C_LPS_PARM_MAXTXANTNUM : 0) |
+		(parm->lpstxantnum ? FWCMD_H2C_LPS_PARM_LPSTXANTNUM : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PS,
+			      FWCMD_H2C_FUNC_LPS_PARM,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static void send_rpwm(struct mac_ax_adapter *adapter,
+		      struct ps_rpwm_parm *parm)
+{
+	u16 rpwm_value = 0;
+	u8 toggle = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	rpwm_value = MAC_REG_R16(R_AX_RPWM);
+	if (0 == (rpwm_value & PS_RPWM_TOGGLE))
+		toggle = 1;
+
+	if (parm->notify_wake) {
+		rpwm_value |= PS_RPWM_NOTIFY_WAKE;
+	} else {
+		if (rpwm_seq_num == RPWM_SEQ_NUM_MAX)
+			rpwm_seq_num = 0;
+		else
+			rpwm_seq_num += 1;
+
+		rpwm_value = (SET_WORD(parm->req_pwr_state, PS_RPWM_STATE) |
+			SET_WORD(rpwm_seq_num, PS_RPWM_SEQ_NUM));
+
+		if (parm->req_pwr_state == MAC_AX_RPWM_REQ_PWR_STATE_ACTIVE ||
+		    parm->req_pwr_state == MAC_AX_RPWM_REQ_PWR_STATE_BAND0_RFON ||
+		    parm->req_pwr_state == MAC_AX_RPWM_REQ_PWR_STATE_BAND1_RFON ||
+		    parm->req_pwr_state == MAC_AX_RPWM_REQ_PWR_STATE_BAND0_RFOFF ||
+		    parm->req_pwr_state == MAC_AX_RPWM_REQ_PWR_STATE_BAND1_RFOFF)
+			rpwm_value |= PS_RPWM_ACK;
+
+		if (parm->req_pwr_state == MAC_AX_RPWM_REQ_PWR_STATE_CLK_GATED ||
+		    parm->req_pwr_state == MAC_AX_RPWM_REQ_PWR_STATE_PWR_GATED ||
+		    parm->req_pwr_state == MAC_AX_RPWM_REQ_PWR_STATE_HIOE_PWR_GATED) {
+			adapter->mac_pwr_info.pwr_in_lps = 1;
+		}
+	}
+
+	if (toggle == 1)
+		rpwm_value |= PS_RPWM_TOGGLE;
+	else
+		rpwm_value &= ~PS_RPWM_TOGGLE;
+
+	switch (adapter->hw_info->intf) {
+#if MAC_AX_USB_SUPPORT
+	case MAC_AX_INTF_USB:
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+			MAC_REG_W16(R_AX_USB_D2F_F2D_INFO + 2, rpwm_value);
+#endif
+
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))
+			MAC_REG_W16(R_AX_USB_D2F_F2D_INFO_V1 + 2, rpwm_value);
+#endif
+		break;
+#endif //MAC_AX_USB_SUPPORT
+
+#if MAC_AX_SDIO_SUPPORT
+	case MAC_AX_INTF_SDIO:
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+			MAC_REG_W16(R_AX_SDIO_HRPWM1 + 2, rpwm_value);
+#endif
+
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))
+			MAC_REG_W16(R_AX_SDIO_HRPWM1_V1 + 2, rpwm_value);
+#endif
+
+		if (parm->req_pwr_state == MAC_AX_RPWM_REQ_PWR_STATE_CLK_GATED ||
+		    parm->req_pwr_state == MAC_AX_RPWM_REQ_PWR_STATE_PWR_GATED ||
+		    parm->req_pwr_state == MAC_AX_RPWM_REQ_PWR_STATE_HIOE_PWR_GATED)
+			adapter->sdio_info.tx_seq = 1;
+		break;
+#endif //MAC_AX_SDIO_SUPPORT
+
+#if MAC_AX_PCIE_SUPPORT
+	case MAC_AX_INTF_PCIE:
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+			MAC_REG_W16(R_AX_PCIE_HRPWM, rpwm_value);
+#endif
+
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))
+			MAC_REG_W16(R_AX_PCIE_HRPWM_V1, rpwm_value);
+#endif
+
+		break;
+#endif //MAC_AX_PCIE_SUPPORT
+	default:
+		PLTFM_MSG_ERR("%s: invalid interface = %d!!\n",
+			      __func__, adapter->hw_info->intf);
+
+		break;
+	}
+
+	PLTFM_DELAY_US(RPWM_DELAY_FOR_32K_TICK);
+
+	PLTFM_MSG_TRACE("Send RPWM. rpwm_val=0x%x\n", rpwm_value);
+}
+
+static u32 leave_lps(struct mac_ax_adapter *adapter, u8 macid)
+{
+	struct lps_parm h2c_lps_parm;
+	u32 ret;
+
+	PLTFM_MEMSET(&h2c_lps_parm, 0, sizeof(struct lps_parm));
+
+	h2c_lps_parm.macid = macid;
+	h2c_lps_parm.psmode = MAC_AX_PS_MODE_ACTIVE;
+	h2c_lps_parm.lastrpwm = LAST_RPWM_ACTIVE;
+
+	ret = send_h2c_lps_parm(adapter, &h2c_lps_parm);
+
+	if (ret)
+		return ret;
+
+	lps_status[(macid >> 5)] &= ~BIT(macid & 0x1F);
+
+	return MACSUCCESS;
+}
+
+static u32 enter_lps(struct mac_ax_adapter *adapter,
+		     u8 macid,
+		     struct mac_ax_lps_info *lps_info)
+{
+	struct lps_parm h2c_lps_parm;
+	u32 ret = 0;
+
+	if (!lps_info) {
+		PLTFM_MSG_ERR("[ERR]:LPS info is null\n");
+		return MACNOITEM;
+	}
+
+	if (lps_status[(macid >> 5)] & BIT(macid & 0x1F))
+		ret = leave_lps(adapter, macid);
+
+	if (ret)
+		return ret;
+
+	PLTFM_MEMSET(&h2c_lps_parm, 0, sizeof(struct lps_parm));
+
+	h2c_lps_parm.macid = macid;
+	h2c_lps_parm.psmode = MAC_AX_PS_MODE_LEGACY;
+
+	if (lps_info->listen_bcn_mode > MAC_AX_RLBM_USERDEFINE)
+		lps_info->listen_bcn_mode = MAC_AX_RLBM_MIN;
+
+	if (lps_info->listen_bcn_mode == MAC_AX_RLBM_USERDEFINE) {
+		h2c_lps_parm.rlbm = MAC_AX_RLBM_USERDEFINE;
+		h2c_lps_parm.awakeinterval = lps_info->awake_interval;
+		if (h2c_lps_parm.awakeinterval == 0)
+			h2c_lps_parm.awakeinterval = 1;
+	} else if (lps_info->listen_bcn_mode == MAC_AX_RLBM_MAX) {
+		h2c_lps_parm.rlbm = MAC_AX_RLBM_MAX;
+		h2c_lps_parm.awakeinterval = 1;
+	} else {
+		h2c_lps_parm.rlbm = MAC_AX_RLBM_MIN;
+		h2c_lps_parm.awakeinterval = 1;
+	}
+
+	h2c_lps_parm.smartps = lps_info->smart_ps_mode;
+	h2c_lps_parm.lastrpwm = LAST_RPWM_PS;
+	h2c_lps_parm.bcnnohit_en = lps_info->bcnnohit_en;
+	h2c_lps_parm.nulltype = lps_info->nulltype;
+
+	h2c_lps_parm.dyntxantnum_en = lps_info->dyn_tx_ant_num_en;
+
+	if (h2c_lps_parm.dyntxantnum_en) {
+		h2c_lps_parm.maxtxantnum = lps_info->max_tx_ant_num;
+		h2c_lps_parm.lpstxantnum = lps_info->lps_tx_ant_num;
+	}
+
+	ret = send_h2c_lps_parm(adapter, &h2c_lps_parm);
+
+	if (ret)
+		return ret;
+
+	lps_status[(macid >> 5)] |= BIT(macid & 0x1F);
+
+	return MACSUCCESS;
+}
+
+static u32 enter_wmmlps(struct mac_ax_adapter *adapter,
+			u8 macid,
+			struct mac_ax_lps_info *lps_info)
+{
+	struct lps_parm h2c_lps_parm;
+	u32 ret = 0;
+
+	if (!lps_info) {
+		PLTFM_MSG_ERR("[ERR]:LPS info is null\n");
+		return MACNOITEM;
+	}
+
+	if (lps_status[(macid >> 5)] & BIT(macid & 0x1F))
+		ret = leave_lps(adapter, macid);
+
+	if (ret)
+		return ret;
+
+	PLTFM_MEMSET(&h2c_lps_parm, 0, sizeof(struct lps_parm));
+
+	h2c_lps_parm.macid = macid;
+	h2c_lps_parm.psmode = MAC_AX_PS_MODE_WMMPS;
+
+	if (lps_info->listen_bcn_mode > MAC_AX_RLBM_USERDEFINE)
+		lps_info->listen_bcn_mode = MAC_AX_RLBM_MIN;
+
+	if (lps_info->listen_bcn_mode == MAC_AX_RLBM_USERDEFINE) {
+		h2c_lps_parm.rlbm = MAC_AX_RLBM_USERDEFINE;
+		h2c_lps_parm.awakeinterval = lps_info->awake_interval;
+		if (h2c_lps_parm.awakeinterval == 0)
+			h2c_lps_parm.awakeinterval = 1;
+	} else if (lps_info->listen_bcn_mode == MAC_AX_RLBM_MAX) {
+		h2c_lps_parm.rlbm = MAC_AX_RLBM_MAX;
+		h2c_lps_parm.awakeinterval = 1;
+	} else {
+		h2c_lps_parm.rlbm = MAC_AX_RLBM_MIN;
+		h2c_lps_parm.awakeinterval = 1;
+	}
+
+	h2c_lps_parm.lastrpwm = LAST_RPWM_PS;
+	h2c_lps_parm.bcnnohit_en = lps_info->bcnnohit_en;
+	h2c_lps_parm.vouapsd = lps_info->vouapsd_en;
+	h2c_lps_parm.viuapsd = lps_info->viuapsd_en;
+	h2c_lps_parm.beuapsd = lps_info->beuapsd_en;
+	h2c_lps_parm.bkuapsd = lps_info->bkuapsd_en;
+
+	ret = send_h2c_lps_parm(adapter, &h2c_lps_parm);
+
+	if (ret)
+		return ret;
+
+	lps_status[(macid >> 5)] |= BIT(macid & 0x1F);
+
+	return MACSUCCESS;
+}
+
+static u32 set_req_pwr_state(struct mac_ax_adapter *adapter,
+			     enum mac_ax_rpwm_req_pwr_state req_pwr_state)
+{
+	struct ps_rpwm_parm parm;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct ps_rpwm_parm));
+
+	if (req_pwr_state >= MAC_AX_RPWM_REQ_PWR_STATE_MAX) {
+		PLTFM_MSG_ERR("%s: invalid pwr state:%d\n",
+			      __func__, req_pwr_state);
+		return MACNOITEM;
+	}
+
+	parm.req_pwr_state = req_pwr_state;
+	parm.notify_wake = 0;
+	send_rpwm(adapter, &parm);
+
+	return MACSUCCESS;
+}
+
+static u32 _chk_cpwm_seq_num(u8 seq_num)
+{
+	u32 ret;
+
+	if (cpwm_seq_num == CPWM_SEQ_NUM_MAX) {
+		if (seq_num == 0) {
+			cpwm_seq_num = seq_num;
+			ret = MACSUCCESS;
+		} else {
+			ret = MACCPWMSEQERR;
+		}
+	} else {
+		if (seq_num == (cpwm_seq_num + 1)) {
+			cpwm_seq_num = seq_num;
+			ret = MACSUCCESS;
+		} else {
+			ret = MACCPWMSEQERR;
+		}
+	}
+
+	return ret;
+}
+
+static u32 chk_cur_pwr_state(struct mac_ax_adapter *adapter,
+			     enum mac_ax_rpwm_req_pwr_state req_pwr_state)
+{
+	u16 cpwm = 0;
+	u32 rpwm_32k;
+	u32 req_32k;
+#if MAC_AX_PCIE_SUPPORT
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 ret = MACSUCCESS;
+#endif
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (req_pwr_state >= MAC_AX_RPWM_REQ_PWR_STATE_CLK_GATED)
+		req_32k = 1;
+	else
+		req_32k = 0;
+
+	//(workaround) CPWM register is in OFF area
+	//Use LDM to check if FW receives RPWM
+	rpwm_32k = (MAC_REG_R32(R_AX_LDM) & B_PS_LDM_32K_EN) >> B_PS_LDM_32K_EN_SH;
+	if (req_32k != rpwm_32k)
+		return MACCPWMPWRSTATERR;
+
+	//There is no CPWM if 32K state
+	if (req_32k)
+		return MACSUCCESS;
+
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+		cpwm = MAC_REG_R16(R_AX_CPWM);
+#endif
+
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		switch (adapter->hw_info->intf) {
+#if MAC_AX_USB_SUPPORT
+		case MAC_AX_INTF_USB:
+			cpwm = MAC_REG_R16(R_AX_USB_D2F_F2D_INFO_V1);
+			break;
+#endif // MAC_AX_USB_SUPPORT
+
+#if MAC_AX_SDIO_SUPPORT
+		case MAC_AX_INTF_SDIO:
+			return MACCPWMINTFERR;
+			break;
+#endif // MAC_AX_SDIO_SUPPORT
+
+#if MAC_AX_PCIE_SUPPORT
+		case MAC_AX_INTF_PCIE:
+			cpwm = MAC_REG_R16(R_AX_PCIE_CRPWM);
+			break;
+#endif // MAC_AX_PCIE_SUPPORT
+		default:
+			PLTFM_MSG_ERR("%s: invalid interface = %d!!\n",
+				      __func__, adapter->hw_info->intf);
+			return MACCPWMINTFERR;
+			break;
+		}
+	}
+#endif
+
+	PLTFM_MSG_TRACE("Read CPWM=0x%x\n", cpwm);
+	if (rpwm_seq_num != GET_FIELD(cpwm, PS_CPWM_RSP_SEQ_NUM)) {
+		PLTFM_MSG_TRACE("RPWM seq mismatch!!: expect val:%d, Rx val:%d\n",
+				rpwm_seq_num, GET_FIELD(cpwm, PS_CPWM_RSP_SEQ_NUM));
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			return MACCPWMSEQERR;
+		}
+#endif
+	}
+
+	if (_chk_cpwm_seq_num(GET_FIELD(cpwm, PS_CPWM_SEQ_NUM)) == MACCPWMSEQERR) {
+		PLTFM_MSG_TRACE("CPWM seq mismatch!!: expect val:%d, Rx val:%d\n",
+				cpwm_seq_num, GET_FIELD(cpwm, PS_CPWM_SEQ_NUM));
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			return MACCPWMSEQERR;
+		}
+#endif
+	}
+
+	if (req_pwr_state != GET_FIELD(cpwm, PS_CPWM_STATE))
+		return MACCPWMSTATERR;
+
+	if (adapter->mac_pwr_info.pwr_in_lps) {
+		adapter->mac_pwr_info.pwr_in_lps = 0;
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+#if MAC_AX_PCIE_SUPPORT
+			if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+				ret = p_ops->sync_trx_bd_idx(adapter);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("sync trx bd fail: %d\n",
+						      ret);
+					return ret;
+				}
+			}
+#endif
+		}
+#endif
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_lps(struct mac_ax_adapter *adapter, u8 macid,
+		enum mac_ax_ps_mode ps_mode, struct mac_ax_lps_info *lps_info)
+{
+	u32 ret = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (ps_mode) {
+	case MAC_AX_PS_MODE_ACTIVE:
+		ret = leave_lps(adapter, macid);
+		/* patch form BT BG/LDO issue */
+		MAC_REG_W8(R_AX_SCOREBOARD + 3, MAC_AX_NOTIFY_TP_MAJOR);
+		break;
+	case MAC_AX_PS_MODE_LEGACY:
+		ret = enter_lps(adapter, macid, lps_info);
+		/* patch form BT BG/LDO issue */
+		MAC_REG_W8(R_AX_SCOREBOARD + 3, MAC_AX_NOTIFY_PWR_MAJOR);
+		break;
+	case MAC_AX_PS_MODE_WMMPS:
+		ret = enter_wmmlps(adapter, macid, lps_info);
+		/* patch form BT BG/LDO issue */
+		MAC_REG_W8(R_AX_SCOREBOARD + 3, MAC_AX_NOTIFY_PWR_MAJOR);
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_ps_pwr_state(struct mac_ax_adapter *adapter,
+		     enum mac_ax_pwr_state_action action,
+		     enum mac_ax_rpwm_req_pwr_state req_pwr_state)
+{
+	u32 ret = MACSUCCESS;
+
+	switch (action) {
+	case MAC_AX_PWR_STATE_ACT_REQ:
+		ret = set_req_pwr_state(adapter, req_pwr_state);
+		break;
+	case MAC_AX_PWR_STATE_ACT_CHK:
+		ret = chk_cur_pwr_state(adapter, req_pwr_state);
+		break;
+	default:
+		ret = MACNOITEM;
+	}
+
+	return ret;
+}
+
+void show_rx_bcn_info(struct mac_ax_adapter *adapter)
+{
+	u8 role_idx, bcn_rate, hit_rate, no_hit_rate;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+		role_idx = (u8)GET_FIELD(MAC_REG_R32(R_RXBCNHIT_RATE), B_AX_ROLE_IDX);
+		bcn_rate = (u8)GET_FIELD(MAC_REG_R32(R_RXBCNHIT_RATE), B_AX_BCN_RATE);
+		hit_rate = (u8)GET_FIELD(MAC_REG_R32(R_RXBCNHIT_RATE), B_AX_BCN_HIT_RATE);
+		no_hit_rate = (u8)GET_FIELD(MAC_REG_R32(R_RXBCNHIT_RATE), B_AX_BCN_NO_HIT_RATE);
+		PLTFM_MSG_ALWAYS("role_idx: %d, bcn_rx_rate = %d%%, hit_rate = %d%%, no_hit_rate = %d%%\n",
+				 role_idx, bcn_rate, hit_rate, no_hit_rate);
+}
+
+u32 mac_chk_leave_lps(struct mac_ax_adapter *adapter, u8 macid)
+{
+	u8 band = 0;
+	u8 port = 0;
+	u32 chk_msk = 0;
+	struct mac_role_tbl *role;
+	u16 pwrbit_set_reg[2] = {R_AX_PPWRBIT_SETTING, R_AX_PPWRBIT_SETTING_C1};
+	u32 pwr_mgt_en_bit = 0xE;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_pause = 0;
+	u32 reg_sleep = 0;
+	u8 macid_grp = macid >> MACID_GRP_SH;
+	u8 macid_sh = macid & MACID_GRP_MASK;
+
+	role = mac_role_srch(adapter, macid);
+
+	if (!role) {
+		PLTFM_MSG_ERR("[ERR]cannot find macid: %d\n", macid);
+		return MACNOITEM;
+	}
+
+	band = role->info.a_info.bb_sel;
+	port = role->info.a_info.port_int;
+
+	chk_msk = pwr_mgt_en_bit << (PORT_SH * port);
+	switch (macid_grp) {
+	case MACID_GRP_0:
+		reg_sleep = R_AX_MACID_SLEEP_0;
+		reg_pause = R_AX_SS_MACID_PAUSE_0;
+		break;
+	case MACID_GRP_1:
+		reg_sleep = R_AX_MACID_SLEEP_1;
+		reg_pause = R_AX_SS_MACID_PAUSE_1;
+		break;
+	case MACID_GRP_2:
+		reg_sleep = R_AX_MACID_SLEEP_2;
+		reg_pause = R_AX_SS_MACID_PAUSE_2;
+		break;
+	case MACID_GRP_3:
+		reg_sleep = R_AX_MACID_SLEEP_3;
+		reg_pause = R_AX_SS_MACID_PAUSE_3;
+		break;
+	default:
+		return MACPSSTATFAIL;
+	}
+
+	// Bypass Tx pause check during STOP SER period
+	if (adapter->sm.ser_ctrl_st != MAC_AX_SER_CTRL_STOP)
+		if (MAC_REG_R32(reg_pause) & BIT(macid_sh))
+			return MACPSSTATFAIL;
+
+	if ((MAC_REG_R32(reg_sleep) & BIT(macid_sh)))
+		return MACPSSTATFAIL;
+
+	if ((MAC_REG_R32(pwrbit_set_reg[band]) & chk_msk))
+		return MACPSSTATPWRBITFAIL;
+
+	show_rx_bcn_info(adapter);
+
+	return MACSUCCESS;
+}
+
+u8 _is_in_lps(struct mac_ax_adapter *adapter)
+{
+	u8 i;
+
+	for (i = 0; i < 4; i++) {
+		if (lps_status[i] != 0)
+			return 1;
+	}
+
+	return 0;
+}
+
+void reset_lps_seq_num(struct mac_ax_adapter *adapter)
+{
+	rpwm_seq_num = RPWM_SEQ_NUM_MAX;
+	cpwm_seq_num = CPWM_SEQ_NUM_MAX;
+}
+
+static u32 send_h2c_ips_cfg(struct mac_ax_adapter *adapter,
+			    struct ips_cfg *cfg)
+{
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_ips_cfg *fwcmd_ips;
+	u32 ret;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_ips_cfg));
+	if (!buf) {
+		h2cb_free(adapter, h2cb);
+		return MACNOBUF;
+	}
+
+	fwcmd_ips = (struct fwcmd_ips_cfg *)buf;
+	fwcmd_ips->dword0 =
+	cpu_to_le32(SET_WORD(cfg->macid, FWCMD_H2C_IPS_CFG_MACID) |
+		(cfg->enable ? FWCMD_H2C_IPS_CFG_ENABLE : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PS,
+			      FWCMD_H2C_FUNC_IPS_CFG,
+			      0,
+			      1);
+	if (ret != MACSUCCESS) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret != MACSUCCESS) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+}
+
+static u32 leave_ips(struct mac_ax_adapter *adapter, u8 macid)
+{
+	struct ips_cfg h2c_ips_cfg;
+	u32 ret;
+
+	PLTFM_MEMSET(&h2c_ips_cfg, 0, sizeof(struct ips_cfg));
+
+	h2c_ips_cfg.macid = macid;
+	h2c_ips_cfg.enable = 0;
+
+	ret = send_h2c_ips_cfg(adapter, &h2c_ips_cfg);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ips_status[(macid >> 5)] &= ~BIT(macid & 0x1F);
+
+	return MACSUCCESS;
+}
+
+static u32 enter_ips(struct mac_ax_adapter *adapter,
+		     u8 macid)
+{
+	struct ips_cfg h2c_ips_cfg;
+	u32 ret;
+
+	if (ips_status[(macid >> 5)] & BIT(macid & 0x1F)) {
+		PLTFM_MSG_ERR("[ERR]:IPS info is null\n");
+		ret = leave_ips(adapter, macid);
+		if (ret != MACSUCCESS)
+			return ret;
+	}
+
+	PLTFM_MEMSET(&h2c_ips_cfg, 0, sizeof(struct ips_cfg));
+
+	h2c_ips_cfg.macid = macid;
+	h2c_ips_cfg.enable = 1;
+
+	ret = send_h2c_ips_cfg(adapter, &h2c_ips_cfg);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ips_status[(macid >> 5)] |= BIT(macid & 0x1F);
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_ips(struct mac_ax_adapter *adapter, u8 macid,
+		u8 enable)
+{
+	u32 ret;
+
+	if (enable == 1)
+		ret = enter_ips(adapter, macid);
+	else
+		ret = leave_ips(adapter, macid);
+
+	return ret;
+}
+
+u32 mac_chk_leave_ips(struct mac_ax_adapter *adapter, u8 macid)
+{
+	u8 band = 0;
+	u8 port = 0;
+	u32 chk_msk = 0;
+	struct mac_role_tbl *role;
+	u32 pwr_mgt_en_bit = 0xE;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_pause = 0;
+	u32 reg_sleep = 0;
+	u8 macid_grp = macid >> MACID_GRP_SH;
+	u8 macid_sh = macid & MACID_GRP_MASK;
+
+	role = mac_role_srch(adapter, macid);
+
+	if (!role) {
+		PLTFM_MSG_ERR("[ERR]cannot find macid: %d\n", macid);
+		return MACNOITEM;
+	}
+
+	band = role->info.a_info.bb_sel;
+	port = role->info.a_info.port_int;
+
+	chk_msk = pwr_mgt_en_bit << (PORT_SH * port);
+	switch (macid_grp) {
+	case MACID_GRP_0:
+		reg_sleep = R_AX_MACID_SLEEP_0;
+		reg_pause = R_AX_SS_MACID_PAUSE_0;
+		break;
+	case MACID_GRP_1:
+		reg_sleep = R_AX_MACID_SLEEP_1;
+		reg_pause = R_AX_SS_MACID_PAUSE_1;
+		break;
+	case MACID_GRP_2:
+		reg_sleep = R_AX_MACID_SLEEP_2;
+		reg_pause = R_AX_SS_MACID_PAUSE_2;
+		break;
+	case MACID_GRP_3:
+		reg_sleep = R_AX_MACID_SLEEP_3;
+		reg_pause = R_AX_SS_MACID_PAUSE_3;
+		break;
+	default:
+		return MACPSSTATFAIL;
+	}
+
+	// Bypass Tx pause check during STOP SER period
+	if (adapter->sm.ser_ctrl_st != MAC_AX_SER_CTRL_STOP)
+		if (MAC_REG_R32(reg_pause) & BIT(macid_sh))
+			return MACPSSTATFAIL;
+
+	if (MAC_REG_R32(reg_sleep) & BIT(macid_sh))
+		return MACPSSTATFAIL;
+
+	return MACSUCCESS;
+}
+
+u8 _is_in_ips(struct mac_ax_adapter *adapter)
+{
+	u8 i;
+
+	for (i = 0; i < 4; i++) {
+		if (ips_status[i] != 0)
+			return 1;
+	}
+
+	return 0;
+}
+
+u32 mac_ps_notify_wake(struct mac_ax_adapter *adapter)
+{
+	struct ps_rpwm_parm parm;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct ps_rpwm_parm));
+
+	if (adapter->mac_pwr_info.pwr_in_lps == 0) {
+		PLTFM_MSG_ERR("%s: Not in power saving!\n", __func__);
+		return MACPWRSTAT;
+	}
+
+	parm.notify_wake = 1;
+	send_rpwm(adapter, &parm);
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_ps_advance_parm(struct mac_ax_adapter *adapter,
+			    struct mac_ax_ps_adv_parm *parm)
+{
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_ps_advance_parm *fwcmd_parm;
+	u32 ret;
+
+	if (!parm)
+		return MACBADDR;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	PLTFM_MSG_ALWAYS("%s: MACID(%d), TRXTimeOutTimeSet(%d), TRXTimeOutTimeVal(%d)!\n",
+			 __func__, parm->macid, parm->trxtimeouttimeset, parm->trxtimeouttimeval);
+	PLTFM_MSG_ALWAYS("%s: EnSmartPsDtimRx(%d)!\n", __func__, parm->ensmartpsdtimrx);
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_ps_advance_parm));
+	if (!buf) {
+		h2cb_free(adapter, h2cb);
+		return MACNOBUF;
+	}
+
+	fwcmd_parm = (struct fwcmd_ps_advance_parm *)buf;
+	fwcmd_parm->dword0 =
+	cpu_to_le32(SET_WORD(parm->macid, FWCMD_H2C_PS_ADVANCE_PARM_MACID) |
+		    SET_WORD(parm->trxtimeouttimeset, FWCMD_H2C_PS_ADVANCE_PARM_TRXTIMEOUTTIMESET) |
+		    (parm->ensmartpsdtimrx ? FWCMD_H2C_PS_ADVANCE_PARM_ENSMARTPSDTIMRX : 0) |
+		    (parm->entrxextmode ? FWCMD_H2C_PS_ADVANCE_PARM_TRXEXTMODE : 0));
+	fwcmd_parm->dword1 =
+	cpu_to_le32(SET_WORD(parm->trxtimeouttimeval, FWCMD_H2C_PS_ADVANCE_PARM_TRXTIMEOUTTIMEVAL) |
+		    SET_WORD(parm->extnum, FWCMD_H2C_PS_ADVANCE_PARM_EXTNUM));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PS,
+			      FWCMD_H2C_FUNC_PS_ADVANCE_PARM,
+			      0,
+			      1);
+	if (ret != MACSUCCESS) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret != MACSUCCESS) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+}
+
+static u32 send_h2c_pw_cfg(struct mac_ax_adapter *adapter,
+			   struct periodic_wake_cfg *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_periodic_wake *fwcmd_pw;
+	u32 ret = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_periodic_wake));
+
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_pw = (struct fwcmd_periodic_wake *)buf;
+	fwcmd_pw->dword0 =
+	cpu_to_le32(SET_WORD(parm->macid, FWCMD_H2C_PERIODIC_WAKE_MACID) |
+		(parm->enable ? FWCMD_H2C_PERIODIC_WAKE_ENABLE : 0) |
+		(parm->band ? FWCMD_H2C_PERIODIC_WAKE_BAND : 0) |
+		SET_WORD(parm->port, FWCMD_H2C_PERIODIC_WAKE_PORT));
+	fwcmd_pw->dword1 = cpu_to_le32(parm->wake_period);
+	fwcmd_pw->dword2 = cpu_to_le32(parm->wake_duration);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PS,
+			      FWCMD_H2C_FUNC_PERIODIC_WAKE,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_periodic_wake_cfg(struct mac_ax_adapter *adapter,
+			  struct mac_ax_periodic_wake_info pw_info)
+{
+	u32 ret = MACSUCCESS;
+	struct periodic_wake_cfg parm;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct periodic_wake_cfg));
+	parm.macid = pw_info.macid;
+	parm.enable = pw_info.enable;
+	parm.band = pw_info.band;
+	parm.port = pw_info.port;
+	parm.wake_period = pw_info.wake_period;
+	parm.wake_duration = pw_info.wake_duration;
+
+	PLTFM_MSG_ALWAYS("%s: macid(%d), enable(%d), band(%d), port(%d)\n",
+			 __func__, parm.macid, parm.enable, parm.band, parm.port);
+	PLTFM_MSG_ALWAYS("%s: wake_period(%d), wake_duration(%d)\n",
+			 __func__, parm.wake_period, parm.wake_duration);
+
+	ret = send_h2c_pw_cfg(adapter, &parm);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+u32 send_h2c_req_pwr_state(struct mac_ax_adapter *adapter,
+			   struct req_pwr_state_cfg *parm)
+{
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_bb_rf_pwr_st *fwcmd_req_pwr_st;
+	u32 ret = 0;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_bb_rf_pwr_st));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_req_pwr_st = (struct fwcmd_bb_rf_pwr_st *)buf;
+	fwcmd_req_pwr_st->dword0 =
+	cpu_to_le32(SET_WORD(parm->req_pwr_state, FWCMD_H2C_BB_RF_PWR_ST_BB_RF_PWR_REQ_ST));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PS,
+			      FWCMD_H2C_FUNC_BB_RF_PWR_ST,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 set_pwr_st_cfg(struct mac_ax_adapter *adapter,
+		   struct req_pwr_state_cfg *parm)
+{
+	u32 ret = MACSUCCESS;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (parm->req_pwr_state) {
+	case REQ_PWR_ST_ADC_OFF:
+		MAC_REG_W8(R_AX_ANAPAR_POW_MAC, (MAC_REG_R8(R_AX_ANAPAR_POW_MAC) &
+			   ~(B_AX_POW_PC_LDO_PORT0 | B_AX_POW_PC_LDO_PORT1)));
+		break;
+	case REQ_PWR_ST_BB_OFF:
+		MAC_REG_W8(R_AX_SYS_FUNC_EN, (MAC_REG_R8(R_AX_SYS_FUNC_EN) &
+			   ~(B_AX_FEN_BBRSTB | B_AX_FEN_BB_GLB_RSTN)));
+		MAC_REG_W8(R_AX_SYS_ISO_CTRL_EXTEND, (MAC_REG_R8(R_AX_SYS_ISO_CTRL_EXTEND) |
+			   B_AX_R_SYM_ISO_BB2PP));
+		MAC_REG_W16(R_AX_AFE_LDO_CTRL, (MAC_REG_R16(R_AX_AFE_LDO_CTRL) &
+			    ~(B_AX_R_SYM_WLBBOFF_PC_EN | B_AX_R_SYM_WLBBOFF_P1_PC_EN |
+			    B_AX_R_SYM_WLBBOFF_P2_PC_EN | B_AX_R_SYM_WLBBOFF_P3_PC_EN |
+			    B_AX_R_SYM_WLBBOFF_P4_PC_EN | B_AX_R_SYM_WLBBOFF1_P1_PC_EN |
+			    B_AX_R_SYM_WLBBOFF1_P2_PC_EN | B_AX_R_SYM_WLBBOFF1_P3_PC_EN |
+			    B_AX_R_SYM_WLBBOFF1_P4_PC_EN)));
+		break;
+	case REQ_PWR_ST_CPU_OFF:
+		MAC_REG_W8(R_AX_PLATFORM_ENABLE, (MAC_REG_R8(R_AX_PLATFORM_ENABLE) &
+			   ~B_AX_WCPU_EN));
+		MAC_REG_W16(R_AX_SYS_CLK_CTRL, (MAC_REG_R16(R_AX_SYS_CLK_CTRL) &
+			    ~(B_AX_CPU_CLK_EN | B_AX_CPU_IDMEM_CLK_EN)));
+		MAC_REG_W32(R_AX_SYS_ISO_CTRL_EXTEND, (MAC_REG_R32(R_AX_SYS_ISO_CTRL_EXTEND) |
+			    B_AX_R_SYM_ISO_IMEM02PP | B_AX_R_SYM_ISO_IMEM12PP |
+			    B_AX_R_SYM_ISO_IMEM22PP | B_AX_R_SYM_ISO_IMEM32PP |
+			    B_AX_R_SYM_ISO_IMEM42PP | B_AX_R_SYM_ISO_DMEM12PP_V1 |
+			    B_AX_R_SYM_ISO_DMEM22PP_V1 | B_AX_R_SYM_ISO_DMEM32PP_V1 |
+			    B_AX_R_SYM_ISO_DMEM42PP | B_AX_R_SYM_ISO_DMEM52PP |
+			    B_AX_R_SYM_ISO_DMEM62PP));
+		MAC_REG_W32(R_AX_AFE_CTRL1, (MAC_REG_R32(R_AX_AFE_CTRL1) &
+			    ~(B_AX_IMEM0_PC_EN | B_AX_IMEM1_PC_EN | B_AX_IMEM2_PC_EN |
+			    B_AX_IMEM3_PC_EN | B_AX_IMEM4_PC_EN | B_AX_DMEM1_PC_EN |
+			    B_AX_DMEM2_PC_EN | B_AX_DMEM3_PC_EN | B_AX_DMEM4_PC_EN |
+			    B_AX_DMEM5_PC_EN | B_AX_DMEM6_PC_EN)));
+		break;
+	case REQ_PWR_ST_MAC_OFF:
+		MAC_REG_W32(R_AX_SYS_ISO_CTRL_EXTEND, (MAC_REG_R32(R_AX_SYS_ISO_CTRL_EXTEND) &
+			    ~B_AX_R_SYM_FEN_WLMACOFF));
+		MAC_REG_W16(R_AX_SYS_CLK_CTRL, (MAC_REG_R16(R_AX_SYS_CLK_CTRL) & ~B_AX_MAC_CLK_EN));
+		MAC_REG_W8(R_AX_PMC_DBG_CTRL2, (MAC_REG_R8(R_AX_PMC_DBG_CTRL2) |
+			   B_AX_SYSON_DIS_PMCR_AX_WRMSK));
+		MAC_REG_W8(R_AX_SYS_ISO_CTRL, (MAC_REG_R8(R_AX_SYS_ISO_CTRL) | B_AX_ISO_WLPON2PP));
+		MAC_REG_W8(R_AX_SYS_ISO_CTRL, (MAC_REG_R8(R_AX_SYS_ISO_CTRL) | B_AX_ISO_WD2PP));
+		MAC_REG_W32(R_AX_AFE_LDO_CTRL, (MAC_REG_R32(R_AX_AFE_LDO_CTRL) &
+			    ~(B_AX_R_SYM_WLPOFF_PC_EN | B_AX_R_SYM_WLPOFF_P1_PC_EN |
+			    B_AX_R_SYM_WLPOFF_P2_PC_EN | B_AX_R_SYM_WLPOFF_P3_PC_EN |
+			    B_AX_R_SYM_WLPOFF_P4_PC_EN)));
+		MAC_REG_W32(R_AX_AFE_LDO_CTRL, (MAC_REG_R32(R_AX_AFE_LDO_CTRL) &
+			    ~(B_AX_R_SYM_WLPON_PC_EN | B_AX_R_SYM_WLPON_P1_PC_EN |
+			    B_AX_R_SYM_WLPON_P2_PC_EN | B_AX_R_SYM_WLPON_P3_PC_EN)));
+		break;
+	case REQ_PWR_ST_PLL_OFF:
+		MAC_REG_W8(R_AX_ANAPAR_POW_MAC, (MAC_REG_R8(R_AX_ANAPAR_POW_MAC) &
+			   ~(B_AX_POW_POWER_CUT_POW_LDO | B_AX_POW_PLL_V1)));
+		break;
+	case REQ_PWR_ST_SWRD_OFF:
+		MAC_REG_W8(R_AX_ANAPARLDO_POW_MAC, (MAC_REG_R8(R_AX_ANAPARLDO_POW_MAC) &
+			   ~B_AX_POW_SW_SPSDIG));
+		break;
+	case REQ_PWR_ST_XTAL_OFF:
+		MAC_REG_W32(R_AX_WLAN_XTAL_SI_CTRL, REQ_PWR_ST_XTAL_OFF_VAL);
+		break;
+	case REQ_PWR_ST_ADIE_OFF:
+		MAC_REG_W32(R_AX_SYM_ANAPAR_XTAL_MODE_DECODER,
+			    (MAC_REG_R32(R_AX_SYM_ANAPAR_XTAL_MODE_DECODER) |
+			    B_AX_ADIE_CTRL_BY_SW));
+		MAC_REG_W32(R_AX_SYM_ANAPAR_XTAL_MODE_DECODER,
+			    (MAC_REG_R32(R_AX_SYM_ANAPAR_XTAL_MODE_DECODER) & ~B_AX_ADIE_EN));
+		break;
+	case REQ_PWR_ST_BYPASS_DATA_ON:
+		MAC_REG_W32(R_AX_RCR, (MAC_REG_R32(R_AX_RCR) | B_AX_STOP_RX_IN));
+		if ((MAC_REG_R32(R_AX_SYS_ISO_CTRL_EXTEND) & B_AX_CMAC1_FEN) == B_AX_CMAC1_FEN)
+			MAC_REG_W32(R_AX_RCR_C1, (MAC_REG_R32(R_AX_RCR_C1) | B_AX_STOP_RX_IN));
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return ret;
+}
+
+u32 mac_req_pwr_state_cfg(struct mac_ax_adapter *adapter,
+			  enum mac_req_pwr_st req_pwr_st)
+{
+	u32 ret = MACSUCCESS;
+	struct req_pwr_state_cfg parm;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct req_pwr_state_cfg));
+	parm.req_pwr_state = req_pwr_st;
+
+	switch (req_pwr_st) {
+	case REQ_PWR_ST_OPEN_RF:
+		ret = send_h2c_req_pwr_state(adapter, &parm);
+		break;
+	case REQ_PWR_ST_CLOSE_RF:
+		ret = send_h2c_req_pwr_state(adapter, &parm);
+		break;
+	case REQ_PWR_ST_ADC_OFF:
+		ret = set_pwr_st_cfg(adapter, &parm);
+		break;
+	case REQ_PWR_ST_BB_OFF:
+		ret = set_pwr_st_cfg(adapter, &parm);
+		break;
+	case REQ_PWR_ST_CPU_OFF:
+		ret = set_pwr_st_cfg(adapter, &parm);
+		break;
+	case REQ_PWR_ST_MAC_OFF:
+		ret = set_pwr_st_cfg(adapter, &parm);
+		break;
+	case REQ_PWR_ST_PLL_OFF:
+		ret = set_pwr_st_cfg(adapter, &parm);
+		break;
+	case REQ_PWR_ST_SWRD_OFF:
+		ret = set_pwr_st_cfg(adapter, &parm);
+		break;
+	case REQ_PWR_ST_XTAL_OFF:
+		ret = set_pwr_st_cfg(adapter, &parm);
+		break;
+	case REQ_PWR_ST_ADIE_OFF:
+		ret = set_pwr_st_cfg(adapter, &parm);
+		break;
+	case REQ_PWR_ST_BYPASS_DATA_ON:
+		ret = set_pwr_st_cfg(adapter, &parm);
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return ret;
+}
+
+u32 send_h2c_req_pwr_lvl(struct mac_ax_adapter *adapter,
+			 struct req_pwr_lvl_cfg *parm)
+{
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_ps_power_level *fwcmd_req_pwr_lvl;
+	u32 ret = 0;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_ps_power_level));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_req_pwr_lvl = (struct fwcmd_ps_power_level *)buf;
+	fwcmd_req_pwr_lvl->dword0 =
+	cpu_to_le32(SET_WORD(parm->macid, FWCMD_H2C_PS_POWER_LEVEL_MACID) |
+		    SET_WORD(parm->bcn_to_val, FWCMD_H2C_PS_POWER_LEVEL_BCN_TO_VAL) |
+		    SET_WORD(parm->ps_lvl, FWCMD_H2C_PS_POWER_LEVEL_PS_LVL) |
+		    SET_WORD(parm->trx_lvl, FWCMD_H2C_PS_POWER_LEVEL_TRX_LVL));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PS,
+			      FWCMD_H2C_FUNC_PS_POWER_LEVEL,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_req_pwr_lvl_cfg(struct mac_ax_adapter *adapter,
+			struct mac_ax_req_pwr_lvl_info *pwr_lvl_info)
+{
+	u32 ret = MACSUCCESS;
+	struct req_pwr_lvl_cfg parm;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct req_pwr_lvl_cfg));
+
+	parm.macid = pwr_lvl_info->macid;
+
+	if (pwr_lvl_info->ps_lvl >= REQ_PS_LVL_MAX ||
+	    pwr_lvl_info->trx_lvl >= REQ_TRX_LVL_MAX ||
+	    pwr_lvl_info->bcn_to_lvl >= REQ_BCN_TO_LVL_MAX)
+		return MACNOITEM;
+
+	if (pwr_lvl_info->bcn_to_val == REQ_BCN_TO_VAL_NONVALID)
+		pwr_lvl_info->bcn_to_val = REQ_BCN_TO_VAL_MIN << pwr_lvl_info->bcn_to_lvl;
+	else if (pwr_lvl_info->bcn_to_val < REQ_BCN_TO_VAL_MIN)
+		pwr_lvl_info->bcn_to_val = REQ_BCN_TO_VAL_MIN;
+	else if (pwr_lvl_info->bcn_to_val > REQ_BCN_TO_VAL_MAX)
+		pwr_lvl_info->bcn_to_val = REQ_BCN_TO_VAL_MAX;
+
+	parm.bcn_to_val = pwr_lvl_info->bcn_to_val;
+	parm.ps_lvl = pwr_lvl_info->ps_lvl;
+	parm.trx_lvl = pwr_lvl_info->trx_lvl;
+
+	ret = send_h2c_req_pwr_lvl(adapter, &parm);
+
+	return ret;
+}
+
+u32 send_h2c_lps_option_cfg(struct mac_ax_adapter *adapter,
+			    struct lps_option_cfg *parm)
+{
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_lps_option_cfg *fwcmd_lps_option;
+	u32 ret = 0;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_lps_option_cfg));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_lps_option = (struct fwcmd_lps_option_cfg *)buf;
+	fwcmd_lps_option->dword0 =
+	cpu_to_le32(parm->req_lps_option ? FWCMD_H2C_LPS_OPTION_CFG_REQ_XTAL_OPTION : 0);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PS,
+			      FWCMD_H2C_FUNC_LPS_OPTION_CFG,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_lps_option_cfg(struct mac_ax_adapter *adapter,
+		       struct mac_lps_option *lps_opt)
+{
+	u32 ret = MACSUCCESS;
+	struct lps_option_cfg parm;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct lps_option_cfg));
+
+#if MAC_AX_USB_SUPPORT
+	if (adapter->hw_info->intf == MAC_AX_INTF_USB) {
+		parm.req_lps_option = lps_opt->req_xtal_option;
+		ret = send_h2c_lps_option_cfg(adapter, &parm);
+	}
+#endif //MAC_AX_USB_SUPPORT
+	return ret;
+}
+
+u32 send_h2c_tbtt_tuning(struct mac_ax_adapter *adapter,
+			 struct tbtt_tuning_cfg *parm)
+{
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_tbtt_tuning *fwcmd_tbtt_tuning_info;
+	u32 ret = 0;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_tbtt_tuning));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_tbtt_tuning_info = (struct fwcmd_tbtt_tuning *)buf;
+	fwcmd_tbtt_tuning_info->dword0 =
+	cpu_to_le32(SET_WORD(parm->band, FWCMD_H2C_TBTT_TUNING_BAND) |
+		    SET_WORD(parm->port, FWCMD_H2C_TBTT_TUNING_PORT));
+
+	fwcmd_tbtt_tuning_info->dword1 =
+	cpu_to_le32(SET_WORD(parm->shift_val, FWCMD_H2C_TBTT_TUNING_SHIFT_VAL));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PS,
+			      FWCMD_H2C_FUNC_TBTT_TUNING,
+			      0,
+			      0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_tbtt_tuning_cfg(struct mac_ax_adapter *adapter,
+			struct mac_ax_tbtt_tuning_info *tbtt_tuning_info)
+{
+	u32 ret = MACSUCCESS;
+	struct tbtt_tuning_cfg parm;
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	struct mac_ax_port_cfg_para cfg_para;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+
+		cfg_para.mbssid_idx = 0;
+		cfg_para.val = tbtt_tuning_info->shift_val/TU_UNIT;
+		cfg_para.port = (u8)tbtt_tuning_info->port;
+		cfg_para.band = (u8)tbtt_tuning_info->band;
+		ret = mac_port_cfg(adapter, MAC_AX_PCFG_TBTT_SHIFT, &cfg_para);
+
+		return ret;
+	}
+#endif
+	PLTFM_MEMSET(&parm, 0, sizeof(struct tbtt_tuning_cfg));
+
+	if (tbtt_tuning_info->band < MAC_AX_BAND_NUM)
+		parm.band = tbtt_tuning_info->band;
+	else
+		return MACNOITEM;
+
+	if (tbtt_tuning_info->port < MAC_AX_PORT_NUM)
+		parm.port = tbtt_tuning_info->port;
+	else
+		return MACNOITEM;
+
+	parm.shift_val = tbtt_tuning_info->shift_val;
+
+	ret = send_h2c_tbtt_tuning(adapter, &parm);
+
+	return ret;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/power_saving.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/power_saving.h
new file mode 100644
index 000000000000..da671ffc2bf8
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/power_saving.h
@@ -0,0 +1,545 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_POWER_SAVING_H_
+#define _MAC_AX_POWER_SAVING_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+#include "role.h"
+
+#define	MACID_GRP_SH	5
+#define	MACID_GRP_MASK	0x1F
+#define PORT_SH		4
+
+#define REQ_BCN_TO_VAL_MIN	4
+#define REQ_BCN_TO_VAL_MAX	64
+
+#define REQ_BCN_TO_VAL_NONVALID	0
+
+#define RPWM_DELAY_FOR_32K_TICK	64
+
+#define REQ_PWR_ST_XTAL_OFF_VAL	0x82ff0000
+/**
+ * @enum last_rpwm_mode
+ *
+ * @brief last_rpwm_mode
+ *
+ * @var last_rpwm_mode::LAST_RPWM_PS
+ * Please Place Description here.
+ * @var last_rpwm_mode::LAST_RPWM_ACTIVE
+ * Please Place Description here.
+ */
+enum last_rpwm_mode {
+	LAST_RPWM_PS        = 0x0,
+	LAST_RPWM_ACTIVE    = 0x6,
+};
+
+/**
+ * @struct lps_parm
+ * @brief lps_parm
+ *
+ * @var lps_parm::macid
+ * Please Place Description here.
+ * @var lps_parm::psmode
+ * Please Place Description here.
+ * @var lps_parm::rlbm
+ * Please Place Description here.
+ * @var lps_parm::smartps
+ * Please Place Description here.
+ * @var lps_parm::awakeinterval
+ * Please Place Description here.
+ * @var lps_parm::vouapsd
+ * Please Place Description here.
+ * @var lps_parm::viuapsd
+ * Please Place Description here.
+ * @var lps_parm::beuapsd
+ * Please Place Description here.
+ * @var lps_parm::bkuapsd
+ * Please Place Description here.
+ * @var lps_parm::rsvd
+ * Please Place Description here.
+ * @var lps_parm::lastrpwm
+ * Please Place Description here.
+ * @var lps_parm::bcnnohit_en
+ * Please Place Description here.
+ * @var lps_parm::nulltype
+ * Please Place Description here.
+ * @var lps_parm::dyntxantnum_en
+ * Please Place Description here.
+ * @var lps_parm::maxtxantnum
+ * Please Place Description here.
+ * @var lps_parm::lpstxantnum
+ * Please Place Description here.
+ * @var lps_parm::rsvd1
+ * Please Place Description here.
+ */
+struct lps_parm {
+	u32 macid:8;
+	u32 psmode:8;
+	u32 rlbm:4;
+	u32 smartps:4;
+	u32 awakeinterval:8;
+	u32 vouapsd:1;
+	u32 viuapsd:1;
+	u32 beuapsd:1;
+	u32 bkuapsd:1;
+	u32 rsvd:4;
+	u32 lastrpwm:8;
+	u32 bcnnohit_en:1;
+	u32 nulltype:1;
+	u32 dyntxantnum_en:1;
+	u32 maxtxantnum:1;
+	u32 lpstxantnum:1;
+	u32 rsvd1:11;
+};
+
+/**
+ * @struct ps_rpwm_parm
+ * @brief ps_rpwm_parm
+ *
+ * @var ps_rpwm_parm::req_pwr_state
+ * Please Place Description here.
+ * @var ps_rpwm_parm::notify_wake
+ * Please Place Description here.
+ * @var ps_rpwm_parm::rsvd0
+ */
+struct ps_rpwm_parm {
+	enum mac_ax_rpwm_req_pwr_state req_pwr_state;
+	u32 notify_wake:1;
+	u32 rsvd0:31;
+};
+
+/**
+ * @macid_grp_list
+ *
+ * @brief macid_grp_list
+ *
+ * @var macid_grp_list::MACID_GRP_0
+ * Please Place Description here.
+ * @var macid_grp_list::MACID_GRP_1
+ * Please Place Description here.
+ * @var macid_grp_list::MACID_GRP_2
+ * Please Place Description here.
+ * @var macid_grp_list::MACID_GRP_3
+ * Please Place Description here.
+ */
+enum macid_grp_list {
+	MACID_GRP_0	= 0,
+	MACID_GRP_1	= 1,
+	MACID_GRP_2	= 2,
+	MACID_GRP_3	= 3,
+};
+
+/**
+ * @struct ips_cfg
+ * @brief ips_cfg
+ *
+ * @var ips_cfg::macid
+ * Please Place Description here.
+ * @var ips_cfg::enable
+ * Please Place Description here.
+ * @var ips_cfg::rsvd0
+ * Please Place Description here.
+ */
+struct ips_cfg {
+	u32 macid:8;
+	u32 enable:1;
+	u32 rsvd0:23;
+};
+
+/**
+ * @struct periodic_wake_cfg
+ * @brief periodic_wake_cfg
+ *
+ * @var fw_redl_cfg::
+ * Please Place Description here.
+ * @var fw_redl_cfg::rsvd
+ * Please Place Description here.
+ */
+struct periodic_wake_cfg {
+	u32 macid:8;
+	u32 enable:1;
+	u32 band:1;
+	u32 port:3;
+	u32 rsvd:19;
+	u32 wake_period;
+	u32 wake_duration;
+};
+
+/**
+ * @struct req_pwr_state_cfg
+ * @brief req_pwr_state_cfg
+ *
+ * @var req_pwr_state_cfg::req_pwr_state
+ * Please Place Description here.
+ * @var req_pwr_state_cfg::rsvd0
+ * Please Place Description here.
+ */
+struct req_pwr_state_cfg {
+	u32 req_pwr_state:8;
+	u32 rsvd0:24;
+};
+
+/**
+ * @struct req_pwr_lvl_cfg
+ * @brief req_pwr_vl_cfg
+ *
+ * @var req_pwr_lvl_cfg::macid
+ * Please Place Description here.
+ * @var req_pwr_lvl_cfg::bcn_to_val
+ * Please Place Description here.
+ * @var req_pwr_lvl_cfg::ps_lvl
+ * Please Place Description here.
+ * @var req_pwr_lvl_cfg::trx_lvl
+ * Please Place Description here.
+ * @var req_pwr_lvl_cfg::bcn_to_lvl
+ * Please Place Description here.
+ * @var req_pwr_lvl_cfg::rsvd0
+ * Please Place Description here.
+ */
+struct req_pwr_lvl_cfg {
+	u32 macid:8;
+	u32 bcn_to_val:8;
+	u32 ps_lvl:4;
+	u32 trx_lvl:4;
+	u32 bcn_to_lvl:4;
+	u32 rsvd0:4;
+};
+
+/**
+ * @struct lps_option_cfg
+ * @brief lps_option_cfg
+ *
+ * @var lps_option_cfg::req_lps_option
+ * Please Place Description here.
+ * @var lps_option_cfg::rsvd0
+ * Please Place Description here.
+ */
+struct lps_option_cfg {
+	u32 req_lps_option:1;
+	u32 rsvd0:31;
+};
+
+/**
+ * @struct tbtt_tuning_cfg
+ * @brief tbtt_tuning_cfg
+ *
+ * @var tbtt_tuning_cfg::band
+ * Please Place Description here.
+ * @var tbtt_tuning_cfg::port
+ * Please Place Description here.
+ * @var tbtt_tuning_cfg::rsvd0
+ * Please Place Description here.
+ * @var tbtt_tuning_cfg::shift_val
+ * Please Place Description here.
+ */
+struct tbtt_tuning_cfg {
+	u32 band:4;
+	u32 port:4;
+	u32 rsvd0:24;
+	u32 shift_val;
+};
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup LPS
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_lps
+ *
+ * @param *adapter
+ * @param macid
+ * @param ps_mode
+ * @param *lps_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_lps(struct mac_ax_adapter *adapter, u8 macid,
+		enum mac_ax_ps_mode ps_mode, struct mac_ax_lps_info *lps_info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup LPS
+ * @{
+ */
+
+/**
+ * @brief mac_ps_pwr_state
+ *
+ * @param *adapter
+ * @param action
+ * @param req_pwr_state
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_ps_pwr_state(struct mac_ax_adapter *adapter,
+		     enum mac_ax_pwr_state_action action,
+		     enum mac_ax_rpwm_req_pwr_state req_pwr_state);
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup LPS
+ * @{
+ */
+
+/**
+ * @brief mac_chk_leave_lps
+ *
+ * @param *adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_chk_leave_lps(struct mac_ax_adapter *adapter, u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup LPS
+ * @{
+ */
+
+/**
+ * @brief _is_in_lps
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u8
+ */
+
+u8 _is_in_lps(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup LPS
+ * @{
+ */
+
+/**
+ * @brief reset_lps_seq_num
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval void
+ */
+void reset_lps_seq_num(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup IPS
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_ips
+ *
+ * @param *adapter
+ * @param macid
+ * @param enable
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_ips(struct mac_ax_adapter *adapter, u8 macid, u8 enable);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup IPS
+ * @{
+ */
+
+/**
+ * @brief mac_chk_leave_ips
+ *
+ * @param *adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_chk_leave_ips(struct mac_ax_adapter *adapter, u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup IPS
+ * @{
+ */
+
+/**
+ * @brief _is_in_ips
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u8
+ */
+u8 _is_in_ips(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup LPS
+ * @{
+ */
+
+/**
+ * @brief mac_ps_notify_wake
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_ps_notify_wake(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup LPS
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_ps_advance_parm
+ *
+ * @param *adapter
+ * @param parm
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_ps_advance_parm(struct mac_ax_adapter *adapter,
+			    struct mac_ax_ps_adv_parm *parm);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_periodic_wake_cfg
+ *
+ * @param *adapter
+ * @param pw_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_periodic_wake_cfg(struct mac_ax_adapter *adapter,
+			  struct mac_ax_periodic_wake_info pw_info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_req_pwr_state_cfg
+ *
+ * @param *adapter
+ * @param req_pwr_st
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_req_pwr_state_cfg(struct mac_ax_adapter *adapter,
+			  enum mac_req_pwr_st req_pwr_st);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_req_pwr_lvl_cfg
+ *
+ * @param *adapter
+ * @param *pwr_lvl_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_req_pwr_lvl_cfg(struct mac_ax_adapter *adapter,
+			struct mac_ax_req_pwr_lvl_info *pwr_lvl_info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_lps_option_cfg
+ *
+ * @param *adapter
+ * @param *lps_option
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_lps_option_cfg(struct mac_ax_adapter *adapter,
+		       struct mac_lps_option *lps_option);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @brief mac_tbtt_tuning_cfg
+ *
+ * @param *adapter
+ * @param *tbtt_tuning_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_tbtt_tuning_cfg(struct mac_ax_adapter *adapter,
+			struct mac_ax_tbtt_tuning_info *tbtt_tuning_info);
+/**
+ * @}
+ * @}
+ */
+
+#endif // #define _MAC_AX_POWER_SAVING_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr.c
new file mode 100644
index 000000000000..a53fd989d945
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr.c
@@ -0,0 +1,432 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "pwr.h"
+#include "coex.h"
+#include "mac_priv.h"
+
+static void restore_flr_lps(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32 = 0;
+
+	MAC_REG_W32(R_AX_WCPU_FW_CTRL, 0);
+
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		MAC_REG_W32(R_AX_AFE_CTRL1, MAC_REG_R32(R_AX_AFE_CTRL1) &
+			    ~B_AX_CMAC_CLK_SEL);
+
+		val32 = MAC_REG_R32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_LOW_EN);
+		MAC_REG_W32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_LOW_EN, val32 &
+			    ~(B_AX_GPIO8_PULL_LOW_EN | B_AX_LED1_PULL_LOW_EN));
+	}
+#endif
+
+#if (MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT || MAC_AX_1115E_SUPPORT)
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D) ||
+	    is_chip_id(adapter, MAC_BE_CHIP_ID_1115E)) {
+		val32 = MAC_REG_R32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_LOW_EN);
+		MAC_REG_W32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_LOW_EN, val32 &
+			    ~(B_AX_GPIO8_PULL_LOW_EN |
+			      B_AX_LED1_PULL_LOW_EN_V1));
+	}
+#endif
+}
+
+static void clr_aon_int(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	if (adapter->hw_info->intf != MAC_AX_INTF_PCIE)
+		return;
+
+	val32 = MAC_REG_R32(R_AX_FWS0IMR);
+	val32 &= ~B_AX_FS_GPIOA_INT_EN;
+	MAC_REG_W32(R_AX_FWS0IMR, val32);
+
+	val32 = MAC_REG_R32(R_AX_FWS0ISR);
+	val32 |= B_AX_FS_GPIOA_INT;
+	MAC_REG_W32(R_AX_FWS0ISR, val32);
+}
+
+static u32 _patch_flr_lps(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, cnt, ret = MACSUCCESS;
+
+	if (chk_patch_flr_lps(adapter) == PATCH_DISABLE)
+		return MACSUCCESS;
+
+	restore_flr_lps(adapter);
+
+	val32 = MAC_REG_R32(R_AX_FWS0IMR);
+	val32 |= B_AX_FS_GPIOA_INT_EN;
+	MAC_REG_W32(R_AX_FWS0IMR, val32);
+
+	ret = mac_ops->set_gpio_func(adapter, RTW_MAC_GPIO_SW_IO,
+				     LPS_LEAVE_GPIO);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]set gpio fail %d\n", ret);
+		return ret;
+	}
+
+	val32 = MAC_REG_R32(R_AX_GPIO_EXT_CTRL);
+	val32 &= ~BIT18;
+	MAC_REG_W32(R_AX_GPIO_EXT_CTRL, val32);
+
+	val32 = MAC_REG_R32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_LOW_EN);
+	val32 &= ~B_AX_GPIO10_PULL_LOW_EN;
+	MAC_REG_W32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_LOW_EN, val32);
+
+	val32 = MAC_REG_R32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_HIGH_EN);
+	val32 |= B_AX_GPIO10_PULL_HIGH_EN;
+	MAC_REG_W32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_HIGH_EN, val32);
+
+	val32 = MAC_REG_R32(R_AX_GPIO_INTM);
+	val32 |= B_AX_GPIOA_INT_MD;
+	MAC_REG_W32(R_AX_GPIO_INTM, val32);
+
+	val32 = MAC_REG_R32(R_AX_GPIO_EXT_CTRL);
+	val32 |= BIT26;
+	MAC_REG_W32(R_AX_GPIO_EXT_CTRL, val32);
+
+	val32 = MAC_REG_R32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_LOW_EN);
+	val32 |= B_AX_GPIO10_PULL_LOW_EN;
+	MAC_REG_W32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_LOW_EN, val32);
+
+	val32 = MAC_REG_R32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_HIGH_EN);
+	val32 &= ~B_AX_GPIO10_PULL_HIGH_EN;
+	MAC_REG_W32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_HIGH_EN, val32);
+
+	val32 = MAC_REG_R32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_LOW_EN);
+	val32 &= ~B_AX_GPIO10_PULL_LOW_EN;
+	MAC_REG_W32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_LOW_EN, val32);
+
+	val32 = MAC_REG_R32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_HIGH_EN);
+	val32 |= B_AX_GPIO10_PULL_HIGH_EN;
+	MAC_REG_W32(R_AX_GPIO0_15_EECS_EESK_LED1_PULL_HIGH_EN, val32);
+
+	cnt = LPS_POLL_CNT;
+	while (cnt && (GET_FIELD(MAC_REG_R32(R_AX_IC_PWR_STATE), B_AX_WLMAC_PWR_STE) ==
+		       MAC_AX_MAC_LPS)) {
+		cnt--;
+		PLTFM_DELAY_US(LPS_POLL_DLY_US);
+	}
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR]Polling MAC state timeout! 0x3F0 = %X\n",
+			      MAC_REG_R32(R_AX_IC_PWR_STATE));
+		return MACPOLLTO;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 pwr_cmd_poll(struct mac_ax_adapter *adapter, struct mac_pwr_cfg *seq)
+{
+	u8 val = 0;
+	u32 addr;
+	u32 cnt;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	cnt = PWR_POLL_CNT;
+	addr = seq->addr;
+
+	while (cnt--) {
+		val = MAC_REG_R8(addr);
+		val &= seq->msk;
+		if (val == (seq->val & seq->msk))
+			return MACSUCCESS;
+		PLTFM_DELAY_US(PWR_POLL_DLY_US);
+	}
+
+	PLTFM_MSG_ERR("[ERR] Polling timeout\n");
+	PLTFM_MSG_ERR("[ERR] addr: %X, %X\n", addr, seq->addr);
+	PLTFM_MSG_ERR("[ERR] val: %X, %X\n", val, seq->val);
+
+	return MACPOLLTO;
+}
+
+static u32 sub_pwr_seq_start(struct mac_ax_adapter *adapter,
+			     u8 cv_msk, u8 intf_msk, struct mac_pwr_cfg *seq)
+{
+	u8 val;
+	u32 addr;
+	u32 ret;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	while (seq->cmd != PWR_CMD_END) {
+		if (!(seq->intf_msk & intf_msk) || !(seq->cut_msk & cv_msk))
+			goto next_seq;
+
+		switch (seq->cmd) {
+		case PWR_CMD_WRITE:
+			addr = seq->addr;
+			val = MAC_REG_R8(addr);
+			val &= ~(seq->msk);
+			val |= (seq->val & seq->msk);
+
+			MAC_REG_W8(addr, val);
+			break;
+		case PWR_CMD_POLL:
+			ret = pwr_cmd_poll(adapter, seq);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("[ERR]pwr cmd poll %d\n", ret);
+				return ret;
+			}
+			break;
+		case PWR_CMD_DELAY:
+			if (seq->val == PWR_DELAY_US)
+				PLTFM_DELAY_US(seq->addr);
+			else
+				PLTFM_DELAY_US(seq->addr * 1000);
+			break;
+		default:
+			PLTFM_MSG_ERR("[ERR]unknown pwr seq cmd %d\n",
+				      seq->cmd);
+			return MACNOITEM;
+		}
+next_seq:
+		seq++;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 pwr_seq_start(struct mac_ax_adapter *adapter,
+		  struct mac_pwr_cfg **seq)
+{
+	u8 cv;
+	u8 intf;
+	u32 ret;
+	struct mac_ax_hw_info *hw_info = adapter->hw_info;
+	struct mac_pwr_cfg *sub_seq = *seq;
+#if MAC_AX_USB_SUPPORT
+	u32 val = 0;
+#endif
+
+	switch (hw_info->cv) {
+	case CAV:
+		cv = PWR_CAV_MSK;
+		break;
+	case CBV:
+		cv = PWR_CBV_MSK;
+		break;
+	case CCV:
+		cv = PWR_CCV_MSK;
+		break;
+	case CDV:
+		cv = PWR_CDV_MSK;
+		break;
+	case CEV:
+		cv = PWR_CEV_MSK;
+		break;
+	case CFV:
+		cv = PWR_CFV_MSK;
+		break;
+	case CGV:
+		//fall through
+	default:
+		PLTFM_MSG_ERR("[ERR]cut version\n");
+		cv = PWR_CGV_MSK;
+		break;
+	}
+
+	switch (hw_info->intf) {
+	case MAC_AX_INTF_SDIO:
+		intf = PWR_INTF_MSK_SDIO;
+		break;
+	case MAC_AX_INTF_USB:
+#if MAC_AX_USB_SUPPORT
+		val = get_usb_mode(adapter);
+		if (val == MAC_AX_USB3)
+			intf = PWR_INTF_MSK_USB3;
+		else
+			intf = PWR_INTF_MSK_USB2;
+		break;
+#endif
+	case MAC_AX_INTF_PCIE:
+		intf = PWR_INTF_MSK_PCIE;
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR]interface\n");
+		return MACNOITEM;
+	}
+
+	while (sub_seq) {
+		ret = sub_pwr_seq_start(adapter, cv, intf, sub_seq);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]sub pwr seq %d\n", ret);
+			return ret;
+		}
+		seq++;
+		sub_seq = *seq;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_pwr_switch(struct mac_ax_adapter *adapter, u8 on)
+{
+	u32 ret = MACSUCCESS;
+	u32 ret_end;
+	struct mac_pwr_cfg **pwr_seq;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	u32 (*pwr_func)(struct mac_ax_adapter *adapter);
+	u32 val32;
+	u32 cnt = PWR_POLL_CNT;
+
+	val32 = MAC_REG_R32(R_AX_GPIO_MUXCFG) & B_AX_BOOT_MODE;
+	if (val32 == B_AX_BOOT_MODE) {
+		val32 = MAC_REG_R32(R_AX_SYS_PW_CTRL) & ~B_AX_APFN_ONMAC;
+		MAC_REG_W32(R_AX_SYS_PW_CTRL, val32);
+		val32 = MAC_REG_R32(R_AX_SYS_STATUS1) & ~B_AX_AUTO_WLPON;
+		MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+		val32 = MAC_REG_R32(R_AX_GPIO_MUXCFG) & ~B_AX_BOOT_MODE;
+		MAC_REG_W32(R_AX_GPIO_MUXCFG, val32);
+		val32 = MAC_REG_R32(R_AX_RSV_CTRL) & ~B_AX_R_DIS_PRST;
+		MAC_REG_W32(R_AX_RSV_CTRL, val32);
+	}
+
+	val32 = MAC_REG_R32(R_AX_IC_PWR_STATE);
+	val32 = GET_FIELD(val32, B_AX_WLMAC_PWR_STE);
+	if (val32 == MAC_AX_MAC_OFF && on == MAC_AX_MAC_OFF) {
+		PLTFM_MSG_WARN("MAC has already powered off\n");
+		return MACSUCCESS;
+	}
+
+	if (!p_ops->intf_pwr_switch) {
+		PLTFM_MSG_ERR("interface power switch func is NULL\n");
+		ret = MACNPTR;
+		return ret;
+	}
+
+	if (on) {
+		pwr_seq = adapter->hw_info->pwr_on_seq;
+		pwr_func = p_ops->pwr_on;
+	} else {
+		pwr_seq = adapter->hw_info->pwr_off_seq;
+		pwr_func = p_ops->pwr_off;
+		adapter->sm.pwr = MAC_AX_PWR_PRE_OFF;
+		adapter->sm.dmac_func = MAC_AX_FUNC_OFF;
+		adapter->sm.cmac0_func = MAC_AX_FUNC_OFF;
+		adapter->sm.cmac1_func = MAC_AX_FUNC_OFF;
+		adapter->sm.bb0_func = MAC_AX_FUNC_OFF;
+		adapter->sm.bb1_func = MAC_AX_FUNC_OFF;
+		adapter->sm.plat = MAC_AX_PLAT_OFF;
+	}
+
+	ret = p_ops->intf_pwr_switch(adapter, PWR_PRE_SWITCH, on);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("interface pre pwr switch fails %d\n", ret);
+		goto END;
+	}
+
+	if (on) {
+		ret = mac_ps_pwr_state(adapter, MAC_AX_PWR_STATE_ACT_REQ,
+				       MAC_AX_RPWM_REQ_PWR_STATE_ACTIVE);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("MAC_AX_PWR_STATE_ACT_REQ fail %X\n", ret);
+			goto END;
+		}
+
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		MAC_REG_W32(R_AX_AFE_CTRL1, MAC_REG_R32(R_AX_AFE_CTRL1) &
+			    ~B_AX_CMAC_CLK_SEL);
+	}
+#endif
+
+		while (--cnt) {
+			val32 = MAC_REG_R32(R_AX_IC_PWR_STATE);
+			val32 = GET_FIELD(val32, B_AX_WLMAC_PWR_STE);
+			if (val32 != MAC_AX_MAC_LPS)
+				break;
+			PLTFM_DELAY_US(PWR_POLL_DLY_US);
+		}
+
+		if (val32 == MAC_AX_MAC_ON) {
+			PLTFM_MSG_WARN("MAC has already powered on %d\n", val32);
+			ret = MACALRDYON;
+			goto END;
+		} else if (val32 == MAC_AX_MAC_LPS) {
+			PLTFM_MSG_ERR("MAC leave LPS fail %d\n", val32);
+			ret = MACPWRSTAT;
+			goto END;
+		}
+	}
+
+	if (!pwr_func) {
+		ret = pwr_seq_start(adapter, pwr_seq);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]pwr seq start %d\n", ret);
+			adapter->sm.pwr = MAC_AX_PWR_ERR;
+			goto END;
+		}
+	} else {
+		ret = pwr_func(adapter);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]pwr func %d\n", ret);
+			adapter->sm.pwr = MAC_AX_PWR_ERR;
+			goto END;
+		}
+	}
+
+	ret = p_ops->intf_pwr_switch(adapter, PWR_POST_SWITCH, on);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("interface post pwr switch fails %d\n", ret);
+		adapter->sm.pwr = MAC_AX_PWR_ERR;
+		goto END;
+	}
+
+	mac_ax_init_state(adapter);
+
+	if (on) {
+		adapter->sm.pwr = MAC_AX_PWR_ON;
+		adapter->sm.plat = MAC_AX_PLAT_ON;
+		adapter->sm.io_st = MAC_AX_IO_ST_NORM;
+		adapter->sm.fw_rst = MAC_AX_FW_RESET_IDLE;
+		adapter->sm.l2_st = MAC_AX_L2_DIS;
+		adapter->mac_pwr_info.pwr_in_lps = 0;
+		/* patch form BT BG/LDO issue */
+		MAC_REG_W8(R_AX_SCOREBOARD + 3, MAC_AX_NOTIFY_TP_MAJOR);
+	} else {
+		adapter->sm.pwr = MAC_AX_PWR_OFF;
+		adapter->sm.l2_st = MAC_AX_L2_DIS;
+		/* patch form BT BG/LDO issue */
+		MAC_REG_W8(R_AX_SCOREBOARD + 3, MAC_AX_NOTIFY_PWR_MAJOR);
+	}
+END:
+	if (on)
+		clr_aon_int(adapter);
+	ret_end = p_ops->intf_pwr_switch(adapter, PWR_END_SWITCH, on);
+	if (ret_end != MACSUCCESS) {
+		PLTFM_MSG_ERR("interface end pwr switch fails %d\n", ret_end);
+		adapter->sm.pwr = MAC_AX_PWR_ERR;
+		return ret_end;
+	}
+	return ret;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr.h
new file mode 100644
index 000000000000..79a312222ce2
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr.h
@@ -0,0 +1,120 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_PWR_H_
+#define _MAC_AX_PWR_H_
+
+#include "../type.h"
+#include "init.h"
+
+/**
+ * Power switch command description
+ * @PWR_CMD_WRITE:
+ * @PWR_CMD_POLL:
+ * @PWR_CMD_DELAY:
+ * @PWR_CMD_END:
+ */
+#define	PWR_CMD_WRITE		0
+#define	PWR_CMD_POLL		1
+#define	PWR_CMD_DELAY		2
+#define	PWR_CMD_END		3
+
+#define	PWR_CAV_MSK		BIT(0)
+#define	PWR_CBV_MSK		BIT(1)
+#define	PWR_CCV_MSK		BIT(2)
+#define	PWR_CDV_MSK		BIT(3)
+#define	PWR_CEV_MSK		BIT(4)
+#define	PWR_CFV_MSK		BIT(5)
+#define	PWR_CGV_MSK		BIT(6)
+#define	PWR_CTV_MSK		BIT(7)
+#define	PWR_CVALL_MSK		0xFF
+
+#define	PWR_INTF_MSK_SDIO	BIT(0)
+#define	PWR_INTF_MSK_USB2	BIT(1)
+#define	PWR_INTF_MSK_USB3	BIT(2)
+#define	PWR_INTF_MSK_USB	(PWR_INTF_MSK_USB3 | PWR_INTF_MSK_USB2)
+#define	PWR_INTF_MSK_PCIE	BIT(3)
+#define	PWR_INTF_MSK_ALL	0xF
+
+#define PWR_BASE_MAC		0
+#define PWR_BASE_USB		1
+#define PWR_BASE_PCIE		2
+
+#define	PWR_DELAY_US		0
+#define	PWR_DELAY_MS		1
+
+#define PWR_POLL_CNT		2000
+#define PWR_POLL_DLY_US		1000
+
+#define LPS_LEAVE_GPIO		10
+#define LPS_POLL_CNT		10000
+#define LPS_POLL_DLY_US		50
+
+#define PWR_POST_SWITCH		0
+#define PWR_PRE_SWITCH		1
+#define PWR_END_SWITCH		2
+
+/**
+ * @struct mac_pwr_cfg
+ * @brief mac_pwr_cfg
+ *
+ * @var mac_pwr_cfg::addr
+ * Please Place Description here.
+ * @var mac_pwr_cfg::cut_msk
+ * Please Place Description here.
+ * @var mac_pwr_cfg::intf_msk
+ * Please Place Description here.
+ * @var mac_pwr_cfg::base
+ * Please Place Description here.
+ * @var mac_pwr_cfg::cmd
+ * Please Place Description here.
+ * @var mac_pwr_cfg::msk
+ * Please Place Description here.
+ * @var mac_pwr_cfg::val
+ * Please Place Description here.
+ */
+struct mac_pwr_cfg {
+	u16 addr;
+	u8 cut_msk;
+	u8 intf_msk;
+	u8 base:4;
+	u8 cmd:4;
+	u8 msk;
+	u8 val;
+};
+
+/**
+ * @brief pwr_seq_start
+ *
+ * @param *adapter
+ * @param **seq
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 pwr_seq_start(struct mac_ax_adapter *adapter, struct mac_pwr_cfg **seq);
+
+/**
+ * @brief mac_pwr_switch
+ *
+ * @param *adapter
+ * @param on
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_pwr_switch(struct mac_ax_adapter *adapter, u8 on);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr_seq_func.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr_seq_func.c
new file mode 100644
index 000000000000..745f853ca08e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr_seq_func.c
@@ -0,0 +1,108 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "pwr_seq_func.h"
+#define MAC_AX_PWR_POLL_CNT 3000
+#define MAC_AX_PWR_POLL_CNT_PXP 3000
+#define MAC_AX_PWR_POLL_MS 1
+
+u32 pwr_poll_u32(struct mac_ax_adapter *adapter, u32 offset,
+		 u32 mask, u32 pwr_val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 cnt = 0, val = 0;
+
+#if MAC_AX_FEATURE_HV
+	if (adapter->env == HV_AX_PXP)
+		cnt = MAC_AX_PWR_POLL_CNT_PXP;
+	else
+		cnt = MAC_AX_PWR_POLL_CNT;
+#else
+	cnt = MAC_AX_PWR_POLL_CNT;
+#endif
+
+	while (--cnt) {
+		val = MAC_REG_R32(offset);
+		if ((val & mask) == pwr_val)
+			return MACSUCCESS;
+		PLTFM_DELAY_MS(MAC_AX_PWR_POLL_MS);
+	}
+
+	PLTFM_MSG_ERR("[ERR] Power sequence polling timeout\n");
+	PLTFM_MSG_ERR("[ERR] offset: %08X\n", offset);
+	PLTFM_MSG_ERR("[ERR] read val: %08X, targe val: %08X\n", (val & mask), pwr_val);
+
+	return MACPOLLTO;
+}
+
+u32 pwr_poll_u16(struct mac_ax_adapter *adapter, u32 offset,
+		 u16 mask, u16 pwr_val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 cnt = 0;
+	u16 val = 0;
+
+#if MAC_AX_FEATURE_HV
+	if (adapter->env == HV_AX_PXP)
+		cnt = MAC_AX_PWR_POLL_CNT_PXP;
+	else
+		cnt = MAC_AX_PWR_POLL_CNT;
+#else
+	cnt = MAC_AX_PWR_POLL_CNT;
+#endif
+
+	while (--cnt) {
+		val = MAC_REG_R16(offset);
+		if ((val & mask) == pwr_val)
+			return MACSUCCESS;
+		PLTFM_DELAY_MS(MAC_AX_PWR_POLL_MS);
+	}
+
+	PLTFM_MSG_ERR("[ERR] Power sequence polling timeout\n");
+	PLTFM_MSG_ERR("[ERR] offset: %08X\n", offset);
+	PLTFM_MSG_ERR("[ERR] read val: %04X, targe val: %04X\n", (val & mask), pwr_val);
+
+	return MACPOLLTO;
+}
+
+u32 pwr_poll_u8(struct mac_ax_adapter *adapter, u32 offset,
+		u8 mask, u8 pwr_val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 cnt = 0;
+	u8 val = 0;
+
+#if MAC_AX_FEATURE_HV
+	if (adapter->env == HV_AX_PXP)
+		cnt = MAC_AX_PWR_POLL_CNT_PXP;
+	else
+		cnt = MAC_AX_PWR_POLL_CNT;
+#else
+	cnt = MAC_AX_PWR_POLL_CNT;
+#endif
+
+	while (--cnt) {
+		val = MAC_REG_R8(offset);
+		if ((val & mask) == pwr_val)
+			return MACSUCCESS;
+		PLTFM_DELAY_MS(MAC_AX_PWR_POLL_MS);
+	}
+
+	PLTFM_MSG_ERR("[ERR] Power sequence polling timeout\n");
+	PLTFM_MSG_ERR("[ERR] offset: %08X\n", offset);
+	PLTFM_MSG_ERR("[ERR] read val: %02X, targe val: %02X\n", (val & mask), pwr_val);
+
+	return MACPOLLTO;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr_seq_func.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr_seq_func.h
new file mode 100644
index 000000000000..982cb90356da
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/pwr_seq_func.h
@@ -0,0 +1,28 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_PWR_SEQ_FUNC_H_
+#define _MAC_AX_PWR_SEQ_FUNC_H_
+
+#include "../mac_def.h"
+
+u32 pwr_poll_u32(struct mac_ax_adapter *adapter, u32 offset,
+		 u32 mask, u32 pwr_val);
+u32 pwr_poll_u16(struct mac_ax_adapter *adapter, u32 offset,
+		 u16 mask, u16 pwr_val);
+u32 pwr_poll_u8(struct mac_ax_adapter *adapter, u32 offset,
+		u8 mask, u8 pwr_val);
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/role.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/role.c
new file mode 100644
index 000000000000..acf9b14db9cf
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/role.c
@@ -0,0 +1,1397 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "role.h"
+#include "mac_priv.h"
+
+static u32 _add_role(struct mac_ax_adapter *adapter,
+		     struct mac_ax_role_info *info);
+
+static u32 _change_role(struct mac_ax_adapter *adapter,
+			struct mac_ax_role_info *info);
+
+static u32 _remove_role(struct mac_ax_adapter *adapter, u8 macid);
+
+static u32 _remove_role_soft(struct mac_ax_adapter *adapter, u8 macid);
+
+static u32 _remove_role_by_band(struct mac_ax_adapter *adapter, u8 band, u8 sw);
+
+static struct mac_role_tbl *_role_srch(struct mac_ax_adapter *adapter, u8 macid);
+
+static u32 _role_sync(struct mac_ax_adapter *adapter,
+		      struct mac_ax_role_info *info);
+
+static inline void __role_queue_head_init(struct mac_ax_adapter *adapter,
+					  struct mac_role_tbl_head *list)
+{
+	list->prev = (struct mac_role_tbl *)list;
+	list->next = (struct mac_role_tbl *)list;
+	list->qlen = 0;
+}
+
+static inline void __role_insert(struct mac_ax_adapter *adapter,
+				 struct mac_role_tbl *new_role,
+				 struct mac_role_tbl *prev,
+				 struct mac_role_tbl *next,
+				 struct mac_role_tbl_head *list)
+{
+	new_role->next = next;
+	new_role->prev = prev;
+	next->prev  = new_role;
+	prev->next = new_role;
+	list->qlen++;
+}
+
+static inline void __role_queue_before(struct mac_ax_adapter *adapter,
+				       struct mac_role_tbl_head *list,
+				       struct mac_role_tbl *next,
+				       struct mac_role_tbl *new_role)
+{
+	__role_insert(adapter, new_role, next->prev, next, list);
+}
+
+static inline void __role_unlink(struct mac_ax_adapter *adapter,
+				 struct mac_role_tbl *role,
+				 struct mac_role_tbl_head *list)
+{
+	struct mac_role_tbl *next, *prev;
+
+	list->qlen--;
+	next = role->next;
+	prev = role->prev;
+	role->prev = NULL;
+	role->next = NULL;
+	next->prev = prev;
+	prev->next = next;
+}
+
+static inline struct mac_role_tbl *__role_peek(struct mac_role_tbl_head *list)
+{
+	struct mac_role_tbl *role = list->next;
+
+	if (role == (struct mac_role_tbl *)list)
+		role = NULL;
+
+	return role;
+}
+
+static struct mac_role_tbl *role_alloc(struct mac_ax_adapter *adapter)
+{
+	struct mac_role_tbl *role;
+
+	role = (struct mac_role_tbl *)PLTFM_MALLOC(sizeof(struct mac_role_tbl));
+	if (!role)
+		return NULL;
+
+	PLTFM_MEMSET(role, 0, sizeof(struct mac_role_tbl));
+
+	return role;
+}
+
+static inline u32 role_queue_len(struct mac_role_tbl_head *list)
+{
+	return list->qlen;
+}
+
+static inline void role_queue_head_init(struct mac_ax_adapter *adapter,
+					struct mac_role_tbl_head *list)
+{
+	PLTFM_MUTEX_INIT(&list->lock);
+	__role_queue_head_init(adapter, list);
+}
+
+static inline void role_enqueue(struct mac_ax_adapter *adapter,
+				struct mac_role_tbl_head *list,
+				struct mac_role_tbl *new_role)
+{
+	__role_queue_before(adapter,
+			    list, (struct mac_role_tbl *)list, new_role);
+}
+
+static inline struct mac_role_tbl *role_dequeue(struct mac_ax_adapter *adapter,
+						struct mac_role_tbl_head *list)
+{
+	struct mac_role_tbl *role = NULL;
+
+	role = __role_peek(list);
+	if (role)
+		__role_unlink(adapter, role, list);
+
+	return role;
+}
+
+static struct mac_role_tbl *role_get(struct mac_ax_adapter *adapter)
+{
+	struct mac_role_tbl *role;
+	struct mac_role_tbl_head *role_pool;
+
+	if (adapter->role_tbl)
+		role_pool = adapter->role_tbl->role_tbl_pool;
+	else
+		return NULL;
+
+	if (!role_pool->qlen)
+		role = NULL;
+	else
+		role = role_dequeue(adapter, role_pool);
+
+	return role;
+}
+
+static void role_return(struct mac_ax_adapter *adapter,
+			struct mac_role_tbl *role)
+{
+	struct mac_role_tbl_head *role_head = adapter->role_tbl;
+	struct mac_role_tbl_head *role_pool = NULL;
+
+	if (role_head)
+		role_pool = adapter->role_tbl->role_tbl_pool;
+	else
+		return;
+
+	__role_unlink(adapter, role, role_head);
+	role_enqueue(adapter, role_pool, role);
+}
+
+static u32 role_free(struct mac_ax_adapter *adapter)
+{
+	struct mac_role_tbl *role;
+	struct mac_role_tbl_head *role_head;
+	struct mac_role_tbl_head *role_pool = NULL;
+	u32 ret = MACSUCCESS;
+
+	role_head = adapter->role_tbl;
+	if (role_head) {
+		role_pool = role_head->role_tbl_pool;
+		while (role_queue_len(role_head) > 0) {
+			role = role_dequeue(adapter, role_head);
+			if (role) {
+				PLTFM_FREE(role, sizeof(struct mac_role_tbl));
+			} else {
+				ret = MACMEMRO;
+				break;
+			}
+		}
+	}
+	if (role_pool) {
+		while (role_queue_len(role_pool) > 0) {
+			role = role_dequeue(adapter, role_pool);
+			if (role) {
+				PLTFM_FREE(role, sizeof(struct mac_role_tbl));
+			} else {
+				ret = MACMEMRO;
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+
+u32 role_info_valid(struct mac_ax_adapter *adapter,
+		    struct mac_ax_role_info *info,
+		    enum mac_ax_role_opmode op)
+{
+	// Check info is NULL or not
+	if (!info) {
+		PLTFM_MSG_ERR("role info is null\n");
+		return MACNPTR;
+	}
+
+	if (op == ADD) {
+		// check add role opmode
+		if (info->opmode != MAC_AX_ROLE_DISCONN) {
+			PLTFM_MSG_ERR("add_role, opmode should equals to:\n");
+			PLTFM_MSG_ERR("MAC_AX_ROLE_DISCONN\n");
+			return MACFUNCINPUT;
+		}
+		// check add role updmode
+		if (info->upd_mode != MAC_AX_ROLE_CREATE) {
+			PLTFM_MSG_ERR("add_role, updmode should equals to:\n");
+			PLTFM_MSG_ERR("MAC_AX_ROLE_CREATE\n");
+			return MACFUNCINPUT;
+		}
+		// Check macid exist or not
+		if (_role_srch(adapter, info->macid)) {
+			PLTFM_MSG_ERR("existing macid: %d\n", info->macid);
+			return MACSAMACID;
+		}
+	} else if (op == CHG) {
+		if (info->upd_mode == MAC_AX_ROLE_CREATE) {
+			PLTFM_MSG_ERR("change_role, updmode should not:\n");
+			PLTFM_MSG_ERR("equals to MAC_AX_ROLE_CREATE\n");
+			return MACFUNCINPUT;
+		}
+		if (!_role_srch(adapter, info->macid)) {
+			PLTFM_MSG_ERR("macid not exist: %d\n", info->macid);
+			return MACNOITEM;
+		}
+	}
+
+	// If net_type is IFRA, self_role should only be CLIENT
+	if (info->net_type == MAC_AX_NET_TYPE_INFRA &&
+	    (info->self_role == MAC_AX_SELF_ROLE_AP ||
+	     info->self_role == MAC_AX_SELF_ROLE_AP_CLIENT)) {
+		PLTFM_MSG_ERR("net_type is INFRA, self_role can only be:\n");
+		PLTFM_MSG_ERR("CLIENT\n");
+			return MACFUNCINPUT;
+	}
+
+	// If net_type is AP, self_role should be AP or AP_CLIENT
+	if (info->net_type == MAC_AX_NET_TYPE_AP &&
+	    info->self_role == MAC_AX_SELF_ROLE_CLIENT) {
+		PLTFM_MSG_ERR("net_type is AP, self_role should be AP:\n");
+		PLTFM_MSG_ERR("or AP_CLIENT\n");
+			return MACFUNCINPUT;
+	}
+
+	// If self_role is AP, the SMA and TMA should equals to BSSID
+	if (info->self_role == MAC_AX_SELF_ROLE_AP &&
+	    info->net_type == MAC_AX_NET_TYPE_AP) {
+		if (PLTFM_MEMCMP(info->self_mac, info->bssid, 6) ||
+		    PLTFM_MEMCMP(info->target_mac, info->bssid, 6)) {
+			PLTFM_MSG_ERR("self_role is AP, the SMA and TMA:\n");
+			PLTFM_MSG_ERR("should equal to BSSID\n");
+			return MACFUNCINPUT;
+		}
+	}
+
+	// If is_mulitcast_entry = 1, group bit should equals to 1
+	if (!(info->is_mul_ent ^
+	       ((info->net_type != MAC_AX_NET_TYPE_AP &&
+		 ((info->self_mac[0] & BIT0) == 0)) ||
+		(info->net_type == MAC_AX_NET_TYPE_AP &&
+		 ((info->bssid[0] & BIT0) == 0))))) {
+		PLTFM_MSG_ERR("is_mul_ent = 1, group bit should = 1\n");
+		return MACFUNCINPUT;
+	}
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		if (info->wmm >= 2) {
+			PLTFM_MSG_ERR("invalid wmm %d\n", info->wmm);
+			return MACFUNCINPUT;
+		}
+		if (info->band == MAC_AX_BAND_1) {
+			PLTFM_MSG_ERR("invalid band %d\n", info->band);
+			return MACFUNCINPUT;
+		}
+	}
+
+	if (info->band >= MAC_AX_BAND_NUM) {
+		PLTFM_MSG_ERR("invalid band %d\n", info->band);
+		return MACFUNCINPUT;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 role_tbl_init(struct mac_ax_adapter *adapter)
+{
+	struct mac_role_tbl *role = NULL;
+	struct mac_role_tbl_head *role_head;
+	struct mac_role_tbl_head *role_pool;
+	u16 a_idx;
+	u32 ret = 0;
+
+	adapter->role_tbl = NULL;
+	adapter->role_tbl = (struct mac_role_tbl_head *)
+		PLTFM_MALLOC(sizeof(struct mac_role_tbl_head));
+	if (!adapter->role_tbl) {
+		PLTFM_MSG_ERR("%s memory alloc failed\n", __func__);
+		return MACBUFALLOC;
+	}
+
+	adapter->role_tbl->role_tbl_pool = NULL;
+	adapter->role_tbl->role_tbl_pool = (struct mac_role_tbl_head *)
+		PLTFM_MALLOC(sizeof(struct mac_role_tbl_head));
+	if (!adapter->role_tbl->role_tbl_pool) {
+		PLTFM_MSG_ERR("%s memory alloc failed\n", __func__);
+		return MACBUFALLOC;
+	}
+
+	role_head = adapter->role_tbl;
+	role_pool = adapter->role_tbl->role_tbl_pool;
+
+	role_queue_head_init(adapter, role_head);
+	role_queue_head_init(adapter, role_pool);
+
+	for (a_idx = 0; a_idx < adapter->hw_info->macid_num; a_idx++) {
+		role = role_alloc(adapter);
+		if (role) {
+			PLTFM_MUTEX_LOCK(&role_pool->lock);
+			role_enqueue(adapter, role_pool, role);
+			PLTFM_MUTEX_UNLOCK(&role_pool->lock);
+		} else {
+			PLTFM_MSG_ERR("%s memory alloc failed\n", __func__);
+			ret = MACBUFALLOC;
+			break;
+		}
+	}
+
+	if (a_idx < adapter->hw_info->macid_num)
+		role_tbl_exit(adapter);
+	else
+		ret = MACSUCCESS;
+
+	return ret;
+}
+
+u32 role_tbl_exit(struct mac_ax_adapter *adapter)
+{
+	struct mac_role_tbl_head *role_head = NULL;
+	struct mac_role_tbl_head *role_pool = NULL;
+	u32 ret = MACSUCCESS;
+
+	role_head = adapter->role_tbl;
+
+	if (!role_head) {
+		PLTFM_MSG_ERR("%s role head list is null\n", __func__);
+		return MACMEMRO;
+	}
+
+	role_pool = adapter->role_tbl->role_tbl_pool;
+
+	if (!role_pool) {
+		PLTFM_MSG_ERR("%s role pool list is null\n", __func__);
+		return MACMEMRO;
+	}
+
+	PLTFM_MUTEX_LOCK(&role_head->lock);
+	PLTFM_MUTEX_LOCK(&role_pool->lock);
+	ret = role_free(adapter);
+	PLTFM_MUTEX_UNLOCK(&role_pool->lock);
+	PLTFM_MUTEX_UNLOCK(&role_head->lock);
+
+	PLTFM_MUTEX_DEINIT(&role_head->lock);
+	PLTFM_MUTEX_DEINIT(&role_pool->lock);
+
+	if (ret != MACSUCCESS)
+		PLTFM_MSG_ERR("%s memory free failed\n", __func__);
+
+	if (adapter->role_tbl) {
+		if (adapter->role_tbl->role_tbl_pool) {
+			PLTFM_FREE(adapter->role_tbl->role_tbl_pool,
+				   sizeof(struct mac_role_tbl_head));
+			adapter->role_tbl->role_tbl_pool = NULL;
+		}
+		PLTFM_FREE(adapter->role_tbl,
+			   sizeof(struct mac_role_tbl_head));
+		adapter->role_tbl = NULL;
+	}
+	return ret;
+}
+
+u32 role_info_init(struct mac_ax_adapter *adapter,
+		   struct mac_ax_role_info *info)
+{
+	u8 i;
+
+	// address cam info
+	info->a_info.len = get_addr_cam_size(adapter);
+	info->a_info.offset = 0;
+	info->a_info.mask_sel = info->mask_sel;
+	info->a_info.addr_mask = info->addr_mask;
+	info->a_info.hit_rule = info->hit_rule;
+	info->a_info.bcn_hit_cond = info->bcn_hit_cond;
+	info->a_info.is_mul_ent = info->is_mul_ent;
+	info->a_info.port_int = info->port;
+	info->a_info.tsf_sync = info->tsf_sync;
+	info->a_info.lsig_txop = info->lsig_txop;
+	info->a_info.tgt_ind = info->tgt_ind;
+	info->a_info.frm_tgt_ind = info->frm_tgt_ind;
+	info->a_info.wol_pattern = info->wol_pattern;
+	info->a_info.wol_uc = info->wol_uc;
+	info->a_info.wol_magic = info->wol_magic;
+	info->a_info.bb_sel = info->band;
+	info->a_info.tf_trs = info->trigger;
+	info->a_info.aid12 = info->aid & 0xfff;
+	info->a_info.macid = info->macid;
+	info->a_info.wapi = info->wapi;
+	info->a_info.sec_ent_mode = info->sec_ent_mode;
+	info->a_info.net_type = info->net_type;
+
+	// bssid cam info
+	info->b_info.len = BSSID_CAM_ENT_SIZE;
+	info->b_info.offset = 0;
+	info->b_info.valid = 1;
+	info->b_info.bss_color = info->bss_color;
+	info->b_info.bb_sel = info->band;
+
+	for (i = 0; i < 6; i++) {
+		info->a_info.sma[i] = info->self_mac[i];
+		info->a_info.tma[i] = info->target_mac[i];
+		info->b_info.bssid[i] = info->bssid[i];
+	}
+
+	return MACSUCCESS;
+}
+
+u32 sec_info_init(struct mac_ax_adapter *adapter,
+		  struct mac_ax_role_info *info)
+{
+	u8 i;
+
+	info->a_info.sec_ent_valid = 0;
+	for (i = 0; i < 7; i++) {
+		info->a_info.sec_ent_keyid[i] = 0;
+		info->a_info.sec_ent[i] = 0;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 sec_info_deinit(struct mac_ax_adapter *adapter,
+		    struct mac_ax_role_info *info,
+		    struct mac_role_tbl *role)
+{
+	u32 i, ret;
+	struct sec_cam_table_t *sec_cam_table = adapter->hw_info->sec_cam_table;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	if (!sec_cam_table)
+		return MACSUCCESS;
+
+	ret = p_ops->disconnect_flush_key(adapter, role);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	/* deinit info */
+	info->a_info.sec_ent_mode = 0;
+	info->a_info.sec_ent_valid = 0;
+	for (i = 0; i < 7; i++) {
+		info->a_info.sec_ent_keyid[i] = 0;
+		info->a_info.sec_ent[i] = 0;
+	}
+
+	/* deinit role */
+	role->info.a_info.sec_ent_mode = 0;
+	role->info.a_info.sec_ent_valid = 0;
+	for (i = 0; i < 7; i++) {
+		role->info.a_info.sec_ent_keyid[i] = 0;
+		role->info.a_info.sec_ent[i] = 0;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 role_init(struct mac_ax_adapter *adapter,
+	      struct mac_role_tbl *role,
+	      struct mac_ax_role_info *info)
+{
+	struct mac_ax_macid_pause_cfg pause;
+	u32 ret;
+
+	role_info_init(adapter, info);
+
+	pause.macid = info->macid;
+	pause.pause = 0;
+	ret = set_macid_pause(adapter, &pause);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	/* The definition of wmm is different between MAC & drivers
+	 * MAC HW use wmm 0~3 to indicate
+	 * phy0-wmm0, phy0-wmm1, phy1-wmm0, phy1-wmm1 correspondingly.
+	 * Drivers use wmm 0/1 & band 0/1
+	 * Notice that wmm mapping may be changed in DBCC feature,
+	 * so we use dbcc_role to indicate DBCC feature
+	 */
+	role->macid = info->macid;
+	role->wmm = (info->band ? MAC_AX_ACTUAL_WMM_BAND : 0) |
+		    (info->wmm ? MAC_AX_ACTUAL_WMM_DRV_WMM : 0);
+
+	if (info->dbcc_role) {
+		ret = dbcc_wmm_add_macid(adapter, info);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("dbcc_wmm_add_macid %d\n", ret);
+			return ret;
+		}
+	}
+
+	role->info = *info;
+
+	return MACSUCCESS;
+}
+
+u32 set_role_bss_clr(struct mac_ax_adapter *adapter,
+		     struct mac_ax_role_info *info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 bss_clr = 0;
+
+	switch (info->port) {
+	case MAC_AX_PORT_0:
+		bss_clr = MAC_REG_R32((info->band == MAC_AX_BAND_0) ?
+				       R_AX_PTCL_BSS_COLOR_0 :
+				       R_AX_PTCL_BSS_COLOR_0_C1);
+		bss_clr = SET_CLR_WORD(bss_clr, info->bss_color,
+				       B_AX_BSS_COLOB_AX_PORT_0);
+		MAC_REG_W32((info->band == MAC_AX_BAND_0) ?
+			     R_AX_PTCL_BSS_COLOR_0 :
+			     R_AX_PTCL_BSS_COLOR_0_C1, bss_clr);
+		break;
+	case MAC_AX_PORT_1:
+		bss_clr = MAC_REG_R32((info->band == MAC_AX_BAND_0) ?
+				       R_AX_PTCL_BSS_COLOR_0 :
+				       R_AX_PTCL_BSS_COLOR_0_C1);
+		bss_clr = SET_CLR_WORD(bss_clr, info->bss_color,
+				       B_AX_BSS_COLOB_AX_PORT_1);
+		MAC_REG_W32((info->band == MAC_AX_BAND_0) ?
+			     R_AX_PTCL_BSS_COLOR_0 :
+			     R_AX_PTCL_BSS_COLOR_0_C1, bss_clr);
+		break;
+	case MAC_AX_PORT_2:
+		bss_clr = MAC_REG_R32((info->band == MAC_AX_BAND_0) ?
+				       R_AX_PTCL_BSS_COLOR_0 :
+				       R_AX_PTCL_BSS_COLOR_0_C1);
+		bss_clr = SET_CLR_WORD(bss_clr, info->bss_color,
+				       B_AX_BSS_COLOB_AX_PORT_2);
+		MAC_REG_W32((info->band == MAC_AX_BAND_0) ?
+			     R_AX_PTCL_BSS_COLOR_0 :
+			     R_AX_PTCL_BSS_COLOR_0_C1, bss_clr);
+		break;
+	case MAC_AX_PORT_3:
+		bss_clr = MAC_REG_R32((info->band == MAC_AX_BAND_0) ?
+				       R_AX_PTCL_BSS_COLOR_0 :
+				       R_AX_PTCL_BSS_COLOR_0_C1);
+		bss_clr = SET_CLR_WORD(bss_clr, info->bss_color,
+				       B_AX_BSS_COLOB_AX_PORT_3);
+		MAC_REG_W32((info->band == MAC_AX_BAND_0) ?
+			     R_AX_PTCL_BSS_COLOR_0 :
+			     R_AX_PTCL_BSS_COLOR_0_C1, bss_clr);
+		break;
+	case MAC_AX_PORT_4:
+		bss_clr = MAC_REG_R32((info->band == MAC_AX_BAND_0) ?
+				       R_AX_PTCL_BSS_COLOR_1 :
+				       R_AX_PTCL_BSS_COLOR_1_C1);
+		bss_clr = SET_CLR_WORD(bss_clr, info->bss_color,
+				       B_AX_BSS_COLOB_AX_PORT_4);
+		MAC_REG_W32((info->band == MAC_AX_BAND_0) ?
+			     R_AX_PTCL_BSS_COLOR_1 :
+			     R_AX_PTCL_BSS_COLOR_1_C1, bss_clr);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static u32 _add_role(struct mac_ax_adapter *adapter,
+		     struct mac_ax_role_info *info)
+{
+	struct mac_role_tbl *role = NULL;
+	struct mac_role_tbl_head *list_head = adapter->role_tbl;
+	u32 ret = MACSUCCESS;
+	u32 cmac_en;
+	bool fw_role = true;
+
+	cmac_en = check_mac_en(adapter, info->band, MAC_AX_CMAC_SEL);
+	if (cmac_en != MACSUCCESS)
+		PLTFM_MSG_WARN("%s CMAC%d not enable\n", __func__, info->band);
+
+	role = role_get(adapter);
+	if (!role) {
+		PLTFM_MSG_ERR("role get failed\n");
+		return MACBUFALLOC;
+	}
+
+	ret = role_info_valid(adapter, info, ADD);
+	if (ret != MACSUCCESS)
+		goto role_add_fail;
+
+	info->a_info.valid = 1;
+	if (role_queue_len(list_head) > adapter->hw_info->macid_num) {
+		PLTFM_MSG_ERR("role list full\n");
+		ret = MACMACIDFL;
+		goto role_add_fail;
+	}
+
+	if (sec_info_init(adapter, info)) {
+		PLTFM_MSG_ERR("sec info change failed\n");
+		return MACROLEINITFL;
+	}
+
+	if (role_init(adapter, role, info)) {
+		PLTFM_MSG_ERR("role init failed\n");
+		ret = MACROLEINITFL;
+		goto role_add_fail;
+	}
+
+	// Do not call mac_fw_role_maintain if is_mulitcast_entry = 1 or virtual role
+	// mac_fw_role_maintain will trigger FW to create FW Role.
+	if (info->wifi_role == MAC_AX_WIFI_ROLE_VIRTUAL || info->is_mul_ent)
+		fw_role = false;
+
+	if (fw_role) {
+		ret = mac_fw_role_maintain(adapter, info);
+		if (ret != MACSUCCESS) {
+			if (ret == MACFWNONRDY) {
+				PLTFM_MSG_WARN("skip fw role maintain\n");
+			} else {
+				PLTFM_MSG_ERR("mac_fw_role_maintain failed:%d\n", ret);
+				goto role_add_fail;
+			}
+		}
+	}
+
+	if (info->self_role == MAC_AX_SELF_ROLE_AP) {
+		ret = mac_h2c_join_info(adapter, info);
+		if (ret != MACSUCCESS) {
+			if (ret == MACFWNONRDY) {
+				PLTFM_MSG_WARN("skip join info\n");
+			} else {
+				PLTFM_MSG_ERR("mac_h2c_join_info: %d\n", ret);
+				return ret;
+			}
+		}
+	}
+
+	ret = mac_upd_addr_cam(adapter, &role->info, ADD);
+
+	if (ret == MACADDRCAMFL) {
+		PLTFM_MSG_ERR("ADDRESS CAM full\n");
+		ret = MACADDRCAMFL;
+		goto role_add_fail;
+	} else if (ret == MACBSSIDCAMFL) {
+		PLTFM_MSG_ERR("BSSID CAM full\n");
+		ret = MACBSSIDCAMFL;
+		goto role_add_fail;
+	}
+
+	role_enqueue(adapter, list_head, role);
+
+	if (cmac_en)
+		set_role_bss_clr(adapter, info);
+
+	return MACSUCCESS;
+
+role_add_fail:
+	role_enqueue(adapter, list_head->role_tbl_pool, role);
+	if (role->info.dbcc_role) {
+		ret = dbcc_wmm_rm_macid(adapter, &role->info);
+		if (ret != MACSUCCESS)
+			PLTFM_MSG_ERR("add role fail dbcc wmm rm macid %d\n", ret);
+	}
+	return ret;
+}
+
+static u32 _change_role(struct mac_ax_adapter *adapter,
+			struct mac_ax_role_info *info)
+{
+	struct mac_role_tbl *role;
+	u32 ret, cmac_en;
+	bool fw_role = true;
+
+	cmac_en = check_mac_en(adapter, info->band, MAC_AX_CMAC_SEL);
+	if (cmac_en != MACSUCCESS)
+		PLTFM_MSG_WARN("%s CMAC%d not enable\n", __func__, info->band);
+
+	ret = role_info_valid(adapter, info, CHG);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	role = _role_srch(adapter, info->macid);
+	if (!role) {
+		PLTFM_MSG_ERR("role search failed\n");
+		return MACNOITEM;
+	}
+
+	if (info->upd_mode == MAC_AX_ROLE_BAND_SW) {
+		if (!role->info.dbcc_role) {
+			PLTFM_MSG_ERR("role band sw runs only for dbcc role\n");
+			return MACFUNCINPUT;
+		}
+
+		ret = mac_dbcc_move_wmm(adapter, info);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("mac_dbcc_move_wmm %d/%d/%d\n",
+				      info->band, info->macid, ret);
+			return ret;
+		}
+	}
+	info->a_info = role->info.a_info;
+	info->b_info = role->info.b_info;
+	info->s_info = role->info.s_info;
+	info->c_info = role->info.c_info;
+
+	info->dbcc_role = role->info.dbcc_role;
+
+	if (role_info_init(adapter, info)) {
+		PLTFM_MSG_ERR("role change failed\n");
+		return MACROLEINITFL;
+	}
+
+	role->macid = info->macid;
+	role->wmm = (info->band ? MAC_AX_ACTUAL_WMM_BAND : 0) |
+		    (info->wmm ? MAC_AX_ACTUAL_WMM_DRV_WMM : 0);
+	role->info = *info;
+
+	// Do not call mac_fw_role_maintain if is_mulitcast_entry = 1 or virtual role
+	// mac_fw_role_maintain will trigger FW to create FW Role.
+	if (info->wifi_role == MAC_AX_WIFI_ROLE_VIRTUAL || info->is_mul_ent)
+		fw_role = false;
+
+	if (info->upd_mode == MAC_AX_ROLE_TYPE_CHANGE ||
+	    info->upd_mode == MAC_AX_ROLE_REMOVE ||
+	    info->upd_mode == MAC_AX_ROLE_FW_RESTORE) {
+		if (fw_role && info->upd_mode != MAC_AX_ROLE_TYPE_CHANGE) {
+			ret = mac_fw_role_maintain(adapter, info);
+			if (ret != MACSUCCESS) {
+				if (ret == MACFWNONRDY) {
+					PLTFM_MSG_WARN("skip fw role maintain\n");
+				} else {
+					PLTFM_MSG_ERR("mac_fw_role_maintain :%d\n",
+						      ret);
+					return ret;
+				}
+			}
+		}
+		if ((info->upd_mode == MAC_AX_ROLE_TYPE_CHANGE ||
+		     info->upd_mode == MAC_AX_ROLE_FW_RESTORE) &&
+		     info->self_role == MAC_AX_SELF_ROLE_AP) {
+			ret = mac_h2c_join_info(adapter, info);
+			if (ret != MACSUCCESS) {
+				if (ret == MACFWNONRDY) {
+					PLTFM_MSG_WARN("skip join info\n");
+				} else {
+					PLTFM_MSG_ERR("mac_h2c_join_info: %d\n",
+						      ret);
+					return ret;
+				}
+			}
+		}
+	} else if (info->upd_mode == MAC_AX_ROLE_CON_DISCONN) {
+		if (info->opmode == MAC_AX_ROLE_DISCONN) {
+			ret = sec_info_deinit(adapter, info, role);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("sec info change failed\n");
+				return ret;
+			}
+		}
+		ret = mac_h2c_join_info(adapter, info);
+		if (ret != MACSUCCESS) {
+			if (ret == MACFWNONRDY) {
+				PLTFM_MSG_WARN("skip join info\n");
+			} else {
+				PLTFM_MSG_ERR("mac_h2c_join_info: %d\n", ret);
+				return ret;
+			}
+		}
+	} else if (info->upd_mode == MAC_AX_ROLE_INFO_CHANGE ||
+		   info->upd_mode == MAC_AX_ROLE_BAND_SW) {
+		if (info->self_role == MAC_AX_SELF_ROLE_CLIENT) {
+		} else {
+			ret = mac_h2c_join_info(adapter, info);
+			if (ret != MACSUCCESS) {
+				if (ret == MACFWNONRDY) {
+					PLTFM_MSG_WARN("skip join info\n");
+				} else {
+					PLTFM_MSG_ERR("mac_h2c_join_info: %d\n", ret);
+					return ret;
+				}
+			}
+		}
+	} else {
+		PLTFM_MSG_ERR("role info upd_mode invalid\n");
+		return ret;
+	}
+
+	ret = mac_upd_addr_cam(adapter, &role->info, CHG);
+	if (ret == MACBSSIDCAMFL) {
+		PLTFM_MSG_ERR("BSSID CAM full\n");
+		return MACBSSIDCAMFL;
+	}
+
+	if (cmac_en)
+		set_role_bss_clr(adapter, info);
+
+	return ret;
+}
+
+static u32 _remove_role(struct mac_ax_adapter *adapter, u8 macid)
+{
+	struct mac_role_tbl *role;
+	u32 ret;
+
+	role = _role_srch(adapter, macid);
+	if (!role) {
+		PLTFM_MSG_ERR("no role for macid %d\n", macid);
+		return MACNOROLE;
+	}
+
+	role->info.a_info.valid = 0;
+	role->info.upd_mode = MAC_AX_ROLE_REMOVE;
+	role->info.opmode = MAC_AX_ROLE_DISCONN;
+
+	if (!mac_role_srch_by_bssid(adapter, role->info.a_info.bssid_cam_idx))
+		role->info.b_info.valid = 0;
+
+	ret = _change_role(adapter, &role->info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: %d\n", __func__, ret);
+		return ret;
+	}
+
+	if (role->info.dbcc_role) {
+		role->info.dbcc_role = 0;
+		ret = dbcc_wmm_rm_macid(adapter, &role->info);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("dbcc_wmm_rm_macid %d\n", ret);
+			return ret;
+		}
+	}
+
+	role_return(adapter, role);
+
+	return MACSUCCESS;
+}
+
+static u32 _remove_role_soft(struct mac_ax_adapter *adapter, u8 macid)
+{
+	/* This function should be called only before poweroff,
+	 * because it will unlink the role without update any info to FW
+	 */
+	struct mac_role_tbl *role;
+
+	role = _role_srch(adapter, macid);
+	if (!role) {
+		PLTFM_MSG_ERR("no role for macid %d\n", macid);
+		return MACNOROLE;
+	}
+
+	role_return(adapter, role);
+
+	return MACSUCCESS;
+}
+
+static u32 _remove_role_by_band(struct mac_ax_adapter *adapter, u8 band, u8 sw)
+{
+	struct mac_role_tbl *role, *curr_role;
+	struct mac_role_tbl_head *list_head = adapter->role_tbl;
+	u32 ret = MACSUCCESS;
+	u32 (*_rm_role)(struct mac_ax_adapter *adapter, u8 macid);
+
+	if (sw)
+		_rm_role = _remove_role_soft;
+	else
+		_rm_role = _remove_role;
+
+	role = list_head->next;
+	while (role->next != list_head->next) {
+		curr_role = role;
+		role = role->next;
+		if (band == curr_role->info.band) {
+			ret = _rm_role(adapter, curr_role->macid);
+			if (ret && ret != MACNOROLE)
+				return ret;
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+static struct mac_role_tbl *_role_srch(struct mac_ax_adapter *adapter,
+				       u8 macid)
+{
+	struct mac_role_tbl *role;
+	struct mac_role_tbl_head *list_head = adapter->role_tbl;
+
+	if (!list_head)
+		return NULL;
+
+	role = list_head->next;
+	for (; role->next != list_head->next; role = role->next) {
+		if (macid == role->macid)
+			return role;
+	}
+
+	return NULL;
+}
+
+static u32 _role_sync(struct mac_ax_adapter *adapter,
+		      struct mac_ax_role_info *info)
+{
+	struct mac_role_tbl *role;
+	u32 ret = MACSUCCESS;
+	bool fw_role = true;
+
+	role = _role_srch(adapter, info->macid);
+	if (!role) {
+		PLTFM_MSG_ERR("role search failed\n");
+		return MACNOITEM;
+	}
+
+	// Do not call mac_fw_role_maintain if is_mulitcast_entry = 1 or virtual role
+	// mac_fw_role_maintain will trigger FW to create FW Role.
+	if (info->wifi_role == MAC_AX_WIFI_ROLE_VIRTUAL || info->is_mul_ent)
+		fw_role = false;
+
+	if (fw_role) {
+		ret = mac_fw_role_maintain(adapter, info);
+		if (ret) {
+			if (ret == MACFWNONRDY)
+				PLTFM_MSG_WARN("skip fw role sync since fw not ready\n");
+			else
+				PLTFM_MSG_ERR("mac_fw_role_maintain failed:%d\n", ret);
+			return ret;
+		}
+	}
+	if (info->self_role == MAC_AX_SELF_ROLE_AP) {
+		ret = mac_h2c_join_info(adapter, info);
+		if (ret) {
+			if (ret == MACFWNONRDY)
+				PLTFM_MSG_WARN("skip join info\n");
+			else
+				PLTFM_MSG_ERR("mac_h2c_join_info: %d\n", ret);
+		}
+	}
+	return ret;
+}
+
+u32 mac_add_role(struct mac_ax_adapter *adapter, struct mac_ax_role_info *info)
+{
+	u32 ret;
+	struct mac_role_tbl_head *list_head = adapter->role_tbl;
+
+	PLTFM_MUTEX_LOCK(&list_head->lock);
+	ret = _add_role(adapter, info);
+	PLTFM_MUTEX_UNLOCK(&list_head->lock);
+
+	return ret;
+}
+
+u32 mac_change_role(struct mac_ax_adapter *adapter,
+		    struct mac_ax_role_info *info)
+{
+	u32 ret;
+	struct mac_role_tbl_head *list_head = adapter->role_tbl;
+
+	PLTFM_MUTEX_LOCK(&list_head->lock);
+	ret = _change_role(adapter, info);
+	PLTFM_MUTEX_UNLOCK(&list_head->lock);
+
+	return ret;
+}
+
+u32 mac_remove_role(struct mac_ax_adapter *adapter, u8 macid)
+{
+	u32 ret;
+	struct mac_role_tbl_head *list_head = adapter->role_tbl;
+
+	PLTFM_MUTEX_LOCK(&list_head->lock);
+	ret = _remove_role(adapter, macid);
+	PLTFM_MUTEX_UNLOCK(&list_head->lock);
+
+	return ret;
+}
+
+u32 mac_remove_role_by_band(struct mac_ax_adapter *adapter, u8 band, u8 sw)
+{
+	u32 ret;
+	struct mac_role_tbl_head *list_head = adapter->role_tbl;
+
+	PLTFM_MUTEX_LOCK(&list_head->lock);
+	ret = _remove_role_by_band(adapter, band, sw);
+	PLTFM_MUTEX_UNLOCK(&list_head->lock);
+
+	return ret;
+}
+
+struct mac_role_tbl *mac_role_srch(struct mac_ax_adapter *adapter, u8 macid)
+{
+	struct mac_role_tbl *ret;
+	struct mac_role_tbl_head *list_head = adapter->role_tbl;
+
+	PLTFM_MUTEX_LOCK(&list_head->lock);
+	ret = _role_srch(adapter, macid);
+	PLTFM_MUTEX_UNLOCK(&list_head->lock);
+
+	return ret;
+}
+
+u32 mac_role_sync(struct mac_ax_adapter *adapter, struct mac_ax_role_info *info)
+{
+	u32 ret;
+	struct mac_role_tbl_head *list_head = adapter->role_tbl;
+
+	PLTFM_MUTEX_LOCK(&list_head->lock);
+	ret = _role_sync(adapter, info);
+	PLTFM_MUTEX_UNLOCK(&list_head->lock);
+
+	return ret;
+}
+
+struct mac_role_tbl *role_srch_no_lock(struct mac_ax_adapter *adapter, u8 macid)
+{
+	return _role_srch(adapter, macid);
+}
+
+struct mac_role_tbl *mac_role_srch_by_addr_cam(struct mac_ax_adapter *adapter,
+					       u16 addr_cam_idx)
+{
+	struct mac_role_tbl *role;
+	struct mac_role_tbl_head *list_head = adapter->role_tbl;
+
+	if (!list_head)
+		return NULL;
+
+	role = list_head->next;
+	for (; role->next != list_head->next; role = role->next) {
+		if (addr_cam_idx == role->info.a_info.addr_cam_idx &&
+		    role->info.a_info.valid)
+			return role;
+	}
+
+	return NULL;
+}
+
+struct mac_role_tbl *mac_role_srch_by_bssid(struct mac_ax_adapter *adapter,
+					    u8 bssid_cam_idx)
+{
+	struct mac_role_tbl *role;
+	struct mac_role_tbl_head *list_head = adapter->role_tbl;
+
+	if (!list_head)
+		return NULL;
+
+	role = list_head->next;
+	for (; role->next != list_head->next; role = role->next) {
+		if (bssid_cam_idx == role->info.b_info.bssid_cam_idx &&
+		    role->info.a_info.valid)
+			return role;
+	}
+
+	return NULL;
+}
+
+u32 mac_get_macaddr(struct mac_ax_adapter *adapter,
+		    struct mac_ax_macaddr *macaddr,
+		    u8 role_idx)
+{
+	struct mac_role_tbl *role;
+	struct mac_role_tbl_head *list_head = adapter->role_tbl;
+	struct mac_ax_macaddr *macaddr_list;
+	u8 i;
+	u8 m_list_idx;
+	u32 ret;
+
+	if (role_idx >= adapter->hw_info->macid_num) {
+		PLTFM_MSG_ERR("role_idx: %d\n", role_idx);
+		return MACFUNCINPUT;
+	}
+	if (!macaddr) {
+		PLTFM_MSG_ERR("mac_ax_macaddr is NULL\n");
+		return MACFUNCINPUT;
+	}
+
+	macaddr_list = (struct mac_ax_macaddr *)
+			PLTFM_MALLOC(sizeof(struct mac_ax_macaddr) *
+			adapter->hw_info->macid_num);
+	role = list_head->next;
+	for (m_list_idx = 0; role->next != list_head->next; role = role->next) {
+		if (!role->info.a_info.valid)
+			continue;
+		for (i = 0; i < m_list_idx; i++) {
+			if (!PLTFM_MEMCMP(macaddr_list + i,
+					  role->info.a_info.sma,
+					  sizeof(struct mac_ax_macaddr))) {
+				break;
+			}
+		}
+		if (i < m_list_idx)
+			continue;
+		PLTFM_MEMCPY(macaddr_list + m_list_idx,
+			     role->info.a_info.sma,
+			     sizeof(struct mac_ax_macaddr));
+		if (m_list_idx == role_idx) {
+			PLTFM_MEMCPY(macaddr,
+				     role->info.a_info.sma,
+				     sizeof(struct mac_ax_macaddr));
+			ret = MACSUCCESS;
+			goto fin;
+		}
+		m_list_idx++;
+	}
+	ret = MACNOITEM;
+fin:
+	PLTFM_FREE(macaddr_list, sizeof(struct mac_ax_macaddr) *
+				 adapter->hw_info->macid_num);
+	return ret;
+}
+
+u32 mac_set_slot_time(struct mac_ax_adapter *adapter, enum mac_ax_slot_time st)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = MACSUCCESS;
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		switch (st) {
+		case MAC_AX_SLOT_TIME_BAND0_9US:
+			ret = MAC_REG_W_OFLD(R_AX_SLOTTIME_CFG,
+					     B_AX_SLOT_TIME_MSK <<
+					     B_AX_SLOT_TIME_SH, 9, 1);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s: write offload fail;"
+					      "offset: %u, ret: %u\n",
+					      __func__, R_AX_SLOTTIME_CFG, ret);
+				return ret;
+			}
+			break;
+		case MAC_AX_SLOT_TIME_BAND0_20US:
+			ret = MAC_REG_W_OFLD(R_AX_SLOTTIME_CFG,
+					     B_AX_SLOT_TIME_MSK <<
+					     B_AX_SLOT_TIME_SH, 20, 1);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s: write offload fail;"
+					      "offset: %u, ret: %u\n",
+					      __func__, R_AX_SLOTTIME_CFG, ret);
+				return ret;
+			}
+			break;
+		case MAC_AX_SLOT_TIME_BAND1_9US:
+			ret = MAC_REG_W_OFLD(R_AX_SLOTTIME_CFG_C1,
+					     B_AX_SLOT_TIME_MSK <<
+					     B_AX_SLOT_TIME_SH, 9, 1);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s: write offload fail;"
+					      "offset: %u, ret: %u\n", __func__,
+					      R_AX_SLOTTIME_CFG_C1, ret);
+				return ret;
+			}
+			break;
+		case MAC_AX_SLOT_TIME_BAND1_20US:
+			ret = MAC_REG_W_OFLD(R_AX_SLOTTIME_CFG_C1,
+					     B_AX_SLOT_TIME_MSK <<
+					     B_AX_SLOT_TIME_SH, 20, 1);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("%s: write offload fail;"
+					      "offset: %u, ret: %u\n", __func__,
+					      R_AX_SLOTTIME_CFG_C1, ret);
+				return ret;
+			}
+			break;
+		}
+
+		return ret;
+	}
+#endif
+	switch (st) {
+	case MAC_AX_SLOT_TIME_BAND0_9US:
+		MAC_REG_W8(R_AX_SLOTTIME_CFG, 9);
+		break;
+	case MAC_AX_SLOT_TIME_BAND0_20US:
+		MAC_REG_W8(R_AX_SLOTTIME_CFG, 20);
+		break;
+	case MAC_AX_SLOT_TIME_BAND1_9US:
+		MAC_REG_W8(R_AX_SLOTTIME_CFG_C1, 9);
+		break;
+	case MAC_AX_SLOT_TIME_BAND1_20US:
+		MAC_REG_W8(R_AX_SLOTTIME_CFG_C1, 20);
+		break;
+	default:
+		ret = MACFUNCINPUT;
+		break;
+	}
+
+	return ret;
+}
+
+static u32 mac_h2c_join_info(struct mac_ax_adapter *adapter,
+			     struct mac_ax_role_info *info)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_joininfo *fwcmd_tbl;
+	struct mac_ax_sta_init_info sta;
+	u32 ret;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	// sta info
+	sta.macid = info->macid;
+	sta.opmode = info->opmode;
+	sta.band = info->band;
+	sta.wmm = (info->band ? MAC_AX_ACTUAL_WMM_BAND : 0) |
+			(info->wmm ? MAC_AX_ACTUAL_WMM_DRV_WMM : 0);
+	sta.trigger = info->trigger;
+	sta.is_hesta = info->is_hesta;
+	sta.dl_bw = info->dl_bw;
+	sta.tf_mac_padding = info->tf_mac_padding;
+	sta.dl_t_pe = info->dl_t_pe;
+	sta.port_id = info->port;
+	sta.net_type = info->net_type;
+	sta.wifi_role = info->wifi_role;
+	sta.self_role = info->self_role;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_joininfo));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto join_info_fail;
+	}
+
+	fwcmd_tbl = (struct fwcmd_joininfo *)buf;
+	fwcmd_tbl->dword0 =
+	cpu_to_le32(SET_WORD(sta.macid, FWCMD_H2C_JOININFO_MACID) |
+		    (sta.opmode ? FWCMD_H2C_JOININFO_OPMODE : 0) |
+		    (sta.band ? FWCMD_H2C_JOININFO_BAND : 0) |
+		    SET_WORD(sta.wmm, FWCMD_H2C_JOININFO_WMM) |
+		    (sta.trigger ? FWCMD_H2C_JOININFO_TRIGGER : 0) |
+		    (sta.is_hesta ? FWCMD_H2C_JOININFO_ISHESTA : 0) |
+		    SET_WORD(sta.dl_bw, FWCMD_H2C_JOININFO_DL_BW) |
+		    SET_WORD(sta.tf_mac_padding,
+			     FWCMD_H2C_JOININFO_TF_MAC_PADDING) |
+		    SET_WORD(sta.dl_t_pe, FWCMD_H2C_JOININFO_DL_T_PE) |
+		    SET_WORD(sta.port_id, FWCMD_H2C_JOININFO_PORT_ID) |
+		    SET_WORD(sta.net_type, FWCMD_H2C_JOININFO_NET_TYPE) |
+		    SET_WORD(sta.wifi_role, FWCMD_H2C_JOININFO_WIFI_ROLE) |
+		    SET_WORD(sta.self_role, FWCMD_H2C_JOININFO_SELF_ROLE));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MEDIA_RPT,
+			      FWCMD_H2C_FUNC_JOININFO,
+			      0,
+			      1);
+
+	if (ret != MACSUCCESS)
+		goto join_info_fail;
+
+	// Return MACSUCCESS if h2c aggregation is enabled and enqueued successfully.
+	// The H2C shall be sent by mac_h2c_agg_tx.
+	ret = h2c_agg_enqueue(adapter, h2cb);
+	if (ret == MACSUCCESS)
+		return MACSUCCESS;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto join_info_fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret != MACSUCCESS)
+		goto join_info_fail;
+
+	h2cb_free(adapter, h2cb);
+	return MACSUCCESS;
+
+join_info_fail:
+	h2cb_free(adapter, h2cb);
+	return ret;
+}
+
+static u32 mac_fw_role_maintain(struct mac_ax_adapter *adapter,
+				struct mac_ax_role_info *info)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_fwrole_maintain *fwcmd_tbl;
+	struct mac_ax_fwrole_maintain fwrole_main;
+	u32 ret;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	fwrole_main.macid = info->macid;
+	fwrole_main.self_role = info->self_role;
+	fwrole_main.upd_mode = info->upd_mode;
+	fwrole_main.wifi_role = info->wifi_role;
+	fwrole_main.band = info->band;
+	fwrole_main.port = info->port;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_fwrole_maintain));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto role_maintain_fail;
+	}
+
+	fwcmd_tbl = (struct fwcmd_fwrole_maintain *)buf;
+	fwcmd_tbl->dword0 =
+	cpu_to_le32(SET_WORD(fwrole_main.macid,
+			     FWCMD_H2C_FWROLE_MAINTAIN_MACID) |
+		    SET_WORD(fwrole_main.self_role,
+			     FWCMD_H2C_FWROLE_MAINTAIN_SELF_ROLE) |
+		    SET_WORD(fwrole_main.upd_mode,
+			     FWCMD_H2C_FWROLE_MAINTAIN_UPD_MODE) |
+		    SET_WORD(fwrole_main.wifi_role,
+			     FWCMD_H2C_FWROLE_MAINTAIN_WIFI_ROLE) |
+		    SET_WORD(fwrole_main.band,
+			     FWCMD_H2C_FWROLE_MAINTAIN_BAND) |
+		    SET_WORD(fwrole_main.port,
+			     FWCMD_H2C_FWROLE_MAINTAIN_PORT));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MEDIA_RPT,
+			      FWCMD_H2C_FUNC_FWROLE_MAINTAIN,
+			      0,
+			      1);
+
+	if (ret != MACSUCCESS)
+		goto role_maintain_fail;
+
+	// Return MACSUCCESS if h2c aggregation is enabled and enqueued successfully.
+	// The H2C shall be sent by mac_h2c_agg_tx.
+	ret = h2c_agg_enqueue(adapter, h2cb);
+	if (ret == MACSUCCESS)
+		return MACSUCCESS;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret != MACSUCCESS)
+		goto role_maintain_fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret != MACSUCCESS)
+		goto role_maintain_fail;
+
+	h2cb_free(adapter, h2cb);
+	return MACSUCCESS;
+
+role_maintain_fail:
+	h2cb_free(adapter, h2cb);
+	return ret;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/role.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/role.h
new file mode 100644
index 000000000000..d1224f83368d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/role.h
@@ -0,0 +1,381 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_ROLE_H_
+#define _MAC_AX_ROLE_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+#include "addr_cam.h"
+#include "security_cam.h"
+#include "hw.h"
+#include "trxcfg.h"
+
+/*--------------------Define -------------------------------------------*/
+#define CCTL_NTX_PATH_EN	3
+#define CCTL_PATH_MAP_B		1
+#define CCTL_PATH_MAP_C		2
+#define CCTL_PATH_MAP_D		3
+#define CCTRL_NC		1
+#define CCTRL_NR		1
+#define CCTRL_CB		1
+#define CCTRL_CSI_PARA_EN	1
+#define CCTRL_CSI_PARA_EN_MSK	1
+
+/*--------------------Define MACRO--------------------------------------*/
+#define MAC_AX_ACTUAL_WMM_BAND BIT(1)
+#define MAC_AX_ACTUAL_WMM_DRV_WMM BIT(0)
+
+/*--------------------Define Enum---------------------------------------*/
+/*--------------------Define Struct-------------------------------------*/
+/*--------------------Function Prototype--------------------------------*/
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief role_tbl_init
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 role_tbl_init(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief role_tbl_exit
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 role_tbl_exit(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief role_info_valid
+ *
+ * @param *adapter
+ * @param *info
+ * @param change_role
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 role_info_valid(struct mac_ax_adapter *adapter,
+		    struct mac_ax_role_info *info,
+		    enum mac_ax_role_opmode op);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief mac_add_role
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_add_role(struct mac_ax_adapter *adapter, struct mac_ax_role_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief mac_remove_role
+ *
+ * @param *adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_remove_role(struct mac_ax_adapter *adapter, u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief mac_remove_role_by_band
+ *
+ * @param *adapter
+ * @param band
+ * @param sw
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_remove_role_by_band(struct mac_ax_adapter *adapter, u8 band, u8 sw);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief mac_change_role
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_change_role(struct mac_ax_adapter *adapter,
+		    struct mac_ax_role_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief mac_role_srch
+ *
+ * @param *adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval  mac_role_tbl
+ */
+struct mac_role_tbl *mac_role_srch(struct mac_ax_adapter *adapter,
+				   u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief role_srch_no_lock
+ *
+ * @param *adapter
+ * @param macid
+ * @return Please Place Description here.
+ * @retval  mac_role_tbl
+ */
+struct mac_role_tbl *role_srch_no_lock(struct mac_ax_adapter *adapter,
+				       u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief mac_role_srch_by_addr_cam
+ *
+ * @param *adapter
+ * @param addr_cam_idx
+ * @return Please Place Description here.
+ * @retval  mac_role_tbl
+ */
+struct mac_role_tbl *mac_role_srch_by_addr_cam(struct mac_ax_adapter *adapter,
+					       u16 addr_cam_idx);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief mac_role_srch_by_bssid
+ *
+ * @param *adapter
+ * @param bssid_cam_idx
+ * @return Please Place Description here.
+ * @retval  mac_role_tbl
+ */
+struct mac_role_tbl *mac_role_srch_by_bssid(struct mac_ax_adapter *adapter,
+					    u8 bssid_cam_idx);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief mac_get_macaddr
+ *
+ * @param *adapter
+ * @param *macaddr
+ * @param role_idx
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_get_macaddr(struct mac_ax_adapter *adapter,
+		    struct mac_ax_macaddr *macaddr,
+		    u8 role_idx);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief mac_set_slot_time
+ *
+ * @param *adapter
+ * @param mac_ax_slot_time
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_slot_time(struct mac_ax_adapter *adapter, enum mac_ax_slot_time);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief mac_h2c_join_info
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval  u32
+ */
+
+static u32 mac_h2c_join_info(struct mac_ax_adapter *adapter,
+			     struct mac_ax_role_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+
+/**
+ * @brief mac_fw_role_maintain
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval  u32
+ */
+static u32 mac_fw_role_maintain(struct mac_ax_adapter *adapter,
+				struct mac_ax_role_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup Role_Related
+ * @{
+ */
+/**
+ * @brief mac_role_sync
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_role_sync(struct mac_ax_adapter *adapter, struct mac_ax_role_info *info);
+/**
+ * @}
+ * @}
+ */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_filter.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_filter.c
new file mode 100644
index 000000000000..824b5f1159dc
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_filter.c
@@ -0,0 +1,431 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "rx_filter.h"
+
+/* control frames: drop, mgnt frames: to host, data frame: to host */
+static enum mac_ax_fwd_target trxcfg_rx_fltr_mgnt_frame = MAC_AX_FWD_TO_HOST;
+static enum mac_ax_fwd_target trxcfg_rx_fltr_ctrl_frame = MAC_AX_FWD_TO_HOST;
+static enum mac_ax_fwd_target trxcfg_rx_fltr_data_frame = MAC_AX_FWD_TO_HOST;
+
+static struct mac_ax_rx_fltr_ctrl_t rx_fltr_init_opt = {
+	1, /* sniffer_mode */
+	1, /* acpt_a1_match_pkt */
+	1, /* acpt_bc_pkt */
+	1, /* acpt_mc_pkt */
+	1, /* uc_pkt_chk_cam_match */
+	1, /* bc_pkt_chk_cam_match */
+	0, /* mc_pkt_white_lst_mode */
+	0, /* bcn_chk_en */
+	0, /* bcn_chk_rule */
+	0, /* acpt_pwr_mngt_pkt */
+	0, /* acpt_crc32_err_pkt */
+	0, /* acpt_unsupport_pkt */
+	0, /* acpt_mac_hdr_content_err_pkt */
+	0, /* acpt_ftm_req_pkt */
+	0, /* rsvd */
+	0, /* pkt_len_fltr */
+	0, /* unsp_pkt_target */
+	8, /* uid_fltr */
+	0, /* rsvd */
+	1, /* cck_crc_chk_enable */
+	1, /* cck_sig_chk_enable */
+	1, /* lsig_parity_chk_enable */
+	1, /* siga_crc_chk_enable */
+	1, /* vht_su_sigb_crc_chk_enable */
+	1, /* vht_mu_sigb_crc_chk_enable */
+	1, /* he_sigb_crc_chk_enable */
+	0, /* min_len_chk_disable */
+};
+
+u32 rx_fltr_init(struct mac_ax_adapter *adapter, enum mac_ax_band band)
+{
+	u32 ret;
+	struct mac_ax_ops *mac_ax_ops = adapter_to_mac_ops(adapter);
+	struct mac_ax_rx_fltr_ctrl_t opt_msk = {
+		0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x3, 0x1, 0x1, 0x1,
+		0x1, 0x1, 0x1, 0x3F, 0x3, 0xf, 0xf, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
+		0x1, 0x1
+	};
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	ret = mac_ax_ops->set_rx_fltr_typ_opt(adapter,
+					      MAC_AX_PKT_MGNT,
+					      trxcfg_rx_fltr_mgnt_frame,
+					      band);
+	if (ret != MACSUCCESS)
+		return ret;
+	ret = mac_ax_ops->set_rx_fltr_typ_opt(adapter,
+					      MAC_AX_PKT_CTRL,
+					      trxcfg_rx_fltr_ctrl_frame,
+					      band);
+	if (ret != MACSUCCESS)
+		return ret;
+	ret = mac_ax_ops->set_rx_fltr_typ_opt(adapter,
+					      MAC_AX_PKT_DATA,
+					      trxcfg_rx_fltr_data_frame,
+					      band);
+	if (ret != MACSUCCESS)
+		return ret;
+	ret = mac_ax_ops->set_rx_fltr_opt(adapter,
+					  &rx_fltr_init_opt,
+					  &opt_msk,
+					  band);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+static void rx_fltr_opt_2_uint(struct mac_ax_adapter *adapter,
+			       struct mac_ax_rx_fltr_ctrl_t *fltr_opt,
+			       u32 *mac_fltr_value,
+			       u16 *plcp_fltr_value)
+{
+	u32 val32 = 0x0;
+	u8 val16 = 0x0;
+
+	val32 =
+		((fltr_opt->sniffer_mode) ?
+				B_AX_SNIFFER_MODE : 0) |
+		((fltr_opt->acpt_a1_match_pkt) ?
+				B_AX_A_A1_MATCH : 0) |
+		((fltr_opt->acpt_bc_pkt) ?
+				B_AX_A_BC : 0) |
+		((fltr_opt->acpt_mc_pkt) ?
+				B_AX_A_MC : 0) |
+		((fltr_opt->uc_pkt_chk_cam_match) ?
+				B_AX_A_UC_CAM_MATCH : 0) |
+		((fltr_opt->bc_pkt_chk_cam_match) ?
+				B_AX_A_BC_CAM_MATCH : 0) |
+		((fltr_opt->mc_pkt_white_lst_mode) ?
+				B_AX_A_MC_LIST_CAM_MATCH : 0) |
+		((fltr_opt->bcn_chk_en) ?
+				B_AX_A_BCN_CHK_EN : 0) |
+		((fltr_opt->acpt_pwr_mngt_pkt) ?
+				B_AX_A_PWR_MGNT : 0) |
+		((fltr_opt->acpt_crc32_err_pkt) ?
+				B_AX_A_CRC32_ERR : 0) |
+		((fltr_opt->acpt_mac_hdr_content_err_pkt) ?
+				B_AX_A_ERR_PKT : 0) |
+		((fltr_opt->acpt_unsupport_pkt) ?
+				B_AX_A_UNSUP_PKT : 0) |
+		((fltr_opt->acpt_ftm_req_pkt) ?
+				B_AX_A_FTM_REQ : 0) |
+		SET_WORD(fltr_opt->bcn_chk_rule,
+			 RX_FLTR_BCN_CHK_RULE) |
+		SET_WORD(fltr_opt->pkt_len_fltr,
+			 RX_FLTR_PKT_LEN_FLTR) |
+		SET_WORD(fltr_opt->unsp_pkt_target,
+			 RX_FLTR_UNSUPPORT_PKT_FLTR) |
+		SET_WORD(fltr_opt->uid_fltr,
+			 RX_FLTR_UID_FLTR);
+
+	*mac_fltr_value = val32;
+
+	val16 =
+		((fltr_opt->cck_crc_chk_enable) ?
+				B_AX_CCK_CRC_CHK : 0) |
+		((fltr_opt->cck_sig_chk_enable) ?
+				B_AX_CCK_SIG_CHK : 0) |
+		((fltr_opt->lsig_parity_chk_enable) ?
+				B_AX_LSIG_PARITY_CHK_EN : 0) |
+		((fltr_opt->siga_crc_chk_enable) ?
+				B_AX_SIGA_CRC_CHK : 0) |
+		((fltr_opt->vht_su_sigb_crc_chk_enable) ?
+				B_AX_VHT_SU_SIGB_CRC_CHK : 0) |
+		((fltr_opt->vht_mu_sigb_crc_chk_enable) ?
+				B_AX_VHT_MU_SIGB_CRC_CHK : 0) |
+		((fltr_opt->he_sigb_crc_chk_enable) ?
+				B_AX_HE_SIGB_CRC_CHK : 0) |
+		((fltr_opt->min_len_chk_disable) ?
+				B_AX_DIS_CHK_MIN_LEN : 0);
+
+	*plcp_fltr_value = val16;
+}
+
+u32 mac_get_rx_fltr_opt(struct mac_ax_adapter *adapter,
+			struct mac_ax_rx_fltr_ctrl_t *fltr_opt,
+			enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (val32 != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return val32;
+	}
+
+	if (!fltr_opt) {
+		PLTFM_MSG_ERR("[ERR]%s opt is null\n", __func__);
+		return MACNPTR;
+	}
+
+	val32 = MAC_REG_R32((band == MAC_AX_BAND_1) ?
+			    R_AX_RX_FLTR_OPT_C1 : R_AX_RX_FLTR_OPT);
+	fltr_opt->sniffer_mode = ((val32 & B_AX_SNIFFER_MODE) != 0);
+	fltr_opt->acpt_a1_match_pkt = ((val32 & B_AX_A_A1_MATCH) != 0);
+	fltr_opt->acpt_bc_pkt = ((val32 & B_AX_A_BC) != 0);
+	fltr_opt->acpt_mc_pkt = ((val32 & B_AX_A_MC) != 0);
+	fltr_opt->uc_pkt_chk_cam_match = ((val32 & B_AX_A_UC_CAM_MATCH) != 0);
+	fltr_opt->bc_pkt_chk_cam_match = ((val32 & B_AX_A_BC_CAM_MATCH) != 0);
+	fltr_opt->mc_pkt_white_lst_mode = ((val32 &
+					   B_AX_A_MC_LIST_CAM_MATCH) != 0);
+	fltr_opt->bcn_chk_en = ((val32 & B_AX_A_BCN_CHK_EN) != 0);
+	fltr_opt->acpt_pwr_mngt_pkt = ((val32 & B_AX_A_PWR_MGNT) != 0);
+	fltr_opt->acpt_crc32_err_pkt = ((val32 & B_AX_A_CRC32_ERR) != 0);
+	fltr_opt->acpt_mac_hdr_content_err_pkt = ((val32 &
+						  B_AX_A_ERR_PKT) != 0);
+	fltr_opt->acpt_unsupport_pkt = ((val32 & B_AX_A_UNSUP_PKT) != 0);
+	fltr_opt->acpt_ftm_req_pkt = ((val32 & B_AX_A_FTM_REQ) != 0);
+	fltr_opt->bcn_chk_rule = GET_FIELD(val32, RX_FLTR_BCN_CHK_RULE);
+	fltr_opt->pkt_len_fltr = GET_FIELD(val32, RX_FLTR_PKT_LEN_FLTR);
+	fltr_opt->unsp_pkt_target = GET_FIELD(val32,
+					      RX_FLTR_UNSUPPORT_PKT_FLTR);
+	fltr_opt->uid_fltr = GET_FIELD(val32, RX_FLTR_UID_FLTR);
+
+	val32 = MAC_REG_R32((band == MAC_AX_BAND_1) ?
+			    R_AX_PLCP_HDR_FLTR_C1 : R_AX_PLCP_HDR_FLTR);
+	fltr_opt->cck_crc_chk_enable = ((val32 & B_AX_CCK_CRC_CHK) != 0);
+	fltr_opt->cck_sig_chk_enable = ((val32 & B_AX_CCK_SIG_CHK) != 0);
+	fltr_opt->lsig_parity_chk_enable = ((val32 &
+					 B_AX_LSIG_PARITY_CHK_EN) != 0);
+	fltr_opt->siga_crc_chk_enable = ((val32 & B_AX_SIGA_CRC_CHK) != 0);
+	fltr_opt->vht_su_sigb_crc_chk_enable = ((val32 &
+						 B_AX_VHT_SU_SIGB_CRC_CHK)
+						 != 0);
+	fltr_opt->vht_mu_sigb_crc_chk_enable = ((val32 &
+						 B_AX_VHT_MU_SIGB_CRC_CHK)
+						 != 0);
+	fltr_opt->he_sigb_crc_chk_enable = ((val32 & B_AX_HE_SIGB_CRC_CHK)
+					    != 0);
+	fltr_opt->min_len_chk_disable = ((val32 & B_AX_DIS_CHK_MIN_LEN)
+					 != 0);
+	return MACSUCCESS;
+}
+
+u32 mac_set_rx_fltr_opt(struct mac_ax_adapter *adapter,
+			struct mac_ax_rx_fltr_ctrl_t *fltr_opt,
+			struct mac_ax_rx_fltr_ctrl_t *fltr_opt_msk,
+			enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_rx_fltr_ctrl_t opt = {0};
+	u32 mac_opt;
+	u16 plcp_opt;
+	u32 mac_opt_msk;
+	u16 plcp_opt_msk;
+	u32 mac_opt_value;
+	u16 plcp_opt_value;
+	u32 ret = MACSUCCESS;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return ret;
+	}
+
+	if (!fltr_opt || !fltr_opt_msk) {
+		PLTFM_MSG_ERR("[ERR]%s opt is null\n", __func__);
+		return MACNPTR;
+	}
+
+	mac_get_rx_fltr_opt(adapter, &opt, band);
+
+	rx_fltr_opt_2_uint(adapter,
+			   fltr_opt,
+			   &mac_opt,
+			   &plcp_opt);
+
+	rx_fltr_opt_2_uint(adapter,
+			   fltr_opt_msk,
+			   &mac_opt_msk,
+			   &plcp_opt_msk);
+
+	rx_fltr_opt_2_uint(adapter,
+			   &opt,
+			   &mac_opt_value,
+			   &plcp_opt_value);
+
+	mac_opt_value = (mac_opt & mac_opt_msk) |
+			(~(~mac_opt & mac_opt_msk) & mac_opt_value);
+
+	plcp_opt_value = (plcp_opt & plcp_opt_msk) |
+			(~(~plcp_opt & plcp_opt_msk) & plcp_opt_value);
+
+	// add fw offload later
+	if (band == MAC_AX_BAND_0) {
+		MAC_REG_W32(R_AX_RX_FLTR_OPT, mac_opt_value);
+		MAC_REG_W16(R_AX_PLCP_HDR_FLTR, plcp_opt_value);
+	} else {
+		MAC_REG_W32(R_AX_RX_FLTR_OPT_C1, mac_opt_value);
+		MAC_REG_W16(R_AX_PLCP_HDR_FLTR_C1, plcp_opt_value);
+	}
+
+	return ret;
+}
+
+u32 mac_set_typ_fltr_opt(struct mac_ax_adapter *adapter,
+			 enum mac_ax_pkt_t type,
+			 enum mac_ax_fwd_target fwd_target,
+			 enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (val32 != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return val32;
+	}
+
+	switch (fwd_target) {
+	case MAC_AX_FWD_DONT_CARE:
+		val32 = RX_FLTR_FRAME_DROP;
+		break;
+	case MAC_AX_FWD_TO_HOST:
+		val32 = RX_FLTR_FRAME_TO_HOST;
+		break;
+	case MAC_AX_FWD_TO_WLAN_CPU:
+		val32 = RX_FLTR_FRAME_TO_WLCPU;
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR]%s fwd target err\n", __func__);
+		return MACNOITEM;
+	}
+
+	switch (type) {
+	case MAC_AX_PKT_MGNT:
+		MAC_REG_W32((band == MAC_AX_BAND_1) ?
+			    R_AX_MGNT_FLTR_C1 : R_AX_MGNT_FLTR, val32);
+		break;
+	case MAC_AX_PKT_CTRL:
+		MAC_REG_W32((band == MAC_AX_BAND_1) ?
+			    R_AX_CTRL_FLTR_C1 : R_AX_CTRL_FLTR, val32);
+		break;
+	case MAC_AX_PKT_DATA:
+		MAC_REG_W32((band == MAC_AX_BAND_1) ?
+			    R_AX_DATA_FLTR_C1 : R_AX_DATA_FLTR, val32);
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR]%s type err\n", __func__);
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_set_typsbtyp_fltr_opt(struct mac_ax_adapter *adapter,
+			      enum mac_ax_pkt_t type,
+			      u8 subtype,
+			      enum mac_ax_fwd_target fwd_target,
+			      enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (val32 != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return val32;
+	}
+
+	if (fwd_target != MAC_AX_FWD_DONT_CARE &&
+	    fwd_target != MAC_AX_FWD_TO_HOST &&
+	    fwd_target != MAC_AX_FWD_TO_WLAN_CPU) {
+		PLTFM_MSG_ERR("[ERR]%s fwd target err\n", __func__);
+		return MACNOITEM;
+	}
+
+	switch (type) {
+	case MAC_AX_PKT_MGNT:
+		val32 = MAC_REG_R32((band == MAC_AX_BAND_1) ?
+				    R_AX_MGNT_FLTR_C1 : R_AX_MGNT_FLTR);
+		val32 = SET_CLR_WOR2(val32, fwd_target,
+				     ((subtype & 0xf) * 2), 0x3);
+		MAC_REG_W32((band == MAC_AX_BAND_1) ?
+			    R_AX_MGNT_FLTR_C1 : R_AX_MGNT_FLTR, val32);
+		break;
+	case MAC_AX_PKT_CTRL:
+		val32 = MAC_REG_R32((band == MAC_AX_BAND_1) ?
+				    R_AX_CTRL_FLTR_C1 : R_AX_CTRL_FLTR);
+		val32 = SET_CLR_WOR2(val32, fwd_target,
+				     ((subtype & 0xf) * 2), 0x3);
+		MAC_REG_W32((band == MAC_AX_BAND_1) ?
+			    R_AX_CTRL_FLTR_C1 : R_AX_CTRL_FLTR, val32);
+		break;
+	case MAC_AX_PKT_DATA:
+		val32 = MAC_REG_R32((band == MAC_AX_BAND_1) ?
+				    R_AX_DATA_FLTR_C1 : R_AX_DATA_FLTR);
+		val32 = SET_CLR_WOR2(val32, fwd_target,
+				     ((subtype & 0xf) * 2), 0x3);
+		MAC_REG_W32((band == MAC_AX_BAND_1) ?
+			    R_AX_DATA_FLTR_C1 : R_AX_DATA_FLTR, val32);
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR]%s type err\n", __func__);
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_set_typsbtyp_fltr_detail(struct mac_ax_adapter *adapter,
+				 enum mac_ax_pkt_t type,
+				 struct mac_ax_rx_fltr_elem *elem,
+				 enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 cmp_bit = 1;
+	u16 reg;
+	u8 idx;
+
+	val32 = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (val32 != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]%s CMAC%d not enable\n", __func__, band);
+		return val32;
+	}
+
+	switch (type) {
+	case MAC_AX_PKT_CTRL:
+		reg = (band == MAC_AX_BAND_0) ? R_AX_CTRL_FLTR : R_AX_CTRL_FLTR_C1;
+		break;
+	case MAC_AX_PKT_MGNT:
+		reg = (band == MAC_AX_BAND_0) ? R_AX_MGNT_FLTR : R_AX_MGNT_FLTR_C1;
+		break;
+	case MAC_AX_PKT_DATA:
+		reg = (band == MAC_AX_BAND_0) ? R_AX_DATA_FLTR : R_AX_DATA_FLTR_C1;
+		break;
+	default:
+		PLTFM_MSG_ERR("[ERR]%s type err\n", __func__);
+		return MACNOITEM;
+	}
+
+	val32 = MAC_REG_R32(reg);
+
+	for (idx = 0; idx < RX_FLTR_SUBTYPE_NUM; idx++) {
+		if ((elem->subtype_mask & cmp_bit) != 0)
+			val32 = SET_CLR_WOR2(val32, elem->target_arr[idx],
+					     ENTRY_SH(idx), ENTRY_MSK);
+		cmp_bit = cmp_bit << ENTRY_IDX;
+	}
+	MAC_REG_W32(reg, val32);
+
+	return MACSUCCESS;
+}
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_filter.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_filter.h
new file mode 100644
index 000000000000..e70260fccf2a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_filter.h
@@ -0,0 +1,169 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_RX_FILTER_H_
+#define _MAC_AX_RX_FILTER_H_
+#include "trxcfg.h"
+#include "../type.h"
+
+#define RX_FLTR_BCN_CHK_RULE_SH		8
+#define RX_FLTR_BCN_CHK_RULE_MSK	0x3
+#define RX_FLTR_PKT_LEN_FLTR_SH		16
+#define RX_FLTR_PKT_LEN_FLTR_MSK	0x7F
+#define RX_FLTR_UNSUPPORT_PKT_FLTR_SH	22
+#define RX_FLTR_UNSUPPORT_PKT_FLTR_MSK	0x3
+#define RX_FLTR_UID_FLTR_SH		24
+#define RX_FLTR_UID_FLTR_MSK		0xFF
+
+#define RX_FLTR_FRAME_DROP	0x00000000
+#define RX_FLTR_FRAME_TO_HOST	0x55555555
+#define RX_FLTR_FRAME_TO_WLCPU	0xAAAAAAAA
+
+#define RX_FLTR_SUBTYPE_NUM	16
+#define ENTRY_MSK	0x3
+#define ENTRY_SH(_idx)	(_idx * 2)
+#define ENTRY_IDX	1
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup RX_Filter
+ * @{
+ */
+
+/**
+ * @brief mac_get_rx_fltr_opt
+ *
+ * @param *adapter
+ * @param *fltr_opt
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_rx_fltr_opt(struct mac_ax_adapter *adapter,
+			struct mac_ax_rx_fltr_ctrl_t *fltr_opt,
+			enum mac_ax_band band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup RX_Filter
+ * @{
+ */
+
+/**
+ * @brief mac_set_rx_fltr_opt
+ *
+ * @param *adapter
+ * @param *fltr_opt
+ * @param *fltr_opt_msk
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_rx_fltr_opt(struct mac_ax_adapter *adapter,
+			struct mac_ax_rx_fltr_ctrl_t *fltr_opt,
+			struct mac_ax_rx_fltr_ctrl_t *fltr_opt_msk,
+			enum mac_ax_band band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup RX_Filter
+ * @{
+ */
+
+/**
+ * @brief mac_set_typ_fltr_opt
+ *
+ * @param *adapter
+ * @param type
+ * @param fwd_target
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_typ_fltr_opt(struct mac_ax_adapter *adapter,
+			 enum mac_ax_pkt_t type,
+			 enum mac_ax_fwd_target fwd_target,
+			 enum mac_ax_band band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup RX_Filter
+ * @{
+ */
+
+/**
+ * @brief mac_set_typsbtyp_fltr_opt
+ *
+ * @param *adapter
+ * @param type
+ * @param subtype
+ * @param fwd_target
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_typsbtyp_fltr_opt(struct mac_ax_adapter *adapter,
+			      enum mac_ax_pkt_t type,
+			      u8 subtype,
+			      enum mac_ax_fwd_target fwd_target,
+			      enum mac_ax_band band);
+/**
+ * @}
+ * @}
+ */
+
+u32 rx_fltr_init(struct mac_ax_adapter *adapter,
+		 enum mac_ax_band band);
+
+/**
+ * @brief mac_set_typ_fltr_opt
+ *
+ * @param *adapter
+ * @param type
+ * @param fwd_target
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_typsbtyp_fltr_detail(struct mac_ax_adapter *adapter,
+				 enum mac_ax_pkt_t type,
+				 struct mac_ax_rx_fltr_elem *elem,
+				 enum mac_ax_band band);
+/**
+ * @}
+ * @}
+ */
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_forwarding.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_forwarding.c
new file mode 100644
index 000000000000..a67f1ded5eb6
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_forwarding.c
@@ -0,0 +1,448 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "rx_forwarding.h"
+
+#if MAC_AX_FW_REG_OFLD
+u32 mac_set_rx_forwarding(struct mac_ax_adapter *adapter,
+			  struct mac_ax_rx_fwd_ctrl_t *rf_ctrl_p)
+{
+	u32 ret = 0;
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_rx_fwd *rx_fwd;
+	struct mac_ax_af_ud_ctrl_t *af_ud;
+	struct mac_ax_pm_cam_ctrl_t *pm_cam;
+
+	if (!rf_ctrl_p)
+		return MACNPTR;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_rx_fwd));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	rx_fwd = (struct fwcmd_rx_fwd *)buf;
+	rx_fwd->dword0 =
+	cpu_to_le32(SET_WORD(rf_ctrl_p->type, FWCMD_H2C_RX_FWD_TYPE) |
+		    SET_WORD(rf_ctrl_p->frame, FWCMD_H2C_RX_FWD_FRAME) |
+		    SET_WORD(rf_ctrl_p->fwd_tg, FWCMD_H2C_RX_FWD_FWD_TG));
+
+	af_ud = &rf_ctrl_p->af_ud_ctrl;
+	rx_fwd->dword1 =
+	cpu_to_le32(SET_WORD(af_ud->index, FWCMD_H2C_RX_FWD_AF_UD_INDEX) |
+		    SET_WORD(af_ud->fwd_tg, FWCMD_H2C_RX_FWD_AF_UD_FWD_TG) |
+		    SET_WORD(af_ud->category, FWCMD_H2C_RX_FWD_AF_UD_CATEGORY) |
+		    SET_WORD(af_ud->action_field,
+			     FWCMD_H2C_RX_FWD_AF_UD_ACTION_FIELD));
+
+	pm_cam = &rf_ctrl_p->pm_cam_ctrl;
+	rx_fwd->dword2 =
+	cpu_to_le32((pm_cam->valid ? FWCMD_H2C_RX_FWD_PM_CAM_VALID : 0) |
+		    SET_WORD(pm_cam->type, FWCMD_H2C_RX_FWD_PM_CAM_TYPE) |
+		    SET_WORD(pm_cam->subtype, FWCMD_H2C_RX_FWD_PM_CAM_SUBTYPE) |
+		    (pm_cam->skip_mac_iv_hdr ?
+		     FWCMD_H2C_RX_FWD_PM_CAM_SKIP_MAC_IV_HDR : 0) |
+		    SET_WORD(pm_cam->target_ind,
+			     FWCMD_H2C_RX_FWD_PM_CAM_TARGET_IND) |
+		    SET_WORD(pm_cam->entry_index,
+			     FWCMD_H2C_RX_FWD_PM_CAM_INDEX) |
+		    SET_WORD(pm_cam->crc16, FWCMD_H2C_RX_FWD_PM_CAM_CRC16));
+
+	rx_fwd->dword3 =
+	cpu_to_le32(SET_WORD(pm_cam->pld_mask0,
+			     FWCMD_H2C_RX_FWD_PM_CAM_PLD_MASK0));
+
+	rx_fwd->dword4 =
+	cpu_to_le32(SET_WORD(pm_cam->pld_mask1,
+			     FWCMD_H2C_RX_FWD_PM_CAM_PLD_MASK1));
+
+	rx_fwd->dword5 =
+	cpu_to_le32(SET_WORD(pm_cam->pld_mask2,
+			     FWCMD_H2C_RX_FWD_PM_CAM_PLD_MASK2));
+
+	rx_fwd->dword6 =
+	cpu_to_le32(SET_WORD(pm_cam->pld_mask3,
+			     FWCMD_H2C_RX_FWD_PM_CAM_PLD_MASK3));
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = h2c_pkt_set_hdr(adapter, h2cb,
+				      FWCMD_TYPE_H2C,
+				      FWCMD_H2C_CAT_MAC,
+				      FWCMD_H2C_CL_FW_OFLD,
+				      FWCMD_H2C_FUNC_RX_FWD,
+				      0,
+				      1);
+		if (ret)
+			goto fail;
+
+		ret = h2c_pkt_build_txd(adapter, h2cb);
+		if (ret)
+			goto fail;
+
+#if MAC_AX_PHL_H2C
+		ret = PLTFM_TX(h2cb);
+#else
+		ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+		if (ret)
+			goto fail;
+	} else {
+		ret = MACFWNONRDY;
+		goto fail;
+	}
+
+	ret = MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+#else
+static inline u32 af_fwd_cfg(struct mac_ax_adapter *adapter,
+			     enum mac_ax_action_frame frame,
+			     enum mac_ax_fwd_target fwd_tg)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_ACTION_FWD0);
+	switch (frame) {
+	case MAC_AX_AF_CSA:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_CSA);
+		break;
+	case MAC_AX_AF_ADDTS_REQ:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_ADDTS_REQ);
+		break;
+	case MAC_AX_AF_ADDTS_RES:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_ADDTS_RES);
+		break;
+	case MAC_AX_AF_DELTS:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_DELTS);
+		break;
+	case MAC_AX_AF_ADDBA_REQ:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_ADDBA_REQ);
+		break;
+	case MAC_AX_AF_ADDBA_RES:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_ADDBA_RES);
+		break;
+	case MAC_AX_AF_DELBA:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_DELBA);
+		break;
+	case MAC_AX_AF_NCW:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_NCW);
+		break;
+	case MAC_AX_AF_GID_MGNT:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_GID_MGNT);
+		break;
+	case MAC_AX_AF_OP_MODE:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_OP_MODE);
+		break;
+	case MAC_AX_AF_CSI:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_CSI);
+		break;
+	case MAC_AX_AF_HT_CBFM:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_HT_CBFM);
+		break;
+	case MAC_AX_AF_VHT_CBFM:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_VHT_CBFM);
+		break;
+	default:
+		return MACNOITEM;
+	}
+	MAC_REG_W32(R_AX_ACTION_FWD0, val32);
+	return MACSUCCESS;
+}
+
+static inline u32 af_ud_fwd_cfg(struct mac_ax_adapter *adapter,
+				struct mac_ax_af_ud_ctrl_t *af_ud_ctrl_p)
+{
+	u32 val32;
+	u16 val16;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_ACTION_FWD1);
+	switch (af_ud_ctrl_p->index) {
+	case MAC_AX_AF_UD_0:
+		val16 = MAC_REG_R16(R_AX_ACTION_FWD_CTRL0);
+		val16 = SET_CLR_WORD(val16, af_ud_ctrl_p->category,
+				     B_AX_FWD_ACTN_CAT0);
+		val16 = SET_CLR_WORD(val16, af_ud_ctrl_p->action_field,
+				     B_AX_FWD_ACTN_ACTN0);
+		MAC_REG_W16(R_AX_ACTION_FWD_CTRL0, val16);
+		val32 = SET_CLR_WORD(val32, af_ud_ctrl_p->fwd_tg,
+				     B_AX_FWD_ACTN_CTRL0);
+		break;
+	case MAC_AX_AF_UD_1:
+		val16 = MAC_REG_R16(R_AX_ACTION_FWD_CTRL1);
+		val16 = SET_CLR_WORD(val16, af_ud_ctrl_p->category,
+				     B_AX_FWD_ACTN_CAT1);
+		val16 = SET_CLR_WORD(val16, af_ud_ctrl_p->action_field,
+				     B_AX_FWD_ACTN_ACTN1);
+		MAC_REG_W16(R_AX_ACTION_FWD_CTRL1, val16);
+		val32 = SET_CLR_WORD(val32, af_ud_ctrl_p->fwd_tg,
+				     B_AX_FWD_ACTN_CTRL1);
+		break;
+	case MAC_AX_AF_UD_2:
+		val16 = MAC_REG_R16(R_AX_ACTION_FWD_CTRL2);
+		val16 = SET_CLR_WORD(val16, af_ud_ctrl_p->category,
+				     B_AX_FWD_ACTN_CAT2);
+		val16 = SET_CLR_WORD(val16, af_ud_ctrl_p->action_field,
+				     B_AX_FWD_ACTN_ACTN2);
+		MAC_REG_W16(R_AX_ACTION_FWD_CTRL2, val16);
+		val32 = SET_CLR_WORD(val32, af_ud_ctrl_p->fwd_tg,
+				     B_AX_FWD_ACTN_CTRL2);
+		break;
+	case MAC_AX_AF_UD_3:
+		val16 = MAC_REG_R16(R_AX_ACTION_FWD_CTRL3);
+		val16 = SET_CLR_WORD(val16, af_ud_ctrl_p->category,
+				     B_AX_FWD_ACTN_CAT3);
+		val16 = SET_CLR_WORD(val16, af_ud_ctrl_p->action_field,
+				     B_AX_FWD_ACTN_ACTN3);
+		MAC_REG_W16(R_AX_ACTION_FWD_CTRL3, val16);
+		val32 = SET_CLR_WORD(val32, af_ud_ctrl_p->fwd_tg,
+				     B_AX_FWD_ACTN_CTRL3);
+		break;
+	default:
+		return MACNOITEM;
+	}
+	MAC_REG_W32(R_AX_ACTION_FWD1, val32);
+	return MACSUCCESS;
+}
+
+static inline u32 tf_fwd_cfg(struct mac_ax_adapter *adapter,
+			     enum mac_ax_trigger_frame frame,
+			     enum mac_ax_fwd_target fwd_tg)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_TF_FWD);
+	switch (frame) {
+	case MAC_AX_TF_BT:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_TF0);
+		break;
+	case MAC_AX_TF_BFRP:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_TF1);
+		break;
+	case MAC_AX_TF_MU_BAR:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_TF2);
+		break;
+	case MAC_AX_TF_MU_RTS:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_TF3);
+		break;
+	case MAC_AX_TF_BSRP:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_TF4);
+		break;
+	case MAC_AX_TF_GCR_MU_BAR:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_TF5);
+		break;
+	case MAC_AX_TF_BQRP:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_TF6);
+		break;
+	case MAC_AX_TF_NFRP:
+		val32 = SET_CLR_WORD(val32, fwd_tg, B_AX_FWD_TF7);
+		break;
+	default:
+		return MACNOITEM;
+	}
+	MAC_REG_W32(R_AX_TF_FWD, val32);
+	return MACSUCCESS;
+}
+
+static inline u32 pm_cam_access_polling(struct mac_ax_adapter *adapter)
+{
+	u32 cnt = PM_CAM_WAIT_CNT;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	while (cnt--) {
+		if (!(MAC_REG_R32(R_AX_PLD_CAM_ACCESS) & B_AX_PLD_CAM_POLL))
+			break;
+		PLTFM_DELAY_US(PM_CAM_WAIT_US);
+	}
+
+	if (!++cnt) {
+		PLTFM_MSG_ERR("[ERR]PM CAM access timeout\n");
+		return MACPOLLTO;
+	}
+	return MACSUCCESS;
+}
+
+static inline u32 pm_cam_indirect_r(struct mac_ax_adapter *adapter,
+				    u32 offset)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = 0;
+	val32 = SET_CLR_WORD(val32, offset, B_AX_PLD_CAM_OFFSET);
+	val32 &= ~B_AX_PLD_CAM_CLR;
+	val32 &= ~B_AX_PLD_CAM_RW;
+	val32 |= B_AX_PLD_CAM_POLL;
+	MAC_REG_W32(R_AX_PLD_CAM_ACCESS, val32);
+
+	if (pm_cam_access_polling(adapter)) {
+		PLTFM_MSG_ERR("[ERR]PM CAM read timeout\n");
+		return MACSUCCESS;
+	}
+
+	return MAC_REG_R32(R_AX_PLD_CAM_RDATA);
+}
+
+static inline void pm_cam_indirect_w(struct mac_ax_adapter *adapter,
+				     u32 offset, u32 data)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	MAC_REG_W32(R_AX_PLD_CAM_WDATA, data);
+
+	val32 = 0;
+	val32 = SET_CLR_WORD(val32, offset, B_AX_PLD_CAM_OFFSET);
+	val32 &= ~B_AX_PLD_CAM_CLR;
+	val32 |= B_AX_PLD_CAM_RW;
+	val32 |= B_AX_PLD_CAM_POLL;
+	MAC_REG_W32(R_AX_PLD_CAM_ACCESS, val32);
+
+	if (pm_cam_access_polling(adapter))
+		PLTFM_MSG_ERR("[ERR]PM CAM write timeout\n");
+}
+
+static inline u32 pm_cam_fwd_cfg(struct mac_ax_adapter *adapter,
+				 struct mac_ax_pm_cam_ctrl_t *pm_cam_ctrl_p)
+{
+	u32 val32, offset;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		PLTFM_MSG_ERR("[ERR]%s PM_CAM API is removed in 52C & 92XB & 51E & 52D.\n"
+			      , __func__);
+		return MACSUCCESS;
+	}
+
+	if (!pm_cam_ctrl_p)
+		return MACNPTR;
+
+	if (pm_cam_ctrl_p->entry_index >= MAC_AX_PM_CAM_ENTRY_NUM_MAX)
+		return MACNOITEM;
+
+	// Set as indirect access and enable PM CAM
+	val32 = MAC_REG_R32(R_AX_PLD_CAM_CTRL);
+	val32 = SET_CLR_WORD(val32, 0xf, B_AX_PLD_CAM_RANGE);
+	val32 |= B_AX_PLD_CAM_ACC;
+	val32 |= B_AX_PLD_CAM_EN;
+	MAC_REG_W32(R_AX_PLD_CAM_CTRL, val32);
+
+	// offset unit: 4 bytes
+	offset = (pm_cam_ctrl_p->entry_index *
+		 MAC_AX_PM_CAM_ENTRY_CONTENT_SIZE) / 4;
+
+	val32 = 0;
+	val32 = SET_CLR_WORD(val32, pm_cam_ctrl_p->pld_mask0, PM_CAM_PLD_MASK0);
+	pm_cam_indirect_w(adapter, offset + PM_CAM_OFFSET_DW1, val32);
+	if (val32 != pm_cam_indirect_r(adapter, offset + PM_CAM_OFFSET_DW1)) {
+		PLTFM_MSG_ERR("[ERR]PM CAM cfg fail 1\n");
+		return MACRFPMCAM;
+	}
+
+	val32 = 0;
+	val32 = SET_CLR_WORD(val32, pm_cam_ctrl_p->pld_mask1, PM_CAM_PLD_MASK1);
+	pm_cam_indirect_w(adapter, offset + PM_CAM_OFFSET_DW2, val32);
+	if (val32 != pm_cam_indirect_r(adapter, offset + PM_CAM_OFFSET_DW2)) {
+		PLTFM_MSG_ERR("[ERR]PM CAM cfg fail 2\n");
+		return MACRFPMCAM;
+	}
+
+	val32 = 0;
+	val32 = SET_CLR_WORD(val32, pm_cam_ctrl_p->pld_mask2, PM_CAM_PLD_MASK2);
+	pm_cam_indirect_w(adapter, offset + PM_CAM_OFFSET_DW3, val32);
+	if (val32 != pm_cam_indirect_r(adapter, offset + PM_CAM_OFFSET_DW3)) {
+		PLTFM_MSG_ERR("[ERR]PM CAM cfg fail 3\n");
+		return MACRFPMCAM;
+	}
+
+	val32 = 0;
+	val32 = SET_CLR_WORD(val32, pm_cam_ctrl_p->pld_mask3, PM_CAM_PLD_MASK3);
+	pm_cam_indirect_w(adapter, offset + PM_CAM_OFFSET_DW4, val32);
+	if (val32 != pm_cam_indirect_r(adapter, offset + PM_CAM_OFFSET_DW4)) {
+		PLTFM_MSG_ERR("[ERR]PM CAM cfg fail 4\n");
+		return MACRFPMCAM;
+	}
+
+	// PMCAM is not trigger-type reg!
+	val32 = 0;
+	val32 |= (pm_cam_ctrl_p->valid ? PM_CAM_VALID : 0);
+	val32 = SET_CLR_WORD(val32, pm_cam_ctrl_p->type, PM_CAM_TYPE);
+	val32 = SET_CLR_WORD(val32, pm_cam_ctrl_p->subtype, PM_CAM_SUBTYPE);
+	val32 |= (pm_cam_ctrl_p->skip_mac_iv_hdr ? PM_CAM_SKIP_MAC_IV_HDR : 0);
+	val32 = SET_CLR_WORD(val32, pm_cam_ctrl_p->target_ind,
+			     PM_CAM_TARGET_IND);
+	val32 = SET_CLR_WORD(val32, pm_cam_ctrl_p->crc16, PM_CAM_CRC16);
+	pm_cam_indirect_w(adapter, offset, val32);
+	if (val32 != pm_cam_indirect_r(adapter, offset)) {
+		PLTFM_MSG_ERR("[ERR]PM CAM cfg fail 5, %x, %x\n",
+			      val32, pm_cam_indirect_r(adapter, offset));
+		return MACRFPMCAM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_set_rx_forwarding(struct mac_ax_adapter *adapter,
+			  struct mac_ax_rx_fwd_ctrl_t *rf_ctrl_p)
+{
+	u32 ret = 0;
+
+	if (!rf_ctrl_p) {
+		PLTFM_MSG_ERR("[ERR]%s NULL pointer!\n", __func__);
+		return MACNPTR;
+	}
+
+	switch (rf_ctrl_p->type) {
+	case MAC_AX_FT_ACTION:
+		ret = af_fwd_cfg(adapter,
+				 (enum mac_ax_action_frame)rf_ctrl_p->frame,
+				 (enum mac_ax_fwd_target)rf_ctrl_p->fwd_tg);
+		break;
+	case MAC_AX_FT_ACTION_UD:
+		ret = af_ud_fwd_cfg(adapter, &rf_ctrl_p->af_ud_ctrl);
+		break;
+	case MAC_AX_FT_TRIGGER:
+		ret = tf_fwd_cfg(adapter,
+				 (enum mac_ax_trigger_frame)rf_ctrl_p->frame,
+				 (enum mac_ax_fwd_target)rf_ctrl_p->fwd_tg);
+		break;
+	case MAC_AX_FT_PM_CAM:
+		// Don't suggest using indirect access.
+		ret = pm_cam_fwd_cfg(adapter, &rf_ctrl_p->pm_cam_ctrl);
+		break;
+	}
+
+	return ret;
+}
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_forwarding.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_forwarding.h
new file mode 100644
index 000000000000..a6cb1be34c22
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/rx_forwarding.h
@@ -0,0 +1,113 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_RX_FORWARDING_H_
+#define _MAC_AX_RX_FORWARDING_H_
+
+#include "../type.h"
+
+/*--------------------Define ----------------------------------------*/
+// Payload Match CAM
+#define PM_CAM_OFFSET_DW0		0
+#define PM_CAM_OFFSET_DW1		1
+#define PM_CAM_OFFSET_DW2		2
+#define PM_CAM_OFFSET_DW3		3
+#define PM_CAM_OFFSET_DW4		4
+
+/* dword0 */
+#define PM_CAM_VALID			BIT(0)
+#define PM_CAM_TYPE_SH			1
+#define PM_CAM_TYPE_MSK			0x3
+#define PM_CAM_SUBTYPE_SH		3
+#define PM_CAM_SUBTYPE_MSK		0xf
+#define PM_CAM_SKIP_MAC_IV_HDR	BIT(7)
+#define PM_CAM_TARGET_IND_SH	8
+#define PM_CAM_TARGET_IND_MSK	0x7
+#define PM_CAM_CRC16_SH			16
+#define PM_CAM_CRC16_MSK		0xffff
+
+/* dword1 */
+#define PM_CAM_PLD_MASK0_SH		0
+#define PM_CAM_PLD_MASK0_MSK	0xffffffff
+
+/* dword2 */
+#define PM_CAM_PLD_MASK1_SH		0
+#define PM_CAM_PLD_MASK1_MSK	0xffffffff
+
+/* dword3 */
+#define PM_CAM_PLD_MASK2_SH		0
+#define PM_CAM_PLD_MASK2_MSK	0xffffffff
+
+/* dword4 */
+#define PM_CAM_PLD_MASK3_SH		0
+#define PM_CAM_PLD_MASK3_MSK	0xffffffff
+
+#define MAC_AX_PM_CAM_ENTRY_CONTENT_SIZE	20
+#define MAC_AX_PM_CAM_ENTRY_NUM_MAX			16
+
+#define PM_CAM_WAIT_CNT			2000
+#define PM_CAM_WAIT_US			1
+
+/*--------------------Define Enum------------------------------------*/
+
+/*--------------------Define MACRO----------------------------------*/
+
+/*--------------------Define Struct-----------------------------------*/
+
+/*--------------------Export global variable----------------------------*/
+
+/*--------------------Function declaration-----------------------------*/
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup RX_Forwarding
+ * @{
+ */
+
+/**
+ * @brief mac_set_rx_forwarding:
+ *    Set rx forwarding feature:
+ *	1. MAC_AX_FT_ACTION: for action frame
+ *	2. MAC_AX_FT_ACTION_UD: for action frame with user define
+ *	3. MAC_AX_FT_TRIGGER: for trigger frame
+ *	4. MAC_AX_FT_PM_CAM: for Payload match CAM
+ *
+ * @param *adapter
+ * @param *rf_ctrl_p
+ * @return Please Place Description here.
+ * @retval u32
+ * #if MAC_AX_FW_REG_OFLD
+ *	1. MACSUCCESS		0
+ *	2. MACNPTR		5
+ *	3. MACNOBUF		9
+ *	4. MACFWNONRDY	80
+ * #else
+ *	1. MACSUCCESS		0
+ *	2. MACNPTR		5
+ *	3. MACNOITEM		11
+ *	4. MACPOLLTO		12
+ *	5. MACRFPMCAM		42
+ * #endif
+ */
+u32 mac_set_rx_forwarding(struct mac_ax_adapter *adapter,
+			  struct mac_ax_rx_fwd_ctrl_t *rf_ctrl_p);
+/**
+ * @}
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/secure_boot.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/secure_boot.c
new file mode 100644
index 000000000000..7aa426844bfc
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/secure_boot.c
@@ -0,0 +1,481 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "secure_boot.h"
+
+//#if WIFI_HAL_G6
+
+// OTP zone1 map
+u8 otp_sec_dis_zone_map_v01[] = {0xFC, 0xFF, 0xFF, 0x3F};
+
+// OTP zone3 map
+u8 otp_secure_zone_map_v01[] = {
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x00, 0x99, 0xB6, 0x34, 0xA0, 0xCD, 0xA1, 0x6B,
+	0xA1, 0xC5, 0x06, 0x8F, 0xCA, 0xDC, 0xE2, 0x95,
+	0xA5, 0xCC, 0x8B, 0x33, 0x13, 0x6E, 0x4F, 0x28,
+	0xFC, 0x1A, 0xE7, 0x91, 0x84, 0x4F, 0x62, 0x43,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+};
+
+// OTP zone4 values
+u8 otp_key_info_cell_01_val = 0xFF; // OTP 0x5EC
+u8 otp_key_info_cell_02_val = 0x6E; // OTP 0x5ED
+
+u32 mac_chk_sec_rec(struct mac_ax_adapter *adapter, u8 *sec_mode)
+{
+	u32 ret = 0;
+	u8 byte_val = 0;
+	u8 sec_rec;
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 otp_key_info_cell_02_addr = OTP_KEY_INFO_CELL_02_ADDR;
+
+	// read efuse OTP_KEY_INFO_CELL_02 to byte_val
+	ret = mac_ops->read_efuse(adapter, otp_key_info_cell_02_addr,
+				  1, &byte_val, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] chk_sec_rec read_efuse fail!\n");
+		return ret;
+	}
+
+	sec_rec = _security_rec(byte_val);
+
+	PLTFM_MSG_TRACE("[TRACE] sec_rec = %x\n", sec_rec);
+	if (sec_rec == 0x0)
+		*sec_mode = MAC_SEC;
+	else
+		*sec_mode = MAC_NON_SEC;
+
+	if (*sec_mode == MAC_SEC)
+		adapter->hw_info->is_sec_ic = 1;
+	else
+		adapter->hw_info->is_sec_ic = 0;
+
+	return MACSUCCESS;
+}
+
+u32 mac_pg_sec_phy_wifi(struct mac_ax_adapter *adapter)
+{
+	u32 ret = 0;
+	u32 i;
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 otp_secure_zone_base = OTP_SECURE_ZONE_BASE;
+
+	for (i = 0; i < OTP_SECURE_ZONE_SIZE; i++) {
+		// write OTP_SECURE_ZONE_BASE + i = otp_secure_zone_map_v01[i]
+		if (otp_secure_zone_map_v01[i] == 0xFF) {
+			continue;
+		} else {
+			ret = mac_ops->write_efuse(adapter, otp_secure_zone_base + i,
+						   otp_secure_zone_map_v01[i],
+						   MAC_AX_EFUSE_BANK_WIFI);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("[ERR] pg_sec_phy_wifi write_efuse fail!\n");
+				return ret;
+			}
+		}
+	}
+
+	PLTFM_MSG_TRACE("[TRACE] pg_sec_phy_wifi success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_cmp_sec_phy_wifi(struct mac_ax_adapter *adapter)
+{
+	u32 ret = 0;
+	u32 i;
+	u8 byte_val[OTP_SECURE_ZONE_SIZE];
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 otp_secure_zone_base = OTP_SECURE_ZONE_BASE;
+	u32 otp_secure_zone_size = OTP_SECURE_ZONE_SIZE;
+
+	ret = mac_ops->read_efuse(adapter, otp_secure_zone_base,
+				  otp_secure_zone_size, byte_val,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] cmp_sec_phy_wifi read_efuse fail!\n");
+		return ret;
+	}
+
+	for (i = 0; i < OTP_SECURE_ZONE_SIZE; i++) {
+		if (byte_val[i] != otp_secure_zone_map_v01[i]) {
+			PLTFM_MSG_ERR("[ERR] cmp_sec_phy_wifi fail!\n");
+			return MACEFUSECMP;
+		}
+	}
+
+	PLTFM_MSG_TRACE("[TRACE] cmp_sec_phy_wifi success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_pg_sec_hid_wifi(struct mac_ax_adapter *adapter)
+{
+	u32 ret = 0;
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 otp_key_info_cell_01_addr = OTP_KEY_INFO_CELL_01_ADDR;
+	u32 otp_key_info_cell_02_addr = OTP_KEY_INFO_CELL_02_ADDR;
+
+	// write OTP_KEY_INFO_CELL_01_ADDR = otp_key_info_cell_01_val
+	if (otp_key_info_cell_01_val == 0xFF) {
+		// do nothing
+	} else {
+		ret = mac_ops->write_efuse(adapter, otp_key_info_cell_01_addr,
+					   otp_key_info_cell_01_val,
+					   MAC_AX_EFUSE_BANK_WIFI);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR] pg_sec_hid_wifi write_efuse fail!\n");
+			return ret;
+		}
+	}
+
+	// write OTP_KEY_INFO_CELL_02_ADDR = otp_key_info_cell_02_val
+	ret = mac_ops->write_efuse(adapter, otp_key_info_cell_02_addr,
+				   otp_key_info_cell_02_val,
+				   MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] pg_sec_hid_wifi write_efuse fail!\n");
+		return ret;
+	}
+
+	PLTFM_MSG_TRACE("[TRACE] pg_sec_hid_wifi success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_cmp_sec_hid_wifi(struct mac_ax_adapter *adapter)
+{
+	u32 ret = 0;
+	u8 byte_val;
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 otp_key_info_cell_01_addr = OTP_KEY_INFO_CELL_01_ADDR;
+	u32 otp_key_info_cell_02_addr = OTP_KEY_INFO_CELL_02_ADDR;
+
+	ret = mac_ops->read_efuse(adapter, otp_key_info_cell_01_addr,
+				  1, &byte_val, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] cmp_sec_hid_wifi read_efuse fail!\n");
+		return ret;
+	}
+
+	if (byte_val != otp_key_info_cell_01_val) {
+		PLTFM_MSG_ERR("[ERR] cmp_sec_hid_wifi cell_01 fail!\n");
+		return MACEFUSECMP;
+	}
+
+	ret = mac_ops->read_efuse(adapter, otp_key_info_cell_02_addr,
+				  1, &byte_val, MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] cmp_sec_hid_wifi read_efuse fail!\n");
+		return ret;
+	}
+
+	if (byte_val != otp_key_info_cell_02_val) {
+		PLTFM_MSG_ERR("[ERR] cmp_sec_hid_wifi cell_02 fail!\n");
+		return MACEFUSECMP;
+	}
+
+	PLTFM_MSG_TRACE("[TRACE] cmp_sec_hid_wifi success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_pg_sec_dis(struct mac_ax_adapter *adapter)
+{
+	u32 ret = 0;
+	u32 i;
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 otp_sec_dis_zone_base = OTP_SEC_DIS_ZONE_BASE;
+
+	// write efuse OTP_SEC_CTRL_ZONE_BASE
+	for (i = 0; i < OTP_SEC_DIS_ZONE_SIZE; i++) {
+		// write OTP_SEC_DIS_ZONE_BASE + i = otp_sec_dis_zone_map_v01[i]
+		if (otp_sec_dis_zone_map_v01[i] == 0xFF) {
+			continue;
+		} else {
+			ret = mac_ops->write_efuse(adapter, otp_sec_dis_zone_base + i,
+						   otp_sec_dis_zone_map_v01[i],
+						   MAC_AX_EFUSE_BANK_WIFI);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("[ERR] pg_sec_dis write_efuse fail!\n");
+				return ret;
+			}
+		}
+	}
+
+	PLTFM_MSG_TRACE("[TRACE] pg_sec_dis success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_cmp_sec_dis(struct mac_ax_adapter *adapter)
+{
+	u32 ret = 0;
+	u32 i;
+	u8 byte_val[OTP_SEC_DIS_ZONE_SIZE];
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 otp_sec_dis_zone_base = OTP_SEC_DIS_ZONE_BASE;
+	u32 otp_sec_dis_zone_size = OTP_SEC_DIS_ZONE_SIZE;
+
+	ret = mac_ops->read_efuse(adapter, otp_sec_dis_zone_base,
+				  otp_sec_dis_zone_size, byte_val,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] cmp_sec_dis read_efuse fail!\n");
+		return ret;
+	}
+
+	for (i = 0; i < OTP_SEC_DIS_ZONE_SIZE; i++) {
+		if (byte_val[i] != otp_sec_dis_zone_map_v01[i]) {
+			PLTFM_MSG_ERR("[ERR] cmp_sec_dis fail!\n");
+			return MACEFUSECMP;
+		}
+	}
+
+	PLTFM_MSG_TRACE("[TRACE] cmp_sec_dis success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_sic_dis(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 ret;
+	u32 addr = OTP_PHY_BASE + OTP_PHY_1ST_B_OFFSET;
+	u8 byte = SIC_B_VAL;
+	u8 byte_tmp[1];
+
+	ret = mac_ops->write_efuse(adapter, addr, byte,
+				   MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] sic_dis write_efuse fail!\n");
+		return ret;
+	}
+
+	ret = mac_ops->read_efuse(adapter, addr, 1, byte_tmp,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] sic_dis read_efuse fail!\n");
+		return ret;
+	}
+
+	if (_2nd_double_bits(byte_tmp[0]) != _2nd_double_bits(byte)) {
+		PLTFM_MSG_ERR("[ERR] sic_dis cmp fail!\n");
+		return MACEFUSECMP;
+	}
+
+	PLTFM_MSG_TRACE("[TRACE] sic_dis success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_chk_sic_dis(struct mac_ax_adapter *adapter, u8 *sic_mode)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 ret;
+	u32 addr = OTP_PHY_BASE + OTP_PHY_1ST_B_OFFSET;
+	u8 byte_tmp[1];
+
+	ret = mac_ops->read_efuse(adapter, addr, 1, byte_tmp,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] chk_sic_dis read_efuse fail!\n");
+		return ret;
+	}
+
+	if (_2nd_double_bits(byte_tmp[0]) == 0x0)
+		*sic_mode = MAC_SIC_EN;
+	else
+		*sic_mode = MAC_SIC_DIS;
+
+	PLTFM_MSG_TRACE("[TRACE] chk_sic_dis success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_jtag_dis(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 ret;
+	u32 addr = OTP_PHY_BASE + OTP_PHY_1ST_B_OFFSET;
+	u8 byte = JTAG_B_VAL;
+	u8 byte_tmp[1];
+
+	ret = mac_ops->write_efuse(adapter, addr, byte,
+				   MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] jtag_dis write_efuse fail!\n");
+		return ret;
+	}
+
+	ret = mac_ops->read_efuse(adapter, addr, 1, byte_tmp,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] jtag_dis read_efuse fail!\n");
+		return ret;
+	}
+
+	if (_3rd_double_bits(byte_tmp[0]) != _3rd_double_bits(byte)) {
+		PLTFM_MSG_ERR("[ERR] jtag_dis cmp fail!\n");
+		return MACEFUSECMP;
+	}
+
+	PLTFM_MSG_TRACE("[TRACE] jtag_dis success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_chk_jtag_dis(struct mac_ax_adapter *adapter, u8 *jtag_mode)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 ret;
+	u32 addr = OTP_PHY_BASE + OTP_PHY_1ST_B_OFFSET;
+	u8 byte_tmp[1];
+
+	ret = mac_ops->read_efuse(adapter, addr, 1, byte_tmp,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] chk_jtag_dis read_efuse fail!\n");
+		return ret;
+	}
+
+	if (_3rd_double_bits(byte_tmp[0]) == 0x0)
+		*jtag_mode = MAC_JTAG_EN;
+	else
+		*jtag_mode = MAC_JTAG_DIS;
+
+	PLTFM_MSG_TRACE("[TRACE] chk_jtag_dis success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_uart_tx_dis(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 ret;
+	u32 addr = OTP_PHY_BASE + OTP_PHY_1ST_B_OFFSET;
+	u8 byte = UART_TX_B_VAL;
+	u8 byte_tmp[1];
+
+	ret = mac_ops->write_efuse(adapter, addr, byte,
+				   MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] uart_tx_dis write_efuse fail!\n");
+		return ret;
+	}
+
+	ret = mac_ops->read_efuse(adapter, addr, 1, byte_tmp,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] uart_tx_dis read_efuse fail!\n");
+		return ret;
+	}
+
+	if (_4th_double_bits(byte_tmp[0]) != _4th_double_bits(byte)) {
+		PLTFM_MSG_ERR("[ERR] uart_tx_dis cmp fail!\n");
+		return MACEFUSECMP;
+	}
+
+	PLTFM_MSG_TRACE("[TRACE] uart_tx_dis success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_chk_uart_tx_dis(struct mac_ax_adapter *adapter, u8 *uart_tx_mode)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 ret;
+	u32 addr = OTP_PHY_BASE + OTP_PHY_1ST_B_OFFSET;
+	u8 byte_tmp[1];
+
+	ret = mac_ops->read_efuse(adapter, addr, 1, byte_tmp,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] chk_uart_tx_dis read_efuse fail!\n");
+		return ret;
+	}
+
+	if (_4th_double_bits(byte_tmp[0]) == 0x0)
+		*uart_tx_mode = MAC_UART_TX_EN;
+	else
+		*uart_tx_mode = MAC_UART_TX_DIS;
+
+	PLTFM_MSG_TRACE("[TRACE] chk_uart_tx_dis success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_uart_rx_dis(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 ret;
+	u32 addr = OTP_PHY_BASE + OTP_PHY_2ND_B_OFFSET;
+	u8 byte = UART_RX_B_VAL;
+	u8 byte_tmp[1];
+
+	ret = mac_ops->write_efuse(adapter, addr, byte,
+				   MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] uart_rx_dis write_efuse fail!\n");
+		return ret;
+	}
+
+	ret = mac_ops->read_efuse(adapter, addr, 1, byte_tmp,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] uart_rx_dis read_efuse fail!\n");
+		return ret;
+	}
+
+	if (_1st_double_bits(byte_tmp[0]) != _1st_double_bits(byte)) {
+		PLTFM_MSG_ERR("[ERR] uart_rx_dis cmp fail!\n");
+		return MACEFUSECMP;
+	}
+
+	PLTFM_MSG_TRACE("[TRACE] uart_rx_dis success!\n");
+	return MACSUCCESS;
+}
+
+u32 mac_chk_uart_rx_dis(struct mac_ax_adapter *adapter, u8 *uart_rx_mode)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	u32 ret;
+	u32 addr = OTP_PHY_BASE + OTP_PHY_2ND_B_OFFSET;
+	u8 byte_tmp[1];
+
+	ret = mac_ops->read_efuse(adapter, addr, 1, byte_tmp,
+				  MAC_AX_EFUSE_BANK_WIFI);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] chk_uart_rx_dis read_efuse fail!\n");
+		return ret;
+	}
+
+	if (_1st_double_bits(byte_tmp[0]) == 0x0)
+		*uart_rx_mode = MAC_UART_RX_EN;
+	else
+		*uart_rx_mode = MAC_UART_RX_DIS;
+
+	PLTFM_MSG_TRACE("[TRACE] chk_uart_rx_dis success!\n");
+	return MACSUCCESS;
+}
+
+//#endif
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/secure_boot.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/secure_boot.h
new file mode 100644
index 000000000000..0c0f4260b0a9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/secure_boot.h
@@ -0,0 +1,102 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_SECURE_BOOT_H_
+#define _MAC_AX_SECURE_BOOT_H_
+
+#include "../type.h"
+#include "efuse.h"
+//#include "fwcmd.h"
+
+//#if WIFI_HAL_G6
+
+#define OTP_SEC_DIS_ZONE_BASE 0x0
+#define OTP_SEC_DIS_ZONE_SIZE 4
+#define OTP_SECURE_ZONE_BASE 0x4C0
+#define OTP_SECURE_ZONE_SIZE 192
+
+#define OTP_KEY_INFO_CELL_01_ADDR 0x5EC
+#define OTP_KEY_INFO_CELL_02_ADDR 0x5ED
+
+#define OTP_PHY_BASE 0x0
+#define OTP_PHY_1ST_B_OFFSET 0
+#define OTP_PHY_2ND_B_OFFSET 1
+#define OTP_PHY_3RD_B_OFFSET 2
+#define OTP_PHY_4TH_B_OFFSET 3
+
+#define SEC_B_VAL 0xFC
+#define SIC_B_VAL 0xF3
+#define JTAG_B_VAL 0xCF
+#define UART_TX_B_VAL 0x3F
+#define UART_RX_B_VAL 0xFC
+
+enum mac_sec_mode {
+	MAC_NON_SEC,
+	MAC_SEC,
+};
+
+enum mac_sic_mode {
+	MAC_SIC_EN,
+	MAC_SIC_DIS,
+};
+
+enum mac_jtag_mode {
+	MAC_JTAG_EN,
+	MAC_JTAG_DIS,
+};
+
+enum mac_uart_tx_mode {
+	MAC_UART_TX_EN,
+	MAC_UART_TX_DIS,
+};
+
+enum mac_uart_rx_mode {
+	MAC_UART_RX_EN,
+	MAC_UART_RX_DIS,
+};
+
+// externalPN  = 0x5EC[7:0]
+// customer    = 0x5ED[3:0]
+// serialNum   = 0x5ED[6:4]
+// securityRec = 0x5ED[7:7]
+#define _external_pn(byte)   ((byte & 0xFF) >> 0)
+#define _customer(byte)     ((byte & 0x0F) >> 0)
+#define _serial_num(byte)    ((byte & 0x70) >> 4)
+#define _security_rec(byte)  ((byte & 0x80) >> 7)
+
+#define _1st_double_bits(byte) ((byte & 0x03) >> 0)
+#define _2nd_double_bits(byte) ((byte & 0x0C) >> 2)
+#define _3rd_double_bits(byte) ((byte & 0x30) >> 4)
+#define _4th_double_bits(byte) ((byte & 0xC0) >> 6)
+
+u32 mac_chk_sec_rec(struct mac_ax_adapter *adapter, u8 *sec_mode);
+u32 mac_pg_sec_phy_wifi(struct mac_ax_adapter *adapter);
+u32 mac_cmp_sec_phy_wifi(struct mac_ax_adapter *adapter);
+u32 mac_pg_sec_hid_wifi(struct mac_ax_adapter *adapter);
+u32 mac_cmp_sec_hid_wifi(struct mac_ax_adapter *adapter);
+u32 mac_pg_sec_dis(struct mac_ax_adapter *adapter);
+u32 mac_cmp_sec_dis(struct mac_ax_adapter *adapter);
+u32 mac_sic_dis(struct mac_ax_adapter *adapter);
+u32 mac_chk_sic_dis(struct mac_ax_adapter *adapter, u8 *sic_mode);
+u32 mac_jtag_dis(struct mac_ax_adapter *adapter);
+u32 mac_chk_jtag_dis(struct mac_ax_adapter *adapter, u8 *jtag_mode);
+u32 mac_uart_tx_dis(struct mac_ax_adapter *adapter);
+u32 mac_chk_uart_tx_dis(struct mac_ax_adapter *adapter, u8 *uart_tx_mode);
+u32 mac_uart_rx_dis(struct mac_ax_adapter *adapter);
+u32 mac_chk_uart_rx_dis(struct mac_ax_adapter *adapter, u8 *uart_rx_mode);
+
+#endif
+//#endif
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/security_cam.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/security_cam.c
new file mode 100644
index 000000000000..64ef493d3677
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/security_cam.c
@@ -0,0 +1,1036 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "security_cam.h"
+
+#define ADDR_CAM_SECINFO_OFFSET 0x1C
+#define HW_SUPPORT_ENC_TYPE_NUM 0x0A
+#define OUTRANGE_KEY_INDEX	0xFF
+#define NO_MACID_ROLE		0xFF
+#define VALID			0x01
+#define INVALID			0x00
+
+struct addr_sec_only_info {
+	u32 dword0;
+	u32 dword1;
+	u32 dword2;
+};
+
+enum SEC_CAM_KEY_TYPE {
+	SEC_CAM_KEY_TYPE_UNI = 0,
+	SEC_CAM_KEY_TYPE_GROUP = 1,
+	SEC_CAM_KEY_TYPE_BIP = 2,
+	SEC_CAM_KEY_TYPE_DEFAULT = 3
+};
+
+enum ADDR_CAM_SEC_MODE {
+	ADDR_CAM_SEC_MODE_ZERO = 0,
+	ADDR_CAM_SEC_MODE_ONE  = 1,
+	ADDR_CAM_SEC_MODE_TWO  = 2,
+	ADDR_CAM_SEC_MODE_THREE = 3,
+};
+
+enum HW_SUPPORT_ENC_TYPE {
+	HW_SUPPORT_ENC_TYPE_NONE = 0x0,
+	HW_SUPPORT_ENC_TYPE_WEP40  = 0x1,
+	HW_SUPPORT_ENC_TYPE_WEP104  = 0x2,
+	HW_SUPPORT_ENC_TYPE_TKIP = 0x3,
+	HW_SUPPORT_ENC_TYPE_WAPI = 0x4,
+	HW_SUPPORT_ENC_TYPE_GCMSMS4 = 0x5,
+	HW_SUPPORT_ENC_TYPE_CCMP128 = 0x6,
+	HW_SUPPORT_ENC_TYPE_CCMP256 = 0x7,
+	HW_SUPPORT_ENC_TYPE_GCMP128 = 0x8,
+	HW_SUPPORT_ENC_TYPE_GCMP256 = 0x9,
+	HW_SUPPORT_ENC_TYPE_BIP128 = 0xA,
+};
+
+u32 sec_info_tbl_init(struct mac_ax_adapter *adapter)
+{
+	u8 i = 0;
+	struct sec_cam_table_t **sec_cam_table =
+		&adapter->hw_info->sec_cam_table;
+
+	/*First time access sec cam , initial sec cam table INVALID  */
+	if ((*sec_cam_table) == NULL) {
+		(*sec_cam_table) = (struct sec_cam_table_t *)PLTFM_MALLOC
+			(sizeof(struct sec_cam_table_t));
+
+		if (!(*sec_cam_table))
+			return MACNOBUF;
+
+		for (i = 0; i < SEC_CAM_ENTRY_NUM; i++) {
+			(*sec_cam_table)->sec_cam_entry[i] =
+			(struct sec_cam_entry_t *)PLTFM_MALLOC
+			(sizeof(struct sec_cam_entry_t));
+
+			if (!(*sec_cam_table)->sec_cam_entry[i])
+				return MACNOBUF;
+
+			(*sec_cam_table)->sec_cam_entry[i]->sec_cam_info =
+			(struct mac_ax_sec_cam_info *)PLTFM_MALLOC
+			(sizeof(struct mac_ax_sec_cam_info));
+
+			if (!(*sec_cam_table)->sec_cam_entry[i]->sec_cam_info)
+				return MACNOBUF;
+
+			/* initial value*/
+			(*sec_cam_table)->sec_cam_entry[i]->valid = INVALID;
+			(*sec_cam_table)->sec_cam_entry[i]->mac_id = 0;
+			(*sec_cam_table)->sec_cam_entry[i]->key_id = 0;
+			(*sec_cam_table)->sec_cam_entry[i]->key_type = 0;
+		}
+		(*sec_cam_table)->next_cam_storage_idx = 0;
+	}
+	return MACSUCCESS;
+}
+
+u32 free_sec_info_tbl(struct mac_ax_adapter *adapter)
+{
+	u8 i;
+	struct sec_cam_table_t *sec_cam_table = adapter->hw_info->sec_cam_table;
+
+	if (!sec_cam_table)
+		return MACSUCCESS;
+
+	for (i = 0; i < SEC_CAM_ENTRY_NUM; i++) {
+		PLTFM_FREE(sec_cam_table->sec_cam_entry[i]->sec_cam_info,
+			   sizeof(struct mac_ax_sec_cam_info));
+	}
+	for (i = 0; i < SEC_CAM_ENTRY_NUM; i++) {
+		PLTFM_FREE(sec_cam_table->sec_cam_entry[i],
+			   sizeof(struct sec_cam_entry_t));
+	}
+
+	PLTFM_FREE(sec_cam_table, sizeof(struct sec_cam_table_t));
+
+	adapter->hw_info->sec_cam_table = NULL;
+	return MACSUCCESS;
+}
+
+u32 fill_sec_cam_info(struct mac_ax_adapter *adapter,
+		      struct mac_ax_sec_cam_info *s_info,
+		      struct fwcmd_seccam_info *sec_info,
+		      u8 clear)
+{
+	if (clear == INVALID) {
+		sec_info->dword0 =
+		cpu_to_le32(SET_WORD(s_info->sec_cam_idx, FWCMD_H2C_SECCAM_INFO_IDX) |
+			    SET_WORD(s_info->offset, FWCMD_H2C_SECCAM_INFO_OFFSET) |
+			    SET_WORD(s_info->len, FWCMD_H2C_SECCAM_INFO_LEN));
+
+		sec_info->dword1 =
+		cpu_to_le32(SET_WORD(s_info->type, FWCMD_H2C_SECCAM_INFO_TYPE) |
+			    ((s_info->ext_key) ? FWCMD_H2C_SECCAM_INFO_EXT_KEY : 0) |
+			    ((s_info->spp_mode) ? FWCMD_H2C_SECCAM_INFO_SPP_MODE : 0));
+		sec_info->dword2 = s_info->key[0];
+		sec_info->dword3 = s_info->key[1];
+		sec_info->dword4 = s_info->key[2];
+		sec_info->dword5 = s_info->key[3];
+	} else {
+		sec_info->dword0 =
+		cpu_to_le32(SET_WORD(s_info->sec_cam_idx, FWCMD_H2C_SECCAM_INFO_IDX) |
+			    SET_WORD(s_info->offset, FWCMD_H2C_SECCAM_INFO_OFFSET) |
+			    SET_WORD(s_info->len, FWCMD_H2C_SECCAM_INFO_LEN));
+
+		sec_info->dword1 = 0x0;
+		sec_info->dword2 = 0x0;
+		sec_info->dword3 = 0x0;
+		sec_info->dword4 = 0x0;
+		sec_info->dword5 = 0x0;
+	}
+	return MACSUCCESS;
+}
+
+u32 fill_addr_cam_sec_only(struct mac_ax_adapter *adapter,
+			   struct mac_ax_role_info *info,
+			   struct addr_sec_only_info *addr_sec_info)
+{
+	struct mac_ax_addr_cam_info a_info;
+
+	a_info = info->a_info;
+
+	addr_sec_info->dword0 =
+	cpu_to_le32((a_info.aid12 & 0xfff) |
+		    ((a_info.wol_pattern) ? FWCMD_H2C_ADDRCAM_INFO_WOL_PATTERN
+		     : 0) |
+		    ((a_info.wol_uc) ? FWCMD_H2C_ADDRCAM_INFO_WOL_UC : 0) |
+		    ((a_info.wol_magic) ?
+		     FWCMD_H2C_ADDRCAM_INFO_WOL_MAGIC : 0) |
+		    ((a_info.wapi) ? FWCMD_H2C_ADDRCAM_INFO_WAPI : 0) |
+		    SET_WORD(a_info.sec_ent_mode,
+			     FWCMD_H2C_ADDRCAM_INFO_SEC_ENT_MODE) |
+		    SET_WORD(a_info.sec_ent_keyid[0],
+			     FWCMD_H2C_ADDRCAM_INFO_SEC_ENT0_KEYID) |
+		    SET_WORD(a_info.sec_ent_keyid[1],
+			     FWCMD_H2C_ADDRCAM_INFO_SEC_ENT1_KEYID) |
+		    SET_WORD(a_info.sec_ent_keyid[2],
+			     FWCMD_H2C_ADDRCAM_INFO_SEC_ENT2_KEYID) |
+		    SET_WORD(a_info.sec_ent_keyid[3],
+			     FWCMD_H2C_ADDRCAM_INFO_SEC_ENT3_KEYID) |
+		    SET_WORD(a_info.sec_ent_keyid[4],
+			     FWCMD_H2C_ADDRCAM_INFO_SEC_ENT4_KEYID) |
+		    SET_WORD(a_info.sec_ent_keyid[5],
+			     FWCMD_H2C_ADDRCAM_INFO_SEC_ENT5_KEYID) |
+		    SET_WORD(a_info.sec_ent_keyid[6],
+			     FWCMD_H2C_ADDRCAM_INFO_SEC_ENT6_KEYID));
+
+	addr_sec_info->dword1 =
+	  cpu_to_le32(SET_WORD(a_info.sec_ent_valid,
+			       FWCMD_H2C_ADDRCAM_INFO_SEC_ENT_VALID) |
+		      SET_WORD(a_info.sec_ent[0],
+			       FWCMD_H2C_ADDRCAM_INFO_SEC_ENT0) |
+		      SET_WORD(a_info.sec_ent[1],
+			       FWCMD_H2C_ADDRCAM_INFO_SEC_ENT1) |
+		      SET_WORD(a_info.sec_ent[2],
+			       FWCMD_H2C_ADDRCAM_INFO_SEC_ENT2));
+
+	addr_sec_info->dword2 =
+	cpu_to_le32(SET_WORD(a_info.sec_ent[3],
+			     FWCMD_H2C_ADDRCAM_INFO_SEC_ENT3) |
+		    SET_WORD(a_info.sec_ent[4],
+			     FWCMD_H2C_ADDRCAM_INFO_SEC_ENT4) |
+		    SET_WORD(a_info.sec_ent[5],
+			     FWCMD_H2C_ADDRCAM_INFO_SEC_ENT5) |
+		    SET_WORD(a_info.sec_ent[6],
+			     FWCMD_H2C_ADDRCAM_INFO_SEC_ENT6));
+
+	return MACSUCCESS;
+}
+
+u32 mac_upd_sec_infotbl(struct mac_ax_adapter *adapter,
+			struct fwcmd_seccam_info *info)
+{
+	u32 ret = 0, s_info_tbl[6], cam_address = 0;
+	u8 *buf, i;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_seccam_info *tbl;
+	struct mac_ax_sec_cam_info *s_info;
+
+	/*h2c access*/
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_seccam_info));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	tbl = (struct fwcmd_seccam_info *)buf;
+
+	tbl->dword0 = info->dword0;
+	tbl->dword1 = info->dword1;
+	tbl->dword2 = info->dword2;
+	tbl->dword3 = info->dword3;
+	tbl->dword4 = info->dword4;
+	tbl->dword5 = info->dword5;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = h2c_pkt_set_hdr(adapter, h2cb,
+				      FWCMD_TYPE_H2C,
+				      FWCMD_H2C_CAT_MAC,
+				      FWCMD_H2C_CL_SEC_CAM,
+				      FWCMD_H2C_FUNC_SECCAM_INFO,
+				      0,
+				      1);
+
+		if (ret != MACSUCCESS)
+			goto fail;
+
+		// Return MACSUCCESS if h2c aggregation is enabled and enqueued successfully.
+		// The H2C shall be sent by mac_h2c_agg_tx.
+		ret = h2c_agg_enqueue(adapter, h2cb);
+		if (ret == MACSUCCESS)
+			return MACSUCCESS;
+
+		ret = h2c_pkt_build_txd(adapter, h2cb);
+		if (ret != MACSUCCESS)
+			goto fail;
+
+		#if MAC_AX_PHL_H2C
+		ret = PLTFM_TX(h2cb);
+		#else
+		ret = PLTFM_TX(h2cb->data, h2cb->len);
+		#endif
+		if (ret != MACSUCCESS)
+			goto fail;
+
+		h2cb_free(adapter, h2cb);
+		return MACSUCCESS;
+fail:
+		h2cb_free(adapter, h2cb);
+	} else {
+		/* Indirect Access */
+		s_info = (struct mac_ax_sec_cam_info *)info;
+		s_info_tbl[0] = info->dword0;
+		s_info_tbl[1] = info->dword1;
+		s_info_tbl[2] = info->dword2;
+		s_info_tbl[3] = info->dword3;
+		s_info_tbl[4] = info->dword4;
+		s_info_tbl[5] = info->dword5;
+
+		/*  Indirect write security cam */
+		PLTFM_MSG_WARN("%s ind access start\n", __func__);
+		cam_address = s_info->sec_cam_idx * SEC_CAM_ENTRY_SIZE;
+		for (i = 0; i < 5; i++)
+			mac_sram_dbg_write(adapter, cam_address + (i * 4),
+					   cpu_to_le32(s_info_tbl[i + 1]),
+					   SEC_CAM_SEL);
+		PLTFM_MSG_WARN("%s ind access end\n", __func__);
+
+		return MACSUCCESS;
+	}
+
+	return ret;
+}
+
+u8 check_key_index(u8 addr_cam_sec_mode, u8 key_type, u8 key_index)
+{
+	switch (addr_cam_sec_mode) {
+	case ADDR_CAM_SEC_MODE_ZERO:
+		switch (key_type) {
+		case SEC_CAM_KEY_TYPE_UNI:
+			if (key_index <= 6)
+				return MACSUCCESS;
+		default:
+			break;
+		}
+		break;
+	case ADDR_CAM_SEC_MODE_ONE:
+		switch (key_type) {
+		case SEC_CAM_KEY_TYPE_UNI:
+			if (key_index <= 6)
+				return MACSUCCESS;
+		default:
+			break;
+		}
+		break;
+	case ADDR_CAM_SEC_MODE_TWO:
+		switch (key_type) {
+		case SEC_CAM_KEY_TYPE_UNI:
+			if (key_index <= 1)
+				return MACSUCCESS;
+			break;
+		case SEC_CAM_KEY_TYPE_GROUP:
+			if (key_index >= 2 && key_index <= 4)
+				return MACSUCCESS;
+			break;
+		case SEC_CAM_KEY_TYPE_BIP:
+			if (key_index >= 5 && key_index <= 6)
+				return MACSUCCESS;
+			break;
+		default:
+			break;
+		}
+		break;
+	case ADDR_CAM_SEC_MODE_THREE:
+		switch (key_type) {
+		case SEC_CAM_KEY_TYPE_UNI:
+			if (key_index <= 1)
+				return MACSUCCESS;
+			break;
+		case SEC_CAM_KEY_TYPE_GROUP:
+			if (key_index >= 2 && key_index <= 5)
+				return MACSUCCESS;
+			break;
+		case SEC_CAM_KEY_TYPE_BIP:
+			if (key_index == 6)
+				return MACSUCCESS;
+			break;
+		default:
+			break;
+		}
+		break;
+	}
+	return 1;
+}
+
+u8 decide_key_index(u8 addr_cam_sec_mode, u8 key_type)
+{
+	u8 key_index = 0;
+
+	switch (addr_cam_sec_mode) {
+	case ADDR_CAM_SEC_MODE_ZERO:
+		if (key_type == SEC_CAM_KEY_TYPE_UNI)
+			key_index = 0;
+		else if (key_type == SEC_CAM_KEY_TYPE_GROUP)
+			return MACWNGKEYTYPE;
+		else if (key_type == SEC_CAM_KEY_TYPE_BIP)
+			return MACWNGKEYTYPE;
+		break;
+	case ADDR_CAM_SEC_MODE_ONE:
+		if (key_type == SEC_CAM_KEY_TYPE_UNI)
+			key_index = 0;
+		else if (key_type == SEC_CAM_KEY_TYPE_GROUP)
+			return MACWNGKEYTYPE;
+		else if (key_type == SEC_CAM_KEY_TYPE_BIP)
+			return MACWNGKEYTYPE;
+		break;
+	case ADDR_CAM_SEC_MODE_TWO:
+		if (key_type == SEC_CAM_KEY_TYPE_UNI)
+			key_index = 0;
+		else if (key_type == SEC_CAM_KEY_TYPE_GROUP)
+			key_index = 2;
+		else if (key_type == SEC_CAM_KEY_TYPE_BIP)
+			key_index = 5;
+		break;
+	case ADDR_CAM_SEC_MODE_THREE:
+		if (key_type == SEC_CAM_KEY_TYPE_UNI)
+			key_index = 0;
+		else if (key_type == SEC_CAM_KEY_TYPE_GROUP)
+			key_index = 2;
+		else if (key_type == SEC_CAM_KEY_TYPE_BIP)
+			key_index = 6;
+		break;
+	default:
+		break;
+	}
+	return key_index;
+}
+
+u8 decide_sec_cam_index(struct mac_ax_adapter *adapter, u8 *sec_cam_idx)
+{
+	u8 sec_idx = 0, i = 0;
+	/* call by pointer */
+	struct sec_cam_table_t **sec_cam_table =
+		&adapter->hw_info->sec_cam_table;
+
+	/*First time access sec cam , initial sec cam table INVALID  */
+	if ((*sec_cam_table) == NULL) {
+		(*sec_cam_table) = (struct sec_cam_table_t *)PLTFM_MALLOC
+			(sizeof(struct sec_cam_table_t));
+
+		if (!(*sec_cam_table))
+			return MACNOBUF;
+
+		for (i = 0; i < SEC_CAM_ENTRY_NUM; i++) {
+			(*sec_cam_table)->sec_cam_entry[i] =
+			(struct sec_cam_entry_t *)PLTFM_MALLOC
+			(sizeof(struct sec_cam_entry_t));
+
+			if (!(*sec_cam_table)->sec_cam_entry[i])
+				return MACNOBUF;
+
+			(*sec_cam_table)->sec_cam_entry[i]->sec_cam_info =
+			(struct mac_ax_sec_cam_info *)PLTFM_MALLOC
+			(sizeof(struct mac_ax_sec_cam_info));
+
+			if (!(*sec_cam_table)->sec_cam_entry[i]->sec_cam_info)
+				return MACNOBUF;
+
+			/* initial value*/
+			(*sec_cam_table)->sec_cam_entry[i]->valid = INVALID;
+			(*sec_cam_table)->sec_cam_entry[i]->mac_id = 0;
+			(*sec_cam_table)->sec_cam_entry[i]->key_id = 0;
+			(*sec_cam_table)->sec_cam_entry[i]->key_type = 0;
+		}
+		(*sec_cam_table)->next_cam_storage_idx = 0;
+	}
+
+	/*If table has been initialize, assgin the sec cam storge idx */
+	sec_idx = (*sec_cam_table)->next_cam_storage_idx;
+	for (i = 0; i < SEC_CAM_ENTRY_NUM; i++) {
+		if ((*sec_cam_table)->sec_cam_entry[sec_idx]->valid ==
+		    INVALID) {
+			(*sec_cam_table)->next_cam_storage_idx =
+			(sec_idx + 1) % SEC_CAM_ENTRY_NUM;
+			*sec_cam_idx = sec_idx;
+			return MACSUCCESS;
+		}
+		sec_idx++;
+		sec_idx %= SEC_CAM_ENTRY_NUM;
+	}
+
+	return MACSECCAMFL;
+}
+
+u8 delete_key_from_addr_cam(struct mac_ax_adapter *adapter,
+			    struct mac_role_tbl *role, u8 key_type,
+			    u8 key_id, u8 *sec_cam_idx)
+{
+	u32 ret = 0;
+	u8 key_index = 0, key_valid_byte = 0, i = 0;
+	u8 key_valid[7] = {0}, hit_flag = 0;
+
+	key_valid_byte = role->info.a_info.sec_ent_valid;
+
+	key_index = decide_key_index(role->info.a_info.sec_ent_mode, key_type);
+
+	if (key_index == MACWNGKEYTYPE)
+		return MACWNGKEYTYPE;
+
+	for (i = 0; i < 7; i++) {
+		key_valid[i] = key_valid_byte % 2;
+		key_valid_byte = key_valid_byte >> 1;
+	}
+
+	/* find the key real storage idx */
+	for (i = key_index; i < 7; i++) {
+		if (role->info.a_info.sec_ent_keyid[i] == key_id &&
+		    key_valid[i] == VALID) {
+			key_index = i;
+			hit_flag = 1;
+			break;
+		}
+	}
+
+	if (hit_flag == 0)
+		return MACKEYNOTEXT;
+
+	if (check_key_index(role->info.a_info.sec_ent_mode,
+			    key_type, key_index)) {
+		PLTFM_MSG_TRACE("check addr key index full\n");
+		return MACADDRCAMKEYFL;
+	}
+
+	/*get the key cam index*/
+	*sec_cam_idx = role->info.a_info.sec_ent[key_index];
+
+	role->info.a_info.sec_ent_keyid[key_index] = 0;
+	role->info.a_info.sec_ent_valid &= ~(BIT(key_index));
+	role->info.a_info.sec_ent[key_index] = 0;
+
+	/*  update addr cam */
+	ret = mac_upd_addr_cam(adapter, &role->info, CHG);
+	if (ret == MACBSSIDCAMFL) {
+		PLTFM_MSG_ERR("[ERR]: BSSID CAM full\n");
+		return MACBSSIDCAMFL;
+	}
+
+	return MACSUCCESS;
+}
+
+u8 insert_key_to_addr_cam(struct mac_ax_adapter *adapter,
+			  struct mac_role_tbl *role, u8 key_type,
+			  u8 key_id, u8 sec_cam_idx)
+{
+	u32 ret = 0;
+	u8 key_index = 0, key_valid_byte = 0, i = 0;
+	u8 key_valid[7] = {0}, hit_flag = 0;
+
+	key_valid_byte = role->info.a_info.sec_ent_valid;
+	key_index = decide_key_index(role->info.a_info.sec_ent_mode, key_type);
+
+	if (key_index == MACWNGKEYTYPE)
+		return MACWNGKEYTYPE;
+
+	for (i = 0; i < 7; i++) {
+		key_valid[i] = key_valid_byte % 2;
+		key_valid_byte = key_valid_byte >> 1;
+	}
+
+	/* find the key real storage idx */
+	for (i = key_index; i < 7; i++) {
+		if (key_valid[i] != VALID) {
+			key_index = i;
+			hit_flag = 1;
+			break;
+		}
+	}
+	if (hit_flag == 0)
+		return MACADDRCAMKEYFL;
+
+	if (check_key_index(role->info.a_info.sec_ent_mode,
+			    key_type, key_index)) {
+		PLTFM_MSG_TRACE("check addr key index full\n");
+		return MACADDRCAMKEYFL;
+	}
+
+	role->info.a_info.sec_ent_keyid[key_index] = key_id;
+	role->info.a_info.sec_ent_valid |= BIT(key_index);
+	role->info.a_info.sec_ent[key_index] = sec_cam_idx;
+
+	ret = mac_upd_addr_cam(adapter, &role->info, CHG);
+	if (ret == MACBSSIDCAMFL) {
+		PLTFM_MSG_ERR("[ERR]: BSSID CAM full\n");
+		return MACBSSIDCAMFL;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 m_security_cam_hal(struct mac_ax_adapter *adapter,
+		       struct mac_ax_sec_cam_info *sec_cam_info,
+		       u8 mac_id, u8 key_id, u8 key_type,
+		       u8 sec_cam_idx, u8 clear)
+{
+	u8 i = 0;
+	struct sec_cam_entry_t *sec_cam_entry = NULL;
+	struct sec_cam_table_t *sec_cam_table =
+		adapter->hw_info->sec_cam_table;
+
+	if (!sec_cam_table)
+		return MACSUCCESS;
+
+	/* patch for read wrong value from HW*/
+	if (sec_cam_idx >= SEC_CAM_ENTRY_NUM)
+		return MACSUCCESS;
+
+	sec_cam_entry =
+		adapter->hw_info->sec_cam_table->sec_cam_entry[sec_cam_idx];
+	if (clear == 1) {
+		sec_cam_entry->valid = INVALID;
+		sec_cam_entry->mac_id = 0;
+		sec_cam_entry->key_id = 0;
+		sec_cam_entry->key_type = 0;
+		sec_cam_entry->sec_cam_info->type = 0;
+		sec_cam_entry->sec_cam_info->ext_key = 0;
+		sec_cam_entry->sec_cam_info->spp_mode = 0;
+		for (i = 0; i < 3; i++)
+			sec_cam_entry->sec_cam_info->key[i] = 0;
+	} else {
+		if (!sec_cam_info) {
+			sec_cam_entry->valid = VALID;
+			sec_cam_entry->mac_id = mac_id;
+			sec_cam_entry->key_id = key_id;
+			sec_cam_entry->key_type = key_type;
+			sec_cam_entry->sec_cam_info->type = 0x0;
+			sec_cam_entry->sec_cam_info->ext_key = 0x0;
+			sec_cam_entry->sec_cam_info->spp_mode = 0x0;
+			for (i = 0; i < 4; i++)
+				sec_cam_entry->sec_cam_info->key[i] = 0x0;
+		} else {
+			sec_cam_entry->valid = VALID;
+			sec_cam_entry->mac_id = mac_id;
+			sec_cam_entry->key_id = key_id;
+			sec_cam_entry->key_type = key_type;
+			sec_cam_entry->sec_cam_info->type = sec_cam_info->type;
+			sec_cam_entry->sec_cam_info->ext_key =
+				sec_cam_info->ext_key;
+			sec_cam_entry->sec_cam_info->spp_mode =
+				sec_cam_info->spp_mode;
+			for (i = 0; i < 4; i++)
+				sec_cam_entry->sec_cam_info->key[i] =
+				sec_cam_info->key[i];
+		}
+	}
+
+	return MACSUCCESS;
+}
+
+u32 disconnect_flush_key(struct mac_ax_adapter *adapter,
+			 struct mac_role_tbl *role)
+{
+	struct mac_ax_sec_cam_info *sec_cam_info = NULL;
+	u8 i, sec_ent_valid, mac_id, key_type, key_index;
+	u8 key_valid[7] = {0}, sec_cam_index[7] = {0}, sec_ent_keyid[7] = {0};
+
+	sec_ent_valid = role->info.a_info.sec_ent_valid;
+	mac_id = role->info.a_info.sec_ent_valid;
+
+	for (i = 0; i < 7; i++) {
+		key_valid[i] = sec_ent_valid % 2;
+		sec_ent_valid = sec_ent_valid >> 1;
+		sec_cam_index[i] = role->info.a_info.sec_ent[i];
+		sec_ent_keyid[i] = role->info.a_info.sec_ent_keyid[i];
+	}
+
+	key_type = SEC_CAM_KEY_TYPE_DEFAULT;
+	for (key_index = 0; key_index < 7; key_index++) {
+		if (key_valid[key_index] == VALID) {
+			m_security_cam_hal(adapter, sec_cam_info,
+					   mac_id, sec_ent_keyid[key_index],
+					   key_type, sec_cam_index[key_index],
+					   1);
+		}
+	}
+	return MACSUCCESS;
+}
+
+u32 mac_sta_del_key(struct mac_ax_adapter *adapter,
+		    u8 mac_id,
+		    u8 key_id,
+		    u8 key_type)
+{
+	struct mac_ax_sec_cam_info sec_cam_info;
+	struct mac_role_tbl *role = NULL;
+	u8 sec_cam_idx = 0;
+	u32 sec_table[6] = {0}, ret = 0;
+
+	role = mac_role_srch(adapter, mac_id);
+
+	if (!role)
+		return MACNOROLE;
+
+	ret = delete_key_from_addr_cam(adapter, role, key_type,
+				       key_id, &sec_cam_idx);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	sec_cam_info.sec_cam_idx = sec_cam_idx;
+	sec_cam_info.offset = 0x00;
+	sec_cam_info.len = SEC_CAM_ENTRY_SIZE;
+
+	fill_sec_cam_info(adapter, &sec_cam_info,
+			  (struct fwcmd_seccam_info *)sec_table, 1);
+
+	ret = (u8)mac_upd_sec_infotbl(adapter,
+				      (struct fwcmd_seccam_info *)sec_table);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	m_security_cam_hal(adapter, NULL,
+			   mac_id, key_id, key_type,
+			   sec_cam_idx, 1);
+
+	return MACSUCCESS;
+}
+
+u32 mac_sta_add_key(struct mac_ax_adapter *adapter,
+		    struct mac_ax_sec_cam_info *sec_cam_info,
+		    u8 mac_id,
+		    u8 key_id,
+		    u8 key_type)
+{
+	u8 sec_cam_idx = 0;
+	u32 sec_table[6] = {0}, ret = 0;
+	struct mac_role_tbl *role = NULL;
+
+	if (sec_cam_info->type > HW_SUPPORT_ENC_TYPE_NUM)
+		return MACWNGKEYTYPE;
+
+	role = mac_role_srch(adapter, mac_id);
+	if (!role)
+		return MACNOROLE;
+
+	ret = decide_sec_cam_index(adapter, &sec_cam_idx);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	sec_cam_info->sec_cam_idx = sec_cam_idx;
+	sec_cam_info->offset = 0x00;
+	sec_cam_info->len = SEC_CAM_ENTRY_SIZE;
+	ret = insert_key_to_addr_cam(adapter, role, key_type, key_id,
+				     sec_cam_info->sec_cam_idx);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	fill_sec_cam_info(adapter, sec_cam_info,
+			  (struct fwcmd_seccam_info *)sec_table, 0);
+
+	ret = (u8)mac_upd_sec_infotbl(adapter,
+				      (struct fwcmd_seccam_info *)sec_table);
+	if (ret != MACSUCCESS)
+		return ret;
+	m_security_cam_hal(adapter, sec_cam_info,
+			   mac_id, key_id, key_type,
+			   sec_cam_idx, 0);
+
+	return MACSUCCESS;
+}
+
+u32 mac_sta_search_key_idx(struct mac_ax_adapter *adapter,
+			   u8 mac_id, u8 key_id, u8 key_type)
+{
+	u32 sec_cam_idx = 0;
+	struct sec_cam_entry_t *s_entry = NULL;
+	struct sec_cam_table_t *sec_cam_table =
+		adapter->hw_info->sec_cam_table;
+
+	if (!sec_cam_table)
+		return MACNOKEYINDEX;
+
+	/*Search SEC CAM Table */
+	for (sec_cam_idx = 0; sec_cam_idx < SEC_CAM_ENTRY_NUM; sec_cam_idx++) {
+		/* Only search valid entry */
+		if (sec_cam_table->sec_cam_entry[sec_cam_idx]->valid == VALID) {
+			s_entry = sec_cam_table->sec_cam_entry[sec_cam_idx];
+
+			if (s_entry->mac_id != mac_id)
+				continue;
+			if (s_entry->key_id != key_id)
+				continue;
+			if (s_entry->key_type != key_type)
+				continue;
+
+			return sec_cam_idx;
+		}
+	}
+	return MACNOKEYINDEX;
+}
+
+u32 mac_sta_hw_security_support(struct mac_ax_adapter *adapter,
+				u8 hw_security_support_type, u8 enable)
+{
+	u32 val32 = 0;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	switch (enable) {
+	case 1:
+		val32 = MAC_REG_R32(R_AX_SEC_ENG_CTRL);
+		switch (hw_security_support_type) {
+		case SEC_TX_ENC:
+			val32 |= B_AX_SEC_TX_ENC;
+			break;
+		case SEC_RX_ENC:
+			val32 |= B_AX_SEC_RX_DEC;
+			break;
+		case SEC_BC_ENC:
+			val32 |= B_AX_BC_DEC;
+			break;
+		case SEC_MC_ENC:
+			val32 |= B_AX_MC_DEC;
+			break;
+		case SEC_UC_MGNT_ENC:
+			val32 |= B_AX_UC_MGNT_DEC;
+			break;
+		case SEC_BMC_MGNT_ENC:
+			val32 |= B_AX_BMC_MGNT_DEC;
+			break;
+		default:
+			break;
+		}
+		MAC_REG_W32(R_AX_SEC_ENG_CTRL, val32);
+		break;
+	case 0:
+		val32 = MAC_REG_R32(R_AX_SEC_ENG_CTRL);
+		switch (hw_security_support_type) {
+		case SEC_TX_ENC:
+			val32 &= ~B_AX_SEC_TX_ENC;
+			break;
+		case SEC_RX_ENC:
+			val32 &= ~B_AX_SEC_RX_DEC;
+			break;
+		case SEC_BC_ENC:
+			val32 &= ~B_AX_BC_DEC;
+			break;
+		case SEC_MC_ENC:
+			val32 &= ~B_AX_MC_DEC;
+			break;
+		case SEC_UC_MGNT_ENC:
+			val32 &= ~B_AX_UC_MGNT_DEC;
+			break;
+		case SEC_BMC_MGNT_ENC:
+			val32 &= ~B_AX_BMC_MGNT_DEC;
+			break;
+		default:
+			break;
+		}
+
+		MAC_REG_W32(R_AX_SEC_ENG_CTRL, val32);
+		break;
+	default:
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+u8 check_key_type(u8 addr_cam_sec_mode, u8 key_index)
+{
+	switch (addr_cam_sec_mode) {
+	case ADDR_CAM_SEC_MODE_ZERO:
+		if (key_index <= 6)
+			return SEC_CAM_KEY_TYPE_UNI;
+	break;
+
+	case ADDR_CAM_SEC_MODE_ONE:
+		if (key_index <= 6)
+			return SEC_CAM_KEY_TYPE_UNI;
+	break;
+
+	case ADDR_CAM_SEC_MODE_TWO:
+		if (key_index <= 1)
+			return SEC_CAM_KEY_TYPE_UNI;
+
+		else if (key_index >= 2 && key_index <= 4)
+			return SEC_CAM_KEY_TYPE_GROUP;
+
+		else if (key_index >= 5 && key_index <= 6)
+			return SEC_CAM_KEY_TYPE_BIP;
+
+		else
+			break;
+	break;
+
+	case ADDR_CAM_SEC_MODE_THREE:
+		if (key_index <= 1)
+			return SEC_CAM_KEY_TYPE_UNI;
+
+		else if (key_index >= 2 && key_index <= 5)
+			return SEC_CAM_KEY_TYPE_GROUP;
+
+		else if (key_index == 6)
+			return SEC_CAM_KEY_TYPE_BIP;
+
+		else
+			break;
+	break;
+	}
+
+	return MACKEYNOTEXT;
+}
+
+u32 refresh_security_cam_info(struct mac_ax_adapter *adapter,
+			      u8 mac_id)
+{
+	u32 addr_idx = 0, cam_address = 0;
+	u32 i = 0;
+	u8 key_valid[7] = {0}, key_cam_index[7] = {0}, sec_ent_keyid[7] = {0};
+	u8 macid = 0, hit_flag = VALID, key_id_sh = 0, key_cam_idx_sh = 0;
+	u8 key_valid_byte = 0, key_valid_byte_ori = 0, key_type = 0;
+	u8 key_index = 0, sec_ent_mode = 0, sec_cam_idx = 0;
+	u32 dword[10] = {0};
+	u8 addr_cam_size = get_addr_cam_size(adapter);
+
+	struct sec_cam_entry_t *s_entry = NULL;
+	struct sec_cam_table_t *sec_cam_table = adapter->hw_info->sec_cam_table;
+	struct mac_role_tbl *role = NULL;
+
+	/*read HW key in address cam */
+	for (addr_idx = 0; addr_idx < 0x80; addr_idx++) {
+		hit_flag = INVALID;
+
+		PLTFM_MSG_WARN("%s ind access macid %d start\n", __func__, mac_id);
+		cam_address = addr_idx * addr_cam_size;
+		for (i = 0; i < 10; i++) {
+			dword[i] = mac_sram_dbg_read(adapter, cam_address + (i * 4),
+						     ADDR_CAM_SEL);
+			PLTFM_MSG_WARN("CAMADDR<%x>=%x\n", cam_address, dword[i]);
+		}
+		PLTFM_MSG_WARN("%s ind access macid %d end\n", __func__, mac_id);
+
+		if ((dword[0] & ADDRCAM_VALID) == VALID) {
+			macid = (dword[6] & ADDRCAM_MACID_MSK);
+
+			if (macid == mac_id) {
+				sec_ent_mode = (dword[7] >> ADDRCAM_SEC_MODE_SH)
+						& ADDRCAM_SECMODE_MSK;
+
+				key_id_sh = ADDRCAM_SEC_ENT0_KEYID_SH;
+				for (i = 0; i < 7; i++) {
+					sec_ent_keyid[i] =
+						(dword[7] >> key_id_sh) &
+						ADDRCAM_KEYID_MSK;
+					key_id_sh += 2;
+				}
+
+				key_valid_byte =
+					dword[8] & ADDRCAM_KEY_VALID_MSK;
+				key_valid_byte_ori = key_valid_byte;
+
+				for (i = 0; i < 7; i++) {
+					key_valid[i] = key_valid_byte % 2;
+					key_valid_byte = key_valid_byte >> 1;
+				}
+
+				key_cam_idx_sh = 0;
+				for (i = 0; i < 3; i++) {
+					key_cam_idx_sh = (i + 1) * 8;
+					key_cam_index[i] =
+						(dword[8] >> key_cam_idx_sh) &
+						ADDRCAM_KEY_CAM_IDX_MSK;
+				}
+
+				key_cam_idx_sh = 0;
+				for (i = 3; i < 7; i++) {
+					key_cam_idx_sh = (i - 3) * 8;
+					key_cam_index[i] =
+						(dword[9] >> key_cam_idx_sh) &
+						ADDRCAM_KEY_CAM_IDX_MSK;
+				}
+
+				hit_flag = VALID;
+				break;
+			}
+		}
+	}
+
+	if (hit_flag == INVALID) {
+		PLTFM_MSG_ALWAYS("MACID : %d not exist\n", mac_id);
+		return MACNOROLE;
+	}
+
+	// clear halmac table
+	for (sec_cam_idx = 0; sec_cam_idx < SEC_CAM_ENTRY_NUM; sec_cam_idx++) {
+		// Only search valid entry
+		if (sec_cam_table->sec_cam_entry[sec_cam_idx]->valid == VALID) {
+			s_entry = sec_cam_table->sec_cam_entry[sec_cam_idx];
+
+			if (s_entry->mac_id == mac_id) {
+				m_security_cam_hal(adapter, NULL,
+						   mac_id, DEFAULT_KEYID,
+						   DEFAULT_KEYTYPE,
+						   sec_cam_idx, 1);
+			}
+		}
+	}
+
+	// insert halmac table
+	for (key_index = 0; key_index < 7; key_index++) {
+		if (key_valid[key_index] == VALID) {
+			key_type = check_key_type(sec_ent_mode, key_index);
+			m_security_cam_hal(adapter, NULL,
+					   mac_id, sec_ent_keyid[key_index],
+					   key_type,
+					   key_cam_index[key_index], 0);
+		}
+	}
+
+	// write back to address cam sec part
+	role = mac_role_srch(adapter, mac_id);
+	if (!role) {
+		PLTFM_MSG_ALWAYS("%s mac_role_srch fail\n", __func__);
+		return MACNOROLE;
+	}
+
+	role->info.a_info.sec_ent_valid = key_valid_byte_ori;
+	for (i = 0; i < 7; i++) {
+		role->info.a_info.sec_ent_keyid[i] = sec_ent_keyid[i];
+		role->info.a_info.sec_ent[i] = key_cam_index[i];
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_wowlan_secinfo(struct mac_ax_adapter *adapter,
+		       struct mac_ax_sec_iv_info *sec_iv_info)
+{
+	u8 mac_id = 0;
+	u32 ret = 0;
+	struct mac_role_tbl *role = NULL;
+	struct dctl_secinfo_entry_t *dctl_secinfo_entry = NULL;
+	struct dctl_sec_info_t *dctl_sec_info = adapter->hw_info->dctl_sec_info;
+
+	/*check dmac tbl is valid*/
+	if (!dctl_sec_info)
+		return MACNOKEYINDEX;
+
+	mac_id = sec_iv_info->macid;
+	/*check mac_id role is valid*/
+	role = mac_role_srch(adapter, mac_id);
+	if (!role)
+		return MACNOROLE;
+
+	/*get some decide key index info*/
+	dctl_secinfo_entry = dctl_sec_info->dctl_secinfo_entry[mac_id];
+
+	switch (sec_iv_info->opcode) {
+	case SEC_IV_UPD_TYPE_WRITE:
+		break;
+	case SEC_IV_UPD_TYPE_READ:
+		ret = refresh_security_cam_info(adapter, mac_id);
+		break;
+	default:
+
+		break;
+	}
+
+	return MACSUCCESS;
+}
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/security_cam.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/security_cam.h
new file mode 100644
index 000000000000..a8cbb65bc48a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/security_cam.h
@@ -0,0 +1,352 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_SEC_CAM_H_
+#define _MAC_AX_SEC_CAM_H_
+
+#include "../mac_def.h"
+#include "role.h"
+#include "fwcmd.h"
+#include "addr_cam.h"
+
+/*--------------------Define ----------------------------------------*/
+#ifdef PHL_FEATURE_AP
+	#define SEC_CAM_ENTRY_NUM	0x80
+#else
+	#define SEC_CAM_ENTRY_NUM	0x10
+#endif
+
+#define ADDRCAM_VALID BIT0
+#define ADDRCAM_SEC_MODE_SH 16
+#define ADDRCAM_SEC_ENT0_KEYID_SH 18
+#define ADDRCAM_SEC_ENT0_KEYID_SH 18
+
+#define ADDRCAM_KEYID_MSK 0x3
+#define ADDRCAM_SECMODE_MSK 0x3
+#define ADDRCAM_MACID_MSK 0xFF
+#define ADDRCAM_KEY_VALID_MSK 0xFF
+#define ADDRCAM_KEY_CAM_IDX_MSK 0xFF
+
+#define ADDRCAM_VALID_BIT_OFFSET 0x00
+#define ADDRCAM_MACID_OFFSET 0x18
+#define ADDRCAM_SECMODE_OFFSET 0x1C
+#define ADDRCAM_KEY_VALID_OFFSET 0x20
+#define ADDRCAM_KEY_IDX_OFFSET 0x21
+
+#define SEC_CAM_ENTRY_SIZE	0x20
+#define ADDR_CAM_ENTRY_SIZE	0x40
+#define MACNOKEYINDEX		0xFF
+
+#define DEFAULT_KEYID		0x0
+#define DEFAULT_KEYTYPE		0x0
+
+#define MACID_ENTRY_NUM		0x80
+#define KEYNUM_PER_MACID	0x07
+
+/*--------------------DSecurity cam type declaration-----------------*/
+
+/**
+ * @struct sec_cam_entry_t
+ * @brief sec_cam_entry_t
+ *
+ * @var sec_cam_entry_t::valid
+ * Please Place Description here.
+ * @var sec_cam_entry_t::mac_id
+ * Please Place Description here.
+ * @var sec_cam_entry_t::key_id
+ * Please Place Description here.
+ * @var sec_cam_entry_t::key_type
+ * Please Place Description here.
+ * @var sec_cam_entry_t::sec_cam_info
+ * Please Place Description here.
+ */
+struct sec_cam_entry_t {
+	u8 valid;
+	u8 mac_id;
+	u8 key_id;
+	u8 key_type;
+	struct mac_ax_sec_cam_info *sec_cam_info;
+};
+
+struct dctl_secinfo_entry_t {
+	u16 aes_iv_l;
+	u32 aes_iv_h;
+	u8 sec_keyid;
+	u8 wapi_ctrl;
+	u8 sec_ent_valid;
+	u8 sec_ent_keyid[7];
+	u8 sec_ent[7];
+};
+
+/**
+ * @struct sec_cam_table_t
+ * @brief sec_cam_table_t
+ *
+ * @var sec_cam_table_t::sec_cam_entry
+ * Please Place Description here.
+ * @var sec_cam_table_t::next_cam_storage_idx
+ * Please Place Description here.
+ */
+struct sec_cam_table_t {
+	struct sec_cam_entry_t *sec_cam_entry[128];
+	u8 next_cam_storage_idx;
+};
+
+struct dctl_sec_info_t {
+	struct dctl_secinfo_entry_t *dctl_secinfo_entry[MACID_ENTRY_NUM];
+};
+
+/**
+ * @enum SEC_FUNCTION_TYPE
+ *
+ * @brief SEC_FUNCTION_TYPE
+ *
+ * @var SEC_FUNCTION_TYPE::SEC_TX_ENC
+ * Please Place Description here.
+ * @var SEC_FUNCTION_TYPE::SEC_RX_ENC
+ * Please Place Description here.
+ * @var SEC_FUNCTION_TYPE::SEC_BC_ENC
+ * Please Place Description here.
+ * @var SEC_FUNCTION_TYPE::SEC_MC_ENC
+ * Please Place Description here.
+ * @var SEC_FUNCTION_TYPE::SEC_UC_MGNT_ENC
+ * Please Place Description here.
+ * @var SEC_FUNCTION_TYPE::SEC_BMC_MGNT_ENC
+ * Please Place Description here.
+ */
+enum SEC_FUNCTION_TYPE {
+	SEC_TX_ENC = 0,
+	SEC_RX_ENC = 1,
+	SEC_BC_ENC = 2,
+	SEC_MC_ENC = 3,
+	SEC_UC_MGNT_ENC  = 4,
+	SEC_BMC_MGNT_ENC = 5,
+};
+
+enum SEC_IV_UPD_TYPE {
+	SEC_IV_UPD_TYPE_NONE = 0,
+	SEC_IV_UPD_TYPE_WRITE = 1,
+	SEC_IV_UPD_TYPE_READ = 2
+};
+
+/*--------------------Funciton declaration----------------------------*/
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup Security
+ * @{
+ */
+
+/**
+ * @brief disconnect_flush_key
+ *
+ * @param *adapter
+ * @param *role
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 disconnect_flush_key(struct mac_ax_adapter *adapter,
+			 struct mac_role_tbl *role);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup Security
+ * @{
+ */
+
+/**
+ * @brief sec_info_tbl_init
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 sec_info_tbl_init(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup Security
+ * @{
+ */
+
+/**
+ * @brief free_sec_info_tbl
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 free_sec_info_tbl(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup Security
+ * @{
+ */
+
+/**
+ * @brief fill_sec_cam_info
+ *
+ * @param *adapter
+ * @param *s_info
+ * @param *sec_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 fill_sec_cam_info(struct mac_ax_adapter *adapter,
+		      struct mac_ax_sec_cam_info *s_info,
+		      struct fwcmd_seccam_info *sec_info,
+		      u8 clear);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup Security
+ * @{
+ */
+
+/**
+ * @brief mac_sta_add_key
+ *
+ * @param *adapter
+ * @param *sec_cam_content
+ * @param mac_id
+ * @param key_id
+ * @param key_type
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_sta_add_key(struct mac_ax_adapter *adapter,
+		    struct mac_ax_sec_cam_info *sec_cam_content,
+		    u8 mac_id,
+		    u8 key_id,
+		    u8 key_type);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup Security
+ * @{
+ */
+
+/**
+ * @brief mac_sta_del_key
+ *
+ * @param *adapter
+ * @param mac_id
+ * @param key_id
+ * @param key_type
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_sta_del_key(struct mac_ax_adapter *adapter,
+		    u8 mac_id,
+		    u8 key_id,
+		    u8 key_type);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup Security
+ * @{
+ */
+
+/**
+ * @brief mac_sta_search_key_idx
+ *
+ * @param *adapter
+ * @param mac_id
+ * @param key_id
+ * @param key_type
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_sta_search_key_idx(struct mac_ax_adapter *adapter,
+			   u8 mac_id, u8 key_id, u8 key_type);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup Security
+ * @{
+ */
+
+/**
+ * @brief mac_sta_hw_security_support
+ *
+ * @param *adapter
+ * @param hw_security_support_type
+ * @param enable
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_sta_hw_security_support(struct mac_ax_adapter *adapter,
+				u8 hw_security_support_type, u8 enable);
+/**
+ * @}
+ * @}
+ */
+
+u32 refresh_security_cam_info(struct mac_ax_adapter *adapter,
+			      u8 mac_id);
+/**
+ * @}
+ * @}
+ */
+
+u32 mac_wowlan_secinfo(struct mac_ax_adapter *adapter,
+		       struct mac_ax_sec_iv_info *sec_iv_info);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/ser.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/ser.c
new file mode 100644
index 000000000000..8425d192b9ea
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/ser.c
@@ -0,0 +1,1541 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "ser.h"
+#include "mac_priv.h"
+
+#define DBG_SENARIO_SH 28
+
+#define L0_TO_L1_EVENT_SH 28
+#define L0_TO_L1_EVENT_MSK 0xF
+
+enum mac_ax_l0_to_l1_event {
+	MAC_AX_L0_TO_L1_CHIF_IDLE = 0,
+	MAC_AX_L0_TO_L1_CMAC_DMA_IDLE = 1,
+	MAC_AX_L0_TO_L1_RLS_PKID = 2,
+	MAC_AX_L0_TO_L1_PTCL_IDLE = 3,
+	MAC_AX_L0_TO_L1_RX_QTA_LOST = 4,
+	MAC_AX_L0_TO_L1_DLE_STAT_HANG = 5,
+	MAC_AX_L0_TO_L1_PCIE_STUCK = 6,
+	MAC_AX_L0_TO_L1_EVENT_MAX = 15,
+};
+
+enum mac_ax_halt_h2c_info {
+	MAC_AX_L0_DBG_MODE = 0x10,
+	MAC_AX_L1_DBG_MODE = 0x17,
+};
+
+static void dump_err_status_dispatcher(struct mac_ax_adapter *adapter);
+static void dump_err_status_dmac(struct mac_ax_adapter *adapter);
+static void dump_err_status_cmac(struct mac_ax_adapter *adapter, u8 band);
+static void dump_cmac_cr(struct mac_ax_adapter *adapter, u8 band);
+static void dump_dmac_cr(struct mac_ax_adapter *adapter);
+
+u32 mac_dbg_log_dump(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_dbgpkg dbg_val;
+	struct mac_ax_dbgpkg_en dbg_en;
+	u32 error = 0, dbg_port_dump_en = 0, val32, mem_size;
+
+	error = (enum mac_ax_err_info)MAC_REG_R32(R_AX_HALT_C2H);
+
+	switch (error) {
+	case MAC_AX_ERR_L1_ERR_DMAC:
+	case MAC_AX_ERR_L0_PROMOTE_TO_L1:
+		PLTFM_MEMSET(&dbg_en, 0, sizeof(struct mac_ax_dbgpkg_en));
+		if (adapter->ser_info.dbg_lvl.dmac_dbg_dump) {
+			dbg_en.dmac_dbg = 1;
+			dbg_port_dump_en = 1;
+		}
+		if (adapter->ser_info.dbg_lvl.cmac_dbg_dump) {
+			dbg_en.cmac_dbg = 1;
+			dbg_port_dump_en = 1;
+		}
+		if (adapter->ser_info.dbg_lvl.txflow_dbg_dump) {
+			dbg_en.tx_flow_dbg = 1;
+			dbg_port_dump_en = 1;
+		}
+		if (adapter->ser_info.dbg_lvl.dbgprt_dump) {
+			dbg_en.mac_dbg_port = 1;
+			dbg_en.dle_dbg = 1;
+			dbg_port_dump_en = 1;
+		}
+
+		if (dbg_port_dump_en) {
+			// for debug port log would cause fw wdt
+			val32 = MAC_REG_R32(R_AX_HIMR0);
+			val32 &= ~B_AX_WDT_TIMEOUT_INT_EN;
+			MAC_REG_W32(R_AX_HIMR0, val32);
+			mac_dbg_status_dump(adapter, &dbg_val, &dbg_en);
+			val32 = MAC_REG_R32(R_AX_HIMR0);
+			val32 |= B_AX_WDT_TIMEOUT_INT_EN;
+			MAC_REG_W32(R_AX_HIMR0, val32);
+		}
+		if (adapter->ser_info.dbg_lvl.share_mem_dump) {
+			mem_size = mac_get_mem_size(adapter, MAC_AX_MEM_SHARED_BUF);
+			val32 = MAC_REG_R32(R_AX_HIMR0);
+			val32 &= ~B_AX_WDT_TIMEOUT_INT_EN;
+			MAC_REG_W32(R_AX_HIMR0, val32);
+			mac_mem_dump(adapter, MAC_AX_MEM_SHARED_BUF, 0x0, NULL, mem_size, 0);
+			val32 = MAC_REG_R32(R_AX_HIMR0);
+			val32 |= B_AX_WDT_TIMEOUT_INT_EN;
+			MAC_REG_W32(R_AX_HIMR0, val32);
+		}
+
+		if (adapter->ser_info.dbg_lvl.mac_reg_dump)
+			mac_reg_dump(adapter, MAC_AX_REG_MAC);
+		break;
+	case MAC_AX_ERR_L1_RESET_DISABLE_DMAC_DONE:
+		break;
+	case MAC_AX_ERR_L1_RESET_RECOVERY_DONE:
+		break;
+	default:
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_dbg_log_lvl_adjust(struct mac_ax_adapter *adapter, struct mac_debug_log_lvl *lvl)
+{
+	adapter->ser_info.dbg_lvl.dbgprt_dump = lvl->dbgprt_dump;
+	adapter->ser_info.dbg_lvl.share_mem_dump = lvl->share_mem_dump;
+	adapter->ser_info.dbg_lvl.cmac_dbg_dump = lvl->cmac_dbg_dump;
+	adapter->ser_info.dbg_lvl.dmac_dbg_dump = lvl->dmac_dbg_dump;
+	adapter->ser_info.dbg_lvl.txflow_dbg_dump = lvl->txflow_dbg_dump;
+	adapter->ser_info.dbg_lvl.mac_reg_dump = lvl->mac_reg_dump;
+
+	return MACSUCCESS;
+}
+
+u32 mac_trigger_cmac_err(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val8;
+	u16 val16;
+	u32 ret;
+
+	ret = check_mac_en(adapter, MAC_AX_BAND_0, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	val8 = MAC_REG_R8(R_AX_CMAC_FUNC_EN);
+	MAC_REG_W8(R_AX_CMAC_FUNC_EN, val8 & (~B_AX_TMAC_EN));
+	PLTFM_DELAY_MS(1);
+	MAC_REG_W8(R_AX_CMAC_FUNC_EN, val8);
+
+	val16 = MAC_REG_R16(R_AX_PTCL_IMR0) | B_AX_F2PCMD_EMPTY_ERR_INT_EN;
+	MAC_REG_W16(R_AX_PTCL_IMR0, val16);
+	MAC_REG_W16(R_AX_PTCL_IMR0, val16 & ~B_AX_F2PCMD_EMPTY_ERR_INT_EN);
+
+	return MACSUCCESS;
+}
+
+u32 mac_trigger_cmac1_err(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val8;
+	u16 val16;
+	u32 ret;
+
+	ret = check_mac_en(adapter, MAC_AX_BAND_1, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	val8 = MAC_REG_R8(R_AX_CMAC_FUNC_EN_C1);
+	MAC_REG_W8(R_AX_CMAC_FUNC_EN_C1, val8 & (~B_AX_TMAC_EN));
+	PLTFM_DELAY_MS(1);
+	MAC_REG_W8(R_AX_CMAC_FUNC_EN_C1, val8);
+
+	val16 = MAC_REG_R16(R_AX_PTCL_IMR0_C1) | B_AX_F2PCMD_EMPTY_ERR_INT_EN;
+	MAC_REG_W16(R_AX_PTCL_IMR0_C1, val16);
+	MAC_REG_W16(R_AX_PTCL_IMR0_C1, val16 & ~B_AX_F2PCMD_EMPTY_ERR_INT_EN);
+
+	return MACSUCCESS;
+}
+
+u32 mac_trigger_dmac_err(struct mac_ax_adapter *adapter)
+{
+	struct cpuio_buf_req_t buf_req;
+	struct cpuio_ctrl_t ctrl_para;
+	u32 ret;
+
+	// Use CPUIO to enqueue packet.
+	//WD
+	buf_req.len = 0x20;
+	ret = mac_dle_buf_req_wd(adapter, &buf_req);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]WDE DLE buf req\n");
+		return ret;
+	}
+
+	// Enqueue two pkt_id, but only has one pkt_id.
+	PLTFM_MEMSET((void *)&ctrl_para, 0, sizeof(ctrl_para));
+	ctrl_para.cmd_type = CPUIO_OP_CMD_ENQ_TO_HEAD;
+	ctrl_para.start_pktid = buf_req.pktid;
+	ctrl_para.end_pktid = buf_req.pktid;
+	ctrl_para.pkt_num = 1;
+	ctrl_para.dst_pid = WDE_DLE_PORT_ID_WDRLS;
+	ctrl_para.dst_qid = 4;
+	ret = mac_set_cpuio_wd(adapter, &ctrl_para);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]WDE DLE enqueue to head\n");
+		return ret;
+	}
+	return MACSUCCESS;
+}
+
+u32 mac_dump_qta_lost(struct mac_ax_adapter *adapter)
+{
+	struct dle_dfi_qempty_t qempty;
+	struct dle_dfi_quota_t quota;
+	struct dle_dfi_ctrl_t ctrl;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret, val, not_empty, i;
+
+	qempty.dle_type = DLE_CTRL_TYPE_PLE;
+	qempty.grpsel = 0;
+	ret = dle_dfi_qempty(adapter, &qempty);
+	if (ret == MACSUCCESS)
+		PLTFM_MSG_ALWAYS("DLE group0 empty: 0x%x\n", qempty.qempty);
+	else
+		PLTFM_MSG_ERR("%s: query DLE fail\n", __func__);
+
+	for (not_empty = ~qempty.qempty, i = 0;
+	     not_empty != 0; not_empty = not_empty >> 1, i++) {
+		if (!(not_empty & BIT(0)))
+			continue;
+		ctrl.type = DLE_CTRL_TYPE_PLE;
+		ctrl.target = DLE_DFI_TYPE_QLNKTBL;
+		ctrl.addr = (QLNKTBL_ADDR_INFO_SEL_0 ?
+			     QLNKTBL_ADDR_INFO_SEL : 0) |
+			SET_WORD(i, QLNKTBL_ADDR_TBL_IDX);
+		ret = p_ops->dle_dfi_ctrl(adapter, &ctrl);
+		if (ret == MACSUCCESS)
+			PLTFM_MSG_ALWAYS("qidx%d pktcnt = %d\n", i,
+					 GET_FIELD(ctrl.out_data,
+						   QLNKTBL_DATA_SEL1_PKT_CNT));
+		else
+			PLTFM_MSG_ERR("%s: query DLE fail\n", __func__);
+	}
+
+	/* cmac0 */
+	quota.dle_type = DLE_CTRL_TYPE_PLE;
+	quota.qtaid = 6;
+	ret = dle_dfi_quota(adapter, &quota);
+	if (ret == MACSUCCESS)
+		PLTFM_MSG_ALWAYS("quota6 rsv/use: 0x%x/0x%x\n",
+				 quota.rsv_pgnum, quota.use_pgnum);
+	else
+		PLTFM_MSG_ERR("%s: query DLE fail\n", __func__);
+
+	val = MAC_REG_R32(R_AX_PLE_QTA6_CFG);
+	PLTFM_MSG_ALWAYS("[PLE][CMAC0_RX]min_pgnum=0x%x\n",
+			 GET_FIELD(val, B_AX_PLE_Q6_MIN_SIZE));
+	PLTFM_MSG_ALWAYS("[PLE][CMAC0_RX]max_pgnum=0x%x\n",
+			 GET_FIELD(val, B_AX_PLE_Q6_MAX_SIZE));
+
+	val = MAC_REG_R32(R_AX_RX_FLTR_OPT);
+	PLTFM_MSG_ALWAYS("[CMAC0_RX]B_AX_RX_MPDU_MAX_LEN=0x%x\n",
+			 GET_FIELD(val, B_AX_RX_MPDU_MAX_LEN));
+
+	val = MAC_REG_R32(R_AX_RSP_CHK_SIG);
+	PLTFM_MSG_ALWAYS("R_AX_RSP_CHK_SIG=0x%x\n",
+			 val);
+
+	val = MAC_REG_R32(R_AX_TRXPTCL_RESP_0);
+	PLTFM_MSG_ALWAYS("R_AX_TRXPTCL_RESP_0=0x%x\n",
+			 val);
+
+	val = MAC_REG_R32(R_AX_CCA_CONTROL);
+	PLTFM_MSG_ALWAYS("R_AX_CCA_CONTROL=0x%x\n",
+			 val);
+
+	/* cmac1 */
+	ret = check_mac_en(adapter, 1, MAC_AX_CMAC_SEL);
+
+	if (ret == MACSUCCESS) {
+		quota.dle_type = DLE_CTRL_TYPE_PLE;
+		quota.qtaid = 7;
+		ret = dle_dfi_quota(adapter, &quota);
+		if (ret == MACSUCCESS)
+			PLTFM_MSG_ALWAYS("quota7 rsv/use: 0x%x/0x%x\n",
+					 quota.rsv_pgnum, quota.use_pgnum);
+		else
+			PLTFM_MSG_ERR("%s: query DLE fail\n", __func__);
+
+		val = MAC_REG_R32(R_AX_PLE_QTA7_CFG);
+		PLTFM_MSG_ALWAYS("[PLE][CMAC1_RX]min_pgnum=0x%x\n",
+				 GET_FIELD(val, B_AX_PLE_Q7_MIN_SIZE));
+		PLTFM_MSG_ALWAYS("[PLE][CMAC1_RX]max_pgnum=0x%x\n",
+				 GET_FIELD(val, B_AX_PLE_Q7_MAX_SIZE));
+
+		val = MAC_REG_R32(R_AX_RX_FLTR_OPT_C1);
+		PLTFM_MSG_ALWAYS("[CMAC1_RX]B_AX_RX_MPDU_MAX_LEN=0x%x\n",
+				 GET_FIELD(val, B_AX_RX_MPDU_MAX_LEN));
+
+		val = MAC_REG_R32(R_AX_RSP_CHK_SIG_C1);
+		PLTFM_MSG_ALWAYS("R_AX_RSP_CHK_SIG_C1=0x%x\n",
+				 val);
+
+		val = MAC_REG_R32(R_AX_TRXPTCL_RESP_0_C1);
+		PLTFM_MSG_ALWAYS("R_AX_TRXPTCL_RESP_0_C1=0x%x\n",
+				 val);
+
+		val = MAC_REG_R32(R_AX_CCA_CONTROL_C1);
+		PLTFM_MSG_ALWAYS("R_AX_CCA_CONTROL_C1=0x%x\n",
+				 val);
+	}
+
+	val = MAC_REG_R32(R_AX_DLE_EMPTY0);
+	PLTFM_MSG_ALWAYS("R_AX_DLE_EMPTY0=0x%x\n",
+			 val);
+
+	val = MAC_REG_R32(R_AX_DLE_EMPTY1);
+	PLTFM_MSG_ALWAYS("R_AX_DLE_EMPTY1=0x%x\n",
+			 val);
+
+	dump_err_status_dispatcher(adapter);
+
+	return MACSUCCESS;
+}
+
+u32 mac_dump_l0_to_l1(struct mac_ax_adapter *adapter,
+		      enum mac_ax_err_info err)
+{
+	u32 dbg, event;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	PLTFM_MSG_ALWAYS("%s\n", __func__);
+
+	dbg = MAC_REG_R32(R_AX_SER_DBG_INFO);
+	event = GET_FIELD(dbg, L0_TO_L1_EVENT);
+
+	switch (event) {
+	case MAC_AX_L0_TO_L1_RX_QTA_LOST:
+		PLTFM_MSG_ALWAYS("quota lost!\n");
+		mac_dump_qta_lost(adapter);
+		break;
+	default:
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_dump_err_status(struct mac_ax_adapter *adapter,
+			enum mac_ax_err_info err)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_dbgpkg dbg_val;
+	struct mac_ax_dbgpkg_en dbg_en;
+	u32 cmac_err, dmac_err;
+	u8 val8;
+	u32 ret, i, mem_size;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	PLTFM_MSG_ERR("--->\n err=0x%x\n", err);
+	if (err == MAC_AX_ERR_L1_ERR_DMAC ||
+	    err == MAC_AX_ERR_L0_PROMOTE_TO_L1 ||
+	    err == MAC_AX_ERR_L0_ERR_CMAC0 ||
+	    err == MAC_AX_ERR_L0_ERR_CMAC1 ||
+	    err == HALT_C2H_L1_DBG_MODE ||
+	    err == MAC_AX_ERR_L0_PROMOTE_TO_L1_DBG) {
+		PLTFM_MSG_ERR("R_AX_SER_DBG_INFO =0x%08x\n",
+			      MAC_REG_R32(R_AX_SER_DBG_INFO));
+		PLTFM_MSG_ERR("DBG Counter 1 (0x1C0)=0x%08x\n",
+			      MAC_REG_R32(0x1C0));
+		PLTFM_MSG_ERR("DBG Counter 2 (0x1C4)=0x%08x\n",
+			      MAC_REG_R32(0x1C4));
+
+		dump_err_status_dmac(adapter);
+		dump_err_status_cmac(adapter, MAC_AX_BAND_0);
+		dump_err_status_cmac(adapter, MAC_AX_BAND_1);
+
+		if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+#if (MAC_AX_8852A_SUPPORT) || (MAC_AX_8852B_SUPPORT) || (MAC_AX_8851B_SUPPORT)
+			if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+			    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+			    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+				PLTFM_MSG_ERR("R_AX_DBG_ERR_FLAG=0x%08x\n",
+					      MAC_REG_R32(R_AX_DBG_ERR_FLAG));
+				PLTFM_MSG_ERR("R_AX_LBC_WATCHDOG=0x%08x\n",
+					      MAC_REG_R32(R_AX_LBC_WATCHDOG));
+			}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+			if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+			    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+			    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+			    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+				PLTFM_MSG_ERR("R_AX_DBG_ERR_FLAG=0x%08x\n",
+					      MAC_REG_R32(R_AX_DBG_ERR_FLAG_V1));
+				PLTFM_MSG_ERR("R_AX_LBC_WATCHDOG=0x%08x\n",
+					      MAC_REG_R32(R_AX_LBC_WATCHDOG_V1));
+			}
+#endif
+		}
+		if (err == MAC_AX_ERR_L0_PROMOTE_TO_L1 ||
+		    err == MAC_AX_ERR_L0_PROMOTE_TO_L1_DBG)
+			mac_dump_l0_to_l1(adapter, err);
+	}
+	if (err == MAC_AX_ERR_L0_ERR_CMAC0 ||
+	    err == MAC_AX_ERR_L0_ERR_CMAC1 ||
+	    err == HALT_C2H_L1_DBG_MODE ||
+	    err == MAC_AX_ERR_CPU_EXCEPTION ||
+	    err == MAC_AX_ERR_ASSERTION ||
+	    err == MAC_AX_ERR_RXI300 ||
+	    err == MAC_AX_ERR_L0_PROMOTE_TO_L1_DBG) {
+		cmac_err = MAC_REG_R32(R_AX_CMAC_ERR_ISR);
+		dmac_err = MAC_REG_R32(R_AX_DMAC_ERR_ISR);
+		dump_dmac_cr(adapter);
+		dump_cmac_cr(adapter, MAC_AX_BAND_0);
+		dump_cmac_cr(adapter, MAC_AX_BAND_1);
+		// dump DLE TBL & STA SCH
+		PLTFM_MEMSET(&dbg_en, 0, sizeof(struct mac_ax_dbgpkg_en));
+		dbg_en.ss_dbg = 1;
+		dbg_en.dle_dbg = 1;
+		mac_dbg_status_dump(adapter, &dbg_val, &dbg_en);
+		// dump debug port
+		for (i = MAC_AX_DBG_PORT_SEL_PTCL_C0; i < MAC_AX_DBG_PORT_SEL_LAST; i++) {
+			if (p_ops->is_dbg_port_not_valid(adapter, i))
+				continue;
+			ret = dbg_port_dump(adapter, i);
+			if (ret == MACDBGPORTSEL) {
+				PLTFM_MSG_WARN("no dbg port sel %d\n", i);
+				continue;
+			} else if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("dbg port %d dump %d\n", i, ret);
+				break;
+			}
+		}
+
+		mem_size = mac_get_mem_size(adapter, MAC_AX_MEM_SHARED_BUF);
+		mac_mem_dump(adapter, MAC_AX_MEM_SHARED_BUF, 0x0, NULL, mem_size, 0);
+		val8 = MAC_REG_R8(0x1FC) | BIT0;
+		MAC_REG_W8(0x1FC, val8);
+	}
+	PLTFM_MSG_ERR("<---\n");
+
+	return MACSUCCESS;
+}
+
+u32 mac_set_err_status(struct mac_ax_adapter *adapter,
+		       enum mac_ax_err_info err)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 cnt = MAC_SET_ERR_DLY_CNT;
+	u32 ret = MACSUCCESS;
+
+	if (err > MAC_AX_SET_ERR_MAX) {
+		PLTFM_MSG_ERR("Bad set-err-status value\n");
+		return MACFUNCINPUT;
+	}
+
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->err_set_lock);
+
+	while (--cnt) {
+		if (!MAC_REG_R32(R_AX_HALT_H2C_CTRL))
+			break;
+		PLTFM_DELAY_US(MAC_SET_ERR_DLY_US);
+	}
+	if (!cnt) {
+		PLTFM_MSG_ERR("FW does not receive previous msg\n");
+		ret = MACPOLLTO;
+		goto end;
+	}
+
+	if (err == MAC_AX_ERR_L1_DISABLE_EN)
+		adapter->sm.fw_rst = MAC_AX_FW_RESET_RECV_DONE;
+
+	MAC_REG_W32(R_AX_HALT_H2C, err);
+	MAC_REG_W32(R_AX_HALT_H2C_CTRL, B_AX_HALT_H2C_TRIGGER);
+
+end:
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->err_set_lock);
+	return ret;
+}
+
+u32 mac_get_err_status(struct mac_ax_adapter *adapter,
+		       enum mac_ax_err_info *err)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 cnt = MAC_SET_ERR_DLY_CNT;
+	u32 ret = MACSUCCESS;
+	u32 error_scenario = 0;
+
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->err_get_lock);
+	adapter->sm.l2_st = MAC_AX_L2_DIS;
+
+	while (--cnt) {
+		if (MAC_REG_R32(R_AX_HALT_C2H_CTRL))
+			break;
+		PLTFM_DELAY_US(MAC_SET_ERR_DLY_US);
+	}
+	if (!cnt) {
+		PLTFM_MSG_ERR("Polling FW err status fail\n");
+		ret = MACPOLLTO;
+		goto end;
+	}
+
+	*err = (enum mac_ax_err_info)MAC_REG_R32(R_AX_HALT_C2H);
+	MAC_REG_W32(R_AX_HALT_C2H_CTRL, 0);
+	switch (*err) {
+	case MAC_AX_ERR_L1_ERR_DMAC:
+	case MAC_AX_ERR_L0_PROMOTE_TO_L1:
+		adapter->sm.fw_rst = MAC_AX_FW_RESET_RECV;
+		break;
+	case MAC_AX_ERR_L1_RESET_DISABLE_DMAC_DONE:
+		adapter->sm.fw_rst = MAC_AX_FW_RESET_PROCESS;
+		break;
+	case MAC_AX_ERR_L1_RESET_RECOVERY_DONE:
+		adapter->sm.fw_rst = MAC_AX_FW_RESET_IDLE;
+		break;
+	default:
+		break;
+	}
+
+	/* Decode the error status from halc2h */
+	error_scenario = (*err) >> DBG_SENARIO_SH;
+	if (!(MAC_REG_R32(R_AX_UDM0) & B_AX_UDM0_DBG_MODE_CTRL)) {
+		if (error_scenario == CPU_EXCEPTION)
+			*err = MAC_AX_ERR_CPU_EXCEPTION;
+		else if (error_scenario == ASSERTION)
+			*err = MAC_AX_ERR_ASSERTION;
+		else if (error_scenario == RXI300_ERROR)
+			*err = MAC_AX_ERR_RXI300;
+	}
+
+	//3  3. Execute Recode Normal Debug Register
+	fw_st_dbg_dump(adapter);
+	mac_dump_err_status(adapter, *err);
+	if (*err == MAC_AX_ERR_L0_ERR_CMAC0 ||
+	    *err == MAC_AX_ERR_L0_ERR_CMAC1) {
+		pltfm_dbg_dump(adapter);
+	}
+
+	//3 4. Execute Recode Share memory debug information
+	if (MAC_REG_R32(R_AX_UDM0) & B_AX_UDM0_DBG_MODE_CTRL) {
+		/* if debug mode =1 , dump share buffer */
+		if (error_scenario) {
+			*err = (enum mac_ax_err_info)MAC_AX_DUMP_SHAREBUFF_INDICATOR;
+			//notify phl to print share buffer
+		}
+	}
+
+	//3 5.  dump detailed log for further debug usage.
+	mac_dbg_log_dump(adapter);
+end:
+	adapter->sm.l2_st = MAC_AX_L2_EN;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->err_get_lock);
+	return ret;
+}
+
+u32 mac_lv1_rcvy(struct mac_ax_adapter *adapter, enum mac_ax_lv1_rcvy_step step)
+{
+	u32 ret = MACSUCCESS;
+#if MAC_AX_PCIE_SUPPORT
+	u8 val8;
+#endif
+
+	switch (step) {
+	case MAC_AX_LV1_RCVY_STEP_1:
+		if (adapter->sm.fw_rst != MAC_AX_FW_RESET_RECV) {
+			PLTFM_MSG_ERR("The rst-flow state is wrong\n");
+			return MACPROCERR;
+		}
+#if MAC_AX_PCIE_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+			val8 = 0;
+			ret = lv1rst_stop_dma_pcie(adapter, val8);
+			if (ret) {
+				PLTFM_MSG_ERR("lv1 rcvy pcie stop dma fail\n");
+				return ret;
+			}
+		}
+	} else {
+		// 52C PCIE Stop flow made in FW
+	}
+#endif
+
+#if MAC_AX_USB_SUPPORT
+		if (adapter->hw_info->intf == MAC_AX_INTF_USB) {
+			ret = usb_flush_mode(adapter, MAC_AX_FUNC_EN);
+			if (ret) {
+				PLTFM_MSG_ERR("lv1 rcvy USB flush mode fail\n");
+				return ret;
+			}
+			PLTFM_DELAY_MS(30);
+		}
+#endif
+		break;
+
+	case MAC_AX_LV1_RCVY_STEP_2:
+		if (adapter->sm.fw_rst != MAC_AX_FW_RESET_PROCESS) {
+			PLTFM_MSG_ERR("The rst-flow state is wrong\n");
+			return MACPROCERR;
+		}
+#if MAC_AX_PCIE_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+				val8 = 0;
+				ret = lv1rst_start_dma_pcie(adapter, val8);
+				if (ret) {
+					PLTFM_MSG_ERR("lv1 rcvy pcie start dma fail\n");
+					return ret;
+				}
+			}
+		} else {
+			// 52C PCIE Stop flow made in FW
+		}
+#endif
+
+#if MAC_AX_USB_SUPPORT
+		if (adapter->hw_info->intf == MAC_AX_INTF_USB) {
+			ret = 0;
+			ret = usb_flush_mode(adapter, MAC_AX_FUNC_DIS);
+			if (ret) {
+				PLTFM_MSG_ERR("lv1 rcvy USB norm mode fail\n");
+				return ret;
+			}
+		}
+#endif
+		break;
+
+	default:
+		return MACLV1STEPERR;
+	}
+
+	return ret;
+}
+
+u32 mac_err_imr_ctrl(struct mac_ax_adapter *adapter, enum mac_ax_func_sw sw)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 v32_dmac, v32_cmac0, v32_cmac1;
+	u32 ret = MACSUCCESS;
+	u8 is_dbcc;
+
+	v32_dmac = sw != MAC_AX_FUNC_DIS ? DMAC_ERR_IMR_EN : DMAC_ERR_IMR_DIS;
+	v32_cmac0 = sw != MAC_AX_FUNC_DIS ? CMAC0_ERR_IMR_EN : CMAC0_ERR_IMR_DIS;
+	v32_cmac1 = sw != MAC_AX_FUNC_DIS ? CMAC1_ERR_IMR_EN : CMAC1_ERR_IMR_DIS;
+	is_dbcc = is_curr_dbcc(adapter);
+
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = MAC_REG_W_OFLD((u16)R_AX_DMAC_ERR_IMR, DMAC_ERR_IMR_MASK,
+				     v32_dmac, 0);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("dmac err imr w ofld fail\n");
+			return ret;
+		}
+
+		ret = MAC_REG_W_OFLD((u16)R_AX_CMAC_ERR_IMR, CMAC0_ERR_IMR_MASK,
+				     v32_cmac0, (is_dbcc ? 0 : 1));
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("cmac0 err imr w ofld fail\n");
+			return ret;
+		}
+
+		if (is_dbcc) {
+			ret = MAC_REG_W_OFLD((u16)R_AX_CMAC_ERR_IMR_C1,
+					     CMAC1_ERR_IMR_MASK,
+					     v32_cmac1, 1);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("cmac1 err imr w ofld fail\n");
+				return ret;
+			}
+		}
+
+		return ret;
+	}
+#endif
+
+	MAC_REG_W32(R_AX_DMAC_ERR_IMR, v32_dmac);
+	MAC_REG_W32(R_AX_CMAC_ERR_IMR, v32_cmac0);
+
+	if (is_dbcc)
+		MAC_REG_W32(R_AX_CMAC_ERR_IMR_C1, v32_cmac1);
+
+	return ret;
+}
+
+static void dump_err_status_dispatcher(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	PLTFM_MSG_ERR("R_AX_HOST_DISPATCHER_ERR_IMR=0x%08x\n",
+		      MAC_REG_R32(R_AX_HOST_DISPATCHER_ERR_IMR));
+	PLTFM_MSG_ERR("R_AX_HOST_DISPATCHER_ERR_ISR=0x%08x\n",
+		      MAC_REG_R32(R_AX_HOST_DISPATCHER_ERR_ISR));
+
+	PLTFM_MSG_ERR("R_AX_CPU_DISPATCHER_ERR_IMR=0x%08x\n",
+		      MAC_REG_R32(R_AX_CPU_DISPATCHER_ERR_IMR));
+	PLTFM_MSG_ERR("R_AX_CPU_DISPATCHER_ERR_ISR=0x%08x\n",
+		      MAC_REG_R32(R_AX_CPU_DISPATCHER_ERR_ISR));
+	PLTFM_MSG_ERR("R_AX_OTHER_DISPATCHER_ERR_IMR=0x%08x ",
+		      MAC_REG_R32(R_AX_OTHER_DISPATCHER_ERR_IMR));
+	PLTFM_MSG_ERR("R_AX_OTHER_DISPATCHER_ERR_ISR=0x%08x\n",
+		      MAC_REG_R32(R_AX_OTHER_DISPATCHER_ERR_ISR));
+}
+
+static void dump_err_status_dmac(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 dmac_err;
+
+	dmac_err = MAC_REG_R32(R_AX_DMAC_ERR_ISR);
+	PLTFM_MSG_ERR("R_AX_DMAC_ERR_ISR =0x%08x\n", dmac_err);
+	PLTFM_MSG_ALWAYS("R_AX_DMAC_ERR_IMR=0x%x\n",
+			 MAC_REG_R32(R_AX_DMAC_ERR_IMR));
+
+	PLTFM_MSG_ERR("R_AX_DMAC_FUNC_EN =0x%08x\n",
+		      MAC_REG_R32(R_AX_DMAC_FUNC_EN));
+	PLTFM_MSG_ERR("R_AX_DMAC_CLK_EN =0x%08x\n",
+		      MAC_REG_R32(R_AX_DMAC_CLK_EN));
+
+	if (dmac_err) {
+		PLTFM_MSG_ERR("R_AX_WDE_ERR_FLAG_CFG =0x%08x\n",
+			      MAC_REG_R32(R_AX_WDE_ERR_FLAG_CFG_NUM1));
+		PLTFM_MSG_ERR("R_AX_PLE_ERR_FLAG_CFG =0x%08x\n",
+			      MAC_REG_R32(R_AX_PLE_ERR_FLAG_CFG_NUM1));
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		PLTFM_MSG_ERR("R_AX_PLE_ERRFLAG_MSG =0x%08x\n",
+			      MAC_REG_R32(R_AX_PLE_ERRFLAG_MSG));
+		PLTFM_MSG_ERR("R_AX_PLE_ERRFLAG_MSG 0x9030 Reg dump =0x%08x\n",
+			      MAC_REG_R32(R_AX_PLE_ERRFLAG_MSG));
+		PLTFM_MSG_ERR("R_AX_WDE_ERRFLAG_MSG 0x8C30 Reg dump =0x%08x\n",
+			      MAC_REG_R32(R_AX_WDE_ERRFLAG_MSG));
+		PLTFM_MSG_ERR("R_AX_PLE_DBGERR_LOCKEN 0x9020 Reg dump =0x%08x\n",
+			      MAC_REG_R32(R_AX_PLE_DBGERR_LOCKEN));
+		PLTFM_MSG_ERR("R_AX_PLE_DBGERR_STS 0x9024 Reg dump =0x%08x\n",
+			      MAC_REG_R32(R_AX_PLE_DBGERR_STS));
+#endif
+	}
+
+	if (dmac_err & B_AX_WDRLS_ERR_FLAG) {
+		PLTFM_MSG_ERR("R_AX_WDRLS_ERR_IMR =0x%08x\n",
+			      MAC_REG_R32(R_AX_WDRLS_ERR_IMR));
+		PLTFM_MSG_ERR("R_AX_WDRLS_ERR_ISR =0x%08x\n",
+			      MAC_REG_R32(R_AX_WDRLS_ERR_ISR));
+#if (MAC_AX_8852A_SUPPORT) || (MAC_AX_8852B_SUPPORT) || (MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ERR("R_AX_RPQ_RXBD_IDX =0x%08x\n",
+				      MAC_REG_R32(R_AX_RPQ_RXBD_IDX));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ERR("R_AX_RPQ_RXBD_IDX =0x%08x\n",
+				      MAC_REG_R32(R_AX_RPQ_RXBD_IDX_V1));
+		}
+#endif
+	}
+
+	if (dmac_err & B_AX_WSEC_ERR_FLAG) {
+#if (MAC_AX_8852A_SUPPORT) || (MAC_AX_8852B_SUPPORT) || (MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ERR("R_AX_SEC_ERR_IMR_ISR =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_DEBUG));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D00 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_ENG_CTRL));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D04 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_MPDU_PROC));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D10 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_CAM_ACCESS));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D14 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_CAM_RDATA));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D18 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_CAM_WDATA));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D20 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_TX_DEBUG));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D24 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_RX_DEBUG));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D28 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_TRX_PKT_CNT));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D2C =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_TRX_BLK_CNT));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		u32 val32 = 0, i = 0;
+
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ERR("R_AX_SEC_ERR_IMR =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_ERROR_FLAG_IMR));
+			PLTFM_MSG_ERR("R_AX_SEC_ERR_ISR =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_ERROR_FLAG));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D00 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_ENG_CTRL));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D04 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_MPDU_PROC));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D10 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_CAM_ACCESS));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D14 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_CAM_RDATA));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D1C =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_DEBUG1));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D20 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_TX_DEBUG));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D24 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_RX_DEBUG));
+			PLTFM_MSG_ERR("SEC_local_Register 0x9D28 =0x%08x\n",
+				      MAC_REG_R32(R_AX_SEC_DEBUG2));
+
+			val32 = MAC_REG_R32(R_AX_DBG_CTRL);
+			val32 = SET_CLR_WORD(val32, SEC_DBG_SEL, B_AX_DBG_SEL0);
+			val32 = SET_CLR_WORD(val32, SEC_DBG_SEL, B_AX_DBG_SEL1);
+			MAC_REG_W32(R_AX_DBG_CTRL, val32);
+
+			val32 = MAC_REG_R32(R_AX_SYS_STATUS1);
+			val32 = SET_CLR_WORD(val32, MAC_DBG_SEL, B_AX_SEL_0XC0);
+			MAC_REG_W32(R_AX_SYS_STATUS1, val32);
+			PLTFM_MSG_ALWAYS("SECURITY ENGINE DEBUG PORT DUMP\n");
+			for (i = 0; i < SEC_DBG_PORT_NUM; i++) {
+				val32 = MAC_REG_R32(R_AX_SEC_ENG_CTRL);
+				val32 = SET_CLR_WORD(val32, i, SEC_DBG_PORT_FIELD);
+				MAC_REG_W32(R_AX_SEC_ENG_CTRL, val32);
+				PLTFM_MSG_ERR("debug sel = %x, 0x9D28 =0x%08x\n",
+					      i, MAC_REG_R32(R_AX_SEC_DEBUG2));
+			}
+		}
+#endif
+	}
+
+	if (dmac_err & B_AX_MPDU_ERR_FLAG) {
+		PLTFM_MSG_ERR("R_AX_MPDU_TX_ERR_IMR =0x%08x\n",
+			      MAC_REG_R32(R_AX_MPDU_TX_ERR_IMR));
+		PLTFM_MSG_ERR("R_AX_MPDU_TX_ERR_ISR =0x%08x\n",
+			      MAC_REG_R32(R_AX_MPDU_TX_ERR_ISR));
+		PLTFM_MSG_ERR("R_AX_MPDU_RX_ERR_IMR =0x%08x\n",
+			      MAC_REG_R32(R_AX_MPDU_RX_ERR_IMR));
+		PLTFM_MSG_ERR("R_AX_MPDU_RX_ERR_ISR =0x%08x\n",
+			      MAC_REG_R32(R_AX_MPDU_RX_ERR_ISR));
+	}
+
+	if (dmac_err & B_AX_STA_SCHEDULER_ERR_FLAG) {
+		PLTFM_MSG_ERR("R_AX_STA_SCHEDULER_ERR_IMR =0x%08x\n",
+			      MAC_REG_R32(R_AX_STA_SCHEDULER_ERR_IMR));
+		PLTFM_MSG_ERR("R_AX_STA_SCHEDULER_ERR_ISR= 0x%08x\n",
+			      MAC_REG_R32(R_AX_STA_SCHEDULER_ERR_ISR));
+	}
+
+	if (dmac_err & B_AX_WDE_DLE_ERR_FLAG) {
+		PLTFM_MSG_ERR("R_AX_WDE_ERR_IMR=0x%08x\n",
+			      MAC_REG_R32(R_AX_WDE_ERR_IMR));
+		PLTFM_MSG_ERR("R_AX_WDE_ERR_ISR=0x%08x\n",
+			      MAC_REG_R32(R_AX_WDE_ERR_ISR));
+		PLTFM_MSG_ERR("R_AX_PLE_ERR_IMR=0x%08x\n",
+			      MAC_REG_R32(R_AX_PLE_ERR_IMR));
+		PLTFM_MSG_ERR("R_AX_PLE_ERR_FLAG_ISR=0x%08x\n",
+			      MAC_REG_R32(R_AX_PLE_ERR_FLAG_ISR));
+	}
+
+	if (dmac_err & B_AX_TXPKTCTRL_ERR_FLAG) {
+#if (MAC_AX_8852A_SUPPORT) || (MAC_AX_8852B_SUPPORT) || (MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ERR("R_AX_TXPKTCTL_ERR_IMR_ISR=0x%08x\n",
+				      MAC_REG_R32(R_AX_TXPKTCTL_ERR_IMR_ISR));
+			PLTFM_MSG_ERR("R_AX_TXPKTCTL_ERR_IMR_ISR_B1=0x%08x\n",
+				      MAC_REG_R32(R_AX_TXPKTCTL_ERR_IMR_ISR_B1));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ERR("R_AX_TXPKTCTL_B0_ERRFLAG_IMR=0x%08x\n",
+				      MAC_REG_R32(R_AX_TXPKTCTL_B0_ERRFLAG_IMR));
+			PLTFM_MSG_ERR("R_AX_TXPKTCTL_B0_ERRFLAG_ISR=0x%08x\n",
+				      MAC_REG_R32(R_AX_TXPKTCTL_B0_ERRFLAG_ISR));
+			PLTFM_MSG_ERR("R_AX_TXPKTCTL_B1_ERRFLAG_IMR=0x%08x\n",
+				      MAC_REG_R32(R_AX_TXPKTCTL_B1_ERRFLAG_IMR));
+			PLTFM_MSG_ERR("R_AX_TXPKTCTL_B1_ERRFLAG_ISR=0x%08x\n",
+				      MAC_REG_R32(R_AX_TXPKTCTL_B1_ERRFLAG_ISR));
+		}
+#endif
+	}
+
+	if (dmac_err & B_AX_PLE_DLE_ERR_FLAG) {
+		PLTFM_MSG_ERR("R_AX_WDE_ERR_IMR=0x%08x\n",
+			      MAC_REG_R32(R_AX_WDE_ERR_IMR));
+		PLTFM_MSG_ERR("R_AX_WDE_ERR_ISR=0x%08x\n",
+			      MAC_REG_R32(R_AX_WDE_ERR_ISR));
+		PLTFM_MSG_ERR("R_AX_PLE_ERR_IMR=0x%08x\n",
+			      MAC_REG_R32(R_AX_PLE_ERR_IMR));
+		PLTFM_MSG_ERR("R_AX_PLE_ERR_FLAG_ISR=0x%08x\n",
+			      MAC_REG_R32(R_AX_PLE_ERR_FLAG_ISR));
+		PLTFM_MSG_ERR("R_AX_WD_CPUQ_OP_0=0x%08x\n",
+			      MAC_REG_R32(R_AX_WD_CPUQ_OP_0));
+		PLTFM_MSG_ERR("R_AX_WD_CPUQ_OP_1=0x%08x\n",
+			      MAC_REG_R32(R_AX_WD_CPUQ_OP_1));
+		PLTFM_MSG_ERR("R_AX_WD_CPUQ_OP_2=0x%08x\n",
+			      MAC_REG_R32(R_AX_WD_CPUQ_OP_2));
+		PLTFM_MSG_ERR("R_AX_WD_CPUQ_OP_STATUS=0x%08x\n",
+			      MAC_REG_R32(R_AX_WD_CPUQ_OP_STATUS));
+		PLTFM_MSG_ERR("R_AX_PL_CPUQ_OP_0=0x%08x\n",
+			      MAC_REG_R32(R_AX_PL_CPUQ_OP_0));
+		PLTFM_MSG_ERR("R_AX_PL_CPUQ_OP_1=0x%08x\n",
+			      MAC_REG_R32(R_AX_PL_CPUQ_OP_1));
+		PLTFM_MSG_ERR("R_AX_PL_CPUQ_OP_2=0x%08x\n",
+			      MAC_REG_R32(R_AX_PL_CPUQ_OP_2));
+		PLTFM_MSG_ERR("R_AX_PL_CPUQ_OP_STATUS=0x%08x\n",
+			      MAC_REG_R32(R_AX_PL_CPUQ_OP_STATUS));
+#if (MAC_AX_8852A_SUPPORT) || (MAC_AX_8852B_SUPPORT) || (MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ERR("R_AX_RXDMA_PKT_INFO_0=0x%08x\n",
+				      MAC_REG_R32(R_AX_RXDMA_PKT_INFO_0));
+			PLTFM_MSG_ERR("R_AX_RXDMA_PKT_INFO_1=0x%08x\n",
+				      MAC_REG_R32(R_AX_RXDMA_PKT_INFO_1));
+			PLTFM_MSG_ERR("R_AX_RXDMA_PKT_INFO_2=0x%08x\n",
+				      MAC_REG_R32(R_AX_RXDMA_PKT_INFO_2));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ERR("R_AX_RX_CTRL0=0x%08x\n",
+				      MAC_REG_R32(R_AX_RX_CTRL0));
+			PLTFM_MSG_ERR("R_AX_RX_CTRL1=0x%08x\n",
+				      MAC_REG_R32(R_AX_RX_CTRL1));
+			PLTFM_MSG_ERR("R_AX_RX_CTRL2=0x%08x\n",
+				      MAC_REG_R32(R_AX_RX_CTRL2));
+		}
+#endif
+		dump_err_status_dispatcher(adapter);
+	}
+
+	if (dmac_err & B_AX_PKTIN_ERR_FLAG) {
+		PLTFM_MSG_ERR("R_AX_PKTIN_ERR_IMR =0x%08x\n",
+			      MAC_REG_R32(R_AX_PKTIN_ERR_IMR));
+		PLTFM_MSG_ERR("R_AX_PKTIN_ERR_ISR =0x%08x\n",
+			      MAC_REG_R32(R_AX_PKTIN_ERR_ISR));
+		PLTFM_MSG_ERR("R_AX_PKTIN_ERR_IMR =0x%08x ",
+			      MAC_REG_R32(R_AX_PKTIN_ERR_IMR));
+		PLTFM_MSG_ERR("R_AX_PKTIN_ERR_ISR =0x%08x\n",
+			      MAC_REG_R32(R_AX_PKTIN_ERR_ISR));
+	}
+
+	if (dmac_err & B_AX_DISPATCH_ERR_FLAG)
+		dump_err_status_dispatcher(adapter);
+
+	if (dmac_err & B_AX_DLE_CPUIO_ERR_FLAG) {
+		PLTFM_MSG_ERR("R_AX_CPUIO_ERR_IMR=0x%08x\n",
+			      MAC_REG_R32(R_AX_CPUIO_ERR_IMR));
+		PLTFM_MSG_ERR("R_AX_CPUIO_ERR_ISR=0x%08x\n",
+			      MAC_REG_R32(R_AX_CPUIO_ERR_ISR));
+	}
+
+	if (dmac_err & B_AX_BBRPT_ERR_FLAG) {
+#if (MAC_AX_8852A_SUPPORT) || (MAC_AX_8852B_SUPPORT) || (MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ERR("R_AX_BBRPT_COM_ERR_IMR_ISR=0x%08x\n",
+				      MAC_REG_R32(R_AX_BBRPT_COM_ERR_IMR_ISR));
+			PLTFM_MSG_ERR("R_AX_BBRPT_CHINFO_ERR_ISR=0x%08x\n",
+				      MAC_REG_R32(R_AX_BBRPT_CHINFO_ERR_ISR));
+			PLTFM_MSG_ERR("R_AX_BBRPT_CHINFO_ERR_IMR=0x%08x\n",
+				      MAC_REG_R32(R_AX_BBRPT_CHINFO_ERR_IMR));
+			PLTFM_MSG_ERR("R_AX_BBRPT_DFS_ERR_IMR=0x%08x\n",
+				      MAC_REG_R32(R_AX_BBRPT_DFS_ERR_IMR));
+			PLTFM_MSG_ERR("R_AX_BBRPT_DFS_ERR_ISR=0x%08x\n",
+				      MAC_REG_R32(R_AX_BBRPT_DFS_ERR_ISR));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ERR("R_AX_BBRPT_COM_ERR_IMR=0x%08x\n",
+				      MAC_REG_R32(R_AX_BBRPT_COM_ERR_IMR));
+			PLTFM_MSG_ERR("R_AX_BBRPT_COM_ERR_ISR=0x%08x\n",
+				      MAC_REG_R32(R_AX_BBRPT_COM_ERR_ISR));
+			PLTFM_MSG_ERR("R_AX_BBRPT_CHINFO_ERR_ISR=0x%08x\n",
+				      MAC_REG_R32(R_AX_BBRPT_CHINFO_ERR_ISR));
+			PLTFM_MSG_ERR("R_AX_BBRPT_CHINFO_ERR_IMR=0x%08x\n",
+				      MAC_REG_R32(R_AX_BBRPT_CHINFO_ERR_IMR));
+			PLTFM_MSG_ERR("R_AX_BBRPT_DFS_ERR_IMR=0x%08x\n",
+				      MAC_REG_R32(R_AX_BBRPT_DFS_ERR_IMR));
+			PLTFM_MSG_ERR("R_AX_BBRPT_DFS_ERR_ISR=0x%08x\n",
+				      MAC_REG_R32(R_AX_BBRPT_DFS_ERR_ISR));
+		}
+#endif
+	}
+
+	if (dmac_err & B_AX_HAXIDMA_ERR_FLAG) {
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ERR("R_AX_HAXIDMA_ERR_IMR=0x%08x\n",
+				      MAC_REG_R32(R_AX_HAXI_IDCT_MSK));
+			PLTFM_MSG_ERR("R_AX_HAXIDMA_ERR_ISR=0x%08x\n",
+				      MAC_REG_R32(R_AX_HAXI_IDCT));
+		}
+#endif
+	}
+}
+
+static void dump_err_status_cmac(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 cmac_err;
+	u32 ret;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return;
+
+	PLTFM_MSG_ERR("CMAC Band =0x%02x\n", band);
+
+	cmac_err = MAC_REG_R32(band == MAC_AX_BAND_0 ? R_AX_CMAC_ERR_ISR :
+			       R_AX_CMAC_ERR_ISR_C1);
+	PLTFM_MSG_ERR("R_AX_CMAC_ERR_ISR =0x%08x\n", cmac_err);
+
+	PLTFM_MSG_ERR("R_AX_CMAC_FUNC_EN =0x%08x\n",
+		      MAC_REG_R32(band == MAC_AX_BAND_0 ? R_AX_CMAC_FUNC_EN :
+		      R_AX_CMAC_FUNC_EN_C1));
+	PLTFM_MSG_ERR("R_AX_CK_EN =0x%08x\n",
+		      MAC_REG_R32(band == MAC_AX_BAND_0 ? R_AX_CK_EN :
+		      R_AX_CK_EN_C1));
+
+	if (cmac_err & B_AX_SCHEDULE_TOP_ERR_IND) {
+		PLTFM_MSG_ERR("R_AX_SCHEDULE_ERR_IMR=0x%08x\n",
+			      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+			      R_AX_SCHEDULE_ERR_IMR : R_AX_SCHEDULE_ERR_IMR_C1));
+		PLTFM_MSG_ERR("R_AX_SCHEDULE_ERR_ISR=0x%04x\n",
+			      MAC_REG_R16(band == MAC_AX_BAND_0 ?
+			      R_AX_SCHEDULE_ERR_ISR : R_AX_SCHEDULE_ERR_ISR_C1));
+	}
+
+	if (cmac_err & B_AX_PTCL_TOP_ERR_IND) {
+		PLTFM_MSG_ERR("R_AX_PTCL_IMR0=0x%08x\n",
+			      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+			      R_AX_PTCL_IMR0 : R_AX_PTCL_IMR0_C1));
+		PLTFM_MSG_ERR("R_AX_PTCL_ISR0=0x%08x\n",
+			      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+			      R_AX_PTCL_ISR0 : R_AX_PTCL_ISR0_C1));
+	}
+
+	if (cmac_err & B_AX_DMA_TOP_ERR_IND) {
+#if (MAC_AX_8852A_SUPPORT) || (MAC_AX_8852B_SUPPORT) || (MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ERR("R_AX_DLE_CTRL (0xC800)=0x%08x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_DLE_CTRL : R_AX_DLE_CTRL_C1));
+			PLTFM_MSG_ERR("0xC828=0x%08x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_RX_INFO_RXSTS : R_AX_RX_INFO_RXSTS_C1));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ERR("R_AX_RX_ERR_FLAG (0xC800)=0x%08x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_RX_ERR_FLAG : R_AX_RX_ERR_FLAG_C1));
+			PLTFM_MSG_ERR("R_AX_RX_ERR_FLAG_IMR (0xC804)=0x%08x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_RX_ERR_FLAG_IMR : R_AX_RX_ERR_FLAG_IMR_C1));
+			PLTFM_MSG_ERR("R_AX_RX_ERR_FLAG (0xC86C)=0x%08x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_TX_ERR_FLAG : R_AX_TX_ERR_FLAG_C1));
+			PLTFM_MSG_ERR("R_AX_RX_ERR_FLAG_IMR (0xC870)=0x%08x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_TX_ERR_FLAG_IMR : R_AX_TX_ERR_FLAG_IMR_C1));
+		}
+#endif
+	}
+
+	if (cmac_err & B_AX_PHYINTF_ERR_IND) {
+#if (MAC_AX_8852A_SUPPORT) || (MAC_AX_8852B_SUPPORT) || (MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ERR("R_AX_PHYINFO_ERR_IMR=0x%04x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_PHYINFO_ERR_IMR :
+				      R_AX_PHYINFO_ERR_IMR_C1));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ERR("R_AX_PHYINFO_ERR_ISR=0x%04x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_PHYINFO_ERR_ISR :
+				      R_AX_PHYINFO_ERR_ISR_C1));
+			PLTFM_MSG_ERR("R_AX_PHYINFO_ERR_IMR=0x%04x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_PHYINFO_ERR_IMR_V1 :
+				      R_AX_PHYINFO_ERR_IMR_V1_C1));
+		}
+#endif
+	}
+
+	if (cmac_err & B_AX_TXPWR_CTRL_ERR_IND) {
+		PLTFM_MSG_ERR("R_AX_TXPWR_IMR=0x%08x\n",
+			      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+			      R_AX_TXPWR_IMR : R_AX_TXPWR_IMR_C1));
+		PLTFM_MSG_ERR("R_AX_TXPWR_ISR=0x%08x\n",
+			      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+			      R_AX_TXPWR_ISR : R_AX_TXPWR_ISR_C1));
+	}
+
+	if (cmac_err & B_AX_WMAC_RX_ERR_IND) {
+		PLTFM_MSG_ERR("R_AX_DBGSEL_TRXPTCL=0x%08x\n",
+			      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+			      R_AX_DBGSEL_TRXPTCL : R_AX_DBGSEL_TRXPTCL_C1));
+#if (MAC_AX_8852A_SUPPORT) || (MAC_AX_8852B_SUPPORT) || (MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ERR("R_AX_PHYINFO_ERR_IMR=0x%04x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_PHYINFO_ERR_IMR :
+				      R_AX_PHYINFO_ERR_IMR_C1));
+			PLTFM_MSG_ERR("R_AX_RMAC_ERR_ISR=0x%04x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_RMAC_ERR_ISR :
+				      R_AX_RMAC_ERR_ISR_C1));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ERR("R_AX_PHYINFO_ERR_ISR=0x%04x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_PHYINFO_ERR_ISR :
+				      R_AX_PHYINFO_ERR_ISR_C1));
+			PLTFM_MSG_ERR("R_AX_PHYINFO_ERR_IMR=0x%04x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_PHYINFO_ERR_IMR_V1 :
+				      R_AX_PHYINFO_ERR_IMR_V1_C1));
+			PLTFM_MSG_ERR("R_AX_RX_ERR_ISR=0x%04x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_RX_ERR_ISR :
+				      R_AX_RX_ERR_ISR_C1));
+			PLTFM_MSG_ERR("R_AX_RX_ERR_IMR=0x%04x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_RX_ERR_IMR :
+				      R_AX_RX_ERR_IMR_C1));
+		}
+#endif
+	}
+
+	if (cmac_err & B_AX_WMAC_TX_ERR_IND) {
+#if (MAC_AX_8852A_SUPPORT) || (MAC_AX_8852B_SUPPORT) || (MAC_AX_8851B_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			PLTFM_MSG_ERR("R_AX_TMAC_ERR_IMR_ISR=0x%08x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_TMAC_ERR_IMR_ISR :
+				      R_AX_TMAC_ERR_IMR_ISR_C1));
+		}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			PLTFM_MSG_ERR("R_AX_TRXPTCL_ERROR_INDICA=0x%08x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_TRXPTCL_ERROR_INDICA :
+				      R_AX_TRXPTCL_ERROR_INDICA_C1));
+			PLTFM_MSG_ERR("R_AX_TRXPTCL_ERROR_INDICA_MASK=0x%08x\n",
+				      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+				      R_AX_TRXPTCL_ERROR_INDICA_MASK :
+				      R_AX_TRXPTCL_ERROR_INDICA_MASK_C1));
+		}
+#endif
+		PLTFM_MSG_ERR("R_AX_DBGSEL_TRXPTCL=0x%08x\n",
+			      MAC_REG_R32(band == MAC_AX_BAND_0 ?
+			      R_AX_DBGSEL_TRXPTCL : R_AX_DBGSEL_TRXPTCL_C1));
+	}
+
+	cmac_err = MAC_REG_R32(band == MAC_AX_BAND_1 ? R_AX_CMAC_ERR_IMR_C1 :
+			       R_AX_CMAC_ERR_IMR);
+	PLTFM_MSG_ALWAYS("B%d R_AX_CMAC_ERR_IMR=0x%x\n", band, cmac_err);
+}
+
+u32 mac_ser_ctrl(struct mac_ax_adapter *adapter, enum mac_ax_func_sw sw)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	enum mac_ax_err_info err_info;
+	u32 val32, ret, cnt;
+
+	if (sw == MAC_AX_FUNC_EN) {
+		err_info = MAC_AX_ERR_L1_RCVY_START_REQ;
+		adapter->sm.ser_ctrl_st = MAC_AX_SER_CTRL_SRT;
+	} else if (sw == MAC_AX_FUNC_DIS) {
+		err_info = MAC_AX_ERR_L1_RCVY_STOP_REQ;
+		adapter->sm.ser_ctrl_st = MAC_AX_SER_CTRL_STOP;
+	} else if (sw == MAC_AX_FUNC_WO_RECVY_DIS) {
+		err_info = MAC_AX_ERR_L1_RCVY_STOP_WO_RECVY_REQ;
+		adapter->sm.ser_ctrl_st = MAC_AX_SER_CTRL_SRT;
+	} else if (sw == MAC_AX_FUNC_WO_RECVY_EN) {
+		err_info = MAC_AX_ERR_L1_RCVY_START_WO_RECVY_REQ;
+		adapter->sm.ser_ctrl_st = MAC_AX_SER_CTRL_STOP;
+	} else {
+		adapter->sm.ser_ctrl_st = MAC_AX_SER_CTRL_ERR;
+		PLTFM_MSG_ERR("[ERR]SER ctrl input err %d\n", sw);
+		return MACFUNCINPUT;
+	}
+
+	ret = mac_set_err_status(adapter, err_info);
+	if (ret != MACSUCCESS) {
+		adapter->sm.ser_ctrl_st = MAC_AX_SER_CTRL_ERR;
+		PLTFM_MSG_ERR("[ERR]set err for stop ser %d\n", ret);
+		return ret;
+	}
+
+	cnt = MAC_SET_ERR_DLY_CNT;
+	while (cnt) {
+		val32 = MAC_REG_R32(R_AX_HALT_H2C_CTRL);
+		if (!(val32 & B_AX_HALT_H2C_TRIGGER))
+			break;
+		PLTFM_DELAY_US(MAC_SET_ERR_DLY_US);
+		cnt--;
+	}
+
+	if (!cnt) {
+		adapter->sm.ser_ctrl_st = MAC_AX_SER_CTRL_ERR;
+		PLTFM_MSG_ERR("[ERR]FW not handle haltH2C req\n");
+		ret = MACPOLLTO;
+		return ret;
+	}
+
+	if (sw == MAC_AX_FUNC_EN || sw == MAC_AX_FUNC_WO_RECVY_DIS ||
+	    sw == MAC_AX_FUNC_WO_RECVY_EN)
+		return MACSUCCESS;
+
+	cnt = MAC_SER_STOP_DLY_CNT;
+	while (cnt) {
+		PLTFM_DELAY_US(MAC_SER_STOP_DLY_US);
+		val32 = MAC_REG_R32(R_AX_UDM0);
+		val32 = GET_FIELD(val32, FW_ST);
+		if (val32 != FW_ST_ERR_IN)
+			break;
+		cnt--;
+	}
+
+	if (!cnt) {
+		adapter->sm.ser_ctrl_st = MAC_AX_SER_CTRL_ERR;
+		PLTFM_MSG_ERR("[ERR]stop ser polling FW ST timeout\n");
+		return MACPOLLTO;
+	}
+
+	return ret;
+}
+
+u32 mac_chk_err_status(struct mac_ax_adapter *adapter, u8 *ser_status)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 cnt = MAC_SET_ERR_DLY_CNT;
+	u32 ret = MACSUCCESS;
+	enum mac_ax_err_info err;
+
+	PLTFM_MUTEX_LOCK(&adapter->hw_info->err_get_lock);
+	adapter->sm.l2_st = MAC_AX_L2_DIS;
+
+	while (--cnt) {
+		if (MAC_REG_R32(R_AX_HALT_C2H_CTRL))
+			break;
+		PLTFM_DELAY_US(MAC_SET_ERR_DLY_US);
+	}
+	if (!cnt) {
+		PLTFM_MSG_ERR("Polling FW err status fail\n");
+		ret = MACPOLLTO;
+		goto end;
+	}
+
+	err = (enum mac_ax_err_info)MAC_REG_R32(R_AX_HALT_C2H);
+
+	switch (err) {
+	case MAC_AX_ERR_L1_ERR_DMAC:
+	case MAC_AX_ERR_L0_PROMOTE_TO_L1:
+		*ser_status = MAC_AX_L1_TRUE;
+		break;
+	default:
+		*ser_status = MAC_AX_L1_FALSE;
+		break;
+	}
+
+end:
+	adapter->sm.l2_st = MAC_AX_L2_EN;
+	PLTFM_MUTEX_UNLOCK(&adapter->hw_info->err_get_lock);
+	return ret;
+}
+
+u32 mac_set_l0_dbg_mode(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret;
+	u32 val32;
+	u32 cnt = MAC_SET_ERR_DLY_CNT;
+
+	MAC_REG_W32(R_AX_HALT_H2C, MAC_AX_L0_DBG_MODE);
+	val32 = MAC_REG_R32(R_AX_HALT_H2C_CTRL) | B_AX_HALT_H2C_TRIGGER;
+	MAC_REG_W32(R_AX_HALT_H2C_CTRL, val32);
+	while (--cnt) {
+		if (!(MAC_REG_R32(R_AX_HALT_H2C_CTRL)))
+			break;
+		PLTFM_DELAY_US(MAC_SET_ERR_DLY_US);
+	}
+	if (!cnt) {
+		PLTFM_MSG_ERR("Polling FW err status fail\n");
+		ret = MACPOLLTO;
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_set_l1_dbg_mode(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret;
+	u32 val32;
+	u32 cnt = MAC_SET_ERR_DLY_CNT;
+
+	MAC_REG_W32(R_AX_HALT_H2C, MAC_AX_L1_DBG_MODE);
+	val32 = MAC_REG_R32(R_AX_HALT_H2C_CTRL) | B_AX_HALT_H2C_TRIGGER;
+	MAC_REG_W32(R_AX_HALT_H2C_CTRL, val32);
+	while (--cnt) {
+		if (!(MAC_REG_R32(R_AX_HALT_H2C_CTRL)))
+			break;
+		PLTFM_DELAY_US(MAC_SET_ERR_DLY_US);
+	}
+	if (!cnt) {
+		PLTFM_MSG_ERR("Polling FW err status fail\n");
+		ret = MACPOLLTO;
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_dump_ser_cnt(struct mac_ax_adapter *adapter, struct mac_ser_status *status)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	val32 = MAC_REG_R32(R_AX_SER_DBG_INFO);
+	status->l0_cnt = GET_FIELD(val32, B_AX_SER_L0_COUNTER);
+	status->l1_cnt = GET_FIELD(val32, B_AX_SER_L1_COUNTER);
+	status->l0_pro_event = GET_FIELD(val32, B_AX_SER_L0_PROMOTE_L1_EVENT);
+	status->rmac_ppdu_hang_cnt = GET_FIELD(val32, B_AX_RMAC_PPDU_HANG_CNT);
+
+	return MACSUCCESS;
+}
+
+static void dump_cmac_cr(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 base_addr, max_addr, i;
+	u32 ret;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return;
+
+	PLTFM_MSG_ERR("Dump CMAC band %d\n", band);
+	PLTFM_MSG_ERR("CMAC common\n");
+	base_addr = (band == 0) ? CMAC_AX_COMMON_BASE_ADDR : CMAC_AX_COMMON_BASE_ADDR_C1;
+	max_addr = CMAC_AX_COMMON_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x186%05x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("Scheduler\n");
+	base_addr = (band == 0) ? CMAC_AX_SCH_BASE_ADDR : CMAC_AX_SCH_BASE_ADDR_C1;
+	max_addr = CMAC_AX_SCH_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x186%05x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("PTCL\n");
+	base_addr = (band == 0) ? CMAC_AX_PTCL_BASE_ADDR : CMAC_AX_PTCL_BASE_ADDR_C1;
+	max_addr = CMAC_AX_PTCL_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x186%05x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("CDMA\n");
+	base_addr = (band == 0) ? CMAC_AX_CDMA_BASE_ADDR : CMAC_AX_CDMA_BASE_ADDR_C1;
+	max_addr = CMAC_AX_CDMA_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x186%05x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("TMAC\n");
+	base_addr = (band == 0) ? CMAC_AX_TMAC_BASE_ADDR : CMAC_AX_TMAC_BASE_ADDR_C1;
+	max_addr = CMAC_AX_TMAC_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x186%05x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("TRXPTCL\n");
+	base_addr = (band == 0) ? CMAC_AX_TRXPTCL_BASE_ADDR : CMAC_AX_TRXPTCL_BASE_ADDR_C1;
+	max_addr = CMAC_AX_TRXPTCL_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x186%05x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("RMAC\n");
+	base_addr = (band == 0) ? CMAC_AX_RMAC_BASE_ADDR : CMAC_AX_RMAC_BASE_ADDR_C1;
+	max_addr = CMAC_AX_RMAC_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x186%05x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("PWR\n");
+	base_addr = (band == 0) ? CMAC_AX_PWR_BASE_ADDR : CMAC_AX_PWR_BASE_ADDR_C1;
+	max_addr = CMAC_AX_PWR_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x186%05x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("BTCOEX\n");
+	base_addr = (band == 0) ? CMAC_AX_BTCOEX_BASE_ADDR : CMAC_AX_BTCOEX_BASE_ADDR_C1;
+	max_addr = CMAC_AX_BTCOEX_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x186%05x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+}
+
+static void dump_dmac_cr(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 base_addr, max_addr, i;
+
+	PLTFM_MSG_ERR("Dump DMAC\n");
+	PLTFM_MSG_ERR("TOP_OFF\n");
+	base_addr = DMAC_AX_TOP_OFF_BASE_ADDR;
+	max_addr = DMAC_AX_TOP_OFF_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("WL_PON\n");
+	base_addr = DMAC_AX_WL_PON_BASE_ADDR;
+	max_addr = DMAC_AX_WL_PON_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("Common\n");
+	base_addr = DMAC_AX_COMMON_BASE_ADDR;
+	max_addr = DMAC_AX_COMMON_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("Dispatcher\n");
+	base_addr = DMAC_AX_DISPATCHER_BASE_ADDR;
+	max_addr = DMAC_AX_DISPATCHER_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("WDE\n");
+	base_addr = DMAC_AX_WDE_BASE_ADDR;
+	max_addr = DMAC_AX_WDE_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("PLE\n");
+	base_addr = DMAC_AX_PLE_BASE_ADDR;
+	max_addr = DMAC_AX_PLE_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("WDRLS\n");
+	base_addr = DMAC_AX_WDRLS_BASE_ADDR;
+	max_addr = DMAC_AX_WDRLS_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("BBRPT\n");
+	base_addr = DMAC_AX_BBRPT_BASE_ADDR;
+	max_addr = DMAC_AX_BBRPT_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("CPUIO\n");
+	base_addr = DMAC_AX_CPUIO_BASE_ADDR;
+	max_addr = DMAC_AX_CPUIO_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("PLTIN\n");
+	base_addr = DMAC_AX_PKTIN_BASE_ADDR;
+	max_addr = DMAC_AX_PKTIN_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("MPDU Processor\n");
+	base_addr = DMAC_AX_MPDU_BASE_ADDR;
+	max_addr = DMAC_AX_MPDU_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("SEC ENG\n");
+	base_addr = DMAC_AX_SEC_BASE_ADDR;
+	max_addr = DMAC_AX_SEC_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("STA scheduler\n");
+	base_addr = DMAC_AX_SS_BASE_ADDR;
+	max_addr = DMAC_AX_SS_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("Tx packet control\n");
+	base_addr = DMAC_AX_TXPKTCTL_BASE_ADDR;
+	max_addr = DMAC_AX_TXPKTCTL_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+
+	PLTFM_MSG_ERR("HCI Common\n");
+	base_addr = DMAC_AX_HCI_BASE_ADDR;
+	max_addr = DMAC_AX_HCI_MAX_ADDR;
+	for (i = 0x0; i <= max_addr; i += 4)
+		PLTFM_MSG_ERR("0x1860%04x = 0x%08x\n", base_addr + i, MAC_REG_R32(base_addr + i));
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/ser.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/ser.h
new file mode 100644
index 000000000000..2cd083614a7b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/ser.h
@@ -0,0 +1,815 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_SER_H_
+#define _MAC_AX_SER_H_
+
+#include "../type.h"
+
+#if MAC_AX_SDIO_SUPPORT
+#include "_sdio.h"
+#endif
+
+#if MAC_AX_PCIE_SUPPORT
+#include "_pcie.h"
+#endif
+
+#if MAC_AX_USB_SUPPORT
+#include "_usb.h"
+#endif
+
+#define SER_ENABLE 0XFFFFFFFF
+#define SER_DISABLE 0X00000000
+#define SEC_DBG_SEL 0x8B
+#define SEC_DBG_PORT_NUM 0x10
+#define SEC_DBG_PORT_FIELD_MSK 0xf
+#define SEC_DBG_PORT_FIELD_SH 16
+
+#if defined(PHL_FEATURE_AP)
+/*--------------------CMAC ERROR ----------------------------------------*/
+/*--------------------CMAC DMA IMR --------------------------------------*/
+// 0xC800
+// bit[14]
+#define CMAC_DMA_RXSTS_FSM_HANG_SER_EN SER_ENABLE
+// bit[15]
+#define CMAC_DMA_RXDATA_FSM_HANG_SER_EN SER_DISABLE
+// bit[23]
+#define CMAC_DMA_NO_RSVD_PAGE_SER_EN SER_DISABLE
+// 0xC828
+// bit[31]
+#define CMAC_DMA_RXDATA_SUBFSM_HANG_SER_EN SER_ENABLE
+
+/*-------------------- PTCL IMR -----------------------------------------*/
+// 0xC6C0
+// bit[0]
+#define PTCL_FSM_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[8]
+#define PTCL_F2PCMDRPT_FULL_DROP_SER_EN SER_DISABLE
+// bit[9]
+#define PTCL_TXRPT_FULL_DROP_SER_EN SER_DISABLE
+// bit[10]
+#define PTCL_D_PKTID_ERR_SER_EN SER_DISABLE
+// bit[11]
+#define PTCL_Q_PKTID_ERR_SER_EN SER_DISABLE
+// bit[12]
+#define PTCL_BCNQ_ORDER_ERR_SER_EN SER_DISABLE
+// bit[14]
+#define PTCL_TWTSP_QSEL_ERR_SER_EN SER_DISABLE
+// bit[15]
+#define PTCL_F2PCMD_EMPTY_ERR_SER_EN SER_DISABLE
+// bit[23]
+#define PTCL_TX_RECORD_PKTID_ERR_SER_EN SER_ENABLE
+// bit[24]
+#define PTCL_TX_SPF_U3_PKTID_ERR_SER_EN SER_DISABLE
+// bit[25]
+#define PTCL_TX_SPF_U2_PKTID_ERR_SER_EN SER_DISABLE
+// bit[26]
+#define PTCL_TX_SPF_U1_PKTID_ERR_SER_EN SER_DISABLE
+// bit[27]
+#define PTCL_TX_SPF_U0_PKTID_ERR_SER_EN SER_DISABLE
+// bit[28]
+#define PTCL_F2PCMD_USER_ALLC_ERR_SER_EN SER_ENABLE
+// bit[29]
+#define PTCL_F2PCMD_ASSIGN_PKTID_ERR_SER_EN SER_DISABLE
+// bit[30]
+#define PTCL_F2PCMD_RD_PKTID_ERR_SER_EN SER_DISABLE
+// bit[31]
+#define PTCL_F2PCMD_PKTID_ERR_SER_EN SER_DISABLE
+
+/*-------------------- Scheduler IMR ------------------------------------*/
+// 0xC3E8 : 0x00000000
+// bit[0]
+#define SCHEDULER_FSM_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[1]
+#define SCHEDULER_SORT_NON_IDLE_ERR_SER_EN SER_DISABLE
+
+/*-------------------- PHY INTF IMR --------------------------------------*/
+// 0xCCFE : 0x0000
+// bit[0]
+#define PHYINTF_PHY_TXON_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[1]
+#define PHYINTF_CCK_CCA_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[2]
+#define PHYINTF_OFDM_CCA_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[3]
+#define PHYINTF_DATA_ON_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[4]
+#define PHYINTF_STS_ON_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[5]
+#define PHYINTF_CSI_ON_TIMEOUT_ERR_SER_EN SER_DISABLE
+
+/*-------------------- RMAC IMR -----------------------------------------*/
+// 0xCEF6
+// bit[4]
+#define RMAC_CCA_TO_RX_IDLE_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[5]
+#define RMAC_DATA_ON_TO_RX_IDLE_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[6]
+#define RMAC_DMA_WRITE_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[7]
+#define RMAC_CCA_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[8]
+#define RMAC_DATA_ON_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[9]
+#define RMAC_CSI_DATA_ON_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[10]
+#define RMAC_RX_FSM_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[11]
+#define RMAC_CSI_MODE_TIMEOUT_ERR_SER_EN SER_ENABLE
+
+/*-------------------- TMAC IMR -----------------------------------------*/
+// 0xCCEC
+// bit[7]
+#define TMAC_MACTX_TIME_ERR_SER_EN SER_ENABLE
+// bit[8]
+#define TMAC_TRXPTCL_TXCTL_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[9]
+#define TMAC_RESPONSE_TXCTL_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[10]
+#define TMAC_TX_PLCP_INFO_ERR_SER_EN SER_ENABLE
+
+#elif defined(PHL_FEATURE_STA)
+/*--------------------CMAC ERROR ----------------------------------------*/
+/*--------------------CMAC DMA IMR --------------------------------------*/
+// 0xC800
+// bit[14]
+#define CMAC_DMA_RXSTS_FSM_HANG_SER_EN SER_ENABLE
+// bit[15]
+#define CMAC_DMA_RXDATA_FSM_HANG_SER_EN SER_DISABLE
+// bit[23]
+#define CMAC_DMA_NO_RSVD_PAGE_SER_EN SER_DISABLE
+// 0xC828
+// bit[31]
+#define CMAC_DMA_RXDATA_SUBFSM_HANG_SER_EN SER_ENABLE
+
+/*-------------------- PTCL IMR -----------------------------------------*/
+// 0xC6C0
+// bit[0]
+#define PTCL_FSM_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[8]
+#define PTCL_F2PCMDRPT_FULL_DROP_SER_EN SER_DISABLE
+// bit[9]
+#define PTCL_TXRPT_FULL_DROP_SER_EN SER_DISABLE
+// bit[10]
+#define PTCL_D_PKTID_ERR_SER_EN SER_DISABLE
+// bit[11]
+#define PTCL_Q_PKTID_ERR_SER_EN SER_DISABLE
+// bit[12]
+#define PTCL_BCNQ_ORDER_ERR_SER_EN SER_DISABLE
+// bit[14]
+#define PTCL_TWTSP_QSEL_ERR_SER_EN SER_DISABLE
+// bit[15]
+#define PTCL_F2PCMD_EMPTY_ERR_SER_EN SER_DISABLE
+// bit[23]
+#define PTCL_TX_RECORD_PKTID_ERR_SER_EN SER_ENABLE
+// bit[24]
+#define PTCL_TX_SPF_U3_PKTID_ERR_SER_EN SER_DISABLE
+// bit[25]
+#define PTCL_TX_SPF_U2_PKTID_ERR_SER_EN SER_DISABLE
+// bit[26]
+#define PTCL_TX_SPF_U1_PKTID_ERR_SER_EN SER_DISABLE
+// bit[27]
+#define PTCL_TX_SPF_U0_PKTID_ERR_SER_EN SER_DISABLE
+// bit[28]
+#define PTCL_F2PCMD_USER_ALLC_ERR_SER_EN SER_ENABLE
+// bit[29]
+#define PTCL_F2PCMD_ASSIGN_PKTID_ERR_SER_EN SER_DISABLE
+// bit[30]
+#define PTCL_F2PCMD_RD_PKTID_ERR_SER_EN SER_DISABLE
+// bit[31]
+#define PTCL_F2PCMD_PKTID_ERR_SER_EN SER_DISABLE
+
+/*-------------------- Scheduler IMR ------------------------------------*/
+// 0xC3E8 : 0x00000000
+// bit[0]
+#define SCHEDULER_FSM_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[1]
+#define SCHEDULER_SORT_NON_IDLE_ERR_SER_EN SER_DISABLE
+
+/*-------------------- PHY INTF IMR --------------------------------------*/
+// 0xCCFE : 0x0000
+// bit[0]
+#define PHYINTF_PHY_TXON_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[1]
+#define PHYINTF_CCK_CCA_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[2]
+#define PHYINTF_OFDM_CCA_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[3]
+#define PHYINTF_DATA_ON_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[4]
+#define PHYINTF_STS_ON_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[5]
+#define PHYINTF_CSI_ON_TIMEOUT_ERR_SER_EN SER_DISABLE
+
+/*-------------------- RMAC IMR -----------------------------------------*/
+// 0xCEF6
+// bit[4]
+#define RMAC_CCA_TO_RX_IDLE_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[5]
+#define RMAC_DATA_ON_TO_RX_IDLE_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[6]
+#define RMAC_DMA_WRITE_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[7]
+#define RMAC_CCA_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[8]
+#define RMAC_DATA_ON_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[9]
+#define RMAC_CSI_DATA_ON_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[10]
+#define RMAC_RX_FSM_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[11]
+#define RMAC_CSI_MODE_TIMEOUT_ERR_SER_EN SER_ENABLE
+
+/*-------------------- TMAC IMR -----------------------------------------*/
+// 0xCCEC
+// bit[7]
+#define TMAC_MACTX_TIME_ERR_SER_EN SER_ENABLE
+// bit[8]
+#define TMAC_TRXPTCL_TXCTL_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[9]
+#define TMAC_RESPONSE_TXCTL_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[10]
+#define TMAC_TX_PLCP_INFO_ERR_SER_EN SER_ENABLE
+
+#else
+/*--------------------CMAC ERROR ----------------------------------------*/
+/*--------------------CMAC DMA IMR --------------------------------------*/
+// 0xC800
+// bit[14]
+#define CMAC_DMA_RXSTS_FSM_HANG_SER_EN SER_ENABLE
+// bit[15]
+#define CMAC_DMA_RXDATA_FSM_HANG_SER_EN SER_DISABLE
+// bit[23]
+#define CMAC_DMA_NO_RSVD_PAGE_SER_EN SER_DISABLE
+// 0xC828
+// bit[31]
+#define CMAC_DMA_RXDATA_SUBFSM_HANG_SER_EN SER_ENABLE
+
+/*-------------------- PTCL IMR -----------------------------------------*/
+// 0xC6C0
+// bit[0]
+#define PTCL_FSM_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[8]
+#define PTCL_F2PCMDRPT_FULL_DROP_SER_EN SER_DISABLE
+// bit[9]
+#define PTCL_TXRPT_FULL_DROP_SER_EN SER_DISABLE
+// bit[10]
+#define PTCL_D_PKTID_ERR_SER_EN SER_DISABLE
+// bit[11]
+#define PTCL_Q_PKTID_ERR_SER_EN SER_DISABLE
+// bit[12]
+#define PTCL_BCNQ_ORDER_ERR_SER_EN SER_DISABLE
+// bit[14]
+#define PTCL_TWTSP_QSEL_ERR_SER_EN SER_DISABLE
+// bit[15]
+#define PTCL_F2PCMD_EMPTY_ERR_SER_EN SER_DISABLE
+// bit[23]
+#define PTCL_TX_RECORD_PKTID_ERR_SER_EN SER_ENABLE
+// bit[24]
+#define PTCL_TX_SPF_U3_PKTID_ERR_SER_EN SER_DISABLE
+// bit[25]
+#define PTCL_TX_SPF_U2_PKTID_ERR_SER_EN SER_DISABLE
+// bit[26]
+#define PTCL_TX_SPF_U1_PKTID_ERR_SER_EN SER_DISABLE
+// bit[27]
+#define PTCL_TX_SPF_U0_PKTID_ERR_SER_EN SER_DISABLE
+// bit[28]
+#define PTCL_F2PCMD_USER_ALLC_ERR_SER_EN SER_ENABLE
+// bit[29]
+#define PTCL_F2PCMD_ASSIGN_PKTID_ERR_SER_EN SER_DISABLE
+// bit[30]
+#define PTCL_F2PCMD_RD_PKTID_ERR_SER_EN SER_DISABLE
+// bit[31]
+#define PTCL_F2PCMD_PKTID_ERR_SER_EN SER_DISABLE
+
+/*-------------------- Scheduler IMR ------------------------------------*/
+// 0xC3E8 : 0x00000000
+// bit[0]
+#define SCHEDULER_FSM_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[1]
+#define SCHEDULER_SORT_NON_IDLE_ERR_SER_EN SER_DISABLE
+
+/*-------------------- PHY INTF IMR --------------------------------------*/
+// 0xCCFE : 0x0000
+// bit[0]
+#define PHYINTF_PHY_TXON_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[1]
+#define PHYINTF_CCK_CCA_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[2]
+#define PHYINTF_OFDM_CCA_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[3]
+#define PHYINTF_DATA_ON_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[4]
+#define PHYINTF_STS_ON_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[5]
+#define PHYINTF_CSI_ON_TIMEOUT_ERR_SER_EN SER_DISABLE
+
+/*-------------------- RMAC IMR -----------------------------------------*/
+// 0xCEF6
+// bit[4]
+#define RMAC_CCA_TO_RX_IDLE_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[5]
+#define RMAC_DATA_ON_TO_RX_IDLE_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[6]
+#define RMAC_DMA_WRITE_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[7]
+#define RMAC_CCA_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[8]
+#define RMAC_DATA_ON_TIMEOUT_ERR_SER_EN SER_DISABLE
+// bit[9]
+#define RMAC_CSI_DATA_ON_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[10]
+#define RMAC_RX_FSM_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[11]
+#define RMAC_CSI_MODE_TIMEOUT_ERR_SER_EN SER_ENABLE
+
+/*-------------------- TMAC IMR -----------------------------------------*/
+// 0xCCEC
+// bit[7]
+#define TMAC_MACTX_TIME_ERR_SER_EN SER_ENABLE
+// bit[8]
+#define TMAC_TRXPTCL_TXCTL_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[9]
+#define TMAC_RESPONSE_TXCTL_TIMEOUT_ERR_SER_EN SER_ENABLE
+// bit[10]
+#define TMAC_TX_PLCP_INFO_ERR_SER_EN SER_ENABLE
+#endif
+
+//WDRLS 0x9430
+//bit[0]
+#define DMAC_WDRLS_CTL_WDPKTID_ISNULL_ERR_SER_EN SER_ENABLE
+//bit[1]
+#define DMAC_WDRLS_CTL_PLPKTID_ISNULL_ERR_SER_EN SER_ENABLE
+//bit[2]
+#define DMAC_WDRLS_CTL_FRZTO_ERR_SER_EN SER_ENABLE
+//bit[4]
+#define DMAC_WDRLS_PLEBREQ_TO_ERR_SER_EN SER_DISABLE
+//bit[5]
+#define DMAC_WDRLS_PLEBREQ_PKTID_ISNULL_ERR_SER_EN SER_ENABLE
+//bit[8]
+#define DMAC_WDRLS_RPT0_AGGNUM0_ERR_SER_EN SER_ENABLE
+//bit[9]
+#define DMAC_WDRLS_RPT0_FRZTO_ERR_SER_EN SER_ENABLE
+//bit[12]
+#define DMAC_WDRLS_RPT1_AGGNUM0_ERR_SER_EN SER_ENABLE
+//bit[13]
+#define DMAC_WDRLS_RPT1_FRZTO_ERR_SER_EN SER_ENABLE
+
+//SEC_DEBUG 0x9D1C
+//bit[3]
+#define DMAC_IMR_ERROR SER_ENABLE
+
+//MPDU_TX_ERR_IMR 0x9BF4
+//bit[1]
+#define DMAC_TX_GET_ERRPKTID_SER_EN SER_DISABLE
+//bit[2]
+#define DMAC_TX_NXT_ERRPKTID_SER_EN SER_DISABLE
+//bit[3]
+#define DMAC_TX_MPDU_SIZE_ZERO_SER_EN SER_DISABLE
+//bit[4]
+#define DMAC_TX_OFFSET_ERR_SER_EN SER_DISABLE
+//bit[5]
+#define DMAC_TX_HDR3_SIZE_ERR_SER_EN SER_DISABLE
+
+//MPDU_RX_ERR_IMR 0x9CF4
+//bit[0]
+#define DMAC_GETPKTID_ERR_SER_EN SER_DISABLE
+//bit[1]
+#define DMAC_MHDRLEN_ERR_SER_EN SER_DISABLE
+//bit[3]
+#define DMAC_RPT_ERR_SER_EN SER_DISABLE
+
+//STA_SCHEDULER_ERR_IMR 0x9EF0
+//bit[0]
+#define DMAC_SEARCH_HANG_TIMEOUT_SER_EN SER_ENABLE
+//bit[1]
+#define DMAC_RPT_HANG_TIMEOUT_SER_EN SER_ENABLE
+//bit[2]
+#define DMAC_PLE_B_PKTID_ERR_SER_EN SER_ENABLE
+
+//TXPKTCTL_ERR_IMR_ISR 0x9F1C
+//bit[0]
+#define DMAC_TXPKTCTL_USRCTL_REINIT_ERR_SER_EN SER_ENABLE
+//bit[1]
+#define DMAC_TXPKTCTL_USRCTL_NOINIT_ERR_SER_EN SER_DISABLE
+//bit[2]
+#define DMAC_TXPKTCTL_USRCTL_RDNRLSCMD_ERR_SER_EN SER_DISABLE
+//bit[3]
+#define DMAC_TXPKTCTL_USRCTL_RLSBMPLEN_ERR_SER_EN SER_DISABLE
+//bit[8]
+#define DMAC_TXPKTCTL_CMDPSR_CMDTYPE_ERR_SER_EN SER_ENABLE
+//bit[9]
+#define DMAC_TXPKTCTL_CMDPSR_FRZTO_ERR_SER_EN SER_DISABLE
+
+//TXPKTCTL_ERR_IMR_ISR_B1 0x9F2C
+//bit[0]
+#define DMAC_TXPKTCTL_USRCTL_REINIT_B1_ERR_SER_EN SER_ENABLE
+//bit[1]
+#define DMAC_TXPKTCTL_USRCTL_NOINIT_B1_ERR_SER_EN SER_ENABLE
+//bit[2]
+#define DMAC_TXPKTCTL_USRCTL_RDNRLSCMD_B1_ERR_SER_EN SER_DISABLE
+//bit[3]
+#define DMAC_TXPKTCTL_USRCTL_RLSBMPLEN_B1_ERR_SER_EN SER_DISABLE
+//bit[8]
+#define DMAC_TXPKTCTL_CMDPSR_CMDTYPE_ERR_B1_SER_EN SER_ENABLE
+//bit[9]
+#define DMAC_TXPKTCTL_CMDPSR_FRZTO_ERR_B1_SER_EN SER_ENABLE
+
+//WDE_ERR_IMR 0x8C38
+//bit[0]
+#define DMAC_WDE_BUFREQ_QTAID_ERR_SER_EN SER_ENABLE
+//bit[1]
+#define DMAC_WDE_BUFREQ_UNAVAL_ERR_SER_EN SER_ENABLE
+//bit[2]
+#define DMAC_WDE_BUFRTN_INVLD_PKTID_ERR_SER_EN SER_ENABLE
+//bit[3]
+#define DMAC_WDE_BUFRTN_SIZE_ERR_SER_EN SER_ENABLE
+//bit[4]
+#define DMAC_WDE_BUFREQ_SRCHTAILPG_ERR_SER_EN SER_ENABLE
+//bit[5]
+#define DMAC_WDE_GETNPG_STRPG_ERR_SER_EN SER_ENABLE
+//bit[6]
+#define DMAC_WDE_GETNPG_PGOFST_ERR_SER_EN SER_ENABLE
+//bit[7]
+#define DMAC_WDE_BUFMGN_FRZTO_ERR_SER_EN SER_ENABLE
+//bit[12]
+#define DMAC_WDE_QUE_CMDTYPE_ERR_SER_EN SER_ENABLE
+//bit[13]
+#define DMAC_WDE_QUE_DSTQUEID_ERR_SER_EN SER_ENABLE
+//bit[14]
+#define DMAC_WDE_QUE_SRCQUEID_ERR_SER_EN SER_ENABLE
+//bit[15]
+#define DMAC_WDE_ENQ_PKTCNT_OVRF_ERR_SER_EN SER_ENABLE
+//bit[16]
+#define DMAC_WDE_ENQ_PKTCNT_NVAL_ERR_SER_EN SER_ENABLE
+//bit[17]
+#define DMAC_WDE_PREPKTLLT_AD_ERR_SER_EN SER_ENABLE
+//bit[18]
+#define DMAC_WDE_NXTPKTLL_AD_ERR_SER_EN SER_ENABLE
+//bit[19]
+#define DMAC_WDE_QUEMGN_FRZTO_ERR_SER_EN SER_ENABLE
+//bit[24]
+#define DMAC_WDE_DATCHN_ARBT_ERR_SER_EN SER_ENABLE
+//bit[25]
+#define DMAC_WDE_DATCHN_NULLPG_ERR_SER_EN SER_ENABLE
+//bit[26]
+#define DMAC_WDE_DATCHN_FRZTO_ERR_SER_EN SER_ENABLE
+
+//PLE_ERR_IMR 0x9038
+//bit[0]
+#define DMAC_PLE_BUFREQ_QTAID_ERR_SER_EN SER_ENABLE
+//bit[1]
+#define DMAC_PLE_BUFREQ_UNAVAL_ERR_SER_EN SER_ENABLE
+//bit[2]
+#define DMAC_PLE_BUFRTN_INVLD_PKTID_ERR_SER_EN SER_ENABLE
+//bit[3]
+#define DMAC_PLE_BUFRTN_SIZE_ERR_SER_EN SER_ENABLE
+//bit[4]
+#define DMAC_PLE_BUFREQ_SRCHTAILPG_ERR_SER_EN SER_ENABLE
+//bit[5]
+#define DMAC_PLE_GETNPG_STRPG_ERR_SER_EN SER_DISABLE
+//bit[6]
+#define DMAC_PLE_GETNPG_PGOFST_ERR_SER_EN SER_ENABLE
+//bit[7]
+#define DMAC_PLE_BUFMGN_FRZTO_ERR_SER_EN SER_ENABLE
+//bit[12]
+#define DMAC_PLE_QUE_CMDTYPE_ERR_SER_EN SER_ENABLE
+//bit[13]
+#define DMAC_PLE_QUE_DSTQUEID_ERR_SER_EN SER_ENABLE
+//bit[14]
+#define DMAC_PLE_QUE_SRCQUEID_ERR_SER_EN SER_ENABLE
+//bit[15]
+#define DMAC_PLE_ENQ_PKTCNT_OVRF_ERR_SER_EN SER_ENABLE
+//bit[16]
+#define DMAC_PLE_ENQ_PKTCNT_NVAL_ERR_SER_EN SER_ENABLE
+//bit[17]
+#define DMAC_PLE_PREPKTLLT_AD_ERR_SER_EN SER_ENABLE
+//bit[18]
+#define DMAC_PLE_NXTPKTLL_AD_ERR_SER_EN SER_ENABLE
+//bit[19]
+#define DMAC_PLE_QUEMGN_FRZTO_ERR_SER_EN SER_ENABLE
+//bit[24]
+#define DMAC_PLE_DATCHN_ARBT_ERR_SER_EN SER_ENABLE
+//bit[25]
+#define DMAC_PLE_DATCHN_NULLPG_ERR_SER_EN SER_ENABLE
+//bit[26]
+#define DMAC_PLE_DATCHN_FRZTO_ERR_SER_EN SER_ENABLE
+
+//PKTIN_ERR_IMR 0x9A20
+//bit[0]
+#define DMAC_PKTIN_GETPKTID_ERR_SER_EN SER_ENABLE
+
+//HOST_DISPATCHER_ERR_IMR 0x8850
+//bit[0]
+#define DMAC_HDT_CHANNEL_DIFF_ERR_SER_EN SER_ENABLE
+//bit[1]
+#define DMAC_HDT_CHANNEL_ID_ERR_SER_EN SER_DISABLE
+//bit[2]
+#define DMAC_HDT_PKT_FAIL_DBG_SER_EN SER_DISABLE
+//bit[3]
+#define DMAC_HDT_PERMU_OVERFLOW_SER_EN SER_DISABLE
+//bit[4]
+#define DMAC_HDT_PERMU_UNDERFLOW_SER_EN SER_DISABLE
+//bit[5]
+#define DMAC_HDT_PAYLOAD_OVERFLOW_SER_EN SER_ENABLE
+//bit[6]
+#define DMAC_HDT_PAYLOAD_UNDERFLOW_SER_EN SER_ENABLE
+//bit[7]
+#define DMAC_HDT_OFFSET_UNMATCH_SER_EN SER_DISABLE
+//bit[8]
+#define DMAC_HDT_CHANNEL_DMA_ERR_SER_EN SER_ENABLE
+//bit[9]
+#define DMAC_HDT_WD_CHK_ERR_SER_EN SER_DISABLE
+//bit[10]
+#define DMAC_HDT_PRE_COST_ERR_SER_EN SER_DISABLE
+//bit[11]
+#define DMAC_HDT_TXPKTSIZE_ERR_SER_EN SER_DISABLE
+//bit[12]
+#define DMAC_HDT_TCP_CHK_ERR_SER_EN SER_DISABLE
+//bit[13]
+#define DMAC_HDT_TX_WRITE_OVERFLOW_SER_EN SER_DISABLE
+//bit[14]
+#define DMAC_HDT_TX_WRITE_UNDERFLOW_SER_EN SER_DISABLE
+//bit[15]
+#define DMAC_HDT_PLD_CMD_OVERLOW_SER_EN SER_DISABLE
+//bit[16]
+#define DMAC_HDT_PLD_CMD_UNDERFLOW_SER_EN SER_DISABLE
+//bit[17]
+#define DMAC_HDT_FLOW_CTRL_ERR_SER_EN SER_DISABLE
+//bit[18]
+#define DMAC_HDT_NULLPKT_ERR_SER_EN SER_DISABLE
+//bit[19]
+#define DMAC_HDT_BURST_NUM_ERR_SER_EN SER_DISABLE
+//bit[24]
+#define DMAC_HDT_RXAGG_CFG_ERR_SER_EN SER_DISABLE
+//bit[25]
+#define DMAC_HDT_SHIFT_EN_ERR_SER_EN SER_DISABLE
+//bit[26]
+#define DMAC_HDT_TOTAL_LEN_ERR_SER_EN SER_ENABLE
+//bit[27]
+#define DMAC_HDT_DMA_PROCESS_ERR_SER_EN SER_ENABLE
+//bit[28]
+#define DMAC_HDT_SHIFT_DMA_CFG_ERR_SER_EN SER_DISABLE
+//bit[29]
+#define DMAC_HDT_CHKSUM_FSM_ERR_SER_EN SER_DISABLE
+//bit[30]
+#define DMAC_HDT_RX_WRITE_OVERFLOW_SER_EN SER_ENABLE
+//bit[31]
+#define DMAC_HDT_RX_WRITE_UNDERFLOW_SER_EN SER_ENABLE
+
+//CPU_DISPATCHER_ERR_IMR 0x8854
+//bit[0]
+#define DMAC_CPU_CHANNEL_DIFF_ERR_SER_EN SER_DISABLE
+//bit[1]
+#define DMAC_CPU_PKT_FAIL_DBG_SER_EN SER_ENABLE
+//bit[2]
+#define DMAC_CPU_CHANNEL_ID_ERR_SER_EN SER_DISABLE
+//bit[3]
+#define DMAC_CPU_PERMU_OVERFLOW_SER_EN SER_DISABLE
+//bit[4]
+#define DMAC_CPU_PERMU_UNDERFLOW_SER_EN SER_DISABLE
+//bit[5]
+#define DMAC_CPU_PAYLOAD_OVERFLOW_SER_EN SER_ENABLE
+//bit[6]
+#define DMAC_CPU_PAYLOAD_UNDERFLOW_SER_EN SER_ENABLE
+//bit[7]
+#define DMAC_CPU_PAYLOAD_CHKSUM_ERR_SER_EN SER_DISABLE
+//bit[8]
+#define DMAC_CPU_OFFSET_UNMATCH_SER_EN SER_DISABLE
+//bit[9]
+#define DMAC_CPU_CHANNEL_DMA_ERR_SER_EN SER_DISABLE
+//bit[10]
+#define DMAC_CPU_WD_CHK_ERR_SER_EN SER_DISABLE
+//bit[11]
+#define DMAC_CPU_PRE_COST_ERR_SER_EN SER_DISABLE
+//bit[12]
+#define DMAC_CPU_PLD_CMD_OVERLOW_SER_EN SER_DISABLE
+//bit[13]
+#define DMAC_CPU_PLD_CMD_UNDERFLOW_SER_EN SER_DISABLE
+//bit[14]
+#define DMAC_CPU_F2P_QSEL_ERR_SER_EN SER_DISABLE
+//bit[15]
+#define DMAC_CPU_F2P_SEQ_ERR_SER_EN SER_DISABLE
+//bit[16]
+#define DMAC_CPU_FLOW_CTRL_ERR_SER_EN SER_DISABLE
+//bit[17]
+#define DMAC_CPU_NULLPKT_ERR_SER_EN SER_DISABLE
+//bit[18]
+#define DMAC_CPU_BURST_NUM_ERR_SER_EN SER_DISABLE
+//bit[24]
+#define DMAC_CPU_RXAGG_CFG_ERR_SER_EN SER_DISABLE
+//bit[25]
+#define DMAC_CPU_SHIFT_EN_ERR_SER_EN SER_DISABLE
+//bit[26]
+#define DMAC_CPU_TOTAL_LEN_ERR_SER_EN SER_ENABLE
+//bit[27]
+#define DMAC_CPU_DMA_PROCESS_ERR_SER_EN SER_DISABLE
+//bit[28]
+#define DMAC_CPU_SHIFT_DMA_CFG_ERR_SER_EN SER_DISABLE
+//bit[29]
+#define DMAC_CPU_CHKSUM_FSM_ERR_SER_EN SER_DISABLE
+
+//OTHER_DISPATCHER_ERR_IMR 0x8858
+//bit[0]
+#define DMAC_WDE_FLOW_CTRL_ERR_SER_EN SER_DISABLE
+//bit[1]
+#define DMAC_WDE_NULL_PKT_ERR_SER_EN SER_DISABLE
+//bit[2]
+#define DMAC_WDE_BURST_NUM_ERR_SER_EN SER_DISABLE
+//bit[3]
+#define DMAC_WDE_RESP_ERR_SER_EN SER_DISABLE
+//bit[4]
+#define DMAC_WDE_OUTPUT_ERR_SER_EN SER_DISABLE
+//bit[8]
+#define DMAC_PLE_FLOW_CTRL_ERR_SER_EN SER_DISABLE
+//bit[9]
+#define DMAC_PLE_NULL_PKT_ERR_SER_EN SER_DISABLE
+//bit[10]
+#define DMAC_PLE_BURST_NUM_ERR_SER_EN SER_DISABLE
+//bit[11]
+#define DMAC_PLE_RESP_ERR_SER_EN SER_DISABLE
+//bit[12]
+#define DMAC_PLE_OUTPUT_ERR_SER_EN SER_DISABLE
+//bit[16]
+#define DMAC_CPU_ADDR_INFO_LEN_ZERO_ERR_SER_EN SER_DISABLE
+//bit[17]
+#define DMAC_HOST_ADDR_INFO_LEN_ZERO_ERR_SER_EN SER_DISABLE
+//bit[24]
+#define DMAC_OTHER_STF_CMD_OVERFLOW_SER_EN SER_DISABLE
+//bit[25]
+#define DMAC_OTHER_STF_CMD_UNDERFLOW_SER_EN SER_DISABLE
+//bit[26]
+#define DMAC_OTHER_STF_WRFF_OVERFLOW_SER_EN SER_DISABLE
+//bit[27]
+#define DMAC_OTHER_STF_WRFF_UNDERFLOW_SER_EN SER_DISABLE
+//bit[28]
+#define DMAC_OTHER_STF_WROQT_OVERFLOW_SER_EN SER_DISABLE
+//bit[29]
+#define DMAC_OTHER_STF_WROQT_UNDERFLOW_SER_EN SER_DISABLE
+
+//CPUIO_ERR_IMR 0x9840
+//bit[0]
+#define DMAC_WDEBUF_OP_ERR_SER_EN SER_ENABLE
+//bit[4]
+#define DMAC_WDEQUE_OP_ERR_SER_EN SER_ENABLE
+//bit[8]
+#define DMAC_PLEBUF_OP_ERR_SER_EN SER_ENABLE
+//bit[12]
+#define DMAC_PLEQUE_OP_ERR_SER_EN SER_ENABLE
+
+//BBRPT_COM_ERR_IMR_ISR 0x960C
+//bit[0]
+#define DMAC_BBRPT_COM_NULL_PLPKTID_ERR_SER_EN SER_ENABLE
+
+//BBRPT_CHINFO_ERR_IMR_ISR 0x962C
+//bit[0]
+#define DMAC_BBPRT_CHIF_BB_TO_ERR_SER_EN SER_DISABLE
+//bit[1]
+#define DMAC_BBPRT_CHIF_OVF_ERR_SER_EN SER_DISABLE
+//bit[2]
+#define DMAC_BBPRT_CHIF_BOVF_ERR_SER_EN SER_DISABLE
+//bit[3]
+#define DMAC_BBPRT_CHIF_HDRL_ERR_SER_EN SER_DISABLE
+//bit[4]
+#define DMAC_BBPRT_CHIF_LEFT1_ERR_SER_EN SER_DISABLE
+//bit[5]
+#define DMAC_BBPRT_CHIF_LEFT2_ERR_SER_EN SER_DISABLE
+//bit[6]
+#define DMAC_BBPRT_CHIF_NULL_ERR_SER_EN SER_DISABLE
+//bit[7]
+#define DMAC_BBPRT_CHIF_TO_ERR_SER_EN SER_DISABLE
+
+//BBRPT_DFS_ERR_IMR_ISR 0x963C
+//bit[0]
+#define DMAC_BBRPT_DFS_TO_ERR_SER_EN SER_ENABLE
+
+//LA_ERRFLAG 0x966C
+//bit[0]
+#define DMAC_LA_IMR_DATA_LOSS_ERR SER_ENABLE
+
+/*--------------------Define -------------------------------------------*/
+#define MAC_SET_ERR_DLY_CNT 200
+#define MAC_SET_ERR_DLY_US 50
+
+#define DMAC_ERR_IMR_MASK 0xFFFFFFFF
+#define DMAC_ERR_IMR_EN 0xFFFFFFFF
+#define CMAC0_ERR_IMR_MASK 0xFFFFFFFF
+#define CMAC0_ERR_IMR_EN 0xFFFFFFFF
+#define CMAC1_ERR_IMR_MASK 0xFFFFFFFF
+#define CMAC1_ERR_IMR_EN 0xFFFFFFFF
+#define DMAC_ERR_IMR_DIS 0
+#define CMAC0_ERR_IMR_DIS 0
+#define CMAC1_ERR_IMR_DIS 0
+
+#define FW_ST_MSK 0xFFFF
+#define FW_ST_SH 8
+#define FW_ST_ERR_IN 0x11
+
+#define MAC_SER_STOP_DLY_CNT 200
+#define MAC_SER_STOP_DLY_US 50
+
+#define CMAC_AX_COMMON_BASE_ADDR 0xC000
+#define CMAC_AX_COMMON_BASE_ADDR_C1 0xE000
+#define CMAC_AX_COMMON_MAX_ADDR 0x1FC
+#define CMAC_AX_SCH_BASE_ADDR 0xC200
+#define CMAC_AX_SCH_BASE_ADDR_C1 0xE200
+#define CMAC_AX_SCH_MAX_ADDR 0x3FC
+#define CMAC_AX_PTCL_BASE_ADDR 0xC600
+#define CMAC_AX_PTCL_BASE_ADDR_C1 0xE600
+#define CMAC_AX_PTCL_MAX_ADDR 0x1FC
+#define CMAC_AX_CDMA_BASE_ADDR 0xC800
+#define CMAC_AX_CDMA_BASE_ADDR_C1 0xE800
+#define CMAC_AX_CDMA_MAX_ADDR 0x2FC
+#define CMAC_AX_TMAC_BASE_ADDR 0xCA00
+#define CMAC_AX_TMAC_BASE_ADDR_C1 0xEA00
+#define CMAC_AX_TMAC_MAX_ADDR 0xFC
+#define CMAC_AX_TRXPTCL_BASE_ADDR 0xCC00
+#define CMAC_AX_TRXPTCL_BASE_ADDR_C1 0xEC00
+#define CMAC_AX_TRXPTCL_MAX_ADDR 0x1FC
+#define CMAC_AX_RMAC_BASE_ADDR 0xCE00
+#define CMAC_AX_RMAC_BASE_ADDR_C1 0xEE00
+#define CMAC_AX_RMAC_MAX_ADDR 0x1FC
+#define CMAC_AX_PWR_BASE_ADDR 0xD200
+#define CMAC_AX_PWR_BASE_ADDR_C1 0xF200
+#define CMAC_AX_PWR_MAX_ADDR 0x7FC
+#define CMAC_AX_BTCOEX_BASE_ADDR 0xDA00
+#define CMAC_AX_BTCOEX_BASE_ADDR_C1 0xFA00
+#define CMAC_AX_BTCOEX_MAX_ADDR 160
+
+#define DMAC_AX_TOP_OFF_BASE_ADDR 0x7000
+#define DMAC_AX_TOP_OFF_MAX_ADDR 0x2FC
+#define DMAC_AX_WL_PON_BASE_ADDR 0x7800
+#define DMAC_AX_WL_PON_MAX_ADDR 0x154
+#define DMAC_AX_COMMON_BASE_ADDR 0x8400
+#define DMAC_AX_COMMON_MAX_ADDR 0x3FC
+#define DMAC_AX_DISPATCHER_BASE_ADDR 0x8800
+#define DMAC_AX_DISPATCHER_MAX_ADDR 0x15C
+#define DMAC_AX_WDE_BASE_ADDR 0x8C00
+#define DMAC_AX_WDE_MAX_ADDR 0x18C
+#define DMAC_AX_PLE_BASE_ADDR 0x9000
+#define DMAC_AX_PLE_MAX_ADDR 0x13C
+#define DMAC_AX_WDRLS_BASE_ADDR 0x9400
+#define DMAC_AX_WDRLS_MAX_ADDR 0x7C
+#define DMAC_AX_BBRPT_BASE_ADDR 0x9600
+#define DMAC_AX_BBRPT_MAX_ADDR 0x8C
+#define DMAC_AX_CPUIO_BASE_ADDR 0x9800
+#define DMAC_AX_CPUIO_MAX_ADDR 0x8C
+#define DMAC_AX_PKTIN_BASE_ADDR 0x9A00
+#define DMAC_AX_PKTIN_MAX_ADDR 0x48
+#define DMAC_AX_MPDU_BASE_ADDR 0x9B00
+#define DMAC_AX_MPDU_MAX_ADDR 0x1FC
+#define DMAC_AX_SEC_BASE_ADDR 0x9D00
+#define DMAC_AX_SEC_MAX_ADDR 0xFC
+#define DMAC_AX_SS_BASE_ADDR 0x9E00
+#define DMAC_AX_SS_MAX_ADDR 0xFC
+#define DMAC_AX_TXPKTCTL_BASE_ADDR 0x9F00
+#define DMAC_AX_TXPKTCTL_MAX_ADDR 0xFC
+#define DMAC_AX_HCI_BASE_ADDR 0x6000
+#define DMAC_AX_HCI_MAX_ADDR 0xFC
+/*--------------------Define Enum---------------------------------------*/
+enum WCPU_ERR_SCENARIO {
+	RXI300_ERROR = 1,
+	CPU_EXCEPTION  = 2,
+	ASSERTION  = 3,
+	WDT_ALARM = 4,
+};
+
+/*--------------------Define MACRO--------------------------------------*/
+/*--------------------Define Struct-------------------------------------*/
+/*--------------------Function declaration------------------------------*/
+u32 mac_trigger_cmac_err(struct mac_ax_adapter *adapter);
+u32 mac_trigger_cmac1_err(struct mac_ax_adapter *adapter);
+u32 mac_trigger_dmac_err(struct mac_ax_adapter *adapter);
+
+u32 mac_dump_err_status(struct mac_ax_adapter *adapter,
+			enum mac_ax_err_info err);
+u32 mac_set_err_status(struct mac_ax_adapter *adapter,
+		       enum mac_ax_err_info err);
+u32 mac_get_err_status(struct mac_ax_adapter *adapter,
+		       enum mac_ax_err_info *err);
+
+u32 mac_lv1_rcvy(struct mac_ax_adapter *adapter,
+		 enum mac_ax_lv1_rcvy_step step);
+
+u32 mac_err_imr_ctrl(struct mac_ax_adapter *adapter, enum mac_ax_func_sw sw);
+u32 mac_ser_ctrl(struct mac_ax_adapter *adapter, enum mac_ax_func_sw sw);
+u32 mac_chk_err_status(struct mac_ax_adapter *adapter, u8 *ser_status);
+u32 mac_dbg_log_dump(struct mac_ax_adapter *adapter);
+u32 mac_dbg_log_lvl_adjust(struct mac_ax_adapter *adapter, struct mac_debug_log_lvl *lvl);
+u32 mac_dump_ser_cnt(struct mac_ax_adapter *adapter, struct mac_ser_status *status);
+u32 mac_set_l0_dbg_mode(struct mac_ax_adapter *adapter);
+u32 mac_set_l1_dbg_mode(struct mac_ax_adapter *adapter);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sounding.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sounding.c
new file mode 100644
index 000000000000..5a3e4076ac92
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sounding.c
@@ -0,0 +1,3404 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "sounding.h"
+
+static u32 _patch_snd_ple_modify(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u16 cr;
+
+	if (!chk_patch_snd_ple_modify(adapter))
+		return MACSUCCESS;
+
+	cr = band ? R_AX_BFMEE_RESP_OPTION_C1 : R_AX_BFMEE_RESP_OPTION;
+	val32 = MAC_REG_R32(cr);
+	val32 = SET_CLR_WORD(val32, PATCH_NDP_RX_STANDBY_TIMER, B_AX_BFMEE_NDP_RX_STANDBY_TIMER);
+	MAC_REG_W32(cr, val32);
+
+	return MACSUCCESS;
+}
+
+static u32 _patch_snd_fifofull_err(struct mac_ax_adapter *adapter, u8 band)
+{
+#if MAC_AX_USB_SUPPORT
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u16 cr, val16;
+
+	if (!chk_patch_snd_fifofull_err(adapter))
+		return MACSUCCESS;
+
+	if (get_usb_mode(adapter) == MAC_AX_USB2) {
+		cr = band ? R_AX_DLK_PROTECT_CTL_C1 : R_AX_DLK_PROTECT_CTL;
+		val16 = MAC_REG_R16(cr) | B_AX_RX_DLK_RST_FSM;
+		MAC_REG_W16(cr, val16);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 _patch_csi_append_zero(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u16 cr;
+
+	cr = band ? R_AX_CSIRPT_OPTION_C1 : R_AX_CSIRPT_OPTION;
+	val32 = MAC_REG_R32(cr);
+	val32 &= ~B_AX_CSIRPT_EMPTY_APPZERO;
+	MAC_REG_W32(cr, val32);
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_csi_buffer_index(struct mac_ax_adapter *adapter, u8 band,
+			     u8 csi_buffer_id)
+{
+	u32 val32, ret;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+	if (csi_buffer_id > CSI_MAX_BUFFER_IDX)
+		return MACCSIBUFIDERR;
+
+	val32 = MAC_REG_R32((band ? R_AX_BFMER_CSI_BUFF_IDX0_C1 :
+			    R_AX_BFMER_CSI_BUFF_IDX0) + CSI_SH * csi_buffer_id);
+	return val32;
+}
+
+u32 mac_set_csi_buffer_index(struct mac_ax_adapter *adapter, u8 band,
+			     u8 macid, u16 csi_buffer_id, u16 buffer_idx)
+{
+	u32 val32, ret;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+#if MAC_AX_FW_REG_OFLD
+	u16 cr;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+		if (ret != MACSUCCESS)
+			return ret;
+		if (csi_buffer_id > CSI_MAX_BUFFER_IDX)
+			return MACCSIBUFIDERR;
+
+		cr = (band ? R_AX_BFMER_CSI_BUFF_IDX0_C1 :
+			  R_AX_BFMER_CSI_BUFF_IDX0) + (CSI_SH * csi_buffer_id);
+		val32 = (buffer_idx & B_AX_MER_TXBF_CSI_BUFF_IDX0_MSK)
+			 << B_AX_MER_SND_CSI_BUFF_IDX0_SH |
+			 (macid & B_AX_MER_CSI_BUFF_MACID_IDX0_MSK);
+
+		ret = MAC_REG_W32_OFLD(cr, val32, 1);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+	if (csi_buffer_id > CSI_MAX_BUFFER_IDX)
+		return MACCSIBUFIDERR;
+
+	val32 = (buffer_idx & B_AX_MER_TXBF_CSI_BUFF_IDX0_MSK)
+		 << B_AX_MER_SND_CSI_BUFF_IDX0_SH |
+		 (macid & B_AX_MER_CSI_BUFF_MACID_IDX0_MSK);
+
+	MAC_REG_W32((band ? R_AX_BFMER_CSI_BUFF_IDX0_C1 :
+		    R_AX_BFMER_CSI_BUFF_IDX0) + CSI_SH * csi_buffer_id, val32);
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_snd_sts_index(struct mac_ax_adapter *adapter, u8 band, u8 index)
+{
+	u32 va32, ret;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (index > SOUNDING_STS_MAX_IDX)
+		return MACSNDSTSIDERR;
+
+	va32 = MAC_REG_R16((band ? R_AX_BFMER_ASSOCIATED_SU0_C1 :
+			   R_AX_BFMER_ASSOCIATED_SU0) + SND_SH * index);
+	return va32;
+}
+
+u32 mac_set_snd_sts_index(struct mac_ax_adapter *adapter,  u8 band, u8 macid,
+			  u8 index)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret;
+
+#if MAC_AX_FW_REG_OFLD
+	u16 cr, val16;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		if (index > SOUNDING_STS_MAX_IDX)
+			return MACSNDSTSIDERR;
+
+		cr = (band ? R_AX_BFMER_ASSOCIATED_SU0_C1 :
+			   R_AX_BFMER_ASSOCIATED_SU0) + (SND_SH * index);
+		val16 = B_AX_MER_SU_BFMEE0_EN | macid;
+
+		ret = MAC_REG_W16_OFLD(cr, val16, 1);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (index > SOUNDING_STS_MAX_IDX)
+		return MACSNDSTSIDERR;
+
+	MAC_REG_W16((band ? R_AX_BFMER_ASSOCIATED_SU0_C1 :
+		   R_AX_BFMER_ASSOCIATED_SU0) + SND_SH * index,
+		   B_AX_MER_SU_BFMEE0_EN | macid);
+	return MACSUCCESS;
+}
+
+u32 mac_init_snd_mer(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, ret;
+
+#if MAC_AX_FW_REG_OFLD
+	u16 cr;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		cr = band ? R_AX_BFMER_CTRL_0_C1 : R_AX_BFMER_CTRL_0;
+		val32 = B_AX_BFMER_NDP_BFEN;
+		val32 |= HT_PAYLOAD_OFFSET << B_AX_BFMER_HT_CSI_OFFSET_SH;
+		val32 |= VHT_PAYLOAD_OFFSET << B_AX_BFMER_VHT_CSI_OFFSET_SH;
+		val32 |= HE_PAYLOAD_OFFSET << B_AX_BFMER_HE_CSI_OFFSET_SH;
+
+		ret = MAC_REG_W32_OFLD(cr, val32, 1);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	val32 = B_AX_BFMER_NDP_BFEN;
+	val32 |= HT_PAYLOAD_OFFSET << B_AX_BFMER_HT_CSI_OFFSET_SH;
+	val32 |= VHT_PAYLOAD_OFFSET << B_AX_BFMER_VHT_CSI_OFFSET_SH;
+	val32 |= HE_PAYLOAD_OFFSET << B_AX_BFMER_HE_CSI_OFFSET_SH;
+	MAC_REG_W32(band ? R_AX_BFMER_CTRL_0_C1 : R_AX_BFMER_CTRL_0, val32);
+	return MACSUCCESS;
+}
+
+u32 mac_init_snd_mee(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, ret;
+
+#if MAC_AX_FW_REG_OFLD
+	u32 mask;
+	u16 cr;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		cr = band ? R_AX_TRXPTCL_RESP_CSI_RRSC_C1 : R_AX_TRXPTCL_RESP_CSI_RRSC;
+		val32 = CSI_RRSC_BMAP;
+
+		ret = MAC_REG_W32_OFLD(cr, val32, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+
+		cr = band ? R_AX_BFMEE_RESP_OPTION_C1 : R_AX_BFMEE_RESP_OPTION;
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			val32 = (BFRP_RX_STANDBY_TIMER << B_AX_BFMEE_BFRP_RX_STANDBY_TIMER_SH);
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+			   is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+			   is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+			   is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			val32 = (BFRP_RX_STANDBY_TIMER_V1 << B_AX_BFMEE_BFRP_RX_STANDBY_TIMER_SH);
+		} else {
+			return MACCHIPID;
+		}
+		val32 |= (NDP_RX_STANDBY_TIMER << B_AX_BFMEE_NDP_RX_STANDBY_TIMER_SH);
+		val32 |= (B_AX_BFMEE_HT_NDPA_EN | B_AX_BFMEE_VHT_NDPA_EN |
+			  B_AX_BFMEE_HE_NDPA_EN);
+		ret = MAC_REG_W32_OFLD(cr, val32, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB)) {
+			cr = band ? R_AX_TRXPTCL_ERROR_INDICA_MASK_C1 :
+				    R_AX_TRXPTCL_ERROR_INDICA_MASK;
+			mask = B_AX_RMAC_CSI;
+			ret = write_mac_reg_ofld(adapter, cr, mask, 0, 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n",
+					      __func__, cr);
+				return ret;
+			}
+		}
+
+		cr = band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+			    R_AX_TRXPTCL_RESP_CSI_CTRL_0;
+		val32 = (B_AX_BFMEE_BFPARAM_SEL | B_AX_BFMEE_USE_NSTS |
+			  B_AX_BFMEE_CSI_GID_SEL | B_AX_BFMEE_CSI_FORCE_RETE_EN);
+		ret = MAC_REG_W32_OFLD(cr, val32, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+
+		cr = band ? R_AX_CSIRPT_OPTION_C1 : R_AX_CSIRPT_OPTION;
+		mask = B_AX_CSIPRT_VHTSU_AID_EN;
+		ret = write_mac_reg_ofld(adapter, cr, mask, 1, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		mask = B_AX_CSIPRT_HESU_AID_EN;
+		ret = write_mac_reg_ofld(adapter, cr, mask, 1, 1);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	/*AP mode set tx gid to 63*/
+	/*STA mode set tx gid to 0(default)*/
+	val32 = MAC_REG_R32(band ? R_AX_BFMER_CTRL_0_C1 : R_AX_BFMER_CTRL_0);
+	val32 |= B_AX_BFMER_NDP_BFEN;
+	MAC_REG_W32(band ? R_AX_BFMER_CTRL_0_C1 : R_AX_BFMER_CTRL_0, val32);
+
+	MAC_REG_W32(band ? R_AX_TRXPTCL_RESP_CSI_RRSC_C1 :
+		    R_AX_TRXPTCL_RESP_CSI_RRSC, CSI_RRSC_BMAP);
+
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		val32 = (BFRP_RX_STANDBY_TIMER << B_AX_BFMEE_BFRP_RX_STANDBY_TIMER_SH);
+		val32 |= (NDP_RX_STANDBY_TIMER << B_AX_BFMEE_NDP_RX_STANDBY_TIMER_SH);
+		val32 |= (B_AX_BFMEE_HT_NDPA_EN | B_AX_BFMEE_VHT_NDPA_EN |
+			  B_AX_BFMEE_HE_NDPA_EN);
+		MAC_REG_W32(band ? R_AX_BFMEE_RESP_OPTION_C1 :
+				    R_AX_BFMEE_RESP_OPTION, val32);
+	}
+#endif
+
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		val32 = MAC_REG_R32(band ? R_AX_TRXPTCL_ERROR_INDICA_MASK_C1 :
+				    R_AX_TRXPTCL_ERROR_INDICA_MASK);
+		val32 &= (~B_AX_RMAC_CSI);
+		MAC_REG_W32(band ? R_AX_TRXPTCL_ERROR_INDICA_MASK_C1 :
+			    R_AX_TRXPTCL_ERROR_INDICA_MASK, val32);
+		val32 = (BFRP_RX_STANDBY_TIMER_V1 << B_AX_BFMEE_CSI_RELEASE_TIMER_SH);
+		val32 |= (NDP_RX_STANDBY_TIMER << B_AX_BFMEE_NDP_RX_TIMEOUT_SH);
+		val32 |= (B_AX_BFMEE_HT_NDPA_EN | B_AX_BFMEE_VHT_NDPA_EN |
+			  B_AX_BFMEE_HE_NDPA_EN);
+		MAC_REG_W32(band ? R_AX_BFMEE_RESP_OPTION_C1 :
+				    R_AX_BFMEE_RESP_OPTION, val32);
+	}
+#endif
+
+	val32 = MAC_REG_R32(band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+			    R_AX_TRXPTCL_RESP_CSI_CTRL_0);
+	val32 |= (B_AX_BFMEE_BFPARAM_SEL | B_AX_BFMEE_USE_NSTS |
+		  B_AX_BFMEE_CSI_GID_SEL | B_AX_BFMEE_CSI_FORCE_RETE_EN);
+	MAC_REG_W32(band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+		    R_AX_TRXPTCL_RESP_CSI_CTRL_0, val32);
+
+	val32 = MAC_REG_R32(band ? R_AX_CSIRPT_OPTION_C1 : R_AX_CSIRPT_OPTION);
+	val32 |= (B_AX_CSIPRT_VHTSU_AID_EN | B_AX_CSIPRT_HESU_AID_EN);
+	MAC_REG_W32(band ? R_AX_CSIRPT_OPTION_C1 : R_AX_CSIRPT_OPTION, val32);
+	_patch_snd_ple_modify(adapter, band);
+	_patch_snd_fifofull_err(adapter, band);
+	_patch_csi_append_zero(adapter, band);
+	return MACSUCCESS;
+}
+
+u32 mac_csi_force_rate(struct mac_ax_adapter *adapter, u8 band, u8 ht_rate,
+		       u8 vht_rate, u8 he_rate)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, ret;
+
+#if MAC_AX_FW_REG_OFLD
+	u32 mask;
+	u16 cr;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		cr = band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 : R_AX_TRXPTCL_RESP_CSI_CTRL_0;
+		mask = B_AX_BFMEE_CSI_FORCE_RETE_EN;
+		ret = write_mac_reg_ofld(adapter, cr, mask, 1, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		mask = B_AX_BFMEE_BFPARAM_SEL;
+		ret = write_mac_reg_ofld(adapter, cr, mask, 1, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+
+		cr = band ? R_AX_TRXPTCL_RESP_CSI_RATE_C1 : R_AX_TRXPTCL_RESP_CSI_RATE;
+		mask |= B_AX_BFMEE_HT_CSI_RATE_MSK;
+		mask |= B_AX_BFMEE_VHT_CSI_RATE_MSK << B_AX_BFMEE_VHT_CSI_RATE_SH;
+		mask |= B_AX_BFMEE_HE_CSI_RATE_MSK << B_AX_BFMEE_HE_CSI_RATE_SH;
+		val32 = ((u32)ht_rate | ((u32)vht_rate << B_AX_BFMEE_VHT_CSI_RATE_SH) |
+			 ((u32)he_rate << B_AX_BFMEE_HE_CSI_RATE_SH));
+		ret = write_mac_reg_ofld(adapter, cr, mask, val32, 1);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	val32 = MAC_REG_R32(band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+			    R_AX_TRXPTCL_RESP_CSI_CTRL_0);
+	val32 |= B_AX_BFMEE_CSI_FORCE_RETE_EN | B_AX_BFMEE_BFPARAM_SEL;
+	MAC_REG_W32(band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+		    R_AX_TRXPTCL_RESP_CSI_CTRL_0, val32);
+
+	val32 = ((u32)ht_rate | ((u32)vht_rate << B_AX_BFMEE_VHT_CSI_RATE_SH) |
+		 ((u32)he_rate << B_AX_BFMEE_HE_CSI_RATE_SH));
+	MAC_REG_W32(band ? R_AX_TRXPTCL_RESP_CSI_RATE_C1 :
+		    R_AX_TRXPTCL_RESP_CSI_RATE, val32);
+	return MACSUCCESS;
+}
+
+u32 mac_csi_rrsc(struct mac_ax_adapter *adapter, u8 band, u32 rrsc)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, ret;
+
+#if MAC_AX_FW_REG_OFLD
+	u32 mask;
+	u16 cr;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		cr = band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 : R_AX_TRXPTCL_RESP_CSI_CTRL_0;
+		mask = B_AX_BFMEE_CSI_FORCE_RETE_EN;
+		ret = write_mac_reg_ofld(adapter, cr, mask, 0, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		mask = B_AX_BFMEE_BFPARAM_SEL;
+		ret = write_mac_reg_ofld(adapter, cr, mask, 1, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+
+		cr = band ? R_AX_TRXPTCL_RESP_CSI_RRSC_C1 : R_AX_TRXPTCL_RESP_CSI_RRSC;
+		val32 = rrsc;
+		ret = MAC_REG_W32_OFLD(cr, val32, 1);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	val32 = MAC_REG_R32(band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+			    R_AX_TRXPTCL_RESP_CSI_CTRL_0);
+	val32 |= B_AX_BFMEE_BFPARAM_SEL;
+	val32 &= (~B_AX_BFMEE_CSI_FORCE_RETE_EN);
+	MAC_REG_W32(band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+		    R_AX_TRXPTCL_RESP_CSI_CTRL_0, val32);
+	MAC_REG_W32(band ? R_AX_TRXPTCL_RESP_CSI_RRSC_C1 :
+		    R_AX_TRXPTCL_RESP_CSI_RRSC, rrsc);
+	return MACSUCCESS;
+}
+
+u32 mac_set_mu_table(struct mac_ax_adapter *adapter,
+		     struct mac_mu_table *mu_table)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+#if MAC_AX_FW_REG_OFLD
+		u32 val32, ret;
+		u16 cr;
+
+		if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+			cr = R_AX_SS_MU_CTRL;
+			val32 = mu_table->mu_score_tbl_ctrl;
+			ret = MAC_REG_W32_OFLD(cr, val32, 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+				return ret;
+			}
+
+			cr = R_AX_SS_MU_TBL_0;
+			val32 = mu_table->mu_score_tbl_0;
+			ret = MAC_REG_W32_OFLD(cr, val32, 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+				return ret;
+			}
+
+			cr = R_AX_SS_MU_TBL_1;
+			val32 = mu_table->mu_score_tbl_1;
+			ret = MAC_REG_W32_OFLD(cr, val32, 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+				return ret;
+			}
+
+			cr = R_AX_SS_MU_TBL_2;
+			val32 = mu_table->mu_score_tbl_2;
+			ret = MAC_REG_W32_OFLD(cr, val32, 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+				return ret;
+			}
+
+			cr = R_AX_SS_MU_TBL_3;
+			val32 = mu_table->mu_score_tbl_3;
+			ret = MAC_REG_W32_OFLD(cr, val32, 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+				return ret;
+			}
+
+			cr = R_AX_SS_MU_TBL_4;
+			val32 = mu_table->mu_score_tbl_4;
+			ret = MAC_REG_W32_OFLD(cr, val32, 0);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+				return ret;
+			}
+
+			cr = R_AX_SS_MU_TBL_5;
+			val32 = mu_table->mu_score_tbl_5;
+			ret = MAC_REG_W32_OFLD(cr, val32, 1);
+			if (ret) {
+				PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+				return ret;
+			}
+			return MACSUCCESS;
+		}
+#endif
+		MAC_REG_W32(R_AX_SS_MU_CTRL, mu_table->mu_score_tbl_ctrl);
+		MAC_REG_W32(R_AX_SS_MU_TBL_0, mu_table->mu_score_tbl_0);
+		MAC_REG_W32(R_AX_SS_MU_TBL_1, mu_table->mu_score_tbl_1);
+		MAC_REG_W32(R_AX_SS_MU_TBL_2, mu_table->mu_score_tbl_2);
+		MAC_REG_W32(R_AX_SS_MU_TBL_3, mu_table->mu_score_tbl_3);
+		MAC_REG_W32(R_AX_SS_MU_TBL_4, mu_table->mu_score_tbl_4);
+		MAC_REG_W32(R_AX_SS_MU_TBL_5, mu_table->mu_score_tbl_5);
+		return MACSUCCESS;
+	}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	//For 8852C and 8192XB,
+	//the MU Score Table CR are replaced by SS DL Group Table CR(same with RU)
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		return mac_ops->ss_dl_grp_upd(adapter, mu_table->dlmu_grp_info);
+	}
+#endif
+	return MACNOTSUP;
+}
+
+u32 mac_set_csi_para_reg(struct mac_ax_adapter *adapter,
+			 struct mac_reg_csi_para *csi_para)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, ret;
+	u16 val16;
+
+#if MAC_AX_FW_REG_OFLD
+	u32 mask;
+	u16 cr;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		if (chk_patch_snd_ng3_setting(adapter)) {
+			if (csi_para->ng == 3)
+				return MACHWNOSUP;
+		}
+
+		cr = csi_para->band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+				      R_AX_TRXPTCL_RESP_CSI_CTRL_0;
+		mask = B_AX_BFMEE_BFPARAM_SEL;
+		ret = write_mac_reg_ofld(adapter, cr, mask, 1, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+
+		if (csi_para->portsel == 0)
+			cr = csi_para->band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+				      R_AX_TRXPTCL_RESP_CSI_CTRL_0;
+		else
+			cr = csi_para->band ? R_AX_TRXPTCL_RESP_CSI_CTRL_1_C1 :
+				      R_AX_TRXPTCL_RESP_CSI_CTRL_1;
+		val16 = SET_WORD(csi_para->nc, B_AX_BFMEE_CSIINFO0_NC) |
+			SET_WORD(csi_para->nr, B_AX_BFMEE_CSIINFO0_NR) |
+			SET_WORD(csi_para->ng, B_AX_BFMEE_CSIINFO0_NG) |
+			SET_WORD(csi_para->cb, B_AX_BFMEE_CSIINFO0_CB) |
+			SET_WORD(csi_para->cs, B_AX_BFMEE_CSIINFO0_CS) |
+			(csi_para->ldpc_en ? B_AX_BFMEE_CSIINFO0_LDPC_EN : 0) |
+			(csi_para->stbc_en ? B_AX_BFMEE_CSIINFO0_STBC_EN : 0);
+		ret = MAC_REG_W16_OFLD(cr, val16, 1);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+	ret = check_mac_en(adapter, (u8)csi_para->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (chk_patch_snd_ng3_setting(adapter)) {
+		if (csi_para->ng == 3)
+			return MACHWNOSUP;
+	}
+
+	val32 = MAC_REG_R32(csi_para->band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+			    R_AX_TRXPTCL_RESP_CSI_CTRL_0);
+	val32 |= B_AX_BFMEE_BFPARAM_SEL;
+	MAC_REG_W32(csi_para->band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+		    R_AX_TRXPTCL_RESP_CSI_CTRL_0, val32);
+
+	val16 = SET_WORD(csi_para->nc, B_AX_BFMEE_CSIINFO0_NC) |
+		SET_WORD(csi_para->nr, B_AX_BFMEE_CSIINFO0_NR) |
+		SET_WORD(csi_para->ng, B_AX_BFMEE_CSIINFO0_NG) |
+		SET_WORD(csi_para->cb, B_AX_BFMEE_CSIINFO0_CB) |
+		SET_WORD(csi_para->cs, B_AX_BFMEE_CSIINFO0_CS) |
+		(csi_para->ldpc_en ? B_AX_BFMEE_CSIINFO0_LDPC_EN : 0) |
+		(csi_para->stbc_en ? B_AX_BFMEE_CSIINFO0_STBC_EN : 0);
+
+	if (csi_para->portsel == 0)
+		MAC_REG_W16(csi_para->band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+			    R_AX_TRXPTCL_RESP_CSI_CTRL_0, val16);
+	else
+		MAC_REG_W16(csi_para->band ? R_AX_TRXPTCL_RESP_CSI_CTRL_1_C1 :
+			    R_AX_TRXPTCL_RESP_CSI_CTRL_1, val16);
+	return MACSUCCESS;
+}
+
+u32 mac_set_csi_para_cctl(struct mac_ax_adapter *adapter,
+			  struct mac_cctl_csi_para *csi_para)
+{
+	struct rtw_hal_mac_ax_cctl_info info;
+	struct rtw_hal_mac_ax_cctl_info mask;
+	struct mac_ax_ops *ax_ops = adapter_to_mac_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret, val32;
+
+#if MAC_AX_FW_REG_OFLD
+	u32 msk;
+	u16 cr;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = check_mac_en(adapter, (u8)csi_para->band, MAC_AX_CMAC_SEL);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		if (chk_patch_snd_ng3_setting(adapter)) {
+			if (csi_para->ng == 3)
+				return MACHWNOSUP;
+		}
+
+		cr = csi_para->band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+				      R_AX_TRXPTCL_RESP_CSI_CTRL_0;
+		msk = B_AX_BFMEE_BFPARAM_SEL;
+		ret = write_mac_reg_ofld(adapter, cr, msk, 0, 1);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+
+		info.nc = csi_para->nc;
+		info.nr = csi_para->nr;
+		info.ng = csi_para->ng;
+		info.cb = csi_para->cb;
+		info.cs = csi_para->cs;
+		//info.csi_txbf_en = csi_para->bf_en; BB HW BUG not support
+		info.csi_txbf_en = 0x0;
+		info.csi_stbc_en = csi_para->stbc_en;
+		info.csi_ldpc_en = csi_para->ldpc_en;
+		info.csi_para_en = 1;
+		info.csi_fix_rate = csi_para->rate;
+		info.csi_gi_ltf = csi_para->gi_ltf;
+		info.uldl = csi_para->gid_sel;
+		info.csi_bw = csi_para->bw;
+
+		PLTFM_MEMSET(&mask, 0, sizeof(mask));
+		mask.nc = 0x7;
+		mask.nr = 0x7;
+		mask.ng = 0x3;
+		mask.cb = 0x3;
+		mask.cs = 0x3;
+		mask.csi_txbf_en = 0x1;
+		mask.csi_stbc_en = 0x1;
+		mask.csi_ldpc_en = 0x1;
+		mask.csi_para_en = 0x1;
+		mask.csi_fix_rate = 0x1FF;
+		mask.csi_gi_ltf = 0x7;
+		mask.uldl = 0x1;
+		mask.csi_bw = 0x3;
+		ret = ax_ops->upd_cctl_info(adapter, &info, &mask, csi_para->macid, 1);
+		if (ret)
+			return MACCCTLWRFAIL;
+
+		return MACSUCCESS;
+	}
+#endif
+	ret = check_mac_en(adapter, (u8)csi_para->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (chk_patch_snd_ng3_setting(adapter)) {
+		if (csi_para->ng == 3)
+			return MACHWNOSUP;
+	}
+
+	val32 = MAC_REG_R32(csi_para->band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+			    R_AX_TRXPTCL_RESP_CSI_CTRL_0);
+	val32 &= (~B_AX_BFMEE_BFPARAM_SEL);
+	MAC_REG_W32(csi_para->band ? R_AX_TRXPTCL_RESP_CSI_CTRL_0_C1 :
+		    R_AX_TRXPTCL_RESP_CSI_CTRL_0, val32);
+
+	info.nc = csi_para->nc;
+	info.nr = csi_para->nr;
+	info.ng = csi_para->ng;
+	info.cb = csi_para->cb;
+	info.cs = csi_para->cs;
+	//info.csi_txbf_en = csi_para->bf_en; BB HW BUG not support
+	info.csi_txbf_en = 0x0;
+	info.csi_stbc_en = csi_para->stbc_en;
+	info.csi_ldpc_en = csi_para->ldpc_en;
+	info.csi_para_en = 1;
+	info.csi_fix_rate = csi_para->rate;
+	info.csi_gi_ltf = csi_para->gi_ltf;
+	info.uldl = csi_para->gid_sel;
+	info.csi_bw = csi_para->bw;
+
+	PLTFM_MEMSET(&mask, 0, sizeof(mask));
+	mask.nc = 0x7;
+	mask.nr = 0x7;
+	mask.ng = 0x3;
+	mask.cb = 0x3;
+	mask.cs = 0x3;
+	mask.csi_txbf_en = 0x1;
+	mask.csi_stbc_en = 0x1;
+	mask.csi_ldpc_en = 0x1;
+	mask.csi_para_en = 0x1;
+	mask.csi_fix_rate = 0x1FF;
+	mask.csi_gi_ltf = 0x7;
+	mask.uldl = 0x1;
+	mask.csi_bw = 0x3;
+	ret = ax_ops->upd_cctl_info(adapter, &info, &mask, csi_para->macid, 1);
+	if (ret)
+		return MACCCTLWRFAIL;
+
+	return MACSUCCESS;
+}
+
+u32 mac_hw_snd_pause_release(struct mac_ax_adapter *adapter, u8 band,
+			     u8 pr)
+{
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	struct mac_ax_sch_tx_en_cfg sch_cfg;
+	u32 ret;
+
+	sch_cfg.band = band;
+	if (!pr)
+		PLTFM_MEMSET(&sch_cfg.tx_en, 0, SCH_TX_EN_SIZE);
+	else
+		PLTFM_MEMSET(&sch_cfg.tx_en, 0xFF, SCH_TX_EN_SIZE);
+	PLTFM_MEMSET(&sch_cfg.tx_en_mask, 0xFF, SCH_TX_EN_SIZE);
+	ret = mac_ops->set_hw_value(adapter, MAC_AX_HW_SET_SCH_TXEN_CFG,
+				    (void *)&sch_cfg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("B%d pause%d sch txen cfg %d\n", band, pr, ret);
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_bypass_snd_sts(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val8;
+
+#if MAC_AX_FW_REG_OFLD
+	u32 mask, ret;
+	u16 cr;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		cr = R_AX_AGG_BK_0;
+		mask = B_AX_DIS_SND_STS_CHECK;
+		ret = write_mac_reg_ofld(adapter, cr, mask, 1, 1);
+
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+	val8 = MAC_REG_R8(R_AX_AGG_BK_0);
+	MAC_REG_W8(R_AX_AGG_BK_0, val8 | B_AX_DIS_SND_STS_CHECK);
+
+	return MACSUCCESS;
+}
+
+u32 mac_deinit_mee(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, ret;
+
+#if MAC_AX_FW_REG_OFLD
+	u32 mask;
+	u16 cr;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		cr = band ? R_AX_BFMEE_RESP_OPTION_C1 : R_AX_BFMEE_RESP_OPTION;
+		mask = (B_AX_BFMEE_HT_NDPA_EN | B_AX_BFMEE_VHT_NDPA_EN |
+			B_AX_BFMEE_HE_NDPA_EN);
+		ret = write_mac_reg_ofld(adapter, cr, mask, 0, 1);
+
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	val32 = MAC_REG_R32(band ? R_AX_BFMEE_RESP_OPTION_C1 :
+			    R_AX_BFMEE_RESP_OPTION);
+	val32 &= ~(B_AX_BFMEE_HT_NDPA_EN | B_AX_BFMEE_VHT_NDPA_EN |
+		  B_AX_BFMEE_HE_NDPA_EN);
+	MAC_REG_W32(band ? R_AX_BFMEE_RESP_OPTION_C1 :
+		    R_AX_BFMEE_RESP_OPTION, val32);
+
+	return MACSUCCESS;
+}
+
+u32 mac_snd_sup(struct mac_ax_adapter *adapter, struct mac_bf_sup *bf_sup)
+{
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+		bf_sup->bf_entry_num = 16;
+		bf_sup->su_buffer_num = 16;
+		bf_sup->mu_buffer_num = 6;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B)) {
+		bf_sup->bf_entry_num = 16;
+		bf_sup->su_buffer_num = 16;
+		bf_sup->mu_buffer_num = 6;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C)) {
+		bf_sup->bf_entry_num = 16;
+		bf_sup->su_buffer_num = 16;
+		bf_sup->mu_buffer_num = 6;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		bf_sup->bf_entry_num = 16;
+		bf_sup->su_buffer_num = 16;
+		bf_sup->mu_buffer_num = 6;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851E)) {
+		bf_sup->bf_entry_num = 16;
+		bf_sup->su_buffer_num = 16;
+		bf_sup->mu_buffer_num = 6;
+	} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		bf_sup->bf_entry_num = 16;
+		bf_sup->su_buffer_num = 16;
+		bf_sup->mu_buffer_num = 6;
+	} else {
+		return MACNOTSUP;
+	}
+	return MACSUCCESS;
+}
+
+u32 mac_gidpos(struct mac_ax_adapter *adapter, struct mac_gid_pos *mu_gid)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+#if MAC_AX_FW_REG_OFLD
+	u32 ret, val32;
+	u16 cr;
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		cr = mu_gid->band ? R_AX_GID_POSITION_EN0_C1 : R_AX_GID_POSITION_EN0;
+		val32 = mu_gid->gid_tab[0];
+		ret = MAC_REG_W32_OFLD(cr, val32, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+
+		cr = mu_gid->band ? R_AX_GID_POSITION_EN1_C1 : R_AX_GID_POSITION_EN1;
+		val32 = mu_gid->gid_tab[1];
+		ret = MAC_REG_W32_OFLD(cr, val32, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+
+		cr = mu_gid->band ? R_AX_GID_POSITION0_C1 : R_AX_GID_POSITION0;
+		val32 = mu_gid->user_pos[0];
+		ret = MAC_REG_W32_OFLD(cr, val32, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+
+		cr = mu_gid->band ? R_AX_GID_POSITION1_C1 : R_AX_GID_POSITION1;
+		val32 = mu_gid->user_pos[1];
+		ret = MAC_REG_W32_OFLD(cr, val32, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+
+		cr = mu_gid->band ? R_AX_GID_POSITION2_C1 : R_AX_GID_POSITION2;
+		val32 = mu_gid->user_pos[2];
+		ret = MAC_REG_W32_OFLD(cr, val32, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+
+		cr = mu_gid->band ? R_AX_GID_POSITION3_C1 : R_AX_GID_POSITION3;
+		val32 = mu_gid->user_pos[3];
+		ret = MAC_REG_W32_OFLD(cr, val32, 0);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]%s FW_OFLD in %x\n", __func__, cr);
+			return ret;
+		}
+		return MACSUCCESS;
+	}
+#endif
+	MAC_REG_W32(mu_gid->band ? R_AX_GID_POSITION_EN0_C1 :
+		    R_AX_GID_POSITION_EN0, mu_gid->gid_tab[0]);
+	MAC_REG_W32(mu_gid->band ? R_AX_GID_POSITION_EN1_C1 :
+		    R_AX_GID_POSITION_EN1, mu_gid->gid_tab[1]);
+
+	MAC_REG_W32(mu_gid->band ? R_AX_GID_POSITION0_C1 : R_AX_GID_POSITION0,
+		    mu_gid->user_pos[0]);
+	MAC_REG_W32(mu_gid->band ? R_AX_GID_POSITION1_C1 : R_AX_GID_POSITION1,
+		    mu_gid->user_pos[1]);
+	MAC_REG_W32(mu_gid->band ? R_AX_GID_POSITION2_C1 : R_AX_GID_POSITION2,
+		    mu_gid->user_pos[2]);
+	MAC_REG_W32(mu_gid->band ? R_AX_GID_POSITION3_C1 : R_AX_GID_POSITION3,
+		    mu_gid->user_pos[3]);
+
+	return MACSUCCESS;
+}
+
+#if MAC_AX_8852A_SUPPORT
+static u32 build_snd_h2c(struct mac_ax_adapter *adapter, struct mac_ax_fwcmd_snd *snd_info)
+{
+	u32 ret = 0;
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_set_snd_para *h2c;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, MAX_FWCMD_SND_LEN);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	PLTFM_MEMSET(buf, 0, MAX_FWCMD_SND_LEN);
+	h2c = (struct fwcmd_set_snd_para *)buf;
+
+	h2c->dword0 =
+	cpu_to_le32(SET_WORD(snd_info->frexgtype,
+			     FWCMD_H2C_SET_SND_PARA_FREXCH_TYPE) |
+		    SET_WORD(snd_info->mode, FWCMD_H2C_SET_SND_PARA_MODE) |
+		    SET_WORD(snd_info->bfrp0_user_num,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_USER_NUM) |
+		    SET_WORD(snd_info->bfrp1_user_num,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP1_USER_NUM));
+	h2c->dword1 =
+	cpu_to_le32(SET_WORD(snd_info->macid[0], FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->macid[1], FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->macid[2], FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->macid[3], FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword2 =
+	cpu_to_le32(SET_WORD(snd_info->macid[8], FWCMD_H2C_SET_SND_PARA_MACID4) |
+		    SET_WORD(snd_info->macid[9], FWCMD_H2C_SET_SND_PARA_MACID5) |
+		    SET_WORD(snd_info->macid[10], FWCMD_H2C_SET_SND_PARA_MACID6) |
+		    SET_WORD(snd_info->macid[11], FWCMD_H2C_SET_SND_PARA_MACID7));
+	h2c->dword3 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.common.frame_ctl,
+			     FWCMD_H2C_SET_SND_PARA_NDPA_FRAME_CTRL) |
+		    SET_WORD(snd_info->pndpa.common.duration,
+			     FWCMD_H2C_SET_SND_PARA_NDPA_DURATION));
+	h2c->dword4 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.common.addr1[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pndpa.common.addr1[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pndpa.common.addr1[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pndpa.common.addr1[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword5 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.common.addr1[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pndpa.common.addr1[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pndpa.common.addr2[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pndpa.common.addr2[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword6 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.common.addr2[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pndpa.common.addr2[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pndpa.common.addr2[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pndpa.common.addr2[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword7 =
+	cpu_to_le32((snd_info->pndpa.snd_dialog.he ?
+		     FWCMD_H2C_SET_SND_PARA_NDPA_SND_DLG_HE : 0) |
+		    SET_WORD(snd_info->pndpa.snd_dialog.dialog,
+			     FWCMD_H2C_SET_SND_PARA_NDPA_SND_DLG_DIALOG));
+	h2c->dword8 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.ht_para.addr3[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pndpa.ht_para.addr3[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pndpa.ht_para.addr3[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pndpa.ht_para.addr3[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword9 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.ht_para.addr3[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+			SET_WORD(snd_info->pndpa.ht_para.addr3[5],
+				 FWCMD_H2C_SET_SND_PARA_MACID1) |
+			SET_WORD(snd_info->pndpa.ht_para.seq_control,
+				 FWCMD_H2C_SET_SND_PARA_HT_SEQ_CONTROL));
+	h2c->dword10 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.vht_para.sta_info[0].aid,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA0_AID12) |
+		    (snd_info->pndpa.vht_para.sta_info[0].fb_type ?
+		     FWCMD_H2C_SET_SND_PARA_VHT_STA0_FEEDBACK_TYPE : 0) |
+		    SET_WORD(snd_info->pndpa.vht_para.sta_info[0].nc,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA0_NC) |
+		    SET_WORD(snd_info->pndpa.vht_para.sta_info[1].aid,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA1_AID12) |
+		    (snd_info->pndpa.vht_para.sta_info[1].fb_type ?
+		     FWCMD_H2C_SET_SND_PARA_VHT_STA1_FEEDBACK_TYPE : 0) |
+		    SET_WORD(snd_info->pndpa.vht_para.sta_info[1].nc,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA1_NC));
+	h2c->dword11 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.vht_para.sta_info[2].aid,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA2_AID12) |
+		    (snd_info->pndpa.vht_para.sta_info[2].fb_type ?
+		     FWCMD_H2C_SET_SND_PARA_VHT_STA2_FEEDBACK_TYPE : 0) |
+		    SET_WORD(snd_info->pndpa.vht_para.sta_info[2].nc,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA2_NC) |
+		    SET_WORD(snd_info->pndpa.vht_para.sta_info[3].aid,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA3_AID12) |
+		    (snd_info->pndpa.vht_para.sta_info[3].fb_type ?
+		     FWCMD_H2C_SET_SND_PARA_VHT_STA3_FEEDBACK_TYPE : 0) |
+		    SET_WORD(snd_info->pndpa.vht_para.sta_info[3].nc,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA3_NC));
+	h2c->dword12 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[0].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[0].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[0].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[0].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[0].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[0].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_NC));
+	h2c->dword13 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[1].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA1_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[1].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA1_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[1].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA1_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[1].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA1_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[1].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA1_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[1].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA1_NC));
+	h2c->dword14 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[2].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA2_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[2].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA2_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[2].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA2_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[2].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA2_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[2].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA2_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[2].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA2_NC));
+	h2c->dword15 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[3].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA3_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[3].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA3_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[3].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA3_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[3].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA3_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[3].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA3_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[3].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA3_NC));
+	h2c->dword16 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[4].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA4_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[4].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA4_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[4].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA4_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[4].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA4_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[4].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA4_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[4].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA4_NC));
+	h2c->dword17 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[5].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA5_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[5].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA5_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[5].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA5_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[5].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA5_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[5].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA5_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[5].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA5_NC));
+	h2c->dword18 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[6].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA6_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[6].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA6_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[6].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA6_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[6].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA6_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[6].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA6_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[6].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA6_NC));
+	h2c->dword19 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[7].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA7_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[7].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA7_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[7].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA7_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[7].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA7_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[7].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA7_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[7].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA7_NC));
+	h2c->dword20 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[0].frame_ctl,
+			     FWCMD_H2C_SET_SND_PARA_BFRP0_FRAME_CTL) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].duration,
+			     FWCMD_H2C_SET_SND_PARA_BFRP0_DURATION));
+	h2c->dword21 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[0].addr1[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr1[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr1[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr1[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword22 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[0].addr1[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr1[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr2[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr2[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword23 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[0].addr2[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr2[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr2[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr2[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword24 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[1].frame_ctl,
+			     FWCMD_H2C_SET_SND_PARA_BFRP0_FRAME_CTL) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].duration,
+			     FWCMD_H2C_SET_SND_PARA_BFRP0_DURATION));
+	h2c->dword25 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[1].addr1[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr1[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr1[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr1[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword26 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[1].addr1[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr1[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr2[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr2[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword27 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[1].addr2[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr2[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr2[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr2[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword28 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[2].frame_ctl,
+			     FWCMD_H2C_SET_SND_PARA_BFRP0_FRAME_CTL) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].duration,
+			     FWCMD_H2C_SET_SND_PARA_BFRP0_DURATION));
+	h2c->dword29 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[2].addr1[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr1[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr1[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr1[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword30 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[2].addr1[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr1[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr2[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr2[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword31 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[2].addr2[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr2[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr2[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr2[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword32 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].common.tgr_info,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_TRIGGER_INFO) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].common.ul_len,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_LENGTH) |
+		    (snd_info->pbfrp.he_para[0].common.more_tf ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_MORE_TF : 0) |
+		    (snd_info->pbfrp.he_para[0].common.cs_rqd ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_CS_REQUIRED : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].common.ul_bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_BW) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].common.gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_GI_LTF) |
+		    (snd_info->pbfrp.he_para[0].common.mimo_ltfmode ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_MU_MIMO_LTF_MODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].common.num_heltf,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_NUM_OF_HE_LTF) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].common.ul_pktext,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_PKTEXT) |
+		    (snd_info->pbfrp.he_para[0].common.ul_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_STBC : 0) |
+		    (snd_info->pbfrp.he_para[0].common.ldpc_extra_sym ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_LDPC_EXTRA_SYMBOL : 0) |
+		    (snd_info->pbfrp.he_para[0].common.dplr ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_DOPPLER : 0));
+	h2c->dword33 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].common.ap_tx_pwr,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_AP_TX_POWER) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].common.ul_sr,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_SPATIAL_REUSE));
+	h2c->dword34 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[0].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[0].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[0].user[0].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[0].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[0].user[0].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[0].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword35 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[0].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[0].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword36 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[1].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[1].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[0].user[1].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[1].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[0].user[1].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[1].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword37 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[1].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[1].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword38 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[2].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[2].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[0].user[2].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[2].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[0].user[2].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[2].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword39 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[2].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[2].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword40 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[3].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[3].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[0].user[3].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[3].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[0].user[3].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[3].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword41 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[3].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[3].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword42 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].common.tgr_info,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_TRIGGER_INFO) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].common.ul_len,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_LENGTH) |
+		    (snd_info->pbfrp.he_para[1].common.more_tf ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_MORE_TF : 0) |
+		    (snd_info->pbfrp.he_para[1].common.cs_rqd ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_CS_REQUIRED : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].common.ul_bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_BW) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].common.gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_GI_LTF) |
+		    (snd_info->pbfrp.he_para[1].common.mimo_ltfmode ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_MU_MIMO_LTF_MODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].common.num_heltf,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_NUM_OF_HE_LTF) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].common.ul_pktext,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_PKTEXT) |
+		    (snd_info->pbfrp.he_para[1].common.ul_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_STBC : 0) |
+		    (snd_info->pbfrp.he_para[1].common.ldpc_extra_sym ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_LDPC_EXTRA_SYMBOL : 0) |
+		    (snd_info->pbfrp.he_para[1].common.dplr ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_DOPPLER : 0));
+	h2c->dword43 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].common.ap_tx_pwr,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_AP_TX_POWER) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].common.ul_sr,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_SPATIAL_REUSE));
+	h2c->dword44 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[0].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[0].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[1].user[0].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[0].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[1].user[0].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[0].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword45 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[0].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[0].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword46 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[1].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[1].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[1].user[1].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[1].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[1].user[1].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[1].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword47 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[1].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[1].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword48 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[2].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[2].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[1].user[2].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[2].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[1].user[2].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[2].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword49 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[2].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[2].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword50 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[3].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[3].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[1].user[3].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[3].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[1].user[3].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[3].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword51 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[3].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[3].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword52 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.vht_para[0].retransmission_bitmap,
+			     FWCMD_H2C_SET_SND_PARA_VHT_BFRP0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.vht_para[1].retransmission_bitmap,
+			     FWCMD_H2C_SET_SND_PARA_VHT_BFRP1_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.vht_para[2].retransmission_bitmap,
+			     FWCMD_H2C_SET_SND_PARA_VHT_BFRP2_FB_REXMIT));
+	h2c->dword53 =
+	cpu_to_le32(SET_WORD(snd_info->wd[0].txpktsize,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPKTSIZE_WD0) |
+		    SET_WORD(snd_info->wd[0].ndpa_duration,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_DURATION_WD0));
+	h2c->dword54 =
+	cpu_to_le32(SET_WORD(snd_info->wd[0].datarate,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATARATE_WD0) |
+		    SET_WORD(snd_info->wd[0].macid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MACID_WD0) |
+		    (snd_info->wd[0].force_txop ?
+		     FWCMD_H2C_SET_SND_PARA_WD_FORCE_TXOP_WD0 : 0) |
+		    SET_WORD(snd_info->wd[0].data_bw,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_WD0) |
+		    SET_WORD(snd_info->wd[0].gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_WD_GI_LTF_WD0) |
+		    (snd_info->wd[0].data_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_ER_WD0 : 0) |
+		    (snd_info->wd[0].data_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_DCM_WD0 : 0) |
+		    (snd_info->wd[0].data_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_STBC_WD0 : 0) |
+		    (snd_info->wd[0].data_ldpc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_LDPC_WD0 : 0) |
+		    (snd_info->wd[0].data_bw_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_ER_WD0 : 0) |
+		    (snd_info->wd[0].multiport_id ?
+		     FWCMD_H2C_SET_SND_PARA_WD_MULTIPORT_ID_WD0 : 0) |
+		    SET_WORD(snd_info->wd[0].mbssid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MBSSID_WD0));
+	h2c->dword55 =
+	cpu_to_le32(SET_WORD(snd_info->wd[0].signaling_ta_pkt_sc,
+			     FWCMD_H2C_SET_SND_PARA_WD_SIGNALING_TA_PKT_SC_WD0) |
+		    SET_WORD(snd_info->wd[0].sw_define,
+			     FWCMD_H2C_SET_SND_PARA_WD_SW_DEFINE_WD0) |
+		    SET_WORD(snd_info->wd[0].txpwr_ofset_type,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPWR_OFSET_TYPE_WD0) |
+		    SET_WORD(snd_info->wd[0].lifetime_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_LIFETIME_SEL_WD0) |
+		    (snd_info->wd[0].stf_mode ?
+		     FWCMD_H2C_SET_SND_PARA_WD_STF_MODE_WD0 : 0) |
+		    (snd_info->wd[0].disdatafb ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DISDATAFB_WD0 : 0) |
+		    (snd_info->wd[0].data_txcnt_lmt_sel ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_SEL_WD0 : 0) |
+		    SET_WORD(snd_info->wd[0].data_txcnt_lmt,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_WD0) |
+		    (snd_info->wd[0].sifs_tx ?
+		     FWCMD_H2C_SET_SND_PARA_WD_SIFS_TX_WD0 : 0) |
+		    SET_WORD(snd_info->wd[0].snd_pkt_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_SND_PKT_SEL_WD0) |
+		    SET_WORD(snd_info->wd[0].ndpa,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_WD0));
+	h2c->dword56 =
+	cpu_to_le32(SET_WORD(snd_info->wd[1].txpktsize,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPKTSIZE_WD0) |
+		    SET_WORD(snd_info->wd[1].ndpa_duration,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_DURATION_WD0));
+	h2c->dword57 =
+	cpu_to_le32(SET_WORD(snd_info->wd[1].datarate,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATARATE_WD0) |
+		    SET_WORD(snd_info->wd[1].macid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MACID_WD0) |
+		    (snd_info->wd[1].force_txop ?
+		     FWCMD_H2C_SET_SND_PARA_WD_FORCE_TXOP_WD0 : 0) |
+		    SET_WORD(snd_info->wd[1].data_bw,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_WD0) |
+		    SET_WORD(snd_info->wd[1].gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_WD_GI_LTF_WD0) |
+		    (snd_info->wd[1].data_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_ER_WD0 : 0) |
+		    (snd_info->wd[1].data_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_DCM_WD0 : 0) |
+		    (snd_info->wd[1].data_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_STBC_WD0 : 0) |
+		    (snd_info->wd[1].data_ldpc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_LDPC_WD0 : 0) |
+		    (snd_info->wd[1].data_bw_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_ER_WD0 : 0) |
+		    (snd_info->wd[1].multiport_id ?
+		     FWCMD_H2C_SET_SND_PARA_WD_MULTIPORT_ID_WD0 : 0) |
+		    SET_WORD(snd_info->wd[1].mbssid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MBSSID_WD0));
+	h2c->dword58 =
+	cpu_to_le32(SET_WORD(snd_info->wd[1].signaling_ta_pkt_sc,
+			     FWCMD_H2C_SET_SND_PARA_WD_SIGNALING_TA_PKT_SC_WD0) |
+		    SET_WORD(snd_info->wd[1].sw_define,
+			     FWCMD_H2C_SET_SND_PARA_WD_SW_DEFINE_WD0) |
+		    SET_WORD(snd_info->wd[1].txpwr_ofset_type,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPWR_OFSET_TYPE_WD0) |
+		    SET_WORD(snd_info->wd[1].lifetime_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_LIFETIME_SEL_WD0) |
+		    (snd_info->wd[1].stf_mode ?
+		     FWCMD_H2C_SET_SND_PARA_WD_STF_MODE_WD0 : 0) |
+		    (snd_info->wd[1].disdatafb ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DISDATAFB_WD0 : 0) |
+		    (snd_info->wd[1].data_txcnt_lmt_sel ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_SEL_WD0 : 0) |
+		    SET_WORD(snd_info->wd[1].data_txcnt_lmt,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_WD0) |
+		    (snd_info->wd[1].sifs_tx ?
+		     FWCMD_H2C_SET_SND_PARA_WD_SIFS_TX_WD0 : 0) |
+		    SET_WORD(snd_info->wd[1].snd_pkt_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_SND_PKT_SEL_WD0) |
+		    SET_WORD(snd_info->wd[1].ndpa,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_WD0));
+	h2c->dword59 =
+	cpu_to_le32(SET_WORD(snd_info->wd[2].txpktsize,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPKTSIZE_WD0) |
+		    SET_WORD(snd_info->wd[2].ndpa_duration,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_DURATION_WD0));
+	h2c->dword60 =
+	cpu_to_le32(SET_WORD(snd_info->wd[2].datarate,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATARATE_WD0) |
+		    SET_WORD(snd_info->wd[2].macid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MACID_WD0) |
+		    (snd_info->wd[2].force_txop ?
+		     FWCMD_H2C_SET_SND_PARA_WD_FORCE_TXOP_WD0 : 0) |
+		    SET_WORD(snd_info->wd[2].data_bw,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_WD0) |
+		    SET_WORD(snd_info->wd[2].gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_WD_GI_LTF_WD0) |
+		    (snd_info->wd[2].data_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_ER_WD0 : 0) |
+		    (snd_info->wd[2].data_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_DCM_WD0 : 0) |
+		    (snd_info->wd[2].data_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_STBC_WD0 : 0) |
+		    (snd_info->wd[2].data_ldpc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_LDPC_WD0 : 0) |
+		    (snd_info->wd[2].data_bw_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_ER_WD0 : 0) |
+		    (snd_info->wd[2].multiport_id ?
+		     FWCMD_H2C_SET_SND_PARA_WD_MULTIPORT_ID_WD0 : 0) |
+		    SET_WORD(snd_info->wd[2].mbssid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MBSSID_WD0));
+	h2c->dword61 =
+	cpu_to_le32(SET_WORD(snd_info->wd[2].signaling_ta_pkt_sc,
+			     FWCMD_H2C_SET_SND_PARA_WD_SIGNALING_TA_PKT_SC_WD0) |
+		    SET_WORD(snd_info->wd[2].sw_define,
+			     FWCMD_H2C_SET_SND_PARA_WD_SW_DEFINE_WD0) |
+		    SET_WORD(snd_info->wd[2].txpwr_ofset_type,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPWR_OFSET_TYPE_WD0) |
+		    SET_WORD(snd_info->wd[2].lifetime_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_LIFETIME_SEL_WD0) |
+		    (snd_info->wd[2].stf_mode ?
+		     FWCMD_H2C_SET_SND_PARA_WD_STF_MODE_WD0 : 0) |
+		    (snd_info->wd[2].disdatafb ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DISDATAFB_WD0 : 0) |
+		    (snd_info->wd[2].data_txcnt_lmt_sel ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_SEL_WD0 : 0) |
+		    SET_WORD(snd_info->wd[2].data_txcnt_lmt,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_WD0) |
+		    (snd_info->wd[2].sifs_tx ?
+		     FWCMD_H2C_SET_SND_PARA_WD_SIFS_TX_WD0 : 0) |
+		    SET_WORD(snd_info->wd[2].snd_pkt_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_SND_PKT_SEL_WD0) |
+		    SET_WORD(snd_info->wd[2].ndpa,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_WD0));
+	h2c->dword62 =
+	cpu_to_le32(SET_WORD(snd_info->wd[3].txpktsize,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPKTSIZE_WD0) |
+		    SET_WORD(snd_info->wd[3].ndpa_duration,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_DURATION_WD0));
+	h2c->dword63 =
+	cpu_to_le32(SET_WORD(snd_info->wd[3].datarate,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATARATE_WD0) |
+		    SET_WORD(snd_info->wd[3].macid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MACID_WD0) |
+		    (snd_info->wd[3].force_txop ?
+		     FWCMD_H2C_SET_SND_PARA_WD_FORCE_TXOP_WD0 : 0) |
+		    SET_WORD(snd_info->wd[3].data_bw,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_WD0) |
+		    SET_WORD(snd_info->wd[3].gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_WD_GI_LTF_WD0) |
+		    (snd_info->wd[3].data_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_ER_WD0 : 0) |
+		    (snd_info->wd[3].data_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_DCM_WD0 : 0) |
+		    (snd_info->wd[3].data_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_STBC_WD0 : 0) |
+		    (snd_info->wd[3].data_ldpc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_LDPC_WD0 : 0) |
+		    (snd_info->wd[3].data_bw_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_ER_WD0 : 0) |
+		    (snd_info->wd[3].multiport_id ?
+		     FWCMD_H2C_SET_SND_PARA_WD_MULTIPORT_ID_WD0 : 0) |
+		    SET_WORD(snd_info->wd[3].mbssid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MBSSID_WD0));
+	h2c->dword64 =
+	cpu_to_le32(SET_WORD(snd_info->wd[3].signaling_ta_pkt_sc,
+			     FWCMD_H2C_SET_SND_PARA_WD_SIGNALING_TA_PKT_SC_WD0) |
+		    SET_WORD(snd_info->wd[3].sw_define,
+			     FWCMD_H2C_SET_SND_PARA_WD_SW_DEFINE_WD0) |
+		    SET_WORD(snd_info->wd[3].txpwr_ofset_type,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPWR_OFSET_TYPE_WD0) |
+		    SET_WORD(snd_info->wd[3].lifetime_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_LIFETIME_SEL_WD0) |
+		    (snd_info->wd[3].stf_mode ?
+		     FWCMD_H2C_SET_SND_PARA_WD_STF_MODE_WD0 : 0) |
+		    (snd_info->wd[3].disdatafb ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DISDATAFB_WD0 : 0) |
+		    (snd_info->wd[3].data_txcnt_lmt_sel ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_SEL_WD0 : 0) |
+		    SET_WORD(snd_info->wd[3].data_txcnt_lmt,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_WD0) |
+		    (snd_info->wd[3].sifs_tx ?
+		     FWCMD_H2C_SET_SND_PARA_WD_SIFS_TX_WD0 : 0) |
+		    SET_WORD(snd_info->wd[3].snd_pkt_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_SND_PKT_SEL_WD0) |
+		    SET_WORD(snd_info->wd[3].ndpa,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_WD0));
+	h2c->dword65 =
+	cpu_to_le32(SET_WORD(snd_info->wd[4].txpktsize,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPKTSIZE_WD0) |
+		    SET_WORD(snd_info->wd[4].ndpa_duration,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_DURATION_WD0));
+	h2c->dword66 =
+	cpu_to_le32(SET_WORD(snd_info->wd[4].datarate,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATARATE_WD0) |
+		    SET_WORD(snd_info->wd[4].macid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MACID_WD0) |
+		    (snd_info->wd[4].force_txop ?
+		     FWCMD_H2C_SET_SND_PARA_WD_FORCE_TXOP_WD0 : 0) |
+		    SET_WORD(snd_info->wd[4].data_bw,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_WD0) |
+		    SET_WORD(snd_info->wd[4].gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_WD_GI_LTF_WD0) |
+		    (snd_info->wd[4].data_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_ER_WD0 : 0) |
+		    (snd_info->wd[4].data_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_DCM_WD0 : 0) |
+		    (snd_info->wd[4].data_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_STBC_WD0 : 0) |
+		    (snd_info->wd[4].data_ldpc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_LDPC_WD0 : 0) |
+		    (snd_info->wd[4].data_bw_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_ER_WD0 : 0) |
+		    (snd_info->wd[4].multiport_id ?
+		     FWCMD_H2C_SET_SND_PARA_WD_MULTIPORT_ID_WD0 : 0) |
+		    SET_WORD(snd_info->wd[4].mbssid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MBSSID_WD0));
+	h2c->dword67 =
+	cpu_to_le32(SET_WORD(snd_info->wd[4].signaling_ta_pkt_sc,
+			     FWCMD_H2C_SET_SND_PARA_WD_SIGNALING_TA_PKT_SC_WD0) |
+		    SET_WORD(snd_info->wd[4].sw_define,
+			     FWCMD_H2C_SET_SND_PARA_WD_SW_DEFINE_WD0) |
+		    SET_WORD(snd_info->wd[4].txpwr_ofset_type,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPWR_OFSET_TYPE_WD0) |
+		    SET_WORD(snd_info->wd[4].lifetime_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_LIFETIME_SEL_WD0) |
+		    (snd_info->wd[4].stf_mode ?
+		     FWCMD_H2C_SET_SND_PARA_WD_STF_MODE_WD0 : 0) |
+		    (snd_info->wd[4].disdatafb ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DISDATAFB_WD0 : 0) |
+		    (snd_info->wd[4].data_txcnt_lmt_sel ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_SEL_WD0 : 0) |
+		    SET_WORD(snd_info->wd[4].data_txcnt_lmt,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_WD0) |
+		    (snd_info->wd[4].sifs_tx ?
+		     FWCMD_H2C_SET_SND_PARA_WD_SIFS_TX_WD0 : 0) |
+		    SET_WORD(snd_info->wd[4].snd_pkt_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_SND_PKT_SEL_WD0) |
+		    SET_WORD(snd_info->wd[4].ndpa,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_WD0));
+	h2c->dword68 =
+	cpu_to_le32(SET_WORD(snd_info->f2p[0].csi_len_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_CSI_LEN_BFRP0) |
+		    SET_WORD(snd_info->f2p[0].tb_t_pe_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_TB_T_PE_BFRP0) |
+		    SET_WORD(snd_info->f2p[0].tri_pad_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_TRI_PAD_BFRP0) |
+		    (snd_info->f2p[0].ul_cqi_rpt_tri_bfrp ?
+		     FWCMD_H2C_SET_SND_PARA_UL_CQI_RPT_TRI_BFRP0 : 0) |
+		    SET_WORD(snd_info->f2p[0].rf_gain_idx_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_RF_GAIN_IDX_BFRP0) |
+		    (snd_info->f2p[0].fix_gain_en_bfrp ?
+		     FWCMD_H2C_SET_SND_PARA_FIX_GAIN_EN_BFRP0 : 0));
+	h2c->dword69 =
+	cpu_to_le32(SET_WORD(snd_info->f2p[1].csi_len_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_CSI_LEN_BFRP0) |
+		    SET_WORD(snd_info->f2p[1].tb_t_pe_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_TB_T_PE_BFRP0) |
+		    SET_WORD(snd_info->f2p[1].tri_pad_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_TRI_PAD_BFRP0) |
+		    (snd_info->f2p[1].ul_cqi_rpt_tri_bfrp ?
+		     FWCMD_H2C_SET_SND_PARA_UL_CQI_RPT_TRI_BFRP0 : 0) |
+		    SET_WORD(snd_info->f2p[1].rf_gain_idx_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_RF_GAIN_IDX_BFRP0) |
+		    (snd_info->f2p[1].fix_gain_en_bfrp ?
+		     FWCMD_H2C_SET_SND_PARA_FIX_GAIN_EN_BFRP0 : 0));
+	h2c->dword70 =
+	cpu_to_le32(SET_WORD(snd_info->sfp.f2p_type,
+			     FWCMD_H2C_SET_SND_PARA_F2P_TYPE) |
+		    SET_WORD(snd_info->sfp.f2p_index,
+			     FWCMD_H2C_SET_SND_PARA_F2P_INDEX) |
+		    SET_WORD(snd_info->sfp.f2p_period,
+			     FWCMD_H2C_SET_SND_PARA_F2P_PERIOD));
+	h2c->dword71 =
+	cpu_to_le32(SET_WORD(snd_info->sfp.f2p_updcnt,
+			     FWCMD_H2C_SET_SND_PARA_F2P_UPDCNT) |
+		    SET_WORD(snd_info->sfp.cr_idx,
+			     FWCMD_H2C_SET_SND_PARA_CR_IDX));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_SOUND,
+			      FWCMD_H2C_FUNC_SET_SND_PARA,
+			      0,
+			      0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+#endif
+
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+static u32 build_snd_h2c_v1(struct mac_ax_adapter *adapter, struct mac_ax_fwcmd_snd *snd_info)
+{
+	u32 ret = 0;
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_set_snd_para_v1 *h2c;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, MAX_FWCMD_SND_LEN);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	PLTFM_MEMSET(buf, 0, MAX_FWCMD_SND_LEN);
+	h2c = (struct fwcmd_set_snd_para_v1 *)buf;
+
+	h2c->dword0 =
+	cpu_to_le32(SET_WORD(snd_info->frexgtype,
+			     FWCMD_H2C_SET_SND_PARA_FREXCH_TYPE) |
+		    SET_WORD(snd_info->mode, FWCMD_H2C_SET_SND_PARA_MODE) |
+		    SET_WORD(snd_info->bfrp0_user_num,
+			     FWCMD_H2C_SET_SND_PARA_V1_HE_BFRP0_USER_NUM) |
+		    SET_WORD(snd_info->bfrp1_user_num,
+			     FWCMD_H2C_SET_SND_PARA_V1_HE_BFRP1_USER_NUM));
+	h2c->dword1 =
+	cpu_to_le32(SET_WORD(snd_info->macid[0], FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->macid[1], FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->macid[2], FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->macid[3], FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword2 =
+	cpu_to_le32(SET_WORD(snd_info->macid[4], FWCMD_H2C_SET_SND_PARA_MACID4) |
+		    SET_WORD(snd_info->macid[5], FWCMD_H2C_SET_SND_PARA_MACID5) |
+		    SET_WORD(snd_info->macid[6], FWCMD_H2C_SET_SND_PARA_MACID6) |
+		    SET_WORD(snd_info->macid[7], FWCMD_H2C_SET_SND_PARA_MACID7));
+	h2c->dword3 =
+	cpu_to_le32(SET_WORD(snd_info->macid[8], FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->macid[9], FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->macid[10], FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->macid[11], FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword4 =
+	cpu_to_le32(SET_WORD(snd_info->macid[12], FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->macid[13], FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->macid[14], FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->macid[15], FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword5 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.common.frame_ctl,
+			     FWCMD_H2C_SET_SND_PARA_NDPA_FRAME_CTRL) |
+		    SET_WORD(snd_info->pndpa.common.duration,
+			     FWCMD_H2C_SET_SND_PARA_NDPA_DURATION));
+	h2c->dword6 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.common.addr1[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pndpa.common.addr1[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pndpa.common.addr1[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pndpa.common.addr1[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword7 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.common.addr1[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pndpa.common.addr1[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pndpa.common.addr2[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pndpa.common.addr2[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword8 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.common.addr2[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pndpa.common.addr2[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pndpa.common.addr2[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pndpa.common.addr2[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword9 =
+	cpu_to_le32((snd_info->pndpa.snd_dialog.he ?
+		     FWCMD_H2C_SET_SND_PARA_NDPA_SND_DLG_HE : 0) |
+		    SET_WORD(snd_info->pndpa.snd_dialog.dialog,
+			     FWCMD_H2C_SET_SND_PARA_NDPA_SND_DLG_DIALOG));
+	h2c->dword10 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.ht_para.addr3[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pndpa.ht_para.addr3[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pndpa.ht_para.addr3[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pndpa.ht_para.addr3[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword11 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.ht_para.addr3[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+			SET_WORD(snd_info->pndpa.ht_para.addr3[5],
+				 FWCMD_H2C_SET_SND_PARA_MACID1) |
+			SET_WORD(snd_info->pndpa.ht_para.seq_control,
+				 FWCMD_H2C_SET_SND_PARA_HT_SEQ_CONTROL));
+	h2c->dword12 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.vht_para.sta_info[0].aid,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA0_AID12) |
+		    (snd_info->pndpa.vht_para.sta_info[0].fb_type ?
+		     FWCMD_H2C_SET_SND_PARA_VHT_STA0_FEEDBACK_TYPE : 0) |
+		    SET_WORD(snd_info->pndpa.vht_para.sta_info[0].nc,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA0_NC) |
+		    SET_WORD(snd_info->pndpa.vht_para.sta_info[1].aid,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA1_AID12) |
+		    (snd_info->pndpa.vht_para.sta_info[1].fb_type ?
+		     FWCMD_H2C_SET_SND_PARA_VHT_STA1_FEEDBACK_TYPE : 0) |
+		    SET_WORD(snd_info->pndpa.vht_para.sta_info[1].nc,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA1_NC));
+	h2c->dword13 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.vht_para.sta_info[2].aid,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA2_AID12) |
+		    (snd_info->pndpa.vht_para.sta_info[2].fb_type ?
+		     FWCMD_H2C_SET_SND_PARA_VHT_STA2_FEEDBACK_TYPE : 0) |
+		    SET_WORD(snd_info->pndpa.vht_para.sta_info[2].nc,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA2_NC) |
+		    SET_WORD(snd_info->pndpa.vht_para.sta_info[3].aid,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA3_AID12) |
+		    (snd_info->pndpa.vht_para.sta_info[3].fb_type ?
+		     FWCMD_H2C_SET_SND_PARA_VHT_STA3_FEEDBACK_TYPE : 0) |
+		    SET_WORD(snd_info->pndpa.vht_para.sta_info[3].nc,
+			     FWCMD_H2C_SET_SND_PARA_VHT_STA3_NC));
+	h2c->dword14 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[0].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[0].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[0].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[0].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[0].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[0].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_NC));
+	h2c->dword15 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[1].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA1_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[1].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA1_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[1].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA1_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[1].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA1_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[1].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA1_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[1].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA1_NC));
+	h2c->dword16 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[2].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA2_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[2].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA2_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[2].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA2_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[2].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA2_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[2].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA2_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[2].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA2_NC));
+	h2c->dword17 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[3].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA3_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[3].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA3_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[3].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA3_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[3].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA3_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[3].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA3_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[3].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA3_NC));
+	h2c->dword18 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[4].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA4_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[4].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA4_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[4].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA4_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[4].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA4_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[4].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA4_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[4].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA4_NC));
+	h2c->dword19 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[5].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA5_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[5].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA5_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[5].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA5_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[5].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA5_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[5].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA5_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[5].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA5_NC));
+	h2c->dword20 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[6].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA6_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[6].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA6_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[6].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA6_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[6].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA6_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[6].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA6_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[6].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA6_NC));
+	h2c->dword21 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[7].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA7_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[7].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA7_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[7].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA7_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[7].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA7_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[7].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA7_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[7].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA7_NC));
+	h2c->dword22 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[8].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[8].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[8].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[8].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[8].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[8].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_NC));
+	h2c->dword23 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[9].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[9].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[9].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[9].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[9].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[9].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_NC));
+	h2c->dword24 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[10].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[10].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[10].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[10].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[10].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[10].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_NC));
+	h2c->dword25 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[11].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[11].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[11].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[11].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[11].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[11].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_NC));
+	h2c->dword26 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[12].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[12].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[12].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[12].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[12].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[12].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_NC));
+	h2c->dword27 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[13].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[13].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[13].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[13].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[13].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[13].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_NC));
+	h2c->dword28 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[14].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[14].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[14].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[14].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[14].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[14].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_NC));
+	h2c->dword29 =
+	cpu_to_le32(SET_WORD(snd_info->pndpa.he_para.sta_info[15].aid,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_AID11) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[15].bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_BW) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[15].fb_ng,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_FB_NG) |
+		    (snd_info->pndpa.he_para.sta_info[15].disambiguation ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_DISAMBIGUATION : 0) |
+		    (snd_info->pndpa.he_para.sta_info[15].cb ?
+		     FWCMD_H2C_SET_SND_PARA_HE_STA0_CB : 0) |
+		    SET_WORD(snd_info->pndpa.he_para.sta_info[15].nc,
+			     FWCMD_H2C_SET_SND_PARA_HE_STA0_NC));
+	h2c->dword30 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[0].frame_ctl,
+			     FWCMD_H2C_SET_SND_PARA_BFRP0_FRAME_CTL) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].duration,
+			     FWCMD_H2C_SET_SND_PARA_BFRP0_DURATION));
+	h2c->dword31 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[0].addr1[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr1[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr1[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr1[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword32 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[0].addr1[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr1[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr2[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr2[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword33 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[0].addr2[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr2[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr2[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[0].addr2[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword34 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[1].frame_ctl,
+			     FWCMD_H2C_SET_SND_PARA_BFRP0_FRAME_CTL) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].duration,
+			     FWCMD_H2C_SET_SND_PARA_BFRP0_DURATION));
+	h2c->dword35 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[1].addr1[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr1[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr1[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr1[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword36 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[1].addr1[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr1[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr2[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr2[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword37 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[1].addr2[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr2[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr2[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[1].addr2[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword38 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[2].frame_ctl,
+			     FWCMD_H2C_SET_SND_PARA_BFRP0_FRAME_CTL) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].duration,
+			     FWCMD_H2C_SET_SND_PARA_BFRP0_DURATION));
+	h2c->dword39 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[2].addr1[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr1[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr1[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr1[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword40 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[2].addr1[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr1[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr2[0],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr2[1],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword41 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.hdr[2].addr2[2],
+			     FWCMD_H2C_SET_SND_PARA_MACID0) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr2[3],
+			     FWCMD_H2C_SET_SND_PARA_MACID1) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr2[4],
+			     FWCMD_H2C_SET_SND_PARA_MACID2) |
+		    SET_WORD(snd_info->pbfrp.hdr[2].addr2[5],
+			     FWCMD_H2C_SET_SND_PARA_MACID3));
+	h2c->dword42 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].common.tgr_info,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_TRIGGER_INFO) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].common.ul_len,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_LENGTH) |
+		    (snd_info->pbfrp.he_para[0].common.more_tf ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_MORE_TF : 0) |
+		    (snd_info->pbfrp.he_para[0].common.cs_rqd ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_CS_REQUIRED : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].common.ul_bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_BW) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].common.gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_GI_LTF) |
+		    (snd_info->pbfrp.he_para[0].common.mimo_ltfmode ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_MU_MIMO_LTF_MODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].common.num_heltf,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_NUM_OF_HE_LTF) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].common.ul_pktext,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_PKTEXT) |
+		    (snd_info->pbfrp.he_para[0].common.ul_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_STBC : 0) |
+		    (snd_info->pbfrp.he_para[0].common.ldpc_extra_sym ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_LDPC_EXTRA_SYMBOL : 0) |
+		    (snd_info->pbfrp.he_para[0].common.dplr ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_DOPPLER : 0));
+	h2c->dword43 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].common.ap_tx_pwr,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_AP_TX_POWER) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].common.ul_sr,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_SPATIAL_REUSE));
+	h2c->dword44 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[0].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[0].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[0].user[0].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[0].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[0].user[0].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[0].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword45 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[0].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[0].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword46 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[1].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[1].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[0].user[1].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[1].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[0].user[1].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[1].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword47 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[1].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[1].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword48 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[2].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[2].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[0].user[2].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[2].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[0].user[2].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[2].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword49 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[2].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[2].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword50 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[3].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[3].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[0].user[3].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[3].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[0].user[3].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[3].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword51 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[3].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[3].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword52 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[4].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[4].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[0].user[4].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[4].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[0].user[4].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[4].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword53 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[4].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[4].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword54 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[5].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[5].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[0].user[5].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[5].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[0].user[5].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[5].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword55 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[5].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[5].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword56 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[6].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[6].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[0].user[6].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[6].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[0].user[6].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[6].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword57 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[6].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[6].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword58 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[7].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[7].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[0].user[7].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[7].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[0].user[7].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[7].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword59 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[0].user[7].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[0].user[7].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword60 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].common.tgr_info,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_TRIGGER_INFO) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].common.ul_len,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_LENGTH) |
+		    (snd_info->pbfrp.he_para[1].common.more_tf ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_MORE_TF : 0) |
+		    (snd_info->pbfrp.he_para[1].common.cs_rqd ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_CS_REQUIRED : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].common.ul_bw,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_BW) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].common.gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_GI_LTF) |
+		    (snd_info->pbfrp.he_para[1].common.mimo_ltfmode ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_MU_MIMO_LTF_MODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].common.num_heltf,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_NUM_OF_HE_LTF) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].common.ul_pktext,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_PKTEXT) |
+		    (snd_info->pbfrp.he_para[1].common.ul_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_STBC : 0) |
+		    (snd_info->pbfrp.he_para[1].common.ldpc_extra_sym ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_LDPC_EXTRA_SYMBOL : 0) |
+		    (snd_info->pbfrp.he_para[1].common.dplr ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_DOPPLER : 0));
+	h2c->dword61 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].common.ap_tx_pwr,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_AP_TX_POWER) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].common.ul_sr,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_UL_SPATIAL_REUSE));
+	h2c->dword62 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[0].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[0].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[1].user[0].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[0].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[1].user[0].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[0].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword63 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[0].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[0].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword64 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[1].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[1].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[1].user[1].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[1].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[1].user[1].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[1].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword65 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[1].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[1].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword66 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[2].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[2].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[1].user[2].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[2].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[1].user[2].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[2].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword67 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[2].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[2].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword68 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[3].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[3].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[1].user[3].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[3].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[1].user[3].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[3].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword69 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[3].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[3].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword70 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[4].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[4].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[1].user[4].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[4].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[1].user[4].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[4].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword71 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[4].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[4].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword72 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[5].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[5].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[1].user[5].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[5].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[1].user[5].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[5].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword73 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[5].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[5].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword74 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[6].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[6].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[1].user[6].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[6].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[1].user[6].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[6].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword75 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[6].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[6].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword76 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[7].aid12,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_AID12) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[7].ru_pos,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_RU_POS) |
+		    (snd_info->pbfrp.he_para[1].user[7].ul_fec_code ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_FEC_CODE : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[7].ul_mcs,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_MCS) |
+		    (snd_info->pbfrp.he_para[1].user[7].ul_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_DCM : 0) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[7].ss_alloc,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_SS_ALLOC));
+	h2c->dword77 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.he_para[1].user[7].fbseg_rexmit_bmp,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.he_para[1].user[7].ul_tgt_rssi,
+			     FWCMD_H2C_SET_SND_PARA_HE_BFRP0_U0_UL_TGT_RSSI));
+	h2c->dword78 =
+	cpu_to_le32(SET_WORD(snd_info->pbfrp.vht_para[0].retransmission_bitmap,
+			     FWCMD_H2C_SET_SND_PARA_VHT_BFRP0_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.vht_para[1].retransmission_bitmap,
+			     FWCMD_H2C_SET_SND_PARA_VHT_BFRP1_FB_REXMIT) |
+		    SET_WORD(snd_info->pbfrp.vht_para[2].retransmission_bitmap,
+			     FWCMD_H2C_SET_SND_PARA_VHT_BFRP2_FB_REXMIT));
+	h2c->dword79 =
+	cpu_to_le32(SET_WORD(snd_info->wd[0].txpktsize,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPKTSIZE_WD0) |
+		    SET_WORD(snd_info->wd[0].ndpa_duration,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_DURATION_WD0));
+	h2c->dword80 =
+	cpu_to_le32(SET_WORD(snd_info->wd[0].datarate,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATARATE_WD0) |
+		    SET_WORD(snd_info->wd[0].macid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MACID_WD0) |
+		    (snd_info->wd[0].force_txop ?
+		     FWCMD_H2C_SET_SND_PARA_WD_FORCE_TXOP_WD0 : 0) |
+		    SET_WORD(snd_info->wd[0].data_bw,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_WD0) |
+		    SET_WORD(snd_info->wd[0].gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_WD_GI_LTF_WD0) |
+		    (snd_info->wd[0].data_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_ER_WD0 : 0) |
+		    (snd_info->wd[0].data_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_DCM_WD0 : 0) |
+		    (snd_info->wd[0].data_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_STBC_WD0 : 0) |
+		    (snd_info->wd[0].data_ldpc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_LDPC_WD0 : 0) |
+		    (snd_info->wd[0].data_bw_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_ER_WD0 : 0) |
+		    (snd_info->wd[0].multiport_id ?
+		     FWCMD_H2C_SET_SND_PARA_WD_MULTIPORT_ID_WD0 : 0) |
+		    SET_WORD(snd_info->wd[0].mbssid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MBSSID_WD0));
+	h2c->dword81 =
+	cpu_to_le32(SET_WORD(snd_info->wd[0].signaling_ta_pkt_sc,
+			     FWCMD_H2C_SET_SND_PARA_WD_SIGNALING_TA_PKT_SC_WD0) |
+		    SET_WORD(snd_info->wd[0].sw_define,
+			     FWCMD_H2C_SET_SND_PARA_WD_SW_DEFINE_WD0) |
+		    SET_WORD(snd_info->wd[0].txpwr_ofset_type,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPWR_OFSET_TYPE_WD0) |
+		    SET_WORD(snd_info->wd[0].lifetime_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_LIFETIME_SEL_WD0) |
+		    (snd_info->wd[0].stf_mode ?
+		     FWCMD_H2C_SET_SND_PARA_WD_STF_MODE_WD0 : 0) |
+		    (snd_info->wd[0].disdatafb ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DISDATAFB_WD0 : 0) |
+		    (snd_info->wd[0].data_txcnt_lmt_sel ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_SEL_WD0 : 0) |
+		    SET_WORD(snd_info->wd[0].data_txcnt_lmt,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_WD0) |
+		    (snd_info->wd[0].sifs_tx ?
+		     FWCMD_H2C_SET_SND_PARA_WD_SIFS_TX_WD0 : 0) |
+		    SET_WORD(snd_info->wd[0].snd_pkt_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_SND_PKT_SEL_WD0) |
+		    SET_WORD(snd_info->wd[0].ndpa,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_WD0));
+	h2c->dword82 =
+	cpu_to_le32(SET_WORD(snd_info->wd[1].txpktsize,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPKTSIZE_WD0) |
+		    SET_WORD(snd_info->wd[1].ndpa_duration,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_DURATION_WD0));
+	h2c->dword83 =
+	cpu_to_le32(SET_WORD(snd_info->wd[1].datarate,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATARATE_WD0) |
+		    SET_WORD(snd_info->wd[1].macid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MACID_WD0) |
+		    (snd_info->wd[1].force_txop ?
+		     FWCMD_H2C_SET_SND_PARA_WD_FORCE_TXOP_WD0 : 0) |
+		    SET_WORD(snd_info->wd[1].data_bw,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_WD0) |
+		    SET_WORD(snd_info->wd[1].gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_WD_GI_LTF_WD0) |
+		    (snd_info->wd[1].data_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_ER_WD0 : 0) |
+		    (snd_info->wd[1].data_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_DCM_WD0 : 0) |
+		    (snd_info->wd[1].data_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_STBC_WD0 : 0) |
+		    (snd_info->wd[1].data_ldpc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_LDPC_WD0 : 0) |
+		    (snd_info->wd[1].data_bw_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_ER_WD0 : 0) |
+		    (snd_info->wd[1].multiport_id ?
+		     FWCMD_H2C_SET_SND_PARA_WD_MULTIPORT_ID_WD0 : 0) |
+		    SET_WORD(snd_info->wd[1].mbssid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MBSSID_WD0));
+	h2c->dword84 =
+	cpu_to_le32(SET_WORD(snd_info->wd[1].signaling_ta_pkt_sc,
+			     FWCMD_H2C_SET_SND_PARA_WD_SIGNALING_TA_PKT_SC_WD0) |
+		    SET_WORD(snd_info->wd[1].sw_define,
+			     FWCMD_H2C_SET_SND_PARA_WD_SW_DEFINE_WD0) |
+		    SET_WORD(snd_info->wd[1].txpwr_ofset_type,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPWR_OFSET_TYPE_WD0) |
+		    SET_WORD(snd_info->wd[1].lifetime_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_LIFETIME_SEL_WD0) |
+		    (snd_info->wd[1].stf_mode ?
+		     FWCMD_H2C_SET_SND_PARA_WD_STF_MODE_WD0 : 0) |
+		    (snd_info->wd[1].disdatafb ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DISDATAFB_WD0 : 0) |
+		    (snd_info->wd[1].data_txcnt_lmt_sel ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_SEL_WD0 : 0) |
+		    SET_WORD(snd_info->wd[1].data_txcnt_lmt,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_WD0) |
+		    (snd_info->wd[1].sifs_tx ?
+		     FWCMD_H2C_SET_SND_PARA_WD_SIFS_TX_WD0 : 0) |
+		    SET_WORD(snd_info->wd[1].snd_pkt_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_SND_PKT_SEL_WD0) |
+		    SET_WORD(snd_info->wd[1].ndpa,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_WD0));
+	h2c->dword85 =
+	cpu_to_le32(SET_WORD(snd_info->wd[2].txpktsize,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPKTSIZE_WD0) |
+		    SET_WORD(snd_info->wd[2].ndpa_duration,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_DURATION_WD0));
+	h2c->dword86 =
+	cpu_to_le32(SET_WORD(snd_info->wd[2].datarate,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATARATE_WD0) |
+		    SET_WORD(snd_info->wd[2].macid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MACID_WD0) |
+		    (snd_info->wd[2].force_txop ?
+		     FWCMD_H2C_SET_SND_PARA_WD_FORCE_TXOP_WD0 : 0) |
+		    SET_WORD(snd_info->wd[2].data_bw,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_WD0) |
+		    SET_WORD(snd_info->wd[2].gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_WD_GI_LTF_WD0) |
+		    (snd_info->wd[2].data_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_ER_WD0 : 0) |
+		    (snd_info->wd[2].data_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_DCM_WD0 : 0) |
+		    (snd_info->wd[2].data_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_STBC_WD0 : 0) |
+		    (snd_info->wd[2].data_ldpc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_LDPC_WD0 : 0) |
+		    (snd_info->wd[2].data_bw_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_ER_WD0 : 0) |
+		    (snd_info->wd[2].multiport_id ?
+		     FWCMD_H2C_SET_SND_PARA_WD_MULTIPORT_ID_WD0 : 0) |
+		    SET_WORD(snd_info->wd[2].mbssid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MBSSID_WD0));
+	h2c->dword87 =
+	cpu_to_le32(SET_WORD(snd_info->wd[2].signaling_ta_pkt_sc,
+			     FWCMD_H2C_SET_SND_PARA_WD_SIGNALING_TA_PKT_SC_WD0) |
+		    SET_WORD(snd_info->wd[2].sw_define,
+			     FWCMD_H2C_SET_SND_PARA_WD_SW_DEFINE_WD0) |
+		    SET_WORD(snd_info->wd[2].txpwr_ofset_type,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPWR_OFSET_TYPE_WD0) |
+		    SET_WORD(snd_info->wd[2].lifetime_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_LIFETIME_SEL_WD0) |
+		    (snd_info->wd[2].stf_mode ?
+		     FWCMD_H2C_SET_SND_PARA_WD_STF_MODE_WD0 : 0) |
+		    (snd_info->wd[2].disdatafb ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DISDATAFB_WD0 : 0) |
+		    (snd_info->wd[2].data_txcnt_lmt_sel ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_SEL_WD0 : 0) |
+		    SET_WORD(snd_info->wd[2].data_txcnt_lmt,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_WD0) |
+		    (snd_info->wd[2].sifs_tx ?
+		     FWCMD_H2C_SET_SND_PARA_WD_SIFS_TX_WD0 : 0) |
+		    SET_WORD(snd_info->wd[2].snd_pkt_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_SND_PKT_SEL_WD0) |
+		    SET_WORD(snd_info->wd[2].ndpa,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_WD0));
+	h2c->dword88 =
+	cpu_to_le32(SET_WORD(snd_info->wd[3].txpktsize,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPKTSIZE_WD0) |
+		    SET_WORD(snd_info->wd[3].ndpa_duration,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_DURATION_WD0));
+	h2c->dword89 =
+	cpu_to_le32(SET_WORD(snd_info->wd[3].datarate,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATARATE_WD0) |
+		    SET_WORD(snd_info->wd[3].macid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MACID_WD0) |
+		    (snd_info->wd[3].force_txop ?
+		     FWCMD_H2C_SET_SND_PARA_WD_FORCE_TXOP_WD0 : 0) |
+		    SET_WORD(snd_info->wd[3].data_bw,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_WD0) |
+		    SET_WORD(snd_info->wd[3].gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_WD_GI_LTF_WD0) |
+		    (snd_info->wd[3].data_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_ER_WD0 : 0) |
+		    (snd_info->wd[3].data_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_DCM_WD0 : 0) |
+		    (snd_info->wd[3].data_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_STBC_WD0 : 0) |
+		    (snd_info->wd[3].data_ldpc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_LDPC_WD0 : 0) |
+		    (snd_info->wd[3].data_bw_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_ER_WD0 : 0) |
+		    (snd_info->wd[3].multiport_id ?
+		     FWCMD_H2C_SET_SND_PARA_WD_MULTIPORT_ID_WD0 : 0) |
+		    SET_WORD(snd_info->wd[3].mbssid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MBSSID_WD0));
+	h2c->dword90 =
+	cpu_to_le32(SET_WORD(snd_info->wd[3].signaling_ta_pkt_sc,
+			     FWCMD_H2C_SET_SND_PARA_WD_SIGNALING_TA_PKT_SC_WD0) |
+		    SET_WORD(snd_info->wd[3].sw_define,
+			     FWCMD_H2C_SET_SND_PARA_WD_SW_DEFINE_WD0) |
+		    SET_WORD(snd_info->wd[3].txpwr_ofset_type,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPWR_OFSET_TYPE_WD0) |
+		    SET_WORD(snd_info->wd[3].lifetime_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_LIFETIME_SEL_WD0) |
+		    (snd_info->wd[3].stf_mode ?
+		     FWCMD_H2C_SET_SND_PARA_WD_STF_MODE_WD0 : 0) |
+		    (snd_info->wd[3].disdatafb ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DISDATAFB_WD0 : 0) |
+		    (snd_info->wd[3].data_txcnt_lmt_sel ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_SEL_WD0 : 0) |
+		    SET_WORD(snd_info->wd[3].data_txcnt_lmt,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_WD0) |
+		    (snd_info->wd[3].sifs_tx ?
+		     FWCMD_H2C_SET_SND_PARA_WD_SIFS_TX_WD0 : 0) |
+		    SET_WORD(snd_info->wd[3].snd_pkt_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_SND_PKT_SEL_WD0) |
+		    SET_WORD(snd_info->wd[3].ndpa,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_WD0));
+	h2c->dword91 =
+	cpu_to_le32(SET_WORD(snd_info->wd[4].txpktsize,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPKTSIZE_WD0) |
+		    SET_WORD(snd_info->wd[4].ndpa_duration,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_DURATION_WD0));
+	h2c->dword92 =
+	cpu_to_le32(SET_WORD(snd_info->wd[4].datarate,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATARATE_WD0) |
+		    SET_WORD(snd_info->wd[4].macid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MACID_WD0) |
+		    (snd_info->wd[4].force_txop ?
+		     FWCMD_H2C_SET_SND_PARA_WD_FORCE_TXOP_WD0 : 0) |
+		    SET_WORD(snd_info->wd[4].data_bw,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_WD0) |
+		    SET_WORD(snd_info->wd[4].gi_ltf,
+			     FWCMD_H2C_SET_SND_PARA_WD_GI_LTF_WD0) |
+		    (snd_info->wd[4].data_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_ER_WD0 : 0) |
+		    (snd_info->wd[4].data_dcm ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_DCM_WD0 : 0) |
+		    (snd_info->wd[4].data_stbc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_STBC_WD0 : 0) |
+		    (snd_info->wd[4].data_ldpc ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_LDPC_WD0 : 0) |
+		    (snd_info->wd[4].data_bw_er ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_BW_ER_WD0 : 0) |
+		    (snd_info->wd[4].multiport_id ?
+		     FWCMD_H2C_SET_SND_PARA_WD_MULTIPORT_ID_WD0 : 0) |
+		    SET_WORD(snd_info->wd[4].mbssid,
+			     FWCMD_H2C_SET_SND_PARA_WD_MBSSID_WD0));
+	h2c->dword93 =
+	cpu_to_le32(SET_WORD(snd_info->wd[4].signaling_ta_pkt_sc,
+			     FWCMD_H2C_SET_SND_PARA_WD_SIGNALING_TA_PKT_SC_WD0) |
+		    SET_WORD(snd_info->wd[4].sw_define,
+			     FWCMD_H2C_SET_SND_PARA_WD_SW_DEFINE_WD0) |
+		    SET_WORD(snd_info->wd[4].txpwr_ofset_type,
+			     FWCMD_H2C_SET_SND_PARA_WD_TXPWR_OFSET_TYPE_WD0) |
+		    SET_WORD(snd_info->wd[4].lifetime_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_LIFETIME_SEL_WD0) |
+		    (snd_info->wd[4].stf_mode ?
+		     FWCMD_H2C_SET_SND_PARA_WD_STF_MODE_WD0 : 0) |
+		    (snd_info->wd[4].disdatafb ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DISDATAFB_WD0 : 0) |
+		    (snd_info->wd[4].data_txcnt_lmt_sel ?
+		     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_SEL_WD0 : 0) |
+		    SET_WORD(snd_info->wd[4].data_txcnt_lmt,
+			     FWCMD_H2C_SET_SND_PARA_WD_DATA_TXCNT_LMT_WD0) |
+		    (snd_info->wd[4].sifs_tx ?
+		     FWCMD_H2C_SET_SND_PARA_WD_SIFS_TX_WD0 : 0) |
+		    SET_WORD(snd_info->wd[4].snd_pkt_sel,
+			     FWCMD_H2C_SET_SND_PARA_WD_SND_PKT_SEL_WD0) |
+		    SET_WORD(snd_info->wd[4].ndpa,
+			     FWCMD_H2C_SET_SND_PARA_WD_NDPA_WD0));
+	h2c->dword94 =
+	cpu_to_le32(SET_WORD(snd_info->f2p[0].csi_len_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_CSI_LEN_BFRP0) |
+		    SET_WORD(snd_info->f2p[0].tb_t_pe_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_TB_T_PE_BFRP0) |
+		    SET_WORD(snd_info->f2p[0].tri_pad_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_TRI_PAD_BFRP0) |
+		    (snd_info->f2p[0].ul_cqi_rpt_tri_bfrp ?
+		     FWCMD_H2C_SET_SND_PARA_UL_CQI_RPT_TRI_BFRP0 : 0) |
+		    SET_WORD(snd_info->f2p[0].rf_gain_idx_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_RF_GAIN_IDX_BFRP0) |
+		    (snd_info->f2p[0].fix_gain_en_bfrp ?
+		     FWCMD_H2C_SET_SND_PARA_FIX_GAIN_EN_BFRP0 : 0) |
+		    SET_WORD(snd_info->f2p[0].ul_len_ref,
+			     FWCMD_H2C_SET_SND_PARA_RF_GAIN_IDX_BFRP0));
+	h2c->dword95 =
+	cpu_to_le32(SET_WORD(snd_info->f2p[1].csi_len_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_CSI_LEN_BFRP0) |
+		    SET_WORD(snd_info->f2p[1].tb_t_pe_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_TB_T_PE_BFRP0) |
+		    SET_WORD(snd_info->f2p[1].tri_pad_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_TRI_PAD_BFRP0) |
+		    (snd_info->f2p[1].ul_cqi_rpt_tri_bfrp ?
+		     FWCMD_H2C_SET_SND_PARA_UL_CQI_RPT_TRI_BFRP0 : 0) |
+		    SET_WORD(snd_info->f2p[1].rf_gain_idx_bfrp,
+			     FWCMD_H2C_SET_SND_PARA_RF_GAIN_IDX_BFRP0) |
+		    (snd_info->f2p[1].fix_gain_en_bfrp ?
+		     FWCMD_H2C_SET_SND_PARA_FIX_GAIN_EN_BFRP0 : 0) |
+		    SET_WORD(snd_info->f2p[1].ul_len_ref,
+			     FWCMD_H2C_SET_SND_PARA_RF_GAIN_IDX_BFRP0));
+	h2c->dword96 =
+	cpu_to_le32(SET_WORD(snd_info->sfp.f2p_type,
+			     FWCMD_H2C_SET_SND_PARA_F2P_TYPE) |
+		    SET_WORD(snd_info->sfp.f2p_index,
+			     FWCMD_H2C_SET_SND_PARA_F2P_INDEX) |
+		    SET_WORD(snd_info->sfp.f2p_period,
+			     FWCMD_H2C_SET_SND_PARA_F2P_PERIOD));
+	h2c->dword97 =
+	cpu_to_le32(SET_WORD(snd_info->sfp.f2p_updcnt,
+			     FWCMD_H2C_SET_SND_PARA_F2P_UPDCNT) |
+		    SET_WORD(snd_info->sfp.cr_idx,
+			     FWCMD_H2C_SET_SND_PARA_CR_IDX));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_SOUND,
+			      FWCMD_H2C_FUNC_SET_SND_PARA_V1,
+			      0,
+			      0);
+		if (ret)
+			goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+#endif
+
+u32 mac_set_snd_para(struct mac_ax_adapter *adapter,
+		     struct mac_ax_fwcmd_snd *snd_info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret, val32;
+	u8 band = 0;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+	//set wmm1 to sw mode tx for snd
+	val32 = MAC_REG_R32(R_AX_PTCL_COMMON_SETTING_0);
+	val32 = val32 & (~B_AX_CMAC_TX_MODE_1);
+	MAC_REG_W32(R_AX_PTCL_COMMON_SETTING_0, val32);
+
+	switch (snd_info->frexgtype) {
+	case FRAME_EXCHANGE_SND_N_SU:
+		snd_info->wd[0].txpktsize = 31;
+		snd_info->wd[0].stf_mode = 1;
+		snd_info->wd[0].disdatafb = 1;
+		snd_info->wd[0].data_txcnt_lmt_sel = 1;
+		snd_info->wd[0].data_txcnt_lmt = 1;
+		snd_info->wd[0].sifs_tx = 1;
+		snd_info->wd[0].snd_pkt_sel = 0;
+		snd_info->wd[0].ndpa = 1;
+
+		snd_info->wd[1].txpktsize = 0;
+		snd_info->wd[1].stf_mode = 1;
+		snd_info->wd[1].disdatafb = 1;
+		snd_info->wd[1].data_txcnt_lmt_sel = 1;
+		snd_info->wd[1].data_txcnt_lmt = 1;
+		snd_info->wd[1].sifs_tx = 0;
+		snd_info->wd[1].snd_pkt_sel = 2;
+		snd_info->wd[1].ndpa = 1;
+
+		snd_info->wd[2].txpktsize = 0;
+		snd_info->wd[2].stf_mode = 0;
+		snd_info->wd[2].disdatafb = 0;
+		snd_info->wd[2].data_txcnt_lmt_sel = 0;
+		snd_info->wd[2].data_txcnt_lmt = 0;
+		snd_info->wd[2].sifs_tx = 0;
+		snd_info->wd[2].snd_pkt_sel = 0;
+		snd_info->wd[2].ndpa = 0;
+
+		snd_info->wd[3].txpktsize = 0;
+		snd_info->wd[3].stf_mode = 0;
+		snd_info->wd[3].disdatafb = 0;
+		snd_info->wd[3].data_txcnt_lmt_sel = 0;
+		snd_info->wd[3].data_txcnt_lmt = 0;
+		snd_info->wd[3].sifs_tx = 0;
+		snd_info->wd[3].snd_pkt_sel = 0;
+		snd_info->wd[3].ndpa = 0;
+
+		snd_info->wd[4].txpktsize = 0;
+		snd_info->wd[4].stf_mode = 0;
+		snd_info->wd[4].disdatafb = 0;
+		snd_info->wd[4].data_txcnt_lmt_sel = 0;
+		snd_info->wd[4].data_txcnt_lmt = 0;
+		snd_info->wd[4].sifs_tx = 0;
+		snd_info->wd[4].snd_pkt_sel = 0;
+		snd_info->wd[4].ndpa = 0;
+		break;
+
+	case FRAME_EXCHANGE_SND_AC_SU:
+		snd_info->wd[0].txpktsize = 19;
+		snd_info->wd[0].stf_mode = 1;
+		snd_info->wd[0].disdatafb = 1;
+		snd_info->wd[0].data_txcnt_lmt_sel = 1;
+		snd_info->wd[0].data_txcnt_lmt = 1;
+		snd_info->wd[0].sifs_tx = 1;
+		snd_info->wd[0].snd_pkt_sel = 0;
+		snd_info->wd[0].ndpa = 2;
+
+		snd_info->wd[1].txpktsize = 0;
+		snd_info->wd[1].stf_mode = 1;
+		snd_info->wd[1].disdatafb = 1;
+		snd_info->wd[1].data_txcnt_lmt_sel = 1;
+		snd_info->wd[1].data_txcnt_lmt = 1;
+		snd_info->wd[1].sifs_tx = 0;
+		snd_info->wd[1].snd_pkt_sel = 2;
+		snd_info->wd[1].ndpa = 2;
+
+		snd_info->wd[2].txpktsize = 0;
+		snd_info->wd[2].stf_mode = 0;
+		snd_info->wd[2].disdatafb = 0;
+		snd_info->wd[2].data_txcnt_lmt_sel = 0;
+		snd_info->wd[2].data_txcnt_lmt = 0;
+		snd_info->wd[2].sifs_tx = 0;
+		snd_info->wd[2].snd_pkt_sel = 0;
+		snd_info->wd[2].ndpa = 0;
+
+		snd_info->wd[3].txpktsize = 0;
+		snd_info->wd[3].stf_mode = 0;
+		snd_info->wd[3].disdatafb = 0;
+		snd_info->wd[3].data_txcnt_lmt_sel = 0;
+		snd_info->wd[3].data_txcnt_lmt = 0;
+		snd_info->wd[3].sifs_tx = 0;
+		snd_info->wd[3].snd_pkt_sel = 0;
+		snd_info->wd[3].ndpa = 0;
+
+		snd_info->wd[4].txpktsize = 0;
+		snd_info->wd[4].stf_mode = 0;
+		snd_info->wd[4].disdatafb = 0;
+		snd_info->wd[4].data_txcnt_lmt_sel = 0;
+		snd_info->wd[4].data_txcnt_lmt = 0;
+		snd_info->wd[4].sifs_tx = 0;
+		snd_info->wd[4].snd_pkt_sel = 0;
+		snd_info->wd[4].ndpa = 0;
+		break;
+	case FRAME_EXCHANGE_SND_AC_MU_BFRP1:
+		snd_info->wd[0].txpktsize = 21;
+		snd_info->wd[0].stf_mode = 1;
+		snd_info->wd[0].disdatafb = 1;
+		snd_info->wd[0].data_txcnt_lmt_sel = 1;
+		snd_info->wd[0].data_txcnt_lmt = 1;
+		snd_info->wd[0].sifs_tx = 1;
+		snd_info->wd[0].snd_pkt_sel = 1;
+		snd_info->wd[0].ndpa = 2;
+
+		snd_info->wd[1].txpktsize = 0;
+		snd_info->wd[1].stf_mode = 1;
+		snd_info->wd[1].disdatafb = 1;
+		snd_info->wd[1].data_txcnt_lmt_sel = 1;
+		snd_info->wd[1].data_txcnt_lmt = 1;
+		snd_info->wd[1].sifs_tx = 1;
+		snd_info->wd[1].snd_pkt_sel = 3;
+		snd_info->wd[1].ndpa = 2;
+
+		snd_info->wd[2].txpktsize = 17;
+		snd_info->wd[2].stf_mode = 1;
+		snd_info->wd[2].disdatafb = 1;
+		snd_info->wd[2].data_txcnt_lmt_sel = 1;
+		snd_info->wd[2].data_txcnt_lmt = 1;
+		snd_info->wd[2].sifs_tx = 0;
+		snd_info->wd[2].snd_pkt_sel = 5;
+		snd_info->wd[2].ndpa = 2;
+
+		snd_info->wd[3].txpktsize = 0;
+		snd_info->wd[3].stf_mode = 0;
+		snd_info->wd[3].disdatafb = 0;
+		snd_info->wd[3].data_txcnt_lmt_sel = 0;
+		snd_info->wd[3].data_txcnt_lmt = 0;
+		snd_info->wd[3].sifs_tx = 0;
+		snd_info->wd[3].snd_pkt_sel = 0;
+		snd_info->wd[3].ndpa = 0;
+
+		snd_info->wd[4].txpktsize = 0;
+		snd_info->wd[4].stf_mode = 0;
+		snd_info->wd[4].disdatafb = 0;
+		snd_info->wd[4].data_txcnt_lmt_sel = 0;
+		snd_info->wd[4].data_txcnt_lmt = 0;
+		snd_info->wd[4].sifs_tx = 0;
+		snd_info->wd[4].snd_pkt_sel = 0;
+		snd_info->wd[4].ndpa = 0;
+		break;
+	case FRAME_EXCHANGE_SND_AC_MU_BFRP2:
+		snd_info->wd[0].txpktsize = 23;
+		snd_info->wd[0].stf_mode = 1;
+		snd_info->wd[0].disdatafb = 1;
+		snd_info->wd[0].data_txcnt_lmt_sel = 1;
+		snd_info->wd[0].data_txcnt_lmt = 1;
+		snd_info->wd[0].sifs_tx = 1;
+		snd_info->wd[0].snd_pkt_sel = 1;
+		snd_info->wd[0].ndpa = 2;
+
+		snd_info->wd[1].txpktsize = 0;
+		snd_info->wd[1].stf_mode = 1;
+		snd_info->wd[1].disdatafb = 1;
+		snd_info->wd[1].data_txcnt_lmt_sel = 1;
+		snd_info->wd[1].data_txcnt_lmt = 1;
+		snd_info->wd[1].sifs_tx = 1;
+		snd_info->wd[1].snd_pkt_sel = 3;
+		snd_info->wd[1].ndpa = 2;
+
+		snd_info->wd[2].txpktsize = 17;
+		snd_info->wd[2].stf_mode = 1;
+		snd_info->wd[2].disdatafb = 1;
+		snd_info->wd[2].data_txcnt_lmt_sel = 1;
+		snd_info->wd[2].data_txcnt_lmt = 1;
+		snd_info->wd[2].sifs_tx = 1;
+		snd_info->wd[2].snd_pkt_sel = 4;
+		snd_info->wd[2].ndpa = 2;
+
+		snd_info->wd[3].txpktsize = 17;
+		snd_info->wd[3].stf_mode = 1;
+		snd_info->wd[3].disdatafb = 1;
+		snd_info->wd[3].data_txcnt_lmt_sel = 1;
+		snd_info->wd[3].data_txcnt_lmt = 1;
+		snd_info->wd[3].sifs_tx = 0;
+		snd_info->wd[3].snd_pkt_sel = 5;
+		snd_info->wd[3].ndpa = 2;
+
+		snd_info->wd[4].txpktsize = 0;
+		snd_info->wd[4].stf_mode = 0;
+		snd_info->wd[4].disdatafb = 0;
+		snd_info->wd[4].data_txcnt_lmt_sel = 0;
+		snd_info->wd[4].data_txcnt_lmt = 0;
+		snd_info->wd[4].sifs_tx = 0;
+		snd_info->wd[4].snd_pkt_sel = 0;
+		snd_info->wd[4].ndpa = 0;
+		break;
+	case FRAME_EXCHANGE_SND_AC_MU_BFRP3:
+		snd_info->wd[0].txpktsize = 25;
+		snd_info->wd[0].stf_mode = 1;
+		snd_info->wd[0].disdatafb = 1;
+		snd_info->wd[0].data_txcnt_lmt_sel = 1;
+		snd_info->wd[0].data_txcnt_lmt = 1;
+		snd_info->wd[0].sifs_tx = 1;
+		snd_info->wd[0].snd_pkt_sel = 1;
+		snd_info->wd[0].ndpa = 2;
+
+		snd_info->wd[1].txpktsize = 0;
+		snd_info->wd[1].stf_mode = 1;
+		snd_info->wd[1].disdatafb = 1;
+		snd_info->wd[1].data_txcnt_lmt_sel = 1;
+		snd_info->wd[1].data_txcnt_lmt = 1;
+		snd_info->wd[1].sifs_tx = 1;
+		snd_info->wd[1].snd_pkt_sel = 3;
+		snd_info->wd[1].ndpa = 2;
+
+		snd_info->wd[2].txpktsize = 17;
+		snd_info->wd[2].stf_mode = 1;
+		snd_info->wd[2].disdatafb = 1;
+		snd_info->wd[2].data_txcnt_lmt_sel = 1;
+		snd_info->wd[2].data_txcnt_lmt = 1;
+		snd_info->wd[2].sifs_tx = 1;
+		snd_info->wd[2].snd_pkt_sel = 4;
+		snd_info->wd[2].ndpa = 2;
+
+		snd_info->wd[3].txpktsize = 17;
+		snd_info->wd[3].stf_mode = 1;
+		snd_info->wd[3].disdatafb = 1;
+		snd_info->wd[3].data_txcnt_lmt_sel = 1;
+		snd_info->wd[3].data_txcnt_lmt = 1;
+		snd_info->wd[3].sifs_tx = 1;
+		snd_info->wd[3].snd_pkt_sel = 4;
+		snd_info->wd[3].ndpa = 2;
+
+		snd_info->wd[4].txpktsize = 17;
+		snd_info->wd[4].stf_mode = 1;
+		snd_info->wd[4].disdatafb = 1;
+		snd_info->wd[4].data_txcnt_lmt_sel = 1;
+		snd_info->wd[4].data_txcnt_lmt = 1;
+		snd_info->wd[4].sifs_tx = 0;
+		snd_info->wd[4].snd_pkt_sel = 5;
+		snd_info->wd[4].ndpa = 2;
+		break;
+	case FRAME_EXCHANGE_SND_AX_SU:
+		snd_info->wd[0].txpktsize = 21;
+		snd_info->wd[0].stf_mode = 1;
+		snd_info->wd[0].disdatafb = 1;
+		snd_info->wd[0].data_txcnt_lmt_sel = 1;
+		snd_info->wd[0].data_txcnt_lmt = 1;
+		snd_info->wd[0].sifs_tx = 1;
+		snd_info->wd[0].snd_pkt_sel = 0;
+		snd_info->wd[0].ndpa = 3;
+
+		snd_info->wd[1].txpktsize = 0;
+		snd_info->wd[1].stf_mode = 1;
+		snd_info->wd[1].disdatafb = 1;
+		snd_info->wd[1].data_txcnt_lmt_sel = 1;
+		snd_info->wd[1].data_txcnt_lmt = 1;
+		snd_info->wd[1].sifs_tx = 0;
+		snd_info->wd[1].snd_pkt_sel = 2;
+		snd_info->wd[1].ndpa = 3;
+
+		snd_info->wd[2].txpktsize = 0;
+		snd_info->wd[2].stf_mode = 0;
+		snd_info->wd[2].disdatafb = 0;
+		snd_info->wd[2].data_txcnt_lmt_sel = 0;
+		snd_info->wd[2].data_txcnt_lmt = 0;
+		snd_info->wd[2].sifs_tx = 0;
+		snd_info->wd[2].snd_pkt_sel = 0;
+		snd_info->wd[2].ndpa = 0;
+
+		snd_info->wd[3].txpktsize = 0;
+		snd_info->wd[3].stf_mode = 0;
+		snd_info->wd[3].disdatafb = 0;
+		snd_info->wd[3].data_txcnt_lmt_sel = 0;
+		snd_info->wd[3].data_txcnt_lmt = 0;
+		snd_info->wd[3].sifs_tx = 0;
+		snd_info->wd[3].snd_pkt_sel = 0;
+		snd_info->wd[3].ndpa = 0;
+
+		snd_info->wd[4].txpktsize = 0;
+		snd_info->wd[4].stf_mode = 0;
+		snd_info->wd[4].disdatafb = 0;
+		snd_info->wd[4].data_txcnt_lmt_sel = 0;
+		snd_info->wd[4].data_txcnt_lmt = 0;
+		snd_info->wd[4].sifs_tx = 0;
+		snd_info->wd[4].snd_pkt_sel = 0;
+		snd_info->wd[4].ndpa = 0;
+		break;
+	case FRAME_EXCHANGE_SND_AX_MU_BFRP1:
+		snd_info->wd[0].txpktsize = 17 + 4 * snd_info->bfrp0_user_num;
+		if (snd_info->mode == SND_NDPA_PATCH_STA)
+			snd_info->wd[0].txpktsize += 4;
+		snd_info->wd[0].stf_mode = 1;
+		snd_info->wd[0].disdatafb = 1;
+		snd_info->wd[0].data_txcnt_lmt_sel = 1;
+		snd_info->wd[0].data_txcnt_lmt = 1;
+		snd_info->wd[0].sifs_tx = 1;
+		snd_info->wd[0].snd_pkt_sel = 1;
+		snd_info->wd[0].ndpa = 3;
+
+		snd_info->wd[1].txpktsize = 0;
+		snd_info->wd[1].stf_mode = 1;
+		snd_info->wd[1].disdatafb = 1;
+		snd_info->wd[1].data_txcnt_lmt_sel = 1;
+		snd_info->wd[1].data_txcnt_lmt = 1;
+		snd_info->wd[1].sifs_tx = 1;
+		snd_info->wd[1].snd_pkt_sel = 3;
+		snd_info->wd[1].ndpa = 3;
+
+		snd_info->wd[2].txpktsize = 24 + 6 * snd_info->bfrp0_user_num;
+		snd_info->wd[2].stf_mode = 1;
+		snd_info->wd[2].disdatafb = 1;
+		snd_info->wd[2].data_txcnt_lmt_sel = 1;
+		snd_info->wd[2].data_txcnt_lmt = 1;
+		snd_info->wd[2].sifs_tx = 0;
+		snd_info->wd[2].snd_pkt_sel = 5;
+		snd_info->wd[2].ndpa = 3;
+
+		snd_info->wd[3].txpktsize = 0;
+		snd_info->wd[3].stf_mode = 0;
+		snd_info->wd[3].disdatafb = 0;
+		snd_info->wd[3].data_txcnt_lmt_sel = 0;
+		snd_info->wd[3].data_txcnt_lmt = 0;
+		snd_info->wd[3].sifs_tx = 0;
+		snd_info->wd[3].snd_pkt_sel = 0;
+		snd_info->wd[3].ndpa = 0;
+
+		snd_info->wd[4].txpktsize = 0;
+		snd_info->wd[4].stf_mode = 0;
+		snd_info->wd[4].disdatafb = 0;
+		snd_info->wd[4].data_txcnt_lmt_sel = 0;
+		snd_info->wd[4].data_txcnt_lmt = 0;
+		snd_info->wd[4].sifs_tx = 0;
+		snd_info->wd[4].snd_pkt_sel = 0;
+		snd_info->wd[4].ndpa = 0;
+		break;
+	case FRAME_EXCHANGE_SND_AX_MU_BFRP2:
+		snd_info->wd[0].txpktsize = 17 + 4 * (snd_info->bfrp0_user_num
+					    + snd_info->bfrp1_user_num);
+		snd_info->wd[0].stf_mode = 1;
+		snd_info->wd[0].disdatafb = 1;
+		snd_info->wd[0].data_txcnt_lmt_sel = 1;
+		snd_info->wd[0].data_txcnt_lmt = 1;
+		snd_info->wd[0].sifs_tx = 1;
+		snd_info->wd[0].snd_pkt_sel = 1;
+		snd_info->wd[0].ndpa = 3;
+
+		snd_info->wd[1].txpktsize = 0;
+		snd_info->wd[1].stf_mode = 1;
+		snd_info->wd[1].disdatafb = 1;
+		snd_info->wd[1].data_txcnt_lmt_sel = 1;
+		snd_info->wd[1].data_txcnt_lmt = 1;
+		snd_info->wd[1].sifs_tx = 1;
+		snd_info->wd[1].snd_pkt_sel = 3;
+		snd_info->wd[1].ndpa = 3;
+
+		snd_info->wd[2].txpktsize = 24 + 6 * (snd_info->bfrp0_user_num);
+		snd_info->wd[2].stf_mode = 1;
+		snd_info->wd[2].disdatafb = 1;
+		snd_info->wd[2].data_txcnt_lmt_sel = 1;
+		snd_info->wd[2].data_txcnt_lmt = 1;
+		snd_info->wd[2].sifs_tx = 1;
+		snd_info->wd[2].snd_pkt_sel = 4;
+		snd_info->wd[2].ndpa = 3;
+
+		snd_info->wd[3].txpktsize = 24 + 6 * (snd_info->bfrp1_user_num);
+		snd_info->wd[3].stf_mode = 1;
+		snd_info->wd[3].disdatafb = 1;
+		snd_info->wd[3].data_txcnt_lmt_sel = 1;
+		snd_info->wd[3].data_txcnt_lmt = 1;
+		snd_info->wd[3].sifs_tx = 0;
+		snd_info->wd[3].snd_pkt_sel = 5;
+		snd_info->wd[3].ndpa = 3;
+
+		snd_info->wd[4].txpktsize = 0;
+		snd_info->wd[4].stf_mode = 0;
+		snd_info->wd[4].disdatafb = 0;
+		snd_info->wd[4].data_txcnt_lmt_sel = 0;
+		snd_info->wd[4].data_txcnt_lmt = 0;
+		snd_info->wd[4].sifs_tx = 0;
+		snd_info->wd[4].snd_pkt_sel = 0;
+		snd_info->wd[4].ndpa = 0;
+		break;
+	default:
+		return MACNOTSUP;
+	}
+
+	// check input valid
+	if (snd_info->sfp.f2p_type > SNDF2P_DEL) {
+		PLTFM_MSG_ERR("Unrecognized SND F2P type: %d\n",
+			      snd_info->sfp.f2p_type);
+		return MACFUNCINPUT;
+	}
+	if (snd_info->sfp.f2p_index >= MAX_SNDTXCMDINFO_NUM) {
+		PLTFM_MSG_ERR("Unrecognized SND F2P index: %d\n",
+			      snd_info->sfp.f2p_index);
+		return MACFUNCINPUT;
+	}
+	if (snd_info->sfp.f2p_type == SNDF2P_ADD && snd_info->sfp.f2p_period == 0) {
+		PLTFM_MSG_ERR("Unrecognized SND F2P period: %d\n",
+			      snd_info->sfp.f2p_period);
+		return MACFUNCINPUT;
+	}
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+#if MAC_AX_8852A_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A))
+		return build_snd_h2c(adapter, snd_info);
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))
+		return build_snd_h2c_v1(adapter, snd_info);
+#endif
+
+	return MACNOTSUP;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sounding.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sounding.h
new file mode 100644
index 000000000000..237facdc5e81
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sounding.h
@@ -0,0 +1,409 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_SOUNDING_H_
+#define _MAC_AX_SOUNDING_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+#include "trxcfg.h"
+
+#define CSI_MAX_BUFFER_IDX		0xF
+#define SOUNDING_STS_MAX_IDX		0x15
+#define CSI_RRSC_BMAP			0x29292911
+#define BFRP_RX_STANDBY_TIMER		0x0
+#define BFRP_RX_STANDBY_TIMER_V1	0x0
+#define NDP_RX_STANDBY_TIMER		0xFF
+#define PATCH_NDP_RX_STANDBY_TIMER	0x0
+#define CSI_INIT_RATE_HE		0x0
+#define CSI_INIT_RATE_VHT		0x0
+#define CSI_INIT_RATE_HT		0x0
+#define HT_PAYLOAD_OFFSET		0x10
+#define VHT_PAYLOAD_OFFSET		0xd
+#define HE_PAYLOAD_OFFSET		0xf
+#define CSI_SH				0x4
+#define SND_SH				0x2
+#define SND_MEE_CFG	 (B_AX_BFMEE_BFPARAM_SEL | B_AX_BFMEE_USE_NSTS | \
+			 B_AX_BFMEE_CSI_FORCE_RETE_EN | B_AX_BFMEE_BFINF0_NR | \
+			 B_AX_BFMEE_BFINFO0_NC)
+#define MAX_SNDTXCMDINFO_NUM		0x4
+#define MAX_FWCMD_SND_LEN 600
+
+enum FrameExchangeType {
+	FRAME_EXCHANGE_SND_AC_SU = 31,
+	FRAME_EXCHANGE_SND_AC_MU_BFRP1 = 32,
+	FRAME_EXCHANGE_SND_AC_MU_BFRP2 = 33,
+	FRAME_EXCHANGE_SND_AC_MU_BFRP3 = 34,
+	FRAME_EXCHANGE_SND_AX_SU = 35,
+	FRAME_EXCHANGE_SND_AX_MU_BFRP1 = 36,
+	FRAME_EXCHANGE_SND_AX_MU_BFRP2 = 37,
+	FRAME_EXCHANGE_SND_N_SU = 38
+};
+
+enum SND_F2P_TYPE {
+	SNDF2P_ONCE = 0,
+	SNDF2P_ADD = 1,
+	SNDF2P_DEL = 2
+};
+
+enum SND_NDPA_MODE {
+	SND_NDPA_NORM = 0,
+	SND_NDPA_PATCH_STA = 1
+};
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+/**
+ * @brief mac_get_csi_buffer_index
+ *
+ * @param *adapter
+ * @param band
+ * @param csi_buffer_id
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_csi_buffer_index(struct mac_ax_adapter *adapter, u8 band,
+			     u8 csi_buffer_id);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_set_csi_buffer_index
+ *
+ * @param *adapter
+ * @param band
+ * @param macid
+ * @param csi_buffer_id
+ * @param buffer_idx
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_csi_buffer_index(struct mac_ax_adapter *adapter, u8 band,
+			     u8 macid, u16 csi_buffer_id, u16 buffer_idx);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_get_snd_sts_index
+ *
+ * @param *adapter
+ * @param band
+ * @param index
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_get_snd_sts_index(struct mac_ax_adapter *adapter, u8 band, u8 index);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_set_snd_sts_index
+ *
+ * @param *adapter
+ * @param band
+ * @param macid
+ * @param index
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_snd_sts_index(struct mac_ax_adapter *adapter, u8 band, u8 macid,
+			  u8 index);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_init_snd_mer
+ *
+ * @param *adapter
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_init_snd_mer(struct mac_ax_adapter *adapter, u8 band);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_init_snd_mee
+ *
+ * @param *adapter
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_init_snd_mee(struct mac_ax_adapter *adapter, u8 band);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_csi_force_rate
+ *
+ * @param *adapter
+ * @param band
+ * @param ht_rate
+ * @param vht_rate
+ * @param he_rate
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_csi_force_rate(struct mac_ax_adapter *adapter, u8 band, u8 ht_rate,
+		       u8 vht_rate, u8 he_rate);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_csi_rrsc
+ *
+ * @param *adapter
+ * @param band
+ * @param rrsc
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_csi_rrsc(struct mac_ax_adapter *adapter, u8 band, u32 rrsc);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_set_mu_table
+ *
+ * @param *adapter
+ * @param *mu_table
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_mu_table(struct mac_ax_adapter *adapter,
+		     struct mac_mu_table *mu_table);
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_set_csi_para_reg
+ *
+ * @param *adapter
+ * @param *csi_para
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_csi_para_reg(struct mac_ax_adapter *adapter,
+			 struct mac_reg_csi_para *csi_para);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_set_csi_para_cctl
+ *
+ * @param *adapter
+ * @param *csi_para
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_csi_para_cctl(struct mac_ax_adapter *adapter,
+			  struct mac_cctl_csi_para *csi_para);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_hw_snd_pause_release
+ *
+ * @param *adapter
+ * @param band
+ * @param pr
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_hw_snd_pause_release(struct mac_ax_adapter *adapter, u8 band, u8 pr);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_bypass_snd_sts
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_bypass_snd_sts(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_deinit_mee
+ *
+ * @param *adapter
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_deinit_mee(struct mac_ax_adapter *adapter, u8 band);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_snd_sup
+ *
+ * @param *adapter
+ * @param *bf_sup
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_snd_sup(struct mac_ax_adapter *adapter, struct mac_bf_sup *bf_sup);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_gid_pos
+ *
+ * @param *adapter
+ * @param *mac_gid_pos
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_gidpos(struct mac_ax_adapter *adapter, struct mac_gid_pos *mu_gid);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup Sounding
+ * @{
+ */
+
+/**
+ * @brief mac_set_snd_para_v1
+ *
+ * @param *adapter
+ * @param *snd_info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_set_snd_para(struct mac_ax_adapter *adapter,
+		     struct mac_ax_fwcmd_snd *snd_info);
+/**
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/spatial_reuse.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/spatial_reuse.c
new file mode 100644
index 000000000000..687c716060e1
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/spatial_reuse.c
@@ -0,0 +1,84 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+#include "spatial_reuse.h"
+
+u32 mac_sr_update(struct mac_ax_adapter *adapter,
+		  struct mac_ax_sr_info *sr_info,
+		  enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val8;
+	u32 val32, ret, reg;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_RX_SR_CTRL_C1 : R_AX_RX_SR_CTRL;
+	val8 = MAC_REG_R8(reg);
+	val8 = (sr_info->sr_en) ? (val8 | B_AX_SR_EN) : (val8 & ~B_AX_SR_EN);
+	MAC_REG_W8(reg, val8);
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_TCR0_C1 : R_AX_TCR0;
+	val8 = MAC_REG_R8(reg);
+	val8 = (sr_info->sr_field_v15_allowed) ?
+		(val8 | B_AX_TCR_SR_VAL15_ALLOW) :
+		(val8 & ~B_AX_TCR_SR_VAL15_ALLOW);
+	MAC_REG_W8(reg, val8);
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_SR_OBSS_PD_C1 : R_AX_SR_OBSS_PD;
+	val32 = MAC_REG_R32(reg);
+	val32 = SET_CLR_WORD(val32, sr_info->non_srg_obss_pd_min,
+			     B_AX_NONSRG_OBSS_PD_MIN);
+	val32 = SET_CLR_WORD(val32, sr_info->non_srg_obss_pd_max,
+			     B_AX_NONSRG_OBSS_PD_MAX);
+	val32 = SET_CLR_WORD(val32, sr_info->srg_obss_pd_min,
+			     B_AX_SRG_OBSS_PD_MIN);
+	val32 = SET_CLR_WORD(val32, sr_info->srg_obss_pd_max,
+			     B_AX_SRG_OBSS_PD_MAX);
+	MAC_REG_W32(reg, val32);
+
+	reg = band == MAC_AX_BAND_1 ?
+	      R_AX_SR_BSSCOLOR_BITMAP_C1 : R_AX_SR_BSSCOLOR_BITMAP;
+	MAC_REG_W32(reg, sr_info->srg_bsscolor_bitmap_0);
+	MAC_REG_W32(reg + 4, sr_info->srg_bsscolor_bitmap_1);
+
+	reg = band == MAC_AX_BAND_1 ?
+	      R_AX_SR_PARTIAL_BSSCOLOR_BITMAP_C1 :
+	      R_AX_SR_PARTIAL_BSSCOLOR_BITMAP;
+	MAC_REG_W32(reg, sr_info->srg_partbsid_bitmap_0);
+	MAC_REG_W32(reg + 4, sr_info->srg_partbsid_bitmap_1);
+
+	return MACSUCCESS;
+}
+
+u32 spatial_reuse_init(struct mac_ax_adapter *adapter,
+		       enum mac_ax_band band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val8;
+	u32 ret, reg;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_RX_SR_CTRL_C1 : R_AX_RX_SR_CTRL;
+	val8 = MAC_REG_R8(reg) & ~B_AX_SR_EN;
+	MAC_REG_W8(reg, val8);
+
+	return MACSUCCESS;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/spatial_reuse.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/spatial_reuse.h
new file mode 100644
index 000000000000..79fe20906007
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/spatial_reuse.h
@@ -0,0 +1,29 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_SPATIAL_REUSE_H_
+#define _MAC_AX_SPATIAL_REUSE_H_
+
+#include "../type.h"
+
+u32 mac_sr_update(struct mac_ax_adapter *adapter,
+		  struct mac_ax_sr_info *sr_info,
+		  enum mac_ax_band band);
+
+u32 spatial_reuse_init(struct mac_ax_adapter *adapter,
+		       enum mac_ax_band band);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sta_sch.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sta_sch.c
new file mode 100644
index 000000000000..7a99e39f3f2a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sta_sch.c
@@ -0,0 +1,699 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "sta_sch.h"
+
+static u32 poll_own_chk(struct mac_ax_adapter *adapter, u32 addr)
+{
+	u32 cnt = 100;
+	u32 ck;
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (addr == R_AX_SS_SRAM_CTRL_1 || addr == R_AX_SS_LINK_INFO ||
+	    addr == R_AX_SS_SRAM_CTRL_0 || addr == R_AX_SS_LINK_ADD ||
+	    addr == R_AX_SS_LINK_DEL || addr == R_AX_SS_LINK_SEARCH)
+		ck = B_AX_SS_OWN;
+	else
+		ck = 0;
+
+	while (--cnt) {
+		val32 = MAC_REG_R32(addr);
+		if ((val32 & ck) == 0)
+			break;
+		PLTFM_DELAY_US(1);
+	}
+	if (!cnt) {
+		PLTFM_MSG_ERR("[STASCH]poll_own fail!!\n");
+		return MACPOLLTO;
+	}
+
+	if (addr == R_AX_SS_SRAM_CTRL_1 || addr == R_AX_SS_LINK_INFO ||
+	    addr == R_AX_SS_LINK_ADD || addr == R_AX_SS_LINK_DEL) {
+		val32 = MAC_REG_R32(addr);
+		if (val32 & (BIT(29) | BIT(30))) {
+			PLTFM_MSG_ERR("[STASCH]poll status fail!!\n");
+			return MACPROCERR;
+		}
+	}
+	return MACSUCCESS;
+}
+
+static u32 poll_own_val(struct mac_ax_adapter *adapter, u32 addr, u32 *r_val)
+{
+	u32 cnt = 100;
+	u32 ck;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (addr == R_AX_SS_SRAM_CTRL_1 || addr == R_AX_SS_LINK_INFO ||
+	    addr == R_AX_SS_SRAM_CTRL_0 || addr == R_AX_SS_LINK_ADD ||
+	    addr == R_AX_SS_LINK_DEL || addr == R_AX_SS_LINK_SEARCH)
+		ck = B_AX_SS_OWN;
+	else
+		ck = 0;
+
+	while (--cnt) {
+		*r_val = MAC_REG_R32(addr);
+		if ((*r_val & ck) == 0)
+			break;
+		PLTFM_DELAY_US(1);
+	}
+	if (!cnt) {
+		PLTFM_MSG_ERR("[STASCH]poll_own fail!!\n");
+		return MACPOLLTO;
+	}
+
+	if (addr == R_AX_SS_SRAM_CTRL_1 || addr == R_AX_SS_LINK_INFO ||
+	    addr == R_AX_SS_LINK_ADD || addr == R_AX_SS_LINK_DEL) {
+		if (*r_val & (BIT(29) | BIT(30))) {
+			PLTFM_MSG_ERR("[STASCH]poll status fail!!\n");
+			return MACPROCERR;
+		}
+	}
+	return MACSUCCESS;
+}
+
+static u32 sram1_ctrl_val(struct mac_ax_adapter *adapter, u32 cmd, u32 *r_val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	MAC_REG_W32(R_AX_SS_SRAM_CTRL_1, cmd);
+
+	return poll_own_val(adapter, R_AX_SS_SRAM_CTRL_1, r_val);
+}
+
+static u32 get_link_info(struct mac_ax_adapter *adapter, u32 cmd, u32 *r_val)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	MAC_REG_W32(R_AX_SS_LINK_INFO, cmd);
+
+	return poll_own_val(adapter, R_AX_SS_LINK_INFO, r_val);
+}
+
+static u32 add_to_link(struct mac_ax_adapter *adapter,
+		       struct mac_ax_ss_link_info *link)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	MAC_REG_W32(R_AX_SS_LINK_ADD, B_AX_SS_OWN |
+		    (link->ul ? B_AX_SS_UL : 0) |
+		    SET_WORD(link->wmm, B_AX_SS_WMM) |
+		    SET_WORD(link->ac, B_AX_SS_AC) |
+		    SET_WORD(link->macid2, B_AX_SS_MACID_2) |
+		    SET_WORD(link->macid1, B_AX_SS_MACID_1) |
+		    SET_WORD(link->macid0, B_AX_SS_MACID_0));
+	return poll_own_chk(adapter, R_AX_SS_LINK_ADD);
+}
+
+static u32 del_from_link(struct mac_ax_adapter *adapter,
+			 struct mac_ax_ss_link_info *link)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	MAC_REG_W32(R_AX_SS_LINK_DEL, B_AX_SS_OWN |
+		    (link->ul ? B_AX_SS_UL : 0) |
+		    SET_WORD(link->wmm, B_AX_SS_WMM) |
+		    SET_WORD(link->ac, B_AX_SS_AC) |
+		    SET_WORD(link->macid2, B_AX_SS_MACID_2) |
+		    SET_WORD(link->macid1, B_AX_SS_MACID_1) |
+		    SET_WORD(link->macid0, B_AX_SS_MACID_0));
+	return poll_own_chk(adapter, R_AX_SS_LINK_DEL);
+}
+
+static u32 clean_sta_link(struct mac_ax_adapter *adapter,
+			  struct mac_ax_ss_link_info *link)
+{
+	u32 val32;
+	u8 wmm, ac;
+	u32 cnt = adapter->hw_info->macid_num + 1;
+	u32 cmd;
+	u32 ret;
+
+	if (link->ul) {
+		wmm = 0;
+		ac = 0;
+	} else {
+		wmm = link->wmm;
+		ac = link->ac;
+	}
+
+	do {
+		cmd = B_AX_SS_OWN | (link->ul ? B_AX_SS_UL : 0) |
+		      SET_WORD(wmm, B_AX_SS_WMM) | SET_WORD(ac, B_AX_SS_AC);
+		ret = get_link_info(adapter, cmd, &val32);
+		if (ret != MACSUCCESS)
+			return ret;
+
+		link->link_head = GET_FIELD(val32, B_AX_SS_LINK_HEAD);
+		link->link_tail = GET_FIELD(val32, B_AX_SS_LINK_TAIL);
+		link->link_len = GET_FIELD(val32, B_AX_SS_LINK_LEN);
+		link->macid0 = link->link_head;
+
+		if (link->macid0 != 0xFF) {
+			ret = del_from_link(adapter, link);
+			if (ret != MACSUCCESS)
+				return ret;
+			cnt--;
+		} else {
+			break;
+		}
+	} while (link->link_len || cnt);
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[STASCH]link error!!\n");
+		return MACSSLINK;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 wmm_vld_chk(struct mac_ax_adapter *adapter, u8 *vld, u8 wmm)
+{
+	u8 wmm_num;
+
+	switch (adapter->hw_info->chip_id) {
+	case MAC_AX_CHIP_ID_8852A:
+		wmm_num = STA_SCH_WMM_NUM_8852A;
+		break;
+	case MAC_AX_CHIP_ID_8852B:
+		wmm_num = STA_SCH_WMM_NUM_8852B;
+		break;
+	case MAC_AX_CHIP_ID_8852C:
+		wmm_num = STA_SCH_WMM_NUM_8852C;
+		break;
+	case MAC_AX_CHIP_ID_8192XB:
+		wmm_num = STA_SCH_WMM_NUM_8192XB;
+		break;
+	case MAC_AX_CHIP_ID_8851B:
+		wmm_num = STA_SCH_WMM_NUM_8851B;
+		break;
+	case MAC_AX_CHIP_ID_8851E:
+		wmm_num = STA_SCH_WMM_NUM_8851E;
+		break;
+	case MAC_AX_CHIP_ID_8852D:
+		wmm_num = STA_SCH_WMM_NUM_8852D;
+		break;
+	default:
+		return MACCHIPID;
+	}
+
+	if (wmm < wmm_num)
+		*vld = 1;
+	else
+		*vld = 0;
+
+	return MACSUCCESS;
+}
+
+static u32 ul_vld_chk(struct mac_ax_adapter *adapter, u8 *vld)
+{
+	u8 ul_support;
+
+	switch (adapter->hw_info->chip_id) {
+	case MAC_AX_CHIP_ID_8852A:
+		ul_support = STA_SCH_UL_SUPPORT_8852A;
+		break;
+	case MAC_AX_CHIP_ID_8852B:
+		ul_support = STA_SCH_UL_SUPPORT_8852B;
+		break;
+	case MAC_AX_CHIP_ID_8852C:
+		ul_support = STA_SCH_UL_SUPPORT_8852C;
+		break;
+	case MAC_AX_CHIP_ID_8192XB:
+		ul_support = STA_SCH_UL_SUPPORT_8192XB;
+		break;
+	case MAC_AX_CHIP_ID_8851B:
+		ul_support = STA_SCH_UL_SUPPORT_8851B;
+		break;
+	case MAC_AX_CHIP_ID_8851E:
+		ul_support = STA_SCH_UL_SUPPORT_8851E;
+		break;
+	case MAC_AX_CHIP_ID_8852D:
+		ul_support = STA_SCH_UL_SUPPORT_8852D;
+		break;
+	default:
+		return MACCHIPID;
+	}
+
+	if (ul_support)
+		*vld = 1;
+	else
+		*vld = 0;
+
+	return MACSUCCESS;
+}
+
+static u32 get_sta_link(struct mac_ax_adapter *adapter,
+			struct mac_ax_ss_link_info *link)
+{
+	u32 val32, i;
+	u8 macid, wmm, ac;
+	u32 ret;
+	u32 cmd;
+	u16 id_empty = adapter->hw_info->sta_empty_flg;
+
+	if (link->ul) {
+		wmm = 0;
+		ac = 0;
+	} else {
+		wmm = link->wmm;
+		ac = link->ac;
+	}
+
+	cmd = B_AX_SS_OWN | (link->ul ? B_AX_SS_UL : 0) |
+	      SET_WORD(wmm, B_AX_SS_WMM) | SET_WORD(ac, B_AX_SS_AC);
+	ret = get_link_info(adapter, cmd, &val32);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	link->link_head = GET_FIELD(val32, B_AX_SS_LINK_HEAD);
+	link->link_tail = GET_FIELD(val32, B_AX_SS_LINK_TAIL);
+	link->link_len = GET_FIELD(val32, B_AX_SS_LINK_LEN);
+	macid = link->link_head;
+
+	if (link->link_head == id_empty) {
+		if (link->link_len) {
+			PLTFM_MSG_ERR("empty link_len error!!");
+			return MACSSLINK;
+		}
+	} else {
+		i = 0;
+		do {
+			link->link_list[i] = macid;
+			link->link_bitmap[macid] = 1;
+			cmd = B_AX_SS_OWN |
+			      SET_WORD(CTRL1_R_NEXT_LINK, B_AX_SS_CMD_SEL) |
+			      SET_WORD(ac, B_AX_SS_AC) |
+			      (link->ul ? BIT(23) : 0) | macid;
+			ret = sram1_ctrl_val(adapter, cmd, &val32);
+			if (ret != MACSUCCESS)
+				return ret;
+
+			macid = GET_FIELD(val32, B_AX_SS_VALUE);
+			if (macid == id_empty) {
+				if (link->link_list[i] != link->link_tail) {
+					PLTFM_MSG_ERR("[STASCH]link_tail error!!\n");
+					return MACSSLINK;
+				}
+				if (i >= link->link_len) {
+					PLTFM_MSG_ERR("[STASCH]link_len error!!\n");
+					return MACSSLINK;
+				}
+				break;
+			}
+			i++;
+		} while (i < SS_LINK_SIZE);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 sta_link_cfg(struct mac_ax_adapter *adapter,
+		 struct mac_ax_ss_link_info *link,
+		 enum mac_ax_ss_link_cfg cfg)
+{
+	u32 ret;
+	u8 vld;
+
+	if (link->ul) {
+		ret = ul_vld_chk(adapter, &vld);
+		if (ret != MACSUCCESS)
+			return ret;
+		if (vld == 0)
+			return MACSUCCESS;
+	}
+
+	ret = wmm_vld_chk(adapter, &vld, link->wmm);
+	if (ret != MACSUCCESS)
+		return ret;
+	if (vld == 0)
+		return MACSUCCESS;
+
+	switch (cfg) {
+	case MAC_AX_SS_LINK_CFG_GET:
+		ret = get_sta_link(adapter, link);
+		break;
+	case MAC_AX_SS_LINK_CFG_ADD:
+		ret = add_to_link(adapter, link);
+		break;
+	case MAC_AX_SS_LINK_CFG_DEL:
+		ret = del_from_link(adapter, link);
+		break;
+	case MAC_AX_SS_LINK_CFG_CLEAN:
+		ret = clean_sta_link(adapter, link);
+		break;
+	}
+
+	return ret;
+}
+
+void set_ss_wmm_tbl(struct mac_ax_adapter *adapter,
+		    struct mac_ax_ss_wmm_tbl_ctrl *ctrl)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_SS_CTRL);
+	switch (ctrl->wmm) {
+	case 0:
+		val32 = SET_CLR_WORD(val32, ctrl->wmm_mapping,
+				     B_AX_SS_WMM_SEL_0);
+		break;
+	case 1:
+		val32 = SET_CLR_WORD(val32, ctrl->wmm_mapping,
+				     B_AX_SS_WMM_SEL_1);
+		break;
+	case 2:
+		val32 = SET_CLR_WORD(val32, ctrl->wmm_mapping,
+				     B_AX_SS_WMM_SEL_2);
+		break;
+	case 3:
+		val32 = SET_CLR_WORD(val32, ctrl->wmm_mapping,
+				     B_AX_SS_WMM_SEL_3);
+		break;
+	default:
+		break;
+	}
+	MAC_REG_W32(R_AX_SS_CTRL, val32);
+}
+
+void ss_wmm_tbl_cfg(struct mac_ax_adapter *adapter,
+		    struct mac_ax_ss_wmm_tbl_ctrl *ctrl,
+		    enum mac_ax_ss_wmm_tbl_cfg cfg)
+{
+	set_ss_wmm_tbl(adapter, ctrl);
+}
+
+u32 switch_wmm_macid(struct mac_ax_adapter *adapter,
+		     struct mac_ax_ss_link_info *link,
+		     enum mac_ax_ss_wmm_tbl src_link,
+		     enum mac_ax_ss_wmm_tbl dst_link)
+{
+	u32 ret;
+
+	link->wmm = src_link;
+	ret = sta_link_cfg(adapter, link, MAC_AX_SS_LINK_CFG_DEL);
+	if (ret != MACSUCCESS)
+		return ret;
+	link->wmm = dst_link;
+	ret = sta_link_cfg(adapter, link, MAC_AX_SS_LINK_CFG_ADD);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+static u32 chk_role_wmm(struct mac_ax_adapter *adapter, u8 *pmacid, u8 src_wmm)
+{
+	struct mac_role_tbl *role;
+	u8 wmm;
+
+	role = role_srch_no_lock(adapter, *pmacid);
+	if (!role)
+		return MACNOITEM;
+
+	wmm = role->info.dbcc_role ?
+	      *(adapter->dbcc_info->dbcc_wmm_list + *pmacid) : role->wmm;
+
+	if (wmm != src_wmm)
+		*pmacid = 0xFF;
+
+	return MACSUCCESS;
+}
+
+static u32 switch_wmm_link(struct mac_ax_adapter *adapter,
+			   enum mac_ax_ss_wmm_tbl src_link,
+			   enum mac_ax_ss_wmm_tbl dst_link,
+			   enum mac_ax_ss_wmm src_wmm)
+{
+	struct mac_ax_ss_link_info link;
+	u32 ret;
+	u32 i;
+
+	link.ul = 0;
+	for (link.ac = 0; link.ac < 4; link.ac++) {
+		PLTFM_MEMSET(link.link_list, 0xFF, SS_LINK_SIZE);
+		link.wmm = src_link;
+		ret = sta_link_cfg(adapter, &link, MAC_AX_SS_LINK_CFG_GET);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("sta_link_cfg %d\n", ret);
+			return ret;
+		}
+		for (i = 0; i < link.link_len; i += 3) {
+			link.macid0 = link.link_list[i];
+			link.macid1 = link.link_list[i + 1];
+			link.macid2 = link.link_list[i + 2];
+			if (link.macid0 != 0xFF) {
+				ret = chk_role_wmm(adapter, &link.macid0, src_wmm);
+				if (ret != MACSUCCESS)
+					return ret;
+			}
+			if (link.macid1 != 0xFF) {
+				ret = chk_role_wmm(adapter, &link.macid1, src_wmm);
+				if (ret != MACSUCCESS)
+					return ret;
+			}
+			if (link.macid2 != 0xFF) {
+				ret = chk_role_wmm(adapter, &link.macid2, src_wmm);
+				if (ret != MACSUCCESS)
+					return ret;
+			}
+			if (link.macid0 != 0xFF || link.macid1 != 0xFF ||
+			    link.macid2 != 0xFF) {
+				ret = switch_wmm_macid(adapter, &link, src_link,
+						       dst_link);
+				if (ret != MACSUCCESS)
+					return ret;
+			}
+		}
+	}
+	return MACSUCCESS;
+}
+
+u32 mac_ss_wmm_sta_move(struct mac_ax_adapter *adapter,
+			enum mac_ax_ss_wmm src_wmm,
+			enum mac_ax_ss_wmm_tbl dst_link)
+{
+	struct mac_ax_ss_wmm_tbl_ctrl ctrl;
+	u32 ret;
+
+	switch (src_wmm) {
+	case MAC_AX_SS_WMM0:
+		ctrl.wmm = 0;
+		break;
+	case MAC_AX_SS_WMM1:
+		ctrl.wmm = 1;
+		break;
+	case MAC_AX_SS_WMM2:
+		ctrl.wmm = 2;
+		break;
+	case MAC_AX_SS_WMM3:
+		ctrl.wmm = 3;
+		break;
+	default:
+		return MACFUNCINPUT;
+	}
+	ret = get_ss_wmm_tbl(adapter, &ctrl);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("get_ss_wmm_tbl %d\n", ret);
+		return ret;
+	}
+
+	if (ctrl.wmm_mapping == dst_link)
+		return MACARDYDONE;
+
+	ret = switch_wmm_link(adapter, ctrl.wmm_mapping, dst_link, src_wmm);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("switch_wmm_link %d\n", ret);
+		return ret;
+	}
+
+	ctrl.wmm_mapping = dst_link;
+	ss_wmm_tbl_cfg(adapter, &ctrl, MAC_AX_SS_WMM_TBL_SET);
+
+	return MACSUCCESS;
+}
+
+u32 mac_ss_wmm_map_upd(struct mac_ax_adapter *adapter,
+		       enum mac_ax_ss_wmm src_wmm,
+		       enum mac_ax_ss_wmm_tbl dst_link,
+		       u8 chk_emp)
+{
+	struct mac_ax_ss_wmm_tbl_ctrl ctrl;
+	struct mac_ax_ss_link_info link;
+	u32 ret;
+
+	switch (src_wmm) {
+	case MAC_AX_SS_WMM0:
+		ctrl.wmm = 0;
+		break;
+	case MAC_AX_SS_WMM1:
+		ctrl.wmm = 1;
+		break;
+	case MAC_AX_SS_WMM2:
+		ctrl.wmm = 2;
+		break;
+	case MAC_AX_SS_WMM3:
+		ctrl.wmm = 3;
+		break;
+	default:
+		return MACFUNCINPUT;
+	}
+	ret = get_ss_wmm_tbl(adapter, &ctrl);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("get_ss_wmm_tbl %d\n", ret);
+		return ret;
+	}
+
+	if (ctrl.wmm_mapping == dst_link)
+		return MACSUCCESS;
+
+	link.ul = 0;
+	for (link.ac = 0; link.ac < 4; link.ac++) {
+		if (!chk_emp)
+			break;
+		PLTFM_MEMSET(link.link_list, 0xFF, SS_LINK_SIZE);
+		link.wmm = ctrl.wmm_mapping;
+		ret = sta_link_cfg(adapter, &link, MAC_AX_SS_LINK_CFG_GET);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("sta_link_cfg %d\n", ret);
+			return ret;
+		}
+		if (link.link_len) {
+			PLTFM_MSG_ERR("wmm%d link%d non empty %d\n",
+				      link.wmm, link.ac, link.link_len);
+			return MACCMP;
+		}
+	}
+
+	ctrl.wmm_mapping = dst_link;
+	ss_wmm_tbl_cfg(adapter, &ctrl, MAC_AX_SS_WMM_TBL_SET);
+
+	return MACSUCCESS;
+}
+
+static void get_dl_su_rpt(struct mac_ax_adapter *adapter,
+			  struct mac_ax_ss_dl_rpt_info *info)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_SS_DL_RPT_CRTL);
+	info->wmm0_max = GET_FIELD(val32, B_AX_SS_MAX_SU_NUM_0);
+	info->wmm1_max = GET_FIELD(val32, B_AX_SS_MAX_SU_NUM_1);
+	info->twt_wmm0_max = GET_FIELD(val32, B_AX_SS_TWT_MAX_SU_NUM_0);
+	info->twt_wmm1_max = GET_FIELD(val32, B_AX_SS_TWT_MAX_SU_NUM_1);
+}
+
+static void set_dl_su_rpt(struct mac_ax_adapter *adapter,
+			  struct mac_ax_ss_dl_rpt_info *info)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_SS_DL_RPT_CRTL);
+	val32 = SET_CLR_WORD(val32, info->wmm0_max, B_AX_SS_MAX_SU_NUM_0);
+	val32 = SET_CLR_WORD(val32, info->wmm1_max, B_AX_SS_MAX_SU_NUM_1);
+	val32 =	SET_CLR_WORD(val32, info->twt_wmm0_max,
+			     B_AX_SS_TWT_MAX_SU_NUM_0);
+	val32 =	SET_CLR_WORD(val32, info->twt_wmm1_max,
+			     B_AX_SS_TWT_MAX_SU_NUM_1);
+	MAC_REG_W32(R_AX_SS_DL_RPT_CRTL, val32);
+}
+
+static void get_dl_mu_rpt(struct mac_ax_adapter *adapter,
+			  struct mac_ax_ss_dl_rpt_info *info)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_SS_DL_MU_RPT_CRTL);
+	info->wmm0_max = GET_FIELD(val32, B_AX_SS_MAX_MU_NUM_0);
+	info->wmm1_max = GET_FIELD(val32, B_AX_SS_MAX_MU_NUM_1);
+	info->twt_wmm0_max = GET_FIELD(val32, B_AX_SS_TWT_MAX_MU_NUM_0);
+	info->twt_wmm1_max = GET_FIELD(val32, B_AX_SS_TWT_MAX_MU_NUM_1);
+}
+
+static void set_dl_mu_rpt(struct mac_ax_adapter *adapter,
+			  struct mac_ax_ss_dl_rpt_info *info)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_SS_DL_MU_RPT_CRTL);
+	val32 = SET_CLR_WORD(val32, info->wmm0_max, B_AX_SS_MAX_MU_NUM_0);
+	val32 = SET_CLR_WORD(val32, info->wmm1_max, B_AX_SS_MAX_MU_NUM_1);
+	val32 =	SET_CLR_WORD(val32, info->twt_wmm0_max,
+			     B_AX_SS_TWT_MAX_MU_NUM_0);
+	val32 =	SET_CLR_WORD(val32, info->twt_wmm1_max,
+			     B_AX_SS_TWT_MAX_MU_NUM_1);
+	MAC_REG_W32(R_AX_SS_DL_MU_RPT_CRTL, val32);
+}
+
+static void get_dl_ru_rpt(struct mac_ax_adapter *adapter,
+			  struct mac_ax_ss_dl_rpt_info *info)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_SS_DL_RU_RPT_CRTL);
+	info->wmm0_max = GET_FIELD(val32, B_AX_SS_MAX_RU_NUM_0);
+	info->wmm1_max = GET_FIELD(val32, B_AX_SS_MAX_RU_NUM_1);
+	info->twt_wmm0_max = GET_FIELD(val32, B_AX_SS_TWT_MAX_RU_NUM_0);
+	info->twt_wmm1_max = GET_FIELD(val32, B_AX_SS_TWT_MAX_RU_NUM_1);
+}
+
+static void set_dl_ru_rpt(struct mac_ax_adapter *adapter,
+			  struct mac_ax_ss_dl_rpt_info *info)
+{
+	u32 val32;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	val32 = MAC_REG_R32(R_AX_SS_DL_RU_RPT_CRTL);
+	val32 = SET_CLR_WORD(val32, info->wmm0_max, B_AX_SS_MAX_RU_NUM_0);
+	val32 = SET_CLR_WORD(val32, info->wmm1_max, B_AX_SS_MAX_RU_NUM_1);
+	val32 =	SET_CLR_WORD(val32, info->twt_wmm0_max,
+			     B_AX_SS_TWT_MAX_RU_NUM_0);
+	val32 =	SET_CLR_WORD(val32, info->twt_wmm1_max,
+			     B_AX_SS_TWT_MAX_RU_NUM_1);
+	MAC_REG_W32(R_AX_SS_DL_RU_RPT_CRTL, val32);
+}
+
+void mac_ss_dl_rpt_cfg(struct mac_ax_adapter *adapter,
+		       struct mac_ax_ss_dl_rpt_info *info,
+		       enum mac_ax_ss_rpt_cfg cfg)
+{
+	switch (cfg) {
+	case MAC_AX_SS_DL_SU_RPT_CFG_GET:
+		get_dl_su_rpt(adapter, info);
+		break;
+	case MAC_AX_SS_DL_SU_RPT_CFG_SET:
+		set_dl_su_rpt(adapter, info);
+		break;
+	case MAC_AX_SS_DL_MU_RPT_CFG_GET:
+		get_dl_mu_rpt(adapter, info);
+		break;
+	case MAC_AX_SS_DL_MU_RPT_CFG_SET:
+		set_dl_mu_rpt(adapter, info);
+		break;
+	case MAC_AX_SS_DL_RU_RPT_CFG_GET:
+		get_dl_ru_rpt(adapter, info);
+		break;
+	case MAC_AX_SS_DL_RU_RPT_CFG_SET:
+		set_dl_ru_rpt(adapter, info);
+		break;
+	}
+}
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sta_sch.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sta_sch.h
new file mode 100644
index 000000000000..d85b2e72f8eb
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/sta_sch.h
@@ -0,0 +1,137 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_STA_SCH_H_
+#define _MAC_AX_STA_SCH_H_
+
+#include "../type.h"
+
+/*--------------------Define -------------------------------------------*/
+#define STA_SCH_WMM_NUM_8852A 4
+#define STA_SCH_WMM_NUM_8852B 2
+#define STA_SCH_WMM_NUM_8852C 4
+#define STA_SCH_WMM_NUM_8192XB  4
+#define STA_SCH_WMM_NUM_8851B 2
+#define STA_SCH_WMM_NUM_8851E 4
+#define STA_SCH_WMM_NUM_8852D 4
+
+#define STA_SCH_UL_SUPPORT_8852A 1
+#define STA_SCH_UL_SUPPORT_8852B 0
+#define STA_SCH_UL_SUPPORT_8852C 1
+#define STA_SCH_UL_SUPPORT_8192XB 1
+#define STA_SCH_UL_SUPPORT_8851B 0
+#define STA_SCH_UL_SUPPORT_8851E 1
+#define STA_SCH_UL_SUPPORT_8852D 1
+
+#define CTRL1_R_NEXT_LINK 20
+
+/*--------------------Define MACRO--------------------------------------*/
+/*--------------------Define Enum---------------------------------------*/
+
+/**
+ * @enum mac_ax_ss_link_cfg
+ *
+ * @brief mac_ax_ss_link_cfg
+ *
+ * @var mac_ax_ss_link_cfg::mac_AX_SS_LINK_CFG_GET
+ * Please Place Description here.
+ * @var mac_ax_ss_link_cfg::mac_AX_SS_LINK_CFG_ADD
+ * Please Place Description here.
+ * @var mac_ax_ss_link_cfg::mac_AX_SS_LINK_CFG_DEL
+ * Please Place Description here.
+ * @var mac_ax_ss_link_cfg::mac_AX_SS_LINK_CFG_CLEAN
+ * Please Place Description here.
+ */
+enum mac_ax_ss_link_cfg {
+	MAC_AX_SS_LINK_CFG_GET,
+	MAC_AX_SS_LINK_CFG_ADD,
+	MAC_AX_SS_LINK_CFG_DEL,
+	MAC_AX_SS_LINK_CFG_CLEAN,
+};
+
+/**
+ * @enum mac_ax_ss_wmm_tbl_cfg
+ *
+ * @brief mac_ax_ss_wmm_tbl_cfg
+ *
+ * @var mac_ax_ss_wmm_tbl_cfg::mac_AX_SS_WMM_TBL_SET
+ * Please Place Description here.
+ */
+enum mac_ax_ss_wmm_tbl_cfg {
+	MAC_AX_SS_WMM_TBL_SET,
+};
+
+/*--------------------Define Struct-------------------------------------*/
+
+/**
+ * @struct mac_ax_sta_bmp_ctrl
+ * @brief mac_ax_sta_bmp_ctrl
+ *
+ * @var mac_ax_sta_bmp_ctrl::macid
+ * Please Place Description here.
+ * @var mac_ax_sta_bmp_ctrl::bmp
+ * Please Place Description here.
+ * @var mac_ax_sta_bmp_ctrl::mask
+ * Please Place Description here.
+ */
+struct mac_ax_sta_bmp_ctrl {
+	u8 macid;
+	u32 bmp;
+	u32 mask;
+};
+
+/*--------------------Function Prototype--------------------------------*/
+
+/**
+ * @brief mac_ss_wmm_sta_move
+ *
+ * @param *adapter
+ * @param src_wmm
+ * @param dst_link
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_ss_wmm_sta_move(struct mac_ax_adapter *adapter,
+			enum mac_ax_ss_wmm src_wmm,
+			enum mac_ax_ss_wmm_tbl dst_link);
+
+/**
+ * @brief mac_ss_wmm_map_upd
+ *
+ * @param *adapter
+ * @param src_wmm
+ * @param dst_link
+ * @param chk_emp
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_ss_wmm_map_upd(struct mac_ax_adapter *adapter,
+		       enum mac_ax_ss_wmm src_wmm,
+		       enum mac_ax_ss_wmm_tbl dst_link,
+		       u8 chk_emp);
+/**
+ * @brief mac_ss_dl_rpt_cfg
+ *
+ * @param *adapter
+ * @param *info
+ * @param cfg
+ * @return Please Place Description here.
+ * @retval void
+ */
+void mac_ss_dl_rpt_cfg(struct mac_ax_adapter *adapter,
+		       struct mac_ax_ss_dl_rpt_info *info,
+		       enum mac_ax_ss_rpt_cfg cfg);
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/state_mach.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/state_mach.h
new file mode 100644
index 000000000000..0dd6f61b457d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/state_mach.h
@@ -0,0 +1,249 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_STATE_MACH_H_
+#define _MAC_AX_STATE_MACH_H_
+
+/**
+ * @struct mac_ax_state_mach
+ * @brief mac_ax_state_mach
+ *
+ * @var mac_ax_state_mach::pwr
+ * Please Place Description here.
+ * @var mac_ax_state_mach::fwdl
+ * Please Place Description here.
+ * @var mac_ax_state_mach::efuse
+ * Please Place Description here.
+ * @var mac_ax_state_mach::read_request
+ * Please Place Description here.
+ * @var mac_ax_state_mach::write_request
+ * Please Place Description here.
+ * @var mac_ax_state_mach::conf_request
+ * Please Place Description here.
+ * @var mac_ax_state_mach::write_h2c
+ * Please Place Description here.
+ * @var mac_ax_state_mach::conf_h2c
+ * Please Place Description here.
+ * @var mac_ax_state_mach::read_h2c
+ * Please Place Description here.
+ * @var mac_ax_state_mach::pkt_ofld
+ * Please Place Description here.
+ * @var mac_ax_state_mach::efuse_ofld
+ * Please Place Description here.
+ * @var mac_ax_state_mach::macid_pause
+ * Please Place Description here.
+ * @var mac_ax_state_mach::mcc_group
+ * Please Place Description here.
+ * @var mac_ax_state_mach::mcc_request
+ * Please Place Description here.
+ * @var mac_ax_state_mach::fw_rst
+ * Please Place Description here.
+ * @var mac_ax_state_mach::aoac_rpt
+ * Please Place Description here.
+ */
+
+/**
+ * @struct mac_ax_state_mach
+ * @brief mac_ax_state_mach
+ *
+ * @var mac_ax_state_mach::pwr
+ * Please Place Description here.
+ * @var mac_ax_state_mach::fwdl
+ * Please Place Description here.
+ * @var mac_ax_state_mach::efuse
+ * Please Place Description here.
+ * @var mac_ax_state_mach::read_request
+ * Please Place Description here.
+ * @var mac_ax_state_mach::write_request
+ * Please Place Description here.
+ * @var mac_ax_state_mach::conf_request
+ * Please Place Description here.
+ * @var mac_ax_state_mach::write_h2c
+ * Please Place Description here.
+ * @var mac_ax_state_mach::conf_h2c
+ * Please Place Description here.
+ * @var mac_ax_state_mach::read_h2c
+ * Please Place Description here.
+ * @var mac_ax_state_mach::pkt_ofld
+ * Please Place Description here.
+ * @var mac_ax_state_mach::efuse_ofld
+ * Please Place Description here.
+ * @var mac_ax_state_mach::macid_pause
+ * Please Place Description here.
+ * @var mac_ax_state_mach::mcc_group
+ * Please Place Description here.
+ * @var mac_ax_state_mach::mcc_request
+ * Please Place Description here.
+ * @var mac_ax_state_mach::fw_rst
+ * Please Place Description here.
+ * @var mac_ax_state_mach::aoac_rpt
+ * Please Place Description here.
+ * @var mac_ax_state_mach::p2p_stat
+ * Please Place Description here.
+ * @var mac_ax_state_mach::nan_stat
+ * Please Place Description here.
+ */
+struct mac_ax_state_mach {
+#define MAC_AX_PWR_OFF 0
+#define MAC_AX_PWR_ON 1
+#define MAC_AX_PWR_PRE_OFF 2
+#define MAC_AX_PWR_ERR 3
+	u8 pwr;
+#define MAC_AX_FWDL_IDLE 0
+#define MAC_AX_FWDL_CPU_ON 1
+#define MAC_AX_FWDL_H2C_PATH_RDY 2
+#define MAC_AX_FWDL_PATH_RDY 3
+#define MAC_AX_FWDL_INIT_RDY 4
+	u8 fwdl;
+#define MAC_AX_EFUSE_IDLE 0
+#define MAC_AX_EFUSE_PHY 1
+#define MAC_AX_EFUSE_LOG_MAP 2
+#define MAC_AX_EFUSE_LOG_MASK 3
+#define MAC_AX_EFUSE_MAX 4
+	u8 efuse;
+#define MAC_AX_OFLD_REQ_IDLE 0
+#define MAC_AX_OFLD_REQ_H2C_SENT 1
+#define MAC_AX_OFLD_REQ_CREATED 2
+#define MAC_AX_OFLD_REQ_CLEANED 3
+	u8 read_request;
+	u8 write_request;
+	u8 conf_request;
+#define MAC_AX_CMD_OFLD_IDLE 0
+#define MAC_AX_CMD_OFLD_PROC 1
+#define MAC_AX_CMD_OFLD_SENDING 2
+#define MAC_AX_CMD_OFLD_RCVD 3
+	u8 cmd_state;
+#define MAC_AX_OFLD_H2C_IDLE 0
+#define MAC_AX_OFLD_H2C_SENDING 1
+#define MAC_AX_OFLD_H2C_RCVD 2
+#define MAC_AX_OFLD_H2C_ERROR 4
+	u8 write_h2c;
+	u8 conf_h2c;
+#define MAC_AX_OFLD_H2C_DONE 3
+	u8 read_h2c;
+	u8 pkt_ofld;
+	u8 efuse_ofld;
+	u8 macid_pause;
+	u8 disable_rf;
+	u8 sch_tx_en_ofld;
+	u8 macid_pause_sleep;
+#define MAC_AX_MCC_EMPTY 0
+#define MAC_AX_MCC_STATE_H2C_SENT 1
+#define MAC_AX_MCC_STATE_H2C_RCVD 2
+#define MAC_AX_MCC_ADD_DONE 3
+#define MAC_AX_MCC_START_DONE 4
+#define MAC_AX_MCC_STOP_DONE 5
+#define MAC_AX_MCC_STATE_ERROR 6
+	u8 mcc_group[4];
+	u8 mcc_group_state[4];
+#define MAC_AX_MCC_REQ_IDLE 0
+#define MAC_AX_MCC_REQ_H2C_SENT 1
+#define MAC_AX_MCC_REQ_H2C_RCVD 2
+#define MAC_AX_MCC_REQ_DONE 3
+#define MAC_AX_MCC_REQ_FAIL 4
+	u8 mcc_request[4];
+	u8 mcc_request_state[4];
+#define MAC_AX_FW_RESET_IDLE 0
+#define MAC_AX_FW_RESET_RECV 1
+#define MAC_AX_FW_RESET_RECV_DONE 2
+#define MAC_AX_FW_RESET_PROCESS 3
+	u8 fw_rst;
+#define MAC_AX_AOAC_RPT_IDLE 0
+#define MAC_AX_AOAC_RPT_H2C_SENDING 1
+#define MAC_AX_AOAC_RPT_H2C_RCVD 2
+#define MAC_AX_AOAC_RPT_H2C_DONE 3
+#define MAC_AX_AOAC_RPT_ERROR 4
+	u8 aoac_rpt;
+#define MAC_AX_P2P_ACT_IDLE 0
+#define MAC_AX_P2P_ACT_BUSY 1
+#define MAC_AX_P2P_ACT_FAIL 2
+	u8 p2p_stat;
+#define MAC_AX_FUNC_OFF 0
+#define MAC_AX_FUNC_ON 1
+	u8 dmac_func;
+	u8 cmac0_func;
+	u8 cmac1_func;
+	u8 bb0_func;
+	u8 bb1_func;
+#define MAC_AX_WOW_STOPTRX_IDLE 0
+#define MAC_AX_WOW_STOPTRX_BUSY 1
+#define MAC_AX_WOW_STOPTRX_FAIL 2
+	u8 wow_stoptrx_stat;
+#define MAC_AX_MAC_NOT_RDY 0
+#define MAC_AX_MAC_RDY 1
+#define MAC_AX_MAC_INIT_ERR 2
+#define MAC_AX_MAC_DEINIT_ERR 3
+#define MAC_AX_MAC_FINIT_ERR 4
+#define MAC_AX_MAC_FDEINIT_ERR 5
+	u8 mac_rdy;
+#define MAC_AX_ROLE_ALOC_SUCC 0
+#define MAC_AX_ROLE_INIT_SUCC 1
+#define MAC_AX_ROLE_HW_UPD_SUCC 2
+#define MAC_AX_ROLE_ALOC_FAIL 3
+#define MAC_AX_ROLE_INIT_FAIL 4
+#define MAC_AX_ROLE_HW_UPD_FAIL 5
+	u8 role_stat;
+#define MAC_AX_PLAT_OFF 0
+#define MAC_AX_PLAT_ON 1
+	u8 plat;
+#define MAC_AX_IO_ST_NORM 0
+#define MAC_AX_IO_ST_HANG 1
+	u8 io_st;
+#define MAC_AX_L2_DIS 0
+#define MAC_AX_L2_EN 1
+#define MAC_AX_L2_TRIG 2
+	u8 l2_st;
+#define MAC_AX_SER_CTRL_SRT 0
+#define MAC_AX_SER_CTRL_STOP 1
+#define MAC_AX_SER_CTRL_ERR 2
+	u8 ser_ctrl_st;
+#define MAC_AX_CH_SWITCH_GET_RPT 4
+	u8 ch_switch;
+#define MAC_AX_PROXY_IDLE 0
+#define MAC_AX_PROXY_SENDING 1
+#define MAC_AX_PROXY_BUSY 2
+	u8 proxy_st;
+	u8 proxy_ret;
+	u8 sensing_csi_st;
+#define MAC_AX_SENSING_CSI_IDLE 0
+#define MAC_AX_SENSING_CSI_SENDING 1
+#define MAC_AX_NAN_IDLE 0
+#define MAX_AX_NAN_ACT_H2C_FAIL 1
+#define MAX_AX_NAN_ACT_H2C_DONE 2
+	u8 nan_stat;
+#define MAC_AX_STA_CSA_IDLE 0
+#define MAC_AX_STA_CSA_SENDING 1
+#define MAC_AX_STA_CSA_BUSY 2
+	u8 sta_csa_st;
+	u8 sta_csa_ret;
+};
+
+#define MAC_AX_DFLT_SM \
+	{MAC_AX_PWR_OFF, MAC_AX_FWDL_IDLE, MAC_AX_EFUSE_IDLE, \
+	MAC_AX_OFLD_REQ_IDLE, MAC_AX_OFLD_REQ_IDLE, MAC_AX_OFLD_REQ_IDLE, \
+	MAC_AX_CMD_OFLD_IDLE, MAC_AX_OFLD_H2C_IDLE, MAC_AX_OFLD_H2C_IDLE, \
+	MAC_AX_OFLD_H2C_IDLE, MAC_AX_OFLD_H2C_IDLE, MAC_AX_OFLD_H2C_IDLE, \
+	MAC_AX_OFLD_H2C_IDLE, MAC_AX_OFLD_H2C_IDLE, MAC_AX_OFLD_H2C_IDLE, \
+	MAC_AX_OFLD_H2C_IDLE, \
+	{MAC_AX_MCC_EMPTY}, {MAC_AX_MCC_EMPTY}, {MAC_AX_MCC_REQ_IDLE}, \
+	{MAC_AX_MCC_REQ_IDLE}, MAC_AX_FW_RESET_IDLE, MAC_AX_AOAC_RPT_IDLE, \
+	MAC_AX_P2P_ACT_IDLE, MAC_AX_FUNC_OFF, MAC_AX_FUNC_OFF, \
+	MAC_AX_FUNC_OFF, MAC_AX_FUNC_OFF, MAC_AX_FUNC_OFF, \
+	MAC_AX_WOW_STOPTRX_IDLE, MAC_AX_MAC_NOT_RDY, MAC_AX_ROLE_ALOC_SUCC, \
+	MAC_AX_PLAT_OFF, MAC_AX_IO_ST_NORM, MAC_AX_L2_EN, MAC_AX_SER_CTRL_SRT,\
+	MAC_AX_OFLD_H2C_IDLE, MAC_AX_PROXY_IDLE, MAC_AX_PROXY_IDLE, MAC_AX_SENSING_CSI_IDLE,\
+	MAC_AX_NAN_IDLE, MAC_AX_STA_CSA_IDLE, MAC_AX_STA_CSA_IDLE}
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/status.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/status.c
new file mode 100644
index 000000000000..b3024d2b28e0
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/status.c
@@ -0,0 +1,149 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "status.h"
+
+u32 mac_get_ft_status(struct mac_ax_adapter *adapter,
+		      enum mac_ax_feature mac_ft, enum mac_ax_status *stat,
+		      u8 *buf, const u32 size, u32 *ret_size)
+
+{
+	struct mac_ax_ft_status *ft_stat;
+
+	ft_stat = mac_get_ft(adapter, mac_ft);
+
+	if (!ft_stat)
+		return MACNOITEM;
+
+	if (!buf)
+		return MACNPTR;
+
+	*stat = ft_stat->status;
+	if (ft_stat->size) {
+		if (size < ft_stat->size)
+			return MACNOBUF;
+		PLTFM_MEMCMP(buf, ft_stat->buf, ft_stat->size);
+		*ret_size = ft_stat->size;
+	}
+
+	return MACSUCCESS;
+}
+
+struct mac_ax_ft_status *mac_get_ft(struct mac_ax_adapter *adapter,
+				    enum mac_ax_feature mac_ft)
+{
+	struct mac_ax_ft_status *ft_stat = adapter->ft_stat;
+
+	for (; ft_stat->mac_ft != MAC_AX_FT_MAX; ft_stat++) {
+		if (ft_stat->mac_ft == mac_ft)
+			return ft_stat;
+	}
+
+	PLTFM_MSG_ERR("The mac feature is not supported\n");
+
+	return NULL;
+}
+
+u32 set_hw_ch_busy_cnt(struct mac_ax_adapter *adapter,
+		       struct mac_ax_ch_busy_cnt_cfg *cfg)
+{
+	u8 band;
+	u32 ret;
+	u32 reg_addr;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	band = cfg->band;
+	reg_addr = (band ? R_AX_PTCL_ATM_C1 : R_AX_PTCL_ATM);
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	switch (cfg->cnt_ctrl) {
+	case MAC_AX_CH_BUSY_CNT_CTRL_CNT_EN:
+		MAC_REG_W32(reg_addr,
+			    MAC_REG_R32(reg_addr) | B_AX_CHNL_INFO_EN);
+		break;
+	case MAC_AX_CH_BUSY_CNT_CTRL_CNT_DIS:
+		MAC_REG_W32(reg_addr,
+			    MAC_REG_R32(reg_addr) & ~B_AX_CHNL_INFO_EN);
+		break;
+	case MAC_AX_CH_BUSY_CNT_CTRL_CNT_BUSY_RST:
+		val32 = MAC_REG_R32(reg_addr);
+		MAC_REG_W32(reg_addr, val32 | B_AX_RST_CHNL_BUSY);
+		MAC_REG_W32(reg_addr, val32 & ~B_AX_RST_CHNL_BUSY);
+		break;
+	case MAC_AX_CH_BUSY_CNT_CTRL_CNT_IDLE_RST:
+		val32 = MAC_REG_R32(reg_addr);
+		MAC_REG_W32(reg_addr, val32 | B_AX_RST_CHNL_IDLE);
+		MAC_REG_W32(reg_addr, val32 & ~B_AX_RST_CHNL_IDLE);
+		break;
+	case MAC_AX_CH_BUSY_CNT_CTRL_CNT_RST:
+		val32 = MAC_REG_R32(reg_addr);
+		MAC_REG_W32(reg_addr, val32 |
+			    (B_AX_RST_CHNL_IDLE | B_AX_RST_CHNL_BUSY));
+		MAC_REG_W32(reg_addr, val32 &
+			    ~(B_AX_RST_CHNL_IDLE | B_AX_RST_CHNL_BUSY));
+		break;
+	case MAC_AX_CH_BUSY_CNT_CTRL_CNT_REF:
+		val32 = MAC_REG_R32(reg_addr) &
+			~(B_AX_CHNL_REF_RX_BASIC_NAV |
+			  B_AX_CHNL_REF_RX_INTRA_NAV |
+			  B_AX_CHNL_REF_DATA_ON |
+			  B_AX_CHNL_REF_EDCCA_P20 |
+			  B_AX_CHNL_REF_CCA_P20 |
+			  B_AX_CHNL_REF_CCA_S20 |
+			  B_AX_CHNL_REF_CCA_S40 |
+			  B_AX_CHNL_REF_CCA_S80 |
+			  B_AX_CHNL_REF_PHY_TXON);
+		val32 |= (cfg->ref.basic_nav ? B_AX_CHNL_REF_RX_BASIC_NAV : 0) |
+			(cfg->ref.intra_nav ? B_AX_CHNL_REF_RX_INTRA_NAV : 0) |
+			(cfg->ref.data_on ? B_AX_CHNL_REF_DATA_ON : 0) |
+			(cfg->ref.edcca_p20 ? B_AX_CHNL_REF_EDCCA_P20 : 0) |
+			(cfg->ref.cca_p20 ? B_AX_CHNL_REF_CCA_P20 : 0) |
+			(cfg->ref.cca_s20 ? B_AX_CHNL_REF_CCA_S20 : 0) |
+			(cfg->ref.cca_s40 ? B_AX_CHNL_REF_CCA_S40 : 0) |
+			(cfg->ref.cca_s80 ? B_AX_CHNL_REF_CCA_S80 : 0) |
+			(cfg->ref.phy_txon ? B_AX_CHNL_REF_PHY_TXON : 0);
+		MAC_REG_W32(reg_addr, val32);
+		break;
+	default:
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 get_hw_ch_stat_cnt(struct mac_ax_adapter *adapter,
+		       struct mac_ax_ch_stat_cnt *cnt)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 band;
+	u32 ret;
+
+	band = cnt->band;
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	cnt->busy_cnt = MAC_REG_R32(band ? R_AX_CHNL_BUSY_TIME_0_C1 :
+				    R_AX_CHNL_BUSY_TIME_0);
+	cnt->idle_cnt = MAC_REG_R32(band ? R_AX_CHNL_IDLE_TIME_0_C1 :
+				    R_AX_CHNL_IDLE_TIME_0);
+
+	return MACSUCCESS;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/status.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/status.h
new file mode 100644
index 000000000000..af74385d8c45
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/status.h
@@ -0,0 +1,73 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_STATUS_H_
+#define _MAC_AX_STATUS_H_
+
+#include "../type.h"
+#include "trxcfg.h"
+
+/**
+ * @brief mac_get_ft_status
+ *
+ * @param *adapter
+ * @param mac_ft
+ * @param *stat
+ * @param *buf
+ * @param size
+ * @param *ret_size
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_ft_status(struct mac_ax_adapter *adapter,
+		      enum mac_ax_feature mac_ft, enum mac_ax_status *stat,
+		      u8 *buf, const u32 size, u32 *ret_size);
+
+/**
+ * @brief mac_get_ft
+ *
+ * @param *adapter
+ * @param mac_ft
+ * @return Please Place Description here.
+ * @retval  mac_ax_ft_status
+ */
+
+struct mac_ax_ft_status *mac_get_ft(struct mac_ax_adapter *adapter,
+				    enum mac_ax_feature mac_ft);
+
+/**
+ * @brief set_hw_ch_busy_cnt
+ *
+ * @param *adapter
+ * @param *cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 set_hw_ch_busy_cnt(struct mac_ax_adapter *adapter,
+		       struct mac_ax_ch_busy_cnt_cfg *cfg);
+
+/**
+ * @brief get_hw_ch_stat_cnt
+ *
+ * @param *adapter
+ * @param *cnt
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 get_hw_ch_stat_cnt(struct mac_ax_adapter *adapter,
+		       struct mac_ax_ch_stat_cnt *cnt);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tblupd.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tblupd.c
new file mode 100644
index 000000000000..6c02b1682f8e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tblupd.c
@@ -0,0 +1,2616 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "tblupd.h"
+
+u32 mac_upd_mudecision_para(struct mac_ax_adapter *adapter,
+			    struct mac_ax_mudecision_para *info)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_mude_para_tblud *tbl;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_mude_para_tblud));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	tbl = (struct fwcmd_mude_para_tblud *)buf;
+	tbl->dword0 =
+	cpu_to_le32((info->tbl_hdr.rw ? FWCMD_H2C_TBLUD_R_W : 0) |
+		    SET_WORD(info->tbl_hdr.idx, FWCMD_H2C_TBLUD_MACID_GROUP) |
+		    SET_WORD(info->tbl_hdr.offset, FWCMD_H2C_TBLUD_OFFSET) |
+		    SET_WORD(info->tbl_hdr.len, FWCMD_H2C_TBLUD_LENGTH) |
+		    (info->tbl_hdr.type ? FWCMD_H2C_TBLUD_TYPE : 0) |
+		    SET_WORD(CLASS_MUDECISION_PARA,
+			     FWCMD_H2C_TBLUD_TABLE_CLASS));
+
+	tbl->dword1 =
+	cpu_to_le32(SET_WORD(info->mu_thold,
+			     FWCMD_H2C_MUDECISION_PARA_MUINFO_THOLD) |
+		    (info->bypass_thold ?
+		     FWCMD_H2C_MUDECISION_PARA_BYPASS_THOLD : 0) |
+		    (info->bypass_tp ?
+		     FWCMD_H2C_MUDECISION_PARA_BYPASS_TP : 0));
+
+	 tbl->dword2 =
+	 cpu_to_le32(SET_WORD(info->init_rate,
+			      FWCMD_H2C_MUDECISION_PARA_INIT_RATE) |
+		     SET_WORD(info->retry_th,
+			      FWCMD_H2C_MUDECISION_PARA_RETRY_TH));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FR_EXCHG,
+			      FWCMD_H2C_FUNC_TBLUD,
+			      0,
+			      0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_upd_ul_fixinfo(struct mac_ax_adapter *adapter,
+		       struct rtw_phl_ax_ul_fixinfo *info)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u32 *dword;
+	u16 h2c_size = (5 + RTW_PHL_MAX_RU_NUM / 2 + 2 + RTW_PHL_MAX_RU_NUM * 2) * sizeof(u32);
+	u8 i;
+
+	struct rtw_phl_ul_macid_info *sta_info;
+	struct rtw_phl_ul_macid_info *sta_info_2;
+	struct rtw_phl_ax_ulru_out_sta_ent *sta_ent;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, h2c_size);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	dword = (u32 *)buf;
+
+	(*dword++) =
+	cpu_to_le32((info->tbl_hdr.rw ? FWCMD_H2C_TBLUD_R_W : 0) |
+		    SET_WORD(info->tbl_hdr.idx, FWCMD_H2C_TBLUD_MACID_GROUP) |
+		    SET_WORD(info->tbl_hdr.offset, FWCMD_H2C_TBLUD_OFFSET) |
+		    SET_WORD(info->tbl_hdr.len, FWCMD_H2C_TBLUD_LENGTH) |
+		    (info->tbl_hdr.type ? FWCMD_H2C_TBLUD_TYPE : 0) |
+		    SET_WORD(CLASS_UL_FIXINFO,
+			     FWCMD_H2C_TBLUD_TABLE_CLASS));
+
+	(*dword++) =
+	cpu_to_le32(SET_WORD(info->cfg.mode, FWCMD_H2C_UL_FIXINFO_CFG_MODE) |
+		    SET_WORD(info->cfg.interval,
+			     FWCMD_H2C_UL_FIXINFO_CFG_INTERVAL) |
+		    SET_WORD(info->cfg.bsr_thold,
+			     FWCMD_H2C_UL_FIXINFO_CFG_BSR_THOLD) |
+		    SET_WORD(info->cfg.storemode,
+			     FWCMD_H2C_UL_FIXINFO_CFG_STOREMODE));
+
+	(*dword++) =
+	cpu_to_le32(SET_WORD(info->ndpa_dur,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_NDPA_DUR) |
+		    SET_WORD(info->tf_type,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_TF_TYPE) |
+		    (info->sig_ta_pkten ?
+		     FWCMD_H2C_UL_FIXINFO_ULINFO_SIGEN : 0) |
+		    SET_WORD(info->sig_ta_pktsc,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_SIGSC) |
+		    (info->murts_flag ?
+		     FWCMD_H2C_UL_FIXINFO_ULINFO_MURTS : 0) |
+		    SET_WORD(info->ndpa,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_NDPA) |
+		    SET_WORD(info->snd_pkt_sel,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_SNDPKT) |
+		    SET_WORD(info->gi_ltf,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_GI_LTF));
+
+	(*dword++) =
+	cpu_to_le32(SET_WORD(info->data_rate,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_DATART) |
+		    (info->data_er ?
+		     FWCMD_H2C_UL_FIXINFO_ULINFO_DATAER : 0) |
+		    SET_WORD(info->data_bw,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_DATABW) |
+		    SET_WORD(info->data_stbc,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_STBC) |
+		    (info->data_ldpc ?
+		     FWCMD_H2C_UL_FIXINFO_ULINFO_LDPC : 0) |
+		    (info->data_dcm ?
+		     FWCMD_H2C_UL_FIXINFO_ULINFO_DATADCM : 0) |
+		    SET_WORD(info->apep_len,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_APEPLEN) |
+		    (info->more_tf ?
+		     FWCMD_H2C_UL_FIXINFO_ULINFO_MORETF : 0) |
+		    (info->data_bw_er ?
+		     FWCMD_H2C_UL_FIXINFO_ULINFO_DATA_VWER : 0) |
+		    (info->istwt ?
+		     FWCMD_H2C_UL_FIXINFO_ULINFO_ISTWT : 0) |
+		    (info->ul_logo_test ?
+		     FWCMD_H2C_UL_FIXINFO_ULINFO_UL_LOGO_TEST : 0));
+
+	(*dword++) =
+	cpu_to_le32(SET_WORD(info->multiport_id,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_MULTIPORT) |
+		    SET_WORD(info->mbssid,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_MBSSID) |
+		    SET_WORD(info->txpwr_mode,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_TXPWR_MODE) |
+		    SET_WORD(info->ulfix_usage,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_ULFIX_USAGE) |
+		    SET_WORD(info->twtgrp_stanum_sel,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_TWTGRP_STANUM_SEL) |
+		    SET_WORD(info->store_idx,
+			     FWCMD_H2C_UL_FIXINFO_ULINFO_STORE_IDX));
+
+	for (i = 0; i < RTW_PHL_MAX_RU_NUM; i += 2) {
+		sta_info = &info->sta[i];
+		sta_info_2 = &info->sta[i + 1];
+		(*dword++) =
+		cpu_to_le32(SET_WORD(sta_info->macid,
+				     FWCMD_H2C_UL_FIXINFO_STA_INFO_MACID_0) |
+			    SET_WORD(sta_info->pref_AC,
+				     FWCMD_H2C_UL_FIXINFO_STA_INFO_PREF_AC_0) |
+			    SET_WORD(sta_info_2->macid,
+				     FWCMD_H2C_UL_FIXINFO_STA_INFO_MACID_1) |
+			    SET_WORD(sta_info_2->pref_AC,
+				     FWCMD_H2C_UL_FIXINFO_STA_INFO_PREF_AC_1));
+	}
+
+	(*dword++) =
+	cpu_to_le32((info->ulrua.ru2su ?
+		     FWCMD_H2C_UL_FIXINFO_ULRUA_RU2SU : 0) |
+		    SET_WORD(info->ulrua.ppdu_bw,
+			     FWCMD_H2C_UL_FIXINFO_ULRUA_PPDU_BW) |
+		    SET_WORD(info->ulrua.gi_ltf,
+			     FWCMD_H2C_UL_FIXINFO_ULRUA_GI_LTF) |
+		    (info->ulrua.stbc ?
+		     FWCMD_H2C_UL_FIXINFO_ULRUA_STBC : 0) |
+		    (info->ulrua.doppler ?
+		     FWCMD_H2C_UL_FIXINFO_ULRUA_DOPPLER : 0) |
+		    SET_WORD(info->ulrua.n_ltf_and_ma,
+			     FWCMD_H2C_UL_FIXINFO_ULRUA_LTF_MA) |
+		    SET_WORD(info->ulrua.sta_num,
+			     FWCMD_H2C_UL_FIXINFO_ULRUA_STANUM) |
+		    (info->ulrua.rf_gain_fix ?
+		     FWCMD_H2C_UL_FIXINFO_ULRUA_RFGFIX : 0) |
+		    SET_WORD(info->ulrua.rf_gain_idx,
+			     FWCMD_H2C_UL_FIXINFO_ULRUA_RFGIDX) |
+		    SET_WORD(info->ulrua.tb_t_pe_nom,
+			     FWCMD_H2C_UL_FIXINFO_ULRUA_TB_NOM));
+
+	(*dword++) =
+	cpu_to_le32((info->ulrua.grp_mode ?
+		     FWCMD_H2C_UL_FIXINFO_ULRUA_GRP_MODE : 0) |
+		    SET_WORD(info->ulrua.grp_id,
+			     FWCMD_H2C_UL_FIXINFO_ULRUA_GRP_ID) |
+		    (info->ulrua.fix_mode ?
+		     FWCMD_H2C_UL_FIXINFO_ULRUA_FIX_MODE : 0));
+
+	for (i = 0; i < RTW_PHL_MAX_RU_NUM; i++) {
+		sta_ent = &info->ulrua.sta[i];
+		(*dword++) =
+		cpu_to_le32((sta_ent->dropping ?
+			     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_DROP : 0) |
+			    SET_WORD(sta_ent->tgt_rssi,
+				     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_TGT_RSSI) |
+			    SET_WORD(sta_ent->mac_id,
+				     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_MAC_ID) |
+			    SET_WORD(sta_ent->ru_pos,
+				     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_RU_POS) |
+			    (sta_ent->coding ?
+			     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_CODE : 0) |
+			    (sta_ent->vip_flag ?
+			     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_VIP : 0));
+
+		(*dword++) =
+		cpu_to_le32(SET_WORD(sta_ent->bsr_length,
+				     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_BSRLEN) |
+			    (sta_ent->rate.dcm ?
+			     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_DCM : 0) |
+			    SET_WORD(sta_ent->rate.ss,
+				     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_SS) |
+			    SET_WORD(sta_ent->rate.mcs,
+				     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_MCS) |
+			    SET_WORD(sta_ent->rpt.rt_tblcol,
+				     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_RT_TBLCOL) |
+			    (sta_ent->rpt.prtl_alloc ?
+			     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_PRTL_ALLOC : 0) |
+			    (sta_ent->rpt.rate_chg ?
+			     FWCMD_H2C_UL_FIXINFO_UL_RUA_STA_ENT_RATE_CHG : 0));
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FR_EXCHG,
+			      FWCMD_H2C_FUNC_TBLUD,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_f2p_test_cmd(struct mac_ax_adapter *adapter,
+		     struct mac_ax_f2p_test_para *info,
+		     struct mac_ax_f2p_wd *f2pwd,
+		     struct mac_ax_f2p_tx_cmd *ptxcmd,
+		     u8 *psigb_addr)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_test_para *tbl;
+	struct mac_ax_tf_user_para *user;
+	struct mac_ax_tf_depend_user_para *dep_user;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_test_para));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	PLTFM_MEMSET(buf, 0, sizeof(struct fwcmd_test_para));
+
+	tbl = (struct fwcmd_test_para *)buf;
+
+	tbl->dword0 =
+	cpu_to_le32(SET_WORD(info->tf_pkt.ul_bw, FWCMD_F2PTEST_ULBW) |
+		    SET_WORD(info->tf_pkt.gi_ltf, FWCMD_F2PTEST_GILTF) |
+		    SET_WORD(info->tf_pkt.num_he_ltf, FWCMD_F2PTEST_NUMLTF) |
+		    SET_WORD(info->tf_pkt.ul_stbc, FWCMD_F2PTEST_ULSTBC) |
+		    SET_WORD(info->tf_pkt.doppler, FWCMD_F2PTEST_DPLR) |
+		    SET_WORD(info->tf_pkt.ap_tx_power, FWCMD_F2PTEST_TXPWR) |
+		    SET_WORD(info->tf_pkt.user_num, FWCMD_F2PTEST_USERNUM) |
+		    SET_WORD(info->tf_pkt.pktnum, FWCMD_F2PTEST_PKTNUM) |
+		    SET_WORD(info->tf_pkt.pri20_bitmap, FWCMD_F2PTEST_BITMAP));
+
+	user = &info->tf_pkt.user[0];
+	tbl->dword1 =
+	cpu_to_le32(SET_WORD(user->aid12, FWCMD_F2PTEST_AID12) |
+		    SET_WORD(user->ul_mcs, FWCMD_F2PTEST_ULMCS) |
+		    SET_WORD(user->macid, FWCMD_F2PTEST_MACID) |
+		    SET_WORD(user->ru_pos, FWCMD_F2PTEST_RUPOS));
+
+	tbl->dword2 =
+	cpu_to_le32(SET_WORD(user->ul_fec_code, FWCMD_F2PTEST_ULFEC) |
+		    SET_WORD(user->ul_dcm, FWCMD_F2PTEST_ULDCM) |
+		    SET_WORD(user->ss_alloc, FWCMD_F2PTEST_SS_ALLOC) |
+		    SET_WORD(user->ul_tgt_rssi, FWCMD_F2PTEST_UL_TGTRSSI));
+
+	user = &info->tf_pkt.user[1];
+	tbl->dword3 =
+	cpu_to_le32(SET_WORD(user->aid12, FWCMD_F2PTEST_AID12) |
+		    SET_WORD(user->ul_mcs, FWCMD_F2PTEST_ULMCS) |
+		    SET_WORD(user->macid, FWCMD_F2PTEST_MACID) |
+		    SET_WORD(user->ru_pos, FWCMD_F2PTEST_RUPOS));
+
+	tbl->dword4 =
+	cpu_to_le32(SET_WORD(user->ul_fec_code, FWCMD_F2PTEST_ULFEC) |
+		    SET_WORD(user->ul_dcm, FWCMD_F2PTEST_ULDCM) |
+		    SET_WORD(user->ss_alloc, FWCMD_F2PTEST_SS_ALLOC) |
+		    SET_WORD(user->ul_tgt_rssi, FWCMD_F2PTEST_UL_TGTRSSI));
+
+	user = &info->tf_pkt.user[2];
+	tbl->dword5 =
+	cpu_to_le32(SET_WORD(user->aid12, FWCMD_F2PTEST_AID12) |
+		    SET_WORD(user->ul_mcs, FWCMD_F2PTEST_ULMCS) |
+		    SET_WORD(user->macid, FWCMD_F2PTEST_MACID) |
+		    SET_WORD(user->ru_pos, FWCMD_F2PTEST_RUPOS));
+
+	tbl->dword6 =
+	cpu_to_le32(SET_WORD(user->ul_fec_code, FWCMD_F2PTEST_ULFEC) |
+		    SET_WORD(user->ul_dcm, FWCMD_F2PTEST_ULDCM) |
+		    SET_WORD(user->ss_alloc, FWCMD_F2PTEST_SS_ALLOC) |
+		    SET_WORD(user->ul_tgt_rssi, FWCMD_F2PTEST_UL_TGTRSSI));
+
+	user = &info->tf_pkt.user[3];
+	tbl->dword7 =
+	cpu_to_le32(SET_WORD(user->aid12, FWCMD_F2PTEST_AID12) |
+		    SET_WORD(user->ul_mcs, FWCMD_F2PTEST_ULMCS) |
+		    SET_WORD(user->macid, FWCMD_F2PTEST_MACID) |
+		    SET_WORD(user->ru_pos, FWCMD_F2PTEST_RUPOS));
+
+	tbl->dword8 =
+	cpu_to_le32(SET_WORD(user->ul_fec_code, FWCMD_F2PTEST_ULFEC) |
+		    SET_WORD(user->ul_dcm, FWCMD_F2PTEST_ULDCM) |
+		    SET_WORD(user->ss_alloc, FWCMD_F2PTEST_SS_ALLOC) |
+		    SET_WORD(user->ul_tgt_rssi, FWCMD_F2PTEST_UL_TGTRSSI));
+
+	dep_user = &info->tf_pkt.dep_user[0];
+	tbl->byte9 =
+	cpu_to_le32(SET_WORD(dep_user->pref_AC, FWCMD_F2PTEST_PREF_AC));
+
+	dep_user = &info->tf_pkt.dep_user[1];
+	tbl->byte10 =
+	cpu_to_le32(SET_WORD(dep_user->pref_AC, FWCMD_F2PTEST_PREF_AC));
+
+	dep_user = &info->tf_pkt.dep_user[2];
+	tbl->byte11 =
+	cpu_to_le32(SET_WORD(dep_user->pref_AC, FWCMD_F2PTEST_PREF_AC));
+
+	dep_user = &info->tf_pkt.dep_user[3];
+	tbl->byte12 =
+	cpu_to_le32(SET_WORD(dep_user->pref_AC, FWCMD_F2PTEST_PREF_AC));
+
+	tbl->dword13 =
+	cpu_to_le32(SET_WORD(info->tf_wd.datarate, FWCMD_F2PTEST_DATARATE) |
+		    SET_WORD(info->tf_wd.mulport_id, FWCMD_F2PTEST_MULPORT) |
+		    SET_WORD(info->tf_wd.pwr_ofset, FWCMD_F2PTEST_PWR_OFSET) |
+		    SET_WORD(info->mode, FWCMD_F2PTEST_MODE) |
+		    SET_WORD(info->frexch_type, FWCMD_F2PTEST_TYPE) |
+		    SET_WORD(info->sigb_len, FWCMD_F2PTEST_SIGB_LEN));
+
+	tbl->dword14 =
+	cpu_to_le32(SET_WORD(f2pwd->cmd_qsel, F2P_WD_CMD_QSEL) |
+		    (f2pwd->ls ? F2P_WD_LS : 0) |
+		    (f2pwd->fs ? F2P_WD_FS : 0) |
+		    SET_WORD(f2pwd->total_number, F2P_WD_TOTAL_NUMBER) |
+		    SET_WORD(f2pwd->seq, F2P_WD_SEQ) |
+		    SET_WORD(f2pwd->length, F2P_WD_LENGTH));
+
+	tbl->dword16 =
+	cpu_to_le32(SET_WORD(ptxcmd->cmd_type, F2P_CMD_TYPE) |
+		    SET_WORD(ptxcmd->cmd_sub_type, F2P_CMD_SUB_TYPE) |
+		    SET_WORD(ptxcmd->dl_user_num, F2P_DL_USER_NUM) |
+		    SET_WORD(ptxcmd->bw, F2P_BW) |
+		    SET_WORD(ptxcmd->tx_power, F2P_TX_POWER));
+
+	tbl->dword17 =
+	cpu_to_le32(SET_WORD(ptxcmd->fw_define, F2P_FW_DEFINE) |
+		    SET_WORD(ptxcmd->ss_sel_mode, F2P_SS_SEL_MODE) |
+		    SET_WORD(ptxcmd->next_qsel, F2P_NEXT_QSEL) |
+		    SET_WORD(ptxcmd->twt_group, F2P_TWT_GROUP) |
+		    (ptxcmd->dis_chk_slp ? F2P_DIS_CHK_SLP : 0) |
+		    (ptxcmd->ru_mu_2_su ? F2P_RU_MU_2_SU : 0) |
+		    SET_WORD(ptxcmd->dl_t_pe, F2P_DL_T_PE));
+
+	tbl->dword18 =
+	cpu_to_le32(SET_WORD(ptxcmd->sigb_ch1_len, F2P_SIGB_CH1_LEN) |
+		    SET_WORD(ptxcmd->sigb_ch2_len, F2P_SIGB_CH2_LEN) |
+		    SET_WORD(ptxcmd->sigb_sym_num, F2P_SIGB_SYM_NUM) |
+		    SET_WORD(ptxcmd->sigb_ch2_ofs, F2P_SIGB_CH2_OFS) |
+		    (ptxcmd->dis_htp_ack ? F2P_DIS_HTP_ACK : 0) |
+		    SET_WORD(ptxcmd->tx_time_ref, F2P_TX_TIME_REF) |
+		    SET_WORD(ptxcmd->pri_user_idx, F2P_PRI_USER_IDX));
+
+	tbl->dword19 =
+	cpu_to_le32(SET_WORD(ptxcmd->ampdu_max_txtime, F2P_AMPDU_MAX_TXTIME) |
+		    SET_WORD(ptxcmd->group_id, F2P_GROUP_ID) |
+		    (ptxcmd->twt_chk_en ? F2P_TWT_CHK_EN : 0) |
+		    SET_WORD(ptxcmd->twt_port_id, F2P_TWT_PORT_ID));
+
+	tbl->dword20 =
+	cpu_to_le32(SET_WORD(ptxcmd->twt_start_time, F2P_TWT_START_TIME));
+
+	tbl->dword21 =
+	cpu_to_le32(SET_WORD(ptxcmd->twt_end_time, F2P_TWT_END_TIME));
+
+	tbl->dword22 =
+	cpu_to_le32(SET_WORD(ptxcmd->apep_len, F2P_APEP_LEN) |
+		    SET_WORD(ptxcmd->tri_pad, F2P_TRI_PAD) |
+		    SET_WORD(ptxcmd->ul_t_pe, F2P_UL_T_PE) |
+		    SET_WORD(ptxcmd->rf_gain_idx, F2P_RF_GAIN_IDX) |
+		    (ptxcmd->fixed_gain_en ? F2P_FIXED_GAIN_EN : 0) |
+		    SET_WORD(ptxcmd->ul_gi_ltf, F2P_UL_GI_LTF) |
+		    (ptxcmd->ul_doppler ? F2P_UL_DOPPLER : 0) |
+		    (ptxcmd->ul_stbc ? F2P_UL_STBC : 0));
+
+	tbl->dword23 =
+	cpu_to_le32((ptxcmd->ul_mid_per ? F2P_UL_MID_PER : 0) |
+		    (ptxcmd->ul_cqi_rrp_tri ? F2P_UL_CQI_RRP_TRI : 0) |
+		    (ptxcmd->sigb_dcm ? F2P_SIGB_DCM : 0) |
+		    (ptxcmd->sigb_comp ? F2P_SIGB_COMP : 0) |
+		    (ptxcmd->doppler ? F2P_DOPPLER : 0) |
+		    (ptxcmd->stbc ? F2P_STBC : 0) |
+		    (ptxcmd->mid_per ? F2P_MID_PER : 0) |
+		    SET_WORD(ptxcmd->gi_ltf_size, F2P_GI_LTF_SIZE) |
+		    SET_WORD(ptxcmd->sigb_mcs, F2P_SIGB_MCS));
+
+	tbl->dword24 =
+	cpu_to_le32(SET_WORD(ptxcmd->macid_u0, F2P_MACID_U0) |
+		    SET_WORD(ptxcmd->ac_type_u0, F2P_AC_TYPE_U0) |
+		    SET_WORD(ptxcmd->mu_sta_pos_u0, F2P_MU_STA_POS_U0) |
+		    SET_WORD(ptxcmd->dl_rate_idx_u0, F2P_DL_RATE_IDX_U0) |
+		    (ptxcmd->dl_dcm_en_u0 ? F2P_TX_CMD_DL_DCM_EN_U0 : 0) |
+		    SET_WORD(ptxcmd->ru_alo_idx_u0, F2P_RU_ALO_IDX_U0) |
+		    (ptxcmd->rsvd6 ? BIT(22) : 0));
+
+	tbl->dword25 =
+	cpu_to_le32(SET_WORD(ptxcmd->pwr_boost_u0, F2P_PWR_BOOST_U0) |
+		    SET_WORD(ptxcmd->agg_bmp_alo_u0, F2P_AGG_BMP_ALO_U0) |
+		    SET_WORD(ptxcmd->ampdu_max_txnum_u0, F2P_AMPDU_MAX_NUM_U0) |
+		    SET_WORD(ptxcmd->user_define_u0, F2P_USER_DEFINE_U0) |
+		    SET_WORD(ptxcmd->user_define_ext_u0, F2P_USER_DEFINE_EXT_U0)
+		    );
+
+	tbl->dword26 =
+	cpu_to_le32(SET_WORD(ptxcmd->ul_addr_idx_u0, F2P_UL_ADDR_IDX_U0) |
+		    (ptxcmd->ul_dcm_u0 ? F2P_UL_DCM_U0 : 0) |
+		    (ptxcmd->ul_fec_cod_u0 ? F2P_UL_FEC_COD_U0 : 0) |
+		    SET_WORD(ptxcmd->ul_ru_rate_u0, F2P_UL_RU_RATE_U0) |
+		    SET_WORD(ptxcmd->ul_ru_alo_idx_u0, F2P_UL_RU_ALO_IDX_U0));
+
+	tbl->dword28 =
+	cpu_to_le32(SET_WORD(ptxcmd->macid_u1, F2P_MACID_U1) |
+		    SET_WORD(ptxcmd->ac_type_u1, F2P_AC_TYPE_U1) |
+		    SET_WORD(ptxcmd->mu_sta_pos_u1, F2P_MU_STA_POS_U1) |
+		    SET_WORD(ptxcmd->dl_rate_idx_u1, F2P_DL_RATE_IDX_U1) |
+		    (ptxcmd->dl_dcm_en_u1 ? F2P_TX_CMD_DL_DCM_EN_U1 : 0) |
+		    SET_WORD(ptxcmd->ru_alo_idx_u1, F2P_RU_ALO_IDX_U1) |
+		    (ptxcmd->rsvd10 ? BIT(22) : 0));
+
+	tbl->dword29 =
+	cpu_to_le32(SET_WORD(ptxcmd->pwr_boost_u1, F2P_PWR_BOOST_U1) |
+		    SET_WORD(ptxcmd->agg_bmp_alo_u1, F2P_AGG_BMP_ALO_U1) |
+		    SET_WORD(ptxcmd->ampdu_max_txnum_u1, F2P_AMPDU_MAX_NUM_U1) |
+		    SET_WORD(ptxcmd->user_define_u1, F2P_USER_DEFINE_U1) |
+		    SET_WORD(ptxcmd->user_define_ext_u1, F2P_USER_DEFINE_EXT_U1)
+		    );
+
+	tbl->dword30 =
+	cpu_to_le32(SET_WORD(ptxcmd->ul_addr_idx_u1, F2P_UL_ADDR_IDX_U1) |
+		    (ptxcmd->ul_dcm_u1 ? F2P_UL_DCM_U1 : 0) |
+		    (ptxcmd->ul_fec_cod_u1 ? F2P_UL_FEC_COD_U1 : 0) |
+		    SET_WORD(ptxcmd->ul_ru_rate_u1, F2P_UL_RU_RATE_U1) |
+		    SET_WORD(ptxcmd->ul_ru_alo_idx_u1, F2P_UL_RU_ALO_IDX_U1));
+
+	tbl->dword32 =
+	cpu_to_le32(SET_WORD(ptxcmd->macid_u2, F2P_MACID_U2) |
+		    SET_WORD(ptxcmd->ac_type_u2, F2P_AC_TYPE_U2) |
+		    SET_WORD(ptxcmd->mu_sta_pos_u2, F2P_MU_STA_POS_U2) |
+		    SET_WORD(ptxcmd->dl_rate_idx_u2, F2P_DL_RATE_IDX_U2) |
+		    (ptxcmd->dl_dcm_en_u2 ? F2P_TX_CMD_DL_DCM_EN_U2 : 0) |
+		    SET_WORD(ptxcmd->ru_alo_idx_u2, F2P_RU_ALO_IDX_U2) |
+		    (ptxcmd->rsvd14 ? BIT(22) : 0));
+
+	tbl->dword33 =
+	cpu_to_le32(SET_WORD(ptxcmd->pwr_boost_u2, F2P_PWR_BOOST_U2) |
+		    SET_WORD(ptxcmd->agg_bmp_alo_u2, F2P_AGG_BMP_ALO_U2) |
+		    SET_WORD(ptxcmd->ampdu_max_txnum_u2, F2P_AMPDU_MAX_NUM_U2) |
+		    SET_WORD(ptxcmd->user_define_u2, F2P_USER_DEFINE_U2) |
+		    SET_WORD(ptxcmd->user_define_ext_u2, F2P_USER_DEFINE_EXT_U2)
+		    );
+
+	tbl->dword34 =
+	cpu_to_le32(SET_WORD(ptxcmd->ul_addr_idx_u2, F2P_UL_ADDR_IDX_U2) |
+		    (ptxcmd->ul_dcm_u2 ? F2P_UL_DCM_U2 : 0) |
+		    (ptxcmd->ul_fec_cod_u2 ? F2P_UL_FEC_COD_U2 : 0) |
+		    SET_WORD(ptxcmd->ul_ru_rate_u2, F2P_UL_RU_RATE_U2) |
+		    SET_WORD(ptxcmd->ul_ru_alo_idx_u2, F2P_UL_RU_ALO_IDX_U2));
+
+	tbl->dword36 =
+	cpu_to_le32(SET_WORD(ptxcmd->macid_u3, F2P_MACID_U3) |
+		    SET_WORD(ptxcmd->ac_type_u3, F2P_AC_TYPE_U3) |
+		    SET_WORD(ptxcmd->mu_sta_pos_u3, F2P_MU_STA_POS_U3) |
+		    SET_WORD(ptxcmd->dl_rate_idx_u3, F2P_DL_RATE_IDX_U3) |
+		    (ptxcmd->dl_dcm_en_u3 ? F2P_TX_CMD_DL_DCM_EN_U3 : 0) |
+		    SET_WORD(ptxcmd->ru_alo_idx_u3, F2P_RU_ALO_IDX_U3) |
+		    (ptxcmd->rsvd18 ? BIT(22) : 0));
+
+	tbl->dword37 =
+	cpu_to_le32(SET_WORD(ptxcmd->pwr_boost_u3, F2P_PWR_BOOST_U3) |
+		    SET_WORD(ptxcmd->agg_bmp_alo_u3, F2P_AGG_BMP_ALO_U3) |
+		    SET_WORD(ptxcmd->ampdu_max_txnum_u3, F2P_AMPDU_MAX_NUM_U3) |
+		    SET_WORD(ptxcmd->user_define_u3, F2P_USER_DEFINE_U3) |
+		    SET_WORD(ptxcmd->user_define_ext_u3, F2P_USER_DEFINE_EXT_U3)
+		    );
+
+	tbl->dword38 =
+	cpu_to_le32(SET_WORD(ptxcmd->ul_addr_idx_u3, F2P_UL_ADDR_IDX_U3) |
+		    (ptxcmd->ul_dcm_u3 ? F2P_UL_DCM_U3 : 0) |
+		    (ptxcmd->ul_fec_cod_u3 ? F2P_UL_FEC_COD_U3 : 0) |
+		    SET_WORD(ptxcmd->ul_ru_rate_u3, F2P_UL_RU_RATE_U3) |
+		    SET_WORD(ptxcmd->ul_ru_alo_idx_u3, F2P_UL_RU_ALO_IDX_U3));
+
+	tbl->dword40 =
+	cpu_to_le32(SET_WORD(ptxcmd->pkt_id_0, F2P_PKT_ID_0) |
+		    (ptxcmd->valid_0 ? F2P_VALID_0 : 0) |
+		    SET_WORD(ptxcmd->ul_user_num_0, F2P_UL_USER_NUM_0));
+
+	tbl->dword41 =
+	cpu_to_le32(SET_WORD(ptxcmd->pkt_id_1, F2P_PKT_ID_1) |
+		    (ptxcmd->valid_1 ? F2P_VALID_1 : 0) |
+		    SET_WORD(ptxcmd->ul_user_num_1, F2P_UL_USER_NUM_1));
+
+	tbl->dword42 =
+	cpu_to_le32(SET_WORD(ptxcmd->pkt_id_2, F2P_PKT_ID_2) |
+		    (ptxcmd->valid_2 ? F2P_VALID_2 : 0) |
+		    SET_WORD(ptxcmd->ul_user_num_2, F2P_UL_USER_NUM_2));
+
+	tbl->dword43 =
+	cpu_to_le32(SET_WORD(ptxcmd->pkt_id_3, F2P_PKT_ID_3) |
+		    (ptxcmd->valid_3 ? F2P_VALID_3 : 0) |
+		    SET_WORD(ptxcmd->ul_user_num_3, F2P_UL_USER_NUM_3));
+
+	tbl->dword44 =
+	cpu_to_le32(SET_WORD(ptxcmd->pkt_id_4, F2P_PKT_ID_4) |
+		    (ptxcmd->valid_4 ? F2P_VALID_4 : 0) |
+		    SET_WORD(ptxcmd->ul_user_num_4, F2P_UL_USER_NUM_4));
+
+	tbl->dword45 =
+	cpu_to_le32(SET_WORD(ptxcmd->pkt_id_5, F2P_PKT_ID_5) |
+		    (ptxcmd->valid_5 ? F2P_VALID_5 : 0) |
+		    SET_WORD(ptxcmd->ul_user_num_5, F2P_UL_USER_NUM_5));
+
+	PLTFM_MEMCPY(tbl->byte46, psigb_addr, info->sigb_len);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FR_EXCHG,
+			      FWCMD_H2C_FUNC_F2P_TEST,
+			      0,
+			      0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_snd_test_cmd(struct mac_ax_adapter *adapter,
+		     u8 *cmd_buf)
+{
+	return MACSUCCESS;
+}
+
+u32 mac_upd_dctl_info(struct mac_ax_adapter *adapter,
+		      struct mac_ax_dctl_info *info,
+		      struct mac_ax_dctl_info *mask, u8 macid, u8 operation)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_dctlinfo_ud *tbl;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_dctlinfo_ud));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	tbl = (struct fwcmd_dctlinfo_ud *)buf;
+	tbl->dword0 =
+	cpu_to_le32(SET_WORD(macid, FWCMD_H2C_DCTLINFO_UD_MACID) |
+		    (operation ? FWCMD_H2C_DCTLINFO_UD_OP : 0));
+
+	tbl->dword1 =
+	cpu_to_le32(SET_WORD(info->qos_field_h, FWCMD_H2C_DCTRL_QOS_FIELD_H) |
+		    SET_WORD(info->hw_exseq_macid, FWCMD_H2C_DCTRL_HW_EXSEQ_MACID) |
+		    (info->qos_field_h_en ? FWCMD_H2C_DCTRL_QOS_FIELD_H_EN : 0) |
+		    SET_WORD(info->aes_iv_l, FWCMD_H2C_DCTRL_AES_IV_L));
+
+	tbl->dword2 =
+	cpu_to_le32(SET_WORD(info->aes_iv_h, FWCMD_H2C_DCTRL_AES_IV_H));
+
+	tbl->dword3 =
+	cpu_to_le32(SET_WORD(info->seq0, FWCMD_H2C_DCTRL_SEQ0) |
+		    SET_WORD(info->seq1, FWCMD_H2C_DCTRL_SEQ1) |
+		    SET_WORD(info->amsdu_max_length, FWCMD_H2C_DCTRL_AMSDU_MAX_LEN) |
+		    (info->sta_amsdu_en ? FWCMD_H2C_DCTRL_STA_AMSDU_EN : 0) |
+		    (info->chksum_offload_en ? FWCMD_H2C_DCTRL_CHKSUM_OFLD_EN : 0) |
+		    (info->with_llc ? FWCMD_H2C_DCTRL_WITH_LLC : 0) |
+		    (info->sec_hw_enc ? FWCMD_H2C_DCTRL_SEC_HW_ENC : 0));
+
+	tbl->dword4 =
+	cpu_to_le32(SET_WORD(info->seq2, FWCMD_H2C_DCTRL_SEQ2) |
+		    SET_WORD(info->seq3, FWCMD_H2C_DCTRL_SEQ3) |
+		    SET_WORD(info->sec_cam_idx, FWCMD_H2C_DCTRL_SEC_CAM_IDX));
+
+	tbl->dword5 =
+	cpu_to_le32(SET_WORD(mask->qos_field_h, FWCMD_H2C_DCTRL_QOS_FIELD_H) |
+		    SET_WORD(mask->hw_exseq_macid, FWCMD_H2C_DCTRL_HW_EXSEQ_MACID) |
+		    (mask->qos_field_h_en ? FWCMD_H2C_DCTRL_QOS_FIELD_H_EN : 0) |
+		    SET_WORD(mask->aes_iv_l, FWCMD_H2C_DCTRL_AES_IV_L));
+
+	tbl->dword6 =
+	cpu_to_le32(SET_WORD(mask->aes_iv_h, FWCMD_H2C_DCTRL_AES_IV_H));
+
+	tbl->dword7 =
+	cpu_to_le32(SET_WORD(mask->seq0, FWCMD_H2C_DCTRL_SEQ0) |
+		    SET_WORD(mask->seq1, FWCMD_H2C_DCTRL_SEQ1) |
+		    SET_WORD(mask->amsdu_max_length, FWCMD_H2C_DCTRL_AMSDU_MAX_LEN) |
+		    (mask->sta_amsdu_en ? FWCMD_H2C_DCTRL_STA_AMSDU_EN : 0) |
+		    (mask->chksum_offload_en ? FWCMD_H2C_DCTRL_CHKSUM_OFLD_EN : 0) |
+		    (mask->with_llc ? FWCMD_H2C_DCTRL_WITH_LLC : 0) |
+		    (mask->sec_hw_enc ? FWCMD_H2C_DCTRL_SEC_HW_ENC : 0));
+
+	tbl->dword8 =
+	cpu_to_le32(SET_WORD(mask->seq2, FWCMD_H2C_DCTRL_SEQ2) |
+		    SET_WORD(mask->seq3, FWCMD_H2C_DCTRL_SEQ3) |
+		    SET_WORD(mask->sec_cam_idx, FWCMD_H2C_DCTRL_SEC_CAM_IDX));
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = h2c_pkt_set_hdr(adapter, h2cb,
+				      FWCMD_TYPE_H2C,
+				      FWCMD_H2C_CAT_MAC,
+				      FWCMD_H2C_CL_FR_EXCHG,
+				      FWCMD_H2C_FUNC_DCTLINFO_UD,
+				      0,
+				      1);
+		if (ret)
+			goto fail;
+
+		// Return MACSUCCESS if h2c aggregation is enabled and enqueued successfully.
+		// The H2C shall be sent by mac_h2c_agg_tx.
+		ret = h2c_agg_enqueue(adapter, h2cb);
+		if (ret == MACSUCCESS)
+			return MACSUCCESS;
+
+		ret = h2c_pkt_build_txd(adapter, h2cb);
+		if (ret)
+			goto fail;
+
+		#if MAC_AX_PHL_H2C
+		ret = PLTFM_TX(h2cb);
+		#else
+		ret = PLTFM_TX(h2cb->data, h2cb->len);
+		#endif
+		if (ret)
+			goto fail;
+	} else {
+#if MAC_AX_FEATURE_DBGPKG
+		if (operation)
+			dctl_info_debug_write(adapter, macid,
+					      (struct fwcmd_dctlinfo_ud *)buf);
+#else
+		return MACFWNONRDY;
+#endif
+	}
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_upd_shcut_mhdr(struct mac_ax_adapter *adapter,
+		       struct mac_ax_shcut_mhdr *info, u8 shcut_camid)
+{
+	u32 ret = 0;
+	u32 i;
+	u8 *buf;
+	u32 *src, *dest;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_shcut_update *tbl;
+
+	if (!(is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	      is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	      is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)))
+		return MACNOTSUP;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_shcut_update));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	tbl = (struct fwcmd_shcut_update *)buf;
+	tbl->dword0 =
+	cpu_to_le32(SET_WORD(shcut_camid, FWCMD_H2C_DCTLINFO_UD_MACID));
+	src = (u32 *)info;
+	dest = (u32 *)(&tbl->dword1);
+	for (i = 0; i < (sizeof(struct mac_ax_shcut_mhdr) / 4); i++)
+		*(dest++) = *(src++);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FR_EXCHG,
+			      FWCMD_H2C_FUNC_SHCUT_UPDATE,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+void _set_role_cctrl(struct mac_ax_adapter *adapter,
+		     struct rtw_hal_mac_ax_cctl_info *info,
+		     struct rtw_hal_mac_ax_cctl_info *mask,
+		     struct rtw_hal_mac_ax_cctl_info *cctrl)
+{
+	cctrl->datarate = (cctrl->datarate & ~mask->datarate) |
+			(mask->datarate & info->datarate);
+	cctrl->force_txop = (cctrl->force_txop & ~mask->force_txop) |
+			(mask->force_txop & info->force_txop);
+	cctrl->data_bw = (cctrl->data_bw & ~mask->data_bw) |
+			(mask->data_bw & info->data_bw);
+	cctrl->data_gi_ltf = (cctrl->data_gi_ltf & ~mask->data_gi_ltf) |
+			(mask->data_gi_ltf & info->data_gi_ltf);
+	cctrl->darf_tc_index = (cctrl->darf_tc_index & ~mask->darf_tc_index) |
+			(mask->darf_tc_index & info->darf_tc_index);
+	cctrl->arfr_ctrl = (cctrl->arfr_ctrl & ~mask->arfr_ctrl) |
+			(mask->arfr_ctrl & info->arfr_ctrl);
+	cctrl->acq_rpt_en = (cctrl->acq_rpt_en & ~mask->acq_rpt_en) |
+			(mask->acq_rpt_en & info->acq_rpt_en);
+	cctrl->mgq_rpt_en = (cctrl->mgq_rpt_en & ~mask->mgq_rpt_en) |
+			(mask->mgq_rpt_en & info->mgq_rpt_en);
+	cctrl->ulq_rpt_en = (cctrl->ulq_rpt_en & ~mask->ulq_rpt_en) |
+			(mask->ulq_rpt_en & info->ulq_rpt_en);
+	cctrl->twtq_rpt_en = (cctrl->twtq_rpt_en & ~mask->twtq_rpt_en) |
+			(mask->twtq_rpt_en & info->twtq_rpt_en);
+	cctrl->disrtsfb = (cctrl->disrtsfb & ~mask->disrtsfb) |
+			(mask->disrtsfb & info->disrtsfb);
+	cctrl->disdatafb = (cctrl->disdatafb & ~mask->disdatafb) |
+			(mask->disdatafb & info->disdatafb);
+	cctrl->tryrate = (cctrl->tryrate & ~mask->tryrate) |
+			(mask->tryrate & info->tryrate);
+	cctrl->ampdu_density = (cctrl->ampdu_density & ~mask->ampdu_density) |
+			(mask->ampdu_density & info->ampdu_density);
+
+	cctrl->data_rty_lowest_rate =
+			(cctrl->data_rty_lowest_rate &
+			 ~mask->data_rty_lowest_rate) |
+			(mask->data_rty_lowest_rate &
+			 info->data_rty_lowest_rate);
+	cctrl->ampdu_time_sel = (cctrl->ampdu_time_sel &
+				 ~mask->ampdu_time_sel) |
+			(mask->ampdu_time_sel & info->ampdu_time_sel);
+	cctrl->ampdu_len_sel = (cctrl->ampdu_len_sel & ~mask->ampdu_len_sel) |
+			(mask->ampdu_len_sel & info->ampdu_len_sel);
+	cctrl->rts_txcnt_lmt_sel =
+			(cctrl->rts_txcnt_lmt_sel & ~mask->rts_txcnt_lmt_sel) |
+			(mask->rts_txcnt_lmt_sel & info->rts_txcnt_lmt_sel);
+	cctrl->rts_txcnt_lmt = (cctrl->rts_txcnt_lmt & ~mask->rts_txcnt_lmt) |
+			(mask->rts_txcnt_lmt & info->rts_txcnt_lmt);
+	cctrl->rtsrate = (cctrl->rtsrate & ~mask->rtsrate) |
+			(mask->rtsrate & info->rtsrate);
+	cctrl->vcs_stbc = (cctrl->vcs_stbc & ~mask->vcs_stbc) |
+			(mask->vcs_stbc & info->vcs_stbc);
+	cctrl->rts_rty_lowest_rate =
+			(cctrl->rts_rty_lowest_rate &
+			 ~mask->rts_rty_lowest_rate) |
+			(mask->rts_rty_lowest_rate & info->rts_rty_lowest_rate);
+
+	cctrl->data_tx_cnt_lmt =
+			(cctrl->data_tx_cnt_lmt & ~mask->data_tx_cnt_lmt) |
+			(mask->data_tx_cnt_lmt & info->data_tx_cnt_lmt);
+	cctrl->data_txcnt_lmt_sel =
+			(cctrl->data_txcnt_lmt_sel &
+			 ~mask->data_txcnt_lmt_sel) |
+			(mask->data_txcnt_lmt_sel & info->data_txcnt_lmt_sel);
+	cctrl->max_agg_num_sel = (cctrl->max_agg_num_sel &
+				  ~mask->max_agg_num_sel) |
+			(mask->max_agg_num_sel & info->max_agg_num_sel);
+	cctrl->rts_en = (cctrl->rts_en & ~mask->rts_en) |
+			(mask->rts_en & info->rts_en);
+	cctrl->cts2self_en = (cctrl->cts2self_en & ~mask->cts2self_en) |
+			(mask->cts2self_en & info->cts2self_en);
+	cctrl->cca_rts = (cctrl->cca_rts & ~mask->cca_rts) |
+			(mask->cca_rts & info->cca_rts);
+	cctrl->hw_rts_en = (cctrl->hw_rts_en & ~mask->hw_rts_en) |
+			(mask->hw_rts_en & info->hw_rts_en);
+	cctrl->rts_drop_data_mode =
+			(cctrl->rts_drop_data_mode &
+			 ~mask->rts_drop_data_mode) |
+			(mask->rts_drop_data_mode & info->rts_drop_data_mode);
+	cctrl->preld_en = (cctrl->preld_en & ~mask->preld_en) |
+			  (mask->preld_en & info->preld_en);
+	cctrl->ampdu_max_len = (cctrl->ampdu_max_len & ~mask->ampdu_max_len) |
+			(mask->ampdu_max_len & info->ampdu_max_len);
+	cctrl->ul_mu_dis = (cctrl->ul_mu_dis & ~mask->ul_mu_dis) |
+			(mask->ul_mu_dis & info->ul_mu_dis);
+	cctrl->ampdu_max_time = (cctrl->ampdu_max_time &
+				 ~mask->ampdu_max_time) |
+			(mask->ampdu_max_time & info->ampdu_max_time);
+
+	cctrl->max_agg_num = (cctrl->max_agg_num & ~mask->max_agg_num) |
+			(mask->max_agg_num & info->max_agg_num);
+	cctrl->ba_bmap = (cctrl->ba_bmap & ~mask->ba_bmap) |
+			(mask->ba_bmap & info->ba_bmap);
+	cctrl->vo_lftime_sel = (cctrl->vo_lftime_sel & ~mask->vo_lftime_sel) |
+			(mask->vo_lftime_sel & info->vo_lftime_sel);
+	cctrl->vi_lftime_sel = (cctrl->vi_lftime_sel & ~mask->vi_lftime_sel) |
+			(mask->vi_lftime_sel & info->vi_lftime_sel);
+	cctrl->be_lftime_sel = (cctrl->be_lftime_sel & ~mask->be_lftime_sel) |
+			(mask->be_lftime_sel & info->be_lftime_sel);
+	cctrl->bk_lftime_sel = (cctrl->bk_lftime_sel & ~mask->bk_lftime_sel) |
+			(mask->bk_lftime_sel & info->bk_lftime_sel);
+	cctrl->sectype = (cctrl->bk_lftime_sel & ~mask->sectype) |
+			(mask->bk_lftime_sel & info->sectype);
+
+	cctrl->multi_port_id = (cctrl->multi_port_id & ~mask->multi_port_id) |
+			(mask->multi_port_id & info->multi_port_id);
+	cctrl->bmc = (cctrl->multi_port_id & ~mask->bmc) |
+			(mask->multi_port_id & info->bmc);
+	cctrl->mbssid = (cctrl->mbssid & ~mask->mbssid) |
+			(mask->mbssid & info->mbssid);
+	cctrl->navusehdr = (cctrl->navusehdr & ~mask->navusehdr) |
+			(mask->navusehdr & info->navusehdr);
+	cctrl->txpwr_mode = (cctrl->txpwr_mode & ~mask->txpwr_mode) |
+			(mask->txpwr_mode & info->txpwr_mode);
+	cctrl->data_dcm = (cctrl->data_dcm & ~mask->data_dcm) |
+			(mask->data_dcm & info->data_dcm);
+	cctrl->data_er = (cctrl->data_er & ~mask->data_er) |
+			(mask->data_er & info->data_er);
+	cctrl->data_ldpc = (cctrl->data_ldpc & ~mask->data_ldpc) |
+			(mask->data_ldpc & info->data_ldpc);
+	cctrl->data_stbc = (cctrl->data_stbc & ~mask->data_stbc) |
+			(mask->data_stbc & info->data_stbc);
+	cctrl->a_ctrl_bqr = (cctrl->a_ctrl_bqr & ~mask->a_ctrl_bqr) |
+			(mask->a_ctrl_bqr & info->a_ctrl_bqr);
+	cctrl->a_ctrl_uph = (cctrl->a_ctrl_uph & ~mask->a_ctrl_uph) |
+			(mask->a_ctrl_uph & info->a_ctrl_uph);
+	cctrl->a_ctrl_bsr = (cctrl->a_ctrl_bsr & ~mask->a_ctrl_bsr) |
+			(mask->a_ctrl_bsr & info->a_ctrl_bsr);
+	cctrl->a_ctrl_cas = (cctrl->a_ctrl_cas & ~mask->a_ctrl_cas) |
+			(mask->a_ctrl_cas & info->a_ctrl_cas);
+	cctrl->data_bw_er = (cctrl->data_bw_er & ~mask->data_bw_er) |
+			(mask->data_bw_er & info->data_bw_er);
+	cctrl->lsig_txop_en = (cctrl->lsig_txop_en & ~mask->lsig_txop_en) |
+			(mask->lsig_txop_en & info->lsig_txop_en);
+	cctrl->ctrl_cnt_vld = (cctrl->ctrl_cnt_vld & ~mask->ctrl_cnt_vld) |
+			(mask->ctrl_cnt_vld & info->ctrl_cnt_vld);
+	cctrl->ctrl_cnt = (cctrl->ctrl_cnt & ~mask->ctrl_cnt) |
+			(mask->ctrl_cnt & info->ctrl_cnt);
+
+	cctrl->resp_ref_rate = (cctrl->resp_ref_rate & ~mask->resp_ref_rate) |
+			(mask->resp_ref_rate & info->resp_ref_rate);
+	cctrl->all_ack_support =
+			(cctrl->all_ack_support & ~mask->all_ack_support) |
+			(mask->all_ack_support & info->all_ack_support);
+	cctrl->bsr_queue_size_format =
+			(cctrl->bsr_queue_size_format &
+			 ~mask->bsr_queue_size_format) |
+			(mask->bsr_queue_size_format &
+			 info->bsr_queue_size_format);
+	cctrl->ntx_path_en = (cctrl->ntx_path_en & ~mask->ntx_path_en) |
+			(mask->ntx_path_en & info->ntx_path_en);
+	cctrl->path_map_a = (cctrl->ntx_path_en & ~mask->path_map_a) |
+			(mask->ntx_path_en & info->path_map_a);
+	cctrl->path_map_b = (cctrl->path_map_b & ~mask->path_map_b) |
+			(mask->path_map_b & info->path_map_b);
+	cctrl->path_map_c = (cctrl->path_map_c & ~mask->path_map_c) |
+			(mask->path_map_c & info->path_map_c);
+	cctrl->path_map_d = (cctrl->path_map_d & ~mask->path_map_d) |
+			(mask->path_map_d & info->path_map_d);
+	cctrl->antsel_a = (cctrl->antsel_a & ~mask->antsel_a) |
+			(mask->antsel_a & info->antsel_a);
+	cctrl->antsel_b = (cctrl->antsel_b & ~mask->antsel_b) |
+			(mask->antsel_b & info->antsel_b);
+	cctrl->antsel_c = (cctrl->antsel_c & ~mask->antsel_c) |
+			(mask->antsel_c & info->antsel_c);
+	cctrl->antsel_d = (cctrl->antsel_d & ~mask->antsel_d) |
+			(mask->antsel_d & info->antsel_d);
+
+	cctrl->addr_cam_index = (cctrl->addr_cam_index &
+				 ~mask->addr_cam_index) |
+			(mask->addr_cam_index & info->addr_cam_index);
+	cctrl->paid = (cctrl->paid & ~mask->paid) |
+			(mask->paid & info->paid);
+	cctrl->uldl = (cctrl->uldl & ~mask->uldl) |
+			(mask->uldl & info->uldl);
+	cctrl->doppler_ctrl = (cctrl->doppler_ctrl & ~mask->doppler_ctrl) |
+			(mask->doppler_ctrl & info->doppler_ctrl);
+	cctrl->nominal_pkt_padding =
+			(cctrl->nominal_pkt_padding &
+			 ~mask->nominal_pkt_padding) |
+			(mask->nominal_pkt_padding & info->nominal_pkt_padding);
+	cctrl->nominal_pkt_padding40 =
+			(cctrl->nominal_pkt_padding40 &
+			 ~mask->nominal_pkt_padding40) |
+			(mask->nominal_pkt_padding40 &
+			 info->nominal_pkt_padding40);
+	cctrl->nominal_pkt_padding80 =
+			(cctrl->nominal_pkt_padding80 &
+			 ~mask->nominal_pkt_padding80) |
+			(mask->nominal_pkt_padding80 &
+			 info->nominal_pkt_padding80);
+	cctrl->txpwr_tolerence =
+			(cctrl->txpwr_tolerence & ~mask->txpwr_tolerence) |
+			(mask->txpwr_tolerence & info->txpwr_tolerence);
+
+	cctrl->nc = (cctrl->nc & ~mask->nc) |
+			(mask->nc & info->nc);
+	cctrl->nr = (cctrl->nr & ~mask->nr) |
+			(mask->nr & info->nr);
+	cctrl->ng = (cctrl->ng & ~mask->ng) |
+			(mask->ng & info->ng);
+	cctrl->cb = (cctrl->cb & ~mask->cb) |
+			(mask->cb & info->cb);
+	cctrl->cs = (cctrl->cs & ~mask->cs) |
+			(mask->cs & info->cs);
+	cctrl->csi_txbf_en = (cctrl->csi_txbf_en & ~mask->csi_txbf_en) |
+			(mask->csi_txbf_en & info->csi_txbf_en);
+	cctrl->csi_stbc_en = (cctrl->csi_stbc_en & ~mask->csi_stbc_en) |
+			(mask->csi_stbc_en & info->csi_stbc_en);
+	cctrl->csi_ldpc_en = (cctrl->csi_ldpc_en & ~mask->csi_ldpc_en) |
+			(mask->csi_ldpc_en & info->csi_ldpc_en);
+	cctrl->csi_para_en = (cctrl->csi_para_en & ~mask->csi_para_en) |
+			(mask->csi_para_en & info->csi_para_en);
+	cctrl->csi_fix_rate = (cctrl->csi_fix_rate & ~mask->csi_fix_rate) |
+			(mask->csi_fix_rate & info->csi_fix_rate);
+	cctrl->csi_gi_ltf = (cctrl->csi_gi_ltf & ~mask->csi_gi_ltf) |
+			(mask->csi_gi_ltf & info->csi_gi_ltf);
+	cctrl->nominal_pkt_padding160 =
+			(cctrl->nominal_pkt_padding160 &
+			 ~mask->nominal_pkt_padding160) |
+			(mask->nominal_pkt_padding160 &
+			 info->nominal_pkt_padding160);
+	cctrl->csi_bw = (cctrl->csi_bw & ~mask->csi_bw) |
+			(mask->csi_bw & info->csi_bw);
+}
+
+void mac_upd_role_cctrl(struct mac_ax_adapter *adapter,
+			struct rtw_hal_mac_ax_cctl_info *info,
+			struct rtw_hal_mac_ax_cctl_info *mask, u8 macid)
+{
+	struct mac_role_tbl *role;
+
+	role = mac_role_srch(adapter, macid);
+	if (!role) {
+		PLTFM_MSG_ERR("role search failed\n");
+		return;
+	}
+	_set_role_cctrl(adapter, info, mask, &role->info.c_info);
+}
+
+u32 mac_tx_path_map_cfg(struct mac_ax_adapter *adapter, struct hal_txmap_cfg *cfg)
+{
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+	struct rtw_hal_mac_ax_cctl_info info;
+	struct rtw_hal_mac_ax_cctl_info mask;
+	u32 ret;
+
+	PLTFM_MEMSET(&mask, 0, sizeof(struct rtw_hal_mac_ax_cctl_info));
+	PLTFM_MEMSET(&info, 0, sizeof(struct rtw_hal_mac_ax_cctl_info));
+
+	info.ntx_path_en = cfg->n_tx_en;
+	info.path_map_a = cfg->map_a;
+	info.path_map_b = cfg->map_b;
+	info.path_map_c = cfg->map_c;
+	info.path_map_d = cfg->map_d;
+
+	mask.ntx_path_en = NTX_PATH_EN_MASK;
+	mask.path_map_a = PATH_MAP_MASK;
+	mask.path_map_b = PATH_MAP_MASK;
+	mask.path_map_c = PATH_MAP_MASK;
+	mask.path_map_d = PATH_MAP_MASK;
+
+	ret = mops->upd_cctl_info(adapter, &info, &mask, (u8)cfg->macid, TBL_WRITE_OP);
+
+	return MACSUCCESS;
+}
+
+u32 mac_upd_cctl_info(struct mac_ax_adapter *adapter,
+		      struct rtw_hal_mac_ax_cctl_info *info,
+		      struct rtw_hal_mac_ax_cctl_info *mask, u8 macid, u8 operation)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_cctlinfo_ud *tbl;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_cctlinfo_ud));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	tbl = (struct fwcmd_cctlinfo_ud *)buf;
+	tbl->dword0 =
+	cpu_to_le32(SET_WORD(macid, FWCMD_H2C_CCTLINFO_UD_MACID) |
+		    (operation ? FWCMD_H2C_CCTLINFO_UD_OP : 0));
+
+	tbl->dword1 =
+	cpu_to_le32(SET_WORD(info->datarate, FWCMD_H2C_CCTRL_DATARATE) |
+		    (info->force_txop ? FWCMD_H2C_CCTRL_FORCE_TXOP : 0) |
+		    SET_WORD(info->data_bw, FWCMD_H2C_CCTRL_DATA_BW) |
+		    SET_WORD(info->data_gi_ltf, FWCMD_H2C_CCTRL_DATA_GI_LTF) |
+		    (info->darf_tc_index ? FWCMD_H2C_CCTRL_DARF_TC_INDEX : 0) |
+		    SET_WORD(info->arfr_ctrl, FWCMD_H2C_CCTRL_ARFR_CTRL) |
+		    (info->acq_rpt_en ? FWCMD_H2C_CCTRL_ACQ_RPT_EN : 0) |
+		    (info->mgq_rpt_en ? FWCMD_H2C_CCTRL_MGQ_RPT_EN : 0) |
+		    (info->ulq_rpt_en ? FWCMD_H2C_CCTRL_ULQ_RPT_EN : 0) |
+		    (info->twtq_rpt_en ? FWCMD_H2C_CCTRL_TWTQ_RPT_EN : 0) |
+		    (info->disrtsfb ? FWCMD_H2C_CCTRL_DISRTSFB : 0) |
+		    (info->disdatafb ? FWCMD_H2C_CCTRL_DISDATAFB : 0) |
+		    (info->tryrate ? FWCMD_H2C_CCTRL_TRYRATE : 0) |
+		    SET_WORD(info->ampdu_density, FWCMD_H2C_CCTRL_AMPDU_DENSITY));
+
+	if (info->rtsrate >= MAC_AX_VHT_NSS1_MCS0) // for Fool-proof mechanism
+		info->rtsrate = MAC_AX_OFDM6;
+
+	tbl->dword2 =
+	cpu_to_le32(SET_WORD(info->data_rty_lowest_rate,
+			     FWCMD_H2C_CCTRL_DATA_RTY_LOWEST_RATE) |
+		    (info->ampdu_time_sel ? FWCMD_H2C_CCTRL_AMPDU_TIME_SEL : 0) |
+		    (info->ampdu_len_sel ? FWCMD_H2C_CCTRL_AMPDU_LEN_SEL : 0) |
+		    (info->rts_txcnt_lmt_sel ? FWCMD_H2C_CCTRL_RTS_TXCNT_LMT_SEL :
+		     0) |
+		    SET_WORD(info->rts_txcnt_lmt, FWCMD_H2C_CCTRL_RTS_TXCNT_LMT) |
+		    SET_WORD(info->rtsrate, FWCMD_H2C_CCTRL_RTSRATE) |
+		    (info->vcs_stbc ? FWCMD_H2C_CCTRL_VCS_STBC : 0) |
+		    SET_WORD(info->rts_rty_lowest_rate,
+			     FWCMD_H2C_CCTRL_RTS_RTY_LOWEST_RATE));
+
+	tbl->dword3 =
+	cpu_to_le32(SET_WORD(info->data_tx_cnt_lmt, FWCMD_H2C_CCTRL_DATA_TX_CNT_LMT) |
+		    (info->data_txcnt_lmt_sel ? FWCMD_H2C_CCTRL_DATA_TXCNT_LMT_SEL :
+		     0) |
+		    (info->max_agg_num_sel ? FWCMD_H2C_CCTRL_MAX_AGG_NUM_SEL : 0) |
+		    (info->rts_en ? FWCMD_H2C_CCTRL_RTS_EN : 0) |
+		    (info->cts2self_en ? FWCMD_H2C_CCTRL_CTS2SELF_EN : 0) |
+		    SET_WORD(info->cca_rts, FWCMD_H2C_CCTRL_CCA_RTS) |
+		    (info->hw_rts_en ? FWCMD_H2C_CCTRL_HW_RTS_EN : 0) |
+		    SET_WORD(info->rts_drop_data_mode,
+			     FWCMD_H2C_CCTRL_RTS_DROP_DATA_MODE) |
+		    (info->preld_en ? FWCMD_H2C_CCTRL_PRELD_EN : 0) |
+		    SET_WORD(info->ampdu_max_len, FWCMD_H2C_CCTRL_AMPDU_MAX_LEN) |
+		    (info->ul_mu_dis ? FWCMD_H2C_CCTRL_UL_MU_DIS : 0) |
+		    SET_WORD(info->ampdu_max_time, FWCMD_H2C_CCTRL_AMPDU_MAX_TIME));
+
+	if (info->max_agg_num > 0)
+		info->max_agg_num -= 1;
+
+	tbl->dword4 =
+	cpu_to_le32(SET_WORD(info->max_agg_num, FWCMD_H2C_CCTRL_MAX_AGG_NUM) |
+		    SET_WORD(info->ba_bmap, FWCMD_H2C_CCTRL_BA_BMAP) |
+		    SET_WORD(info->vo_lftime_sel, FWCMD_H2C_CCTRL_VO_LFTIME_SEL) |
+		    SET_WORD(info->vi_lftime_sel, FWCMD_H2C_CCTRL_VI_LFTIME_SEL) |
+		    SET_WORD(info->be_lftime_sel, FWCMD_H2C_CCTRL_BE_LFTIME_SEL) |
+		    SET_WORD(info->bk_lftime_sel, FWCMD_H2C_CCTRL_BK_LFTIME_SEL) |
+		    SET_WORD(info->sectype, FWCMD_H2C_CCTRL_SECTYPE));
+
+	tbl->dword5 =
+	cpu_to_le32(SET_WORD(info->multi_port_id, FWCMD_H2C_CCTRL_MULTI_PORT_ID) |
+		    (info->bmc ? FWCMD_H2C_CCTRL_BMC : 0) |
+		    SET_WORD(info->mbssid, FWCMD_H2C_CCTRL_MBSSID) |
+		    (info->navusehdr ? FWCMD_H2C_CCTRL_NAVUSEHDR : 0) |
+		    SET_WORD(info->txpwr_mode, FWCMD_H2C_CCTRL_TXPWR_MODE) |
+		    (info->data_dcm ? FWCMD_H2C_CCTRL_DATA_DCM : 0) |
+		    (info->data_er ? FWCMD_H2C_CCTRL_DATA_ER : 0) |
+		    (info->data_ldpc ? FWCMD_H2C_CCTRL_DATA_LDPC : 0) |
+		    (info->data_stbc ? FWCMD_H2C_CCTRL_DATA_STBC : 0) |
+		    (info->a_ctrl_bqr ? FWCMD_H2C_CCTRL_A_CTRL_BQR : 0) |
+		    (info->a_ctrl_uph ? FWCMD_H2C_CCTRL_A_CTRL_UPH : 0) |
+		    (info->a_ctrl_bsr ? FWCMD_H2C_CCTRL_A_CTRL_BSR : 0) |
+		    (info->a_ctrl_cas ? FWCMD_H2C_CCTRL_A_CTRL_CAS : 0) |
+		    (info->data_bw_er ? FWCMD_H2C_CCTRL_DATA_BW_ER : 0) |
+		    (info->lsig_txop_en ? FWCMD_H2C_CCTRL_LSIG_TXOP_EN : 0) |
+		    (info->ctrl_cnt_vld ? FWCMD_H2C_CCTRL_CTRL_CNT_VLD : 0) |
+		    SET_WORD(info->ctrl_cnt, FWCMD_H2C_CCTRL_CTRL_CNT));
+
+	tbl->dword6 =
+	cpu_to_le32(SET_WORD(info->resp_ref_rate, FWCMD_H2C_CCTRL_RESP_REF_RATE) |
+		    (info->all_ack_support ? FWCMD_H2C_CCTRL_ALL_ACK_SUPPORT : 0) |
+		    (info->bsr_queue_size_format ?
+		     FWCMD_H2C_CCTRL_BSR_QUEUE_SIZE_FORMAT : 0) |
+		    SET_WORD(info->ntx_path_en, FWCMD_H2C_CCTRL_NTX_PATH_EN) |
+		    SET_WORD(info->path_map_a, FWCMD_H2C_CCTRL_PATH_MAP_A) |
+		    SET_WORD(info->path_map_b, FWCMD_H2C_CCTRL_PATH_MAP_B) |
+		    SET_WORD(info->path_map_c, FWCMD_H2C_CCTRL_PATH_MAP_C) |
+		    SET_WORD(info->path_map_d, FWCMD_H2C_CCTRL_PATH_MAP_D) |
+		    (info->antsel_a ? FWCMD_H2C_CCTRL_ANTSEL_A : 0) |
+		    (info->antsel_b ? FWCMD_H2C_CCTRL_ANTSEL_B : 0) |
+		    (info->antsel_c ? FWCMD_H2C_CCTRL_ANTSEL_C : 0) |
+		    (info->antsel_d ? FWCMD_H2C_CCTRL_ANTSEL_D : 0));
+
+	tbl->dword7 =
+	cpu_to_le32(SET_WORD(info->addr_cam_index, FWCMD_H2C_CCTRL_ADDR_CAM_INDEX) |
+		    SET_WORD(info->paid, FWCMD_H2C_CCTRL_PAID) |
+		    (info->uldl ? FWCMD_H2C_CCTRL_ULDL : 0) |
+		    SET_WORD(info->doppler_ctrl, FWCMD_H2C_CCTRL_DOPPLER_CTRL) |
+		    SET_WORD(info->nominal_pkt_padding,
+			     FWCMD_H2C_CCTRL_NOMINAL_PKT_PADDING) |
+		    SET_WORD(info->nominal_pkt_padding40,
+			     FWCMD_H2C_CCTRL_NOMINAL_PKT_PADDING40) |
+		    SET_WORD(info->nominal_pkt_padding80,
+			     FWCMD_H2C_CCTRL_NOMINAL_PKT_PADDING80) |
+		    SET_WORD(info->txpwr_tolerence, FWCMD_H2C_CCTRL_TXPWR_TOLERENCE));
+
+	tbl->dword8 =
+	cpu_to_le32(SET_WORD(info->nc, FWCMD_H2C_CCTRL_NC) |
+		    SET_WORD(info->nr, FWCMD_H2C_CCTRL_NR) |
+		    SET_WORD(info->ng, FWCMD_H2C_CCTRL_NG) |
+		    SET_WORD(info->cb, FWCMD_H2C_CCTRL_CB) |
+		    SET_WORD(info->cs, FWCMD_H2C_CCTRL_CS) |
+		    (info->csi_txbf_en ? FWCMD_H2C_CCTRL_CSI_TXBF_EN : 0) |
+		    (info->csi_stbc_en ? FWCMD_H2C_CCTRL_CSI_STBC_EN : 0) |
+		    (info->csi_ldpc_en ? FWCMD_H2C_CCTRL_CSI_LDPC_EN : 0) |
+		    (info->csi_para_en ? FWCMD_H2C_CCTRL_CSI_PARA_EN : 0) |
+		    SET_WORD(info->csi_fix_rate, FWCMD_H2C_CCTRL_CSI_FIX_RATE) |
+		    SET_WORD(info->csi_gi_ltf, FWCMD_H2C_CCTRL_CSI_GI_LTF) |
+		    SET_WORD(info->nominal_pkt_padding160,
+			     FWCMD_H2C_CCTRL_NOMINAL_PKT_PADDING160) |
+		    SET_WORD(info->csi_bw, FWCMD_H2C_CCTRL_CSI_BW));
+
+	tbl->dword9 =
+	cpu_to_le32(SET_WORD(mask->datarate, FWCMD_H2C_CCTRL_DATARATE) |
+		    (mask->force_txop ? FWCMD_H2C_CCTRL_FORCE_TXOP : 0) |
+		    SET_WORD(mask->data_bw, FWCMD_H2C_CCTRL_DATA_BW) |
+		    SET_WORD(mask->data_gi_ltf, FWCMD_H2C_CCTRL_DATA_GI_LTF) |
+		    (mask->darf_tc_index ? FWCMD_H2C_CCTRL_DARF_TC_INDEX : 0) |
+		    SET_WORD(mask->arfr_ctrl, FWCMD_H2C_CCTRL_ARFR_CTRL) |
+		    (mask->acq_rpt_en ? FWCMD_H2C_CCTRL_ACQ_RPT_EN : 0) |
+		    (mask->mgq_rpt_en ? FWCMD_H2C_CCTRL_MGQ_RPT_EN : 0) |
+		    (mask->ulq_rpt_en ? FWCMD_H2C_CCTRL_ULQ_RPT_EN : 0) |
+		    (mask->twtq_rpt_en ? FWCMD_H2C_CCTRL_TWTQ_RPT_EN : 0) |
+		    (mask->disrtsfb ? FWCMD_H2C_CCTRL_DISRTSFB : 0) |
+		    (mask->disdatafb ? FWCMD_H2C_CCTRL_DISDATAFB : 0) |
+		    (mask->tryrate ? FWCMD_H2C_CCTRL_TRYRATE : 0) |
+		    SET_WORD(mask->ampdu_density, FWCMD_H2C_CCTRL_AMPDU_DENSITY));
+
+	tbl->dword10 =
+	cpu_to_le32(SET_WORD(mask->data_rty_lowest_rate,
+			     FWCMD_H2C_CCTRL_DATA_RTY_LOWEST_RATE) |
+		    (mask->ampdu_time_sel ? FWCMD_H2C_CCTRL_AMPDU_TIME_SEL : 0) |
+		    (mask->ampdu_len_sel ? FWCMD_H2C_CCTRL_AMPDU_LEN_SEL : 0) |
+		    (mask->rts_txcnt_lmt_sel ? FWCMD_H2C_CCTRL_RTS_TXCNT_LMT_SEL :
+		     0) |
+		    SET_WORD(mask->rts_txcnt_lmt, FWCMD_H2C_CCTRL_RTS_TXCNT_LMT) |
+		    SET_WORD(mask->rtsrate, FWCMD_H2C_CCTRL_RTSRATE) |
+		    (mask->vcs_stbc ? FWCMD_H2C_CCTRL_VCS_STBC : 0) |
+		    SET_WORD(mask->rts_rty_lowest_rate,
+			     FWCMD_H2C_CCTRL_RTS_RTY_LOWEST_RATE));
+
+	tbl->dword11 =
+	cpu_to_le32(SET_WORD(mask->data_tx_cnt_lmt, FWCMD_H2C_CCTRL_DATA_TX_CNT_LMT) |
+		    (mask->data_txcnt_lmt_sel ? FWCMD_H2C_CCTRL_DATA_TXCNT_LMT_SEL :
+		     0) |
+		    (mask->max_agg_num_sel ? FWCMD_H2C_CCTRL_MAX_AGG_NUM_SEL : 0) |
+		    (mask->rts_en ? FWCMD_H2C_CCTRL_RTS_EN : 0) |
+		    (mask->cts2self_en ? FWCMD_H2C_CCTRL_CTS2SELF_EN : 0) |
+		    SET_WORD(mask->cca_rts, FWCMD_H2C_CCTRL_CCA_RTS) |
+		    (mask->hw_rts_en ? FWCMD_H2C_CCTRL_HW_RTS_EN : 0) |
+		    SET_WORD(mask->rts_drop_data_mode,
+			     FWCMD_H2C_CCTRL_RTS_DROP_DATA_MODE) |
+		    (mask->preld_en ? FWCMD_H2C_CCTRL_PRELD_EN : 0) |
+		    SET_WORD(mask->ampdu_max_len, FWCMD_H2C_CCTRL_AMPDU_MAX_LEN) |
+		    (mask->ul_mu_dis ? FWCMD_H2C_CCTRL_UL_MU_DIS : 0) |
+		    SET_WORD(mask->ampdu_max_time, FWCMD_H2C_CCTRL_AMPDU_MAX_TIME));
+
+	tbl->dword12 =
+	cpu_to_le32(SET_WORD(mask->max_agg_num, FWCMD_H2C_CCTRL_MAX_AGG_NUM) |
+		    SET_WORD(mask->ba_bmap, FWCMD_H2C_CCTRL_BA_BMAP) |
+		    SET_WORD(mask->vo_lftime_sel, FWCMD_H2C_CCTRL_VO_LFTIME_SEL) |
+		    SET_WORD(mask->vi_lftime_sel, FWCMD_H2C_CCTRL_VI_LFTIME_SEL) |
+		    SET_WORD(mask->be_lftime_sel, FWCMD_H2C_CCTRL_BE_LFTIME_SEL) |
+		    SET_WORD(mask->bk_lftime_sel, FWCMD_H2C_CCTRL_BK_LFTIME_SEL) |
+		    SET_WORD(mask->sectype, FWCMD_H2C_CCTRL_SECTYPE));
+
+	tbl->dword13 =
+	cpu_to_le32(SET_WORD(mask->multi_port_id, FWCMD_H2C_CCTRL_MULTI_PORT_ID) |
+		    (mask->bmc ? FWCMD_H2C_CCTRL_BMC : 0) |
+		    SET_WORD(mask->mbssid, FWCMD_H2C_CCTRL_MBSSID) |
+		    (mask->navusehdr ? FWCMD_H2C_CCTRL_NAVUSEHDR : 0) |
+		    SET_WORD(mask->txpwr_mode, FWCMD_H2C_CCTRL_TXPWR_MODE) |
+		    (mask->data_dcm ? FWCMD_H2C_CCTRL_DATA_DCM : 0) |
+		    (mask->data_er ? FWCMD_H2C_CCTRL_DATA_ER : 0) |
+		    (mask->data_ldpc ? FWCMD_H2C_CCTRL_DATA_LDPC : 0) |
+		    (mask->data_stbc ? FWCMD_H2C_CCTRL_DATA_STBC : 0) |
+		    (mask->a_ctrl_bqr ? FWCMD_H2C_CCTRL_A_CTRL_BQR : 0) |
+		    (mask->a_ctrl_uph ? FWCMD_H2C_CCTRL_A_CTRL_UPH : 0) |
+		    (mask->a_ctrl_bsr ? FWCMD_H2C_CCTRL_A_CTRL_BSR : 0) |
+		    (mask->a_ctrl_cas ? FWCMD_H2C_CCTRL_A_CTRL_CAS : 0) |
+		    (mask->data_bw_er ? FWCMD_H2C_CCTRL_DATA_BW_ER : 0) |
+		    (mask->lsig_txop_en ? FWCMD_H2C_CCTRL_LSIG_TXOP_EN : 0) |
+		    (mask->ctrl_cnt_vld ? FWCMD_H2C_CCTRL_CTRL_CNT_VLD : 0) |
+		    SET_WORD(mask->ctrl_cnt, FWCMD_H2C_CCTRL_CTRL_CNT));
+
+	tbl->dword14 =
+	cpu_to_le32(SET_WORD(mask->resp_ref_rate, FWCMD_H2C_CCTRL_RESP_REF_RATE) |
+		    (mask->all_ack_support ? FWCMD_H2C_CCTRL_ALL_ACK_SUPPORT : 0) |
+		    (mask->bsr_queue_size_format ?
+		     FWCMD_H2C_CCTRL_BSR_QUEUE_SIZE_FORMAT : 0) |
+		    SET_WORD(mask->ntx_path_en, FWCMD_H2C_CCTRL_NTX_PATH_EN) |
+		    SET_WORD(mask->path_map_a, FWCMD_H2C_CCTRL_PATH_MAP_A) |
+		    SET_WORD(mask->path_map_b, FWCMD_H2C_CCTRL_PATH_MAP_B) |
+		    SET_WORD(mask->path_map_c, FWCMD_H2C_CCTRL_PATH_MAP_C) |
+		    SET_WORD(mask->path_map_d, FWCMD_H2C_CCTRL_PATH_MAP_D) |
+		    (mask->antsel_a ? FWCMD_H2C_CCTRL_ANTSEL_A : 0) |
+		    (mask->antsel_b ? FWCMD_H2C_CCTRL_ANTSEL_B : 0) |
+		    (mask->antsel_c ? FWCMD_H2C_CCTRL_ANTSEL_C : 0) |
+		    (mask->antsel_d ? FWCMD_H2C_CCTRL_ANTSEL_D : 0));
+
+	tbl->dword15 =
+	cpu_to_le32(SET_WORD(mask->addr_cam_index, FWCMD_H2C_CCTRL_ADDR_CAM_INDEX) |
+		    SET_WORD(mask->paid, FWCMD_H2C_CCTRL_PAID) |
+		    (mask->uldl ? FWCMD_H2C_CCTRL_ULDL : 0) |
+		    SET_WORD(mask->doppler_ctrl, FWCMD_H2C_CCTRL_DOPPLER_CTRL) |
+		    SET_WORD(mask->nominal_pkt_padding,
+			     FWCMD_H2C_CCTRL_NOMINAL_PKT_PADDING) |
+		    SET_WORD(mask->nominal_pkt_padding40,
+			     FWCMD_H2C_CCTRL_NOMINAL_PKT_PADDING40) |
+		    SET_WORD(mask->nominal_pkt_padding80,
+			     FWCMD_H2C_CCTRL_NOMINAL_PKT_PADDING80) |
+		    SET_WORD(mask->txpwr_tolerence,
+			     FWCMD_H2C_CCTRL_TXPWR_TOLERENCE));
+
+	tbl->dword16 =
+	cpu_to_le32(SET_WORD(mask->nc, FWCMD_H2C_CCTRL_NC) |
+		    SET_WORD(mask->nr, FWCMD_H2C_CCTRL_NR) |
+		    SET_WORD(mask->ng, FWCMD_H2C_CCTRL_NG) |
+		    SET_WORD(mask->cb, FWCMD_H2C_CCTRL_CB) |
+		    SET_WORD(mask->cs, FWCMD_H2C_CCTRL_CS) |
+		    (mask->csi_txbf_en ? FWCMD_H2C_CCTRL_CSI_TXBF_EN : 0) |
+		    (mask->csi_stbc_en ? FWCMD_H2C_CCTRL_CSI_STBC_EN : 0) |
+		    (mask->csi_ldpc_en ? FWCMD_H2C_CCTRL_CSI_LDPC_EN : 0) |
+		    (mask->csi_para_en ? FWCMD_H2C_CCTRL_CSI_PARA_EN : 0) |
+		    SET_WORD(mask->csi_fix_rate, FWCMD_H2C_CCTRL_CSI_FIX_RATE) |
+		    SET_WORD(mask->csi_gi_ltf, FWCMD_H2C_CCTRL_CSI_GI_LTF) |
+		    SET_WORD(mask->nominal_pkt_padding160,
+			     FWCMD_H2C_CCTRL_NOMINAL_PKT_PADDING160) |
+		    SET_WORD(mask->csi_bw, FWCMD_H2C_CCTRL_CSI_BW));
+
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		ret = h2c_pkt_set_hdr(adapter, h2cb,
+				      FWCMD_TYPE_H2C,
+				      FWCMD_H2C_CAT_MAC,
+				      FWCMD_H2C_CL_FR_EXCHG,
+				      FWCMD_H2C_FUNC_CCTLINFO_UD,
+				      0,
+				      1);
+		if (ret)
+			goto fail;
+
+		// Return MACSUCCESS if h2c aggregation is enabled and enqueued successfully.
+		// The H2C shall be sent by mac_h2c_agg_tx.
+		ret = h2c_agg_enqueue(adapter, h2cb);
+		if (ret == MACSUCCESS)
+			return MACSUCCESS;
+
+		ret = h2c_pkt_build_txd(adapter, h2cb);
+		if (ret)
+			goto fail;
+
+		#if MAC_AX_PHL_H2C
+		ret = PLTFM_TX(h2cb);
+		#else
+		ret = PLTFM_TX(h2cb->data, h2cb->len);
+		#endif
+		if (ret)
+			goto fail;
+	} else {
+#if MAC_AX_FEATURE_DBGPKG
+		if (operation)
+			cctl_info_debug_write(adapter, macid,
+					      (struct fwcmd_cctlinfo_ud *)buf);
+#else
+		return MACFWNONRDY;
+#endif
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	mac_upd_role_cctrl(adapter, info, mask, macid);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_set_fixmode_mib(struct mac_ax_adapter *adapter,
+			struct mac_ax_fixmode_para *info)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_fixmode_para_tblud *tbl;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_fixmode_para_tblud));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	PLTFM_MEMSET(buf, 0, sizeof(struct fwcmd_fixmode_para_tblud));
+
+	tbl = (struct fwcmd_fixmode_para_tblud *)buf;
+	tbl->dword0 =
+	cpu_to_le32((info->tbl_hdr.rw ? FWCMD_H2C_TBLUD_R_W : 0) |
+		    SET_WORD(info->tbl_hdr.idx, FWCMD_H2C_TBLUD_MACID_GROUP) |
+		    SET_WORD(info->tbl_hdr.offset, FWCMD_H2C_TBLUD_OFFSET) |
+		    SET_WORD(info->tbl_hdr.len, FWCMD_H2C_TBLUD_LENGTH) |
+		    (info->tbl_hdr.type ? FWCMD_H2C_TBLUD_TYPE : 0) |
+		    SET_WORD(CLASS_F2P_FIXMODE_PARA,
+			     FWCMD_H2C_TBLUD_TABLE_CLASS));
+
+	tbl->dword1 =
+	cpu_to_le32((info->force_sumuru_en ?
+		     FWCMD_H2C_FIXMODE_PARA_FORCE_SUMURU_EN : 0) |
+		    (info->forcesu ?
+		     FWCMD_H2C_FIXMODE_PARA_FORCESU : 0) |
+		    (info->forcemu ?
+		     FWCMD_H2C_FIXMODE_PARA_FORCEMU : 0) |
+		    (info->forceru ?
+		     FWCMD_H2C_FIXMODE_PARA_FORCERU : 0) |
+		    (info->fix_fe_su_en ?
+		     FWCMD_H2C_FIXMODE_PARA_FIX_FE_SU_EN : 0) |
+		    (info->fix_fe_vhtmu_en ?
+		     FWCMD_H2C_FIXMODE_PARA_FIX_FE_VHTMU_EN : 0) |
+		    (info->fix_fe_hemu_en ?
+		     FWCMD_H2C_FIXMODE_PARA_FIX_FE_HEMU_EN : 0) |
+		    (info->fix_fe_heru_en ?
+		     FWCMD_H2C_FIXMODE_PARA_FIX_FE_HERU_EN : 0) |
+		    (info->fix_fe_ul_en ?
+		     FWCMD_H2C_FIXMODE_PARA_FIX_FE_UL_EN : 0) |
+		    (info->fix_frame_seq_su ?
+		     FWCMD_H2C_FIXMODE_PARA_FIX_FRAME_SEQ_SU : 0) |
+		    (info->fix_frame_seq_vhtmu ?
+		     FWCMD_H2C_FIXMODE_PARA_FIX_FRAME_SEQ_VHTMU : 0) |
+		    (info->fix_frame_seq_hemu ?
+		     FWCMD_H2C_FIXMODE_PARA_FIX_FRAME_SEQ_HEMU : 0) |
+		    (info->fix_frame_seq_heru ?
+		     FWCMD_H2C_FIXMODE_PARA_FIX_FRAME_SEQ_HERU : 0) |
+		    (info->fix_frame_seq_ul ?
+		     FWCMD_H2C_FIXMODE_PARA_FIX_FRAME_SEQ_UL : 0) |
+		    (info->is_dlruhwgrp ?
+		     FWCMD_H2C_FIXMODE_PARA_IS_DLRUHWGRP : 0) |
+		    (info->is_ulruhwgrp ?
+		     FWCMD_H2C_FIXMODE_PARA_IS_ULRUHWGRP : 0) |
+		    SET_WORD(info->prot_type_su,
+			     FWCMD_H2C_FIXMODE_PARA_PROT_TYPE_SU) |
+		    SET_WORD(info->prot_type_vhtmu,
+			     FWCMD_H2C_FIXMODE_PARA_PROT_TYPE_VHTMU) |
+		    SET_WORD(info->resp_type_vhtmu,
+			     FWCMD_H2C_FIXMODE_PARA_RESP_TYPE_VHTMU) |
+		    SET_WORD(info->prot_type_hemu,
+			     FWCMD_H2C_FIXMODE_PARA_PROT_TYPE_HEMU));
+
+	tbl->dword2 =
+	cpu_to_le32(SET_WORD(info->resp_type_hemu,
+			     FWCMD_H2C_FIXMODE_PARA_RESP_TYPE_HEMU) |
+		    SET_WORD(info->prot_type_heru,
+			     FWCMD_H2C_FIXMODE_PARA_PROT_TYPE_HERU) |
+		    SET_WORD(info->resp_type_heru,
+			     FWCMD_H2C_FIXMODE_PARA_RESP_TYPE_HERU) |
+		    SET_WORD(info->ul_prot_type,
+			     FWCMD_H2C_FIXMODE_PARA_UL_PROT_TYPE) |
+		    SET_WORD(info->rugrpid,
+			     FWCMD_H2C_FIXMODE_PARA_RUGRPID) |
+		    SET_WORD(info->mugrpid,
+			     FWCMD_H2C_FIXMODE_PARA_MUGRPID) |
+		    SET_WORD(info->ulgrpid,
+			     FWCMD_H2C_FIXMODE_PARA_ULGRPID));
+
+	tbl->dword3 =
+	cpu_to_le32((info->fix_txcmdnum_en ?
+		     FWCMD_H2C_FIXMODE_PARA_FIX_TXCMDNUM_EN : 0) |
+		    (info->force_to_one ?
+		    FWCMD_H2C_FIXMODE_PARA_FORCE_TO_ONE : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FR_EXCHG,
+			      FWCMD_H2C_FUNC_TBLUD,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 rst_bacam(struct mac_ax_adapter *adapter, struct rst_bacam_info *info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, cnt;
+
+	val32 = MAC_REG_R32(R_AX_RESPBA_CAM_CTRL);
+	switch (info->type) {
+	case BACAM_RST_ALL:
+		val32 = SET_CLR_WORD(val32, S_AX_BACAM_RST_ALL, B_AX_BACAM_RST);
+		break;
+	case BACAM_RST_ENT:
+		val32 = SET_CLR_WORD(val32, info->ent, B_AX_SRC_ENTRY_IDX);
+		MAC_REG_W32(R_AX_RESPBA_CAM_CTRL, val32);
+
+		val32 = SET_CLR_WORD(val32, S_AX_BACAM_RST_ENT, B_AX_BACAM_RST);
+		break;
+	}
+	MAC_REG_W32(R_AX_RESPBA_CAM_CTRL, val32);
+
+	cnt = BACAM_RST_DLY_CNT;
+	while (cnt) {
+		val32 = MAC_REG_R32(R_AX_RESPBA_CAM_CTRL);
+		if (GET_FIELD(val32, B_AX_BACAM_RST) == S_AX_BACAM_RST_DONE)
+			break;
+		PLTFM_DELAY_US(BACAM_RST_DLY_US);
+		cnt--;
+	}
+
+	if (!cnt) {
+		PLTFM_MSG_ERR("[ERR]bacam rst timeout %X\n", val32);
+		return MACPOLLTO;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_bacam_avl_std_entry_idx(struct mac_ax_adapter *adapter,
+				struct mac_ax_avl_std_bacam_info *info)
+{
+	#ifdef PHL_FEATURE_AP
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8851B:
+			info->min_avl_idx = BACAM_MIN_ENTRY_IDX_8851B;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_8851B;
+			return MACSUCCESS;
+		case MAC_AX_CHIP_ID_8852B:
+			info->min_avl_idx = BACAM_MIN_ENTRY_IDX_8852B;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_8852B;
+			return MACSUCCESS;
+		case MAC_AX_CHIP_ID_8852C:
+			info->min_avl_idx = BACAM_INIT_TMP_ENTRY_NUM_AP_8852C;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_8852C;
+			break;
+		case MAC_AX_CHIP_ID_8192XB:
+			info->min_avl_idx = BACAM_INIT_TMP_ENTRY_NUM_AP_8192XB;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_8192XB;
+			break;
+		case MAC_AX_CHIP_ID_8852D:
+			info->min_avl_idx = BACAM_INIT_TMP_ENTRY_NUM_AP_8852D;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_8852D;
+			break;
+		case MAC_AX_CHIP_ID_8851E: // for Fool-proof mechanism
+			info->min_avl_idx = BACAM_MAX_RU_SUPPORT_B0_NON_AP;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_8851E;
+			break;
+		case MAC_BE_CHIP_ID_1115E:// for Fool-proof mechanism
+			info->min_avl_idx = BACAM_MIN_ENTRY_IDX_DEF_1115E;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_DEF_1115E;
+			break;
+		default:
+			PLTFM_MSG_ERR("[ERR] chip not support, idx search fail");
+			return MACNOITEM;
+		}
+		#ifdef PHL_FEATURE_NIC // for Fool-proof mechanism in hvtool
+			info->min_avl_idx = info->min_avl_idx + BACAM_MAX_RU_SUPPORT_B1_STA;
+		#endif
+	#else // for NiC mode setting
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8851B:
+			info->min_avl_idx = BACAM_MIN_ENTRY_IDX_8851B;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_8851B;
+			break;
+		case MAC_AX_CHIP_ID_8852B:
+			info->min_avl_idx = BACAM_MIN_ENTRY_IDX_8852B;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_8852B;
+			break;
+		case MAC_AX_CHIP_ID_8852C:
+			info->min_avl_idx = BACAM_INIT_TMP_ENTRY_NUM_STA_8852C;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_8852C;
+			break;
+		case MAC_AX_CHIP_ID_8192XB:
+			info->min_avl_idx = BACAM_INIT_TMP_ENTRY_NUM_STA_8192XB;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_8192XB;
+			break;
+		case MAC_AX_CHIP_ID_8852D:
+			info->min_avl_idx = BACAM_INIT_TMP_ENTRY_NUM_STA_8852D;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_8852D;
+			break;
+		case MAC_AX_CHIP_ID_8851E:
+			info->min_avl_idx = BACAM_INIT_TMP_ENTRY_NUM_STA_8851E;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_8851E;
+			break;
+		case MAC_BE_CHIP_ID_1115E:// for Fool-proof mechanism
+			info->min_avl_idx = BACAM_MIN_ENTRY_IDX_DEF_1115E;
+			info->max_avl_idx = BACAM_MAX_ENTRY_IDX_DEF_1115E;
+			break;
+		default:
+			PLTFM_MSG_ERR("[ERR] chip not support, idx search fail");
+			return MACNOITEM;
+		}
+	#endif
+	return MACSUCCESS;
+}
+
+u32 mac_bacam_init(struct mac_ax_adapter *adapter)
+{
+	u32 ret = MACSUCCESS;
+	u8 entry_num_b0, entry_num_b1, i;
+	struct mac_ax_bacam_info info = { 0x0 };
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+
+#ifdef PHL_FEATURE_AP
+	switch (adapter->hw_info->chip_id) {
+	case MAC_AX_CHIP_ID_8852C:
+		entry_num_b0 = BACAM_MAX_RU_SUPPORT_B0_AP_8852C;
+		entry_num_b1 = BACAM_MAX_RU_SUPPORT_B1_AP_8852C;
+		break;
+	case MAC_AX_CHIP_ID_8192XB:
+		entry_num_b0 = BACAM_MAX_RU_SUPPORT_B0_AP_8192XB;
+		entry_num_b1 = BACAM_MAX_RU_SUPPORT_B1_AP_8192XB;
+		break;
+	case MAC_AX_CHIP_ID_8852D:
+		entry_num_b0 = BACAM_MAX_RU_SUPPORT_B0_AP_8852D;
+		entry_num_b1 = BACAM_MAX_RU_SUPPORT_B1_AP_8852D;
+		break;
+	case MAC_AX_CHIP_ID_8851E:  // for Fool-proof mechanism
+		entry_num_b0 = BACAM_MAX_RU_SUPPORT_B0_NON_AP;
+		entry_num_b1 = BACAM_MAX_RU_SUPPORT_B1_NON_AP;
+		break;
+	case MAC_AX_CHIP_ID_8852A:
+	case MAC_AX_CHIP_ID_8852B:
+	case MAC_AX_CHIP_ID_8851B:
+	case MAC_BE_CHIP_ID_1115E:
+		return MACSUCCESS;
+	default:
+		PLTFM_MSG_ERR("[ERR] chip not support, bacam init fail");
+		return MACNOITEM;
+	}
+	#ifdef PHL_FEATURE_NIC // for Fool-proof mechanism in hvtool
+		entry_num_b1 = BACAM_MAX_RU_SUPPORT_B1_STA;
+	#endif
+#else // for NiC mode setting
+	switch (adapter->hw_info->chip_id) {
+	case MAC_AX_CHIP_ID_8852C:
+	case MAC_AX_CHIP_ID_8192XB:
+	case MAC_AX_CHIP_ID_8852D:
+	case MAC_AX_CHIP_ID_8851E:
+		entry_num_b0 = BACAM_MAX_RU_SUPPORT_B0_STA;
+		entry_num_b1 = BACAM_MAX_RU_SUPPORT_B1_STA;
+		break;
+	case MAC_AX_CHIP_ID_8852A:
+	case MAC_AX_CHIP_ID_8852B:
+	case MAC_AX_CHIP_ID_8851B:
+	case MAC_BE_CHIP_ID_1115E:
+		return MACSUCCESS;
+	default:
+		PLTFM_MSG_ERR("[ERR] chip not support, bacam init fail");
+		return MACNOITEM;
+	}
+#endif
+	// set band 0 temp entry
+	info.band_sel = 0;
+	for (i = 0; i < entry_num_b0; i++) {
+		info.entry_idx_v1 = i;
+		info.uid_value = i;
+		ret = mops->bacam_info(adapter, &info);
+		if (ret)
+			goto fail;
+	}
+
+#ifdef PHL_FEATURE_NIC
+	// set band 1 temp entry
+	info.band_sel = 1;
+	for (i = 0; i < entry_num_b1; i++) {
+		info.entry_idx_v1 = entry_num_b0 + i;
+		info.uid_value = i;
+		ret = mops->bacam_info(adapter, &info);
+		if (ret)
+			goto fail;
+	}
+#endif
+
+	return ret;
+
+fail:
+	PLTFM_MSG_ERR("[ERR]bacam init fail %d\n", ret);
+	return ret;
+}
+
+u32 mac_bacam_info(struct mac_ax_adapter *adapter,
+		   struct mac_ax_bacam_info *info)
+{
+	u32 ret = MACSUCCESS;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_ba_cam *tbl;
+	struct mac_ax_avl_std_bacam_info idx_info = {0x0};
+	struct mac_ax_ops *mops = adapter_to_mac_ops(adapter);
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb) {
+		PLTFM_MSG_ERR("[ERR]h2cb_alloc\n");
+		return MACNPTR;
+	}
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_ba_cam));
+	if (!buf) {
+		ret = MACNOBUF;
+		PLTFM_MSG_ERR("[ERR]h2cb_put %d\n", ret);
+		goto fail;
+	}
+
+	tbl = (struct fwcmd_ba_cam *)buf;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		tbl->dword0 =
+			cpu_to_le32((info->valid ? FWCMD_H2C_BA_CAM_VALID : 0) |
+				    (info->init_req ? FWCMD_H2C_BA_CAM_INIT_REQ : 0) |
+				    SET_WORD(info->entry_idx, FWCMD_H2C_BA_CAM_ENTRY_IDX) |
+				    SET_WORD(info->tid, FWCMD_H2C_BA_CAM_TID) |
+				    SET_WORD(info->macid, FWCMD_H2C_BA_CAM_MACID) |
+				    SET_WORD(info->bmap_size, FWCMD_H2C_BA_CAM_BMAP_SIZE) |
+				    SET_WORD(info->ssn, FWCMD_H2C_BA_CAM_SSN)
+				    );
+	} else {
+		ret = mops->bacam_avl_std_entry_idx(adapter, &idx_info);
+		if (ret)
+			return ret;
+		if (idx_info.max_avl_idx < info->entry_idx_v1) {
+			ret = MACNOBUF;
+			PLTFM_MSG_ERR("[ERR]out of idx %d\n", ret);
+			goto fail;
+		}
+		tbl->dword0 =
+			cpu_to_le32((info->valid ? FWCMD_H2C_BA_CAM_VALID : 0) |
+				    (info->init_req ? FWCMD_H2C_BA_CAM_INIT_REQ : 0) |
+				    SET_WORD(info->tid, FWCMD_H2C_BA_CAM_TID) |
+				    SET_WORD(info->macid, FWCMD_H2C_BA_CAM_MACID) |
+				    SET_WORD(info->bmap_size, FWCMD_H2C_BA_CAM_BMAP_SIZE) |
+				    SET_WORD(info->ssn, FWCMD_H2C_BA_CAM_SSN)
+				    );
+		tbl->dword1 =
+			cpu_to_le32(SET_WORD(info->uid_value, FWCMD_H2C_BA_CAM_UID_VALUE) |
+				    (info->std_entry_en ? FWCMD_H2C_BA_CAM_STD_ENTRY_EN : 0) |
+				    (info->band_sel ? FWCMD_H2C_BA_CAM_BAND_SEL : 0) |
+				    SET_WORD(info->entry_idx_v1, FWCMD_H2C_BA_CAM_ENTRY_IDX_V1)
+				    );
+	}
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+			ret = mac_sram_dbg_write(adapter, info->entry_idx * BA_CAM_SIZE,
+						 tbl->dword0, BA_CAM_SEL);
+		} else {
+			ret = mac_sram_dbg_write(adapter, info->entry_idx_v1 * BA_CAM_SIZE,
+						 tbl->dword0, BA_CAM_SEL);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("[ERR]mac_sram_dbg_write %d\n", ret);
+				goto fail;
+			}
+			ret = mac_sram_dbg_write(adapter, (info->entry_idx_v1 * BA_CAM_SIZE) + 4,
+						 tbl->dword1, BA_CAM_SEL);
+		}
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]mac_sram_dbg_write %d\n", ret);
+			goto fail;
+		}
+	} else {
+		ret = h2c_pkt_set_hdr(adapter, h2cb,
+				      FWCMD_TYPE_H2C,
+				      FWCMD_H2C_CAT_MAC,
+				      FWCMD_H2C_CL_BA_CAM,
+				      FWCMD_H2C_FUNC_BA_CAM,
+				      0,
+				      1);
+
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]h2c_pkt_set_hdr %d\n", ret);
+			goto fail;
+		}
+
+		ret = h2c_pkt_build_txd(adapter, h2cb);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]h2c_pkt_build_txd %d\n", ret);
+			goto fail;
+		}
+		#if MAC_AX_PHL_H2C
+		ret = PLTFM_TX(h2cb);
+		#else
+		ret = PLTFM_TX(h2cb->data, h2cb->len);
+		#endif
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]PLTFM_TX %d\n", ret);
+			goto fail;
+		}
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_ss_dl_grp_upd(struct mac_ax_adapter *adapter,
+		      struct mac_ax_ss_dl_grp_upd *info)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_dl_grp_upd *tbl;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_dl_grp_upd));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	tbl = (struct fwcmd_dl_grp_upd *)buf;
+	tbl->dword0 =
+	cpu_to_le32((info->grp_valid ? FWCMD_H2C_DL_GRP_UPD_GRP_VALID : 0) |
+		    SET_WORD(info->grp_id, FWCMD_H2C_DL_GRP_UPD_GRP_ID) |
+		    (info->is_hwgrp ? FWCMD_H2C_DL_GRP_UPD_IS_HWGRP : 0) |
+		    SET_WORD(info->macid_u0, FWCMD_H2C_DL_GRP_UPD_MACID_U0) |
+		    SET_WORD(info->macid_u1, FWCMD_H2C_DL_GRP_UPD_MACID_U1) |
+		    SET_WORD(info->macid_u2, FWCMD_H2C_DL_GRP_UPD_MACID_U2));
+
+	tbl->dword1 =
+	cpu_to_le32(SET_WORD(info->macid_u3, FWCMD_H2C_DL_GRP_UPD_MACID_U3) |
+		    SET_WORD(info->macid_u4, FWCMD_H2C_DL_GRP_UPD_MACID_U4) |
+		    SET_WORD(info->macid_u5, FWCMD_H2C_DL_GRP_UPD_MACID_U5) |
+		    SET_WORD(info->macid_u6, FWCMD_H2C_DL_GRP_UPD_MACID_U6));
+
+	tbl->dword2 =
+	cpu_to_le32(SET_WORD(info->macid_u7, FWCMD_H2C_DL_GRP_UPD_MACID_U7) |
+		    SET_WORD(info->ac_bitmap_u0,
+			     FWCMD_H2C_DL_GRP_UPD_AC_BITMAP_U0) |
+		    SET_WORD(info->ac_bitmap_u1,
+			     FWCMD_H2C_DL_GRP_UPD_AC_BITMAP_U1) |
+		    SET_WORD(info->ac_bitmap_u2,
+			     FWCMD_H2C_DL_GRP_UPD_AC_BITMAP_U2) |
+		    SET_WORD(info->ac_bitmap_u3,
+			     FWCMD_H2C_DL_GRP_UPD_AC_BITMAP_U3) |
+		    SET_WORD(info->ac_bitmap_u4,
+			     FWCMD_H2C_DL_GRP_UPD_AC_BITMAP_U4) |
+		    SET_WORD(info->ac_bitmap_u5,
+			     FWCMD_H2C_DL_GRP_UPD_AC_BITMAP_U5));
+
+	tbl->dword3 =
+	cpu_to_le32(SET_WORD(info->ac_bitmap_u6,
+			     FWCMD_H2C_DL_GRP_UPD_AC_BITMAP_U6) |
+		    SET_WORD(info->ac_bitmap_u7,
+			     FWCMD_H2C_DL_GRP_UPD_AC_BITMAP_U7) |
+		    SET_WORD(info->next_protecttype,
+			     FWCMD_H2C_DL_GRP_UPD_NEXT_PROTECTTYPE) |
+		    SET_WORD(info->next_rsptype,
+			     FWCMD_H2C_DL_GRP_UPD_NEXT_RSPTYPE));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MEDIA_RPT,
+			      FWCMD_H2C_FUNC_DL_GRP_UPD,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_ss_ul_grp_upd(struct mac_ax_adapter *adapter,
+		      struct mac_ax_ss_ul_grp_upd *info)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_ul_grp_upd *tbl;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_ul_grp_upd));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	tbl = (struct fwcmd_ul_grp_upd *)buf;
+	tbl->dword0 =
+	cpu_to_le32(SET_WORD(info->macid_u0, FWCMD_H2C_UL_GRP_UPD_MACID_U0) |
+		    SET_WORD(info->macid_u1, FWCMD_H2C_UL_GRP_UPD_MACID_U1) |
+		    SET_WORD(info->grp_bitmap,
+			     FWCMD_H2C_UL_GRP_UPD_GRP_BITMAP));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MEDIA_RPT,
+			      FWCMD_H2C_FUNC_UL_GRP_UPD,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_ss_ul_sta_upd(struct mac_ax_adapter *adapter,
+		      struct mac_ax_ss_ul_sta_upd *info)
+{
+	u32 ret = 0;
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct fwcmd_ss_ulsta_upd *tbl;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_ss_ulsta_upd));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	tbl = (struct fwcmd_ss_ulsta_upd *)buf;
+	tbl->dword0 =
+	cpu_to_le32(SET_WORD(info->mode, FWCMD_H2C_SS_ULSTA_UPD_MODE));
+
+	tbl->dword1 =
+	cpu_to_le32(SET_WORD(info->macid[0], FWCMD_H2C_SS_ULSTA_UPD_MACID_U0) |
+		    SET_WORD(info->macid[1], FWCMD_H2C_SS_ULSTA_UPD_MACID_U1) |
+		    SET_WORD(info->macid[2], FWCMD_H2C_SS_ULSTA_UPD_MACID_U2) |
+		    SET_WORD(info->macid[3], FWCMD_H2C_SS_ULSTA_UPD_MACID_U3));
+
+	tbl->dword2 =
+	cpu_to_le32(SET_WORD(info->bsr_len[0],
+			     FWCMD_H2C_SS_ULSTA_UPD_BSR_LEN_U0) |
+		    SET_WORD(info->bsr_len[1],
+			     FWCMD_H2C_SS_ULSTA_UPD_BSR_LEN_U1));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FR_EXCHG,
+			      FWCMD_H2C_FUNC_SS_ULSTA_UPD,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_mu_sta_upd(struct mac_ax_adapter *adapter,
+		   struct mac_ax_mu_sta_upd *info)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_mu_sta_upd *tbl;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_mu_sta_upd));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	tbl = (struct fwcmd_mu_sta_upd *)buf;
+	tbl->dword0 =
+	cpu_to_le32(SET_WORD(info->macid, FWCMD_H2C_MU_STA_UPD_MACID) |
+		    SET_WORD(info->mu_idx, FWCMD_H2C_MU_STA_UPD_MU_IDX) |
+		    SET_WORD(info->prot_rsp_type[0].u.byte_type,
+			     FWCMD_H2C_MU_STA_UPD_PROT_RSP_TYPE_0) |
+		    SET_WORD(info->prot_rsp_type[1].u.byte_type,
+			     FWCMD_H2C_MU_STA_UPD_PROT_RSP_TYPE_1));
+
+	tbl->dword1 =
+	cpu_to_le32(SET_WORD(info->prot_rsp_type[2].u.byte_type,
+			     FWCMD_H2C_MU_STA_UPD_PROT_RSP_TYPE_2) |
+		    SET_WORD(info->prot_rsp_type[3].u.byte_type,
+			     FWCMD_H2C_MU_STA_UPD_PROT_RSP_TYPE_3) |
+		    SET_WORD(info->prot_rsp_type[4].u.byte_type,
+			     FWCMD_H2C_MU_STA_UPD_PROT_RSP_TYPE_4) |
+		    SET_WORD(info->mugrp_bitmap,
+			     FWCMD_H2C_MU_STA_UPD_MUGRP_BITMAP) |
+		    (info->dis_256q ?
+			     FWCMD_H2C_MU_STA_UPD_DIS_256Q : 0) |
+		    (info->dis_1024q ?
+			     FWCMD_H2C_MU_STA_UPD_DIS_1024Q : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_MEDIA_RPT,
+			      FWCMD_H2C_FUNC_MU_STA_UPD,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_wlaninfo_get(struct mac_ax_adapter *adapter,
+		     struct mac_ax_wlaninfo_get *info)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_wlaninfo_get *tbl;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_wlaninfo_get));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	tbl = (struct fwcmd_wlaninfo_get *)buf;
+	tbl->dword0 =
+	cpu_to_le32(SET_WORD(info->info_sel, FWCMD_H2C_WLANINFO_GET_INFO_SEL) |
+		    SET_WORD(info->argv0, FWCMD_H2C_WLANINFO_GET_ARGV0) |
+		    SET_WORD(info->argv1,
+			     FWCMD_H2C_WLANINFO_GET_ARGV1) |
+		    SET_WORD(info->argv2,
+			     FWCMD_H2C_WLANINFO_GET_ARGV2));
+
+	tbl->dword1 =
+	cpu_to_le32(SET_WORD(info->argv3,
+			     FWCMD_H2C_WLANINFO_GET_ARGV3) |
+		    SET_WORD(info->argv4,
+			     FWCMD_H2C_WLANINFO_GET_ARGV4) |
+		    SET_WORD(info->argv5,
+			     FWCMD_H2C_WLANINFO_GET_ARGV5) |
+		    SET_WORD(info->argv6,
+			     FWCMD_H2C_WLANINFO_GET_ARGV6));
+
+	tbl->dword2 =
+	cpu_to_le32(SET_WORD(info->argv7,
+			     FWCMD_H2C_WLANINFO_GET_ARGV7));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FR_EXCHG,
+			      FWCMD_H2C_FUNC_WLANINFO_GET,
+			      0,
+			      0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_dumpwlanc(struct mac_ax_adapter *adapter, struct mac_ax_dumpwlanc *para)
+{
+	struct mac_ax_wlaninfo_get info;
+	u32 ret = 0;
+
+	info.info_sel = DUMPWLANC;
+	info.argv0 = para->cmdid;
+	info.argv1 = 0;
+	info.argv2 = 0;
+	info.argv3 = 0;
+	info.argv4 = 0;
+	info.argv5 = 0;
+	info.argv6 = 0;
+	info.argv7 = 0;
+	ret = mac_wlaninfo_get(adapter, &info);
+
+	return ret;
+}
+
+u32 mac_dumpwlans(struct mac_ax_adapter *adapter, struct mac_ax_dumpwlans *para)
+{
+	struct mac_ax_wlaninfo_get info;
+	u32 ret = 0;
+
+	info.info_sel = DUMPWLANS;
+	info.argv0 = para->cmdid;
+	info.argv1 = para->macid_grp;
+	info.argv2 = 0;
+	info.argv3 = 0;
+	info.argv4 = 0;
+	info.argv5 = 0;
+	info.argv6 = 0;
+	info.argv7 = 0;
+	ret = mac_wlaninfo_get(adapter, &info);
+
+	return ret;
+}
+
+u32 mac_dumpwland(struct mac_ax_adapter *adapter, struct mac_ax_dumpwland *para)
+{
+	u32 ret = 0;
+	struct mac_ax_wlaninfo_get info;
+
+	info.argv0 = 0;
+	info.argv1 = 0;
+	info.argv2 = 0;
+	info.argv3 = 0;
+	info.argv4 = 0;
+	info.argv5 = 0;
+	info.argv6 = 0;
+	info.argv7 = 0;
+
+	info.info_sel = DUMPWLAND;
+	info.argv0 = para->cmdid;
+	if (para->cmdid == DLDECISION_SU_FORCEMU_FAIL) {
+		info.argv1 = para->macid[0];
+		info.argv2 = para->macid[1];
+		info.argv3 = 0;
+		info.argv4 = 0;
+		info.argv5 = 0;
+		info.argv6 = 0;
+		info.argv7 = 0;
+	} else if (para->cmdid == DLDECISION_SU_FORCERU_FAIL) {
+		info.argv1 = para->grp_type;
+		info.argv2 = para->grp_id;
+		info.argv3 = para->macid[0];
+		info.argv4 = para->macid[1];
+		info.argv5 = para->macid[2];
+		info.argv6 = para->macid[3];
+		info.argv7 = 0;
+	} else if (para->cmdid == DLDECISION_SU_MUTXTIME_PASS_MU_NOTSUPPORT) {
+		info.argv1 = para->macid[0];
+		info.argv2 = para->macid[1];
+		info.argv3 = 0;
+		info.argv4 = 0;
+		info.argv5 = 0;
+		info.argv6 = 0;
+		info.argv7 = 0;
+	} else if (para->cmdid == DLDECISION_SU_MUTXTIME_FAIL_RU_NOTSUPPORT) {
+		info.argv1 = para->grp_type;
+		info.argv2 = para->grp_id;
+		info.argv3 = para->macid[0];
+		info.argv4 = para->macid[1];
+		info.argv5 = para->macid[2];
+		info.argv6 = para->macid[3];
+		info.argv7 = 0;
+	} else if (para->cmdid == DLDECISION_MU_TPCOMPARE_RST) {
+		info.argv1 = para->macid[0];
+		info.argv2 = para->macid[1];
+		info.argv3 = 0;
+		info.argv4 = 0;
+		info.argv5 = 0;
+		info.argv6 = 0;
+		info.argv7 = 0;
+	} else if (para->cmdid == DLDECISION_RU_TPCOMPARE_RST) {
+		info.argv1 = para->grp_type;
+		info.argv2 = para->grp_id;
+		info.argv3 = para->macid[0];
+		info.argv4 = para->macid[1];
+		info.argv5 = para->macid[2];
+		info.argv6 = para->macid[3];
+		info.argv7 = 0;
+	} else if (para->cmdid == DLDECISION_SU_TPCOMPARE_RST) {
+		if (para->muru == 0) {
+			info.argv1 = para->macid[0];
+			info.argv2 = para->macid[1];
+			info.argv3 = 0;
+			info.argv4 = 0;
+			info.argv5 = 0;
+			info.argv6 = 0;
+			info.argv7 = 0;
+		} else {
+			info.argv1 = para->grp_type;
+			info.argv2 = para->grp_id;
+			info.argv3 = para->macid[0];
+			info.argv4 = para->macid[1];
+			info.argv5 = para->macid[2];
+			info.argv6 = para->macid[3];
+			info.argv7 = 0;
+		}
+	}
+	ret = mac_wlaninfo_get(adapter, &info);
+
+	return ret;
+}
+
+#if MAC_AX_FEATURE_DBGPKG
+u32 cctl_info_debug_write(struct mac_ax_adapter *adapter, u8 macid,
+			  struct fwcmd_cctlinfo_ud *tbl)
+{
+	u32 val;
+	u32 *data = &tbl->dword1, *msk = &tbl->dword9;
+	u8 i;
+
+	for (i = 0; i < (CCTL_INFO_SIZE >> 2); i++) {
+		val = mac_sram_dbg_read(adapter, macid * CCTL_INFO_SIZE + i * 4,
+					CMAC_TBL_SEL);
+		val = (val & ~(*(msk + i))) | ((*(data + i)) & (*(msk + i)));
+		mac_sram_dbg_write(adapter, macid * CCTL_INFO_SIZE + i * 4, val,
+				   CMAC_TBL_SEL);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 dctl_info_debug_write(struct mac_ax_adapter *adapter, u8 macid,
+			  struct fwcmd_dctlinfo_ud *tbl)
+{
+	mac_sram_dbg_write(adapter, macid * DCTL_INFO_SIZE, tbl->dword1,
+			   DMAC_TBL_SEL);
+	mac_sram_dbg_write(adapter, macid * DCTL_INFO_SIZE + 4, tbl->dword2,
+			   DMAC_TBL_SEL);
+	mac_sram_dbg_write(adapter, macid * DCTL_INFO_SIZE + 8, tbl->dword3,
+			   DMAC_TBL_SEL);
+	mac_sram_dbg_write(adapter, macid * DCTL_INFO_SIZE + 12, tbl->dword4,
+			   DMAC_TBL_SEL);
+
+	return MACSUCCESS;
+}
+#endif
+u32 mac_fw_status_cmd(struct mac_ax_adapter *adapter,
+		      struct mac_ax_fwstatus_payload *info)
+{
+	u32 ret = 0;
+	u32 i;
+	u8 *buf;
+	u32 *src, *dest;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct mac_ax_fwstatus_payload *tbl;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_fwstatus_payload));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	tbl = (struct mac_ax_fwstatus_payload *)buf;
+	src = (u32 *)info;
+	dest = (u32 *)tbl;
+	for (i = 0; i < (sizeof(struct mac_ax_fwstatus_payload) / 4); i++)
+		*(dest++) = cpu_to_le32(*(src++));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_TEST,
+			      FWCMD_H2C_CL_FW_STATUS_TEST,
+			      0,
+			      0,
+			      0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_fwc2h_ofdma_sts_parse(struct mac_ax_adapter *adapter,
+			      struct mac_ax_fwc2h_sts *fw_c2h_sts,
+			      u32 *content)
+{
+	u32 val;
+	u8 i;
+	u32 *dl_content = content + sizeof(struct mac_ax_tf_sts) / sizeof(u32);
+
+	if (!fw_c2h_sts || !content) {
+		PLTFM_MSG_ERR("[ERR]fwc2h_sts is null\n");
+		return MACNPTR;
+	}
+
+	val = le32_to_cpu(*(content++));
+	fw_c2h_sts->tfsts.user_num =
+		GET_FIELD(val, FWCMD_C2H_OFDMA_STS_TFSTS_USER_NUM);
+	fw_c2h_sts->tfsts.ru_su_per =
+		GET_FIELD(val, FWCMD_C2H_OFDMA_STS_TFSTS_RU_SU_PER);
+
+	for (i = 0; i < UL_PER_STA_DBGINFO_NUM; i++) {
+		val = le32_to_cpu(*(content++));
+		fw_c2h_sts->tfsts.tf_user_sts[i].macid =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_TFSTS_MACID);
+		fw_c2h_sts->tfsts.tf_user_sts[i].tb_rate =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_TFSTS_TB_RATE);
+		fw_c2h_sts->tfsts.tf_user_sts[i].tb_fail_per =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_TFSTS_TB_FAIL_PER);
+		fw_c2h_sts->tfsts.tf_user_sts[i].avg_tb_rssi =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_TFSTS_AVG_TB_RSSI);
+		val = le32_to_cpu(*(content++));
+		fw_c2h_sts->tfsts.tf_user_sts[i].cca_miss_per =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_TFSTS_CCA_MISS_PER);
+		fw_c2h_sts->tfsts.tf_user_sts[i].avg_uph =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_TFSTS_AVG_UPH);
+		fw_c2h_sts->tfsts.tf_user_sts[i].minflag_per =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_TFSTS_MINFLAG_PER);
+		fw_c2h_sts->tfsts.tf_user_sts[i].avg_tb_evm =
+		val = le32_to_cpu(*(content++));
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_TFSTS_AVG_TB_EVM);
+		fw_c2h_sts->tfsts.tf_user_sts[i].tf_num =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_TFSTS_TF_NUM);
+		val = le32_to_cpu(*(content++));
+		fw_c2h_sts->tfsts.tf_user_sts[i].bsr_len =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_TFSTS_BSR_LEN);
+	}
+
+	content =  dl_content;
+
+	val = le32_to_cpu(*(content++));
+	fw_c2h_sts->dlrusts.total_su_ru_ratio =
+		GET_FIELD(val, FWCMD_C2H_OFDMA_STS_DLRUSTS_TOTAL_SU_RU_RATIO);
+	fw_c2h_sts->dlrusts.total_ru_fail_ratio =
+		GET_FIELD(val, FWCMD_C2H_OFDMA_STS_DLRUSTS_TOTAL_RU_FAIL_RATIO);
+	fw_c2h_sts->dlrusts.total_su_fail_ratio =
+		GET_FIELD(val, FWCMD_C2H_OFDMA_STS_DLRUSTS_TOTAL_SU_FAIL_RATIO);
+	fw_c2h_sts->dlrusts.user_num =
+		GET_FIELD(val, FWCMD_C2H_OFDMA_STS_DLRUSTS_USER_NUM);
+
+	for (i = 0; i < fw_c2h_sts->dlrusts.user_num; i++) {
+		val = le32_to_cpu(*(content++));
+		fw_c2h_sts->dlrusts.user_sts[i].macid =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_DLRUSTS_MACID);
+		fw_c2h_sts->dlrusts.user_sts[i].su_ru_ratio =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_DLRUSTS_SU_RU_RATIO);
+		fw_c2h_sts->dlrusts.user_sts[i].su_fail_ratio =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_DLRUSTS_SU_FAIL);
+		fw_c2h_sts->dlrusts.user_sts[i].ru_fail_ratio =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_DLRUSTS_RU_FAIL);
+		val = le32_to_cpu(*(content++));
+		fw_c2h_sts->dlrusts.user_sts[i].ru_avg_agg =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_DLRUSTS_AVG_AGG);
+		fw_c2h_sts->dlrusts.user_sts[i].NSS =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_DLRUSTS_RU_RATE_NSS);
+		fw_c2h_sts->dlrusts.user_sts[i].MCS =
+			GET_FIELD(val, FWCMD_C2H_OFDMA_STS_DLRUSTS_RU_RATE_MCS);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_fw_ofdma_sts_en(struct mac_ax_adapter *adapter,
+			struct mac_ax_fwsts_para *fwsts_para)
+{
+	u32 ret = 0;
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u32 *para;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(u32));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	para = (u32 *)buf;
+	(*para) = cpu_to_le32((fwsts_para->en ? FWCMD_H2C_FW_STS_PARA_EN : 0) |
+			       SET_WORD(fwsts_para->intvl_ms,
+					FWCMD_H2C_FW_STS_PARA_INTVL_MS));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FR_EXCHG,
+			      FWCMD_H2C_FUNC_FW_STS_PARA,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret)
+		goto fail;
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tblupd.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tblupd.h
new file mode 100644
index 000000000000..83cb0d4ed0f9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tblupd.h
@@ -0,0 +1,766 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _TABLEUPD_H2C_H_
+#define _TABLEUPD_H2C_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+#include "trx_desc.h"
+#include "addr_cam.h"
+
+/*--------------------Define MACRO--------------------------------------*/
+#define DLRU_CLASS_GRP_TBL	0
+#define ULRU_CLASS_GRP_TBL	1
+#define CLASS_RUSTA_INFO	2
+#define DLRU_CLASS_FIXED_TBL	3
+#define ULRU_CLASS_FIXED_TBL	4
+#define CLASS_BA_INFOTBL	5
+#define CLASS_MUDECISION_PARA	6
+#define CLASS_UL_FIXINFO	7
+#define CLASS_F2P_FIXMODE_PARA	8
+
+#define BACAM_RST_DLY_CNT	1000
+#define BACAM_RST_DLY_US	1
+
+#define NTX_PATH_EN_MASK 0xf
+#define PATH_MAP_MASK 0x3
+
+#define BACAM_MIN_ENTRY_IDX_8852B 0
+#define BACAM_MAX_ENTRY_IDX_8852B 1
+#define BACAM_MIN_ENTRY_IDX_8851B 0
+#define BACAM_MAX_ENTRY_IDX_8851B 1
+#define BACAM_MAX_ENTRY_IDX_8851E 15
+#define BACAM_INIT_TMP_ENTRY_NUM_STA_8851E 2
+#define BACAM_MAX_ENTRY_IDX_8852C 15
+#define BACAM_INIT_TMP_ENTRY_NUM_AP_8852C 8
+#define BACAM_INIT_TMP_ENTRY_NUM_STA_8852C 2
+#define BACAM_MAX_ENTRY_IDX_8192XB 15
+#define BACAM_INIT_TMP_ENTRY_NUM_AP_8192XB 8
+#define BACAM_INIT_TMP_ENTRY_NUM_STA_8192XB 2
+#define BACAM_MAX_ENTRY_IDX_8852D 15
+#define BACAM_INIT_TMP_ENTRY_NUM_AP_8852D 8
+#define BACAM_INIT_TMP_ENTRY_NUM_STA_8852D 2
+#define BACAM_MAX_RU_SUPPORT_B0_AP_8852C 8
+#define BACAM_MAX_RU_SUPPORT_B1_AP_8852C 0
+#define BACAM_MAX_RU_SUPPORT_B0_AP_8192XB 8
+#define BACAM_MAX_RU_SUPPORT_B1_AP_8192XB 0
+#define BACAM_MAX_RU_SUPPORT_B0_AP_8852D 8
+#define BACAM_MAX_RU_SUPPORT_B1_AP_8852D 0
+#define BACAM_MIN_ENTRY_IDX_DEF_1115E 0
+#define BACAM_MAX_RU_SUPPORT_B0_NON_AP 1 //for Fool-proof mechanism
+#define BACAM_MAX_RU_SUPPORT_B1_NON_AP 0 //for Fool-proof mechanism
+#define BACAM_MAX_ENTRY_IDX_DEF_1115E 127
+#define BACAM_MAX_RU_SUPPORT_B0_STA 1
+#define BACAM_MAX_RU_SUPPORT_B1_STA 1
+/*--------------------Define Enum---------------------------------------*/
+
+/**
+ * @enum H2C_WLANINFO_SEL
+ *
+ * @brief H2C_WLANINFO_SEL
+ *
+ * @var H2C_WLANINFO_SEL::DUMPWLANC
+ * Please Place Description here.
+ * @var H2C_WLANINFO_SEL::DUMPWLANS
+ * Please Place Description here.
+ * @var H2C_WLANINFO_SEL::DUMPWLAND
+ * Please Place Description here.
+ */
+enum H2C_WLANINFO_SEL {
+	DUMPWLANC = BIT0,
+	DUMPWLANS = BIT1,
+	DUMPWLAND = BIT2
+};
+
+/**
+ * @enum DLDECISION_RESULT_TYPE
+ *
+ * @brief DLDECISION_RESULT_TYPE
+ *
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_SU_FORCESU
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_MU_FORCEMU
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_SU_FORCEMU_FAIL
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_SU_FORCERU_FAIL
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_SU_FORCERU_RUARST_RU2SU
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_RU_FORCERU_RUSRST_FIXTBL
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_RU_FORCERU
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_SU_WDINFO_USERATE
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_SU_PRINULLWD
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_MU_BYPASS_MUTPCOMPARE
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_SU_MUTXTIME_PASS_MU_NOTSUPPORT
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_SU_MUTXTIME_FAIL_RU_NOTSUPPORT
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_SU_RUARST_RU2SU
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_RU_RUARST_FIXTBL
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_MU_TPCOMPARE_RST
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_RU_TPCOMPARE_RST
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_SU_TPCOMPARE_RST
+ * Please Place Description here.
+ * @var DLDECISION_RESULT_TYPE::DLDECISION_MAX
+ * Please Place Description here.
+ */
+enum DLDECISION_RESULT_TYPE {
+	DLDECISION_SU_FORCESU = 0,
+	DLDECISION_MU_FORCEMU = 1,
+	DLDECISION_SU_FORCEMU_FAIL = 2,
+	DLDECISION_SU_FORCERU_FAIL = 3,
+	DLDECISION_SU_FORCERU_RUARST_RU2SU = 4,
+	DLDECISION_RU_FORCERU_RUSRST_FIXTBL = 5,
+	DLDECISION_RU_FORCERU = 6,
+	DLDECISION_SU_WDINFO_USERATE = 7,
+	DLDECISION_SU_PRINULLWD = 8,
+	DLDECISION_MU_BYPASS_MUTPCOMPARE = 9,
+	DLDECISION_SU_MUTXTIME_PASS_MU_NOTSUPPORT = 10,
+	DLDECISION_SU_MUTXTIME_FAIL_RU_NOTSUPPORT = 11,
+	DLDECISION_SU_RUARST_RU2SU = 12,
+	DLDECISION_RU_RUARST_FIXTBL = 13,
+	DLDECISION_MU_TPCOMPARE_RST = 14,
+	DLDECISION_RU_TPCOMPARE_RST = 15,
+	DLDECISION_SU_TPCOMPARE_RST = 16,
+	DLDECISION_MAX = 17
+};
+
+enum S_AX_BACAM_RST {
+	S_AX_BACAM_RST_DONE = 0,
+	S_AX_BACAM_RST_ENT,
+	S_AX_BACAM_RST_ALL,
+	S_AX_BACAM_RST_RSVD
+};
+
+enum BACAM_RST_TYPE {
+	BACAM_RST_ALL = 0,
+	BACAM_RST_ENT,
+};
+
+/*--------------------Define Struct-------------------------------------*/
+
+struct rst_bacam_info {
+	enum BACAM_RST_TYPE type;
+	u8 ent;
+};
+
+/**
+ * @brief mac_bacam_avl_std_entry_idx
+ *
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_bacam_avl_std_entry_idx(struct mac_ax_adapter *adapter,
+				struct mac_ax_avl_std_bacam_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup BA_Info
+ * @{
+ */
+
+/**
+ * @brief mac_bacam_init
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_bacam_init(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup BA_Info
+ * @{
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup BA_Info
+ * @{
+ */
+/**
+ * @brief mac_upd_ba_infotbl
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_upd_ba_infotbl(struct mac_ax_adapter *adapter,
+		       struct mac_ax_ba_infotbl *info);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup MU
+ * @{
+ */
+
+/**
+ * @brief mac_upd_mudecision_para
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_upd_mudecision_para(struct mac_ax_adapter *adapter,
+			    struct mac_ax_mudecision_para *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup UL
+ * @{
+ */
+
+/**
+ * @brief mac_upd_ul_fixinfo
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_upd_ul_fixinfo(struct mac_ax_adapter *adapter,
+		       struct rtw_phl_ax_ul_fixinfo *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup F2P_TestCmd
+ * @{
+ */
+
+/**
+ * @brief mac_f2p_test_cmd
+ *
+ * @param *adapter
+ * @param *info
+ * @param *f2pwd
+ * @param *ptxcmd
+ * @param *psigb_addr
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_f2p_test_cmd(struct mac_ax_adapter *adapter,
+		     struct mac_ax_f2p_test_para *info,
+		     struct mac_ax_f2p_wd *f2pwd,
+		     struct mac_ax_f2p_tx_cmd *ptxcmd,
+		     u8 *psigb_addr);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup DMAC_Table
+ * @{
+ */
+
+/**
+ * @brief mac_upd_dctl_info
+ *
+ * @param *adapter
+ * @param *info
+ * @param *mask
+ * @param macid
+ * @param operation
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_upd_dctl_info(struct mac_ax_adapter *adapter,
+		      struct mac_ax_dctl_info *info,
+		      struct mac_ax_dctl_info *mask, u8 macid, u8 operation);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_ShortCut
+ * @{
+ */
+
+/**
+ * @brief mac_upd_shcut_mhdr
+ *
+ * @param *adapter
+ * @param *info
+ * @param macid
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_upd_shcut_mhdr(struct mac_ax_adapter *adapter,
+		       struct mac_ax_shcut_mhdr *info, u8 macid);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup CMAC_Table
+ * @{
+ */
+
+/**
+ * @brief mac_upd_cctl_info
+ *
+ * @param *adapter
+ * @param *info
+ * @param *mask
+ * @param macid
+ * @param operation
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_upd_cctl_info(struct mac_ax_adapter *adapter,
+		      struct rtw_hal_mac_ax_cctl_info *info,
+		      struct rtw_hal_mac_ax_cctl_info *mask, u8 macid, u8 operation);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup FW_CommonInfo
+ * @{
+ */
+
+/**
+ * @brief mac_set_fixmode_mib
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_set_fixmode_mib(struct mac_ax_adapter *adapter,
+			struct mac_ax_fixmode_para *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup F2P_TestCmd
+ * @{
+ */
+
+/**
+ * @brief mac_snd_test_cmd
+ *
+ * @param *adapter
+ * @param *cmd_buf
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_snd_test_cmd(struct mac_ax_adapter *adapter,
+		     u8 *cmd_buf);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup BA_Info
+ * @{
+ */
+
+/**
+ * @brief rst_bacam
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 rst_bacam(struct mac_ax_adapter *adapter, struct rst_bacam_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Association
+ * @{
+ * @addtogroup BA_Info
+ * @{
+ */
+
+/**
+ * @brief mac_bacam_info
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_bacam_info(struct mac_ax_adapter *adapter,
+		   struct mac_ax_bacam_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup SU
+ * @{
+ */
+
+/**
+ * @brief mac_ss_dl_grp_upd
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_ss_dl_grp_upd(struct mac_ax_adapter *adapter,
+		      struct mac_ax_ss_dl_grp_upd *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup UL
+ * @{
+ */
+
+/**
+ * @brief mac_ss_ul_grp_upd
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_ss_ul_grp_upd(struct mac_ax_adapter *adapter,
+		      struct mac_ax_ss_ul_grp_upd *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup UL
+ * @{
+ */
+
+/**
+ * @brief mac_ss_ul_sta_upd
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_ss_ul_sta_upd(struct mac_ax_adapter *adapter,
+		      struct mac_ax_ss_ul_sta_upd *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup MU
+ * @{
+ */
+
+/**
+ * @brief mac_mu_sta_upd
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_mu_sta_upd(struct mac_ax_adapter *adapter,
+		   struct mac_ax_mu_sta_upd *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup FW_CommonInfo
+ * @{
+ */
+
+/**
+ * @brief mac_wlaninfo_get
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_wlaninfo_get(struct mac_ax_adapter *adapter,
+		     struct mac_ax_wlaninfo_get *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup FW_CommonInfo
+ * @{
+ */
+
+/**
+ * @brief mac_dumpwlanc
+ *
+ * @param *adapter
+ * @param *para
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dumpwlanc(struct mac_ax_adapter *adapter,
+		  struct mac_ax_dumpwlanc *para);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup FW_CommonInfo
+ * @{
+ */
+
+/**
+ * @brief mac_dumpwlans
+ *
+ * @param *adapter
+ * @param *para
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dumpwlans(struct mac_ax_adapter *adapter,
+		  struct mac_ax_dumpwlans *para);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup FW_CommonInfo
+ * @{
+ */
+
+/**
+ * @brief mac_dumpwland
+ *
+ * @param *adapter
+ * @param *para
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_dumpwland(struct mac_ax_adapter *adapter,
+		  struct mac_ax_dumpwland *para);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup CMAC_Table
+ * @{
+ */
+
+/**
+ * @brief cctl_info_debug_write
+ *
+ * @param *adapter
+ * @param macid
+ * @param *tbl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+#if MAC_AX_FEATURE_DBGPKG
+u32 cctl_info_debug_write(struct mac_ax_adapter *adapter, u8 macid,
+			  struct fwcmd_cctlinfo_ud *tbl);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup DMAC_Table
+ * @{
+ */
+
+/**
+ * @brief dctl_info_debug_write
+ *
+ * @param *adapter
+ * @param macid
+ * @param *tbl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 dctl_info_debug_write(struct mac_ax_adapter *adapter, u8 macid,
+			  struct fwcmd_dctlinfo_ud *tbl);
+/**
+ * @}
+ * @}
+ */
+
+#endif
+u32 mac_fw_status_cmd(struct mac_ax_adapter *adapter,
+		      struct mac_ax_fwstatus_payload *info);
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup CMAC_TABLE
+ * @{
+ */
+
+/**
+ * @brief mac_tx_path_map_cfg
+ *
+ * @param *adapter
+ * @param macid
+ * @param *tbl
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 mac_tx_path_map_cfg(struct mac_ax_adapter *adapter,
+			struct hal_txmap_cfg *cfg);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup fw_ofdma_info
+ * @{
+ */
+
+/**
+ * @brief mac_fwc2h_ofdma_sts_parse
+ *
+ * @param *adapter
+ * @param *fw_c2h_sts
+ * @param *content
+ * @return parse the ofdma info report by fw to mac_ax_fwc2h_sts structure
+ * @retval u32
+ */
+
+u32 mac_fwc2h_ofdma_sts_parse(struct mac_ax_adapter *adapter,
+			      struct mac_ax_fwc2h_sts *fw_c2h_sts,
+			      u32 *content);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup FrameExchange
+ * @{
+ * @addtogroup fw_ofdma_info
+ * @{
+ */
+
+/**
+ * @brief mac_fw_ofdma_sts_en
+ *
+ * @param *adapter
+ * @param *fwsts_para
+ * @return enable/disable and set period for fw report ofdma info
+ * @retval u32
+ */
+
+u32 mac_fw_ofdma_sts_en(struct mac_ax_adapter *adapter,
+			struct mac_ax_fwsts_para *fwsts_para);
+/**
+ * @}
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tcpip_checksum_offload.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tcpip_checksum_offload.c
new file mode 100644
index 000000000000..267d75840510
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tcpip_checksum_offload.c
@@ -0,0 +1,124 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "tcpip_checksum_offload.h"
+#if MAC_AX_FW_REG_OFLD
+u32 mac_tcpip_chksum_ofd(struct mac_ax_adapter *adapter,
+			 u8 en_tx_chksum_ofd, u8 en_rx_chksum_ofd)
+{
+	u32 ret = 0;
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+#else
+	struct h2c_buf *h2cb;
+#endif
+	struct mac_ax_en_tcpipchksum *content;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct mac_ax_en_tcpipchksum));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	content = (struct mac_ax_en_tcpipchksum *)buf;
+	content->en_tx_chksum_ofd = en_tx_chksum_ofd;
+	content->en_rx_chksum_ofd = en_rx_chksum_ofd;
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_FW_OFLD,
+			      FWCMD_H2C_FUNC_TCPIP_CHKSUM_OFFLOAD_REG,
+			      0,
+			      1);
+
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+#else
+u32 mac_tcpip_chksum_ofd(struct mac_ax_adapter *adapter,
+			 u8 en_tx_chksum_ofd, u8 en_rx_chksum_ofd)
+{
+	u32 val;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (en_tx_chksum_ofd) {
+		val = MAC_REG_R32(R_AX_TX_TCPIP_CHECKSUM_FUNCTION);
+		val |= B_AX_HDT_TCPIP_CHKSUM_EN;
+		MAC_REG_W32(R_AX_TX_TCPIP_CHECKSUM_FUNCTION, val);
+	} else {
+		val = MAC_REG_R32(R_AX_TX_TCPIP_CHECKSUM_FUNCTION);
+		val &= (~B_AX_HDT_TCPIP_CHKSUM_EN);
+		MAC_REG_W32(R_AX_TX_TCPIP_CHECKSUM_FUNCTION, val);
+	}
+
+	if (en_rx_chksum_ofd) {
+		val = MAC_REG_R32(R_AX_RX_TCPIP_CHECKSUM_FUNCTION);
+		val |= B_AX_HDR_TCPIP_CHKSUM_EN;
+		MAC_REG_W32((R_AX_RX_TCPIP_CHECKSUM_FUNCTION), val);
+	} else {
+		val = MAC_REG_R32((R_AX_RX_TCPIP_CHECKSUM_FUNCTION));
+		val &= (~B_AX_HDR_TCPIP_CHKSUM_EN);
+		MAC_REG_W32((R_AX_RX_TCPIP_CHECKSUM_FUNCTION), val);
+	}
+
+	return MACSUCCESS;
+}
+#endif
+u32 mac_chk_rx_tcpip_chksum_ofd(struct mac_ax_adapter *adapter,
+				u8 chksum_status)
+{
+	u8 chk_val = (chksum_status & 0xF0);
+
+	if (!(chk_val & MAC_AX_CHKOFD_TCP_CHKSUM_VLD))
+		return MAC_AX_CHKSUM_OFD_HW_NO_SUPPORT;
+
+	if (chk_val & MAC_AX_CHKOFD_TCP_CHKSUM_ERR)
+		return MAC_AX_CHKSUM_OFD_CHKSUM_ERR;
+
+	if (!(chk_val & MAC_AX_CHKOFD_RX_IS_TCP_UDP) &&
+	    !(chk_val & MAC_AX_CHKOFD_RX_IPV))
+		return MAC_AX_CHKSUM_OFD_IPV4_TCP_OK;
+
+	if (!(chk_val & MAC_AX_CHKOFD_RX_IS_TCP_UDP) &&
+	    (chk_val & MAC_AX_CHKOFD_RX_IPV))
+		return MAC_AX_CHKSUM_OFD_IPV6_TCP_OK;
+
+	if ((chk_val & MAC_AX_CHKOFD_RX_IS_TCP_UDP) &&
+	    !(chk_val & MAC_AX_CHKOFD_RX_IPV))
+		return MAC_AX_CHKSUM_OFD_IPV4_UDP_OK;
+
+	return MAC_AX_CHKSUM_OFD_IPV6_UDP_OK;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tcpip_checksum_offload.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tcpip_checksum_offload.h
new file mode 100644
index 000000000000..5ee6f04901d5
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/tcpip_checksum_offload.h
@@ -0,0 +1,94 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_TCPIP_CHECKSUM_OFFLOAD_H_
+#define _MAC_AX_TCPIP_CHECKSUM_OFFLOAD_H_
+
+#include "../type.h"
+#include "../mac_ax.h"
+
+/**
+ * @struct mac_ax_en_tcpipchksum
+ * @brief mac_ax_en_tcpipchksum
+ *
+ * @var mac_ax_en_tcpipchksum::en_tx_chksum_ofd
+ * Please Place Description here.
+ * @var mac_ax_en_tcpipchksum::en_rx_chksum_ofd
+ * Please Place Description here.
+ * @var mac_ax_en_tcpipchksum::rsvd0
+ * Please Place Description here.
+ */
+struct mac_ax_en_tcpipchksum {
+	/* dword0 */
+	u32 en_tx_chksum_ofd: 1;
+	u32 en_rx_chksum_ofd: 1;
+	u32 rsvd0: 30;
+};
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_ShortCut
+ * @{
+ */
+/**
+ * @brief mac_tcpip_chksum_ofd
+ *
+ * @param *adapter
+ * @param en_tx_chksum_ofd
+ * @param en_rx_chksum_ofd
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_tcpip_chksum_ofd(struct mac_ax_adapter *adapter,
+			 u8 en_tx_chksum_ofd,
+			 u8 en_rx_chksum_ofd);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_ShortCut
+ * @{
+ */
+
+/**
+ * @brief mac_chk_rx_tcpip_chksum_ofd
+ *
+ * @param *adapter
+ * @param chksum_status
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_chk_rx_tcpip_chksum_ofd(struct mac_ax_adapter *adapter,
+				u8 chksum_status);
+/**
+ * @}
+ * @}
+ */
+
+#define MAC_AX_CHKSUM_OFD_TX	0x1
+#define MAC_AX_CHKSUM_OFD_RX	0x2
+
+#define MAC_AX_CHKOFD_TCP_CHKSUM_ERR	BIT(4)
+#define MAC_AX_CHKOFD_RX_IS_TCP_UDP		BIT(6)
+#define MAC_AX_CHKOFD_RX_IPV			BIT(5)
+#define MAC_AX_CHKOFD_TCP_CHKSUM_VLD	BIT(7)
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trx_desc.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trx_desc.c
new file mode 100644
index 000000000000..99286f662d3a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trx_desc.c
@@ -0,0 +1,17 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "trx_desc.h"
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trx_desc.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trx_desc.h
new file mode 100644
index 000000000000..681259aafb33
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trx_desc.h
@@ -0,0 +1,47 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_TRX_DESC_H_
+#define _MAC_AX_TRX_DESC_H_
+
+#include "../type.h"
+#include "role.h"
+#if MAC_AX_8852A_SUPPORT
+#include "mac_8852a/trx_desc_8852a.h"
+#endif
+#if MAC_AX_8852B_SUPPORT
+#include "mac_8852b/trx_desc_8852b.h"
+#endif
+#if MAC_AX_8852C_SUPPORT
+#include "mac_8852c/trx_desc_8852c.h"
+#endif
+#if MAC_AX_8192XB_SUPPORT
+#include "mac_8192xb/trx_desc_8192xb.h"
+#endif
+#if MAC_AX_8851B_SUPPORT
+#include "mac_8851b/trx_desc_8851b.h"
+#endif
+#if MAC_AX_8851E_SUPPORT
+#include "mac_8851e/trx_desc_8851e.h"
+#endif
+#if MAC_AX_8852D_SUPPORT
+#include "mac_8852d/trx_desc_8852d.h"
+#endif
+#if MAC_AX_1115E_SUPPORT
+#include "mac_1115e/trx_desc_1115e.h"
+#endif
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trxcfg.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trxcfg.c
new file mode 100644
index 000000000000..1f4ff3076664
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trxcfg.c
@@ -0,0 +1,2342 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "trxcfg.h"
+#include "mac_priv.h"
+
+u32 check_mac_en(struct mac_ax_adapter *adapter, u8 band,
+		 enum mac_ax_hwmod_sel sel)
+{
+	if (adapter->sm.pwr != MAC_AX_PWR_ON)
+		return MACPROCERR;
+
+	if (sel == MAC_AX_DMAC_SEL) {
+		if (adapter->sm.dmac_func != MAC_AX_FUNC_ON)
+			return MACIOERRDMAC;
+	} else if (sel == MAC_AX_CMAC_SEL && band == MAC_AX_BAND_0) {
+		if (adapter->sm.cmac0_func != MAC_AX_FUNC_ON)
+			return MACIOERRCMAC0;
+	} else if (sel == MAC_AX_CMAC_SEL && band == MAC_AX_BAND_1) {
+		if (adapter->sm.cmac1_func != MAC_AX_FUNC_ON)
+			return MACIOERRCMAC1;
+	} else {
+		PLTFM_MSG_ERR("[ERR] mac sel: %d\n", sel);
+		return MACNOITEM;
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 scheduler_imr_enable(struct mac_ax_adapter *adapter, u8 band)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32, reg;
+
+		reg = band == MAC_AX_BAND_0 ?
+		      R_AX_SCHEDULE_ERR_IMR : R_AX_SCHEDULE_ERR_IMR_C1;
+		val32 = MAC_REG_R32(reg);
+		val32 &= ~(B_AX_SORT_NON_IDLE_ERR_INT_EN |
+			   B_AX_FSM_TIMEOUT_ERR_INT_EN);
+		val32 |= ((B_AX_SORT_NON_IDLE_ERR_INT_EN &
+			   SCHEDULER_SORT_NON_IDLE_ERR_SER_EN) |
+			  (B_AX_FSM_TIMEOUT_ERR_INT_EN &
+			   SCHEDULER_FSM_TIMEOUT_ERR_SER_EN));
+		MAC_REG_W32(reg, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 ptcl_imr_enable(struct mac_ax_adapter *adapter, u8 band)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32, reg;
+
+		reg = band == MAC_AX_BAND_0 ?
+		      R_AX_PTCL_IMR0 : R_AX_PTCL_IMR0_C1;
+		val32 = 0;
+		val32 &= ~(B_AX_FSM_TIMEOUT_ERR_INT_EN |
+			   B_AX_F2PCMDRPT_FULL_DROP_ERR_INT_EN |
+			   B_AX_TXPRT_FULL_DROP_ERR_INT_EN |
+			   B_AX_D_PKTID_ERR_INT_EN |
+			   B_AX_Q_PKTID_ERR_INT_EN |
+			   B_AX_BCNQ_ORDER_ERR_INT_EN |
+			   B_AX_TWTSP_QSEL_ERR_INT_EN |
+			   B_AX_F2PCMD_EMPTY_ERR_INT_EN |
+			   B_AX_TX_RECORD_PKTID_ERR_INT_EN |
+			   B_AX_TX_SPF_U3_PKTID_ERR_INT_EN |
+			   B_AX_TX_SPF_U2_PKTID_ERR_INT_EN |
+			   B_AX_TX_SPF_U1_PKTID_ERR_INT_EN |
+			   B_AX_RX_SPF_U0_PKTID_ERR_INT_EN |
+			   B_AX_F2PCMD_USER_ALLC_ERR_INT_EN |
+			   B_AX_F2PCMD_ASSIGN_PKTID_ERR_INT_EN |
+			   B_AX_F2PCMD_RD_PKTID_ERR_INT_EN |
+			   B_AX_F2PCMD_PKTID_ERR_INT_EN);
+
+		val32 |= ((B_AX_FSM_TIMEOUT_ERR_INT_EN &
+			   PTCL_FSM_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_F2PCMDRPT_FULL_DROP_ERR_INT_EN &
+			   PTCL_F2PCMDRPT_FULL_DROP_SER_EN) |
+			  (B_AX_TXPRT_FULL_DROP_ERR_INT_EN &
+			   PTCL_TXRPT_FULL_DROP_SER_EN) |
+			  (B_AX_D_PKTID_ERR_INT_EN &
+			   PTCL_D_PKTID_ERR_SER_EN) |
+			  (B_AX_Q_PKTID_ERR_INT_EN &
+			   PTCL_Q_PKTID_ERR_SER_EN) |
+			  (B_AX_BCNQ_ORDER_ERR_INT_EN &
+			   PTCL_BCNQ_ORDER_ERR_SER_EN) |
+			  (B_AX_TWTSP_QSEL_ERR_INT_EN &
+			   PTCL_TWTSP_QSEL_ERR_SER_EN) |
+			  (B_AX_F2PCMD_EMPTY_ERR_INT_EN &
+			   PTCL_F2PCMD_EMPTY_ERR_SER_EN) |
+			  (B_AX_TX_RECORD_PKTID_ERR_INT_EN &
+			   PTCL_TX_RECORD_PKTID_ERR_SER_EN) |
+			  (B_AX_TX_SPF_U3_PKTID_ERR_INT_EN &
+			   PTCL_TX_SPF_U3_PKTID_ERR_SER_EN) |
+			  (B_AX_TX_SPF_U2_PKTID_ERR_INT_EN &
+			   PTCL_TX_SPF_U2_PKTID_ERR_SER_EN) |
+			  (B_AX_TX_SPF_U1_PKTID_ERR_INT_EN &
+			   PTCL_TX_SPF_U1_PKTID_ERR_SER_EN) |
+			  (B_AX_RX_SPF_U0_PKTID_ERR_INT_EN &
+			   PTCL_TX_SPF_U0_PKTID_ERR_SER_EN) |
+			  (B_AX_F2PCMD_USER_ALLC_ERR_INT_EN &
+			   PTCL_F2PCMD_USER_ALLC_ERR_SER_EN) |
+			  (B_AX_F2PCMD_ASSIGN_PKTID_ERR_INT_EN &
+			   PTCL_F2PCMD_ASSIGN_PKTID_ERR_SER_EN) |
+			  (B_AX_F2PCMD_RD_PKTID_ERR_INT_EN &
+			   PTCL_F2PCMD_RD_PKTID_ERR_SER_EN) |
+			  (B_AX_F2PCMD_PKTID_ERR_INT_EN &
+			   PTCL_F2PCMD_PKTID_ERR_SER_EN));
+		MAC_REG_W32(reg, val32);
+	}
+#endif
+
+	return MACSUCCESS;
+}
+
+static u32 _patch_cmac_dma_err_fa(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+/*
+ * AP  Disable B_AX_STS_FSM_HANG_ERROR_IMR
+ * STA Enable  B_AX_STS_FSM_HANG_ERROR_IMR (Wait for "Scan+SER L0")
+ */
+		if (!chk_patch_cmac_dma_err_fa(adapter))
+			return B_AX_RXDATA_FSM_HANG_ERROR_IMR;
+	}
+#endif
+	return 0;
+}
+
+static u32 _patch_wmac_timer_src(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u16 val16;
+	u32 reg;
+
+	if (chk_patch_wmac_timer_src(adapter)) {
+		reg = band == MAC_AX_BAND_1 ?
+			R_AX_DLK_PROTECT_CTL_C1 : R_AX_DLK_PROTECT_CTL;
+		val16 = MAC_REG_R16(reg);
+		val16 = SET_CLR_WORD(val16, 0x0, B_AX_RX_DLK_CCA_TIME);
+		MAC_REG_W16(reg, val16);
+
+		reg = band == MAC_AX_BAND_1 ? R_AX_RCR_C1 : R_AX_RCR;
+		val16 = MAC_REG_R16(reg);
+		MAC_REG_W16(reg, val16 | BIT12);
+	}
+	return 0;
+}
+
+static u32 _patch_ss2f_path(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	/*52C&92XB has wrong hw default value*/
+	if (!chk_patch_ss2f_path(adapter))
+		return MACSUCCESS;
+
+	val32 = MAC_REG_R32(R_AX_SS2FINFO_PATH);
+	val32 = SET_CLR_WORD(val32, SS2F_PATH_WLCPU, B_AX_SS_DEST_QUEUE);
+	MAC_REG_W32(R_AX_SS2FINFO_PATH, val32);
+
+	return MACSUCCESS;
+}
+
+bool chk_patch_ss2f_path(struct mac_ax_adapter *adapter)
+{
+		switch (adapter->hw_info->chip_id) {
+		case MAC_AX_CHIP_ID_8192XB:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				case CCV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852A:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852B:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_DISABLE;
+				case CBV:
+						return PATCH_DISABLE;
+				case CCV:
+						return PATCH_DISABLE;
+				case CDV:
+						return PATCH_DISABLE;
+				default:
+						return PATCH_DISABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852C:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				case CBV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8851E:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+				break;
+		case MAC_AX_CHIP_ID_8852D:
+				switch (adapter->hw_info->cv) {
+				case CAV:
+						return PATCH_ENABLE;
+				default:
+						return PATCH_ENABLE;
+				}
+		default:
+				PLTFM_MSG_ALWAYS("Not Support IC version =%x\n",
+						 adapter->hw_info->cv);
+				return PATCH_DISABLE;
+		}
+}
+
+static u32 cdma_imr_enable(struct mac_ax_adapter *adapter, u8 band)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32, reg;
+
+		reg = band == MAC_AX_BAND_0 ? R_AX_DLE_CTRL : R_AX_DLE_CTRL_C1;
+		val32 = MAC_REG_R32(reg);
+		val32 &= ~(B_AX_RXSTS_FSM_HANG_ERROR_IMR |
+			   B_AX_RXDATA_FSM_HANG_ERROR_IMR |
+			   B_AX_NO_RESERVE_PAGE_ERR_IMR);
+		val32 |= ((B_AX_RXSTS_FSM_HANG_ERROR_IMR &
+			   CMAC_DMA_RXSTS_FSM_HANG_SER_EN) |
+			  (B_AX_RXDATA_FSM_HANG_ERROR_IMR &
+			   CMAC_DMA_RXDATA_FSM_HANG_SER_EN) |
+			  (B_AX_NO_RESERVE_PAGE_ERR_IMR &
+			   CMAC_DMA_NO_RSVD_PAGE_SER_EN));
+		val32 |= _patch_cmac_dma_err_fa(adapter);
+		MAC_REG_W32(reg, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 phy_intf_imr_enable(struct mac_ax_adapter *adapter, u8 band)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32;
+		u32 reg;
+
+		reg = band == MAC_AX_BAND_0 ?
+		      R_AX_PHYINFO_ERR_IMR : R_AX_PHYINFO_ERR_IMR_C1;
+		val32 = MAC_REG_R32(reg);
+		val32 &= ~(B_AX_PHY_TXON_TIMEOUT_INT_EN |
+			   B_AX_CCK_CCA_TIMEOUT_INT_EN |
+			   B_AX_OFDM_CCA_TIMEOUT_INT_EN |
+			   B_AX_DATA_ON_TIMEOUT_INT_EN |
+			   B_AX_STS_ON_TIMEOUT_INT_EN |
+			   B_AX_CSI_ON_TIMEOUT_INT_EN);
+
+		val32 |= ((B_AX_PHY_TXON_TIMEOUT_INT_EN &
+			   PHYINTF_PHY_TXON_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_CCK_CCA_TIMEOUT_INT_EN &
+			   PHYINTF_CCK_CCA_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_OFDM_CCA_TIMEOUT_INT_EN &
+			   PHYINTF_OFDM_CCA_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_DATA_ON_TIMEOUT_INT_EN &
+			   PHYINTF_DATA_ON_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_STS_ON_TIMEOUT_INT_EN &
+			   PHYINTF_STS_ON_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_CSI_ON_TIMEOUT_INT_EN &
+			   PHYINTF_CSI_ON_TIMEOUT_ERR_SER_EN));
+		MAC_REG_W32(reg, val32);
+	}
+#endif
+
+	return MACSUCCESS;
+}
+
+static u32 rmac_imr_enable(struct mac_ax_adapter *adapter, u8 band)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32, reg;
+
+		reg = band == MAC_AX_BAND_0 ?
+		      R_AX_RMAC_ERR_ISR : R_AX_RMAC_ERR_ISR_C1;
+		val32 = MAC_REG_R32(reg);
+		val32 &= ~(B_AX_RMAC_CCA_TO_IDLE_TIMEOUT_INT_EN |
+			   B_AX_RMAC_DATA_ON_TO_IDLE_TIMEOUT_INT_EN |
+			   B_AX_RMAC_DMA_TIMEOUT_INT_EN |
+			   B_AX_RMAC_CCA_TIMEOUT_INT_EN |
+			   B_AX_RMAC_DATA_ON_TIMEOUT_INT_EN |
+			   B_AX_RMAC_CSI_TIMEOUT_INT_EN |
+			   B_AX_RMAC_RX_TIMEOUT_INT_EN |
+			   B_AX_RMAC_RX_CSI_TIMEOUT_INT_EN);
+
+		val32 |= ((B_AX_RMAC_CCA_TO_IDLE_TIMEOUT_INT_EN &
+			   RMAC_CCA_TO_RX_IDLE_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_RMAC_DATA_ON_TO_IDLE_TIMEOUT_INT_EN &
+			   RMAC_DATA_ON_TO_RX_IDLE_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_RMAC_DMA_TIMEOUT_INT_EN &
+			   RMAC_DMA_WRITE_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_RMAC_CCA_TIMEOUT_INT_EN &
+			   RMAC_CCA_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_RMAC_DATA_ON_TIMEOUT_INT_EN &
+			   RMAC_DATA_ON_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_RMAC_CSI_TIMEOUT_INT_EN &
+			   RMAC_CSI_DATA_ON_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_RMAC_RX_TIMEOUT_INT_EN &
+			   RMAC_RX_FSM_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_RMAC_RX_CSI_TIMEOUT_INT_EN &
+			   RMAC_CSI_MODE_TIMEOUT_ERR_SER_EN));
+		MAC_REG_W32(reg, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 tmac_imr_enable(struct mac_ax_adapter *adapter, u8 band)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32, reg;
+
+		reg = band == MAC_AX_BAND_0 ?
+		      R_AX_TMAC_ERR_IMR_ISR : R_AX_TMAC_ERR_IMR_ISR_C1;
+		val32 = MAC_REG_R32(reg);
+		val32 &= ~(B_AX_TMAC_MACTX_INT_EN |
+			   B_AX_TMAC_TXCTL_INT_EN |
+			   B_AX_TMAC_RESP_INT_EN |
+			   B_AX_TMAC_TXPLCP_INT_EN);
+
+		val32 |= ((B_AX_TMAC_MACTX_INT_EN &
+			   TMAC_MACTX_TIME_ERR_SER_EN) |
+			  (B_AX_TMAC_TXCTL_INT_EN &
+			   TMAC_TRXPTCL_TXCTL_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_TMAC_RESP_INT_EN &
+			   TMAC_RESPONSE_TXCTL_TIMEOUT_ERR_SER_EN) |
+			  (B_AX_TMAC_TXPLCP_INT_EN &
+			   TMAC_TX_PLCP_INFO_ERR_SER_EN));
+		MAC_REG_W32(reg, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 wdrls_imr_enable(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32;
+
+		val32 = MAC_REG_R32(R_AX_WDRLS_ERR_IMR);
+		val32 &= ~(B_AX_WDRLS_CTL_WDPKTID_ISNULL_ERR_INT_EN |
+			   B_AX_WDRLS_CTL_PLPKTID_ISNULL_ERR_INT_EN |
+			   B_AX_WDRLS_CTL_FRZTO_ERR_INT_EN |
+			   B_AX_WDRLS_PLEBREQ_TO_ERR_INT_EN |
+			   B_AX_WDRLS_PLEBREQ_PKTID_ISNULL_ERR_INT_EN |
+			   B_AX_WDRLS_RPT0_AGGNUM0_ERR_INT_EN |
+			   B_AX_WDRLS_RPT0_FRZTO_ERR_INT_EN |
+			   B_AX_WDRLS_RPT1_AGGNUM0_ERR_INT_EN |
+			   B_AX_WDRLS_RPT1_FRZTO_ERR_INT_EN);
+
+		val32 |= ((B_AX_WDRLS_CTL_WDPKTID_ISNULL_ERR_INT_EN &
+			   DMAC_WDRLS_CTL_WDPKTID_ISNULL_ERR_SER_EN) |
+			  (B_AX_WDRLS_CTL_PLPKTID_ISNULL_ERR_INT_EN &
+			   DMAC_WDRLS_CTL_PLPKTID_ISNULL_ERR_SER_EN) |
+			  (B_AX_WDRLS_CTL_FRZTO_ERR_INT_EN &
+			   DMAC_WDRLS_CTL_FRZTO_ERR_SER_EN) |
+			  (B_AX_WDRLS_PLEBREQ_TO_ERR_INT_EN &
+			   DMAC_WDRLS_PLEBREQ_TO_ERR_SER_EN) |
+			  (B_AX_WDRLS_PLEBREQ_PKTID_ISNULL_ERR_INT_EN &
+			   DMAC_WDRLS_PLEBREQ_PKTID_ISNULL_ERR_SER_EN) |
+			  (B_AX_WDRLS_RPT0_AGGNUM0_ERR_INT_EN &
+			   DMAC_WDRLS_RPT0_AGGNUM0_ERR_SER_EN) |
+			  (B_AX_WDRLS_RPT0_FRZTO_ERR_INT_EN &
+			   DMAC_WDRLS_RPT0_FRZTO_ERR_SER_EN) |
+			  (B_AX_WDRLS_RPT1_AGGNUM0_ERR_INT_EN &
+			   DMAC_WDRLS_RPT1_AGGNUM0_ERR_SER_EN) |
+			  (B_AX_WDRLS_RPT1_FRZTO_ERR_INT_EN &
+			   DMAC_WDRLS_RPT1_FRZTO_ERR_SER_EN));
+		MAC_REG_W32(R_AX_WDRLS_ERR_IMR, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 wsec_imr_enable(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32;
+
+		val32 = MAC_REG_R32(R_AX_SEC_DEBUG);
+		val32 &= ~(B_AX_IMR_ERROR);
+
+		val32 |= ((B_AX_IMR_ERROR &
+			   DMAC_IMR_ERROR));
+		MAC_REG_W32(R_AX_SEC_DEBUG, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 mpdu_trx_imr_enable(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32;
+
+		/* MDPU Processor TX */
+		val32 = MAC_REG_R32(R_AX_MPDU_TX_ERR_IMR);
+		val32 &= ~(B_AX_TX_GET_ERRPKTID_INT_EN |
+			   B_AX_TX_NXT_ERRPKTID_INT_EN |
+			   B_AX_TX_MPDU_SIZE_ZERO_INT_EN |
+			   B_AX_TX_OFFSET_ERR_INT_EN |
+			   B_AX_TX_HDR3_SIZE_ERR_INT_EN);
+
+		val32 |= ((B_AX_TX_GET_ERRPKTID_INT_EN &
+			   DMAC_TX_GET_ERRPKTID_SER_EN) |
+			  (B_AX_TX_NXT_ERRPKTID_INT_EN &
+			   DMAC_TX_NXT_ERRPKTID_SER_EN) |
+			  (B_AX_TX_MPDU_SIZE_ZERO_INT_EN &
+			   DMAC_TX_MPDU_SIZE_ZERO_SER_EN) |
+			  (B_AX_TX_OFFSET_ERR_INT_EN &
+			   DMAC_TX_OFFSET_ERR_SER_EN) |
+			  (B_AX_TX_HDR3_SIZE_ERR_INT_EN &
+			   DMAC_TX_HDR3_SIZE_ERR_SER_EN));
+		MAC_REG_W32(R_AX_MPDU_TX_ERR_IMR, val32);
+
+		/* MDPU Processor RX */
+		val32 = MAC_REG_R32(R_AX_MPDU_RX_ERR_IMR);
+		val32 &= ~(B_AX_GETPKTID_ERR_INT_EN |
+			   B_AX_MHDRLEN_ERR_INT_EN |
+			   B_AX_RPT_ERR_INT_EN);
+
+		val32 |= ((B_AX_GETPKTID_ERR_INT_EN &
+			   DMAC_GETPKTID_ERR_SER_EN) |
+			  (B_AX_MHDRLEN_ERR_INT_EN &
+			   DMAC_MHDRLEN_ERR_SER_EN) |
+			  (B_AX_RPT_ERR_INT_EN &
+			   DMAC_RPT_ERR_SER_EN));
+		MAC_REG_W32(R_AX_MPDU_RX_ERR_IMR, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 sta_sch_imr_enable(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32;
+
+		/* MDPU Processor TX */
+		val32 = MAC_REG_R32(R_AX_STA_SCHEDULER_ERR_IMR);
+		val32 &= ~(B_AX_SEARCH_HANG_TIMEOUT_INT_EN |
+			   B_AX_RPT_HANG_TIMEOUT_INT_EN |
+			   B_AX_PLE_B_PKTID_ERR_INT_EN);
+
+		val32 |= ((B_AX_SEARCH_HANG_TIMEOUT_INT_EN &
+			   DMAC_SEARCH_HANG_TIMEOUT_SER_EN) |
+			  (B_AX_RPT_HANG_TIMEOUT_INT_EN &
+			   DMAC_RPT_HANG_TIMEOUT_SER_EN) |
+			  (B_AX_PLE_B_PKTID_ERR_INT_EN &
+			   DMAC_PLE_B_PKTID_ERR_SER_EN));
+		MAC_REG_W32(R_AX_STA_SCHEDULER_ERR_IMR, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 txpktctl_imr_enable(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32;
+
+		val32 = MAC_REG_R32(R_AX_TXPKTCTL_ERR_IMR_ISR);
+		val32 &= ~(B_AX_TXPKTCTL_USRCTL_REINIT_ERR_INT_EN |
+			   B_AX_TXPKTCTL_USRCTL_NOINIT_ERR_INT_EN |
+			   B_AX_TXPKTCTL_USRCTL_RDNRLSCMD_ERR_INT_EN |
+			   B_AX_TXPKTCTL_USRCTL_RLSBMPLEN_ERR_INT_EN |
+			   B_AX_TXPKTCTL_CMDPSR_CMDTYPE_ERR_INT_EN |
+			   B_AX_TXPKTCTL_CMDPSR_FRZTO_ERR_INT_EN);
+
+		val32 |= ((B_AX_TXPKTCTL_USRCTL_REINIT_ERR_INT_EN &
+			   DMAC_TXPKTCTL_USRCTL_REINIT_ERR_SER_EN) |
+			  (B_AX_TXPKTCTL_USRCTL_NOINIT_ERR_INT_EN &
+			   DMAC_TXPKTCTL_USRCTL_NOINIT_ERR_SER_EN) |
+			  (B_AX_TXPKTCTL_USRCTL_RDNRLSCMD_ERR_INT_EN &
+			   DMAC_TXPKTCTL_USRCTL_RDNRLSCMD_ERR_SER_EN) |
+			  (B_AX_TXPKTCTL_USRCTL_RLSBMPLEN_ERR_INT_EN &
+			   DMAC_TXPKTCTL_USRCTL_RLSBMPLEN_ERR_SER_EN) |
+			  (B_AX_TXPKTCTL_CMDPSR_CMDTYPE_ERR_INT_EN &
+			   DMAC_TXPKTCTL_CMDPSR_CMDTYPE_ERR_SER_EN) |
+			  (B_AX_TXPKTCTL_CMDPSR_FRZTO_ERR_INT_EN &
+			   DMAC_TXPKTCTL_CMDPSR_FRZTO_ERR_SER_EN));
+		MAC_REG_W32(R_AX_TXPKTCTL_ERR_IMR_ISR, val32);
+
+		val32 = MAC_REG_R32(R_AX_TXPKTCTL_ERR_IMR_ISR_B1);
+		val32 &= ~(B_AX_TXPKTCTL_USRCTL_REINIT_ERR_INT_EN |
+			   B_AX_TXPKTCTL_USRCTL_NOINIT_ERR_INT_EN |
+			   B_AX_TXPKTCTL_USRCTL_RDNRLSCMD_ERR_INT_EN |
+			   B_AX_TXPKTCTL_USRCTL_RLSBMPLEN_ERR_INT_EN |
+			   B_AX_TXPKTCTL_CMDPSR_CMDTYPE_ERR_INT_EN |
+			   B_AX_TXPKTCTL_CMDPSR_FRZTO_ERR_INT_EN);
+
+		val32 |= ((B_AX_TXPKTCTL_USRCTL_REINIT_ERR_INT_EN &
+			   DMAC_TXPKTCTL_USRCTL_REINIT_B1_ERR_SER_EN) |
+			  (B_AX_TXPKTCTL_USRCTL_NOINIT_ERR_INT_EN &
+			   DMAC_TXPKTCTL_USRCTL_NOINIT_B1_ERR_SER_EN) |
+			  (B_AX_TXPKTCTL_USRCTL_RDNRLSCMD_ERR_INT_EN &
+			   DMAC_TXPKTCTL_USRCTL_RDNRLSCMD_B1_ERR_SER_EN) |
+			  (B_AX_TXPKTCTL_USRCTL_RLSBMPLEN_ERR_INT_EN &
+			   DMAC_TXPKTCTL_USRCTL_RLSBMPLEN_B1_ERR_SER_EN) |
+			  (B_AX_TXPKTCTL_CMDPSR_CMDTYPE_ERR_INT_EN &
+			   DMAC_TXPKTCTL_CMDPSR_CMDTYPE_ERR_B1_SER_EN) |
+			  (B_AX_TXPKTCTL_CMDPSR_FRZTO_ERR_INT_EN &
+			   DMAC_TXPKTCTL_CMDPSR_FRZTO_ERR_B1_SER_EN));
+		MAC_REG_W32(R_AX_TXPKTCTL_ERR_IMR_ISR_B1, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 wde_imr_enable(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32;
+
+		val32 = MAC_REG_R32(R_AX_WDE_ERR_IMR);
+		val32 &= ~(B_AX_WDE_BUFREQ_QTAID_ERR_INT_EN |
+			   B_AX_WDE_BUFREQ_UNAVAL_ERR_INT_EN |
+			   B_AX_WDE_BUFRTN_INVLD_PKTID_ERR_INT_EN |
+			   B_AX_WDE_BUFRTN_SIZE_ERR_INT_EN |
+			   B_AX_WDE_BUFREQ_SRCHTAILPG_ERR_INT_EN |
+			   B_AX_WDE_GETNPG_STRPG_ERR_INT_EN |
+			   B_AX_WDE_GETNPG_PGOFST_ERR_INT_EN |
+			   B_AX_WDE_BUFMGN_FRZTO_ERR_INT_EN |
+			   B_AX_WDE_QUE_CMDTYPE_ERR_INT_EN |
+			   B_AX_WDE_QUE_DSTQUEID_ERR_INT_EN |
+			   B_AX_WDE_QUE_SRCQUEID_ERR_INT_EN |
+			   B_AX_WDE_ENQ_PKTCNT_OVRF_ERR_INT_EN |
+			   B_AX_WDE_ENQ_PKTCNT_NVAL_ERR_INT_EN |
+			   B_AX_WDE_PREPKTLLT_AD_ERR_INT_EN |
+			   B_AX_WDE_NXTPKTLL_AD_ERR_INT_EN |
+			   B_AX_WDE_QUEMGN_FRZTO_ERR_INT_EN |
+			   B_AX_WDE_DATCHN_ARBT_ERR_INT_EN |
+			   B_AX_WDE_DATCHN_NULLPG_ERR_INT_EN |
+			   B_AX_WDE_DATCHN_FRZTO_ERR_INT_EN);
+
+		val32 |= ((B_AX_WDE_BUFREQ_QTAID_ERR_INT_EN &
+			   DMAC_WDE_BUFREQ_QTAID_ERR_SER_EN) |
+			  (B_AX_WDE_BUFREQ_UNAVAL_ERR_INT_EN &
+			   DMAC_WDE_BUFREQ_UNAVAL_ERR_SER_EN) |
+			  (B_AX_WDE_BUFRTN_INVLD_PKTID_ERR_INT_EN &
+			   DMAC_WDE_BUFRTN_INVLD_PKTID_ERR_SER_EN) |
+			  (B_AX_WDE_BUFRTN_SIZE_ERR_INT_EN &
+			   DMAC_WDE_BUFRTN_SIZE_ERR_SER_EN) |
+			  (B_AX_WDE_BUFREQ_SRCHTAILPG_ERR_INT_EN &
+			   DMAC_WDE_BUFREQ_SRCHTAILPG_ERR_SER_EN) |
+			  (B_AX_WDE_GETNPG_STRPG_ERR_INT_EN &
+			   DMAC_WDE_GETNPG_STRPG_ERR_SER_EN) |
+			  (B_AX_WDE_GETNPG_PGOFST_ERR_INT_EN &
+			   DMAC_WDE_GETNPG_PGOFST_ERR_SER_EN) |
+			  (B_AX_WDE_BUFMGN_FRZTO_ERR_INT_EN &
+			   DMAC_WDE_BUFMGN_FRZTO_ERR_SER_EN) |
+			  (B_AX_WDE_QUE_CMDTYPE_ERR_INT_EN &
+			   DMAC_WDE_QUE_CMDTYPE_ERR_SER_EN) |
+			  (B_AX_WDE_QUE_DSTQUEID_ERR_INT_EN &
+			   DMAC_WDE_QUE_DSTQUEID_ERR_SER_EN) |
+			  (B_AX_WDE_QUE_SRCQUEID_ERR_INT_EN &
+			   DMAC_WDE_QUE_SRCQUEID_ERR_SER_EN) |
+			  (B_AX_WDE_ENQ_PKTCNT_OVRF_ERR_INT_EN &
+			   DMAC_WDE_ENQ_PKTCNT_OVRF_ERR_SER_EN) |
+			  (B_AX_WDE_ENQ_PKTCNT_NVAL_ERR_INT_EN &
+			   DMAC_WDE_ENQ_PKTCNT_NVAL_ERR_SER_EN) |
+			  (B_AX_WDE_PREPKTLLT_AD_ERR_INT_EN &
+			   DMAC_WDE_PREPKTLLT_AD_ERR_SER_EN) |
+			  (B_AX_WDE_NXTPKTLL_AD_ERR_INT_EN &
+			   DMAC_WDE_NXTPKTLL_AD_ERR_SER_EN) |
+			  (B_AX_WDE_QUEMGN_FRZTO_ERR_INT_EN &
+			   DMAC_WDE_QUEMGN_FRZTO_ERR_SER_EN) |
+			  (B_AX_WDE_DATCHN_ARBT_ERR_INT_EN &
+			   DMAC_WDE_DATCHN_ARBT_ERR_SER_EN) |
+			  (B_AX_WDE_DATCHN_NULLPG_ERR_INT_EN &
+			   DMAC_WDE_DATCHN_NULLPG_ERR_SER_EN) |
+			  (B_AX_WDE_DATCHN_FRZTO_ERR_INT_EN &
+			   DMAC_WDE_DATCHN_FRZTO_ERR_SER_EN));
+		MAC_REG_W32(R_AX_WDE_ERR_IMR, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 ple_imr_enable(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32;
+
+		val32 = MAC_REG_R32(R_AX_PLE_ERR_IMR);
+		val32 &= ~(B_AX_PLE_BUFREQ_QTAID_ERR_INT_EN |
+			   B_AX_PLE_BUFREQ_UNAVAL_ERR_INT_EN |
+			   B_AX_PLE_BUFRTN_INVLD_PKTID_ERR_INT_EN |
+			   B_AX_PLE_BUFRTN_SIZE_ERR_INT_EN |
+			   B_AX_PLE_BUFREQ_SRCHTAILPG_ERR_INT_EN |
+			   B_AX_PLE_GETNPG_STRPG_ERR_INT_EN |
+			   B_AX_PLE_GETNPG_PGOFST_ERR_INT_EN |
+			   B_AX_PLE_BUFMGN_FRZTO_ERR_INT_EN |
+			   B_AX_PLE_QUE_CMDTYPE_ERR_INT_EN |
+			   B_AX_PLE_QUE_DSTQUEID_ERR_INT_EN |
+			   B_AX_PLE_QUE_SRCQUEID_ERR_INT_EN |
+			   B_AX_PLE_ENQ_PKTCNT_OVRF_ERR_INT_EN |
+			   B_AX_PLE_ENQ_PKTCNT_NVAL_ERR_INT_EN |
+			   B_AX_PLE_PREPKTLLT_AD_ERR_INT_EN |
+			   B_AX_PLE_NXTPKTLL_AD_ERR_INT_EN |
+			   B_AX_PLE_QUEMGN_FRZTO_ERR_INT_EN |
+			   B_AX_PLE_DATCHN_ARBT_ERR_INT_EN |
+			   B_AX_PLE_DATCHN_NULLPG_ERR_INT_EN |
+			   B_AX_PLE_DATCHN_FRZTO_ERR_INT_EN);
+
+		val32 |= ((B_AX_PLE_BUFREQ_QTAID_ERR_INT_EN &
+			   DMAC_PLE_BUFREQ_QTAID_ERR_SER_EN) |
+			  (B_AX_PLE_BUFREQ_UNAVAL_ERR_INT_EN &
+			   DMAC_PLE_BUFREQ_UNAVAL_ERR_SER_EN) |
+			  (B_AX_PLE_BUFRTN_INVLD_PKTID_ERR_INT_EN &
+			   DMAC_PLE_BUFRTN_INVLD_PKTID_ERR_SER_EN) |
+			  (B_AX_PLE_BUFRTN_SIZE_ERR_INT_EN &
+			   DMAC_PLE_BUFRTN_SIZE_ERR_SER_EN) |
+			  (B_AX_PLE_BUFREQ_SRCHTAILPG_ERR_INT_EN &
+			   DMAC_PLE_BUFREQ_SRCHTAILPG_ERR_SER_EN) |
+			  (B_AX_PLE_GETNPG_STRPG_ERR_INT_EN &
+			   DMAC_PLE_GETNPG_STRPG_ERR_SER_EN) |
+			  (B_AX_PLE_GETNPG_PGOFST_ERR_INT_EN &
+			   DMAC_PLE_GETNPG_PGOFST_ERR_SER_EN) |
+			  (B_AX_PLE_BUFMGN_FRZTO_ERR_INT_EN &
+			   DMAC_PLE_BUFMGN_FRZTO_ERR_SER_EN) |
+			  (B_AX_PLE_QUE_CMDTYPE_ERR_INT_EN &
+			   DMAC_PLE_QUE_CMDTYPE_ERR_SER_EN) |
+			  (B_AX_PLE_QUE_DSTQUEID_ERR_INT_EN &
+			   DMAC_PLE_QUE_DSTQUEID_ERR_SER_EN) |
+			  (B_AX_PLE_QUE_SRCQUEID_ERR_INT_EN &
+			   DMAC_PLE_QUE_SRCQUEID_ERR_SER_EN) |
+			  (B_AX_PLE_ENQ_PKTCNT_OVRF_ERR_INT_EN &
+			   DMAC_PLE_ENQ_PKTCNT_OVRF_ERR_SER_EN) |
+			  (B_AX_PLE_ENQ_PKTCNT_NVAL_ERR_INT_EN &
+			   DMAC_PLE_ENQ_PKTCNT_NVAL_ERR_SER_EN) |
+			  (B_AX_PLE_PREPKTLLT_AD_ERR_INT_EN &
+			   DMAC_PLE_PREPKTLLT_AD_ERR_SER_EN) |
+			  (B_AX_PLE_NXTPKTLL_AD_ERR_INT_EN &
+			   DMAC_PLE_NXTPKTLL_AD_ERR_SER_EN) |
+			  (B_AX_PLE_QUEMGN_FRZTO_ERR_INT_EN &
+			   DMAC_PLE_QUEMGN_FRZTO_ERR_SER_EN) |
+			  (B_AX_PLE_DATCHN_ARBT_ERR_INT_EN &
+			   DMAC_PLE_DATCHN_ARBT_ERR_SER_EN) |
+			  (B_AX_PLE_DATCHN_NULLPG_ERR_INT_EN &
+			   DMAC_PLE_DATCHN_NULLPG_ERR_SER_EN) |
+			  (B_AX_PLE_DATCHN_FRZTO_ERR_INT_EN &
+			   DMAC_PLE_DATCHN_FRZTO_ERR_SER_EN));
+		MAC_REG_W32(R_AX_PLE_ERR_IMR, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 pktin_imr_enable(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32;
+
+		val32 = MAC_REG_R32(R_AX_PKTIN_ERR_IMR);
+		val32 &= ~(B_AX_PKTIN_GETPKTID_ERR_INT_EN);
+
+		val32 |= ((B_AX_PKTIN_GETPKTID_ERR_INT_EN &
+			   DMAC_PKTIN_GETPKTID_ERR_SER_EN));
+		MAC_REG_W32(R_AX_PKTIN_ERR_IMR, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 dispatcher_imr_enable(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32;
+
+		val32 = MAC_REG_R32(R_AX_HOST_DISPATCHER_ERR_IMR);
+		val32 &= ~(B_AX_HDT_CHANNEL_DIFF_ERR_INT_EN |
+			   B_AX_HDT_CHANNEL_ID_ERR_INT_EN |
+			   B_AX_HDT_PKT_FAIL_DBG_INT_EN |
+			   B_AX_HDT_PERMU_OVERFLOW_INT_EN |
+			   B_AX_HDT_PERMU_UNDERFLOW_INT_EN |
+			   B_AX_HDT_PAYLOAD_OVERFLOW_INT_EN |
+			   B_AX_HDT_PAYLOAD_UNDERFLOW_INT_EN |
+			   B_AX_HDT_OFFSET_UNMATCH_INT_EN |
+			   B_AX_HDT_CHANNEL_DMA_ERR_INT_EN |
+			   B_AX_HDT_WD_CHK_ERR_INT_EN |
+			   B_AX_HDT_PRE_COST_ERR_INT_EN |
+			   B_AX_HDT_TXPKTSIZE_ERR_INT_EN |
+			   B_AX_HDT_TCP_CHK_ERR_INT_EN |
+			   B_AX_HDT_TX_WRITE_OVERFLOW_INT_EN |
+			   B_AX_HDT_TX_WRITE_UNDERFLOW_INT_EN |
+			   B_AX_HDT_PLD_CMD_OVERLOW_INT_EN |
+			   B_AX_HDT_PLD_CMD_UNDERFLOW_INT_EN |
+			   B_AX_HDT_FLOW_CTRL_ERR_INT_EN |
+			   B_AX_HDT_NULLPKT_ERR_INT_EN |
+			   B_AX_HDT_BURST_NUM_ERR_INT_EN |
+			   B_AX_HDT_RXAGG_CFG_ERR_INT_EN |
+			   B_AX_HDT_SHIFT_EN_ERR_INT_EN |
+			   B_AX_HDT_TOTAL_LEN_ERR_INT_EN |
+			   B_AX_HDT_DMA_PROCESS_ERR_INT_EN |
+			   B_AX_HDT_SHIFT_DMA_CFG_ERR_INT_EN |
+			   B_AX_HDT_CHKSUM_FSM_ERR_INT_EN |
+			   B_AX_HDT_RX_WRITE_OVERFLOW_INT_EN |
+			   B_AX_HDT_RX_WRITE_UNDERFLOW_INT_EN);
+
+		val32 |= ((B_AX_HDT_CHANNEL_DIFF_ERR_INT_EN &
+			   DMAC_HDT_CHANNEL_DIFF_ERR_SER_EN) |
+			  (B_AX_HDT_CHANNEL_ID_ERR_INT_EN &
+			   DMAC_HDT_CHANNEL_ID_ERR_SER_EN) |
+			  (B_AX_HDT_PKT_FAIL_DBG_INT_EN &
+			   DMAC_HDT_PKT_FAIL_DBG_SER_EN) |
+			  (B_AX_HDT_PERMU_OVERFLOW_INT_EN &
+			   DMAC_HDT_PERMU_OVERFLOW_SER_EN) |
+			  (B_AX_HDT_PERMU_UNDERFLOW_INT_EN &
+			   DMAC_HDT_PERMU_UNDERFLOW_SER_EN) |
+			  (B_AX_HDT_PAYLOAD_OVERFLOW_INT_EN &
+			   DMAC_HDT_PAYLOAD_OVERFLOW_SER_EN) |
+			  (B_AX_HDT_PAYLOAD_UNDERFLOW_INT_EN &
+			   DMAC_HDT_PAYLOAD_UNDERFLOW_SER_EN) |
+			  (B_AX_HDT_OFFSET_UNMATCH_INT_EN &
+			   DMAC_HDT_OFFSET_UNMATCH_SER_EN) |
+			  (B_AX_HDT_CHANNEL_DMA_ERR_INT_EN &
+			   DMAC_HDT_CHANNEL_DMA_ERR_SER_EN) |
+			  (B_AX_HDT_WD_CHK_ERR_INT_EN &
+			   DMAC_HDT_WD_CHK_ERR_SER_EN) |
+			  (B_AX_HDT_PRE_COST_ERR_INT_EN &
+			   DMAC_HDT_PRE_COST_ERR_SER_EN) |
+			  (B_AX_HDT_TXPKTSIZE_ERR_INT_EN &
+			   DMAC_HDT_TXPKTSIZE_ERR_SER_EN) |
+			  (B_AX_HDT_TCP_CHK_ERR_INT_EN &
+			   DMAC_HDT_TCP_CHK_ERR_SER_EN) |
+			  (B_AX_HDT_TX_WRITE_OVERFLOW_INT_EN &
+			   DMAC_HDT_TX_WRITE_OVERFLOW_SER_EN) |
+			  (B_AX_HDT_TX_WRITE_UNDERFLOW_INT_EN &
+			   DMAC_HDT_TX_WRITE_UNDERFLOW_SER_EN) |
+			  (B_AX_HDT_PLD_CMD_OVERLOW_INT_EN &
+			   DMAC_HDT_PLD_CMD_OVERLOW_SER_EN) |
+			  (B_AX_HDT_PLD_CMD_UNDERFLOW_INT_EN &
+			   DMAC_HDT_PLD_CMD_UNDERFLOW_SER_EN) |
+			  (B_AX_HDT_FLOW_CTRL_ERR_INT_EN &
+			   DMAC_HDT_FLOW_CTRL_ERR_SER_EN) |
+			  (B_AX_HDT_NULLPKT_ERR_INT_EN &
+			   DMAC_HDT_NULLPKT_ERR_SER_EN) |
+			  (B_AX_HDT_BURST_NUM_ERR_INT_EN &
+			   DMAC_HDT_BURST_NUM_ERR_SER_EN) |
+			  (B_AX_HDT_RXAGG_CFG_ERR_INT_EN &
+			   DMAC_HDT_RXAGG_CFG_ERR_SER_EN) |
+			  (B_AX_HDT_SHIFT_EN_ERR_INT_EN &
+			   DMAC_HDT_SHIFT_EN_ERR_SER_EN) |
+			  (B_AX_HDT_TOTAL_LEN_ERR_INT_EN &
+			   DMAC_HDT_TOTAL_LEN_ERR_SER_EN) |
+			  (B_AX_HDT_DMA_PROCESS_ERR_INT_EN &
+			   DMAC_HDT_DMA_PROCESS_ERR_SER_EN) |
+			  (B_AX_HDT_SHIFT_DMA_CFG_ERR_INT_EN &
+			   DMAC_HDT_SHIFT_DMA_CFG_ERR_SER_EN) |
+			  (B_AX_HDT_CHKSUM_FSM_ERR_INT_EN &
+			   DMAC_HDT_CHKSUM_FSM_ERR_SER_EN) |
+			  (B_AX_HDT_RX_WRITE_OVERFLOW_INT_EN &
+			   DMAC_HDT_RX_WRITE_OVERFLOW_SER_EN) |
+			  (B_AX_HDT_RX_WRITE_UNDERFLOW_INT_EN &
+			   DMAC_HDT_RX_WRITE_UNDERFLOW_SER_EN));
+		MAC_REG_W32(R_AX_HOST_DISPATCHER_ERR_IMR, val32);
+
+		val32 = MAC_REG_R32(R_AX_CPU_DISPATCHER_ERR_IMR);
+		val32 &= ~(B_AX_CPU_CHANNEL_DIFF_ERR_INT_EN |
+			   B_AX_CPU_PKT_FAIL_DBG_INT_EN |
+			   B_AX_CPU_CHANNEL_ID_ERR_INT_EN |
+			   B_AX_CPU_PERMU_OVERFLOW_INT_EN |
+			   B_AX_CPU_PERMU_UNDERFLOW_INT_EN |
+			   B_AX_CPU_PAYLOAD_OVERFLOW_INT_EN |
+			   B_AX_CPU_PAYLOAD_UNDERFLOW_INT_EN |
+			   B_AX_CPU_PAYLOAD_CHKSUM_ERR_INT_EN |
+			   B_AX_CPU_OFFSET_UNMATCH_INT_EN |
+			   B_AX_CPU_CHANNEL_DMA_ERR_INT_EN |
+			   B_AX_CPU_WD_CHK_ERR_INT_EN |
+			   B_AX_CPU_PRE_COST_ERR_INT_EN |
+			   B_AX_CPU_PLD_CMD_OVERLOW_INT_EN |
+			   B_AX_CPU_PLD_CMD_UNDERFLOW_INT_EN |
+			   B_AX_CPU_F2P_QSEL_ERR_INT_EN |
+			   B_AX_CPU_F2P_SEQ_ERR_INT_EN |
+			   B_AX_CPU_FLOW_CTRL_ERR_INT_EN |
+			   B_AX_CPU_NULLPKT_ERR_INT_EN |
+			   B_AX_CPU_BURST_NUM_ERR_INT_EN |
+			   B_AX_CPU_RXAGG_CFG_ERR_INT_EN |
+			   B_AX_CPU_SHIFT_EN_ERR_INT_EN |
+			   B_AX_CPU_TOTAL_LEN_ERR_INT_EN |
+			   B_AX_CPU_DMA_PROCESS_ERR_INT_EN |
+			   B_AX_CPU_SHIFT_DMA_CFG_ERR_INT_EN |
+			   B_AX_CPU_CHKSUM_FSM_ERR_INT_EN |
+			   B_AX_CPU_RX_WRITE_OVERFLOW_INT_EN |
+			   B_AX_CPU_RX_WRITE_UNDERFLOW_INT_EN);
+
+		val32 |= ((B_AX_CPU_CHANNEL_DIFF_ERR_INT_EN &
+			   DMAC_CPU_CHANNEL_DIFF_ERR_SER_EN) |
+			  (B_AX_CPU_PKT_FAIL_DBG_INT_EN &
+			   DMAC_CPU_PKT_FAIL_DBG_SER_EN) |
+			  (B_AX_CPU_CHANNEL_ID_ERR_INT_EN &
+			   DMAC_CPU_CHANNEL_ID_ERR_SER_EN) |
+			  (B_AX_CPU_PERMU_OVERFLOW_INT_EN &
+			   DMAC_CPU_PERMU_OVERFLOW_SER_EN) |
+			  (B_AX_CPU_PERMU_UNDERFLOW_INT_EN &
+			   DMAC_CPU_PERMU_UNDERFLOW_SER_EN) |
+			  (B_AX_CPU_PAYLOAD_OVERFLOW_INT_EN &
+			   DMAC_CPU_PAYLOAD_OVERFLOW_SER_EN) |
+			  (B_AX_CPU_PAYLOAD_UNDERFLOW_INT_EN &
+			   DMAC_CPU_PAYLOAD_UNDERFLOW_SER_EN) |
+			  (B_AX_CPU_PAYLOAD_CHKSUM_ERR_INT_EN &
+			   DMAC_CPU_PAYLOAD_CHKSUM_ERR_SER_EN) |
+			  (B_AX_CPU_OFFSET_UNMATCH_INT_EN &
+			   DMAC_CPU_OFFSET_UNMATCH_SER_EN) |
+			  (B_AX_CPU_CHANNEL_DMA_ERR_INT_EN &
+			   DMAC_CPU_CHANNEL_DMA_ERR_SER_EN) |
+			  (B_AX_CPU_WD_CHK_ERR_INT_EN &
+			   DMAC_CPU_WD_CHK_ERR_SER_EN) |
+			  (B_AX_CPU_PRE_COST_ERR_INT_EN &
+			   DMAC_CPU_PRE_COST_ERR_SER_EN) |
+			  (B_AX_CPU_PLD_CMD_OVERLOW_INT_EN &
+			   DMAC_CPU_PLD_CMD_OVERLOW_SER_EN) |
+			  (B_AX_CPU_PLD_CMD_UNDERFLOW_INT_EN &
+			   DMAC_CPU_PLD_CMD_UNDERFLOW_SER_EN) |
+			  (B_AX_CPU_F2P_QSEL_ERR_INT_EN &
+			   DMAC_CPU_F2P_QSEL_ERR_SER_EN) |
+			  (B_AX_CPU_F2P_SEQ_ERR_INT_EN &
+			   DMAC_CPU_F2P_SEQ_ERR_SER_EN) |
+			  (B_AX_CPU_FLOW_CTRL_ERR_INT_EN &
+			   DMAC_CPU_FLOW_CTRL_ERR_SER_EN) |
+			  (B_AX_CPU_NULLPKT_ERR_INT_EN &
+			   DMAC_CPU_NULLPKT_ERR_SER_EN) |
+			  (B_AX_CPU_BURST_NUM_ERR_INT_EN &
+			   DMAC_CPU_BURST_NUM_ERR_SER_EN) |
+			  (B_AX_CPU_RXAGG_CFG_ERR_INT_EN &
+			   DMAC_CPU_RXAGG_CFG_ERR_SER_EN) |
+			  (B_AX_CPU_SHIFT_EN_ERR_INT_EN &
+			   DMAC_CPU_SHIFT_EN_ERR_SER_EN) |
+			  (B_AX_CPU_TOTAL_LEN_ERR_INT_EN &
+			   DMAC_CPU_TOTAL_LEN_ERR_SER_EN) |
+			  (B_AX_CPU_DMA_PROCESS_ERR_INT_EN &
+			   DMAC_CPU_DMA_PROCESS_ERR_SER_EN) |
+			  (B_AX_CPU_SHIFT_DMA_CFG_ERR_INT_EN &
+			   DMAC_CPU_SHIFT_DMA_CFG_ERR_SER_EN) |
+			  (B_AX_CPU_CHKSUM_FSM_ERR_INT_EN &
+			   DMAC_CPU_CHKSUM_FSM_ERR_SER_EN));
+		MAC_REG_W32(R_AX_CPU_DISPATCHER_ERR_IMR, val32);
+
+		val32 = MAC_REG_R32(R_AX_OTHER_DISPATCHER_ERR_IMR);
+		val32 &= ~(B_AX_OTHER_STF_WROQT_UNDERFLOW_INT_EN |
+			   B_AX_OTHER_STF_WROQT_OVERFLOW_INT_EN |
+			   B_AX_OTHER_STF_WRFF_UNDERFLOW_INT_EN |
+			   B_AX_OTHER_STF_WRFF_OVERFLOW_INT_EN |
+			   B_AX_OTHER_STF_CMD_UNDERFLOW_INT_EN |
+			   B_AX_OTHER_STF_CMD_OVERFLOW_INT_EN |
+			   B_AX_HOST_ADDR_INFO_LEN_ZERO_ERR_INT_EN |
+			   B_AX_CPU_ADDR_INFO_LEN_ZERO_ERR_INT_EN |
+			   B_AX_PLE_OUTPUT_ERR_INT_EN |
+			   B_AX_PLE_RESP_ERR_INT_EN |
+			   B_AX_PLE_BURST_NUM_ERR_INT_EN |
+			   B_AX_PLE_NULL_PKT_ERR_INT_EN |
+			   B_AX_PLE_FLOW_CTRL_ERR_INT_EN |
+			   B_AX_WDE_OUTPUT_ERR_INT_EN |
+			   B_AX_WDE_RESP_ERR_INT_EN |
+			   B_AX_WDE_BURST_NUM_ERR_INT_EN |
+			   B_AX_WDE_NULL_PKT_ERR_INT_EN |
+			   B_AX_WDE_FLOW_CTRL_ERR_INT_EN);
+
+		val32 |= ((B_AX_OTHER_STF_WROQT_UNDERFLOW_INT_EN &
+			   DMAC_OTHER_STF_WROQT_UNDERFLOW_SER_EN) |
+			  (B_AX_OTHER_STF_WROQT_OVERFLOW_INT_EN &
+			   DMAC_OTHER_STF_WROQT_OVERFLOW_SER_EN) |
+			  (B_AX_OTHER_STF_WRFF_UNDERFLOW_INT_EN &
+			   DMAC_OTHER_STF_WRFF_UNDERFLOW_SER_EN) |
+			  (B_AX_OTHER_STF_WRFF_OVERFLOW_INT_EN &
+			   DMAC_OTHER_STF_WRFF_OVERFLOW_SER_EN) |
+			  (B_AX_OTHER_STF_CMD_UNDERFLOW_INT_EN &
+			   DMAC_OTHER_STF_CMD_UNDERFLOW_SER_EN) |
+			  (B_AX_OTHER_STF_CMD_OVERFLOW_INT_EN &
+			   DMAC_OTHER_STF_CMD_OVERFLOW_SER_EN) |
+			  (B_AX_HOST_ADDR_INFO_LEN_ZERO_ERR_INT_EN &
+			   DMAC_HOST_ADDR_INFO_LEN_ZERO_ERR_SER_EN) |
+			  (B_AX_CPU_ADDR_INFO_LEN_ZERO_ERR_INT_EN &
+			   DMAC_CPU_ADDR_INFO_LEN_ZERO_ERR_SER_EN) |
+			  (B_AX_PLE_OUTPUT_ERR_INT_EN &
+			   DMAC_PLE_OUTPUT_ERR_SER_EN) |
+			  (B_AX_PLE_RESP_ERR_INT_EN &
+			   DMAC_PLE_RESP_ERR_SER_EN) |
+			  (B_AX_PLE_BURST_NUM_ERR_INT_EN &
+			   DMAC_PLE_BURST_NUM_ERR_SER_EN) |
+			  (B_AX_PLE_NULL_PKT_ERR_INT_EN &
+			   DMAC_PLE_NULL_PKT_ERR_SER_EN) |
+			  (B_AX_PLE_FLOW_CTRL_ERR_INT_EN &
+			   DMAC_PLE_FLOW_CTRL_ERR_SER_EN) |
+			  (B_AX_WDE_OUTPUT_ERR_INT_EN &
+			   DMAC_WDE_OUTPUT_ERR_SER_EN) |
+			  (B_AX_WDE_RESP_ERR_INT_EN &
+			   DMAC_WDE_RESP_ERR_SER_EN) |
+			  (B_AX_WDE_BURST_NUM_ERR_INT_EN &
+			   DMAC_WDE_BURST_NUM_ERR_SER_EN) |
+			  (B_AX_WDE_NULL_PKT_ERR_INT_EN &
+			   DMAC_WDE_NULL_PKT_ERR_SER_EN) |
+			  (B_AX_WDE_FLOW_CTRL_ERR_INT_EN &
+			   DMAC_WDE_FLOW_CTRL_ERR_SER_EN));
+		MAC_REG_W32(R_AX_OTHER_DISPATCHER_ERR_IMR, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 cpuio_imr_enable(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32;
+
+		val32 = MAC_REG_R32(R_AX_CPUIO_ERR_IMR);
+		val32 &= ~(B_AX_WDEBUF_OP_ERR_INT_EN |
+			   B_AX_WDEQUE_OP_ERR_INT_EN |
+			   B_AX_PLEBUF_OP_ERR_INT_EN |
+			   B_AX_PLEQUE_OP_ERR_INT_EN);
+
+		val32 |= ((B_AX_WDEBUF_OP_ERR_INT_EN &
+			   DMAC_WDEBUF_OP_ERR_SER_EN) |
+			  (B_AX_WDEQUE_OP_ERR_INT_EN &
+			   DMAC_WDEQUE_OP_ERR_SER_EN) |
+			  (B_AX_PLEBUF_OP_ERR_INT_EN &
+			   DMAC_PLEBUF_OP_ERR_SER_EN) |
+			  (B_AX_PLEQUE_OP_ERR_INT_EN &
+			   DMAC_PLEQUE_OP_ERR_SER_EN));
+		MAC_REG_W32(R_AX_CPUIO_ERR_IMR, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 bbrpt_imr_enable(struct mac_ax_adapter *adapter)
+{
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+		u32 val32;
+
+		val32 = MAC_REG_R32(R_AX_BBRPT_COM_ERR_IMR_ISR);
+		val32 &= ~(B_AX_BBRPT_COM_NULL_PLPKTID_ERR_INT_EN);
+
+		val32 |= ((B_AX_BBRPT_COM_NULL_PLPKTID_ERR_INT_EN &
+			   DMAC_BBRPT_COM_NULL_PLPKTID_ERR_SER_EN));
+		MAC_REG_W32(R_AX_BBRPT_COM_ERR_IMR_ISR, val32);
+
+		val32 = MAC_REG_R32(R_AX_BBRPT_CHINFO_ERR_IMR_ISR);
+		val32 &= ~(B_AX_BBPRT_CHIF_BB_TO_ERR_INT_EN |
+			   B_AX_BBPRT_CHIF_OVF_ERR_INT_EN |
+			   B_AX_BBPRT_CHIF_BOVF_ERR_INT_EN |
+			   B_AX_BBPRT_CHIF_HDRL_ERR_INT_EN |
+			   B_AX_BBPRT_CHIF_LEFT1_ERR_INT_EN |
+			   B_AX_BBPRT_CHIF_LEFT2_ERR_INT_EN |
+			   B_AX_BBPRT_CHIF_NULL_ERR_INT_EN |
+			   B_AX_BBPRT_CHIF_TO_ERR_INT_EN);
+
+		val32 |= ((B_AX_BBPRT_CHIF_BB_TO_ERR_INT_EN &
+			   DMAC_BBPRT_CHIF_BB_TO_ERR_SER_EN) |
+			  (B_AX_BBPRT_CHIF_OVF_ERR_INT_EN &
+			   DMAC_BBPRT_CHIF_OVF_ERR_SER_EN) |
+			  (B_AX_BBPRT_CHIF_BOVF_ERR_INT_EN &
+			   DMAC_BBPRT_CHIF_BOVF_ERR_SER_EN) |
+			  (B_AX_BBPRT_CHIF_HDRL_ERR_INT_EN &
+			   DMAC_BBPRT_CHIF_HDRL_ERR_SER_EN) |
+			  (B_AX_BBPRT_CHIF_LEFT1_ERR_INT_EN &
+			   DMAC_BBPRT_CHIF_LEFT1_ERR_SER_EN) |
+			  (B_AX_BBPRT_CHIF_LEFT2_ERR_INT_EN &
+			   DMAC_BBPRT_CHIF_LEFT2_ERR_SER_EN) |
+			  (B_AX_BBPRT_CHIF_NULL_ERR_INT_EN &
+			   DMAC_BBPRT_CHIF_NULL_ERR_SER_EN) |
+			  (B_AX_BBPRT_CHIF_TO_ERR_INT_EN &
+			   DMAC_BBPRT_CHIF_TO_ERR_SER_EN));
+		MAC_REG_W32(R_AX_BBRPT_CHINFO_ERR_IMR_ISR, val32);
+
+		val32 = MAC_REG_R32(R_AX_BBRPT_DFS_ERR_IMR_ISR);
+		val32 &= ~(B_AX_BBRPT_DFS_TO_ERR_INT_EN);
+
+		val32 |= ((B_AX_BBRPT_DFS_TO_ERR_INT_EN &
+			   DMAC_BBRPT_DFS_TO_ERR_SER_EN));
+		MAC_REG_W32(R_AX_BBRPT_DFS_ERR_IMR_ISR, val32);
+
+		val32 = MAC_REG_R32(R_AX_LA_ERRFLAG);
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A)) {
+#if MAC_AX_8852A_SUPPORT
+			val32 &= ~(B_AX_LA_IMR_DATA_LOSS_ERR);
+
+			val32 |= ((B_AX_LA_IMR_DATA_LOSS_ERR &
+				   DMAC_LA_IMR_DATA_LOSS_ERR));
+#endif
+		} else {
+#if MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+			val32 &= ~(B_AX_LA_IMR_DATA_LOSS);
+
+			val32 |= ((B_AX_LA_IMR_DATA_LOSS &
+				   DMAC_LA_IMR_DATA_LOSS_ERR));
+#endif
+		}
+		MAC_REG_W32(R_AX_LA_ERRFLAG, val32);
+	}
+#endif
+	return MACSUCCESS;
+}
+
+static u32 sta_sch_init(struct mac_ax_adapter *adapter,
+			struct mac_ax_trx_info *info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u8 val8;
+	u32 cnt, ret, val32;
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	val8 = MAC_REG_R8(R_AX_SS_CTRL);
+	val8 |= B_AX_SS_EN;
+	MAC_REG_W8(R_AX_SS_CTRL, val8);
+
+	cnt = TRXCFG_WAIT_CNT;
+	while (cnt--) {
+		if (MAC_REG_R32(R_AX_SS_CTRL) & B_AX_SS_INIT_DONE_1)
+			break;
+		PLTFM_DELAY_US(TRXCFG_WAIT_US);
+	}
+
+	if (!++cnt) {
+		PLTFM_MSG_ERR("[ERR]STA scheduler init\n");
+		return MACPOLLTO;
+	}
+
+	MAC_REG_W32(R_AX_SS_CTRL,
+		    MAC_REG_R32(R_AX_SS_CTRL) | B_AX_SS_WARM_INIT_FLG);
+
+	val32 = MAC_REG_R32(R_AX_SS_CTRL);
+	if (info->trx_mode == MAC_AX_TRX_SW_MODE)
+		val32 |= B_AX_SS_NONEMPTY_SS2FINFO_EN;
+	else
+		val32 &= ~B_AX_SS_NONEMPTY_SS2FINFO_EN;
+	MAC_REG_W32(R_AX_SS_CTRL, val32);
+
+	ret = _patch_ss2f_path(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]_patch_ss2f_path\n");
+		return ret;
+	}
+
+	if (info->trx_mode == MAC_AX_TRX_SW_MODE) {
+		// Set UL SS2FRPT MAX user number
+		val32 = 0x0;
+		val32 = SET_CLR_WORD(val32, MAX_ULSS2F_SU_STA_NUM, B_AX_SS_MAX_SU_NUM_UL);
+		val32 = SET_CLR_WORD(val32, MAX_ULSS2F_TWT_STA_NUM, B_AX_SS_TWT_MAX_SU_NUM_UL);
+		val32 = SET_CLR_WORD(val32, MAX_ULSS2F_RU_STA_NUM, B_AX_SS_MAX_RU_NUM_UL);
+		MAC_REG_W32(R_AX_SS_UL_RPT_CRTL, val32);
+		// Set UL SS2FRPT BSR Threshold
+		val32 = SET_CLR_WORD(val32, UL_NORMAL_SS2FWRPT_BSR_THRES, B_AX_SS_BSR_THR_0);
+		val32 = SET_CLR_WORD(val32, UL_LATCY_SS2FWRPT_BSR_THRES, B_AX_SS_BSR_THR_1);
+		MAC_REG_W32(R_AX_SS_BSR_CTRL, val32);
+
+		val32 = 0x0;
+		val32 = SET_CLR_WORD(val32, MAX_DLSS2F_RU_STA_NUM, B_AX_SS_MAX_RU_NUM_0);
+		val32 = SET_CLR_WORD(val32, MAX_DLSS2F_RU_STA_NUM, B_AX_SS_MAX_RU_NUM_1);
+		val32 = SET_CLR_WORD(val32, MAX_DLSS2F_RU_STA_NUM, B_AX_SS_TWT_MAX_RU_NUM_0);
+		val32 = SET_CLR_WORD(val32, MAX_DLSS2F_RU_STA_NUM, B_AX_SS_TWT_MAX_RU_NUM_1);
+		MAC_REG_W32(R_AX_SS_DL_RU_RPT_CRTL, val32);
+
+		val32 = 0x0;
+		val32 = SET_CLR_WORD(val32, MAX_DLSS2F_MU_STA_NUM, B_AX_SS_MAX_MU_NUM_0);
+		val32 = SET_CLR_WORD(val32, MAX_DLSS2F_MU_STA_NUM, B_AX_SS_MAX_MU_NUM_1);
+		val32 = SET_CLR_WORD(val32, MAX_DLSS2F_MU_STA_NUM, B_AX_SS_TWT_MAX_MU_NUM_0);
+		val32 = SET_CLR_WORD(val32, MAX_DLSS2F_MU_STA_NUM, B_AX_SS_TWT_MAX_MU_NUM_1);
+		MAC_REG_W32(R_AX_SS_DL_MU_RPT_CRTL, val32);
+
+		val32 = MAC_REG_R32(R_AX_SS_DL_RPT_CRTL);
+		val32 = SET_CLR_WORD(val32, MAX_DLSS2F_SU_STA_NUM, B_AX_SS_MAX_SU_NUM_0);
+		val32 = SET_CLR_WORD(val32, MAX_DLSS2F_SU_STA_NUM, B_AX_SS_MAX_SU_NUM_1);
+		val32 = SET_CLR_WORD(val32, MAX_DLSS2F_SU_STA_NUM, B_AX_SS_TWT_MAX_SU_NUM_0);
+		val32 = SET_CLR_WORD(val32, MAX_DLSS2F_SU_STA_NUM, B_AX_SS_TWT_MAX_SU_NUM_1);
+		MAC_REG_W32(R_AX_SS_DL_RPT_CRTL, val32);
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 scheduler_init(struct mac_ax_adapter *adapter, u8 band, struct mac_ax_trx_info *info)
+{
+	u32 reg, val32, ret;
+	u8 is_poh;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_edca_param edca_para;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+	ret = is_qta_poh(adapter, adapter->dle_info.qta_mode, &is_poh);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_PREBKF_CFG_1_C1 : R_AX_PREBKF_CFG_1;
+	val32 = MAC_REG_R32(reg);
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+		val32 = SET_CLR_WORD(val32, SIFS_MACTXEN_T1_V0,
+				     B_AX_SIFS_MACTXEN_T1);
+	else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		 is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		 is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		 is_chip_id(adapter, MAC_AX_CHIP_ID_8852D))
+		val32 = SET_CLR_WORD(val32, SIFS_MACTXEN_T1_V1,
+				     B_AX_SIFS_MACTXEN_T1);
+	MAC_REG_W32(reg, val32);
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+#if MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		reg = band == MAC_AX_BAND_1 ?
+		      R_AX_SCH_EXT_CTRL_C1 : R_AX_SCH_EXT_CTRL;
+		val32 = MAC_REG_R32(reg) | B_AX_PORT_RST_TSF_ADV;
+		MAC_REG_W32(reg, val32);
+#endif
+	}
+
+#if MAC_AX_ASIC_TEMP
+	reg = band == MAC_AX_BAND_1 ? R_AX_CCA_CFG_0_C1 : R_AX_CCA_CFG_0;
+	val32 = MAC_REG_R32(reg) & ~(B_AX_BTCCA_EN);
+	MAC_REG_W32(reg, val32);
+#endif
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_CCA_CFG_0_C1 : R_AX_CCA_CFG_0;
+	val32 = MAC_REG_R32(reg);
+	if (adapter->env == DUT_ENV_FPGA) {
+		if (info->trx_mode == MAC_AX_TRX_LOOPBACK) {
+			val32 = val32 & ~(B_AX_CCA_EN) & ~(B_AX_SEC20_EN) &
+				~(B_AX_SEC40_EN) & ~(B_AX_SEC80_EN) &
+				~(B_AX_EDCCA_EN);
+		}
+	} else if (adapter->env == DUT_ENV_ASIC || adapter->env == DUT_ENV_PXP) {
+		val32 = val32;
+	} else {
+		PLTFM_MSG_ERR("[ERR]Unknown env %d\n", adapter->env);
+		return MACNOITEM;
+	}
+
+	MAC_REG_W32(reg, val32);
+
+#ifdef PHL_FEATURE_AP
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		reg = band == MAC_AX_BAND_1 ? R_AX_PREBKF_CFG_0_C1 : R_AX_PREBKF_CFG_0;
+		val32 = MAC_REG_R32(reg);
+		val32 = SET_CLR_WORD(val32, SCH_PREBKF_16US, B_AX_PREBKF_TIME);
+		MAC_REG_W32(reg, val32);
+	}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		if (!(MAC_REG_R32(R_AX_SEC_ENG_CTRL) & B_AX_TX_PARTIAL_MODE)) {
+			reg = band == MAC_AX_BAND_1 ? R_AX_PREBKF_CFG_0_C1 : R_AX_PREBKF_CFG_0;
+			val32 = MAC_REG_R32(reg);
+			val32 = SET_CLR_WORD(val32, SCH_PREBKF_16US, B_AX_PREBKF_TIME);
+			MAC_REG_W32(reg, val32);
+		}
+	}
+#endif
+
+	if (band == MAC_AX_BAND_0) {
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+			val32 = MAC_REG_R32(R_AX_CCA_CFG_0);
+			val32 = SET_CLR_WORD(val32, 0x6a,
+					     B_AX_R_SIFS_AGGR_TIME);
+			MAC_REG_W32(R_AX_CCA_CFG_0, val32);
+#endif
+		} else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+			   is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+			   is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+			val32 = MAC_REG_R32(R_AX_CCA_CFG_0);
+			val32 = SET_CLR_WORD(val32, 0x6a,
+					     B_AX_R_SIFS_AGGR_TIME_V1);
+			MAC_REG_W32(R_AX_CCA_CFG_0, val32);
+#endif
+		}
+	}
+#else /*for NIC mode setting*/
+	if (is_poh && adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+		reg = band == MAC_AX_BAND_1 ?
+				R_AX_PREBKF_CFG_0_C1 : R_AX_PREBKF_CFG_0;
+		val32 = MAC_REG_R32(reg);
+		val32 = SET_CLR_WORD(val32, SCH_PREBKF_24US, B_AX_PREBKF_TIME);
+		MAC_REG_W32(reg, val32);
+
+#if (MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			reg = band == MAC_AX_BAND_1 ?
+					R_AX_CTN_CFG_0_C1 : R_AX_CTN_CFG_0;
+			val32 = MAC_REG_R32(reg);
+			val32 = SET_CLR_WORD(val32, SCH_PREBKF_24US, B_AX_PREBKF_TIME_NONAC);
+			MAC_REG_W32(reg, val32);
+		}
+#endif
+	}
+#endif
+
+	edca_para.band = band;
+	edca_para.path = MAC_AX_CMAC_PATH_SEL_BCN;
+	edca_para.ecw_min = 2;
+	edca_para.ecw_max = 3;
+	edca_para.aifs_us = BCN_IFS_25US;
+	ret = set_hw_edca_param(adapter, &edca_para);
+
+	return ret;
+}
+
+static u32 mpdu_proc_init(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret;
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	MAC_REG_W32(R_AX_ACTION_FWD0, TRXCFG_MPDU_PROC_ACT_FRWD);
+	MAC_REG_W32(R_AX_TF_FWD, TRXCFG_MPDU_PROC_TF_FRWD);
+	val32 = MAC_REG_R32(R_AX_MPDU_PROC);
+	val32 |= (B_AX_APPEND_FCS | B_AX_A_ICV_ERR);
+	MAC_REG_W32(R_AX_MPDU_PROC, val32);
+	MAC_REG_W32(R_AX_CUT_AMSDU_CTRL, TRXCFG_MPDU_PROC_CUT_CTRL);
+
+	return MACSUCCESS;
+}
+
+static u32 sec_eng_init(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32 = 0;
+	u32 ret;
+
+	ret = check_mac_en(adapter, 0, MAC_AX_DMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	val32 = MAC_REG_R32(R_AX_SEC_ENG_CTRL);
+	// init clock
+	val32 |= (B_AX_CLK_EN_CGCMP | B_AX_CLK_EN_WAPI | B_AX_CLK_EN_WEP_TKIP);
+	// init TX encryption
+	val32 |= (B_AX_SEC_TX_ENC | B_AX_SEC_RX_DEC);
+	val32 |= (B_AX_MC_DEC | B_AX_BC_DEC);
+	val32 |= (B_AX_BMC_MGNT_DEC | B_AX_UC_MGNT_DEC);
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		val32 &= ~B_AX_TX_PARTIAL_MODE;
+	}
+#endif
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+#if MAC_AX_USB_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		if (adapter->hw_info->intf == MAC_AX_INTF_USB)
+			val32 &= ~B_AX_TX_PARTIAL_MODE;
+	}
+#endif
+#endif
+
+	MAC_REG_W32(R_AX_SEC_ENG_CTRL, val32);
+
+	//init MIC ICV append
+	val32 = MAC_REG_R32(R_AX_SEC_MPDU_PROC);
+	val32 |= (B_AX_APPEND_ICV | B_AX_APPEND_MIC);
+
+	// option init
+	MAC_REG_W32(R_AX_SEC_MPDU_PROC, val32);
+
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+		val32 = MAC_REG_R32(R_AX_SEC_DEBUG1);
+		val32 = SET_CLR_WORD(val32, B_AX_TX_TO, B_AX_TX_TIMEOUT_SEL);
+		MAC_REG_W32(R_AX_SEC_DEBUG1, val32);
+	}
+#endif
+
+#ifdef PHL_FEATURE_AP
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+		if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+		    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+			val32 = MAC_REG_R32(R_AX_RCR);
+			val32 = SET_CLR_WORD(val32, DRVINFO_PATCH_SIZE, B_AX_DRV_INFO_SIZE);
+			MAC_REG_W32(R_AX_RCR, val32);
+		}
+#endif
+#endif
+
+	return MACSUCCESS;
+}
+
+static u32 tmac_init(struct mac_ax_adapter *adapter, u8 band,
+		     struct mac_ax_trx_info *info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg, val32, ret;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_MAC_LOOPBACK_C1 : R_AX_MAC_LOOPBACK;
+	val32 = MAC_REG_R32(reg);
+	if (info->trx_mode == MAC_AX_TRX_LOOPBACK)
+		val32 |= B_AX_MACLBK_EN;
+	else
+		val32 &= ~B_AX_MACLBK_EN;
+	MAC_REG_W32(reg, val32);
+
+#if (MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8852C_SUPPORT || \
+MAC_AX_8192XB_SUPPORT || MAC_AX_8851B_SUPPORT || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT)
+	reg = band == MAC_AX_BAND_1 ? R_AX_TCR0_C1 : R_AX_TCR0;
+	val32 = MAC_REG_R32(reg);
+	val32 = SET_CLR_WORD(val32, TCR_UDF_THSD, B_AX_TCR_UDF_THSD);
+	MAC_REG_W32(reg, val32);
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_TXD_FIFO_CTRL_C1 : R_AX_TXD_FIFO_CTRL;
+	val32 = MAC_REG_R32(reg);
+	val32 = SET_CLR_WORD(val32, TXDFIFO_HIGH_MCS_THRE, B_AX_TXDFIFO_HIGH_MCS_THRE);
+	val32 = SET_CLR_WORD(val32, TXDFIFO_LOW_MCS_THRE, B_AX_TXDFIFO_LOW_MCS_THRE);
+	MAC_REG_W32(reg, val32);
+#endif
+#if MAC_AX_FPGA_TEST
+	reg = band == MAC_AX_BAND_1 ? R_AX_MAC_LOOPBACK_C1 : R_AX_MAC_LOOPBACK;
+	val32 = MAC_REG_R32(reg);
+	if (info->trx_mode == MAC_AX_TRX_LOOPBACK)
+		val32 = SET_CLR_WORD(val32, LBK_PLCP_DLY_FPGA,
+				     B_AX_MACLBK_PLCP_DLY);
+	else
+		val32 = SET_CLR_WORD(val32, LBK_PLCP_DLY_DEF,
+				     B_AX_MACLBK_PLCP_DLY);
+	MAC_REG_W32(reg, val32);
+#endif
+	return MACSUCCESS;
+}
+
+static u32 trxptcl_init(struct mac_ax_adapter *adapter, u8 band,
+			struct mac_ax_trx_info *info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_rrsr_cfg cfg = {0};
+	u32 reg, val32, ret;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	reg = band == MAC_AX_BAND_1 ?
+	      R_AX_TRXPTCL_RESP_0_C1 : R_AX_TRXPTCL_RESP_0;
+	val32 = MAC_REG_R32(reg);
+	val32 = SET_CLR_WORD(val32, WMAC_SPEC_SIFS_CCK,
+			     B_AX_WMAC_SPEC_SIFS_CCK);
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A))
+		val32 = SET_CLR_WORD(val32, WMAC_SPEC_SIFS_OFDM_52A,
+				     B_AX_WMAC_SPEC_SIFS_OFDM);
+	else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852B))
+		val32 = SET_CLR_WORD(val32, WMAC_SPEC_SIFS_OFDM_52B,
+				     B_AX_WMAC_SPEC_SIFS_OFDM);
+	else if (is_chip_id(adapter, MAC_AX_CHIP_ID_8851B))
+		val32 = SET_CLR_WORD(val32, WMAC_SPEC_SIFS_OFDM_51B,
+				     B_AX_WMAC_SPEC_SIFS_OFDM);
+	else
+		val32 = SET_CLR_WORD(val32, WMAC_SPEC_SIFS_OFDM_52C,
+				     B_AX_WMAC_SPEC_SIFS_OFDM);
+	MAC_REG_W32(reg, val32);
+
+	reg = band == MAC_AX_BAND_1 ?
+	      R_AX_RXTRIG_TEST_USER_2_C1 : R_AX_RXTRIG_TEST_USER_2;
+	val32 = MAC_REG_R32(reg);
+	val32 |= B_AX_RXTRIG_FCSCHK_EN;
+	MAC_REG_W32(reg, val32);
+
+	/*disable 5.5M CCK rate response for PHY performance consideration*/
+	ret = p_ops->get_rrsr_cfg(adapter, &cfg);
+	cfg.cck_cfg = WMAC_CCK_EN_1M;
+	cfg.rrsr_rate_en |= WMAC_RRSR_RATE_LEGACY_EN;
+
+	/* refer to rx rate and cmac table, choose the smaller as resp initial rate */
+	cfg.ref_rate_sel = REF2RXRATEANDCCTBL;
+	ret = p_ops->set_rrsr_cfg(adapter, &cfg);
+
+	return MACSUCCESS;
+}
+
+static u32 rmac_init(struct mac_ax_adapter *adapter, u8 band,
+		     struct mac_ax_trx_info *info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct rst_bacam_info rst_info;
+	u32 ret;
+	u8 val8;
+	u16 val16;
+	u32 val32, rx_max_len, rx_max_pg, reg;
+	u32 rx_min_qta, rx_max_lenb;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (band == MAC_AX_BAND_0) {
+		rst_info.type = BACAM_RST_ALL;
+		rst_info.ent = 0;
+		ret = rst_bacam(adapter, &rst_info);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]bacam rst %d\n", ret);
+			return ret;
+		}
+	}
+
+	reg = band == MAC_AX_BAND_1 ?
+	      R_AX_RESPBA_CAM_CTRL_C1 : R_AX_RESPBA_CAM_CTRL;
+	val8 = MAC_REG_R8(reg) | B_AX_SSN_SEL;
+	MAC_REG_W8(reg, val8);
+
+	reg = band == MAC_AX_BAND_1 ?
+	      R_AX_DLK_PROTECT_CTL_C1 : R_AX_DLK_PROTECT_CTL;
+	val16 = MAC_REG_R16(reg);
+	val16 = SET_CLR_WORD(val16, TRXCFG_RMAC_DATA_TO,
+			     B_AX_RX_DLK_DATA_TIME);
+	val16 = SET_CLR_WORD(val16, TRXCFG_RMAC_CCA_TO,
+			     B_AX_RX_DLK_CCA_TIME);
+	val16 |= B_AX_RX_DLK_RST_EN;
+	MAC_REG_W16(reg, val16);
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		reg = band == MAC_AX_BAND_1 ? R_AX_RCR_C1 : R_AX_RCR;
+		val8 = MAC_REG_R8(reg);
+		if (band == MAC_AX_BAND_0 &&
+		    info->trx_mode == MAC_AX_TRX_SW_MODE)
+			val8 = SET_CLR_WORD(val8, 0xF, B_AX_CH_EN);
+		else
+			val8 = SET_CLR_WORD(val8, 0x1, B_AX_CH_EN);
+		MAC_REG_W8(reg, val8);
+#endif
+	} else {
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || \
+MAC_AX_8852D_SUPPORT || MAC_AX_1115E_SUPPORT
+		reg = band == MAC_AX_BAND_1 ? R_AX_RCR_C1 : R_AX_RCR;
+		val8 = MAC_REG_R8(reg);
+		if (band == MAC_AX_BAND_0 &&
+		    info->trx_mode == MAC_AX_TRX_SW_MODE)
+			val8 = (u8)SET_CLR_WORD(val8, 0xF, B_AX_CH_EN_V1);
+		else
+			val8 = (u8)SET_CLR_WORD(val8, 0x1, B_AX_CH_EN_V1);
+		MAC_REG_W8(reg, val8);
+#endif
+	}
+	rx_min_qta = band == MAC_AX_BAND_1 ?
+		     adapter->dle_info.c1_rx_qta : adapter->dle_info.c0_rx_qta;
+	rx_max_pg = rx_min_qta > PLD_RLS_MAX_PG ? PLD_RLS_MAX_PG : rx_min_qta;
+	rx_max_lenb = rx_max_pg * adapter->dle_info.ple_pg_size;
+	if (rx_max_lenb < RX_SPEC_MAX_LEN)
+		PLTFM_MSG_WARN("B%dRX max len %d lower than spec max %d\n",
+			       band, rx_max_lenb, RX_SPEC_MAX_LEN);
+	else
+		rx_max_lenb = RX_SPEC_MAX_LEN;
+
+	/* rx_max_len shall not be larger than B_AX_RX_MPDU_MAX_LEN_MSK */
+	rx_max_len = rx_max_lenb / RX_MAX_LEN_UNIT;
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_RX_FLTR_OPT_C1 : R_AX_RX_FLTR_OPT;
+	val32 = MAC_REG_R32(reg);
+	val32 = SET_CLR_WORD(val32, rx_max_len, B_AX_RX_MPDU_MAX_LEN);
+	MAC_REG_W32(reg, val32);
+
+	/* rmac timer src reconfig eco item 96 */
+	_patch_wmac_timer_src(adapter, band);
+
+	/* Add drv_info dbg size as dummy (SDIO) */
+	if (adapter->hw_info->intf == MAC_AX_INTF_SDIO &&
+	    adapter->hw_info->chip_id == MAC_AX_CHIP_ID_8852A) {
+		val16 = MAC_REG_R16(R_AX_RCR);
+		MAC_REG_W16(R_AX_RCR, val16 |
+			    SET_WORD(SDIO_DRV_INFO_SIZE, B_AX_DRV_INFO_SIZE));
+	}
+
+	/* NOT ALL vendors calculate VHT SIG-B's CRC */
+	reg = band == MAC_AX_BAND_1 ?
+	      R_AX_PLCP_HDR_FLTR_C1 : R_AX_PLCP_HDR_FLTR;
+	val8 = MAC_REG_R8(reg) & ~B_AX_VHT_SU_SIGB_CRC_CHK;
+	MAC_REG_W8(reg, val8);
+
+	return MACSUCCESS;
+}
+
+static u32 cmac_com_init(struct mac_ax_adapter *adapter, u8 band,
+			 struct mac_ax_trx_info *info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, reg;
+	u32 ret;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	reg = band == MAC_AX_BAND_1 ?
+	      R_AX_TX_SUB_CARRIER_VALUE_C1 : R_AX_TX_SUB_CARRIER_VALUE;
+	val32 = MAC_REG_R32(reg);
+	if (info->trx_mode == MAC_AX_TRX_LOOPBACK) {
+		val32 = SET_CLR_WORD(val32, S_AX_TXSC_20M_4, B_AX_TXSC_20M);
+		val32 = SET_CLR_WORD(val32, S_AX_TXSC_40M_4, B_AX_TXSC_40M);
+		val32 = SET_CLR_WORD(val32, S_AX_TXSC_80M_4, B_AX_TXSC_80M);
+	} else {
+		val32 = SET_CLR_WORD(val32, S_AX_TXSC_20M_0, B_AX_TXSC_20M);
+		val32 = SET_CLR_WORD(val32, S_AX_TXSC_40M_0, B_AX_TXSC_40M);
+		val32 = SET_CLR_WORD(val32, S_AX_TXSC_80M_0, B_AX_TXSC_80M);
+	}
+	MAC_REG_W32(reg, val32);
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+		reg = band == MAC_AX_BAND_1 ?
+		      R_AX_PTCL_RRSR1_C1 : R_AX_PTCL_RRSR1;
+		val32 = MAC_REG_R32(reg);
+		val32 = SET_CLR_WORD(val32, RRSR_OFDM_CCK_EN,
+				     B_AX_RRSR_RATE_EN);
+		MAC_REG_W32(reg, val32);
+	}
+
+	return MACSUCCESS;
+}
+
+static void _patch_vht_ampdu_max_len(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 reg;
+
+	if (!chk_patch_vht_ampdu_max_len(adapter))
+		return;
+
+	reg = band == MAC_AX_BAND_1 ?
+	      R_AX_AGG_LEN_VHT_0_C1 : R_AX_AGG_LEN_VHT_0;
+	val32 = MAC_REG_R32(reg);
+	val32 = SET_CLR_WORD(val32, AMPDU_MAX_LEN_VHT_262K,
+			     B_AX_AMPDU_MAX_LEN_VHT);
+	MAC_REG_W32(reg, val32);
+}
+
+static u32 ptcl_init(struct mac_ax_adapter *adapter, u8 band,
+		     struct mac_ax_trx_info *info)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+	u32 ret;
+	u8 val8;
+	u32 reg;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+		ret = is_qta_poh(adapter, info->qta_mode, &val8);
+		if (ret)
+			return ret;
+		if (val8) {
+			reg = band == MAC_AX_BAND_1 ?
+			      R_AX_SIFS_SETTING_C1 : R_AX_SIFS_SETTING;
+			val32 = MAC_REG_R32(reg);
+			val32 = SET_CLR_WORD(val32, S_AX_CTS2S_TH_1K,
+					     B_AX_HW_CTS2SELF_PKT_LEN_TH);
+			val32 = SET_CLR_WORD(val32, S_AX_CTS2S_TH_SEC_256B,
+					     B_AX_HW_CTS2SELF_PKT_LEN_TH_TWW);
+			val32 |= B_AX_HW_CTS2SELF_EN;
+			MAC_REG_W32(reg, val32);
+
+			reg = band == MAC_AX_BAND_1 ?
+			      R_AX_PTCL_FSM_MON_C1 : R_AX_PTCL_FSM_MON;
+			val32 = MAC_REG_R32(reg);
+			val32 = SET_CLR_WORD(val32, S_AX_PTCL_TO_2MS,
+					     B_AX_PTCL_TX_ARB_TO_THR);
+			val32 &= ~B_AX_PTCL_TX_ARB_TO_MODE;
+			MAC_REG_W32(reg, val32);
+		}
+	}
+
+	if (band == MAC_AX_BAND_0) {
+		val8 = MAC_REG_R8(R_AX_PTCL_COMMON_SETTING_0);
+		if (info->trx_mode == MAC_AX_TRX_SW_MODE) {
+			val8 &= ~(B_AX_CMAC_TX_MODE_0 | B_AX_CMAC_TX_MODE_1);
+			val8 |= B_AX_PTCL_TRIGGER_SS_EN_0 |
+				B_AX_PTCL_TRIGGER_SS_EN_1 |
+				B_AX_PTCL_TRIGGER_SS_EN_UL;
+		} else {
+			val8 |= B_AX_CMAC_TX_MODE_0 | B_AX_CMAC_TX_MODE_1;
+			val8 &= ~(B_AX_PTCL_TRIGGER_SS_EN_0 |
+				  B_AX_PTCL_TRIGGER_SS_EN_1 |
+				  B_AX_PTCL_TRIGGER_SS_EN_UL);
+		}
+		MAC_REG_W8(R_AX_PTCL_COMMON_SETTING_0, val8);
+
+		val8 = MAC_REG_R8(R_AX_PTCLRPT_FULL_HDL);
+		val8 = SET_CLR_WORD(val8, FWD_TO_WLCPU, B_AX_SPE_RPT_PATH);
+		MAC_REG_W8(R_AX_PTCLRPT_FULL_HDL, val8);
+	} else if (band == MAC_AX_BAND_1) {
+		val8 = MAC_REG_R8(R_AX_PTCLRPT_FULL_HDL_C1);
+		val8 = SET_CLR_WORD(val8, FWD_TO_WLCPU, B_AX_SPE_RPT_PATH);
+		MAC_REG_W8(R_AX_PTCLRPT_FULL_HDL_C1, val8);
+	}
+
+	_patch_vht_ampdu_max_len(adapter, band);
+
+	return MACSUCCESS;
+}
+
+static u32 cmac_dma_init(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852A) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8852B) ||
+	    is_chip_id(adapter, MAC_AX_CHIP_ID_8851B)) {
+#if MAC_AX_8852A_SUPPORT || MAC_AX_8852B_SUPPORT || MAC_AX_8851B_SUPPORT
+		u32 reg_rx_ctrl = (band == MAC_AX_BAND_1) ?
+				 R_AX_RXDMA_CTRL_0_C1 : R_AX_RXDMA_CTRL_0;
+		u8 val8 = MAC_REG_R8(reg_rx_ctrl) & ~RX_FULL_MODE;
+
+		MAC_REG_W8(reg_rx_ctrl, val8);
+#endif
+	} else {
+		return MACSUCCESS;
+	}
+
+	return MACSUCCESS;
+}
+
+static void _patch_dis_resp_chk(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg, val32;
+	u32 b_rsp_chk_nav, b_rsp_chk_cca;
+
+	b_rsp_chk_nav = B_AX_RSP_CHK_TXNAV | B_AX_RSP_CHK_INTRA_NAV |
+			B_AX_RSP_CHK_BASIC_NAV;
+
+	b_rsp_chk_cca = B_AX_RSP_CHK_SEC_CCA_80 | B_AX_RSP_CHK_SEC_CCA_40 |
+			B_AX_RSP_CHK_SEC_CCA_20 | B_AX_RSP_CHK_BTCCA |
+			B_AX_RSP_CHK_EDCCA | B_AX_RSP_CHK_CCA;
+
+	if (chk_patch_dis_resp_chk(adapter)) {
+		reg = band == MAC_AX_BAND_1 ?
+		      R_AX_RSP_CHK_SIG_C1 : R_AX_RSP_CHK_SIG;
+		val32 = MAC_REG_R32(reg) & ~b_rsp_chk_nav;
+		MAC_REG_W32(reg, val32);
+
+		reg = band == MAC_AX_BAND_1 ?
+		      R_AX_TRXPTCL_RESP_0_C1 : R_AX_TRXPTCL_RESP_0;
+		val32 = MAC_REG_R32(reg) & ~b_rsp_chk_cca;
+		MAC_REG_W32(reg, val32);
+	} else {
+		reg = band == MAC_AX_BAND_1 ?
+		      R_AX_RSP_CHK_SIG_C1 : R_AX_RSP_CHK_SIG;
+		val32 = MAC_REG_R32(reg) | b_rsp_chk_nav;
+		MAC_REG_W32(reg, val32);
+
+		reg = band == MAC_AX_BAND_1 ?
+		      R_AX_TRXPTCL_RESP_0_C1 : R_AX_TRXPTCL_RESP_0;
+		val32 = MAC_REG_R32(reg) | b_rsp_chk_cca;
+		/*response frame could ignore CCA/EDCCA according to SPEC*/
+		val32 &= ~B_AX_WMAC_RESP_ACK_BA_CHK_CCA;
+		MAC_REG_W32(reg, val32);
+	}
+}
+
+static u32 cca_ctrl_init(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, reg;
+	u32 ret;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	reg = band == MAC_AX_BAND_1 ? R_AX_CCA_CONTROL_C1 : R_AX_CCA_CONTROL;
+	val32 = MAC_REG_R32(reg);
+	val32 |= (B_AX_TB_CHK_BASIC_NAV | B_AX_TB_CHK_BTCCA |
+		  B_AX_TB_CHK_EDCCA | B_AX_TB_CHK_CCA_P20 |
+		  B_AX_SIFS_CHK_BTCCA | B_AX_SIFS_CHK_CCA_P20 |
+		  B_AX_CTN_CHK_INTRA_NAV |
+		  B_AX_CTN_CHK_BASIC_NAV | B_AX_CTN_CHK_BTCCA |
+		  B_AX_CTN_CHK_EDCCA | B_AX_CTN_CHK_CCA_S80 |
+		  B_AX_CTN_CHK_CCA_S40 | B_AX_CTN_CHK_CCA_S20 |
+		  B_AX_CTN_CHK_CCA_P20);
+
+	val32 &= (~B_AX_TB_CHK_TX_NAV & ~B_AX_TB_CHK_CCA_S80 &
+		  ~B_AX_TB_CHK_CCA_S40 & ~B_AX_TB_CHK_CCA_S20 &
+		  ~B_AX_SIFS_CHK_CCA_S80 & ~B_AX_SIFS_CHK_CCA_S40 &
+		  ~B_AX_SIFS_CHK_CCA_S20 & ~B_AX_CTN_CHK_TXNAV &
+		  ~B_AX_SIFS_CHK_EDCCA);
+
+	MAC_REG_W32(reg, val32);
+
+	_patch_dis_resp_chk(adapter, band);
+
+	return MACSUCCESS;
+}
+
+u32 _patch_rsp_ack(struct mac_ax_adapter *adapter,
+		   struct mac_ax_resp_chk_cca *cfg)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, reg;
+	u32 ret;
+
+	if (chk_patch_rsp_ack(adapter) == PATCH_ENABLE)
+		return MACSUCCESS;
+
+	ret = check_mac_en(adapter, cfg->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (cfg->resp_ack_chk_cca_en) {
+		reg = cfg->band == MAC_AX_BAND_1 ? R_AX_TRXPTCL_RESP_0_C1 : R_AX_TRXPTCL_RESP_0;
+		val32 = MAC_REG_R32(reg);
+		val32 |= B_AX_WMAC_RESP_ACK_BA_CHK_CCA;
+		MAC_REG_W32(reg, val32);
+	} else {
+		reg = cfg->band == MAC_AX_BAND_1 ? R_AX_TRXPTCL_RESP_0_C1 : R_AX_TRXPTCL_RESP_0;
+		val32 = MAC_REG_R32(reg);
+		val32 &= ~B_AX_WMAC_RESP_ACK_BA_CHK_CCA;
+		MAC_REG_W32(reg, val32);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_sifs_chk_cca_en(struct mac_ax_adapter *adapter, u8 band, u8 en)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, reg;
+	u32 ret;
+
+	ret = check_mac_en(adapter, band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+	if (en) {
+		reg = band == MAC_AX_BAND_1 ? R_AX_CCA_CONTROL_C1 : R_AX_CCA_CONTROL;
+		val32 = MAC_REG_R32(reg);
+		val32 |= (B_AX_SIFS_CHK_CCA_S80 | B_AX_SIFS_CHK_CCA_S40 |
+			  B_AX_SIFS_CHK_CCA_S20 | B_AX_SIFS_CHK_EDCCA);
+		MAC_REG_W32(reg, val32);
+	} else {
+		reg = band == MAC_AX_BAND_1 ? R_AX_CCA_CONTROL_C1 : R_AX_CCA_CONTROL;
+		val32 = MAC_REG_R32(reg);
+		val32 &= ~(B_AX_SIFS_CHK_CCA_S80 | B_AX_SIFS_CHK_CCA_S40 |
+			   B_AX_SIFS_CHK_CCA_S20 | B_AX_SIFS_CHK_EDCCA);
+		MAC_REG_W32(reg, val32);
+	}
+
+	return MACSUCCESS;
+}
+
+static u32 nav_ctrl_init(struct mac_ax_adapter *adapter, u8 band)
+{
+	struct mac_ax_2nav_info info;
+	u32 ret;
+
+	info.plcp_upd_nav_en = 1;
+	info.tgr_fram_upd_nav_en = 1;
+
+#ifdef PHL_FEATURE_AP
+	info.nav_up = NAV_12MS;
+#else
+	info.nav_up = NAV_25MS;
+#endif
+
+	ret = mac_two_nav_cfg(adapter, &info);
+
+	return MACSUCCESS;
+}
+
+u32 dmac_init(struct mac_ax_adapter *adapter, struct mac_ax_trx_info *info,
+	      enum mac_ax_band band)
+{
+	u32 ret = 0;
+	struct mac_ax_priv_ops *p_ops;
+
+	ret = dle_init(adapter, info->qta_mode, MAC_AX_QTA_INVALID);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]DLE init %d\n", ret);
+		return ret;
+	}
+
+	ret = preload_init(adapter, band, info->qta_mode);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]preload init B%d %d\n", band, ret);
+		return ret;
+	}
+
+	ret = hfc_init(adapter, 1, 1, 1);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]HCI FC init %d\n", ret);
+		return ret;
+	}
+
+	ret = sta_sch_init(adapter, info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]STA SCH init %d\n", ret);
+		return ret;
+	}
+
+	ret = mpdu_proc_init(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]MPDU Proc init %d\n", ret);
+		return ret;
+	}
+
+	ret = sec_eng_init(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]Security Engine init %d\n", ret);
+		return ret;
+	}
+
+	p_ops = adapter_to_priv_ops(adapter);
+	ret = p_ops->sec_info_tbl_init(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]sec info tbl init %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+u32 cmac_init(struct mac_ax_adapter *adapter, struct mac_ax_trx_info *info,
+	      enum mac_ax_band band)
+{
+	u32 ret;
+
+	ret = scheduler_init(adapter, band, info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d SCH init %d\n", band, ret);
+		return ret;
+	}
+
+	ret = rst_port_info(adapter, band);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d rst port info %d\n", band, ret);
+		return ret;
+	}
+
+	ret = addr_cam_init(adapter, band);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d ADDR_CAM reset %d\n", band, ret);
+		return ret;
+	}
+
+	ret = rx_fltr_init(adapter, band);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d RX filter init %d\n", band, ret);
+		return ret;
+	}
+
+	ret = cca_ctrl_init(adapter, band);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d CCA CTRL init %d\n", band, ret);
+		return ret;
+	}
+
+	ret = nav_ctrl_init(adapter, band);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d NAV CTRL init %d\n", band, ret);
+		return ret;
+	}
+
+	ret = spatial_reuse_init(adapter, band);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d Spatial Reuse init %d\n", band, ret);
+		return ret;
+	}
+
+	ret = tmac_init(adapter, band, info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d TMAC init %d\n", band, ret);
+		return ret;
+	}
+
+	ret = trxptcl_init(adapter, band, info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d TRXPTCL init %d\n", band, ret);
+		return ret;
+	}
+
+	ret = rmac_init(adapter, band, info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d RMAC init %d\n", band, ret);
+		return ret;
+	}
+
+	ret = cmac_com_init(adapter, band, info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d Com init %d\n", band, ret);
+		return ret;
+	}
+
+	ret = ptcl_init(adapter, band, info);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d PTCL init %d\n", band, ret);
+		return ret;
+	}
+
+	ret = cmac_dma_init(adapter, band);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d DMA init %d\n", band, ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+u32 mac_check_access(struct mac_ax_adapter *adapter, u32 offset)
+{
+	if (offset >= CMAC1_START_ADDR && offset <= CMAC1_END_ADDR) {
+		if (adapter->dle_info.qta_mode == MAC_AX_QTA_SCC)
+			return MACHWNOTEN;
+		else if (adapter->dle_info.qta_mode == MAC_AX_QTA_SCC_STF)
+			return MACHWNOTEN;
+		else
+			return MACSUCCESS;
+	} else {
+		return MACSUCCESS;
+	}
+}
+
+u32 ser_imr_config(struct mac_ax_adapter *adapter, u8 band,
+		   enum mac_ax_hwmod_sel sel)
+{
+	u32 ret;
+
+	ret = check_mac_en(adapter, band, sel);
+	if (ret) {
+		PLTFM_MSG_ERR("MAC%d band%d is not ready\n", sel, band);
+		return ret;
+	}
+
+	if (sel == MAC_AX_DMAC_SEL) {
+		ret = wdrls_imr_enable(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]wdrls_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = wsec_imr_enable(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]wsec_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = mpdu_trx_imr_enable(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]mpdu_trx_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = sta_sch_imr_enable(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]sta_sch_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = txpktctl_imr_enable(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]txpktctl_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = wde_imr_enable(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]wde_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = ple_imr_enable(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]ple_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = pktin_imr_enable(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]pktin_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = dispatcher_imr_enable(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]dispatcher_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = cpuio_imr_enable(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]cpuio_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = bbrpt_imr_enable(adapter);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]bbrpt_imr_enable %d\n", ret);
+			return ret;
+		}
+	} else if (sel == MAC_AX_CMAC_SEL) {
+		ret = scheduler_imr_enable(adapter, band);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]scheduler_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = ptcl_imr_enable(adapter, band);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]ptcl_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = cdma_imr_enable(adapter, band);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]cdma_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = phy_intf_imr_enable(adapter, band);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]phy_intf_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = rmac_imr_enable(adapter, band);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]rmac_imr_enable %d\n", ret);
+			return ret;
+		}
+
+		ret = tmac_imr_enable(adapter, band);
+		if (ret) {
+			PLTFM_MSG_ERR("[ERR]tmac_imr_enable %d\n", ret);
+			return ret;
+		}
+	} else {
+		PLTFM_MSG_ERR("illegal sel %d\n", sel);
+		return MACNOITEM;
+	}
+	return MACSUCCESS;
+}
+
+u32 mac_enable_imr(struct mac_ax_adapter *adapter, u8 band,
+		   enum mac_ax_hwmod_sel sel)
+{
+	u32 ret;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	ret = p_ops->ser_imr_config(adapter, band, sel);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]ser_imr_config : %d\n", ret);
+		return ret;
+	}
+	return MACSUCCESS;
+}
+
+u32 mac_trx_init(struct mac_ax_adapter *adapter, struct mac_ax_trx_info *info)
+{
+	u32 ret = 0;
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+#if MAC_AX_COEX_INIT_EN
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+#endif
+	u8 val8;
+
+	/* Check TRX status is idle later. */
+	ret = dmac_init(adapter, info, MAC_AX_BAND_0);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]DMAC init %d\n", ret);
+		return ret;
+	}
+
+	ret = cmac_init(adapter, info, MAC_AX_BAND_0);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC%d init %d\n", MAC_AX_BAND_0, ret);
+		return ret;
+	}
+
+#if MAC_AX_COEX_INIT_EN
+	ret = p_ops->coex_mac_init(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] update coex setting %d\n", ret);
+		return ret;
+	}
+#endif
+
+	ret = is_qta_dbcc(adapter, info->qta_mode, &val8);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] is_qta_dbcc %d\n", ret);
+		return ret;
+	}
+	if (val8) {
+		ret = mac_ops->dbcc_enable(adapter, info, 1);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]dbcc_enable init %d\n", ret);
+			return ret;
+		}
+	}
+
+	ret = mac_enable_imr(adapter, MAC_AX_BAND_0, MAC_AX_DMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] enable DMAC IMR %d\n", ret);
+		return ret;
+	}
+
+	ret = mac_enable_imr(adapter, MAC_AX_BAND_0, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR] enable CMAC0 IMR %d\n", ret);
+		return ret;
+	}
+
+	ret = mac_err_imr_ctrl(adapter, MAC_AX_FUNC_EN);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR] enable err IMR %d\n", ret);
+		return ret;
+	}
+
+	ret = set_host_rpr(adapter, info->rpr_cfg);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]set host rpr %d\n", ret);
+		return ret;
+	}
+
+	ret = set_l2_status(adapter);
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]%s %d\n", __func__, ret);
+		return ret;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_tx_mode_sel(struct mac_ax_adapter *adapter,
+		    struct mac_ax_mac_tx_mode_sel *mode_sel)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32, ret;
+
+	ret = check_mac_en(adapter, MAC_AX_BAND_0, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	val32 = MAC_REG_R32(R_AX_SS_DL_RPT_CRTL);
+	val32 &= ~(B_AX_SS_TXOP_MODE_0 | B_AX_SS_TXOP_MODE_1 |
+		   B_AX_SS_TXOP_MODE_2 | B_AX_SS_TXOP_MODE_3);
+	val32 |= (mode_sel->txop_rot_wmm0_en ? B_AX_SS_TXOP_MODE_0 : 0) |
+		 (mode_sel->txop_rot_wmm1_en ? B_AX_SS_TXOP_MODE_1 : 0) |
+		 (mode_sel->txop_rot_wmm2_en ? B_AX_SS_TXOP_MODE_2 : 0) |
+		 (mode_sel->txop_rot_wmm3_en ? B_AX_SS_TXOP_MODE_3 : 0);
+	MAC_REG_W32(R_AX_SS_DL_RPT_CRTL, val32);
+
+	return MACSUCCESS;
+}
+
+u32 mac_two_nav_cfg(struct mac_ax_adapter *adapter,
+		    struct mac_ax_2nav_info *info)
+
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32 = 0;
+
+	val32 = MAC_REG_R32(R_AX_WMAC_NAV_CTL);
+	val32 |= ((info->plcp_upd_nav_en ? B_AX_WMAC_PLCP_UP_NAV_EN : 0)) |
+		 ((info->tgr_fram_upd_nav_en ? B_AX_WMAC_TF_UP_NAV_EN : 0));
+
+	val32 = SET_CLR_WORD(val32, info->nav_up, B_AX_WMAC_NAV_UPPER);
+
+	if (info->nav_up > NAV_UPPER_DEFAULT)
+		val32 |= B_AX_WMAC_NAV_UPPER_EN;
+
+	MAC_REG_W32(R_AX_WMAC_NAV_CTL, val32);
+	return MACSUCCESS;
+}
+
+u32 mac_feat_init(struct mac_ax_adapter *adapter, struct mac_ax_trx_info *info)
+{
+	u32 ret;
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	ret = p_ops->bacam_init(adapter);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]CMAC BACAM init %d\n", ret);
+		return ret;
+	}
+	return MACSUCCESS;
+}
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trxcfg.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trxcfg.h
new file mode 100644
index 000000000000..5353a38866b3
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/trxcfg.h
@@ -0,0 +1,361 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_TRXCFG_H_
+#define _MAC_AX_TRXCFG_H_
+
+#include "../type.h"
+#include "hw.h"
+#include "init.h"
+#include "role.h"
+#include "cmac_tx.h"
+#include "rx_filter.h"
+#include "dle.h"
+#include "hci_fc.h"
+#include "mport.h"
+#include "spatial_reuse.h"
+
+/*--------------------Define -------------------------------------------*/
+#define TRXCFG_WAIT_CNT		2000
+#define TRXCFG_WAIT_US		1
+
+/* MPDU Processor Control */
+#define TRXCFG_MPDU_PROC_ACT_FRWD	0x02A95A95
+#define TRXCFG_MPDU_PROC_TF_FRWD	0x0000AA55
+#define TRXCFG_MPDU_PROC_CUT_CTRL	0x010E05F0
+
+/* RMAC timeout control */
+#if (MAC_AX_8852C_SUPPORT) && defined(PHL_FEATURE_AP)
+#define TRXCFG_RMAC_CCA_TO	128
+#else
+#define TRXCFG_RMAC_CCA_TO	32
+#endif
+#define TRXCFG_RMAC_DATA_TO	15
+
+#define S_AX_TXSC_20M_0		0
+#define S_AX_TXSC_20M_4		4
+#define S_AX_TXSC_40M_0		0
+#define S_AX_TXSC_40M_4		4
+#define S_AX_TXSC_80M_0		0
+#define S_AX_TXSC_80M_4		4
+
+#define RRSR_OFDM_CCK_EN	3
+
+/* TRXPTCL SIFS TIME*/
+#define WMAC_SPEC_SIFS_OFDM_52A 0x15
+#define WMAC_SPEC_SIFS_OFDM_52B 0x11
+#define WMAC_SPEC_SIFS_OFDM_52C 0x11
+#define WMAC_SPEC_SIFS_OFDM_51B 0x11
+#define WMAC_SPEC_SIFS_CCK	 0xA
+
+/* RRSR disable 5.5M CCK*/
+#define WMAC_CCK_EN_1M 0x1
+#define WMAC_RRSR_RATE_LEGACY_EN 0x1
+
+/* SRAM fifo address */
+#define CMAC_TBL_BASE_ADDR	0x18840000
+
+#define CMAC1_START_ADDR	0xE000
+#define CMAC1_END_ADDR		0xFFFF
+
+#if MAC_AX_ASIC_TEMP
+#define R_AX_LTECOEX_CTRL 0x38
+#define R_AX_LTECOEX_CTRL_2 0x3C
+#endif
+
+#define S_AX_CTS2S_TH_1K 4
+#define S_AX_CTS2S_TH_SEC_256B 1
+
+#define S_AX_PTCL_TO_2MS 0x3F
+
+#define LBK_PLCP_DLY_DEF 0x28
+#define LBK_PLCP_DLY_FPGA 0x46
+
+#define PLD_RLS_MAX_PG 127
+#define RX_MAX_LEN_UNIT 512
+/* if spec max len is not align to rx max len unit, add 1 unit */
+#define RX_SPEC_MAX_LEN (11454 + RX_MAX_LEN_UNIT)
+
+#define SCH_PREBKF_24US 0x18
+#define SCH_PREBKF_16US 0x10
+
+#define BCN_IFS_25US 0x19
+#define SIFS_MACTXEN_T1_V0 0x47
+#define SIFS_MACTXEN_T1_V1 0x41
+
+#define SDIO_DRV_INFO_SIZE 2
+
+#define DMA_MOD_PCIE_1B 0x0
+#define DMA_MOD_PCIE_4B 0x1
+#define DMA_MOD_USB 0x2
+#define DMA_MOD_SDIO 0x3
+
+#define  NAV_12MS 0x5D // (12ms, unit: 128us)
+#define  NAV_25MS 0xC4 // (25ms, unit: 128us)
+
+#define FWD_TO_HOST 0
+#define FWD_TO_WLCPU 1
+#define FWD_TO_DATACPU 2
+
+#define AMPDU_MAX_LEN_VHT_262K 0x3FF80
+#define SS2F_PATH_WLCPU 0x0A
+
+#define NAV_UPPER_DEFAULT 0
+
+#define TCR_UDF_THSD          0x6
+#define TXDFIFO_HIGH_MCS_THRE 0x7
+#define TXDFIFO_LOW_MCS_THRE  0x7
+
+#define B_AX_TX_TO  0x2
+#define DRVINFO_PATCH_SIZE  0x5
+
+/* response reference rate */
+#define REF2RXRATEANDCCTBL	0
+#define REF2RXRATEONLY		1
+
+/*The number of STA in UL SS2FRPT*/
+#define MAX_ULSS2F_SU_STA_NUM 0x3
+#define MAX_ULSS2F_TWT_STA_NUM 0x3
+#define MAX_ULSS2F_RU_STA_NUM 0x3
+
+/*The number of STA in DL SS2FRPT*/
+#define MAX_DLSS2F_SU_STA_NUM 0xF
+#define MAX_DLSS2F_MU_STA_NUM 0xF
+#define MAX_DLSS2F_RU_STA_NUM 0xF
+
+/*The bsr len threshold of UL SS2FRPT*/
+#define UL_NORMAL_SS2FWRPT_BSR_THRES 0x50
+#define UL_LATCY_SS2FWRPT_BSR_THRES 0x1
+
+/*--------------------Define MACRO--------------------------------------*/
+#define RX_FULL_MODE (B_AX_RU0_PTR_FULL_MODE | B_AX_RU1_PTR_FULL_MODE | \
+		      B_AX_RU2_PTR_FULL_MODE | B_AX_RU3_PTR_FULL_MODE | \
+		      B_AX_CSI_PTR_FULL_MODE | B_AX_RXSTS_PTR_FULL_MODE)
+
+/*--------------------Define Enum---------------------------------------*/
+/*--------------------Define Struct-------------------------------------*/
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_enable_imr
+ *
+ * @param *adapter
+ * @param band
+ * @param sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_enable_imr(struct mac_ax_adapter *adapter, u8 band,
+		   enum mac_ax_hwmod_sel sel);
+
+u32 ser_imr_config(struct mac_ax_adapter *adapter, u8 band,
+		   enum mac_ax_hwmod_sel sel);
+
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief check_mac_en
+ *
+ * @param *adapter
+ * @param band
+ * @param sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 check_mac_en(struct mac_ax_adapter *adapter, u8 band,
+		 enum mac_ax_hwmod_sel sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_check_access
+ *
+ * @param *adapter
+ * @param offset
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_access(struct mac_ax_adapter *adapter, u32 offset);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief cmac_init
+ *
+ * @param *adapter
+ * @param *info
+ * @param band
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 cmac_init(struct mac_ax_adapter *adapter, struct mac_ax_trx_info *info,
+	      enum mac_ax_band band);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_trx_init
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_trx_init(struct mac_ax_adapter *adapter, struct mac_ax_trx_info *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_tx_mode_sel
+ *
+ * @param *adapter
+ * @param *mode_sel
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_tx_mode_sel(struct mac_ax_adapter *adapter,
+		    struct mac_ax_mac_tx_mode_sel *mode_sel);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup Basic_TRX
+ * @{
+ * @addtogroup TX_Config
+ * @{
+ */
+
+/**
+ * @brief mac_two_nav_cfg
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_two_nav_cfg(struct mac_ax_adapter *adapter,
+		    struct mac_ax_2nav_info *info);
+/**
+ * @}
+ * @}
+ *
+ *//**
+ * @brief mac_sifs_chk_edcca_en
+ *
+ * @param *adapter
+ * @param *band
+ * @param *en
+ * @return check cca in sifs enable/disable
+ * @retval u32
+ */
+u32 mac_sifs_chk_cca_en(struct mac_ax_adapter *adapter, u8 band, u8 en);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @}
+ * @}
+ *
+ *//**
+ * @brief _patch_rsp_ack
+ *
+ * @param *adapter
+ * @param *band
+ * @param *en
+ * @return check cca in sifs enable/disable
+ * @retval u32
+ */
+u32 _patch_rsp_ack(struct mac_ax_adapter *adapter,
+		   struct mac_ax_resp_chk_cca *cfg);
+/**
+ * @}
+ * @}
+ */
+/**
+ * @brief chk_patch_ss2f_path
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval bool
+ */
+bool chk_patch_ss2f_path(struct mac_ax_adapter *adapter);
+
+/**
+ * @brief mac_feat_init
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval bool
+ */
+u32 mac_feat_init(struct mac_ax_adapter *adapter, struct mac_ax_trx_info *info);
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/twt.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/twt.c
new file mode 100644
index 000000000000..233fde5a589e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/twt.c
@@ -0,0 +1,329 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "twt.h"
+
+u32 twt_info_init(struct mac_ax_adapter *adapter)
+{
+	adapter->twt_info =
+		(struct mac_ax_twt_info *)PLTFM_MALLOC(TWT_INFO_SIZE);
+	adapter->twt_info->err_rec = 0;
+	adapter->twt_info->pdbg_info = (u8 *)PLTFM_MALLOC(TWT_DBG_INFO_SIZE);
+	PLTFM_MEMSET(adapter->twt_info->pdbg_info, 0, TWT_DBG_INFO_SIZE);
+
+	return MACSUCCESS;
+}
+
+u32 twt_info_exit(struct mac_ax_adapter *adapter)
+{
+	PLTFM_FREE(adapter->twt_info->pdbg_info, TWT_DBG_INFO_SIZE);
+	PLTFM_FREE(adapter->twt_info, TWT_INFO_SIZE);
+
+	return MACSUCCESS;
+}
+
+u32 mac_twt_info_upd_h2c(struct mac_ax_adapter *adapter,
+			 struct mac_ax_twt_para *info)
+{
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_twtinfo_upd *hdr;
+	u32 ret = MACSUCCESS;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_twtinfo_upd *)
+		h2cb_put(h2cb, sizeof(struct fwcmd_twtinfo_upd));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	/* port 4 not support */
+	if (info->port >= MAC_AX_PORT_4) {
+		PLTFM_MSG_ERR("[ERR] twt info upd h2c port %d\n", info->port);
+		return MACFUNCINPUT;
+	}
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(info->nego_tp,
+				     FWCMD_H2C_TWTINFO_UPD_NEGOTYPE) |
+			    SET_WORD(info->act, FWCMD_H2C_TWTINFO_UPD_ACT) |
+			    (info->trig ? FWCMD_H2C_TWTINFO_UPD_TRIGGER : 0) |
+			    (info->flow_tp ?
+			     FWCMD_H2C_TWTINFO_UPD_FLOWTYPE : 0) |
+			    (info->impt ? FWCMD_H2C_TWTINFO_UPD_IMPT : 0) |
+			    (info->wake_unit ?
+			     FWCMD_H2C_TWTINFO_UPD_WAKEDURUNIT : 0) |
+			    (info->rsp_pm ? FWCMD_H2C_TWTINFO_UPD_RSPPM : 0) |
+			    (info->proct ? FWCMD_H2C_TWTINFO_UPD_PROT : 0) |
+			    SET_WORD(info->flow_id,
+				     FWCMD_H2C_TWTINFO_UPD_FLOWID) |
+			    SET_WORD(info->id, FWCMD_H2C_TWTINFO_UPD_ID) |
+			    (info->band ? FWCMD_H2C_TWTINFO_UPD_BAND : 0) |
+			    SET_WORD(info->port, FWCMD_H2C_TWTINFO_UPD_PORT));
+
+	hdr->dword1 =
+		cpu_to_le32(SET_WORD(info->wake_exp,
+				     FWCMD_H2C_TWTINFO_UPD_WAKE_EXP) |
+			    SET_WORD(info->wake_man,
+				     FWCMD_H2C_TWTINFO_UPD_WAKE_MAN) |
+			    SET_WORD(info->twtulfixmode,
+				     FWCMD_H2C_TWTINFO_UPD_ULFIXMODE) |
+			    SET_WORD(info->dur,
+				     FWCMD_H2C_TWTINFO_UPD_DUR));
+
+	hdr->dword2 =
+		cpu_to_le32(SET_WORD(info->trgt_l,
+				     FWCMD_H2C_TWTINFO_UPD_TGT_L));
+
+	hdr->dword3 =
+		cpu_to_le32(SET_WORD(info->trgt_h,
+				     FWCMD_H2C_TWTINFO_UPD_TGT_H));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_TWT,
+			      FWCMD_H2C_FUNC_TWTINFO_UPD,
+			      0,
+			      0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_twt_act_h2c(struct mac_ax_adapter *adapter,
+		    struct mac_ax_twtact_para *info)
+{
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_twt_stansp_upd *hdr;
+	u32 ret = MACSUCCESS;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	hdr = (struct fwcmd_twt_stansp_upd *)
+		h2cb_put(h2cb, sizeof(struct fwcmd_twt_stansp_upd));
+	if (!hdr) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	hdr->dword0 =
+		cpu_to_le32(SET_WORD(info->macid,
+				     FWCMD_H2C_TWT_STANSP_UPD_MACID) |
+			    SET_WORD(info->id,
+				     FWCMD_H2C_TWT_STANSP_UPD_ID) |
+			    SET_WORD(info->act,
+				     FWCMD_H2C_TWT_STANSP_UPD_ACT));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_TWT,
+			      FWCMD_H2C_FUNC_TWT_STANSP_UPD,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	h2c_end_flow(adapter);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_twt_staanno_h2c(struct mac_ax_adapter *adapter,
+			struct mac_ax_twtanno_para *info)
+{
+	#if MAC_AX_PHL_H2C
+		struct rtw_h2c_pkt *h2cb;
+	#else
+		struct h2c_buf *h2cb;
+	#endif
+		struct fwcmd_twt_announce_upd *hdr;
+		u32 ret = MACSUCCESS;
+
+		h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+		if (!h2cb)
+			return MACNPTR;
+
+		hdr = (struct fwcmd_twt_announce_upd *)h2cb_put(h2cb,
+			sizeof(struct fwcmd_twt_announce_upd));
+		if (!hdr) {
+			ret = MACNOBUF;
+			goto fail;
+		}
+
+		hdr->dword0 =
+			cpu_to_le32(SET_WORD(info->macid, FWCMD_H2C_TWT_ANNOUNCE_UPD_MACID));
+
+		ret = h2c_pkt_set_hdr(adapter, h2cb,
+				      FWCMD_TYPE_H2C,
+				      FWCMD_H2C_CAT_MAC,
+				      FWCMD_H2C_CL_TWT,
+				      FWCMD_H2C_FUNC_TWT_ANNOUNCE_UPD,
+				      1,
+				      0);
+		if (ret)
+			goto fail;
+
+		ret = h2c_pkt_build_txd(adapter, h2cb);
+		if (ret)
+			goto fail;
+
+	#if MAC_AX_PHL_H2C
+		ret = PLTFM_TX(h2cb);
+	#else
+		ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+		if (ret)
+			goto fail;
+
+		h2cb_free(adapter, h2cb);
+
+		h2c_end_flow(adapter);
+
+		return MACSUCCESS;
+fail:
+		h2cb_free(adapter, h2cb);
+
+		return ret;
+}
+
+void mac_twt_wait_anno(struct mac_ax_adapter *adapter,
+		       u8 *c2h_content, u8 *upd_addr)
+{
+	u32 plat_c2h_content = *(u32 *)(c2h_content);
+	struct mac_ax_twtanno_c2hpara *para =
+		(struct mac_ax_twtanno_c2hpara *)upd_addr;
+
+	para->wait_case = GET_FIELD(plat_c2h_content,
+				    FWCMD_C2H_WAIT_ANNOUNCE_WAIT_CASE);
+	para->macid0 = GET_FIELD(plat_c2h_content,
+				 FWCMD_C2H_WAIT_ANNOUNCE_MACID0);
+	para->macid1 = GET_FIELD(plat_c2h_content,
+				 FWCMD_C2H_WAIT_ANNOUNCE_MACID1);
+	para->macid2 = GET_FIELD(plat_c2h_content,
+				 FWCMD_C2H_WAIT_ANNOUNCE_MACID2);
+}
+
+u32 mac_get_tsf(struct mac_ax_adapter *adapter, struct mac_ax_port_tsf *tsf)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 reg_l = 0;
+	u32 reg_h = 0;
+	u32 ret;
+	u8 port = tsf->port;
+
+	ret = check_mac_en(adapter, tsf->band, MAC_AX_CMAC_SEL);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	if (port >= adapter->hw_info->port_num) {
+		PLTFM_MSG_ERR("%s invalid port idx %d\n", __func__, port);
+		return MACPORTERR;
+	}
+
+	switch (port) {
+	case MAC_AX_PORT_0:
+		reg_h = tsf->band == MAC_AX_BAND_0 ?
+			R_AX_TSFTR_HIGH_P0 : R_AX_TSFTR_HIGH_P0_C1;
+		reg_l = tsf->band == MAC_AX_BAND_0 ?
+			R_AX_TSFTR_LOW_P0 : R_AX_TSFTR_LOW_P0_C1;
+		break;
+	case MAC_AX_PORT_1:
+		reg_h = tsf->band == MAC_AX_BAND_0 ?
+			R_AX_TSFTR_HIGH_P1 : R_AX_TSFTR_HIGH_P1_C1;
+		reg_l = tsf->band == MAC_AX_BAND_0 ?
+			R_AX_TSFTR_LOW_P1 : R_AX_TSFTR_LOW_P1_C1;
+		break;
+	case MAC_AX_PORT_2:
+		reg_h = tsf->band == MAC_AX_BAND_0 ?
+			R_AX_TSFTR_HIGH_P2 : R_AX_TSFTR_HIGH_P2_C1;
+		reg_l = tsf->band == MAC_AX_BAND_0 ?
+			R_AX_TSFTR_LOW_P2 : R_AX_TSFTR_LOW_P2_C1;
+		break;
+	case MAC_AX_PORT_3:
+		reg_h = tsf->band == MAC_AX_BAND_0 ?
+			R_AX_TSFTR_HIGH_P3 : R_AX_TSFTR_HIGH_P3_C1;
+		reg_l = tsf->band == MAC_AX_BAND_0 ?
+			R_AX_TSFTR_LOW_P3 : R_AX_TSFTR_LOW_P3_C1;
+		break;
+	case MAC_AX_PORT_4:
+		reg_h = tsf->band == MAC_AX_BAND_0 ?
+			R_AX_TSFTR_HIGH_P4 : R_AX_TSFTR_HIGH_P4_C1;
+		reg_l = tsf->band == MAC_AX_BAND_0 ?
+			R_AX_TSFTR_LOW_P4 : R_AX_TSFTR_LOW_P4_C1;
+		break;
+	default:
+		return MACFUNCINPUT;
+	}
+
+	tsf->tsf_h = MAC_REG_R32(reg_h);
+	tsf->tsf_l = MAC_REG_R32(reg_l);
+
+	return MACSUCCESS;
+}
+
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/twt.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/twt.h
new file mode 100644
index 000000000000..bf2bed259f24
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/twt.h
@@ -0,0 +1,176 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_TWT_H_
+#define _MAC_AX_TWT_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+
+#define TWT_INFO_SIZE (sizeof(struct mac_ax_twt_info))
+#define TWT_DBG_INFO_SIZE 16 /* 1st dword of each TWT common info */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup TWT
+ * @{
+ */
+
+/**
+ * @brief twt_info_init
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 twt_info_init(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup TWT
+ * @{
+ */
+
+/**
+ * @brief twt_info_exit
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 twt_info_exit(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup TWT
+ * @{
+ */
+
+/**
+ * @brief mac_twt_info_upd_h2c
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_twt_info_upd_h2c(struct mac_ax_adapter *adapter,
+			 struct mac_ax_twt_para *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup TWT
+ * @{
+ */
+
+/**
+ * @brief mac_twt_act_h2c
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_twt_act_h2c(struct mac_ax_adapter *adapter,
+		    struct mac_ax_twtact_para *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup TWT
+ * @{
+ */
+
+/**
+ * @brief mac_twt_staanno_h2c
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_twt_staanno_h2c(struct mac_ax_adapter *adapter,
+			struct mac_ax_twtanno_para *info);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup TWT
+ * @{
+ */
+
+/**
+ * @brief mac_twt_wait_anno
+ *
+ * @param *adapter
+ * @param *c2h_content
+ * @param *upd_addr
+ * @return Please Place Description here.
+ * @retval void
+ */
+void mac_twt_wait_anno(struct mac_ax_adapter *adapter,
+		       u8 *c2h_content, u8 *upd_addr);
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup PowerSaving
+ * @{
+ * @addtogroup TWT
+ * @{
+ */
+
+/**
+ * @brief mac_get_tsf
+ *
+ * @param *adapter
+ * @param *tsf
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_tsf(struct mac_ax_adapter *adapter, struct mac_ax_port_tsf *tsf);
+/**
+ * @}
+ * @}
+ */
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/wowlan.c b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/wowlan.c
new file mode 100644
index 000000000000..4a77ecc5d322
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/wowlan.c
@@ -0,0 +1,2690 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#include "wowlan.h"
+#include "mac_priv.h"
+
+static u32 wow_bk_status[4] = {0};
+static u32 tgt_ind_orig;
+static u32 frm_tgt_ind_orig;
+static u32 wol_pattern_orig;
+static u32 wol_uc_orig;
+static u32 wol_magic_orig;
+static u8 mdns_v4_multicast_addr[] = {0x01, 0x00, 0x5e, 0x00, 0x00, 0xFB};
+static u8 mdns_v6_multicast_addr[] = {0x33, 0x33, 0x00, 0x00, 0x00, 0xFB};
+static u8 wsd_v4_multicast_addr[] = {0x01, 0x00, 0x5E, 0x7F, 0xFF, 0xFA};
+static u8 wsd_v6_multicast_addr[] = {0x33, 0x33, 0x00, 0x00, 0x00, 0x0C};
+
+static u32 send_h2c_keep_alive(struct mac_ax_adapter *adapter,
+			       struct keep_alive *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_keep_alive *fwcmd_kalive;
+	u32 ret = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_keep_alive));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_kalive = (struct fwcmd_keep_alive *)buf;
+	fwcmd_kalive->dword0 =
+	cpu_to_le32((parm->keepalive_en ?
+		     FWCMD_H2C_KEEP_ALIVE_KEEPALIVE_EN : 0) |
+		SET_WORD(parm->packet_id, FWCMD_H2C_KEEP_ALIVE_PACKET_ID) |
+		SET_WORD(parm->period, FWCMD_H2C_KEEP_ALIVE_PERIOD) |
+		SET_WORD(parm->mac_id, FWCMD_H2C_KEEP_ALIVE_MAC_ID));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_KEEP_ALIVE,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 send_h2c_disconnect_detect(struct mac_ax_adapter *adapter,
+				      struct disconnect_detect *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_disconnect_detect *fwcmd_disconnect_det;
+	u32 ret = 0;
+	u32 tmp;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_disconnect_detect));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_disconnect_det = (struct fwcmd_disconnect_detect *)buf;
+	fwcmd_disconnect_det->dword0 =
+	cpu_to_le32((parm->disconnect_detect_en ?
+		     FWCMD_H2C_DISCONNECT_DETECT_DISCONNECT_DETECT_EN : 0) |
+	(parm->tryok_bcnfail_count_en ?
+	 FWCMD_H2C_DISCONNECT_DETECT_TRYOK_BCNFAIL_COUNT_EN : 0) |
+	(parm->disconnect_en ? FWCMD_H2C_DISCONNECT_DETECT_DISCONNECT_EN : 0) |
+	SET_WORD(parm->mac_id, FWCMD_H2C_DISCONNECT_DETECT_MAC_ID) |
+	SET_WORD(parm->check_period, FWCMD_H2C_DISCONNECT_DETECT_CHECK_PERIOD) |
+	SET_WORD(parm->try_pkt_count,
+		 FWCMD_H2C_DISCONNECT_DETECT_TRY_PKT_COUNT));
+
+	tmp = SET_WORD(parm->tryok_bcnfail_count_limit,
+		       FWCMD_H2C_DISCONNECT_DETECT_TRYOK_BCNFAIL_COUNT_LIMIT);
+	fwcmd_disconnect_det->dword1 = cpu_to_le32(tmp);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_DISCONNECT_DETECT,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 send_h2c_wow_global(struct mac_ax_adapter *adapter,
+			       struct wow_global *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_wow_global *fwcmd_wow_glo;
+	u32 ret = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_wow_global)
+		       + sizeof(struct mac_ax_remotectrl_info_parm_) - 4);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_wow_glo = (struct fwcmd_wow_global *)buf;
+	fwcmd_wow_glo->dword0 =
+	cpu_to_le32((parm->wow_en ? FWCMD_H2C_WOW_GLOBAL_WOW_EN : 0) |
+		(parm->drop_all_pkt ? FWCMD_H2C_WOW_GLOBAL_DROP_ALL_PKT : 0) |
+		(parm->rx_parse_after_wake ?
+		 FWCMD_H2C_WOW_GLOBAL_RX_PARSE_AFTER_WAKE : 0) |
+		SET_WORD(parm->mac_id, FWCMD_H2C_WOW_GLOBAL_MAC_ID) |
+		SET_WORD(parm->pairwise_sec_algo,
+			 FWCMD_H2C_WOW_GLOBAL_PAIRWISE_SEC_ALGO) |
+		SET_WORD(parm->group_sec_algo,
+			 FWCMD_H2C_WOW_GLOBAL_GROUP_SEC_ALGO));
+
+	//fwcmd_wow_glo->dword1 =
+	//	cpu_to_le32(parm->remotectrl_info_content);
+	PLTFM_MEMCPY(&fwcmd_wow_glo->dword1, &parm->remotectrl_info_content,
+		     sizeof(struct mac_ax_remotectrl_info_parm_));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_WOW_GLOBAL,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 send_h2c_gtk_ofld(struct mac_ax_adapter *adapter,
+			     struct gtk_ofld *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_gtk_ofld *fwcmd_gtk_ofl;
+	u32 ret = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_gtk_ofld)
+		       + sizeof(struct mac_ax_gtk_info_parm_) - 4);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_gtk_ofl = (struct fwcmd_gtk_ofld *)buf;
+	fwcmd_gtk_ofl->dword0 =
+	cpu_to_le32((parm->gtk_en ? FWCMD_H2C_GTK_OFLD_GTK_EN : 0) |
+		(parm->tkip_en ? FWCMD_H2C_GTK_OFLD_TKIP_EN : 0) |
+		(parm->ieee80211w_en ? FWCMD_H2C_GTK_OFLD_IEEE80211W_EN : 0) |
+		(parm->pairwise_wakeup ?
+		 FWCMD_H2C_GTK_OFLD_PAIRWISE_WAKEUP : 0) |
+		(parm->norekey_wakeup ?
+		 FWCMD_H2C_GTK_OFLD_NOREKEY_WAKEUP : 0) |
+		SET_WORD(parm->mac_id, FWCMD_H2C_GTK_OFLD_MAC_ID) |
+		SET_WORD(parm->gtk_rsp_id, FWCMD_H2C_GTK_OFLD_GTK_RSP_ID));
+
+	fwcmd_gtk_ofl->dword1 =
+	cpu_to_le32(SET_WORD(parm->pmf_sa_query_id, FWCMD_H2C_GTK_OFLD_PMF_SA_QUERY_ID) |
+		    SET_WORD(parm->bip_sec_algo, FWCMD_H2C_GTK_OFLD_PMF_BIP_SEC_ALGO) |
+		    SET_WORD(parm->algo_akm_suit, FWCMD_H2C_GTK_OFLD_ALGO_AKM_SUIT));
+
+	PLTFM_MEMCPY(&fwcmd_gtk_ofl->dword2, &parm->gtk_info_content,
+		     sizeof(struct mac_ax_gtk_info_parm_));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_GTK_OFLD,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 send_h2c_arp_ofld(struct mac_ax_adapter *adapter,
+			     struct arp_ofld *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_arp_ofld *fwcmd_arp_ofl;
+	u32 ret = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_arp_ofld));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_arp_ofl = (struct fwcmd_arp_ofld *)buf;
+	fwcmd_arp_ofl->dword0 =
+	cpu_to_le32((parm->arp_en ? FWCMD_H2C_ARP_OFLD_ARP_EN : 0) |
+		(parm->arp_action ? FWCMD_H2C_ARP_OFLD_ARP_ACTION : 0) |
+		SET_WORD(parm->mac_id, FWCMD_H2C_ARP_OFLD_MAC_ID) |
+		SET_WORD(parm->arp_rsp_id, FWCMD_H2C_ARP_OFLD_ARP_RSP_ID));
+
+	fwcmd_arp_ofl->dword1 =
+		cpu_to_le32(parm->arp_info_content);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_ARP_OFLD,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 send_h2c_ndp_ofld(struct mac_ax_adapter *adapter,
+			     struct ndp_ofld *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_ndp_ofld *fwcmd_ndp_ofl;
+	u32 ret = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_ndp_ofld) + 2 *
+		       sizeof(struct mac_ax_ndp_info_parm_) - 4);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_ndp_ofl = (struct fwcmd_ndp_ofld *)buf;
+	fwcmd_ndp_ofl->dword0 =
+	cpu_to_le32((parm->ndp_en ? FWCMD_H2C_NDP_OFLD_NDP_EN : 0) |
+		    SET_WORD(parm->mac_id, FWCMD_H2C_NDP_OFLD_MAC_ID) |
+		    SET_WORD(parm->na_id, FWCMD_H2C_NDP_OFLD_NA_ID));
+
+	PLTFM_MEMCPY(&fwcmd_ndp_ofl->dword1, &parm->ndp_info_content, 2 *
+		     sizeof(struct mac_ax_ndp_info_parm_));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_NDP_OFLD,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 send_h2c_realwow(struct mac_ax_adapter *adapter,
+			    struct realwow *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_realwow *fwcmd_realw;
+	u32 ret = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_realwow) +
+		       sizeof(struct mac_ax_realwowv2_info_parm_) - 4);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_realw = (struct fwcmd_realwow *)buf;
+	fwcmd_realw->dword0 =
+	cpu_to_le32((parm->realwow_en ? FWCMD_H2C_REALWOW_REALWOW_EN : 0) |
+		(parm->auto_wakeup ? FWCMD_H2C_REALWOW_AUTO_WAKEUP : 0) |
+		SET_WORD(parm->mac_id, FWCMD_H2C_REALWOW_MAC_ID));
+
+	fwcmd_realw->dword1 =
+	cpu_to_le32(SET_WORD(parm->keepalive_id,
+			     FWCMD_H2C_REALWOW_KEEPALIVE_ID) |
+	SET_WORD(parm->wakeup_pattern_id, FWCMD_H2C_REALWOW_WAKEUP_PATTERN_ID) |
+	SET_WORD(parm->ack_pattern_id, FWCMD_H2C_REALWOW_ACK_PATTERN_ID));
+
+	fwcmd_realw->dword2 =
+		cpu_to_le32(parm->realwow_info_content);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_REALWOW,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 send_h2c_nlo(struct mac_ax_adapter *adapter,
+			struct nlo *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+
+	u32 *h2cb_u32;
+	u32 *nlo_parm_u32;
+	u32 ret = 0;
+	u8 sh;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_nlo) +
+		       sizeof(struct mac_ax_nlo_networklist_parm_) - 4);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	nlo_parm_u32 = &parm->nlo_networklistinfo_content;
+	h2cb_u32 = (u32 *)buf;
+	*h2cb_u32 = cpu_to_le32((parm->nlo_en ? FWCMD_H2C_NLO_NLO_EN : 0) |
+				(parm->nlo_32k_en ? FWCMD_H2C_NLO_NLO_32K_EN : 0) |
+				(parm->ignore_cipher_type ? FWCMD_H2C_NLO_IGNORE_CIPHER_TYPE : 0) |
+				SET_WORD(parm->mac_id, FWCMD_H2C_NLO_MAC_ID));
+	h2cb_u32++;
+
+	*h2cb_u32 = cpu_to_le32(*nlo_parm_u32);
+	h2cb_u32++;
+	nlo_parm_u32 = parm->nlo_networklistinfo_more;
+
+	for (sh = 0; sh < (sizeof(struct mac_ax_nlo_networklist_parm_) / 4 - 1); sh++)
+		*(h2cb_u32 + sh) = cpu_to_le32(*(nlo_parm_u32 + sh));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_NLO,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 send_h2c_wakeup_ctrl(struct mac_ax_adapter *adapter,
+				struct wakeup_ctrl *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_wakeup_ctrl *fwcmd_wakeup_ctr;
+	u32 ret = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_wakeup_ctrl));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_wakeup_ctr = (struct fwcmd_wakeup_ctrl *)buf;
+	fwcmd_wakeup_ctr->dword0 =
+	cpu_to_le32((parm->pattern_match_en ?
+		     FWCMD_H2C_WAKEUP_CTRL_PATTERN_MATCH_EN : 0) |
+	(parm->magic_en ? FWCMD_H2C_WAKEUP_CTRL_MAGIC_EN : 0) |
+	(parm->hw_unicast_en ? FWCMD_H2C_WAKEUP_CTRL_HW_UNICAST_EN : 0) |
+	(parm->fw_unicast_en ? FWCMD_H2C_WAKEUP_CTRL_FW_UNICAST_EN : 0) |
+	(parm->deauth_wakeup ? FWCMD_H2C_WAKEUP_CTRL_DEAUTH_WAKEUP : 0) |
+	(parm->rekey_wakeup ? FWCMD_H2C_WAKEUP_CTRL_REKEY_WAKEUP : 0) |
+	(parm->eap_wakeup ? FWCMD_H2C_WAKEUP_CTRL_EAP_WAKEUP : 0) |
+	(parm->all_data_wakeup ? FWCMD_H2C_WAKEUP_CTRL_ALL_DATA_WAKEUP : 0) |
+	SET_WORD(parm->mac_id, FWCMD_H2C_WAKEUP_CTRL_MAC_ID));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_WAKEUP_CTRL,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 send_h2c_negative_pattern(struct mac_ax_adapter *adapter,
+				     struct negative_pattern *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_negative_pattern *fwcmd_negative_patter;
+	u32 ret = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_negative_pattern));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_negative_patter = (struct fwcmd_negative_pattern *)buf;
+
+	fwcmd_negative_patter->dword0 =
+	cpu_to_le32((parm->negative_pattern_en ?
+			FWCMD_H2C_NEGATIVE_PATTERN_NEGATIVE_PATTERN_EN : 0) |
+	SET_WORD(parm->pattern_count,
+		 FWCMD_H2C_NEGATIVE_PATTERN_PATTERN_COUNT) |
+	SET_WORD(parm->mac_id, FWCMD_H2C_NEGATIVE_PATTERN_MAC_ID));
+
+	fwcmd_negative_patter->dword1 =
+		cpu_to_le32(parm->pattern_content);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_NEGATIVE_PATTERN,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_cfg_dev2hst_gpio(struct mac_ax_adapter *adapter,
+			 struct rtw_dev2hst_gpio_info *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_dev2hst_gpio *fwcmd_dev2hst_gpi;
+	u32 ret = 0;
+	u32 totalSize = sizeof(struct fwcmd_dev2hst_gpio);
+	enum h2c_buf_class h2cb_type;
+
+	if (parm->gpio_num > MAC_AX_GPIO15) {
+		PLTFM_MSG_ERR("gpio num > 15");
+		return MACNOITEM;
+	}
+	if (parm->toggle_pulse == MAC_AX_DEV2HST_PULSE) {
+		if (parm->gpio_pulse_dura == 0) {
+			PLTFM_MSG_ERR("gpio pulse duration cant be 0");
+			return MACNOITEM;
+		}
+		if (parm->gpio_pulse_period <= parm->gpio_pulse_dura) {
+			PLTFM_MSG_ERR("gpio pulse period can less than duration");
+			return MACNOITEM;
+		}
+		if (!parm->gpio_pulse_nonstop && parm->gpio_pulse_count == 0) {
+			PLTFM_MSG_ERR("gpio pulse count cant be 0");
+			return MACNOITEM;
+		}
+	}
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	totalSize += sizeof(struct rtw_dev2hst_extend_rsn) * parm->num_extend_rsn;
+	if (totalSize <= (H2C_CMD_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_CMD;
+		PLTFM_MSG_TRACE("dev2hst_gpio size %d, using CMD Q\n", totalSize);
+	}
+	else if (totalSize <= (H2C_DATA_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_DATA;
+		PLTFM_MSG_TRACE("dev2hst_gpio size %d, using DATA Q\n", totalSize);
+	}
+	else if (totalSize <= (H2C_LONG_DATA_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_LONG_DATA;
+		PLTFM_MSG_TRACE("dev2hst_gpio size %d, using LDATA Q\n", totalSize);
+	}
+	else {
+		PLTFM_MSG_ERR("dev2hst_gpio size %d, exceed LDATA Q size, abort\n", totalSize);
+		return MACBUFSZ;
+	}
+
+	h2cb = h2cb_alloc(adapter, h2cb_type);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, totalSize);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+	fwcmd_dev2hst_gpi = (struct fwcmd_dev2hst_gpio *)buf;
+	fwcmd_dev2hst_gpi->dword0 =
+	cpu_to_le32((parm->dev2hst_gpio_en ? FWCMD_H2C_DEV2HST_GPIO_DEV2HST_GPIO_EN : 0) |
+		    (parm->disable_inband ? FWCMD_H2C_DEV2HST_GPIO_DISABLE_INBAND : 0) |
+		    (parm->gpio_output_input ? FWCMD_H2C_DEV2HST_GPIO_GPIO_OUTPUT_INPUT : 0) |
+		    (parm->gpio_active ? FWCMD_H2C_DEV2HST_GPIO_GPIO_ACTIVE : 0) |
+		    (parm->toggle_pulse ? FWCMD_H2C_DEV2HST_GPIO_TOGGLE_PULSE : 0) |
+		    (parm->data_pin_wakeup ? FWCMD_H2C_DEV2HST_GPIO_DATA_PIN_WAKEUP : 0) |
+		    (parm->data_pin_wakeup ? FWCMD_H2C_DEV2HST_GPIO_DATA_PIN_WAKEUP : 0) |
+		    (parm->gpio_pulse_nonstop ? FWCMD_H2C_DEV2HST_GPIO_GPIO_PULSE_NONSTOP : 0) |
+		    (parm->gpio_time_unit ? FWCMD_H2C_DEV2HST_GPIO_GPIO_TIME_UNIT : 0) |
+		    SET_WORD(parm->gpio_num, FWCMD_H2C_DEV2HST_GPIO_GPIO_NUM) |
+		    SET_WORD(parm->gpio_pulse_dura, FWCMD_H2C_DEV2HST_GPIO_GPIO_PULSE_DURATION) |
+		    SET_WORD(parm->gpio_pulse_period, FWCMD_H2C_DEV2HST_GPIO_GPIO_PULSE_PERIOD));
+
+	fwcmd_dev2hst_gpi->dword1 =
+	cpu_to_le32(SET_WORD(parm->gpio_pulse_count,
+			     FWCMD_H2C_DEV2HST_GPIO_GPIO_PULSE_COUNT) |
+		    SET_WORD(parm->num_extend_rsn,
+			     FWCMD_H2C_DEV2HST_GPIO_NUM_EXTEND_RSN) |
+		    SET_WORD(parm->indicate_duration,
+			     FWCMD_H2C_DEV2HST_GPIO_INDICATE_DURATION) |
+		    SET_WORD(parm->indicate_intermission,
+			     FWCMD_H2C_DEV2HST_GPIO_INDICATE_INTERMISSION));
+
+	fwcmd_dev2hst_gpi->dword2 =
+	cpu_to_le32(SET_WORD(parm->customer_id,
+			     FWCMD_H2C_DEV2HST_GPIO_CUSTOMER_ID));
+
+	fwcmd_dev2hst_gpi->dword3 =
+	cpu_to_le32((parm->rsn_a_en ? FWCMD_H2C_DEV2HST_GPIO_RSN_A_EN : 0) |
+		    (parm->rsn_a_toggle_pulse ? FWCMD_H2C_DEV2HST_GPIO_RSN_A_TOGGLE_PULSE : 0) |
+		    (parm->rsn_a_pulse_nonstop ? FWCMD_H2C_DEV2HST_GPIO_RSN_A_PULSE_NONSTOP : 0) |
+		    (parm->rsn_a_time_unit ? FWCMD_H2C_DEV2HST_GPIO_RSN_A_TIME_UNIT : 0));
+
+	fwcmd_dev2hst_gpi->dword4 =
+	cpu_to_le32(SET_WORD(parm->rsn_a, FWCMD_H2C_DEV2HST_GPIO_RSN_A) |
+		    SET_WORD(parm->rsn_a_pulse_duration,
+			     FWCMD_H2C_DEV2HST_GPIO_RSN_A_PULSE_DURATION) |
+		    SET_WORD(parm->rsn_a_pulse_period, FWCMD_H2C_DEV2HST_GPIO_RSN_A_PULSE_PERIOD) |
+		    SET_WORD(parm->rsn_a_pulse_count, FWCMD_H2C_DEV2HST_GPIO_RSN_A_PULSE_COUNT));
+
+	fwcmd_dev2hst_gpi->dword5 =
+	cpu_to_le32((parm->rsn_b_en ? FWCMD_H2C_DEV2HST_GPIO_RSN_B_EN : 0) |
+		    (parm->rsn_b_toggle_pulse ? FWCMD_H2C_DEV2HST_GPIO_RSN_B_TOGGLE_PULSE : 0) |
+		    (parm->rsn_b_pulse_nonstop ? FWCMD_H2C_DEV2HST_GPIO_RSN_B_PULSE_NONSTOP : 0) |
+		    (parm->rsn_b_time_unit ? FWCMD_H2C_DEV2HST_GPIO_RSN_B_TIME_UNIT : 0));
+
+	fwcmd_dev2hst_gpi->dword6 =
+	cpu_to_le32(SET_WORD(parm->rsn_b, FWCMD_H2C_DEV2HST_GPIO_RSN_B) |
+		    SET_WORD(parm->rsn_b_pulse_duration,
+			     FWCMD_H2C_DEV2HST_GPIO_RSN_B_PULSE_DURATION) |
+		    SET_WORD(parm->rsn_b_pulse_period, FWCMD_H2C_DEV2HST_GPIO_RSN_B_PULSE_PERIOD) |
+		    SET_WORD(parm->rsn_b_pulse_count, FWCMD_H2C_DEV2HST_GPIO_RSN_B_PULSE_COUNT));
+
+	buf += sizeof(struct fwcmd_dev2hst_gpio);
+	PLTFM_MEMCPY(buf, parm->extend_rsn,
+		     sizeof(struct rtw_dev2hst_extend_rsn) * parm->num_extend_rsn);
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_DEV2HST_GPIO,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+	PLTFM_MSG_TRACE("ok");
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+	return ret;
+}
+
+static u32 send_h2c_hst2dev_ctrl(struct mac_ax_adapter *adapter,
+				 struct hst2dev_ctrl *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_hst2dev_ctrl *fwcmd_hst2dev_ctr;
+	u32 ret = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_hst2dev_ctrl));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_hst2dev_ctr = (struct fwcmd_hst2dev_ctrl *)buf;
+	fwcmd_hst2dev_ctr->dword0 =
+	cpu_to_le32((parm->disable_uphy ?
+			FWCMD_H2C_HST2DEV_CTRL_DISABLE_UPHY : 0) |
+	SET_WORD(parm->handshake_mode, FWCMD_H2C_HST2DEV_CTRL_HANDSHAKE_MODE) |
+	(parm->rise_hst2dev_dis_uphy ? FWCMD_H2C_HST2DEV_CTRL_RISE_HST2DEV_DIS_UPHY
+									: 0) |
+	(parm->uphy_dis_delay_unit ? FWCMD_H2C_HST2DEV_CTRL_UPHY_DIS_DELAY_UNIT
+									: 0) |
+	(parm->pdn_as_uphy_dis ? FWCMD_H2C_HST2DEV_CTRL_PDN_AS_UPHY_DIS : 0) |
+	(parm->pdn_to_enable_uphy ? FWCMD_H2C_HST2DEV_CTRL_PDN_TO_ENABLE_UPHY
+									: 0) |
+	(parm->hst2dev_en ? FWCMD_H2C_HST2DEV_CTRL_HST2DEV_EN : 0) |
+	SET_WORD(parm->hst2dev_gpio_num, FWCMD_H2C_HST2DEV_CTRL_HST2DEV_GPIO_NUM) |
+	SET_WORD(parm->uphy_dis_delay_count,
+		 FWCMD_H2C_HST2DEV_CTRL_UPHY_DIS_DELAY_COUNT));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_HST2DEV_CTRL,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static u32 send_h2c_wowcam_upd(struct mac_ax_adapter *adapter,
+			       struct wowcam_upd *parm)
+{
+	u8 *buf;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	struct fwcmd_wow_cam_upd *fwcmd_wowcam_upd;
+	u32 ret = 0;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_CMD);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_wow_cam_upd));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_wowcam_upd = (struct fwcmd_wow_cam_upd *)buf;
+	fwcmd_wowcam_upd->dword0 =
+		cpu_to_le32((parm->r_w ? FWCMD_H2C_WOW_CAM_UPD_R_W : 0) |
+		SET_WORD(parm->idx, FWCMD_H2C_WOW_CAM_UPD_IDX));
+
+	fwcmd_wowcam_upd->dword1 =
+		cpu_to_le32(parm->wkfm1);
+
+	fwcmd_wowcam_upd->dword2 =
+		cpu_to_le32(parm->wkfm2);
+
+	fwcmd_wowcam_upd->dword3 =
+		cpu_to_le32(parm->wkfm3);
+
+	fwcmd_wowcam_upd->dword4 =
+		cpu_to_le32(parm->wkfm4);
+
+	fwcmd_wowcam_upd->dword5 =
+		cpu_to_le32(SET_WORD(parm->crc, FWCMD_H2C_WOW_CAM_UPD_CRC) |
+		(parm->negative_pattern_match ? FWCMD_H2C_WOW_CAM_UPD_NEGATIVE_PATTERN_MATCH : 0) |
+		(parm->skip_mac_hdr ? FWCMD_H2C_WOW_CAM_UPD_SKIP_MAC_HDR : 0) |
+		(parm->uc ? FWCMD_H2C_WOW_CAM_UPD_UC : 0) |
+		(parm->mc ? FWCMD_H2C_WOW_CAM_UPD_MC : 0) |
+		(parm->bc ? FWCMD_H2C_WOW_CAM_UPD_BC : 0) |
+		(parm->valid ? FWCMD_H2C_WOW_CAM_UPD_VALID : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_WOW_CAM_UPD,
+			      0,
+			      0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_cfg_wow_wake(struct mac_ax_adapter *adapter,
+		     u8 macid,
+		     struct mac_ax_wow_wake_info *info,
+		     struct mac_ax_remotectrl_info_parm_ *content)
+{
+	u32 ret = 0, i = 0;
+	struct wow_global parm1;
+	struct wakeup_ctrl parm2;
+	struct mac_role_tbl *role;
+	struct mac_ax_sec_iv_info sec_iv_info = {{0}};
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	parm2.pattern_match_en = info->pattern_match_en;
+	parm2.magic_en = info->magic_en;
+	parm2.hw_unicast_en = info->hw_unicast_en;
+	parm2.fw_unicast_en = info->fw_unicast_en;
+	parm2.deauth_wakeup = info->deauth_wakeup;
+	parm2.rekey_wakeup = info->rekey_wakeup;
+	parm2.eap_wakeup = info->eap_wakeup;
+	parm2.all_data_wakeup = info->all_data_wakeup;
+	parm2.mac_id = macid;
+	ret = send_h2c_wakeup_ctrl(adapter, &parm2);
+	if (ret) {
+		PLTFM_MSG_ERR("send h2c wakeup ctrl failed\n");
+		return ret;
+	}
+
+	parm1.wow_en = info->wow_en;
+	parm1.drop_all_pkt = info->drop_all_pkt;
+	parm1.rx_parse_after_wake = info->rx_parse_after_wake;
+	parm1.mac_id = macid;
+	parm1.pairwise_sec_algo = info->pairwise_sec_algo;
+	parm1.group_sec_algo = info->group_sec_algo;
+	//parm1.remotectrl_info_content =
+	//info->remotectrl_info_content;
+	if (content)
+		PLTFM_MEMCPY(&parm1.remotectrl_info_content,
+			     content,
+			     sizeof(struct mac_ax_remotectrl_info_parm_));
+
+	if (info->wow_en) {
+		role = mac_role_srch(adapter, macid);
+		if (role) {
+			tgt_ind_orig = role->info.tgt_ind;
+			frm_tgt_ind_orig = role->info.frm_tgt_ind;
+			wol_pattern_orig = role->info.wol_pattern;
+			wol_uc_orig = role->info.wol_uc;
+			wol_magic_orig = role->info.wol_magic;
+			wow_bk_status[(macid >> 5)] |= BIT(macid & 0x1F);
+			role->info.wol_pattern = (u8)parm2.pattern_match_en;
+			role->info.wol_uc = info->hw_unicast_en;
+			role->info.wol_magic = info->magic_en;
+			role->info.upd_mode = MAC_AX_ROLE_INFO_CHANGE;
+			sec_iv_info.macid = macid;
+			if (content)
+				for (i = 0 ; i < 6 ; i++)
+					sec_iv_info.ptktxiv[i] =
+						content->ptktxiv[i];
+
+			sec_iv_info.opcode = SEC_IV_UPD_TYPE_WRITE;
+			ret = p_ops->mac_wowlan_secinfo(adapter, &sec_iv_info);
+
+			ret = mac_change_role(adapter, &role->info);
+			if (ret) {
+				PLTFM_MSG_ERR("role change failed\n");
+				return ret;
+			}
+		} else {
+			PLTFM_MSG_ERR("role search failed\n");
+			return MACNOITEM;
+		}
+	} else {
+		sec_iv_info.macid = macid;
+		sec_iv_info.opcode = SEC_IV_UPD_TYPE_READ;
+		ret = p_ops->mac_wowlan_secinfo(adapter, &sec_iv_info);
+		if (ret)
+			PLTFM_MSG_ERR("refresh_security_cam_info failed %d\n", ret);
+		else
+			PLTFM_MSG_TRACE("refresh_security_cam_info success!\n");
+
+		if (wow_bk_status[(macid >> 5)] & BIT(macid & 0x1F)) {
+			//restore address cam
+			role = mac_role_srch(adapter, macid);
+			if (role) {
+				role->info.tgt_ind = (u8)tgt_ind_orig;
+				role->info.frm_tgt_ind = (u8)frm_tgt_ind_orig;
+				role->info.wol_pattern = (u8)wol_pattern_orig;
+				role->info.wol_uc = (u8)wol_uc_orig;
+				role->info.wol_magic = (u8)wol_magic_orig;
+				role->info.upd_mode = MAC_AX_ROLE_INFO_CHANGE;
+				ret = mac_change_role(adapter, &role->info);
+				if (ret) {
+					PLTFM_MSG_ERR("role change failed\n");
+					return ret;
+				}
+			}
+			wow_bk_status[(macid >> 5)] &= ~BIT(macid & 0x1F);
+		} else {
+			PLTFM_MSG_ERR("role search failed\n");
+			return MACNOITEM;
+		}
+	}
+
+	ret = send_h2c_wow_global(adapter, &parm1);
+	if (ret)
+		PLTFM_MSG_ERR("set wow global failed\n");
+
+	return ret;
+}
+
+u32 mac_cfg_disconnect_det(struct mac_ax_adapter *adapter,
+			   u8 macid,
+			   struct mac_ax_disconnect_det_info *info)
+{
+	u32 ret = 0;
+	struct disconnect_detect parm;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	parm.disconnect_detect_en = info->disconnect_detect_en;
+	parm.tryok_bcnfail_count_en =
+	    info->tryok_bcnfail_count_en;
+	parm.disconnect_en = info->disconnect_en;
+	parm.mac_id = macid;
+	parm.check_period = info->check_period;
+	parm.try_pkt_count = info->try_pkt_count;
+	parm.tryok_bcnfail_count_limit =
+	    info->tryok_bcnfail_count_limit;
+
+	ret = send_h2c_disconnect_detect(adapter, &parm);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_keep_alive(struct mac_ax_adapter *adapter,
+		       u8 macid,
+		       struct mac_ax_keep_alive_info *info)
+{
+	u32 ret = 0;
+	struct keep_alive parm;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	parm.keepalive_en = info->keepalive_en;
+	parm.packet_id = info->packet_id;
+	parm.period = info->period;
+	parm.mac_id = macid;
+
+	ret = send_h2c_keep_alive(adapter, &parm);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_gtk_ofld(struct mac_ax_adapter *adapter,
+		     u8 macid,
+		     struct mac_ax_gtk_ofld_info *info,
+		     struct mac_ax_gtk_info_parm_ *content)
+{
+	u32 ret = 0;
+	struct gtk_ofld parm;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	parm.gtk_en = info->gtk_en;
+	parm.tkip_en = info->tkip_en;
+	parm.ieee80211w_en = info->ieee80211w_en;
+	parm.pairwise_wakeup = info->pairwise_wakeup;
+	parm.norekey_wakeup = info->norekey_wakeup;
+	parm.mac_id = macid;
+	parm.gtk_rsp_id = info->gtk_rsp_id;
+	parm.pmf_sa_query_id = info->pmf_sa_query_id;
+	parm.bip_sec_algo = info->bip_sec_algo;
+	parm.algo_akm_suit = info->algo_akm_suit;
+
+	if (content)
+		PLTFM_MEMCPY(&parm.gtk_info_content, content,
+			     sizeof(struct mac_ax_gtk_info_parm_));
+
+	ret = send_h2c_gtk_ofld(adapter, &parm);
+	if (ret)
+		return ret;
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_arp_ofld(struct mac_ax_adapter *adapter,
+		     u8 macid,
+		     struct mac_ax_arp_ofld_info *info,
+		     void *parp_info_content)
+{
+	u32 ret = 0;
+	struct arp_ofld parm;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct arp_ofld));
+	parm.arp_en = info->arp_en;
+	parm.arp_action = info->arp_action;
+	parm.mac_id = macid;
+	parm.arp_rsp_id = info->arp_rsp_id;
+
+	//if (parp_info_content)
+	//	PLTFM_MEMCPY(&parm.ndp_info_content, parp_info_content,
+	//		     sizeof(struct _arp_info_parm_) * 2);
+
+	ret = send_h2c_arp_ofld(adapter, &parm);
+	if (ret)
+		return ret;
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_ndp_ofld(struct mac_ax_adapter *adapter,
+		     u8 macid,
+		     struct mac_ax_ndp_ofld_info *info,
+		     struct mac_ax_ndp_info_parm_ *content)
+{
+	u32 ret = 0;
+	struct ndp_ofld parm;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct ndp_ofld));
+	parm.ndp_en = info->ndp_en;
+	parm.na_id = info->na_id;
+	parm.mac_id = macid;
+
+	if (content)
+		PLTFM_MEMCPY(&parm.ndp_info_content, content,
+			     sizeof(struct mac_ax_ndp_info_parm_) * 2);
+
+	ret = send_h2c_ndp_ofld(adapter, &parm);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_realwow(struct mac_ax_adapter *adapter,
+		    u8 macid,
+		    struct mac_ax_realwow_info *info,
+		    struct mac_ax_realwowv2_info_parm_ *content)
+{
+	u32 ret = 0;
+	struct realwow parm;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct realwow));
+	parm.realwow_en = info->realwow_en;
+	parm.auto_wakeup = info->auto_wakeup;
+	parm.mac_id = macid;
+	parm.keepalive_id = info->keepalive_id;
+	parm.wakeup_pattern_id = info->wakeup_pattern_id;
+	parm.ack_pattern_id = info->ack_pattern_id;
+	if (content)
+		PLTFM_MEMCPY(&parm.realwow_info_content, content,
+			     sizeof(struct mac_ax_realwowv2_info_parm_));
+
+	ret = send_h2c_realwow(adapter, &parm);
+	if (ret)
+		return ret;
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_nlo(struct mac_ax_adapter *adapter,
+		u8 macid,
+		struct mac_ax_nlo_info *info,
+		struct mac_ax_nlo_networklist_parm_ *content)
+{
+	u32 ret = 0;
+	struct nlo parm;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct nlo));
+	parm.nlo_en = info->nlo_en;
+	parm.nlo_32k_en = info->nlo_32k_en;
+	parm.ignore_cipher_type = !info->compare_cipher_type;
+	parm.mac_id = macid;
+
+	if (content)
+		PLTFM_MEMCPY(&parm.nlo_networklistinfo_content,
+			     content,
+			     sizeof(struct mac_ax_nlo_networklist_parm_));
+
+	ret = send_h2c_nlo(adapter, &parm);
+	if (ret)
+		return ret;
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_hst2dev_ctrl(struct mac_ax_adapter *adapter,
+			 struct mac_ax_hst2dev_ctrl_info *info)
+{
+	u32 ret = 0;
+	struct hst2dev_ctrl parm;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct hst2dev_ctrl));
+	parm.disable_uphy = info->disable_uphy;
+	parm.handshake_mode = info->handshake_mode;
+	parm.rise_hst2dev_dis_uphy = info->rise_hst2dev_dis_uphy;
+	parm.uphy_dis_delay_unit = info->uphy_dis_delay_unit;
+	parm.pdn_as_uphy_dis = info->pdn_as_uphy_dis;
+	parm.pdn_to_enable_uphy = info->pdn_to_enable_uphy;
+	parm.hst2dev_en = info->hst2dev_en;
+	parm.hst2dev_gpio_num = info->hst2dev_gpio_num;
+	parm.uphy_dis_delay_count = info->uphy_dis_delay_count;
+
+	ret = send_h2c_hst2dev_ctrl(adapter, &parm);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_wowcam_upd(struct mac_ax_adapter *adapter,
+		       struct mac_ax_wowcam_upd_info *info)
+{
+	u32 ret = 0;
+	struct wowcam_upd parm;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+
+	PLTFM_MEMSET(&parm, 0, sizeof(struct wowcam_upd));
+	parm.r_w = info->r_w;
+	parm.idx = info->idx;
+	parm.wkfm1 = info->wkfm1;
+	parm.wkfm2 = info->wkfm2;
+	parm.wkfm3 = info->wkfm3;
+	parm.wkfm4 = info->wkfm4;
+	parm.crc = info->crc;
+	parm.negative_pattern_match = info->negative_pattern_match;
+	parm.skip_mac_hdr = info->skip_mac_hdr;
+	parm.uc = info->uc;
+	parm.mc = info->mc;
+	parm.bc = info->bc;
+	parm.valid = info->valid;
+
+	ret = send_h2c_wowcam_upd(adapter, &parm);
+	if (ret)
+		return ret;
+
+	return MACSUCCESS;
+}
+
+u32 get_wake_reason(struct mac_ax_adapter *adapter, u8 *wowlan_wake_reason)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_priv_ops *p_ops = adapter_to_priv_ops(adapter);
+	struct mac_ax_c2hreg_offset *c2hreg_offset;
+
+	c2hreg_offset = p_ops->get_c2hreg_offset(adapter);
+	if (!c2hreg_offset) {
+		PLTFM_MSG_ERR("%s: get c2hreg offset fail\n", __func__);
+		return MACNPTR;
+	}
+
+	*wowlan_wake_reason = MAC_REG_R8(c2hreg_offset->data3 + 3);
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_wow_wake_rsn(struct mac_ax_adapter *adapter, u8 *wake_rsn,
+			 u8 *reset)
+{
+	u32 ret = MACSUCCESS;
+
+	ret = get_wake_reason(adapter, wake_rsn);
+	if (ret != MACSUCCESS)
+		return ret;
+
+	switch (*wake_rsn) {
+	case RTW_MAC_WOW_DMAC_ERROR_OCCURRED:
+	case RTW_MAC_WOW_EXCEPTION_OCCURRED:
+	case RTW_MAC_WOW_L0_TO_L1_ERROR_OCCURRED:
+	case RTW_MAC_WOW_ASSERT_OCCURRED:
+	case RTW_MAC_WOW_L2_ERROR_OCCURRED:
+	case RTW_MAC_WOW_WDT_TIMEOUT_WAKE:
+		*reset = 1;
+		break;
+	default:
+		*reset = 0;
+		break;
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_wow_sleep(struct mac_ax_adapter *adapter,
+		      u8 sleep)
+{
+	u32 ret;
+	u32 val32;
+	u8 dbg_page;
+	struct mac_ax_phy_rpt_cfg cfg;
+	struct mac_ax_ops *mac_ops = adapter_to_mac_ops(adapter);
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+#if MAC_AX_PCIE_SUPPORT
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+	struct mac_ax_pcie_ltr_param ltr_param = {
+		1,
+		0,
+		MAC_AX_PCIE_DISABLE,
+		MAC_AX_PCIE_DISABLE,
+		MAC_AX_PCIE_LTR_SPC_DEF,
+		MAC_AX_PCIE_LTR_IDLE_TIMER_DEF,
+		{MAC_AX_PCIE_DEFAULT, 0},
+		{MAC_AX_PCIE_DEFAULT, 0},
+		{MAC_AX_PCIE_DEFAULT, 0},
+		{MAC_AX_PCIE_DEFAULT, 0},
+		{MAC_AX_PCIE_DEFAULT, 0},
+		MAC_AX_PCIE_IGNORE,
+		MAC_AX_PCIE_IGNORE,
+		MAC_AX_PCIE_IGNORE,
+		PCIE_LTR_IDX_INVALID,
+		PCIE_LTR_IDX_INVALID,
+		PCIE_LTR_IDX_INVALID
+	};
+#endif
+#endif
+
+	PLTFM_MEMSET(&cfg, 0, sizeof(struct mac_ax_phy_rpt_cfg));
+#if MAC_AX_FW_REG_OFLD
+	if (adapter->sm.fwdl == MAC_AX_FWDL_INIT_RDY) {
+		if (sleep) {
+			ret = redu_wowlan_rx_qta(adapter);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("[ERR]patch reduce rx qta %d\n", ret);
+				return ret;
+			}
+
+			cfg.type = MAC_AX_PPDU_STATUS;
+			cfg.en = 0;
+			ret = mac_ops->cfg_phy_rpt(adapter, &cfg);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("[ERR]cfg_phy_rpt failed %d\n", ret);
+				return ret;
+			}
+
+			ret = MAC_REG_W_OFLD(R_AX_RX_FUNCTION_STOP, B_AX_HDR_RX_STOP, 1, 0);
+			if (ret)
+				return ret;
+			ret = MAC_REG_W_OFLD(R_AX_RX_FLTR_OPT, B_AX_SNIFFER_MODE, 0, 0);
+			if (ret)
+				return ret;
+			ret = MAC_REG_W32_OFLD(R_AX_ACTION_FWD0, 0x00000000, 0);
+			if (ret)
+				return ret;
+			ret = MAC_REG_W32_OFLD(R_AX_ACTION_FWD1, 0x00000000, 0);
+			if (ret)
+				return ret;
+			ret = MAC_REG_W32_OFLD(R_AX_TF_FWD, 0x00000000, 0);
+			if (ret)
+				return ret;
+			ret = MAC_REG_W32_OFLD(R_AX_HW_RPT_FWD, 0x00000000, 1);
+			if (ret)
+				return ret;
+			if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+#if MAC_AX_PCIE_SUPPORT
+				if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+				    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+				    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+				    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+					ret = ops->ltr_set_pcie(adapter, &ltr_param);
+					if (ret != MACSUCCESS) {
+						PLTFM_MSG_ERR("[ERR]pcie ltr set fail %d\n", ret);
+						return ret;
+					}
+#endif
+				}
+#endif
+			}
+		} else {
+			ret = restr_wowlan_rx_qta(adapter);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("[ERR]patch resume rx qta %d\n", ret);
+				return ret;
+			}
+
+			ret = MAC_REG_W_OFLD(R_AX_RX_FUNCTION_STOP, B_AX_HDR_RX_STOP, 0, 0);
+			if (ret)
+				return ret;
+			ret = MAC_REG_W32_OFLD(R_AX_ACTION_FWD0, TRXCFG_MPDU_PROC_ACT_FRWD, 0);
+			if (ret)
+				return ret;
+			ret = MAC_REG_W32_OFLD(R_AX_TF_FWD, TRXCFG_MPDU_PROC_TF_FRWD, 1);
+			if (ret)
+				return ret;
+
+			cfg.type = MAC_AX_PPDU_STATUS;
+			cfg.en = 1;
+			ret = mac_ops->cfg_phy_rpt(adapter, &cfg);
+			if (ret != MACSUCCESS) {
+				PLTFM_MSG_ERR("[ERR]cfg_phy_rpt failed %d\n", ret);
+				return ret;
+			}
+		}
+		return MACSUCCESS;
+	}
+#endif
+	if (sleep) {
+		ret = redu_wowlan_rx_qta(adapter);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]patch reduce rx qta %d\n", ret);
+			return ret;
+		}
+		val32 = MAC_REG_R32(R_AX_RX_FUNCTION_STOP);
+		val32 |= B_AX_HDR_RX_STOP;
+		MAC_REG_W32(R_AX_RX_FUNCTION_STOP, val32);
+		val32 = MAC_REG_R32(R_AX_RX_FLTR_OPT);
+		val32 &= ~B_AX_SNIFFER_MODE;
+		MAC_REG_W32(R_AX_RX_FLTR_OPT, val32);
+
+		cfg.type = MAC_AX_PPDU_STATUS;
+		cfg.en = 0;
+		ret = mac_ops->cfg_phy_rpt(adapter, &cfg);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]cfg_phy_rpt failed %d\n", ret);
+			return ret;
+		}
+
+		MAC_REG_W32(R_AX_ACTION_FWD0, 0x00000000);
+		MAC_REG_W32(R_AX_ACTION_FWD1, 0x00000000);
+		MAC_REG_W32(R_AX_TF_FWD, 0x00000000);
+		MAC_REG_W32(R_AX_HW_RPT_FWD, 0x00000000);
+		if (adapter->hw_info->intf == MAC_AX_INTF_PCIE) {
+#if MAC_AX_PCIE_SUPPORT
+			if (is_chip_id(adapter, MAC_AX_CHIP_ID_8852C) ||
+			    is_chip_id(adapter, MAC_AX_CHIP_ID_8192XB) ||
+			    is_chip_id(adapter, MAC_AX_CHIP_ID_8851E) ||
+			    is_chip_id(adapter, MAC_AX_CHIP_ID_8852D)) {
+#if MAC_AX_8852C_SUPPORT || MAC_AX_8192XB_SUPPORT || MAC_AX_8851E_SUPPORT || MAC_AX_8852D_SUPPORT
+				ret = ops->ltr_set_pcie(adapter, &ltr_param);
+				if (ret != MACSUCCESS) {
+					PLTFM_MSG_ERR("[ERR]pcie ltr set fail %d\n", ret);
+					return ret;
+				}
+#endif
+			}
+#endif
+		}
+	} else {
+		ret = restr_wowlan_rx_qta(adapter);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]patch resume rx qta %d\n", ret);
+			return ret;
+		}
+		val32 = MAC_REG_R32(R_AX_RX_FUNCTION_STOP);
+		val32 &= ~B_AX_HDR_RX_STOP;
+		MAC_REG_W32(R_AX_RX_FUNCTION_STOP, val32);
+		val32 = MAC_REG_R32(R_AX_RX_FLTR_OPT);
+		MAC_REG_W32(R_AX_RX_FLTR_OPT, val32);
+
+		cfg.type = MAC_AX_PPDU_STATUS;
+		cfg.en = 1;
+		ret = mac_ops->cfg_phy_rpt(adapter, &cfg);
+		if (ret != MACSUCCESS) {
+			PLTFM_MSG_ERR("[ERR]cfg_phy_rpt failed %d\n", ret);
+			return ret;
+		}
+
+		MAC_REG_W32(R_AX_ACTION_FWD0, TRXCFG_MPDU_PROC_ACT_FRWD);
+		MAC_REG_W32(R_AX_TF_FWD, TRXCFG_MPDU_PROC_TF_FRWD);
+
+		PLTFM_MSG_ERR("[wow] Start to dump PLE debug pages\n");
+		for (dbg_page = 0; dbg_page < 4; dbg_page++)
+			mac_dump_ple_dbg_page(adapter, dbg_page);
+	}
+
+	return MACSUCCESS;
+}
+
+u32 mac_get_wow_fw_status(struct mac_ax_adapter *adapter, u8 *status,
+			  u8 func_en)
+{
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+
+	if (func_en)
+		func_en = 1;
+
+	*status = !!((MAC_REG_R8(R_AX_WOW_CTRL) & B_AX_WOW_WOWEN));
+
+	if (func_en == *status)
+		*status = 1;
+	else
+		*status = 0;
+
+	return MACSUCCESS;
+}
+
+u32 _mac_request_aoac_report_rx_rdy(struct mac_ax_adapter *adapter)
+{
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	struct fwcmd_aoac_report_req *fwcmd_aoac_rpt_req;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 val32;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_aoac_report_req));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	PLTFM_MSG_ERR("Request aoac_rpt\n");
+	val32 = MAC_REG_R32(R_AX_CH12_TXBD_IDX);
+	PLTFM_MSG_ERR("CH12_TXBD=%x\n", val32);
+	MAC_REG_W32(R_AX_PLE_DBG_FUN_INTF_CTL, 80010002);
+	val32 = MAC_REG_R32(R_AX_PLE_DBG_FUN_INTF_DATA);
+	PLTFM_MSG_ERR("PLE_C2H=%x\n", val32);
+	MAC_REG_W32(R_AX_PLE_DBG_FUN_INTF_CTL, 80010003);
+	val32 = MAC_REG_R32(R_AX_PLE_DBG_FUN_INTF_DATA);
+	PLTFM_MSG_ERR("PLE_H2C=%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, 0x400, AXIDMA_SEL);
+	PLTFM_MSG_ERR("AXI_H2C=%x\n", val32);
+	val32 = mac_sram_dbg_read(adapter, 0x420, AXIDMA_SEL);
+	PLTFM_MSG_ERR("AXI_C2H=%x\n", val32);
+	val32 = MAC_REG_R32(R_AX_RXQ_RXBD_IDX);
+	PLTFM_MSG_ERR("RXQ_RXBD=%x\n\n", val32);
+
+	fwcmd_aoac_rpt_req = (struct fwcmd_aoac_report_req *)buf;
+	fwcmd_aoac_rpt_req->dword0 =
+	cpu_to_le32(FWCMD_H2C_AOAC_REPORT_REQ_RX_READY);
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW, FWCMD_H2C_FUNC_AOAC_REPORT_REQ,
+			      1, 0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %d\n", ret);
+		adapter->sm.aoac_rpt = MAC_AX_AOAC_RPT_ERROR;
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 _mac_request_aoac_report_rx_not_rdy(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_wowlan_info *wow_info = &adapter->wowlan_info;
+	struct mac_ax_aoac_report *aoac_rpt = (struct mac_ax_aoac_report *)wow_info->aoac_report;
+	struct mac_ax_h2creg_info h2c_info = {0};
+	struct mac_ax_c2hreg_poll c2h_poll = {0};
+	struct fwcmd_c2hreg *c2h_content = &c2h_poll.c2hreg_cont.c2h_content;
+	u8 csa_failed = 0;
+	u32 ret;
+	u8 *p_iv;
+
+	h2c_info.id = FWCMD_H2CREG_FUNC_AOAC_RPT_1;
+	h2c_info.content_len = sizeof(struct fwcmd_aoac_rpt_1);
+
+	c2h_poll.polling_id = FWCMD_C2HREG_FUNC_AOAC_RPT_1;
+	c2h_poll.retry_cnt = WOW_GET_AOAC_RPT_C2H_CNT;
+	c2h_poll.retry_wait_us = WOW_GET_AOAC_RPT_C2H_DLY;
+
+	ret = proc_msg_reg(adapter, &h2c_info, &c2h_poll);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: get aoac rpt(%d) fail: %d\n",
+			      __func__, FWCMD_C2HREG_FUNC_AOAC_RPT_1, ret);
+		return ret;
+	}
+
+	aoac_rpt->key_idx = GET_FIELD(c2h_content->dword0,
+				      FWCMD_C2HREG_AOAC_RPT_1_KEY_IDX);
+	aoac_rpt->rekey_ok = GET_FIELD(c2h_content->dword0,
+				       FWCMD_C2HREG_AOAC_RPT_1_REKEY_OK);
+	p_iv = (&aoac_rpt->gtk_rx_iv_0[0] + (aoac_rpt->key_idx * IV_LENGTH));
+	p_iv[0] = GET_FIELD(c2h_content->dword1,
+			    FWCMD_C2HREG_AOAC_RPT_1_IV_0);
+	p_iv[1] = GET_FIELD(c2h_content->dword1,
+			    FWCMD_C2HREG_AOAC_RPT_1_IV_1);
+	p_iv[2] = GET_FIELD(c2h_content->dword1,
+			    FWCMD_C2HREG_AOAC_RPT_1_IV_2);
+	p_iv[3] = GET_FIELD(c2h_content->dword1,
+			    FWCMD_C2HREG_AOAC_RPT_1_IV_3);
+	p_iv[4] = GET_FIELD(c2h_content->dword2,
+			    FWCMD_C2HREG_AOAC_RPT_1_IV_4);
+	p_iv[5] = GET_FIELD(c2h_content->dword2,
+			    FWCMD_C2HREG_AOAC_RPT_1_IV_5);
+	p_iv[6] = GET_FIELD(c2h_content->dword2,
+			    FWCMD_C2HREG_AOAC_RPT_1_IV_6);
+	p_iv[7] = GET_FIELD(c2h_content->dword2,
+			    FWCMD_C2HREG_AOAC_RPT_1_IV_7);
+	aoac_rpt->ptk_rx_iv[0] = GET_FIELD(c2h_content->dword3,
+					   FWCMD_C2HREG_AOAC_RPT_1_PKT_IV_0);
+	aoac_rpt->ptk_rx_iv[1] = GET_FIELD(c2h_content->dword3,
+					   FWCMD_C2HREG_AOAC_RPT_1_PKT_IV_1);
+	aoac_rpt->ptk_rx_iv[2] = GET_FIELD(c2h_content->dword3,
+					   FWCMD_C2HREG_AOAC_RPT_1_PKT_IV_2);
+	aoac_rpt->ptk_rx_iv[3] = GET_FIELD(c2h_content->dword3,
+					   FWCMD_C2HREG_AOAC_RPT_1_PKT_IV_3);
+
+	h2c_info.id = FWCMD_H2CREG_FUNC_AOAC_RPT_2;
+	h2c_info.content_len = sizeof(struct fwcmd_aoac_rpt_2);
+
+	c2h_poll.polling_id = FWCMD_C2HREG_FUNC_AOAC_RPT_2;
+	c2h_poll.retry_cnt = WOW_GET_AOAC_RPT_C2H_CNT;
+	c2h_poll.retry_wait_us = WOW_GET_AOAC_RPT_C2H_DLY;
+	ret = proc_msg_reg(adapter, &h2c_info, &c2h_poll);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: get aoac rpt(%d) fail: %d\n",
+			      __func__, FWCMD_C2HREG_FUNC_AOAC_RPT_2, ret);
+		return ret;
+	}
+
+	aoac_rpt->ptk_rx_iv[4] = GET_FIELD(c2h_content->dword0,
+					   FWCMD_C2HREG_AOAC_RPT_2_PKT_IV_4);
+	aoac_rpt->ptk_rx_iv[5] = GET_FIELD(c2h_content->dword0,
+					   FWCMD_C2HREG_AOAC_RPT_2_PKT_IV_5);
+	aoac_rpt->ptk_rx_iv[6] = GET_FIELD(c2h_content->dword1,
+					   FWCMD_C2HREG_AOAC_RPT_2_PKT_IV_6);
+	aoac_rpt->ptk_rx_iv[7] = GET_FIELD(c2h_content->dword1,
+					   FWCMD_C2HREG_AOAC_RPT_2_PKT_IV_7);
+	aoac_rpt->igtk_ipn[0] = GET_FIELD(c2h_content->dword1,
+					  FWCMD_C2HREG_AOAC_RPT_2_IGTK_IPN_0);
+	aoac_rpt->igtk_ipn[1] = GET_FIELD(c2h_content->dword1,
+					  FWCMD_C2HREG_AOAC_RPT_2_IGTK_IPN_1);
+	aoac_rpt->igtk_ipn[2] = GET_FIELD(c2h_content->dword2,
+					  FWCMD_C2HREG_AOAC_RPT_2_IGTK_IPN_2);
+	aoac_rpt->igtk_ipn[3] = GET_FIELD(c2h_content->dword2,
+					  FWCMD_C2HREG_AOAC_RPT_2_IGTK_IPN_3);
+	aoac_rpt->igtk_ipn[4] = GET_FIELD(c2h_content->dword2,
+					  FWCMD_C2HREG_AOAC_RPT_2_IGTK_IPN_4);
+	aoac_rpt->igtk_ipn[5] = GET_FIELD(c2h_content->dword2,
+					  FWCMD_C2HREG_AOAC_RPT_2_IGTK_IPN_5);
+	aoac_rpt->igtk_ipn[6] = GET_FIELD(c2h_content->dword3,
+					  FWCMD_C2HREG_AOAC_RPT_2_IGTK_IPN_6);
+	aoac_rpt->igtk_ipn[7] = GET_FIELD(c2h_content->dword3,
+					  FWCMD_C2HREG_AOAC_RPT_2_IGTK_IPN_7);
+
+	h2c_info.id = FWCMD_H2CREG_FUNC_AOAC_RPT_3_REQ;
+	h2c_info.content_len = sizeof(struct fwcmd_aoac_rpt_3_req);
+
+	c2h_poll.polling_id = FWCMD_C2HREG_FUNC_AOAC_RPT_3;
+	c2h_poll.retry_cnt = WOW_GET_AOAC_RPT_C2H_CNT;
+	c2h_poll.retry_wait_us = WOW_GET_AOAC_RPT_C2H_DLY;
+	ret = proc_msg_reg(adapter, &h2c_info, &c2h_poll);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("%s: get aoac rpt(%d) fail: %d\n",
+			      __func__, FWCMD_C2HREG_FUNC_AOAC_RPT_3, ret);
+		return ret;
+	}
+
+	aoac_rpt->csa_pri_ch = GET_FIELD(c2h_content->dword1, FWCMD_C2HREG_AOAC_RPT_3_CSA_PRI_CH);
+	aoac_rpt->csa_bw = GET_FIELD(c2h_content->dword1, FWCMD_C2HREG_AOAC_RPT_3_CSA_BW);
+	aoac_rpt->csa_ch_offset = GET_FIELD(c2h_content->dword1,
+					    FWCMD_C2HREG_AOAC_RPT_3_CSA_CH_OFFSET);
+	csa_failed = c2h_content->dword1 & FWCMD_C2HREG_AOAC_RPT_3_CSA_CHSW_FAILED ? 1 : 0;
+	aoac_rpt->csa_chsw_failed = csa_failed;
+	aoac_rpt->csa_ch_band = GET_FIELD(c2h_content->dword1, FWCMD_C2HREG_AOAC_RPT_3_CSA_CH_BAND);
+
+	return MACSUCCESS;
+}
+
+u32 mac_request_aoac_report(struct mac_ax_adapter *adapter,
+			    u8 rx_ready)
+{
+	u32 ret;
+	struct mac_ax_wowlan_info *wow_info = &adapter->wowlan_info;
+
+	if (adapter->sm.aoac_rpt != MAC_AX_AOAC_RPT_IDLE)
+		return MACPROCERR;
+
+	if (wow_info->aoac_report) {
+		PLTFM_FREE(wow_info->aoac_report,
+			   sizeof(struct mac_ax_aoac_report));
+	}
+	wow_info->aoac_report = (u8 *)PLTFM_MALLOC(sizeof(struct mac_ax_aoac_report));
+	if (!wow_info->aoac_report) {
+		PLTFM_MSG_ERR("%s: malloc fail\n", __func__);
+		return MACBUFALLOC;
+	}
+
+	adapter->sm.aoac_rpt = MAC_AX_AOAC_RPT_H2C_SENDING;
+
+	if (rx_ready)
+		ret = _mac_request_aoac_report_rx_rdy(adapter);
+	else
+		ret = _mac_request_aoac_report_rx_not_rdy(adapter);
+
+	return ret;
+}
+
+u32 mac_read_aoac_report(struct mac_ax_adapter *adapter,
+			 struct mac_ax_aoac_report *rpt_buf, u8 rx_ready)
+{
+	struct mac_ax_wowlan_info *wow_info = &adapter->wowlan_info;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	u32 ret = MACSUCCESS;
+	u8 cnt = 200;
+	u32 val32;
+
+	while ((rx_ready) && (adapter->sm.aoac_rpt != MAC_AX_AOAC_RPT_H2C_DONE)) {
+		PLTFM_DELAY_MS(1);
+		if (--cnt == 0) {
+			PLTFM_MSG_ERR("[ERR] read aoac report(%d) fail\n",
+				      adapter->sm.aoac_rpt);
+			adapter->sm.aoac_rpt = MAC_AX_AOAC_RPT_IDLE;
+			val32 = MAC_REG_R32(R_AX_CH12_TXBD_IDX);
+			PLTFM_MSG_ERR("CH12_TXBD=%x\n", val32);
+			MAC_REG_W32(R_AX_PLE_DBG_FUN_INTF_CTL, 80010002);
+			val32 = MAC_REG_R32(R_AX_PLE_DBG_FUN_INTF_DATA);
+			PLTFM_MSG_ERR("PLE_C2H=%x\n", val32);
+			MAC_REG_W32(R_AX_PLE_DBG_FUN_INTF_CTL, 80010003);
+			val32 = MAC_REG_R32(R_AX_PLE_DBG_FUN_INTF_DATA);
+			PLTFM_MSG_ERR("PLE_H2C=%x\n", val32);
+			val32 = mac_sram_dbg_read(adapter, 0x400, AXIDMA_SEL);
+			PLTFM_MSG_ERR("AXI_H2C=%x\n", val32);
+			val32 = mac_sram_dbg_read(adapter, 0x420, AXIDMA_SEL);
+			PLTFM_MSG_ERR("AXI_C2H=%x\n", val32);
+			val32 = MAC_REG_R32(R_AX_RXQ_RXBD_IDX);
+			PLTFM_MSG_ERR("RXQ_RXBD=%x\n\n", val32);
+			return MACPOLLTO;
+		}
+	}
+
+	if (wow_info->aoac_report) {
+		PLTFM_MEMCPY(rpt_buf, wow_info->aoac_report,
+			     sizeof(struct mac_ax_aoac_report));
+		PLTFM_FREE(wow_info->aoac_report,
+			   sizeof(struct mac_ax_aoac_report));
+		wow_info->aoac_report = NULL;
+	} else {
+		PLTFM_MSG_ERR("[ERR] aoac report memory allocate fail\n");
+		ret = MACBUFALLOC;
+	}
+
+	adapter->sm.aoac_rpt = MAC_AX_AOAC_RPT_IDLE;
+
+	return ret;
+}
+
+u32 mac_check_aoac_report_done(struct mac_ax_adapter *adapter)
+{
+	PLTFM_MSG_TRACE("[TRACE]%s: curr state: %d\n", __func__,
+			adapter->sm.aoac_rpt);
+
+	if (adapter->sm.aoac_rpt == MAC_AX_AOAC_RPT_H2C_DONE)
+		return MACSUCCESS;
+	else
+		return MACPROCBUSY;
+}
+
+u32 mac_wow_stop_trx(struct mac_ax_adapter *adapter)
+{
+	struct mac_ax_h2creg_info h2c_info;
+	struct mac_ax_c2hreg_poll c2h_poll;
+	u32 ret;
+
+	if (adapter->sm.wow_stoptrx_stat == MAC_AX_WOW_STOPTRX_BUSY) {
+		PLTFM_MSG_ERR("[ERR]wow stop trx busy\n");
+		return MACPROCERR;
+	} else if (adapter->sm.wow_stoptrx_stat == MAC_AX_WOW_STOPTRX_FAIL) {
+		PLTFM_MSG_WARN("[WARN]prev wow stop trx fail\n");
+	}
+
+	adapter->sm.wow_stoptrx_stat = MAC_AX_WOW_STOPTRX_BUSY;
+
+	h2c_info.id = FWCMD_H2CREG_FUNC_WOW_TRX_STOP;
+	h2c_info.content_len = 0;
+	h2c_info.h2c_content.dword0 = 0;
+	h2c_info.h2c_content.dword1 = 0;
+	h2c_info.h2c_content.dword2 = 0;
+	h2c_info.h2c_content.dword3 = 0;
+
+	c2h_poll.polling_id = FWCMD_C2HREG_FUNC_WOW_TRX_STOP;
+	c2h_poll.retry_cnt = WOW_GET_STOP_TRX_C2H_CNT;
+	c2h_poll.retry_wait_us = WOW_GET_STOP_TRX_C2H_DLY;
+
+	ret = proc_msg_reg(adapter, &h2c_info, &c2h_poll);
+	if (ret != MACSUCCESS) {
+		PLTFM_MSG_ERR("[ERR]wow stoptrx proc msg reg %d\n", ret);
+		adapter->sm.wow_stoptrx_stat = MAC_AX_WOW_STOPTRX_FAIL;
+		return ret;
+	}
+
+	adapter->sm.wow_stoptrx_stat = MAC_AX_WOW_STOPTRX_IDLE;
+
+	return MACSUCCESS;
+}
+
+u32 mac_cfg_wow_auto_test(struct mac_ax_adapter *adapter, u8 rxtest)
+{
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	struct fwcmd_wow_auto_test *fwcmd_wow_auto_test;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY) {
+		PLTFM_MSG_WARN("%s fw not ready\n", __func__);
+		return MACFWNONRDY;
+	}
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_wow_auto_test));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_wow_auto_test = (struct fwcmd_wow_auto_test *)buf;
+	fwcmd_wow_auto_test->dword0 =
+	cpu_to_le32((rxtest ? FWCMD_H2C_WOW_AUTO_TEST_RX_TEST : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb,
+			      FWCMD_TYPE_H2C, FWCMD_H2C_CAT_TEST,
+			      FWCMD_H2C_CL_WOW_TEST, FWCMD_H2C_FUNC_WOW_AUTO_TEST,
+			      0, 0);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+#endif
+	if (ret) {
+		PLTFM_MSG_ERR("[ERR]platform tx: %d\n", ret);
+		adapter->sm.aoac_rpt = MAC_AX_AOAC_RPT_ERROR;
+		goto fail;
+	}
+
+	h2cb_free(adapter, h2cb);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+static void dump_bytes(struct mac_ax_adapter *adapter, u8 *start, u32 size)
+{
+#if PROXY_MDNS_DUMP
+	u32 idx;
+
+	for (idx = 0; idx < size; idx += 4, start += 4) {
+		switch (size - idx) {
+		case 1:
+			PLTFM_MSG_TRACE("- 0x%x: 0x%x\n", idx, *start);
+			break;
+		case 2:
+			PLTFM_MSG_TRACE("- 0x%x: 0x%x 0x%x\n", idx, *start, *(start + 1));
+			break;
+		case 3:
+			PLTFM_MSG_TRACE("- 0x%x: 0x%x 0x%x 0x%x\n", idx,
+					*start, *(start + 1), *(start + 2));
+			break;
+		default:
+			PLTFM_MSG_TRACE("- 0x%x: 0x%x 0x%x 0x%x 0x%x\n", idx,
+					*start, *(start + 1), *(start + 2), *(start + 3));
+			break;
+		}
+	}
+#endif
+}
+
+static void mdns_sprintf(struct mac_ax_adapter *adapter, char *content, u8 *in, u32 len)
+{
+#if PROXY_MDNS_DUMP
+	u32 idx;
+	u32 write_idx;
+
+	write_idx = 0;
+	PLTFM_MEMSET(content, 0, 128);
+	content[write_idx++] = '<';
+	for (idx = 0; idx < len; idx++) {
+		if (in[idx] >= 0x20) {
+			content[write_idx++] = in[idx];
+		} else {
+			content[write_idx++] = '[';
+			if ((in[idx] >> 4) < 10)
+				content[write_idx++] = '0' + (in[idx] >> 4);
+			else
+				content[write_idx++] = 'A' + (in[idx] >> 4) - 10;
+			if ((in[idx] & 0xf) < 10)
+				content[write_idx++] = '0' + (in[idx] & 0xf);
+			else
+				content[write_idx++] = 'A' + (in[idx] & 0xf) - 10;
+			content[write_idx++] = ']';
+		}
+	}
+	content[write_idx++] = '>';
+	content[write_idx] = 0;
+#endif
+}
+
+static void dump_mdns_machine(struct mac_ax_adapter *adapter,
+			      struct rtw_hal_mac_proxy_mdns_machine *machine)
+{
+#if PROXY_MDNS_DUMP
+
+	char p[128];
+
+	mdns_sprintf(adapter, p, machine->name, machine->len);
+	PLTFM_MSG_TRACE("[MDNS][Mchn] %s (%d)\n", &p, machine->len);
+#endif
+}
+
+static void dump_mdns_rsp_hdr(struct mac_ax_adapter *adapter,
+			      struct rtw_hal_mac_proxy_mdns_rsp_hdr h)
+{
+#if PROXY_MDNS_DUMP
+	PLTFM_MSG_TRACE("[MDNS] hdr: type (0x%x 0x%x), cf_cls (0x%x 0x%x), ttl (%d), len (%d)\n",
+			h.rspTypeB0, h.rspTypeB1,
+			h.cache_class_B0, h.cache_class_B1, h.ttl, h.dataLen);
+#endif
+}
+
+static void dump_mdns_serv(struct mac_ax_adapter *adapter, struct rtw_hal_mac_proxy_mdns_service *s)
+{
+#if PROXY_MDNS_DUMP
+	char p[128];
+
+	mdns_sprintf(adapter, p, s->name, s->name_len);
+	PLTFM_MSG_TRACE("[Serv] name %s (%d)\n", p, s->name_len);
+	PLTFM_MSG_TRACE("[Serv] =============>\n");
+	dump_mdns_rsp_hdr(adapter, s->hdr);
+	PLTFM_MSG_TRACE("[Serv] prio (0x%x), weight (0x%x), port (%d)\n",
+			s->priority, s->weight, s->port);
+	mdns_sprintf(adapter, p, s->target, s->target_len);
+	PLTFM_MSG_TRACE("[Serv] target %s (%d), compress (0x%x), hasTxt (%x), txtPktId (%d)\n",
+			p, s->target_len, s->compression, s->has_txt, s->txt_pktid);
+#endif
+}
+
+static void dump_mdns(struct mac_ax_adapter *adapter, struct rtw_hal_mac_proxy_mdns *mdns)
+{
+#if PROXY_MDNS_DUMP
+	u8 idx;
+	char p[128];
+
+	PLTFM_MSG_TRACE("\n");
+	PLTFM_MSG_TRACE("[MDNS] v4 pkt (%d), v6 pkt (%d), #serv (%d), #machine (%d), macid (%d)\n",
+			mdns->ipv4_pktid, mdns->ipv6_pktid,
+			mdns->num_supported_services, mdns->num_machine_names, mdns->macid);
+	PLTFM_MSG_TRACE("[MDNS] serv0 (%d), serv1 (%d), serv2 (%d), serv3 (%d), serv4 (%d)\n",
+			mdns->serv_pktid[0], mdns->serv_pktid[1], mdns->serv_pktid[2],
+			mdns->serv_pktid[3], mdns->serv_pktid[4]);
+	PLTFM_MSG_TRACE("[MDNS] serv5 (%d), serv6 (%d), serv7 (%d), serv8 (%d), serv9 (%d)\n",
+			mdns->serv_pktid[5], mdns->serv_pktid[6], mdns->serv_pktid[7],
+			mdns->serv_pktid[8], mdns->serv_pktid[9]);
+
+	PLTFM_MSG_TRACE("\n");
+	for (idx = 0; idx < mdns->num_machine_names; idx++) {
+		PLTFM_MSG_TRACE("[MDNS][Mchn %d] =====>\n", idx);
+		dump_mdns_machine(adapter, &mdns->machines[idx]);
+	}
+
+	PLTFM_MSG_TRACE("\n");
+	PLTFM_MSG_TRACE("[MDNS][A] =============>\n");
+	dump_mdns_rsp_hdr(adapter, mdns->a_rsp.hdr);
+	PLTFM_MSG_TRACE("[MDNS][A] %d.%d.%d.%d\n", mdns->a_rsp.ipv4Addr[0],
+			mdns->a_rsp.ipv4Addr[1], mdns->a_rsp.ipv4Addr[2], mdns->a_rsp.ipv4Addr[3]);
+	dump_bytes(adapter, (u8 *)&mdns->a_rsp, sizeof(mdns->a_rsp));
+
+	PLTFM_MSG_TRACE("\n");
+	PLTFM_MSG_TRACE("[MDNS][AAAA] =============>\n");
+	dump_mdns_rsp_hdr(adapter, mdns->aaaa_rsp.hdr);
+	PLTFM_MSG_TRACE("[MDNS][AAAA] %x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x\n",
+			mdns->aaaa_rsp.ipv6Addr[0], mdns->aaaa_rsp.ipv6Addr[1],
+			mdns->aaaa_rsp.ipv6Addr[2], mdns->aaaa_rsp.ipv6Addr[3],
+			mdns->aaaa_rsp.ipv6Addr[4], mdns->aaaa_rsp.ipv6Addr[5],
+			mdns->aaaa_rsp.ipv6Addr[6], mdns->aaaa_rsp.ipv6Addr[7],
+			mdns->aaaa_rsp.ipv6Addr[8], mdns->aaaa_rsp.ipv6Addr[9],
+			mdns->aaaa_rsp.ipv6Addr[10], mdns->aaaa_rsp.ipv6Addr[11],
+			mdns->aaaa_rsp.ipv6Addr[12], mdns->aaaa_rsp.ipv6Addr[13],
+			mdns->aaaa_rsp.ipv6Addr[14], mdns->aaaa_rsp.ipv6Addr[15]);
+	dump_bytes(adapter, (u8 *)&mdns->aaaa_rsp, sizeof(mdns->aaaa_rsp));
+
+	PLTFM_MSG_TRACE("\n");
+	PLTFM_MSG_TRACE("[MDNS][PTR] =============>\n");
+	dump_mdns_rsp_hdr(adapter, mdns->ptr_rsp.hdr);
+	mdns_sprintf(adapter, p, mdns->ptr_rsp.domain, mdns->ptr_rsp.hdr.dataLen - 2);
+	PLTFM_MSG_TRACE("[MDNS][PTR] domain %s\n", &p);
+	dump_bytes(adapter, (u8 *)&mdns->ptr_rsp, sizeof(mdns->ptr_rsp));
+#endif
+}
+
+static void mdns_rsp_hdr_endian(struct rtw_hal_mac_proxy_mdns_rsp_hdr *hdr)
+{
+	hdr->ttl = cpu_to_be32(hdr->ttl);
+	hdr->dataLen = cpu_to_be16(hdr->dataLen);
+}
+
+u32 mac_proxyofld(struct mac_ax_adapter *adapter, struct rtw_hal_mac_proxyofld *pcfg)
+{
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 *buf;
+	struct rtw_hal_mac_proxyofld cfg;
+	struct mac_ax_intf_ops *ops = adapter_to_intf_ops(adapter);
+	struct mac_ax_multicast_info mc_info = {{0}, {0}};
+	u32 val32;
+
+	ret = MACSUCCESS;
+	cfg = *pcfg;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+	if (adapter->sm.proxy_st != MAC_AX_PROXY_IDLE)
+		return MACPROCERR;
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct fwcmd_proxy));
+	if (!buf) {
+		h2cb_free(adapter, h2cb);
+		return MACNOBUF;
+	}
+
+	PLTFM_MEMCPY(buf, &cfg, sizeof(cfg));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb, FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PROXY, FWCMD_H2C_FUNC_PROXY, 1, 1);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+	adapter->sm.proxy_st = MAC_AX_PROXY_SENDING;
+	h2cb_free(adapter, h2cb);
+
+	if (cfg.mdns_v4_rsp || cfg.mdns_v4_wake || cfg.mdns_v6_rsp || cfg.mdns_v6_wake) {
+		val32 = MAC_REG_R32(R_AX_RX_FLTR_OPT);
+		val32 |= B_AX_A_MC_LIST_CAM_MATCH;
+		MAC_REG_W32(R_AX_RX_FLTR_OPT, val32);
+		if (cfg.mdns_v4_rsp || cfg.mdns_v4_wake) {
+			PLTFM_MEMCPY(mc_info.mc_addr, mdns_v4_multicast_addr, 6);
+			mc_info.mc_msk = MAC_AX_MSK_NONE;
+			mac_cfg_multicast(adapter, 1, &mc_info);
+		}
+		if (cfg.mdns_v6_rsp || cfg.mdns_v6_wake) {
+			PLTFM_MEMCPY(mc_info.mc_addr, mdns_v6_multicast_addr, 6);
+			mc_info.mc_msk = MAC_AX_MSK_NONE;
+			mac_cfg_multicast(adapter, 1, &mc_info);
+		}
+	}
+	if (cfg.wsd_v4_wake || cfg.wsd_v6_wake) {
+		val32 = MAC_REG_R32(R_AX_RX_FLTR_OPT);
+		val32 |= B_AX_A_MC_LIST_CAM_MATCH;
+		MAC_REG_W32(R_AX_RX_FLTR_OPT, val32);
+		if (cfg.wsd_v4_wake) {
+			PLTFM_MEMCPY(mc_info.mc_addr, wsd_v4_multicast_addr, 6);
+			mc_info.mc_msk = MAC_AX_MSK_NONE;
+			mac_cfg_multicast(adapter, 1, &mc_info);
+		}
+		if (cfg.wsd_v6_wake) {
+			PLTFM_MEMCPY(mc_info.mc_addr, wsd_v6_multicast_addr, 6);
+			mc_info.mc_msk = MAC_AX_MSK_NONE;
+			mac_cfg_multicast(adapter, 1, &mc_info);
+		}
+	}
+
+	return ret;
+}
+
+u32 mac_proxy_mdns(struct mac_ax_adapter *adapter, struct rtw_hal_mac_proxy_mdns *pmdns)
+{
+	u8 *buf;
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 idx;
+	struct rtw_hal_mac_proxy_mdns mdns;
+
+	ret = MACSUCCESS;
+	mdns = *pmdns;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+	if (adapter->sm.proxy_st != MAC_AX_PROXY_IDLE)
+		return MACPROCERR;
+
+	PLTFM_MSG_TRACE("[MDNS] =============>\n");
+	dump_mdns(adapter, &mdns);
+	// dump_bytes(adapter, (u8 *)&mdns, sizeof(struct rtw_hal_mac_proxy_mdns));
+
+	for (idx = 0; idx < RTW_PHL_PROXY_MDNS_MAX_MACHINE_NUM; idx++)
+		mdns.machines[idx].len = cpu_to_le32(mdns.machines[idx].len);
+	mdns_rsp_hdr_endian(&mdns.a_rsp.hdr);
+	mdns_rsp_hdr_endian(&mdns.aaaa_rsp.hdr);
+	mdns_rsp_hdr_endian(&mdns.ptr_rsp.hdr);
+
+	// dump_bytes(adapter, (u8 *)&mdns, sizeof(struct rtw_hal_mac_proxy_mdns));
+
+	h2cb = h2cb_alloc(adapter, H2CB_CLASS_LONG_DATA);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, sizeof(struct rtw_hal_mac_proxy_mdns));
+	if (!buf) {
+		h2cb_free(adapter, h2cb);
+		return MACNOBUF;
+	}
+
+	PLTFM_MEMCPY(buf, (u8 *)&mdns, sizeof(struct rtw_hal_mac_proxy_mdns));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb, FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PROXY, FWCMD_H2C_FUNC_MDNS, 1, 1);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+	adapter->sm.proxy_st = MAC_AX_PROXY_SENDING;
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_proxy_mdns_serv_pktofld(struct mac_ax_adapter *adapter,
+				struct rtw_hal_mac_proxy_mdns_service *pserv, u8 *pktid)
+{
+	u16 idx;
+	u8 *buf;
+	u16 len;
+	u32 ret;
+	struct rtw_hal_mac_proxy_mdns_service serv;
+
+	serv = *pserv;
+	ret = MACSUCCESS;
+	len = sizeof(struct rtw_hal_mac_proxy_mdns_service) + serv.name_len + serv.target_len;
+	len = len - (sizeof(u8 *) * 2) - 1 - 1; //get rid of *name, *target, target_len, txt_id
+	buf = (u8 *)PLTFM_MALLOC(len);
+
+	PLTFM_MSG_TRACE("\n");
+	PLTFM_MSG_TRACE("[MDNS][Serv] =============>\n");
+	dump_mdns_serv(adapter, &serv);
+
+	mdns_rsp_hdr_endian(&serv.hdr);
+	serv.priority = cpu_to_be16(serv.priority);
+	serv.weight = cpu_to_be16(serv.weight);
+	serv.port = cpu_to_be16(serv.port);
+
+	idx = 0;
+
+	buf[idx++] = serv.name_len;
+
+	PLTFM_MEMCPY(buf + idx, serv.name, serv.name_len);
+	idx += serv.name_len;
+
+	PLTFM_MEMCPY(buf + idx, &serv.hdr, RTW_PHL_PROXY_MDNS_RSP_HDR_LEN);
+	idx += RTW_PHL_PROXY_MDNS_RSP_HDR_LEN;
+
+	PLTFM_MEMCPY(buf + idx, &serv.priority, 2);
+	idx += 2;
+
+	PLTFM_MEMCPY(buf + idx, &serv.weight, 2);
+	idx += 2;
+
+	PLTFM_MEMCPY(buf + idx, &serv.port, 2);
+	idx += 2;
+
+	PLTFM_MEMCPY(buf + idx, serv.target, serv.target_len);
+	idx += serv.target_len;
+
+	buf[idx++] = serv.compression;
+	buf[idx++] = serv.compression_loc;
+	buf[idx++] = serv.has_txt;
+	buf[idx++] = serv.txt_pktid;
+
+	dump_bytes(adapter, buf, len);
+	ret = mac_add_pkt_ofld(adapter, buf, len, pktid);
+	PLTFM_MSG_TRACE("[MDNS][Serv] ret %d, pktid %d\n", ret, *pktid);
+	PLTFM_FREE(buf, len);
+	return ret;
+}
+
+u32 mac_proxy_mdns_txt_pktofld(struct mac_ax_adapter *adapter,
+			       struct rtw_hal_mac_proxy_mdns_txt *ptxt, u8 *pktid)
+{
+	u16 idx;
+	u8 *buf;
+	u16 len;
+	u32 ret;
+	struct rtw_hal_mac_proxy_mdns_txt txt;
+
+	txt = *ptxt;
+	ret = MACSUCCESS;
+	len = sizeof(struct rtw_hal_mac_proxy_mdns_txt) + txt.content_len;
+	len = len - sizeof(u16) - sizeof(u8 *);
+	buf = (u8 *)PLTFM_MALLOC(len);
+
+	PLTFM_MSG_TRACE("\n");
+	PLTFM_MSG_TRACE("[MDNS][Txt] =============>\n");
+	dump_mdns_rsp_hdr(adapter, txt.hdr);
+	mdns_rsp_hdr_endian(&txt.hdr);
+
+	idx = 0;
+
+	PLTFM_MEMCPY(buf, &txt.hdr, RTW_PHL_PROXY_MDNS_RSP_HDR_LEN);
+	idx += RTW_PHL_PROXY_MDNS_RSP_HDR_LEN;
+
+	PLTFM_MEMCPY(buf + idx, txt.content, txt.content_len);
+
+	dump_bytes(adapter, buf, len);
+	ret = mac_add_pkt_ofld(adapter, buf, len, pktid);
+	PLTFM_MSG_TRACE("[MDNS][Txt] ret %d, pktid %d\n", ret, *pktid);
+	PLTFM_FREE(buf, len);
+	return ret;
+}
+
+u32 mac_proxy_ptcl_pattern(struct mac_ax_adapter *adapter,
+			   struct rtw_hal_mac_proxy_ptcl_pattern *cfg)
+{
+	u8 *buf;
+	u32 ret;
+	#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cb;
+	#else
+	struct h2c_buf *h2cb;
+	#endif
+	u8 len;
+	u32 idx;
+	enum h2c_buf_class h2cb_type;
+	struct fwcmd_ptcl_pattern *ptcl_pattern_hdr;
+	u8 *patterns_head;
+	u8 curr_pattern_len;
+
+	len = sizeof(struct fwcmd_ptcl_pattern);
+	ret = MACSUCCESS;
+
+	if (adapter->sm.fwdl != MAC_AX_FWDL_INIT_RDY)
+		return MACNOFW;
+	if (adapter->sm.proxy_st != MAC_AX_PROXY_IDLE)
+		return MACPROCERR;
+
+	if (cfg->num_pattern > RTW_PHL_PROXY_PTCL_PATTERN_MAX_NUM)
+		return MACCMP;
+	for (idx = 0; idx < cfg->num_pattern; idx++) {
+		curr_pattern_len = cfg->pattern_len[idx];
+		if (curr_pattern_len > RTW_PHL_PROXY_PTCL_PATTERN_MAX_LEN)
+			return MACCMP;
+		len += (curr_pattern_len + 1);
+	}
+
+	if (len <= (H2C_CMD_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_CMD;
+		PLTFM_MSG_TRACE("[PtclPattern] size %d, using CMD Q\n", len);
+	} else if (len <= (H2C_DATA_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_DATA;
+		PLTFM_MSG_TRACE("[PtclPattern] size %d, using DATA Q\n", len);
+	} else if (len <= (H2C_LONG_DATA_LEN - FWCMD_HDR_LEN)) {
+		h2cb_type = H2CB_CLASS_LONG_DATA;
+		PLTFM_MSG_TRACE("[PtclPattern] size %d, using LDATA Q\n", len);
+	} else {
+		PLTFM_MSG_ERR("[PtclPattern] size %d, exceed LDATA Q size, abort\n", len);
+		return MACBUFSZ;
+	}
+
+	h2cb = h2cb_alloc(adapter, h2cb_type);
+	if (!h2cb)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cb, len);
+	if (!buf) {
+		h2cb_free(adapter, h2cb);
+		return MACNOBUF;
+	}
+
+	ptcl_pattern_hdr = (struct fwcmd_ptcl_pattern *)buf;
+	ptcl_pattern_hdr->dword0 = cpu_to_le32(SET_WORD(cfg->macid, FWCMD_H2C_PTCL_PATTERN_MACID) |
+					       SET_WORD(cfg->ptcl, FWCMD_H2C_PTCL_PATTERN_PTCL) |
+					       SET_WORD(cfg->num_pattern,
+							FWCMD_H2C_PTCL_PATTERN_NUM_PATTERN));
+	PLTFM_MSG_TRACE("[PtclPattern] macid (%d), ptcl (%d), n_pattern (%d)\n",
+			cfg->macid, cfg->ptcl, cfg->num_pattern);
+	patterns_head = buf + sizeof(struct fwcmd_ptcl_pattern);
+	for (idx = 0; idx < cfg->num_pattern; idx++) {
+		curr_pattern_len = cfg->pattern_len[idx];
+		*patterns_head++ = curr_pattern_len;
+		PLTFM_MEMCPY(patterns_head, (u8 *)cfg->patterns[idx], curr_pattern_len);
+		PLTFM_MSG_TRACE("[PtclPattern] - # %d : len (%d), [%s]",
+				idx, curr_pattern_len, (char *)cfg->patterns[idx]);
+		patterns_head += curr_pattern_len;
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cb, FWCMD_TYPE_H2C, FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_PROXY, FWCMD_H2C_FUNC_PTCL_PATTERN, 1, 1);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	ret = h2c_pkt_build_txd(adapter, h2cb);
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+
+	#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cb);
+	#else
+	ret = PLTFM_TX(h2cb->data, h2cb->len);
+	#endif
+
+	if (ret) {
+		h2cb_free(adapter, h2cb);
+		return ret;
+	}
+	adapter->sm.proxy_st = MAC_AX_PROXY_SENDING;
+	h2cb_free(adapter, h2cb);
+
+	return ret;
+}
+
+u32 mac_check_proxy_done(struct mac_ax_adapter *adapter, u8 *fw_ret)
+{
+	if (adapter->sm.proxy_st == MAC_AX_PROXY_IDLE) {
+		*fw_ret = adapter->sm.proxy_ret;
+		return MACSUCCESS;
+	}
+	return MACPROCBUSY;
+}
+
+u32 mac_magic_waker_filter(struct mac_ax_adapter *adapter,
+			   struct rtw_magic_waker_parm *parm)
+{
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cbuf;
+#else
+	struct h2c_buf *h2cbuf;
+#endif
+	struct fwcmd_magic_waker_filter *fwcmd_magic_waker;
+	u32 ret = 0;
+	u32 i = 0;
+
+	u8 waker_addr_size = parm->waker_num * WLAN_ADDR_LEN;
+	u32 *waker_addr_dword;
+	u8 *p_arr = parm->waker_addr_arr[0];
+
+	PLTFM_MSG_TRACE("[Magic_Waker] %s : num (%d)\n",
+			__func__, parm->waker_num);
+
+	for (i = 0; i < parm->waker_num; i++) {
+		PLTFM_MSG_TRACE("[Magic_Waker] %2x:%2x:%2x:%2x:%2x:%2x\n",
+				parm->waker_addr_arr[i][0], parm->waker_addr_arr[i][1],
+				parm->waker_addr_arr[i][2], parm->waker_addr_arr[i][3],
+				parm->waker_addr_arr[i][4], parm->waker_addr_arr[i][5]);
+	}
+
+	h2cbuf = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cbuf)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cbuf, sizeof(struct fwcmd_magic_waker_filter) + waker_addr_size);
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_magic_waker = (struct fwcmd_magic_waker_filter *)buf;
+	fwcmd_magic_waker->dword0 =
+		cpu_to_le32(SET_WORD(parm->waker_num, FWCMD_H2C_MAGIC_WAKER_FILTER_WAKER_NUM));
+
+	// endian proc
+	waker_addr_dword = (u32 *)(buf + sizeof(struct fwcmd_magic_waker_filter));
+	for (i = 0; i < waker_addr_size; i += 4) {
+		if ((waker_addr_size - i) != 2) {
+			*waker_addr_dword = cpu_to_le32(*(u32 *)((p_arr)+i));
+			waker_addr_dword++;
+		}
+		else {
+			*(u16 *)waker_addr_dword = cpu_to_le16(*(u16 *)((p_arr)+i));
+			waker_addr_dword++;
+		}
+	}
+
+	ret = h2c_pkt_set_hdr(adapter, h2cbuf,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_MAGIC_WAKER_FILTER,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cbuf);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cbuf);
+#else
+	ret = PLTFM_TX(h2cbuf->data, h2cbuf->len);
+#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cbuf);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cbuf);
+
+	return ret;
+}
+
+u32 mac_tcp_keepalive(struct mac_ax_adapter *adapter,
+		      struct rtw_tcp_keepalive_parm *parm)
+{
+	u8 *buf;
+#if MAC_AX_PHL_H2C
+	struct rtw_h2c_pkt *h2cbuf;
+#else
+	struct h2c_buf *h2cbuf;
+#endif
+	struct fwcmd_tcp_keepalive *fwcmd_tcp_keepalive;
+	u32 ret = 0;
+
+	PLTFM_MSG_TRACE("[TCP_Keepalive]macid(%d), period(%d sec), enable(%d), tx_pktid(%d)\n",
+			parm->macid, parm->period, parm->enable, parm->tx_pktid);
+	PLTFM_MSG_TRACE("[TCP_Keepalive]retry_intvl(%d sec), max_retry_cnt(%d), immed_tx(%d)\n",
+			parm->retry_intvl, parm->max_retry_cnt, parm->immed_tx);
+	PLTFM_MSG_TRACE("[TCP_Keepalive]ack_pktid(%d), recv_timeout(%d sec), seq_increase(%d)\n",
+			parm->ack_pktid, parm->recv_keepalive_timeout, parm->seq_increase);
+
+	if (parm->macid > WOW_MAX_MACID) {
+		PLTFM_MSG_ERR("[TCP_Keepalive] macid can not exceed %d\n", WOW_MAX_MACID);
+		return MACFUNCINPUT;
+	}
+
+	h2cbuf = h2cb_alloc(adapter, H2CB_CLASS_DATA);
+	if (!h2cbuf)
+		return MACNPTR;
+
+	buf = h2cb_put(h2cbuf, sizeof(struct fwcmd_tcp_keepalive));
+	if (!buf) {
+		ret = MACNOBUF;
+		goto fail;
+	}
+
+	fwcmd_tcp_keepalive = (struct fwcmd_tcp_keepalive *)buf;
+	fwcmd_tcp_keepalive->dword0 =
+	cpu_to_le32(SET_WORD((u8)parm->macid, FWCMD_H2C_TCP_KEEPALIVE_MACID) |
+		    SET_WORD(parm->period, FWCMD_H2C_TCP_KEEPALIVE_PERIOD) |
+		    SET_WORD(parm->tx_pktid, FWCMD_H2C_TCP_KEEPALIVE_TX_PKTID) |
+		    (parm->enable ? FWCMD_H2C_TCP_KEEPALIVE_ENABLE : 0));
+	fwcmd_tcp_keepalive->dword1 =
+	cpu_to_le32(SET_WORD(parm->retry_intvl,
+			     FWCMD_H2C_TCP_KEEPALIVE_RETRY_INTVL) |
+		    SET_WORD(parm->max_retry_cnt,
+			     FWCMD_H2C_TCP_KEEPALIVE_MAX_RETRY_CNT) |
+		    (parm->immed_tx ?
+		     FWCMD_H2C_TCP_KEEPALIVE_IMMED_TX : 0));
+	fwcmd_tcp_keepalive->dword2 =
+	cpu_to_le32(SET_WORD(parm->ack_pktid,
+			     FWCMD_H2C_TCP_KEEPALIVE_ACK_PKTID) |
+		    SET_WORD(parm->recv_keepalive_timeout,
+			     FWCMD_H2C_TCP_KEEPALIVE_RECV_KEEPALIVE_TIMEOUT) |
+		    (parm->seq_increase ?
+		     FWCMD_H2C_TCP_KEEPALIVE_SEQ_INCREASE : 0));
+
+	ret = h2c_pkt_set_hdr(adapter, h2cbuf,
+			      FWCMD_TYPE_H2C,
+			      FWCMD_H2C_CAT_MAC,
+			      FWCMD_H2C_CL_WOW,
+			      FWCMD_H2C_FUNC_TCP_KEEPALIVE,
+			      0,
+			      1);
+	if (ret)
+		goto fail;
+
+	ret = h2c_pkt_build_txd(adapter, h2cbuf);
+	if (ret)
+		goto fail;
+
+#if MAC_AX_PHL_H2C
+	ret = PLTFM_TX(h2cbuf);
+#else
+	ret = PLTFM_TX(h2cbuf->data, h2cbuf->len);
+#endif
+	if (ret)
+		goto fail;
+
+	h2cb_free(adapter, h2cbuf);
+
+	return MACSUCCESS;
+fail:
+	h2cb_free(adapter, h2cbuf);
+
+	return ret;
+}
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/wowlan.h b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/wowlan.h
new file mode 100644
index 000000000000..6a9011013f06
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8852bs/phl/hal_g6/mac/mac_ax/wowlan.h
@@ -0,0 +1,978 @@
+/** @file */
+/******************************************************************************
+ *
+ * Copyright(c) 2019 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ ******************************************************************************/
+
+#ifndef _MAC_AX_WOWLAN_H_
+#define _MAC_AX_WOWLAN_H_
+
+#include "../type.h"
+#include "fwcmd.h"
+#include "role.h"
+#include "gpio_cmd.h"
+
+#define WOW_GET_STOP_TRX_C2H_CNT 10000
+#define WOW_GET_STOP_TRX_C2H_DLY 10
+
+#define WOW_GET_AOAC_RPT_C2H_CNT 1000
+#define WOW_GET_AOAC_RPT_C2H_DLY 100
+
+#define WOW_STOPTRX_H2CREG_DW_SIZE 1 /* mapping to struct wow_stoptrx_h2creg */
+
+#define PROXY_MDNS_DUMP	0
+
+#define WOW_MAX_MACID 255
+
+/**
+ * @struct keep_alive
+ * @brief keep_alive
+ *
+ * @var keep_alive::keepalive_en
+ * Please Place Description here.
+ * @var keep_alive::rsvd0
+ * Please Place Description here.
+ * @var keep_alive::packet_id
+ * Please Place Description here.
+ * @var keep_alive::period
+ * Please Place Description here.
+ * @var keep_alive::mac_id
+ * Please Place Description here.
+ */
+struct keep_alive {
+	u32 keepalive_en:1;
+	u32 rsvd0:7;
+	u32 packet_id:8;
+	u32 period:8;
+	u32 mac_id:8;
+};
+
+/**
+ * @struct disconnect_detect
+ * @brief disconnect_detect
+ *
+ * @var disconnect_detect::disconnect_detect_en
+ * Please Place Description here.
+ * @var disconnect_detect::tryok_bcnfail_count_en
+ * Please Place Description here.
+ * @var disconnect_detect::disconnect_en
+ * Please Place Description here.
+ * @var disconnect_detect::rsvd0
+ * Please Place Description here.
+ * @var disconnect_detect::mac_id
+ * Please Place Description here.
+ * @var disconnect_detect::check_period
+ * Please Place Description here.
+ * @var disconnect_detect::try_pkt_count
+ * Please Place Description here.
+ * @var disconnect_detect::tryok_bcnfail_count_limit
+ * Please Place Description here.
+ * @var disconnect_detect::rsvd1
+ * Please Place Description here.
+ */
+struct disconnect_detect {
+	u32 disconnect_detect_en:1;
+	u32 tryok_bcnfail_count_en:1;
+	u32 disconnect_en:1;
+	u32 rsvd0:5;
+	u32 mac_id:8;
+	u32 check_period:8;
+	u32 try_pkt_count:8;
+	u32 tryok_bcnfail_count_limit:8;
+	u32 rsvd1:24;
+};
+
+/**
+ * @struct wow_global
+ * @brief wow_global
+ *
+ * @var wow_global::wow_en
+ * Please Place Description here.
+ * @var wow_global::drop_all_pkt
+ * Please Place Description here.
+ * @var wow_global::rx_parse_after_wake
+ * Please Place Description here.
+ * @var wow_global::rsvd0
+ * Please Place Description here.
+ * @var wow_global::mac_id
+ * Please Place Description here.
+ * @var wow_global::pairwise_sec_algo
+ * Please Place Description here.
+ * @var wow_global::group_sec_algo
+ * Please Place Description here.
+ * @var wow_global::remotectrl_info_content
+ * Please Place Description here.
+ * @var wow_global::remotectrl_info_more
+ * Please Place Description here.
+ */
+struct wow_global {
+	u32 wow_en:1;
+	u32 drop_all_pkt:1;
+	u32 rx_parse_after_wake:1;
+	u32 rsvd0:5;
+	u32 mac_id:8;
+	u32 pairwise_sec_algo:8;
+	u32 group_sec_algo:8;
+	u32 remotectrl_info_content;
+	u32 remotectrl_info_more[sizeof(struct
+					mac_ax_remotectrl_info_parm_) / 4 - 1];
+};
+
+/**
+ * @struct gtk_ofld
+ * @brief gtk_ofld
+ *
+ * @var gtk_ofld::gtk_en
+ * Please Place Description here.
+ * @var gtk_ofld::tkip_en
+ * Please Place Description here.
+ * @var gtk_ofld::ieee80211w_en
+ * Please Place Description here.
+ * @var gtk_ofld::pairwise_wakeup
+ * Please Place Description here.
+ * @var gtk_ofld::rsvd0
+ * Please Place Description here.
+ * @var gtk_ofld::aoac_rep_id
+ * Please Place Description here.
+ * @var gtk_ofld::mac_id
+ * Please Place Description here.
+ * @var gtk_ofld::gtk_rsp_id
+ * Please Place Description here.
+ * @var gtk_ofld::pmf_sa_query_id
+ * Please Place Description here.
+ * @var gtk_ofld::bip_sec_algo
+ * Please Place Description here.
+ * @var gtk_ofld::rsvd1
+ * Please Place Description here.
+ * @var gtk_ofld::gtk_info_content
+ * Please Place Description here.
+ * @var gtk_ofld::gtk_info_more
+ * Please Place Description here.
+ */
+struct gtk_ofld {
+	u32 gtk_en:1;
+	u32 tkip_en:1;
+	u32 ieee80211w_en:1;
+	u32 pairwise_wakeup:1;
+	u32 norekey_wakeup:1;
+	u32 rsvd0:3;
+	u32 aoac_rep_id:8;
+	u32 mac_id:8;
+	u32 gtk_rsp_id:8;
+	u32 pmf_sa_query_id:8;
+	u32 bip_sec_algo:2;
+	u32 algo_akm_suit: 8;
+	u32 rsvd1: 14;
+
+	u32 gtk_info_content;
+	//u32 gtk_info_more[30];
+	u32 gtk_info_more[sizeof(struct mac_ax_gtk_info_parm_) / 4 - 1];
+};
+
+/**
+ * @struct arp_ofld
+ * @brief arp_ofld
+ *
+ * @var arp_ofld::arp_en
+ * Please Place Description here.
+ * @var arp_ofld::arp_action
+ * Please Place Description here.
+ * @var arp_ofld::rsvd0
+ * Please Place Description here.
+ * @var arp_ofld::mac_id
+ * Please Place Description here.
+ * @var arp_ofld::arp_rsp_id
+ * Please Place Description here.
+ * @var arp_ofld::arp_info_content
+ * Please Place Description here.
+ */
+struct arp_ofld {
+	u32 arp_en:1;
+	u32 arp_action:1;
+	u32 rsvd0:14;
+	u32 mac_id:8;
+	u32 arp_rsp_id:8;
+	u32 arp_info_content:32;
+};
+
+/**
+ * @struct ndp_ofld
+ * @brief ndp_ofld
+ *
+ * @var ndp_ofld::ndp_en
+ * Please Place Description here.
+ * @var ndp_ofld::rsvd0
+ * Please Place Description here.
+ * @var ndp_ofld::mac_id
+ * Please Place Description here.
+ * @var ndp_ofld::na_id
+ * Please Place Description here.
+ * @var ndp_ofld::ndp_info_content
+ * Please Place Description here.
+ * @var ndp_ofld::ndp_info_more
+ * Please Place Description here.
+ */
+struct ndp_ofld {
+	u32 ndp_en:1;
+	u32 rsvd0:15;
+	u32 mac_id:8;
+	u32 na_id:8;
+	u32 ndp_info_content;
+	//u32 ndp_info_more[27];
+	u32 ndp_info_more[2 * sizeof(struct mac_ax_ndp_info_parm_) / 4 - 1];
+};
+
+/**
+ * @struct realwow
+ * @brief realwow
+ *
+ * @var realwow::realwow_en
+ * Please Place Description here.
+ * @var realwow::auto_wakeup
+ * Please Place Description here.
+ * @var realwow::rsvd0
+ * Please Place Description here.
+ * @var realwow::mac_id
+ * Please Place Description here.
+ * @var realwow::keepalive_id
+ * Please Place Description here.
+ * @var realwow::wakeup_pattern_id
+ * Please Place Description here.
+ * @var realwow::ack_pattern_id
+ * Please Place Description here.
+ * @var realwow::rsvd1
+ * Please Place Description here.
+ * @var realwow::realwow_info_content
+ * Please Place Description here.
+ * @var realwow::realwow_info_more
+ * Please Place Description here.
+ */
+struct realwow {
+	u32 realwow_en:1;
+	u32 auto_wakeup:1;
+	u32 rsvd0:22;
+	u32 mac_id:8;
+	u32 keepalive_id:8;
+	u32 wakeup_pattern_id:8;
+	u32 ack_pattern_id:8;
+	u32 rsvd1:8;
+	u32 realwow_info_content;
+	u32 realwow_info_more[sizeof(struct mac_ax_realwowv2_info_parm_)
+			      / 4 - 1];
+};
+
+/**
+ * @struct nlo
+ * @brief nlo
+ *
+ * @var nlo::nlo_en
+ * Please Place Description here.
+ * @var nlo::nlo_32k_en
+ * Please Place Description here.
+ * @var nlo::ignore_cipher_type
+ * Please Place Description here.
+ * @var nlo::rsvd0
+ * Please Place Description here.
+ * @var nlo::mac_id
+ * Please Place Description here.
+ * @var nlo::nlo_networklistinfo_content
+ * Please Place Description here.
+ * @var nlo::nlo_networklistinfo_more
+ * Please Place Description here.
+ */
+struct nlo {
+	u32 nlo_en:1;
+	u32 nlo_32k_en:1;
+	u32 ignore_cipher_type:1;
+	u32 rsvd0:21;
+	u32 mac_id:8;
+	u32 nlo_networklistinfo_content;
+	u32 nlo_networklistinfo_more[sizeof(struct mac_ax_nlo_networklist_parm_)
+				     / 4 - 1];
+};
+
+/**
+ * @struct wakeup_ctrl
+ * @brief wakeup_ctrl
+ *
+ * @var wakeup_ctrl::pattern_match_en
+ * Please Place Description here.
+ * @var wakeup_ctrl::magic_en
+ * Please Place Description here.
+ * @var wakeup_ctrl::hw_unicast_en
+ * Please Place Description here.
+ * @var wakeup_ctrl::fw_unicast_en
+ * Please Place Description here.
+ * @var wakeup_ctrl::deauth_wakeup
+ * Please Place Description here.
+ * @var wakeup_ctrl::rekey_wakeup
+ * Please Place Description here.
+ * @var wakeup_ctrl::eap_wakeup
+ * Please Place Description here.
+ * @var wakeup_ctrl::all_data_wakeup
+ * Please Place Description here.
+ * @var wakeup_ctrl::rsvd0
+ * Please Place Description here.
+ * @var wakeup_ctrl::rsvd1
+ * Please Place Description here.
+ * @var wakeup_ctrl::mac_id
+ * Please Place Description here.
+ */
+struct wakeup_ctrl {
+	u32 pattern_match_en:1;
+	u32 magic_en:1;
+	u32 hw_unicast_en:1;
+	u32 fw_unicast_en:1;
+	u32 deauth_wakeup:1;
+	u32 rekey_wakeup:1;
+	u32 eap_wakeup:1;
+	u32 all_data_wakeup:1;
+	u32 rsvd0:1;
+	u32 rsvd1:15;
+	u32 mac_id:8;
+};
+
+/**
+ * @struct negative_pattern
+ * @brief negative_pattern
+ *
+ * @var negative_pattern::negative_pattern_en
+ * Please Place Description here.
+ * @var negative_pattern::rsvd0
+ * Please Place Description here.
+ * @var negative_pattern::pattern_count
+ * Please Place Description here.
+ * @var negative_pattern::mac_id
+ * Please Place Description here.
+ * @var negative_pattern::pattern_content
+ * Please Place Description here.
+ */
+struct negative_pattern {
+	u32 negative_pattern_en:1;
+	u32 rsvd0:19;
+	u32 pattern_count:4;
+	u32 mac_id:8;
+	u32 pattern_content:32;
+};
+
+/**
+ * @struct hst2dev_ctrl
+ * @brief hst2dev_ctrl
+ *
+ * @var hst2dev_ctrl::disable_uphy
+ * Please Place Description here.
+ * @var hst2dev_ctrl::handshake_mode
+ * Please Place Description here.
+ * @var hst2dev_ctrl::rsvd0
+ * Please Place Description here.
+ * @var hst2dev_ctrl::rise_hst2dev_dis_uphy
+ * Please Place Description here.
+ * @var hst2dev_ctrl::uphy_dis_delay_unit
+ * Please Place Description here.
+ * @var hst2dev_ctrl::pdn_as_uphy_dis
+ * Please Place Description here.
+ * @var hst2dev_ctrl::pdn_to_enable_uphy
+ * Please Place Description here.
+ * @var hst2dev_ctrl::rsvd1
+ * Please Place Description here.
+ * @var hst2dev_ctrl::hst2dev_gpio_num
+ * Please Place Description here.
+ * @var hst2dev_ctrl::uphy_dis_delay_count
+ * Please Place Description here.
+ */
+struct hst2dev_ctrl {
+	u32 disable_uphy:1;
+	u32 handshake_mode:3;
+	u32 rsvd0:4;
+	u32 rise_hst2dev_dis_uphy:1;
+	u32 uphy_dis_delay_unit:1;
+	u32 pdn_as_uphy_dis:1;
+	u32 pdn_to_enable_uphy:1;
+	u32 hst2dev_en:1;
+	u32 rsvd1:3;
+	u32 hst2dev_gpio_num:8;
+	u32 uphy_dis_delay_count:8;
+};
+
+/**
+ * @struct wowcam_upd
+ * @brief wowcam_upd
+ *
+ * @var wowcam_upd::r_w
+ * Please Place Description here.
+ * @var wowcam_upd::idx
+ * Please Place Description here.
+ * @var wowcam_upd::rsvd0
+ * Please Place Description here.
+ * @var wowcam_upd::wkfm1
+ * Please Place Description here.
+ * @var wowcam_upd::wkfm2
+ * Please Place Description here.
+ * @var wowcam_upd::wkfm3
+ * Please Place Description here.
+ * @var wowcam_upd::wkfm4
+ * Please Place Description here.
+ * @var wowcam_upd::crc
+ * Please Place Description here.
+ * @var wowcam_upd::rsvd1
+ * Please Place Description here.
+ * @var wowcam_upd::negative_pattern_match
+ * Please Place Description here.
+ * @var wowcam_upd::skip_mac_hdr
+ * Please Place Description here.
+ * @var wowcam_upd::uc
+ * Please Place Description here.
+ * @var wowcam_upd::mc
+ * Please Place Description here.
+ * @var wowcam_upd::bc
+ * Please Place Description here.
+ * @var wowcam_upd::rsvd2
+ * Please Place Description here.
+ * @var wowcam_upd::valid
+ * Please Place Description here.
+ */
+struct wowcam_upd {
+	u32 r_w: 1;
+	u32 idx: 7;
+	u32 rsvd0: 24;
+	u32 wkfm1: 32;
+	u32 wkfm2: 32;
+	u32 wkfm3: 32;
+	u32 wkfm4: 32;
+	u32 crc: 16;
+	u32 rsvd1: 6;
+	u32 negative_pattern_match: 1;
+	u32 skip_mac_hdr: 1;
+	u32 uc: 1;
+	u32 mc: 1;
+	u32 bc: 1;
+	u32 rsvd2: 4;
+	u32 valid: 1;
+};
+
+struct wow_stoptrx_h2creg {
+	u32 func:7;
+	u32 ack:1;
+	u32 total_len:4;
+	u32 seq_num:4;
+	u32 rsvd:16;
+};
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+/**
+ * @brief mac_cfg_wow_wake
+ *
+ * @param *adapter
+ * @param macid
+ * @param *info
+ * @param *content
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_wow_wake(struct mac_ax_adapter *adapter,
+		     u8 macid,
+		     struct mac_ax_wow_wake_info *info,
+		     struct mac_ax_remotectrl_info_parm_ *content);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_disconnect_det
+ *
+ * @param *adapter
+ * @param macid
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_disconnect_det(struct mac_ax_adapter *adapter,
+			   u8 macid,
+			   struct mac_ax_disconnect_det_info *info);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_keep_alive
+ *
+ * @param *adapter
+ * @param macid
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_keep_alive(struct mac_ax_adapter *adapter,
+		       u8 macid,
+		       struct mac_ax_keep_alive_info *info);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief get_wake_reason
+ *
+ * @param *adapter
+ * @param *wowlan_wake_reason
+ * @return Please Place Description here.
+ * @retval u32
+ */
+
+u32 get_wake_reason(struct mac_ax_adapter *adapter,
+		    u8 *wowlan_wake_reason);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_gtk_ofld
+ *
+ * @param *adapter
+ * @param macid
+ * @param *info
+ * @param *content
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_gtk_ofld(struct mac_ax_adapter *adapter,
+		     u8 macid,
+		     struct mac_ax_gtk_ofld_info *info,
+		     struct mac_ax_gtk_info_parm_ *content);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_arp_ofld
+ *
+ * @param *adapter
+ * @param macid
+ * @param *info
+ * @param *parp_info_content
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_arp_ofld(struct mac_ax_adapter *adapter,
+		     u8 macid,
+		     struct mac_ax_arp_ofld_info *info,
+		     void  *parp_info_content);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_ndp_ofld
+ *
+ * @param *adapter
+ * @param macid
+ * @param *info
+ * @param *content
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_ndp_ofld(struct mac_ax_adapter *adapter,
+		     u8 macid,
+		     struct mac_ax_ndp_ofld_info *info,
+		     struct mac_ax_ndp_info_parm_ *content);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_realwow
+ *
+ * @param *adapter
+ * @param macid
+ * @param *info
+ * @param *content
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_realwow(struct mac_ax_adapter *adapter,
+		    u8 macid,
+		    struct mac_ax_realwow_info *info,
+		    struct mac_ax_realwowv2_info_parm_ *content);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_nlo
+ *
+ * @param *adapter
+ * @param macid
+ * @param *info
+ * @param *content
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_nlo(struct mac_ax_adapter *adapter,
+		u8 macid,
+		struct mac_ax_nlo_info *info,
+		struct mac_ax_nlo_networklist_parm_ *content);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_dev2hst_gpio
+ *
+ * @param *adapter
+ * @param *parm
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_dev2hst_gpio(struct mac_ax_adapter *adapter,
+			 struct rtw_dev2hst_gpio_info *parm);
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_hst2dev_uphy_ctrl
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_hst2dev_ctrl(struct mac_ax_adapter *adapter,
+			 struct mac_ax_hst2dev_ctrl_info *info);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_wowcam_upd
+ *
+ * @param *adapter
+ * @param *info
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_wowcam_upd(struct mac_ax_adapter *adapter,
+		       struct mac_ax_wowcam_upd_info *info);
+/**
+ * @}
+ */
+
+u32 mac_get_wow_wake_rsn(struct mac_ax_adapter *adapter, u8 *wake_rsn,
+			 u8 *reset);
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_cfg_wow_sleep
+ *
+ * @param *adapter
+ * @param sleep
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_wow_sleep(struct mac_ax_adapter *adapter,
+		      u8 sleep);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_get_wow_fw_status
+ *
+ * @param *adapter
+ * @param *status
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_get_wow_fw_status(struct mac_ax_adapter *adapter,
+			  u8 *status, u8 func_en);
+/**
+ * @}
+ */
+
+static u32 read_aoac_c2hreg(struct mac_ax_adapter *adapter,
+			    struct mac_ax_aoac_report *aoac_rpt);
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_request_aoac_report
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_request_aoac_report(struct mac_ax_adapter *adapter,
+			    u8 rx_ready);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_read_aoac_report
+ *
+ * @param *adapter
+ * @param **rpt_buf
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_read_aoac_report(struct mac_ax_adapter *adapter,
+			 struct mac_ax_aoac_report *rpt_buf, u8 rx_ready);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_check_aoac_report_done
+ *
+ * @param *adapter
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_aoac_report_done(struct mac_ax_adapter *adapter);
+/**
+ * @}
+ */
+
+u32 mac_wow_stop_trx(struct mac_ax_adapter *adapter);
+
+u32 mac_wow_get_stoptrx_st(struct mac_ax_adapter *adapter);
+
+/**
+ * @brief mac_cfg_wow_auto_test
+ *
+ * @param *adapter
+ * @param rxtest
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_cfg_wow_auto_test(struct mac_ax_adapter *adapter, u8 rxtest);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_proxyofld
+ *
+ * @param *adapter
+ * @param cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_proxyofld(struct mac_ax_adapter *adapter, struct rtw_hal_mac_proxyofld *pcfg);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_proxy_mdns_serv_pktofld
+ *
+ * @param *adapter
+ * @param serv
+ * @param pktid
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_proxy_mdns_serv_pktofld(struct mac_ax_adapter *adapter,
+				struct rtw_hal_mac_proxy_mdns_service *pserv, u8 *pktid);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_proxy_mdns_txt_pktofld
+ *
+ * @param *adapter
+ * @param txt
+ * @param pktid
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_proxy_mdns_txt_pktofld(struct mac_ax_adapter *adapter,
+			       struct rtw_hal_mac_proxy_mdns_txt *ptxt, u8 *pktid);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_proxy_mdns
+ *
+ * @param *adapter
+ * @param mdns
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_proxy_mdns(struct mac_ax_adapter *adapter, struct rtw_hal_mac_proxy_mdns *pmdns);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_proxy_ptcl_pattern
+ *
+ * @param *adapter
+ * @param cfg
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_proxy_ptcl_pattern(struct mac_ax_adapter *adapter,
+			   struct rtw_hal_mac_proxy_ptcl_pattern *cfg);
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup WakeOnWlan
+ * @{
+ */
+
+/**
+ * @brief mac_check_proxy_done
+ *
+ * @param *adapter
+ * @param *fw_ret
+ * @return Please Place Description here.
+ * @retval u32
+ */
+u32 mac_check_proxy_done(struct mac_ax_adapter *adapter, u8 *fw_ret);
+/**
+ * @}
+ */
+ /**
+  * @brief mac_magic_waker_filter
+  *
+  * @param *adapter
+  * @param parm
+  * @return Please Place Description here.
+  * @retval u32
+  */
+u32 mac_magic_waker_filter(struct mac_ax_adapter* adapter,
+			   struct rtw_magic_waker_parm* parm);
+/**
+ * @}
+ */
+ /**
+  * @brief mac_tcp_keepalive
+  *
+  * @param *adapter
+  * @param parm
+  * @return Please Place Description here.
+  * @retval u32
+  */
+u32 mac_tcp_keepalive(struct mac_ax_adapter* adapter,
+		      struct rtw_tcp_keepalive_parm* parm);
+/**
+ * @}
+ */
+
+#endif // #define _MAC_AX_WOWLAN_H_
-- 
2.39.2

