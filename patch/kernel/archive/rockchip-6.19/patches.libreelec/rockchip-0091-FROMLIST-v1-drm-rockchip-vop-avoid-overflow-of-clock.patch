From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Karina Yankevich <k.yankevich@omp.ru>
Date: Wed, 5 Nov 2025 19:07:17 +0300
Subject: drm/rockchip: vop: avoid overflow of clock rate in
 vop_crtc_mode_fixup()

Conversion of clock frequency from kHz to Hz in vop_crtc_mode_fixup()
can lead to integer overflow, since type of drm_display_mode::clock
is 'int'. Fix it by using 1000UL multiplier to avoid overflow
at least on 64-bit arches.

Found by Linux Verification Center (linuxtesting.org) with SVACE.

Fixes: b59b8de31497 ("drm/rockchip: return a true clock rate to adjusted_mode")
Signed-off-by: Karina Yankevich <k.yankevich@omp.ru>
Reviewed-by: Sergey Shtylyov <s.shtylyov@omp.ru>
---
 drivers/gpu/drm/rockchip/rockchip_drm_vop.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
index 111111111111..222222222222 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
@@ -1240,10 +1240,10 @@ static bool vop_crtc_mode_fixup(struct drm_crtc *crtc,
 	 * 4. Store the rounded up rate so that we don't need to worry about
 	 *    this in the actual clk_set_rate().
 	 */
-	rate = clk_round_rate(vop->dclk, adjusted_mode->clock * 1000);
+	rate = clk_round_rate(vop->dclk, adjusted_mode->clock * 1000UL);
 	if (rate / 1000 != adjusted_mode->clock)
 		rate = clk_round_rate(vop->dclk,
-				      adjusted_mode->clock * 1000 + 999);
+				      adjusted_mode->clock * 1000UL + 999);
 	adjusted_mode->clock = DIV_ROUND_UP(rate, 1000);
 
 	return true;
-- 
Armbian

