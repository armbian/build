From 3ca15f0cf371fe9c58b5c23c2cc5323df0067599 Mon Sep 17 00:00:00 2001
From: Frank Wunderlich <frank-w@public-files.de>
Date: Mon, 11 Aug 2025 12:18:33 +0200
Subject: [PATCH 002/116] add regs command from mtk-sdk and add crosscompile
 support

https://git01.mediatek.com/plugins/gitiles/openwrt/feeds/mtk-openwrt-feeds/+/refs/heads/master/feed/app/regs/src/

CROSS_COMPILE=aarch64-linux-gnu- make
---
 utils/regs/src/Makefile |  18 ++++
 utils/regs/src/regs     | Bin 0 -> 71024 bytes
 utils/regs/src/regs.c   | 224 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 242 insertions(+)
 create mode 100644 utils/regs/src/Makefile
 create mode 100755 utils/regs/src/regs
 create mode 100644 utils/regs/src/regs.c

diff --git a/utils/regs/src/Makefile b/utils/regs/src/Makefile
new file mode 100644
index 000000000000..6243684b47bd
--- /dev/null
+++ b/utils/regs/src/Makefile
@@ -0,0 +1,18 @@
+CC              = $(CROSS_COMPILE)gcc
+#LD              = $(CROSS_COMPILE)ld
+#AR              = $(CROSS_COMPILE)ar
+#NM              = $(CROSS_COMPILE)nm
+#OBJCOPY         = $(CROSS_COMPILE)objcopy
+#OBJDUMP         = $(CROSS_COMPILE)objdump
+#READELF         = $(CROSS_COMPILE)readelf
+#STRIP           = $(CROSS_COMPILE)strip
+
+
+EXEC = regs
+all: $(EXEC)
+$(EXEC): $(EXEC).c
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $@.c $(LDLIBS)
+romfs:
+	$(ROMFSINST) /bin/$(EXEC)
+clean:
+	-rm -f $(EXEC) *.elf *.gdb *.o
diff --git a/utils/regs/src/regs b/utils/regs/src/regs
new file mode 100755
index 0000000000000000000000000000000000000000..422babb880ae5e24f85713fad78f15ca5608af1c
GIT binary patch
literal 71024
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
J6%`HI|2H?I|9Sub

literal 0
HcmV?d00001

diff --git a/utils/regs/src/regs.c b/utils/regs/src/regs.c
new file mode 100644
index 000000000000..415b41cb0e7b
--- /dev/null
+++ b/utils/regs/src/regs.c
@@ -0,0 +1,224 @@
+/*
+ * pcimem.c: Simple program to read/write from/to a pci device from userspace.
+ *
+ *  Copyright (C) 2010, Bill Farrow (bfarrow@beyondelectronics.us)
+ *
+ *  Based on the devmem2.c code
+ *  Copyright (C) 2000, Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <termios.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#define PRINT_ERROR \
+	do { \
+		fprintf(stderr, "Error at line %d, file %s (%d) [%s]\n", \
+		__LINE__, __FILE__, errno, strerror(errno)); exit(1); \
+	} while(0)
+#define MAP_SIZE 4096UL
+#define MAP_MASK (MAP_SIZE - 1)
+void dump_page(uint32_t *vaddr, uint32_t *vbase, uint32_t *pbase)
+{
+	int i = 0;
+	uint32_t *end = vaddr + (MAP_SIZE >> 6);
+	uint32_t *start = vaddr;
+	while(start  < end) {
+		printf("%p:%08x %08x %08x %08x\n",
+			start - vbase + pbase, start[0], start[1] , start[2], start[3]);
+		start+=4;
+	}
+}
+void reg_mod_bits(uint32_t *virt_addr, int data, int start_bit, int data_len)
+{
+	int mask = 0;
+	int value;
+	int i;
+	if ((start_bit < 0) || (start_bit > 31) ||
+	    (data_len < 1) || (data_len > 32) ||
+	    (start_bit + data_len > 32)) {
+		fprintf(stderr,
+			"Startbit range[0~31], and DataLen range[1~32], and Startbit + DataLen <= 32\n");
+		exit(1);
+	}
+	for (i = 0; i < data_len; i++) {
+		if (start_bit + i > 31)
+			break;
+		mask |= 1 << (start_bit + i);
+	}
+	value = *((volatile uint32_t *) virt_addr);
+	value &= ~mask;
+	value |= (data << start_bit) & mask;;
+	*((uint32_t *) virt_addr) = value;
+	printf("Modify 0x%X[%d:%d]; ", data, start_bit + data_len - 1, start_bit);
+}
+void print_binary(uint32_t data)
+{
+	if (data > 1)
+		print_binary(data >> 1);
+	printf("%x", data % 2);
+}
+void reg_read_bits(uint32_t *virt_addr, uint32_t *virt_base, uint32_t *phy_base,
+		   int start_bit, int data_len)
+{
+	uint32_t mask = 0;
+	uint32_t value;
+	int i;
+	if ((start_bit < 0) || (start_bit > 31) ||
+	    (data_len < 1) || (data_len > 32) ||
+	    (start_bit + data_len > 32)) {
+		fprintf(stderr,
+			"Startbit range[0~31], and DataLen range[1~32], and Startbit + DataLen <= 32\n");
+		exit(1);
+	}
+	for (i = 0; i < data_len; i++) {
+		if (start_bit + i > 31)
+			break;
+		mask |= 1 << (start_bit + i);
+	}
+	value = *((uint32_t *)virt_addr);
+	value &= mask;
+	if (start_bit == 0 && data_len == 32)
+		printf("%p: %08x\n",
+		       virt_addr - virt_base + phy_base, value);
+	else {
+		printf("%p[%2d:%2d] = %x (hex)\n",
+		       virt_addr - virt_base + phy_base,
+		       start_bit + data_len - 1, start_bit,
+		       value >> start_bit);
+		printf("%17s = %d (dec)\n", "", value >> start_bit);
+		printf("%17s = ", "");
+		print_binary(value >> start_bit);
+		printf(" (bin)\n");
+	}
+}
+void usage(void)
+{
+	fprintf(stderr,
+		"\nUsage:\tregs [Type] [ Offset:Hex ] [ Data:Hex ] [StartBit:Dec] [DataLen:Dec]\n"
+		"\tType    : access operation type : [m]odify, [w]wite, [d]ump\n"
+		"\tOffset  : offset into memory region to act upon\n"
+		"\tData    : data to be written\n"
+		"\tStartbit: Startbit of Addr that want to be modified. Range[0~31]\n"
+		"\tDataLen : Data length of Data. Range[1~32], and Startbit + DataLen <= 32\n\n"
+		"Example:\tRead/Write/Modify register\n"
+		"\tDump    : regs d 0x1b100000           //dump 0x1b100000~0x1b1000f0\n"
+		"\tRead    : regs r 0x1b100000           //read 0x1b100000\n"
+		"\tRead    : regs r 0x1b100000 29 3      //read 0x1b100000[29:31]\n"
+		"\tWrite   : regs w 0x1b100000 0x1234    //write 0x1b100000=0x1234\n"
+		"\tModify  : regs m 0x1b100000 0x0 29 3  //modify 0x1b100000[29:31]=0\n");
+	exit(1);
+}
+int main(int argc, char **argv)
+{
+	int fd;
+	void *map_base = NULL;
+	void *virt_addr = NULL;
+	uint32_t read_result =0;
+	uint32_t writeval = 0;
+	uint32_t startbit = 0;
+	uint32_t datalen = 0;
+	char *filename = NULL;
+	off_t offset = 0;
+	int access_type = 0;
+	if(argc < 3) {
+		usage();
+		exit(1);
+	}
+	access_type = tolower((uint8_t)argv[1][0]);
+	if ((access_type == 'w' && argc < 4) || (access_type == 'm' && argc < 6)) {
+		usage();
+		exit(1);
+	}
+	filename = "/dev/mem";
+	if((fd = open(filename, O_RDWR | O_SYNC)) == -1)
+		PRINT_ERROR;
+	/* Map one page */
+	offset = strtoul(argv[2], NULL, 16);
+	if (offset > 0xFFFFFFFFFFFFUL)
+		PRINT_ERROR;
+	map_base = mmap(0, 2 * MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,
+			fd, offset & ~MAP_MASK);
+	if(map_base == (void *) -1)
+		PRINT_ERROR;
+	virt_addr = map_base + (offset & MAP_MASK);
+	read_result = *((volatile uint32_t *) virt_addr);
+	printf("Value at 0x%llX (%p): 0x%X\n",
+	       (unsigned long long)offset, virt_addr, read_result);
+	switch(access_type) {
+		case 'm':
+			writeval = strtoul(argv[3], 0, 16);
+			if (writeval > 0xFFFFFFFFUL)
+				PRINT_ERROR;
+			startbit = strtoul(argv[4], 0, 10);
+			if (startbit > 32)
+				PRINT_ERROR;
+			datalen  = strtoul(argv[5], 0, 10);
+			if (datalen > 32)
+				PRINT_ERROR;
+			reg_mod_bits((uint32_t *)virt_addr, writeval, startbit, datalen);
+			break;
+		case 'w':
+			writeval = strtoul(argv[3], 0, 16);
+			if (writeval > 0xFFFFFFFFUL)
+				PRINT_ERROR;
+			*((uint32_t *) virt_addr) = writeval;
+			printf("Written 0x%X; ", writeval);
+			break;
+		case 'd':
+			dump_page((uint32_t *)virt_addr, (uint32_t *)map_base,
+				  (uint32_t *)(offset & ~MAP_MASK));
+			goto out;
+		case 'r':
+			if (argc == 3)
+				reg_read_bits((uint32_t *)virt_addr,
+					      (uint32_t *)map_base,
+					      (uint32_t *)(offset & ~MAP_MASK),
+					      0, 32);
+			else {
+				startbit = strtoul(argv[3], 0, 10);
+				if (startbit > 32)
+					PRINT_ERROR;
+				datalen = strtoul(argv[4], 0, 10);
+				if (datalen > 32)
+					PRINT_ERROR;
+				reg_read_bits((uint32_t *)virt_addr,
+					      (uint32_t *)map_base,
+					      (uint32_t *)(offset & ~MAP_MASK),
+					      startbit, datalen);
+			}
+			goto out;
+		default:
+			printf("Illegal data type '%c'.\n", access_type);
+			goto out;
+	}
+	read_result = *((volatile uint32_t *) virt_addr);
+	printf("Readback 0x%X\n", read_result);
+out:
+	if(munmap(map_base, MAP_SIZE) == -1)
+		PRINT_ERROR;
+	close(fd);
+	return 0;
+}
-- 
2.39.5

