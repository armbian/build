From 8c62d09cdccb83e7d03b6bbeb4f8e30faba382c2 Mon Sep 17 00:00:00 2001
From: Daniel Golle <daniel@makrotopia.org>
Date: Thu, 3 Apr 2025 22:50:49 +0100
Subject: [PATCH 043/116] tag_mxl862xx*: remove support for older kernel
 versions

to be squashed into the previous commit before upstream submission
---
 net/dsa/tag_mxl862xx.c       | 61 ------------------------
 net/dsa/tag_mxl862xx_8021q.c | 91 ------------------------------------
 2 files changed, 152 deletions(-)

diff --git a/net/dsa/tag_mxl862xx.c b/net/dsa/tag_mxl862xx.c
index 470c70853bc6..c24ae6d706ac 100644
--- a/net/dsa/tag_mxl862xx.c
+++ b/net/dsa/tag_mxl862xx.c
@@ -24,18 +24,7 @@
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
 #include <net/dsa.h>
-
-#ifndef LINUX_VERSION_CODE
-#include <linux/version.h>
-#else
-#define KERNEL_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
-#endif
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0))
-#include "dsa_priv.h"
-#else
 #include "tag.h"
-#endif
 
 #define MXL862_NAME	"mxl862xx"
 
@@ -59,14 +48,7 @@
 static struct sk_buff *mxl862_tag_xmit(struct sk_buff *skb,
 				       struct net_device *dev)
 {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0))
-	int err;
-#endif
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 7, 0))
-	struct dsa_port *dp = dsa_slave_to_port(dev);
-#else
 	struct dsa_port *dp = dsa_user_to_port(dev);
-#endif
 	struct dsa_port *cpu_dp = dp->cpu_dp;
 	unsigned int cpu_port = cpu_dp->index + 1;
 	unsigned int usr_port = dp->index + 1;
@@ -76,12 +58,6 @@ static struct sk_buff *mxl862_tag_xmit(struct sk_buff *skb,
 	if (skb == NULL)
 		return skb;
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0))
-	err = skb_cow_head(skb, MXL862_TX_HEADER_LEN);
-	if (err)
-		return NULL;
-#endif
-
 	/* provide additional space 'MXL862_TX_HEADER_LEN' bytes */
 	skb_push(skb, MXL862_TX_HEADER_LEN);
 
@@ -103,20 +79,11 @@ static struct sk_buff *mxl862_tag_xmit(struct sk_buff *skb,
 	return skb;
 }
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0))
-static struct sk_buff *mxl862_tag_rcv(struct sk_buff *skb,
-				      struct net_device *dev,
-				      struct packet_type *pt)
-#else
 static struct sk_buff *mxl862_tag_rcv(struct sk_buff *skb,
 				      struct net_device *dev)
-#endif
 {
 	int port;
 	u8 *mxl862_tag;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0))
-	struct dsa_port *dp;
-#endif
 
 	if (unlikely(!pskb_may_pull(skb, MXL862_RX_HEADER_LEN))) {
 		dev_warn_ratelimited(&dev->dev,
@@ -142,11 +109,7 @@ static struct sk_buff *mxl862_tag_rcv(struct sk_buff *skb,
 	/* Get source port information */
 	port = (mxl862_tag[7] & MXL862_IGP_EGP_MASK) >> MXL862_IGP_EGP_SHIFT;
 	port = port - 1;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 7, 0))
-	skb->dev = dsa_master_find_slave(dev, 0, port);
-#else
 	skb->dev = dsa_conduit_find_user(dev, 0, port);
-#endif
 	if (!skb->dev) {
 		dev_warn_ratelimited(
 			&dev->dev,
@@ -164,44 +127,20 @@ static struct sk_buff *mxl862_tag_rcv(struct sk_buff *skb,
 	skb_pull_rcsum(skb, MXL862_RX_HEADER_LEN);
 	memmove(skb->data - ETH_HLEN,
 		skb->data - (ETH_HLEN + MXL862_RX_HEADER_LEN), 2 * ETH_ALEN);
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0))
-	dp = dsa_slave_to_port(skb->dev);
-	if (dp->bridge_dev)
-		skb->offload_fwd_mark = 1;
-#else
 	dsa_default_offload_fwd_mark(skb);
-#endif
 
 	return skb;
 }
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0))
-const struct dsa_device_ops mxl862_netdev_ops = {
-	.xmit = mxl862_tag_xmit,
-	.rcv = mxl862_tag_rcv,
-};
-#else
-
 static const struct dsa_device_ops mxl862_netdev_ops = {
 	.name = "mxl862",
 	.proto = DSA_TAG_PROTO_MXL862,
 	.xmit = mxl862_tag_xmit,
 	.rcv = mxl862_tag_rcv,
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 14, 0))
-	.overhead = MXL862_RX_HEADER_LEN,
-#else
 	.needed_headroom = MXL862_RX_HEADER_LEN,
-#endif
 };
 
 MODULE_LICENSE("GPL");
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0))
-MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_MXL862);
-#else
 MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_MXL862, MXL862_NAME);
-#endif
-
 module_dsa_tag_driver(mxl862_netdev_ops);
-#endif
 
-MODULE_LICENSE("GPL");
diff --git a/net/dsa/tag_mxl862xx_8021q.c b/net/dsa/tag_mxl862xx_8021q.c
index dbf48f9b409f..e6389c2a35ef 100644
--- a/net/dsa/tag_mxl862xx_8021q.c
+++ b/net/dsa/tag_mxl862xx_8021q.c
@@ -20,23 +20,9 @@
  *
  */
 
-#ifndef LINUX_VERSION_CODE
-#include <linux/version.h>
-#else
-#define KERNEL_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
-#endif
-
 #include <linux/dsa/8021q.h>
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(6, 1, 0))
 #include "tag_8021q.h"
-#endif
-#include <net/dsa.h>
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0))
-#include "dsa_priv.h"
-#else
 #include "tag.h"
-#endif
 
 
 #define MXL862_NAME	"mxl862xx"
@@ -53,58 +39,12 @@
 
 /* special tag in TX path header */
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION (5, 14, 0))
-static void dsa_8021q_rcv(struct sk_buff *skb, int *source_port, int *switch_id)
-{
-	u16 vid, tci;
-
-	skb_push_rcsum(skb, ETH_HLEN);
-	if (skb_vlan_tag_present(skb)) {
-		tci = skb_vlan_tag_get(skb);
-		__vlan_hwaccel_clear_tag(skb);
-	} else {
-		__skb_vlan_pop(skb, &tci);
-	}
-	skb_pull_rcsum(skb, ETH_HLEN);
-
-	vid = tci & VLAN_VID_MASK;
-
-	*source_port = dsa_8021q_rx_source_port(vid);
-	*switch_id = dsa_8021q_rx_switch_id(vid);
-	skb->priority = (tci & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;
-}
-
-/* If the ingress port offloads the bridge, we mark the frame as autonomously
- * forwarded by hardware, so the software bridge doesn't forward in twice, back
- * to us, because we already did. However, if we're in fallback mode and we do
- * software bridging, we are not offloading it, therefore the dp->bridge_dev
- * pointer is not populated, and flooding needs to be done by software (we are
- * effectively operating in standalone ports mode).
- */
-static inline void dsa_default_offload_fwd_mark(struct sk_buff *skb)
-{
-	struct dsa_port *dp = dsa_slave_to_port(skb->dev);
-
-	skb->offload_fwd_mark = !!(dp->bridge_dev);
-}
-#endif
-
 static struct sk_buff *mxl862_8021q_tag_xmit(struct sk_buff *skb,
 				      struct net_device *dev)
 {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 7, 0))
-	struct dsa_port *dp = dsa_slave_to_port(dev);
-#else
 	struct dsa_port *dp = dsa_user_to_port(dev);
-#endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 16, 0))
-	u16 tx_vid = dsa_8021q_tx_vid(dp->ds, dp->index);
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(5, 18, 0))
-	u16 tx_vid = dsa_tag_8021q_tx_vid(dp);
-#else
 	u16 tx_vid = dsa_tag_8021q_standalone_vid(dp);
-#endif
 	u16 queue_mapping = skb_get_queue_mapping(skb);
 	u8 pcp = netdev_txq_to_tc(dev, queue_mapping);
 
@@ -114,36 +54,20 @@ static struct sk_buff *mxl862_8021q_tag_xmit(struct sk_buff *skb,
 	return skb;
 }
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 0))
-static struct sk_buff *mxl862_8021q_tag_rcv(struct sk_buff *skb,
-				      struct net_device *dev,
-				      struct packet_type *pt)
-#else
 static struct sk_buff *mxl862_8021q_tag_rcv(struct sk_buff *skb,
 				      struct net_device *dev)
-#endif
 {
 	int src_port = -1;
 	int switch_id = -1;
 
 	/* removes Outer VLAN tag */
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 18, 0))
-	dsa_8021q_rcv(skb, &src_port, &switch_id);
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0))
-	dsa_8021q_rcv(skb, &src_port, &switch_id, NULL);
-#else
 	dsa_8021q_rcv(skb, &src_port, &switch_id, NULL, NULL);
-#endif
 	if (src_port == -1 || switch_id == -1) {
 		dev_warn_ratelimited(&dev->dev, "Dropping packet due to invalid outer 802.1Q tag: switch %d port %d\n", switch_id, src_port);
 		return NULL;
 	}
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 7, 0))
-	skb->dev = dsa_master_find_slave(dev, switch_id, src_port);
-#else
 	skb->dev = dsa_conduit_find_user(dev, switch_id, src_port);
-#endif
 	if (!skb->dev) {
 		dev_warn_ratelimited(&dev->dev, "Dropping packet due to invalid source port: %d\n", src_port);
 		return NULL;
@@ -159,25 +83,10 @@ static const struct dsa_device_ops mxl862_8021q_netdev_ops = {
 	.proto = DSA_TAG_PROTO_MXL862_8021Q,
 	.xmit = mxl862_8021q_tag_xmit,
 	.rcv = mxl862_8021q_tag_rcv,
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 14, 0))
-	.overhead = VLAN_HLEN,
-#else
 	.needed_headroom	= VLAN_HLEN,
-#endif
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 7, 0) && \
-	 LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 0))
-	.promisc_on_master	= true,
-#elif (LINUX_VERSION_CODE > KERNEL_VERSION(6, 7, 0))
 	.promisc_on_conduit = true,
-#endif
 };
 
-
 MODULE_LICENSE("GPL");
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0))
-MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_MXL862_8021Q);
-#else
 MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_MXL862_8021Q, MXL862_NAME);
-#endif
-
 module_dsa_tag_driver(mxl862_8021q_netdev_ops);
-- 
2.39.5

