From e277961af9c451d4794be84d3979e9c7ebbd587a Mon Sep 17 00:00:00 2001
From: leo <leo@localhost.localdomain>
Date: Mon, 7 Feb 2022 15:20:23 +0300
Subject: [PATCH 6/9] drv:net:rtl8723cs:hal: btc

---
 .../rtl8723cs/hal/btc/HalBtc8188c2Ant.c       | 1987 +++++++
 .../rtl8723cs/hal/btc/HalBtc8188c2Ant.h       |  149 +
 .../rtl8723cs/hal/btc/HalBtc8192d2Ant.c       | 1992 +++++++
 .../rtl8723cs/hal/btc/HalBtc8192d2Ant.h       |  170 +
 .../rtl8723cs/hal/btc/HalBtc8192e1Ant.c       | 3417 ++++++++++++
 .../rtl8723cs/hal/btc/HalBtc8192e1Ant.h       |  226 +
 .../rtl8723cs/hal/btc/HalBtc8192e2Ant.c       | 3949 +++++++++++++
 .../rtl8723cs/hal/btc/HalBtc8192e2Ant.h       |  190 +
 .../rtl8723cs/hal/btc/HalBtc8703b1Ant.c       | 4623 ++++++++++++++++
 .../rtl8723cs/hal/btc/HalBtc8703b1Ant.h       |  343 ++
 .../rtl8723cs/hal/btc/HalBtc8703b2Ant.c       | 4864 +++++++++++++++++
 .../rtl8723cs/hal/btc/HalBtc8703b2Ant.h       |  228 +
 .../rtl8723cs/hal/btc/HalBtc8723a1Ant.c       | 1544 ++++++
 .../rtl8723cs/hal/btc/HalBtc8723a1Ant.h       |  171 +
 .../rtl8723cs/hal/btc/HalBtc8723a2Ant.c       | 3746 +++++++++++++
 .../rtl8723cs/hal/btc/HalBtc8723a2Ant.h       |  184 +
 .../rtl8723cs/hal/btc/HalBtc8723b1Ant.c       | 4845 ++++++++++++++++
 .../rtl8723cs/hal/btc/HalBtc8723b1Ant.h       |  288 +
 .../rtl8723cs/hal/btc/HalBtc8723b2Ant.c       | 4829 ++++++++++++++++
 .../rtl8723cs/hal/btc/HalBtc8723b2Ant.h       |  214 +
 .../rtl8723cs/hal/btc/HalBtc8812a1Ant.c       | 3457 ++++++++++++
 .../rtl8723cs/hal/btc/HalBtc8812a1Ant.h       |  230 +
 .../rtl8723cs/hal/btc/HalBtc8812a2Ant.c       | 4782 ++++++++++++++++
 .../rtl8723cs/hal/btc/HalBtc8812a2Ant.h       |  202 +
 .../rtl8723cs/hal/btc/HalBtc8821a1Ant.c       | 3100 +++++++++++
 .../rtl8723cs/hal/btc/HalBtc8821a1Ant.h       |  197 +
 .../rtl8723cs/hal/btc/HalBtc8821a2Ant.c       | 4560 ++++++++++++++++
 .../rtl8723cs/hal/btc/HalBtc8821a2Ant.h       |  205 +
 .../rtl8723cs/hal/btc/HalBtc8821aCsr2Ant.c    | 3997 ++++++++++++++
 .../rtl8723cs/hal/btc/HalBtc8821aCsr2Ant.h    |  188 +
 .../realtek/rtl8723cs/hal/btc/HalBtcOutSrc.h  |  900 +++
 .../realtek/rtl8723cs/hal/btc/Mp_Precomp.h    |   98 +
 32 files changed, 59875 insertions(+)
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8188c2Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8188c2Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192d2Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192d2Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e1Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e1Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e2Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e2Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b1Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b1Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b2Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b2Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a1Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a1Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a2Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a2Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b1Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b1Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b2Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b2Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a1Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a1Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a2Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a2Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a1Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a1Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a2Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a2Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821aCsr2Ant.c
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821aCsr2Ant.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtcOutSrc.h
 create mode 100644 drivers/net/wireless/realtek/rtl8723cs/hal/btc/Mp_Precomp.h

diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8188c2Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8188c2Ant.c
new file mode 100644
index 000000000..59c2d4c7b
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8188c2Ant.c
@@ -0,0 +1,1987 @@
+//============================================================
+// Description:
+//
+// This file is for 92CE/92CU BT 1 Antenna Co-exist mechanism
+//
+// By cosa 02/11/2011
+//
+//============================================================
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+
+#if WPP_SOFTWARE_TRACE
+#include "HalBtc8188c2Ant.tmh"
+#endif
+
+#if(BT_30_SUPPORT == 1)
+//============================================================
+// Global variables, these are static variables
+//============================================================
+static COEX_DM_8188C_2ANT	GLCoexDm8188c2Ant;
+static PCOEX_DM_8188C_2ANT 	pCoexDm=&GLCoexDm8188c2Ant;
+static COEX_STA_8188C_2ANT	GLCoexSta8188c2Ant;
+static PCOEX_STA_8188C_2ANT	pCoexSta=&GLCoexSta8188c2Ant;
+
+//============================================================
+// local function start with btdm_
+//============================================================
+u1Byte
+halbtc8188c2ant_WifiRssiState(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			index,
+	IN	u1Byte			levelNum,
+	IN	u1Byte			rssiThresh,
+	IN	u1Byte			rssiThresh1
+	)
+{
+	s4Byte			wifiRssi=0;
+	u1Byte			wifiRssiState=pCoexSta->preWifiRssiState[index];
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
+	
+	if(levelNum == 2)
+	{
+		if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(wifiRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8188C_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_HIGH;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_LOW;
+			}
+		}
+		else
+		{
+			if(wifiRssi < rssiThresh)
+			{
+				wifiRssiState = BTC_RSSI_STATE_LOW;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_HIGH;
+			}
+		}
+	}
+	else if(levelNum == 3)
+	{
+		if(rssiThresh > rssiThresh1)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], wifi RSSI thresh error!!\n"));
+			return pCoexSta->preWifiRssiState[index];
+		}
+		
+		if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(wifiRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8188C_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_MEDIUM;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_LOW;
+			}
+		}
+		else if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_MEDIUM) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_MEDIUM))
+		{
+			if(wifiRssi >= (rssiThresh1+BTC_RSSI_COEX_THRESH_TOL_8188C_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_HIGH;
+			}
+			else if(wifiRssi < rssiThresh)
+			{
+				wifiRssiState = BTC_RSSI_STATE_LOW;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_MEDIUM;
+			}
+		}
+		else
+		{
+			if(wifiRssi < rssiThresh1)
+			{
+				wifiRssiState = BTC_RSSI_STATE_MEDIUM;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_HIGH;
+			}
+		}
+	}
+		
+	pCoexSta->preWifiRssiState[index] = wifiRssiState;
+
+	return wifiRssiState;
+}
+
+u1Byte
+halbtc8188c2ant_ActionAlgorithm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	u1Byte				algorithm=BT_8188C_2ANT_COEX_ALGO_UNDEFINED;
+	u1Byte				numOfDiffProfile=0;
+	
+	if(!pStackInfo->bBtLinkExist)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], No profile exists!!!\n"));
+		return algorithm;
+	}
+
+	if(pStackInfo->bScoExist)
+		numOfDiffProfile++;
+	if(pStackInfo->bHidExist)
+		numOfDiffProfile++;
+	if(pStackInfo->bPanExist)
+		numOfDiffProfile++;
+	if(pStackInfo->bA2dpExist)
+		numOfDiffProfile++;
+
+	if(pStackInfo->bScoExist)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO algorithm\n"));
+		algorithm = BT_8188C_2ANT_COEX_ALGO_SCO;
+	}
+	else
+	{
+		if(numOfDiffProfile == 1)
+		{
+			if(pStackInfo->bHidExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID only\n"));
+				algorithm = BT_8188C_2ANT_COEX_ALGO_HID;
+			}
+			else if(pStackInfo->bA2dpExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], A2DP only\n"));
+				algorithm = BT_8188C_2ANT_COEX_ALGO_A2DP;
+			}
+			else if(pStackInfo->bPanExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN only\n"));
+				algorithm = BT_8188C_2ANT_COEX_ALGO_PAN;
+			}
+		}
+		else
+		{
+			if( pStackInfo->bHidExist &&
+				pStackInfo->bA2dpExist )
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + A2DP\n"));
+				algorithm = BT_8188C_2ANT_COEX_ALGO_HID_A2DP;
+			}
+			else if( pStackInfo->bHidExist &&
+				pStackInfo->bPanExist )
+			{				
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + PAN\n"));
+				algorithm = BT_8188C_2ANT_COEX_ALGO_HID_PAN;
+			}
+			else if( pStackInfo->bPanExist &&
+				pStackInfo->bA2dpExist )
+			{				
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN + A2DP\n"));
+				algorithm = BT_8188C_2ANT_COEX_ALGO_PAN_A2DP;
+			}
+		}		
+	}
+	return algorithm;
+}
+
+VOID
+halbtc8188c2ant_SetFwBalance(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bBalanceOn,
+	IN	u1Byte			ms0,
+	IN	u1Byte			ms1
+	)
+{
+	u1Byte	H2C_Parameter[3] ={0};
+
+	if(bBalanceOn)
+	{
+		H2C_Parameter[2] = 1;
+		H2C_Parameter[1] = ms1;
+		H2C_Parameter[0] = ms0;
+	}
+	else
+	{
+		H2C_Parameter[2] = 0;
+		H2C_Parameter[1] = 0;
+		H2C_Parameter[0] = 0;
+	}
+	
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Balance=[%s:%dms:%dms], write 0xc=0x%x\n", 
+		bBalanceOn?"ON":"OFF", ms0, ms1,
+		H2C_Parameter[0]<<16|H2C_Parameter[1]<<8|H2C_Parameter[2]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0xc, 3, H2C_Parameter);	
+}
+
+VOID
+halbtc8188c2ant_Balance(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bBalanceOn,
+	IN	u1Byte			ms0,
+	IN	u1Byte			ms1
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn Balance %s\n", 
+		(bForceExec? "force to":""), (bBalanceOn? "ON":"OFF")));
+	pCoexDm->bCurBalanceOn = bBalanceOn;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreBalanceOn == pCoexDm->bCurBalanceOn)
+			return;
+	}
+	halbtc8188c2ant_SetFwBalance(pBtCoexist, bBalanceOn, ms0, ms1);
+
+	pCoexDm->bPreBalanceOn = pCoexDm->bCurBalanceOn;
+}
+
+VOID
+halbtc8188c2ant_SetFwDiminishWifi(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN 		bDacOn,
+	IN	BOOLEAN 		bInterruptOn,
+	IN	u1Byte			fwDacSwingLvl,
+	IN	BOOLEAN 		bNavOn
+	)
+{
+	u1Byte			H2C_Parameter[3] ={0};
+
+	if((pBtCoexist->stackInfo.minBtRssi <= -5) && (fwDacSwingLvl == 0x20))
+	{
+		RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], DiminishWiFi 0x20 original, but set 0x18 for Low RSSI!\n"));
+		fwDacSwingLvl = 0x18;
+	}
+
+	H2C_Parameter[2] = 0;
+	H2C_Parameter[1] = fwDacSwingLvl;
+	H2C_Parameter[0] = 0;
+	if(bDacOn)
+	{
+		H2C_Parameter[2] |= 0x01;	//BIT0
+		if(bInterruptOn)
+		{
+			H2C_Parameter[2] |= 0x02;	//BIT1
+		}
+	}
+	if(bNavOn)
+	{
+		H2C_Parameter[2] |= 0x08;	//BIT3
+	}
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], bDacOn=%s, bInterruptOn=%s, bNavOn=%s, write 0xe=0x%x\n", 
+		(bDacOn?"ON":"OFF"), (bInterruptOn?"ON":"OFF"), (bNavOn?"ON":"OFF"),
+		(H2C_Parameter[0]<<16|H2C_Parameter[1]<<8|H2C_Parameter[2])));
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0xe, 3, H2C_Parameter);
+}
+
+VOID
+halbtc8188c2ant_DiminishWifi(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bDacOn,
+	IN	BOOLEAN			bInterruptOn,
+	IN	u1Byte			fwDacSwingLvl,
+	IN	BOOLEAN			bNavOn
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s set Diminish Wifi, bDacOn=%s, bInterruptOn=%s, fwDacSwingLvl=%d, bNavOn=%s\n", 
+		(bForceExec? "force to":""), (bDacOn? "ON":"OFF"), (bInterruptOn? "ON":"OFF"), fwDacSwingLvl, (bNavOn? "ON":"OFF")));
+
+	pCoexDm->bCurDacOn = bDacOn;
+	pCoexDm->bCurInterruptOn = bInterruptOn;
+	pCoexDm->curFwDacSwingLvl = fwDacSwingLvl;
+	pCoexDm->bCurNavOn = bNavOn;
+
+	if(!bForceExec)
+	{
+		if( (pCoexDm->bPreDacOn==pCoexDm->bCurDacOn) &&
+			(pCoexDm->bPreInterruptOn==pCoexDm->bCurInterruptOn) &&
+			(pCoexDm->preFwDacSwingLvl==pCoexDm->curFwDacSwingLvl) &&
+			(pCoexDm->bPreNavOn==pCoexDm->bCurNavOn) )
+			return;
+	}
+	halbtc8188c2ant_SetFwDiminishWifi(pBtCoexist, bDacOn, bInterruptOn, fwDacSwingLvl, bNavOn);
+
+	pCoexDm->bPreDacOn = pCoexDm->bCurDacOn;
+	pCoexDm->bPreInterruptOn = pCoexDm->bCurInterruptOn;
+	pCoexDm->preFwDacSwingLvl = pCoexDm->curFwDacSwingLvl;
+	pCoexDm->bPreNavOn = pCoexDm->bCurNavOn;
+}
+
+VOID
+halbtc8188c2ant_SetSwRfRxLpfCorner(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bRxRfShrinkOn
+	)
+{
+	if(bRxRfShrinkOn)
+	{
+		//Shrink RF Rx LPF corner
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Shrink RF Rx LPF corner!!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xf0, 0xf);		
+	}
+	else
+	{
+		//Resume RF Rx LPF corner
+		// After initialized, we can use pCoexDm->btRf0x1eBackup
+		if(pBtCoexist->bInitilized)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Resume RF Rx LPF corner!!\n"));
+			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xf0, pCoexDm->btRf0x1eBackup);
+		}
+	}
+}
+
+VOID
+halbtc8188c2ant_RfShrink(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bRxRfShrinkOn
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn Rx RF Shrink = %s\n",  
+		(bForceExec? "force to":""), ((bRxRfShrinkOn)? "ON":"OFF")));
+	pCoexDm->bCurRfRxLpfShrink = bRxRfShrinkOn;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreRfRxLpfShrink == pCoexDm->bCurRfRxLpfShrink) 
+			return;
+	}
+	halbtc8188c2ant_SetSwRfRxLpfCorner(pBtCoexist, pCoexDm->bCurRfRxLpfShrink);
+
+	pCoexDm->bPreRfRxLpfShrink = pCoexDm->bCurRfRxLpfShrink;
+}
+
+VOID
+halbtc8188c2ant_SetSwPenaltyTxRateAdaptive(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bLowPenaltyRa
+	)
+{
+	u1Byte	tmpU1;
+
+	tmpU1 = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x4fd);
+	if(bLowPenaltyRa)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Tx rate adaptive, set low penalty!!\n"));
+		tmpU1 &= ~BIT2;
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Tx rate adaptive, set normal!!\n"));
+		tmpU1 |= BIT2;
+	}
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x4fd, tmpU1);
+}
+
+VOID
+halbtc8188c2ant_LowPenaltyRa(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bLowPenaltyRa
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn LowPenaltyRA = %s\n",  
+		(bForceExec? "force to":""), ((bLowPenaltyRa)? "ON":"OFF")));
+	pCoexDm->bCurLowPenaltyRa = bLowPenaltyRa;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreLowPenaltyRa == pCoexDm->bCurLowPenaltyRa) 
+			return;
+	}
+	halbtc8188c2ant_SetSwPenaltyTxRateAdaptive(pBtCoexist, pCoexDm->bCurLowPenaltyRa);
+
+	pCoexDm->bPreLowPenaltyRa = pCoexDm->bCurLowPenaltyRa;
+}
+
+VOID
+halbtc8188c2ant_SetSwFullTimeDacSwing(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bSwDacSwingOn,
+	IN	u4Byte			swDacSwingLvl
+	)
+{
+	u4Byte	dacSwingLvl;
+
+	if(bSwDacSwingOn)
+	{		
+		if((pBtCoexist->stackInfo.minBtRssi <= -5) && (swDacSwingLvl == 0x20))
+		{
+			dacSwingLvl = 0x18;
+		}
+		else
+		{
+			dacSwingLvl = swDacSwingLvl;
+		}
+		pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x880, 0xfc000000, dacSwingLvl);
+	}
+	else
+	{
+		pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x880, 0xfc000000, 0x30);
+	}
+}
+
+VOID
+halbtc8188c2ant_DacSwing(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bDacSwingOn,
+	IN	u4Byte			dacSwingLvl
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn DacSwing=%s, dacSwingLvl=0x%x\n",  
+		(bForceExec? "force to":""), ((bDacSwingOn)? "ON":"OFF"), dacSwingLvl));
+	pCoexDm->bCurDacSwingOn = bDacSwingOn;
+	pCoexDm->curDacSwingLvl = dacSwingLvl;
+
+	if(!bForceExec)
+	{
+		if( (pCoexDm->bPreDacSwingOn == pCoexDm->bCurDacSwingOn) &&
+			(pCoexDm->preDacSwingLvl == pCoexDm->curDacSwingLvl) )
+			return;
+	}
+	delay_ms(30);
+	halbtc8188c2ant_SetSwFullTimeDacSwing(pBtCoexist, bDacSwingOn, dacSwingLvl);
+
+	pCoexDm->bPreDacSwingOn = pCoexDm->bCurDacSwingOn;
+	pCoexDm->preDacSwingLvl = pCoexDm->curDacSwingLvl;
+}
+
+VOID
+halbtc8188c2ant_SetAdcBackOff(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bAdcBackOff
+	)
+{
+	if(bAdcBackOff)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BB BackOff Level On!\n"));
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc04,0x3a07611);
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BB BackOff Level Off!\n"));		
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc04,0x3a05611);
+	}
+}
+
+VOID
+halbtc8188c2ant_AdcBackOff(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bAdcBackOff
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn AdcBackOff = %s\n",  
+		(bForceExec? "force to":""), ((bAdcBackOff)? "ON":"OFF")));
+	pCoexDm->bCurAdcBackOff = bAdcBackOff;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreAdcBackOff == pCoexDm->bCurAdcBackOff) 
+			return;
+	}
+	halbtc8188c2ant_SetAdcBackOff(pBtCoexist, pCoexDm->bCurAdcBackOff);
+
+	pCoexDm->bPreAdcBackOff = pCoexDm->bCurAdcBackOff;
+}
+
+VOID
+halbtc8188c2ant_SetAgcTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bAgcTableEn
+	)
+{
+	u1Byte		rssiAdjustVal=0;
+
+	if(bAgcTableEn)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Agc Table On!\n"));
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x4e1c0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x4d1d0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x4c1e0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x4b1f0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x4a200001);
+
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0xdc000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0x90000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0x51000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0x12000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1a, 0xfffff, 0x00255);
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Agc Table Off!\n"));
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x641c0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x631d0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x621e0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x611f0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x60200001);
+
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0x32000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0x71000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0xb0000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0xfc000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1a, 0xfffff, 0x10255);
+	}
+
+	// set rssiAdjustVal for wifi module.
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON, &rssiAdjustVal);
+}
+
+
+VOID
+halbtc8188c2ant_AgcTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bAgcTableEn
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s %s Agc Table\n",  
+		(bForceExec? "force to":""), ((bAgcTableEn)? "Enable":"Disable")));
+	pCoexDm->bCurAgcTableEn = bAgcTableEn;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreAgcTableEn == pCoexDm->bCurAgcTableEn) 
+			return;
+	}
+	halbtc8188c2ant_SetAgcTable(pBtCoexist, bAgcTableEn);
+
+	pCoexDm->bPreAgcTableEn = pCoexDm->bCurAgcTableEn;
+}
+
+VOID
+halbtc8188c2ant_SetCoexTable(
+	IN	PBTC_COEXIST	pBtCoexist,
+	IN	u4Byte		val0x6c4,
+	IN	u4Byte		val0x6c8,
+	IN	u4Byte		val0x6cc
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], set coex table, set 0x6c4=0x%x\n", val0x6c4));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c4, val0x6c4);
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], set coex table, set 0x6c8=0x%x\n", val0x6c8));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c8, val0x6c8);
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], set coex table, set 0x6cc=0x%x\n", val0x6cc));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6cc, val0x6cc);
+}
+
+VOID
+halbtc8188c2ant_CoexTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	u4Byte			val0x6c4,
+	IN	u4Byte			val0x6c8,
+	IN	u4Byte			val0x6cc
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s write Coex Table 0x6c4=0x%x, 0x6c8=0x%x, 0x6cc=0x%x\n", 
+		(bForceExec? "force to":""), val0x6c4, val0x6c8, val0x6cc));
+	pCoexDm->curVal0x6c4 = val0x6c4;
+	pCoexDm->curVal0x6c8 = val0x6c8;
+	pCoexDm->curVal0x6cc = val0x6cc;
+
+	if(!bForceExec)
+	{	
+		if( (pCoexDm->preVal0x6c4 == pCoexDm->curVal0x6c4) &&
+			(pCoexDm->preVal0x6c8 == pCoexDm->curVal0x6c8) &&
+			(pCoexDm->preVal0x6cc == pCoexDm->curVal0x6cc) )
+			return;
+	}
+	halbtc8188c2ant_SetCoexTable(pBtCoexist, val0x6c4, val0x6c8, val0x6cc);
+
+	pCoexDm->preVal0x6c4 = pCoexDm->curVal0x6c4;
+	pCoexDm->preVal0x6c8 = pCoexDm->curVal0x6c8;
+	pCoexDm->preVal0x6cc = pCoexDm->curVal0x6cc;
+}
+
+VOID
+halbtc8188c2ant_CoexAllOff(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	// fw mechanism
+	halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+	halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+	// sw mechanism
+	halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+}
+VOID
+halbtc8188c2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+}
+
+
+VOID
+halbtc8188c2ant_MonitorBtState(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	BOOLEAN			stateChange=FALSE;
+	u4Byte 			BT_Polling, Ratio_Act, Ratio_STA;
+	u4Byte 			BT_Active, BT_State;
+	u4Byte			regBTActive=0, regBTState=0, regBTPolling=0;
+	u4Byte			btBusyThresh=0;
+	u4Byte			fwVer=0;
+	static BOOLEAN	bBtBusyTraffic=FALSE;
+	BOOLEAN			bRejApAggPkt=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_FW_VER, &fwVer);
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], FirmwareVersion = 0x%x(%d)\n", fwVer, fwVer));
+	if(fwVer < 62)
+	{
+		regBTActive = 0x488;
+		regBTState = 0x48c;
+		regBTPolling = 0x490;
+	}
+	else
+	{
+		regBTActive = 0x444;
+		regBTState = 0x448;
+		if(fwVer >= 74)
+			regBTPolling = 0x44c;
+		else
+			regBTPolling = 0x700;
+	}
+	btBusyThresh = 60;
+	
+	BT_Active = pBtCoexist->fBtcRead4Byte(pBtCoexist, regBTActive);
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT_Active(0x%x)=0x%x\n", regBTActive, BT_Active));
+	BT_Active = BT_Active & 0x00ffffff;
+
+	BT_State = pBtCoexist->fBtcRead4Byte(pBtCoexist, regBTState);
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT_State(0x%x)=0x%x\n", regBTState, BT_State));
+	BT_State = BT_State & 0x00ffffff;
+
+	BT_Polling = pBtCoexist->fBtcRead4Byte(pBtCoexist, regBTPolling);
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT_Polling(0x%x)=0x%x\n", regBTPolling, BT_Polling));
+
+	if(BT_Active==0xffffffff && BT_State==0xffffffff && BT_Polling==0xffffffff )
+		return;
+
+	// 2011/05/04 MH For Slim combo test meet a problem. Surprise remove and WLAN is running
+	// DHCP process. At the same time, the register read value might be zero. And cause BSOD 0x7f
+	// EXCEPTION_DIVIDED_BY_ZERO. In This case, the stack content may always be wrong due to 
+	// HW divide trap.
+	if (BT_Polling==0)
+		return;
+	
+	Ratio_Act = BT_Active*1000/BT_Polling;
+	Ratio_STA = BT_State*1000/BT_Polling;
+		
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Ratio_Act=%d\n", Ratio_Act));
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Ratio_STA=%d\n", Ratio_STA));
+
+	if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+	{
+		if(Ratio_STA < 60)	// BT PAN idle
+		{
+		}
+		else
+		{
+			// Check if BT PAN (under BT 2.1) is uplink or downlink
+			if((Ratio_Act/Ratio_STA) < 2)
+			{	// BT PAN Uplink
+				pCoexSta->bBtUplink = TRUE;
+			}
+			else
+			{	// BT PAN downlink
+				pCoexSta->bBtUplink = FALSE;
+			}
+		}
+	}	
+	
+	// Check BT is idle or not
+	if(!pBtCoexist->stackInfo.bBtLinkExist)
+	{
+		pCoexSta->bBtBusy = FALSE;
+	}
+	else
+	{
+		if(BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType)
+		{
+			if(Ratio_Act<20)
+			{
+				pCoexSta->bBtBusy = FALSE;
+			}
+			else
+			{
+				pCoexSta->bBtBusy = TRUE;
+			}
+		}
+		else if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+		{
+			if(Ratio_STA < btBusyThresh)
+			{
+				pCoexSta->bBtBusy = FALSE;
+			}
+			else
+			{
+				pCoexSta->bBtBusy = TRUE;
+			}
+
+			if( (Ratio_STA < btBusyThresh) ||
+				(Ratio_Act<180 && Ratio_STA<130) )
+			{
+				pCoexSta->bA2dpBusy = FALSE;
+			}
+			else
+			{
+				pCoexSta->bA2dpBusy = TRUE;
+			}
+		}
+	}
+
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &pCoexSta->bBtBusy);
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_LIMITED_DIG, &pCoexSta->bBtBusy);
+	
+	if(bBtBusyTraffic != pCoexSta->bBtBusy)
+	{	// BT idle or BT non-idle
+		bBtBusyTraffic = pCoexSta->bBtBusy;
+		stateChange = TRUE;
+	}
+
+	if(stateChange)
+	{
+		if(!pCoexSta->bBtBusy)
+		{
+			halbtc8188c2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_RfShrink(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_CoexAllOff(pBtCoexist);
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+		}
+		else
+		{
+			halbtc8188c2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8188c2ant_RfShrink(pBtCoexist, NORMAL_EXEC, TRUE);
+		}
+	}
+
+	if(stateChange)
+	{
+		bRejApAggPkt = pCoexSta->bBtBusy;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT, &bRejApAggPkt);
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+	}
+}
+
+VOID
+halbtc8188c2ant_ActionA2dpBc4(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte			wifiRssiState;
+	u4Byte			wifiBw, wifiTrafficDir;
+
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+	
+	if(pCoexSta->bBtBusy)
+	{
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+		{
+			// fw mechanism first
+			if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0xc, 0x18);
+				halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x20, FALSE);
+			}
+			else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+				halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+			}
+
+			// sw mechanism 
+			halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x20);
+		}
+		else
+		{
+			wifiRssiState = halbtc8188c2ant_WifiRssiState(pBtCoexist, 0, 2, 47, 0);
+
+			if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0xc, 0x18);
+				halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x20, FALSE);
+			}
+			else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+				halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+			}
+
+			// sw mechanism 
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x20);
+			}
+			else
+			{
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x20);
+			}
+		}
+	}
+	else
+	{
+		halbtc8188c2ant_CoexAllOff(pBtCoexist);
+	}
+}
+
+VOID
+halbtc8188c2ant_ActionA2dpBc8(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte			wifiRssiState;
+	u4Byte			wifiBw, wifiTrafficDir;
+	BOOLEAN			bWifiBusy=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	if(pCoexSta->bA2dpBusy && bWifiBusy)
+	{
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+		wifiRssiState = halbtc8188c2ant_WifiRssiState(pBtCoexist, 0, 2, 47, 0);
+
+		// fw mechanism first
+		if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+		{
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0xc, 0x18);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+		}
+		else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+		{
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x10, 0x18);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+		}
+
+		// sw mechanism 
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+		{
+			halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+		}
+		else
+		{
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+			else
+			{
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+		}
+	}
+	else if(pCoexSta->bA2dpBusy)
+	{
+		// fw mechanism first
+		halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+		halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, TRUE, 0x18, FALSE);
+
+		// sw mechanism 
+		halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+	}
+	else
+	{
+		halbtc8188c2ant_CoexAllOff(pBtCoexist);
+	}
+}
+
+VOID
+halbtc8188c2ant_ActionA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	if(BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8188c2ant_ActionA2dpBc4(pBtCoexist);
+	}
+	else if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8188c2ant_ActionA2dpBc8(pBtCoexist);
+	}
+}
+
+VOID
+halbtc8188c2ant_ActionPanBc4(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bBtHsOn=FALSE, bWifiBusy=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+	if(bBtHsOn)
+	{
+		halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+		halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+	}
+	else
+	{
+		if(pCoexSta->bBtBusy && bWifiBusy)
+		{
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x20, 0x10);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+		}
+		else
+		{
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+		}
+	}
+	// sw mechanism
+	halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+}
+
+VOID
+halbtc8188c2ant_ActionPanBc8(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bBtHsOn=FALSE, bWifiBusy=FALSE;
+	u1Byte		wifiRssiState;
+	u4Byte		wifiBw, wifiTrafficDir;
+	s4Byte		wifiRssi;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
+	
+	if(bBtHsOn)
+	{
+		halbtc8188c2ant_CoexAllOff(pBtCoexist);
+	}
+	else
+	{
+		wifiRssiState = halbtc8188c2ant_WifiRssiState(pBtCoexist, 0, 3, 25, 50);
+
+		if(pCoexSta->bBtBusy && bWifiBusy)
+		{
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				// fw mechanism first
+				if(pCoexSta->bBtUplink)
+				{
+					halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x20, 0x20);
+					halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+				}
+				else
+				{
+					halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+					halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+				}
+				// sw mechanism 
+				if(BTC_WIFI_BW_HT40 == wifiBw)
+				{
+					halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				}
+				else
+				{
+					halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+				}
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+				if(pCoexSta->bBtUplink)
+				{
+					halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+				}
+				else
+				{
+					halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x20);
+				}
+			}
+			else if( (wifiRssiState == BTC_RSSI_STATE_MEDIUM) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_MEDIUM) )
+			{
+				// fw mechanism first
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x20, 0x20);
+
+				if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+				{
+					halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+				}
+				else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+				{
+					if(BTC_WIFI_BW_HT40 == wifiBw)
+						halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);//BT_FW_NAV_ON);
+					else
+						halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+				}
+				// sw mechanism 
+				if(BTC_WIFI_BW_HT40 == wifiBw)
+				{
+					halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				}
+				else
+				{
+					halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+				}
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+			else
+			{
+				// fw mechanism first
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x20, 0x20);
+				
+				if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+				{
+					halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+				}
+				else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+				{
+					if(pCoexSta->bBtUplink)
+					{
+						if(BTC_WIFI_BW_HT40 == wifiBw)
+						{
+							halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);//BT_FW_NAV_ON);
+						}
+						else
+						{
+							halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+						}						
+					}
+					else
+					{
+						halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+					}
+				}
+				// sw mechanism 
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+		}
+		else if(pCoexSta->bBtBusy && !bWifiBusy && (wifiRssi < 30))
+		{
+			// fw mechanism first
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x0a, 0x20);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+			// sw mechanism 
+			halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+		}
+		else
+		{
+			halbtc8188c2ant_CoexAllOff(pBtCoexist);
+		}
+	}
+}
+
+VOID
+halbtc8188c2ant_ActionPan(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	if(BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8188c2ant_ActionPanBc4(pBtCoexist);
+	}
+	else if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8188c2ant_ActionPanBc8(pBtCoexist);
+	}
+}
+
+VOID
+halbtc8188c2ant_ActionHid(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u4Byte		wifiBw, wifiTrafficDir;
+	BOOLEAN 	bWifiBusy=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+	if(BTC_WIFI_BW_LEGACY == wifiBw)
+	{
+		halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+		halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+
+		halbtc8188c2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0x000000f0, 0x40000010);
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0xa0);
+	}
+	else if(!bWifiBusy)
+	{
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+		halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+		halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+	}
+	else if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+	{
+		halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+		halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+
+		halbtc8188c2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0x000000f0, 0x40000010);
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0xa0);
+	}
+	else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+	{
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+		halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+		halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+	}
+	// sw mechanism
+	halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+}
+
+
+VOID
+halbtc8188c2ant_ActionSco(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte	wifiRssiState;
+	u4Byte	wifiBw;
+
+	if(BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType)
+	{
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+		
+		// fw mechanism
+		halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+		halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+
+		// sw mechanism
+		halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+	}
+	else if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+	{
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+		{
+			// fw mechanism first
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+			// sw mechanism 
+			halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+		}
+		else
+		{
+			wifiRssiState = halbtc8188c2ant_WifiRssiState(pBtCoexist, 0, 2, 47, 0);
+			// fw mechanism first
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+			// sw mechanism 
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+			else
+			{			
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);	
+			}
+		}
+	}
+}
+
+VOID
+halbtc8188c2ant_ActionHidA2dpBc4(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState;
+	u4Byte		wifiBw, wifiTrafficDir;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+
+	if(pCoexSta->bBtBusy)
+	{
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+		{
+			// fw mechanism first
+			if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x7, 0x20);
+				halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x20, FALSE);
+			}
+			else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+				halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+			}
+
+			// sw mechanism 
+			halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+		}
+		else
+		{
+			wifiRssiState = halbtc8188c2ant_WifiRssiState(pBtCoexist, 0, 2, 47, 0);
+			// fw mechanism first
+			if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x7, 0x20);
+				halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x20, FALSE);
+			}
+			else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+				halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+			}
+
+			// sw mechanism 
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+			}
+			else
+			{
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+			}
+		}
+	}
+	else
+	{
+		halbtc8188c2ant_CoexAllOff(pBtCoexist);
+	}
+}
+VOID
+halbtc8188c2ant_ActionHidA2dpBc8(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState;
+	u4Byte		wifiBw;
+	
+	if(pCoexSta->bBtBusy)
+	{
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+		{
+			// fw mechanism first
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+			// sw mechanism 
+			halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+		}
+		else
+		{
+			wifiRssiState = halbtc8188c2ant_WifiRssiState(pBtCoexist, 0, 2, 47, 0);
+			// fw mechanism
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+			// sw mechanism 
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+			}
+			else
+			{
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+			}
+		}
+	}
+	else
+	{
+		halbtc8188c2ant_CoexAllOff(pBtCoexist);
+	}
+}
+
+VOID
+halbtc8188c2ant_ActionHidA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	if(BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8188c2ant_ActionHidA2dpBc4(pBtCoexist);
+	}
+	else if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8188c2ant_ActionHidA2dpBc8(pBtCoexist);
+	}
+}
+
+VOID
+halbtc8188c2ant_ActionHidPanBc4(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bBtHsOn=FALSE, bWifiBusy=FALSE;
+	u4Byte		wifiBw, wifiTrafficDir;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+	
+	if(bBtHsOn)
+	{	
+		halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+		halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+
+		halbtc8188c2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0x000000f0, 0x40000010);
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0xa0);
+	}
+	else
+	{
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+		if(BTC_WIFI_BW_LEGACY == wifiBw)
+		{
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+
+			halbtc8188c2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0x000000f0, 0x40000010);
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0xa0);
+		}
+		else if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+		{
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+			
+			halbtc8188c2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0x000000f0, 0x40000010);
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0xa0);
+		}
+		else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+		{
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x20, 0x10);					
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+		}
+		else if(!bWifiBusy)
+		{
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+		}			
+	}
+	halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+}
+VOID
+halbtc8188c2ant_ActionHidPanBc8(	
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bBtHsOn=FALSE, bWifiBusy=FALSE;
+	u1Byte		wifiRssiState;
+	u4Byte		wifiBw, wifiTrafficDir;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+
+	if(!bBtHsOn)
+	{
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+		wifiRssiState = halbtc8188c2ant_WifiRssiState(pBtCoexist, 0, 2, 25, 0);
+		if((pCoexSta->bBtBusy && bWifiBusy))
+		{
+			// fw mechanism first
+			if(pCoexSta->bBtUplink)
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x15, 0x20);
+			}
+			else
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x10, 0x20);
+			}
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+
+			// sw mechanism 
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+				if(BTC_WIFI_BW_HT40 == wifiBw)
+				{
+					halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+					halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+					halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+				}
+				else
+				{
+					halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+					halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+					halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+				}
+			}
+			else
+			{
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+		}
+		else
+		{
+			halbtc8188c2ant_CoexAllOff(pBtCoexist);
+		}
+	}
+	else
+	{
+		if(BTC_INTF_USB == pBtCoexist->chipInterface)
+		{	
+			pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+			if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+				halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+
+				halbtc8188c2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0x000000f0, 0x40000010);
+				pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0xa0);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+			}
+			else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+			{
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+			}
+		}
+		else 
+		{
+			if(pCoexSta->bBtBusy)
+			{
+				// fw mechanism
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+				halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+				// sw mechanism
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x20);
+			}
+			else
+			{
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+		}
+	}
+}
+
+VOID
+halbtc8188c2ant_ActionHidPan(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{		
+	if(BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8188c2ant_ActionHidPanBc4(pBtCoexist);
+	}
+	else if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8188c2ant_ActionHidPanBc8(pBtCoexist);
+	}
+}
+
+VOID
+halbtc8188c2ant_ActionPanA2dpBc4(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bBtHsOn=FALSE, bWifiBusy=FALSE;
+	u1Byte		wifiRssiState;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+	if(bBtHsOn)
+	{
+		if(pCoexSta->bBtBusy)
+		{
+			// fw mechanism
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+			// sw mechanism
+			halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x20);
+		}
+		else
+		{
+			halbtc8188c2ant_CoexAllOff(pBtCoexist);
+		}
+	}
+	else
+	{
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+		if(pCoexSta->bBtBusy && bWifiBusy)
+		{
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x20, 0x10);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+		}
+		else
+		{
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+		}			
+		// sw mechanism
+		halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+	}
+}
+VOID
+halbtc8188c2ant_ActionPanA2dpBc8(	
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bBtHsOn=FALSE, bWifiBusy=FALSE;
+	u1Byte		wifiRssiState;
+	u4Byte		wifiBw;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+
+	if(!bBtHsOn)
+	{
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+		wifiRssiState = halbtc8188c2ant_WifiRssiState(pBtCoexist, 0, 2, 25, 0);
+		if((pCoexSta->bBtBusy && bWifiBusy))
+		{
+			// fw mechanism first
+			if(pCoexSta->bBtUplink)
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x15, 0x20);
+			}
+			else
+			{
+				halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x10, 0x20);
+			}
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+
+			// sw mechanism 
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+				if(BTC_WIFI_BW_HT40 == wifiBw)
+				{
+					halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+					halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+					halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+				}
+				else	
+				{
+					halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+					halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+					halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+				}
+			}
+			else
+			{
+				halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+		}
+		else
+		{
+			halbtc8188c2ant_CoexAllOff(pBtCoexist);
+		}
+	}
+	else
+	{
+		if(pCoexSta->bBtBusy)
+		{
+			// fw mechanism
+			halbtc8188c2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8188c2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+			// sw mechanism			
+			halbtc8188c2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x20);
+		}
+		else
+		{
+			halbtc8188c2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+		}
+	}
+}
+
+VOID
+halbtc8188c2ant_ActionPanA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	if(BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8188c2ant_ActionPanA2dpBc4(pBtCoexist);
+	}
+	else if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8188c2ant_ActionPanA2dpBc8(pBtCoexist);
+	}
+}
+
+//============================================================
+// extern function start with EXhalbtc8188c2ant_
+//============================================================
+VOID
+EXhalbtc8188c2ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+}
+
+VOID
+EXhalbtc8188c2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
+{
+	u1Byte	u1Tmp=0;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], 2Ant Init HW Config!!\n"));
+
+	// backup rf 0x1e value
+	pCoexDm->btRf0x1eBackup = 
+		pBtCoexist->fBtcGetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xf0);
+
+	if( (BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType) ||
+		(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType) )
+	{
+		u1Tmp = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x4fd) & BIT0;
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x4fd, u1Tmp);
+		
+		halbtc8188c2ant_CoexTable(pBtCoexist, FORCE_EXEC, 0xaaaa9aaa, 0xffbd0040, 0x40000010);
+	}
+}
+
+VOID
+EXhalbtc8188c2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Coex Mechanism Init!!\n"));
+	
+	halbtc8188c2ant_InitCoexDm(pBtCoexist);
+}
+
+VOID
+EXhalbtc8188c2ant_DisplayCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	pu1Byte				cliBuf=pBtCoexist->cliBuf;
+	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
+	u4Byte				u4Tmp[4];
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
+		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
+	CL_PRINTF(cliBuf);	
+	
+	if(pBtCoexist->bManualControl)
+	{
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "[Action Manual control]!!");
+		CL_PRINTF(cliBuf);
+	}
+	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %d", "BT stack/ hci ext ver", \
+		((pStackInfo->bProfileNotified)? "Yes":"No"), pStackInfo->hciVersion);
+	CL_PRINTF(cliBuf);
+	
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
+	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
+	CL_PRINTF(cliBuf);
+	
+	if(pStackInfo->bProfileNotified)
+	{			
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "SCO/HID/PAN/A2DP", \
+			pStackInfo->bScoExist, pStackInfo->bHidExist, pStackInfo->bPanExist, pStackInfo->bA2dpExist);
+		CL_PRINTF(cliBuf);	
+
+		pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_BT_LINK_INFO);
+	}
+	
+	// Sw mechanism	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Sw mechanism]============");
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ", "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]", \
+		pCoexDm->bCurAgcTableEn, pCoexDm->bCurAdcBackOff, pCoexDm->bCurDacSwingOn, pCoexDm->curDacSwingLvl);
+	CL_PRINTF(cliBuf);
+
+	// Fw mechanism		
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Fw mechanism]============");
+	CL_PRINTF(cliBuf);
+
+	// Hw setting		
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Hw setting]============");
+	CL_PRINTF(cliBuf);	
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "RF-A, 0x1e initVal", \
+		pCoexDm->btRf0x1eBackup);
+	CL_PRINTF(cliBuf);
+
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x40);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x40", \
+		u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xc50);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)", \
+		u4Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c4);
+	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c8);
+	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6cc);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", "0x6c4/0x6c8/0x6cc(coexTable)", \
+		u4Tmp[0], u4Tmp[1], u4Tmp[2]);
+	CL_PRINTF(cliBuf);
+
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+VOID
+EXhalbtc8188c2ant_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_IPS_ENTER == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], IPS ENTER notify\n"));
+		halbtc8188c2ant_CoexAllOff(pBtCoexist);
+	}
+	else if(BTC_IPS_LEAVE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], IPS LEAVE notify\n"));
+		//halbtc8188c2ant_InitCoexDm(pBtCoexist);
+	}
+}
+
+VOID
+EXhalbtc8188c2ant_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_LPS_ENABLE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], LPS ENABLE notify\n"));
+		halbtc8188c2ant_CoexAllOff(pBtCoexist);
+	}
+	else if(BTC_LPS_DISABLE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], LPS DISABLE notify\n"));
+		halbtc8188c2ant_InitCoexDm(pBtCoexist);
+	}
+}
+
+VOID
+EXhalbtc8188c2ant_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_SCAN_START == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCAN START notify\n"));
+	}
+	else if(BTC_SCAN_FINISH == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCAN FINISH notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8188c2ant_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_ASSOCIATE_START == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], CONNECT START notify\n"));
+	}
+	else if(BTC_ASSOCIATE_FINISH == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], CONNECT FINISH notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8188c2ant_MediaStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{	
+	if(BTC_MEDIA_CONNECT == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], MEDIA connect notify\n"));
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], MEDIA disconnect notify\n"));
+	}
+	
+}
+
+VOID
+EXhalbtc8188c2ant_SpecialPacketNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{
+	if(type == BTC_PACKET_DHCP)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], DHCP Packet notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8188c2ant_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	)
+{
+}
+
+VOID
+EXhalbtc8188c2ant_HaltNotify(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Halt notify\n"));
+
+	EXhalbtc8188c2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
+}
+
+VOID
+EXhalbtc8188c2ant_Periodical(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	u1Byte	algorithm;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], 2Ant Periodical!!\n"));
+
+	// NOTE:
+	// sw mechanism must be done after fw mechanism
+	// 
+
+	if((BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType) ||
+		(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType) )
+	{
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_GET_BT_RSSI, NULL);
+
+		halbtc8188c2ant_MonitorBtState(pBtCoexist);
+		algorithm = halbtc8188c2ant_ActionAlgorithm(pBtCoexist);	
+		pCoexDm->curAlgorithm = algorithm;
+		switch(pCoexDm->curAlgorithm)
+		{
+			case BT_8188C_2ANT_COEX_ALGO_SCO:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = SCO\n"));
+				halbtc8188c2ant_ActionSco(pBtCoexist);
+				break;
+			case BT_8188C_2ANT_COEX_ALGO_HID:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = HID\n"));
+				halbtc8188c2ant_ActionHid(pBtCoexist);
+				break;
+			case BT_8188C_2ANT_COEX_ALGO_A2DP:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = A2DP\n"));
+				halbtc8188c2ant_ActionA2dp(pBtCoexist);
+				break;
+			case BT_8188C_2ANT_COEX_ALGO_PAN:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = PAN\n"));
+				halbtc8188c2ant_ActionPan(pBtCoexist);
+				break;
+			case BT_8188C_2ANT_COEX_ALGO_HID_A2DP:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = HID+A2DP\n"));
+				halbtc8188c2ant_ActionHidA2dp(pBtCoexist);
+				break;
+			case BT_8188C_2ANT_COEX_ALGO_HID_PAN:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = PAN+HID\n"));
+				halbtc8188c2ant_ActionHidPan(pBtCoexist);
+				break;
+			case BT_8188C_2ANT_COEX_ALGO_PAN_A2DP:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = PAN+A2DP\n"));
+				halbtc8188c2ant_ActionPanA2dp(pBtCoexist);
+				break;
+			default:
+				break;
+		}
+	}
+}
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8188c2Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8188c2Ant.h
new file mode 100644
index 000000000..e4aa7152d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8188c2Ant.h
@@ -0,0 +1,149 @@
+//===========================================
+// The following is for 8188C 2Ant BT Co-exist definition
+//===========================================
+#define		BTC_RSSI_COEX_THRESH_TOL_8188C_2ANT		6
+
+typedef enum _BT_INFO_SRC_8188C_2ANT{
+	BT_INFO_SRC_8188C_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8188C_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8188C_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8188C_2ANT_MAX
+}BT_INFO_SRC_8188C_2ANT,*PBT_INFO_SRC_8188C_2ANT;
+
+typedef enum _BT_8188C_2ANT_BT_STATUS{
+	BT_8188C_2ANT_BT_STATUS_IDLE				= 0x0,
+	BT_8188C_2ANT_BT_STATUS_CONNECTED_IDLE	= 0x1,
+	BT_8188C_2ANT_BT_STATUS_NON_IDLE			= 0x2,
+	BT_8188C_2ANT_BT_STATUS_MAX
+}BT_8188C_2ANT_BT_STATUS,*PBT_8188C_2ANT_BT_STATUS;
+
+typedef enum _BT_8188C_2ANT_COEX_ALGO{
+	BT_8188C_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8188C_2ANT_COEX_ALGO_SCO					= 0x1,
+	BT_8188C_2ANT_COEX_ALGO_HID					= 0x2,
+	BT_8188C_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8188C_2ANT_COEX_ALGO_PAN					= 0x4,
+	BT_8188C_2ANT_COEX_ALGO_HID_A2DP			= 0x5,
+	BT_8188C_2ANT_COEX_ALGO_HID_PAN				= 0x6,
+	BT_8188C_2ANT_COEX_ALGO_PAN_A2DP			= 0x7,
+	BT_8188C_2ANT_COEX_ALGO_MAX
+}BT_8188C_2ANT_COEX_ALGO,*PBT_8188C_2ANT_COEX_ALGO;
+
+typedef struct _COEX_DM_8188C_2ANT{
+	// fw mechanism
+	BOOLEAN		bPreBalanceOn;
+	BOOLEAN		bCurBalanceOn;
+
+	// diminishWifi
+	BOOLEAN		bPreDacOn;
+	BOOLEAN		bCurDacOn;
+	BOOLEAN 	bPreInterruptOn;
+	BOOLEAN		bCurInterruptOn;
+	u1Byte		preFwDacSwingLvl;
+	u1Byte		curFwDacSwingLvl;
+	BOOLEAN 	bPreNavOn;
+	BOOLEAN		bCurNavOn;
+
+	// sw mechanism
+	BOOLEAN		bPreRfRxLpfShrink;
+	BOOLEAN		bCurRfRxLpfShrink;
+	u4Byte		btRf0x1eBackup;
+	BOOLEAN 	bPreLowPenaltyRa;
+	BOOLEAN		bCurLowPenaltyRa;
+	BOOLEAN		bPreDacSwingOn;
+	u4Byte		preDacSwingLvl;
+	BOOLEAN		bCurDacSwingOn;
+	u4Byte		curDacSwingLvl;
+	BOOLEAN		bPreAdcBackOff;
+	BOOLEAN		bCurAdcBackOff;
+	BOOLEAN 	bPreAgcTableEn;
+	BOOLEAN		bCurAgcTableEn;
+	//u4Byte		preVal0x6c0;
+	//u4Byte		curVal0x6c0;
+	u4Byte		preVal0x6c4;
+	u4Byte		curVal0x6c4;
+	u4Byte		preVal0x6c8;
+	u4Byte		curVal0x6c8;
+	u4Byte		preVal0x6cc;
+	u4Byte		curVal0x6cc;
+	//BOOLEAN		bLimitedDig;
+
+	// algorithm related
+	u1Byte		preAlgorithm;
+	u1Byte		curAlgorithm;
+	//u1Byte		btStatus;
+	//u1Byte		wifiChnlInfo[3];
+} COEX_DM_8188C_2ANT, *PCOEX_DM_8188C_2ANT;
+
+typedef struct _COEX_STA_8188C_2ANT{
+	u1Byte					preWifiRssiState[4];
+	BOOLEAN					bBtBusy;
+	BOOLEAN					bBtUplink;
+	BOOLEAN					bBtDownLink;
+	BOOLEAN					bA2dpBusy;
+}COEX_STA_8188C_2ANT, *PCOEX_STA_8188C_2ANT;
+
+//===========================================
+// The following is interface which will notify coex module.
+//===========================================
+VOID
+EXhalbtc8188c2ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8188c2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
+EXhalbtc8188c2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8188c2ant_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8188c2ant_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8188c2ant_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8188c2ant_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8188c2ant_MediaStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8188c2ant_SpecialPacketNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8188c2ant_HaltNotify(
+	IN	PBTC_COEXIST			pBtCoexist
+	);
+VOID
+EXhalbtc8188c2ant_Periodical(
+	IN	PBTC_COEXIST			pBtCoexist
+	);
+VOID
+EXhalbtc8188c2ant_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	);
+VOID
+EXhalbtc8188c2ant_DisplayCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192d2Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192d2Ant.c
new file mode 100644
index 000000000..0cb38ee7c
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192d2Ant.c
@@ -0,0 +1,1992 @@
+//============================================================
+// Description:
+//
+// This file is for 92D BT 2 Antenna Co-exist mechanism
+//
+// By cosa 02/11/2011
+//
+//============================================================
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+
+#if WPP_SOFTWARE_TRACE
+#include "HalBtc8192d2Ant.tmh"
+#endif
+
+#if(BT_30_SUPPORT == 1)
+//============================================================
+// Global variables, these are static variables
+//============================================================
+static COEX_DM_8192D_2ANT	GLCoexDm8192d2Ant;
+static PCOEX_DM_8192D_2ANT 	pCoexDm=&GLCoexDm8192d2Ant;
+static COEX_STA_8192D_2ANT	GLCoexSta8192d2Ant;
+static PCOEX_STA_8192D_2ANT	pCoexSta=&GLCoexSta8192d2Ant;
+
+//============================================================
+// local function start with btdm_
+//============================================================
+u1Byte
+halbtc8192d2ant_WifiRssiState(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			index,
+	IN	u1Byte			levelNum,
+	IN	u1Byte			rssiThresh,
+	IN	u1Byte			rssiThresh1
+	)
+{
+	s4Byte			wifiRssi=0;
+	u1Byte			wifiRssiState=pCoexSta->preWifiRssiState[index];
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
+	
+	if(levelNum == 2)
+	{
+		if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(wifiRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8192D_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_HIGH;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_LOW;
+			}
+		}
+		else
+		{
+			if(wifiRssi < rssiThresh)
+			{
+				wifiRssiState = BTC_RSSI_STATE_LOW;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_HIGH;
+			}
+		}
+	}
+	else if(levelNum == 3)
+	{
+		if(rssiThresh > rssiThresh1)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], wifi RSSI thresh error!!\n"));
+			return pCoexSta->preWifiRssiState[index];
+		}
+		
+		if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(wifiRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8192D_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_MEDIUM;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_LOW;
+			}
+		}
+		else if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_MEDIUM) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_MEDIUM))
+		{
+			if(wifiRssi >= (rssiThresh1+BTC_RSSI_COEX_THRESH_TOL_8192D_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_HIGH;
+			}
+			else if(wifiRssi < rssiThresh)
+			{
+				wifiRssiState = BTC_RSSI_STATE_LOW;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_MEDIUM;
+			}
+		}
+		else
+		{
+			if(wifiRssi < rssiThresh1)
+			{
+				wifiRssiState = BTC_RSSI_STATE_MEDIUM;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_HIGH;
+			}
+		}
+	}
+		
+	pCoexSta->preWifiRssiState[index] = wifiRssiState;
+
+	return wifiRssiState;
+}
+
+u1Byte
+halbtc8192d2ant_ActionAlgorithm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	BOOLEAN				bBtHsOn=FALSE;
+	u1Byte				algorithm=BT_8192D_2ANT_COEX_ALGO_UNDEFINED;
+	u1Byte				numOfDiffProfile=0;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+	
+	if(!pStackInfo->bBtLinkExist)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], No profile exists!!!\n"));
+		return algorithm;
+	}
+
+	if(pStackInfo->bScoExist)
+		numOfDiffProfile++;
+	if(pStackInfo->bHidExist)
+		numOfDiffProfile++;
+	if(pStackInfo->bPanExist)
+		numOfDiffProfile++;
+	if(pStackInfo->bA2dpExist)
+		numOfDiffProfile++;
+
+	if(pStackInfo->bScoExist)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO algorithm\n"));
+		algorithm = BT_8192D_2ANT_COEX_ALGO_SCO;
+	}
+	else
+	{
+		if(numOfDiffProfile == 1)
+		{
+			if(pStackInfo->bHidExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID only\n"));
+				algorithm = BT_8192D_2ANT_COEX_ALGO_HID;
+			}
+			else if(pStackInfo->bA2dpExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], A2DP only\n"));
+				algorithm = BT_8192D_2ANT_COEX_ALGO_A2DP;
+			}
+			else if(pStackInfo->bPanExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN only\n"));
+				algorithm = BT_8192D_2ANT_COEX_ALGO_PAN;
+			}
+		}
+		else
+		{
+			if( pStackInfo->bHidExist &&
+				pStackInfo->bA2dpExist )
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + A2DP\n"));
+				algorithm = BT_8192D_2ANT_COEX_ALGO_HID_A2DP;
+			}
+			else if( pStackInfo->bHidExist &&
+				pStackInfo->bPanExist )
+			{				
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + PAN\n"));
+				algorithm = BT_8192D_2ANT_COEX_ALGO_HID_PAN;
+			}
+			else if( pStackInfo->bPanExist &&
+				pStackInfo->bA2dpExist )
+			{				
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN + A2DP\n"));
+				algorithm = BT_8192D_2ANT_COEX_ALGO_PAN_A2DP;
+			}
+		}		
+	}
+	return algorithm;
+}
+
+VOID
+halbtc8192d2ant_SetFwBalance(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bBalanceOn,
+	IN	u1Byte			ms0,
+	IN	u1Byte			ms1
+	)
+{
+	u1Byte	H2C_Parameter[3] ={0};
+
+	if(bBalanceOn)
+	{
+		H2C_Parameter[2] = 1;
+		H2C_Parameter[1] = ms1;
+		H2C_Parameter[0] = ms0;
+	}
+	else
+	{
+		H2C_Parameter[2] = 0;
+		H2C_Parameter[1] = 0;
+		H2C_Parameter[0] = 0;
+	}
+	
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Balance=[%s:%dms:%dms], write 0xc=0x%x\n", 
+		bBalanceOn?"ON":"OFF", ms0, ms1,
+		H2C_Parameter[0]<<16|H2C_Parameter[1]<<8|H2C_Parameter[2]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0xc, 3, H2C_Parameter);	
+}
+
+VOID
+halbtc8192d2ant_Balance(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bBalanceOn,
+	IN	u1Byte			ms0,
+	IN	u1Byte			ms1
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn Balance %s\n", 
+		(bForceExec? "force to":""), (bBalanceOn? "ON":"OFF")));
+	pCoexDm->bCurBalanceOn = bBalanceOn;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreBalanceOn == pCoexDm->bCurBalanceOn)
+			return;
+	}
+	halbtc8192d2ant_SetFwBalance(pBtCoexist, bBalanceOn, ms0, ms1);
+
+	pCoexDm->bPreBalanceOn = pCoexDm->bCurBalanceOn;
+}
+
+VOID
+halbtc8192d2ant_SetFwDiminishWifi(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN 		bDacOn,
+	IN	BOOLEAN 		bInterruptOn,
+	IN	u1Byte			fwDacSwingLvl,
+	IN	BOOLEAN 		bNavOn
+	)
+{
+	u1Byte			H2C_Parameter[3] ={0};
+
+	if((pBtCoexist->stackInfo.minBtRssi <= -5) && (fwDacSwingLvl == 0x20))
+	{
+		RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], DiminishWiFi 0x20 original, but set 0x18 for Low RSSI!\n"));
+		fwDacSwingLvl = 0x18;
+	}
+
+	H2C_Parameter[2] = 0;
+	H2C_Parameter[1] = fwDacSwingLvl;
+	H2C_Parameter[0] = 0;
+	if(bDacOn)
+	{
+		H2C_Parameter[2] |= 0x01;	//BIT0
+		if(bInterruptOn)
+		{
+			H2C_Parameter[2] |= 0x02;	//BIT1
+		}
+	}
+	if(bNavOn)
+	{
+		H2C_Parameter[2] |= 0x08;	//BIT3
+	}
+		
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], bDacOn=%s, bInterruptOn=%s, bNavOn=%s, write 0x12=0x%x\n", 
+		(bDacOn?"ON":"OFF"), (bInterruptOn?"ON":"OFF"), (bNavOn?"ON":"OFF"),
+		(H2C_Parameter[0]<<16|H2C_Parameter[1]<<8|H2C_Parameter[2])));		
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x12, 3, H2C_Parameter);
+}
+
+
+VOID
+halbtc8192d2ant_DiminishWifi(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bDacOn,
+	IN	BOOLEAN			bInterruptOn,
+	IN	u1Byte			fwDacSwingLvl,
+	IN	BOOLEAN			bNavOn
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s set Diminish Wifi, bDacOn=%s, bInterruptOn=%s, fwDacSwingLvl=%d, bNavOn=%s\n", 
+		(bForceExec? "force to":""), (bDacOn? "ON":"OFF"), (bInterruptOn? "ON":"OFF"), fwDacSwingLvl, (bNavOn? "ON":"OFF")));
+
+	pCoexDm->bCurDacOn = bDacOn;
+	pCoexDm->bCurInterruptOn = bInterruptOn;
+	pCoexDm->curFwDacSwingLvl = fwDacSwingLvl;
+	pCoexDm->bCurNavOn = bNavOn;
+
+	if(!bForceExec)
+	{
+		if( (pCoexDm->bPreDacOn==pCoexDm->bCurDacOn) &&
+			(pCoexDm->bPreInterruptOn==pCoexDm->bCurInterruptOn) &&
+			(pCoexDm->preFwDacSwingLvl==pCoexDm->curFwDacSwingLvl) &&
+			(pCoexDm->bPreNavOn==pCoexDm->bCurNavOn) )
+			return;
+	}
+	halbtc8192d2ant_SetFwDiminishWifi(pBtCoexist, bDacOn, bInterruptOn, fwDacSwingLvl, bNavOn);
+
+	pCoexDm->bPreDacOn = pCoexDm->bCurDacOn;
+	pCoexDm->bPreInterruptOn = pCoexDm->bCurInterruptOn;
+	pCoexDm->preFwDacSwingLvl = pCoexDm->curFwDacSwingLvl;
+	pCoexDm->bPreNavOn = pCoexDm->bCurNavOn;
+}
+
+VOID
+halbtc8192d2ant_SetSwRfRxLpfCorner(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bRxRfShrinkOn
+	)
+{
+	if(bRxRfShrinkOn)
+	{
+		//Shrink RF Rx LPF corner
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Shrink RF Rx LPF corner!!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff, 0xf2ff7);
+	}
+	else
+	{
+		//Resume RF Rx LPF corner
+		// After initialized, we can use pCoexDm->btRf0x1eBackup
+		if(pBtCoexist->bInitilized)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Resume RF Rx LPF corner!!\n"));
+			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff, pCoexDm->btRf0x1eBackup);
+		}
+	}
+}
+
+
+VOID
+halbtc8192d2ant_RfShrink(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bRxRfShrinkOn
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn Rx RF Shrink = %s\n",  
+		(bForceExec? "force to":""), ((bRxRfShrinkOn)? "ON":"OFF")));
+	pCoexDm->bCurRfRxLpfShrink = bRxRfShrinkOn;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreRfRxLpfShrink == pCoexDm->bCurRfRxLpfShrink) 
+			return;
+	}
+	halbtc8192d2ant_SetSwRfRxLpfCorner(pBtCoexist, pCoexDm->bCurRfRxLpfShrink);
+
+	pCoexDm->bPreRfRxLpfShrink = pCoexDm->bCurRfRxLpfShrink;
+}
+
+VOID
+halbtc8192d2ant_SetSwPenaltyTxRateAdaptive(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bLowPenaltyRa
+	)
+{
+	u1Byte	tmpU1;
+
+	tmpU1 = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x4fd);
+	if(bLowPenaltyRa)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Tx rate adaptive, set low penalty!!\n"));
+		tmpU1 &= ~BIT2;
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Tx rate adaptive, set normal!!\n"));
+		tmpU1 |= BIT2;
+	}
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x4fd, tmpU1);
+}
+
+VOID
+halbtc8192d2ant_LowPenaltyRa(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bLowPenaltyRa
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn LowPenaltyRA = %s\n",  
+		(bForceExec? "force to":""), ((bLowPenaltyRa)? "ON":"OFF")));
+	pCoexDm->bCurLowPenaltyRa = bLowPenaltyRa;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreLowPenaltyRa == pCoexDm->bCurLowPenaltyRa) 
+			return;
+	}
+	halbtc8192d2ant_SetSwPenaltyTxRateAdaptive(pBtCoexist, pCoexDm->bCurLowPenaltyRa);
+
+	pCoexDm->bPreLowPenaltyRa = pCoexDm->bCurLowPenaltyRa;
+}
+
+VOID
+halbtc8192d2ant_SetSwFullTimeDacSwing(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bSwDacSwingOn,
+	IN	u4Byte			swDacSwingLvl
+	)
+{
+	u4Byte	dacSwingLvl;
+
+	if(bSwDacSwingOn)
+	{		
+		if((pBtCoexist->stackInfo.minBtRssi <= -5) && (swDacSwingLvl == 0x20))
+		{
+			dacSwingLvl = 0x18;
+		}
+		else
+		{
+			dacSwingLvl = swDacSwingLvl;
+		}
+		pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x880, 0xfc000000, dacSwingLvl);
+	}
+	else
+	{
+		pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x880, 0xfc000000, 0x30);
+	}
+}
+
+VOID
+halbtc8192d2ant_DacSwing(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bDacSwingOn,
+	IN	u4Byte			dacSwingLvl
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn DacSwing=%s, dacSwingLvl=0x%x\n",  
+		(bForceExec? "force to":""), ((bDacSwingOn)? "ON":"OFF"), dacSwingLvl));
+	pCoexDm->bCurDacSwingOn = bDacSwingOn;
+	pCoexDm->curDacSwingLvl = dacSwingLvl;
+
+	if(!bForceExec)
+	{
+		if( (pCoexDm->bPreDacSwingOn == pCoexDm->bCurDacSwingOn) &&
+			(pCoexDm->preDacSwingLvl == pCoexDm->curDacSwingLvl) )
+			return;
+	}
+	delay_ms(30);
+	halbtc8192d2ant_SetSwFullTimeDacSwing(pBtCoexist, bDacSwingOn, dacSwingLvl);
+
+	pCoexDm->bPreDacSwingOn = pCoexDm->bCurDacSwingOn;
+	pCoexDm->preDacSwingLvl = pCoexDm->curDacSwingLvl;
+}
+
+VOID
+halbtc8192d2ant_SetAdcBackOff(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bAdcBackOff
+	)
+{
+	if(bAdcBackOff)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BB BackOff Level On!\n"));
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc04,0x3a07611);
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BB BackOff Level Off!\n"));		
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc04,0x3a05611);
+	}
+}
+
+VOID
+halbtc8192d2ant_AdcBackOff(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bAdcBackOff
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn AdcBackOff = %s\n",  
+		(bForceExec? "force to":""), ((bAdcBackOff)? "ON":"OFF")));
+	pCoexDm->bCurAdcBackOff = bAdcBackOff;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreAdcBackOff == pCoexDm->bCurAdcBackOff) 
+			return;
+	}
+	halbtc8192d2ant_SetAdcBackOff(pBtCoexist, pCoexDm->bCurAdcBackOff);
+
+	pCoexDm->bPreAdcBackOff = pCoexDm->bCurAdcBackOff;
+}
+
+VOID
+halbtc8192d2ant_SetAgcTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bAgcTableEn
+	)
+{
+	u1Byte		rssiAdjustVal=0;
+
+	if(bAgcTableEn)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Agc Table On!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1a, 0xfffff, 0xa99);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0xd4000);
+		
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7b000001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7b010001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7b020001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7b030001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7b040001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7b050001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7b060001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7b070001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7b080001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7b090001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7b0A0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7b0B0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7a0C0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x790D0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x780E0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x770F0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x76100001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x75110001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x74120001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x73130001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x72140001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x71150001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x70160001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6f170001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6e180001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6d190001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6c1A0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6b1B0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6a1C0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x691D0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x4f1E0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x4e1F0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x4d200001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x4c210001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x4b220001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x4a230001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x49240001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x48250001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x47260001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x46270001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x45280001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x44290001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x432A0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x422B0001);
+
+		rssiAdjustVal = 12;
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Agc Table Off!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1a, 0xfffff, 0x30a99);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0xdc000);
+
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7B000001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7B010001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7B020001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7B030001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7B040001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7B050001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7B060001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x7A070001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x79080001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x78090001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x770A0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x760B0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x750C0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x740D0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x730E0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x720F0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x71100001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x70110001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6F120001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6E130001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6D140001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6C150001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6B160001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6A170001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x69180001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x68190001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x671A0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x661B0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x651C0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x641D0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x631E0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x621F0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x61200001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x60210001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x49220001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x48230001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x47240001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x46250001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x45260001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x44270001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x43280001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x42290001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x412A0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x402B0001);
+	}
+
+	// set rssiAdjustVal for wifi module.
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON, &rssiAdjustVal);
+}
+
+
+
+VOID
+halbtc8192d2ant_AgcTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bAgcTableEn
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s %s Agc Table\n",  
+		(bForceExec? "force to":""), ((bAgcTableEn)? "Enable":"Disable")));
+	pCoexDm->bCurAgcTableEn = bAgcTableEn;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreAgcTableEn == pCoexDm->bCurAgcTableEn) 
+			return;
+	}
+	halbtc8192d2ant_SetAgcTable(pBtCoexist, bAgcTableEn);
+
+	pCoexDm->bPreAgcTableEn = pCoexDm->bCurAgcTableEn;
+}
+
+VOID
+halbtc8192d2ant_SetCoexTable(
+	IN	PBTC_COEXIST	pBtCoexist,
+	IN	u4Byte		val0x6c4,
+	IN	u4Byte		val0x6c8,
+	IN	u4Byte		val0x6cc
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], set coex table, set 0x6c4=0x%x\n", val0x6c4));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c4, val0x6c4);
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], set coex table, set 0x6c8=0x%x\n", val0x6c8));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c8, val0x6c8);
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], set coex table, set 0x6cc=0x%x\n", val0x6cc));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6cc, val0x6cc);
+}
+
+VOID
+halbtc8192d2ant_CoexTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	u4Byte			val0x6c4,
+	IN	u4Byte			val0x6c8,
+	IN	u4Byte			val0x6cc
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s write Coex Table 0x6c4=0x%x, 0x6c8=0x%x, 0x6cc=0x%x\n", 
+		(bForceExec? "force to":""), val0x6c4, val0x6c8, val0x6cc));
+	pCoexDm->curVal0x6c4 = val0x6c4;
+	pCoexDm->curVal0x6c8 = val0x6c8;
+	pCoexDm->curVal0x6cc = val0x6cc;
+
+	if(!bForceExec)
+	{	
+		if( (pCoexDm->preVal0x6c4 == pCoexDm->curVal0x6c4) &&
+			(pCoexDm->preVal0x6c8 == pCoexDm->curVal0x6c8) &&
+			(pCoexDm->preVal0x6cc == pCoexDm->curVal0x6cc) )
+			return;
+	}
+	halbtc8192d2ant_SetCoexTable(pBtCoexist, val0x6c4, val0x6c8, val0x6cc);
+
+	pCoexDm->preVal0x6c4 = pCoexDm->curVal0x6c4;
+	pCoexDm->preVal0x6c8 = pCoexDm->curVal0x6c8;
+	pCoexDm->preVal0x6cc = pCoexDm->curVal0x6cc;
+}
+
+VOID
+halbtc8192d2ant_CoexAllOff(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	// fw mechanism
+	halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+	halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+	// sw mechanism
+	halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+}
+VOID
+halbtc8192d2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+}
+
+VOID
+halbtc8192d2ant_MonitorBtEnableDisable(
+	IN 	PBTC_COEXIST		pBtCoexist,
+	IN	u4Byte			btActive
+	)
+{
+	static BOOLEAN	bPreBtDisabled=FALSE;
+	static u4Byte		btDisableCnt=0;
+	BOOLEAN			bBtDisabled=FALSE, bForceToRoam=FALSE;
+	u4Byte			u4Tmp=0;
+
+	// This function check if bt is disabled
+	if(btActive)
+	{
+		btDisableCnt = 0;
+		bBtDisabled = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_DISABLE, &bBtDisabled);
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is enabled !!\n"));
+	}
+	else
+	{
+		btDisableCnt++;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], bt all counters=0, %d times!!\n", 
+				btDisableCnt));
+		if(btDisableCnt >= 2)
+		{
+			bBtDisabled = TRUE;
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_DISABLE, &bBtDisabled);
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is disabled !!\n"));
+		}
+	}
+	if(bPreBtDisabled != bBtDisabled)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is from %s to %s!!\n", 
+			(bPreBtDisabled ? "disabled":"enabled"), 
+			(bBtDisabled ? "disabled":"enabled")));
+
+		bForceToRoam = TRUE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_FORCE_TO_ROAM, &bForceToRoam);
+
+		bPreBtDisabled = bBtDisabled;
+	}
+}
+
+VOID
+halbtc8192d2ant_MonitorBtState(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	BOOLEAN 		stateChange=FALSE;
+	u4Byte			BT_Polling, Ratio_Act, Ratio_STA;
+	u4Byte			BT_Active, BT_State;
+	u4Byte			regBTActive=0, regBTState=0, regBTPolling=0;
+	u4Byte			btBusyThresh=0;
+	u4Byte			fwVer=0;
+	static BOOLEAN	bBtBusyTraffic=FALSE;
+	BOOLEAN 		bRejApAggPkt=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_FW_VER, &fwVer);
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], FirmwareVersion = 0x%x(%d)\n", fwVer, fwVer));
+	
+	regBTActive = 0x444;
+	regBTState = 0x448;
+	regBTPolling = 0x44c;	
+	
+	btBusyThresh = 40;
+	
+	BT_Active = pBtCoexist->fBtcRead4Byte(pBtCoexist, regBTActive);
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT_Active(0x%x)=0x%x\n", regBTActive, BT_Active));
+	BT_Active = BT_Active & 0x00ffffff;
+
+	BT_State = pBtCoexist->fBtcRead4Byte(pBtCoexist, regBTState);
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT_State(0x%x)=0x%x\n", regBTState, BT_State));
+	BT_State = BT_State & 0x00ffffff;
+
+	BT_Polling = pBtCoexist->fBtcRead4Byte(pBtCoexist, regBTPolling);
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT_Polling(0x%x)=0x%x\n", regBTPolling, BT_Polling));
+
+	if(BT_Active==0xffffffff && BT_State==0xffffffff && BT_Polling==0xffffffff )
+		return;
+
+	// 2011/05/04 MH For Slim combo test meet a problem. Surprise remove and WLAN is running
+	// DHCP process. At the same time, the register read value might be zero. And cause BSOD 0x7f
+	// EXCEPTION_DIVIDED_BY_ZERO. In This case, the stack content may always be wrong due to 
+	// HW divide trap.
+	if (BT_Polling==0)
+		return;
+
+	halbtc8192d2ant_MonitorBtEnableDisable(pBtCoexist, BT_Active);
+	
+	Ratio_Act = BT_Active*1000/BT_Polling;
+	Ratio_STA = BT_State*1000/BT_Polling;
+		
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Ratio_Act=%d\n", Ratio_Act));
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Ratio_STA=%d\n", Ratio_STA));
+
+	if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+	{
+		if(Ratio_STA < 60)	// BT PAN idle
+		{
+		}
+		else
+		{
+			// Check if BT PAN (under BT 2.1) is uplink or downlink
+			if((Ratio_Act/Ratio_STA) < 2)
+			{	// BT PAN Uplink
+				pCoexSta->bBtUplink = TRUE;
+			}
+			else
+			{	// BT PAN downlink
+				pCoexSta->bBtUplink = FALSE;
+			}
+		}
+	}	
+	
+	// Check BT is idle or not
+	if(!pBtCoexist->stackInfo.bBtLinkExist)
+	{
+		pCoexSta->bBtBusy = FALSE;
+	}
+	else
+	{
+		if(BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType)
+		{
+			if(Ratio_Act<20)
+			{
+				pCoexSta->bBtBusy = FALSE;
+			}
+			else
+			{
+				pCoexSta->bBtBusy = TRUE;
+			}
+		}
+		else if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+		{
+			if(Ratio_STA < btBusyThresh)
+			{
+				pCoexSta->bBtBusy = FALSE;
+			}
+			else
+			{
+				pCoexSta->bBtBusy = TRUE;
+			}
+
+			if( (Ratio_STA < btBusyThresh) ||
+				(Ratio_Act<180 && Ratio_STA<130) )
+			{
+				pCoexSta->bA2dpBusy = FALSE;
+			}
+			else
+			{
+				pCoexSta->bA2dpBusy = TRUE;
+			}
+		}
+	}
+
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &pCoexSta->bBtBusy);
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_LIMITED_DIG, &pCoexSta->bBtBusy);
+	
+	if(bBtBusyTraffic != pCoexSta->bBtBusy)
+	{	// BT idle or BT non-idle
+		bBtBusyTraffic = pCoexSta->bBtBusy;
+		stateChange = TRUE;
+	}
+
+	if(stateChange)
+	{
+		if(!pCoexSta->bBtBusy)
+		{
+			halbtc8192d2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_RfShrink(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_CoexAllOff(pBtCoexist);
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+		}
+		else
+		{
+			halbtc8192d2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8192d2ant_RfShrink(pBtCoexist, NORMAL_EXEC, TRUE);
+		}
+	}
+
+	if(stateChange)
+	{
+		bRejApAggPkt = pCoexSta->bBtBusy;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT, &bRejApAggPkt);
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+	}
+}
+
+VOID
+halbtc8192d2ant_ActionA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte			wifiRssiState, wifiRssiState1=BTC_RSSI_STATE_HIGH;
+	u4Byte			wifiBw, wifiTrafficDir;
+	BOOLEAN 		bWifiBusy=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+
+	wifiRssiState = halbtc8192d2ant_WifiRssiState(pBtCoexist, 0, 2, 47, 0);
+	if(pCoexSta->bA2dpBusy && bWifiBusy)
+	{
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+		{
+			wifiRssiState1 = halbtc8192d2ant_WifiRssiState(pBtCoexist, 1, 2, 47, 0);
+		}
+		else
+		{
+			if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+			{
+				wifiRssiState1 = halbtc8192d2ant_WifiRssiState(pBtCoexist, 1, 2, 25, 0);
+			}
+			else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+			{
+				wifiRssiState1 = halbtc8192d2ant_WifiRssiState(pBtCoexist, 1, 2, 40, 0);
+			}
+		}
+
+		// fw mechanism first
+		if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+		{
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0xc, 0x18);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+		}
+		else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+		{
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x10, 0x18);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+		}
+
+		// sw mechanism 
+		if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+		}
+		else
+		{
+			halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		}
+		
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+		{
+			halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+		}
+		else
+		{
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+			else
+			{
+				halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+		}
+	}
+	else if(pCoexSta->bA2dpBusy)
+	{
+		// fw mechanism first
+		halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+		halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, TRUE, 0x18, FALSE);
+
+		// sw mechanism 
+		halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+	}
+	else
+	{
+		halbtc8192d2ant_CoexAllOff(pBtCoexist);
+	}
+}
+
+VOID
+halbtc8192d2ant_ActionPan(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN 	bBtHsOn=FALSE, bWifiBusy=FALSE;
+	u1Byte		wifiRssiState, wifiRssiState1;
+	u4Byte		wifiBw, wifiTrafficDir;
+	s4Byte		wifiRssi;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
+
+	if(bBtHsOn)
+	{
+		halbtc8192d2ant_CoexAllOff(pBtCoexist);
+	}
+	else
+	{
+		wifiRssiState = halbtc8192d2ant_WifiRssiState(pBtCoexist, 0, 3, 25, 50);
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+		{
+			wifiRssiState1 = halbtc8192d2ant_WifiRssiState(pBtCoexist, 1, 2, 47, 0);
+		}
+		else
+		{			
+			wifiRssiState1 = halbtc8192d2ant_WifiRssiState(pBtCoexist, 1, 2, 25, 0);
+		}
+
+		if(pCoexSta->bBtBusy && bWifiBusy)
+		{
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				// fw mechanism first
+				if(pCoexSta->bBtUplink)
+				{
+					halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x20, 0x20);
+					halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+				}
+				else
+				{
+					halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+					halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+				}
+				// sw mechanism 
+				if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+					(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+				{
+					halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+				}
+				else
+				{
+					halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				}
+				halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+				if(pCoexSta->bBtUplink)
+				{
+					halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+				}
+				else
+				{
+					halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x20);
+				}
+			}
+			else if( (wifiRssiState == BTC_RSSI_STATE_MEDIUM) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_MEDIUM) )
+			{
+				// fw mechanism first
+				halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x20, 0x20);
+
+				if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+				{
+					halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+				}
+				else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+				{
+					if(BTC_WIFI_BW_HT40 == wifiBw)
+						halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);//BT_FW_NAV_ON);
+					else
+						halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+				}
+				// sw mechanism 
+				if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+					(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+				{
+					halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+				}
+				else
+				{
+					halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				}
+				halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+			else
+			{
+				// fw mechanism first
+				halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x20, 0x20);
+				
+				if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+				{
+					halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+				}
+				else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+				{
+					if(pCoexSta->bBtUplink)
+					{
+						if(BTC_WIFI_BW_HT40 == wifiBw)
+						{
+							halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);//BT_FW_NAV_ON);
+						}
+						else
+						{
+							halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+						}						
+					}
+					else
+					{
+						halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+					}
+				}
+				// sw mechanism 
+				if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+					(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+				{
+					halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+				}
+				else
+				{
+					halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				}
+				halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+		}
+		else if(pCoexSta->bBtBusy && 
+				!bWifiBusy &&
+				(wifiRssi < 30))
+		{
+			// fw mechanism first
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x0a, 0x20);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+			// sw mechanism 
+			halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+		}
+		else
+		{
+			halbtc8192d2ant_CoexAllOff(pBtCoexist);
+		}
+	}
+}
+
+
+VOID
+halbtc8192d2ant_ActionHid(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState=BTC_RSSI_STATE_HIGH;
+	u4Byte		wifiTrafficDir;
+	BOOLEAN 	bWifiBusy=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+	if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+	{
+		wifiRssiState = halbtc8192d2ant_WifiRssiState(pBtCoexist, 0, 2, 45, 0);
+	}
+	else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+	{
+		wifiRssiState = halbtc8192d2ant_WifiRssiState(pBtCoexist, 0, 2, 20, 0);
+	}
+		
+	if(pCoexSta->bBtBusy && bWifiBusy)
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			// fw mechanism first
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+			
+			// sw mechanism 			
+			halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x20);
+		}
+		else
+		{
+			// fw mechanism first
+			if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+			{
+				halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+				halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, TRUE, 0x18, FALSE);
+			}
+			else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+			{
+				halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x15, 0x15);
+				halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x30, FALSE);
+			}			
+			// sw mechanism 
+			halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+		}
+	}
+	else
+	{
+		halbtc8192d2ant_CoexAllOff(pBtCoexist);
+	}
+}
+
+
+
+VOID
+halbtc8192d2ant_ActionSco(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte	wifiRssiState;
+	u4Byte	wifiBw;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	wifiRssiState = halbtc8192d2ant_WifiRssiState(pBtCoexist, 0, 2, 47, 0);
+
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		// fw mechanism first
+		halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+		halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+		// sw mechanism 		
+		halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+	}
+	else
+	{
+		// fw mechanism first
+		halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+		halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+		
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+		}
+		else
+		{
+			halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+		}
+	}
+}
+
+VOID
+halbtc8192d2ant_ActionHidA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1;
+	u4Byte		wifiBw;
+
+	if(pCoexSta->bBtBusy)
+	{
+		wifiRssiState1 = halbtc8192d2ant_WifiRssiState(pBtCoexist, 1, 2, 35, 0);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+		{
+			// fw mechanism first
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+
+			// sw mechanism 
+			if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+			}
+			else
+			{
+				halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			}
+			halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+		}
+		else
+		{
+			wifiRssiState = halbtc8192d2ant_WifiRssiState(pBtCoexist, 0, 2, 47, 0);
+			// fw mechanism
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+			// sw mechanism 
+			if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+			}
+			else
+			{
+				halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			}
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+				halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+			}
+			else
+			{
+				halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+			}
+		}
+	}
+	else
+	{
+		halbtc8192d2ant_CoexAllOff(pBtCoexist);
+	}
+}
+
+
+VOID
+halbtc8192d2ant_ActionHidPanBc4(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bBtHsOn=FALSE, bWifiBusy=FALSE;
+	u4Byte		wifiBw, wifiTrafficDir;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+	
+	if(bBtHsOn)
+	{
+		halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+		halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+
+		halbtc8192d2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0x000000f0, 0x40000010);
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0xa0);
+	}
+	else
+	{
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+		if(BTC_WIFI_BW_LEGACY == wifiBw)
+		{
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+
+			halbtc8192d2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0x000000f0, 0x40000010);
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0xa0);
+		}
+		else if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+		{
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+			
+			halbtc8192d2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0x000000f0, 0x40000010);
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0xa0);
+		}
+		else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+		{
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x20, 0x10);					
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+		}
+		else if(!bWifiBusy)
+		{
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+		}			
+	}
+	halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+}
+VOID
+halbtc8192d2ant_ActionHidPanBc8(	
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bBtHsOn=FALSE, bWifiBusy=FALSE;
+	u1Byte		wifiRssiState;
+	u4Byte		wifiBw, wifiTrafficDir;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+
+	if(!bBtHsOn)
+	{
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+		wifiRssiState = halbtc8192d2ant_WifiRssiState(pBtCoexist, 0, 2, 25, 0);
+		if((pCoexSta->bBtBusy && bWifiBusy))
+		{
+			// fw mechanism first
+			if(pCoexSta->bBtUplink)
+			{
+				halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x15, 0x20);
+			}
+			else
+			{
+				halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x10, 0x20);
+			}
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+
+			// sw mechanism 
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+				if(BTC_WIFI_BW_HT40 == wifiBw)
+				{
+					halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+					halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+					halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+				}
+				else
+				{
+					halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+					halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+					halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+				}
+			}
+			else
+			{
+				halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+		}
+		else
+		{
+			halbtc8192d2ant_CoexAllOff(pBtCoexist);
+		}
+	}
+	else
+	{
+		if(BTC_INTF_USB == pBtCoexist->chipInterface)
+		{	
+			pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+			if(BTC_WIFI_TRAFFIC_TX == wifiTrafficDir)
+			{
+				halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+				halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+
+				halbtc8192d2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0x000000f0, 0x40000010);
+				pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0xa0);
+				halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+			}
+			else if(BTC_WIFI_TRAFFIC_RX == wifiTrafficDir)
+			{
+				halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+			}
+		}
+		else 
+		{
+			if(pCoexSta->bBtBusy)
+			{
+				// fw mechanism
+				halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+				halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+				// sw mechanism
+				halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x20);
+			}
+			else
+			{
+				halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+		}
+	}
+}
+
+VOID
+halbtc8192d2ant_ActionHidPan(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{		
+	if(BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8192d2ant_ActionHidPanBc4(pBtCoexist);
+	}
+	else if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8192d2ant_ActionHidPanBc8(pBtCoexist);
+	}
+}
+
+VOID
+halbtc8192d2ant_ActionPanA2dpBc4(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bBtHsOn=FALSE, bWifiBusy=FALSE;
+	u1Byte		wifiRssiState;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x0);
+	if(bBtHsOn)
+	{
+		if(pCoexSta->bBtBusy)
+		{
+			// fw mechanism
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+			// sw mechanism
+			halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x20);
+		}
+		else
+		{
+			halbtc8192d2ant_CoexAllOff(pBtCoexist);
+		}
+	}
+	else
+	{
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+		if(pCoexSta->bBtBusy && bWifiBusy)
+		{
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x20, 0x10);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+		}
+		else
+		{
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x0, FALSE);
+		}			
+		// sw mechanism
+		halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+	}
+}
+VOID
+halbtc8192d2ant_ActionPanA2dpBc8(	
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bBtHsOn=FALSE, bWifiBusy=FALSE;
+	u1Byte		wifiRssiState;
+	u4Byte		wifiBw;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+
+	if(!bBtHsOn)
+	{
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+		wifiRssiState = halbtc8192d2ant_WifiRssiState(pBtCoexist, 0, 2, 25, 0);
+		if((pCoexSta->bBtBusy && bWifiBusy))
+		{
+			// fw mechanism first
+			if(pCoexSta->bBtUplink)
+			{
+				halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x15, 0x20);
+			}
+			else
+			{
+				halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, TRUE, 0x10, 0x20);
+			}
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x20, FALSE);
+
+			// sw mechanism 
+			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+				if(BTC_WIFI_BW_HT40 == wifiBw)
+				{
+					halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+					halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+					halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+				}
+				else	
+				{
+					halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+					halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+					halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+				}
+			}
+			else
+			{
+				halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+				halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+			}
+		}
+		else
+		{
+			halbtc8192d2ant_CoexAllOff(pBtCoexist);
+		}
+	}
+	else
+	{
+		if(pCoexSta->bBtBusy)
+		{
+			// fw mechanism
+			halbtc8192d2ant_Balance(pBtCoexist, NORMAL_EXEC, FALSE, 0, 0);
+			halbtc8192d2ant_DiminishWifi(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0, FALSE);
+
+			// sw mechanism			
+			halbtc8192d2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x20);
+		}
+		else
+		{
+			halbtc8192d2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0x30);
+		}
+	}
+}
+
+VOID
+halbtc8192d2ant_ActionPanA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	if(BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8192d2ant_ActionPanA2dpBc4(pBtCoexist);
+	}
+	else if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+	{
+		halbtc8192d2ant_ActionPanA2dpBc8(pBtCoexist);
+	}
+}
+
+BOOLEAN
+halbtc8192d2ant_IsBtCoexistEnter(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte			macPhyMode;
+	BOOLEAN			bRet=TRUE;
+	BOOLEAN			bWifiUnder5G=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_MAC_PHY_MODE, &macPhyMode);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
+	
+	if(BTC_SMSP != macPhyMode)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Only support single mac single phy!!\n"));
+		bRet = FALSE;
+	}
+
+	if(bWifiUnder5G)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], wifi is under 5G or A band\n"));
+		halbtc8192d2ant_CoexAllOff(pBtCoexist);
+		bRet = FALSE;
+	}
+
+	return bRet;
+}
+
+//============================================================
+// extern function start with EXhalbtc8192d2ant_
+//============================================================
+VOID
+EXhalbtc8192d2ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+}
+
+VOID
+EXhalbtc8192d2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
+{
+	u1Byte	u1Tmp=0;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], 2Ant Init HW Config!!\n"));
+
+	// backup rf 0x1e value
+	pCoexDm->btRf0x1eBackup = 
+		pBtCoexist->fBtcGetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff);
+
+	if( (BTC_CHIP_CSR_BC4 == pBtCoexist->boardInfo.btChipType) ||
+		(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType) )
+	{
+		u1Tmp =  pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x4fd) & BIT0;
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x4fd, u1Tmp);
+		
+		halbtc8192d2ant_CoexTable(pBtCoexist, FORCE_EXEC, 0xaaaa9aaa, 0xffbd0040, 0x40000010);
+
+		// switch control, here we set pathA to control
+		// 0x878[13] = 1, 0:pathB, 1:pathA(default)
+		pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x878, BIT13, 0x1);
+		
+		// antsel control, here we use phy0 and enable antsel.
+		// 0x87c[16:15] = b'11, enable antsel, antsel output pin
+		// 0x87c[30] = 0, 0: phy0, 1:phy 1
+		pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x87c, bMaskDWord, 0x1fff8);
+		
+		// antsel to Bt or Wifi, it depends Bt on/off.
+		// 0x860[9:8] = 'b10, b10:Bt On, WL2G off(default), b01:Bt off, WL2G on.
+		pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x860, BIT9|BIT8, 0x2);
+		
+		// sw/hw control switch, here we set sw control
+		// 0x870[9:8] = 'b11 sw control, 'b00 hw control
+		pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x870, BIT9|BIT8, 0x3);
+	}
+}
+
+VOID
+EXhalbtc8192d2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Coex Mechanism Init!!\n"));
+	
+	halbtc8192d2ant_InitCoexDm(pBtCoexist);
+}
+
+VOID
+EXhalbtc8192d2ant_DisplayCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	pu1Byte				cliBuf=pBtCoexist->cliBuf;
+	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
+	u4Byte				u4Tmp[4];
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
+		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
+	CL_PRINTF(cliBuf);	
+	
+	if(pBtCoexist->bManualControl)
+	{
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "[Action Manual control]!!");
+		CL_PRINTF(cliBuf);
+	}
+	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %d", "BT stack/ hci ext ver", \
+		((pStackInfo->bProfileNotified)? "Yes":"No"), pStackInfo->hciVersion);
+	CL_PRINTF(cliBuf);
+
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
+	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
+	CL_PRINTF(cliBuf);
+	
+	if(pStackInfo->bProfileNotified)
+	{			
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "SCO/HID/PAN/A2DP", \
+			pStackInfo->bScoExist, pStackInfo->bHidExist, pStackInfo->bPanExist, pStackInfo->bA2dpExist);
+		CL_PRINTF(cliBuf);	
+
+		pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_BT_LINK_INFO);
+	}
+	
+	// Sw mechanism	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Sw mechanism]============");
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ", "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]", \
+		pCoexDm->bCurAgcTableEn, pCoexDm->bCurAdcBackOff, pCoexDm->bCurDacSwingOn, pCoexDm->curDacSwingLvl);
+	CL_PRINTF(cliBuf);
+
+	// Fw mechanism		
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Fw mechanism]============");
+	CL_PRINTF(cliBuf);
+
+	// Hw setting		
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Hw setting]============");
+	CL_PRINTF(cliBuf);	
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "RF-A, 0x1e initVal", \
+		pCoexDm->btRf0x1eBackup);
+	CL_PRINTF(cliBuf);
+
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x40);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x40", \
+		u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xc50);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)", \
+		u4Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c4);
+	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c8);
+	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6cc);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", "0x6c4/0x6c8/0x6cc(coexTable)", \
+		u4Tmp[0], u4Tmp[1], u4Tmp[2]);
+	CL_PRINTF(cliBuf);
+
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+VOID
+EXhalbtc8192d2ant_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_IPS_ENTER == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], IPS ENTER notify\n"));
+		halbtc8192d2ant_CoexAllOff(pBtCoexist);
+	}
+	else if(BTC_IPS_LEAVE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], IPS LEAVE notify\n"));
+		//halbtc8192d2ant_InitCoexDm(pBtCoexist);
+	}
+}
+
+VOID
+EXhalbtc8192d2ant_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_LPS_ENABLE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], LPS ENABLE notify\n"));
+		halbtc8192d2ant_CoexAllOff(pBtCoexist);
+	}
+	else if(BTC_LPS_DISABLE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], LPS DISABLE notify\n"));
+		halbtc8192d2ant_InitCoexDm(pBtCoexist);
+	}
+}
+
+VOID
+EXhalbtc8192d2ant_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_SCAN_START == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCAN START notify\n"));
+	}
+	else if(BTC_SCAN_FINISH == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCAN FINISH notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8192d2ant_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_ASSOCIATE_START == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], CONNECT START notify\n"));
+	}
+	else if(BTC_ASSOCIATE_FINISH == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], CONNECT FINISH notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8192d2ant_MediaStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{	
+	if(BTC_MEDIA_CONNECT == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], MEDIA connect notify\n"));
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], MEDIA disconnect notify\n"));
+	}	
+}
+
+VOID
+EXhalbtc8192d2ant_SpecialPacketNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{
+	if(type == BTC_PACKET_DHCP)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], DHCP Packet notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8192d2ant_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	)
+{
+}
+
+VOID
+EXhalbtc8192d2ant_HaltNotify(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Halt notify\n"));
+
+	EXhalbtc8192d2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
+}
+
+VOID
+EXhalbtc8192d2ant_Periodical(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	u1Byte	algorithm;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], 2Ant Periodical!!\n"));
+
+	// NOTE:
+	// sw mechanism must be done after fw mechanism
+	// 
+	if(!halbtc8192d2ant_IsBtCoexistEnter(pBtCoexist))
+		return;
+
+	if(BTC_CHIP_CSR_BC8 == pBtCoexist->boardInfo.btChipType)
+	{
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_GET_BT_RSSI, NULL);
+
+		halbtc8192d2ant_MonitorBtState(pBtCoexist);
+		algorithm = halbtc8192d2ant_ActionAlgorithm(pBtCoexist);	
+		pCoexDm->curAlgorithm = algorithm;
+		switch(pCoexDm->curAlgorithm)
+		{
+			case BT_8192D_2ANT_COEX_ALGO_SCO:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = SCO\n"));
+				halbtc8192d2ant_ActionSco(pBtCoexist);
+				break;
+			case BT_8192D_2ANT_COEX_ALGO_HID:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = HID\n"));
+				halbtc8192d2ant_ActionHid(pBtCoexist);
+				break;
+			case BT_8192D_2ANT_COEX_ALGO_A2DP:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = A2DP\n"));
+				halbtc8192d2ant_ActionA2dp(pBtCoexist);
+				break;
+			case BT_8192D_2ANT_COEX_ALGO_PAN:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = PAN\n"));
+				halbtc8192d2ant_ActionPan(pBtCoexist);
+				break;
+			case BT_8192D_2ANT_COEX_ALGO_HID_A2DP:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = HID+A2DP\n"));
+				halbtc8192d2ant_ActionHidA2dp(pBtCoexist);
+				break;
+			case BT_8192D_2ANT_COEX_ALGO_HID_PAN:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = PAN+HID\n"));
+				halbtc8192d2ant_ActionHidPan(pBtCoexist);
+				break;
+			case BT_8192D_2ANT_COEX_ALGO_PAN_A2DP:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = PAN+A2DP\n"));
+				halbtc8192d2ant_ActionPanA2dp(pBtCoexist);
+				break;
+			default:
+				break;
+		}
+	}
+}
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192d2Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192d2Ant.h
new file mode 100644
index 000000000..f3862b33e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192d2Ant.h
@@ -0,0 +1,170 @@
+//===========================================
+// The following is for 8192D 2Ant BT Co-exist definition
+//===========================================
+#define		BTC_RSSI_COEX_THRESH_TOL_8192D_2ANT		6
+
+typedef enum _BT_INFO_SRC_8192D_2ANT{
+	BT_INFO_SRC_8192D_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8192D_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8192D_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8192D_2ANT_MAX
+}BT_INFO_SRC_8192D_2ANT,*PBT_INFO_SRC_8192D_2ANT;
+
+typedef enum _BT_8192D_2ANT_BT_STATUS{
+	BT_8192D_2ANT_BT_STATUS_IDLE				= 0x0,
+	BT_8192D_2ANT_BT_STATUS_CONNECTED_IDLE	= 0x1,
+	BT_8192D_2ANT_BT_STATUS_NON_IDLE			= 0x2,
+	BT_8192D_2ANT_BT_STATUS_MAX
+}BT_8192D_2ANT_BT_STATUS,*PBT_8192D_2ANT_BT_STATUS;
+
+typedef enum _BT_8192D_2ANT_COEX_ALGO{
+	BT_8192D_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8192D_2ANT_COEX_ALGO_SCO					= 0x1,
+	BT_8192D_2ANT_COEX_ALGO_HID					= 0x2,
+	BT_8192D_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8192D_2ANT_COEX_ALGO_PAN					= 0x4,
+	BT_8192D_2ANT_COEX_ALGO_HID_A2DP			= 0x5,
+	BT_8192D_2ANT_COEX_ALGO_HID_PAN				= 0x6,
+	BT_8192D_2ANT_COEX_ALGO_PAN_A2DP			= 0x7,
+	BT_8192D_2ANT_COEX_ALGO_MAX
+}BT_8192D_2ANT_COEX_ALGO,*PBT_8192D_2ANT_COEX_ALGO;
+
+typedef struct _COEX_DM_8192D_2ANT{
+	// fw mechanism
+	BOOLEAN		bPreBalanceOn;
+	BOOLEAN		bCurBalanceOn;
+
+	// diminishWifi
+	BOOLEAN		bPreDacOn;
+	BOOLEAN		bCurDacOn;
+	BOOLEAN 	bPreInterruptOn;
+	BOOLEAN		bCurInterruptOn;
+	u1Byte		preFwDacSwingLvl;
+	u1Byte		curFwDacSwingLvl;
+	BOOLEAN 	bPreNavOn;
+	BOOLEAN		bCurNavOn;
+
+
+	
+
+	
+	//BOOLEAN		bPreDecBtPwr;
+	//BOOLEAN		bCurDecBtPwr;
+
+	//u1Byte		preFwDacSwingLvl;
+	//u1Byte		curFwDacSwingLvl;
+	//BOOLEAN		bCurIgnoreWlanAct;
+	//BOOLEAN		bPreIgnoreWlanAct;
+	//u1Byte		prePsTdma;
+	//u1Byte		curPsTdma;
+	//u1Byte		psTdmaPara[5];
+	//u1Byte		psTdmaDuAdjType;
+	//BOOLEAN		bResetTdmaAdjust;
+	//BOOLEAN		bPrePsTdmaOn;
+	//BOOLEAN		bCurPsTdmaOn;
+	//BOOLEAN		bPreBtAutoReport;
+	//BOOLEAN		bCurBtAutoReport;
+
+	// sw mechanism
+	BOOLEAN		bPreRfRxLpfShrink;
+	BOOLEAN		bCurRfRxLpfShrink;
+	u4Byte		btRf0x1eBackup;
+	BOOLEAN 	bPreLowPenaltyRa;
+	BOOLEAN		bCurLowPenaltyRa;
+	BOOLEAN		bPreDacSwingOn;
+	u4Byte		preDacSwingLvl;
+	BOOLEAN		bCurDacSwingOn;
+	u4Byte		curDacSwingLvl;
+	BOOLEAN		bPreAdcBackOff;
+	BOOLEAN		bCurAdcBackOff;
+	BOOLEAN 	bPreAgcTableEn;
+	BOOLEAN		bCurAgcTableEn;
+	//u4Byte		preVal0x6c0;
+	//u4Byte		curVal0x6c0;
+	u4Byte		preVal0x6c4;
+	u4Byte		curVal0x6c4;
+	u4Byte		preVal0x6c8;
+	u4Byte		curVal0x6c8;
+	u4Byte		preVal0x6cc;
+	u4Byte		curVal0x6cc;
+	//BOOLEAN		bLimitedDig;
+
+	// algorithm related
+	u1Byte		preAlgorithm;
+	u1Byte		curAlgorithm;
+	//u1Byte		btStatus;
+	//u1Byte		wifiChnlInfo[3];
+} COEX_DM_8192D_2ANT, *PCOEX_DM_8192D_2ANT;
+
+typedef struct _COEX_STA_8192D_2ANT{
+	u1Byte					preWifiRssiState[4];
+	BOOLEAN					bBtBusy;
+	BOOLEAN					bBtUplink;
+	BOOLEAN					bBtDownLink;
+	BOOLEAN					bA2dpBusy;
+}COEX_STA_8192D_2ANT, *PCOEX_STA_8192D_2ANT;
+
+//===========================================
+// The following is interface which will notify coex module.
+//===========================================
+VOID
+EXhalbtc8192d2ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8192d2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
+EXhalbtc8192d2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8192d2ant_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8192d2ant_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8192d2ant_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8192d2ant_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8192d2ant_MediaStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8192d2ant_SpecialPacketNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8192d2ant_HaltNotify(
+	IN	PBTC_COEXIST			pBtCoexist
+	);
+VOID
+EXhalbtc8192d2ant_Periodical(
+	IN	PBTC_COEXIST			pBtCoexist
+	);
+VOID
+EXhalbtc8192d2ant_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	);
+VOID
+EXhalbtc8192d2ant_DisplayCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e1Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e1Ant.c
new file mode 100644
index 000000000..8a4d9777f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e1Ant.c
@@ -0,0 +1,3417 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8192E Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "Mp_Precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8192E_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8192e_1ant		glcoex_dm_8192e_1ant;
+static struct  coex_dm_8192e_1ant	*coex_dm = &glcoex_dm_8192e_1ant;
+static struct  coex_sta_8192e_1ant		glcoex_sta_8192e_1ant;
+static struct  coex_sta_8192e_1ant	*coex_sta = &glcoex_sta_8192e_1ant;
+
+const char *const glbt_info_src_8192e_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8192e_1ant = 20140527;
+u32	glcoex_ver_8192e_1ant = 0x4f;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8192e1ant_
+ * ************************************************************ */
+u8 halbtc8192e1ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8192e1ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8192e1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8192e1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8192e1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8192e1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8192e1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8192e1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8192e1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8192e1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8192e1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8192e1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8192e1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8192e1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8192e1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+void halbtc8192e1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u8		num_of_bt_counter_chk = 0;
+
+	/* to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS */
+	/* if (! (btcoexist->btc_read_1byte(btcoexist, 0x76e) & 0x8) ) */
+
+	if (coex_sta->under_ips) {
+		coex_sta->high_priority_tx = 65535;
+		coex_sta->high_priority_rx = 65535;
+		coex_sta->low_priority_tx = 65535;
+		coex_sta->low_priority_rx = 65535;
+		return;
+	}
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if ((coex_sta->low_priority_tx >= 1050)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\n",
+		    reg_hp_rx, reg_hp_tx, reg_lp_rx, reg_lp_tx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	if ((reg_hp_tx == 0) && (reg_hp_rx == 0) && (reg_lp_tx == 0) &&
+	    (reg_lp_rx == 0)) {
+		num_of_bt_counter_chk++;
+		if (num_of_bt_counter_chk >= 3) {
+			halbtc8192e1ant_query_bt_info(btcoexist);
+			num_of_bt_counter_chk = 0;
+		}
+	}
+}
+
+
+void halbtc8192e1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+	s32	wifi_rssi = 0;
+	boolean wifi_busy = false, wifi_under_b_mode = false;
+	static u8 cck_lock_counter = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+			   &wifi_under_b_mode);
+
+	if (coex_sta->under_ips) {
+		coex_sta->crc_ok_cck = 0;
+		coex_sta->crc_ok_11g = 0;
+		coex_sta->crc_ok_11n = 0;
+		coex_sta->crc_ok_11n_agg = 0;
+
+		coex_sta->crc_err_cck = 0;
+		coex_sta->crc_err_11g = 0;
+		coex_sta->crc_err_11n = 0;
+		coex_sta->crc_err_11n_agg = 0;
+	} else {
+		coex_sta->crc_ok_cck	= btcoexist->btc_read_4byte(btcoexist,
+					  0xf88);
+		coex_sta->crc_ok_11g	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf94);
+		coex_sta->crc_ok_11n	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf90);
+		coex_sta->crc_ok_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					   0xfb8);
+
+		coex_sta->crc_err_cck	 = btcoexist->btc_read_4byte(btcoexist,
+					   0xf84);
+		coex_sta->crc_err_11g	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf96);
+		coex_sta->crc_err_11n	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf92);
+		coex_sta->crc_err_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					    0xfba);
+	}
+
+
+	/* reset counter */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xf16, 0x1, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xf16, 0x1, 0x0);
+
+	if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+		if ((coex_dm->bt_status == BT_8192E_1ANT_BT_STATUS_ACL_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8192E_1ANT_BT_STATUS_SCO_BUSY)) {
+			if (coex_sta->crc_ok_cck > (coex_sta->crc_ok_11g +
+						    coex_sta->crc_ok_11n +
+						    coex_sta->crc_ok_11n_agg)) {
+				if (cck_lock_counter < 5)
+					cck_lock_counter++;
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+	} else {
+		if (cck_lock_counter > 0)
+			cck_lock_counter--;
+	}
+
+	if (!coex_sta->pre_ccklock) {
+
+		if (cck_lock_counter >= 5)
+			coex_sta->cck_lock = true;
+		else
+			coex_sta->cck_lock = false;
+	} else {
+		if (cck_lock_counter == 0)
+			coex_sta->cck_lock = false;
+		else
+			coex_sta->cck_lock = true;
+	}
+
+	coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+
+}
+
+boolean halbtc8192e1ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void halbtc8192e1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8192e1ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8192E_1ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Profile = SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8192E_1ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_1ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_1ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8192E_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_1ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8192E_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! BT Profile = SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8192e1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8192e1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8192e1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8192e1ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf7;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf8;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf9;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8192e1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8192e1ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8192e1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8192e1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8192e1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8192e1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** CoexTable(%d) **********\n", type);
+	BTC_TRACE(trace_buf);
+
+	coex_sta->coex_table_type = type;
+
+	switch (type) {
+	case 0:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaa5a5a, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0xaa5a5a5a, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8192e1ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8192e1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable) {
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8192e1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8192e1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8192e1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8192e1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8192e1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8192e1ant_sw_mechanism(IN struct btc_coexist *btcoexist,
+				  IN boolean low_penalty_ra)
+{
+	halbtc8192e1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+void halbtc8192e1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	u32			u32tmp = 0;
+
+	if (init_hwcfg) {
+		btcoexist->btc_write_1byte(btcoexist, 0x944, 0x24);
+		btcoexist->btc_write_4byte(btcoexist, 0x930, 0x700700);
+		if (btcoexist->chip_interface == BTC_INTF_USB)
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30430004);
+		else
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30030004);
+
+		/* 0x4c[27][24]='00', Set Antenna to BB */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(24);
+		u32tmp &= ~BIT(27);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+	} else if (wifi_off) {
+		if (btcoexist->chip_interface == BTC_INTF_USB)
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30430004);
+		else
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30030004);
+
+		/* 0x4c[27][24]='11', Set Antenna to BT, 0x64[8:7]=0, 0x64[2]=1 */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp |= BIT(24);
+		u32tmp |= BIT(27);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+	}
+
+	/* ext switch setting */
+	switch (ant_pos_type) {
+	case BTC_ANT_PATH_WIFI:
+		btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x4);
+		break;
+	case BTC_ANT_PATH_BT:
+		btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x20);
+		break;
+	default:
+	case BTC_ANT_PATH_PTA:
+		btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x4);
+		break;
+	}
+}
+
+void halbtc8192e1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for 1Ant AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+		}
+	}
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+
+void halbtc8192e1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_busy = false;
+	u8			rssi_adjust_val = 0;
+	u8			ps_tdma_byte4_val = 0x50, ps_tdma_byte0_val = 0x51,
+				ps_tdma_byte3_val =  0x10;
+	s8			wifi_duration_adjust = 0x0;
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_sta->scan_ap_num <= 5)
+		wifi_duration_adjust = 5;
+	else if (coex_sta->scan_ap_num >= 40)
+		wifi_duration_adjust = -15;
+	else if (coex_sta->scan_ap_num >= 20)
+		wifi_duration_adjust = -10;
+
+	if (!coex_sta->force_lps_on) { /* only for A2DP-only case 1/2/9/11 while wifi noisy threshold > 30 */
+		ps_tdma_byte0_val = 0x61;  /* no null-pkt */
+		ps_tdma_byte3_val = 0x11; /* no tx-pause at BT-slot */
+		ps_tdma_byte4_val = 0x10; /* 0x778 = d/1 toggle */
+	}
+
+	if ((type == 3) || (type == 13) || (type == 14))
+		ps_tdma_byte4_val = ps_tdma_byte4_val &
+			    0xbf;  /* no dynamic slot for multi-profile */
+
+	if (bt_link_info->slave_role == true)
+		ps_tdma_byte4_val = ps_tdma_byte4_val |
+			0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x1a, 0x1a, 0x0, ps_tdma_byte4_val);
+			break;
+		case 1:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x3a +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 2:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x2d +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 3:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x1d, 0x1d, 0x0, ps_tdma_byte4_val);
+			break;
+		case 4:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x14, 0x0);
+			break;
+		case 5:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x15, 0x3, 0x11, 0x11);
+			break;
+		case 6:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x20, 0x3, 0x11, 0x11);
+			break;
+		case 7:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xc, 0x5, 0x0, 0x0);
+			break;
+		case 8:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 9:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 10:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0xa, 0x0, 0x40);
+			break;
+		case 11:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 12:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x0a, 0x0a, 0x0, 0x50);
+			break;
+		case 13:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x12, 0x12, 0x0, ps_tdma_byte4_val);
+			break;
+		case 14:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x21, 0x3, 0x10, ps_tdma_byte4_val);
+			break;
+		case 15:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0x3, 0x8, 0x0);
+			break;
+		case 16:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x10, 0x0);
+			break;
+		case 18:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 20:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x3f, 0x03, 0x11, 0x10);
+			break;
+		case 21:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x11);
+			break;
+		case 22:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x10);
+			break;
+		case 23:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x18);
+			break;
+		case 24:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x3, 0x31, 0x18);
+			break;
+		case 25:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 26:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 27:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x98);
+			break;
+		case 28:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x69,
+						      0x25, 0x3, 0x31, 0x0);
+			break;
+		case 29:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xab,
+						      0x1a, 0x1a, 0x1, 0x10);
+			break;
+		case 30:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x10);
+			break;
+		case 31:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1a, 0x1a, 0, 0x58);
+			break;
+		case 32:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x3, 0x11, 0x11);
+			break;
+		case 33:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x25, 0x3, 0x30, 0x90);
+			break;
+		case 34:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 35:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 36:
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x12, 0x3, 0x14, 0x50);
+			break;
+		case 40: /* SoftAP only with no sta associated,BT disable ,TDMA mode for power saving */
+			/* here softap mode screen off will cost 70-80mA for phone */
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x23,
+						      0x18, 0x00, 0x10, 0x24);
+			break;
+		}
+	} else {
+
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8192e1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_PTA, false, false);
+			break;
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8192e1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_BT, false, false);
+			break;
+		case 9:   /* Software control, Antenna at WiFi side */
+			halbtc8192e1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8192e1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_WIFI, false, false);
+			break;
+		}
+	}
+	rssi_adjust_val = 0;
+	btcoexist->btc_set(btcoexist,
+		BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE, &rssi_adjust_val);
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+		    btcoexist->btc_read_4byte(btcoexist, 0x948),
+		    btcoexist->btc_read_1byte(btcoexist, 0x765),
+		    btcoexist->btc_read_1byte(btcoexist, 0x67));
+	BTC_TRACE(trace_buf);
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8192e1ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* sw all off */
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+
+	/* hw all off */
+	halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+boolean halbtc8192e1ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8192E_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		/* halbtc8192e1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8192E_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		/* halbtc8192e1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (!wifi_connected &&
+		(BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		/* halbtc8192e1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (wifi_connected &&
+		(BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		/* halbtc8192e1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (!wifi_connected &&
+		(BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE != coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non connected-idle + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+		/* halbtc8192e1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else {
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		common = false;
+	}
+
+	return common;
+}
+
+
+void halbtc8192e1ant_tdma_duration_adjust_for_acl(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0, bt_info_ext;
+	boolean			wifi_busy = false;
+	/*static boolean	pre_wifi_busy = false;*/
+
+	if (BT_8192E_1ANT_WIFI_STATUS_CONNECTED_BUSY == wifi_status)
+		wifi_busy = true;
+	else
+		wifi_busy = false;
+
+	if ((BT_8192E_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN ==
+	     wifi_status) ||
+	    (BT_8192E_1ANT_WIFI_STATUS_CONNECTED_SCAN == wifi_status) ||
+	    (BT_8192E_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT ==
+	     wifi_status)) {
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 3 &&
+		    coex_dm->cur_ps_tdma != 9) {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						9);
+			coex_dm->ps_tdma_du_adj_type = 9;
+
+			up = 0;
+			dn = 0;
+			m = 1;
+			n = 3;
+			result = 0;
+			wait_count = 0;
+		}
+		return;
+	}
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 2);
+		coex_dm->ps_tdma_du_adj_type = 2;
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* accquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		bt_info_ext = coex_sta->bt_info_ext;
+
+		if ((coex_sta->low_priority_tx) > 1050 ||
+		    (coex_sta->low_priority_rx) > 1250)
+			retry_count++;
+
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (result == -1) {
+			if ((BT_INFO_8192E_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+			    ((coex_dm->cur_ps_tdma == 1) ||
+			     (coex_dm->cur_ps_tdma == 2))) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 1) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 11);
+				coex_dm->ps_tdma_du_adj_type = 11;
+			}
+		} else if (result == 1) {
+			if ((BT_INFO_8192E_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+			    ((coex_dm->cur_ps_tdma == 1) ||
+			     (coex_dm->cur_ps_tdma == 2))) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 11) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 1);
+				coex_dm->ps_tdma_du_adj_type = 1;
+			}
+		} else { /* no change */
+			/* Bryant Modify
+			if(wifi_busy != pre_wifi_busy)
+			{
+				pre_wifi_busy = wifi_busy;
+				halbtc8192e1ant_ps_tdma(btcoexist, FORCE_EXEC, true, coex_dm->cur_ps_tdma);
+			}
+			*/
+		}
+
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 9 &&
+		    coex_dm->cur_ps_tdma != 11) {
+			/* recover to previous adjust type */
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		}
+	}
+}
+
+void halbtc8192e1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8192e1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8192e1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8192e1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8192e1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8192e1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 9);
+}
+
+void halbtc8192e1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e1ant_action_wifi_only(btcoexist);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		if (!bt_disabled) {
+		} else {
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+					   NULL);
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+					   NULL);
+		}
+	}
+}
+
+/* *********************************************
+ *
+ *	Software Coex Mechanism start
+ *
+ * ********************************************* */
+
+/* SCO only or SCO+PAN(HS) */
+
+/*
+void halbtc8192e1ant_action_sco(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8192e1ant_action_hid(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8192e1ant_action_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8192e1ant_action_a2dp_pan_hs(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8192e1ant_action_pan_edr(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+}
+
+
+void halbtc8192e1ant_action_pan_hs(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+}
+
+
+void halbtc8192e1ant_action_pan_edr_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8192e1ant_action_pan_edr_hid(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8192e1ant_action_hid_a2dp_pan_edr(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, true);
+}
+
+void halbtc8192e1ant_action_hid_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8192e1ant_sw_mechanism(btcoexist, true);
+}
+
+*/
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8192e1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8192e1ant_action_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8192e1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = false, ap_enable = false, wifi_busy = false,
+				bt_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	if ((!wifi_connected) && (!coex_sta->wifi_is_high_pri_task)) {
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+		   (bt_link_info->a2dp_exist)) {
+		/* SCO/HID/A2DP  busy */
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if ((bt_link_info->pan_exist) || (wifi_busy)) {
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	}
+}
+
+void halbtc8192e1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/* tdma and coex table */
+
+	if (bt_link_info->sco_exist) {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	} else { /* HID */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 6);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	}
+}
+
+void halbtc8192e1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	u8		bt_rssi_state;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	bt_rssi_state = halbtc8192e1ant_bt_rssi_state(2, 28, 0);
+
+	if ((coex_sta->low_priority_rx >= 1000)  &&
+	    (coex_sta->low_priority_rx != 65535))
+		bt_link_info->slave_role = true;
+	else
+		bt_link_info->slave_role = false;
+
+	if (bt_link_info->hid_only) { /* HID */
+		halbtc8192e1ant_action_bt_sco_hid_only_busy(btcoexist,
+				wifi_status);
+		coex_dm->auto_tdma_adjust = false;
+		return;
+	} else if (bt_link_info->a2dp_only) { /* A2DP		 */
+		if (BT_8192E_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status) {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = false;
+		} else {
+			halbtc8192e1ant_tdma_duration_adjust_for_acl(btcoexist,
+					wifi_status);
+#if 0
+			if (coex_sta->cck_lock)
+				halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 3);
+			else
+#endif
+				halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = true;
+		}
+	} else if (((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+		coex_dm->auto_tdma_adjust = false;
+
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	} else if ((bt_link_info->pan_only) || (bt_link_info->hid_exist &&
+		bt_link_info->pan_exist)) { /* PAN(OPP,FTP), HID+PAN(OPP,FTP)			 */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		/* BT no-profile busy (0x9) */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	}
+}
+
+void halbtc8192e1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	/* power save state */
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	halbtc8192e1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8192e1ant_action_wifi_not_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if (BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8192E_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8192e1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8192E_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8192e1ant_action_wifi_not_connected_asso_auth(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist)  || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8192e1ant_action_wifi_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if (BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8192E_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8192e1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8192E_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8192e1ant_action_wifi_connected_specific_packet(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8192e1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	boolean	wifi_busy = false;
+	boolean		scan = false, link = false, roam = false;
+	boolean		under_4way = false, ap_enable = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+	if (under_4way) {
+		halbtc8192e1ant_action_wifi_connected_specific_packet(btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under 4way<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	if (scan || link || roam) {
+		if (scan)
+			halbtc8192e1ant_action_wifi_connected_scan(btcoexist);
+		else
+			halbtc8192e1ant_action_wifi_connected_specific_packet(
+				btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under scan<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* power save state */
+	if (!ap_enable &&
+	    BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status &&
+	    !btcoexist->bt_link_info.hid_only) {
+		if (btcoexist->bt_link_info.a2dp_only) {	/* A2DP */
+			if (!wifi_busy)
+				halbtc8192e1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			else { /* busy */
+				if (coex_sta->scan_ap_num >=
+				    BT_8192E_1ANT_WIFI_NOISY_THRESH)  /* no force LPS, no PS-TDMA, use pure TDMA */
+					halbtc8192e1ant_power_save_state(
+						btcoexist, BTC_PS_WIFI_NATIVE,
+						0x0, 0x0);
+				else
+					halbtc8192e1ant_power_save_state(
+						btcoexist, BTC_PS_LPS_ON, 0x50,
+						0x4);
+			}
+		} else if ((coex_sta->pan_exist == false) &&
+			   (coex_sta->a2dp_exist == false) &&
+			   (coex_sta->hid_exist == false))
+			halbtc8192e1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		else
+			halbtc8192e1ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+	} else
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+
+	/* tdma and coex table */
+	if (!wifi_busy) {
+		if (BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8192e1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8192E_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else if ((BT_8192E_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8192e1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8192E_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+
+			if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60)
+				halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+			else
+				halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+	} else {
+		if (BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8192e1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8192E_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else if ((BT_8192E_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8192e1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8192E_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else {
+			halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+
+			if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60)
+				halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+			else
+				halbtc8192e1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+	}
+}
+
+void halbtc8192e1ant_run_sw_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+
+	algorithm = halbtc8192e1ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+
+	if (halbtc8192e1ant_is_common_action(btcoexist)) {
+
+	} else {
+		switch (coex_dm->cur_algorithm) {
+		case BT_8192E_1ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_sco(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_hid(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_a2dp(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_a2dp_pan_hs(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_pan_edr(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_pan_hs(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_pan_edr_a2dp(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_pan_edr_hid(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_hid_a2dp_pan_edr(btcoexist); */
+			break;
+		case BT_8192E_1ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_action_hid_a2dp(btcoexist); */
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8192e1ant_coex_all_off(btcoexist); */
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8192e1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, bt_hs_on = false;
+	boolean	increase_scan_dev_num = false;
+	boolean	bt_ctrl_agg_buf_size = false;
+	boolean	miracast_plus_bt = false;
+	u8	agg_buf_size = 5;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if ((BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8192E_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist) {
+			halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1,
+						   0, 1);
+			miracast_plus_bt = true;
+		} else {
+			halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0,
+						   0, 0);
+			miracast_plus_bt = false;
+		}
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+
+		if ((bt_link_info->a2dp_exist) &&
+		    (coex_sta->c2h_bt_inquiry_page)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is Inquirying\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e1ant_action_bt_inquiry(btcoexist);
+		} else
+			halbtc8192e1ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	} else {
+		miracast_plus_bt = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+	}
+
+	if ((bt_link_info->bt_link_exist) && (wifi_connected)) {
+		halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1, 0, 1);
+
+		if (bt_link_info->sco_exist)
+			halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, true, 0x5);
+		else
+			halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, true, 0x8);
+
+		halbtc8192e1ant_sw_mechanism(btcoexist, true);
+		halbtc8192e1ant_run_sw_coexist_mechanism(
+			btcoexist);  /* just print debug message */
+	} else {
+		halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+		halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x5);
+
+		halbtc8192e1ant_sw_mechanism(btcoexist, false);
+		halbtc8192e1ant_run_sw_coexist_mechanism(
+			btcoexist); /* just print debug message */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "############# [BTCoex],  BT Is Inquirying\n");
+		BTC_TRACE(trace_buf);
+		halbtc8192e1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8192e1ant_action_hs(btcoexist);
+		return;
+	}
+
+
+	if (!wifi_connected) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is non connected-idle !!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (scan || link || roam) {
+			if (scan)
+				halbtc8192e1ant_action_wifi_not_connected_scan(
+					btcoexist);
+			else
+				halbtc8192e1ant_action_wifi_not_connected_asso_auth(
+					btcoexist);
+		} else
+			halbtc8192e1ant_action_wifi_not_connected(btcoexist);
+	} else	/* wifi LPS/Busy */
+		halbtc8192e1ant_action_wifi_connected(btcoexist);
+}
+
+void halbtc8192e1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+
+	/* sw all off */
+	halbtc8192e1ant_sw_mechanism(btcoexist, false);
+
+	/* halbtc8192e1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8); */
+	halbtc8192e1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	coex_sta->pop_event_cnt = 0;
+}
+
+void halbtc8192e1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean wifi_only)
+{
+	u16	u16tmp = 0;
+	u8	u8tmp = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	/* antenna sw ctrl to bt */
+	halbtc8192e1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, true, false);
+
+	halbtc8192e1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	/* antenna switch control parameter */
+	btcoexist->btc_write_4byte(btcoexist, 0x858, 0x55555555);
+
+	/* coex parameters */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	/* enable PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x40, 0x20);
+	/* enable mailbox interface */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x40);
+	u16tmp |= BIT(9);
+	btcoexist->btc_write_2byte(btcoexist, 0x40, u16tmp);
+
+	/* enable PTA I2C mailbox */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x101);
+	u8tmp |= BIT(4);
+	btcoexist->btc_write_1byte(btcoexist, 0x101, u8tmp);
+
+	/* enable bt clock when wifi is disabled. */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x93);
+	u8tmp |= BIT(0);
+	btcoexist->btc_write_1byte(btcoexist, 0x93, u8tmp);
+	/* enable bt clock when suspend. */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x7);
+	u8tmp |= BIT(0);
+	btcoexist->btc_write_1byte(btcoexist, 0x7, u8tmp);
+}
+
+
+/*
+void halbtc8192e1ant_wifi_off_hw_cfg(IN struct btc_coexist* btcoexist)
+{
+
+
+}
+*/
+
+/* ************************************************************
+ * work around function start with wa_halbtc8192e1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8192e1ant_
+ * ************************************************************ */
+void ex_halbtc8192e1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+#if 0
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x0;
+	u16 u16tmp = 0x0;
+
+	btcoexist->stop_coex_dm = true;
+
+	btcoexist->btc_write_1byte(btcoexist, 0x67, 0x20);
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+	/* set GRAN_BT = 1 */
+	btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+	/* set WLAN_ACT = 0 */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	/*  */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+	if (btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+
+		u8tmp |= 0x1;	/* antenna inverse */
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+	} else {
+		/* for PCIE and SDIO interface, we check efuse 0xc3[6] */
+		if (board_info->single_ant_path == 0) {
+			/* set to S1 */
+			btcoexist->btc_write_4byte(btcoexist, 0x948, 0x280);
+			board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+		} else if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+			u8tmp |= 0x1;	/* antenna inverse */
+			board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+		}
+
+		if (btcoexist->chip_interface == BTC_INTF_PCI)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x384,
+							     u8tmp);
+		else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60,
+							     u8tmp);
+	}
+#endif
+}
+
+void ex_halbtc8192e1ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8192e1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8192e1ant_init_hw_config(btcoexist, wifi_only);
+	btcoexist->stop_coex_dm = false;
+}
+
+void ex_halbtc8192e1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = false;
+
+	halbtc8192e1ant_init_coex_dm(btcoexist);
+
+	halbtc8192e1ant_query_bt_info(btcoexist);
+}
+
+void ex_halbtc8192e1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u32				fw_ver = 0, bt_patch_ver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%d/ 0x%x/ 0x%x(%d)",
+		   "CoexVer/ FwVer/ PatchVer",
+		   glcoex_ver_date_8192e_1ant, glcoex_ver_8192e_1ant, fw_ver,
+		   bt_patch_ver, bt_patch_ver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8192E_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_BT_LINK_INFO);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8192E_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8192e_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (!btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[mechanisms]============");
+		CL_PRINTF(cli_buf);
+
+		ps_tdma_case = coex_dm->cur_ps_tdma;
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n %-35s = %02x %02x %02x %02x %02x case-%d (auto:%d)",
+			   "PS TDMA",
+			   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+			   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+			   coex_dm->ps_tdma_para[4], ps_tdma_case,
+			   coex_dm->auto_tdma_adjust);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ",
+			   "Latest error condition(should be 0)",
+			   coex_dm->error_condition);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ",
+			   "IgnWlanAct",
+			   coex_dm->cur_ignore_wlan_act);
+		CL_PRINTF(cli_buf);
+	}
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc04);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xd04);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x90c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0xc04/ 0xd04/ 0x90c",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x778",
+		   u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x92c);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x930);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x92c/ 0x930",
+		   (u8tmp[0]), u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x4f);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x40/ 0x4f",
+		   u8tmp[0], u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)",
+		   u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(hp rx[31:16]/tx[15:0])",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(lp rx[31:16]/tx[15:0])",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8192E_1ANT == 1)
+	halbtc8192e1ant_monitor_bt_ctr(btcoexist);
+#endif
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+void ex_halbtc8192e1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false,
+					     true);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+
+		halbtc8192e1ant_init_hw_config(btcoexist, false);
+		halbtc8192e1ant_init_coex_dm(btcoexist);
+		halbtc8192e1ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8192e1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8192e1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	u8 u8tmpa, u8tmpb;
+	u32 u32tmp;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_SCAN_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8192e1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+		u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+		u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+			    u32tmp,  u8tmpa, u8tmpb);
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+	}
+
+	if (coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	halbtc8192e1ant_query_bt_info(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8192e1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8192e1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8192e1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8192e1ant_action_wifi_not_connected_scan(
+				btcoexist);
+		else	/* wifi is connected */
+			halbtc8192e1ant_action_wifi_connected_scan(btcoexist);
+	} else if (BTC_SCAN_FINISH == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8192e1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8192e1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8192e1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_ASSOCIATE_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		/* coex_dm->arp_cnt = 0; */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8192e1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8192e1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8192e1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_ASSOCIATE_START == type)
+		halbtc8192e1ant_action_wifi_not_connected_asso_auth(btcoexist);
+	else if (BTC_ASSOCIATE_FINISH == type) {
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+				   &wifi_connected);
+		if (!wifi_connected) /* non-connected scan */
+			halbtc8192e1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8192e1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8192e1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	boolean			wifi_under_b_mode = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x10); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		/* h2c_parameter[0] = 0x1; */
+		h2c_parameter[0] = 0x0;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8192e1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    BTC_PACKET_ARP == type) {
+		if (BTC_PACKET_ARP == type) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], specific Packet ARP notify\n");
+			BTC_TRACE(trace_buf);
+
+			coex_dm->arp_cnt++;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], ARP Packet Count = %d\n",
+				    coex_dm->arp_cnt);
+			BTC_TRACE(trace_buf);
+
+			if (coex_dm->arp_cnt >=
+			    10) /* if APR PKT > 10 after connect, do not go to ActionWifiConnectedSpecificPacket(btcoexist) */
+				coex_sta->wifi_is_high_pri_task = false;
+			else
+				coex_sta->wifi_is_high_pri_task = true;
+		} else {
+			coex_sta->wifi_is_high_pri_task = true;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], specific Packet DHCP or EAPOL notify\n");
+			BTC_TRACE(trace_buf);
+		}
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet [Type = %d] notify\n", type);
+		BTC_TRACE(trace_buf);
+	}
+
+	coex_sta->specific_pkt_period_cnt = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8192e1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8192e1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8192e1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8192e1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8192e1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    ((BTC_PACKET_ARP == type) && (coex_sta->wifi_is_high_pri_task)))
+		halbtc8192e1ant_action_wifi_connected_specific_packet(btcoexist);
+}
+
+void ex_halbtc8192e1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				bt_info = 0;
+	u8				i, rsp_source = 0;
+	boolean				wifi_connected = false;
+	boolean				bt_busy = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8192E_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8192E_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (BT_INFO_SRC_8192E_1ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x20)
+			coex_sta->c2h_bt_page = true;
+		else
+			coex_sta->c2h_bt_page = false;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 - 90;
+		/* coex_sta->bt_info_c2h[rsp_source][3]*2+10; */
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+		if (!coex_sta->bt_tx_rx_mask) {
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x15\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+						  0x3c, 0x15);
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if (coex_sta->bt_info_ext & BIT(1)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8192e1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8192e1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if (coex_sta->bt_info_ext & BIT(3)) {
+			if (!btcoexist->manual_control &&
+			    !btcoexist->stop_coex_dm) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8192e1ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+		}
+#if (BT_AUTO_REPORT_ONLY_8192E_1ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8192e1ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8192E_1ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8192E_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8192E_1ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8192E_1ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8192E_1ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8192E_1ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+	}
+
+	halbtc8192e1ant_update_bt_link_info(btcoexist);
+
+	bt_info = bt_info &
+		0x1f;  /* mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41) */
+
+	if (!(bt_info & BT_INFO_8192E_1ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8192E_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8192E_1ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8192E_1ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8192E_1ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8192E_1ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8192E_1ANT_B_ACL_BUSY) {
+		if (BT_8192E_1ANT_BT_STATUS_ACL_BUSY != coex_dm->bt_status)
+			coex_dm->auto_tdma_adjust = false;
+		coex_dm->bt_status = BT_8192E_1ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8192E_1ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8192E_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8192E_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	halbtc8192e1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8192e1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u32	u32tmp;
+	u8	u8tmpa, u8tmpb, u8tmpc;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+		halbtc8192e1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false,
+					     true);
+
+		halbtc8192e1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		btcoexist->stop_coex_dm = true;
+
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+		u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+		u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x67);
+		u8tmpc = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x, 0x76e=0x%x\n",
+			    u32tmp,  u8tmpa, u8tmpb, u8tmpc);
+		BTC_TRACE(trace_buf);
+
+	}
+}
+
+void ex_halbtc8192e1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8192e1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+	halbtc8192e1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false, true);
+
+	halbtc8192e1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8192e1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8192e1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8192e1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8192e1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+		halbtc8192e1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false,
+					     true);
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+		halbtc8192e1ant_init_hw_config(btcoexist, false);
+		halbtc8192e1ant_init_coex_dm(btcoexist);
+		halbtc8192e1ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8192e1ant_coex_dm_reset(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], *****************Coex DM Reset*****************\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8192e1ant_init_hw_config(btcoexist, false);
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x2, 0xfffff, 0x0); */
+	halbtc8192e1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8192e1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+#if (BT_AUTO_REPORT_ONLY_8192E_1ANT == 0)
+	halbtc8192e1ant_query_bt_info(btcoexist);
+	halbtc8192e1ant_monitor_bt_enable_disable(btcoexist);
+#else
+	halbtc8192e1ant_monitor_bt_ctr(btcoexist);
+	halbtc8192e1ant_monitor_wifi_ctr(btcoexist);
+
+	if (halbtc8192e1ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust)
+
+		halbtc8192e1ant_run_coexist_mechanism(btcoexist);
+
+	coex_sta->specific_pkt_period_cnt++;
+#endif
+}
+
+
+void ex_halbtc8192e1ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata)
+{
+	switch (op_code) {
+	case BTC_DBG_SET_COEX_NORMAL:
+		btcoexist->manual_control = false;
+		halbtc8192e1ant_init_coex_dm(btcoexist);
+		break;
+	case BTC_DBG_SET_COEX_WIFI_ONLY:
+		btcoexist->manual_control = true;
+		halbtc8192e1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		halbtc8192e1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+					9);
+		break;
+	case BTC_DBG_SET_COEX_BT_ONLY:
+		/* todo */
+		break;
+	default:
+		break;
+	}
+}
+
+#endif	/*  #if (RTL8192E_SUPPORT == 1) */
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e1Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e1Ant.h
new file mode 100644
index 000000000..e75127c10
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e1Ant.h
@@ -0,0 +1,226 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8192E_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8192E 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8192E_1ANT				1
+
+#define	BT_INFO_8192E_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8192E_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8192E_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8192E_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8192E_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8192E_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8192E_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8192E_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8192E_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8192E_1ANT		2
+
+#define  BT_8192E_1ANT_WIFI_NOISY_THRESH								30   /* max: 255 */
+
+enum bt_info_src_8192e_1ant {
+	BT_INFO_SRC_8192E_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8192E_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8192E_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8192E_1ANT_MAX
+};
+
+enum bt_8192e_1ant_bt_status {
+	BT_8192E_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8192E_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8192E_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8192E_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8192E_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8192E_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8192e_1ant_wifi_status {
+	BT_8192E_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8192E_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8192E_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8192E_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8192E_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8192E_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8192E_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8192e_1ant_coex_algo {
+	BT_8192E_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8192E_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8192E_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8192E_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8192E_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8192E_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8192E_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8192E_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8192E_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8192E_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8192E_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8192E_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8192e_1ant {
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8192e_1ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	s8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8192E_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8192E_1ANT_MAX];
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_page;				/* Add for win8.1 page out issue */
+	boolean					wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_agg;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_agg;
+
+	boolean					cck_lock;
+	boolean					pre_ccklock;
+	u8					coex_table_type;
+
+	boolean					force_lps_on;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8192e1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8192e1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8192e1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8192e1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8192e1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8192e1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8192e1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8192e1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8192e1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8192e1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8192e1ant_coex_dm_reset(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e1ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata);
+
+#else	/*  #if (RTL8192E_SUPPORT == 1) */
+#define	ex_halbtc8192e1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8192e1ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8192e1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8192e1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8192e1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8192e1ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8192e1ant_halt_notify(btcoexist)
+#define	ex_halbtc8192e1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8192e1ant_coex_dm_reset(btcoexist)
+#define	ex_halbtc8192e1ant_periodical(btcoexist)
+#define	ex_halbtc8192e1ant_display_coex_info(btcoexist)
+#define	ex_halbtc8192e1ant_dbg_control(btcoexist, op_code, op_len, pdata)
+
+#endif
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e2Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e2Ant.c
new file mode 100644
index 000000000..76e0e937d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e2Ant.c
@@ -0,0 +1,3949 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8192E Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "Mp_Precomp.h"
+
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8192E_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8192e_2ant		glcoex_dm_8192e_2ant;
+static struct  coex_dm_8192e_2ant	*coex_dm = &glcoex_dm_8192e_2ant;
+static struct  coex_sta_8192e_2ant		glcoex_sta_8192e_2ant;
+static struct  coex_sta_8192e_2ant	*coex_sta = &glcoex_sta_8192e_2ant;
+
+const char *const glbt_info_src_8192e_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8192e_2ant = 20130912;
+u32	glcoex_ver_8192e_2ant = 0x35;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8192e2ant_
+ * ************************************************************ */
+u8 halbtc8192e2ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8192e2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8192e2ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32	bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		if (!bt_disabled) {
+		} else {
+		}
+	}
+}
+
+u32 halbtc8192e2ant_decide_ra_mask(IN struct btc_coexist *btcoexist,
+				   IN u8 ss_type, IN u32 ra_mask_type)
+{
+	u32	dis_ra_mask = 0x0;
+
+	switch (ra_mask_type) {
+	case 0: /* normal mode */
+		if (ss_type == 2)
+			dis_ra_mask = 0x0;			/* enable 2ss */
+		else
+			dis_ra_mask = 0xfff00000;		/* disable 2ss */
+		break;
+	case 1: /* disable cck 1/2 */
+		if (ss_type == 2)
+			dis_ra_mask = 0x00000003;		/* enable 2ss */
+		else
+			dis_ra_mask = 0xfff00003;		/* disable 2ss */
+		break;
+	case 2: /* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		if (ss_type == 2)
+			dis_ra_mask = 0x0001f1f7;		/* enable 2ss */
+		else
+			dis_ra_mask = 0xfff1f1f7;		/* disable 2ss */
+		break;
+	default:
+		break;
+	}
+
+	return dis_ra_mask;
+}
+
+void halbtc8192e2ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8192e2ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8192e2ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8192e2ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8192e2ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	u32	dis_ra_mask = 0x0;
+
+	coex_dm->cur_ra_mask_type = ra_mask_type;
+	dis_ra_mask = halbtc8192e2ant_decide_ra_mask(btcoexist,
+			coex_dm->cur_ss_type, ra_mask_type);
+	halbtc8192e2ant_update_ra_mask(btcoexist, force_exec, dis_ra_mask);
+
+	halbtc8192e2ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8192e2ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8192e2ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8192e2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8192e2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_hp_txrx, reg_hp_tx, reg_hp_tx, reg_hp_rx, reg_hp_rx);
+	BTC_TRACE(trace_buf);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_lp_txrx, reg_lp_tx, reg_lp_tx, reg_lp_rx, reg_lp_rx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+}
+
+void halbtc8192e2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+boolean halbtc8192e2ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean	wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean	wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void halbtc8192e2ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8192e2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	struct  btc_stack_info	*stack_info = &btcoexist->stack_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8192E_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_2ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_SCO_PAN;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (stack_info->num_of_hid >= 2) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID*2 + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8192E_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_SCO_PAN;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8192E_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8192E_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8192e2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8192e2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				       IN u8 dec_bt_pwr_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = dec_bt_pwr_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x62, 1, h2c_parameter);
+}
+
+void halbtc8192e2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN u8 dec_bt_pwr_lvl)
+{
+	coex_dm->cur_bt_dec_pwr_lvl = dec_bt_pwr_lvl;
+
+	if (!force_exec) {
+#if 0	/* work around, avoid h2c command fail. */
+		if (coex_dm->pre_bt_dec_pwr_lvl == coex_dm->cur_bt_dec_pwr_lvl)
+			return;
+#endif
+	}
+	halbtc8192e2ant_set_fw_dec_bt_pwr(btcoexist,
+					  coex_dm->cur_bt_dec_pwr_lvl);
+
+	coex_dm->pre_bt_dec_pwr_lvl = coex_dm->cur_bt_dec_pwr_lvl;
+}
+
+void halbtc8192e2ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8192e2ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8192e2ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8192e2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+			      IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8192e2ant_set_fw_dac_swing_level(btcoexist,
+					       coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+void halbtc8192e2ant_set_sw_rf_rx_lpf_corner(IN struct btc_coexist *btcoexist,
+		IN boolean rx_rf_shrink_on)
+{
+	if (rx_rf_shrink_on) {
+		/* Shrink RF Rx LPF corner */
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Shrink RF Rx LPF corner!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff,
+					  0xffffc);
+	} else {
+		/* Resume RF Rx LPF corner */
+		/* After initialized, we can use coex_dm->bt_rf_0x1e_backup */
+		if (btcoexist->initilized) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Resume RF Rx LPF corner!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+					  0xfffff, coex_dm->bt_rf_0x1e_backup);
+		}
+	}
+}
+
+void halbtc8192e2ant_rf_shrink(IN struct btc_coexist *btcoexist,
+		       IN boolean force_exec, IN boolean rx_rf_shrink_on)
+{
+	coex_dm->cur_rf_rx_lpf_shrink = rx_rf_shrink_on;
+
+	if (!force_exec) {
+		if (coex_dm->pre_rf_rx_lpf_shrink ==
+		    coex_dm->cur_rf_rx_lpf_shrink)
+			return;
+	}
+	halbtc8192e2ant_set_sw_rf_rx_lpf_corner(btcoexist,
+						coex_dm->cur_rf_rx_lpf_shrink);
+
+	coex_dm->pre_rf_rx_lpf_shrink = coex_dm->cur_rf_rx_lpf_shrink;
+}
+
+void halbtc8192e2ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf7;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf8;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf9;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8192e2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8192e2ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8192e2ant_set_dac_swing_reg(IN struct btc_coexist *btcoexist,
+				       IN u32 level)
+{
+	u8	val = (u8)level;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Write SwDacSwing = 0x%x\n", level);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x883, 0x3e, val);
+}
+
+void halbtc8192e2ant_set_sw_full_time_dac_swing(IN struct btc_coexist
+		*btcoexist, IN boolean sw_dac_swing_on, IN u32 sw_dac_swing_lvl)
+{
+	if (sw_dac_swing_on)
+		halbtc8192e2ant_set_dac_swing_reg(btcoexist, sw_dac_swing_lvl);
+	else
+		halbtc8192e2ant_set_dac_swing_reg(btcoexist, 0x18);
+}
+
+
+void halbtc8192e2ant_dac_swing(IN struct btc_coexist *btcoexist,
+	IN boolean force_exec, IN boolean dac_swing_on, IN u32 dac_swing_lvl)
+{
+	coex_dm->cur_dac_swing_on = dac_swing_on;
+	coex_dm->cur_dac_swing_lvl = dac_swing_lvl;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_dac_swing_on == coex_dm->cur_dac_swing_on) &&
+		    (coex_dm->pre_dac_swing_lvl ==
+		     coex_dm->cur_dac_swing_lvl))
+			return;
+	}
+	delay_ms(30);
+	halbtc8192e2ant_set_sw_full_time_dac_swing(btcoexist, dac_swing_on,
+			dac_swing_lvl);
+
+	coex_dm->pre_dac_swing_on = coex_dm->cur_dac_swing_on;
+	coex_dm->pre_dac_swing_lvl = coex_dm->cur_dac_swing_lvl;
+}
+
+void halbtc8192e2ant_set_adc_back_off(IN struct btc_coexist *btcoexist,
+				      IN boolean adc_back_off)
+{
+	if (adc_back_off) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc05, 0x30, 0x3);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc05, 0x30, 0x1);
+	}
+}
+
+void halbtc8192e2ant_adc_back_off(IN struct btc_coexist *btcoexist,
+			  IN boolean force_exec, IN boolean adc_back_off)
+{
+	coex_dm->cur_adc_back_off = adc_back_off;
+
+	if (!force_exec) {
+		if (coex_dm->pre_adc_back_off == coex_dm->cur_adc_back_off)
+			return;
+	}
+	halbtc8192e2ant_set_adc_back_off(btcoexist, coex_dm->cur_adc_back_off);
+
+	coex_dm->pre_adc_back_off = coex_dm->cur_adc_back_off;
+}
+
+void halbtc8192e2ant_set_agc_table(IN struct btc_coexist *btcoexist,
+				   IN boolean agc_table_en)
+{
+	/* =================BB AGC Gain Table */
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x0a1A0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x091B0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x081C0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x071D0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x061E0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x051F0001);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xaa1A0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa91B0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa81C0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa71D0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa61E0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa51F0001);
+	}
+}
+
+void halbtc8192e2ant_agc_table(IN struct btc_coexist *btcoexist,
+			       IN boolean force_exec, IN boolean agc_table_en)
+{
+	coex_dm->cur_agc_table_en = agc_table_en;
+
+	if (!force_exec) {
+		if (coex_dm->pre_agc_table_en == coex_dm->cur_agc_table_en)
+			return;
+	}
+	halbtc8192e2ant_set_agc_table(btcoexist, agc_table_en);
+
+	coex_dm->pre_agc_table_en = coex_dm->cur_agc_table_en;
+}
+
+void halbtc8192e2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8192e2ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8192e2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8192e2ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	switch (type) {
+	case 0:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5ffb5ffb, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec,
+				   0x5fdf5fdf, 0x5fdb5fdb, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8192e2ant_coex_table(btcoexist, force_exec,
+				   0xdfffdfff, 0x5ffb5ffb, 0xffffff, 0x3);
+		break;
+
+	default:
+		break;
+	}
+}
+
+void halbtc8192e2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable) {
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8192e2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8192e2ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8192e2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+
+	h2c_parameter[0] = byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = byte5;
+
+	coex_dm->ps_tdma_para[0] = byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8192e2ant_sw_mechanism1(IN struct btc_coexist *btcoexist,
+			   IN boolean shrink_rx_lpf, IN boolean low_penalty_ra,
+			   IN boolean limited_dig, IN boolean bt_lna_constrain)
+{
+	/*
+	u32	wifi_bw;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if(BTC_WIFI_BW_HT40 != wifi_bw)
+	{
+		if (shrink_rx_lpf)
+			shrink_rx_lpf = false;
+	}
+	*/
+
+	halbtc8192e2ant_rf_shrink(btcoexist, NORMAL_EXEC, shrink_rx_lpf);
+	/* halbtc8192e2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra); */
+}
+
+void halbtc8192e2ant_sw_mechanism2(IN struct btc_coexist *btcoexist,
+			   IN boolean agc_table_shift, IN boolean adc_back_off,
+			   IN boolean sw_dac_swing, IN u32 dac_swing_lvl)
+{
+	halbtc8192e2ant_agc_table(btcoexist, NORMAL_EXEC, agc_table_shift);
+	/* halbtc8192e2ant_adc_back_off(btcoexist, NORMAL_EXEC, adc_back_off); */
+	halbtc8192e2ant_dac_swing(btcoexist, NORMAL_EXEC, sw_dac_swing,
+				  dac_swing_lvl);
+}
+
+void halbtc8192e2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	u32			u32tmp = 0;
+
+	if (init_hwcfg) {
+		btcoexist->btc_write_1byte(btcoexist, 0x944, 0x24);
+		btcoexist->btc_write_4byte(btcoexist, 0x930, 0x700700);
+		if (btcoexist->chip_interface == BTC_INTF_USB)
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30430004);
+		else
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30030004);
+
+		/* 0x4c[27][24]='00', Set Antenna to BB */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(24);
+		u32tmp &= ~BIT(27);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+	} else if (wifi_off) {
+		if (btcoexist->chip_interface == BTC_INTF_USB)
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30430004);
+		else
+			btcoexist->btc_write_4byte(btcoexist, 0x64, 0x30030004);
+
+		/* 0x4c[27][24]='11', Set Antenna to BT, 0x64[8:7]=0, 0x64[2]=1 */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp |= BIT(24);
+		u32tmp |= BIT(27);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+	}
+
+	/* ext switch setting */
+	switch (ant_pos_type) {
+	case BTC_ANT_PATH_WIFI:
+		btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x4);
+		break;
+	case BTC_ANT_PATH_BT:
+		btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x20);
+		break;
+	default:
+	case BTC_ANT_PATH_PTA:
+		btcoexist->btc_write_1byte(btcoexist, 0x92c, 0x4);
+		break;
+	}
+}
+
+void halbtc8192e2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+	if (turn_on) {
+		switch (type) {
+		case 1:
+		default:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1a, 0x1a, 0xe1, 0x90);
+			break;
+		case 2:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x12, 0x12, 0xe1, 0x90);
+			break;
+		case 3:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1, 0x90);
+			break;
+		case 4:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0xf1, 0x90);
+			break;
+		case 5:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1a, 0x1a, 0x60, 0x90);
+			break;
+		case 6:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x12, 0x12, 0x60, 0x90);
+			break;
+		case 7:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x70, 0x90);
+			break;
+		case 8:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x10, 0x3, 0x70, 0x90);
+			break;
+		case 9:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1a, 0x1a, 0xe1, 0x10);
+			break;
+		case 10:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x12, 0x12, 0xe1, 0x10);
+			break;
+		case 11:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1, 0x10);
+			break;
+		case 12:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0xf1, 0x10);
+			break;
+		case 13:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1a, 0x1a, 0xe0, 0x10);
+			break;
+		case 14:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x12, 0x12, 0xe0, 0x10);
+			break;
+		case 15:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf0, 0x10);
+			break;
+		case 16:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x12, 0x3, 0xf0, 0x10);
+			break;
+		case 17:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x20, 0x03, 0x10, 0x10);
+			break;
+		case 18:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x5, 0x5, 0xe1, 0x90);
+			break;
+		case 19:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0xe1, 0x90);
+			break;
+		case 20:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0x60, 0x90);
+			break;
+		case 21:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x03, 0x70, 0x90);
+			break;
+		case 71:
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1a, 0x1a, 0xe1, 0x90);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		default:
+		case 0:  /* ANT2PTA, 0x778=1 */
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8192e2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_PTA, false, false);
+			break;
+		case 1:  /* ANT2BT, 0x778=3 */
+			halbtc8192e2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x8, 0x0);
+			delay_ms(5);
+			halbtc8192e2ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_BT, false, false);
+			break;
+
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8192e2ant_set_switch_ss_type(IN struct btc_coexist *btcoexist,
+					IN u8 ss_type)
+{
+	u8	mimo_ps = BTC_MIMO_PS_DYNAMIC;
+	u32	dis_ra_mask = 0x0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], REAL set SS Type = %d\n", ss_type);
+	BTC_TRACE(trace_buf);
+
+	dis_ra_mask = halbtc8192e2ant_decide_ra_mask(btcoexist, ss_type,
+			coex_dm->cur_ra_mask_type);
+	halbtc8192e2ant_update_ra_mask(btcoexist, FORCE_EXEC, dis_ra_mask);
+
+	if (ss_type == 1) {
+		halbtc8192e2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);
+		/* switch ofdm path */
+		btcoexist->btc_write_1byte(btcoexist, 0xc04, 0x11);
+		btcoexist->btc_write_1byte(btcoexist, 0xd04, 0x1);
+		btcoexist->btc_write_4byte(btcoexist, 0x90c, 0x81111111);
+		/* switch cck patch */
+		/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0xe77, 0x4, 0x1); */
+		/* btcoexist->btc_write_1byte(btcoexist, 0xa07, 0x81); */
+		mimo_ps = BTC_MIMO_PS_STATIC;
+	} else if (ss_type == 2) {
+		halbtc8192e2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+		btcoexist->btc_write_1byte(btcoexist, 0xc04, 0x33);
+		btcoexist->btc_write_1byte(btcoexist, 0xd04, 0x3);
+		btcoexist->btc_write_4byte(btcoexist, 0x90c, 0x81121313);
+		/* remove, if 0xe77[2]=0x0 then CCK will fail, advised by Jenyu */
+		/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0xe77, 0x4, 0x0); */
+		/* btcoexist->btc_write_1byte(btcoexist, 0xa07, 0x41); */
+		mimo_ps = BTC_MIMO_PS_DYNAMIC;
+	}
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_SEND_MIMO_PS,
+			   &mimo_ps);	/* set rx 1ss or 2ss */
+}
+
+void halbtc8192e2ant_switch_ss_type(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 new_ss_type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s Switch SS Type = %d\n",
+		    (force_exec ? "force to" : ""), new_ss_type);
+	BTC_TRACE(trace_buf);
+	coex_dm->cur_ss_type = new_ss_type;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ss_type == coex_dm->cur_ss_type)
+			return;
+	}
+	halbtc8192e2ant_set_switch_ss_type(btcoexist, coex_dm->cur_ss_type);
+
+	coex_dm->pre_ss_type = coex_dm->cur_ss_type;
+}
+
+void halbtc8192e2ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* fw all off */
+	halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8192e2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+
+	halbtc8192e2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8192e2ant_dec_bt_pwr(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+	halbtc8192e2ant_switch_ss_type(btcoexist, FORCE_EXEC, 2);
+
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+void halbtc8192e2ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	boolean	low_pwr_disable = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+			   &low_pwr_disable);
+
+	halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+boolean halbtc8192e2ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+	boolean			bt_hs_on = false, low_pwr_disable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (bt_link_info->sco_exist || bt_link_info->hid_exist)
+		halbtc8192e2ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 0, 0, 0);
+	else
+		halbtc8192e2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+	if (!wifi_connected) {
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non-connected idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		if ((BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		     coex_dm->bt_status) ||
+		    (BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE ==
+		     coex_dm->bt_status)) {
+			halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC,
+						       2);
+			halbtc8192e2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+		} else {
+			halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC,
+						       1);
+			halbtc8192e2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+		}
+
+		halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8192e2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8192e2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		common = true;
+	} else {
+		if (BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status) {
+			low_pwr_disable = false;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC,
+						       2);
+			halbtc8192e2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+			halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 6);
+			halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else if (BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE ==
+			   coex_dm->bt_status) {
+			low_pwr_disable = true;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+
+			if (bt_hs_on)
+				return false;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+
+			halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC,
+						       2);
+			halbtc8192e2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+			halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 6);
+			halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else {
+			low_pwr_disable = true;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+
+			if (wifi_busy) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				common = false;
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+
+				halbtc8192e2ant_switch_ss_type(btcoexist,
+							       NORMAL_EXEC, 1);
+				halbtc8192e2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+				halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 21);
+				halbtc8192e2ant_fw_dac_swing_lvl(btcoexist,
+							 NORMAL_EXEC, 6);
+				halbtc8192e2ant_dec_bt_pwr(btcoexist,
+							   NORMAL_EXEC, 0);
+				halbtc8192e2ant_sw_mechanism1(btcoexist, false,
+						      false, false, false);
+				halbtc8192e2ant_sw_mechanism2(btcoexist, false,
+						      false, false, 0x18);
+				common = true;
+			}
+		}
+	}
+
+	return common;
+}
+void halbtc8192e2ant_tdma_duration_adjust(IN struct btc_coexist *btcoexist,
+		IN boolean sco_hid, IN boolean tx_pause, IN u8 max_interval)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0;
+
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+		{
+			if (sco_hid) {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					} else if (max_interval == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (max_interval == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					} else if (max_interval == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (max_interval == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			} else {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (max_interval == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (max_interval == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (max_interval == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (max_interval == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					}
+				}
+			}
+		}
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* accquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (max_interval == 1) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 71) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 13);
+					coex_dm->ps_tdma_du_adj_type = 13;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 71);
+					coex_dm->ps_tdma_du_adj_type = 71;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 9);
+					coex_dm->ps_tdma_du_adj_type = 9;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 71) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 71);
+						coex_dm->ps_tdma_du_adj_type =
+							71;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					}
+				}
+			}
+		} else if (max_interval == 2) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					}
+				}
+			}
+		} else if (max_interval == 3) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8192e2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8192e2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			}
+		}
+	}
+
+	/* if current PsTdma not match with the recorded one (when scan, dhcp...), */
+	/* then we have to adjust it back to the previous record one. */
+	if (coex_dm->cur_ps_tdma != coex_dm->ps_tdma_du_adj_type) {
+		boolean	scan = false, link = false, roam = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], PsTdma type dismatch!!!, cur_ps_tdma=%d, recordPsTdma=%d\n",
+			    coex_dm->cur_ps_tdma, coex_dm->ps_tdma_du_adj_type);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (!scan && !link && !roam)
+			halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+}
+
+/* SCO only or SCO+PAN(HS) */
+void halbtc8192e2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	u8	wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+	u32	wifi_bw;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+
+	halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x6);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x6);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x6);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x6);
+		}
+	}
+}
+
+void halbtc8192e2ant_action_sco_pan(IN struct btc_coexist *btcoexist)
+{
+	u8	wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+	u32	wifi_bw;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+
+	halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 10);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 10);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x6);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x6);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x6);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x6);
+		}
+	}
+}
+
+void halbtc8192e2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	u8	wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32	wifi_bw;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+	}
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8192e2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	boolean		long_dist = false;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW ||
+	     bt_rssi_state == BTC_RSSI_STATE_STAY_LOW) &&
+	    (wifi_rssi_state == BTC_RSSI_STATE_LOW ||
+	     wifi_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], A2dp, wifi/bt rssi both LOW!!\n");
+		BTC_TRACE(trace_buf);
+		long_dist = true;
+	}
+	if (long_dist) {
+		halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 2);
+		halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true,
+					   0x4);
+	} else {
+		halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);
+		halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	}
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (long_dist)
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	else
+		halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+
+	if (long_dist) {
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 17);
+		coex_dm->auto_tdma_adjust = false;
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	} else {
+		if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			halbtc8192e2ant_tdma_duration_adjust(btcoexist, false,
+							     true, 1);
+			halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+			   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+			halbtc8192e2ant_tdma_duration_adjust(btcoexist, false,
+							     false, 1);
+			halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+			   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_tdma_duration_adjust(btcoexist, false,
+							     false, 1);
+			halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+		}
+	}
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8192e2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false, true, 2);
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false, false,
+						     2);
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false, false,
+						     2);
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+	}
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x6);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x6);
+		}
+	}
+}
+
+void halbtc8192e2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 1);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 1);
+	}
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* PAN(HS) only */
+void halbtc8192e2ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW))
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+		 (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM))
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		 (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+	halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* PAN(EDR)+A2DP */
+void halbtc8192e2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false, true, 3);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false, false,
+						     3);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, false, false,
+						     3);
+	}
+
+	/* sw mechanism	 */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8192e2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 10);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+		halbtc8192e2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 10);
+	}
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8192e2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8192e2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, true, true, 3);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, true, false, 3);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, true, false, 3);
+	}
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8192e2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8192e2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8192e2ant_bt_rssi_state(3, 34, 42);
+
+	halbtc8192e2ant_switch_ss_type(btcoexist, NORMAL_EXEC, 1);
+	halbtc8192e2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, true, true, 2);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, true, false, 2);
+	} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8192e2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+		halbtc8192e2ant_tdma_duration_adjust(btcoexist, true, false, 2);
+	}
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8192e2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8192e2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8192e2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	algorithm = halbtc8192e2ant_action_algorithm(btcoexist);
+	if (coex_sta->c2h_bt_inquiry_page &&
+	    (BT_8192E_2ANT_COEX_ALGO_PANHS != algorithm)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8192e2ant_action_bt_inquiry(btcoexist);
+		return;
+	}
+
+	coex_dm->cur_algorithm = algorithm;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Algorithm = %d\n",
+		    coex_dm->cur_algorithm);
+	BTC_TRACE(trace_buf);
+
+	if (halbtc8192e2ant_is_common_action(btcoexist)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant common.\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		if (coex_dm->cur_algorithm != coex_dm->pre_algorithm) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], pre_algorithm=%d, cur_algorithm=%d\n",
+				coex_dm->pre_algorithm, coex_dm->cur_algorithm);
+			BTC_TRACE(trace_buf);
+			coex_dm->auto_tdma_adjust = false;
+		}
+		switch (coex_dm->cur_algorithm) {
+		case BT_8192E_2ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_sco(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_SCO_PAN:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO+PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_sco_pan(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_hid(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_a2dp(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_a2dp_pan_hs(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_pan_edr(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_pan_hs(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_pan_edr_a2dp(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_pan_edr_hid(btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_hid_a2dp_pan_edr(
+				btcoexist);
+			break;
+		case BT_8192E_2ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8192e2ant_action_hid_a2dp(btcoexist);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = unknown!!\n");
+			BTC_TRACE(trace_buf);
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8192e2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up)
+{
+	u16	u16tmp = 0;
+	u8	u8tmp = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	if (back_up) {
+		/* backup rf 0x1e value */
+		coex_dm->bt_rf_0x1e_backup =
+			btcoexist->btc_get_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+						  0xfffff);
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	}
+
+	/* antenna sw ctrl to bt */
+	halbtc8192e2ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, true, false);
+
+	halbtc8192e2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	/* antenna switch control parameter */
+	btcoexist->btc_write_4byte(btcoexist, 0x858, 0x55555555);
+
+	/* coex parameters */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x3);
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	/* enable PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x40, 0x20);
+	/* enable mailbox interface */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x40);
+	u16tmp |= BIT(9);
+	btcoexist->btc_write_2byte(btcoexist, 0x40, u16tmp);
+
+	/* enable PTA I2C mailbox */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x101);
+	u8tmp |= BIT(4);
+	btcoexist->btc_write_1byte(btcoexist, 0x101, u8tmp);
+
+	/* enable bt clock when wifi is disabled. */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x93);
+	u8tmp |= BIT(0);
+	btcoexist->btc_write_1byte(btcoexist, 0x93, u8tmp);
+	/* enable bt clock when suspend. */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x7);
+	u8tmp |= BIT(0);
+	btcoexist->btc_write_1byte(btcoexist, 0x7, u8tmp);
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8192e2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8192e2ant_
+ * ************************************************************ */
+void ex_halbtc8192e2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8192e2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8192e2ant_init_hw_config(btcoexist, true);
+}
+
+void ex_halbtc8192e2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8192e2ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8192e2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_stack_info		*stack_info = &btcoexist->stack_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fw_ver = 0, bt_patch_ver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%d/ 0x%x/ 0x%x(%d)",
+		   "CoexVer/ FwVer/ PatchVer",
+		   glcoex_ver_date_8192e_2ant, glcoex_ver_8192e_2ant, fw_ver,
+		   bt_patch_ver, bt_patch_ver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   stack_info->sco_exist, stack_info->hid_exist,
+		   stack_info->pan_exist, stack_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_BT_LINK_INFO);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8192E_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8192e_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ", "SS Type",
+		   coex_dm->cur_ss_type);
+	CL_PRINTF(cli_buf);
+
+	/* Sw mechanism	 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Sw mechanism]============");
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ",
+		   "SM1[ShRf/ LpRA/ LimDig]",
+		   coex_dm->cur_rf_rx_lpf_shrink, coex_dm->cur_low_penalty_ra,
+		   coex_dm->limited_dig);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ",
+		   "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]",
+		   coex_dm->cur_agc_table_en, coex_dm->cur_adc_back_off,
+		   coex_dm->cur_dac_swing_on, coex_dm->cur_dac_swing_lvl);
+	CL_PRINTF(cli_buf);
+
+	/* Fw mechanism		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Fw mechanism]============");
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (auto:%d)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   coex_dm->auto_tdma_adjust);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "DecBtPwr/ IgnWlanAct",
+		   coex_dm->cur_bt_dec_pwr_lvl, coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x",
+		   "RF-A, 0x1e initVal",
+		   coex_dm->bt_rf_0x1e_backup);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "backup ARFR1/ARFR2/RL/AMaxTime",
+		   coex_dm->backup_arfr_cnt1, coex_dm->backup_arfr_cnt2,
+		   coex_dm->backup_retry_limit,
+		   coex_dm->backup_ampdu_max_time);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "0x430/0x434/0x42a/0x456",
+		   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc04);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xd04);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x90c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0xc04/ 0xd04/ 0x90c",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x778",
+		   u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x92c);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x930);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x92c/ 0x930",
+		   (u8tmp[0]), u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x4f);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x40/ 0x4f",
+		   u8tmp[0], u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)",
+		   u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(hp rx[31:16]/tx[15:0])",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(lp rx[31:16]/tx[15:0])",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8192E_2ANT == 1)
+	halbtc8192e2ant_monitor_bt_ctr(btcoexist);
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8192e2ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		halbtc8192e2ant_coex_all_off(btcoexist);
+		halbtc8192e2ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false,
+					     true);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+	}
+}
+
+void ex_halbtc8192e2ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8192e2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	if (BTC_SCAN_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_SCAN_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8192e2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	if (BTC_ASSOCIATE_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_ASSOCIATE_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8192e2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] = 0x1;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8192e2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	if (type == BTC_PACKET_DHCP) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], DHCP Packet notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8192e2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			bt_info = 0;
+	u8			i, rsp_source = 0;
+	boolean			bt_busy = false, limited_dig = false;
+	boolean			wifi_connected = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8192E_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8192E_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (BT_INFO_SRC_8192E_2ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if ((coex_sta->bt_info_ext & BIT(1))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8192e2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8192e2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if ((coex_sta->bt_info_ext & BIT(3))) {
+			if (!btcoexist->manual_control &&
+			    !btcoexist->stop_coex_dm) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8192e2ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+		}
+
+#if (BT_AUTO_REPORT_ONLY_8192E_2ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8192e2ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8192E_2ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8192E_2ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8192E_2ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8192E_2ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8192E_2ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8192E_2ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+	}
+
+	halbtc8192e2ant_update_bt_link_info(btcoexist);
+
+	if (!(bt_info & BT_INFO_8192E_2ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8192E_2ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8192E_2ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8192E_2ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8192E_2ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8192E_2ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8192E_2ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8192E_2ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8192E_2ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status)) {
+		bt_busy = true;
+		limited_dig = true;
+	} else {
+		bt_busy = false;
+		limited_dig = false;
+	}
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	coex_dm->limited_dig = limited_dig;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_LIMITED_DIG, &limited_dig);
+
+	halbtc8192e2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8192e2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8192e2ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false, true);
+	halbtc8192e2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+	ex_halbtc8192e2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+}
+
+void ex_halbtc8192e2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+#if (BT_AUTO_REPORT_ONLY_8192E_2ANT == 0)
+	halbtc8192e2ant_query_bt_info(btcoexist);
+	halbtc8192e2ant_monitor_bt_ctr(btcoexist);
+	halbtc8192e2ant_monitor_bt_enable_disable(btcoexist);
+#else
+	if (halbtc8192e2ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust)
+		halbtc8192e2ant_run_coexist_mechanism(btcoexist);
+#endif
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e2Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e2Ant.h
new file mode 100644
index 000000000..5a4786a5e
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8192e2Ant.h
@@ -0,0 +1,190 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8192E_SUPPORT == 1)
+/* *******************************************
+ * The following is for 8192E 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8192E_2ANT				0
+
+#define	BT_INFO_8192E_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8192E_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8192E_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8192E_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8192E_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8192E_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8192E_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8192E_2ANT_B_CONNECTION				BIT(0)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8192E_2ANT		2
+
+enum bt_info_src_8192e_2ant {
+	BT_INFO_SRC_8192E_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8192E_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8192E_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8192E_2ANT_MAX
+};
+
+enum bt_8192e_2ant_bt_status {
+	BT_8192E_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8192E_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8192E_2ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8192E_2ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8192E_2ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8192E_2ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8192E_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8192e_2ant_coex_algo {
+	BT_8192E_2ANT_COEX_ALGO_UNDEFINED		= 0x0,
+	BT_8192E_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8192E_2ANT_COEX_ALGO_SCO_PAN			= 0x2,
+	BT_8192E_2ANT_COEX_ALGO_HID				= 0x3,
+	BT_8192E_2ANT_COEX_ALGO_A2DP			= 0x4,
+	BT_8192E_2ANT_COEX_ALGO_A2DP_PANHS		= 0x5,
+	BT_8192E_2ANT_COEX_ALGO_PANEDR			= 0x6,
+	BT_8192E_2ANT_COEX_ALGO_PANHS			= 0x7,
+	BT_8192E_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x8,
+	BT_8192E_2ANT_COEX_ALGO_PANEDR_HID		= 0x9,
+	BT_8192E_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0xa,
+	BT_8192E_2ANT_COEX_ALGO_HID_A2DP		= 0xb,
+	BT_8192E_2ANT_COEX_ALGO_MAX				= 0xc
+};
+
+struct coex_dm_8192e_2ant {
+	/* fw mechanism */
+	u8		pre_bt_dec_pwr_lvl;
+	u8		cur_bt_dec_pwr_lvl;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		reset_tdma_adjust;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	u32		bt_rf_0x1e_backup;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u8		pre_ss_type;
+	u8		cur_ss_type;
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		cur_ra_mask_type;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+};
+
+struct coex_sta_8192e_2ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	u8					bt_rssi;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8192E_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8192E_2ANT_MAX];
+	boolean					c2h_bt_inquiry_page;
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8192e2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8192e2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8192e2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8192e2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8192e2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8192e2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8192e2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8192e2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8192e2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8192e2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else	/*  #if (RTL8192E_SUPPORT == 1) */
+#define	ex_halbtc8192e2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8192e2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8192e2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8192e2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8192e2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8192e2ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8192e2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8192e2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8192e2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8192e2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8192e2ant_halt_notify(btcoexist)
+#define	ex_halbtc8192e2ant_periodical(btcoexist)
+#define	ex_halbtc8192e2ant_display_coex_info(btcoexist)
+
+#endif
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b1Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b1Ant.c
new file mode 100644
index 000000000..81071fb9a
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b1Ant.c
@@ -0,0 +1,4623 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8703B Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "Mp_Precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8703B_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8703b_1ant		glcoex_dm_8703b_1ant;
+static struct  coex_dm_8703b_1ant	*coex_dm = &glcoex_dm_8703b_1ant;
+static struct  coex_sta_8703b_1ant		glcoex_sta_8703b_1ant;
+static struct  coex_sta_8703b_1ant	*coex_sta = &glcoex_sta_8703b_1ant;
+static struct  psdscan_sta_8703b_1ant	gl_psd_scan_8703b_1ant;
+static struct  psdscan_sta_8703b_1ant *psd_scan = &gl_psd_scan_8703b_1ant;
+
+
+const char *const glbt_info_src_8703b_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8703b_1ant = 20151214;
+u32	glcoex_ver_8703b_1ant = 0x07;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8703b1ant_
+ * ************************************************************ */
+u8 halbtc8703b1ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8703b1ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8703b1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8703b1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8703b1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8703b1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8703b1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8703b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8703b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8703b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8703b1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8703b1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8703b1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8703b1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8703b1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+void halbtc8703b1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u8		num_of_bt_counter_chk = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS */
+	/* if (! (btcoexist->btc_read_1byte(btcoexist, 0x76e) & 0x8) ) */
+
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if ((coex_sta->low_priority_tx > 1150)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	if ((coex_sta->low_priority_rx >= 950)  && (!coex_sta->under_ips)
+	    && (coex_sta->low_priority_rx >=
+		coex_sta->low_priority_tx)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		bt_link_info->slave_role = true;
+	else
+		bt_link_info->slave_role = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\n",
+		    reg_hp_rx, reg_hp_tx, reg_lp_rx, reg_lp_tx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	if ((reg_hp_tx == 0) && (reg_hp_rx == 0) && (reg_lp_tx == 0) &&
+	    (reg_lp_rx == 0)) {
+		num_of_bt_counter_chk++;
+		if (num_of_bt_counter_chk >= 3) {
+			halbtc8703b1ant_query_bt_info(btcoexist);
+			num_of_bt_counter_chk = 0;
+		}
+	}
+}
+
+
+void halbtc8703b1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+	s32	wifi_rssi = 0;
+	boolean wifi_busy = false, wifi_under_b_mode = false;
+	static u8 cck_lock_counter = 0;
+	u32	total_cnt;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+			   &wifi_under_b_mode);
+
+	if (coex_sta->under_ips) {
+		coex_sta->crc_ok_cck = 0;
+		coex_sta->crc_ok_11g = 0;
+		coex_sta->crc_ok_11n = 0;
+		coex_sta->crc_ok_11n_agg = 0;
+
+		coex_sta->crc_err_cck = 0;
+		coex_sta->crc_err_11g = 0;
+		coex_sta->crc_err_11n = 0;
+		coex_sta->crc_err_11n_agg = 0;
+	} else {
+		coex_sta->crc_ok_cck	= btcoexist->btc_read_4byte(btcoexist,
+					  0xf88);
+		coex_sta->crc_ok_11g	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf94);
+		coex_sta->crc_ok_11n	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf90);
+		coex_sta->crc_ok_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					   0xfb8);
+
+		coex_sta->crc_err_cck	 = btcoexist->btc_read_4byte(btcoexist,
+					   0xf84);
+		coex_sta->crc_err_11g	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf96);
+		coex_sta->crc_err_11n	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf92);
+		coex_sta->crc_err_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					    0xfba);
+	}
+
+
+	/* reset counter */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xf16, 0x1, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xf16, 0x1, 0x0);
+
+	if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+		total_cnt = coex_sta->crc_ok_cck + coex_sta->crc_ok_11g +
+			    coex_sta->crc_ok_11n +
+			    coex_sta->crc_ok_11n_agg;
+
+		if ((coex_dm->bt_status == BT_8703B_1ANT_BT_STATUS_ACL_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8703B_1ANT_BT_STATUS_SCO_BUSY)) {
+			if (coex_sta->crc_ok_cck > (total_cnt -
+						    coex_sta->crc_ok_cck)) {
+				if (cck_lock_counter < 3)
+					cck_lock_counter++;
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+	} else {
+		if (cck_lock_counter > 0)
+			cck_lock_counter--;
+	}
+
+	if (!coex_sta->pre_ccklock) {
+
+		if (cck_lock_counter >= 3)
+			coex_sta->cck_lock = true;
+		else
+			coex_sta->cck_lock = false;
+	} else {
+		if (cck_lock_counter == 0)
+			coex_sta->cck_lock = false;
+		else
+			coex_sta->cck_lock = true;
+	}
+
+	if (coex_sta->cck_lock)
+		coex_sta->cck_ever_lock = true;
+
+	coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+
+}
+
+boolean halbtc8703b1ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void halbtc8703b1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+	bt_link_info->bt_hi_pri_link_exist = coex_sta->bt_hi_pri_link_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+void halbtc8703b1ant_UpdateWifiChannelInfo(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] =
+			0x1;  /* enable BT AFH skip WL channel for 8703b because BT Rx LO interference */
+		/* h2c_parameter[0] = 0x0; */
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+
+}
+
+u8 halbtc8703b1ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8703B_1ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Profile = SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8703B_1ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8703B_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8703B_1ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8703B_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8703B_1ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8703B_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8703B_1ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8703B_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8703B_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! BT Profile = SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8703B_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8703b1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8703b1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8703b1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8703b1ant_WriteScoreBoard(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	u16				bitpos,
+	IN	BOOLEAN		state
+)
+{
+
+	static u16 originalval = 0x8002;
+
+	if (state)
+		originalval = originalval | bitpos;
+	else
+		originalval = originalval & (~bitpos);
+	
+
+	btcoexist->btc_write_2byte(btcoexist, 0xaa, originalval);
+#if 0
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"\n [BTCoex], ********** Write Scoreboard = %x**********\n",
+		    originalval);
+	BTC_TRACE(trace_buf);
+#endif 	
+
+}
+
+void halbtc8703b1ant_ReadScoreBoard(
+	IN	struct  btc_coexist		*btcoexist,
+	IN   u16				*score_board_val
+)
+{
+
+	*score_board_val = (btcoexist->btc_read_2byte(btcoexist,
+			    0xaa)) & 0x7fff;
+}
+
+void halbtc8703b1ant_PostActiveStateToBT(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	boolean				wifi_active
+)
+{
+
+	if (wifi_active)
+		halbtc8703b1ant_WriteScoreBoard(btcoexist, (u16) BIT0, TRUE);
+	else
+		halbtc8703b1ant_WriteScoreBoard(btcoexist, (u16) BIT0, FALSE);
+
+	/* The BT should set "No Shunt-down" mode if WL = Active for BT Synthesizer on/off interference WL Lo issue at 8703b b-cut. */
+
+}
+
+void halbtc8703b1ant_PostOnOffStateToBT(
+	IN	struct  btc_coexist		*btcoexist,
+	IN	boolean				wifi_on
+)
+{
+
+	if (wifi_on)
+		halbtc8703b1ant_WriteScoreBoard(btcoexist, (u16) BIT1, TRUE);
+	else
+		halbtc8703b1ant_WriteScoreBoard(btcoexist, (u16) BIT1, FALSE);
+
+}
+
+void halbtc8703b1ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf7;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf8;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf9;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8703b1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8703b1ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+u32 halbtc8703b1ant_LTECoex_InDirectReadReg(IN struct btc_coexist *btcoexist,
+		IN u16 reg_addr)
+{
+	u32 j = 0;
+
+
+	/* wait for ready bit before access 0x7c0		 */
+	btcoexist->btc_write_4byte(btcoexist, 0x7c0, 0x800F0000 | reg_addr);
+
+	do {
+		j++;
+	} while (((btcoexist->btc_read_1byte(btcoexist,
+					     0x7c3) & BIT(5)) == 0) &&
+		 (j < BT_8703B_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+
+
+	return btcoexist->btc_read_4byte(btcoexist,
+					  0x7c8);  /* get read data */
+
+}
+
+void halbtc8703b1ant_LTECoex_InDirectWriteReg(IN struct btc_coexist *btcoexist,
+		IN u16 reg_addr, IN u32 bit_mask, IN u32 reg_value)
+{
+	u32 val, i = 0, j = 0, bitpos = 0;
+
+
+	if (bit_mask == 0x0)
+		return;
+	if (bit_mask == 0xffffffff) {
+		btcoexist->btc_write_4byte(btcoexist, 0x7c4,
+					   reg_value); /* put write data */
+
+		/* wait for ready bit before access 0x7c0 */
+		do {
+			j++;
+		} while (((btcoexist->btc_read_1byte(btcoexist,
+						     0x7c3) & BIT(5)) == 0) &&
+			(j < BT_8703B_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+
+
+		btcoexist->btc_write_4byte(btcoexist, 0x7c0,
+					   0xc00F0000 | reg_addr);
+	} else {
+		for (i = 0; i <= 31; i++) {
+			if (((bit_mask >> i) & 0x1) == 0x1) {
+				bitpos = i;
+				break;
+			}
+		}
+
+		/* read back register value before write */
+		val = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist,
+				reg_addr);
+		val = (val & (~bit_mask)) | (reg_value << bitpos);
+
+		btcoexist->btc_write_4byte(btcoexist, 0x7c4,
+					   val); /* put write data */
+
+		/* wait for ready bit before access 0x7c0		 */
+		do {
+			j++;
+		} while (((btcoexist->btc_read_1byte(btcoexist,
+						     0x7c3) & BIT(5)) == 0) &&
+			(j < BT_8703B_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT));
+
+
+		btcoexist->btc_write_4byte(btcoexist, 0x7c0,
+					   0xc00F0000 | reg_addr);
+
+	}
+
+}
+
+void halbtc8703b1ant_LTECoex_Enable(IN struct btc_coexist *btcoexist,
+				    IN boolean enable)
+{
+	u8 val;
+
+	val = (enable) ? 1 : 0;
+	halbtc8703b1ant_LTECoex_InDirectWriteReg(btcoexist, 0x38, 0x80,
+			val);  /* 0x38[7] */
+
+}
+
+void halbtc8703b1ant_LTECoex_PathControlOwner(IN struct btc_coexist *btcoexist,
+		IN boolean wifi_control)
+{
+	u8 val;
+
+	val = (wifi_control) ? 1 : 0;
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x4,
+					   val); /* 0x70[26] */
+
+}
+
+void halbtc8703b1ant_LTECoex_set_GNT_BT(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, bit_mask;
+
+	state = state & 0x1;
+	val = (sw_control) ? ((state << 1) | 0x1) : 0;
+
+	switch (control_block) {
+	case BT_8703B_1ANT_GNT_BLOCK_RFC_BB:
+	default:
+		bit_mask = 0xc000;
+		halbtc8703b1ant_LTECoex_InDirectWriteReg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[15:14] */
+		bit_mask = 0x0c00;
+		halbtc8703b1ant_LTECoex_InDirectWriteReg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[11:10]						 */
+		break;
+	case BT_8703B_1ANT_GNT_BLOCK_RFC:
+		bit_mask = 0xc000;
+		halbtc8703b1ant_LTECoex_InDirectWriteReg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[15:14] */
+		break;
+	case BT_8703B_1ANT_GNT_BLOCK_BB:
+		bit_mask = 0x0c00;
+		halbtc8703b1ant_LTECoex_InDirectWriteReg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[11:10] */
+		break;
+
+	}
+
+}
+
+void halbtc8703b1ant_LTECoex_set_GNT_WL(IN struct btc_coexist *btcoexist,
+			IN u8 control_block, IN boolean sw_control, IN u8 state)
+{
+	u32 val = 0, bit_mask;
+
+	state = state & 0x1;
+	val = (sw_control) ? ((state << 1) | 0x1) : 0;
+
+	switch (control_block) {
+	case BT_8703B_1ANT_GNT_BLOCK_RFC_BB:
+	default:
+		bit_mask = 0x3000;
+		halbtc8703b1ant_LTECoex_InDirectWriteReg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[13:12] */
+		bit_mask = 0x0300;
+		halbtc8703b1ant_LTECoex_InDirectWriteReg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[9:8]						 */
+		break;
+	case BT_8703B_1ANT_GNT_BLOCK_RFC:
+		bit_mask = 0x3000;
+		halbtc8703b1ant_LTECoex_InDirectWriteReg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[13:12] */
+		break;
+	case BT_8703B_1ANT_GNT_BLOCK_BB:
+		bit_mask = 0x0300;
+		halbtc8703b1ant_LTECoex_InDirectWriteReg(btcoexist,
+				0x38, bit_mask, val); /* 0x38[9:8] */
+		break;
+
+	}
+
+}
+
+void halbtc8703b1ant_LTECoex_set_coex_table(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u16 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8703B_1ANT_CTT_WL_VS_LTE:
+		reg_addr = 0xa0;
+		break;
+	case BT_8703B_1ANT_CTT_BT_VS_LTE:
+		reg_addr = 0xa4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8703b1ant_LTECoex_InDirectWriteReg(btcoexist, reg_addr,
+			0xffff, table_content); /* 0xa0[15:0] or 0xa4[15:0] */
+
+
+}
+
+
+void halbtc8703b1ant_LTECoex_set_BreakTable(IN struct btc_coexist *btcoexist,
+		IN u8 table_type, IN u8 table_content)
+{
+	u16 reg_addr = 0x0000;
+
+	switch (table_type) {
+	case BT_8703B_1ANT_LBTT_WL_BREAK_LTE:
+		reg_addr = 0xa8;
+		break;
+	case BT_8703B_1ANT_LBTT_BT_BREAK_LTE:
+		reg_addr = 0xac;
+		break;
+	case BT_8703B_1ANT_LBTT_LTE_BREAK_WL:
+		reg_addr = 0xb0;
+		break;
+	case BT_8703B_1ANT_LBTT_LTE_BREAK_BT:
+		reg_addr = 0xb4;
+		break;
+	}
+
+	if (reg_addr != 0x0000)
+		halbtc8703b1ant_LTECoex_InDirectWriteReg(btcoexist, reg_addr,
+			0xff, table_content); /* 0xa8[15:0] or 0xb4[15:0] */
+
+
+}
+
+void halbtc8703b1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8703b1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8703b1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8703b1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	u32	break_table;
+	u8	select_table;
+
+	coex_sta->coex_table_type = type;
+
+	if (coex_sta->concurrent_rx_mode_on == true) {
+		break_table = 0xf0ffffff;  /* set WL hi-pri can break BT */
+		select_table =
+			0xb;		/* set Tx response = Hi-Pri (ex: Transmitting ACK,BA,CTS) */
+	} else {
+		break_table = 0xffffff;
+		select_table = 0x3;
+	}
+
+	switch (type) {
+	case 0:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0x55555555, 0x55555555, break_table,
+					   select_table);
+		break;
+	case 1:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0x55555555, 0x5a5a5a5a, break_table,
+					   select_table);
+		break;
+	case 2:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0xaa5a5a5a, 0xaa5a5a5a, break_table,
+					   select_table);
+		break;
+	case 3:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0xaa555555, 0xaa5a5a5a, break_table,
+					   select_table);
+		break;
+	case 4:
+		/* if (  (coex_sta->cck_ever_lock)  &&  (coex_sta->scan_ap_num <= 5) ) */
+		/*	halbtc8703b1ant_coex_table(btcoexist, force_exec, 0xaa555555, 0xaaaa5a5a, break_table, select_table); */
+		/* else */
+		halbtc8703b1ant_coex_table(btcoexist,
+					   force_exec, 0xaa555555, 0xaa5a5a5a,
+					   break_table, select_table);
+		break;
+	case 5:
+		/* if (  (coex_sta->cck_ever_lock)  &&  (coex_sta->scan_ap_num <= 5) ) */
+		/*	halbtc8703b1ant_coex_table(btcoexist, force_exec, 0xaa555555, 0xaaaa5a5a, break_table, select_table); */
+		/* else */
+		halbtc8703b1ant_coex_table(btcoexist,
+					   force_exec, 0x5a5a5a5a, 0x5a5a5a5a,
+					   break_table, select_table);
+		break;
+	case 6:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0x55555555, 0xaaaaaaaa, break_table,
+					   select_table);
+		break;
+	case 7:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0xaaaaaaaa, 0xaaaaaaaa, break_table,
+					   select_table);
+		break;
+	case 8:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0x55dd55dd, 0x5ada5ada, break_table,
+					   select_table);
+		break;
+	case 9:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0x55dd55dd, 0x5ada5ada, break_table,
+					   select_table);
+		break;
+	case 10:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0x55dd55dd, 0x5ada5ada, break_table,
+					   select_table);
+		break;
+	case 11:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0x55dd55dd, 0x5ada5ada, break_table,
+					   select_table);
+		break;
+	case 12:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0x55dd55dd, 0x5ada5ada, break_table,
+					   select_table);
+		break;
+	case 13:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0x5fff5fff, 0xaaaaaaaa, break_table,
+					   select_table);
+		break;
+	case 14:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0x5fff5fff, 0x5ada5ada, break_table,
+					   select_table);
+		break;
+	case 15:
+		halbtc8703b1ant_coex_table(btcoexist, force_exec,
+					   0x55dd55dd, 0xaaaaaaaa, break_table,
+					   select_table);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8703b1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable) {
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8703b1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+
+#if 0 
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8703b1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+#endif	
+}
+
+void halbtc8703b1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8703b1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8703b1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8703b1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+	u8	h2c_parameter[5] = {0x8,0,0,0,0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			/*halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,			
+						8); */
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);			
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			/*halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);*/
+			btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);			
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8703b1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		coex_sta->force_lps_on = false;
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+
+		break;
+	case BTC_PS_LPS_ON:
+		coex_sta->force_lps_on = true;
+		halbtc8703b1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8703b1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+
+		break;
+	case BTC_PS_LPS_OFF:
+		coex_sta->force_lps_on = false;
+		halbtc8703b1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+
+		break;
+	default:
+		break;
+	}
+}
+
+
+
+void halbtc8703b1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for 1Ant AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+
+			halbtc8703b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+		}
+	} else if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+		
+		halbtc8703b1ant_power_save_state(
+							btcoexist, BTC_PS_LPS_ON, 0x50,
+							0x4);
+	}
+	else
+	{
+		halbtc8703b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	}
+		
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+
+void halbtc8703b1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_busy = false;
+	u8			rssi_adjust_val = 0;
+	u8			ps_tdma_byte4_val = 0x10;				
+	static boolean	 pre_wifi_busy = false;
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (wifi_busy != pre_wifi_busy) {
+		force_exec = true;
+		pre_wifi_busy = wifi_busy;
+	}
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+	
+
+	/*	for A2DP slave  */
+	if ((bt_link_info->slave_role == true)	&& (bt_link_info->a2dp_exist))
+		ps_tdma_byte4_val = ps_tdma_byte4_val |
+			0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+
+
+	if (turn_on)	{
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+	}
+
+
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+						0x61, 0x35, 0x03, 0x11, 0x11);
+			break;
+		
+		case 3:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x3a, 0x03, 0x10, 0x10);
+			break;
+		case 4:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x21, 0x03, 0x10, 0x10);
+			break;
+		case 5:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x15, 0x03, 0x11, 0x11);
+			break;
+		case 6:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x20, 0x03, 0x11, 0x11);
+			break;
+		case 7:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+						0x51, 0x10, 0x03, 0x10, ps_tdma_byte4_val);
+			break;
+		case 8:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist, 
+						0x51, 0x10, 0x03, 0x10, ps_tdma_byte4_val);
+			break;			
+		case 13:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x3a, 0x03, 0x10, ps_tdma_byte4_val);			
+			break;
+		case 14:	
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x21, 0x03, 0x10, ps_tdma_byte4_val);
+			break;
+		case 17:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist, 
+						0x61, 0x10, 0x03, 0x11, ps_tdma_byte4_val);
+			break;				
+		case 19:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x15, 0x03, 0x11, 0x10);
+			break;	
+		case 20:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x3f, 0x03, 0x11, 0x10);
+			break;
+		case 21:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x30, 0x03, 0x11, 0x10);
+			break;
+		case 22:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x25, 0x03, 0x11, 0x10);
+			break;		
+		case 32:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x35, 0x03, 0x11, 0x11);
+			break;
+		case 33:
+			halbtc8703b1ant_set_fw_pstdma(btcoexist,
+					      0x61, 0x35, 0x03, 0x11, 0x10);
+			break;		
+
+		}
+	} else {
+
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8703b1ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8703b1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 1: /* 2-Ant, 0x778=3, antenna control by antenna diversity */
+			halbtc8703b1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8703b1ant_sw_mechanism(IN struct btc_coexist *btcoexist,
+				  IN boolean low_penalty_ra)
+{
+	halbtc8703b1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+void halbtc8703b1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean force_exec, IN boolean init_hwcfg,
+				  IN boolean wifi_off)
+{
+	u32			cnt_bt_cal_chk = 0;
+	boolean			is_in_mp_mode = false;
+	u8			u8tmp = 0;
+	u32			u32tmp1 = 0, u32tmp2 = 0;
+
+	coex_dm->cur_ant_pos_type = ant_pos_type;
+
+#if 1
+	u32tmp1 = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist,
+			0x38);
+	u32tmp2 = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist,
+			0x54);
+	u8tmp  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** (Before Ant Setup) 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x**********\n",
+		    u8tmp, u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+#endif
+
+	if (init_hwcfg) {
+		/* Disable LTE Coex Function in WiFi side (this should be on if LTE coex is required) */
+		halbtc8703b1ant_LTECoex_Enable(btcoexist, 0x0);
+
+		/* GNT_WL_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8703b1ant_LTECoex_set_coex_table(btcoexist,
+				       BT_8703B_1ANT_CTT_WL_VS_LTE, 0xffff);
+
+		/* GNT_BT_LTE always = 1 (this should be config if LTE coex is required) */
+		halbtc8703b1ant_LTECoex_set_coex_table(btcoexist,
+				       BT_8703B_1ANT_CTT_BT_VS_LTE, 0xffff);
+
+		/* Wait If BT IQK running, because Path control owner is at BT during BT IQK (setup by WiFi firmware)  */
+		while (cnt_bt_cal_chk <= 20) {
+			u8tmp = btcoexist->btc_read_1byte(btcoexist,
+							  0x49d);
+			cnt_bt_cal_chk++;
+			if (u8tmp & BIT(0)) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], ########### BT is calibrating (wait cnt=%d) ###########\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				delay_ms(50);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], ********** BT is NOT calibrating (wait cnt=%d)**********\n",
+					    cnt_bt_cal_chk);
+				BTC_TRACE(trace_buf);
+				break;
+			}
+		}
+
+		/* set Path control owner to WL at initial step */
+		halbtc8703b1ant_LTECoex_PathControlOwner(btcoexist,
+				BT_8703B_1ANT_PCO_WLSIDE);
+
+		/* set GNT_BT to SW high */
+		halbtc8703b1ant_LTECoex_set_GNT_BT(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_HIGH);
+		/* Set GNT_WL to SW low */
+		halbtc8703b1ant_LTECoex_set_GNT_WL(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_LOW);
+		
+	} else if (wifi_off) {
+		/* Disable LTE Coex Function in WiFi side */
+		halbtc8703b1ant_LTECoex_Enable(btcoexist, 0x0);
+
+		/* set Path control owner to BT  */
+			halbtc8703b1ant_LTECoex_PathControlOwner(btcoexist,
+				BT_8703B_1ANT_PCO_BTSIDE);
+	} else {
+	
+		halbtc8703b1ant_LTECoex_PathControlOwner(btcoexist,
+				BT_8703B_1ANT_PCO_WLSIDE);
+
+
+	if (force_exec ||
+	    (coex_dm->cur_ant_pos_type != coex_dm->pre_ant_pos_type) ||
+	    init_hwcfg || wifi_off) {
+		/* internal switch setting */
+		switch (ant_pos_type) {
+		case BTC_ANT_PATH_WIFI:
+			/* set GNT_BT to low */
+			halbtc8703b1ant_LTECoex_set_GNT_BT(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_LOW);
+			/* Set GNT_WL to high */
+			halbtc8703b1ant_LTECoex_set_GNT_WL(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_HIGH);
+			break;
+		case BTC_ANT_PATH_BT:
+				/*halbtc8703b1ant_LTECoex_PathControlOwner(
+					btcoexist, BT_8703B_1ANT_PCO_BTSIDE);*/
+			/* set GNT_BT to high */
+				 halbtc8703b1ant_LTECoex_set_GNT_BT(btcoexist, 
+				 		  BT_8703B_1ANT_GNT_BLOCK_RFC_BB, 
+				 		  BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+				 		  BT_8703B_1ANT_SIG_STA_SET_TO_HIGH); 
+			/* Set GNT_WL to low */
+				 halbtc8703b1ant_LTECoex_set_GNT_WL(btcoexist, 
+				                BT_8703B_1ANT_GNT_BLOCK_RFC_BB, 
+				 		  BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW, 
+				 		  BT_8703B_1ANT_SIG_STA_SET_TO_LOW); 
+			break;
+		default:
+		case BTC_ANT_PATH_PTA:
+			/* set GNT_BT to PTA */
+			halbtc8703b1ant_LTECoex_set_GNT_BT(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_PTA,
+					   BT_8703B_1ANT_SIG_STA_SET_BY_HW);
+			/* Set GNT_WL to PTA */
+			halbtc8703b1ant_LTECoex_set_GNT_WL(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_PTA,
+					   BT_8703B_1ANT_SIG_STA_SET_BY_HW);
+			break;
+		}
+	}
+	}
+
+#if 1
+	u32tmp1 = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist, 0x38);
+	u32tmp2 = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist, 0x54);
+	u8tmp  = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	if (init_hwcfg) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (After Ant-Setup Init) 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x**********\n",
+			    u8tmp, u32tmp1, u32tmp2);
+		BTC_TRACE(trace_buf);
+	} else if (wifi_off) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (After Ant-Setup WiFi off) 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x**********\n",
+			    u8tmp, u32tmp1, u32tmp2);
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], ********** (After Ant-Setup Run time) 0x73 = 0x%x, 0x38= 0x%x, 0x54= 0x%x**********\n",
+			    u8tmp, u32tmp1, u32tmp2);
+		BTC_TRACE(trace_buf);
+	}
+#endif
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+}
+
+
+boolean halbtc8703b1ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8703b1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8703b1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (!wifi_connected &&
+		(BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8703b1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (wifi_connected &&
+		(BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8703b1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (!wifi_connected &&
+		(BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE != coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non connected-idle + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8703b1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else {
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		common = false;
+	}
+
+	return common;
+}
+
+
+void halbtc8703b1ant_tdma_duration_adjust_for_acl(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+
+#if 0
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0, bt_info_ext;
+	boolean			wifi_busy = false;
+
+	if (BT_8703B_1ANT_WIFI_STATUS_CONNECTED_BUSY == wifi_status)
+		wifi_busy = true;
+	else
+		wifi_busy = false;
+
+	if ((BT_8703B_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN ==
+	     wifi_status) ||
+	    (BT_8703B_1ANT_WIFI_STATUS_CONNECTED_SCAN == wifi_status) ||
+	    (BT_8703B_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT ==
+	     wifi_status)) {
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 3 &&
+		    coex_dm->cur_ps_tdma != 9) {
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						9);
+			coex_dm->ps_tdma_du_adj_type = 9;
+
+			up = 0;
+			dn = 0;
+			m = 1;
+			n = 3;
+			result = 0;
+			wait_count = 0;
+		}
+		return;
+	}
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 2);
+		coex_dm->ps_tdma_du_adj_type = 2;
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* accquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		bt_info_ext = coex_sta->bt_info_ext;
+
+		if ((coex_sta->low_priority_tx) > 1050 ||
+		    (coex_sta->low_priority_rx) > 1250)
+			retry_count++;
+
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (result == -1) {
+			/*			if( (BT_INFO_8703B_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+							((coex_dm->cur_ps_tdma == 1) ||(coex_dm->cur_ps_tdma == 2)) )
+						{
+							halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+							coex_dm->ps_tdma_du_adj_type = 9;
+						}
+						else */ if (coex_dm->cur_ps_tdma == 1) {
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 11);
+				coex_dm->ps_tdma_du_adj_type = 11;
+			}
+		} else if (result == 1) {
+			/*			if( (BT_INFO_8703B_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+							((coex_dm->cur_ps_tdma == 1) ||(coex_dm->cur_ps_tdma == 2)) )
+						{
+							halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+							coex_dm->ps_tdma_du_adj_type = 9;
+						}
+						else */ if (coex_dm->cur_ps_tdma == 11) {
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 1);
+				coex_dm->ps_tdma_du_adj_type = 1;
+			}
+		} else { /* no change */
+			/* Bryant Modify
+			if(wifi_busy != pre_wifi_busy)
+			{
+				pre_wifi_busy = wifi_busy;
+				halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, true, coex_dm->cur_ps_tdma);
+			}
+			*/
+
+		}
+
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 9 &&
+		    coex_dm->cur_ps_tdma != 11) {
+			/* recover to previous adjust type */
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		}
+	}
+
+#endif	
+}
+
+void halbtc8703b1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8703b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+	halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, FORCE_EXEC,
+				     false, false);
+}
+
+void halbtc8703b1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{ 
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+	u16 			u16tmp;
+
+	/* This function check if bt is disabled */
+#if 1
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+
+	
+#else   /*  8703b BT can't show correct on/off status in scoreboard[1] 2015/11/26 */
+
+	halbtc8703b1ant_ReadScoreBoard(btcoexist,	&u16tmp);
+
+	bt_active = u16tmp & BIT1;
+
+	
+#endif
+	
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+	
+		bt_disable_cnt++;
+		if (bt_disable_cnt >= 2)
+			bt_disabled = true;
+		
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_action_wifi_only(btcoexist);		
+	}
+
+	
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		if (!bt_disabled) {
+		} else {
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+					   NULL);
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+					   NULL);
+		}
+	}
+}
+
+/* *********************************************
+ *
+ *	Software Coex Mechanism start
+ *
+ * ********************************************* */
+
+/* SCO only or SCO+PAN(HS) */
+
+/*
+void halbtc8703b1ant_action_sco(IN struct btc_coexist* btcoexist)
+{
+	halbtc8703b1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8703b1ant_action_hid(IN struct btc_coexist* btcoexist)
+{
+	halbtc8703b1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8703b1ant_action_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8703b1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8703b1ant_action_a2dp_pan_hs(IN struct btc_coexist* btcoexist)
+{
+	halbtc8703b1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8703b1ant_action_pan_edr(IN struct btc_coexist* btcoexist)
+{
+	halbtc8703b1ant_sw_mechanism(btcoexist, false);
+}
+
+
+void halbtc8703b1ant_action_pan_hs(IN struct btc_coexist* btcoexist)
+{
+	halbtc8703b1ant_sw_mechanism(btcoexist, false);
+}
+
+
+void halbtc8703b1ant_action_pan_edr_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8703b1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8703b1ant_action_pan_edr_hid(IN struct btc_coexist* btcoexist)
+{
+	halbtc8703b1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8703b1ant_action_hid_a2dp_pan_edr(IN struct btc_coexist* btcoexist)
+{
+	halbtc8703b1ant_sw_mechanism(btcoexist, true);
+}
+
+void halbtc8703b1ant_action_hid_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8703b1ant_sw_mechanism(btcoexist, true);
+}
+
+*/
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8703b1ant_action_bt_whck_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8703b1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8703b1ant_action_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8703b1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = false, ap_enable = false, wifi_busy = false,
+				bt_busy = false;
+
+	boolean	scan = false;
+	
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+
+
+	if ((!wifi_connected) && (!scan)) {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if  ( (scan) && (coex_sta->num_of_profile == 0) ) {
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	}else if ((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist) ) {
+	
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (bt_link_info->a2dp_exist) {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (wifi_busy){
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 21);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);	
+	}
+	else {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 19);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);	
+	}
+}
+
+void halbtc8703b1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/* tdma and coex table */
+
+	if (bt_link_info->sco_exist) {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	} else { /* HID */
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 6);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	}
+}
+
+void halbtc8703b1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+
+	if (bt_link_info->hid_only) { /* HID */
+		halbtc8703b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				wifi_status);
+		coex_dm->auto_tdma_adjust = false;
+		return;
+	} else if (bt_link_info->a2dp_only) { /* A2DP		 */
+		if (BT_8703B_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status) {
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = false;
+		} else {
+
+		if (coex_sta->scan_ap_num >=
+				    BT_8703B_1ANT_WIFI_NOISY_THRESH)  {			
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						17);	}	else{
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						7);
+			}
+			
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = true;
+		}
+	} else if (((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+
+		if (coex_sta->scan_ap_num <=
+			    3)
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+		else
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+		
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+		coex_dm->auto_tdma_adjust = false;
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 8);
+		coex_dm->auto_tdma_adjust = false;
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+	} else if ((bt_link_info->pan_only) || (bt_link_info->hid_exist &&
+		bt_link_info->pan_exist)) { /* PAN(OPP,FTP), HID+PAN(OPP,FTP)			 */
+		if (BT_8703B_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status)
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						4);
+		else
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		/* BT no-profile busy (0x9) */
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	}	
+}
+
+void halbtc8703b1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	
+	/* tdma and coex table */
+	halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8703b1ant_action_wifi_not_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+		
+	if (BT_8703B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		 if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}else if (bt_link_info->a2dp_exist) {
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8703B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8703b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8703B_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8703b1ant_action_wifi_not_connected_asso_auth(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist)  || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 4);
+	} else {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 2);
+	}
+}
+
+void halbtc8703b1ant_action_wifi_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+
+	/* tdma and coex table */
+	if (BT_8703B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		 if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}else if (bt_link_info->a2dp_exist) {
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8703B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8703b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8703B_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8703b1ant_action_wifi_connected_specific_packet(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* no specific packet process for both WiFi and BT very busy */
+	if ((wifi_busy) && ((bt_link_info->pan_exist) ||
+			    (coex_sta->num_of_profile >= 2)))
+		return;
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist)) {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	} else if (bt_link_info->a2dp_exist) {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8703b1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	boolean	wifi_busy = false;
+	boolean		scan = false, link = false, roam = false;
+	boolean		under_4way = false, ap_enable = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+	if (under_4way) {
+		halbtc8703b1ant_action_wifi_connected_specific_packet(btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under 4way<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	if (scan || link || roam) {
+		if (scan)
+			halbtc8703b1ant_action_wifi_connected_scan(btcoexist);
+		else
+			halbtc8703b1ant_action_wifi_connected_specific_packet(
+				btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under scan<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	
+
+	/* tdma and coex table */
+	if (!wifi_busy) {
+		if (BT_8703B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8703b1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8703B_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else if ((BT_8703B_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8703b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8703B_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else {
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8703b1ant_set_ant_path(btcoexist,
+				BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false);
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+		}
+	} else {
+		if (BT_8703B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8703b1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8703B_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else if ((BT_8703B_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8703b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8703B_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else {
+			/* halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8); */
+			halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8703b1ant_set_ant_path(btcoexist,
+				BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false);
+			/* halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);	 */
+			halbtc8703b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	}
+}
+
+void halbtc8703b1ant_run_sw_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+
+	algorithm = halbtc8703b1ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+
+	if (halbtc8703b1ant_is_common_action(btcoexist)) {
+
+	} else {
+		switch (coex_dm->cur_algorithm) {
+		case BT_8703B_1ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8703b1ant_action_sco(btcoexist); */
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8703b1ant_action_hid(btcoexist); */
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8703b1ant_action_a2dp(btcoexist); */
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8703b1ant_action_a2dp_pan_hs(btcoexist); */
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8703b1ant_action_pan_edr(btcoexist); */
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8703b1ant_action_pan_hs(btcoexist); */
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8703b1ant_action_pan_edr_a2dp(btcoexist); */
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8703b1ant_action_pan_edr_hid(btcoexist); */
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8703b1ant_action_hid_a2dp_pan_edr(btcoexist); */
+			break;
+		case BT_8703B_1ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8703b1ant_action_hid_a2dp(btcoexist); */
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8703b1ant_coex_all_off(btcoexist); */
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8703b1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, bt_hs_on = false;
+	boolean	increase_scan_dev_num = false;
+	boolean	bt_ctrl_agg_buf_size = false;
+	boolean	miracast_plus_bt = false;
+	u8	agg_buf_size = 5;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0, wifi_bw;
+	u8	iot_peer = BTC_IOT_PEER_UNKNOWN;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_action_bt_whck_test(btcoexist);
+		return;
+	}
+
+	if ((BT_8703B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8703B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist) {
+			halbtc8703b1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1,
+						   0, 1);
+			miracast_plus_bt = true;
+		} else {
+			halbtc8703b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+			miracast_plus_bt = false;
+		}
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8703b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+
+		if (coex_sta->c2h_bt_inquiry_page) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is Inquirying\n");
+			BTC_TRACE(trace_buf);
+			halbtc8703b1ant_action_bt_inquiry(btcoexist);
+		} else
+			halbtc8703b1ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	} else {
+		miracast_plus_bt = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_link_info->bt_link_exist) && (wifi_connected)) {
+		halbtc8703b1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1, 0, 1);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_IOT_PEER, &iot_peer);
+
+		if (BTC_IOT_PEER_CISCO != iot_peer) {
+			if (bt_link_info->sco_exist) /* if (bt_link_info->bt_hi_pri_link_exist) */
+				halbtc8703b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, true, false, 0x5);
+			else
+				halbtc8703b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, false, false, 0x5);
+		} else {
+			if (bt_link_info->sco_exist)
+				halbtc8703b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, true, false, 0x5);
+			else {
+				if (BTC_WIFI_BW_HT40 == wifi_bw)
+					halbtc8703b1ant_limited_rx(btcoexist,
+						NORMAL_EXEC, false, true, 0x10);
+				else
+					halbtc8703b1ant_limited_rx(btcoexist,
+						NORMAL_EXEC, false, true, 0x8);
+			}
+		}
+
+		halbtc8703b1ant_sw_mechanism(btcoexist, true);
+		halbtc8703b1ant_run_sw_coexist_mechanism(
+			btcoexist);  /* just print debug message */
+	} else {
+		halbtc8703b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+		halbtc8703b1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x5);
+
+		halbtc8703b1ant_sw_mechanism(btcoexist, false);
+		halbtc8703b1ant_run_sw_coexist_mechanism(
+			btcoexist); /* just print debug message */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "############# [BTCoex],  BT Is Inquirying\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8703b1ant_action_hs(btcoexist);
+		return;
+	}
+
+
+	if (!wifi_connected) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is non connected-idle !!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (scan || link || roam) {
+			if (scan)
+				halbtc8703b1ant_action_wifi_not_connected_scan(
+					btcoexist);
+			else
+				halbtc8703b1ant_action_wifi_not_connected_asso_auth(
+					btcoexist);
+		} else
+			halbtc8703b1ant_action_wifi_not_connected(btcoexist);
+	} else	/* wifi LPS/Busy */
+		halbtc8703b1ant_action_wifi_connected(btcoexist);
+}
+
+u32 halbtc8703b1ant_psd_log2base(IN struct btc_coexist *btcoexist, IN u32 val)
+{
+	u8	j;
+	u32	tmp, tmp2, val_integerd_b = 0, tindex, shiftcount = 0;
+	u32	result, val_fractiond_b = 0, table_fraction[21] = {0, 432, 332, 274, 232, 200,
+				   174, 151, 132, 115, 100, 86, 74, 62, 51, 42,
+							   32, 23, 15, 7, 0
+							      };
+
+	if (val == 0)
+		return 0;
+
+	tmp = val;
+
+	while (1) {
+		if (tmp == 1)
+			break;
+		else {
+			tmp = (tmp >> 1);
+			shiftcount++;
+		}
+	}
+
+
+	val_integerd_b = shiftcount + 1;
+
+	tmp2 = 1;
+	for (j = 1; j <= val_integerd_b; j++)
+		tmp2 = tmp2 * 2;
+
+	tmp = (val * 100) / tmp2;
+	tindex = tmp / 5;
+
+	if (tindex > 20)
+		tindex = 20;
+
+	val_fractiond_b = table_fraction[tindex];
+
+	result = val_integerd_b * 100 - val_fractiond_b;
+
+	return result;
+
+
+}
+
+void halbtc8703b1ant_enable_gnt_to_gpio(IN struct btc_coexist *btcoexist,
+				IN boolean isenable)
+{
+
+#if (BT_8703B_1ANT_ENABLE_GNTBT_TO_GPIO14 == 1)
+	if (isenable)
+	{
+	    /* enable GNT_WL/GNT_BT debug signal to GPIO14/15 */
+  	    btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x1);
+
+  	    /* enable GNT_BT debug to GPIO */
+	    btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e, 0x40, 0x0);
+	    btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x1, 0x0);
+	}
+	else
+	{
+  	    /* enable GNT_WL/GNT_BT debug signal to GPIO14/15 */
+  	    btcoexist->btc_write_1byte_bitmask(btcoexist, 0x73, 0x8, 0x0);
+
+  	    /* Disable GNT_BT debug to GPIO, and enable chip_wakeup_host */
+	    btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4e, 0x40, 0x1);
+	    btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x1, 0x1);
+	}
+#endif	
+}
+
+void halbtc8703b1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+
+	/* sw all off */
+	halbtc8703b1ant_sw_mechanism(btcoexist, false);
+
+	/* halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8); */
+	/* halbtc8703b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0); */
+
+	coex_sta->pop_event_cnt = 0;
+}
+
+void halbtc8703b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up, IN boolean wifi_only)
+{
+	u32				u32tmp0 = 0, u32tmp1 = 0, u32tmp2 = 0;
+
+	u32tmp0 = btcoexist->btc_read_4byte(btcoexist, 0x70),
+	u32tmp1 = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist, 0x38);
+	u32tmp2 = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist, 0x54);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"\n [BTCoex], ********** 0x70/ 0x38/ 0x54 (Before Init HW config) = 0x%x/ 0x%x/ 0x%x**********\n",
+		    u32tmp0, 
+		    u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+
+	/* BT report packet sample rate	 */
+	btcoexist->btc_write_1byte(btcoexist, 0x790, 0x5);
+
+	/* Enable BT counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+
+	/* Enable PTA (3-wire function form BT side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x41, 0x02, 0x1);
+
+	/* Enable PTA (tx/rx signal form WiFi side) */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x4c6, 0x10, 0x1);
+
+	halbtc8703b1ant_enable_gnt_to_gpio(btcoexist, FALSE);
+
+	if (btcoexist->btc_read_1byte(btcoexist, 0x80) == 0xc6) {
+		halbtc8703b1ant_PostOnOffStateToBT(btcoexist, true);	
+	}
+
+	halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+
+	/* Antenna config */
+	if (wifi_only) {
+		coex_sta->concurrent_rx_mode_on = false;
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_WIFI,
+					     FORCE_EXEC, true, false);
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_WIFI,
+					     FORCE_EXEC, false, false);
+	} else {
+		coex_sta->concurrent_rx_mode_on = true;
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x953, 0x2, 0x1);
+		/* RF 0x1[0] = 0 -> Set GNT_WL_RF_Rx always = 1 for con-current Rx */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0x1, 0x0);
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, true, false);
+	}
+
+	/* PTA parameter */
+	halbtc8703b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	u32tmp0 = btcoexist->btc_read_4byte(btcoexist, 0x70),
+	u32tmp1 = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist, 0x38);
+	u32tmp2 = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist, 0x54);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ********** 0x70/ 0x38/ 0x54 (After Init HW config) = 0x%x/ 0x%x/ 0x%x**********\n",
+		    u32tmp0, 
+		    u32tmp1, u32tmp2);
+	BTC_TRACE(trace_buf);
+
+}
+
+
+
+void halbtc8703b1ant_psd_showdata(IN struct btc_coexist *btcoexist)
+{
+	u8		*cli_buf = btcoexist->cli_buf;
+	u32		delta_freq_per_point;
+	u32		freq, freq1, freq2, n = 0, i = 0, j = 0, m = 0, psd_rep1, psd_rep2;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n\n============[PSD info]  (%d)============\n",
+		   psd_scan->psd_gen_count);
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->psd_gen_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n No data !!\n");
+		CL_PRINTF(cli_buf);
+		return;
+	}
+
+	if (psd_scan->psd_point == 0)
+		delta_freq_per_point = 0;
+	else
+		delta_freq_per_point = psd_scan->psd_band_width /
+				       psd_scan->psd_point;
+
+	/* if (psd_scan->is_psd_show_max_only) */
+	if (0) {
+		psd_rep1 = psd_scan->psd_max_value / 100;
+		psd_rep2 = psd_scan->psd_max_value - psd_rep1 * 100;
+
+		freq = ((psd_scan->real_cent_freq - 20) * 1000000 +
+			psd_scan->psd_max_value_point * delta_freq_per_point);
+		freq1 = freq / 1000000;
+		freq2 = freq / 1000 - freq1 * 1000;
+
+		if (freq2 < 100)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n Freq = %d.0%d MHz",
+				   freq1, freq2);
+		else
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n Freq = %d.%d MHz",
+				   freq1, freq2);
+
+		if (psd_rep2 < 10)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   ", Value = %d.0%d dB, (%d)\n",
+				   psd_rep1, psd_rep2, psd_scan->psd_max_value);
+		else
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   ", Value = %d.%d dB, (%d)\n",
+				   psd_rep1, psd_rep2, psd_scan->psd_max_value);
+
+		CL_PRINTF(cli_buf);
+	} else {
+		m = psd_scan->psd_start_point;
+		n = psd_scan->psd_start_point;
+		i = 1;
+		j = 1;
+
+		while (1) {
+			do {
+				freq = ((psd_scan->real_cent_freq - 20) * 1000000 + m *
+					delta_freq_per_point);
+				freq1 = freq / 1000000;
+				freq2 = freq / 1000 - freq1 * 1000;
+
+				if (i == 1) {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"\r\n Freq%6d.000", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"\r\n Freq%6d.0%2d", freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"\r\n Freq%6d.%3d", freq1,
+							   freq2);
+				} else if ((i % 8 == 0) ||
+					   (m == psd_scan->psd_stop_point)) {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							   "%6d.000\n", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%6d.0%2d\n", freq1, freq2);
+					else
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%6d.%3d\n", freq1, freq2);
+				} else {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							   "%6d.000", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%6d.0%2d", freq1, freq2);
+					else
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%6d.%3d", freq1, freq2);
+				}
+
+				i++;
+				m++;
+				CL_PRINTF(cli_buf);
+
+			} while ((i <= 8) && (m <= psd_scan->psd_stop_point));
+
+
+			do {
+				psd_rep1 = psd_scan->psd_report_max_hold[n] / 100;
+				psd_rep2 = psd_scan->psd_report_max_hold[n] - psd_rep1 *
+					   100;
+
+				if (j == 1) {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"\r\n Val %7d.0%d", psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"\r\n Val %7d.%d", psd_rep1,
+							   psd_rep2);
+				} else if ((j % 8 == 0)  ||
+					   (n == psd_scan->psd_stop_point)) {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%7d.0%d\n", psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%7d.%d\n", psd_rep1, psd_rep2);
+				} else {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%7d.0%d", psd_rep1, psd_rep2);
+					else
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%7d.%d", psd_rep1, psd_rep2);
+				}
+
+				j++;
+				n++;
+				CL_PRINTF(cli_buf);
+
+			} while ((j <= 8) && (n <= psd_scan->psd_stop_point));
+
+			if ((m > psd_scan->psd_stop_point) ||
+			    (n > psd_scan->psd_stop_point))
+				break;
+			else {
+				i = 1;
+				j = 1;
+			}
+
+		}
+	}
+
+
+}
+
+void halbtc8703b1ant_psd_max_holddata(IN struct btc_coexist *btcoexist,
+				      IN u32 gen_count)
+{
+	u32	i = 0, i_max = 0, val_max = 0;
+
+	if (gen_count == 1) {
+		memcpy(psd_scan->psd_report_max_hold,
+		       psd_scan->psd_report,
+		       BT_8703B_1ANT_ANTDET_PSD_POINTS * sizeof(u32));
+
+		for (i = psd_scan->psd_start_point;
+		     i <= psd_scan->psd_stop_point; i++) {
+
+		}
+
+		psd_scan->psd_max_value_point = 0;
+		psd_scan->psd_max_value = 0;
+
+	} else {
+		for (i = psd_scan->psd_start_point;
+		     i <= psd_scan->psd_stop_point; i++) {
+			if (psd_scan->psd_report[i] >
+			    psd_scan->psd_report_max_hold[i])
+				psd_scan->psd_report_max_hold[i] =
+					psd_scan->psd_report[i];
+
+			/* search Max Value */
+			if (i == psd_scan->psd_start_point) {
+				i_max = i;
+				val_max = psd_scan->psd_report_max_hold[i];
+			} else {
+				if (psd_scan->psd_report_max_hold[i] >
+				    val_max) {
+					i_max = i;
+					val_max = psd_scan->psd_report_max_hold[i];
+				}
+			}
+
+
+		}
+
+		psd_scan->psd_max_value_point = i_max;
+		psd_scan->psd_max_value = val_max;
+
+	}
+
+
+}
+
+u32 halbtc8703b1ant_psd_getdata(IN struct btc_coexist *btcoexist, IN u32 point)
+{
+	/* reg 0x808[9:0]: FFT data x */
+	/* reg 0x808[22]: 0-->1 to get 1 FFT data y */
+	/* reg 0x8b4[15:0]: FFT data y report */
+
+	u32 val = 0, psd_report = 0;
+
+	val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+
+	val &= 0xffbffc00;
+	val |= point;
+
+	btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+	val |= 0x00400000;
+	btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+
+	val = btcoexist->btc_read_4byte(btcoexist, 0x8b4);
+
+	psd_report = val & 0x0000ffff;
+
+	return psd_report;
+}
+
+
+void halbtc8703b1ant_psd_sweep_point(IN struct btc_coexist *btcoexist,
+	     IN u32 cent_freq, IN s32 offset, IN u32 span, IN u32 points,
+				     IN u32 avgnum)
+{
+	u32	 i, val, n, k = 0;
+	u32	points1 = 0, psd_report = 0;
+	u32	start_p = 0, stop_p = 0, delta_freq_per_point = 156250;
+	u32    psd_center_freq = 20 * 10 ^ 6, freq, freq1, freq2;
+	boolean outloop = false;
+	u8	 flag = 0;
+	u32	tmp, psd_rep1, psd_rep2;
+	u32	wifi_original_channel = 1;
+
+	psd_scan->is_psd_running = true;
+
+	do {
+		switch (flag) {
+		case 0:  /* Get PSD parameters */
+		default:
+
+			psd_scan->psd_band_width = 40 * 1000000;
+			psd_scan->psd_point = points;
+			psd_scan->psd_start_base = points / 2;
+			psd_scan->psd_avg_num = avgnum;
+			psd_scan->real_cent_freq = cent_freq;
+			psd_scan->real_offset = offset;
+			psd_scan->real_span = span;
+
+
+			points1 = psd_scan->psd_point;
+			delta_freq_per_point = psd_scan->psd_band_width /
+					       psd_scan->psd_point;
+
+			/* PSD point setup */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+			val &= 0xffff0fff;
+
+			switch (psd_scan->psd_point) {
+			case 128:
+				val |= 0x0;
+				break;
+			case 256:
+			default:
+				val |= 0x00004000;
+				break;
+			case 512:
+				val |= 0x00008000;
+				break;
+			case 1024:
+				val |= 0x0000c000;
+				break;
+			}
+
+			switch (psd_scan->psd_avg_num) {
+			case 1:
+				val |= 0x0;
+				break;
+			case 8:
+				val |= 0x00001000;
+				break;
+			case 16:
+				val |= 0x00002000;
+				break;
+			case 32:
+			default:
+				val |= 0x00003000;
+				break;
+			}
+			btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+			flag = 1;
+			break;
+		case 1:	  /* calculate the PSD point index from freq/offset/span */
+			psd_center_freq = psd_scan->psd_band_width / 2 +
+					  offset * (1000000);
+
+			start_p = psd_scan->psd_start_base + (psd_center_freq -
+				span * (1000000) / 2) / delta_freq_per_point;
+			psd_scan->psd_start_point = start_p -
+						    psd_scan->psd_start_base;
+
+			stop_p = psd_scan->psd_start_base + (psd_center_freq +
+				span * (1000000) / 2) / delta_freq_per_point;
+			psd_scan->psd_stop_point = stop_p -
+						   psd_scan->psd_start_base - 1;
+
+			flag = 2;
+			break;
+		case 2:  /* set RF channel/BW/Mode */
+
+			/* set 3-wire off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x88c);
+			val |= 0x00300000;
+			btcoexist->btc_write_4byte(btcoexist, 0x88c, val);
+
+			/* CCK off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x800);
+			val &= 0xfeffffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x800, val);
+
+			/* store WiFi original channel */
+			wifi_original_channel = btcoexist->btc_get_rf_reg(
+					btcoexist, BTC_RF_A, 0x18, 0x3ff);
+
+			/* Set RF channel */
+			if (cent_freq == 2484)
+				btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A,
+							  0x18, 0x3ff, 0xe);
+			else
+				btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A,
+					  0x18, 0x3ff, (cent_freq - 2412) / 5 +
+						  1); /* WiFi TRx Mask on */
+
+			/* Set  RF mode = Rx, RF Gain = 0x8a0 */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x0,
+						  0xfffff, 0x308a0);
+
+			/* Set RF Rx filter corner */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+						  0xfffff, 0x3e4);
+
+			/* Set TRx mask off */
+			/* un-lock TRx Mask setup */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdd,
+						  0x80, 0x1);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdf,
+						  0x1, 0x1);
+
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+
+			flag = 3;
+			break;
+		case 3:
+			memset(psd_scan->psd_report, 0,
+			       psd_scan->psd_point * sizeof(u32));
+			start_p = psd_scan->psd_start_point +
+				  psd_scan->psd_start_base;
+			stop_p = psd_scan->psd_stop_point +
+				 psd_scan->psd_start_base + 1;
+
+			i = start_p;
+
+			while (i < stop_p) {
+				if (i >= points1)
+					psd_report =
+						halbtc8703b1ant_psd_getdata(
+							btcoexist, i - points1);
+				else
+					psd_report =
+						halbtc8703b1ant_psd_getdata(
+							btcoexist, i);
+
+				if (psd_report == 0)
+					tmp = 0;
+				else
+					/* tmp =  20*log10((double)psd_report); */
+					/* 20*log2(x)/log2(10), log2Base return theresult of the psd_report*100 */
+					tmp = 6 * halbtc8703b1ant_psd_log2base(
+						      btcoexist, psd_report);
+
+				n = i - psd_scan->psd_start_base;
+				psd_scan->psd_report[n] =  tmp;
+				psd_rep1 = psd_scan->psd_report[n] / 100;
+				psd_rep2 = psd_scan->psd_report[n] - psd_rep1 *
+					   100;
+
+				freq = ((cent_freq - 20) * 1000000 + n *
+					delta_freq_per_point);
+				freq1 = freq / 1000000;
+				freq2 = freq / 1000 - freq1 * 1000;
+
+				i++;
+
+				k = 0;
+
+				/* Add Delay between PSD point */
+				while (1) {
+					if (k++ > 20000)
+						break;
+				}
+
+			}
+
+			flag = 100;
+			break;
+		case 99:	/* error */
+
+			outloop = true;
+			break;
+		case 100: /* recovery */
+
+			/* set 3-wire on */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x88c);
+			val &= 0xffcfffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x88c, val);
+
+			/* CCK on */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x800);
+			val |= 0x01000000;
+			btcoexist->btc_write_4byte(btcoexist, 0x800, val);
+
+			/* PSD off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+			val &= 0xffbfffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+			/* TRx Mask on */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x780);
+
+			/* lock TRx Mask setup */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdd,
+						  0x80, 0x0);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdf,
+						  0x1, 0x0);
+
+			/* Set RF Rx filter corner */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+						  0xfffff, 0x0);
+
+			/* restore WiFi original channel */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x18,
+						  0x3ff, wifi_original_channel);
+
+			outloop = true;
+			break;
+
+		}
+
+	} while (!outloop);
+
+
+
+	psd_scan->is_psd_running = false;
+
+
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8703b1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8703b1ant_
+ * ************************************************************ */
+void ex_halbtc8703b1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x0;
+	u16 u16tmp = 0x0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"xxxxxxxxxxxxxxxx Execute 8703b 1-Ant PowerOn Setting xxxxxxxxxxxxxxxx!!\n");
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "Ant Det Finish = %s, Ant Det Number  = %d\n",
+		    (board_info->btdm_ant_det_finish ? "Yes" : "No"),
+		    board_info->btdm_ant_num_by_ant_det);
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = true;
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write BB/MAC reg correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+	/* set Path control owner to WiFi */
+	halbtc8703b1ant_LTECoex_PathControlOwner(btcoexist,
+			BT_8703B_1ANT_PCO_WLSIDE);
+
+	/* set GNT_BT to high */
+	halbtc8703b1ant_LTECoex_set_GNT_BT(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_HIGH);
+	/* Set GNT_WL to low */
+	halbtc8703b1ant_LTECoex_set_GNT_WL(btcoexist,
+					   BT_8703B_1ANT_GNT_BLOCK_RFC_BB,
+					   BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW,
+					   BT_8703B_1ANT_SIG_STA_SET_TO_LOW);
+
+	/* set WLAN_ACT = 0 */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	halbtc8703b1ant_enable_gnt_to_gpio(btcoexist, FALSE);
+
+	/*  */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+
+	u8tmp = 0;
+	board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+
+	if (btcoexist->chip_interface == BTC_INTF_USB)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60, u8tmp);
+
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], **********  0x70(MAC)/0x38/0x54 (Power-On) =0x%x/  0x%x/ 0x%x**********\n",
+		    btcoexist->btc_read_4byte(btcoexist, 0x70),
+		    halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist, 0x38),
+		    halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist, 0x54));
+	BTC_TRACE(trace_buf);
+
+
+}
+
+void ex_halbtc8703b1ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8703b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8703b1ant_init_hw_config(btcoexist, true, wifi_only);
+	btcoexist->stop_coex_dm = false;
+}
+
+void ex_halbtc8703b1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = false;
+
+	halbtc8703b1ant_init_coex_dm(btcoexist);
+
+	halbtc8703b1ant_query_bt_info(btcoexist);
+}
+
+void ex_halbtc8703b1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_stack_info		*stack_info = &btcoexist->stack_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fa_of_dm, fa_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0;
+	static u8			pop_report_in_10s = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (psd_scan->ant_det_try_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d",
+			   "Ant PG Num/ Mech/ Pos",
+			   board_info->pg_ant_num, board_info->btdm_ant_num,
+			   board_info->btdm_ant_pos);
+		CL_PRINTF(cli_buf);
+	} else {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %d  (%d/%d/%d)",
+			   "Ant PG Num/ Mech(Ant_Det)/ Pos",
+			board_info->pg_ant_num, board_info->btdm_ant_num_by_ant_det,
+			   board_info->btdm_ant_pos,
+			psd_scan->ant_det_try_count, psd_scan->ant_det_fail_count,
+			   psd_scan->ant_det_result);
+		CL_PRINTF(cli_buf);
+
+		if (board_info->btdm_ant_det_finish) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+				   "Ant Det PSD Value",
+				   psd_scan->ant_det_peak_val);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %d",
+		   "BT stack/ hci ext ver",
+		   ((stack_info->profile_notified) ? "Yes" : "No"),
+		   stack_info->hci_version);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%x/ 0x%x/ 0x%x(%d)",
+		   "CoexVer/ FwVer/ PatchVer",
+		   glcoex_ver_date_8703b_1ant, glcoex_ver_8703b_1ant, fw_ver,
+		   bt_patch_ver, bt_patch_ver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s",
+		   "WifibHiPri/ Ccklock/ CckEverLock",
+		   (coex_sta->wifi_is_high_pri_task ? "Yes" : "No"),
+		   (coex_sta->cck_lock ? "Yes" : "No"),
+		   (coex_sta->cck_ever_lock ? "Yes" : "No"));
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page")
+			   : ((BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;
+		pop_report_in_10s = 0;
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d / %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP/Hi-Pri",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist,
+		   bt_link_info->bt_hi_pri_link_exist);
+	CL_PRINTF(cli_buf);
+
+	if (stack_info->profile_notified)
+		btcoexist->btc_disp_dbg_msg(btcoexist,
+					    BTC_DBG_DISP_BT_LINK_INFO);
+	else {
+		bt_info_ext = coex_sta->bt_info_ext;
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s",
+			   "BT Role/A2DP rate",
+			   (bt_link_info->slave_role) ? "Slave" : "Master",
+			   (bt_info_ext & BIT(0)) ? "BR" : "EDR");
+		CL_PRINTF(cli_buf);
+	}
+
+
+	for (i = 0; i < BT_INFO_SRC_8703B_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8703b_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanisms] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[mechanisms]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "SM[LowPenaltyRA]",
+		   coex_dm->cur_low_penalty_ra);
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (%s,%s)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "On" : "Off"),
+		   (coex_dm->auto_tdma_adjust ? "Adj" : "Fix"));
+
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "WL/BT Coex Table Type",
+		   coex_sta->coex_table_type);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x778/0x6cc/IgnWlanAct",
+		   u8tmp[0], u32tmp[0],  coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist,
+			0xa0);
+	u32tmp[1] = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist,
+			0xa4);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "LTE Coex Table W_L/B_L",
+		   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist,
+			0xa8);
+	u32tmp[1] = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist,
+			0xac);
+	u32tmp[2] = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist,
+			0xb0);
+	u32tmp[3] = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist,
+			0xb4);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "LTE Break Table W_L/B_L/L_W/L_B",
+		   u32tmp[0] & 0xffff, u32tmp[1] & 0xffff,
+		   u32tmp[2] & 0xffff, u32tmp[3] & 0xffff);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "0x430/0x434/0x42a/0x456",
+		   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+
+	u32tmp[0] = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist, 0x38);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x73);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %s",
+		   "LTE CoexOn/Path Ctrl Owner",
+		(int)((u32tmp[0]&BIT(7)) >> 7), ((u8tmp[0]&BIT(2)) ? "WL" : "BT"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "LTE 3Wire/OPMode/UART/UARTMode",
+		(int)((u32tmp[0]&BIT(6)) >> 6), (int)((u32tmp[0] & (BIT(5) | BIT(4))) >> 4),
+		   (int)((u32tmp[0]&BIT(3)) >> 3),
+		   (int)(u32tmp[0] & (BIT(2) | BIT(1) | BIT(0))));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %s",
+		   "GNT_WL_SWCtrl/GNT_BT_SWCtrl/Dbg",
+		   (int)((u32tmp[0]&BIT(12)) >> 12), (int)((u32tmp[0]&BIT(14)) >> 14),
+		   ((u8tmp[0]&BIT(3)) ? "On" : "Off"));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = halbtc8703b1ant_LTECoex_InDirectReadReg(btcoexist, 0x54);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "GNT_WL/GNT_BT/LTE_Busy/UART_Busy",
+		   (int)((u32tmp[0]&BIT(2)) >> 2), (int)((u32tmp[0]&BIT(3)) >> 3),
+		   (int)((u32tmp[0]&BIT(1)) >> 1), (int)(u32tmp[0]&BIT(0)));
+	CL_PRINTF(cli_buf);
+
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x4c6);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x4c6[4]/0x40[5] (WL/BT PTA)",
+		   (int)((u8tmp[0] & BIT(4)) >> 4), (int)((u8tmp[1] & BIT(5)) >> 5));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x953);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ %s",
+		   "0x550(bcn ctrl)/0x522/4-RxAGC",
+		   u32tmp[0], u8tmp[0], (u8tmp[1] & 0x2) ? "On" : "Off");
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xda0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xda4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0xda8);
+	u32tmp[3] = btcoexist->btc_read_4byte(btcoexist, 0xcf0);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xa5b);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xa5c);
+
+	fa_of_dm = ((u32tmp[0] & 0xffff0000) >> 16) + ((u32tmp[1] & 0xffff0000)
+			>> 16) + (u32tmp[1] & 0xffff) + (u32tmp[2] & 0xffff) +
+		   ((u32tmp[3] & 0xffff0000) >> 16) + (u32tmp[3] &
+				   0xffff) ;
+	fa_cck = (u8tmp[0] << 8) + u8tmp[1];
+
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0xc50/OFDM-CCA/OFDM-FA/CCK-FA",
+		   u32tmp[1] & 0xff, u32tmp[0] & 0xffff, fa_of_dm, fa_cck);
+	CL_PRINTF(cli_buf);
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-Agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_agg);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-Agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_agg);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+
+	halbtc8703b1ant_ReadScoreBoard(btcoexist,	&u16tmp[0]);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %04x",
+		   "ScoreBoard[14:0] (from BT)", u16tmp[0]);
+	CL_PRINTF(cli_buf);
+
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8703b1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		coex_sta->under_lps = false;
+
+		/* Write WL "Active" in Score-board for LPS off */
+		halbtc8703b1ant_PostActiveStateToBT(btcoexist, false);
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_PostActiveStateToBT(btcoexist, true);
+
+		halbtc8703b1ant_init_hw_config(btcoexist, false, false);
+		halbtc8703b1ant_init_coex_dm(btcoexist);
+		halbtc8703b1ant_query_bt_info(btcoexist);
+
+		coex_sta->under_ips = false;
+	}
+}
+
+void ex_halbtc8703b1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+		coex_sta->under_ips = false;
+
+		if (coex_sta->force_lps_on == true) { /* LPS No-32K */
+			/* Write WL "Active" in Score-board for PS-TDMA */
+			halbtc8703b1ant_PostActiveStateToBT(btcoexist, true);
+
+		} else { /* LPS-32K, need check if this h2c 0x71 can work?? (2015/08/28) */
+			/* Write WL "Non-Active" in Score-board for Native-PS */
+			halbtc8703b1ant_PostActiveStateToBT(btcoexist, false);
+
+		}
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+
+
+		/* Write WL "Active" in Score-board for LPS off */
+		halbtc8703b1ant_PostActiveStateToBT(btcoexist, true);
+
+	}
+}
+
+void ex_halbtc8703b1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_SCAN_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_PostActiveStateToBT(btcoexist, true);
+		halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+	}
+
+	if (coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	halbtc8703b1ant_query_bt_info(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8703b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8703b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		if (coex_sta->c2h_bt_inquiry_page) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is Inquirying\n");
+			BTC_TRACE(trace_buf);
+			halbtc8703b1ant_action_bt_inquiry(btcoexist);
+		} else
+			halbtc8703b1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8703b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8703b1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8703b1ant_action_wifi_not_connected_scan(
+				btcoexist);
+		else	/* wifi is connected */
+			halbtc8703b1ant_action_wifi_connected_scan(btcoexist);
+	} else if (BTC_SCAN_FINISH == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8703b1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8703b1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8703b1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_ASSOCIATE_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		halbtc8703b1ant_PostActiveStateToBT(btcoexist, true);
+		halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		/* coex_dm->arp_cnt = 0; */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8703b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8703b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8703b1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8703b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8703b1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_ASSOCIATE_START == type)
+		halbtc8703b1ant_action_wifi_not_connected_asso_auth(btcoexist);
+	else if (BTC_ASSOCIATE_FINISH == type) {
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+				   &wifi_connected);
+		if (!wifi_connected) /* non-connected scan */
+			halbtc8703b1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8703b1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8703b1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean			wifi_under_b_mode = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_PostActiveStateToBT(btcoexist, true);
+		halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+			/* btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x10); //CCK Tx */
+			/* btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x10); //CCK Rx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_PostActiveStateToBT(btcoexist, false);
+		coex_dm->arp_cnt = 0;
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+
+		coex_sta->cck_ever_lock = false;
+	}
+
+	halbtc8703b1ant_UpdateWifiChannelInfo(btcoexist, type);
+
+}
+
+void ex_halbtc8703b1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false, under_4way = false;
+	u8	agg_buf_size = 5;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    BTC_PACKET_ARP == type) {
+		halbtc8703b1ant_PostActiveStateToBT(btcoexist, true);
+
+		if (BTC_PACKET_ARP == type) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], specific Packet ARP notify\n");
+			BTC_TRACE(trace_buf);
+
+			coex_dm->arp_cnt++;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], ARP Packet Count = %d\n",
+				    coex_dm->arp_cnt);
+			BTC_TRACE(trace_buf);
+
+			if ((coex_dm->arp_cnt >= 10) &&
+			    (!under_4way)) /* if APR PKT > 10 after connect, do not go to ActionWifiConnectedSpecificPacket(btcoexist) */
+				coex_sta->wifi_is_high_pri_task = false;
+			else
+				coex_sta->wifi_is_high_pri_task = true;
+		} else {
+			coex_sta->wifi_is_high_pri_task = true;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], specific Packet DHCP or EAPOL notify\n");
+			BTC_TRACE(trace_buf);
+		}
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet [Type = %d] notify\n", type);
+		BTC_TRACE(trace_buf);
+	}
+
+	coex_sta->specific_pkt_period_cnt = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8703b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8703b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8703b1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8703b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8703b1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    ((BTC_PACKET_ARP == type) && (coex_sta->wifi_is_high_pri_task)))
+		halbtc8703b1ant_action_wifi_connected_specific_packet(btcoexist);
+}
+
+void ex_halbtc8703b1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				bt_info = 0;
+	u8				i, rsp_source = 0;
+	boolean				wifi_connected = false;
+	boolean				bt_busy = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8703B_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8703B_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	/* if 0xff, it means BT is under WHCK test */
+	if (bt_info == 0xff)
+		coex_sta->bt_whck_test = true;
+	else
+		coex_sta->bt_whck_test = false;
+
+	if (BT_INFO_SRC_8703B_1ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x20)
+			coex_sta->c2h_bt_page = true;
+		else
+			coex_sta->c2h_bt_page = false;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 - 90;
+		/* coex_sta->bt_info_c2h[rsp_source][3]*2+10; */
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if (coex_sta->bt_info_ext & BIT(1)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				halbtc8703b1ant_UpdateWifiChannelInfo(btcoexist,
+						      BTC_MEDIA_CONNECT);
+			else
+				halbtc8703b1ant_UpdateWifiChannelInfo(btcoexist,
+						      BTC_MEDIA_DISCONNECT);
+		}
+
+
+#if (BT_AUTO_REPORT_ONLY_8703B_1ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8703b1ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8703B_1ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	coex_sta->num_of_profile = 0;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8703B_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+
+		coex_sta->bt_hi_pri_link_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8703B_1ANT_B_FTP) {
+			coex_sta->pan_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8703B_1ANT_B_A2DP) {
+			coex_sta->a2dp_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8703B_1ANT_B_HID) {
+			coex_sta->hid_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8703B_1ANT_B_SCO_ESCO) {
+			coex_sta->sco_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->sco_exist = false;
+
+		if ((coex_sta->hid_exist == false) &&
+		    (coex_sta->c2h_bt_inquiry_page == false) &&
+		    (coex_sta->sco_exist == false)) {
+			if (coex_sta->high_priority_tx  +
+			    coex_sta->high_priority_rx >= 160) {
+				coex_sta->hid_exist = true;
+				coex_sta->wrong_profile_notification++;
+				coex_sta->num_of_profile++;
+				bt_info = bt_info | 0x28;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BtInfoNotify(), BT HID = true (Hi-Pri > 160)!\n");
+				BTC_TRACE(trace_buf);
+			}
+		}
+
+		/* Add Hi-Pri Tx/Rx counter to avoid false detection */
+		if (((coex_sta->hid_exist) || (coex_sta->sco_exist)) &&
+		    (coex_sta->high_priority_tx + coex_sta->high_priority_rx
+		     >= 160)
+		    && (!coex_sta->c2h_bt_inquiry_page))
+			coex_sta->bt_hi_pri_link_exist = true;
+		else
+			coex_sta->bt_hi_pri_link_exist = false;
+
+		if ((bt_info & BT_INFO_8703B_1ANT_B_ACL_BUSY) &&
+		    (coex_sta->num_of_profile == 0)) {
+			if (coex_sta->low_priority_tx +
+			    coex_sta->low_priority_rx >= 160) {
+				coex_sta->pan_exist = true;
+				coex_sta->num_of_profile++;
+				coex_sta->wrong_profile_notification++;
+				bt_info = bt_info | 0x88;
+			}
+		}
+	}
+
+	halbtc8703b1ant_update_bt_link_info(btcoexist);
+
+	bt_info = bt_info &
+		0x1f;  /* mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41) */
+
+	if (!(bt_info & BT_INFO_8703B_1ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8703B_1ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8703B_1ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8703B_1ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8703B_1ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8703B_1ANT_B_ACL_BUSY) {
+		if (BT_8703B_1ANT_BT_STATUS_ACL_BUSY != coex_dm->bt_status)
+			coex_dm->auto_tdma_adjust = false;
+		coex_dm->bt_status = BT_8703B_1ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8703B_1ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8703B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8703B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	halbtc8703b1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8703b1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_PostActiveStateToBT(btcoexist, true);
+		halbtc8703b1ant_PostOnOffStateToBT(btcoexist, true);
+		
+		halbtc8703b1ant_init_hw_config(btcoexist, false, false);
+		btcoexist->stop_coex_dm = false;
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_PostActiveStateToBT(btcoexist, false);
+		halbtc8703b1ant_PostOnOffStateToBT(btcoexist, false);
+		
+		halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+		btcoexist->stop_coex_dm = true;
+
+	}
+}
+
+void ex_halbtc8703b1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8703b1ant_PostActiveStateToBT(btcoexist, false);
+	halbtc8703b1ant_PostOnOffStateToBT(btcoexist, false);
+
+	halbtc8703b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+	halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, FORCE_EXEC,
+				     false, true);
+
+	ex_halbtc8703b1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	halbtc8703b1ant_enable_gnt_to_gpio(btcoexist, FALSE);
+
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8703b1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8703b1ant_PostActiveStateToBT(btcoexist, false);
+		halbtc8703b1ant_PostOnOffStateToBT(btcoexist, false);
+
+		halbtc8703b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8703b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+		halbtc8703b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		halbtc8703b1ant_PostActiveStateToBT(btcoexist, true);
+		halbtc8703b1ant_PostOnOffStateToBT(btcoexist, true);
+
+		btcoexist->stop_coex_dm = false;
+		halbtc8703b1ant_init_hw_config(btcoexist, false, false);
+		halbtc8703b1ant_init_coex_dm(btcoexist);
+		halbtc8703b1ant_query_bt_info(btcoexist);
+	}
+}
+
+
+void ex_halbtc8703b1ant_ScoreBoardStatusNotify(IN struct btc_coexist *btcoexist,
+		IN u8 *tmp_buf, IN u8 length)
+{
+	/*  */
+
+
+}
+
+void ex_halbtc8703b1ant_coex_dm_reset(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], *****************Coex DM Reset*****************\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8703b1ant_init_hw_config(btcoexist, false, false);
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x2, 0xfffff, 0x0); */
+	halbtc8703b1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8703b1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+
+#if (BT_AUTO_REPORT_ONLY_8703B_1ANT == 0)
+	halbtc8703b1ant_query_bt_info(btcoexist);
+#endif
+
+	halbtc8703b1ant_monitor_bt_ctr(btcoexist);
+	halbtc8703b1ant_monitor_wifi_ctr(btcoexist);
+
+	halbtc8703b1ant_monitor_bt_enable_disable(btcoexist);
+
+	if (halbtc8703b1ant_is_wifi_status_changed(btcoexist) )
+		halbtc8703b1ant_run_coexist_mechanism(btcoexist);
+
+	coex_sta->specific_pkt_period_cnt++;
+}
+
+void ex_halbtc8703b1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+	/* No Antenna Detection required because 8730b is only 1-Ant */
+}
+
+void ex_halbtc8703b1ant_antenna_isolation(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+
+}
+
+void ex_halbtc8703b1ant_psd_scan(IN struct btc_coexist *btcoexist,
+		 IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+
+
+}
+
+void ex_halbtc8703b1ant_display_ant_detection(IN struct btc_coexist *btcoexist)
+{
+
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b1Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b1Ant.h
new file mode 100644
index 000000000..38a034719
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b1Ant.h
@@ -0,0 +1,343 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8703B_SUPPORT == 1)
+/* *******************************************
+ * The following is for 8703B 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8703B_1ANT				1
+#define BT_8703B_1ANT_ENABLE_GNTBT_TO_GPIO14		0
+
+#define	BT_INFO_8703B_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8703B_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8703B_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8703B_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8703B_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8703B_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8703B_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8703B_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8703B_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8703B_1ANT		2
+
+#define  BT_8703B_1ANT_WIFI_NOISY_THRESH							50   /* max: 255 */
+
+/* for Antenna detection */
+#define	BT_8703B_1ANT_ANTDET_PSDTHRES_BACKGROUND					50
+#define	BT_8703B_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION				70
+#define	BT_8703B_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION			55
+#define	BT_8703B_1ANT_ANTDET_PSDTHRES_1ANT							35
+#define	BT_8703B_1ANT_ANTDET_RETRY_INTERVAL							10	/* retry timer if ant det is fail, unit: second */
+#define	BT_8703B_1ANT_ANTDET_ENABLE									0
+#define	BT_8703B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE				0
+
+#define	BT_8703B_1ANT_LTECOEX_INDIRECTREG_ACCESS_TIMEOUT		30000
+
+enum bt_8703b_1ant_signal_state {
+	BT_8703B_1ANT_SIG_STA_SET_TO_LOW		= 0x0,
+	BT_8703B_1ANT_SIG_STA_SET_BY_HW		= 0x0,
+	BT_8703B_1ANT_SIG_STA_SET_TO_HIGH		= 0x1,
+	BT_8703B_1ANT_SIG_STA_MAX
+};
+
+enum bt_8703b_1ant_path_ctrl_owner {
+	BT_8703B_1ANT_PCO_BTSIDE		= 0x0,
+	BT_8703B_1ANT_PCO_WLSIDE	= 0x1,
+	BT_8703B_1ANT_PCO_MAX
+};
+
+enum bt_8703b_1ant_gnt_ctrl_type {
+	BT_8703B_1ANT_GNT_TYPE_CTRL_BY_PTA		= 0x0,
+	BT_8703B_1ANT_GNT_TYPE_CTRL_BY_SW		= 0x1,
+	BT_8703B_1ANT_GNT_TYPE_MAX
+};
+
+enum bt_8703b_1ant_gnt_ctrl_block {
+	BT_8703B_1ANT_GNT_BLOCK_RFC_BB		= 0x0,
+	BT_8703B_1ANT_GNT_BLOCK_RFC			= 0x1,
+	BT_8703B_1ANT_GNT_BLOCK_BB			= 0x2,
+	BT_8703B_1ANT_GNT_BLOCK_MAX
+};
+
+enum bt_8703b_1ant_lte_coex_table_type {
+	BT_8703B_1ANT_CTT_WL_VS_LTE			= 0x0,
+	BT_8703B_1ANT_CTT_BT_VS_LTE			= 0x1,
+	BT_8703B_1ANT_CTT_MAX
+};
+
+enum bt_8703b_1ant_lte_break_table_type {
+	BT_8703B_1ANT_LBTT_WL_BREAK_LTE			= 0x0,
+	BT_8703B_1ANT_LBTT_BT_BREAK_LTE				= 0x1,
+	BT_8703B_1ANT_LBTT_LTE_BREAK_WL			= 0x2,
+	BT_8703B_1ANT_LBTT_LTE_BREAK_BT				= 0x3,
+	BT_8703B_1ANT_LBTT_MAX
+};
+
+enum bt_info_src_8703b_1ant {
+	BT_INFO_SRC_8703B_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8703B_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8703B_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8703B_1ANT_MAX
+};
+
+enum bt_8703b_1ant_bt_status {
+	BT_8703B_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8703B_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8703B_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8703B_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8703B_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8703B_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8703B_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8703b_1ant_wifi_status {
+	BT_8703B_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8703B_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8703B_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8703B_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8703B_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8703B_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8703B_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8703b_1ant_coex_algo {
+	BT_8703B_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8703B_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8703B_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8703B_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8703B_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8703B_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8703B_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8703B_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8703B_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8703B_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8703B_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8703B_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8703b_1ant {
+	/* hw setting */
+	u8		pre_ant_pos_type;
+	u8		cur_ant_pos_type;
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8703b_1ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+	boolean					bt_hi_pri_link_exist;
+	u8					num_of_profile;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	s8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8703B_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8703B_1ANT_MAX];
+	boolean					bt_whck_test;
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_page;				/* Add for win8.1 page out issue */
+	boolean					wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_agg;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_agg;
+
+	boolean					cck_lock;
+	boolean					pre_ccklock;
+	boolean					cck_ever_lock;
+	u8					coex_table_type;
+
+	boolean					force_lps_on;
+	u32					wrong_profile_notification;
+
+	boolean					concurrent_rx_mode_on;
+
+	u16					score_board;
+};
+
+#define  BT_8703B_1ANT_ANTDET_PSD_POINTS			256	/* MAX:1024 */
+#define  BT_8703B_1ANT_ANTDET_PSD_AVGNUM			1	/* MAX:3 */
+#define	BT_8703B_1ANT_ANTDET_BUF_LEN				16
+
+struct psdscan_sta_8703b_1ant {
+
+	u32			ant_det_bt_le_channel;  /* BT LE Channel ex:2412 */
+	u32			ant_det_bt_tx_time;
+	u32			ant_det_pre_psdscan_peak_val;
+	boolean			ant_det_is_ant_det_available;
+	u32			ant_det_psd_scan_peak_val;
+	boolean			ant_det_is_btreply_available;
+	u32			ant_det_psd_scan_peak_freq;
+
+	u8			ant_det_result;
+	u8			ant_det_peak_val[BT_8703B_1ANT_ANTDET_BUF_LEN];
+	u8			ant_det_peak_freq[BT_8703B_1ANT_ANTDET_BUF_LEN];
+	u32			ant_det_try_count;
+	u32			ant_det_fail_count;
+	u32			ant_det_inteval_count;
+	u32			ant_det_thres_offset;
+
+	u32			real_cent_freq;
+	s32			real_offset;
+	u32			real_span;
+
+	u32			psd_band_width;  /* unit: Hz */
+	u32			psd_point;		/* 128/256/512/1024 */
+	u32			psd_report[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_report_max_hold[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_start_point;
+	u32			psd_stop_point;
+	u32			psd_max_value_point;
+	u32			psd_max_value;
+	u32			psd_start_base;
+	u32			psd_avg_num;	/* 1/8/16/32 */
+	u32			psd_gen_count;
+	boolean			is_psd_running;
+	boolean			is_psd_show_max_only;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8703b1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8703b1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8703b1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8703b1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8703b1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8703b1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8703b1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8703b1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8703b1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8703b1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8703b1ant_ScoreBoardStatusNotify(IN struct btc_coexist *btcoexist,
+		IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8703b1ant_coex_dm_reset(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8703b1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8703b1ant_antenna_isolation(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+
+void ex_halbtc8703b1ant_psd_scan(IN struct btc_coexist *btcoexist,
+		 IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+void ex_halbtc8703b1ant_display_ant_detection(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8703b1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8703b1ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8703b1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8703b1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8703b1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8703b1ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8703b1ant_halt_notify(btcoexist)
+#define	ex_halbtc8703b1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8703b1ant_ScoreBoardStatusNotify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8703b1ant_coex_dm_reset(btcoexist)
+#define	ex_halbtc8703b1ant_periodical(btcoexist)
+#define	ex_halbtc8703b1ant_display_coex_info(btcoexist)
+#define	ex_halbtc8703b1ant_antenna_detection(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8703b1ant_antenna_isolation(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8703b1ant_psd_scan(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8703b1ant_display_ant_detection(btcoexist)
+
+#endif
+
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b2Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b2Ant.c
new file mode 100644
index 000000000..81e6b9c60
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b2Ant.c
@@ -0,0 +1,4864 @@
+//============================================================
+// Description:
+//
+// This file is for RTL8703B Co-exist mechanism
+//
+// History
+// 2012/11/15 Cosa first check in.
+//
+//============================================================
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+
+#if WPP_SOFTWARE_TRACE
+#include "HalBtc8703b2Ant.tmh"
+#endif
+
+#if(BT_30_SUPPORT == 1)
+//============================================================
+// Global variables, these are static variables
+//============================================================
+static COEX_DM_8703B_2ANT		GLCoexDm8703b2Ant;
+static PCOEX_DM_8703B_2ANT 	pCoexDm=&GLCoexDm8703b2Ant;
+static COEX_STA_8703B_2ANT		GLCoexSta8703b2Ant;
+static PCOEX_STA_8703B_2ANT	pCoexSta=&GLCoexSta8703b2Ant;
+
+const char *const GLBtInfoSrc8703b2Ant[]={
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u4Byte	GLCoexVerDate8703b2Ant=20140903;
+u4Byte	GLCoexVer8703b2Ant=0x43;
+
+//============================================================
+// local function proto type if needed
+//============================================================
+//============================================================
+// local function start with halbtc8703b2ant_
+//============================================================
+u1Byte
+halbtc8703b2ant_BtRssiState(
+	u1Byte			levelNum,
+	u1Byte			rssiThresh,
+	u1Byte			rssiThresh1
+	)
+{
+	s4Byte			btRssi=0;
+	u1Byte			btRssiState=pCoexSta->preBtRssiState;
+
+	btRssi = pCoexSta->btRssi;
+
+	if(levelNum == 2)
+	{			
+		if( (pCoexSta->preBtRssiState == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preBtRssiState == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(btRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8703B_2ANT))
+			{
+				btRssiState = BTC_RSSI_STATE_HIGH;
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_LOW;
+			}
+		}
+		else
+		{
+			if(btRssi < rssiThresh)
+			{
+				btRssiState = BTC_RSSI_STATE_LOW;
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_HIGH;
+			}
+		}
+	}
+	else if(levelNum == 3)
+	{
+		if(rssiThresh > rssiThresh1)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT Rssi thresh error!!\n"));
+			return pCoexSta->preBtRssiState;
+		}
+		
+		if( (pCoexSta->preBtRssiState == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preBtRssiState == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(btRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8703B_2ANT))
+			{
+				btRssiState = BTC_RSSI_STATE_MEDIUM;
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_LOW;
+			}
+		}
+		else if( (pCoexSta->preBtRssiState == BTC_RSSI_STATE_MEDIUM) ||
+			(pCoexSta->preBtRssiState == BTC_RSSI_STATE_STAY_MEDIUM))
+		{
+			if(btRssi >= (rssiThresh1+BTC_RSSI_COEX_THRESH_TOL_8703B_2ANT))
+			{
+				btRssiState = BTC_RSSI_STATE_HIGH;
+			}
+			else if(btRssi < rssiThresh)
+			{
+				btRssiState = BTC_RSSI_STATE_LOW;
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_MEDIUM;
+			}
+		}
+		else
+		{
+			if(btRssi < rssiThresh1)
+			{
+				btRssiState = BTC_RSSI_STATE_MEDIUM;
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_HIGH;
+			}
+		}
+	}
+		
+	pCoexSta->preBtRssiState = btRssiState;
+
+	return btRssiState;
+}
+
+u1Byte
+halbtc8703b2ant_WifiRssiState(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			index,
+	IN	u1Byte			levelNum,
+	IN	u1Byte			rssiThresh,
+	IN	u1Byte			rssiThresh1
+	)
+{
+	s4Byte			wifiRssi=0;
+	u1Byte			wifiRssiState=pCoexSta->preWifiRssiState[index];
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
+	
+	if(levelNum == 2)
+	{
+		if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(wifiRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8703B_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_HIGH;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_LOW;
+			}
+		}
+		else
+		{
+			if(wifiRssi < rssiThresh)
+			{
+				wifiRssiState = BTC_RSSI_STATE_LOW;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_HIGH;
+			}
+		}
+	}
+	else if(levelNum == 3)
+	{
+		if(rssiThresh > rssiThresh1)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], wifi RSSI thresh error!!\n"));
+			return pCoexSta->preWifiRssiState[index];
+		}
+		
+		if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(wifiRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8703B_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_MEDIUM;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_LOW;
+			}
+		}
+		else if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_MEDIUM) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_MEDIUM))
+		{
+			if(wifiRssi >= (rssiThresh1+BTC_RSSI_COEX_THRESH_TOL_8703B_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_HIGH;
+			}
+			else if(wifiRssi < rssiThresh)
+			{
+				wifiRssiState = BTC_RSSI_STATE_LOW;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_MEDIUM;
+			}
+		}
+		else
+		{
+			if(wifiRssi < rssiThresh1)
+			{
+				wifiRssiState = BTC_RSSI_STATE_MEDIUM;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_HIGH;
+			}
+		}
+	}
+		
+	pCoexSta->preWifiRssiState[index] = wifiRssiState;
+
+	return wifiRssiState;
+}
+
+VOID
+halbtc8703b2ant_MonitorBtEnableDisable(
+	IN 	PBTC_COEXIST		pBtCoexist
+	)
+{
+	static BOOLEAN	bPreBtDisabled=FALSE;
+	static u4Byte	btDisableCnt=0;
+	BOOLEAN			bBtActive=TRUE, bBtDisabled=FALSE;
+
+	// This function check if bt is disabled
+
+	if(	pCoexSta->highPriorityTx == 0 &&
+		pCoexSta->highPriorityRx == 0 &&
+		pCoexSta->lowPriorityTx == 0 &&
+		pCoexSta->lowPriorityRx == 0)
+	{
+		bBtActive = FALSE;
+	}
+	if(	pCoexSta->highPriorityTx == 0xffff &&
+		pCoexSta->highPriorityRx == 0xffff &&
+		pCoexSta->lowPriorityTx == 0xffff &&
+		pCoexSta->lowPriorityRx == 0xffff)
+	{
+		bBtActive = FALSE;
+	}
+	if(bBtActive)
+	{
+		btDisableCnt = 0;
+		bBtDisabled = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_DISABLE, &bBtDisabled);
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is enabled !!\n"));
+	}
+	else
+	{
+		btDisableCnt++;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], bt all counters=0, %d times!!\n", 
+				btDisableCnt));
+		if(btDisableCnt >= 2)
+		{
+			bBtDisabled = TRUE;
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_DISABLE, &bBtDisabled);
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is disabled !!\n"));
+		}
+	}
+	if(bPreBtDisabled != bBtDisabled)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is from %s to %s!!\n", 
+			(bPreBtDisabled ? "disabled":"enabled"), 
+			(bBtDisabled ? "disabled":"enabled")));
+		bPreBtDisabled = bBtDisabled;
+		if(!bBtDisabled)
+		{
+		}
+		else
+		{
+		}
+	}
+}
+
+VOID
+halbtc8703b2ant_LimitedRx(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bForceExec,
+	IN	BOOLEAN				bRejApAggPkt,
+	IN	BOOLEAN				bBtCtrlAggBufSize,
+	IN	u1Byte				aggBufSize
+	)
+{
+	BOOLEAN	bRejectRxAgg=bRejApAggPkt;
+	BOOLEAN	bBtCtrlRxAggSize=bBtCtrlAggBufSize;
+	u1Byte	rxAggSize=aggBufSize;
+
+	//============================================
+	//	Rx Aggregation related setting
+	//============================================
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT, &bRejectRxAgg);
+	// decide BT control aggregation buf size or not
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE, &bBtCtrlRxAggSize);
+	// aggregation buf size, only work when BT control Rx aggregation size.
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_AGG_BUF_SIZE, &rxAggSize);
+	// real update aggregation setting
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+}
+
+VOID
+halbtc8703b2ant_MonitorBtCtr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u4Byte 			regHPTxRx, regLPTxRx, u4Tmp;
+	u4Byte			regHPTx=0, regHPRx=0, regLPTx=0, regLPRx=0;
+	u1Byte			u1Tmp;
+	
+	PBTC_BT_LINK_INFO pBtLinkInfo=&pBtCoexist->btLinkInfo;
+	
+	regHPTxRx = 0x770;
+	regLPTxRx = 0x774;
+
+	u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, regHPTxRx);
+	regHPTx = u4Tmp & bMaskLWord;
+	regHPRx = (u4Tmp & bMaskHWord)>>16;
+
+	u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, regLPTxRx);
+	regLPTx = u4Tmp & bMaskLWord;
+	regLPRx = (u4Tmp & bMaskHWord)>>16;
+		
+	pCoexSta->highPriorityTx = regHPTx;
+	pCoexSta->highPriorityRx = regHPRx;
+	pCoexSta->lowPriorityTx = regLPTx;
+	pCoexSta->lowPriorityRx = regLPRx;
+
+	if ( (pCoexSta->lowPriorityRx >= 950)  &&  (pCoexSta->lowPriorityRx >= pCoexSta->lowPriorityTx) && (!pCoexSta->bUnderIps) )
+	{
+		pBtLinkInfo->bSlaveRole = TRUE;
+	}
+	else
+	{
+		pBtLinkInfo->bSlaveRole = FALSE;
+	}
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n", 
+		regHPTxRx, regHPTx, regHPTx, regHPRx, regHPRx));
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n", 
+		regLPTxRx, regLPTx, regLPTx, regLPRx, regLPRx));
+
+	// reset counter
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0xc);
+}
+
+VOID
+halbtc8703b2ant_MonitorWiFiCtr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u4Byte 	u4Tmp;
+	u2Byte 	u2Tmp[3];
+	s4Byte	wifiRssi=0;
+	BOOLEAN bWifiBusy = FALSE, bWifiUnderBMode = FALSE;
+	static u1Byte nCCKLockCounter = 0;
+
+
+	if (pCoexSta->bUnderIps)
+	{
+		pCoexSta->nCRCOK_CCK = 0;
+		pCoexSta->nCRCOK_11g = 0;
+		pCoexSta->nCRCOK_11n = 0;
+		pCoexSta->nCRCOK_11nAgg = 0;
+
+		pCoexSta->nCRCErr_CCK = 0;
+		pCoexSta->nCRCErr_11g = 0;
+		pCoexSta->nCRCErr_11n = 0;
+		pCoexSta->nCRCErr_11nAgg = 0;	
+	}
+	else
+	{
+		pCoexSta->nCRCOK_CCK	= pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xf88);
+		pCoexSta->nCRCOK_11g 	= pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xf94);
+		pCoexSta->nCRCOK_11n	= pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xf90);
+		pCoexSta->nCRCOK_11nAgg= pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xfb8);
+
+		pCoexSta->nCRCErr_CCK 	 = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xf84);
+		pCoexSta->nCRCErr_11g 	 = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xf96);
+		pCoexSta->nCRCErr_11n 	 = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xf92);
+		pCoexSta->nCRCErr_11nAgg = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xfba);		
+	}
+
+	//reset counter
+	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xf16, 0x1, 0x1);
+	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xf16, 0x1, 0x0);
+}
+
+VOID
+halbtc8703b2ant_QueryBtInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+
+	pCoexSta->bC2hBtInfoReqSent = TRUE;
+
+	H2C_Parameter[0] |= BIT0;	// trigger
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Query Bt Info, FW write 0x61=0x%x\n", 
+		H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x61, 1, H2C_Parameter);
+}
+
+BOOLEAN
+halbtc8703b2ant_IsWifiStatusChanged(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	static BOOLEAN	bPreWifiBusy=FALSE, bPreUnder4way=FALSE, bPreBtHsOn=FALSE;
+	BOOLEAN	bWifiBusy=FALSE, bUnder4way=FALSE, bBtHsOn=FALSE;
+	BOOLEAN	bWifiConnected=FALSE;
+	u1Byte			wifiRssiState=BTC_RSSI_STATE_HIGH;
+	
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS, &bUnder4way);
+
+	if(bWifiConnected)
+	{
+		if(bWifiBusy != bPreWifiBusy)
+		{
+			bPreWifiBusy = bWifiBusy;
+			return TRUE;
+		}
+		if(bUnder4way != bPreUnder4way)
+		{
+			bPreUnder4way = bUnder4way;
+			return TRUE;
+		}
+		if(bBtHsOn != bPreBtHsOn)
+		{
+			bPreBtHsOn = bBtHsOn;
+			return TRUE;
+		}
+
+
+		wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist,3, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+
+		if ( (BTC_RSSI_STATE_HIGH ==wifiRssiState ) ||  (BTC_RSSI_STATE_LOW ==wifiRssiState ))
+		{
+			return TRUE;
+		}
+	
+	}
+
+	return FALSE;
+}
+
+VOID
+halbtc8703b2ant_UpdateBtLinkInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_STACK_INFO 	pStackInfo=&pBtCoexist->stackInfo;
+	PBTC_BT_LINK_INFO	pBtLinkInfo=&pBtCoexist->btLinkInfo;
+	BOOLEAN				bBtHsOn=FALSE;
+
+#if(BT_AUTO_REPORT_ONLY_8703B_2ANT == 1)	// profile from bt patch
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+
+	pBtLinkInfo->bBtLinkExist = pCoexSta->bBtLinkExist;
+	pBtLinkInfo->bScoExist = pCoexSta->bScoExist;
+	pBtLinkInfo->bA2dpExist = pCoexSta->bA2dpExist;
+	pBtLinkInfo->bPanExist = pCoexSta->bPanExist;
+	pBtLinkInfo->bHidExist = pCoexSta->bHidExist;
+
+	// work around for HS mode.
+	if(bBtHsOn)
+	{
+		pBtLinkInfo->bPanExist = TRUE;
+		pBtLinkInfo->bBtLinkExist = TRUE;
+	}
+#else	// profile from bt stack
+	pBtLinkInfo->bBtLinkExist = pStackInfo->bBtLinkExist;
+	pBtLinkInfo->bScoExist = pStackInfo->bScoExist;
+	pBtLinkInfo->bA2dpExist = pStackInfo->bA2dpExist;
+	pBtLinkInfo->bPanExist = pStackInfo->bPanExist;
+	pBtLinkInfo->bHidExist = pStackInfo->bHidExist;
+
+	//for win-8 stack HID report error
+	if(!pStackInfo->bHidExist)
+		pStackInfo->bHidExist = pCoexSta->bHidExist;  //sync  BTInfo with BT firmware and stack
+	// when stack HID report error, here we use the info from bt fw.
+	if(!pStackInfo->bBtLinkExist)
+		pStackInfo->bBtLinkExist = pCoexSta->bBtLinkExist;	
+#endif
+	// check if Sco only
+	if( pBtLinkInfo->bScoExist &&
+		!pBtLinkInfo->bA2dpExist &&
+		!pBtLinkInfo->bPanExist &&
+		!pBtLinkInfo->bHidExist )
+		pBtLinkInfo->bScoOnly = TRUE;
+	else
+		pBtLinkInfo->bScoOnly = FALSE;
+
+	// check if A2dp only
+	if( !pBtLinkInfo->bScoExist &&
+		pBtLinkInfo->bA2dpExist &&
+		!pBtLinkInfo->bPanExist &&
+		!pBtLinkInfo->bHidExist )
+		pBtLinkInfo->bA2dpOnly = TRUE;
+	else
+		pBtLinkInfo->bA2dpOnly = FALSE;
+
+	// check if Pan only
+	if( !pBtLinkInfo->bScoExist &&
+		!pBtLinkInfo->bA2dpExist &&
+		pBtLinkInfo->bPanExist &&
+		!pBtLinkInfo->bHidExist )
+		pBtLinkInfo->bPanOnly = TRUE;
+	else
+		pBtLinkInfo->bPanOnly = FALSE;
+	
+	// check if Hid only
+	if( !pBtLinkInfo->bScoExist &&
+		!pBtLinkInfo->bA2dpExist &&
+		!pBtLinkInfo->bPanExist &&
+		pBtLinkInfo->bHidExist )
+		pBtLinkInfo->bHidOnly = TRUE;
+	else
+		pBtLinkInfo->bHidOnly = FALSE;
+}
+
+u1Byte
+halbtc8703b2ant_ActionAlgorithm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BT_LINK_INFO	pBtLinkInfo=&pBtCoexist->btLinkInfo;
+	BOOLEAN				bBtHsOn=FALSE;
+	u1Byte				algorithm=BT_8703B_2ANT_COEX_ALGO_UNDEFINED;
+	u1Byte				numOfDiffProfile=0;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+		
+	if(!pBtLinkInfo->bBtLinkExist)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], No BT link exists!!!\n"));
+		return algorithm;
+	}
+
+	if(pBtLinkInfo->bScoExist)
+		numOfDiffProfile++;
+	if(pBtLinkInfo->bHidExist)
+		numOfDiffProfile++;
+	if(pBtLinkInfo->bPanExist)
+		numOfDiffProfile++;
+	if(pBtLinkInfo->bA2dpExist)
+		numOfDiffProfile++;
+	
+	if(numOfDiffProfile == 1)
+	{
+		if(pBtLinkInfo->bScoExist)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO only\n"));
+			algorithm = BT_8703B_2ANT_COEX_ALGO_SCO;
+		}
+		else
+		{
+			if(pBtLinkInfo->bHidExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID only\n"));
+				algorithm = BT_8703B_2ANT_COEX_ALGO_HID;
+			}
+			else if(pBtLinkInfo->bA2dpExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], A2DP only\n"));
+				algorithm = BT_8703B_2ANT_COEX_ALGO_A2DP;
+			}
+			else if(pBtLinkInfo->bPanExist)
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN(HS) only\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_PANHS;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN(EDR) only\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	}
+	else if(numOfDiffProfile == 2)
+	{
+		if(pBtLinkInfo->bScoExist)
+		{
+			if(pBtLinkInfo->bHidExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + HID\n"));
+				algorithm = BT_8703B_2ANT_COEX_ALGO_PANEDR_HID;
+			}
+			else if(pBtLinkInfo->bA2dpExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + A2DP ==> SCO\n"));
+				algorithm = BT_8703B_2ANT_COEX_ALGO_PANEDR_HID;
+			}
+			else if(pBtLinkInfo->bPanExist)
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + PAN(HS)\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_SCO;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + PAN(EDR)\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+		else
+		{
+			if( pBtLinkInfo->bHidExist &&
+				pBtLinkInfo->bA2dpExist )
+			{
+#if 0
+				if(pStackInfo->numOfHid >= 2)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID*2 + A2DP\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+				else
+#endif
+				{			
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + A2DP\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			}
+			else if( pBtLinkInfo->bHidExist &&
+				pBtLinkInfo->bPanExist )
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + PAN(HS)\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_HID;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + PAN(EDR)\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+			else if( pBtLinkInfo->bPanExist &&
+				pBtLinkInfo->bA2dpExist )
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], A2DP + PAN(HS)\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_A2DP_PANHS;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], A2DP + PAN(EDR)\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	}
+	else if(numOfDiffProfile == 3)
+	{
+		if(pBtLinkInfo->bScoExist)
+		{
+			if( pBtLinkInfo->bHidExist &&
+				pBtLinkInfo->bA2dpExist )
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + HID + A2DP ==> HID\n"));
+				algorithm = BT_8703B_2ANT_COEX_ALGO_PANEDR_HID;
+			}
+			else if( pBtLinkInfo->bHidExist &&
+				pBtLinkInfo->bPanExist )
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + HID + PAN(HS)\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + HID + PAN(EDR)\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+			else if( pBtLinkInfo->bPanExist &&
+				pBtLinkInfo->bA2dpExist )
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + A2DP + PAN(HS)\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+		else
+		{
+			if( pBtLinkInfo->bHidExist &&
+				pBtLinkInfo->bPanExist &&
+				pBtLinkInfo->bA2dpExist )
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + A2DP + PAN(HS)\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_HID_A2DP;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + A2DP + PAN(EDR)\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	}
+	else if(numOfDiffProfile >= 3)
+	{
+		if(pBtLinkInfo->bScoExist)
+		{
+			if( pBtLinkInfo->bHidExist &&
+				pBtLinkInfo->bPanExist &&
+				pBtLinkInfo->bA2dpExist )
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n"));
+
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n"));
+					algorithm = BT_8703B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+VOID
+halbtc8703b2ant_SetFwDacSwingLevel(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			dacSwingLvl
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+
+	// There are several type of dacswing
+	// 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6
+	H2C_Parameter[0] = dacSwingLvl;
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Set Dac Swing Level=0x%x\n", dacSwingLvl));
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], FW write 0x64=0x%x\n", H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x64, 1, H2C_Parameter);
+}
+
+VOID
+halbtc8703b2ant_SetFwDecBtPwr(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte				decBtPwrLvl
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+	
+	H2C_Parameter[0] = decBtPwrLvl;
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], decrease Bt Power level = %d, FW write 0x62=0x%x\n", 
+		decBtPwrLvl, H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x62, 1, H2C_Parameter);	
+}
+
+VOID
+halbtc8703b2ant_DecBtPwr(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	u1Byte				decBtPwrLvl
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s Dec BT power level = %d\n",  
+		(bForceExec? "force to":""), decBtPwrLvl));
+	pCoexDm->curBtDecPwrLvl = decBtPwrLvl;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->preBtDecPwrLvl == pCoexDm->curBtDecPwrLvl) 
+			return;
+	}
+	halbtc8703b2ant_SetFwDecBtPwr(pBtCoexist, pCoexDm->curBtDecPwrLvl);
+
+	pCoexDm->preBtDecPwrLvl = pCoexDm->curBtDecPwrLvl;
+}
+
+VOID
+halbtc8703b2ant_SetBtAutoReport(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bEnableAutoReport
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+	
+	H2C_Parameter[0] = 0;
+
+	if(bEnableAutoReport)
+	{
+		H2C_Parameter[0] |= BIT0;
+	}
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], BT FW auto report : %s, FW write 0x68=0x%x\n", 
+		(bEnableAutoReport? "Enabled!!":"Disabled!!"), H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x68, 1, H2C_Parameter);	
+}
+
+VOID
+halbtc8703b2ant_BtAutoReport(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bEnableAutoReport
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s BT Auto report = %s\n",  
+		(bForceExec? "force to":""), ((bEnableAutoReport)? "Enabled":"Disabled")));
+	pCoexDm->bCurBtAutoReport = bEnableAutoReport;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreBtAutoReport == pCoexDm->bCurBtAutoReport) 
+			return;
+	}
+	halbtc8703b2ant_SetBtAutoReport(pBtCoexist, pCoexDm->bCurBtAutoReport);
+
+	pCoexDm->bPreBtAutoReport = pCoexDm->bCurBtAutoReport;
+}
+
+VOID
+halbtc8703b2ant_FwDacSwingLvl(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	u1Byte			fwDacSwingLvl
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s set FW Dac Swing level = %d\n",  
+		(bForceExec? "force to":""), fwDacSwingLvl));
+	pCoexDm->curFwDacSwingLvl = fwDacSwingLvl;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->preFwDacSwingLvl == pCoexDm->curFwDacSwingLvl) 
+			return;
+	}
+
+	halbtc8703b2ant_SetFwDacSwingLevel(pBtCoexist, pCoexDm->curFwDacSwingLvl);
+
+	pCoexDm->preFwDacSwingLvl = pCoexDm->curFwDacSwingLvl;
+}
+
+VOID
+halbtc8703b2ant_SetSwRfRxLpfCorner(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bRxRfShrinkOn
+	)
+{
+	if(bRxRfShrinkOn)
+	{
+		//Shrink RF Rx LPF corner
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Shrink RF Rx LPF corner!!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff, 0xffffc);
+	}
+	else
+	{
+		//Resume RF Rx LPF corner
+		// After initialized, we can use pCoexDm->btRf0x1eBackup
+		if(pBtCoexist->bInitilized)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Resume RF Rx LPF corner!!\n"));
+			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff, pCoexDm->btRf0x1eBackup);
+		}
+	}
+}
+
+VOID
+halbtc8703b2ant_RfShrink(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bRxRfShrinkOn
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn Rx RF Shrink = %s\n",  
+		(bForceExec? "force to":""), ((bRxRfShrinkOn)? "ON":"OFF")));
+	pCoexDm->bCurRfRxLpfShrink = bRxRfShrinkOn;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreRfRxLpfShrink == pCoexDm->bCurRfRxLpfShrink) 
+			return;
+	}
+	halbtc8703b2ant_SetSwRfRxLpfCorner(pBtCoexist, pCoexDm->bCurRfRxLpfShrink);
+
+	pCoexDm->bPreRfRxLpfShrink = pCoexDm->bCurRfRxLpfShrink;
+}
+
+VOID
+halbtc8703b2ant_SetSwPenaltyTxRateAdaptive(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bLowPenaltyRa
+	)
+{
+	u1Byte			H2C_Parameter[6] ={0};
+	
+	H2C_Parameter[0] = 0x6;	// opCode, 0x6= Retry_Penalty
+
+	if(bLowPenaltyRa)
+	{
+		H2C_Parameter[1] |= BIT0;
+		H2C_Parameter[2] = 0x00;  //normal rate except MCS7/6/5, OFDM54/48/36
+		H2C_Parameter[3] = 0xf7;  //MCS7 or OFDM54
+		H2C_Parameter[4] = 0xf8;  //MCS6 or OFDM48
+		H2C_Parameter[5] = 0xf9;	//MCS5 or OFDM36	
+	}
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set WiFi Low-Penalty Retry: %s", 
+		(bLowPenaltyRa? "ON!!":"OFF!!")) );
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x69, 6, H2C_Parameter);
+}
+
+VOID
+halbtc8703b2ant_LowPenaltyRa(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bLowPenaltyRa
+	)
+{
+	//return;
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn LowPenaltyRA = %s\n",  
+		(bForceExec? "force to":""), ((bLowPenaltyRa)? "ON":"OFF")));
+	pCoexDm->bCurLowPenaltyRa = bLowPenaltyRa;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreLowPenaltyRa == pCoexDm->bCurLowPenaltyRa) 
+			return;
+	}
+	halbtc8703b2ant_SetSwPenaltyTxRateAdaptive(pBtCoexist, pCoexDm->bCurLowPenaltyRa);
+
+	pCoexDm->bPreLowPenaltyRa = pCoexDm->bCurLowPenaltyRa;
+}
+
+VOID
+halbtc8703b2ant_SetDacSwingReg(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u4Byte			level
+	)
+{
+	u1Byte	val=(u1Byte)level;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Write SwDacSwing = 0x%x\n", level));
+	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x883, 0x3e, val);
+}
+
+VOID
+halbtc8703b2ant_SetSwFullTimeDacSwing(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bSwDacSwingOn,
+	IN	u4Byte			swDacSwingLvl
+	)
+{
+	if(bSwDacSwingOn)
+	{
+		halbtc8703b2ant_SetDacSwingReg(pBtCoexist, swDacSwingLvl);
+	}
+	else
+	{
+		halbtc8703b2ant_SetDacSwingReg(pBtCoexist, 0x18);
+	}
+}
+
+
+VOID
+halbtc8703b2ant_DacSwing(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bDacSwingOn,
+	IN	u4Byte			dacSwingLvl
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn DacSwing=%s, dacSwingLvl=0x%x\n",  
+		(bForceExec? "force to":""), ((bDacSwingOn)? "ON":"OFF"), dacSwingLvl));
+	pCoexDm->bCurDacSwingOn = bDacSwingOn;
+	pCoexDm->curDacSwingLvl = dacSwingLvl;
+
+	if(!bForceExec)
+	{
+		if( (pCoexDm->bPreDacSwingOn == pCoexDm->bCurDacSwingOn) &&
+			(pCoexDm->preDacSwingLvl == pCoexDm->curDacSwingLvl) )
+			return;
+	}
+	delay_ms(30);
+	halbtc8703b2ant_SetSwFullTimeDacSwing(pBtCoexist, bDacSwingOn, dacSwingLvl);
+
+	pCoexDm->bPreDacSwingOn = pCoexDm->bCurDacSwingOn;
+	pCoexDm->preDacSwingLvl = pCoexDm->curDacSwingLvl;
+}
+
+VOID
+halbtc8703b2ant_SetAdcBackOff(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bAdcBackOff
+	)
+{
+	if(bAdcBackOff)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BB BackOff Level On!\n"));
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xc05, 0x30, 0x3);
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BB BackOff Level Off!\n"));
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xc05, 0x30, 0x1);
+	}
+}
+
+VOID
+halbtc8703b2ant_AdcBackOff(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bAdcBackOff
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn AdcBackOff = %s\n",  
+		(bForceExec? "force to":""), ((bAdcBackOff)? "ON":"OFF")));
+	pCoexDm->bCurAdcBackOff = bAdcBackOff;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreAdcBackOff == pCoexDm->bCurAdcBackOff) 
+			return;
+	}
+	halbtc8703b2ant_SetAdcBackOff(pBtCoexist, pCoexDm->bCurAdcBackOff);
+
+	pCoexDm->bPreAdcBackOff = pCoexDm->bCurAdcBackOff;
+}
+
+VOID
+halbtc8703b2ant_SetAgcTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bAgcTableEn
+	)
+{
+	u1Byte		rssiAdjustVal=0;
+
+	//=================BB AGC Gain Table
+	if(bAgcTableEn)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BB Agc Table On!\n"));
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6e1A0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6d1B0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6c1C0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6b1D0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x6a1E0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x691F0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0x68200001);
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BB Agc Table Off!\n"));
+	 	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0xaa1A0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0xa91B0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0xa81C0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0xa71D0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0xa61E0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0xa51F0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78, 0xa4200001);
+	}
+	
+	
+	//=================RF Gain
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0xef, 0xfffff, 0x02000);
+	if(bAgcTableEn)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Agc Table On!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x3b, 0xfffff, 0x38fff);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x3b, 0xfffff, 0x38ffe);
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Agc Table Off!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x3b, 0xfffff, 0x380c3);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x3b, 0xfffff, 0x28ce6);
+	}
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0xef, 0xfffff, 0x0);
+
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0xed, 0xfffff, 0x1);
+	if(bAgcTableEn)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Agc Table On!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x40, 0xfffff, 0x38fff);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x40, 0xfffff, 0x38ffe);
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Agc Table Off!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x40, 0xfffff, 0x380c3);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x40, 0xfffff, 0x28ce6);
+	}
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0xed, 0xfffff, 0x0);
+
+	// set rssiAdjustVal for wifi module.
+	if(bAgcTableEn)
+	{
+		rssiAdjustVal = 8;
+	}
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON, &rssiAdjustVal);
+}
+
+VOID
+halbtc8703b2ant_AgcTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bAgcTableEn
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s %s Agc Table\n",  
+		(bForceExec? "force to":""), ((bAgcTableEn)? "Enable":"Disable")));
+	pCoexDm->bCurAgcTableEn = bAgcTableEn;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreAgcTableEn == pCoexDm->bCurAgcTableEn) 
+			return;
+	}
+	halbtc8703b2ant_SetAgcTable(pBtCoexist, bAgcTableEn);
+
+	pCoexDm->bPreAgcTableEn = pCoexDm->bCurAgcTableEn;
+}
+
+VOID
+halbtc8703b2ant_SetCoexTable(
+	IN	PBTC_COEXIST	pBtCoexist,
+	IN	u4Byte		val0x6c0,
+	IN	u4Byte		val0x6c4,
+	IN	u4Byte		val0x6c8,
+	IN	u1Byte		val0x6cc
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set coex table, set 0x6c0=0x%x\n", val0x6c0));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c0, val0x6c0);
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set coex table, set 0x6c4=0x%x\n", val0x6c4));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c4, val0x6c4);
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set coex table, set 0x6c8=0x%x\n", val0x6c8));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c8, val0x6c8);
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set coex table, set 0x6cc=0x%x\n", val0x6cc));
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x6cc, val0x6cc);
+}
+
+VOID
+halbtc8703b2ant_CoexTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	u4Byte			val0x6c0,
+	IN	u4Byte			val0x6c4,
+	IN	u4Byte			val0x6c8,
+	IN	u1Byte			val0x6cc
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s write Coex Table 0x6c0=0x%x, 0x6c4=0x%x, 0x6c8=0x%x, 0x6cc=0x%x\n", 
+		(bForceExec? "force to":""), val0x6c0, val0x6c4, val0x6c8, val0x6cc));
+	pCoexDm->curVal0x6c0 = val0x6c0;
+	pCoexDm->curVal0x6c4 = val0x6c4;
+	pCoexDm->curVal0x6c8 = val0x6c8;
+	pCoexDm->curVal0x6cc = val0x6cc;
+
+	if(!bForceExec)
+	{
+		if( (pCoexDm->preVal0x6c0 == pCoexDm->curVal0x6c0) &&
+			(pCoexDm->preVal0x6c4 == pCoexDm->curVal0x6c4) &&
+			(pCoexDm->preVal0x6c8 == pCoexDm->curVal0x6c8) &&
+			(pCoexDm->preVal0x6cc == pCoexDm->curVal0x6cc) )
+			return;
+	}
+	halbtc8703b2ant_SetCoexTable(pBtCoexist, val0x6c0, val0x6c4, val0x6c8, val0x6cc);
+
+	pCoexDm->preVal0x6c0 = pCoexDm->curVal0x6c0;
+	pCoexDm->preVal0x6c4 = pCoexDm->curVal0x6c4;
+	pCoexDm->preVal0x6c8 = pCoexDm->curVal0x6c8;
+	pCoexDm->preVal0x6cc = pCoexDm->curVal0x6cc;
+}
+
+VOID
+halbtc8703b2ant_CoexTableWithType(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bForceExec,
+	IN	u1Byte				type
+	)
+{
+	pCoexSta->nCoexTableType = type;
+	
+	switch(type)
+	{
+		case 0:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0x55555555, 0xffffff, 0x3);
+			break;
+		case 1:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0x5afa5afa, 0xffffff, 0x3);
+			break;
+		case 2:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x5ada5ada, 0x5ada5ada, 0xffffff, 0x3);
+			break;
+		case 3:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+			break;
+		case 4:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0xffffffff, 0xffffffff, 0xffffff, 0x3);
+			break;
+		case 5:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x5fff5fff, 0x5fff5fff, 0xffffff, 0x3);
+			break;
+		case 6:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x55ff55ff, 0x5a5a5a5a, 0xffffff, 0x3);
+			break;
+		case 7:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+			break;
+		case 8:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+			break;
+		case 9:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+			break;
+		case 10:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+			break;
+		case 11:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+			break;
+		case 12:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+			break;
+		case 13:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x5fff5fff, 0xaaaaaaaa, 0xffffff, 0x3);
+			break;
+		case 14:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x5fff5fff, 0x5ada5ada, 0xffffff, 0x3);
+			break;
+		case 15:
+			halbtc8703b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0xaaaaaaaa, 0xffffff, 0x3);
+			break;
+		default:
+			break;
+	}
+}
+
+VOID
+halbtc8703b2ant_SetFwIgnoreWlanAct(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bEnable
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+		
+	if(bEnable)
+	{
+		H2C_Parameter[0] |= BIT0;		// function enable
+	}
+	
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set FW for BT Ignore Wlan_Act, FW write 0x63=0x%x\n", 
+		H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x63, 1, H2C_Parameter);
+}
+
+VOID
+halbtc8703b2ant_SetLpsRpwm(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			lpsVal,
+	IN	u1Byte			rpwmVal
+	)
+{
+	u1Byte	lps=lpsVal;
+	u1Byte	rpwm=rpwmVal;
+	
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_LPS_VAL, &lps);
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+VOID
+halbtc8703b2ant_LpsRpwm(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	u1Byte			lpsVal,
+	IN	u1Byte			rpwmVal
+	)
+{
+	BOOLEAN	bForceExecPwrCmd=FALSE;
+	
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s set lps/rpwm=0x%x/0x%x \n", 
+		(bForceExec? "force to":""), lpsVal, rpwmVal));
+	pCoexDm->curLps = lpsVal;
+	pCoexDm->curRpwm = rpwmVal;
+
+	if(!bForceExec)
+	{
+		if( (pCoexDm->preLps == pCoexDm->curLps) &&
+			(pCoexDm->preRpwm == pCoexDm->curRpwm) )
+		{
+			return;
+		}
+	}
+	halbtc8703b2ant_SetLpsRpwm(pBtCoexist, lpsVal, rpwmVal);
+
+	pCoexDm->preLps = pCoexDm->curLps;
+	pCoexDm->preRpwm = pCoexDm->curRpwm;
+}
+
+VOID
+halbtc8703b2ant_IgnoreWlanAct(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bEnable
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn Ignore WlanAct %s\n", 
+		(bForceExec? "force to":""), (bEnable? "ON":"OFF")));
+	pCoexDm->bCurIgnoreWlanAct = bEnable;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreIgnoreWlanAct == pCoexDm->bCurIgnoreWlanAct)
+			return;
+	}
+	halbtc8703b2ant_SetFwIgnoreWlanAct(pBtCoexist, bEnable);
+
+	pCoexDm->bPreIgnoreWlanAct = pCoexDm->bCurIgnoreWlanAct;
+}
+
+VOID
+halbtc8703b2ant_SetFwPstdma(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			byte1,
+	IN	u1Byte			byte2,
+	IN	u1Byte			byte3,
+	IN	u1Byte			byte4,
+	IN	u1Byte			byte5
+	)
+{
+	u1Byte			H2C_Parameter[5] ={0};
+
+
+	 if ( (pCoexSta->bA2dpExist) && (pCoexSta->bHidExist) )
+	 {
+		byte5 = byte5 | 0x1;
+	 }
+	 
+	H2C_Parameter[0] = byte1;	
+	H2C_Parameter[1] = byte2;	
+	H2C_Parameter[2] = byte3;
+	H2C_Parameter[3] = byte4;
+	H2C_Parameter[4] = byte5;
+
+	pCoexDm->psTdmaPara[0] = byte1;
+	pCoexDm->psTdmaPara[1] = byte2;
+	pCoexDm->psTdmaPara[2] = byte3;
+	pCoexDm->psTdmaPara[3] = byte4;
+	pCoexDm->psTdmaPara[4] = byte5;
+	
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], FW write 0x60(5bytes)=0x%x%08x\n", 
+		H2C_Parameter[0], 
+		H2C_Parameter[1]<<24|H2C_Parameter[2]<<16|H2C_Parameter[3]<<8|H2C_Parameter[4]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x60, 5, H2C_Parameter);
+}
+
+VOID
+halbtc8703b2ant_SwMechanism1(
+	IN	PBTC_COEXIST	pBtCoexist,	
+	IN	BOOLEAN		bShrinkRxLPF,
+	IN	BOOLEAN 	bLowPenaltyRA,
+	IN	BOOLEAN		bLimitedDIG, 
+	IN	BOOLEAN		bBTLNAConstrain
+	) 
+{
+	/*
+	u4Byte	wifiBw;
+	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	
+	if(BTC_WIFI_BW_HT40 != wifiBw)  //only shrink RF Rx LPF for HT40
+	{
+		if (bShrinkRxLPF)
+			bShrinkRxLPF = FALSE;
+	}
+	*/
+	
+	//halbtc8703b2ant_RfShrink(pBtCoexist, NORMAL_EXEC, bShrinkRxLPF);
+	halbtc8703b2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, bLowPenaltyRA);
+}
+
+VOID
+halbtc8703b2ant_SwMechanism2(
+	IN	PBTC_COEXIST	pBtCoexist,	
+	IN	BOOLEAN		bAGCTableShift,
+	IN	BOOLEAN 	bADCBackOff,
+	IN	BOOLEAN		bSWDACSwing,
+	IN	u4Byte		dacSwingLvl
+	) 
+{
+	//halbtc8703b2ant_AgcTable(pBtCoexist, NORMAL_EXEC, bAGCTableShift);
+	//halbtc8703b2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, bADCBackOff);
+	//halbtc8703b2ant_DacSwing(pBtCoexist, NORMAL_EXEC, bSWDACSwing, dacSwingLvl);
+}
+
+VOID
+halbtc8703b2ant_SetAntPath(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte				antPosType,
+	IN	BOOLEAN				bInitHwCfg,
+	IN	BOOLEAN				bWifiOff
+	)
+{
+	PBTC_BOARD_INFO pBoardInfo=&pBtCoexist->boardInfo;
+	u4Byte			fwVer=0, u4Tmp=0;
+	BOOLEAN			bPgExtSwitch=FALSE;
+	BOOLEAN			bUseExtSwitch=FALSE;
+	u1Byte			H2C_Parameter[2] ={0};
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_EXT_SWITCH, &bPgExtSwitch);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_FW_VER, &fwVer);	// [31:16]=fw ver, [15:0]=fw sub ver
+
+	if((fwVer>0 && fwVer<0xc0000) || bPgExtSwitch)
+		bUseExtSwitch = TRUE;
+
+	if(bInitHwCfg)
+	{
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x39, 0x8, 0x1);
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x974, 0xff);
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x944, 0x3, 0x3);
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x930, 0x77);
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x67, 0x20, 0x1);
+
+		if(fwVer >= 0x180000)
+		{
+			/* Use H2C to set GNT_BT to High to avoid A2DP click */
+			H2C_Parameter[0] = 1;
+		pBtCoexist->fBtcFillH2c(pBtCoexist, 0x6E, 1, H2C_Parameter);
+		}
+		else
+		{
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x765, 0x18);
+		}
+		
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0);
+
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); //WiFi TRx Mask off
+		//remove due to interrupt is disabled that polling c2h will fail and delay 100ms.
+		//pBtCoexist->fBtcSetBtReg(pBtCoexist, BTC_BT_REG_RF, 0x3c, 0x01); //BT TRx Mask off
+
+		if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
+		{
+			//tell firmware "no antenna inverse"
+			H2C_Parameter[0] = 0;
+		}
+		else
+		{
+			//tell firmware "antenna inverse"
+			H2C_Parameter[0] = 1;
+		}
+
+		if (bUseExtSwitch)
+		{
+			//ext switch type
+			H2C_Parameter[1] = 1;
+		}
+		else
+		{
+			//int switch type
+			H2C_Parameter[1] = 0;
+		}
+		pBtCoexist->fBtcFillH2c(pBtCoexist, 0x65, 2, H2C_Parameter);
+	}
+	else
+	{
+		if(fwVer >= 0x180000)
+		{
+			/* Use H2C to set GNT_BT to "Control by PTA"*/
+			H2C_Parameter[0] = 0;
+			pBtCoexist->fBtcFillH2c(pBtCoexist, 0x6E, 1, H2C_Parameter);			
+		}
+		else
+		{
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x765, 0x0);
+		}
+	}
+
+	// ext switch setting
+	if(bUseExtSwitch)
+	{
+		if (bInitHwCfg)
+		{
+			// 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT
+			u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x4c);
+			u4Tmp &=~BIT23;
+			u4Tmp |= BIT24;
+			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x4c, u4Tmp);
+		}
+		
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0); // fixed internal switch S1->WiFi, S0->BT
+		switch(antPosType)
+		{
+			case BTC_ANT_WIFI_AT_MAIN:
+				pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x1);	// ext switch main at wifi
+				break;
+			case BTC_ANT_WIFI_AT_AUX:
+				pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x2);	// ext switch aux at wifi
+				break;
+		}	
+	}
+	else	// internal switch
+	{
+		if (bInitHwCfg)
+		{
+			// 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT
+			u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x4c);
+			u4Tmp |= BIT23;
+			u4Tmp &=~BIT24;
+			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x4c, u4Tmp);
+		}
+		
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x64, 0x1, 0x0); //fixed external switch S1->Main, S0->Aux
+		switch(antPosType)
+		{
+			case BTC_ANT_WIFI_AT_MAIN:
+				pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0); // fixed internal switch S1->WiFi, S0->BT
+				break;
+			case BTC_ANT_WIFI_AT_AUX:
+				pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x280); // fixed internal switch S0->WiFi, S1->BT
+				break;
+		}
+	}
+}
+
+VOID
+halbtc8703b2ant_PsTdma(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bTurnOn,
+	IN	u1Byte			type
+	)
+{
+	BOOLEAN			bTurnOnByCnt=FALSE;
+	u1Byte			psTdmaTypeByCnt=0;
+	u1Byte			wifiRssiState1, btRssiState;
+
+	
+	wifiRssiState1 = halbtc8703b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	btRssiState = halbtc8703b2ant_BtRssiState(2, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], %s turn %s PS TDMA, type=%d\n", 
+		(bForceExec? "force to":""), (bTurnOn? "ON":"OFF"), type));
+	pCoexDm->bCurPsTdmaOn = bTurnOn;
+	pCoexDm->curPsTdma = type;
+
+	if (!(BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState)) && bTurnOn)
+	{
+		type = type +100;  //for WiFi RSSI low or BT RSSI low
+		pCoexDm->bIsSwitchTo1dot5Ant = TRUE;
+	}
+	else
+	{
+		pCoexDm->bIsSwitchTo1dot5Ant = FALSE;
+	}
+
+
+	if(!bForceExec)
+	{
+		if( (pCoexDm->bPrePsTdmaOn == pCoexDm->bCurPsTdmaOn) &&
+			(pCoexDm->prePsTdma == pCoexDm->curPsTdma) )
+			return;
+	}	
+	if(bTurnOn)
+	{
+		switch(type)
+		{
+			case 1:
+			default:
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x03, 0xf1, 0x90);
+				break;
+			case 2:
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0xe1, 0x90);
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x2d, 0x03, 0xf1, 0x90);
+				break;
+			case 3:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1c, 0x3, 0xf1, 0x90);
+				break;
+			case 4:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x10, 0x03, 0xf1, 0x90);
+				break;
+			case 5:
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90);
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x3, 0x70, 0x90);				
+				break;
+			case 6:
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0x60, 0x90);
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x2d, 0x3, 0x70, 0x90);
+				break;
+			case 7:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1c, 0x3, 0x70, 0x90);
+				break;
+			case 8:	
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xa3, 0x10, 0x3, 0x70, 0x90);
+				break;
+			case 9:	
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x03, 0xf1, 0x90);
+				break;
+			case 10:	
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0xe1, 0x90);
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x2d, 0x03, 0xf1, 0x90);
+				break;
+			case 11:	
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0xa, 0xe1, 0x90);
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1c, 0x3, 0xf1, 0x90);
+				break;
+			case 12:
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0xe1, 0x90);
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x10, 0x3, 0xf1, 0x90);
+				break;
+			case 13:
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90);
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x3, 0x70, 0x90);		
+				break;
+			case 14:
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0x60, 0x90);
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x2d, 0x3, 0x70, 0x90);		
+				break;
+			case 15:
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0xa, 0x60, 0x90);
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1c, 0x3, 0x70, 0x90);		
+				break;
+			case 16:
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0x60, 0x90);
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x10, 0x3, 0x70, 0x90);		
+				break;
+			case 17:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xa3, 0x2f, 0x2f, 0x60, 0x90);
+				break;
+			case 18:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0xe1, 0x90);
+				break;			
+			case 19:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x25, 0x25, 0xe1, 0x90);
+				break;
+			case 20:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x25, 0x25, 0x60, 0x90);
+				break;
+			case 21:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x15, 0x03, 0x70, 0x90);
+				break;	
+			case 71:
+				//halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x03, 0xf1, 0x90);
+				break;
+			case 101:
+			case 105:
+			case 171:	
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xd3, 0x3a, 0x03, 0x70, 0x50);
+				break;
+			case 102:
+			case 106:
+			case 110:
+			case 114:	
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xd3, 0x2d, 0x03, 0x70, 0x50);
+				break;	
+			case 103:
+			case 107:
+			case 111:
+			case 115:	
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xd3, 0x1c, 0x03, 0x70, 0x50);
+				break;		
+			case 104:
+			case 108:
+			case 112:
+			case 116:	
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xd3, 0x10, 0x03, 0x70, 0x50);
+				break;	
+			case 109:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x03, 0xf1, 0x90);
+				break;
+			case 113:	
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x03, 0x70, 0x90);
+				break;
+			case 121:	
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x15, 0x03, 0x70, 0x90);
+				break;	
+			case 22:
+			case 122:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x35, 0x03, 0x71, 0x11);
+				break;
+		}
+	}
+	else
+	{
+		// disable PS tdma
+		switch(type)
+		{
+			case 0:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0x0, 0x0, 0x0, 0x40, 0x0);
+				break;
+			case 1:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0x0, 0x0, 0x0, 0x48, 0x0);
+				break;
+			default:
+				halbtc8703b2ant_SetFwPstdma(pBtCoexist, 0x0, 0x0, 0x0, 0x40, 0x0);
+				break;
+		}
+	}
+
+	// update pre state
+	pCoexDm->bPrePsTdmaOn = pCoexDm->bCurPsTdmaOn;
+	pCoexDm->prePsTdma = pCoexDm->curPsTdma;
+}
+
+VOID
+halbtc8703b2ant_PsTdmaCheckForPowerSaveState(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bNewPsState
+	)
+{
+	u1Byte	lpsMode=0x0;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_LPS_MODE, &lpsMode);
+	
+	if(lpsMode)	// already under LPS state
+	{
+		if(bNewPsState)		
+		{
+			// keep state under LPS, do nothing.
+		}
+		else
+		{
+			// will leave LPS state, turn off psTdma first
+			halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		}
+	}
+	else						// NO PS state
+	{
+		if(bNewPsState)
+		{
+			// will enter LPS state, turn off psTdma first
+			halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		}
+		else
+		{
+			// keep state under NO PS state, do nothing.
+		}
+	}
+}
+
+VOID
+halbtc8703b2ant_PowerSaveState(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte				psType,
+	IN	u1Byte				lpsVal,
+	IN	u1Byte				rpwmVal
+	)
+{
+	BOOLEAN		bLowPwrDisable=FALSE;
+	
+	switch(psType)
+	{
+		case BTC_PS_WIFI_NATIVE:
+			// recover to original 32k low power setting
+			bLowPwrDisable = FALSE;
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_NORMAL_LPS, NULL);
+			pCoexSta->bForceLpsOn = FALSE;
+			break;
+		case BTC_PS_LPS_ON:
+			halbtc8703b2ant_PsTdmaCheckForPowerSaveState(pBtCoexist, TRUE);
+			halbtc8703b2ant_LpsRpwm(pBtCoexist, NORMAL_EXEC, lpsVal, rpwmVal);			
+			// when coex force to enter LPS, do not enter 32k low power.
+			bLowPwrDisable = TRUE;
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+			// power save must executed before psTdma.			
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_ENTER_LPS, NULL);
+			pCoexSta->bForceLpsOn = TRUE;
+			break;
+		case BTC_PS_LPS_OFF:
+			halbtc8703b2ant_PsTdmaCheckForPowerSaveState(pBtCoexist, FALSE);
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_LEAVE_LPS, NULL);
+			pCoexSta->bForceLpsOn = FALSE;
+			break;
+		default:
+			break;
+	}
+}
+
+
+VOID
+halbtc8703b2ant_CoexAllOff(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	// fw all off
+	halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+	halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	// sw all off
+	halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+	halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+
+	// hw all off
+	//pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+	halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+}
+
+VOID
+halbtc8703b2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{	
+	// force to reset coex mechanism
+	halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+	
+	halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	halbtc8703b2ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 1);
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, FORCE_EXEC, 6);
+	halbtc8703b2ant_DecBtPwr(pBtCoexist, FORCE_EXEC, 0);
+
+	halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+	halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+}
+
+VOID
+halbtc8703b2ant_ActionBtInquiry(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
+	BOOLEAN	bWifiConnected=FALSE;
+	BOOLEAN	bLowPwrDisable=TRUE;
+	BOOLEAN		bScan=FALSE, bLink=FALSE, bRoam=FALSE;
+
+
+	wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	wifiRssiState1 = halbtc8703b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	btRssiState = halbtc8703b2ant_BtRssiState(2, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+	
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+		
+	
+	halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+
+	if(bScan || bLink || bRoam)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi link process + BT Inq/Page!!\n"));
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 15);		
+		halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
+	}
+	else if(bWifiConnected)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi connected + BT Inq/Page!!\n"));
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 15);		
+		halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi no-link + BT Inq/Page!!\n"));
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+		halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+	}	
+	
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, FORCE_EXEC, 6);
+	halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+	halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+/*
+	pCoexDm->bNeedRecover0x948 = TRUE;
+	pCoexDm->backup0x948 = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x948);
+
+	halbtc8703b2ant_SetAntPath(pBtCoexist, BTC_ANT_WIFI_AT_AUX, FALSE, FALSE);
+*/	
+}
+
+
+VOID
+halbtc8703b2ant_ActionWiFiLinkProcess(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u4Byte 	u4Tmp;
+	u1Byte 	u1Tmpa, u1Tmpb;
+	
+	halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 15);		
+	halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
+
+	halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+	halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+
+
+	 u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x948);
+        u1Tmpa = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x765);
+	 u1Tmpb = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x76e);
+
+	 RT_TRACE(COMP_COEX, DBG_LOUD, ("############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x76e=0x%x\n",
+	   	      u4Tmp,  u1Tmpa, u1Tmpb));
+}
+
+BOOLEAN
+halbtc8703b2ant_ActionWifiIdleProcess(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{	
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
+	u4Byte		wifiBw;
+	u1Byte		apNum=0;
+
+	wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	//wifiRssiState1 = halbtc8703b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	wifiRssiState1 = halbtc8703b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES-20, 0);
+	btRssiState = halbtc8703b2ant_BtRssiState(2, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_AP_NUM, &apNum);
+
+	// define the office environment
+	if(BTC_RSSI_HIGH(wifiRssiState1) && 
+			(pCoexSta->bHidExist == TRUE) && (pCoexSta->bA2dpExist == TRUE))
+	{
+
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi  idle process for BT HID+A2DP exist!!\n"));
+		
+		halbtc8703b2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x6);
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+		// sw all off
+		halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+		halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+		halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+
+	  	return TRUE;
+	}
+	else
+	{
+		halbtc8703b2ant_DacSwing(pBtCoexist, NORMAL_EXEC, TRUE, 0x18);
+		return FALSE;	
+	}
+	
+	
+}
+
+
+
+BOOLEAN
+halbtc8703b2ant_IsCommonAction(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte			btRssiState=BTC_RSSI_STATE_HIGH;
+	BOOLEAN			bCommon=FALSE, bWifiConnected=FALSE, bWifiBusy=FALSE;
+	BOOLEAN			bBtHsOn=FALSE, bLowPwrDisable=FALSE;
+	BOOLEAN			bAsus8703b=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+
+	if(!bWifiConnected)
+	{
+		bLowPwrDisable = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+		halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi non-connected idle!!\n"));
+
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+		
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);			
+		halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+		
+ 		halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+		halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+
+		bCommon = TRUE;
+	}
+	else
+	{
+		if(BT_8703B_2ANT_BT_STATUS_NON_CONNECTED_IDLE == pCoexDm->btStatus)
+		{
+			bLowPwrDisable = FALSE;
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+			halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi connected + BT non connected-idle!!\n"));
+
+			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+			halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+
+			halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);			
+			halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);		
+			halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0xb);
+			halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	      	halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+
+			bCommon = TRUE;
+		}
+		else if(BT_8703B_2ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus)
+		{
+			bLowPwrDisable = TRUE;
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+
+			if(bBtHsOn)
+				return FALSE;
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi connected + BT connected-idle!!\n"));
+			halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
+			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+			halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+
+			halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);			
+			halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+			halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0xb);
+			halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+
+			bCommon = TRUE;
+		}
+		else
+		{
+			bLowPwrDisable = TRUE;
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+
+			if(bWifiBusy)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi Connected-Busy + BT Busy!!\n"));
+#if 0				
+				pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_IS_ASUS_8703B, &bAsus8703b);
+				if(!bAsus8703b)
+					bCommon = FALSE;
+				else
+					bCommon = halbtc8703b2ant_ActionWifiIdleProcess(pBtCoexist);	
+#else
+				bCommon = FALSE;
+#endif
+			}
+			else
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi Connected-Idle + BT Busy!!\n"));
+				//bCommon = FALSE;	
+				bCommon = halbtc8703b2ant_ActionWifiIdleProcess(pBtCoexist);			
+			}
+		}	
+	}
+
+	return bCommon;
+}
+VOID
+halbtc8703b2ant_TdmaDurationAdjust(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bScoHid,
+	IN	BOOLEAN			bTxPause,
+	IN	u1Byte			maxInterval
+	)
+{
+	static s4Byte		up,dn,m,n,WaitCount;
+	s4Byte			result;   //0: no change, +1: increase WiFi duration, -1: decrease WiFi duration
+	u1Byte			retryCount=0;
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TdmaDurationAdjust()\n"));
+
+	if(!pCoexDm->bAutoTdmaAdjust)
+	{
+		pCoexDm->bAutoTdmaAdjust = TRUE;
+		RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], first run TdmaDurationAdjust()!!\n"));
+		{
+			if(bScoHid)
+			{
+				if(bTxPause)
+				{
+					if(maxInterval == 1)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+						pCoexDm->psTdmaDuAdjType = 13;	
+					}
+					else if(maxInterval == 2)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;	
+					}
+					else if(maxInterval == 3)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;	
+					}
+					else
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+				}
+				else
+				{
+					if(maxInterval == 1)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+						pCoexDm->psTdmaDuAdjType = 9;	
+					}
+					else if(maxInterval == 2)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;	
+					}
+					else if(maxInterval == 3)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+				}
+			}
+			else
+			{
+				if(bTxPause)
+				{
+					if(maxInterval == 1)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+						pCoexDm->psTdmaDuAdjType = 5;	
+					}
+					else if(maxInterval == 2)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;	
+					}
+					else if(maxInterval == 3)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+				}
+				else
+				{
+					if(maxInterval == 1)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+						pCoexDm->psTdmaDuAdjType = 1;	
+					}
+					else if(maxInterval == 2)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;	
+					}
+					else if(maxInterval == 3)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+				}
+			}
+		}
+		//============
+		up = 0;
+		dn = 0;
+		m = 1;
+		n= 3;
+		result = 0;
+		WaitCount = 0;
+	}
+	else
+	{
+		//accquire the BT TRx retry count from BT_Info byte2
+		retryCount = pCoexSta->btRetryCnt;
+		RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], retryCount = %d\n", retryCount));
+		RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], up=%d, dn=%d, m=%d, n=%d, WaitCount=%d\n", 
+			up, dn, m, n, WaitCount));
+		result = 0;
+		WaitCount++; 
+		  
+		if(retryCount == 0)  // no retry in the last 2-second duration
+		{
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;				 
+
+			if(up >= n)	// if s n 2 retry count0, heWiFi duration
+			{
+				WaitCount = 0; 
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1; 
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Increase wifi duration!!\n"));
+			}
+		}
+		else if (retryCount <= 3)	// <=3 retry in the last 2-second duration
+		{
+			up--; 
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2)	// if s 2 2 retry count< 3, hWiFi duration
+			{
+				if (WaitCount <= 2)
+					m++; // K@blevel^
+				else
+					m = 1;
+
+				if ( m >= 20) //m j = 20 ' j120 recheckO_ WiFi duration.
+					m = 20;
+
+				n = 3*m;
+				up = 0;
+				dn = 0;
+				WaitCount = 0;
+				result = -1; 
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Decrease wifi duration for retryCounter<3!!\n"));
+			}
+		}
+		else  //retry count > 3, un1 retry count > 3, hWiFi duration
+		{
+			if (WaitCount == 1)
+				m++; // K@blevel^
+			else
+				m = 1;
+
+			if ( m >= 20) //m j = 20 ' j120 recheckO_ WiFi duration.
+				m = 20;
+
+			n = 3*m;
+			up = 0;
+			dn = 0;
+			WaitCount = 0; 
+			result = -1;
+			RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Decrease wifi duration for retryCounter>3!!\n"));
+		}
+
+		RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], max Interval = %d\n", maxInterval));
+		if(maxInterval == 1)
+		{
+			if(bTxPause)
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TxPause = 1\n"));
+
+				if(pCoexDm->curPsTdma == 71)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+					pCoexDm->psTdmaDuAdjType = 5;
+				}
+				else if(pCoexDm->curPsTdma == 1)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+					pCoexDm->psTdmaDuAdjType = 5;
+				}
+				else if(pCoexDm->curPsTdma == 2)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+					pCoexDm->psTdmaDuAdjType = 6;
+				}
+				else if(pCoexDm->curPsTdma == 3)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 4)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+					pCoexDm->psTdmaDuAdjType = 8;
+				}
+				if(pCoexDm->curPsTdma == 9)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+					pCoexDm->psTdmaDuAdjType = 13;
+				}
+				else if(pCoexDm->curPsTdma == 10)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+					pCoexDm->psTdmaDuAdjType = 14;
+				}
+				else if(pCoexDm->curPsTdma == 11)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 12)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+					pCoexDm->psTdmaDuAdjType = 16;
+				}
+				
+				if(result == -1)
+				{					
+					if(pCoexDm->curPsTdma == 5)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+						pCoexDm->psTdmaDuAdjType = 8;
+					}
+					else if(pCoexDm->curPsTdma == 13)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+						pCoexDm->psTdmaDuAdjType = 16;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 8)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+						pCoexDm->psTdmaDuAdjType = 5;
+					}
+					else if(pCoexDm->curPsTdma == 16)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+						pCoexDm->psTdmaDuAdjType = 13;
+					}
+				}
+			}
+			else
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TxPause = 0\n"));
+				if(pCoexDm->curPsTdma == 5)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 71);
+					pCoexDm->psTdmaDuAdjType = 71;
+				}
+				else if(pCoexDm->curPsTdma == 6)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+					pCoexDm->psTdmaDuAdjType = 2;
+				}
+				else if(pCoexDm->curPsTdma == 7)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 8)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+					pCoexDm->psTdmaDuAdjType = 4;
+				}
+				if(pCoexDm->curPsTdma == 13)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+					pCoexDm->psTdmaDuAdjType = 9;
+				}
+				else if(pCoexDm->curPsTdma == 14)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+					pCoexDm->psTdmaDuAdjType = 10;
+				}
+				else if(pCoexDm->curPsTdma == 15)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 16)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+					pCoexDm->psTdmaDuAdjType = 12;
+				}
+				
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 71)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+						pCoexDm->psTdmaDuAdjType = 1;
+					}
+					else if(pCoexDm->curPsTdma == 1)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+						pCoexDm->psTdmaDuAdjType = 4;
+					}
+					else if(pCoexDm->curPsTdma == 9)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+						pCoexDm->psTdmaDuAdjType = 12;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 4)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+						pCoexDm->psTdmaDuAdjType = 1;
+					}
+					else if(pCoexDm->curPsTdma == 1)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 71);
+						pCoexDm->psTdmaDuAdjType = 71;
+					}
+					else if(pCoexDm->curPsTdma == 12)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+						pCoexDm->psTdmaDuAdjType = 9;
+					}
+				}
+			}
+		}
+		else if(maxInterval == 2)
+		{
+			if(bTxPause)
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TxPause = 1\n"));
+				if(pCoexDm->curPsTdma == 1)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+					pCoexDm->psTdmaDuAdjType = 6;
+				}
+				else if(pCoexDm->curPsTdma == 2)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+					pCoexDm->psTdmaDuAdjType = 6;
+				}
+				else if(pCoexDm->curPsTdma == 3)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 4)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+					pCoexDm->psTdmaDuAdjType = 8;
+				}
+				if(pCoexDm->curPsTdma == 9)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+					pCoexDm->psTdmaDuAdjType = 14;
+				}
+				else if(pCoexDm->curPsTdma == 10)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+					pCoexDm->psTdmaDuAdjType = 14;
+				}
+				else if(pCoexDm->curPsTdma == 11)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 12)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+					pCoexDm->psTdmaDuAdjType = 16;
+				}
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 5) 
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+						pCoexDm->psTdmaDuAdjType = 8;
+					}
+					else if(pCoexDm->curPsTdma == 13)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+						pCoexDm->psTdmaDuAdjType = 16;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 8)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}					
+					else if(pCoexDm->curPsTdma == 16)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+				}
+			}
+			else
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TxPause = 0\n"));
+				if(pCoexDm->curPsTdma == 5)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+					pCoexDm->psTdmaDuAdjType = 2;
+				}
+				else if(pCoexDm->curPsTdma == 6)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+					pCoexDm->psTdmaDuAdjType = 2;
+				}
+				else if(pCoexDm->curPsTdma == 7)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 8)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+					pCoexDm->psTdmaDuAdjType = 4;
+				}
+				if(pCoexDm->curPsTdma == 13)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+					pCoexDm->psTdmaDuAdjType = 10;
+				}
+				else if(pCoexDm->curPsTdma == 14)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+					pCoexDm->psTdmaDuAdjType = 10;
+				}
+				else if(pCoexDm->curPsTdma == 15)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 16)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+					pCoexDm->psTdmaDuAdjType = 12;
+				}
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 1)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+						pCoexDm->psTdmaDuAdjType = 4;
+					}
+					else if(pCoexDm->curPsTdma == 9)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+						pCoexDm->psTdmaDuAdjType = 12;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 4)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 12)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+				}
+			}
+		}
+		else if(maxInterval == 3)
+		{
+			if(bTxPause)
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TxPause = 1\n"));
+				if(pCoexDm->curPsTdma == 1)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 2)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 3)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 4)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+					pCoexDm->psTdmaDuAdjType = 8;
+				}
+				if(pCoexDm->curPsTdma == 9)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 10)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 11)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 12)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+					pCoexDm->psTdmaDuAdjType = 16;
+				}
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 5) 
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+						pCoexDm->psTdmaDuAdjType = 8;
+					}
+					else if(pCoexDm->curPsTdma == 13)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+						pCoexDm->psTdmaDuAdjType = 16;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 8)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}					
+					else if(pCoexDm->curPsTdma == 16)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+				}
+			}
+			else
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TxPause = 0\n"));
+				if(pCoexDm->curPsTdma == 5)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 6)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 7)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 8)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+					pCoexDm->psTdmaDuAdjType = 4;
+				}
+				if(pCoexDm->curPsTdma == 13)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 14)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 15)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 16)
+				{
+					halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+					pCoexDm->psTdmaDuAdjType = 12;
+				}
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 1)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+						pCoexDm->psTdmaDuAdjType = 4;
+					}
+					else if(pCoexDm->curPsTdma == 9)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+						pCoexDm->psTdmaDuAdjType = 12;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 4)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 12)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+				}
+			}
+		}
+	}
+
+	// if current PsTdma not match with the recorded one (when scan, dhcp...), 
+	// then we have to adjust it back to the previous record one.
+	if(pCoexDm->curPsTdma != pCoexDm->psTdmaDuAdjType)
+	{
+		BOOLEAN	bScan=FALSE, bLink=FALSE, bRoam=FALSE;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PsTdma type dismatch!!!, curPsTdma=%d, recordPsTdma=%d\n", 
+			pCoexDm->curPsTdma, pCoexDm->psTdmaDuAdjType));
+
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+		
+		if( !bScan && !bLink && !bRoam)
+		{
+			halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, pCoexDm->psTdmaDuAdjType);
+		}
+		else
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n"));
+		}
+	}
+}
+
+// SCO only or SCO+PAN(HS)
+VOID
+halbtc8703b2ant_ActionSco(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte	wifiRssiState, btRssiState;
+	u4Byte	wifiBw;
+
+	wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8703b2ant_BtRssiState(2, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+	
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 4);
+
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+	else	
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if (BTC_WIFI_BW_LEGACY == wifiBw) //for SCO quality at 11b/g mode
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
+	}
+	else  //for SCO quality & wifi performance balance at 11n mode
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 8);
+	}
+
+	halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);			
+	halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0); //for voice quality
+
+	// sw mechanism
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,TRUE,0x4);			
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,TRUE,0x4);	
+		}		
+	}
+	else
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,TRUE,0x4);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,TRUE,0x4);
+		}		
+	}
+}
+
+
+VOID
+halbtc8703b2ant_ActionHid(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte	wifiRssiState, btRssiState;	
+	u4Byte	wifiBw;
+
+	wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8703b2ant_BtRssiState(2, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+	
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+	else	
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if (BTC_WIFI_BW_LEGACY == wifiBw) //for HID at 11b/g mode
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+	}
+	else  //for HID quality & wifi performance balance at 11n mode
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 9);
+	}
+
+	halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);			
+	
+	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+	{
+		halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+	}
+	else
+	{
+		halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+	}
+
+	// sw mechanism
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+ 			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}	
+	}
+	else
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+ 			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}		
+	}
+}
+
+//A2DP only / PAN(EDR) only/ A2DP+PAN(HS)
+VOID
+halbtc8703b2ant_ActionA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
+	u4Byte		wifiBw;
+	u1Byte		apNum=0;
+
+	wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	wifiRssiState1 = halbtc8703b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	btRssiState = halbtc8703b2ant_BtRssiState(2, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_AP_NUM, &apNum);
+
+	// define the office environment
+	if( (apNum >= 10) && BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))
+	{
+		//DbgPrint(" AP#>10(%d)\n", apNum);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);			
+		
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);	
+		halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+		halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);	
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);			
+					
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+		halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+
+		// sw mechanism
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,TRUE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,TRUE,0x18);		
+		}
+		return;
+		
+	}
+
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+	halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+	else	
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+		
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))
+	{
+	halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	}
+	else
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 13);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);		
+	}
+	
+
+	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+	{
+		halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, FALSE, FALSE, 1);
+	}
+	else
+	{
+		halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 1);
+	}
+
+	// sw mechanism
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+ 			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}		
+	}
+}
+
+VOID
+halbtc8703b2ant_ActionA2dpPanHs(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
+	u4Byte		wifiBw;
+
+	wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	wifiRssiState1 = halbtc8703b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8703b2ant_BtRssiState(2, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+	
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+	else	
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))
+	{
+	halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	}
+	else
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 13);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);		
+	}
+
+	halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 2);
+
+	// sw mechanism
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+ 			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}		
+	}
+}
+
+VOID
+halbtc8703b2ant_ActionPanEdr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState,wifiRssiState1, btRssiState;
+	u4Byte		wifiBw;
+
+	wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	wifiRssiState1 = halbtc8703b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8703b2ant_BtRssiState(2, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+	else	
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))
+	{
+	halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 10);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	}
+	else
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 13);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);		
+	}
+
+	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+	{
+		halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+	}
+	else
+	{
+		halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+	}
+	
+	// sw mechanism
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+}
+
+
+//PAN(HS) only
+VOID
+halbtc8703b2ant_ActionPanHs(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
+	u4Byte		wifiBw;
+
+	wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	wifiRssiState1 = halbtc8703b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8703b2ant_BtRssiState(2, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+	
+	halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+	
+	halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+}
+
+//PAN(EDR)+A2DP
+VOID
+halbtc8703b2ant_ActionPanEdrA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
+	u4Byte		wifiBw;
+
+	wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	wifiRssiState1 = halbtc8703b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8703b2ant_BtRssiState(2, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+	else	
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))		
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	else
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 12);
+		
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+			halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 3);
+		else
+			halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, FALSE, FALSE, 3);
+	}
+	else
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 13);
+		halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 3);
+	}
+	
+	// sw mechanism	
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+}
+
+VOID
+halbtc8703b2ant_ActionPanEdrHid(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
+	u4Byte		wifiBw;
+
+	wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	wifiRssiState1 = halbtc8703b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8703b2ant_BtRssiState(2, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+	else	
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))	
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	}
+	else
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 14);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);
+	}
+
+	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+	{
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+		{
+			halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 3);
+			//halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 11);
+			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x780);
+		}
+		else
+		{
+			halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+			//halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+		}
+		halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 2);
+	}
+	else
+	{
+		halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+		//halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 14);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+		halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 2);
+	}
+	
+	// sw mechanism
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+}
+
+// HID+A2DP+PAN(EDR)
+VOID
+halbtc8703b2ant_ActionHidA2dpPanEdr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState,wifiRssiState1,  btRssiState;
+	u4Byte		wifiBw;
+
+	wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	wifiRssiState1 = halbtc8703b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8703b2ant_BtRssiState(2, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+	else	
+		halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	}
+	else
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 14);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);		
+	}
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+	{
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+			halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 3);
+		else
+			halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 3);
+	}
+	else
+	{
+		halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 3);
+	}
+
+	// sw mechanism
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+}
+
+VOID
+halbtc8703b2ant_ActionHidA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
+	u4Byte		wifiBw;
+	u1Byte		apNum=0;
+
+	wifiRssiState = halbtc8703b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	//btRssiState = halbtc8703b2ant_BtRssiState(2, 29, 0);
+	wifiRssiState1 = halbtc8703b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8703b2ant_BtRssiState(3, BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES, 37);
+
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8703b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, TRUE, 0x5);
+
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_LEGACY == wifiBw)
+	{
+		if(BTC_RSSI_HIGH(btRssiState))
+			halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+		else if(BTC_RSSI_MEDIUM(btRssiState))
+			halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+	else	
+			halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+	}
+	else	
+	{	// only 802.11N mode we have to dec bt power to 4 degree
+		if(BTC_RSSI_HIGH(btRssiState))
+		{
+			pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_AP_NUM, &apNum);
+			// need to check ap Number of Not
+			if(apNum < 10)
+				halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 4);
+			else
+				halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+		}
+		else if(BTC_RSSI_MEDIUM(btRssiState))
+			halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+		else	
+			halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+	}
+
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))
+	{
+	halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	}
+	else
+	{
+		halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 14);
+		halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);		
+	}
+
+	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+	{
+		halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 3);
+	}
+	else
+	{
+		halbtc8703b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 3);
+	}
+	
+	// sw mechanism
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+}
+
+VOID
+halbtc8703b2ant_ActionBtWhckTest(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	// sw all off
+	halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+	halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+
+	halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+	
+	halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+	halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+}
+
+VOID
+halbtc8703b2ant_ActionWifiMultiPort(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{		
+	halbtc8703b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+	halbtc8703b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	// sw all off
+	halbtc8703b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+	halbtc8703b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+
+	// hw all off
+	//pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+	halbtc8703b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+
+	halbtc8703b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	halbtc8703b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+}
+
+VOID
+halbtc8703b2ant_RunCoexistMechanism(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN				bWifiUnder5G=FALSE, bBtHsOn=FALSE;
+	u1Byte				btInfoOriginal=0, btRetryCnt=0;
+	u1Byte				algorithm=0;
+	u4Byte				numOfWifiLink=0;
+	u4Byte				wifiLinkStatus=0;
+	PBTC_BT_LINK_INFO pBtLinkInfo=&pBtCoexist->btLinkInfo;
+	BOOLEAN				bMiracastPlusBt=FALSE;
+	BOOLEAN				bScan=FALSE, bLink=FALSE, bRoam=FALSE;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], RunCoexistMechanism()===>\n"));
+
+	if(pBtCoexist->bManualControl)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n"));
+		return;
+	}
+
+	if(pCoexSta->bUnderIps)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], wifi is under IPS !!!\n"));
+		return;
+	}
+
+	if(pCoexSta->bBtWhckTest)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is under WHCK TEST!!!\n"));
+		halbtc8703b2ant_ActionBtWhckTest(pBtCoexist);
+		return;
+	}
+
+	algorithm = halbtc8703b2ant_ActionAlgorithm(pBtCoexist);
+	if(pCoexSta->bC2hBtInquiryPage && (BT_8703B_2ANT_COEX_ALGO_PANHS!=algorithm))
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is under inquiry/page scan !!\n"));
+		halbtc8703b2ant_ActionBtInquiry(pBtCoexist);
+		return;
+	}
+	else
+	{
+		/*
+		if(pCoexDm->bNeedRecover0x948)
+		{
+			pCoexDm->bNeedRecover0x948 = FALSE;
+			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, pCoexDm->backup0x948);
+		}
+		*/
+	}
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+
+	if(bScan || bLink || bRoam)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], WiFi is under Link Process !!\n"));
+		halbtc8703b2ant_ActionWiFiLinkProcess(pBtCoexist);
+		return;
+	}
+
+	//for P2P
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_LINK_STATUS, &wifiLinkStatus);
+	numOfWifiLink = wifiLinkStatus>>16;
+	
+	if((numOfWifiLink>=2) || (wifiLinkStatus&WIFI_P2P_GO_CONNECTED))
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("############# [BTCoex],  Multi-Port numOfWifiLink = %d, wifiLinkStatus = 0x%x\n", numOfWifiLink,wifiLinkStatus) );
+
+		if(pBtLinkInfo->bBtLinkExist)
+		{
+			bMiracastPlusBt = TRUE;
+		}
+		else
+		{
+			bMiracastPlusBt = FALSE;
+		}
+		
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_MIRACAST_PLUS_BT, &bMiracastPlusBt);
+		halbtc8703b2ant_ActionWifiMultiPort(pBtCoexist);
+		
+		return;
+	}
+	else
+	{
+		bMiracastPlusBt = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_MIRACAST_PLUS_BT, &bMiracastPlusBt);
+	}
+
+	pCoexDm->curAlgorithm = algorithm;
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Algorithm = %d \n", pCoexDm->curAlgorithm));
+
+	if(halbtc8703b2ant_IsCommonAction(pBtCoexist))
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant common.\n"));
+		pCoexDm->bAutoTdmaAdjust = FALSE;
+	}
+	else
+	{
+		if(pCoexDm->curAlgorithm != pCoexDm->preAlgorithm)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], preAlgorithm=%d, curAlgorithm=%d\n", 
+				pCoexDm->preAlgorithm, pCoexDm->curAlgorithm));
+			pCoexDm->bAutoTdmaAdjust = FALSE;
+		}
+		switch(pCoexDm->curAlgorithm)
+		{
+			case BT_8703B_2ANT_COEX_ALGO_SCO:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = SCO.\n"));
+				halbtc8703b2ant_ActionSco(pBtCoexist);
+				break;
+			case BT_8703B_2ANT_COEX_ALGO_HID:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = HID.\n"));
+				halbtc8703b2ant_ActionHid(pBtCoexist);
+				break;
+			case BT_8703B_2ANT_COEX_ALGO_A2DP:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = A2DP.\n"));
+				halbtc8703b2ant_ActionA2dp(pBtCoexist);
+				break;
+			case BT_8703B_2ANT_COEX_ALGO_A2DP_PANHS:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n"));
+				halbtc8703b2ant_ActionA2dpPanHs(pBtCoexist);
+				break;
+			case BT_8703B_2ANT_COEX_ALGO_PANEDR:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n"));
+				halbtc8703b2ant_ActionPanEdr(pBtCoexist);
+				break;
+			case BT_8703B_2ANT_COEX_ALGO_PANHS:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = HS mode.\n"));
+				halbtc8703b2ant_ActionPanHs(pBtCoexist);
+				break;
+			case BT_8703B_2ANT_COEX_ALGO_PANEDR_A2DP:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n"));
+				halbtc8703b2ant_ActionPanEdrA2dp(pBtCoexist);
+				break;
+			case BT_8703B_2ANT_COEX_ALGO_PANEDR_HID:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n"));
+				halbtc8703b2ant_ActionPanEdrHid(pBtCoexist);
+				break;
+			case BT_8703B_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n"));
+				halbtc8703b2ant_ActionHidA2dpPanEdr(pBtCoexist);
+				break;
+			case BT_8703B_2ANT_COEX_ALGO_HID_A2DP:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n"));
+				halbtc8703b2ant_ActionHidA2dp(pBtCoexist);
+				break;
+			default:
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n"));
+				halbtc8703b2ant_CoexAllOff(pBtCoexist);
+				break;
+		}
+		pCoexDm->preAlgorithm = pCoexDm->curAlgorithm;
+	}
+}
+
+VOID
+halbtc8703b2ant_WifiOffHwCfg(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN	bIsInMpMode = FALSE;
+	u1Byte H2C_Parameter[2] ={0};
+	u4Byte fwVer=0;
+
+	// set wlan_act to low
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x4);
+
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x780); //WiFi goto standby while GNT_BT 0-->1
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_FW_VER, &fwVer);
+	if(fwVer >= 0x180000)
+	{
+	/* Use H2C to set GNT_BT to HIGH */
+	H2C_Parameter[0] = 1;
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x6E, 1, H2C_Parameter);
+	}
+	else
+	{
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x765, 0x18);
+	}
+	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_IS_IN_MP_MODE, &bIsInMpMode);
+	if(!bIsInMpMode)
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x67, 0x20, 0x0); //BT select s0/s1 is controlled by BT
+	else
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x67, 0x20, 0x1); //BT select s0/s1 is controlled by WiFi
+}
+
+VOID
+halbtc8703b2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bBackUp
+	)
+{
+	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
+	u4Byte	u4Tmp=0, fwVer;
+	u2Byte				u2Tmp=0;
+	u1Byte	u1Tmp=0;
+	u1Byte				H2C_Parameter[2] ={0};
+		
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], 2Ant Init HW Config!!\n"));
+
+	// backup rf 0x1e value
+	pCoexDm->btRf0x1eBackup = 
+		pBtCoexist->fBtcGetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff);	
+
+	// 0x790[5:0]=0x5
+	u1Tmp = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x790);
+	u1Tmp &= 0xc0;
+	u1Tmp |= 0x5;
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x790, u1Tmp);
+
+	//Antenna config	
+	halbtc8703b2ant_SetAntPath(pBtCoexist, BTC_ANT_WIFI_AT_MAIN, TRUE, FALSE);
+	pCoexSta->disVerInfoCnt = 0;
+
+	// PTA parameter
+	halbtc8703b2ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 0);
+	
+	// Enable counter statistics
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x4); //0x76e[3] =1, WLAN_Act control by PTA
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x778, 0x3);
+	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x40, 0x20, 0x1);
+}
+
+//============================================================
+// work around function start with wa_halbtc8703b2ant_
+//============================================================
+//============================================================
+// extern function start with EXhalbtc8703b2ant_
+//============================================================
+VOID
+EXhalbtc8703b2ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BOARD_INFO 	pBoardInfo=&pBtCoexist->boardInfo;
+	u2Byte u2Tmp=0x0;
+
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x67, 0x20);
+
+	// enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly.
+	u2Tmp = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0x2);
+	pBtCoexist->fBtcWrite2Byte(pBtCoexist, 0x2, u2Tmp|BIT0|BIT1);
+
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0);
+
+	if(pBtCoexist->chipInterface == BTC_INTF_USB)
+	{
+		// fixed at S0 for USB interface
+		pBoardInfo->btdmAntPos = BTC_ANTENNA_AT_AUX_PORT;
+	}
+	else
+	{
+		// for PCIE and SDIO interface, we check efuse 0xc3[6]
+		if(pBoardInfo->singleAntPath == 0)
+		{
+			// set to S1
+			pBoardInfo->btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT;
+		}
+		else if(pBoardInfo->singleAntPath == 1)
+		{
+			// set to S0
+			pBoardInfo->btdmAntPos = BTC_ANTENNA_AT_AUX_PORT;
+		}
+	}
+}
+
+VOID
+EXhalbtc8703b2ant_PreLoadFirmware(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BOARD_INFO 	pBoardInfo=&pBtCoexist->boardInfo;
+	u1Byte u1Tmp=0x4; /* Set BIT2 by default since it's 2ant case */
+
+	// 
+	// S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info)
+	// Local setting bit define
+	//	BIT0: "0" for no antenna inverse; "1" for antenna inverse 
+	//	BIT1: "0" for internal switch; "1" for external switch
+	//	BIT2: "0" for one antenna; "1" for two antenna
+	// NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0
+	if(pBtCoexist->chipInterface == BTC_INTF_USB)
+	{
+		// fixed at S0 for USB interface
+	 	u1Tmp |= 0x1;	// antenna inverse
+		pBtCoexist->fBtcWriteLocalReg1Byte(pBtCoexist, 0xfe08, u1Tmp);
+	}
+	else
+	{
+		// for PCIE and SDIO interface, we check efuse 0xc3[6]
+		if(pBoardInfo->singleAntPath == 0)
+		{
+		}
+		else if(pBoardInfo->singleAntPath == 1)
+		{
+			// set to S0
+			u1Tmp |= 0x1;	// antenna inverse
+		}
+
+		if(pBtCoexist->chipInterface == BTC_INTF_PCI)
+		{	
+			pBtCoexist->fBtcWriteLocalReg1Byte(pBtCoexist, 0x384, u1Tmp);
+		}
+		else if(pBtCoexist->chipInterface == BTC_INTF_SDIO)
+		{
+			pBtCoexist->fBtcWriteLocalReg1Byte(pBtCoexist, 0x60, u1Tmp);
+		}			
+	}
+}
+
+VOID
+EXhalbtc8703b2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
+{
+	halbtc8703b2ant_InitHwConfig(pBtCoexist, TRUE);
+}
+
+VOID
+EXhalbtc8703b2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Coex Mechanism Init!!\n"));
+	
+	halbtc8703b2ant_InitCoexDm(pBtCoexist);
+}
+
+VOID
+EXhalbtc8703b2ant_DisplayCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	PBTC_BT_LINK_INFO	pBtLinkInfo=&pBtCoexist->btLinkInfo;
+	pu1Byte				cliBuf=pBtCoexist->cliBuf;
+	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
+	u4Byte				u4Tmp[4];
+	u4Byte				faOfdm, faCck;
+	u4Byte				fwVer=0, btPatchVer=0;
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cliBuf);
+
+	if(pBtCoexist->bManualControl)
+	{
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cliBuf);
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ==========================================");
+		CL_PRINTF(cliBuf);
+	}
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
+		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
+	CL_PRINTF(cliBuf);
+	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %d", "BT stack/ hci ext ver", \
+		((pStackInfo->bProfileNotified)? "Yes":"No"), pStackInfo->hciVersion);
+	CL_PRINTF(cliBuf);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_BT_PATCH_VER, &btPatchVer);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_FW_VER, &fwVer);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d_%x/ 0x%x/ 0x%x(%d)", "CoexVer/ FwVer/ PatchVer", \
+		GLCoexVerDate8703b2Ant, GLCoexVer8703b2Ant, fwVer, btPatchVer, btPatchVer);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
+		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
+		pCoexDm->wifiChnlInfo[2]);
+	CL_PRINTF(cliBuf);
+
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
+	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %ddBm/ %d] ", "BT [status/ rssi/ retryCnt]", \
+		((pBtCoexist->btInfo.bBtDisabled)? ("disabled"):	((pCoexSta->bC2hBtInquiryPage)?("inquiry/page scan"):((BT_8703B_2ANT_BT_STATUS_NON_CONNECTED_IDLE == pCoexDm->btStatus)? "non-connected idle":
+		(  (BT_8703B_2ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus)? "connected-idle":"busy")))),
+		pCoexSta->btRssi-100, pCoexSta->btRetryCnt);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "SCO/HID/PAN/A2DP", \
+		pBtLinkInfo->bScoExist, pBtLinkInfo->bHidExist, pBtLinkInfo->bPanExist, pBtLinkInfo->bA2dpExist);
+	CL_PRINTF(cliBuf);
+
+	if (pStackInfo->bProfileNotified)
+	{
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_BT_LINK_INFO);
+	}
+	else
+	{
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "BT Role", \
+		(pBtLinkInfo->bSlaveRole )? "Slave":"Master");
+		CL_PRINTF(cliBuf);	
+	}	
+
+	btInfoExt = pCoexSta->btInfoExt;
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "BT Info A2DP rate", \
+		(btInfoExt&BIT0)? "Basic rate":"EDR rate");
+	CL_PRINTF(cliBuf);	
+
+	for(i=0; i<BT_INFO_SRC_8703B_2ANT_MAX; i++)
+	{
+		if(pCoexSta->btInfoC2hCnt[i])
+		{				
+			CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)", GLBtInfoSrc8703b2Ant[i], \
+				pCoexSta->btInfoC2h[i][0], pCoexSta->btInfoC2h[i][1],
+				pCoexSta->btInfoC2h[i][2], pCoexSta->btInfoC2h[i][3],
+				pCoexSta->btInfoC2h[i][4], pCoexSta->btInfoC2h[i][5],
+				pCoexSta->btInfoC2h[i][6], pCoexSta->btInfoC2hCnt[i]);
+			CL_PRINTF(cliBuf);
+		}
+	}
+
+	// Sw mechanism	
+	if(pBtCoexist->bManualControl)
+	{			
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Sw mechanism] (before Manual)============");			
+	}
+	else
+	{
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Sw mechanism]============");
+	}
+	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "SM1[ShRf/ LpRA/ LimDig]", \
+		pCoexDm->bCurRfRxLpfShrink, pCoexDm->bCurLowPenaltyRa, pCoexDm->bLimitedDig);
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ", "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]", \
+		pCoexDm->bCurAgcTableEn, pCoexDm->bCurAdcBackOff, pCoexDm->bCurDacSwingOn, pCoexDm->curDacSwingLvl);
+	CL_PRINTF(cliBuf);
+
+	// Fw mechanism		
+	if(pBtCoexist->bManualControl)
+	{
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Fw mechanism] (before Manual) ============");			
+	}
+	else
+	{
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Fw mechanism]============");
+	}
+
+	psTdmaCase = pCoexDm->curPsTdma;
+
+	if (pCoexDm->bIsSwitchTo1dot5Ant)
+		psTdmaCase = psTdmaCase + 100;
+		
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (%s,%s)", "PS TDMA", \
+		pCoexDm->psTdmaPara[0], pCoexDm->psTdmaPara[1],
+		pCoexDm->psTdmaPara[2], pCoexDm->psTdmaPara[3],
+			pCoexDm->psTdmaPara[4], psTdmaCase, 
+			(pCoexDm->bCurPsTdmaOn? "On":"Off"),
+			(pCoexDm->bAutoTdmaAdjust? "Adj":"Fix") );
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "Coex Table Type", \
+			pCoexSta->nCoexTableType);
+		CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "DecBtPwr/ IgnWlanAct", \
+		pCoexDm->curBtDecPwrLvl, pCoexDm->bCurIgnoreWlanAct);
+	CL_PRINTF(cliBuf);
+
+	// Hw setting		
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Hw setting]============");
+	CL_PRINTF(cliBuf);	
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "RF-A, 0x1e initVal", \
+		pCoexDm->btRf0x1eBackup);
+	CL_PRINTF(cliBuf);
+
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x778);
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x880);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x", "0x778/0x880[29:25]", \
+		u1Tmp[0], (u4Tmp[0]&0x3e000000) >> 25);
+	CL_PRINTF(cliBuf);
+
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x948);
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x67);
+	u1Tmp[1] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x765);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", "0x948/ 0x67[5] / 0x765", \
+		u4Tmp[0], ((u1Tmp[0]&0x20)>> 5), u1Tmp[1]);
+	CL_PRINTF(cliBuf);
+	
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x92c);
+	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x930);
+	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x944);	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", "0x92c[1:0]/ 0x930[7:0]/0x944[1:0]", \
+		u4Tmp[0]&0x3, u4Tmp[1]&0xff, u4Tmp[2]&0x3);
+	CL_PRINTF(cliBuf);
+
+
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x39);
+	u1Tmp[1] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x40);
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x4c);
+	u1Tmp[2] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x64);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x", "0x38[11]/0x40/0x4c[24:23]/0x64[0]", \
+		((u1Tmp[0] & 0x8)>>3), u1Tmp[1], ((u4Tmp[0]&0x01800000)>>23), u1Tmp[2]&0x1);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x550);
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x522);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x", "0x550(bcn ctrl)/0x522", \
+		u4Tmp[0], u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xc50);
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x49c);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x", "0xc50(dig)/0x49c(null-drop)", \
+		u4Tmp[0]&0xff, u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xda0);
+	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xda4);
+	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xda8);
+	u4Tmp[3] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xcf0);
+
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0xa5b);
+	u1Tmp[1] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0xa5c);
+
+	faOfdm = ((u4Tmp[0]&0xffff0000) >> 16) +  ((u4Tmp[1]&0xffff0000) >> 16) + (u4Tmp[1] & 0xffff) +  (u4Tmp[2] & 0xffff) + \
+		             ((u4Tmp[3]&0xffff0000) >> 16) + (u4Tmp[3] & 0xffff) ;
+	faCck = (u1Tmp[0] << 8) + u1Tmp[1];
+	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", "OFDM-CCA/OFDM-FA/CCK-FA", \
+		u4Tmp[0]&0xffff, faOfdm, faCck);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d", "CRC_OK CCK/11g/11n/11n-Agg", \
+		pCoexSta->nCRCOK_CCK, pCoexSta->nCRCOK_11g, pCoexSta->nCRCOK_11n, pCoexSta->nCRCOK_11nAgg);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d", "CRC_Err CCK/11g/11n/11n-Agg", \
+		pCoexSta->nCRCErr_CCK, pCoexSta->nCRCErr_11g, pCoexSta->nCRCErr_11n, pCoexSta->nCRCErr_11nAgg);
+	CL_PRINTF(cliBuf);	
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c0);
+	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c4);
+	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c8);
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x6cc);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x", "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)", \
+		u4Tmp[0], u4Tmp[1], u4Tmp[2], u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "0x770(high-pri rx/tx)", \
+		pCoexSta->highPriorityRx, pCoexSta->highPriorityTx);
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "0x774(low-pri rx/tx)", \
+		pCoexSta->lowPriorityRx, pCoexSta->lowPriorityTx);
+	CL_PRINTF(cliBuf);
+#if(BT_AUTO_REPORT_ONLY_8703B_2ANT == 1)
+	//halbtc8703b2ant_MonitorBtCtr(pBtCoexist);
+#endif
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+VOID
+EXhalbtc8703b2ant_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_IPS_ENTER == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], IPS ENTER notify\n"));
+		pCoexSta->bUnderIps = TRUE;
+		halbtc8703b2ant_WifiOffHwCfg(pBtCoexist);
+		halbtc8703b2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
+		halbtc8703b2ant_CoexAllOff(pBtCoexist);
+	}
+	else if(BTC_IPS_LEAVE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], IPS LEAVE notify\n"));
+		pCoexSta->bUnderIps = FALSE;
+		halbtc8703b2ant_InitHwConfig(pBtCoexist, FALSE);
+		halbtc8703b2ant_InitCoexDm(pBtCoexist);
+		halbtc8703b2ant_QueryBtInfo(pBtCoexist);
+	}
+}
+
+VOID
+EXhalbtc8703b2ant_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_LPS_ENABLE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], LPS ENABLE notify\n"));
+		pCoexSta->bUnderLps = TRUE;
+	}
+	else if(BTC_LPS_DISABLE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], LPS DISABLE notify\n"));
+		pCoexSta->bUnderLps = FALSE;
+	}
+}
+
+VOID
+EXhalbtc8703b2ant_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	u4Byte 	u4Tmp;
+	u1Byte 	u1Tmpa, u1Tmpb;	
+	
+
+
+	u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x948);
+	u1Tmpa = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x765);
+	u1Tmpb = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x76e);
+	
+	if(BTC_SCAN_START == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCAN START notify\n"));
+	}
+	else if(BTC_SCAN_FINISH == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCAN FINISH notify\n"));
+	}
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x76e=0x%x\n",
+		u4Tmp,  u1Tmpa, u1Tmpb));
+}
+
+VOID
+EXhalbtc8703b2ant_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_ASSOCIATE_START == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], CONNECT START notify\n"));
+	}
+	else if(BTC_ASSOCIATE_FINISH == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], CONNECT FINISH notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8703b2ant_MediaStatusNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte				type
+	)
+{
+	u1Byte			H2C_Parameter[3] ={0};
+	u4Byte			wifiBw;
+	u1Byte			wifiCentralChnl;
+	u1Byte			apNum=0;
+
+	if(BTC_MEDIA_CONNECT == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], MEDIA connect notify\n"));
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], MEDIA disconnect notify\n"));
+	}
+
+	// only 2.4G we need to inform bt the chnl mask
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL, &wifiCentralChnl);
+	if( (BTC_MEDIA_CONNECT == type) &&
+		(wifiCentralChnl <= 14) )
+	{
+		H2C_Parameter[0] = 0x1;
+		H2C_Parameter[1] = wifiCentralChnl;
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+			H2C_Parameter[2] = 0x30;
+		else
+		{
+			pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_AP_NUM, &apNum);
+			if(apNum < 10)
+				H2C_Parameter[2] = 0x30;
+			else
+				H2C_Parameter[2] = 0x20;
+	}
+	}
+	
+	pCoexDm->wifiChnlInfo[0] = H2C_Parameter[0];
+	pCoexDm->wifiChnlInfo[1] = H2C_Parameter[1];
+	pCoexDm->wifiChnlInfo[2] = H2C_Parameter[2];
+	
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], FW write 0x66=0x%x\n", 
+		H2C_Parameter[0]<<16|H2C_Parameter[1]<<8|H2C_Parameter[2]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x66, 3, H2C_Parameter);	
+}
+
+VOID
+EXhalbtc8703b2ant_SpecialPacketNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{
+	if(type == BTC_PACKET_DHCP)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], DHCP Packet notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8703b2ant_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	)
+{
+	PBTC_BT_LINK_INFO	pBtLinkInfo=&pBtCoexist->btLinkInfo;
+	u1Byte			btInfo=0;
+	u1Byte			i, rspSource=0;
+	BOOLEAN			bBtBusy=FALSE, bLimitedDig=FALSE;
+	BOOLEAN			bWifiConnected=FALSE;
+	static BOOLEAN		bPreScoExist=FALSE;
+	u4Byte				raMask=0x0;
+
+	pCoexSta->bC2hBtInfoReqSent = FALSE;
+
+	rspSource = tmpBuf[0]&0xf;
+	if(rspSource >= BT_INFO_SRC_8703B_2ANT_MAX)
+		rspSource = BT_INFO_SRC_8703B_2ANT_WIFI_FW;
+	pCoexSta->btInfoC2hCnt[rspSource]++;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Bt info[%d], length=%d, hex data=[", rspSource, length));
+	for(i=0; i<length; i++)
+	{
+		pCoexSta->btInfoC2h[rspSource][i] = tmpBuf[i];
+		if(i == 1)
+			btInfo = tmpBuf[i];
+		if(i == length-1)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("0x%02x]\n", tmpBuf[i]));
+		}
+		else
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("0x%02x, ", tmpBuf[i]));
+		}
+	}
+
+	if(pBtCoexist->bManualControl)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BtInfoNotify(), return for Manual CTRL<===\n"));
+		return;
+	}
+
+	// if 0xff, it means BT is under WHCK test
+	if (btInfo == 0xff)
+		pCoexSta->bBtWhckTest = TRUE;
+	else
+		pCoexSta->bBtWhckTest = FALSE;
+
+	if(BT_INFO_SRC_8703B_2ANT_WIFI_FW != rspSource)
+	{
+		pCoexSta->btRetryCnt =	// [3:0]
+			pCoexSta->btInfoC2h[rspSource][2]&0xf;
+
+		pCoexSta->btRssi =
+			pCoexSta->btInfoC2h[rspSource][3]*2+10;
+
+		pCoexSta->btInfoExt = 
+			pCoexSta->btInfoC2h[rspSource][4];
+
+		pCoexSta->bBtTxRxMask = (pCoexSta->btInfoC2h[rspSource][2]&0x40);
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_TX_RX_MASK, &pCoexSta->bBtTxRxMask);
+		if (pCoexSta->bBtTxRxMask)
+		{
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x01 => Need to switch BT TRx Mask */				
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x01\n"));
+			pBtCoexist->fBtcSetBtReg(pBtCoexist, BTC_BT_REG_RF, 0x3c, 0x01);
+		}
+
+		// Here we need to resend some wifi info to BT
+		// because bt is reset and loss of the info.
+		if( (pCoexSta->btInfoExt & BIT1) )
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n"));
+			pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+			if(bWifiConnected)
+			{
+				EXhalbtc8703b2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_CONNECT);
+			}
+			else
+			{
+				EXhalbtc8703b2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
+			}
+		}
+		
+		if( (pCoexSta->btInfoExt & BIT3) )
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n"));
+			halbtc8703b2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, FALSE);
+		}
+		else
+		{
+			// BT already NOT ignore Wlan active, do nothing here.
+		}
+#if(BT_AUTO_REPORT_ONLY_8703B_2ANT == 0)
+		if( (pCoexSta->btInfoExt & BIT4) )
+		{
+			// BT auto report already enabled, do nothing
+		}
+		else
+		{
+			halbtc8703b2ant_BtAutoReport(pBtCoexist, FORCE_EXEC, TRUE);
+		}
+#endif
+	}
+
+	// check BIT2 first ==> check if bt is under inquiry or page scan
+	if(btInfo & BT_INFO_8703B_2ANT_B_INQ_PAGE)
+		pCoexSta->bC2hBtInquiryPage = TRUE;
+	else
+		pCoexSta->bC2hBtInquiryPage = FALSE;
+
+	// set link exist status
+	if(!(btInfo&BT_INFO_8703B_2ANT_B_CONNECTION))
+	{
+		pCoexSta->bBtLinkExist = FALSE;
+		pCoexSta->bPanExist = FALSE;
+		pCoexSta->bA2dpExist = FALSE;
+		pCoexSta->bHidExist = FALSE;
+		pCoexSta->bScoExist = FALSE;
+	}
+	else	// connection exists
+	{
+		pCoexSta->bBtLinkExist = TRUE;
+		if(btInfo & BT_INFO_8703B_2ANT_B_FTP)
+			pCoexSta->bPanExist = TRUE;
+		else
+			pCoexSta->bPanExist = FALSE;
+		if(btInfo & BT_INFO_8703B_2ANT_B_A2DP)
+			pCoexSta->bA2dpExist = TRUE;
+		else
+			pCoexSta->bA2dpExist = FALSE;
+		if(btInfo & BT_INFO_8703B_2ANT_B_HID)
+			pCoexSta->bHidExist = TRUE;
+		else
+			pCoexSta->bHidExist = FALSE;
+		if(btInfo & BT_INFO_8703B_2ANT_B_SCO_ESCO)
+			pCoexSta->bScoExist = TRUE;
+		else
+			pCoexSta->bScoExist = FALSE;
+
+		if ( (pCoexSta->bHidExist == FALSE) && (pCoexSta->bC2hBtInquiryPage == FALSE) && (pCoexSta->bScoExist == FALSE))
+		{
+			if (pCoexSta->highPriorityTx  + pCoexSta->highPriorityRx >= 160) 		
+			{
+				pCoexSta->bHidExist = TRUE;
+				btInfo = btInfo | 0x20;
+			}
+		}
+	}
+
+	halbtc8703b2ant_UpdateBtLinkInfo(pBtCoexist);
+	
+	if(!(btInfo&BT_INFO_8703B_2ANT_B_CONNECTION))
+	{
+		pCoexDm->btStatus = BT_8703B_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n"));
+	}
+	else if(btInfo == BT_INFO_8703B_2ANT_B_CONNECTION)	// connection exists but no busy
+	{
+		pCoexDm->btStatus = BT_8703B_2ANT_BT_STATUS_CONNECTED_IDLE;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n"));
+	}
+	else if((btInfo&BT_INFO_8703B_2ANT_B_SCO_ESCO) ||
+		(btInfo&BT_INFO_8703B_2ANT_B_SCO_BUSY))
+	{
+		pCoexDm->btStatus = BT_8703B_2ANT_BT_STATUS_SCO_BUSY;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BtInfoNotify(), BT SCO busy!!!\n"));
+	}
+	else if(btInfo&BT_INFO_8703B_2ANT_B_ACL_BUSY)
+	{
+		pCoexDm->btStatus = BT_8703B_2ANT_BT_STATUS_ACL_BUSY;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BtInfoNotify(), BT ACL busy!!!\n"));
+	}
+	else
+	{
+		pCoexDm->btStatus = BT_8703B_2ANT_BT_STATUS_MAX;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n"));
+	}
+	
+	if( (BT_8703B_2ANT_BT_STATUS_ACL_BUSY == pCoexDm->btStatus) ||
+		(BT_8703B_2ANT_BT_STATUS_SCO_BUSY == pCoexDm->btStatus) ||
+		(BT_8703B_2ANT_BT_STATUS_ACL_SCO_BUSY == pCoexDm->btStatus) )
+	{
+		bBtBusy = TRUE;
+		bLimitedDig = TRUE;
+	}
+	else
+	{
+		bBtBusy = FALSE;
+		bLimitedDig = FALSE;
+	}
+
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bBtBusy);
+
+	pCoexDm->bLimitedDig = bLimitedDig;
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_LIMITED_DIG, &bLimitedDig);
+
+	halbtc8703b2ant_RunCoexistMechanism(pBtCoexist);
+}
+
+VOID
+EXhalbtc8703b2ant_HaltNotify(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Halt notify\n"));
+
+	halbtc8703b2ant_WifiOffHwCfg(pBtCoexist);
+	//remove due to interrupt is disabled that polling c2h will fail and delay 100ms.
+	//pBtCoexist->fBtcSetBtReg(pBtCoexist, BTC_BT_REG_RF, 0x3c, 0x15); //BT goto standby while GNT_BT 1-->0
+	halbtc8703b2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
+	
+	EXhalbtc8703b2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
+}
+
+VOID
+EXhalbtc8703b2ant_PnpNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				pnpState
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Pnp notify\n"));
+
+	if(BTC_WIFI_PNP_SLEEP == pnpState)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Pnp notify to SLEEP\n"));
+	}
+	else if(BTC_WIFI_PNP_WAKE_UP == pnpState)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Pnp notify to WAKE UP\n"));
+		halbtc8703b2ant_InitHwConfig(pBtCoexist, FALSE);
+		halbtc8703b2ant_InitCoexDm(pBtCoexist);
+		halbtc8703b2ant_QueryBtInfo(pBtCoexist);
+	}
+}
+
+VOID
+EXhalbtc8703b2ant_Periodical(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	//static u1Byte		disVerInfoCnt=0;
+	u4Byte				fwVer=0, btPatchVer=0;
+	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], ==========================Periodical===========================\n"));
+
+	if(pCoexSta->disVerInfoCnt <= 5)
+	{
+		pCoexSta->disVerInfoCnt += 1;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], ****************************************************************\n"));
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Ant PG Num/ Ant Mech/ Ant Pos = %d/ %d/ %d\n",
+			pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum, pBoardInfo->btdmAntPos));
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT stack/ hci ext ver = %s / %d\n",
+			((pStackInfo->bProfileNotified)? "Yes":"No"), pStackInfo->hciVersion));
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_BT_PATCH_VER, &btPatchVer);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_FW_VER, &fwVer);
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], CoexVer/ FwVer/ PatchVer = %d_%x/ 0x%x/ 0x%x(%d)\n",
+			GLCoexVerDate8703b2Ant, GLCoexVer8703b2Ant, fwVer, btPatchVer, btPatchVer));
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], ****************************************************************\n"));
+
+		if (pCoexSta->disVerInfoCnt == 3)
+		{
+			//Antenna config to set 0x765 = 0x0 (GNT_BT control by PTA) after initial 
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Set GNT_BT control by PTA\n"));
+			halbtc8703b2ant_SetAntPath(pBtCoexist, BTC_ANT_WIFI_AT_MAIN, FALSE, FALSE);
+		}
+	}
+
+#if(BT_AUTO_REPORT_ONLY_8703B_2ANT == 0)
+	halbtc8703b2ant_QueryBtInfo(pBtCoexist);
+	halbtc8703b2ant_MonitorBtEnableDisable(pBtCoexist);
+#else
+	halbtc8703b2ant_MonitorBtCtr(pBtCoexist);
+	halbtc8703b2ant_MonitorWiFiCtr(pBtCoexist);
+	
+	if( halbtc8703b2ant_IsWifiStatusChanged(pBtCoexist) ||
+		pCoexDm->bAutoTdmaAdjust)
+	{
+		halbtc8703b2ant_RunCoexistMechanism(pBtCoexist);
+	}
+#endif
+}
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b2Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b2Ant.h
new file mode 100644
index 000000000..ab9449758
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8703b2Ant.h
@@ -0,0 +1,228 @@
+//===========================================
+// The following is for 8703B 2Ant BT Co-exist definition
+//===========================================
+#define	BT_AUTO_REPORT_ONLY_8703B_2ANT				1
+
+
+#define	BT_INFO_8703B_2ANT_B_FTP						BIT7
+#define	BT_INFO_8703B_2ANT_B_A2DP					BIT6
+#define	BT_INFO_8703B_2ANT_B_HID						BIT5
+#define	BT_INFO_8703B_2ANT_B_SCO_BUSY				BIT4
+#define	BT_INFO_8703B_2ANT_B_ACL_BUSY				BIT3
+#define	BT_INFO_8703B_2ANT_B_INQ_PAGE				BIT2
+#define	BT_INFO_8703B_2ANT_B_SCO_ESCO				BIT1
+#define	BT_INFO_8703B_2ANT_B_CONNECTION				BIT0
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8703B_2ANT		2
+
+
+#define	BT_8703B_2ANT_WIFI_RSSI_COEXSWITCH_THRES				42  //WiFi RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation
+#define	BT_8703B_2ANT_BT_RSSI_COEXSWITCH_THRES				46 //BT RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation
+
+typedef enum _BT_INFO_SRC_8703B_2ANT{
+	BT_INFO_SRC_8703B_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8703B_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8703B_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8703B_2ANT_MAX
+}BT_INFO_SRC_8703B_2ANT,*PBT_INFO_SRC_8703B_2ANT;
+
+typedef enum _BT_8703B_2ANT_BT_STATUS{
+	BT_8703B_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8703B_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8703B_2ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8703B_2ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8703B_2ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8703B_2ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8703B_2ANT_BT_STATUS_MAX
+}BT_8703B_2ANT_BT_STATUS,*PBT_8703B_2ANT_BT_STATUS;
+
+typedef enum _BT_8703B_2ANT_COEX_ALGO{
+	BT_8703B_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8703B_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8703B_2ANT_COEX_ALGO_HID				= 0x2,
+	BT_8703B_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8703B_2ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8703B_2ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8703B_2ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8703B_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8703B_2ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8703B_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8703B_2ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8703B_2ANT_COEX_ALGO_MAX				= 0xb,
+}BT_8703B_2ANT_COEX_ALGO,*PBT_8703B_2ANT_COEX_ALGO;
+
+typedef struct _COEX_DM_8703B_2ANT{
+	// fw mechanism
+	u1Byte		preBtDecPwrLvl;
+	u1Byte		curBtDecPwrLvl;
+	u1Byte		preFwDacSwingLvl;
+	u1Byte		curFwDacSwingLvl;
+	BOOLEAN		bCurIgnoreWlanAct;
+	BOOLEAN		bPreIgnoreWlanAct;
+	u1Byte		prePsTdma;
+	u1Byte		curPsTdma;
+	u1Byte		psTdmaPara[5];
+	u1Byte		psTdmaDuAdjType;
+	BOOLEAN		bResetTdmaAdjust;
+	BOOLEAN		bAutoTdmaAdjust;
+	BOOLEAN		bPrePsTdmaOn;
+	BOOLEAN		bCurPsTdmaOn;
+	BOOLEAN		bPreBtAutoReport;
+	BOOLEAN		bCurBtAutoReport;
+
+	// sw mechanism
+	BOOLEAN		bPreRfRxLpfShrink;
+	BOOLEAN		bCurRfRxLpfShrink;
+	u4Byte		btRf0x1eBackup;
+	BOOLEAN 	bPreLowPenaltyRa;
+	BOOLEAN		bCurLowPenaltyRa;
+	BOOLEAN		bPreDacSwingOn;
+	u4Byte		preDacSwingLvl;
+	BOOLEAN		bCurDacSwingOn;
+	u4Byte		curDacSwingLvl;
+	BOOLEAN		bPreAdcBackOff;
+	BOOLEAN		bCurAdcBackOff;
+	BOOLEAN 	bPreAgcTableEn;
+	BOOLEAN		bCurAgcTableEn;
+	u4Byte		preVal0x6c0;
+	u4Byte		curVal0x6c0;
+	u4Byte		preVal0x6c4;
+	u4Byte		curVal0x6c4;
+	u4Byte		preVal0x6c8;
+	u4Byte		curVal0x6c8;
+	u1Byte		preVal0x6cc;
+	u1Byte		curVal0x6cc;
+	BOOLEAN		bLimitedDig;
+
+	// algorithm related
+	u1Byte		preAlgorithm;
+	u1Byte		curAlgorithm;
+	u1Byte		btStatus;
+	u1Byte		wifiChnlInfo[3];
+
+	BOOLEAN		bNeedRecover0x948;
+	u4Byte		backup0x948;
+
+	u1Byte		preLps;
+	u1Byte		curLps;
+	u1Byte		preRpwm;
+	u1Byte		curRpwm;
+
+	BOOLEAN		bIsSwitchTo1dot5Ant;
+} COEX_DM_8703B_2ANT, *PCOEX_DM_8703B_2ANT;
+
+typedef struct _COEX_STA_8703B_2ANT{	
+	BOOLEAN					bBtLinkExist;
+	BOOLEAN					bScoExist;
+	BOOLEAN					bA2dpExist;
+	BOOLEAN					bHidExist;
+	BOOLEAN					bPanExist;
+
+	BOOLEAN					bUnderLps;
+	BOOLEAN					bUnderIps;
+	u4Byte					highPriorityTx;
+	u4Byte					highPriorityRx;
+	u4Byte					lowPriorityTx;
+	u4Byte					lowPriorityRx;
+	u1Byte					btRssi;
+	BOOLEAN				bBtTxRxMask;
+	u1Byte					preBtRssiState;
+	u1Byte					preWifiRssiState[4];
+	BOOLEAN					bC2hBtInfoReqSent;
+	u1Byte					btInfoC2h[BT_INFO_SRC_8703B_2ANT_MAX][10];
+	u4Byte					btInfoC2hCnt[BT_INFO_SRC_8703B_2ANT_MAX];
+	BOOLEAN 				bBtWhckTest;
+	BOOLEAN					bC2hBtInquiryPage;
+	u1Byte					btRetryCnt;
+	u1Byte					btInfoExt;
+
+	u4Byte					nCRCOK_CCK;
+	u4Byte					nCRCOK_11g;
+	u4Byte					nCRCOK_11n;
+	u4Byte					nCRCOK_11nAgg;
+	
+	u4Byte					nCRCErr_CCK;
+	u4Byte					nCRCErr_11g;
+	u4Byte					nCRCErr_11n;
+	u4Byte					nCRCErr_11nAgg;
+
+	u1Byte					nCoexTableType;
+	BOOLEAN					bForceLpsOn;
+
+	u1Byte					disVerInfoCnt;
+}COEX_STA_8703B_2ANT, *PCOEX_STA_8703B_2ANT;
+
+//===========================================
+// The following is interface which will notify coex module.
+//===========================================
+VOID
+EXhalbtc8703b2ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8703b2ant_PreLoadFirmware(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8703b2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
+EXhalbtc8703b2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8703b2ant_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8703b2ant_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8703b2ant_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8703b2ant_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8703b2ant_MediaStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8703b2ant_SpecialPacketNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8703b2ant_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	);
+VOID
+EXhalbtc8703b2ant_HaltNotify(
+	IN	PBTC_COEXIST			pBtCoexist
+	);
+VOID
+EXhalbtc8703b2ant_PnpNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				pnpState
+	);
+VOID
+EXhalbtc8703b2ant_Periodical(
+	IN	PBTC_COEXIST			pBtCoexist
+	);
+VOID
+EXhalbtc8703b2ant_DisplayCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a1Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a1Ant.c
new file mode 100644
index 000000000..5883a3743
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a1Ant.c
@@ -0,0 +1,1544 @@
+//============================================================
+// Description:
+//
+// This file is for RTL8723A Co-exist mechanism
+//
+// History
+// 2012/08/22 Cosa first check in.
+// 2012/11/14 Cosa Revise for 8723A 1Ant out sourcing.
+//
+//============================================================
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+
+#if WPP_SOFTWARE_TRACE
+#include "HalBtc8723a1Ant.tmh"
+#endif
+
+#if(BT_30_SUPPORT == 1)
+//============================================================
+// Global variables, these are static variables
+//============================================================
+static COEX_DM_8723A_1ANT	GLCoexDm8723a1Ant;
+static PCOEX_DM_8723A_1ANT 	pCoexDm=&GLCoexDm8723a1Ant;
+static COEX_STA_8723A_1ANT	GLCoexSta8723a1Ant;
+static PCOEX_STA_8723A_1ANT	pCoexSta=&GLCoexSta8723a1Ant;
+
+const char *const GLBtInfoSrc8723a1Ant[]={
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+//============================================================
+// local function proto type if needed
+//============================================================
+//============================================================
+// local function start with halbtc8723a1ant_
+//============================================================
+VOID
+halbtc8723a1ant_Reg0x550Bit3(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bSet
+	)
+{
+	u1Byte	u1tmp=0;
+	
+	u1tmp = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x550);
+	if(bSet)
+	{
+		u1tmp |= BIT3;
+	}
+	else
+	{
+		u1tmp &= ~BIT3;
+	}
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x550, u1tmp);
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], set 0x550[3]=%d\n", (bSet? 1:0)));
+}
+
+VOID
+halbtc8723a1ant_NotifyFwScan(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			scanType
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+	
+	if(BTC_SCAN_START == scanType)
+		H2C_Parameter[0] = 0x1;
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Notify FW for wifi scan, write 0x3b=0x%x\n", 
+		H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x3b, 1, H2C_Parameter);
+}
+
+VOID
+halbtc8723a1ant_QueryBtInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+
+	pCoexSta->bC2hBtInfoReqSent = TRUE;
+
+	H2C_Parameter[0] |= BIT0;	// trigger
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Query Bt Info, FW write 0x38=0x%x\n", 
+		H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x38, 1, H2C_Parameter);
+}
+
+VOID
+halbtc8723a1ant_SetSwRfRxLpfCorner(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bRxRfShrinkOn
+	)
+{
+	if(bRxRfShrinkOn)
+	{
+		//Shrink RF Rx LPF corner
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Shrink RF Rx LPF corner!!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff, 0xf0ff7);
+	}
+	else
+	{
+		//Resume RF Rx LPF corner
+		// After initialized, we can use pCoexDm->btRf0x1eBackup
+		if(pBtCoexist->bInitilized)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Resume RF Rx LPF corner!!\n"));
+			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff, pCoexDm->btRf0x1eBackup);
+		}
+	}
+}
+
+VOID
+halbtc8723a1ant_RfShrink(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bRxRfShrinkOn
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn Rx RF Shrink = %s\n",  
+		(bForceExec? "force to":""), ((bRxRfShrinkOn)? "ON":"OFF")));
+	pCoexDm->bCurRfRxLpfShrink = bRxRfShrinkOn;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreRfRxLpfShrink == pCoexDm->bCurRfRxLpfShrink) 
+			return;
+	}
+	halbtc8723a1ant_SetSwRfRxLpfCorner(pBtCoexist, pCoexDm->bCurRfRxLpfShrink);
+
+	pCoexDm->bPreRfRxLpfShrink = pCoexDm->bCurRfRxLpfShrink;
+}
+
+VOID
+halbtc8723a1ant_SetSwPenaltyTxRateAdaptive(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bLowPenaltyRa
+	)
+{
+	u1Byte	tmpU1;
+
+	tmpU1 = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x4fd);
+	tmpU1 |= BIT0;
+	if(bLowPenaltyRa)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Tx rate adaptive, set low penalty!!\n"));
+		tmpU1 &= ~BIT2;
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Tx rate adaptive, set normal!!\n"));
+		tmpU1 |= BIT2;
+	}
+
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x4fd, tmpU1);
+}
+
+VOID
+halbtc8723a1ant_LowPenaltyRa(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bLowPenaltyRa
+	)
+{
+	return;
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn LowPenaltyRA = %s\n",  
+		(bForceExec? "force to":""), ((bLowPenaltyRa)? "ON":"OFF")));
+	pCoexDm->bCurLowPenaltyRa = bLowPenaltyRa;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreLowPenaltyRa == pCoexDm->bCurLowPenaltyRa) 
+			return;
+	}
+	halbtc8723a1ant_SetSwPenaltyTxRateAdaptive(pBtCoexist, pCoexDm->bCurLowPenaltyRa);
+
+	pCoexDm->bPreLowPenaltyRa = pCoexDm->bCurLowPenaltyRa;
+}
+
+VOID
+halbtc8723a1ant_SetCoexTable(
+	IN	PBTC_COEXIST	pBtCoexist,
+	IN	u4Byte		val0x6c0,
+	IN	u4Byte		val0x6c8,
+	IN	u1Byte		val0x6cc
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set coex table, set 0x6c0=0x%x\n", val0x6c0));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c0, val0x6c0);
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set coex table, set 0x6c8=0x%x\n", val0x6c8));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c8, val0x6c8);
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set coex table, set 0x6cc=0x%x\n", val0x6cc));
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x6cc, val0x6cc);
+}
+
+VOID
+halbtc8723a1ant_CoexTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	u4Byte			val0x6c0,
+	IN	u4Byte			val0x6c8,
+	IN	u1Byte			val0x6cc
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s write Coex Table 0x6c0=0x%x, 0x6c8=0x%x, 0x6cc=0x%x\n", 
+		(bForceExec? "force to":""), val0x6c0, val0x6c8, val0x6cc));
+	pCoexDm->curVal0x6c0 = val0x6c0;
+	pCoexDm->curVal0x6c8 = val0x6c8;
+	pCoexDm->curVal0x6cc = val0x6cc;
+
+	if(!bForceExec)
+	{	
+		if( (pCoexDm->preVal0x6c0 == pCoexDm->curVal0x6c0) &&
+			(pCoexDm->preVal0x6c8 == pCoexDm->curVal0x6c8) &&
+			(pCoexDm->preVal0x6cc == pCoexDm->curVal0x6cc) )
+			return;
+	}
+	halbtc8723a1ant_SetCoexTable(pBtCoexist, val0x6c0, val0x6c8, val0x6cc);
+
+	pCoexDm->preVal0x6c0 = pCoexDm->curVal0x6c0;
+	pCoexDm->preVal0x6c8 = pCoexDm->curVal0x6c8;
+	pCoexDm->preVal0x6cc = pCoexDm->curVal0x6cc;
+}
+
+VOID
+halbtc8723a1ant_SetFwIgnoreWlanAct(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bEnable
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+		
+	if(bEnable)
+	{
+		H2C_Parameter[0] |= BIT0;		// function enable
+	}
+	
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set FW for BT Ignore Wlan_Act, FW write 0x25=0x%x\n", 
+		H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x25, 1, H2C_Parameter);	
+}
+
+VOID
+halbtc8723a1ant_IgnoreWlanAct(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bEnable
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn Ignore WlanAct %s\n", 
+		(bForceExec? "force to":""), (bEnable? "ON":"OFF")));
+	pCoexDm->bCurIgnoreWlanAct = bEnable;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreIgnoreWlanAct == pCoexDm->bCurIgnoreWlanAct)
+			return;
+	}
+	halbtc8723a1ant_SetFwIgnoreWlanAct(pBtCoexist, bEnable);
+
+	pCoexDm->bPreIgnoreWlanAct = pCoexDm->bCurIgnoreWlanAct;
+}
+
+VOID
+halbtc8723a1ant_SetFwPstdma(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type,
+	IN	u1Byte			byte1,
+	IN	u1Byte			byte2,
+	IN	u1Byte			byte3,
+	IN	u1Byte			byte4,
+	IN	u1Byte			byte5
+	)
+{
+	u1Byte			H2C_Parameter[5] ={0};
+	u1Byte			realByte1=byte1, realByte5=byte5;
+	BOOLEAN			bApEnable=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE, &bApEnable);
+
+	// byte1[1:0] != 0 means enable pstdma
+	// for 2Ant bt coexist, if byte1 != 0 means enable pstdma
+	if(byte1)
+	{
+		if(bApEnable)
+		{
+			if(type != 5 && type != 12)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], FW for 1Ant AP mode\n"));
+				realByte1 &= ~BIT4;
+				realByte1 |= BIT5;
+
+				realByte5 |= BIT5;
+				realByte5 &= ~BIT6;
+			}
+		}
+	}
+	H2C_Parameter[0] = realByte1;	
+	H2C_Parameter[1] = byte2;	
+	H2C_Parameter[2] = byte3;
+	H2C_Parameter[3] = byte4;
+	H2C_Parameter[4] = realByte5;
+
+	pCoexDm->psTdmaPara[0] = realByte1;
+	pCoexDm->psTdmaPara[1] = byte2;
+	pCoexDm->psTdmaPara[2] = byte3;
+	pCoexDm->psTdmaPara[3] = byte4;
+	pCoexDm->psTdmaPara[4] = realByte5;
+	
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], FW write 0x3a(5bytes)=0x%x%08x\n", 
+		H2C_Parameter[0], 
+		H2C_Parameter[1]<<24|H2C_Parameter[2]<<16|H2C_Parameter[3]<<8|H2C_Parameter[4]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x3a, 5, H2C_Parameter);
+}
+
+VOID
+halbtc8723a1ant_PsTdma(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bTurnOn,
+	IN	u1Byte			type
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn %s PS TDMA, type=%d\n", 
+		(bForceExec? "force to":""), (bTurnOn? "ON":"OFF"), type));		
+	pCoexDm->bCurPsTdmaOn = bTurnOn;
+	pCoexDm->curPsTdma = type;
+
+	if(!bForceExec)
+	{
+		if( (pCoexDm->bPrePsTdmaOn == pCoexDm->bCurPsTdmaOn) &&
+			(pCoexDm->prePsTdma == pCoexDm->curPsTdma) )
+			return;
+	}	
+	if(pCoexDm->bCurPsTdmaOn)
+	{
+		switch(pCoexDm->curPsTdma)
+		{
+			case 1:
+			default:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x13, 0x1a, 0x1a, 0x0, 0x40);
+				break;
+			case 2:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x13, 0x12, 0x12, 0x0, 0x40);
+				break;
+			case 3:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x93, 0x3f, 0x3, 0x10, 0x40);
+				break;
+			case 4:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x93, 0x15, 0x3, 0x10, 0x0);
+				break;
+			case 5:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0xa9, 0x15, 0x3, 0x35, 0xc0);
+				break;
+			
+			case 8: 
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x93, 0x25, 0x3, 0x10, 0x0);
+				break;
+			case 9: 
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x13, 0xa, 0xa, 0x0, 0x40);
+				break;
+			case 10:	
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x13, 0xa, 0xa, 0x0, 0x40);
+				break;
+			case 11:	
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x13, 0x5, 0x5, 0x0, 0x40);
+				break;
+			case 12:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0xa9, 0xa, 0x3, 0x15, 0xc0);
+				break;
+	
+			case 18:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x93, 0x25, 0x3, 0x10, 0x0);
+				break;			
+
+			case 20:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x13, 0x2a, 0x2a, 0x0, 0x0);
+				break;
+			case 21:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x93, 0x20, 0x3, 0x10, 0x40);
+				break;
+			case 22:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x13, 0x1a, 0x1a, 0x2, 0x40);
+				break;
+			case 23:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x13, 0x12, 0x12, 0x2, 0x40);
+				break;
+			case 24:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x13, 0xa, 0xa, 0x2, 0x40);
+				break;
+			case 25:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x13, 0x5, 0x5, 0x2, 0x40);
+				break;
+			case 26:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x93, 0x25, 0x3, 0x10, 0x0);
+				break;
+			case 27:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x13, 0x5, 0x5, 0x2, 0x40);
+				break;
+			case 28:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x3, 0x2f, 0x2f, 0x0, 0x0);
+				break;
+
+		}
+	}
+	else
+	{
+		// disable PS tdma
+		switch(pCoexDm->curPsTdma)
+		{
+			case 8:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x8, 0x0, 0x0, 0x0, 0x0);		
+				break;
+			case 0:
+			default:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x0, 0x0, 0x0, 0x0, 0x0);
+				pBtCoexist->fBtcWrite2Byte(pBtCoexist, 0x860, 0x210);
+				break;
+			case 9:
+				halbtc8723a1ant_SetFwPstdma(pBtCoexist, type, 0x0, 0x0, 0x0, 0x0, 0x0);
+				pBtCoexist->fBtcWrite2Byte(pBtCoexist, 0x860, 0x110);
+				break;
+
+		}
+	}
+
+	// update pre state
+	pCoexDm->bPrePsTdmaOn = pCoexDm->bCurPsTdmaOn;
+	pCoexDm->prePsTdma = pCoexDm->curPsTdma;
+}
+
+
+VOID
+halbtc8723a1ant_CoexAllOff(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	// fw all off
+	halbtc8723a1ant_IgnoreWlanAct(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+
+	// sw all off
+	halbtc8723a1ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a1ant_RfShrink(pBtCoexist, NORMAL_EXEC, FALSE);
+
+	// hw all off
+	halbtc8723a1ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+}
+
+VOID
+halbtc8723a1ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	// force to reset coex mechanism
+	halbtc8723a1ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, FALSE);
+}
+
+VOID
+halbtc8723a1ant_BtEnableAction(
+	IN 	PBTC_COEXIST		pBtCoexist
+	)
+{
+	halbtc8723a1ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, FALSE);
+}
+
+VOID
+halbtc8723a1ant_MonitorBtCtr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u4Byte 			regHPTxRx, regLPTxRx, u4Tmp;
+	u4Byte			regHPTx=0, regHPRx=0, regLPTx=0, regLPRx=0;
+	u1Byte			u1Tmp;
+	
+	regHPTxRx = 0x770;
+	regLPTxRx = 0x774;
+
+	u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, regHPTxRx);
+	regHPTx = u4Tmp & bMaskLWord;
+	regHPRx = (u4Tmp & bMaskHWord)>>16;
+
+	u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, regLPTxRx);
+	regLPTx = u4Tmp & bMaskLWord;
+	regLPRx = (u4Tmp & bMaskHWord)>>16;
+		
+	pCoexSta->highPriorityTx = regHPTx;
+	pCoexSta->highPriorityRx = regHPRx;
+	pCoexSta->lowPriorityTx = regLPTx;
+	pCoexSta->lowPriorityRx = regLPRx;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n", 
+		regHPTxRx, regHPTx, regHPTx, regHPRx, regHPRx));
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n", 
+		regLPTxRx, regLPTx, regLPTx, regLPRx, regLPRx));
+
+	// reset counter
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0xc);
+}
+
+VOID
+halbtc8723a1ant_MonitorBtEnableDisable(
+	IN 	PBTC_COEXIST		pBtCoexist
+	)
+{
+	static BOOLEAN	bPreBtDisabled=FALSE;
+	static u4Byte	btDisableCnt=0;
+	BOOLEAN			bBtActive=TRUE, bBtDisabled=FALSE;
+
+	// This function check if bt is disabled
+	
+	if(	pCoexSta->highPriorityTx == 0 &&
+		pCoexSta->highPriorityRx == 0 &&
+		pCoexSta->lowPriorityTx == 0 &&
+		pCoexSta->lowPriorityRx == 0)
+	{
+		bBtActive = FALSE;
+	}
+	if(	pCoexSta->highPriorityTx == 0xffff &&
+		pCoexSta->highPriorityRx == 0xffff &&
+		pCoexSta->lowPriorityTx == 0xffff &&
+		pCoexSta->lowPriorityRx == 0xffff)
+	{
+		bBtActive = FALSE;
+	}
+	if(bBtActive)
+	{
+		btDisableCnt = 0;
+		bBtDisabled = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_DISABLE, &bBtDisabled);
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is enabled !!\n"));
+	}
+	else
+	{
+		btDisableCnt++;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], bt all counters=0, %d times!!\n", 
+				btDisableCnt));
+		if(btDisableCnt >= 2)
+		{
+			bBtDisabled = TRUE;
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_DISABLE, &bBtDisabled);
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is disabled !!\n"));
+		}
+	}
+	if(bPreBtDisabled != bBtDisabled)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is from %s to %s!!\n", 
+			(bPreBtDisabled ? "disabled":"enabled"), 
+			(bBtDisabled ? "disabled":"enabled")));
+		bPreBtDisabled = bBtDisabled;
+		if(!bBtDisabled)
+		{
+			halbtc8723a1ant_BtEnableAction(pBtCoexist);
+		}
+		else
+		{
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_NORMAL_LPS, NULL);
+		}
+	}
+}
+
+VOID
+halbtc8723a1ant_TdmaDurationAdjust(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	static s4Byte		up,dn,m,n,WaitCount;
+	s4Byte			result;   //0: no change, +1: increase WiFi duration, -1: decrease WiFi duration
+	u1Byte			retryCount=0;
+	u1Byte			btState;
+	BOOLEAN			bScan=FALSE, bLink=FALSE, bRoam=FALSE;
+	u4Byte			wifiBw;
+	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	btState = pCoexDm->btStatus;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], TdmaDurationAdjust()\n"));
+	if(pCoexDm->psTdmaGlobalCnt != pCoexDm->psTdmaMonitorCnt)
+	{
+		pCoexDm->psTdmaMonitorCnt = 0;
+		pCoexDm->psTdmaGlobalCnt = 0;
+	}
+	if(pCoexDm->psTdmaMonitorCnt == 0)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], first run BT A2DP + WiFi busy state!!\n"));
+		if(btState == BT_STATE_8723A_1ANT_ACL_ONLY_BUSY)
+		{
+			halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+			pCoexDm->psTdmaDuAdjType = 1;
+		}
+		else
+		{
+			halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
+			pCoexDm->psTdmaDuAdjType = 22;
+		}
+		//============
+		up = 0;
+		dn = 0;
+		m = 1;
+		n= 3;
+		result = 0;
+		WaitCount = 0;
+	}
+	else
+	{
+		//accquire the BT TRx retry count from BT_Info byte2
+		retryCount = pCoexSta->btRetryCnt;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], retryCount = %d\n", retryCount));
+		result = 0;
+		WaitCount++; 
+		  
+		if(retryCount == 0)  // no retry in the last 2-second duration
+		{
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0; 			 
+
+			if(up >= n) // if s n 2 retry count0, heWiFi duration
+			{
+				WaitCount = 0; 
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1; 
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Increase wifi duration!!\n"));
+			}
+		}
+		else if (retryCount <= 3)	// <=3 retry in the last 2-second duration
+		{
+			up--; 
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2)	// if s 2 2 retry count< 3, hWiFi duration
+			{
+				if (WaitCount <= 2)
+					m++; // K@blevel^
+				else
+					m = 1;
+
+				if ( m >= 20) //m j = 20 ' j120 recheckO_ WiFi duration.
+					m = 20;
+
+				n = 3*m;
+				up = 0;
+				dn = 0;
+				WaitCount = 0;	
+				result = -1; 
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Decrease wifi duration for retryCounter<3!!\n"));
+			}
+		}
+		else  //retry count > 3, un1 retry count > 3, hWiFi duration
+		{
+			if (WaitCount == 1)
+				m++; // K@blevel^
+			else
+				m = 1;
+
+			if ( m >= 20) //m j = 20 ' j120 recheckO_ WiFi duration.
+				m = 20;
+
+			n = 3*m;
+			up = 0;
+			dn = 0;
+			WaitCount = 0; 
+			result = -1;
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Decrease wifi duration for retryCounter>3!!\n"));
+		}
+		
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT TxRx counter H+L <= 1200\n"));
+			if(btState != BT_STATE_8723A_1ANT_ACL_ONLY_BUSY)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], NOT ACL only busy!\n"));
+				if(BTC_WIFI_BW_HT40 != wifiBw)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], 20MHz\n"));
+					if(result == -1)
+					{
+						if(pCoexDm->curPsTdma == 22)
+						{
+							halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 23);
+							pCoexDm->psTdmaDuAdjType = 23;
+						}
+						else if(pCoexDm->curPsTdma == 23)
+						{
+							halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 24);
+							pCoexDm->psTdmaDuAdjType = 24;
+						}
+						else if(pCoexDm->curPsTdma == 24)
+						{
+							halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 25);
+							pCoexDm->psTdmaDuAdjType = 25;
+						}
+					} 
+					else if (result == 1)
+					{
+						if(pCoexDm->curPsTdma == 25)
+						{
+							halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 24);
+							pCoexDm->psTdmaDuAdjType = 24;
+						}
+						else if(pCoexDm->curPsTdma == 24)
+						{
+							halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 23);
+							pCoexDm->psTdmaDuAdjType = 23;
+						}
+						else if(pCoexDm->curPsTdma == 23)
+						{
+							halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
+							pCoexDm->psTdmaDuAdjType = 22;
+						}
+					}
+					// error handle, if not in the following state,
+					// set psTdma again.
+					if( (pCoexDm->psTdmaDuAdjType != 22) &&
+						(pCoexDm->psTdmaDuAdjType != 23) &&
+						(pCoexDm->psTdmaDuAdjType != 24) &&
+						(pCoexDm->psTdmaDuAdjType != 25) )
+					{
+						RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], duration case out of handle!!\n"));
+						halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 23);
+						pCoexDm->psTdmaDuAdjType = 23;
+					}
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], 40MHz\n"));
+					if(result == -1)
+					{
+						if(pCoexDm->curPsTdma == 23)
+						{
+							halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 24);
+							pCoexDm->psTdmaDuAdjType = 24;
+						}
+						else if(pCoexDm->curPsTdma == 24)
+						{
+							halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 25);
+							pCoexDm->psTdmaDuAdjType = 25;
+						}
+						else if(pCoexDm->curPsTdma == 25)
+						{
+							halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 27);
+							pCoexDm->psTdmaDuAdjType = 27;
+						}
+					} 
+					else if (result == 1)
+					{
+						if(pCoexDm->curPsTdma == 27)
+						{
+							halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 25);
+							pCoexDm->psTdmaDuAdjType = 25;
+						}
+						else if(pCoexDm->curPsTdma == 25)
+						{
+							halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 24);
+							pCoexDm->psTdmaDuAdjType = 24;
+						}
+						else if(pCoexDm->curPsTdma == 24)
+						{
+							halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 23);
+							pCoexDm->psTdmaDuAdjType = 23;
+						}
+					}
+					// error handle, if not in the following state,
+					// set psTdma again.
+					if( (pCoexDm->psTdmaDuAdjType != 23) &&
+						(pCoexDm->psTdmaDuAdjType != 24) &&
+						(pCoexDm->psTdmaDuAdjType != 25) &&
+						(pCoexDm->psTdmaDuAdjType != 27) )
+					{
+						RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], duration case out of handle!!\n"));
+						halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 24);
+						pCoexDm->psTdmaDuAdjType = 24;
+					}
+				}
+			}
+			else
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], ACL only busy\n"));
+				if (result == -1)
+				{
+					if(pCoexDm->curPsTdma == 1)
+					{
+						halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+						pCoexDm->psTdmaDuAdjType = 9;
+					}
+					else if(pCoexDm->curPsTdma == 9)
+					{
+						halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+				}
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+						pCoexDm->psTdmaDuAdjType = 9;
+					}
+					else if(pCoexDm->curPsTdma == 9)
+					{
+						halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+						pCoexDm->psTdmaDuAdjType = 1;
+					}
+				}
+
+				// error handle, if not in the following state,
+				// set psTdma again.
+				if( (pCoexDm->psTdmaDuAdjType != 1) &&
+					(pCoexDm->psTdmaDuAdjType != 2) &&
+					(pCoexDm->psTdmaDuAdjType != 9) &&
+					(pCoexDm->psTdmaDuAdjType != 11) )
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], duration case out of handle!!\n"));
+					halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+					pCoexDm->psTdmaDuAdjType = 2;
+				}
+			}
+		}
+	}
+
+	// if current PsTdma not match with the recorded one (when scan, dhcp...), 
+	// then we have to adjust it back to the previous record one.
+	if(pCoexDm->curPsTdma != pCoexDm->psTdmaDuAdjType)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PsTdma type dismatch!!!, curPsTdma=%d, recordPsTdma=%d\n", 
+			pCoexDm->curPsTdma, pCoexDm->psTdmaDuAdjType));
+
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+
+		if( !bScan && !bLink &&	!bRoam)
+		{
+			halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, pCoexDm->psTdmaDuAdjType);
+		}
+		else
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n"));
+		}
+	}
+	pCoexDm->psTdmaMonitorCnt++;
+}
+
+
+VOID
+halbtc8723a1ant_CoexForWifiConnect(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bWifiConnected=FALSE, bWifiBusy=FALSE;
+	u1Byte		btState, btInfoOriginal=0;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+
+	btState = pCoexDm->btStatus;
+	btInfoOriginal = pCoexSta->btInfoC2h[BT_INFO_SRC_8723A_1ANT_BT_RSP][0];
+
+	if(bWifiConnected)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], wifi connected!!\n"));
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+		
+		if( !bWifiBusy &&
+			((BT_STATE_8723A_1ANT_NO_CONNECTION == btState) ||
+			(BT_STATE_8723A_1ANT_CONNECT_IDLE == btState)) )
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], [Wifi is idle] or [Bt is non connected idle or Bt is connected idle]!!\n"));
+
+			if(BT_STATE_8723A_1ANT_NO_CONNECTION == btState)
+				halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 9);
+			else if(BT_STATE_8723A_1ANT_CONNECT_IDLE == btState)
+				halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+
+			pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x880, 0xff000000, 0xc0);
+		}
+		else
+		{
+			if( (BT_STATE_8723A_1ANT_SCO_ONLY_BUSY == btState) ||
+				(BT_STATE_8723A_1ANT_ACL_SCO_BUSY == btState) ||
+				(BT_STATE_8723A_1ANT_HID_BUSY == btState) ||
+				(BT_STATE_8723A_1ANT_HID_SCO_BUSY == btState) )
+			{
+				pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x880, 0xff000000, 0x60);
+			}
+			else
+			{
+				pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x880, 0xff000000, 0xc0);
+			}
+			switch(btState)
+			{
+				case BT_STATE_8723A_1ANT_NO_CONNECTION:
+					halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+					break;
+				case BT_STATE_8723A_1ANT_CONNECT_IDLE:
+					halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+					break;
+				case BT_STATE_8723A_1ANT_INQ_OR_PAG:
+					halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+					break;
+				case BT_STATE_8723A_1ANT_SCO_ONLY_BUSY:
+				case BT_STATE_8723A_1ANT_ACL_SCO_BUSY:
+				case BT_STATE_8723A_1ANT_HID_BUSY:
+				case BT_STATE_8723A_1ANT_HID_SCO_BUSY:
+					halbtc8723a1ant_TdmaDurationAdjust(pBtCoexist);
+					break;
+				case BT_STATE_8723A_1ANT_ACL_ONLY_BUSY:
+					if (btInfoOriginal&BT_INFO_8723A_1ANT_B_A2DP)
+					{
+						halbtc8723a1ant_TdmaDurationAdjust(pBtCoexist);
+					}
+					else if(btInfoOriginal&BT_INFO_8723A_1ANT_B_FTP)
+					{
+						halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+					}
+					else if( (btInfoOriginal&BT_INFO_8723A_1ANT_B_A2DP) &&
+							(btInfoOriginal&BT_INFO_8723A_1ANT_B_FTP) )
+					{
+						halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+					}
+					else
+					{
+						halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+					}
+					break;
+				default:
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], error!!!, undefined case in halbtc8723a1ant_CoexForWifiConnect()!!\n"));
+					break;
+			}
+		}
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], wifi is disconnected!!\n"));
+	}
+
+	pCoexDm->psTdmaGlobalCnt++;
+}
+
+//============================================================
+// work around function start with wa_halbtc8723a1ant_
+//============================================================
+VOID
+wa_halbtc8723a1ant_MonitorC2h(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	u1Byte	tmp1b=0x0;
+	u4Byte	curC2hTotalCnt=0x0;
+	static u4Byte	preC2hTotalCnt=0x0, sameCntPollingTime=0x0;
+
+	curC2hTotalCnt+=pCoexSta->btInfoC2hCnt[BT_INFO_SRC_8723A_1ANT_BT_RSP];
+
+	if(curC2hTotalCnt == preC2hTotalCnt)
+	{
+		sameCntPollingTime++;
+	}
+	else
+	{
+		preC2hTotalCnt = curC2hTotalCnt;
+		sameCntPollingTime = 0;
+	}
+
+	if(sameCntPollingTime >= 2)
+	{
+		tmp1b = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x1af);
+		if(tmp1b != 0x0)
+		{
+			pCoexSta->c2hHangDetectCnt++;
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x1af, 0x0);
+		}
+	}
+}
+
+//============================================================
+// extern function start with EXhalbtc8723a1ant_
+//============================================================
+VOID
+EXhalbtc8723a1ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], 1Ant Init HW Config!!\n"));
+
+	// backup rf 0x1e value
+	pCoexDm->btRf0x1eBackup = 
+		pBtCoexist->fBtcGetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff);
+
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x20);
+
+	// enable counter statistics
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x4);
+	
+	// coex table
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x6cc, 0x0);			// 1-Ant coex
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c8, 0xffff);		// wifi break table
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c4, 0x55555555);	//coex table
+
+	// antenna switch control parameter
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x858, 0xaaaaaaaa);
+	
+	pBtCoexist->fBtcWrite2Byte(pBtCoexist, 0x860, 0x210);	//set antenna at wifi side if ANTSW is software control
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x870, 0x300);	//SPDT(connected with TRSW) control by hardware PTA
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x874, 0x22804000);	//ANTSW keep by GNT_BT
+
+	// coexistence parameters
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x778, 0x1);	// enable RTK mode PTA
+}
+
+VOID
+EXhalbtc8723a1ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Coex Mechanism Init!!\n"));
+	
+	halbtc8723a1ant_InitCoexDm(pBtCoexist);
+}
+
+VOID
+EXhalbtc8723a1ant_DisplayCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	pu1Byte				cliBuf=pBtCoexist->cliBuf;
+	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
+	u4Byte				u4Tmp[4];
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
+		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
+	CL_PRINTF(cliBuf);	
+	
+	if(pBtCoexist->bManualControl)
+	{
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "[Action Manual control]!!");
+		CL_PRINTF(cliBuf);
+	}
+	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %d", "BT stack/ hci ext ver", \
+		((pStackInfo->bProfileNotified)? "Yes":"No"), pStackInfo->hciVersion);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
+		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
+		pCoexDm->wifiChnlInfo[2]);
+	CL_PRINTF(cliBuf);
+	
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
+	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
+		((pCoexSta->bC2hBtInquiryPage)?("inquiry/page scan"):((BT_8723A_1ANT_BT_STATUS_IDLE == pCoexDm->btStatus)? "idle":(  (BT_8723A_1ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus)? "connected-idle":"busy"))),
+		pCoexSta->btRssi, pCoexSta->btRetryCnt);
+	CL_PRINTF(cliBuf);
+	
+	if(pStackInfo->bProfileNotified)
+	{			
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "SCO/HID/PAN/A2DP", \
+			pStackInfo->bScoExist, pStackInfo->bHidExist, pStackInfo->bPanExist, pStackInfo->bA2dpExist);
+		CL_PRINTF(cliBuf);	
+
+		pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_BT_LINK_INFO);
+	}
+
+	btInfoExt = pCoexSta->btInfoExt;
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "BT Info A2DP rate", \
+		(btInfoExt&BIT0)? "Basic rate":"EDR rate");
+	CL_PRINTF(cliBuf);	
+
+	for(i=0; i<BT_INFO_SRC_8723A_1ANT_MAX; i++)
+	{
+		if(pCoexSta->btInfoC2hCnt[i])
+		{				
+			CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)", GLBtInfoSrc8723a1Ant[i], \
+				pCoexSta->btInfoC2h[i][0], pCoexSta->btInfoC2h[i][1],
+				pCoexSta->btInfoC2h[i][2], pCoexSta->btInfoC2h[i][3],
+				pCoexSta->btInfoC2h[i][4], pCoexSta->btInfoC2h[i][5],
+				pCoexSta->btInfoC2h[i][6], pCoexSta->btInfoC2hCnt[i]);
+			CL_PRINTF(cliBuf);
+		}
+	}
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "write 0x1af=0x0 num", \
+		pCoexSta->c2hHangDetectCnt);
+	CL_PRINTF(cliBuf);
+	
+	// Sw mechanism	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Sw mechanism]============");
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d", "SM1[ShRf/ LpRA/ LimDig]", \
+		pCoexDm->bCurRfRxLpfShrink, pCoexDm->bCurLowPenaltyRa, pCoexDm->bLimitedDig);
+	CL_PRINTF(cliBuf);
+
+	// Fw mechanism		
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Fw mechanism]============");
+	CL_PRINTF(cliBuf);	
+	
+	if(!pBtCoexist->bManualControl)
+	{
+		psTdmaCase = pCoexDm->curPsTdma;
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x %02x %02x case-%d", "PS TDMA", \
+			pCoexDm->psTdmaPara[0], pCoexDm->psTdmaPara[1],
+			pCoexDm->psTdmaPara[2], pCoexDm->psTdmaPara[3],
+			pCoexDm->psTdmaPara[4], psTdmaCase);
+		CL_PRINTF(cliBuf);
+	
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ", "IgnWlanAct", \
+			pCoexDm->bCurIgnoreWlanAct);
+		CL_PRINTF(cliBuf);
+	}
+
+	// Hw setting		
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Hw setting]============");
+	CL_PRINTF(cliBuf);	
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "RF-A, 0x1e initVal", \
+		pCoexDm->btRf0x1eBackup);
+	CL_PRINTF(cliBuf);
+
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x778);
+	u1Tmp[1] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x783);
+	u1Tmp[2] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x796);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", "0x778/ 0x783/ 0x796", \
+		u1Tmp[0], u1Tmp[1], u1Tmp[2]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x880);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x880", \
+		u4Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x40);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x40", \
+		u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x550);
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x522);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x", "0x550(bcn ctrl)/0x522", \
+		u4Tmp[0], u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x484);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x484(rate adaptive)", \
+		u4Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xc50);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)", \
+		u4Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xda0);
+	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xda4);
+	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xda8);
+	u4Tmp[3] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xdac);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x", "0xda0/0xda4/0xda8/0xdac(FA cnt)", \
+		u4Tmp[0], u4Tmp[1], u4Tmp[2], u4Tmp[3]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c0);
+	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c4);
+	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c8);
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x6cc);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x", "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)", \
+		u4Tmp[0], u4Tmp[1], u4Tmp[2], u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "0x770 (hp rx[31:16]/tx[15:0])", \
+		pCoexSta->highPriorityRx, pCoexSta->highPriorityTx);
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "0x774(lp rx[31:16]/tx[15:0])", \
+		pCoexSta->lowPriorityRx, pCoexSta->lowPriorityTx);
+	CL_PRINTF(cliBuf);
+
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+VOID
+EXhalbtc8723a1ant_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_IPS_ENTER == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], IPS ENTER notify\n"));
+		halbtc8723a1ant_CoexAllOff(pBtCoexist);
+	}
+	else if(BTC_IPS_LEAVE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], IPS LEAVE notify\n"));
+		//halbtc8723a1ant_InitCoexDm(pBtCoexist);
+	}
+}
+
+VOID
+EXhalbtc8723a1ant_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_LPS_ENABLE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], LPS ENABLE notify\n"));
+	}
+	else if(BTC_LPS_DISABLE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], LPS DISABLE notify\n"));
+		halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+	}
+}
+
+VOID
+EXhalbtc8723a1ant_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	BOOLEAN		bWifiConnected=FALSE;
+	
+	halbtc8723a1ant_NotifyFwScan(pBtCoexist, type);
+
+	if(pBtCoexist->btInfo.bBtDisabled)
+	{
+		halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 9); 
+	}
+	else
+	{
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+		if(BTC_SCAN_START == type)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCAN START notify\n"));
+			if(!bWifiConnected)	// non-connected scan
+			{
+				//set 0x550[3]=1 before PsTdma
+				halbtc8723a1ant_Reg0x550Bit3(pBtCoexist, TRUE);
+			}
+
+			halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+		}
+		else if(BTC_SCAN_FINISH == type)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCAN FINISH notify\n"));
+			if(!bWifiConnected)	// non-connected scan
+			{
+				halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0); 
+			}
+			else
+			{
+				halbtc8723a1ant_CoexForWifiConnect(pBtCoexist);
+			}
+		}
+	}
+}
+
+VOID
+EXhalbtc8723a1ant_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	BOOLEAN		bWifiConnected=FALSE;
+		
+	if(pBtCoexist->btInfo.bBtDisabled)
+	{
+		halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 9); 
+	}
+	else
+	{
+		if(BTC_ASSOCIATE_START == type)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], CONNECT START notify\n"));
+			//set 0x550[3]=1 before PsTdma
+			halbtc8723a1ant_Reg0x550Bit3(pBtCoexist, TRUE);
+			halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);	// extend wifi slot	
+		}
+		else if(BTC_ASSOCIATE_FINISH == type)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], CONNECT FINISH notify\n"));
+			pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+			if(!bWifiConnected)	// non-connected scan
+			{
+				halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+			}
+			else
+			{
+				halbtc8723a1ant_CoexForWifiConnect(pBtCoexist);
+			}
+		}
+	}
+}
+
+VOID
+EXhalbtc8723a1ant_MediaStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{
+	if(BTC_MEDIA_CONNECT == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], MEDIA connect notify\n"));
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], MEDIA disconnect notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8723a1ant_SpecialPacketNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{
+	if(type == BTC_PACKET_DHCP)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], DHCP Packet notify\n"));
+		if(pBtCoexist->btInfo.bBtDisabled)
+		{
+			halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 9);	
+		}
+		else
+		{
+			halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 18);
+		}		
+	}
+}
+
+VOID
+EXhalbtc8723a1ant_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	)
+{
+	u1Byte			btInfo=0;
+	u1Byte			i, rspSource=0;
+	BOOLEAN			bBtHsOn=FALSE, bBtBusy=FALSE, bForceLps=FALSE;
+
+	pCoexSta->bC2hBtInfoReqSent = FALSE;
+	
+	rspSource = BT_INFO_SRC_8723A_1ANT_BT_RSP;
+	pCoexSta->btInfoC2hCnt[rspSource]++;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Bt info[%d], length=%d, hex data=[", rspSource, length));
+	for(i=0; i<length; i++)
+	{
+		pCoexSta->btInfoC2h[rspSource][i] = tmpBuf[i];
+		if(i == 0)
+			btInfo = tmpBuf[i];
+		if(i == length-1)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("0x%02x]\n", tmpBuf[i]));
+		}
+		else
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("0x%02x, ", tmpBuf[i]));
+		}
+	}
+
+	if(BT_INFO_SRC_8723A_1ANT_WIFI_FW != rspSource)
+	{
+		pCoexSta->btRetryCnt =
+			pCoexSta->btInfoC2h[rspSource][1];
+
+		pCoexSta->btRssi =
+			pCoexSta->btInfoC2h[rspSource][2]*2+10;
+
+		pCoexSta->btInfoExt = 
+			pCoexSta->btInfoC2h[rspSource][3];
+	}
+		
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+	// check BIT2 first ==> check if bt is under inquiry or page scan
+	if(btInfo & BT_INFO_8723A_1ANT_B_INQ_PAGE)
+	{
+		pCoexSta->bC2hBtInquiryPage = TRUE;
+	}
+	else
+	{
+		pCoexSta->bC2hBtInquiryPage = FALSE;
+	}
+	btInfo &= ~BIT2;
+	if(!(btInfo & BIT0))
+	{
+		pCoexDm->btStatus = BT_STATE_8723A_1ANT_NO_CONNECTION;
+		bForceLps = FALSE;
+	}
+	else
+	{
+		bForceLps = TRUE;
+		if(btInfo == 0x1)
+		{
+			pCoexDm->btStatus = BT_STATE_8723A_1ANT_CONNECT_IDLE;
+		}
+		else if(btInfo == 0x9)
+		{
+			pCoexDm->btStatus = BT_STATE_8723A_1ANT_ACL_ONLY_BUSY;
+			bBtBusy = TRUE;
+		}
+		else if(btInfo == 0x13)
+		{
+			pCoexDm->btStatus = BT_STATE_8723A_1ANT_SCO_ONLY_BUSY;
+			bBtBusy = TRUE;
+		}
+		else if(btInfo == 0x1b)
+		{
+			pCoexDm->btStatus = BT_STATE_8723A_1ANT_ACL_SCO_BUSY;
+			bBtBusy = TRUE;
+		}
+		else if(btInfo == 0x29)
+		{
+			pCoexDm->btStatus = BT_STATE_8723A_1ANT_HID_BUSY;
+			bBtBusy = TRUE;
+		}
+		else if(btInfo == 0x3b)
+		{
+			pCoexDm->btStatus = BT_STATE_8723A_1ANT_HID_SCO_BUSY;
+			bBtBusy = TRUE;
+		}
+	}
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bBtBusy);
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_LIMITED_DIG, &bBtBusy);
+	if(bForceLps)
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_ENTER_LPS, NULL);
+	else
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_NORMAL_LPS, NULL);
+
+	if( (BT_STATE_8723A_1ANT_NO_CONNECTION == pCoexDm->btStatus) ||
+		(BT_STATE_8723A_1ANT_CONNECT_IDLE == pCoexDm->btStatus) )
+	{
+		if(pCoexSta->bC2hBtInquiryPage)
+			pCoexDm->btStatus = BT_STATE_8723A_1ANT_INQ_OR_PAG;
+	}
+}
+
+VOID
+EXhalbtc8723a1ant_HaltNotify(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	halbtc8723a1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 0);
+	
+	halbtc8723a1ant_LowPenaltyRa(pBtCoexist, FORCE_EXEC, FALSE);
+	halbtc8723a1ant_RfShrink(pBtCoexist, FORCE_EXEC, FALSE);
+
+	halbtc8723a1ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
+	EXhalbtc8723a1ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
+}
+
+VOID
+EXhalbtc8723a1ant_Periodical(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	BOOLEAN		bScan=FALSE, bLink=FALSE, bRoam=FALSE, bWifiConnected=FALSE;
+	
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], 1Ant Periodical!!\n"));
+	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+
+	// work around for c2h hang
+	wa_halbtc8723a1ant_MonitorC2h(pBtCoexist);	
+
+	halbtc8723a1ant_QueryBtInfo(pBtCoexist);
+	halbtc8723a1ant_MonitorBtCtr(pBtCoexist);
+	halbtc8723a1ant_MonitorBtEnableDisable(pBtCoexist);
+
+	
+	if(bScan)
+		return;
+	if(bLink)
+		return;
+
+	if(bWifiConnected)
+	{
+		if(pBtCoexist->btInfo.bBtDisabled)
+		{
+			halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 9);
+			
+			halbtc8723a1ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a1ant_RfShrink(pBtCoexist, NORMAL_EXEC, FALSE);
+		}
+		else
+		{
+			halbtc8723a1ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a1ant_RfShrink(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a1ant_CoexForWifiConnect(pBtCoexist);
+		}
+	}
+	else
+	{
+		halbtc8723a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+
+		halbtc8723a1ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a1ant_RfShrink(pBtCoexist, NORMAL_EXEC, FALSE);
+	}
+}
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a1Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a1Ant.h
new file mode 100644
index 000000000..6d4e1b450
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a1Ant.h
@@ -0,0 +1,171 @@
+//===========================================
+// The following is for 8723A 1Ant BT Co-exist definition
+//===========================================
+#define	BT_INFO_8723A_1ANT_B_FTP						BIT7
+#define	BT_INFO_8723A_1ANT_B_A2DP					BIT6
+#define	BT_INFO_8723A_1ANT_B_HID						BIT5
+#define	BT_INFO_8723A_1ANT_B_SCO_BUSY				BIT4
+#define	BT_INFO_8723A_1ANT_B_ACL_BUSY				BIT3
+#define	BT_INFO_8723A_1ANT_B_INQ_PAGE				BIT2
+#define	BT_INFO_8723A_1ANT_B_SCO_ESCO				BIT1
+#define	BT_INFO_8723A_1ANT_B_CONNECTION				BIT0
+
+typedef enum _BT_STATE_8723A_1ANT{
+	BT_STATE_8723A_1ANT_DISABLED				= 0,
+	BT_STATE_8723A_1ANT_NO_CONNECTION		= 1,
+	BT_STATE_8723A_1ANT_CONNECT_IDLE		= 2,
+	BT_STATE_8723A_1ANT_INQ_OR_PAG			= 3,
+	BT_STATE_8723A_1ANT_ACL_ONLY_BUSY		= 4,
+	BT_STATE_8723A_1ANT_SCO_ONLY_BUSY		= 5,
+	BT_STATE_8723A_1ANT_ACL_SCO_BUSY			= 6,
+	BT_STATE_8723A_1ANT_HID_BUSY				= 7,
+	BT_STATE_8723A_1ANT_HID_SCO_BUSY			= 8,
+	BT_STATE_8723A_1ANT_MAX
+}BT_STATE_8723A_1ANT, *PBT_STATE_8723A_1ANT;
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8723A_1ANT		2
+
+typedef enum _BT_INFO_SRC_8723A_1ANT{
+	BT_INFO_SRC_8723A_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8723A_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8723A_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8723A_1ANT_MAX
+}BT_INFO_SRC_8723A_1ANT,*PBT_INFO_SRC_8723A_1ANT;
+
+typedef enum _BT_8723A_1ANT_BT_STATUS{
+	BT_8723A_1ANT_BT_STATUS_IDLE				= 0x0,
+	BT_8723A_1ANT_BT_STATUS_CONNECTED_IDLE	= 0x1,
+	BT_8723A_1ANT_BT_STATUS_NON_IDLE			= 0x2,
+	BT_8723A_1ANT_BT_STATUS_MAX
+}BT_8723A_1ANT_BT_STATUS,*PBT_8723A_1ANT_BT_STATUS;
+
+typedef enum _BT_8723A_1ANT_COEX_ALGO{
+	BT_8723A_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8723A_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8723A_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8723A_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8723A_1ANT_COEX_ALGO_PANEDR			= 0x4,
+	BT_8723A_1ANT_COEX_ALGO_PANHS			= 0x5,
+	BT_8723A_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x6,
+	BT_8723A_1ANT_COEX_ALGO_PANEDR_HID		= 0x7,
+	BT_8723A_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x8,
+	BT_8723A_1ANT_COEX_ALGO_HID_A2DP			= 0x9,
+	BT_8723A_1ANT_COEX_ALGO_MAX
+}BT_8723A_1ANT_COEX_ALGO,*PBT_8723A_1ANT_COEX_ALGO;
+
+typedef struct _COEX_DM_8723A_1ANT{
+	// fw mechanism
+	BOOLEAN		bCurIgnoreWlanAct;
+	BOOLEAN		bPreIgnoreWlanAct;
+	u1Byte		prePsTdma;
+	u1Byte		curPsTdma;
+	u1Byte		psTdmaPara[5];
+	u1Byte		psTdmaDuAdjType;
+	u4Byte		psTdmaMonitorCnt;
+	u4Byte		psTdmaGlobalCnt;
+	BOOLEAN		bResetTdmaAdjust;
+	BOOLEAN		bPrePsTdmaOn;
+	BOOLEAN		bCurPsTdmaOn;
+
+	// sw mechanism
+	BOOLEAN		bPreRfRxLpfShrink;
+	BOOLEAN		bCurRfRxLpfShrink;
+	u4Byte		btRf0x1eBackup;
+	BOOLEAN 	bPreLowPenaltyRa;
+	BOOLEAN		bCurLowPenaltyRa;
+	u4Byte		preVal0x6c0;
+	u4Byte		curVal0x6c0;
+	u4Byte		preVal0x6c8;
+	u4Byte		curVal0x6c8;
+	u1Byte		preVal0x6cc;
+	u1Byte		curVal0x6cc;
+	BOOLEAN		bLimitedDig;
+
+	// algorithm related
+	u1Byte		preAlgorithm;
+	u1Byte		curAlgorithm;
+	u1Byte		btStatus;
+	u1Byte		wifiChnlInfo[3];
+} COEX_DM_8723A_1ANT, *PCOEX_DM_8723A_1ANT;
+
+typedef struct _COEX_STA_8723A_1ANT{
+	u4Byte					highPriorityTx;
+	u4Byte					highPriorityRx;
+	u4Byte					lowPriorityTx;
+	u4Byte					lowPriorityRx;
+	u1Byte					btRssi;
+	u1Byte					preBtRssiState;
+	u1Byte					preBtRssiState1;
+	u1Byte					preWifiRssiState[4];
+	BOOLEAN					bC2hBtInfoReqSent;
+	u1Byte					btInfoC2h[BT_INFO_SRC_8723A_1ANT_MAX][10];
+	u4Byte					btInfoC2hCnt[BT_INFO_SRC_8723A_1ANT_MAX];
+	BOOLEAN					bC2hBtInquiryPage;
+	u1Byte					btRetryCnt;
+	u1Byte					btInfoExt;
+	//BOOLEAN					bHoldForStackOperation;
+	//u1Byte					bHoldPeriodCnt;
+	// this is for c2h hang work-around
+	u4Byte					c2hHangDetectCnt;
+}COEX_STA_8723A_1ANT, *PCOEX_STA_8723A_1ANT;
+
+//===========================================
+// The following is interface which will notify coex module.
+//===========================================
+VOID
+EXhalbtc8723a1ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8723a1ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8723a1ant_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8723a1ant_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8723a1ant_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8723a1ant_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8723a1ant_MediaStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8723a1ant_SpecialPacketNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8723a1ant_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	);
+VOID
+EXhalbtc8723a1ant_HaltNotify(
+	IN	PBTC_COEXIST			pBtCoexist
+	);
+VOID
+EXhalbtc8723a1ant_Periodical(
+	IN	PBTC_COEXIST			pBtCoexist
+	);
+VOID
+EXhalbtc8723a1ant_DisplayCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a2Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a2Ant.c
new file mode 100644
index 000000000..1becd5c01
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a2Ant.c
@@ -0,0 +1,3746 @@
+//============================================================
+// Description:
+//
+// This file is for RTL8723A Co-exist mechanism
+//
+// History
+// 2012/08/22 Cosa first check in.
+// 2012/11/14 Cosa Revise for 8723A 2Ant out sourcing.
+//
+//============================================================
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+
+#if WPP_SOFTWARE_TRACE
+#include "HalBtc8723a2Ant.tmh"
+#endif
+
+#if(BT_30_SUPPORT == 1)
+//============================================================
+// Global variables, these are static variables
+//============================================================
+static COEX_DM_8723A_2ANT	GLCoexDm8723a2Ant;
+static PCOEX_DM_8723A_2ANT 	pCoexDm=&GLCoexDm8723a2Ant;
+static COEX_STA_8723A_2ANT	GLCoexSta8723a2Ant;
+static PCOEX_STA_8723A_2ANT	pCoexSta=&GLCoexSta8723a2Ant;
+
+const char *const GLBtInfoSrc8723a2Ant[]={
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+//============================================================
+// local function proto type if needed
+//============================================================
+//============================================================
+// local function start with halbtc8723a2ant_
+//============================================================
+BOOLEAN
+halbtc8723a2ant_IsWifiIdle(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bWifiConnected=FALSE, bScan=FALSE, bLink=FALSE, bRoam=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+
+	if(bWifiConnected)
+		return FALSE;
+	if(bScan)
+		return FALSE;
+	if(bLink)
+		return FALSE;
+	if(bRoam)
+		return FALSE;
+
+	return TRUE;
+}
+
+BOOLEAN
+halbtc8723a2ant_IsWifiConnectedIdle(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bWifiConnected=FALSE, bScan=FALSE, bLink=FALSE, bRoam=FALSE, bWifiBusy=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+
+	if(bScan)
+		return FALSE;
+	if(bLink)
+		return FALSE;
+	if(bRoam)
+		return FALSE;
+	if(bWifiConnected && !bWifiBusy)
+		return TRUE;
+	else 
+		return FALSE;
+}
+
+u1Byte
+halbtc8723a2ant_BtRssiState(
+	u1Byte			levelNum,
+	u1Byte			rssiThresh,
+	u1Byte			rssiThresh1
+	)
+{
+	s4Byte			btRssi=0;
+	u1Byte			btRssiState=pCoexSta->preBtRssiState;
+
+	btRssi = pCoexSta->btRssi;
+
+	if(levelNum == 2)
+	{			
+		if( (pCoexSta->preBtRssiState == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preBtRssiState == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(btRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8723A_2ANT))
+			{
+				btRssiState = BTC_RSSI_STATE_HIGH;
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_LOW;
+			}
+		}
+		else
+		{
+			if(btRssi < rssiThresh)
+			{
+				btRssiState = BTC_RSSI_STATE_LOW;
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_HIGH;
+			}
+		}
+	}
+	else if(levelNum == 3)
+	{
+		if(rssiThresh > rssiThresh1)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT Rssi thresh error!!\n"));
+			return pCoexSta->preBtRssiState;
+		}
+		
+		if( (pCoexSta->preBtRssiState == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preBtRssiState == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(btRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8723A_2ANT))
+			{
+				btRssiState = BTC_RSSI_STATE_MEDIUM;
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_LOW;
+			}
+		}
+		else if( (pCoexSta->preBtRssiState == BTC_RSSI_STATE_MEDIUM) ||
+			(pCoexSta->preBtRssiState == BTC_RSSI_STATE_STAY_MEDIUM))
+		{
+			if(btRssi >= (rssiThresh1+BTC_RSSI_COEX_THRESH_TOL_8723A_2ANT))
+			{
+				btRssiState = BTC_RSSI_STATE_HIGH;
+			}
+			else if(btRssi < rssiThresh)
+			{
+				btRssiState = BTC_RSSI_STATE_LOW;
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_MEDIUM;
+			}
+		}
+		else
+		{
+			if(btRssi < rssiThresh1)
+			{
+				btRssiState = BTC_RSSI_STATE_MEDIUM;
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_HIGH;
+			}
+		}
+	}
+		
+	pCoexSta->preBtRssiState = btRssiState;
+
+	return btRssiState;
+}
+
+u1Byte
+halbtc8723a2ant_WifiRssiState(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			index,
+	IN	u1Byte			levelNum,
+	IN	u1Byte			rssiThresh,
+	IN	u1Byte			rssiThresh1
+	)
+{
+	s4Byte			wifiRssi=0;
+	u1Byte			wifiRssiState=pCoexSta->preWifiRssiState[index];
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
+	
+	if(levelNum == 2)
+	{
+		if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(wifiRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8723A_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_HIGH;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_LOW;
+			}
+		}
+		else
+		{
+			if(wifiRssi < rssiThresh)
+			{
+				wifiRssiState = BTC_RSSI_STATE_LOW;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_HIGH;
+			}
+		}
+	}
+	else if(levelNum == 3)
+	{
+		if(rssiThresh > rssiThresh1)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], wifi RSSI thresh error!!\n"));
+			return pCoexSta->preWifiRssiState[index];
+		}
+		
+		if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(wifiRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8723A_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_MEDIUM;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_LOW;
+			}
+		}
+		else if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_MEDIUM) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_MEDIUM))
+		{
+			if(wifiRssi >= (rssiThresh1+BTC_RSSI_COEX_THRESH_TOL_8723A_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_HIGH;
+			}
+			else if(wifiRssi < rssiThresh)
+			{
+				wifiRssiState = BTC_RSSI_STATE_LOW;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_MEDIUM;
+			}
+		}
+		else
+		{
+			if(wifiRssi < rssiThresh1)
+			{
+				wifiRssiState = BTC_RSSI_STATE_MEDIUM;
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_HIGH;
+			}
+		}
+	}
+		
+	pCoexSta->preWifiRssiState[index] = wifiRssiState;
+
+	return wifiRssiState;
+}
+
+VOID
+halbtc8723a2ant_IndicateWifiChnlBwInfo(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{
+	u1Byte			H2C_Parameter[3] ={0};
+	u4Byte			wifiBw;
+	u1Byte			wifiCentralChnl;
+	
+	// only 2.4G we need to inform bt the chnl mask
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL, &wifiCentralChnl);
+	if( (BTC_MEDIA_CONNECT == type) &&
+		(wifiCentralChnl <= 14) )
+	{
+		H2C_Parameter[0] = 0x1;
+		H2C_Parameter[1] = wifiCentralChnl;
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+			H2C_Parameter[2] = 0x30;
+		else
+			H2C_Parameter[2] = 0x20;
+	}
+		
+	pCoexDm->wifiChnlInfo[0] = H2C_Parameter[0];
+	pCoexDm->wifiChnlInfo[1] = H2C_Parameter[1];
+	pCoexDm->wifiChnlInfo[2] = H2C_Parameter[2];
+	
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], FW write 0x19=0x%x\n", 
+		H2C_Parameter[0]<<16|H2C_Parameter[1]<<8|H2C_Parameter[2]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x19, 3, H2C_Parameter);
+}
+
+VOID
+halbtc8723a2ant_QueryBtInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+
+	pCoexSta->bC2hBtInfoReqSent = TRUE;
+
+	H2C_Parameter[0] |= BIT0;	// trigger
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Query Bt Info, FW write 0x38=0x%x\n", 
+		H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x38, 1, H2C_Parameter);
+}
+u1Byte
+halbtc8723a2ant_ActionAlgorithm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	BOOLEAN				bBtHsOn=FALSE, bBtBusy=FALSE, bLimitedDig=FALSE;
+	u1Byte				algorithm=BT_8723A_2ANT_COEX_ALGO_UNDEFINED;
+	u1Byte				numOfDiffProfile=0;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+
+	//======================
+	// here we get BT status first
+	//======================
+	pCoexDm->btStatus = BT_8723A_2ANT_BT_STATUS_IDLE;
+	
+	if((pStackInfo->bScoExist) ||(bBtHsOn) ||(pStackInfo->bHidExist))
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO or HID or HS exists, set BT non-idle !!!\n"));
+		pCoexDm->btStatus = BT_8723A_2ANT_BT_STATUS_NON_IDLE;
+	}
+	else
+	{
+		// A2dp profile
+		if( (pBtCoexist->stackInfo.numOfLink == 1) &&
+			(pStackInfo->bA2dpExist) )
+		{		
+			if( (pCoexSta->lowPriorityTx+	pCoexSta->lowPriorityRx) < 100)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], A2DP, low priority tx+rx < 100, set BT connected-idle!!!\n"));
+				pCoexDm->btStatus = BT_8723A_2ANT_BT_STATUS_CONNECTED_IDLE;
+			}
+			else
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], A2DP, low priority tx+rx >= 100, set BT non-idle!!!\n"));
+				pCoexDm->btStatus = BT_8723A_2ANT_BT_STATUS_NON_IDLE;
+			}
+		}
+		// Pan profile
+		if( (pBtCoexist->stackInfo.numOfLink == 1) &&
+			(pStackInfo->bPanExist) )
+		{		
+			if((pCoexSta->lowPriorityTx+	pCoexSta->lowPriorityRx) < 600)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN, low priority tx+rx < 600, set BT connected-idle!!!\n"));
+				pCoexDm->btStatus = BT_8723A_2ANT_BT_STATUS_CONNECTED_IDLE;
+			}
+			else
+			{
+				if(pCoexSta->lowPriorityTx)
+				{
+					if((pCoexSta->lowPriorityRx /pCoexSta->lowPriorityTx)>9 )
+					{
+						RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN, low priority rx/tx > 9, set BT connected-idle!!!\n"));
+						pCoexDm->btStatus = BT_8723A_2ANT_BT_STATUS_CONNECTED_IDLE;
+					}
+				}
+			}
+			if(BT_8723A_2ANT_BT_STATUS_CONNECTED_IDLE != pCoexDm->btStatus)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN, set BT non-idle!!!\n"));
+				pCoexDm->btStatus = BT_8723A_2ANT_BT_STATUS_NON_IDLE;
+			}
+		}
+		// Pan+A2dp profile
+		if( (pBtCoexist->stackInfo.numOfLink == 2) &&
+			(pStackInfo->bA2dpExist) &&
+			(pStackInfo->bPanExist) )
+		{
+			if((pCoexSta->lowPriorityTx+	pCoexSta->lowPriorityRx) < 600)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN+A2DP, low priority tx+rx < 600, set BT connected-idle!!!\n"));
+				pCoexDm->btStatus = BT_8723A_2ANT_BT_STATUS_CONNECTED_IDLE;
+			}
+			else
+			{
+				if(pCoexSta->lowPriorityTx)
+				{
+					if((pCoexSta->lowPriorityRx /pCoexSta->lowPriorityTx)>9 )
+					{
+						RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN+A2DP, low priority rx/tx > 9, set BT connected-idle!!!\n"));
+						pCoexDm->btStatus = BT_8723A_2ANT_BT_STATUS_CONNECTED_IDLE;
+					}
+				}
+			}
+			if(BT_8723A_2ANT_BT_STATUS_CONNECTED_IDLE != pCoexDm->btStatus)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN+A2DP, set BT non-idle!!!\n"));
+				pCoexDm->btStatus = BT_8723A_2ANT_BT_STATUS_NON_IDLE;
+			}
+		}
+	}
+	if(BT_8723A_2ANT_BT_STATUS_IDLE != pCoexDm->btStatus)
+	{
+		bBtBusy = TRUE;
+		bLimitedDig = TRUE;
+	}
+	else
+	{
+		bBtBusy = FALSE;
+		bLimitedDig = FALSE;
+	}
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bBtBusy);
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_LIMITED_DIG, &bLimitedDig);
+	//======================
+
+	if(!pStackInfo->bBtLinkExist)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], No profile exists!!!\n"));
+		return algorithm;
+	}
+
+	if(pStackInfo->bScoExist)
+		numOfDiffProfile++;
+	if(pStackInfo->bHidExist)
+		numOfDiffProfile++;
+	if(pStackInfo->bPanExist)
+		numOfDiffProfile++;
+	if(pStackInfo->bA2dpExist)
+		numOfDiffProfile++;
+	
+	if(numOfDiffProfile == 1)
+	{
+		if(pStackInfo->bScoExist)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO only\n"));
+			algorithm = BT_8723A_2ANT_COEX_ALGO_SCO;
+		}
+		else
+		{
+			if(pStackInfo->bHidExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID only\n"));
+				algorithm = BT_8723A_2ANT_COEX_ALGO_HID;
+			}
+			else if(pStackInfo->bA2dpExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], A2DP only\n"));
+				algorithm = BT_8723A_2ANT_COEX_ALGO_A2DP;
+			}
+			else if(pStackInfo->bPanExist)
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN(HS) only\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_PANHS;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PAN(EDR) only\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	}
+	else if(numOfDiffProfile == 2)
+	{
+		if(pStackInfo->bScoExist)
+		{
+			if(pStackInfo->bHidExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + HID\n"));
+				algorithm = BT_8723A_2ANT_COEX_ALGO_HID;
+			}
+			else if(pStackInfo->bA2dpExist)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + A2DP ==> SCO\n"));
+				algorithm = BT_8723A_2ANT_COEX_ALGO_SCO;
+			}
+			else if(pStackInfo->bPanExist)
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + PAN(HS)\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_SCO;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + PAN(EDR)\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+		else
+		{
+			if( pStackInfo->bHidExist &&
+				pStackInfo->bA2dpExist )
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + A2DP\n"));
+				algorithm = BT_8723A_2ANT_COEX_ALGO_HID_A2DP;
+			}
+			else if( pStackInfo->bHidExist &&
+				pStackInfo->bPanExist )
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + PAN(HS)\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_HID_A2DP;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + PAN(EDR)\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+			else if( pStackInfo->bPanExist &&
+				pStackInfo->bA2dpExist )
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], A2DP + PAN(HS)\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_A2DP;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], A2DP + PAN(EDR)\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	}
+	else if(numOfDiffProfile == 3)
+	{
+		if(pStackInfo->bScoExist)
+		{
+			if( pStackInfo->bHidExist &&
+				pStackInfo->bA2dpExist )
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + HID + A2DP ==> HID\n"));
+				algorithm = BT_8723A_2ANT_COEX_ALGO_HID;
+			}
+			else if( pStackInfo->bHidExist &&
+				pStackInfo->bPanExist )
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + HID + PAN(HS)\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_HID_A2DP;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + HID + PAN(EDR)\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+			else if( pStackInfo->bPanExist &&
+				pStackInfo->bA2dpExist )
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + A2DP + PAN(HS)\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_SCO;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+		else
+		{
+			if( pStackInfo->bHidExist &&
+				pStackInfo->bPanExist &&
+				pStackInfo->bA2dpExist )
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + A2DP + PAN(HS)\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_HID_A2DP;
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], HID + A2DP + PAN(EDR)\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	}
+	else if(numOfDiffProfile >= 3)
+	{
+		if(pStackInfo->bScoExist)
+		{
+			if( pStackInfo->bHidExist &&
+				pStackInfo->bPanExist &&
+				pStackInfo->bA2dpExist )
+			{
+				if(bBtHsOn)
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n"));
+
+				}
+				else
+				{
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n"));
+					algorithm = BT_8723A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+BOOLEAN
+halbtc8723a2ant_NeedToDecBtPwr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bRet=FALSE;
+	BOOLEAN		bBtHsOn=FALSE, bWifiConnected=FALSE;
+	s4Byte		btHsRssi=0;
+	u1Byte		btRssiState=BTC_RSSI_STATE_HIGH;
+
+	btRssiState = halbtc8723a2ant_BtRssiState(2, 42, 0);
+
+	if(!pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn))
+		return FALSE;
+	if(!pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected))
+		return FALSE;
+	if(!pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi))
+		return FALSE;
+	if(BTC_RSSI_LOW(btRssiState))
+		return FALSE;
+
+	if(bWifiConnected)
+	{
+		if(bBtHsOn)
+		{
+			if(btHsRssi > 37)
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Need to decrease bt power for HS mode!!\n"));
+				bRet = TRUE;
+			}
+		}
+		else
+		{
+			RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Need to decrease bt power for Wifi is connected!!\n"));
+			bRet = TRUE;
+		}
+	}
+	
+	return bRet;
+}
+
+VOID
+halbtc8723a2ant_SetFwDacSwingLevel(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			dacSwingLvl
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+
+	// There are several type of dacswing
+	// 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6
+	H2C_Parameter[0] = dacSwingLvl;
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Set Dac Swing Level=0x%x\n", dacSwingLvl));
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], FW write 0x29=0x%x\n", H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x29, 1, H2C_Parameter);
+}
+
+VOID
+halbtc8723a2ant_SetFwDecBtPwr(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bDecBtPwr
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+	
+	H2C_Parameter[0] = 0;
+
+	if(bDecBtPwr)
+	{
+		H2C_Parameter[0] |= BIT1;
+	}
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], decrease Bt Power : %s, FW write 0x21=0x%x\n", 
+		(bDecBtPwr? "Yes!!":"No!!"), H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x21, 1, H2C_Parameter);	
+}
+
+VOID
+halbtc8723a2ant_DecBtPwr(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bDecBtPwr
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s Dec BT power = %s\n",  
+		(bForceExec? "force to":""), ((bDecBtPwr)? "ON":"OFF")));
+	pCoexDm->bCurDecBtPwr = bDecBtPwr;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreDecBtPwr == pCoexDm->bCurDecBtPwr) 
+			return;
+	}
+	halbtc8723a2ant_SetFwDecBtPwr(pBtCoexist, pCoexDm->bCurDecBtPwr);
+
+	pCoexDm->bPreDecBtPwr = pCoexDm->bCurDecBtPwr;
+}
+
+VOID
+halbtc8723a2ant_FwDacSwingLvl(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	u1Byte			fwDacSwingLvl
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s set FW Dac Swing level = %d\n",  
+		(bForceExec? "force to":""), fwDacSwingLvl));
+	pCoexDm->curFwDacSwingLvl = fwDacSwingLvl;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->preFwDacSwingLvl == pCoexDm->curFwDacSwingLvl) 
+			return;
+	}
+
+	halbtc8723a2ant_SetFwDacSwingLevel(pBtCoexist, pCoexDm->curFwDacSwingLvl);
+
+	pCoexDm->preFwDacSwingLvl = pCoexDm->curFwDacSwingLvl;
+}
+
+VOID
+halbtc8723a2ant_SetSwRfRxLpfCorner(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bRxRfShrinkOn
+	)
+{
+	if(bRxRfShrinkOn)
+	{
+		//Shrink RF Rx LPF corner
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Shrink RF Rx LPF corner!!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff, 0xf0ff7);
+	}
+	else
+	{
+		//Resume RF Rx LPF corner
+		// After initialized, we can use pCoexDm->btRf0x1eBackup
+		if(pBtCoexist->bInitilized)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Resume RF Rx LPF corner!!\n"));
+			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff, pCoexDm->btRf0x1eBackup);
+		}
+	}
+}
+
+VOID
+halbtc8723a2ant_RfShrink(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bRxRfShrinkOn
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn Rx RF Shrink = %s\n",  
+		(bForceExec? "force to":""), ((bRxRfShrinkOn)? "ON":"OFF")));
+	pCoexDm->bCurRfRxLpfShrink = bRxRfShrinkOn;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreRfRxLpfShrink == pCoexDm->bCurRfRxLpfShrink) 
+			return;
+	}
+	halbtc8723a2ant_SetSwRfRxLpfCorner(pBtCoexist, pCoexDm->bCurRfRxLpfShrink);
+
+	pCoexDm->bPreRfRxLpfShrink = pCoexDm->bCurRfRxLpfShrink;
+}
+
+VOID
+halbtc8723a2ant_SetSwPenaltyTxRateAdaptive(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bLowPenaltyRa
+	)
+{
+	u1Byte	tmpU1;
+
+	tmpU1 = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x4fd);
+	tmpU1 |= BIT0;
+	if(bLowPenaltyRa)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Tx rate adaptive, set low penalty!!\n"));
+		tmpU1 &= ~BIT2;
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Tx rate adaptive, set normal!!\n"));
+		tmpU1 |= BIT2;
+	}
+
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x4fd, tmpU1);
+}
+
+VOID
+halbtc8723a2ant_LowPenaltyRa(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bLowPenaltyRa
+	)
+{
+	return;
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn LowPenaltyRA = %s\n",  
+		(bForceExec? "force to":""), ((bLowPenaltyRa)? "ON":"OFF")));
+	pCoexDm->bCurLowPenaltyRa = bLowPenaltyRa;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreLowPenaltyRa == pCoexDm->bCurLowPenaltyRa) 
+			return;
+	}
+	halbtc8723a2ant_SetSwPenaltyTxRateAdaptive(pBtCoexist, pCoexDm->bCurLowPenaltyRa);
+
+	pCoexDm->bPreLowPenaltyRa = pCoexDm->bCurLowPenaltyRa;
+}
+
+VOID
+halbtc8723a2ant_SetSwFullTimeDacSwing(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bSwDacSwingOn,
+	IN	u4Byte			swDacSwingLvl
+	)
+{
+	if(bSwDacSwingOn)
+	{
+		pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x880, 0xff000000, swDacSwingLvl);
+	}
+	else
+	{
+		pBtCoexist->fBtcSetBbReg(pBtCoexist, 0x880, 0xff000000, 0xc0);
+	}
+}
+
+
+VOID
+halbtc8723a2ant_DacSwing(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bDacSwingOn,
+	IN	u4Byte			dacSwingLvl
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn DacSwing=%s, dacSwingLvl=0x%x\n",  
+		(bForceExec? "force to":""), ((bDacSwingOn)? "ON":"OFF"), dacSwingLvl));
+	pCoexDm->bCurDacSwingOn = bDacSwingOn;
+	pCoexDm->curDacSwingLvl = dacSwingLvl;
+
+	if(!bForceExec)
+	{
+		if( (pCoexDm->bPreDacSwingOn == pCoexDm->bCurDacSwingOn) &&
+			(pCoexDm->preDacSwingLvl == pCoexDm->curDacSwingLvl) )
+			return;
+	}
+	delay_ms(30);
+	halbtc8723a2ant_SetSwFullTimeDacSwing(pBtCoexist, bDacSwingOn, dacSwingLvl);
+
+	pCoexDm->bPreDacSwingOn = pCoexDm->bCurDacSwingOn;
+	pCoexDm->preDacSwingLvl = pCoexDm->curDacSwingLvl;
+}
+
+VOID
+halbtc8723a2ant_SetAdcBackOff(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bAdcBackOff
+	)
+{
+	if(bAdcBackOff)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BB BackOff Level On!\n"));
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc04,0x3a07611);
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BB BackOff Level Off!\n"));		
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc04,0x3a05611);
+	}
+}
+
+VOID
+halbtc8723a2ant_AdcBackOff(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bAdcBackOff
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn AdcBackOff = %s\n",  
+		(bForceExec? "force to":""), ((bAdcBackOff)? "ON":"OFF")));
+	pCoexDm->bCurAdcBackOff = bAdcBackOff;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreAdcBackOff == pCoexDm->bCurAdcBackOff) 
+			return;
+	}
+	halbtc8723a2ant_SetAdcBackOff(pBtCoexist, pCoexDm->bCurAdcBackOff);
+
+	pCoexDm->bPreAdcBackOff = pCoexDm->bCurAdcBackOff;
+}
+
+VOID
+halbtc8723a2ant_SetAgcTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bAgcTableEn
+	)
+{
+	u1Byte		rssiAdjustVal=0;
+
+	if(bAgcTableEn)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Agc Table On!\n"));
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x4e1c0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x4d1d0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x4c1e0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x4b1f0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x4a200001);
+		
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0xdc000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0x90000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0x51000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0x12000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1a, 0xfffff, 0x00355);
+		
+		rssiAdjustVal = 6;
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Agc Table Off!\n"));
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x641c0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x631d0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x621e0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x611f0001);
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0xc78,0x60200001);
+
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0x32000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0x71000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0xb0000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x12, 0xfffff, 0xfc000);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1a, 0xfffff, 0x30355);
+	}
+
+	// set rssiAdjustVal for wifi module.
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON, &rssiAdjustVal);
+}
+
+
+VOID
+halbtc8723a2ant_AgcTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bAgcTableEn
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s %s Agc Table\n",  
+		(bForceExec? "force to":""), ((bAgcTableEn)? "Enable":"Disable")));
+	pCoexDm->bCurAgcTableEn = bAgcTableEn;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreAgcTableEn == pCoexDm->bCurAgcTableEn) 
+			return;
+	}
+	halbtc8723a2ant_SetAgcTable(pBtCoexist, bAgcTableEn);
+
+	pCoexDm->bPreAgcTableEn = pCoexDm->bCurAgcTableEn;
+}
+
+VOID
+halbtc8723a2ant_SetCoexTable(
+	IN	PBTC_COEXIST	pBtCoexist,
+	IN	u4Byte		val0x6c0,
+	IN	u4Byte		val0x6c8,
+	IN	u1Byte		val0x6cc
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set coex table, set 0x6c0=0x%x\n", val0x6c0));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c0, val0x6c0);
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set coex table, set 0x6c8=0x%x\n", val0x6c8));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c8, val0x6c8);
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set coex table, set 0x6cc=0x%x\n", val0x6cc));
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x6cc, val0x6cc);
+}
+
+VOID
+halbtc8723a2ant_CoexTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	u4Byte			val0x6c0,
+	IN	u4Byte			val0x6c8,
+	IN	u1Byte			val0x6cc
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s write Coex Table 0x6c0=0x%x, 0x6c8=0x%x, 0x6cc=0x%x\n", 
+		(bForceExec? "force to":""), val0x6c0, val0x6c8, val0x6cc));
+	pCoexDm->curVal0x6c0 = val0x6c0;
+	pCoexDm->curVal0x6c8 = val0x6c8;
+	pCoexDm->curVal0x6cc = val0x6cc;
+
+	if(!bForceExec)
+	{	
+		if( (pCoexDm->preVal0x6c0 == pCoexDm->curVal0x6c0) &&
+			(pCoexDm->preVal0x6c8 == pCoexDm->curVal0x6c8) &&
+			(pCoexDm->preVal0x6cc == pCoexDm->curVal0x6cc) )
+			return;
+	}
+	halbtc8723a2ant_SetCoexTable(pBtCoexist, val0x6c0, val0x6c8, val0x6cc);
+
+	pCoexDm->preVal0x6c0 = pCoexDm->curVal0x6c0;
+	pCoexDm->preVal0x6c8 = pCoexDm->curVal0x6c8;
+	pCoexDm->preVal0x6cc = pCoexDm->curVal0x6cc;
+}
+
+VOID
+halbtc8723a2ant_SetFwIgnoreWlanAct(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bEnable
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+		
+	if(bEnable)
+	{
+		H2C_Parameter[0] |= BIT0;		// function enable
+	}
+	
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], set FW for BT Ignore Wlan_Act, FW write 0x25=0x%x\n", 
+		H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x25, 1, H2C_Parameter);	
+}
+
+VOID
+halbtc8723a2ant_IgnoreWlanAct(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bEnable
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn Ignore WlanAct %s\n", 
+		(bForceExec? "force to":""), (bEnable? "ON":"OFF")));
+	pCoexDm->bCurIgnoreWlanAct = bEnable;
+
+	if(!bForceExec)
+	{
+		if(pCoexDm->bPreIgnoreWlanAct == pCoexDm->bCurIgnoreWlanAct)
+			return;
+	}
+	halbtc8723a2ant_SetFwIgnoreWlanAct(pBtCoexist, bEnable);
+
+	pCoexDm->bPreIgnoreWlanAct = pCoexDm->bCurIgnoreWlanAct;
+}
+
+VOID
+halbtc8723a2ant_SetFwPstdma(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			byte1,
+	IN	u1Byte			byte2,
+	IN	u1Byte			byte3,
+	IN	u1Byte			byte4,
+	IN	u1Byte			byte5
+	)
+{
+	u1Byte			H2C_Parameter[5] ={0};
+
+	H2C_Parameter[0] = byte1;	
+	H2C_Parameter[1] = byte2;	
+	H2C_Parameter[2] = byte3;
+	H2C_Parameter[3] = byte4;
+	H2C_Parameter[4] = byte5;
+
+	pCoexDm->psTdmaPara[0] = byte1;
+	pCoexDm->psTdmaPara[1] = byte2;
+	pCoexDm->psTdmaPara[2] = byte3;
+	pCoexDm->psTdmaPara[3] = byte4;
+	pCoexDm->psTdmaPara[4] = byte5;
+	
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], FW write 0x3a(5bytes)=0x%x%08x\n", 
+		H2C_Parameter[0], 
+		H2C_Parameter[1]<<24|H2C_Parameter[2]<<16|H2C_Parameter[3]<<8|H2C_Parameter[4]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x3a, 5, H2C_Parameter);
+}
+
+VOID
+halbtc8723a2ant_PsTdma(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bTurnOn,
+	IN	u1Byte			type
+	)
+{
+	u4Byte	btTxRxCnt=0;
+
+	btTxRxCnt = pCoexSta->highPriorityTx+pCoexSta->highPriorityRx+
+				pCoexSta->lowPriorityTx+pCoexSta->lowPriorityRx;
+
+	if(btTxRxCnt > 3000)
+	{		
+		pCoexDm->bCurPsTdmaOn = TRUE;
+		pCoexDm->curPsTdma = 8;
+		RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], turn ON PS TDMA, type=%d for BT tx/rx counters=%d(>3000)\n", 
+			pCoexDm->curPsTdma, btTxRxCnt));
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], %s turn %s PS TDMA, type=%d\n", 
+			(bForceExec? "force to":""), (bTurnOn? "ON":"OFF"), type));		
+		pCoexDm->bCurPsTdmaOn = bTurnOn;
+		pCoexDm->curPsTdma = type;
+	}
+
+	if(!bForceExec)
+	{
+		if( (pCoexDm->bPrePsTdmaOn == pCoexDm->bCurPsTdmaOn) &&
+			(pCoexDm->prePsTdma == pCoexDm->curPsTdma) )
+			return;
+	}	
+	if(pCoexDm->bCurPsTdmaOn)
+	{
+		switch(pCoexDm->curPsTdma)
+		{
+			case 1:
+			default:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x98);
+				break;
+			case 2:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0xe1, 0x98);
+				break;
+			case 3:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0xa, 0xe1, 0x98);
+				break;
+			case 4:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xa3, 0x5, 0x5, 0xe1, 0x80);
+				break;
+			case 5:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x98);
+				break;
+			case 6:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0x60, 0x98);
+				break;
+			case 7:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0xa, 0x60, 0x98);
+				break;
+			case 8: 
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xa3, 0x5, 0x5, 0x60, 0x80);
+				break;
+			case 9: 
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x98);
+				break;
+			case 10:	
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0xe1, 0x98);
+				break;
+			case 11:	
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0xa, 0xe1, 0x98);
+				break;
+			case 12:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0xe1, 0x98);
+				break;
+			case 13:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x98);
+				break;
+			case 14:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0x60, 0x98);
+				break;
+			case 15:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0xa, 0x60, 0x98);
+				break;
+			case 16:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0x60, 0x98);
+				break;
+			case 17:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xa3, 0x2f, 0x2f, 0x60, 0x80);
+				break;
+			case 18:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0xe1, 0x98);
+				break;			
+			case 19:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x25, 0x25, 0xe1, 0x98);
+				break;
+			case 20:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x25, 0x25, 0x60, 0x98);
+				break;
+		}
+	}
+	else
+	{
+		// disable PS tdma
+		switch(pCoexDm->curPsTdma)
+		{
+			case 0:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0x0, 0x0, 0x0, 0x8, 0x0);
+				break;
+			case 1:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0x0, 0x0, 0x0, 0x0, 0x0);
+				break;
+			default:
+				halbtc8723a2ant_SetFwPstdma(pBtCoexist, 0x0, 0x0, 0x0, 0x8, 0x0);
+				break;
+		}
+	}
+
+	// update pre state
+	pCoexDm->bPrePsTdmaOn = pCoexDm->bCurPsTdmaOn;
+	pCoexDm->prePsTdma = pCoexDm->curPsTdma;
+}
+
+
+VOID
+halbtc8723a2ant_CoexAllOff(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	// fw all off
+	halbtc8723a2ant_IgnoreWlanAct(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+	halbtc8723a2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0x20);
+	halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+	// sw all off
+	halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_RfShrink(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+
+	// hw all off
+	halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+}
+
+VOID
+halbtc8723a2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	// force to reset coex mechanism
+	halbtc8723a2ant_CoexTable(pBtCoexist, FORCE_EXEC, 0x55555555, 0xffff, 0x3);
+	halbtc8723a2ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 0);
+	halbtc8723a2ant_FwDacSwingLvl(pBtCoexist, FORCE_EXEC, 0x20);
+	halbtc8723a2ant_DecBtPwr(pBtCoexist, FORCE_EXEC, FALSE);
+	halbtc8723a2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, FALSE);
+
+	halbtc8723a2ant_AgcTable(pBtCoexist, FORCE_EXEC, FALSE);
+	halbtc8723a2ant_AdcBackOff(pBtCoexist, FORCE_EXEC, FALSE);
+	halbtc8723a2ant_LowPenaltyRa(pBtCoexist, FORCE_EXEC, FALSE);
+	halbtc8723a2ant_RfShrink(pBtCoexist, FORCE_EXEC, FALSE);
+	halbtc8723a2ant_DacSwing(pBtCoexist, FORCE_EXEC, FALSE, 0xc0);
+}
+
+VOID
+halbtc8723a2ant_BtInquiryPage(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN	bLowPwrDisable=TRUE;
+	
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+
+	halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+	halbtc8723a2ant_IgnoreWlanAct(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+}
+
+VOID
+halbtc8723a2ant_BtEnableAction(
+	IN 	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bWifiConnected=FALSE;
+	
+	// Here we need to resend some wifi info to BT
+	// because bt is reset and loss of the info.						
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+	if(bWifiConnected)
+	{
+		halbtc8723a2ant_IndicateWifiChnlBwInfo(pBtCoexist, BTC_MEDIA_CONNECT);
+	}
+	else
+	{
+		halbtc8723a2ant_IndicateWifiChnlBwInfo(pBtCoexist, BTC_MEDIA_DISCONNECT);
+	}
+
+	halbtc8723a2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, FALSE);
+}
+
+VOID
+halbtc8723a2ant_MonitorBtCtr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u4Byte 			regHPTxRx, regLPTxRx, u4Tmp;
+	u4Byte			regHPTx=0, regHPRx=0, regLPTx=0, regLPRx=0;
+	u1Byte			u1Tmp;
+	
+	regHPTxRx = 0x770;
+	regLPTxRx = 0x774;
+
+	u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, regHPTxRx);
+	regHPTx = u4Tmp & bMaskLWord;
+	regHPRx = (u4Tmp & bMaskHWord)>>16;
+
+	u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, regLPTxRx);
+	regLPTx = u4Tmp & bMaskLWord;
+	regLPRx = (u4Tmp & bMaskHWord)>>16;
+		
+	pCoexSta->highPriorityTx = regHPTx;
+	pCoexSta->highPriorityRx = regHPRx;
+	pCoexSta->lowPriorityTx = regLPTx;
+	pCoexSta->lowPriorityRx = regLPRx;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n", 
+		regHPTxRx, regHPTx, regHPTx, regHPRx, regHPRx));
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n", 
+		regLPTxRx, regLPTx, regLPTx, regLPRx, regLPRx));
+
+	// reset counter
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0xc);
+}
+
+VOID
+halbtc8723a2ant_MonitorBtEnableDisable(
+	IN 	PBTC_COEXIST		pBtCoexist
+	)
+{
+	static BOOLEAN	bPreBtDisabled=FALSE;
+	static u4Byte	btDisableCnt=0;
+	BOOLEAN			bBtActive=TRUE, bBtDisabled=FALSE;
+
+	// This function check if bt is disabled
+
+	if(	pCoexSta->highPriorityTx == 0 &&
+		pCoexSta->highPriorityRx == 0 &&
+		pCoexSta->lowPriorityTx == 0 &&
+		pCoexSta->lowPriorityRx == 0)
+	{
+		bBtActive = FALSE;
+	}
+	if(	pCoexSta->highPriorityTx == 0xffff &&
+		pCoexSta->highPriorityRx == 0xffff &&
+		pCoexSta->lowPriorityTx == 0xffff &&
+		pCoexSta->lowPriorityRx == 0xffff)
+	{
+		bBtActive = FALSE;
+	}
+	if(bBtActive)
+	{
+		btDisableCnt = 0;
+		bBtDisabled = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_DISABLE, &bBtDisabled);
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is enabled !!\n"));
+	}
+	else
+	{
+		btDisableCnt++;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], bt all counters=0, %d times!!\n", 
+				btDisableCnt));
+		if(btDisableCnt >= 2)
+		{
+			bBtDisabled = TRUE;
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_DISABLE, &bBtDisabled);
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is disabled !!\n"));
+		}
+	}
+	if(bPreBtDisabled != bBtDisabled)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], BT is from %s to %s!!\n", 
+			(bPreBtDisabled ? "disabled":"enabled"), 
+			(bBtDisabled ? "disabled":"enabled")));
+		bPreBtDisabled = bBtDisabled;
+		if(!bBtDisabled)
+		{
+			halbtc8723a2ant_BtEnableAction(pBtCoexist);
+		}
+	}
+}
+
+BOOLEAN
+halbtc8723a2ant_IsCommonAction(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	BOOLEAN			bCommon=FALSE, bWifiConnected=FALSE;
+	BOOLEAN			bLowPwrDisable=FALSE;
+
+	if(!pStackInfo->bBtLinkExist)
+	{
+		bLowPwrDisable = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+	}
+	else
+	{
+		bLowPwrDisable = TRUE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+	}
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+
+	if(halbtc8723a2ant_IsWifiIdle(pBtCoexist) && 
+		BT_8723A_2ANT_BT_STATUS_IDLE == pCoexDm->btStatus)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi idle + Bt idle!!\n"));
+			
+		halbtc8723a2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_RfShrink(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+		halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+		halbtc8723a2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0x20);
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+
+		bCommon = TRUE;
+	}
+	else if(!halbtc8723a2ant_IsWifiIdle(pBtCoexist) && 
+			(BT_8723A_2ANT_BT_STATUS_IDLE == pCoexDm->btStatus) )
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi non-idle + BT idle!!\n"));
+
+		halbtc8723a2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_RfShrink(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+		halbtc8723a2ant_IgnoreWlanAct(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+		halbtc8723a2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0x20);
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+
+		bCommon = TRUE;
+	}
+	else if(halbtc8723a2ant_IsWifiIdle(pBtCoexist) && 
+		(BT_8723A_2ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus) )
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi idle + Bt connected idle!!\n"));
+		
+		halbtc8723a2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_RfShrink(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+		halbtc8723a2ant_IgnoreWlanAct(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+		halbtc8723a2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0x20);
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+
+		bCommon = TRUE;
+	}
+	else if(!halbtc8723a2ant_IsWifiIdle(pBtCoexist) && 
+		(BT_8723A_2ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus) )
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi non-idle + Bt connected idle!!\n"));
+
+		halbtc8723a2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_RfShrink(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+		halbtc8723a2ant_IgnoreWlanAct(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+		halbtc8723a2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0x20);
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+
+		bCommon = TRUE;
+	}
+	else if(halbtc8723a2ant_IsWifiIdle(pBtCoexist) && 
+			(BT_8723A_2ANT_BT_STATUS_NON_IDLE == pCoexDm->btStatus) )
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi idle + BT non-idle!!\n"));
+		
+		halbtc8723a2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_RfShrink(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+		halbtc8723a2ant_IgnoreWlanAct(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+		halbtc8723a2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0x20);
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		
+		bCommon = TRUE;
+	}
+	else if(halbtc8723a2ant_IsWifiConnectedIdle(pBtCoexist) && 
+			(BT_8723A_2ANT_BT_STATUS_NON_IDLE == pCoexDm->btStatus) )
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi connected-idle + BT non-idle!!\n"));
+
+		halbtc8723a2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_RfShrink(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+		halbtc8723a2ant_IgnoreWlanAct(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+		halbtc8723a2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0x20);
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		
+		bCommon = TRUE;
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Wifi non-idle + BT non-idle!!\n"));
+		halbtc8723a2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_RfShrink(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_IgnoreWlanAct(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0x20);
+		
+		bCommon = FALSE;
+	}
+	
+	return bCommon;
+}
+VOID
+halbtc8723a2ant_TdmaDurationAdjust(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bScoHid,
+	IN	BOOLEAN			bTxPause,
+	IN	u1Byte			maxInterval
+	)
+{
+	static s4Byte		up,dn,m,n,WaitCount;
+	s4Byte			result;   //0: no change, +1: increase WiFi duration, -1: decrease WiFi duration
+	u1Byte			retryCount=0;
+
+	RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TdmaDurationAdjust()\n"));
+
+	if(pCoexDm->bResetTdmaAdjust)
+	{
+		pCoexDm->bResetTdmaAdjust = FALSE;
+		RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], first run TdmaDurationAdjust()!!\n"));
+		{
+			if(bScoHid)
+			{
+				if(bTxPause)
+				{
+					if(maxInterval == 1)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+						pCoexDm->psTdmaDuAdjType = 13;	
+					}
+					else if(maxInterval == 2)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;	
+					}
+					else if(maxInterval == 3)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;	
+					}
+					else
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+				}
+				else
+				{
+					if(maxInterval == 1)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+						pCoexDm->psTdmaDuAdjType = 9;	
+					}
+					else if(maxInterval == 2)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;	
+					}
+					else if(maxInterval == 3)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+				}
+			}
+			else
+			{
+				if(bTxPause)
+				{
+					if(maxInterval == 1)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+						pCoexDm->psTdmaDuAdjType = 5;	
+					}
+					else if(maxInterval == 2)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;	
+					}
+					else if(maxInterval == 3)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+				}
+				else
+				{
+					if(maxInterval == 1)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+						pCoexDm->psTdmaDuAdjType = 1;	
+					}
+					else if(maxInterval == 2)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;	
+					}
+					else if(maxInterval == 3)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+				}
+			}
+		}
+		//============
+		up = 0;
+		dn = 0;
+		m = 1;
+		n= 3;
+		result = 0;
+		WaitCount = 0;
+	}
+	else
+	{
+		//accquire the BT TRx retry count from BT_Info byte2
+		retryCount = pCoexSta->btRetryCnt;
+		RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], retryCount = %d\n", retryCount));
+		RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], up=%d, dn=%d, m=%d, n=%d, WaitCount=%d\n", 
+			up, dn, m, n, WaitCount));
+		result = 0;
+		WaitCount++; 
+		  
+		if(retryCount == 0)  // no retry in the last 2-second duration
+		{
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;				 
+
+			if(up >= n)	// if s n 2 retry count0, heWiFi duration
+			{
+				WaitCount = 0; 
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1; 
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Increase wifi duration!!\n"));
+			}
+		}
+		else if (retryCount <= 3)	// <=3 retry in the last 2-second duration
+		{
+			up--; 
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2)	// if s 2 2 retry count< 3, hWiFi duration
+			{
+				if (WaitCount <= 2)
+					m++; // K@blevel^
+				else
+					m = 1;
+
+				if ( m >= 20) //m j = 20 ' j120 recheckO_ WiFi duration.
+					m = 20;
+
+				n = 3*m;
+				up = 0;
+				dn = 0;
+				WaitCount = 0;
+				result = -1; 
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Decrease wifi duration for retryCounter<3!!\n"));
+			}
+		}
+		else  //retry count > 3, un1 retry count > 3, hWiFi duration
+		{
+			if (WaitCount == 1)
+				m++; // K@blevel^
+			else
+				m = 1;
+
+			if ( m >= 20) //m j = 20 ' j120 recheckO_ WiFi duration.
+				m = 20;
+
+			n = 3*m;
+			up = 0;
+			dn = 0;
+			WaitCount = 0; 
+			result = -1;
+			RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], Decrease wifi duration for retryCounter>3!!\n"));
+		}
+
+		RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], max Interval = %d\n", maxInterval));
+		if(maxInterval == 1)
+		{
+			if(bTxPause)
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TxPause = 1\n"));
+
+				if(pCoexDm->curPsTdma == 1)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+					pCoexDm->psTdmaDuAdjType = 5;
+				}
+				else if(pCoexDm->curPsTdma == 2)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+					pCoexDm->psTdmaDuAdjType = 6;
+				}
+				else if(pCoexDm->curPsTdma == 3)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 4)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+					pCoexDm->psTdmaDuAdjType = 8;
+				}
+				if(pCoexDm->curPsTdma == 9)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+					pCoexDm->psTdmaDuAdjType = 13;
+				}
+				else if(pCoexDm->curPsTdma == 10)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+					pCoexDm->psTdmaDuAdjType = 14;
+				}
+				else if(pCoexDm->curPsTdma == 11)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 12)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+					pCoexDm->psTdmaDuAdjType = 16;
+				}
+				
+				if(result == -1)
+				{					
+					if(pCoexDm->curPsTdma == 5)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+						pCoexDm->psTdmaDuAdjType = 8;
+					}
+					else if(pCoexDm->curPsTdma == 13)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+						pCoexDm->psTdmaDuAdjType = 16;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 8)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+						pCoexDm->psTdmaDuAdjType = 5;
+					}
+					else if(pCoexDm->curPsTdma == 16)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+						pCoexDm->psTdmaDuAdjType = 13;
+					}
+				}
+			}
+			else
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TxPause = 0\n"));
+				if(pCoexDm->curPsTdma == 5)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+					pCoexDm->psTdmaDuAdjType = 1;
+				}
+				else if(pCoexDm->curPsTdma == 6)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+					pCoexDm->psTdmaDuAdjType = 2;
+				}
+				else if(pCoexDm->curPsTdma == 7)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 8)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+					pCoexDm->psTdmaDuAdjType = 4;
+				}
+				if(pCoexDm->curPsTdma == 13)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+					pCoexDm->psTdmaDuAdjType = 9;
+				}
+				else if(pCoexDm->curPsTdma == 14)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+					pCoexDm->psTdmaDuAdjType = 10;
+				}
+				else if(pCoexDm->curPsTdma == 15)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 16)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+					pCoexDm->psTdmaDuAdjType = 12;
+				}
+				
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 1)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+						pCoexDm->psTdmaDuAdjType = 4;
+					}
+					else if(pCoexDm->curPsTdma == 9)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+						pCoexDm->psTdmaDuAdjType = 12;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 4)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+						pCoexDm->psTdmaDuAdjType = 1;
+					}
+					else if(pCoexDm->curPsTdma == 12)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+						pCoexDm->psTdmaDuAdjType = 9;
+					}
+				}
+			}
+		}
+		else if(maxInterval == 2)
+		{
+			if(bTxPause)
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TxPause = 1\n"));
+				if(pCoexDm->curPsTdma == 1)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+					pCoexDm->psTdmaDuAdjType = 6;
+				}
+				else if(pCoexDm->curPsTdma == 2)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+					pCoexDm->psTdmaDuAdjType = 6;
+				}
+				else if(pCoexDm->curPsTdma == 3)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 4)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+					pCoexDm->psTdmaDuAdjType = 8;
+				}
+				if(pCoexDm->curPsTdma == 9)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+					pCoexDm->psTdmaDuAdjType = 14;
+				}
+				else if(pCoexDm->curPsTdma == 10)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+					pCoexDm->psTdmaDuAdjType = 14;
+				}
+				else if(pCoexDm->curPsTdma == 11)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 12)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+					pCoexDm->psTdmaDuAdjType = 16;
+				}
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 5) 
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+						pCoexDm->psTdmaDuAdjType = 8;
+					}
+					else if(pCoexDm->curPsTdma == 13)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+						pCoexDm->psTdmaDuAdjType = 16;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 8)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}					
+					else if(pCoexDm->curPsTdma == 16)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+				}
+			}
+			else
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TxPause = 0\n"));
+				if(pCoexDm->curPsTdma == 5)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+					pCoexDm->psTdmaDuAdjType = 2;
+				}
+				else if(pCoexDm->curPsTdma == 6)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+					pCoexDm->psTdmaDuAdjType = 2;
+				}
+				else if(pCoexDm->curPsTdma == 7)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 8)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+					pCoexDm->psTdmaDuAdjType = 4;
+				}
+				if(pCoexDm->curPsTdma == 13)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+					pCoexDm->psTdmaDuAdjType = 10;
+				}
+				else if(pCoexDm->curPsTdma == 14)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+					pCoexDm->psTdmaDuAdjType = 10;
+				}
+				else if(pCoexDm->curPsTdma == 15)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 16)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+					pCoexDm->psTdmaDuAdjType = 12;
+				}
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 1)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+						pCoexDm->psTdmaDuAdjType = 4;
+					}
+					else if(pCoexDm->curPsTdma == 9)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+						pCoexDm->psTdmaDuAdjType = 12;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 4)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 12)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+				}
+			}
+		}
+		else if(maxInterval == 3)
+		{
+			if(bTxPause)
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TxPause = 1\n"));
+				if(pCoexDm->curPsTdma == 1)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 2)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 3)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 4)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+					pCoexDm->psTdmaDuAdjType = 8;
+				}
+				if(pCoexDm->curPsTdma == 9)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 10)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 11)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 12)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+					pCoexDm->psTdmaDuAdjType = 16;
+				}
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 5) 
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+						pCoexDm->psTdmaDuAdjType = 8;
+					}
+					else if(pCoexDm->curPsTdma == 13)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+						pCoexDm->psTdmaDuAdjType = 16;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 8)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}					
+					else if(pCoexDm->curPsTdma == 16)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+				}
+			}
+			else
+			{
+				RT_TRACE(COMP_COEX, DBG_TRACE, ("[BTCoex], TxPause = 0\n"));
+				if(pCoexDm->curPsTdma == 5)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 6)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 7)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 8)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+					pCoexDm->psTdmaDuAdjType = 4;
+				}
+				if(pCoexDm->curPsTdma == 13)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 14)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 15)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 16)
+				{
+					halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+					pCoexDm->psTdmaDuAdjType = 12;
+				}
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 1)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+						pCoexDm->psTdmaDuAdjType = 4;
+					}
+					else if(pCoexDm->curPsTdma == 9)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+						pCoexDm->psTdmaDuAdjType = 12;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 4)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 12)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+				}
+			}
+		}
+	}
+
+	// if current PsTdma not match with the recorded one (when scan, dhcp...), 
+	// then we have to adjust it back to the previous record one.
+	if(pCoexDm->curPsTdma != pCoexDm->psTdmaDuAdjType)
+	{
+		BOOLEAN	bScan=FALSE, bLink=FALSE, bRoam=FALSE;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], PsTdma type dismatch!!!, curPsTdma=%d, recordPsTdma=%d\n", 
+			pCoexDm->curPsTdma, pCoexDm->psTdmaDuAdjType));
+
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+		
+		if( !bScan && !bLink && !bRoam)
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, pCoexDm->psTdmaDuAdjType);
+		}
+		else
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n"));
+		}
+	}
+}
+
+// SCO only or SCO+PAN(HS)
+VOID
+halbtc8723a2ant_ActionSco(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte	wifiRssiState, wifiRssiState1;
+	u4Byte	wifiBw;
+
+	if(halbtc8723a2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 37, 0);
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+		}
+		else
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+		}
+
+		// sw mechanism		
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+	}
+	else
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 27, 0);
+		wifiRssiState1 = halbtc8723a2ant_WifiRssiState(pBtCoexist, 1, 2, 47, 0);
+		
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+		}
+		else
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+		}
+		
+		// sw mechanism
+		if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+		else
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}		
+	}
+}
+
+
+VOID
+halbtc8723a2ant_ActionHid(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte	wifiRssiState, wifiRssiState1;
+	u4Byte	wifiBw;
+
+	if(halbtc8723a2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 37, 0);
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+		}
+		else
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+		}
+
+		// sw mechanism
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+	}
+	else
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 27, 0);
+		wifiRssiState1 = halbtc8723a2ant_WifiRssiState(pBtCoexist, 1, 2, 47, 0);
+
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+		}
+		else
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+		}
+
+		// sw mechanism
+		if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+		else
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}		
+	}
+}
+
+//A2DP only / PAN(EDR) only/ A2DP+PAN(HS)
+VOID
+halbtc8723a2ant_ActionA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1, btInfoExt;
+	u4Byte		wifiBw;
+
+	btInfoExt = pCoexSta->btInfoExt;
+
+	if(halbtc8723a2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 37, 0);
+
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp rate, 1:basic /0:edr
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, FALSE, FALSE, 3);
+			}
+			else
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, FALSE, FALSE, 1);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp rate, 1:basic /0:edr
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 3);
+			}
+			else
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 1);
+			}
+		}
+
+		// sw mechanism		
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+	}
+	else
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 27, 0);
+		wifiRssiState1 = halbtc8723a2ant_WifiRssiState(pBtCoexist, 1, 2, 47, 0);
+		
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp rate, 1:basic /0:edr
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, FALSE, FALSE, 3);
+			}
+			else
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, FALSE, FALSE, 1);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp rate, 1:basic /0:edr
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 3);
+			}
+			else
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 1);
+			}
+		}
+		
+		// sw mechanism
+		if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+		else
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}		
+	}
+}
+
+VOID
+halbtc8723a2ant_ActionPanEdr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1, btInfoExt;
+	u4Byte		wifiBw;
+	
+	btInfoExt = pCoexSta->btInfoExt;
+
+	if(halbtc8723a2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 37, 0);
+			
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+		}
+		else
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+		}
+
+		// sw mechanism
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+	}
+	else
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 27, 0);
+		wifiRssiState1 = halbtc8723a2ant_WifiRssiState(pBtCoexist, 1, 2, 47, 0);
+		
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+		}
+		else
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+		}
+
+		// sw mechanism
+		if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+		else
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+	}
+}
+
+
+//PAN(HS) only
+VOID
+halbtc8723a2ant_ActionPanHs(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState;
+	u4Byte		wifiBw;
+
+	halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 37, 0);
+
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+		}
+		else
+		{
+			halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		}
+		halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+
+		// sw mechanism		
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+	}
+	else
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 37, 0);
+
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+		}
+		else
+		{
+			halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+		else
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+	}
+}
+
+//PAN(EDR)+A2DP
+VOID
+halbtc8723a2ant_ActionPanEdrA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1, btInfoExt;
+	u4Byte		wifiBw;
+
+	btInfoExt = pCoexSta->btInfoExt;
+
+	if(halbtc8723a2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 37, 0);
+
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+			}
+		}
+
+		// sw mechanism
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+	}
+	else
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 27, 0);
+		wifiRssiState1 = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 47, 0);
+		
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+			}
+		}
+
+		// sw mechanism
+		if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+		else
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+	}
+}
+
+VOID
+halbtc8723a2ant_ActionPanEdrHid(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1;
+	u4Byte		wifiBw;
+
+	if(halbtc8723a2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 37, 0);
+
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10); 
+		}
+		else
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14); 
+		}
+
+		// sw mechanism
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+	}
+	else
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 27, 0);
+		wifiRssiState1 = halbtc8723a2ant_WifiRssiState(pBtCoexist, 1, 2, 47, 0);
+		
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+		}
+		else
+		{
+			halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+		}
+		
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+		else
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+	}
+}
+
+// HID+A2DP+PAN(EDR)
+VOID
+halbtc8723a2ant_ActionHidA2dpPanEdr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1, btInfoExt;
+	u4Byte		wifiBw;
+
+	btInfoExt = pCoexSta->btInfoExt;
+
+	if(halbtc8723a2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 37, 0);
+			
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+			}
+		}
+		
+		// sw mechanism
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+	}
+	else
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 27, 0);
+		wifiRssiState1 = halbtc8723a2ant_WifiRssiState(pBtCoexist, 1, 2, 47, 0);
+		
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+			}
+		}
+
+		// sw mechanism
+		if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+		else
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+	}
+}
+
+VOID
+halbtc8723a2ant_ActionHidA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, wifiRssiState1, btInfoExt;
+	u4Byte		wifiBw;
+
+	btInfoExt = pCoexSta->btInfoExt;
+
+	if(halbtc8723a2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 37, 0);
+		
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 3);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 1);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 3);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 1);
+			}
+		}
+		
+		// sw mechanism
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+	}
+	else
+	{
+		wifiRssiState = halbtc8723a2ant_WifiRssiState(pBtCoexist, 0, 2, 27, 0);
+		wifiRssiState1 = halbtc8723a2ant_WifiRssiState(pBtCoexist, 1, 2, 47, 0);
+		
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 3);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 1);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 3);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8723a2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 1);
+			}
+		}
+
+		// sw mechanism
+		if( (wifiRssiState1 == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState1 == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, TRUE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+		else
+		{
+			halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		}
+	}
+}
+
+VOID
+halbtc8723a2ant_RunCoexistMechanism(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	u1Byte				btInfoOriginal=0, btRetryCnt=0;
+	u1Byte				algorithm=0;
+
+	if(pBtCoexist->bManualControl)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Manual control!!!\n"));
+		return;
+	}
+
+	if(pStackInfo->bProfileNotified)
+	{
+		if(pCoexSta->bHoldForStackOperation)
+		{
+			// if bt inquiry/page/pair, do not execute.
+			return;
+		}
+		
+		algorithm = halbtc8723a2ant_ActionAlgorithm(pBtCoexist);
+		if(pCoexSta->bHoldPeriodCnt && (BT_8723A_2ANT_COEX_ALGO_PANHS!=algorithm))
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex],Hold BT inquiry/page scan setting (cnt = %d)!!\n", 
+				pCoexSta->bHoldPeriodCnt));
+			if(pCoexSta->bHoldPeriodCnt >= 6)
+			{
+				pCoexSta->bHoldPeriodCnt = 0;
+				// next time the coexist parameters should be reset again.
+			}
+			else
+				pCoexSta->bHoldPeriodCnt++;
+			return;
+		}
+
+		pCoexDm->curAlgorithm = algorithm;
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Algorithm = %d \n", pCoexDm->curAlgorithm));
+		if(halbtc8723a2ant_IsCommonAction(pBtCoexist))
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant common.\n"));
+			pCoexDm->bResetTdmaAdjust = TRUE;
+		}
+		else
+		{
+			if(pCoexDm->curAlgorithm != pCoexDm->preAlgorithm)
+			{
+				RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], preAlgorithm=%d, curAlgorithm=%d\n", 
+					pCoexDm->preAlgorithm, pCoexDm->curAlgorithm));
+				pCoexDm->bResetTdmaAdjust = TRUE;
+			}
+			switch(pCoexDm->curAlgorithm)
+			{
+				case BT_8723A_2ANT_COEX_ALGO_SCO:
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = SCO.\n"));
+					halbtc8723a2ant_ActionSco(pBtCoexist);
+					break;
+				case BT_8723A_2ANT_COEX_ALGO_HID:
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = HID.\n"));
+					halbtc8723a2ant_ActionHid(pBtCoexist);
+					break;
+				case BT_8723A_2ANT_COEX_ALGO_A2DP:
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = A2DP.\n"));
+					halbtc8723a2ant_ActionA2dp(pBtCoexist);
+					break;
+				case BT_8723A_2ANT_COEX_ALGO_PANEDR:
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n"));
+					halbtc8723a2ant_ActionPanEdr(pBtCoexist);
+					break;
+				case BT_8723A_2ANT_COEX_ALGO_PANHS:
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = HS mode.\n"));
+					halbtc8723a2ant_ActionPanHs(pBtCoexist);
+					break;
+				case BT_8723A_2ANT_COEX_ALGO_PANEDR_A2DP:
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n"));
+					halbtc8723a2ant_ActionPanEdrA2dp(pBtCoexist);
+					break;
+				case BT_8723A_2ANT_COEX_ALGO_PANEDR_HID:
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n"));
+					halbtc8723a2ant_ActionPanEdrHid(pBtCoexist);
+					break;
+				case BT_8723A_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n"));
+					halbtc8723a2ant_ActionHidA2dpPanEdr(pBtCoexist);
+					break;
+				case BT_8723A_2ANT_COEX_ALGO_HID_A2DP:
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n"));
+					halbtc8723a2ant_ActionHidA2dp(pBtCoexist);
+					break;
+				default:
+					RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n"));
+					halbtc8723a2ant_CoexAllOff(pBtCoexist);
+					break;
+			}
+			pCoexDm->preAlgorithm = pCoexDm->curAlgorithm;
+		}
+	}
+}
+
+//============================================================
+// work around function start with wa_halbtc8723a2ant_
+//============================================================
+VOID
+wa_halbtc8723a2ant_MonitorC2h(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	u1Byte	tmp1b=0x0;
+	u4Byte	curC2hTotalCnt=0x0;
+	static u4Byte	preC2hTotalCnt=0x0, sameCntPollingTime=0x0;
+
+	curC2hTotalCnt+=pCoexSta->btInfoC2hCnt[BT_INFO_SRC_8723A_2ANT_BT_RSP];
+
+	if(curC2hTotalCnt == preC2hTotalCnt)
+	{
+		sameCntPollingTime++;
+	}
+	else
+	{
+		preC2hTotalCnt = curC2hTotalCnt;
+		sameCntPollingTime = 0;
+	}
+
+	if(sameCntPollingTime >= 2)
+	{
+		tmp1b = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x1af);
+		if(tmp1b != 0x0)
+		{
+			pCoexSta->c2hHangDetectCnt++;
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x1af, 0x0);
+		}
+	}
+}
+
+//============================================================
+// extern function start with EXhalbtc8723a2ant_
+//============================================================
+VOID
+EXhalbtc8723a2ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+}
+
+VOID
+EXhalbtc8723a2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
+{
+	u4Byte	u4Tmp=0;
+	u1Byte	u1Tmp=0;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], 2Ant Init HW Config!!\n"));
+
+	// backup rf 0x1e value
+	pCoexDm->btRf0x1eBackup = 
+		pBtCoexist->fBtcGetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff);
+
+	// Enable counter statistics
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x4);
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x778, 0x3);
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x40, 0x20);
+}
+
+VOID
+EXhalbtc8723a2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Coex Mechanism Init!!\n"));
+	
+	halbtc8723a2ant_InitCoexDm(pBtCoexist);
+}
+
+VOID
+EXhalbtc8723a2ant_DisplayCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	pu1Byte				cliBuf=pBtCoexist->cliBuf;
+	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
+	u4Byte				u4Tmp[4];
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
+		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
+	CL_PRINTF(cliBuf);	
+	
+	if(pBtCoexist->bManualControl)
+	{
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "[Action Manual control]!!");
+		CL_PRINTF(cliBuf);
+	}
+	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %d", "BT stack/ hci ext ver", \
+		((pStackInfo->bProfileNotified)? "Yes":"No"), pStackInfo->hciVersion);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
+		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
+		pCoexDm->wifiChnlInfo[2]);
+	CL_PRINTF(cliBuf);
+	
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
+	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
+		((pCoexSta->bC2hBtInquiryPage)?("inquiry/page scan"):((BT_8723A_2ANT_BT_STATUS_IDLE == pCoexDm->btStatus)? "idle":(  (BT_8723A_2ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus)? "connected-idle":"busy"))),
+		pCoexSta->btRssi, pCoexSta->btRetryCnt);
+	CL_PRINTF(cliBuf);
+	
+	if(pStackInfo->bProfileNotified)
+	{			
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "SCO/HID/PAN/A2DP", \
+			pStackInfo->bScoExist, pStackInfo->bHidExist, pStackInfo->bPanExist, pStackInfo->bA2dpExist);
+		CL_PRINTF(cliBuf);	
+
+		pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_BT_LINK_INFO);
+	}
+
+	btInfoExt = pCoexSta->btInfoExt;
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "BT Info A2DP rate", \
+		(btInfoExt&BIT0)? "Basic rate":"EDR rate");
+	CL_PRINTF(cliBuf);	
+
+	for(i=0; i<BT_INFO_SRC_8723A_2ANT_MAX; i++)
+	{
+		if(pCoexSta->btInfoC2hCnt[i])
+		{				
+			CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)", GLBtInfoSrc8723a2Ant[i], \
+				pCoexSta->btInfoC2h[i][0], pCoexSta->btInfoC2h[i][1],
+				pCoexSta->btInfoC2h[i][2], pCoexSta->btInfoC2h[i][3],
+				pCoexSta->btInfoC2h[i][4], pCoexSta->btInfoC2h[i][5],
+				pCoexSta->btInfoC2h[i][6], pCoexSta->btInfoC2hCnt[i]);
+			CL_PRINTF(cliBuf);
+		}
+	}
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "write 0x1af=0x0 num", \
+		pCoexSta->c2hHangDetectCnt);
+	CL_PRINTF(cliBuf);
+	
+	// Sw mechanism	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Sw mechanism]============");
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d", "SM1[ShRf/ LpRA/ LimDig]", \
+		pCoexDm->bCurRfRxLpfShrink, pCoexDm->bCurLowPenaltyRa, pCoexDm->bLimitedDig);
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ", "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]", \
+		pCoexDm->bCurAgcTableEn, pCoexDm->bCurAdcBackOff, pCoexDm->bCurDacSwingOn, pCoexDm->curDacSwingLvl);
+	CL_PRINTF(cliBuf);
+
+	// Fw mechanism		
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Fw mechanism]============");
+	CL_PRINTF(cliBuf);	
+	
+	if(!pBtCoexist->bManualControl)
+	{
+		psTdmaCase = pCoexDm->curPsTdma;
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x %02x %02x case-%d", "PS TDMA", \
+			pCoexDm->psTdmaPara[0], pCoexDm->psTdmaPara[1],
+			pCoexDm->psTdmaPara[2], pCoexDm->psTdmaPara[3],
+			pCoexDm->psTdmaPara[4], psTdmaCase);
+		CL_PRINTF(cliBuf);
+	
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "DecBtPwr/ IgnWlanAct", \
+			pCoexDm->bCurDecBtPwr, pCoexDm->bCurIgnoreWlanAct);
+		CL_PRINTF(cliBuf);
+	}
+
+	// Hw setting		
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Hw setting]============");
+	CL_PRINTF(cliBuf);	
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "RF-A, 0x1e initVal", \
+		pCoexDm->btRf0x1eBackup);
+	CL_PRINTF(cliBuf);
+
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x778);
+	u1Tmp[1] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x783);
+	u1Tmp[2] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x796);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", "0x778/ 0x783/ 0x796", \
+		u1Tmp[0], u1Tmp[1], u1Tmp[2]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x880);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x880", \
+		u4Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x40);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x40", \
+		u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x550);
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x522);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x", "0x550(bcn ctrl)/0x522", \
+		u4Tmp[0], u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x484);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x484(rate adaptive)", \
+		u4Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xc50);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)", \
+		u4Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xda0);
+	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xda4);
+	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xda8);
+	u4Tmp[3] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xdac);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x", "0xda0/0xda4/0xda8/0xdac(FA cnt)", \
+		u4Tmp[0], u4Tmp[1], u4Tmp[2], u4Tmp[3]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c0);
+	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c4);
+	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c8);
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x6cc);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x", "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)", \
+		u4Tmp[0], u4Tmp[1], u4Tmp[2], u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "0x770 (hp rx[31:16]/tx[15:0])", \
+		pCoexSta->highPriorityRx, pCoexSta->highPriorityTx);
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "0x774(lp rx[31:16]/tx[15:0])", \
+		pCoexSta->lowPriorityRx, pCoexSta->lowPriorityTx);
+	CL_PRINTF(cliBuf);
+
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+VOID
+EXhalbtc8723a2ant_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_IPS_ENTER == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], IPS ENTER notify\n"));
+		halbtc8723a2ant_CoexAllOff(pBtCoexist);
+	}
+	else if(BTC_IPS_LEAVE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], IPS LEAVE notify\n"));
+		//halbtc8723a2ant_InitCoexDm(pBtCoexist);
+	}
+}
+
+VOID
+EXhalbtc8723a2ant_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_LPS_ENABLE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], LPS ENABLE notify\n"));
+	}
+	else if(BTC_LPS_DISABLE == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], LPS DISABLE notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8723a2ant_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_SCAN_START == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCAN START notify\n"));
+	}
+	else if(BTC_SCAN_FINISH == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], SCAN FINISH notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8723a2ant_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_ASSOCIATE_START == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], CONNECT START notify\n"));
+	}
+	else if(BTC_ASSOCIATE_FINISH == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], CONNECT FINISH notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8723a2ant_MediaStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{
+	if(BTC_MEDIA_CONNECT == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], MEDIA connect notify\n"));
+	}
+	else
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], MEDIA disconnect notify\n"));
+	}
+
+	halbtc8723a2ant_IndicateWifiChnlBwInfo(pBtCoexist, type);
+}
+
+VOID
+EXhalbtc8723a2ant_SpecialPacketNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{
+	if(type == BTC_PACKET_DHCP)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], DHCP Packet notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8723a2ant_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	)
+{
+	u1Byte			btInfo=0;
+	u1Byte			i, rspSource=0;
+	BOOLEAN			bBtBusy=FALSE, bLimitedDig=FALSE;
+	BOOLEAN			bWifiConnected=FALSE, bBtHsOn=FALSE;
+
+	pCoexSta->bC2hBtInfoReqSent = FALSE;
+	
+	rspSource = BT_INFO_SRC_8723A_2ANT_BT_RSP;
+	pCoexSta->btInfoC2hCnt[rspSource]++;
+
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Bt info[%d], length=%d, hex data=[", rspSource, length));
+	for(i=0; i<length; i++)
+	{
+		pCoexSta->btInfoC2h[rspSource][i] = tmpBuf[i];
+		if(i == 0)
+			btInfo = tmpBuf[i];
+		if(i == length-1)
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("0x%02x]\n", tmpBuf[i]));
+		}
+		else
+		{
+			RT_TRACE(COMP_COEX, DBG_LOUD, ("0x%02x, ", tmpBuf[i]));
+		}
+	}
+
+	if(BT_INFO_SRC_8723A_2ANT_WIFI_FW != rspSource)
+	{
+		pCoexSta->btRetryCnt =
+			pCoexSta->btInfoC2h[rspSource][1];
+
+		pCoexSta->btRssi =
+			pCoexSta->btInfoC2h[rspSource][2]*2+10;
+
+		pCoexSta->btInfoExt = 
+			pCoexSta->btInfoC2h[rspSource][3];
+	}
+		
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+	// check BIT2 first ==> check if bt is under inquiry or page scan
+	if(btInfo & BT_INFO_8723A_2ANT_B_INQ_PAGE)
+	{
+		pCoexSta->bC2hBtInquiryPage = TRUE;
+	}
+	else
+	{
+		pCoexSta->bC2hBtInquiryPage = FALSE;
+	}
+}
+
+VOID
+EXhalbtc8723a2ant_StackOperationNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{
+	if(BTC_STACK_OP_INQ_PAGE_PAIR_START == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], StackOP Inquiry/page/pair start notify\n"));
+		pCoexSta->bHoldForStackOperation = TRUE;
+		pCoexSta->bHoldPeriodCnt = 1;
+		halbtc8723a2ant_BtInquiryPage(pBtCoexist);
+	}
+	else if(BTC_STACK_OP_INQ_PAGE_PAIR_FINISH == type)
+	{
+		RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], StackOP Inquiry/page/pair finish notify\n"));
+		pCoexSta->bHoldForStackOperation = FALSE;
+	}
+}
+
+VOID
+EXhalbtc8723a2ant_HaltNotify(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], Halt notify\n"));
+
+	halbtc8723a2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
+	EXhalbtc8723a2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
+}
+
+VOID
+EXhalbtc8723a2ant_Periodical(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	RT_TRACE(COMP_COEX, DBG_LOUD, ("[BTCoex], 2Ant Periodical!!\n"));
+
+	// work around for c2h hang
+	wa_halbtc8723a2ant_MonitorC2h(pBtCoexist);
+	
+	halbtc8723a2ant_QueryBtInfo(pBtCoexist);
+	halbtc8723a2ant_MonitorBtCtr(pBtCoexist);
+	halbtc8723a2ant_MonitorBtEnableDisable(pBtCoexist);
+
+	halbtc8723a2ant_RunCoexistMechanism(pBtCoexist);
+}
+
+
+#endif
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a2Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a2Ant.h
new file mode 100644
index 000000000..d5d5488c2
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723a2Ant.h
@@ -0,0 +1,184 @@
+//===========================================
+// The following is for 8723A 2Ant BT Co-exist definition
+//===========================================
+#define	BT_INFO_8723A_2ANT_B_FTP						BIT7
+#define	BT_INFO_8723A_2ANT_B_A2DP					BIT6
+#define	BT_INFO_8723A_2ANT_B_HID						BIT5
+#define	BT_INFO_8723A_2ANT_B_SCO_BUSY				BIT4
+#define	BT_INFO_8723A_2ANT_B_ACL_BUSY				BIT3
+#define	BT_INFO_8723A_2ANT_B_INQ_PAGE				BIT2
+#define	BT_INFO_8723A_2ANT_B_SCO_ESCO				BIT1
+#define	BT_INFO_8723A_2ANT_B_CONNECTION				BIT0
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8723A_2ANT		2
+
+typedef enum _BT_INFO_SRC_8723A_2ANT{
+	BT_INFO_SRC_8723A_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8723A_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8723A_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8723A_2ANT_MAX
+}BT_INFO_SRC_8723A_2ANT,*PBT_INFO_SRC_8723A_2ANT;
+
+typedef enum _BT_8723A_2ANT_BT_STATUS{
+	BT_8723A_2ANT_BT_STATUS_IDLE				= 0x0,
+	BT_8723A_2ANT_BT_STATUS_CONNECTED_IDLE	= 0x1,
+	BT_8723A_2ANT_BT_STATUS_NON_IDLE			= 0x2,
+	BT_8723A_2ANT_BT_STATUS_MAX
+}BT_8723A_2ANT_BT_STATUS,*PBT_8723A_2ANT_BT_STATUS;
+
+typedef enum _BT_8723A_2ANT_COEX_ALGO{
+	BT_8723A_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8723A_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8723A_2ANT_COEX_ALGO_HID				= 0x2,
+	BT_8723A_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8723A_2ANT_COEX_ALGO_PANEDR			= 0x4,
+	BT_8723A_2ANT_COEX_ALGO_PANHS			= 0x5,
+	BT_8723A_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x6,
+	BT_8723A_2ANT_COEX_ALGO_PANEDR_HID		= 0x7,
+	BT_8723A_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x8,
+	BT_8723A_2ANT_COEX_ALGO_HID_A2DP			= 0x9,
+	BT_8723A_2ANT_COEX_ALGO_MAX
+}BT_8723A_2ANT_COEX_ALGO,*PBT_8723A_2ANT_COEX_ALGO;
+
+typedef struct _COEX_DM_8723A_2ANT{
+	// fw mechanism
+	BOOLEAN		bPreDecBtPwr;
+	BOOLEAN		bCurDecBtPwr;
+	//BOOLEAN		bPreBtLnaConstrain;
+	//BOOLEAN		bCurBtLnaConstrain;
+	//u1Byte		bPreBtPsdMode;
+	//u1Byte		bCurBtPsdMode;
+	u1Byte		preFwDacSwingLvl;
+	u1Byte		curFwDacSwingLvl;
+	BOOLEAN		bCurIgnoreWlanAct;
+	BOOLEAN		bPreIgnoreWlanAct;
+	u1Byte		prePsTdma;
+	u1Byte		curPsTdma;
+	u1Byte		psTdmaPara[5];
+	u1Byte		psTdmaDuAdjType;
+	BOOLEAN		bResetTdmaAdjust;
+	BOOLEAN		bPrePsTdmaOn;
+	BOOLEAN		bCurPsTdmaOn;
+	//BOOLEAN		bPreBtAutoReport;
+	//BOOLEAN		bCurBtAutoReport;
+
+	// sw mechanism
+	BOOLEAN		bPreRfRxLpfShrink;
+	BOOLEAN		bCurRfRxLpfShrink;
+	u4Byte		btRf0x1eBackup;
+	BOOLEAN 	bPreLowPenaltyRa;
+	BOOLEAN		bCurLowPenaltyRa;
+	BOOLEAN		bPreDacSwingOn;
+	u4Byte		preDacSwingLvl;
+	BOOLEAN		bCurDacSwingOn;
+	u4Byte		curDacSwingLvl;
+	BOOLEAN		bPreAdcBackOff;
+	BOOLEAN		bCurAdcBackOff;
+	BOOLEAN 	bPreAgcTableEn;
+	BOOLEAN		bCurAgcTableEn;
+	u4Byte		preVal0x6c0;
+	u4Byte		curVal0x6c0;
+	u4Byte		preVal0x6c8;
+	u4Byte		curVal0x6c8;
+	u1Byte		preVal0x6cc;
+	u1Byte		curVal0x6cc;
+	BOOLEAN		bLimitedDig;
+
+	// algorithm related
+	u1Byte		preAlgorithm;
+	u1Byte		curAlgorithm;
+	u1Byte		btStatus;
+	u1Byte		wifiChnlInfo[3];
+} COEX_DM_8723A_2ANT, *PCOEX_DM_8723A_2ANT;
+
+typedef struct _COEX_STA_8723A_2ANT{
+	u4Byte					highPriorityTx;
+	u4Byte					highPriorityRx;
+	u4Byte					lowPriorityTx;
+	u4Byte					lowPriorityRx;
+	u1Byte					btRssi;
+	u1Byte					preBtRssiState;
+	u1Byte					preBtRssiState1;
+	u1Byte					preWifiRssiState[4];
+	BOOLEAN					bC2hBtInfoReqSent;
+	u1Byte					btInfoC2h[BT_INFO_SRC_8723A_2ANT_MAX][10];
+	u4Byte					btInfoC2hCnt[BT_INFO_SRC_8723A_2ANT_MAX];
+	BOOLEAN					bC2hBtInquiryPage;
+	u1Byte					btRetryCnt;
+	u1Byte					btInfoExt;
+	BOOLEAN					bHoldForStackOperation;
+	u1Byte					bHoldPeriodCnt;
+	// this is for c2h hang work-around
+	u4Byte					c2hHangDetectCnt;
+}COEX_STA_8723A_2ANT, *PCOEX_STA_8723A_2ANT;
+
+//===========================================
+// The following is interface which will notify coex module.
+//===========================================
+VOID
+EXhalbtc8723a2ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8723a2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
+EXhalbtc8723a2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8723a2ant_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8723a2ant_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8723a2ant_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8723a2ant_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8723a2ant_MediaStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8723a2ant_SpecialPacketNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8723a2ant_HaltNotify(
+	IN	PBTC_COEXIST			pBtCoexist
+	);
+VOID
+EXhalbtc8723a2ant_Periodical(
+	IN	PBTC_COEXIST			pBtCoexist
+	);
+VOID
+EXhalbtc8723a2ant_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	);
+VOID
+EXhalbtc8723a2ant_StackOperationNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8723a2ant_DisplayCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b1Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b1Ant.c
new file mode 100644
index 000000000..a15a6013f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b1Ant.c
@@ -0,0 +1,4845 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8723B Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "Mp_Precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8723B_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8723b_1ant		glcoex_dm_8723b_1ant;
+static struct  coex_dm_8723b_1ant	*coex_dm = &glcoex_dm_8723b_1ant;
+static struct  coex_sta_8723b_1ant		glcoex_sta_8723b_1ant;
+static struct  coex_sta_8723b_1ant	*coex_sta = &glcoex_sta_8723b_1ant;
+static struct  psdscan_sta_8723b_1ant	gl_psd_scan_8723b_1ant;
+static struct  psdscan_sta_8723b_1ant *psd_scan = &gl_psd_scan_8723b_1ant;
+
+
+const char *const glbt_info_src_8723b_1ant[]={
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8723b_1ant = 20151015;
+u32	glcoex_ver_8723b_1ant = 0x63;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8723b1ant_
+ * ************************************************************ */
+
+void halbtc8723b1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+	
+	if( force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8723b1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8723b1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+				break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+				break;
+			default:
+				break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8723b1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8723b1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8723b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8723b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8723b1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8723b1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8723b1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8723b1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8723b1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8723b1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+void halbtc8723b1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u32		num_of_bt_counter_chk = 0;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if ((coex_sta->low_priority_tx > 1050)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	/* This part is for wifi FW and driver to update BT's status as disabled. */
+	/* The flow is as the following */
+	/* 1. disable BT */
+	/* 2. if all BT Tx/Rx counter=0, after 6 sec we query bt info */
+	/* 3. Because BT will not rsp from mailbox, so wifi fw will know BT is disabled */
+	/* 4. FW will rsp c2h for BT that driver will know BT is disabled. */
+	if ((reg_hp_tx == 0) && (reg_hp_rx == 0) && (reg_lp_tx == 0) &&
+	    (reg_lp_rx == 0)) {
+		num_of_bt_counter_chk++;
+		if (num_of_bt_counter_chk == 3)
+			halbtc8723b1ant_query_bt_info(btcoexist);
+	} else
+		num_of_bt_counter_chk = 0;
+}
+
+
+void halbtc8723b1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+	s32	wifi_rssi = 0;
+	boolean wifi_busy = false, wifi_under_b_mode = false;
+	static u8 cck_lock_counter = 0;
+	u32	total_cnt;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+			   &wifi_under_b_mode);
+
+	if (coex_sta->under_ips) {
+		coex_sta->crc_ok_cck = 0;
+		coex_sta->crc_ok_11g = 0;
+		coex_sta->crc_ok_11n = 0;
+		coex_sta->crc_ok_11n_agg = 0;
+
+		coex_sta->crc_err_cck = 0;
+		coex_sta->crc_err_11g = 0;
+		coex_sta->crc_err_11n = 0;
+		coex_sta->crc_err_11n_agg = 0;	
+	} else {
+		coex_sta->crc_ok_cck	= btcoexist->btc_read_4byte(btcoexist,
+					  0xf88);
+		coex_sta->crc_ok_11g	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf94);
+		coex_sta->crc_ok_11n	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf90);
+		coex_sta->crc_ok_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					   0xfb8);
+
+		coex_sta->crc_err_cck	 = btcoexist->btc_read_4byte(btcoexist,
+					   0xf84);
+		coex_sta->crc_err_11g	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf96);
+		coex_sta->crc_err_11n	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf92);
+		coex_sta->crc_err_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					    0xfba);
+	}
+
+
+	/* reset counter */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xf16, 0x1, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xf16, 0x1, 0x0);
+
+	if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+		total_cnt = coex_sta->crc_ok_cck + coex_sta->crc_ok_11g +
+			    coex_sta->crc_ok_11n +
+				coex_sta->crc_ok_11n_agg;
+	
+		if ( (coex_dm->bt_status == BT_8723B_1ANT_BT_STATUS_ACL_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8723B_1ANT_BT_STATUS_SCO_BUSY)) {
+			if (coex_sta->crc_ok_cck > (total_cnt -
+coex_sta->crc_ok_cck)) 			{
+				if (cck_lock_counter < 3)
+					cck_lock_counter++;
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+	} else {
+		if (cck_lock_counter > 0)
+			cck_lock_counter--;
+	}
+
+	if (!coex_sta->pre_ccklock) {
+
+		if (cck_lock_counter >= 3)
+			coex_sta->cck_lock = true;
+		else
+			coex_sta->cck_lock = false;
+	} else {
+		if (cck_lock_counter == 0)
+			coex_sta->cck_lock = false;
+		else
+			coex_sta->cck_lock = true;
+	}
+
+	if (coex_sta->cck_lock)
+		coex_sta->cck_ever_lock = true;
+
+	coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+
+}
+
+boolean halbtc8723b1ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+
+
+	}
+
+	return false;
+}
+
+void halbtc8723b1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+	bt_link_info->bt_hi_pri_link_exist = coex_sta->bt_hi_pri_link_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if( bt_link_info->sco_exist &&
+		!bt_link_info->a2dp_exist &&
+		!bt_link_info->pan_exist &&
+		!bt_link_info->hid_exist )
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if( !bt_link_info->sco_exist &&
+		bt_link_info->a2dp_exist &&
+		!bt_link_info->pan_exist &&
+		!bt_link_info->hid_exist )
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if( !bt_link_info->sco_exist &&
+		!bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist &&
+		!bt_link_info->hid_exist )
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+	
+	/* check if Hid only */
+	if( !bt_link_info->sco_exist &&
+		!bt_link_info->a2dp_exist &&
+		!bt_link_info->pan_exist &&
+		bt_link_info->hid_exist )
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+void halbtc8723b1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8723b1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8723b1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8723b1ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf7;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf8;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf9;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8723b1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8723b1ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8723b1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8723b1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8723b1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8723b1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+#if BT_8723B_1ANT_ANTDET_ENABLE
+#if BT_8723B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE
+	if (board_info->btdm_ant_num_by_ant_det == 2) {
+		if (type == 3)
+			type = 14;
+		else if (type == 4)
+			type  = 13;
+		else if (type == 5)
+			type = 8;
+	}
+#endif
+#endif
+
+	coex_sta->coex_table_type = type;
+
+	switch (type) {
+	case 0:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 4:
+		if ((coex_sta->cck_ever_lock)  &&
+		    (coex_sta->scan_ap_num <= 5))
+			halbtc8723b1ant_coex_table(btcoexist,
+					   force_exec, 0x55555555, 0xaaaa5a5a,
+						   0xffffff, 0x3);
+		else
+			halbtc8723b1ant_coex_table(btcoexist,
+					   force_exec, 0x55555555, 0x5a5a5a5a,
+						   0xffffff, 0x3);
+		break;
+	case 5:
+		if ((coex_sta->cck_ever_lock)  &&
+		    (coex_sta->scan_ap_num <= 5))
+			halbtc8723b1ant_coex_table(btcoexist,
+					   force_exec, 0x5a5a5a5a, 0x5aaa5a5a,
+						   0xffffff, 0x3);
+		else
+			halbtc8723b1ant_coex_table(btcoexist,
+					   force_exec, 0x5a5a5a5a, 0x5aaa5a5a,
+						   0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 8:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 9:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 10:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 11:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 12:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 13:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 14:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 15:
+		halbtc8723b1ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8723b1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable) {
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8723b1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8723b1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8723b1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8723b1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8723b1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8723b1ant_sw_mechanism(IN struct btc_coexist *btcoexist,
+				  IN boolean low_penalty_ra)
+{
+	halbtc8723b1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+void halbtc8723b1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean force_exec, IN boolean init_hwcfg,
+				  IN boolean wifi_off)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			fw_ver = 0, u32tmp = 0, cnt_bt_cal_chk = 0;
+	boolean			pg_ext_switch = false;
+	boolean			use_ext_switch = false;
+	boolean			is_in_mp_mode = false;
+	u8			h2c_parameter[2] = {0}, u8tmp = 0;
+
+	coex_dm->cur_ant_pos_type = ant_pos_type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_EXT_SWITCH, &pg_ext_switch);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER,
+			   &fw_ver);	/* [31:16]=fw ver, [15:0]=fw sub ver */
+
+	if ((fw_ver > 0 && fw_ver < 0xc0000) || pg_ext_switch)
+		use_ext_switch = true;
+
+#if BT_8723B_1ANT_ANTDET_ENABLE
+#if BT_8723B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE
+	if (ant_pos_type == BTC_ANT_PATH_PTA) {
+		if ((board_info->btdm_ant_det_finish) &&
+		    (board_info->btdm_ant_num_by_ant_det == 2)) {
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT)
+				ant_pos_type = BTC_ANT_PATH_WIFI;
+			else
+				ant_pos_type = BTC_ANT_PATH_BT;
+		}
+	}
+#endif
+#endif
+
+	if (init_hwcfg) {
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x780); /* WiFi TRx Mask on */
+		/* remove due to interrupt is disabled that polling c2h will fail and delay 100ms. */
+		/* btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x3c, 0x15); //BT TRx Mask on */
+
+		if (fw_ver >= 0x180000) {
+			/* Use H2C to set GNT_BT to HIGH */
+			h2c_parameter[0] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1,
+						h2c_parameter);
+		} else {
+			/* set grant_bt to high */
+			btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+		}
+		/* set wlan_act control by PTA */
+		btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+			   0x0); /* BT select s0/s1 is controlled by BT */
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x39, 0x8, 0x1);
+		btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x944, 0x3, 0x3);
+		btcoexist->btc_write_1byte(btcoexist, 0x930, 0x77);
+	} else if (wifi_off) {
+		if (fw_ver >= 0x180000) {
+			/* Use H2C to set GNT_BT to HIGH */
+			h2c_parameter[0] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1,
+						h2c_parameter);
+		} else {
+			/* set grant_bt to high */
+			btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+		}
+		/* set wlan_act to always low */
+		btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_IS_IN_MP_MODE,
+				   &is_in_mp_mode);
+		if (!is_in_mp_mode)
+			btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67,
+				0x20, 0x0); /* BT select s0/s1 is controlled by BT */
+		else
+			btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67,
+				0x20, 0x1); /* BT select s0/s1 is controlled by WiFi */
+
+		/* 0x4c[24:23]=00, Set Antenna control by BT_RFE_CTRL	BT Vendor 0xac=0xf002 */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp &= ~BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+	} else {
+		/* Use H2C to set GNT_BT to LOW */
+		if (fw_ver >= 0x180000) {
+			if (btcoexist->btc_read_1byte(btcoexist, 0x765) != 0) {
+				h2c_parameter[0] = 0;
+				btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1,
+							h2c_parameter);
+			}
+		} else {
+			/* BT calibration check */
+			while (cnt_bt_cal_chk <= 20) {
+				u8tmp = btcoexist->btc_read_1byte(btcoexist,
+								  0x49d);
+				cnt_bt_cal_chk++;
+				if (u8tmp & BIT(0)) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], ########### BT is calibrating (wait cnt=%d) ###########\n",
+						    cnt_bt_cal_chk);
+					BTC_TRACE(trace_buf);
+					delay_ms(50);
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], ********** BT is NOT calibrating (wait cnt=%d)**********\n",
+						    cnt_bt_cal_chk);
+					BTC_TRACE(trace_buf);
+					break;
+				}
+			}
+
+			/* set grant_bt to PTA */
+			btcoexist->btc_write_1byte(btcoexist, 0x765, 0x0);
+		}
+
+		if (btcoexist->btc_read_1byte(btcoexist, 0x76e) != 0xc) {
+			/* set wlan_act control by PTA */
+			btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+		}
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+			   0x1); /* BT select s0/s1 is controlled by WiFi */
+	}
+
+	if (use_ext_switch) {
+		if (init_hwcfg) {
+			/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+			u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+			u32tmp &= ~BIT(23);
+			u32tmp |= BIT(24);
+			btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+			btcoexist->btc_write_4byte(btcoexist, 0x948,
+				0x0); /* fixed internal switch S1->WiFi, S0->BT */
+
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT) {
+				/* tell firmware "no antenna inverse" */
+				h2c_parameter[0] = 0;
+				h2c_parameter[1] = 1;  /* ext switch type */
+				btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+							h2c_parameter);
+			} else {
+				/* tell firmware "antenna inverse" */
+				h2c_parameter[0] = 1;
+				h2c_parameter[1] = 1;  /* ext switch type */
+				btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+							h2c_parameter);
+			}
+		}
+
+		if (force_exec ||
+		    (coex_dm->cur_ant_pos_type !=
+		     coex_dm->pre_ant_pos_type)) {
+			/* ext switch setting */
+			switch (ant_pos_type) {
+			case BTC_ANT_PATH_WIFI:
+				if (board_info->btdm_ant_pos ==
+				    BTC_ANTENNA_AT_MAIN_PORT)
+					btcoexist->btc_write_1byte_bitmask(
+						btcoexist, 0x92c, 0x3,
+						0x1);
+				else
+					btcoexist->btc_write_1byte_bitmask(
+						btcoexist, 0x92c, 0x3,
+						0x2);
+				break;
+			case BTC_ANT_PATH_BT:
+				if (board_info->btdm_ant_pos ==
+				    BTC_ANTENNA_AT_MAIN_PORT)
+					btcoexist->btc_write_1byte_bitmask(
+						btcoexist, 0x92c, 0x3,
+						0x2);
+				else
+					btcoexist->btc_write_1byte_bitmask(
+						btcoexist, 0x92c, 0x3,
+						0x1);
+				break;
+			default:
+			case BTC_ANT_PATH_PTA:
+				if (board_info->btdm_ant_pos ==
+				    BTC_ANTENNA_AT_MAIN_PORT)
+					btcoexist->btc_write_1byte_bitmask(
+						btcoexist, 0x92c, 0x3,
+						0x1);
+				else
+					btcoexist->btc_write_1byte_bitmask(
+						btcoexist, 0x92c, 0x3,
+						0x2);
+				break;
+			}
+		}
+	} else {
+		if (init_hwcfg) {
+			/* 0x4c[23]=1, 0x4c[24]=0  Antenna control by 0x64 */
+			u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+			u32tmp |= BIT(23);
+			u32tmp &= ~BIT(24);
+			btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+			/* Fix Ext switch Main->S1, Aux->S0 */
+			btcoexist->btc_write_1byte_bitmask(btcoexist, 0x64, 0x1,
+							   0x0);
+
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT) {
+
+				/* tell firmware "no antenna inverse" */
+				h2c_parameter[0] = 0;
+				h2c_parameter[1] =
+					0;  /* internal switch type */
+				btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+							h2c_parameter);
+			} else {
+
+				/* tell firmware "antenna inverse" */
+				h2c_parameter[0] = 1;
+				h2c_parameter[1] =
+					0;  /* internal switch type */
+				btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+							h2c_parameter);
+			}
+		}
+
+		if (force_exec ||
+		    (coex_dm->cur_ant_pos_type !=
+		     coex_dm->pre_ant_pos_type)) {
+			/* internal switch setting */
+			switch (ant_pos_type) {
+			case BTC_ANT_PATH_WIFI:
+				if (board_info->btdm_ant_pos ==
+				    BTC_ANTENNA_AT_MAIN_PORT)
+					btcoexist->btc_write_4byte(
+						btcoexist, 0x948, 0x0);
+				else
+					btcoexist->btc_write_4byte(
+						btcoexist, 0x948,
+						0x280);
+				break;
+			case BTC_ANT_PATH_BT:
+				if (board_info->btdm_ant_pos ==
+				    BTC_ANTENNA_AT_MAIN_PORT)
+					btcoexist->btc_write_4byte(
+						btcoexist, 0x948,
+						0x280);
+				else
+					btcoexist->btc_write_4byte(
+						btcoexist, 0x948, 0x0);
+				break;
+			default:
+			case BTC_ANT_PATH_PTA:
+				if (board_info->btdm_ant_pos ==
+				    BTC_ANTENNA_AT_MAIN_PORT)
+					btcoexist->btc_write_4byte(
+						btcoexist, 0x948,
+						0x200);
+				else
+					btcoexist->btc_write_4byte(
+						btcoexist, 0x948, 0x80);
+				break;
+			}
+		}
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+}
+
+void halbtc8723b1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+		}
+	}
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+
+void halbtc8723b1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_busy = false;
+	u8			rssi_adjust_val = 0;
+	u8			ps_tdma_byte4_val = 0x50, ps_tdma_byte0_val = 0x51,
+				ps_tdma_byte3_val =  0x10;
+	s8			wifi_duration_adjust = 0x0;
+	static boolean	 pre_wifi_busy = false;
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+#if BT_8723B_1ANT_ANTDET_ENABLE
+#if BT_8723B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE
+	if (board_info->btdm_ant_num_by_ant_det == 2) {
+		if (turn_on)
+			type = type +
+			       100; /* for WiFi RSSI low or BT RSSI low */
+		else
+			type = 1; /* always translate to TDMA(off,1) for TDMA-off case */
+	}
+	
+#endif	
+#endif
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);	
+
+	if (wifi_busy != pre_wifi_busy) {
+		force_exec = true;
+		 pre_wifi_busy = wifi_busy;
+	}
+			
+	if (!force_exec) {
+		if( (coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+			(coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma) )
+			return;
+	}
+
+	if (coex_sta->scan_ap_num <= 5) {
+		wifi_duration_adjust = 5;
+		
+		if (coex_sta->a2dp_bit_pool >= 35)
+		  wifi_duration_adjust = -10;
+		else if (coex_sta->a2dp_bit_pool >= 45)
+		  wifi_duration_adjust = -15;	
+	} else if (coex_sta->scan_ap_num >= 40) {
+	 	wifi_duration_adjust = -15;	
+
+		if (coex_sta->a2dp_bit_pool < 35)
+		  wifi_duration_adjust = -5;
+		else if (coex_sta->a2dp_bit_pool < 45)
+		  wifi_duration_adjust = -10; 
+	} else if (coex_sta->scan_ap_num >= 20) {
+	 	wifi_duration_adjust = -10;	
+	
+		if (coex_sta->a2dp_bit_pool >= 45)
+		  wifi_duration_adjust = -15;
+	} else {
+		wifi_duration_adjust = 0;	       
+		
+		if (coex_sta->a2dp_bit_pool >= 35)
+		  wifi_duration_adjust = -10;
+		else if (coex_sta->a2dp_bit_pool >= 45)
+		  wifi_duration_adjust = -15;	
+	}
+	
+	if ((type == 1) || (type == 2) || (type == 9) || (type == 11) ||
+	    (type == 101)
+	    || (type == 102) || (type == 109) || (type == 101)) {
+		if (!coex_sta->force_lps_on) { /* Native power save TDMA, only for A2DP-only case 1/2/9/11 while wifi noisy threshold > 30 */
+			ps_tdma_byte0_val = 0x61;  /* no null-pkt */
+			ps_tdma_byte3_val = 0x11; /* no tx-pause at BT-slot */
+			ps_tdma_byte4_val =
+				0x10; /* 0x778 = d/1 toggle, no dynamic slot */
+		} else {
+			ps_tdma_byte0_val = 0x51;  /* null-pkt */
+			ps_tdma_byte3_val = 0x10; /* tx-pause at BT-slot */
+			ps_tdma_byte4_val =
+				0x50; /* 0x778 = d/1 toggle, dynamic slot */
+		}
+	} else if ((type == 3) || (type == 13) || (type == 14) ||
+		   (type == 103) || (type == 113) || (type == 114)) {
+		ps_tdma_byte0_val = 0x51;  /* null-pkt */
+		ps_tdma_byte3_val = 0x10; /* tx-pause at BT-slot */
+		ps_tdma_byte4_val =
+			0x10; /* 0x778 = d/1 toggle, no dynamic slot */
+#if 0
+		if (!wifi_busy)
+			ps_tdma_byte4_val = ps_tdma_byte4_val |
+				0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+#endif
+	} else { /* native power save case */
+		ps_tdma_byte0_val = 0x61;  /* no null-pkt */
+		ps_tdma_byte3_val = 0x11; /* no tx-pause at BT-slot */
+		ps_tdma_byte4_val =
+			0x11; /* 0x778 = d/1 toggle, no dynamic slot */
+		/* psTdmaByte4Va is not defne for 0x778 = d/1, 1/1 case */
+	}
+
+	/* if (bt_link_info->slave_role == true) */
+	if ((bt_link_info->slave_role == true)	&& (bt_link_info->a2dp_exist))
+		ps_tdma_byte4_val = ps_tdma_byte4_val |
+			0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+
+	if (type > 100) {
+		ps_tdma_byte0_val = ps_tdma_byte0_val |
+				    0x82; /* set antenna control by SW	 */
+		ps_tdma_byte3_val = ps_tdma_byte3_val |
+			0x60;  /* set antenna no toggle, control by antenna diversity */
+	}
+		
+
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x1a, 0x1a, 0x0, ps_tdma_byte4_val);
+			break;
+		case 1:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x3a +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 2:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x2d +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 3:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x30, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 4:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x14, 0x0);
+			break;
+		case 5:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x1f, 0x3,
+						      ps_tdma_byte3_val, 0x11);
+			break;
+		case 6:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x20, 0x3,
+						      ps_tdma_byte3_val, 0x11);
+			break;
+		case 7:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xc, 0x5, 0x0, 0x0);
+			break;
+		case 8:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 9:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 10:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0xa, 0x0, 0x40);
+			break;
+		case 11:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 12:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x0a, 0x0a, 0x0, 0x50);
+			break;
+		case 13:
+			if (coex_sta->scan_ap_num <= 3)
+				halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x40, 0x3,
+							      ps_tdma_byte3_val,
+						      ps_tdma_byte4_val);
+			else
+				halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+							      ps_tdma_byte3_val,
+						      ps_tdma_byte4_val);
+			break;
+		case 14:
+			if (coex_sta->scan_ap_num <= 3)
+				halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      0x51, 0x30, 0x3, 0x10, 0x50);
+			else
+				halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+							      ps_tdma_byte3_val,
+						      ps_tdma_byte4_val);
+			break;
+		case 15:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0x3, 0x8, 0x0);
+			break;
+		case 16:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x10, 0x0);
+			break;
+		case 18:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 20:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x3f, 0x03,
+						      ps_tdma_byte3_val, 0x10);
+			break;
+		case 21:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x11);
+			break;
+		case 22:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x25, 0x03,
+						      ps_tdma_byte3_val, 0x10);
+			break;
+		case 23:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x18);
+			break;
+		case 24:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x3, 0x31, 0x18);
+			break;
+		case 25:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 26:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 27:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x98);
+			break;
+		case 28:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x69,
+						      0x25, 0x3, 0x31, 0x0);
+			break;
+		case 29:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xab,
+						      0x1a, 0x1a, 0x1, 0x10);
+			break;
+		case 30:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x10);
+			break;
+		case 31:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1a, 0x1a, 0, 0x58);
+			break;
+		case 32:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x35, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 33:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x35, 0x3,
+						      ps_tdma_byte3_val, 0x10);
+			break;
+		case 34:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 35:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 36:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x12, 0x3, 0x14, 0x50);
+			break;
+		case 40: /* SoftAP only with no sta associated,BT disable ,TDMA mode for power saving */
+			/* here softap mode screen off will cost 70-80mA for phone */
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x23,
+						      0x18, 0x00, 0x10, 0x24);
+			break;
+
+		/* for 1-Ant translate to 2-Ant	 */
+		case 101:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x3a +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 102:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x2d +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 103:
+			/* halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x51, 0x1d, 0x1d, 0x0, ps_tdma_byte4_val); */
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x3a, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 105:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x15, 0x3,
+						      ps_tdma_byte3_val, 0x11);
+			break;
+		case 106:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x20, 0x3,
+						      ps_tdma_byte3_val, 0x11);
+			break;
+		case 109:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 111:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 113:
+			/* halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x51, 0x12, 0x12, 0x0, ps_tdma_byte4_val); */
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 114:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 120:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x3f, 0x03,
+						      ps_tdma_byte3_val, 0x10);
+			break;
+		case 122:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x25, 0x03,
+						      ps_tdma_byte3_val, 0x10);
+			break;
+		case 132:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x25, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 133:
+			halbtc8723b1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x25, 0x03,
+						      ps_tdma_byte3_val, 0x11);
+			break;
+
+		}
+	} else {
+
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 1: /* 2-Ant, 0x778=3, antenna control by antenna diversity */
+			halbtc8723b1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		}
+	}
+	rssi_adjust_val = 0;
+	btcoexist->btc_set(btcoexist,
+		BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE, &rssi_adjust_val);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+		    btcoexist->btc_read_4byte(btcoexist, 0x948),
+		    btcoexist->btc_read_1byte(btcoexist, 0x765),
+		    btcoexist->btc_read_1byte(btcoexist, 0x67));
+	BTC_TRACE(trace_buf);
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8723b1ant_tdma_duration_adjust_for_acl(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0, bt_info_ext;
+	boolean			wifi_busy = false;
+
+	if (BT_8723B_1ANT_WIFI_STATUS_CONNECTED_BUSY == wifi_status)
+		wifi_busy = true;
+	else
+		wifi_busy = false;
+
+	if ((BT_8723B_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN ==
+	     wifi_status) ||
+	    (BT_8723B_1ANT_WIFI_STATUS_CONNECTED_SCAN == wifi_status) ||
+	    (BT_8723B_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT ==
+	     wifi_status)) {
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 3 &&
+		    coex_dm->cur_ps_tdma != 9) {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						9);
+			coex_dm->ps_tdma_du_adj_type = 9;
+
+			up = 0;
+			dn = 0;
+			m = 1;
+			n = 3;
+			result = 0;
+			wait_count = 0;
+		}
+		return;
+	}
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 2);
+		coex_dm->ps_tdma_du_adj_type = 2;
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* accquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		bt_info_ext = coex_sta->bt_info_ext;
+
+		if ((coex_sta->low_priority_tx) > 1050 ||
+		    (coex_sta->low_priority_rx) > 1250)
+			retry_count++;
+
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (result == -1) {
+			/*		if( (BT_INFO_8723B_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+						((coex_dm->cur_ps_tdma == 1) ||(coex_dm->cur_ps_tdma == 2)) )
+					{
+						halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+						coex_dm->ps_tdma_du_adj_type = 9;
+					}
+					else */ if (coex_dm->cur_ps_tdma == 1) {
+				halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 11);
+				coex_dm->ps_tdma_du_adj_type = 11;
+			}
+		} else if (result == 1) {
+			/*			if( (BT_INFO_8723B_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+							((coex_dm->cur_ps_tdma == 1) ||(coex_dm->cur_ps_tdma == 2)) )
+						{
+							halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+							coex_dm->ps_tdma_du_adj_type = 9;
+						}
+						else */ if (coex_dm->cur_ps_tdma == 11) {
+				halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 1);
+				coex_dm->ps_tdma_du_adj_type = 1;
+			}
+		} else { /* no change */
+			/* Bryant Modify
+			if(wifi_busy != pre_wifi_busy)
+			{
+				pre_wifi_busy = wifi_busy;
+				halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, true, coex_dm->cur_ps_tdma);
+			}
+			*/
+
+		}
+
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 9 &&
+		    coex_dm->cur_ps_tdma != 11) {
+			/* recover to previous adjust type */
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		}
+	}
+}
+
+void halbtc8723b1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8723b1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8723b1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8723b1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8723b1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8723b1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+	halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, FORCE_EXEC,
+				     false, false);
+}
+
+void halbtc8723b1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+	} else {
+		bt_disable_cnt++;
+		if (bt_disable_cnt >= 2)
+			bt_disabled = true;
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+
+		coex_sta->bt_disabled = bt_disabled;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		if (bt_disabled) {
+			halbtc8723b1ant_action_wifi_only(btcoexist);
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+					   NULL);
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+					   NULL);
+		}
+	}
+}
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8723b1ant_action_bt_whck_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8723b1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8723b1ant_action_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8723b1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = false, ap_enable = false, wifi_busy = false,
+				bt_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	if (coex_sta->bt_abnormal_scan) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						33);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);				
+	} else if ((!wifi_connected) && (!coex_sta->wifi_is_high_pri_task)) {
+		halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+		   (bt_link_info->a2dp_exist)) {
+		/* SCO/HID/A2DP  busy */
+		halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+
+		if (coex_sta->c2h_bt_remote_name_req)
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						33);
+		else
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if ((bt_link_info->pan_exist) || (wifi_busy)) {
+		halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+
+		if (coex_sta->c2h_bt_remote_name_req)
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						33);
+		else
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+
+	}
+}
+
+void halbtc8723b1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/* tdma and coex table */
+
+	if (bt_link_info->sco_exist) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	} else { /* HID */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 6);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	}
+}
+
+void halbtc8723b1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	if ((coex_sta->low_priority_rx >= 950)  && (!coex_sta->under_ips))
+		bt_link_info->slave_role = true;
+	else
+		bt_link_info->slave_role = false;
+
+	if (bt_link_info->hid_only) { /* HID */
+		halbtc8723b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				wifi_status);
+		coex_dm->auto_tdma_adjust = false;
+		return;
+	} else if (bt_link_info->a2dp_only) { /* A2DP		 */
+		if (BT_8723B_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status) {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = false;
+		} else {
+			halbtc8723b1ant_tdma_duration_adjust_for_acl(btcoexist,
+					wifi_status);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = true;
+		}
+	} else if (((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+		coex_dm->auto_tdma_adjust = false;
+
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if ((bt_link_info->pan_only) || (bt_link_info->hid_exist &&
+		bt_link_info->pan_exist)) { /* PAN(OPP,FTP), HID+PAN(OPP,FTP)			 */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		/* BT no-profile busy (0x9) */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 33);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	}
+}
+
+void halbtc8723b1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	/* power save state */
+	halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8723b1ant_action_wifi_not_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if (BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8723B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8723b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8723B_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8723b1ant_action_wifi_not_connected_asso_auth(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist)  || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 4);
+	} else {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 2);
+	}
+}
+
+void halbtc8723b1ant_action_wifi_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if (BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8723B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8723b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8723B_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8723b1ant_action_wifi_connected_specific_packet(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* no specific packet process for both WiFi and BT very busy */
+	if ((wifi_busy) && ((bt_link_info->pan_exist) ||
+			    (coex_sta->num_of_profile >= 2)))
+		return;
+
+	halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist)) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	} else if (bt_link_info->a2dp_exist) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8723b1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	boolean	wifi_busy = false;
+	boolean		scan = false, link = false, roam = false;
+	boolean		under_4way = false, ap_enable = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+	if (under_4way) {
+		halbtc8723b1ant_action_wifi_connected_specific_packet(btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under 4way<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+	
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	if (scan || link || roam) {
+		if (scan)
+			halbtc8723b1ant_action_wifi_connected_scan(btcoexist);
+		else
+			halbtc8723b1ant_action_wifi_connected_specific_packet(
+				btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under scan<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	
+	/* power save state */
+	if (!ap_enable &&
+	    BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status &&
+	    !btcoexist->bt_link_info.hid_only) {
+		if (btcoexist->bt_link_info.a2dp_only) {	/* A2DP */
+			if (!wifi_busy)
+				halbtc8723b1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			else { /* busy */
+				if (coex_sta->scan_ap_num >=
+				    BT_8723B_1ANT_WIFI_NOISY_THRESH)  /* no force LPS, no PS-TDMA, use pure TDMA */
+					halbtc8723b1ant_power_save_state(
+						btcoexist, BTC_PS_WIFI_NATIVE,
+						0x0, 0x0);
+				else
+					halbtc8723b1ant_power_save_state(
+						btcoexist, BTC_PS_LPS_ON, 0x50,
+						0x4);
+			}
+		} else if ((coex_sta->pan_exist == false) &&
+			   (coex_sta->a2dp_exist == false) &&
+			   (coex_sta->hid_exist == false))
+			halbtc8723b1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		else
+			halbtc8723b1ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+	} else
+		halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+
+	/* tdma and coex table */
+	if (!wifi_busy) {
+		if (BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8723b1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8723B_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else if ((BT_8723B_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8723b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8723B_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else {
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8723b1ant_set_ant_path(btcoexist,
+				BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false);
+			/* if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60) */
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+			/* else
+				halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7); */
+		}
+	} else {
+		if (BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8723b1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8723B_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else if ((BT_8723B_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8723b1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8723B_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else {
+			/* halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8723b1ant_set_ant_path(btcoexist,
+				BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false);
+			if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60)
+				halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+			else
+				halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7); */
+			halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8723b1ant_set_ant_path(btcoexist,
+				BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false);
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+
+		}
+	}
+}
+
+void halbtc8723b1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, bt_hs_on = false, wifi_busy = false;
+	boolean	increase_scan_dev_num = false;
+	boolean	bt_ctrl_agg_buf_size = false;
+	boolean	miracast_plus_bt = false;
+	u8	agg_buf_size = 5;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0, wifi_bw;
+	u8	iot_peer = BTC_IOT_PEER_UNKNOWN;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b1ant_action_bt_whck_test(btcoexist);
+		return;
+	}
+
+	if ((BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8723B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		if (bt_link_info->bt_link_exist) {
+			halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1,
+						   0, 1);
+			miracast_plus_bt = true;
+		} else {
+			halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0,
+						   0, 0);
+			miracast_plus_bt = false;
+		}
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+
+		if (((bt_link_info->a2dp_exist) || (wifi_busy)) &&
+		    (coex_sta->c2h_bt_inquiry_page))
+			halbtc8723b1ant_action_bt_inquiry(btcoexist);
+		else
+			halbtc8723b1ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	} else {
+		miracast_plus_bt = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_link_info->bt_link_exist) && (wifi_connected)) {
+		halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1, 0, 1);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_IOT_PEER, &iot_peer);
+
+		/* if(BTC_IOT_PEER_CISCO != iot_peer)		 */
+		if ((BTC_IOT_PEER_CISCO != iot_peer) &&
+		    (BTC_IOT_PEER_BROADCOM != iot_peer)) {
+			if (bt_link_info->sco_exist) /* if (bt_link_info->bt_hi_pri_link_exist) */
+				/* halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, true, false, 0x5);				 */
+				halbtc8723b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, false, false, 0x5);
+			else
+				halbtc8723b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, false, false, 0x5);
+			/* halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, false, true, 0x8);		 */
+		} else {
+			if (bt_link_info->sco_exist)
+				halbtc8723b1ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, true, false, 0x5);
+			else {
+				if (BTC_WIFI_BW_HT40 == wifi_bw)
+					halbtc8723b1ant_limited_rx(btcoexist,
+						NORMAL_EXEC, false, true, 0x10);
+				else
+					halbtc8723b1ant_limited_rx(btcoexist,
+						NORMAL_EXEC, false, true, 0x8);
+			}
+		}
+
+		halbtc8723b1ant_sw_mechanism(btcoexist, true);
+	} else {
+		halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+		halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x5);
+
+		halbtc8723b1ant_sw_mechanism(btcoexist, false);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8723b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8723b1ant_action_hs(btcoexist);
+		return;
+	}
+
+
+	if (!wifi_connected) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is non connected-idle !!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (scan || link || roam) {
+			if (scan)
+				halbtc8723b1ant_action_wifi_not_connected_scan(
+					btcoexist);
+			else
+				halbtc8723b1ant_action_wifi_not_connected_asso_auth(
+					btcoexist);
+		} else
+			halbtc8723b1ant_action_wifi_not_connected(btcoexist);
+	} else	/* wifi LPS/Busy */
+		halbtc8723b1ant_action_wifi_connected(btcoexist);
+}
+
+void halbtc8723b1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+
+	/* sw all off */
+	halbtc8723b1ant_sw_mechanism(btcoexist, false);
+
+	/* halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8); */
+	/* halbtc8723b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0); */
+
+	coex_sta->pop_event_cnt = 0;
+}
+
+void halbtc8723b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up, IN boolean wifi_only)
+{
+	u32				u32tmp = 0; /* , fw_ver; */
+	u8				u8tmpa = 0, u8tmpb = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	psd_scan->ant_det_is_ant_det_available = false;
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x550, 0x8,
+					   0x1);  /* enable TBTT nterrupt */
+
+	/* 0x790[5:0]=0x5	 */
+	btcoexist->btc_write_1byte(btcoexist, 0x790, 0x5);
+
+	/* Enable counter statistics */
+	/* btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc); //0x76e[3] =1, WLAN_Act control by PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+
+
+	/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20, 0x1); //BT select s0/s1 is controlled by WiFi */
+
+	halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+
+	/* Antenna config */
+	if (wifi_only)
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_WIFI,
+					     FORCE_EXEC, true, false);
+	else
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, true, false);
+
+	/* PTA parameter */
+	halbtc8723b1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+	u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+		    u32tmp,  u8tmpa, u8tmpb);
+	BTC_TRACE(trace_buf);
+}
+
+void halbtc8723b1ant_mechanism_switch(IN struct btc_coexist *btcoexist,
+				      IN boolean bSwitchTo2Antenna)
+{
+
+	if (bSwitchTo2Antenna) { /* 1-Ant -> 2-Ant */
+		/* un-lock TRx Mask setup for 8723b f-cut */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdd, 0x80, 0x1);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdf, 0x1, 0x1);
+		/* WiFi TRx Mask on				 */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+
+		/* BT TRx Mask un-lock 0x2c[0], 0x30[0] = 1 */
+		btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x2c,
+					  0x7c45);
+		btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x30,
+					  0x7c45);
+
+		/* BT TRx Mask on */
+		btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x3c, 0x1);
+
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, false);
+	} else {
+		/* WiFi TRx Mask on				 */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x780);
+
+		/* lock TRx Mask setup for 8723b f-cut */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdd, 0x80, 0x0);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdf, 0x1, 0x0);
+
+		/* BT TRx Mask on */
+		btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x3c, 0x15);
+
+		/* BT TRx Mask ock 0x2c[0], 0x30[0]  = 0 */
+		btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x2c,
+					  0x7c44);
+		btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x30,
+					  0x7c44);
+
+
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+	}
+
+}
+
+u32 halbtc8723b1ant_psd_log2base(IN struct btc_coexist *btcoexist, IN u32 val)
+{
+	u8	j;
+	u32	tmp, tmp2, val_integerd_b = 0, tindex, shiftcount = 0;
+	u32	result, val_fractiond_b = 0, table_fraction[21] = {0, 432, 332, 274, 232, 200,
+				   174, 151, 132, 115, 100, 86, 74, 62, 51, 42,
+							   32, 23, 15, 7, 0
+							      };
+
+	if (val == 0)
+		return 0;
+
+	tmp = val;
+
+	while (1) {
+		if (tmp == 1)
+			break;
+		else {
+			tmp = (tmp >> 1);
+			shiftcount++;
+		}
+	}
+
+
+	val_integerd_b = shiftcount + 1;
+
+	tmp2 = 1;
+	for (j = 1; j <= val_integerd_b; j++)
+		tmp2 = tmp2 * 2;
+
+	tmp = (val * 100) / tmp2;
+	tindex = tmp / 5;
+
+	if (tindex > 20)
+		tindex = 20;
+
+	val_fractiond_b = table_fraction[tindex];
+
+	result = val_integerd_b * 100 - val_fractiond_b;
+
+	return result;
+
+
+}
+
+void halbtc8723b1ant_psd_show_antenna_detect_result(IN struct btc_coexist
+		*btcoexist)
+{	
+	u8		*cli_buf = btcoexist->cli_buf;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n============[Antenna Detection info]  ============\n");
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->ant_det_result == 1)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (>%d)",
+			   "Ant Det Result", "2-Antenna (Bad-Isolation)",
+			   BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION);
+	else if (psd_scan->ant_det_result == 2)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (%d~%d)",
+			   "Ant Det Result", "2-Antenna (Good-Isolation)",
+			   BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+			   + psd_scan->ant_det_thres_offset,
+			   BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION);
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (%d~%d)",
+			   "Ant Det Result", "1-Antenna",
+			   BT_8723B_1ANT_ANTDET_PSDTHRES_1ANT,
+			   BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+			   + psd_scan->ant_det_thres_offset);
+
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s ",
+		   "Antenna Detection Finish",
+		   (board_info->btdm_ant_det_finish
+		    ? "Yes" : "No"));
+	CL_PRINTF(cli_buf);
+
+	switch (psd_scan->ant_det_result) {
+	case 0:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is not available)");
+		break;
+	case 1:  /* 2-Ant bad-isolation */
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available)");
+		break;
+	case 2:  /* 2-Ant good-isolation */
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available)");
+		break;
+	case 3:  /* 1-Ant */
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is available)");
+		break;
+	case 4:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(Uncertainty result)");
+		break;
+	case 5:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "(Pre-Scan fai)");
+		break;
+	case 6:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(WiFi is Scanning)");
+		break;
+	case 7:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is not idle)");
+		break;
+	case 8:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(Abort by WiFi Scanning)");
+		break;
+	case 9:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(Antenna Init is not ready)");
+		break;
+	case 10:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is Inquiry or page)");
+		break;
+	case 11:
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "(BT is Disabled)");
+		break;
+	}
+	CL_PRINTF(cli_buf);	
+
+	
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Ant Detect Total Count", psd_scan->ant_det_try_count);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Ant Detect Fail Count", psd_scan->ant_det_fail_count);
+	CL_PRINTF(cli_buf);
+
+	if ((!board_info->btdm_ant_det_finish) &&
+	    (psd_scan->ant_det_result != 5))
+		return;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "BT Response",
+		   (psd_scan->ant_det_result ? "ok" : "fail"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ms", "BT Tx Time",
+		   psd_scan->ant_det_bt_tx_time);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "BT Tx Ch",
+		   psd_scan->ant_det_bt_le_channel);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d",
+		   "WiFi PSD Cent-Ch/Offset/Span",
+		   psd_scan->real_cent_freq, psd_scan->real_offset,
+		   psd_scan->real_span);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d dB",
+		   "PSD Pre-Scan Peak Value",
+		   psd_scan->ant_det_pre_psdscan_peak_val / 100);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s (<= %d)",
+		   "PSD Pre-Scan result",
+		   (psd_scan->ant_det_result != 5 ? "ok" : "fail"),
+		   BT_8723B_1ANT_ANTDET_PSDTHRES_BACKGROUND
+		   + psd_scan->ant_det_thres_offset);
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->ant_det_result == 5)
+		return;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s dB",
+		   "PSD Scan Peak Value", psd_scan->ant_det_peak_val);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s MHz",
+		   "PSD Scan Peak Freq", psd_scan->ant_det_peak_freq);
+	CL_PRINTF(cli_buf);
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "TFBGA Package",
+		   (board_info->tfbga_package) ?  "Yes" : "No");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "PSD Threshold Offset", psd_scan->ant_det_thres_offset);
+	CL_PRINTF(cli_buf);
+
+}
+
+void halbtc8723b1ant_psd_showdata(IN struct btc_coexist *btcoexist)
+{
+	u8		*cli_buf = btcoexist->cli_buf;
+	u32		delta_freq_per_point;
+	u32		freq, freq1, freq2, n = 0, i = 0, j = 0, m = 0, psd_rep1, psd_rep2;
+	
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n\n============[PSD info]  (%d)============\n",
+		   psd_scan->psd_gen_count);
+	CL_PRINTF(cli_buf);
+
+	if (psd_scan->psd_gen_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n No data !!\n");
+		CL_PRINTF(cli_buf);
+		return;
+	}
+
+	if (psd_scan->psd_point == 0)
+		delta_freq_per_point = 0;
+	else
+		delta_freq_per_point = psd_scan->psd_band_width /
+				       psd_scan->psd_point;
+
+	/* if (psd_scan->is_psd_show_max_only) */
+	if (0) {
+		psd_rep1 = psd_scan->psd_max_value / 100;
+		psd_rep2 = psd_scan->psd_max_value - psd_rep1 * 100;
+
+		freq = ((psd_scan->real_cent_freq - 20) * 1000000 +
+			psd_scan->psd_max_value_point * delta_freq_per_point);
+		freq1 = freq / 1000000;
+		freq2 = freq / 1000 - freq1 * 1000;
+
+		if (freq2 < 100)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n Freq = %d.0%d MHz",
+				   freq1, freq2);
+		else
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   "\r\n Freq = %d.%d MHz",
+				   freq1, freq2);
+
+		if (psd_rep2 < 10)
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   ", Value = %d.0%d dB, (%d)\n",
+				   psd_rep1, psd_rep2, psd_scan->psd_max_value);
+		else
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				   ", Value = %d.%d dB, (%d)\n",
+				   psd_rep1, psd_rep2, psd_scan->psd_max_value);
+
+		CL_PRINTF(cli_buf);
+	} else {
+		m = psd_scan->psd_start_point;
+		n = psd_scan->psd_start_point;
+		i = 1;
+		j = 1;
+
+		while (1) {
+			do {
+				freq = ((psd_scan->real_cent_freq - 20) * 1000000 + m *
+					delta_freq_per_point);
+				freq1 = freq / 1000000;
+				freq2 = freq / 1000 - freq1 * 1000;
+
+				if (i == 1) {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"\r\n Freq%6d.000", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"\r\n Freq%6d.0%2d", freq1,
+							   freq2);
+					else
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"\r\n Freq%6d.%3d", freq1,
+							   freq2);
+				} else if ((i % 8 == 0) ||
+					   (m == psd_scan->psd_stop_point)) {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							   "%6d.000\n", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%6d.0%2d\n", freq1, freq2);
+					else
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%6d.%3d\n", freq1, freq2);
+				} else {
+					if (freq2 == 0)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							   "%6d.000", freq1);
+					else if (freq2 < 100)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%6d.0%2d", freq1, freq2);
+					else
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%6d.%3d", freq1, freq2);
+				}
+
+				i++;
+				m++;
+				CL_PRINTF(cli_buf);
+
+			} while ((i <= 8) && (m <= psd_scan->psd_stop_point));
+
+
+			do {
+				psd_rep1 = psd_scan->psd_report_max_hold[n] / 100;
+				psd_rep2 = psd_scan->psd_report_max_hold[n] - psd_rep1 *
+					   100;
+
+				if (j == 1) {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"\r\n Val %7d.0%d", psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"\r\n Val %7d.%d", psd_rep1,
+							   psd_rep2);
+				} else if ((j % 8 == 0)  ||
+					   (n == psd_scan->psd_stop_point)) {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%7d.0%d\n", psd_rep1,
+							   psd_rep2);
+					else
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%7d.%d\n", psd_rep1, psd_rep2);
+				} else {
+					if (psd_rep2 < 10)
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%7d.0%d", psd_rep1, psd_rep2);
+					else
+						CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+							"%7d.%d", psd_rep1, psd_rep2);
+				}
+
+				j++;
+				n++;
+				CL_PRINTF(cli_buf);
+
+			} while ((j <= 8) && (n <= psd_scan->psd_stop_point));
+
+			if ((m > psd_scan->psd_stop_point) ||
+			    (n > psd_scan->psd_stop_point))
+				break;
+			else {
+				i = 1;
+				j = 1;
+			}
+
+		}
+	}
+
+
+}
+
+void halbtc8723b1ant_psd_max_holddata(IN struct btc_coexist *btcoexist,
+				      IN u32 gen_count)
+{
+	u32	i = 0, i_max = 0, val_max = 0;
+
+	if (gen_count == 1) {
+		memcpy(psd_scan->psd_report_max_hold,
+		       psd_scan->psd_report,
+		       BT_8723B_1ANT_ANTDET_PSD_POINTS * sizeof(u32));
+
+		psd_scan->psd_max_value_point = 0;
+		psd_scan->psd_max_value = 0;
+
+	} else {
+		for (i = psd_scan->psd_start_point;
+		     i <= psd_scan->psd_stop_point; i++) {
+			if (psd_scan->psd_report[i] >
+			    psd_scan->psd_report_max_hold[i])
+				psd_scan->psd_report_max_hold[i] =
+					psd_scan->psd_report[i];
+
+			/* search Max Value */
+			if (i == psd_scan->psd_start_point) {
+				i_max = i;
+				val_max = psd_scan->psd_report_max_hold[i];
+			} else {
+				if (psd_scan->psd_report_max_hold[i] >
+				    val_max) {
+					i_max = i;
+					val_max = psd_scan->psd_report_max_hold[i];
+				}
+			}
+
+		}
+
+		psd_scan->psd_max_value_point = i_max;
+		psd_scan->psd_max_value = val_max;
+
+	}
+
+
+}
+
+u32 halbtc8723b1ant_psd_getdata(IN struct btc_coexist *btcoexist, IN u32 point)
+{
+	/* reg 0x808[9:0]: FFT data x */
+	/* reg 0x808[22]: 0-->1 to get 1 FFT data y */
+	/* reg 0x8b4[15:0]: FFT data y report */
+
+	u32 val = 0, psd_report = 0;
+	int k = 0;
+
+	val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+
+	val &= 0xffbffc00;
+	val |= point;
+
+	btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+	val |= 0x00400000;
+	btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+	while (1) {
+		if (k++ > BT_8723B_1ANT_ANTDET_SWEEPPOINT_DELAY)
+			break;
+	}
+
+	val = btcoexist->btc_read_4byte(btcoexist, 0x8b4);
+
+	psd_report = val & 0x0000ffff;
+
+	return psd_report;
+}
+
+
+boolean halbtc8723b1ant_psd_sweep_point(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN s32 offset, IN u32 span, IN u32 points,
+					IN u32 avgnum, IN u32 loopcnt)
+{
+	u32	 i, val, n, k = 0, j, point_index = 0;
+	u32	points1 = 0, psd_report = 0;
+	u32	start_p = 0, stop_p = 0, delta_freq_per_point = 156250;
+	u32    psd_center_freq = 20 * 10 ^ 6;
+	boolean outloop = false, scan , roam, is_sweep_ok = true;
+	u8	 flag = 0;
+	u32	tmp;
+	u32	wifi_original_channel = 1;
+
+	psd_scan->is_psd_running = true;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx PSD Sweep Start!!\n");
+	BTC_TRACE(trace_buf);
+
+	do {
+		switch (flag) {
+		case 0:  /* Get PSD parameters */
+		default:
+
+			psd_scan->psd_band_width = 40 * 1000000;
+			psd_scan->psd_point = points;
+			psd_scan->psd_start_base = points / 2;
+			psd_scan->psd_avg_num = avgnum;
+			psd_scan->real_cent_freq = cent_freq;
+			psd_scan->real_offset = offset;
+			psd_scan->real_span = span;
+
+
+			points1 = psd_scan->psd_point;
+			delta_freq_per_point = psd_scan->psd_band_width /
+					       psd_scan->psd_point;
+
+			/* PSD point setup */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+			val &= 0xffff0fff;
+
+			switch (psd_scan->psd_point) {
+			case 128:
+				val |= 0x0;
+				break;
+			case 256:
+			default:
+				val |= 0x00004000;
+				break;
+			case 512:
+				val |= 0x00008000;
+				break;
+			case 1024:
+				val |= 0x0000c000;
+				break;
+			}
+
+			switch (psd_scan->psd_avg_num) {
+			case 1:
+				val |= 0x0;
+				break;
+			case 8:
+				val |= 0x00001000;
+				break;
+			case 16:
+				val |= 0x00002000;
+				break;
+			case 32:
+			default:
+				val |= 0x00003000;
+				break;
+			}
+			btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+			flag = 1;
+			break;
+		case 1:	  /* calculate the PSD point index from freq/offset/span */
+			psd_center_freq = psd_scan->psd_band_width / 2 +
+					  offset * (1000000);
+
+			start_p = psd_scan->psd_start_base + (psd_center_freq -
+				span * (1000000) / 2) / delta_freq_per_point;
+			psd_scan->psd_start_point = start_p -
+						    psd_scan->psd_start_base;
+
+			stop_p = psd_scan->psd_start_base + (psd_center_freq +
+				span * (1000000) / 2) / delta_freq_per_point;
+			psd_scan->psd_stop_point = stop_p -
+						   psd_scan->psd_start_base - 1;
+
+			flag = 2;
+			break;
+		case 2:  /* set RF channel/BW/Mode */
+
+			/* set 3-wire off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x88c);
+			val |= 0x00300000;
+			btcoexist->btc_write_4byte(btcoexist, 0x88c, val);
+
+			/* CCK off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x800);
+			val &= 0xfeffffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x800, val);
+
+			/* store WiFi original channel */
+			wifi_original_channel = btcoexist->btc_get_rf_reg(
+					btcoexist, BTC_RF_A, 0x18, 0x3ff);
+
+			/* Set RF channel */
+			if (cent_freq == 2484)
+				btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A,
+							  0x18, 0x3ff, 0xe);
+			else
+				btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A,
+					  0x18, 0x3ff, (cent_freq - 2412) / 5 +
+						  1); /* WiFi TRx Mask on */
+
+
+			/* Set RF Rx filter corner */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+						  0xfffff, 0x3e4);
+
+			/* Set TRx mask off */
+			/* un-lock TRx Mask setup */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdd,
+						  0x80, 0x1);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdf,
+						  0x1, 0x1);
+
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+
+			/* Set  RF mode = Rx, RF Gain = 0x8a0 */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x0,
+						  0xfffff, 0x308a0);
+
+			while (1) {
+				if (k++ > BT_8723B_1ANT_ANTDET_SWEEPPOINT_DELAY)
+					break;
+			}
+			flag = 3;
+			break;
+		case 3:
+			psd_scan->psd_gen_count = 0;
+			for (j = 1; j <= loopcnt; j++) {
+
+				btcoexist->btc_get(btcoexist,
+						   BTC_GET_BL_WIFI_SCAN, &scan);
+				btcoexist->btc_get(btcoexist,
+						   BTC_GET_BL_WIFI_ROAM, &roam);
+
+				if (scan || roam) {
+					is_sweep_ok = false;
+					break;
+				}
+				memset(psd_scan->psd_report, 0,
+				       psd_scan->psd_point * sizeof(u32));
+				start_p = psd_scan->psd_start_point +
+					  psd_scan->psd_start_base;
+				stop_p = psd_scan->psd_stop_point +
+					 psd_scan->psd_start_base + 1;
+
+				i = start_p;
+				point_index = 0;
+
+				while (i < stop_p) {
+					if (i >= points1)
+						psd_report =
+							halbtc8723b1ant_psd_getdata(
+							btcoexist, i - points1);
+					else
+						psd_report =
+							halbtc8723b1ant_psd_getdata(
+								btcoexist, i);
+
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"Point=%d, psd_raw_data = 0x%08x\n",
+						    i, psd_report);
+					BTC_TRACE(trace_buf);
+					if (psd_report == 0)
+						tmp = 0;
+					else
+						/* tmp =  20*log10((double)psd_report); */
+						/* 20*log2(x)/log2(10), log2Base return theresult of the psd_report*100 */
+						tmp = 6 * halbtc8723b1ant_psd_log2base(
+							btcoexist, psd_report);
+
+					n = i - psd_scan->psd_start_base;
+					psd_scan->psd_report[n] =  tmp;
+
+
+					halbtc8723b1ant_psd_max_holddata(
+						btcoexist, j);
+
+					i++;
+
+				}
+
+				psd_scan->psd_gen_count = j;
+			}
+
+			flag = 100;
+			break;
+		case 99:	/* error */
+
+			outloop = true;
+			break;
+		case 100: /* recovery */
+
+			/* set 3-wire on */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x88c);
+			val &= 0xffcfffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x88c, val);
+
+			/* CCK on */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x800);
+			val |= 0x01000000;
+			btcoexist->btc_write_4byte(btcoexist, 0x800, val);
+
+			/* PSD off */
+			val = btcoexist->btc_read_4byte(btcoexist, 0x808);
+			val &= 0xffbfffff;
+			btcoexist->btc_write_4byte(btcoexist, 0x808, val);
+
+			/* TRx Mask on */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x780);
+
+			/* lock TRx Mask setup */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdd,
+						  0x80, 0x0);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xdf,
+						  0x1, 0x0);
+
+			/* Set RF Rx filter corner */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+						  0xfffff, 0x0);
+
+			/* restore WiFi original channel */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x18,
+						  0x3ff, wifi_original_channel);
+
+			outloop = true;
+			break;
+
+		}
+
+	} while (!outloop);
+
+
+
+	psd_scan->is_psd_running = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "xxxxxxxxxxxxxxxx PSD Sweep Stop!!\n");
+	BTC_TRACE(trace_buf);
+	return is_sweep_ok;
+
+}
+
+void halbtc8723b1ant_psd_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 bt_tx_time, IN u32 bt_le_channel)
+{
+	u32	i = 0;
+	u32	wlpsd_cent_freq = 2484, wlpsd_span = 2, wlpsd_sweep_count = 50; 
+	s32 	wlpsd_offset = -4;
+	u8 	bt_le_ch[13] = {3,6,8,11,13,16,18,21,23,26,28,31,33};
+
+	u8	h2c_parameter[3] ={0},u8tmpa,u8tmpb;
+	
+	u8	state=0;
+	boolean		outloop = false, bt_resp = false;
+	u32		freq, freq1, freq2, psd_rep1, psd_rep2, delta_freq_per_point,
+			u32tmp;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	board_info->btdm_ant_det_finish = false;	
+	memset(psd_scan->ant_det_peak_val, 0, 16*sizeof(u8));
+	memset(psd_scan->ant_det_peak_freq, 0, 16*sizeof(u8));
+
+	if (board_info->tfbga_package) /* for TFBGA */
+		psd_scan->ant_det_thres_offset = 5;
+	else
+		psd_scan->ant_det_thres_offset = 0;
+
+	do {
+		switch (state) {
+		case 0:
+			if (bt_le_channel == 39)
+				wlpsd_cent_freq = 2484;
+			else {
+				for (i = 1; i <= 13; i++) {
+					if (bt_le_ch[i - 1] ==
+					    bt_le_channel) {
+						wlpsd_cent_freq = 2412
+								  + (i - 1) * 5;
+						break;
+					}
+				}
+
+				if (i == 14) {
+
+					BTC_SPRINTF(trace_buf,
+						    BT_TMP_BUF_SIZE,
+						"xxxxxxxxxxxxxxxx AntennaDetect(), Abort!!, Invalid LE channel = %d\n ",
+						    bt_le_channel);
+					BTC_TRACE(trace_buf);
+					outloop = true;
+					break;
+				}
+			}
+
+			wlpsd_sweep_count = bt_tx_time * 238 /
+					    100; /* bt_tx_time/0.42								 */
+			wlpsd_sweep_count = wlpsd_sweep_count / 5;
+
+			if (wlpsd_sweep_count % 5 != 0)
+				wlpsd_sweep_count = (wlpsd_sweep_count /
+						     5 + 1) * 5;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), BT_LETxTime=%d,  BT_LECh = %d\n",
+				    bt_tx_time, bt_le_channel);
+			BTC_TRACE(trace_buf);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), wlpsd_cent_freq=%d,  wlpsd_offset = %d, wlpsd_span = %d, wlpsd_sweep_count = %d\n",
+				    wlpsd_cent_freq,
+				    wlpsd_offset,
+				    wlpsd_span,
+				    wlpsd_sweep_count);
+			BTC_TRACE(trace_buf);
+
+			state = 1;
+			break;
+		case 1: /* stop coex DM & set antenna path */
+			/* Stop Coex DM */
+				btcoexist->stop_coex_dm = true;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Stop Coex DM!!\n");
+			BTC_TRACE(trace_buf);
+
+			/* set native power save */
+			halbtc8723b1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+
+			/* Set TDMA off,				 */
+			halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC,
+						false, 0);
+
+			/* Set coex table */
+			halbtc8723b1ant_coex_table_with_type(btcoexist,
+							     FORCE_EXEC, 0);
+
+			if (board_info->btdm_ant_pos ==
+			    BTC_ANTENNA_AT_MAIN_PORT) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna at Main Port\n");
+				BTC_TRACE(trace_buf);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna at Aux Port\n");
+				BTC_TRACE(trace_buf);
+			}
+
+			/* Set Antenna path, switch WiFi to un-certain antenna port */
+			halbtc8723b1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_BT, FORCE_EXEC, false,
+						     false);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set Antenna to BT!!\n");
+			BTC_TRACE(trace_buf);
+
+			/* Set AFH mask on at WiFi channel 2472MHz +/- 10MHz */
+			h2c_parameter[0] = 0x1;
+			h2c_parameter[1] = 0xd;
+			h2c_parameter[2] = 0x14;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set AFH on, Cent-Ch= %d,  Mask=%d\n",
+				    h2c_parameter[1],
+				    h2c_parameter[2]);
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x66, 3,
+						h2c_parameter);
+
+			u32tmp = btcoexist->btc_read_4byte(btcoexist,
+							   0x948);
+			u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+			u8tmpb = btcoexist->btc_read_1byte(btcoexist,
+							   0x778);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x778=0x%x\n",
+				    u32tmp,  u8tmpa, u8tmpb);
+			BTC_TRACE(trace_buf);
+
+			state = 2;
+			break;
+			case 2:	/* Pre-sweep background psd */
+			if (!halbtc8723b1ant_psd_sweep_point(btcoexist,
+				     wlpsd_cent_freq, wlpsd_offset, wlpsd_span,
+					     BT_8723B_1ANT_ANTDET_PSD_POINTS,
+				     BT_8723B_1ANT_ANTDET_PSD_AVGNUM, 3)) {
+				board_info->btdm_ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				psd_scan->ant_det_result = 8;
+				state = 99;
+				break;
+			}
+
+			psd_scan->ant_det_pre_psdscan_peak_val =
+				psd_scan->psd_max_value;
+
+			if (psd_scan->psd_max_value >
+			    (BT_8723B_1ANT_ANTDET_PSDTHRES_BACKGROUND
+			     + psd_scan->ant_det_thres_offset) * 100) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Abort Antenna Detection!! becaus background = %d > thres (%d)\n",
+					    psd_scan->psd_max_value / 100,
+					BT_8723B_1ANT_ANTDET_PSDTHRES_BACKGROUND
+					    + psd_scan->ant_det_thres_offset);
+				BTC_TRACE(trace_buf);
+				board_info->btdm_ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				psd_scan->ant_det_result = 5;
+				state = 99;
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Start Antenna Detection!! becaus background = %d <= thres (%d)\n",
+					    psd_scan->psd_max_value / 100,
+					BT_8723B_1ANT_ANTDET_PSDTHRES_BACKGROUND
+					    + psd_scan->ant_det_thres_offset);
+				BTC_TRACE(trace_buf);
+				state = 3;
+			}
+			break;
+			case 3:	
+			bt_resp = btcoexist->btc_set_bt_ant_detection(
+					  btcoexist, (u8)(bt_tx_time & 0xff),
+					  (u8)(bt_le_channel & 0xff));
+
+			if (!halbtc8723b1ant_psd_sweep_point(btcoexist,
+					     wlpsd_cent_freq, wlpsd_offset,
+							     wlpsd_span,
+					     BT_8723B_1ANT_ANTDET_PSD_POINTS,
+					     BT_8723B_1ANT_ANTDET_PSD_AVGNUM,
+						     wlpsd_sweep_count)) {
+				board_info->btdm_ant_det_finish
+					= false;
+				board_info->btdm_ant_num_by_ant_det
+					= 1;
+				psd_scan->ant_det_result = 8;
+				state = 99;
+				break;
+			}
+
+			psd_scan->ant_det_psd_scan_peak_val =
+				psd_scan->psd_max_value;
+			psd_scan->ant_det_psd_scan_peak_freq =
+				psd_scan->psd_max_value_point;
+			state = 4;
+			break;
+			case 4:				
+
+			if (psd_scan->psd_point == 0)
+				delta_freq_per_point = 0;
+			else
+				delta_freq_per_point =
+					psd_scan->psd_band_width /
+					psd_scan->psd_point;
+
+			psd_rep1 = psd_scan->psd_max_value / 100;
+			psd_rep2 = psd_scan->psd_max_value - psd_rep1 *
+				   100;
+
+			freq = ((psd_scan->real_cent_freq - 20) *
+				1000000 + psd_scan->psd_max_value_point
+				* delta_freq_per_point);
+			freq1 = freq / 1000000;
+			freq2 = freq / 1000 - freq1 * 1000;
+
+			if (freq2 < 100) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Max Value: Freq = %d.0%d MHz",
+					    freq1, freq2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_freq,
+					   BT_8723B_1ANT_ANTDET_BUF_LEN,
+					   "%d.0%d", freq1, freq2);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Max Value: Freq = %d.%d MHz",
+					    freq1, freq2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_freq,
+					   BT_8723B_1ANT_ANTDET_BUF_LEN,
+					   "%d.%d", freq1, freq2);
+			}
+
+			if (psd_rep2 < 10) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    ", Value = %d.0%d dB\n",
+					    psd_rep1, psd_rep2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_val,
+					   BT_8723B_1ANT_ANTDET_BUF_LEN,
+					   "%d.0%d", psd_rep1, psd_rep2);
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    ", Value = %d.%d dB\n",
+					    psd_rep1, psd_rep2);
+				BTC_TRACE(trace_buf);
+				CL_SPRINTF(psd_scan->ant_det_peak_val,
+					   BT_8723B_1ANT_ANTDET_BUF_LEN,
+					   "%d.%d", psd_rep1, psd_rep2);
+			}
+
+			psd_scan->ant_det_is_btreply_available = true;
+
+			if (bt_resp == false) {
+				psd_scan->ant_det_is_btreply_available =
+					false;
+				psd_scan->ant_det_result = 0;
+				board_info->btdm_ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), BT Response = Fail\n ");
+				BTC_TRACE(trace_buf);
+			} else if (psd_scan->psd_max_value >
+				(BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION)
+				   * 100) {
+				psd_scan->ant_det_result = 1;
+				board_info->btdm_ant_det_finish = true;
+				board_info->btdm_ant_num_by_ant_det = 2;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 2-Ant, Bad-Isolation!!\n");
+				BTC_TRACE(trace_buf);
+			} else if (psd_scan->psd_max_value >
+				(BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION
+				    + psd_scan->ant_det_thres_offset) * 100) {
+				psd_scan->ant_det_result = 2;
+				board_info->btdm_ant_det_finish = true;
+				board_info->btdm_ant_num_by_ant_det = 2;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 2-Ant, Good-Isolation!!\n");
+				BTC_TRACE(trace_buf);
+			} else if (psd_scan->psd_max_value >
+				   (BT_8723B_1ANT_ANTDET_PSDTHRES_1ANT) *
+				   100) {
+				psd_scan->ant_det_result = 3;
+				board_info->btdm_ant_det_finish = true;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 1-Ant!!\n");
+				BTC_TRACE(trace_buf);
+			} else {
+				psd_scan->ant_det_result = 4;
+				board_info->btdm_ant_det_finish = false;
+				board_info->btdm_ant_num_by_ant_det = 1;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Detect Result = 1-Ant, un-certainity!!\n");
+				BTC_TRACE(trace_buf);
+			}
+
+			state = 99;
+			break;
+		case 99:  /* restore setup */
+
+			/* Set AFH mask off at WiFi channel 2472MHz +/- 10MHz */
+			h2c_parameter[0] = 0x0;
+			h2c_parameter[1] = 0x0;
+			h2c_parameter[2] = 0x0;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set AFH on, Cent-Ch= %d,  Mask=%d\n",
+				    h2c_parameter[1], h2c_parameter[2]);
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_fill_h2c(btcoexist, 0x66, 3,
+						h2c_parameter);
+
+			/* Set Antenna Path					 */
+			halbtc8723b1ant_set_ant_path(btcoexist,
+				     BTC_ANT_PATH_PTA, FORCE_EXEC, false,
+						     false);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Set Antenna to PTA\n!!");
+			BTC_TRACE(trace_buf);
+
+			/* Resume Coex DM */
+			btcoexist->stop_coex_dm = false;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Resume Coex DM\n!!");
+			BTC_TRACE(trace_buf);
+
+			/* stimulate coex running */
+			halbtc8723b1ant_run_coexist_mechanism(
+				btcoexist);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Stimulate Coex running\n!!");
+			BTC_TRACE(trace_buf);
+
+			outloop = true;
+			break;
+		}
+
+	} while (!outloop);
+
+
+
+}
+
+void halbtc8723b1ant_psd_antenna_detection_check(IN struct btc_coexist
+		*btcoexist)
+{
+	static u32 ant_det_count = 0, ant_det_fail_count = 0;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	
+	boolean scan, roam;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+
+	/* psd_scan->ant_det_bt_tx_time = 20;  */
+	psd_scan->ant_det_bt_tx_time =
+		BT_8723B_1ANT_ANTDET_BTTXTIME;	   /* 0.42ms*50 = 20ms (0.42ms = 1 PSD sweep) */
+	psd_scan->ant_det_bt_le_channel = BT_8723B_1ANT_ANTDET_BTTXCHANNEL;		
+
+	ant_det_count++;
+	
+	psd_scan->ant_det_try_count = ant_det_count;	
+			
+	if (scan || roam) {
+		board_info->btdm_ant_det_finish = false;
+		psd_scan->ant_det_result = 6;
+	} else if (coex_sta->bt_disabled) {
+		board_info->btdm_ant_det_finish = false;
+		psd_scan->ant_det_result = 11;
+	} else if (coex_sta->num_of_profile >= 1) {
+		board_info->btdm_ant_det_finish = false;
+		psd_scan->ant_det_result = 7;
+	} else if (
+		!psd_scan->ant_det_is_ant_det_available) { /* Antenna initial setup is not ready */
+		board_info->btdm_ant_det_finish = false;
+		psd_scan->ant_det_result = 9;
+	} else if (coex_sta->c2h_bt_inquiry_page) {
+		board_info->btdm_ant_det_finish = false;
+		psd_scan->ant_det_result = 10;
+	} else
+		halbtc8723b1ant_psd_antenna_detection(btcoexist,
+					      psd_scan->ant_det_bt_tx_time,
+					      psd_scan->ant_det_bt_le_channel);
+
+	if (!board_info->btdm_ant_det_finish)
+		ant_det_fail_count++;
+
+	psd_scan->ant_det_fail_count = ant_det_fail_count;
+
+}
+
+
+/* ************************************************************
+ * work around function start with wa_halbtc8723b1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8723b1ant_
+ * ************************************************************ */
+void ex_halbtc8723b1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 				u8tmp=0x0;
+	u16 				u16tmp=0x0;
+	u32				value;
+       
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"xxxxxxxxxxxxxxxx Execute 8723b 1-Ant PowerOn Setting xxxxxxxxxxxxxxxx!!\n");
+	BTC_TRACE(trace_buf);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "Ant Det Finish = %s, Ant Det Number  = %d\n",
+		    (board_info->btdm_ant_det_finish ? "Yes" : "No"),
+		    board_info->btdm_ant_num_by_ant_det);
+	BTC_TRACE(trace_buf);
+
+	
+	btcoexist->stop_coex_dm = true;
+
+	btcoexist->btc_write_1byte(btcoexist, 0x67, 0x20);
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+	/* set GRAN_BT = 1 */
+	btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+	/* set WLAN_ACT = 0 */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);	
+
+	/*  */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+	if(btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+		
+		u8tmp |= 0x1;	/* antenna inverse */
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+	} else {
+		/* for PCIE and SDIO interface, we check efuse 0xc3[6] */
+		if (board_info->single_ant_path == 0) {
+			/* set to S1 */
+			btcoexist->btc_write_4byte(btcoexist, 0x948, 0x280);
+			board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+			value = 1;
+		} else if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+			u8tmp |= 0x1;	/* antenna inverse */
+			board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+			value = 0;
+		}
+
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ANTPOSREGRISTRY_CTRL,
+				   &value);
+		
+		if(btcoexist->chip_interface == BTC_INTF_PCI)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x384,
+							     u8tmp);
+		else if(btcoexist->chip_interface == BTC_INTF_SDIO)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60, 
+							     u8tmp);
+	}
+}
+
+void ex_halbtc8723b1ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8723b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8723b1ant_init_hw_config(btcoexist, true, wifi_only);
+	btcoexist->stop_coex_dm = false;
+}
+
+void ex_halbtc8723b1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = false;
+	
+	halbtc8723b1ant_init_coex_dm(btcoexist);
+
+	halbtc8723b1ant_query_bt_info(btcoexist);
+}
+
+void ex_halbtc8723b1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case=0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fa_ofdm, fa_cck;
+	u32				fw_ver=0, bt_patch_ver=0;
+	static u8		pop_report_in_10s = 0;	
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if(btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if(btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (psd_scan->ant_det_try_count == 0) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d",
+			   "Ant PG Num/ Mech/ Pos",
+			   board_info->pg_ant_num, board_info->btdm_ant_num,
+			   board_info->btdm_ant_pos);
+		CL_PRINTF(cli_buf);
+	} else {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d/ %d/ %d  (%d/%d/%d)",
+			   "Ant PG Num/ Mech(Ant_Det)/ Pos",
+			board_info->pg_ant_num, board_info->btdm_ant_num_by_ant_det,
+			   board_info->btdm_ant_pos,
+			psd_scan->ant_det_try_count, psd_scan->ant_det_fail_count,
+			   psd_scan->ant_det_result);
+		CL_PRINTF(cli_buf);
+
+		if (board_info->btdm_ant_det_finish) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+				   "Ant Det PSD Value",
+				   psd_scan->ant_det_peak_val);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%x/ 0x%x/ 0x%x(%d)/ %c",
+		   "Version Coex/ Fw/ Patch/ Cut",
+		   glcoex_ver_date_8723b_1ant, glcoex_ver_8723b_1ant, fw_ver,
+		   bt_patch_ver, bt_patch_ver, coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %s",
+		   "WifibHiPri/ Ccklock/ CckEverLock",
+		   (coex_sta->wifi_is_high_pri_task ? "Yes" : "No"),
+		   (coex_sta->cck_lock ? "Yes" : "No"),
+		   (coex_sta->cck_ever_lock ? "Yes" : "No"));
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Abnormal scan",
+		   (coex_sta->bt_abnormal_scan) ? "Yes" : "No");
+	CL_PRINTF(cli_buf);
+	
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d/ %d] ", 
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		((coex_sta->bt_disabled)? ("disabled"):	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8723B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8723B_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+	
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;	
+		pop_report_in_10s = 0;
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d / %d / %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP/NameReq/WHQL",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist,
+		   coex_sta->c2h_bt_remote_name_req,
+		   coex_sta->bt_whck_test);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Role",
+		   (bt_link_info->slave_role) ? "Slave" : "Master");
+	CL_PRINTF(cli_buf);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %d",
+		   "A2DP Rate/Bitpool",
+		(bt_info_ext & BIT(0)) ? "BR" : "EDR", coex_sta->a2dp_bit_pool);
+	CL_PRINTF(cli_buf);	
+
+	for (i = 0; i < BT_INFO_SRC_8723B_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8723b_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	
+	if(btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[mechanisms] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[mechanisms]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "SM[LowPenaltyRA]",
+		   coex_dm->cur_low_penalty_ra);
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	if (board_info->btdm_ant_num_by_ant_det == 2) {
+		if (coex_dm->cur_ps_tdma_on)
+			ps_tdma_case = ps_tdma_case +
+				100; /* for WiFi RSSI low or BT RSSI low */
+		else
+			ps_tdma_case =
+				1; /* always translate to TDMA(off,1) for TDMA-off case */
+	}
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (%s,%s)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "On" : "Off"),
+		   (coex_dm->auto_tdma_adjust ? "Adj" : "Fix"));
+
+	CL_PRINTF(cli_buf);
+		
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Coex Table Type",
+		   coex_sta->coex_table_type);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "IgnWlanAct",
+		   coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	/*
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ", "Latest error condition(should be 0)",
+		coex_dm->error_condition);
+	CL_PRINTF(cli_buf);
+	*/
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);	
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "backup ARFR1/ARFR2/RL/AMaxTime",
+		   coex_dm->backup_arfr_cnt1, coex_dm->backup_arfr_cnt2,
+		   coex_dm->backup_retry_limit,
+		   coex_dm->backup_ampdu_max_time);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x", 
+		   "0x430/0x434/0x42a/0x456",
+		   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6cc);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x880);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", 
+		   "0x778/0x6cc/0x880[29:25]",
+		   u8tmp[0], u32tmp[0], (u32tmp[1] & 0x3e000000) >> 25);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x948);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x67);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x764);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x948/ 0x67[5] / 0x764 / 0x76e",
+		   u32tmp[0], ((u8tmp[0] & 0x20) >> 5), (u32tmp[1] & 0xffff),
+		   u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x92c);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x930);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x944);	
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x92c[1:0]/ 0x930[7:0]/0x944[1:0]",
+		   u32tmp[0] & 0x3, u32tmp[1] & 0xff, u32tmp[2] & 0x3);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x39);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0x64);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x38[11]/0x40/0x4c[24:23]/0x64[0]",
+		   ((u8tmp[0] & 0x8) >> 3), u8tmp[1],
+		   ((u32tmp[0] & 0x01800000) >> 23), u8tmp[2] & 0x1);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x49c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xc50(dig)/0x49c(null-drop)",
+		   u32tmp[0] & 0xff, u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xda0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xda4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0xda8);
+	u32tmp[3] = btcoexist->btc_read_4byte(btcoexist, 0xcf0);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xa5b);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xa5c);
+
+	fa_ofdm = ((u32tmp[0] & 0xffff0000) >> 16) + ((u32tmp[1] & 0xffff0000)
+			>> 16) + (u32tmp[1] & 0xffff) + (u32tmp[2] & 0xffff) +
+		   ((u32tmp[3] & 0xffff0000) >> 16) + (u32tmp[3] &
+				   0xffff) ;
+	fa_cck = (u8tmp[0] << 8) + u8tmp[1];
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "OFDM-CCA/OFDM-FA/CCK-FA",
+		   u32tmp[0] & 0xffff, fa_ofdm, fa_cck);
+	CL_PRINTF(cli_buf);
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-Agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_agg);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-Agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_agg);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8723B_1ANT == 1)
+	/* halbtc8723b1ant_monitor_bt_ctr(btcoexist); */
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8723b1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if(btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723b1ant_init_hw_config(btcoexist, false, false);
+		halbtc8723b1ant_init_coex_dm(btcoexist);
+		halbtc8723b1ant_query_bt_info(btcoexist);
+
+		coex_sta->under_ips = false;
+	}
+}
+
+void ex_halbtc8723b1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if(btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8723b1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected=false, bt_hs_on=false;
+	u32	wifi_link_status=0;
+	u32	num_of_wifi_link=0;
+	boolean	bt_ctrl_agg_buf_size=false;
+	u8	agg_buf_size=5;
+
+	u8 u8tmpa, u8tmpb;
+	u32 u32tmp;
+
+	if(btcoexist->manual_control ||
+		btcoexist->stop_coex_dm )
+		return;
+
+	if (BTC_SCAN_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+		psd_scan->ant_det_is_ant_det_available = true;
+		halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+		u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+		u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x67);
+
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+			    u32tmp,  u8tmpa, u8tmpb);
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+	}	
+
+	if(coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED, 
+&wifi_connected);
+
+	halbtc8723b1ant_query_bt_info(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+ &wifi_link_status);
+	num_of_wifi_link = wifi_link_status>>16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8723b1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8723b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8723b1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8723b1ant_action_wifi_not_connected_scan(
+				btcoexist);
+		else	/* wifi is connected */
+			halbtc8723b1ant_action_wifi_connected_scan(btcoexist);
+	} else if (BTC_SCAN_FINISH == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8723b1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8723b1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8723b1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_connected=false, bt_hs_on=false;	
+	u32	wifi_link_status=0;
+	u32	num_of_wifi_link=0;
+	boolean	bt_ctrl_agg_buf_size=false;
+	u8	agg_buf_size=5;
+
+	if(btcoexist->manual_control ||
+		btcoexist->stop_coex_dm ||
+		coex_sta->bt_disabled )
+		return;
+
+	if (BTC_ASSOCIATE_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		psd_scan->ant_det_is_ant_det_available = true;
+		halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		/* coex_dm->arp_cnt = 0; */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8723b1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8723b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8723b1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_ASSOCIATE_START == type)
+		halbtc8723b1ant_action_wifi_not_connected_asso_auth(btcoexist);
+	else if (BTC_ASSOCIATE_FINISH == type) {
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+				   &wifi_connected);
+		if (!wifi_connected) /* non-connected scan */
+			halbtc8723b1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8723b1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8723b1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] ={0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	boolean			wifi_under_b_mode = false;
+
+	if(btcoexist->manual_control ||
+		btcoexist->stop_coex_dm ||
+		coex_sta->bt_disabled )
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+		psd_scan->ant_det_is_ant_det_available = true;
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+
+		coex_sta->cck_ever_lock = false;
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		/* h2c_parameter[0] = 0x1; */
+		h2c_parameter[0] = 0x0;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8723b1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	bt_hs_on=false;
+	u32	wifi_link_status=0;
+	u32	num_of_wifi_link=0;
+	boolean	bt_ctrl_agg_buf_size=false, under_4way=false;
+	u8	agg_buf_size=5;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if(btcoexist->manual_control ||
+		btcoexist->stop_coex_dm ||
+		coex_sta->bt_disabled )
+		return;
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    BTC_PACKET_ARP == type) {
+		if (BTC_PACKET_ARP == type) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], specific Packet ARP notify\n");
+			BTC_TRACE(trace_buf);
+
+			coex_dm->arp_cnt++;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], ARP Packet Count = %d\n",
+				    coex_dm->arp_cnt);
+			BTC_TRACE(trace_buf);
+
+			if ((coex_dm->arp_cnt >= 10) &&
+			    (!under_4way))  /* if APR PKT > 10 after connect, do not go to ActionWifiConnectedSpecificPacket(btcoexist) */
+				coex_sta->wifi_is_high_pri_task = false;
+			else
+				coex_sta->wifi_is_high_pri_task = true;
+		} else {
+			coex_sta->wifi_is_high_pri_task = true;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], specific Packet DHCP or EAPOL notify\n");
+			BTC_TRACE(trace_buf);
+		}
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet [Type = %d] notify\n", type);
+		BTC_TRACE(trace_buf);
+	}
+
+	coex_sta->specific_pkt_period_cnt = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8723b1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8723b1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8723b1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8723b1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8723b1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    ((BTC_PACKET_ARP == type) && (coex_sta->wifi_is_high_pri_task)))
+		halbtc8723b1ant_action_wifi_connected_specific_packet(btcoexist);
+}
+
+void ex_halbtc8723b1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				bt_info = 0;
+	u8				i, rsp_source=0;
+	boolean				wifi_connected=false;
+	boolean				bt_busy=false;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	rsp_source = tmp_buf[0]&0xf;
+	if(rsp_source >= BT_INFO_SRC_8723B_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8723B_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, 
+"[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source, 
+length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	/* if 0xff, it means BT is under WHCK test */
+	if (bt_info == 0xff)
+		coex_sta->bt_whck_test = true;
+	else
+		coex_sta->bt_whck_test = false;
+
+	if (BT_INFO_SRC_8723B_1ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2]&0xf;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->bt_info_c2h[rsp_source][2]&0x20)
+			coex_sta->c2h_bt_remote_name_req = true;
+		else
+			coex_sta->c2h_bt_remote_name_req = false;			
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3]*2-90;
+		/* coex_sta->bt_info_c2h[rsp_source][3]*2+10; */
+
+		coex_sta->bt_info_ext = 
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		if (coex_sta->bt_info_c2h[rsp_source][1] == 0x49) {
+			coex_sta->a2dp_bit_pool = 
+				coex_sta->bt_info_c2h[rsp_source][6]; 
+		} else
+			coex_sta->a2dp_bit_pool = 0;
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+
+#if BT_8723B_1ANT_ANTDET_ENABLE
+#if BT_8723B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE
+		if ((board_info->btdm_ant_det_finish) &&
+		    (board_info->btdm_ant_num_by_ant_det == 2)) {
+			if (coex_sta->bt_tx_rx_mask) {
+				/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x1\n");
+				BTC_TRACE(trace_buf);
+
+				/* BT TRx Mask un-lock 0x2c[0], 0x30[0] = 1 */
+				btcoexist->btc_set_bt_reg(btcoexist,
+						  BTC_BT_REG_RF, 0x2c, 0x7c45);
+				btcoexist->btc_set_bt_reg(btcoexist,
+						  BTC_BT_REG_RF, 0x30, 0x7c45);
+
+				btcoexist->btc_set_bt_reg(btcoexist,
+						  BTC_BT_REG_RF, 0x3c, 0x1);
+			}
+		} else
+#endif			
+#endif
+
+		{
+			if (!coex_sta->bt_tx_rx_mask) {
+				/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x15\n");
+				BTC_TRACE(trace_buf);
+				btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+							  0x3c, 0x15);
+
+				/* BT TRx Mask lock 0x2c[0], 0x30[0] = 0 */
+				btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+							  0x2c, 0x7c44);
+				btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+							  0x30, 0x7c44);
+			}
+		}
+		
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if (coex_sta->bt_info_ext & BIT(1)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8723b1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8723b1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+				
+		if (coex_sta->bt_info_ext & BIT(3)) {
+			if(!btcoexist->manual_control && 
+			    !btcoexist->stop_coex_dm) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8723b1ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+		}
+#if(BT_AUTO_REPORT_ONLY_8723B_1ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8723b1ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+		
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8723B_1ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	coex_sta->num_of_profile = 0;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8723B_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+
+		coex_sta->bt_hi_pri_link_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8723B_1ANT_B_FTP) {
+			coex_sta->pan_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8723B_1ANT_B_A2DP) {
+			coex_sta->a2dp_exist = true;	
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8723B_1ANT_B_HID) {
+			coex_sta->hid_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8723B_1ANT_B_SCO_ESCO) {
+			coex_sta->sco_exist = true;
+			coex_sta->num_of_profile++;
+		} else
+			coex_sta->sco_exist = false;
+
+		if ((coex_sta->hid_exist == false) &&
+		    (coex_sta->c2h_bt_inquiry_page == false) &&
+		    (coex_sta->sco_exist == false)) {
+			if (coex_sta->high_priority_tx  +
+			    coex_sta->high_priority_rx >= 160) {
+				coex_sta->hid_exist = true;
+				coex_sta->wrong_profile_notification++;
+				coex_sta->num_of_profile++;
+				bt_info = bt_info | 0x28;
+			}
+		}
+
+		/* Add Hi-Pri Tx/Rx counter to avoid false detection */
+		if (((coex_sta->hid_exist) || (coex_sta->sco_exist)) &&
+		    (coex_sta->high_priority_tx  +
+		     coex_sta->high_priority_rx >= 160)
+		    && (!coex_sta->c2h_bt_inquiry_page))
+			coex_sta->bt_hi_pri_link_exist = true;
+
+		if ((bt_info & BT_INFO_8723B_1ANT_B_ACL_BUSY) &&
+		    (coex_sta->num_of_profile == 0)) {
+			if (coex_sta->low_priority_tx  +
+			    coex_sta->low_priority_rx >= 160) {
+				coex_sta->pan_exist = true;
+				coex_sta->num_of_profile++;
+				coex_sta->wrong_profile_notification++;
+				bt_info = bt_info | 0x88;
+			}
+		}
+	}
+
+	halbtc8723b1ant_update_bt_link_info(btcoexist);
+	
+	bt_info = bt_info &
+		0x1f;  /* mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41) */
+	
+	if (!(bt_info & BT_INFO_8723B_1ANT_B_CONNECTION))
+		coex_dm->bt_status = BT_8723B_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+	else if (bt_info ==
+		BT_INFO_8723B_1ANT_B_CONNECTION)	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8723B_1ANT_BT_STATUS_CONNECTED_IDLE;
+	else if ((bt_info & BT_INFO_8723B_1ANT_B_SCO_ESCO) ||
+		 (bt_info & BT_INFO_8723B_1ANT_B_SCO_BUSY))
+		coex_dm->bt_status = BT_8723B_1ANT_BT_STATUS_SCO_BUSY;
+	else if (bt_info & BT_INFO_8723B_1ANT_B_ACL_BUSY) {
+		if(BT_8723B_1ANT_BT_STATUS_ACL_BUSY != coex_dm->bt_status)
+			coex_dm->auto_tdma_adjust = false;
+		coex_dm->bt_status = BT_8723B_1ANT_BT_STATUS_ACL_BUSY;
+	} else
+		coex_dm->bt_status = BT_8723B_1ANT_BT_STATUS_MAX;
+
+	if( (BT_8723B_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+		(BT_8723B_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		(BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status) )
+		bt_busy = true;
+	else
+		bt_busy = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	halbtc8723b1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8723b1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u32	u32tmp;
+	u8	u8tmpa,u8tmpb, u8tmpc;
+	
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+		
+		halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 
+0x0, 0x0);
+		halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, 
+FORCE_EXEC, false, true);
+		
+		halbtc8723b1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		btcoexist->stop_coex_dm = true;
+
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+		u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+ 		u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x67);
+		u8tmpc = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x, 0x76e=0x%x\n",
+			    u32tmp,  u8tmpa, u8tmpb, u8tmpc);
+		BTC_TRACE(trace_buf);
+
+	}
+}
+
+void ex_halbtc8723b1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8723b1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+	halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, FORCE_EXEC,
+				     false, true);
+
+	halbtc8723b1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8723b1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	btcoexist->stop_coex_dm = true;	
+}
+
+void ex_halbtc8723b1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723b1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8723b1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8723b1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+		halbtc8723b1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+		halbtc8723b1ant_init_hw_config(btcoexist, false, false);
+		halbtc8723b1ant_init_coex_dm(btcoexist);
+		halbtc8723b1ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8723b1ant_coex_dm_reset(IN struct btc_coexist *btcoexist)
+{
+
+	halbtc8723b1ant_init_hw_config(btcoexist, false, false);
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x2, 0xfffff, 0x0); */
+	halbtc8723b1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8723b1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ==========================Periodical===========================\n");
+	BTC_TRACE(trace_buf);
+
+#if(BT_AUTO_REPORT_ONLY_8723B_1ANT == 0)
+	halbtc8723b1ant_query_bt_info(btcoexist);
+	halbtc8723b1ant_monitor_bt_enable_disable(btcoexist);
+#else
+	halbtc8723b1ant_monitor_bt_ctr(btcoexist);
+	halbtc8723b1ant_monitor_wifi_ctr(btcoexist);
+#if BT_8723B_1ANT_ANTDET_ENABLE
+	halbtc8723b1ant_monitor_bt_enable_disable(btcoexist);
+#endif
+
+	if ((coex_sta->high_priority_tx  + coex_sta->high_priority_rx < 50) &&
+	    (bt_link_info->hid_exist == true))
+		bt_link_info->hid_exist  = false;
+
+	if( halbtc8723b1ant_is_wifi_status_changed(btcoexist) ||
+		coex_dm->auto_tdma_adjust )
+		halbtc8723b1ant_run_coexist_mechanism(btcoexist);	
+
+	coex_sta->specific_pkt_period_cnt++;
+
+	/* sample to set bt to execute Ant detection */
+	/* btcoexist->btc_set_bt_ant_detection(btcoexist, 20, 14);
+	*
+	if (psd_scan->is_ant_det_enable)
+	{
+		 if (psd_scan->psd_gen_count > psd_scan->realseconds)
+			psd_scan->psd_gen_count = 0;
+
+		halbtc8723b1ant_antenna_detection(btcoexist, psd_scan->realcent_freq,  psd_scan->realoffset, psd_scan->realspan,  psd_scan->realseconds);
+		psd_scan->psd_gen_total_count +=2;
+		psd_scan->psd_gen_count += 2;
+	}
+	*/	 	
+#endif
+}
+
+void ex_halbtc8723b1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds)
+{
+#if BT_8723B_1ANT_ANTDET_ENABLE	
+	static u32 ant_det_count = 0, ant_det_fail_count = 0;
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	/*boolean scan, roam;*/
+
+	if (seconds == 0) {
+		psd_scan->ant_det_try_count	= 0;
+		psd_scan->ant_det_fail_count	= 0;
+		ant_det_count = 0;
+		ant_det_fail_count = 0;
+		board_info->btdm_ant_det_finish = false;
+		board_info->btdm_ant_num_by_ant_det = 1;
+		return;
+	}
+
+	if (!board_info->btdm_ant_det_finish) {
+		psd_scan->ant_det_inteval_count =
+			psd_scan->ant_det_inteval_count + 2;
+
+		if (psd_scan->ant_det_inteval_count >=
+		    BT_8723B_1ANT_ANTDET_RETRY_INTERVAL) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Timer is up, Try Detect!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b1ant_psd_antenna_detection_check(btcoexist);
+
+			if (board_info->btdm_ant_det_finish) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Success!!\n");
+				BTC_TRACE(trace_buf);
+#if 1
+				if (board_info->btdm_ant_num_by_ant_det == 2)
+					halbtc8723b1ant_mechanism_switch(
+						btcoexist, true);
+				else
+					halbtc8723b1ant_mechanism_switch(
+						btcoexist, false);
+#endif
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Fail!!\n");
+				BTC_TRACE(trace_buf);
+			}
+			psd_scan->ant_det_inteval_count = 0;
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"xxxxxxxxxxxxxxxx AntennaDetect(), Antenna Det Timer is not up! (%d)\n",
+				    psd_scan->ant_det_inteval_count);
+			BTC_TRACE(trace_buf);
+		}
+
+	}
+#endif
+		
+		
+/*
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+
+		psd_scan->ant_det_bt_tx_time = seconds;
+	psd_scan->ant_det_bt_le_channel = cent_freq;		
+		
+	if (seconds == 0)
+		{
+		psd_scan->ant_det_try_count	= 0;
+		psd_scan->ant_det_fail_count	= 0;
+		ant_det_count = 0;
+		ant_det_fail_count = 0;
+		board_info->btdm_ant_det_finish = false;
+		board_info->btdm_ant_num_by_ant_det = 1;
+			 return;
+	}
+	else
+	{
+ 		ant_det_count++;
+	
+		psd_scan->ant_det_try_count = ant_det_count;	
+				
+			if (scan ||roam)
+		{
+			board_info->btdm_ant_det_finish = false;
+			psd_scan->ant_det_result = 6;
+		}
+		else if (coex_sta->num_of_profile >= 1) 
+		{
+			board_info->btdm_ant_det_finish = false;
+			psd_scan->ant_det_result = 7;
+		}			
+			else if (!psd_scan->ant_det_is_ant_det_available)
+		{
+			board_info->btdm_ant_det_finish = false;
+			psd_scan->ant_det_result = 9;
+		}				
+		else if (coex_sta->c2h_bt_inquiry_page)
+		{
+			board_info->btdm_ant_det_finish = false;
+			psd_scan->ant_det_result = 10;
+		}	
+		else
+		{
+
+	}
+
+		if (!board_info->btdm_ant_det_finish)
+			ant_det_fail_count++;
+
+		psd_scan->ant_det_fail_count = ant_det_fail_count;
+	}
+*/
+}
+
+
+void ex_halbtc8723b1ant_display_ant_detection(IN struct btc_coexist *btcoexist)
+{
+#if BT_8723B_1ANT_ANTDET_ENABLE
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+
+	if (psd_scan->ant_det_try_count != 0)	{
+		halbtc8723b1ant_psd_show_antenna_detect_result(btcoexist);
+
+		if (board_info->btdm_ant_det_finish)
+			halbtc8723b1ant_psd_showdata(btcoexist);
+		return;
+	}
+#endif
+	
+	/* halbtc8723b1ant_show_psd_data(btcoexist); */
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b1Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b1Ant.h
new file mode 100644
index 000000000..b0cd79dfd
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b1Ant.h
@@ -0,0 +1,288 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8723B_SUPPORT == 1)
+/* *******************************************
+ * The following is for 8723B 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8723B_1ANT				1
+
+#define	BT_INFO_8723B_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8723B_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8723B_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8723B_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8723B_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8723B_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8723B_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8723B_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8723B_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8723B_1ANT		2
+
+#define  BT_8723B_1ANT_WIFI_NOISY_THRESH								50 /* 30   //max: 255								 */
+
+/* for Antenna detection */
+#define	BT_8723B_1ANT_ANTDET_PSDTHRES_BACKGROUND						50
+#define	BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_BADISOLATION				70
+#define	BT_8723B_1ANT_ANTDET_PSDTHRES_2ANT_GOODISOLATION			55
+#define	BT_8723B_1ANT_ANTDET_PSDTHRES_1ANT							32
+#define	BT_8723B_1ANT_ANTDET_RETRY_INTERVAL							10	/* retry timer if ant det is fail, unit: second */
+#define	BT_8723B_1ANT_ANTDET_SWEEPPOINT_DELAY							40000  
+#define	BT_8723B_1ANT_ANTDET_ENABLE										1
+#define	BT_8723B_1ANT_ANTDET_COEXMECHANISMSWITCH_ENABLE				1
+#define	BT_8723B_1ANT_ANTDET_BTTXTIME									100
+#define	BT_8723B_1ANT_ANTDET_BTTXCHANNEL								39
+
+enum bt_info_src_8723b_1ant {
+	BT_INFO_SRC_8723B_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8723B_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8723B_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8723B_1ANT_MAX
+};
+
+enum bt_8723b_1ant_bt_status {
+	BT_8723B_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8723B_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8723B_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8723B_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8723B_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8723B_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8723b_1ant_wifi_status {
+	BT_8723B_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8723B_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8723B_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8723B_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8723B_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8723B_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8723B_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8723b_1ant_coex_algo {
+	BT_8723B_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8723B_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8723B_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8723B_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8723B_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8723B_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8723B_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8723B_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8723B_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8723B_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8723B_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8723B_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8723b_1ant {
+	/* hw setting */
+	u8		pre_ant_pos_type;
+	u8		cur_ant_pos_type;
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8723b_1ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+	boolean					bt_hi_pri_link_exist;
+	u8					num_of_profile;
+	boolean					bt_abnormal_scan;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	s8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8723B_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8723B_1ANT_MAX];
+	boolean					bt_whck_test;
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_remote_name_req;
+	boolean					wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_agg;
+	
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_agg;
+
+	boolean					cck_lock;
+	boolean					pre_ccklock;
+	boolean					cck_ever_lock;
+	u8					coex_table_type;
+
+	boolean					force_lps_on;
+	u32					wrong_profile_notification;
+
+	u8					a2dp_bit_pool;
+	u8					cut_version;
+};
+
+#define BT_8723B_1ANT_ANTDET_PSD_POINTS			256	/* MAX:1024 */
+#define BT_8723B_1ANT_ANTDET_PSD_AVGNUM		1	/* MAX:3 */
+#define	BT_8723B_1ANT_ANTDET_BUF_LEN			16
+
+struct psdscan_sta_8723b_1ant {
+
+	u32			ant_det_bt_le_channel;  /* BT LE Channel ex:2412 */
+	u32			ant_det_bt_tx_time;
+	u32			ant_det_pre_psdscan_peak_val;
+	boolean			ant_det_is_ant_det_available;
+	u32			ant_det_psd_scan_peak_val;
+	boolean			ant_det_is_btreply_available;
+	u32			ant_det_psd_scan_peak_freq;
+
+	u8			ant_det_result;
+	u8			ant_det_peak_val[BT_8723B_1ANT_ANTDET_BUF_LEN];
+	u8			ant_det_peak_freq[BT_8723B_1ANT_ANTDET_BUF_LEN];
+	u32			ant_det_try_count;
+	u32			ant_det_fail_count;
+	u32			ant_det_inteval_count;
+	u32			ant_det_thres_offset;
+
+	u32			real_cent_freq;
+	s32			real_offset;
+	u32			real_span;
+	
+	u32			psd_band_width;  /* unit: Hz */
+	u32			psd_point;		/* 128/256/512/1024 */
+	u32			psd_report[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_report_max_hold[1024];  /* unit:dB (20logx), 0~255 */
+	u32			psd_start_point;
+	u32			psd_stop_point;
+	u32			psd_max_value_point;
+	u32			psd_max_value;
+	u32			psd_start_base;
+	u32			psd_avg_num;	/* 1/8/16/32 */
+	u32			psd_gen_count;
+	boolean			is_psd_running;
+	boolean			is_psd_show_max_only;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8723b1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8723b1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8723b1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8723b1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8723b1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8723b1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723b1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723b1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8723b1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723b1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8723b1ant_coex_dm_reset(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b1ant_antenna_detection(IN struct btc_coexist *btcoexist,
+		IN u32 cent_freq, IN u32 offset, IN u32 span, IN u32 seconds);
+
+void ex_halbtc8723b1ant_display_ant_detection(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8723b1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8723b1ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8723b1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8723b1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8723b1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8723b1ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8723b1ant_halt_notify(btcoexist)
+#define	ex_halbtc8723b1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8723b1ant_coex_dm_reset(btcoexist)
+#define	ex_halbtc8723b1ant_periodical(btcoexist)
+#define	ex_halbtc8723b1ant_display_coex_info(btcoexist)
+#define	ex_halbtc8723b1ant_antenna_detection(btcoexist, cent_freq, offset, span, seconds)
+#define	ex_halbtc8723b1ant_display_ant_detection(btcoexist)
+
+#endif
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b2Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b2Ant.c
new file mode 100644
index 000000000..4dcdb980f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b2Ant.c
@@ -0,0 +1,4829 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8723B Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "Mp_Precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8723B_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8723b_2ant		glcoex_dm_8723b_2ant;
+static struct  coex_dm_8723b_2ant	*coex_dm = &glcoex_dm_8723b_2ant;
+static struct  coex_sta_8723b_2ant		glcoex_sta_8723b_2ant;
+static struct  coex_sta_8723b_2ant	*coex_sta = &glcoex_sta_8723b_2ant;
+
+const char *const glbt_info_src_8723b_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8723b_2ant = 20150923;
+u32	glcoex_ver_8723b_2ant = 0x46;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8723b2ant_
+ * ************************************************************ */
+u8 halbtc8723b2ant_bt_rssi_state(u8 *ppre_bt_rssi_state, u8 level_num,
+				 u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = *ppre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return *ppre_bt_rssi_state;
+		}
+
+		if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((*ppre_bt_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+			(*ppre_bt_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	*ppre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8723b2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 *pprewifi_rssi_state, IN u8 level_num, IN u8 rssi_thresh,
+				   IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = *pprewifi_rssi_state;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((*pprewifi_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return *pprewifi_rssi_state;
+		}
+
+		if ((*pprewifi_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((*pprewifi_rssi_state == BTC_RSSI_STATE_MEDIUM) ||
+			(*pprewifi_rssi_state == BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	*pprewifi_rssi_state = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8723b2ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean		bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 2)
+			bt_disabled = true;
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+
+		coex_sta->bt_disabled = bt_disabled;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		if (bt_disabled) {
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+					   NULL);
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+					   NULL);
+		}
+	}
+}
+
+
+void halbtc8723b2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+}
+
+void halbtc8723b2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if ((coex_sta->low_priority_tx > 1050)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	if ((coex_sta->low_priority_rx >= 950)  &&
+	    (coex_sta->low_priority_rx >= coex_sta->low_priority_tx) &&
+	    (!coex_sta->under_ips))
+		bt_link_info->slave_role = true;
+	else
+		bt_link_info->slave_role = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_hp_txrx, reg_hp_tx, reg_hp_tx, reg_hp_rx, reg_hp_rx);
+	BTC_TRACE(trace_buf);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_lp_txrx, reg_lp_tx, reg_lp_tx, reg_lp_rx, reg_lp_rx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+}
+
+void halbtc8723b2ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+
+
+	if (coex_sta->under_ips) {
+		coex_sta->crc_ok_cck = 0;
+		coex_sta->crc_ok_11g = 0;
+		coex_sta->crc_ok_11n = 0;
+		coex_sta->crc_ok_11n_agg = 0;
+
+		coex_sta->crc_err_cck = 0;
+		coex_sta->crc_err_11g = 0;
+		coex_sta->crc_err_11n = 0;
+		coex_sta->crc_err_11n_agg = 0;
+	} else {
+		coex_sta->crc_ok_cck	= btcoexist->btc_read_4byte(btcoexist,
+					  0xf88);
+		coex_sta->crc_ok_11g	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf94);
+		coex_sta->crc_ok_11n	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf90);
+		coex_sta->crc_ok_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					   0xfb8);
+
+		coex_sta->crc_err_cck	 = btcoexist->btc_read_4byte(btcoexist,
+					   0xf84);
+		coex_sta->crc_err_11g	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf96);
+		coex_sta->crc_err_11n	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf92);
+		coex_sta->crc_err_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					    0xfba);
+	}
+
+	/* reset counter */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xf16, 0x1, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xf16, 0x1, 0x0);
+}
+
+void halbtc8723b2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+boolean halbtc8723b2ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	boolean			wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean			wifi_connected = false;
+	u8			wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+
+
+		wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+				  &prewifi_rssi_state, 2,
+				  BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+				  coex_dm->switch_thres_offset, 0);
+
+		if ((BTC_RSSI_STATE_HIGH == wifi_rssi_state) ||
+		    (BTC_RSSI_STATE_LOW == wifi_rssi_state))
+			return true;
+
+	}
+
+	return false;
+}
+
+void halbtc8723b2ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8723b2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8723B_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8723B_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723B_2ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723B_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8723B_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				{
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8723B_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8723B_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8723b2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8723b2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				       IN u8 dec_bt_pwr_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = dec_bt_pwr_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x62, 1, h2c_parameter);
+}
+
+void halbtc8723b2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN u8 dec_bt_pwr_lvl)
+{
+	coex_dm->cur_bt_dec_pwr_lvl = dec_bt_pwr_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_dec_pwr_lvl == coex_dm->cur_bt_dec_pwr_lvl)
+			return;
+	}
+	halbtc8723b2ant_set_fw_dec_bt_pwr(btcoexist,
+					  coex_dm->cur_bt_dec_pwr_lvl);
+
+	coex_dm->pre_bt_dec_pwr_lvl = coex_dm->cur_bt_dec_pwr_lvl;
+}
+
+void halbtc8723b2ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8723b2ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8723b2ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8723b2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+			      IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8723b2ant_set_fw_dac_swing_level(btcoexist,
+					       coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+void halbtc8723b2ant_set_sw_rf_rx_lpf_corner(IN struct btc_coexist *btcoexist,
+		IN boolean rx_rf_shrink_on)
+{
+	if (rx_rf_shrink_on) {
+		/* Shrink RF Rx LPF corner */
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Shrink RF Rx LPF corner!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff,
+					  0xffffc);
+	} else {
+		/* Resume RF Rx LPF corner */
+		/* After initialized, we can use coex_dm->bt_rf_0x1e_backup */
+		if (btcoexist->initilized) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Resume RF Rx LPF corner!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+					  0xfffff, coex_dm->bt_rf_0x1e_backup);
+		}
+	}
+}
+
+void halbtc8723b2ant_rf_shrink(IN struct btc_coexist *btcoexist,
+		       IN boolean force_exec, IN boolean rx_rf_shrink_on)
+{
+	coex_dm->cur_rf_rx_lpf_shrink = rx_rf_shrink_on;
+
+	if (!force_exec) {
+		if (coex_dm->pre_rf_rx_lpf_shrink ==
+		    coex_dm->cur_rf_rx_lpf_shrink)
+			return;
+	}
+	halbtc8723b2ant_set_sw_rf_rx_lpf_corner(btcoexist,
+						coex_dm->cur_rf_rx_lpf_shrink);
+
+	coex_dm->pre_rf_rx_lpf_shrink = coex_dm->cur_rf_rx_lpf_shrink;
+}
+
+void halbtc8723b2ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf4;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf5;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf6;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8723b2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8723b2ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8723b2ant_set_dac_swing_reg(IN struct btc_coexist *btcoexist,
+				       IN u32 level)
+{
+	u8	val = (u8)level;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Write SwDacSwing = 0x%x\n", level);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x883, 0x3e, val);
+}
+
+void halbtc8723b2ant_set_sw_full_time_dac_swing(IN struct btc_coexist
+		*btcoexist, IN boolean sw_dac_swing_on, IN u32 sw_dac_swing_lvl)
+{
+	if (sw_dac_swing_on)
+		halbtc8723b2ant_set_dac_swing_reg(btcoexist, sw_dac_swing_lvl);
+	else
+		halbtc8723b2ant_set_dac_swing_reg(btcoexist, 0x18);
+}
+
+
+void halbtc8723b2ant_dac_swing(IN struct btc_coexist *btcoexist,
+	IN boolean force_exec, IN boolean dac_swing_on, IN u32 dac_swing_lvl)
+{
+	coex_dm->cur_dac_swing_on = dac_swing_on;
+	coex_dm->cur_dac_swing_lvl = dac_swing_lvl;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_dac_swing_on == coex_dm->cur_dac_swing_on) &&
+		    (coex_dm->pre_dac_swing_lvl ==
+		     coex_dm->cur_dac_swing_lvl))
+			return;
+	}
+	delay_ms(30);
+	halbtc8723b2ant_set_sw_full_time_dac_swing(btcoexist, dac_swing_on,
+			dac_swing_lvl);
+
+	coex_dm->pre_dac_swing_on = coex_dm->cur_dac_swing_on;
+	coex_dm->pre_dac_swing_lvl = coex_dm->cur_dac_swing_lvl;
+}
+
+void halbtc8723b2ant_set_adc_back_off(IN struct btc_coexist *btcoexist,
+				      IN boolean adc_back_off)
+{
+	if (adc_back_off) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc05, 0x30, 0x3);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc05, 0x30, 0x1);
+	}
+}
+
+void halbtc8723b2ant_adc_back_off(IN struct btc_coexist *btcoexist,
+			  IN boolean force_exec, IN boolean adc_back_off)
+{
+	coex_dm->cur_adc_back_off = adc_back_off;
+
+	if (!force_exec) {
+		if (coex_dm->pre_adc_back_off == coex_dm->cur_adc_back_off)
+			return;
+	}
+	halbtc8723b2ant_set_adc_back_off(btcoexist, coex_dm->cur_adc_back_off);
+
+	coex_dm->pre_adc_back_off = coex_dm->cur_adc_back_off;
+}
+
+void halbtc8723b2ant_set_agc_table(IN struct btc_coexist *btcoexist,
+				   IN boolean agc_table_en)
+{
+	u8		rssi_adjust_val = 0;
+
+	/* =================BB AGC Gain Table */
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6e1A0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6d1B0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6c1C0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6b1D0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6a1E0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x691F0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x68200001);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xaa1A0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa91B0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa81C0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa71D0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa61E0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa51F0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa4200001);
+	}
+
+
+	/* =================RF Gain */
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x02000);
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x38fff);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x38ffe);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x380c3);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x28ce6);
+	}
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xed, 0xfffff, 0x1);
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x38fff);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x38ffe);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x380c3);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x28ce6);
+	}
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xed, 0xfffff, 0x0);
+
+	/* set rssi_adjust_val for wifi module. */
+	if (agc_table_en)
+		rssi_adjust_val = 8;
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON,
+			   &rssi_adjust_val);
+}
+
+void halbtc8723b2ant_agc_table(IN struct btc_coexist *btcoexist,
+			       IN boolean force_exec, IN boolean agc_table_en)
+{
+	coex_dm->cur_agc_table_en = agc_table_en;
+
+	if (!force_exec) {
+		if (coex_dm->pre_agc_table_en == coex_dm->cur_agc_table_en)
+			return;
+	}
+	halbtc8723b2ant_set_agc_table(btcoexist, agc_table_en);
+
+	coex_dm->pre_agc_table_en = coex_dm->cur_agc_table_en;
+}
+
+void halbtc8723b2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8723b2ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8723b2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8723b2ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	coex_sta->coex_table_type = type;
+
+	switch (type) {
+	case 0:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5afa5afa, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x5ada5ada, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0xffffffff, 0xffffffff, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5fff5fff, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55ff55ff, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 8:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 9:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 10:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 11:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 12:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 13:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 14:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 15:
+		halbtc8723b2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8723b2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable) {
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8723b2ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8723b2ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8723b2ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8723b2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8723b2ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8723b2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+
+
+	if ((coex_sta->a2dp_exist) && (coex_sta->hid_exist))
+		byte5 = byte5 | 0x1;
+
+	h2c_parameter[0] = byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = byte5;
+
+	coex_dm->ps_tdma_para[0] = byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8723b2ant_sw_mechanism1(IN struct btc_coexist *btcoexist,
+			   IN boolean shrink_rx_lpf, IN boolean low_penalty_ra,
+			   IN boolean limited_dig, IN boolean bt_lna_constrain)
+{
+	/*
+	u32	wifi_bw;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if(BTC_WIFI_BW_HT40 != wifi_bw)
+	{
+		if (shrink_rx_lpf)
+			shrink_rx_lpf = false;
+	}
+	*/
+
+	/* halbtc8723b2ant_rf_shrink(btcoexist, NORMAL_EXEC, shrink_rx_lpf); */
+	halbtc8723b2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+void halbtc8723b2ant_sw_mechanism2(IN struct btc_coexist *btcoexist,
+			   IN boolean agc_table_shift, IN boolean adc_back_off,
+			   IN boolean sw_dac_swing, IN u32 dac_swing_lvl)
+{
+	/* halbtc8723b2ant_agc_table(btcoexist, NORMAL_EXEC, agc_table_shift); */
+	/* halbtc8723b2ant_adc_back_off(btcoexist, NORMAL_EXEC, adc_back_off); */
+	/* halbtc8723b2ant_dac_swing(btcoexist, NORMAL_EXEC, sw_dac_swing, dac_swing_lvl); */
+}
+
+void halbtc8723b2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			fw_ver = 0, u32tmp = 0;
+	boolean			pg_ext_switch = false;
+	boolean			use_ext_switch = false;
+	u8			h2c_parameter[2] = {0};
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_EXT_SWITCH, &pg_ext_switch);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER,
+			   &fw_ver);	/* [31:16]=fw ver, [15:0]=fw sub ver */
+
+	if ((fw_ver > 0 && fw_ver < 0xc0000) || pg_ext_switch)
+		use_ext_switch = true;
+
+	if (init_hwcfg) {
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x39, 0x8, 0x1);
+		btcoexist->btc_write_1byte(btcoexist, 0x974, 0xff);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x944, 0x3, 0x3);
+		btcoexist->btc_write_1byte(btcoexist, 0x930, 0x77);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20, 0x1);
+
+		if (fw_ver >= 0x180000) {
+			/* Use H2C to set GNT_BT to High to avoid A2DP click */
+			h2c_parameter[0] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1,
+						h2c_parameter);
+		} else
+			btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+
+		btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0); /* WiFi TRx Mask off */
+		/* remove due to interrupt is disabled that polling c2h will fail and delay 100ms. */
+		/* btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x3c, 0x01); //BT TRx Mask off */
+
+		if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT) {
+			/* tell firmware "no antenna inverse" */
+			h2c_parameter[0] = 0;
+		} else {
+			/* tell firmware "antenna inverse" */
+			h2c_parameter[0] = 1;
+		}
+
+		if (use_ext_switch) {
+			/* ext switch type */
+			h2c_parameter[1] = 1;
+		} else {
+			/* int switch type */
+			h2c_parameter[1] = 0;
+		}
+		btcoexist->btc_fill_h2c(btcoexist, 0x65, 2, h2c_parameter);
+	} else {
+		if (fw_ver >= 0x180000) {
+			/* Use H2C to set GNT_BT to "Control by PTA"*/
+			h2c_parameter[0] = 0;
+			btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1,
+						h2c_parameter);
+		} else
+			btcoexist->btc_write_1byte(btcoexist, 0x765, 0x0);
+	}
+
+	/* ext switch setting */
+	if (use_ext_switch) {
+		if (init_hwcfg) {
+			/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+			u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+			u32tmp &= ~BIT(23);
+			u32tmp |= BIT(24);
+			btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+		}
+
+		btcoexist->btc_write_4byte(btcoexist, 0x948,
+			   0x0); /* fixed internal switch S1->WiFi, S0->BT */
+		switch (ant_pos_type) {
+		case BTC_ANT_WIFI_AT_MAIN:
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0x92c, 0x3,
+					   0x1);	/* ext switch main at wifi */
+			break;
+		case BTC_ANT_WIFI_AT_AUX:
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0x92c, 0x3,
+					   0x2);	/* ext switch aux at wifi */
+			break;
+		}
+	} else {	/* internal switch */
+		if (init_hwcfg) {
+			/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+			u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+			u32tmp |= BIT(23);
+			u32tmp &= ~BIT(24);
+			btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+		}
+
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x64, 0x1,
+			   0x0); /* fixed external switch S1->Main, S0->Aux */
+		switch (ant_pos_type) {
+		case BTC_ANT_WIFI_AT_MAIN:
+			btcoexist->btc_write_4byte(btcoexist, 0x948,
+				0x0); /* fixed internal switch S1->WiFi, S0->BT */
+			break;
+		case BTC_ANT_WIFI_AT_AUX:
+			btcoexist->btc_write_4byte(btcoexist, 0x948,
+				0x280); /* fixed internal switch S0->WiFi, S1->BT */
+			break;
+		}
+	}
+}
+#if 0
+boolean halbtc8723b2ant_CoexSwitchThresCheck(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8 wifi_rssi_state1, bt_rssi_state;
+	u32 vendor;
+	u8 offset = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_VENDOR, &vendor);
+
+	/* if (vendor == BTC_VENDOR_LENOVO) */
+	/*	offset = 20; */
+
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+		&prewifi_rssi_state, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES
+			   - coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	if (BTC_RSSI_LOW(wifi_rssi_state1) || BTC_RSSI_LOW(bt_rssi_state))
+		return true;
+
+	return false;
+}
+#endif
+
+void halbtc8723b2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8			wifi_rssi_state1,  bt_rssi_state;
+	s8			wifi_duration_adjust = 0x0;
+	u8			psTdmaByte4Modify = 0x0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+		&prewifi_rssi_state, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES
+			   - coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], %s turn %s PS TDMA, type=%d\n",
+		(force_exec ? "force to" : ""), (turn_on ? "ON" : "OFF"), type);
+	BTC_TRACE(trace_buf);
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (!(BTC_RSSI_HIGH(wifi_rssi_state1) &&
+	      BTC_RSSI_HIGH(bt_rssi_state)) && turn_on)
+		/* if (halbtc8723b2ant_CoexSwitchThresCheck(btcoexist) &&  turn_on) */
+	{
+		type = type + 100; /* for WiFi RSSI low or BT RSSI low */
+		coex_dm->is_switch_to_1dot5_ant = true;
+	} else
+		coex_dm->is_switch_to_1dot5_ant = false;
+
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_sta->scan_ap_num <= 5) {
+		if (coex_sta->a2dp_bit_pool >= 45)
+			wifi_duration_adjust = -15;
+		else if (coex_sta->a2dp_bit_pool >= 35)
+			wifi_duration_adjust = -10;
+		else
+			wifi_duration_adjust = 5;
+	} else  if (coex_sta->scan_ap_num <= 20) {
+		if (coex_sta->a2dp_bit_pool >= 45)
+			wifi_duration_adjust = -15;
+		else if (coex_sta->a2dp_bit_pool >= 35)
+			wifi_duration_adjust = -10;
+		else
+			wifi_duration_adjust = 0;
+	} else if (coex_sta->scan_ap_num <= 40) {
+		if (coex_sta->a2dp_bit_pool >= 45)
+			wifi_duration_adjust = -15;
+		else if (coex_sta->a2dp_bit_pool >= 35)
+			wifi_duration_adjust = -10;
+		else
+			wifi_duration_adjust = -5;
+	} else {
+		if (coex_sta->a2dp_bit_pool >= 45)
+			wifi_duration_adjust = -15;
+		else if (coex_sta->a2dp_bit_pool >= 35)
+			wifi_duration_adjust = -10;
+		else
+			wifi_duration_adjust = -10;
+	}
+
+	if ((bt_link_info->slave_role == true)	&& (bt_link_info->a2dp_exist))
+		psTdmaByte4Modify =
+			0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+
+
+	if (turn_on) {
+		switch (type) {
+		case 1:
+		default:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x3c + wifi_duration_adjust, 0x03, 0xf1,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 2:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x2d + wifi_duration_adjust, 0x03, 0xf1,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 3:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 4:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x03, 0xf1,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 5:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x3c + wifi_duration_adjust, 0x3, 0x70,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 6:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x2d + wifi_duration_adjust, 0x3, 0x70,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 7:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x70,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 8:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x10, 0x3, 0x70,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 9:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x3c + wifi_duration_adjust, 0x03, 0xf1,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 10:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x2d + wifi_duration_adjust, 0x03, 0xf1,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 11:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 12:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0xf1,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 13:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x3c + wifi_duration_adjust, 0x3, 0x70,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 14:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x2d + wifi_duration_adjust, 0x3, 0x70,
+						      0x90 | psTdmaByte4Modify);
+			break;
+		case 15:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x70,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 16:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0x70,  0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 17:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x2f, 0x2f, 0x60, 0x90);
+			break;
+		case 18:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x5, 0x5, 0xe1, 0x90);
+			break;
+		case 19:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0xe1, 0x90);
+			break;
+		case 20:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0x60, 0x90);
+			break;
+		case 21:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x03, 0x70, 0x90);
+			break;
+
+		case 23:
+		case 123:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x35, 0x03, 0x71, 0x10);
+			break;
+		case 71:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+				      0x3c + wifi_duration_adjust, 0x03, 0xf1,
+						      0x90);
+			break;
+		case 101:
+		case 105:
+		case 113:
+		case 171:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xd3,
+				      0x3a + wifi_duration_adjust, 0x03, 0x70,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 102:
+		case 106:
+		case 110:
+		case 114:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xd3,
+				      0x2d + wifi_duration_adjust, 0x03, 0x70,
+						      0x50 | psTdmaByte4Modify);
+			break;
+		case 103:
+		case 107:
+		case 111:
+		case 115:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1c, 0x03, 0x70, 0x50 |
+						      psTdmaByte4Modify);
+			break;
+		case 104:
+		case 108:
+		case 112:
+		case 116:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x10, 0x03, 0x70, 0x50 |
+						      psTdmaByte4Modify);
+			break;
+		case 109:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90 |
+						      psTdmaByte4Modify);
+			break;
+		/* case 113:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0x70, 0x90 |
+						      psTdmaByte4Modify);
+			break; */
+		case 121:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x03, 0x70, 0x90 |
+						      psTdmaByte4Modify);
+			break;
+		case 22:
+		case 122:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x35, 0x03, 0x71, 0x11);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 0:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		case 1:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		default:
+			halbtc8723b2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8723b2ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8723b2ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8723b2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8723b2ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8723b2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+
+void halbtc8723b2ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* fw all off */
+	halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8723b2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+	halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8723b2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8723b2ant_dec_bt_pwr(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	coex_sta->pop_event_cnt = 0;
+
+}
+
+void halbtc8723b2ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	boolean	wifi_connected = false;
+	boolean	low_pwr_disable = true;
+	boolean		scan = false, link = false, roam = false;
+
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+			   &low_pwr_disable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+
+	halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	if (coex_sta->bt_abnormal_scan) {
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						23);
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);				
+	} else if (scan || link || roam) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi link process + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     15);
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+	} else if (wifi_connected) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     15);
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi no-link + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	}
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+	/*
+		coex_dm->need_recover0x948 = true;
+		coex_dm->backup0x948 = btcoexist->btc_read_4byte(btcoexist, 0x948);
+
+		halbtc8723b2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_AUX, false, false);
+	*/
+}
+
+
+void halbtc8723b2ant_action_wifi_link_process(IN struct btc_coexist *btcoexist)
+{
+	u32	u32tmp;
+	u8	u8tmpa, u8tmpb;
+
+	halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 15);
+	halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+	halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+	u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x76e=0x%x\n",
+		    u32tmp,  u8tmpa, u8tmpb);
+	BTC_TRACE(trace_buf);
+}
+
+boolean halbtc8723b2ant_action_wifi_idle_process(IN struct btc_coexist
+		*btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u8		ap_num = 0;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	/* wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist, 1, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES-coex_dm->switch_thres_offset-coex_dm->switch_thres_offset, 0); */
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+		coex_dm->switch_thres_offset - coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+		coex_dm->switch_thres_offset - coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM, &ap_num);
+
+	/* define the office environment */
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) &&
+	    (coex_sta->hid_exist == true) &&
+	    (coex_sta->a2dp_exist == true)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi  idle process for BT HID+A2DP exist!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8723b2ant_dac_swing(btcoexist, NORMAL_EXEC, true, 0x6);
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		/* sw all off */
+		halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+		return true;
+	} else {
+		halbtc8723b2ant_dac_swing(btcoexist, NORMAL_EXEC, true, 0x18);
+		return false;
+	}
+
+
+}
+
+
+
+boolean halbtc8723b2ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+	boolean			bt_hs_on = false, low_pwr_disable = false;
+	boolean			asus_8723b = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected) {
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non-connected idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+		halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		common = true;
+	} else {
+		if (BT_8723B_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status) {
+			low_pwr_disable = false;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+			halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, false, 0x8);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+			halbtc8723b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+			halbtc8723b2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+			halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 0xb);
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false,
+						      false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else if (BT_8723B_2ANT_BT_STATUS_CONNECTED_IDLE ==
+			   coex_dm->bt_status) {
+			low_pwr_disable = true;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+
+			if (bt_hs_on)
+				return false;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, false, 0x8);
+
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+			halbtc8723b2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+			halbtc8723b2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+			halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 0xb);
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else {
+			low_pwr_disable = true;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+
+			if (wifi_busy) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				/* btcoexist->btc_get(btcoexist,
+					BTC_GET_BL_IS_ASUS_8723B, &asus_8723b);
+				if (!asus_8723b) 
+					common = false;
+				else
+					common = halbtc8723b2ant_action_wifi_idle_process(
+							 btcoexist); */
+				common = false;
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				/* common = false;	 */
+				common = halbtc8723b2ant_action_wifi_idle_process(
+						 btcoexist);
+			}
+		}
+	}
+
+	return common;
+}
+void halbtc8723b2ant_tdma_duration_adjust(IN struct btc_coexist *btcoexist,
+		IN boolean sco_hid, IN boolean tx_pause, IN u8 max_interval)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0;
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+		{
+			if (sco_hid) {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					} else if (max_interval == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (max_interval == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					} else if (max_interval == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (max_interval == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			} else {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (max_interval == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (max_interval == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (max_interval == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (max_interval == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					}
+				}
+			}
+		}
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* accquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+
+		if ((coex_sta->low_priority_tx) > 1050 ||
+		    (coex_sta->low_priority_rx) > 1250)
+			retry_count++;
+
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (max_interval == 1) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 71) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 13);
+					coex_dm->ps_tdma_du_adj_type = 13;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 71);
+					coex_dm->ps_tdma_du_adj_type = 71;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 9);
+					coex_dm->ps_tdma_du_adj_type = 9;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 71) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 71);
+						coex_dm->ps_tdma_du_adj_type =
+							71;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					}
+				}
+			}
+		} else if (max_interval == 2) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					}
+				}
+			}
+		} else if (max_interval == 3) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8723b2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8723b2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			}
+		}
+	}
+
+	/* if current PsTdma not match with the recorded one (when scan, dhcp...), */
+	/* then we have to adjust it back to the previous record one. */
+	if (coex_dm->cur_ps_tdma != coex_dm->ps_tdma_du_adj_type) {
+		boolean	scan = false, link = false, roam = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], PsTdma type dismatch!!!, cur_ps_tdma=%d, recordPsTdma=%d\n",
+			    coex_dm->cur_ps_tdma, coex_dm->ps_tdma_du_adj_type);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (!scan && !link && !roam)
+			halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+}
+
+/* SCO only or SCO+PAN(HS) */
+void halbtc8723b2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8	wifi_rssi_state, bt_rssi_state;
+	u32	wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 4);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for SCO quality at 11b/g mode */
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else  /* for SCO quality & wifi performance balance at 11n mode */
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 8);
+
+	halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+				0); /* for voice quality */
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x4);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x4);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x4);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x4);
+		}
+	}
+}
+
+
+void halbtc8723b2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8	wifi_rssi_state, bt_rssi_state;
+	u32	wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for HID at 11b/g mode */
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	else  /* for HID quality & wifi performance balance at 11n mode */
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 9);
+
+	halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+	else
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8723b2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+	u8		ap_num = 0;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM, &ap_num);
+
+	/* define the office environment */
+	if ((ap_num >= 10) && BTC_RSSI_HIGH(wifi_rssi_state1) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+		/* dbg_print(" AP#>10(%d)\n", ap_num); */
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+		halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+		halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+		/* sw mechanism */
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x18);
+		}
+		return;
+
+	}
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	}
+
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+		halbtc8723b2ant_tdma_duration_adjust(btcoexist, false, false,
+						     1);
+	else
+		halbtc8723b2ant_tdma_duration_adjust(btcoexist, false, true, 1);
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8723b2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	}
+
+	halbtc8723b2ant_tdma_duration_adjust(btcoexist, false, true, 2);
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8723b2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     10);
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	}
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 1);
+	else
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+
+/* PAN(HS) only */
+void halbtc8723b2ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+
+	halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* PAN(EDR)+A2DP */
+void halbtc8723b2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	else
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     12);
+
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, false,
+							     true, 3);
+		else
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, false,
+							     false, 3);
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+		/* halbtc8723b2ant_tdma_duration_adjust(btcoexist, false, true, 3); */
+		halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+	}
+
+	/* sw mechanism	 */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8723b2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     14);
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	}
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		if (BTC_WIFI_BW_HT40 == wifi_bw) {
+			halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 3);
+			/* halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 11); */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x780);
+		} else {
+			halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 6);
+			/* halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7); */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+		}
+		halbtc8723b2ant_tdma_duration_adjust(btcoexist, true, false, 2);
+	} else {
+		halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		/* halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 14); */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+		halbtc8723b2ant_tdma_duration_adjust(btcoexist, true, true, 2);
+	}
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8723b2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1,  bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 2,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     14);
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true,
+							     true, 3);
+		else
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true,
+							     false, 3);
+	} else
+		halbtc8723b2ant_tdma_duration_adjust(btcoexist, true, true, 3);
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8723b2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	static u8	prewifi_rssi_state = BTC_RSSI_STATE_LOW,
+			prewifi_rssi_state1 = BTC_RSSI_STATE_LOW;
+	static u8	pre_bt_rssi_state = BTC_RSSI_STATE_LOW;
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+	u8		ap_num = 0;
+
+	wifi_rssi_state = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			  &prewifi_rssi_state, 2, 15, 0);
+	/* bt_rssi_state = halbtc8723b2ant_bt_rssi_state(2, 29, 0); */
+	wifi_rssi_state1 = halbtc8723b2ant_wifi_rssi_state(btcoexist,
+			   &prewifi_rssi_state1, 2,
+			   BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES -
+			   coex_dm->switch_thres_offset, 0);
+	bt_rssi_state = halbtc8723b2ant_bt_rssi_state(&pre_bt_rssi_state, 3,
+			BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES -
+			coex_dm->switch_thres_offset, 37);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+					   &ap_num);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8723b2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true, 0x5);
+
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) {
+		if (BTC_RSSI_HIGH(bt_rssi_state))
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	} else {
+		/* only 802.11N mode we have to dec bt power to 4 degree */
+		if (BTC_RSSI_HIGH(bt_rssi_state)) {
+			/* need to check ap Number of Not */
+			if (ap_num < 10)
+				halbtc8723b2ant_dec_bt_pwr(btcoexist,
+							   NORMAL_EXEC, 4);
+			else
+				halbtc8723b2ant_dec_bt_pwr(btcoexist,
+							   NORMAL_EXEC, 2);
+		} else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	}
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	} else {
+		halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     14);
+		halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	}
+
+	if(BTC_RSSI_HIGH(bt_rssi_state)) {
+		if(ap_num < 10)
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true, false, 1);
+		else
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true, false, 3);
+	} else {
+		halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 18);
+		btcoexist->btc_write_1byte(btcoexist, 0x456, 0x38);
+		btcoexist->btc_write_2byte(btcoexist, 0x42a, 0x0808);
+		btcoexist->btc_write_4byte(btcoexist, 0x430, 0x0);
+		btcoexist->btc_write_4byte(btcoexist, 0x434, 0x01010000);
+
+		if(ap_num < 10)
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true, true, 1);
+		else
+			halbtc8723b2ant_tdma_duration_adjust(btcoexist, true, true, 3);
+	}
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8723b2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8723b2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8723b2ant_action_bt_whck_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8723b2ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8723b2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8723b2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8723b2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8723b2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	halbtc8723b2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8723b2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8723b2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+}
+
+void halbtc8723b2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+	u32				num_of_wifi_link = 0;
+	u32				wifi_link_status = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean				miracast_plus_bt = false;
+	boolean				scan = false, link = false, roam = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_action_bt_whck_test(btcoexist);
+		return;
+	}
+
+	algorithm = halbtc8723b2ant_action_algorithm(btcoexist);
+	if (coex_sta->c2h_bt_inquiry_page &&
+	    (BT_8723B_2ANT_COEX_ALGO_PANHS != algorithm)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_action_bt_inquiry(btcoexist);
+		return;
+	} else {
+		/*
+			if(coex_dm->need_recover0x948)
+			{
+				coex_dm->need_recover0x948 = false;
+				btcoexist->btc_write_4byte(btcoexist, 0x948, coex_dm->backup0x948);
+			}
+		*/
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+	if (scan || link || roam) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under Link Process !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_action_wifi_link_process(btcoexist);
+		return;
+	}
+
+	/* for P2P */
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist)
+			miracast_plus_bt = true;
+		else
+			miracast_plus_bt = false;
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8723b2ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	} else {
+		miracast_plus_bt = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+	}
+
+	coex_dm->cur_algorithm = algorithm;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Algorithm = %d\n",
+		    coex_dm->cur_algorithm);
+	BTC_TRACE(trace_buf);
+
+	if (halbtc8723b2ant_is_common_action(btcoexist)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant common.\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		if (coex_dm->cur_algorithm != coex_dm->pre_algorithm) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], pre_algorithm=%d, cur_algorithm=%d\n",
+				coex_dm->pre_algorithm, coex_dm->cur_algorithm);
+			BTC_TRACE(trace_buf);
+			coex_dm->auto_tdma_adjust = false;
+		}
+		switch (coex_dm->cur_algorithm) {
+		case BT_8723B_2ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_sco(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_hid(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_a2dp(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_a2dp_pan_hs(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_pan_edr(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_pan_hs(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_pan_edr_a2dp(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_pan_edr_hid(btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_hid_a2dp_pan_edr(
+				btcoexist);
+			break;
+		case BT_8723B_2ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_action_hid_a2dp(btcoexist);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_coex_all_off(btcoexist);
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8723b2ant_wifi_off_hw_cfg(IN struct btc_coexist *btcoexist)
+{
+	boolean	is_in_mp_mode = false;
+	u8 h2c_parameter[2] = {0};
+	u32 fw_ver = 0;
+
+	/* set wlan_act to low */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+			  0x780); /* WiFi goto standby while GNT_BT 0-->1 */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	if (fw_ver >= 0x180000) {
+		/* Use H2C to set GNT_BT to HIGH */
+		h2c_parameter[0] = 1;
+		btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1, h2c_parameter);
+	} else
+		btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_IS_IN_MP_MODE,
+			   &is_in_mp_mode);
+	if (!is_in_mp_mode)
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+			   0x0); /* BT select s0/s1 is controlled by BT */
+	else
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x67, 0x20,
+			   0x1); /* BT select s0/s1 is controlled by WiFi */
+}
+
+void halbtc8723b2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up)
+{
+	u8	u8tmp = 0;
+	u32	 vendor;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_VENDOR, &vendor);
+	if (vendor == BTC_VENDOR_LENOVO)
+		coex_dm->switch_thres_offset = 0;
+	else if (vendor == BTC_VENDOR_ASUS)
+		coex_dm->switch_thres_offset = 0;
+	else
+		coex_dm->switch_thres_offset = 20;
+
+	/* 0xf0[15:12] --> Chip Cut information */
+	coex_sta->cut_version = (btcoexist->btc_read_1byte(btcoexist,
+				 0xf1) & 0xf0) >> 4;
+
+	/* backup rf 0x1e value */
+	coex_dm->bt_rf_0x1e_backup =
+		btcoexist->btc_get_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff);
+
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* Antenna config	 */
+	halbtc8723b2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN, true,
+				     false);
+	coex_sta->dis_ver_info_cnt = 0;
+
+	/* PTA parameter */
+	halbtc8723b2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	/* Enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e,
+			   0x4); /* 0x76e[3] =1, WLAN_Act control by PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x3);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8723b2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8723b2ant_
+ * ************************************************************ */
+void ex_halbtc8723b2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u16 u16tmp = 0x0;
+	u32				value = 0;
+
+	btcoexist->btc_write_1byte(btcoexist, 0x67, 0x20);
+
+	/* enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly. */
+	u16tmp = btcoexist->btc_read_2byte(btcoexist, 0x2);
+	btcoexist->btc_write_2byte(btcoexist, 0x2, u16tmp | BIT(0) | BIT(1));
+
+	btcoexist->btc_write_4byte(btcoexist, 0x948, 0x0);
+
+	if (btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+	} else {
+		/* for PCIE and SDIO interface, we check efuse 0xc3[6] */
+		if (board_info->single_ant_path == 0) {
+			/* set to S1 */
+			board_info->btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;
+		} else if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			board_info->btdm_ant_pos = BTC_ANTENNA_AT_AUX_PORT;
+		}
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ANTPOSREGRISTRY_CTRL,
+				   &value);
+	}
+}
+
+void ex_halbtc8723b2ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x4; /* Set BIT2 by default since it's 2ant case */
+
+	/*  */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+	if (btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		u8tmp |= 0x1;	/* antenna inverse */
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	} else {
+		/* for PCIE and SDIO interface, we check efuse 0xc3[6] */
+		if (board_info->single_ant_path == 0) {
+		} else if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			u8tmp |= 0x1;	/* antenna inverse */
+		}
+
+		if (btcoexist->chip_interface == BTC_INTF_PCI)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x384,
+							     u8tmp);
+		else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60,
+							     u8tmp);
+	}
+}
+
+void ex_halbtc8723b2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8723b2ant_init_hw_config(btcoexist, true);
+}
+
+void ex_halbtc8723b2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8723b2ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8723b2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u32				fa_of_dm, fa_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0;
+	static u8			pop_report_in_10s = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%x/ 0x%x/ 0x%x(%d)/ %c",
+		   "Version Coex/ Fw/ Patch/ Cut",
+		   glcoex_ver_date_8723b_2ant, glcoex_ver_8723b_2ant, fw_ver,
+		   bt_patch_ver, bt_patch_ver, coex_sta->cut_version + 65);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Abnormal scan",
+		   (coex_sta->bt_abnormal_scan) ? "Yes" : "No");
+	CL_PRINTF(cli_buf);
+	
+	pop_report_in_10s++;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt/ popCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8723B_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8723B_2ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt,
+		   coex_sta->pop_event_cnt);
+	CL_PRINTF(cli_buf);
+
+	if (pop_report_in_10s >= 5) {
+		coex_sta->pop_event_cnt = 0;
+		pop_report_in_10s = 0;
+	}
+
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d / %d / %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP/NameReq/WHQL",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist,
+		   coex_sta->c2h_bt_remote_name_req,
+		   coex_sta->bt_whck_test);
+	CL_PRINTF(cli_buf);
+
+	{
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+			   "BT Role",
+			   (bt_link_info->slave_role) ? "Slave" : "Master");
+		CL_PRINTF(cli_buf);
+	}
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %d",
+		   "A2DP Rate/Bitpool",
+		(bt_info_ext & BIT(0)) ? "BR" : "EDR", coex_sta->a2dp_bit_pool);
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8723B_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8723b_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	/* Sw mechanism	 */
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[Sw mechanism] (before Manual)============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[Sw mechanism]============");
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ",
+		   "SM1[ShRf/ LpRA/ LimDig]",
+		   coex_dm->cur_rf_rx_lpf_shrink, coex_dm->cur_low_penalty_ra,
+		   coex_dm->limited_dig);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ",
+		   "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]",
+		   coex_dm->cur_agc_table_en, coex_dm->cur_adc_back_off,
+		   coex_dm->cur_dac_swing_on, coex_dm->cur_dac_swing_lvl);
+	CL_PRINTF(cli_buf);
+
+	/* Fw mechanism		 */
+	if (btcoexist->manual_control)
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			"============[Fw mechanism] (before Manual) ============");
+	else
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[Fw mechanism]============");
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+
+	if (coex_dm->is_switch_to_1dot5_ant)
+		ps_tdma_case = ps_tdma_case + 100;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (%s,%s)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   (coex_dm->cur_ps_tdma_on ? "On" : "Off"),
+		   (coex_dm->auto_tdma_adjust ? "Adj" : "Fix"));
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Coex Table Type",
+		   coex_sta->coex_table_type);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "DecBtPwr/ IgnWlanAct",
+		   coex_dm->cur_bt_dec_pwr_lvl, coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x",
+		   "RF-A, 0x1e initVal",
+		   coex_dm->bt_rf_0x1e_backup);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x880);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x778/0x880[29:25]",
+		   u8tmp[0], (u32tmp[0] & 0x3e000000) >> 25);
+	CL_PRINTF(cli_buf);
+
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x948);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x67);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x948/ 0x67[5] / 0x765",
+		   u32tmp[0], ((u8tmp[0] & 0x20) >> 5), u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x92c);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x930);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x944);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x92c[1:0]/ 0x930[7:0]/0x944[1:0]",
+		   u32tmp[0] & 0x3, u32tmp[1] & 0xff, u32tmp[2] & 0x3);
+	CL_PRINTF(cli_buf);
+
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x39);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u8tmp[2] = btcoexist->btc_read_1byte(btcoexist, 0x64);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x38[11]/0x40/0x4c[24:23]/0x64[0]",
+		   ((u8tmp[0] & 0x8) >> 3), u8tmp[1],
+		   ((u32tmp[0] & 0x01800000) >> 23), u8tmp[2] & 0x1);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x49c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xc50(dig)/0x49c(null-drop)",
+		   u32tmp[0] & 0xff, u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xda0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xda4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0xda8);
+	u32tmp[3] = btcoexist->btc_read_4byte(btcoexist, 0xcf0);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xa5b);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xa5c);
+
+	fa_of_dm = ((u32tmp[0] & 0xffff0000) >> 16) + ((u32tmp[1] & 0xffff0000)
+			>> 16) + (u32tmp[1] & 0xffff) + (u32tmp[2] & 0xffff) + \
+		   ((u32tmp[3] & 0xffff0000) >> 16) + (u32tmp[3] &
+				   0xffff) ;
+	fa_cck = (u8tmp[0] << 8) + u8tmp[1];
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "OFDM-CCA/OFDM-FA/CCK-FA",
+		   u32tmp[0] & 0xffff, fa_of_dm, fa_cck);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-Agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_agg);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-Agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_agg);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8723B_2ANT == 1)
+	/* halbtc8723b2ant_monitor_bt_ctr(btcoexist); */
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8723b2ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		halbtc8723b2ant_wifi_off_hw_cfg(btcoexist);
+		halbtc8723b2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		halbtc8723b2ant_coex_all_off(btcoexist);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+		halbtc8723b2ant_init_hw_config(btcoexist, false);
+		halbtc8723b2ant_init_coex_dm(btcoexist);
+		halbtc8723b2ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8723b2ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8723b2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	u32	u32tmp;
+	u8	u8tmpa, u8tmpb;
+
+
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x948);
+	u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+	if (BTC_SCAN_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_SCAN_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x76e=0x%x\n",
+		    u32tmp,  u8tmpa, u8tmpb);
+	BTC_TRACE(trace_buf);
+}
+
+void ex_halbtc8723b2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	if (BTC_ASSOCIATE_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_ASSOCIATE_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8723b2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	u8			ap_num = 0;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] = 0x1;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else {
+			btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+					   &ap_num);
+			if (ap_num < 10)
+				h2c_parameter[2] = 0x30;
+			else
+				h2c_parameter[2] = 0x20;
+		}
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8723b2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	if (type == BTC_PACKET_DHCP) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], DHCP Packet notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8723b2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			bt_info = 0;
+	u8			i, rsp_source = 0;
+	boolean			bt_busy = false, limited_dig = false;
+	boolean			wifi_connected = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8723B_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8723B_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for Manual CTRL<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	/* if 0xff, it means BT is under WHCK test */
+	if (bt_info == 0xff)
+		coex_sta->bt_whck_test = true;
+	else
+		coex_sta->bt_whck_test = false;
+
+	if (BT_INFO_SRC_8723B_2ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x20)
+			coex_sta->c2h_bt_remote_name_req = true;
+		else
+			coex_sta->c2h_bt_remote_name_req = false;
+
+		if (coex_sta->bt_info_c2h[rsp_source][1] == 0x49) {
+			coex_sta->a2dp_bit_pool =
+				coex_sta->bt_info_c2h[rsp_source][6];
+		} else
+			coex_sta->a2dp_bit_pool = 0;
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+		if (coex_sta->bt_tx_rx_mask) {
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x01 => Need to switch BT TRx Mask */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x01\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+						  0x3c, 0x01);
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if ((coex_sta->bt_info_ext & BIT(1))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8723b2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8723b2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if ((coex_sta->bt_info_ext & BIT(3))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_ignore_wlan_act(btcoexist, FORCE_EXEC,
+							false);
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+		}
+#if (BT_AUTO_REPORT_ONLY_8723B_2ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8723b2ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8723B_2ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8723B_2ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8723B_2ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8723B_2ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8723B_2ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8723B_2ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+
+		if ((coex_sta->hid_exist == false) &&
+		    (coex_sta->c2h_bt_inquiry_page == false) &&
+		    (coex_sta->sco_exist == false)) {
+			if (coex_sta->high_priority_tx  +
+			    coex_sta->high_priority_rx >= 160) {
+				coex_sta->hid_exist = true;
+				bt_info = bt_info | 0x28;
+			}
+		}
+	}
+
+	halbtc8723b2ant_update_bt_link_info(btcoexist);
+
+	if (!(bt_info & BT_INFO_8723B_2ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8723B_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8723B_2ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8723B_2ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8723B_2ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8723B_2ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8723B_2ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8723B_2ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8723B_2ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8723B_2ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8723B_2ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8723B_2ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8723B_2ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status)) {
+		bt_busy = true;
+		limited_dig = true;
+	} else {
+		bt_busy = false;
+		limited_dig = false;
+	}
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	coex_dm->limited_dig = limited_dig;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_LIMITED_DIG, &limited_dig);
+
+	halbtc8723b2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8723b2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8723b2ant_wifi_off_hw_cfg(btcoexist);
+	/* remove due to interrupt is disabled that polling c2h will fail and delay 100ms. */
+	/* btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x3c, 0x15); //BT goto standby while GNT_BT 1-->0 */
+	halbtc8723b2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8723b2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+}
+
+void ex_halbtc8723b2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		halbtc8723b2ant_init_hw_config(btcoexist, false);
+		halbtc8723b2ant_init_coex_dm(btcoexist);
+		halbtc8723b2ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8723b2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ==========================Periodical===========================\n");
+	BTC_TRACE(trace_buf);
+	if (coex_sta->dis_ver_info_cnt <= 5) {
+		coex_sta->dis_ver_info_cnt += 1;
+		if (coex_sta->dis_ver_info_cnt == 3) {
+			/* Antenna config to set 0x765 = 0x0 (GNT_BT control by PTA) after initial */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Set GNT_BT control by PTA\n");
+			BTC_TRACE(trace_buf);
+			halbtc8723b2ant_set_ant_path(btcoexist,
+				     BTC_ANT_WIFI_AT_MAIN, false, false);
+		}
+	}
+
+#if (BT_AUTO_REPORT_ONLY_8723B_2ANT == 0)
+	halbtc8723b2ant_query_bt_info(btcoexist);
+	halbtc8723b2ant_monitor_bt_enable_disable(btcoexist);
+#else
+	halbtc8723b2ant_monitor_bt_ctr(btcoexist);
+	halbtc8723b2ant_monitor_wifi_ctr(btcoexist);
+
+	/* for some BT speaker that Hi-Pri pkt appear begore start play, this will cause HID exist */
+	if ((coex_sta->high_priority_tx  + coex_sta->high_priority_rx < 50) &&
+	    (bt_link_info->hid_exist == true))
+		bt_link_info->hid_exist  = false;
+
+	if (halbtc8723b2ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust)
+		halbtc8723b2ant_run_coexist_mechanism(btcoexist);
+#endif
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b2Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b2Ant.h
new file mode 100644
index 000000000..4fe39b295
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8723b2Ant.h
@@ -0,0 +1,214 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8723B_SUPPORT == 1)
+/* *******************************************
+ * The following is for 8723B 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8723B_2ANT				1
+
+
+#define	BT_INFO_8723B_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8723B_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8723B_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8723B_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8723B_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8723B_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8723B_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8723B_2ANT_B_CONNECTION				BIT(0)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT		2
+
+
+#define	BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES				42  /* WiFi RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation */
+#define	BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES				46 /* BT RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation */
+
+enum bt_info_src_8723b_2ant {
+	BT_INFO_SRC_8723B_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8723B_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8723B_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8723B_2ANT_MAX
+};
+
+enum bt_8723b_2ant_bt_status {
+	BT_8723B_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8723B_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8723B_2ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8723B_2ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8723B_2ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8723B_2ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8723B_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8723b_2ant_coex_algo {
+	BT_8723B_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8723B_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8723B_2ANT_COEX_ALGO_HID				= 0x2,
+	BT_8723B_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8723B_2ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8723B_2ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8723B_2ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8723B_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8723B_2ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8723B_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8723B_2ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8723B_2ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8723b_2ant {
+	/* fw mechanism */
+	u8		pre_bt_dec_pwr_lvl;
+	u8		cur_bt_dec_pwr_lvl;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		reset_tdma_adjust;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	u32		bt_rf_0x1e_backup;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	boolean		need_recover0x948;
+	u32		backup0x948;
+
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	boolean		is_switch_to_1dot5_ant;
+	u8		switch_thres_offset;
+};
+
+struct coex_sta_8723b_2ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+	boolean					bt_abnormal_scan;
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	u8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8723B_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8723B_2ANT_MAX];
+	boolean				bt_whck_test;
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_remote_name_req;
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_agg;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_agg;
+
+	u8					coex_table_type;
+	boolean					force_lps_on;
+
+	u8					dis_ver_info_cnt;
+
+	u8					a2dp_bit_pool;
+	u8					cut_version;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8723b2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b2ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8723b2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8723b2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8723b2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8723b2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8723b2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723b2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8723b2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8723b2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8723b2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8723b2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8723b2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8723b2ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8723b2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8723b2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8723b2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8723b2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8723b2ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8723b2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8723b2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8723b2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8723b2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8723b2ant_halt_notify(btcoexist)
+#define	ex_halbtc8723b2ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8723b2ant_periodical(btcoexist)
+#define	ex_halbtc8723b2ant_display_coex_info(btcoexist)
+
+#endif
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a1Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a1Ant.c
new file mode 100644
index 000000000..e094caa62
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a1Ant.c
@@ -0,0 +1,3457 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8812A Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "Mp_Precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8812A_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8812a_1ant		glcoex_dm_8812a_1ant;
+static struct  coex_dm_8812a_1ant	*coex_dm = &glcoex_dm_8812a_1ant;
+static struct  coex_sta_8812a_1ant		glcoex_sta_8812a_1ant;
+static struct  coex_sta_8812a_1ant	*coex_sta = &glcoex_sta_8812a_1ant;
+
+const char *const glbt_info_src_8812a_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8812a_1ant = 20140708;
+u32	glcoex_ver_8812a_1ant = 0x52;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8812a1ant_
+ * ************************************************************ */
+u8 halbtc8812a1ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8812a1ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8812a1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+/* to check 0x430/0x434 is correct?? */
+void halbtc8812a1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+/* to check 0x42a ?? */
+void halbtc8812a1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+/* to check 0x456?? */
+void halbtc8812a1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8812a1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8812a1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8812a1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8812a1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8812a1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8812a1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8812a1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8812a1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8812a1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8	data_len = 3;
+	u8	buf[5] = {0};
+
+	if (!coex_sta->bt_disabled) {
+		if (!coex_sta->bt_info_query_cnt ||
+		    (coex_sta->bt_info_c2h_cnt[BT_INFO_SRC_8812A_1ANT_BT_RSP]
+		     - coex_sta->bt_info_query_cnt) > 2) {
+			buf[0] = data_len;
+			buf[1] = 0x1;	/* polling enable, 1=enable, 0=disable */
+			buf[2] = 0x2;	/* polling time in seconds */
+			buf[3] = 0x1;	/* auto report enable, 1=enable, 0=disable */
+
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_INFO,
+					   (void *)&buf[0]);
+		}
+	}
+	coex_sta->bt_info_query_cnt++;
+}
+
+void halbtc8812a1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+	static u8		num_of_bt_counter_chk = 0;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if ((coex_sta->low_priority_tx > 1150)  &&
+	    (!coex_sta->c2h_bt_inquiry_page))
+		coex_sta->pop_event_cnt++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\n",
+		    reg_hp_rx, reg_hp_tx, reg_lp_rx, reg_lp_tx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+
+	if ((reg_hp_tx == 0) && (reg_hp_rx == 0) && (reg_lp_tx == 0) &&
+	    (reg_lp_rx == 0)) {
+		num_of_bt_counter_chk++;
+		if (num_of_bt_counter_chk >= 3) {
+			halbtc8812a1ant_query_bt_info(btcoexist);
+			num_of_bt_counter_chk = 0;
+		}
+	}
+}
+
+/* to check registers */
+void halbtc8812a1ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+	s32	wifi_rssi = 0;
+	boolean wifi_busy = false, wifi_under_b_mode = false;
+	static u8 cck_lock_counter = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+			   &wifi_under_b_mode);
+
+	if (coex_sta->under_ips) {
+		coex_sta->crc_ok_cck = 0;
+		coex_sta->crc_ok_11g = 0;
+		coex_sta->crc_ok_11n = 0;
+		coex_sta->crc_ok_11n_agg = 0;
+
+		coex_sta->crc_err_cck = 0;
+		coex_sta->crc_err_11g = 0;
+		coex_sta->crc_err_11n = 0;
+		coex_sta->crc_err_11n_agg = 0;
+	} else {
+		coex_sta->crc_ok_cck	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf04);
+		coex_sta->crc_ok_11g	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf14);
+		coex_sta->crc_ok_11n	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf10);
+		coex_sta->crc_ok_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					   0xf40);
+
+		coex_sta->crc_err_cck	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf06);
+		coex_sta->crc_err_11g	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf16);
+		coex_sta->crc_err_11n	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf12);
+		coex_sta->crc_err_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					    0xf42);
+	}
+
+
+	/* reset counter */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xb58, 0x1, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xb58, 0x1, 0x0);
+
+	if ((wifi_busy) && (wifi_rssi >= 30) && (!wifi_under_b_mode)) {
+		if ((coex_dm->bt_status == BT_8812A_1ANT_BT_STATUS_ACL_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+		    (coex_dm->bt_status ==
+		     BT_8812A_1ANT_BT_STATUS_SCO_BUSY)) {
+			if (coex_sta->crc_ok_cck > (coex_sta->crc_ok_11g +
+						    coex_sta->crc_ok_11n +
+						    coex_sta->crc_ok_11n_agg)) {
+				if (cck_lock_counter < 5)
+					cck_lock_counter++;
+			} else {
+				if (cck_lock_counter > 0)
+					cck_lock_counter--;
+			}
+
+		} else {
+			if (cck_lock_counter > 0)
+				cck_lock_counter--;
+		}
+	} else {
+		if (cck_lock_counter > 0)
+			cck_lock_counter--;
+	}
+
+	if (!coex_sta->pre_ccklock) {
+
+		if (cck_lock_counter >= 5)
+			coex_sta->cck_lock = true;
+		else
+			coex_sta->cck_lock = false;
+	} else {
+		if (cck_lock_counter == 0)
+			coex_sta->cck_lock = false;
+		else
+			coex_sta->cck_lock = true;
+	}
+
+	coex_sta->pre_ccklock =  coex_sta->cck_lock;
+
+
+}
+
+boolean halbtc8812a1ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void halbtc8812a1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8812a1ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8812A_1ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Profile = SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8812A_1ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_1ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_1ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8812A_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_1ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8812A_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! BT Profile = SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8812a1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8812a1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8812a1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+/* to check */
+void halbtc8812a1ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8	tmp_u1;
+
+	tmp_u1 = btcoexist->btc_read_1byte(btcoexist, 0x4fd);
+	tmp_u1 |= BIT(0);
+	if (low_penalty_ra) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Tx rate adaptive, set low penalty!!\n");
+		BTC_TRACE(trace_buf);
+		tmp_u1 &= ~BIT(2);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Tx rate adaptive, set normal!!\n");
+		BTC_TRACE(trace_buf);
+		tmp_u1 |= BIT(2);
+	}
+
+	btcoexist->btc_write_1byte(btcoexist, 0x4fd, tmp_u1);
+}
+
+void halbtc8812a1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8812a1ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8812a1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8812a1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8812a1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8812a1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** CoexTable(%d) **********\n", type);
+	BTC_TRACE(trace_buf);
+
+	coex_sta->coex_table_type = type;
+
+	switch (type) {
+	case 0:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaa5a5a, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0xaa5a5a5a, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8812a1ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8812a1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8	data_len = 3;
+	u8	buf[5] = {0};
+
+	buf[0] = data_len;
+	buf[1] = 0x1;			/* OP_Code */
+	buf[2] = 0x1;			/* OP_Code_Length */
+	if (enable)
+		buf[3] = 0x1;		/* OP_Code_Content */
+	else
+		buf[3] = 0x0;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_COEX,
+			   (void *)&buf[0]);
+}
+
+void halbtc8812a1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8812a1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8812a1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8812a1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8812a1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8812a1ant_sw_mechanism(IN struct btc_coexist *btcoexist,
+				  IN boolean low_penalty_ra)
+{
+	halbtc8812a1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+/* to check force_exec */
+void halbtc8812a1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean force_exec, IN boolean init_hwcfg,
+				  IN boolean wifi_off)
+{
+	u8			u8tmp = 0;
+
+	coex_dm->cur_ant_pos_type = ant_pos_type;
+
+	if (init_hwcfg) {
+		btcoexist->btc_write_1byte(btcoexist, 0xcb3, 0x77);
+		btcoexist->btc_write_4byte(btcoexist, 0x900, 0x00000400);
+		btcoexist->btc_write_1byte(btcoexist, 0x76d, 0x1);
+	} else if (wifi_off) {
+		btcoexist->btc_write_1byte(btcoexist, 0xcb3, 0x77);
+		u8tmp = btcoexist->btc_read_1byte(btcoexist, 0xcb7);
+		u8tmp &= ~BIT(3);
+		u8tmp |= BIT(2);
+		btcoexist->btc_write_1byte(btcoexist, 0xcb7, u8tmp);
+	}
+
+	if (force_exec ||
+	    (coex_dm->cur_ant_pos_type != coex_dm->pre_ant_pos_type)) {
+		/* ext switch setting */
+		switch (ant_pos_type) {
+		case BTC_ANT_PATH_WIFI:
+			u8tmp = btcoexist->btc_read_1byte(btcoexist,
+							  0xcb7);
+			u8tmp |= BIT(3);
+			u8tmp &= ~BIT(2);
+			btcoexist->btc_write_1byte(btcoexist, 0xcb7,
+						   u8tmp);
+			break;
+		case BTC_ANT_PATH_BT:
+			u8tmp = btcoexist->btc_read_1byte(btcoexist,
+							  0xcb7);
+			u8tmp &= ~BIT(3);
+			u8tmp |= BIT(2);
+			btcoexist->btc_write_1byte(btcoexist, 0xcb7,
+						   u8tmp);
+			break;
+		default:
+		case BTC_ANT_PATH_PTA:
+			u8tmp = btcoexist->btc_read_1byte(btcoexist,
+							  0xcb7);
+			u8tmp |= BIT(3);
+			u8tmp &= ~BIT(2);
+			btcoexist->btc_write_1byte(btcoexist, 0xcb7,
+						   u8tmp);
+			break;
+		}
+	}
+
+	coex_dm->pre_ant_pos_type = coex_dm->cur_ant_pos_type;
+}
+
+void halbtc8812a1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for 1Ant AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+		}
+	}
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+
+void halbtc8812a1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_busy = false;
+	u8			rssi_adjust_val = 0;
+	u8			ps_tdma_byte4_val = 0x50, ps_tdma_byte0_val = 0x51,
+				ps_tdma_byte3_val =  0x10;
+	s8			wifi_duration_adjust = 0x0;
+	static boolean	 pre_wifi_busy = false;
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (wifi_busy != pre_wifi_busy) {
+		force_exec = true;
+		pre_wifi_busy = wifi_busy;
+	}
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+
+	if (coex_sta->scan_ap_num <= 5)
+		wifi_duration_adjust = 2;
+	else if (coex_sta->scan_ap_num >= 40)
+		wifi_duration_adjust = -15;
+	else if (coex_sta->scan_ap_num >= 20)
+		wifi_duration_adjust = -10;
+
+	if (!coex_sta->force_lps_on) { /* only for A2DP-only case 1/2/9/11 while wifi noisy threshold > 30 */
+		ps_tdma_byte0_val = 0x61;  /* no null-pkt */
+		ps_tdma_byte3_val = 0x11; /* no tx-pause at BT-slot */
+		ps_tdma_byte4_val = 0x10; /* 0x778 = d/1 toggle */
+	}
+
+	if ((type == 3) || (type == 13) || (type == 14)) {
+		ps_tdma_byte4_val = ps_tdma_byte4_val &
+			    0xbf;  /* no dynamic slot for multi-profile */
+
+		if (!wifi_busy)
+			ps_tdma_byte4_val = ps_tdma_byte4_val |
+				0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+	}
+
+	if (bt_link_info->slave_role == true)
+		ps_tdma_byte4_val = ps_tdma_byte4_val |
+			0x1;  /* 0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts) */
+
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x1a, 0x1a, 0x0, ps_tdma_byte4_val);
+			break;
+		case 1:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x3a +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 2:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist,
+						      ps_tdma_byte0_val, 0x2d +
+					      wifi_duration_adjust, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 3:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x1d, 0x1d, 0x0, ps_tdma_byte4_val);
+			break;
+		case 4:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x14, 0x0);
+			break;
+		case 5:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x15, 0x3, 0x11, 0x11);
+			break;
+		case 6:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x20, 0x3, 0x11, 0x11);
+			break;
+		case 7:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xc, 0x5, 0x0, 0x0);
+			break;
+		case 8:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 9:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x3,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 10:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0xa, 0x0, 0x40);
+			break;
+		case 11:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist,
+					      ps_tdma_byte0_val, 0x21, 0x03,
+				      ps_tdma_byte3_val, ps_tdma_byte4_val);
+			break;
+		case 12:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x0a, 0x0a, 0x0, 0x50);
+			break;
+		case 13:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x12, 0x12, 0x0, ps_tdma_byte4_val);
+			break;
+		case 14:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x51,
+				      0x21, 0x3, 0x10, ps_tdma_byte4_val);
+			break;
+		case 15:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0x3, 0x8, 0x0);
+			break;
+		case 16:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x10, 0x0);
+			break;
+		case 18:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 20:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x3f, 0x03, 0x11, 0x10);
+			break;
+		case 21:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x11);
+			break;
+		case 22:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x10);
+			break;
+		case 23:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x18);
+			break;
+		case 24:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x3, 0x31, 0x18);
+			break;
+		case 25:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 26:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			break;
+		case 27:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x98);
+			break;
+		case 28:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x69,
+						      0x25, 0x3, 0x31, 0x0);
+			break;
+		case 29:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xab,
+						      0x1a, 0x1a, 0x1, 0x10);
+			break;
+		case 30:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x10);
+			break;
+		case 31:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1a, 0x1a, 0, 0x58);
+			break;
+		case 32:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x3, 0x11, 0x11);
+			break;
+		case 33:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x25, 0x3, 0x30, 0x90);
+			break;
+		case 34:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 35:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 36:
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x12, 0x3, 0x14, 0x50);
+			break;
+		case 40: /* SoftAP only with no sta associated,BT disable ,TDMA mode for power saving */
+			/* here softap mode screen off will cost 70-80mA for phone */
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x23,
+						      0x18, 0x00, 0x10, 0x24);
+			break;
+		}
+	} else {
+
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8812a1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		}
+	}
+	rssi_adjust_val = 0;
+	btcoexist->btc_set(btcoexist,
+		BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE, &rssi_adjust_val);
+
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+boolean halbtc8812a1ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8812A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8812a1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8812A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8812a1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (!wifi_connected &&
+		(BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8812a1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (wifi_connected &&
+		(BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8812a1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else if (!wifi_connected &&
+		(BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE != coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non connected-idle + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8812a1ant_sw_mechanism(btcoexist, false); */
+
+		common = true;
+	} else {
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		common = false;
+	}
+
+	return common;
+}
+
+
+void halbtc8812a1ant_tdma_duration_adjust_for_acl(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0, bt_info_ext;
+	boolean			wifi_busy = false;
+
+	if (BT_8812A_1ANT_WIFI_STATUS_CONNECTED_BUSY == wifi_status)
+		wifi_busy = true;
+	else
+		wifi_busy = false;
+
+	if ((BT_8812A_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN ==
+	     wifi_status) ||
+	    (BT_8812A_1ANT_WIFI_STATUS_CONNECTED_SCAN == wifi_status) ||
+	    (BT_8812A_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT ==
+	     wifi_status)) {
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 3 &&
+		    coex_dm->cur_ps_tdma != 9) {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						9);
+			coex_dm->ps_tdma_du_adj_type = 9;
+
+			up = 0;
+			dn = 0;
+			m = 1;
+			n = 3;
+			result = 0;
+			wait_count = 0;
+		}
+		return;
+	}
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 2);
+		coex_dm->ps_tdma_du_adj_type = 2;
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* accquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		bt_info_ext = coex_sta->bt_info_ext;
+
+		if ((coex_sta->low_priority_tx) > 1150 ||
+		    (coex_sta->low_priority_rx) > 1250)
+			retry_count++;
+
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (result == -1) {
+			if ((BT_INFO_8812A_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+			    ((coex_dm->cur_ps_tdma == 1) ||
+			     (coex_dm->cur_ps_tdma == 2))) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 1) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 11);
+				coex_dm->ps_tdma_du_adj_type = 11;
+			}
+		} else if (result == 1) {
+			if ((BT_INFO_8812A_1ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+			    ((coex_dm->cur_ps_tdma == 1) ||
+			     (coex_dm->cur_ps_tdma == 2))) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 11) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 9);
+				coex_dm->ps_tdma_du_adj_type = 9;
+			} else if (coex_dm->cur_ps_tdma == 9) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 2);
+				coex_dm->ps_tdma_du_adj_type = 2;
+			} else if (coex_dm->cur_ps_tdma == 2) {
+				halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 1);
+				coex_dm->ps_tdma_du_adj_type = 1;
+			}
+		} else { /* no change */
+			/* Bryant Modify
+			if(wifi_busy != pre_wifi_busy)
+			{
+				pre_wifi_busy = wifi_busy;
+				halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, true, coex_dm->cur_ps_tdma);
+			}
+			*/
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], ********** TDMA(on, %d) **********\n",
+				    coex_dm->cur_ps_tdma);
+			BTC_TRACE(trace_buf);
+		}
+
+		if (coex_dm->cur_ps_tdma != 1 &&
+		    coex_dm->cur_ps_tdma != 2 &&
+		    coex_dm->cur_ps_tdma != 9 &&
+		    coex_dm->cur_ps_tdma != 11) {
+			/* recover to previous adjust type */
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		}
+	}
+}
+
+void halbtc8812a1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8812a1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8812a1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8812a1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8812a1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8812a1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8812a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+	halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, FORCE_EXEC,
+				     false, false);
+}
+
+void halbtc8812a1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a1ant_action_wifi_only(btcoexist);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		if (!bt_disabled) {
+		} else {
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+					   NULL);
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+					   NULL);
+		}
+	}
+}
+
+/* *********************************************
+ *
+ *	Software Coex Mechanism start
+ *
+ * ********************************************* */
+
+/* SCO only or SCO+PAN(HS) */
+
+/*
+void halbtc8812a1ant_action_sco(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8812a1ant_action_hid(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8812a1ant_action_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8812a1ant_action_a2dp_pan_hs(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8812a1ant_action_pan_edr(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, false);
+}
+
+
+void halbtc8812a1ant_action_pan_hs(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, false);
+}
+
+
+void halbtc8812a1ant_action_pan_edr_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8812a1ant_action_pan_edr_hid(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, true);
+}
+
+
+void halbtc8812a1ant_action_hid_a2dp_pan_edr(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, true);
+}
+
+void halbtc8812a1ant_action_hid_a2dp(IN struct btc_coexist* btcoexist)
+{
+	halbtc8812a1ant_sw_mechanism(btcoexist, true);
+}
+
+*/
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8812a1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8812a1ant_action_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8812a1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = false, ap_enable = false, wifi_busy = false,
+				bt_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	if ((!wifi_connected) && (!coex_sta->wifi_is_high_pri_task)) {
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+		   (bt_link_info->a2dp_exist)) {
+		/* SCO/HID/A2DP  busy */
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if ((bt_link_info->pan_exist) || (wifi_busy)) {
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	}
+}
+
+void halbtc8812a1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/* tdma and coex table */
+
+	if (bt_link_info->sco_exist) {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	} else { /* HID */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 6);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	}
+}
+
+void halbtc8812a1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	u8		bt_rssi_state;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	bt_rssi_state = halbtc8812a1ant_bt_rssi_state(2, 28, 0);
+
+	if ((coex_sta->low_priority_rx >= 950)  && (!coex_sta->under_ips))
+		bt_link_info->slave_role = true;
+	else
+		bt_link_info->slave_role = false;
+
+	if (bt_link_info->hid_only) { /* HID */
+		halbtc8812a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				wifi_status);
+		coex_dm->auto_tdma_adjust = false;
+		return;
+	} else if (bt_link_info->a2dp_only) { /* A2DP		 */
+		if (BT_8812A_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status) {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = false;
+		} else {
+			halbtc8812a1ant_tdma_duration_adjust_for_acl(btcoexist,
+					wifi_status);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+			coex_dm->auto_tdma_adjust = true;
+		}
+	} else if (((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+		coex_dm->auto_tdma_adjust = false;
+
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	} else if ((bt_link_info->pan_only) || (bt_link_info->hid_exist &&
+		bt_link_info->pan_exist)) { /* PAN(OPP,FTP), HID+PAN(OPP,FTP)			 */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		/* BT no-profile busy (0x9) */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+		coex_dm->auto_tdma_adjust = false;
+	}
+}
+
+void halbtc8812a1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	/* power save state */
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC,
+				     false, false);
+	halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8812a1ant_action_wifi_not_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if (BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8812A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8812a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8812A_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8812a1ant_action_wifi_not_connected_asso_auth(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist)  || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 4);
+	} else {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 2);
+	}
+}
+
+void halbtc8812a1ant_action_wifi_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if (BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8812A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8812a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8812A_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* Bryant Add */
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8812a1ant_action_wifi_connected_specific_packet(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else if (bt_link_info->pan_exist) {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     NORMAL_EXEC, false, false);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8812a1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	boolean	wifi_busy = false;
+	boolean		scan = false, link = false, roam = false;
+	boolean		under_4way = false, ap_enable = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+	if (under_4way) {
+		halbtc8812a1ant_action_wifi_connected_specific_packet(btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under 4way<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	if (scan || link || roam) {
+		if (scan)
+			halbtc8812a1ant_action_wifi_connected_scan(btcoexist);
+		else
+			halbtc8812a1ant_action_wifi_connected_specific_packet(
+				btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under scan<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	/* power save state */
+	if (!ap_enable &&
+	    BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status &&
+	    !btcoexist->bt_link_info.hid_only) {
+		if (btcoexist->bt_link_info.a2dp_only) {	/* A2DP */
+			if (!wifi_busy)
+				halbtc8812a1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			else { /* busy */
+				if (coex_sta->scan_ap_num >=
+				    BT_8812A_1ANT_WIFI_NOISY_THRESH)  /* no force LPS, no PS-TDMA, use pure TDMA */
+					halbtc8812a1ant_power_save_state(
+						btcoexist, BTC_PS_WIFI_NATIVE,
+						0x0, 0x0);
+				else
+					halbtc8812a1ant_power_save_state(
+						btcoexist, BTC_PS_LPS_ON, 0x50,
+						0x4);
+			}
+		} else if ((coex_sta->pan_exist == false) &&
+			   (coex_sta->a2dp_exist == false) &&
+			   (coex_sta->hid_exist == false))
+			halbtc8812a1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		else
+			halbtc8812a1ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+	} else
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+
+	/* tdma and coex table */
+	if (!wifi_busy) {
+		if (BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8812a1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8812A_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else if ((BT_8812A_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8812a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8812A_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8812a1ant_set_ant_path(btcoexist,
+				BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false);
+			if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60)
+				halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+			else
+				halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+	} else {
+		if (BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8812a1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8812A_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else if ((BT_8812A_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8812a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8812A_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else {
+			halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8812a1ant_set_ant_path(btcoexist,
+				BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false);
+			if ((coex_sta->high_priority_tx) +
+			    (coex_sta->high_priority_rx) <= 60)
+				halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+			else
+				halbtc8812a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 7);
+		}
+	}
+}
+
+void halbtc8812a1ant_run_sw_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8				algorithm = 0;
+
+	algorithm = halbtc8812a1ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+
+	if (halbtc8812a1ant_is_common_action(btcoexist)) {
+
+	} else {
+		switch (coex_dm->cur_algorithm) {
+		case BT_8812A_1ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_sco(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_hid(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_a2dp(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_a2dp_pan_hs(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_pan_edr(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_pan_hs(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_pan_edr_a2dp(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_pan_edr_hid(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_hid_a2dp_pan_edr(btcoexist); */
+			break;
+		case BT_8812A_1ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_action_hid_a2dp(btcoexist); */
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8812a1ant_coex_all_off(btcoexist); */
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8812a1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, bt_hs_on = false;
+	boolean	increase_scan_dev_num = false;
+	boolean	bt_ctrl_agg_buf_size = false;
+	boolean	miracast_plus_bt = false;
+	u8	agg_buf_size = 5;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0, wifi_bw;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if ((BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8812A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist) {
+			halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1,
+						   0, 1);
+			miracast_plus_bt = true;
+		} else {
+			halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0,
+						   0, 0);
+			miracast_plus_bt = false;
+		}
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+
+		if ((bt_link_info->a2dp_exist) &&
+		    (coex_sta->c2h_bt_inquiry_page)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"############# [BTCoex],  BT Is Inquirying\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a1ant_action_bt_inquiry(btcoexist);
+		} else
+			halbtc8812a1ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	} else {
+		miracast_plus_bt = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_link_info->bt_link_exist) && (wifi_connected)) {
+		halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1, 0, 1);
+
+		if (bt_link_info->sco_exist)
+			halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC, true,
+						   false, 0x5);
+		else {
+			if (BTC_WIFI_BW_HT40 == wifi_bw)
+				halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC,
+							   false, true, 0x10);
+			else
+				halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC,
+							   false, true, 0x8);
+		}
+
+		halbtc8812a1ant_sw_mechanism(btcoexist, true);
+		halbtc8812a1ant_run_sw_coexist_mechanism(
+			btcoexist);  /* just print debug message */
+	} else {
+		halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+		halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x5);
+
+		halbtc8812a1ant_sw_mechanism(btcoexist, false);
+		halbtc8812a1ant_run_sw_coexist_mechanism(
+			btcoexist); /* //just print debug message */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "############# [BTCoex],  BT Is Inquirying\n");
+		BTC_TRACE(trace_buf);
+		halbtc8812a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8812a1ant_action_hs(btcoexist);
+		return;
+	}
+
+
+	if (!wifi_connected) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is non connected-idle !!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (scan || link || roam) {
+			if (scan)
+				halbtc8812a1ant_action_wifi_not_connected_scan(
+					btcoexist);
+			else
+				halbtc8812a1ant_action_wifi_not_connected_asso_auth(
+					btcoexist);
+		} else
+			halbtc8812a1ant_action_wifi_not_connected(btcoexist);
+	} else	/* wifi LPS/Busy */
+		halbtc8812a1ant_action_wifi_connected(btcoexist);
+}
+
+void halbtc8812a1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+
+	/* sw all off */
+	halbtc8812a1ant_sw_mechanism(btcoexist, false);
+
+	/* halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8); */
+	/* halbtc8812a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0); */
+
+	coex_sta->pop_event_cnt = 0;
+}
+
+void halbtc8812a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up, IN boolean wifi_only)
+{
+	u8	u8tmp = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	/* ant sw control to BT */
+	halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, FORCE_EXEC,
+				     true, false);
+
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* PTA parameter */
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, 0x0);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, 0xffff);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, 0x55555555);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, 0x55555555);
+
+	/* coex parameters */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+
+	/* enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	/* enable PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x40, 0x20);
+
+	/* bt clock related */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x4);
+	u8tmp |= BIT(7);
+	btcoexist->btc_write_1byte(btcoexist, 0x4, u8tmp);
+
+	/* bt clock related */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x7);
+	u8tmp |= BIT(1);
+	btcoexist->btc_write_1byte(btcoexist, 0x7, u8tmp);
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8812a1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8812a1ant_
+ * ************************************************************ */
+void ex_halbtc8812a1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8812a1ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8812a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8812a1ant_init_hw_config(btcoexist, true, wifi_only);
+	btcoexist->stop_coex_dm = false;
+}
+
+void ex_halbtc8812a1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = false;
+
+	halbtc8812a1ant_init_coex_dm(btcoexist);
+
+	halbtc8812a1ant_query_bt_info(btcoexist);
+}
+
+void ex_halbtc8812a1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8			*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u32				fw_ver = 0, bt_patch_ver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%d/ 0x%x/ 0x%x(%d)",
+		   "CoexVer/ FwVer/ PatchVer",
+		   glcoex_ver_date_8812a_1ant, glcoex_ver_8812a_1ant, fw_ver,
+		   bt_patch_ver, bt_patch_ver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8812A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_BT_LINK_INFO);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8812A_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8812a_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (!btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[mechanisms]============");
+		CL_PRINTF(cli_buf);
+
+		ps_tdma_case = coex_dm->cur_ps_tdma;
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d",
+			   "PS TDMA",
+			   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+			   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+			   coex_dm->ps_tdma_para[4], ps_tdma_case);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ",
+			   "Latest error condition(should be 0)",
+			   coex_dm->error_condition);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ",
+			   "IgnWlanAct",
+			   coex_dm->cur_ignore_wlan_act);
+		CL_PRINTF(cli_buf);
+	}
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x778",
+		   u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xcb3);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xcb7);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x900);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0xcb3/0xcb7/0x900",
+		   u8tmp[0], u8tmp[1], u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x40",
+		   u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)",
+		   u32tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(hp rx[31:16]/tx[15:0])",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(lp rx[31:16]/tx[15:0])",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+
+void ex_halbtc8812a1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8812a1ant_init_hw_config(btcoexist, false, false);
+		halbtc8812a1ant_init_coex_dm(btcoexist);
+		halbtc8812a1ant_query_bt_info(btcoexist);
+
+		coex_sta->under_ips = false;
+	}
+}
+
+void ex_halbtc8812a1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (btcoexist->manual_control || btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8812a1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_SCAN_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+				   &coex_sta->scan_ap_num);
+	}
+
+	if (coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	halbtc8812a1ant_query_bt_info(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8812a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8812a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8812a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8812a1ant_action_wifi_not_connected_scan(
+				btcoexist);
+		else	/* wifi is connected */
+			halbtc8812a1ant_action_wifi_connected_scan(btcoexist);
+	} else if (BTC_SCAN_FINISH == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8812a1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8812a1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8812a1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_ASSOCIATE_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		/* coex_dm->arp_cnt = 0; */
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8812a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8812a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8812a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_ASSOCIATE_START == type)
+		halbtc8812a1ant_action_wifi_not_connected_asso_auth(btcoexist);
+	else if (BTC_ASSOCIATE_FINISH == type) {
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+				   &wifi_connected);
+		if (!wifi_connected) /* non-connected scan */
+			halbtc8812a1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8812a1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+/* to check registers... */
+void ex_halbtc8812a1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			data_len = 5;
+	u8			buf[6] = {0};
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	boolean			wifi_under_b_mode = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+		halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA,
+					     FORCE_EXEC, false, false);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,
+				   &wifi_under_b_mode);
+#if 0
+		/* Set CCK Tx/Rx high Pri except 11b mode */
+		if (wifi_under_b_mode) {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x00); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x00); /* CCK Rx */
+		} else {
+			btcoexist->btc_write_1byte(btcoexist, 0x6cd,
+						   0x10); /* CCK Tx */
+			btcoexist->btc_write_1byte(btcoexist, 0x6cf,
+						   0x10); /* CCK Rx */
+		}
+#endif
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+
+		btcoexist->btc_write_1byte(btcoexist, 0x6cd, 0x0); /* CCK Tx */
+		btcoexist->btc_write_1byte(btcoexist, 0x6cf, 0x0); /* CCK Rx */
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		/* h2c_parameter[0] = 0x1; */
+		h2c_parameter[0] = 0x0;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	buf[0] = data_len;
+	buf[1] = 0x5;				/* OP_Code */
+	buf[2] = 0x3;				/* OP_Code_Length */
+	buf[3] = h2c_parameter[0];	/* OP_Code_Content */
+	buf[4] = h2c_parameter[1];
+	buf[5] = h2c_parameter[2];
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_COEX,
+			   (void *)&buf[0]);
+}
+
+void ex_halbtc8812a1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    BTC_PACKET_ARP == type) {
+		if (BTC_PACKET_ARP == type) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], specific Packet ARP notify\n");
+			BTC_TRACE(trace_buf);
+
+			coex_dm->arp_cnt++;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], ARP Packet Count = %d\n",
+				    coex_dm->arp_cnt);
+			BTC_TRACE(trace_buf);
+
+			if (coex_dm->arp_cnt >=
+			    10) /* if APR PKT > 10 after connect, do not go to ActionWifiConnectedSpecificPacket(btcoexist) */
+				coex_sta->wifi_is_high_pri_task = false;
+			else
+				coex_sta->wifi_is_high_pri_task = true;
+		} else {
+			coex_sta->wifi_is_high_pri_task = true;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], specific Packet DHCP or EAPOL notify\n");
+			BTC_TRACE(trace_buf);
+		}
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet [Type = %d] notify\n", type);
+		BTC_TRACE(trace_buf);
+	}
+
+	coex_sta->specific_pkt_period_cnt = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8812a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8812a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8812a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8812a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8812a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    ((BTC_PACKET_ARP == type) && (coex_sta->wifi_is_high_pri_task)))
+		halbtc8812a1ant_action_wifi_connected_specific_packet(btcoexist);
+}
+
+void ex_halbtc8812a1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				bt_info = 0;
+	u8				i, rsp_source = 0;
+	boolean				wifi_connected = false;
+	boolean				bt_busy = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8812A_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8812A_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (BT_INFO_SRC_8812A_1ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		if (coex_sta->bt_retry_cnt >= 1)
+			coex_sta->pop_event_cnt++;
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x20)
+			coex_sta->c2h_bt_page = true;
+		else
+			coex_sta->c2h_bt_page = false;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 - 90;
+		/* coex_sta->bt_info_c2h[rsp_source][3]*2+10; */
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+		if (!coex_sta->bt_tx_rx_mask) {
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x15\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+						  0x3c, 0x15);
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if (coex_sta->bt_info_ext & BIT(1)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8812a1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8812a1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if (coex_sta->bt_info_ext & BIT(3)) {
+			if (!btcoexist->manual_control &&
+			    !btcoexist->stop_coex_dm) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8812a1ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+		}
+#if (BT_AUTO_REPORT_ONLY_8812A_1ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8812a1ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8812A_1ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8812A_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8812A_1ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8812A_1ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8812A_1ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8812A_1ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+	}
+
+	halbtc8812a1ant_update_bt_link_info(btcoexist);
+
+	bt_info = bt_info &
+		0x1f;  /* mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41) */
+
+	if (!(bt_info & BT_INFO_8812A_1ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8812A_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8812A_1ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8812A_1ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8812A_1ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8812A_1ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8812A_1ANT_B_ACL_BUSY) {
+		if (BT_8812A_1ANT_BT_STATUS_ACL_BUSY != coex_dm->bt_status)
+			coex_dm->auto_tdma_adjust = false;
+		coex_dm->bt_status = BT_8812A_1ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8812A_1ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8812A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8812A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	halbtc8812a1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8812a1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+	} else if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+
+		halbtc8812a1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		btcoexist->stop_coex_dm = true;
+	}
+}
+
+void ex_halbtc8812a1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8812a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+	halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, FORCE_EXEC,
+				     false, true);
+
+	halbtc8812a1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8812a1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8812a1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8812a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8812a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT,
+					     FORCE_EXEC, false, true);
+		halbtc8812a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+		halbtc8812a1ant_init_hw_config(btcoexist, false, false);
+		halbtc8812a1ant_init_coex_dm(btcoexist);
+		halbtc8812a1ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8812a1ant_coex_dm_reset(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], *****************Coex DM Reset*****************\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8812a1ant_init_hw_config(btcoexist, false, false);
+	halbtc8812a1ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8812a1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+#if (BT_AUTO_REPORT_ONLY_8812A_1ANT == 0)
+	halbtc8812a1ant_query_bt_info(btcoexist);
+	halbtc8812a1ant_monitor_bt_enable_disable(btcoexist);
+#else
+	halbtc8812a1ant_monitor_bt_ctr(btcoexist);
+	halbtc8812a1ant_monitor_wifi_ctr(btcoexist);
+
+	if (halbtc8812a1ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust)
+		halbtc8812a1ant_run_coexist_mechanism(btcoexist);
+
+	coex_sta->specific_pkt_period_cnt++;
+#endif
+}
+
+void ex_halbtc8812a1ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata)
+{
+	switch (op_code) {
+	case BTC_DBG_SET_COEX_NORMAL:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set CoexMode to Normal\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->manual_control = false;
+		halbtc8812a1ant_init_coex_dm(btcoexist);
+		break;
+	case BTC_DBG_SET_COEX_WIFI_ONLY:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set CoexMode to Wifi Only\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->manual_control = true;
+		halbtc8812a1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+					9);
+		break;
+	case BTC_DBG_SET_COEX_BT_ONLY:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set CoexMode to BT only\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->manual_control = true;
+		halbtc8812a1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		halbtc8812a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+					0);
+		break;
+	case BTC_DBG_SET_COEX_DEC_BT_PWR:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set Dec BT power\n");
+		BTC_TRACE(trace_buf);
+		{
+			u8	data_len = 4;
+			u8	buf[6] = {0};
+			u8	dec_bt_pwr = 0, pwr_level = 0;
+			if (op_len == 2) {
+				dec_bt_pwr = pdata[0];
+				pwr_level = pdata[1];
+
+				buf[0] = data_len;
+				buf[1] = 0x3;		/* OP_Code */
+				buf[2] = 0x2;		/* OP_Code_Length */
+
+				buf[3] = dec_bt_pwr;	/* OP_Code_Content */
+				buf[4] = pwr_level;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Set Dec BT power=%d, pwr_level=%d\n",
+					    dec_bt_pwr, pwr_level);
+				BTC_TRACE(trace_buf);
+				btcoexist->btc_set(btcoexist,
+						   BTC_SET_ACT_CTRL_BT_COEX,
+						   (void *)&buf[0]);
+			}
+		}
+		break;
+
+	case BTC_DBG_SET_COEX_BT_AFH_MAP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set BT AFH Map\n");
+		BTC_TRACE(trace_buf);
+		{
+			u8	data_len = 5;
+			u8	buf[6] = {0};
+			if (op_len == 3) {
+				buf[0] = data_len;
+				buf[1] = 0x5;				/* OP_Code */
+				buf[2] = 0x3;				/* OP_Code_Length */
+
+				buf[3] = pdata[0];			/* OP_Code_Content */
+				buf[4] = pdata[1];
+				buf[5] = pdata[2];
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Set BT AFH Map = %02x %02x %02x\n",
+					    pdata[0], pdata[1], pdata[2]);
+				BTC_TRACE(trace_buf);
+				btcoexist->btc_set(btcoexist,
+						   BTC_SET_ACT_CTRL_BT_COEX,
+						   (void *)&buf[0]);
+			}
+		}
+		break;
+
+	case BTC_DBG_SET_COEX_BT_IGNORE_WLAN_ACT:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set BT Ignore Wlan Active\n");
+		BTC_TRACE(trace_buf);
+		{
+			u8	data_len = 3;
+			u8	buf[6] = {0};
+			if (op_len == 1) {
+				buf[0] = data_len;
+				buf[1] = 0x1;			/* OP_Code */
+				buf[2] = 0x1;			/* OP_Code_Length */
+
+				buf[3] = pdata[0];		/* OP_Code_Content */
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Set BT Ignore Wlan Active = 0x%x\n",
+					    pdata[0]);
+				BTC_TRACE(trace_buf);
+
+				btcoexist->btc_set(btcoexist,
+						   BTC_SET_ACT_CTRL_BT_COEX,
+						   (void *)&buf[0]);
+			}
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a1Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a1Ant.h
new file mode 100644
index 000000000..e786d375d
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a1Ant.h
@@ -0,0 +1,230 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8812A_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8812A 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8812A_1ANT				1
+
+#define	BT_INFO_8812A_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8812A_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8812A_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8812A_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8812A_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8812A_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8812A_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8812A_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8812A_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8812A_1ANT		2
+
+#define  BT_8812A_1ANT_WIFI_NOISY_THRESH								30   /* max: 255 */
+
+enum bt_info_src_8812a_1ant {
+	BT_INFO_SRC_8812A_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8812A_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8812A_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8812A_1ANT_MAX
+};
+
+enum bt_8812a_1ant_bt_status {
+	BT_8812A_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8812A_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8812A_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8812A_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8812A_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8812A_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8812a_1ant_wifi_status {
+	BT_8812A_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8812A_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8812A_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8812A_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8812A_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8812A_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8812A_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8812a_1ant_coex_algo {
+	BT_8812A_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8812A_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8812A_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8812A_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8812A_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8812A_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8812A_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8812A_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8812A_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8812A_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8812A_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8812A_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8812a_1ant {
+	/* hw setting */
+	u8		pre_ant_pos_type;
+	u8		cur_ant_pos_type;
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8812a_1ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	s8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8812A_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8812A_1ANT_MAX];
+	u32					bt_info_query_cnt;
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_page;				/* Add for win8.1 page out issue */
+	boolean					wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	u32					pop_event_cnt;
+	u8					scan_ap_num;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_agg;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_agg;
+
+	boolean					cck_lock;
+	boolean					pre_ccklock;
+	u8					coex_table_type;
+
+	boolean					force_lps_on;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8812a1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a1ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8812a1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8812a1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8812a1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8812a1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8812a1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8812a1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8812a1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8812a1ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8812a1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8812a1ant_coex_dm_reset(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a1ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata);
+void ex_halbtc8812a1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8812a1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8812a1ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8812a1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8812a1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8812a1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8812a1ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8812a1ant_halt_notify(btcoexist)
+#define	ex_halbtc8812a1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8812a1ant_coex_dm_reset(btcoexist)
+#define	ex_halbtc8812a1ant_periodical(btcoexist)
+#define	ex_halbtc8812a1ant_dbg_control(btcoexist, op_code, op_len, pdata)
+#define	ex_halbtc8812a1ant_display_coex_info(btcoexist)
+
+#endif
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a2Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a2Ant.c
new file mode 100644
index 000000000..cd8a547e9
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a2Ant.c
@@ -0,0 +1,4782 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8812A Co-exist mechanism
+ *
+ * History
+ * 2012/08/22 Cosa first check in.
+ * 2012/11/14 Cosa Revise for 8812A 2Ant out sourcing.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "Mp_Precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8812A_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8812a_2ant	glcoex_dm_8812a_2ant;
+static struct  coex_dm_8812a_2ant	*coex_dm = &glcoex_dm_8812a_2ant;
+static struct  coex_sta_8812a_2ant	glcoex_sta_8812a_2ant;
+static struct  coex_sta_8812a_2ant	*coex_sta = &glcoex_sta_8812a_2ant;
+
+const char *const glbt_info_src_8812a_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8812a_2ant = 20150724;
+u32	glcoex_ver_8812a_2ant = 0x37;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8812a2ant_
+ * ************************************************************ */
+u8 halbtc8812a2ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8812a2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8812a2ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_stack_info	*stack_info = &btcoexist->stack_info;
+	static u32	bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	/* only 8812a need to consider if core stack is installed. */
+	if (!stack_info->hci_version)
+		bt_active = false;
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt is detected as disabled %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		if (!bt_disabled) {
+		} else {
+		}
+	}
+}
+
+u32 halbtc8812a2ant_decide_ra_mask(IN struct btc_coexist *btcoexist,
+				   IN u32 ra_mask_type)
+{
+	u32	dis_ra_mask = 0x0;
+
+	switch (ra_mask_type) {
+	case 0: /* normal mode */
+		dis_ra_mask = 0x0;
+		break;
+	case 1: /* disable cck 1/2 */
+		dis_ra_mask = 0x00000003;
+		break;
+	case 2: /* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4			 */
+		dis_ra_mask = 0x0001f1f7;
+		break;
+	default:
+		break;
+	}
+
+	return dis_ra_mask;
+}
+
+void halbtc8812a2ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8812a2ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8812a2ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8812a2ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8812a2ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	u32	dis_ra_mask = 0x0;
+
+	coex_dm->cur_ra_mask_type = ra_mask_type;
+	dis_ra_mask = halbtc8812a2ant_decide_ra_mask(btcoexist, ra_mask_type);
+	halbtc8812a2ant_update_ra_mask(btcoexist, force_exec, dis_ra_mask);
+
+	halbtc8812a2ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8812a2ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8812a2ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+void halbtc8812a2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8812a2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_hp_txrx, reg_hp_tx, reg_hp_tx, reg_hp_rx, reg_hp_rx);
+	BTC_TRACE(trace_buf);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_lp_txrx, reg_lp_tx, reg_lp_tx, reg_lp_rx, reg_lp_rx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+}
+
+void halbtc8812a2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8	data_len = 3;
+	u8	buf[5] = {0};
+
+	if (!coex_sta->bt_disabled) {
+		if (!coex_sta->bt_info_query_cnt ||
+		    (coex_sta->bt_info_c2h_cnt[BT_INFO_SRC_8812A_2ANT_BT_RSP]
+		     - coex_sta->bt_info_query_cnt) > 2) {
+			buf[0] = data_len;
+			buf[1] = 0x1;	/* polling enable, 1=enable, 0=disable */
+			buf[2] = 0x2;	/* polling time in seconds */
+			buf[3] = 0x1;	/* auto report enable, 1=enable, 0=disable */
+
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_INFO,
+					   (void *)&buf[0]);
+		}
+	}
+	coex_sta->bt_info_query_cnt++;
+}
+
+boolean halbtc8812a2ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean	wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean	wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void halbtc8812a2ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+	bt_link_info->acl_busy = coex_sta->acl_busy;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8812a2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	struct  btc_stack_info	*stack_info = &btcoexist->stack_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8812A_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 0) {
+		if (bt_link_info->acl_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], ACL Busy only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8812A_2ANT_COEX_ALGO_PANEDR;
+		}
+	} else if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8812A_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_2ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_2ANT_COEX_ALGO_SCO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8812A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8812A_2ANT_COEX_ALGO_SCO;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (stack_info->num_of_hid >= 2) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID*2 + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8812A_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_SCO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_SCO_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8812A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8812A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8812a2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8812a2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				       IN u8 dec_bt_pwr_lvl)
+{
+	u8	data_len = 4;
+	u8	buf[6] = {0};
+
+	buf[0] = data_len;
+	buf[1] = 0x3;		/* OP_Code */
+	buf[2] = 0x2;		/* OP_Code_Length */
+	if (dec_bt_pwr_lvl)
+		buf[3] = 0x1;	/* OP_Code_Content */
+	else
+		buf[3] = 0x0;
+	buf[4] = dec_bt_pwr_lvl;/* pwr_level */
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_COEX,
+			   (void *)&buf[0]);
+}
+
+void halbtc8812a2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN u8 dec_bt_pwr_lvl)
+{
+	coex_dm->cur_bt_dec_pwr_lvl = dec_bt_pwr_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_dec_pwr_lvl == coex_dm->cur_bt_dec_pwr_lvl)
+			return;
+	}
+	halbtc8812a2ant_set_fw_dec_bt_pwr(btcoexist,
+					  coex_dm->cur_bt_dec_pwr_lvl);
+
+	coex_dm->pre_bt_dec_pwr_lvl = coex_dm->cur_bt_dec_pwr_lvl;
+}
+
+void halbtc8812a2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+			      IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8812a2ant_set_fw_dac_swing_level(btcoexist,
+					       coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+void halbtc8812a2ant_set_sw_rf_rx_lpf_corner(IN struct btc_coexist *btcoexist,
+		IN boolean rx_rf_shrink_on)
+{
+	if (rx_rf_shrink_on) {
+		/* Shrink RF Rx LPF corner */
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Shrink RF Rx LPF corner!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff,
+					  0xffffc);
+	} else {
+		/* Resume RF Rx LPF corner */
+		/* After initialized, we can use coex_dm->bt_rf_0x1e_backup */
+		if (btcoexist->initilized) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Resume RF Rx LPF corner!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+					  0xfffff, coex_dm->bt_rf_0x1e_backup);
+		}
+	}
+}
+
+void halbtc8812a2ant_rf_shrink(IN struct btc_coexist *btcoexist,
+		       IN boolean force_exec, IN boolean rx_rf_shrink_on)
+{
+	coex_dm->cur_rf_rx_lpf_shrink = rx_rf_shrink_on;
+
+	if (!force_exec) {
+		if (coex_dm->pre_rf_rx_lpf_shrink ==
+		    coex_dm->cur_rf_rx_lpf_shrink)
+			return;
+	}
+	halbtc8812a2ant_set_sw_rf_rx_lpf_corner(btcoexist,
+						coex_dm->cur_rf_rx_lpf_shrink);
+
+	coex_dm->pre_rf_rx_lpf_shrink = coex_dm->cur_rf_rx_lpf_shrink;
+}
+
+void halbtc8812a2ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8	tmp_u1;
+
+	tmp_u1 = btcoexist->btc_read_1byte(btcoexist, 0x4fd);
+	tmp_u1 |= BIT(0);
+	if (low_penalty_ra) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Tx rate adaptive, set low penalty!!\n");
+		BTC_TRACE(trace_buf);
+		tmp_u1 &= ~BIT(2);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Tx rate adaptive, set normal!!\n");
+		BTC_TRACE(trace_buf);
+		tmp_u1 |= BIT(2);
+	}
+
+	btcoexist->btc_write_1byte(btcoexist, 0x4fd, tmp_u1);
+}
+
+void halbtc8812a2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	return;
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8812a2ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8812a2ant_set_dac_swing_reg(IN struct btc_coexist *btcoexist,
+				       IN u32 level)
+{
+	u8	val = (u8)level;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Write SwDacSwing = 0x%x\n", level);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc5b, 0x3e, val);
+}
+
+void halbtc8812a2ant_set_sw_full_time_dac_swing(IN struct btc_coexist
+		*btcoexist, IN boolean sw_dac_swing_on, IN u32 sw_dac_swing_lvl)
+{
+	if (sw_dac_swing_on)
+		halbtc8812a2ant_set_dac_swing_reg(btcoexist, sw_dac_swing_lvl);
+	else
+		halbtc8812a2ant_set_dac_swing_reg(btcoexist, 0x18);
+}
+
+
+void halbtc8812a2ant_dac_swing(IN struct btc_coexist *btcoexist,
+	IN boolean force_exec, IN boolean dac_swing_on, IN u32 dac_swing_lvl)
+{
+	coex_dm->cur_dac_swing_on = dac_swing_on;
+	coex_dm->cur_dac_swing_lvl = dac_swing_lvl;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_dac_swing_on == coex_dm->cur_dac_swing_on) &&
+		    (coex_dm->pre_dac_swing_lvl ==
+		     coex_dm->cur_dac_swing_lvl))
+			return;
+	}
+	delay_ms(30);
+	halbtc8812a2ant_set_sw_full_time_dac_swing(btcoexist, dac_swing_on,
+			dac_swing_lvl);
+
+	coex_dm->pre_dac_swing_on = coex_dm->cur_dac_swing_on;
+	coex_dm->pre_dac_swing_lvl = coex_dm->cur_dac_swing_lvl;
+}
+
+void halbtc8812a2ant_set_adc_back_off(IN struct btc_coexist *btcoexist,
+				      IN boolean adc_back_off)
+{
+	if (adc_back_off) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x8db, 0x60, 0x3);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x8db, 0x60, 0x1);
+	}
+}
+
+void halbtc8812a2ant_adc_back_off(IN struct btc_coexist *btcoexist,
+			  IN boolean force_exec, IN boolean adc_back_off)
+{
+	coex_dm->cur_adc_back_off = adc_back_off;
+
+	if (!force_exec) {
+		if (coex_dm->pre_adc_back_off == coex_dm->cur_adc_back_off)
+			return;
+	}
+	halbtc8812a2ant_set_adc_back_off(btcoexist, coex_dm->cur_adc_back_off);
+
+	coex_dm->pre_adc_back_off = coex_dm->cur_adc_back_off;
+}
+
+void halbtc8812a2ant_set_agc_table(IN struct btc_coexist *btcoexist,
+				   IN boolean agc_table_en)
+{
+	u8		rssi_adjust_val = 0;
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x02000);
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x28F4B);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x10AB2);
+		rssi_adjust_val = 8;
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x2884B);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x104B2);
+	}
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x0);
+
+	/* set rssi_adjust_val for wifi module. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON,
+			   &rssi_adjust_val);
+}
+
+void halbtc8812a2ant_agc_table(IN struct btc_coexist *btcoexist,
+			       IN boolean force_exec, IN boolean agc_table_en)
+{
+	coex_dm->cur_agc_table_en = agc_table_en;
+
+	if (!force_exec) {
+		if (coex_dm->pre_agc_table_en == coex_dm->cur_agc_table_en)
+			return;
+	}
+	halbtc8812a2ant_set_agc_table(btcoexist, agc_table_en);
+
+	coex_dm->pre_agc_table_en = coex_dm->cur_agc_table_en;
+}
+
+void halbtc8812a2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8812a2ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8812a2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8812a2ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	switch (type) {
+	case 0:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5ffb5ffb, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0x5fdf5fdf, 0x5fdb5fdb, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0xdfffdfff, 0x5fdb5fdb, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8812a2ant_coex_table(btcoexist, force_exec,
+				   0x5ddd5ddd, 0x5fdb5fdb, 0xffffff, 0x3);
+		break;
+
+	default:
+		break;
+	}
+}
+
+void halbtc8812a2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8	data_len = 3;
+	u8	buf[5] = {0};
+
+	buf[0] = data_len;
+	buf[1] = 0x1;			/* OP_Code */
+	buf[2] = 0x1;			/* OP_Code_Length */
+	if (enable)
+		buf[3] = 0x1;		/* OP_Code_Content */
+	else
+		buf[3] = 0x0;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_COEX,
+			   (void *)&buf[0]);
+}
+
+void halbtc8812a2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8812a2ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8812a2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for 1Ant AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+		}
+	}
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8812a2ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8812a2ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8812a2ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8812a2ant_sw_mechanism1(IN struct btc_coexist *btcoexist,
+			   IN boolean shrink_rx_lpf, IN boolean low_penalty_ra,
+			   IN boolean limited_dig, IN boolean bt_lna_constrain)
+{
+	/*
+	u32	wifi_bw;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if(BTC_WIFI_BW_HT40 != wifi_bw)
+	{
+		if (shrink_rx_lpf)
+			shrink_rx_lpf = false;
+	}
+	*/
+
+	halbtc8812a2ant_rf_shrink(btcoexist, NORMAL_EXEC, shrink_rx_lpf);
+	/* halbtc8812a2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra); */
+}
+
+void halbtc8812a2ant_sw_mechanism2(IN struct btc_coexist *btcoexist,
+			   IN boolean agc_table_shift, IN boolean adc_back_off,
+			   IN boolean sw_dac_swing, IN u32 dac_swing_lvl)
+{
+	/* halbtc8812a2ant_agc_table(btcoexist, NORMAL_EXEC, agc_table_shift); */
+	halbtc8812a2ant_adc_back_off(btcoexist, NORMAL_EXEC, adc_back_off);
+	halbtc8812a2ant_dac_swing(btcoexist, NORMAL_EXEC, sw_dac_swing,
+				  dac_swing_lvl);
+}
+
+void halbtc8812a2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	u8			u8tmp = 0;
+
+	if (init_hwcfg) {
+		btcoexist->btc_write_4byte(btcoexist, 0x900, 0x00000400);
+		btcoexist->btc_write_1byte(btcoexist, 0x76d, 0x1);
+	} else if (wifi_off) {
+
+	}
+
+	/* ext switch setting */
+	switch (ant_pos_type) {
+	case BTC_ANT_WIFI_AT_CPL_MAIN:
+		break;
+	case BTC_ANT_WIFI_AT_CPL_AUX:
+		u8tmp = btcoexist->btc_read_1byte(btcoexist, 0xcb7);
+		u8tmp &= ~BIT(3);
+		u8tmp |= BIT(2);
+		btcoexist->btc_write_1byte(btcoexist, 0xcb7, u8tmp);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8812a2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+	if (turn_on) {
+		switch (type) {
+		case 1:
+		default:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1a, 0x1a, 0xa1, 0x90);
+			break;
+		case 2:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x12, 0x12, 0xa1, 0x90);
+			break;
+		case 3:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xb1, 0x90);
+			break;
+		case 4:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0xb1, 0x90);
+			break;
+		case 5:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1a, 0x1a, 0x21, 0x10);
+			break;
+		case 6:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x12, 0x12, 0x21, 0x10);
+			break;
+		case 7:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x21, 0x10);
+			break;
+		case 8:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0x21, 0x10);
+			break;
+		case 9:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1a, 0x1a, 0xa1, 0x10);
+			break;
+		case 10:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x12, 0x12, 0xa1, 0x10);
+			break;
+		case 11:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xb1, 0x10);
+			break;
+		case 12:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0xb1, 0x10);
+			break;
+		case 13:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1a, 0x1a, 0x21, 0x10);
+			break;
+		case 14:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x12, 0x12, 0x21, 0x10);
+			break;
+		case 15:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x21, 0x10);
+			break;
+		case 16:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0x21, 0x10);
+			break;
+		case 17:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x35, 0x3, 0xb1, 0x11);
+			break;
+		case 18:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x5, 0x5, 0xe1, 0x90);
+			break;
+		case 19:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0xe1, 0x90);
+			break;
+		case 20:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0x60, 0x90);
+			break;
+		case 21:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x3, 0x70, 0x90);
+			break;
+		case 22:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x1a, 0x1a, 0x21, 0x10);
+			break;
+		case 23:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x03, 0x31, 0x10);
+			break;
+
+		case 71:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1a, 0x1a, 0xe1, 0x90);
+			break;
+
+		/* following cases is for wifi rssi low, started from 81 */
+		case 81:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x3a, 0x3, 0x90, 0x50);
+			break;
+		case 82:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x2b, 0x3, 0x90, 0x50);
+			break;
+		case 83:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x21, 0x3, 0x90, 0x50);
+			break;
+		case 84:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x15, 0x3, 0x90, 0x50);
+			break;
+		case 85:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1d, 0x1d, 0x80, 0x50);
+			break;
+		case 86:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x15, 0x15, 0x80, 0x50);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 0: /* ANT2PTA, 0x778=0x1 */
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		case 1: /* ANT2BT, 0x778=3 */
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x8, 0x0);
+			delay_ms(5);
+			halbtc8812a2ant_set_ant_path(btcoexist,
+				     BTC_ANT_WIFI_AT_CPL_AUX, false, false);
+			break;
+		default:
+			halbtc8812a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8812a2ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* fw all off */
+	halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8812a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8812a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8812a2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+
+	halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8812a2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8812a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8812a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+void halbtc8812a2ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8812a2ant_power_save_state(IN struct btc_coexist *btcoexist,
+		      IN u8 ps_type, IN boolean low_pwr_disable, IN u8 lps_val,
+				      IN u8 rpwm_val)
+{
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8812a2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8812a2ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma. */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8812a2ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, true,
+					 0x0, 0x0);
+
+	halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8812a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8812a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+boolean halbtc8812a2ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				common = false, wifi_connected = false, wifi_busy = false;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8812a2ant_action_bt_inquiry(btcoexist);
+		return true;
+	}
+
+	if (bt_link_info->sco_exist || bt_link_info->hid_exist)
+		halbtc8812a2ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 0, 0, 0);
+	else
+		halbtc8812a2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+	if (!wifi_connected) {
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 false, 0x0, 0x0);
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non-connected idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		if ((BT_8812A_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		     coex_dm->bt_status) ||
+		    (BT_8812A_2ANT_BT_STATUS_CONNECTED_IDLE ==
+		     coex_dm->bt_status)) {
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+		} else {
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+		}
+
+		halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8812a2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8812a2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		common = true;
+	} else {
+		if (BT_8812A_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_power_save_state(btcoexist,
+					 BTC_PS_WIFI_NATIVE, false, 0x0, 0x0);
+			halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, false, 0x8);
+
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+			halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 6);
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else if (BT_8812A_2ANT_BT_STATUS_CONNECTED_IDLE ==
+			   coex_dm->bt_status) {
+			if (bt_hs_on)
+				return false;
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_power_save_state(btcoexist,
+					 BTC_PS_WIFI_NATIVE, true, 0x0, 0x0);
+			halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, false, 0x8);
+
+			halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+			halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 6);
+			halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else {
+			if (wifi_busy) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				common = false;
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+
+				halbtc8812a2ant_power_save_state(btcoexist,
+					 BTC_PS_WIFI_NATIVE, true, 0x0, 0x0);
+
+				halbtc8812a2ant_limited_rx(btcoexist,
+					   NORMAL_EXEC, false, false, 0x8);
+
+				halbtc8812a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 17);
+
+				halbtc8812a2ant_fw_dac_swing_lvl(btcoexist,
+							 NORMAL_EXEC, 6);
+				halbtc8812a2ant_dec_bt_pwr(btcoexist,
+							   NORMAL_EXEC, 0);
+				halbtc8812a2ant_sw_mechanism1(btcoexist, false,
+						      false, false, false);
+				halbtc8812a2ant_sw_mechanism2(btcoexist, false,
+						      false, false, 0x18);
+				common = true;
+			}
+		}
+	}
+
+	return common;
+}
+
+void halbtc8812a2ant_tdma_duration_adjust(IN struct btc_coexist *btcoexist,
+		IN boolean sco_hid, IN boolean tx_pause, IN u8 max_interval)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0;
+
+	coex_dm->auto_tdma_adjust_low_rssi = false;
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+		{
+			if (sco_hid) {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					} else if (max_interval == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (max_interval == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					} else if (max_interval == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (max_interval == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			} else {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (max_interval == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (max_interval == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (max_interval == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (max_interval == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					}
+				}
+			}
+		}
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* accquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if s n 2 retry count0, heWiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if s 2 2 retry count< 3, hWiFi duration */
+				if (wait_count <= 2)
+					m++; /* K@blevel^ */
+				else
+					m = 1;
+
+				if (m >= 20)  /* m j = 20 ' j120 recheckO_ WiFi duration. */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, un1 retry count > 3, hWiFi duration */
+			if (wait_count == 1)
+				m++; /* K@blevel^ */
+			else
+				m = 1;
+
+			if (m >= 20)  /* m j = 20 ' j120 recheckO_ WiFi duration. */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (max_interval == 1) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 71) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 13);
+					coex_dm->ps_tdma_du_adj_type = 13;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 71);
+					coex_dm->ps_tdma_du_adj_type = 71;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 9);
+					coex_dm->ps_tdma_du_adj_type = 9;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 71) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 71);
+						coex_dm->ps_tdma_du_adj_type =
+							71;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					}
+				}
+			}
+		} else if (max_interval == 2) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					}
+				}
+			}
+		} else if (max_interval == 3) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8812a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8812a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			}
+		}
+	}
+
+	/* if current PsTdma not match with the recorded one (when scan, dhcp...), */
+	/* then we have to adjust it back to the previous record one. */
+	if (coex_dm->cur_ps_tdma != coex_dm->ps_tdma_du_adj_type) {
+		boolean	scan = false, link = false, roam = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], PsTdma type dismatch!!!, cur_ps_tdma=%d, recordPsTdma=%d\n",
+			    coex_dm->cur_ps_tdma, coex_dm->ps_tdma_du_adj_type);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (!scan && !link && !roam)
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+}
+
+/* ******************
+ * pstdma for wifi rssi low
+ * ****************** */
+void halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+	IN struct btc_coexist *btcoexist/* , */ /* IN u8 wifi_status */)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0, bt_info_ext;
+
+	coex_dm->auto_tdma_adjust = false;
+
+	retry_count = coex_sta->bt_retry_cnt;
+	bt_info_ext = coex_sta->bt_info_ext;
+
+	if (!coex_dm->auto_tdma_adjust_low_rssi) {
+		coex_dm->auto_tdma_adjust_low_rssi = true;
+
+		if (BT_INFO_8812A_2ANT_A2DP_BASIC_RATE(bt_info_ext)) {
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						83);
+			coex_dm->ps_tdma_du_adj_type = 83;
+		} else {
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 82);
+			coex_dm->ps_tdma_du_adj_type = 82;
+		}
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* accquire the BT TRx retry count from BT_Info byte2
+		*		retry_count = coex_sta->bt_retry_cnt;
+		*		bt_info_ext = coex_sta->bt_info_ext; */
+		result = 0;
+		wait_count++;
+
+		if ((coex_sta->low_priority_tx) > 1150 ||
+		    (coex_sta->low_priority_rx) > 1250)
+			retry_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if retry count during continuous n*2 seconds is 0, enlarge WiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if continuous 2 retry count(every 2 seconds) >0 and < 3, reduce WiFi duration */
+				if (wait_count <= 2)
+					m++; /* to avoid loop between the two levels */
+				else
+					m = 1;
+
+				if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, once retry count > 3, to reduce WiFi duration */
+			if (wait_count == 1)
+				m++; /* to avoid loop between the two levels */
+			else
+				m = 1;
+
+			if (m >= 20)  /* maximum of m = 20 ' will recheck if need to adjust wifi duration in maximum time interval 120 seconds */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (result == -1) {
+			if ((BT_INFO_8812A_2ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+			    ((coex_dm->cur_ps_tdma == 81) ||
+			     (coex_dm->cur_ps_tdma == 82))) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 84);
+				coex_dm->ps_tdma_du_adj_type = 84;
+			} else if (coex_dm->cur_ps_tdma == 81) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 82);
+				coex_dm->ps_tdma_du_adj_type = 82;
+			} else if (coex_dm->cur_ps_tdma == 82) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 83);
+				coex_dm->ps_tdma_du_adj_type = 83;
+			} else if (coex_dm->cur_ps_tdma == 83) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 84);
+				coex_dm->ps_tdma_du_adj_type = 84;
+			}
+		} else if (result == 1) {
+			if ((BT_INFO_8812A_2ANT_A2DP_BASIC_RATE(bt_info_ext)) &&
+			    ((coex_dm->cur_ps_tdma == 81) ||
+			     (coex_dm->cur_ps_tdma == 82))) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 83);
+				coex_dm->ps_tdma_du_adj_type = 83;
+			} else if (coex_dm->cur_ps_tdma == 84) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 83);
+				coex_dm->ps_tdma_du_adj_type = 83;
+			} else if (coex_dm->cur_ps_tdma == 83) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 82);
+				coex_dm->ps_tdma_du_adj_type = 82;
+			} else if (coex_dm->cur_ps_tdma == 82) {
+				halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+							true, 81);
+				coex_dm->ps_tdma_du_adj_type = 81;
+			}
+		}
+
+		if (coex_dm->cur_ps_tdma != 81 &&
+		    coex_dm->cur_ps_tdma != 82 &&
+		    coex_dm->cur_ps_tdma != 83 &&
+		    coex_dm->cur_ps_tdma != 84) {
+			/* recover to previous adjust type */
+			halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		}
+	}
+}
+
+void halbtc8812a2ant_get_bt_rssi_threshold(IN struct btc_coexist *btcoexist,
+		IN u8 *pThres0, IN u8 *pThres1)
+{
+	u8 ant_type;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_ANT_TYPE, &ant_type);
+
+	switch (ant_type) {
+	case BTC_ANT_TYPE_0:
+		*pThres0 = 100;
+		*pThres1 = 100;
+		break;
+	case BTC_ANT_TYPE_1:
+		*pThres0 = 34;
+		*pThres1 = 42;
+		break;
+	case BTC_ANT_TYPE_2:
+		*pThres0 = 34;
+		*pThres1 = 42;
+		break;
+	case BTC_ANT_TYPE_3:
+		*pThres0 = 34;
+		*pThres1 = 42;
+		break;
+	case BTC_ANT_TYPE_4:
+		*pThres0 = 34;
+		*pThres1 = 42;
+		break;
+	default:
+		break;
+	}
+}
+
+
+
+void halbtc8812a2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, true,
+					 0x0, 0x0);
+
+	/* coex table */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	/* pstdma */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+	else
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+
+	/* decrease BT power */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x6);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x6);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_sco_hid(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, true,
+					 0x0, 0x0);
+
+	/* coex table */
+	halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+
+	/* pstdma */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 13);
+	else
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+
+	/* decrease BT power	 */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x6);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x6);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x6);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x6);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, true,
+					 0x0, 0x0);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 9);
+	else
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+	/* decrease BT power */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true,
+					   0x8);
+
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8812a2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/* bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	if ((ap_enable == true) || (BTC_RSSI_HIGH(wifi_rssi_state) &&
+				    (!BTC_RSSI_LOW(bt_rssi_state))))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 true, 0x0, 0x0);
+	else
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, true,
+						 0x50, 0x4);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, false, false,
+						     1);
+	else
+		halbtc8812a2ant_tdma_duration_adjust_for_wifi_rssi_low(
+			btcoexist);
+
+	/* decrease BT power */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, true,
+					 0x0, 0x0);
+
+	/* coex table	 */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+
+	/* pstdma	 */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, false, false,
+						     2);
+	else
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, false, true, 2);
+
+	/* decrease BT power */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x6);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x6);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+	boolean		ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	if ((ap_enable == true) || (BTC_RSSI_HIGH(wifi_rssi_state) &&
+				    (!BTC_RSSI_LOW(bt_rssi_state))))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 true, 0x0, 0x0);
+	else
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, true,
+						 0x50, 0x4);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 1);
+	else
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 85);
+
+	/* decrease BT power */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* PAN(HS) only */
+void halbtc8812a2ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42);
+
+	/* power save state */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, true,
+					 0x0, 0x0);
+
+	/* coex table */
+	halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+	/* pstdma */
+	halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+	/* decrease BT power */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* PAN(EDR)+A2DP */
+void halbtc8812a2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state	 */
+	if ((ap_enable == true) || (BTC_RSSI_HIGH(wifi_rssi_state) &&
+				    (!BTC_RSSI_LOW(bt_rssi_state))))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 true, 0x0, 0x0);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 true, 0x0, 0x0);
+	else
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, true,
+						 0x50, 0x4);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, false, false,
+						     3);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, false, true, 3);
+	else {
+		coex_dm->auto_tdma_adjust = false;
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 86);
+	}
+
+	/* decrease BT power */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism	 */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	if ((ap_enable == true) || (BTC_RSSI_HIGH(wifi_rssi_state) &&
+				    (!BTC_RSSI_LOW(bt_rssi_state))))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 true, 0x0, 0x0);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 true, 0x0, 0x0);
+	else
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, true,
+						 0x50, 0x4);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 10);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+	else
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 85);
+
+	/* decrease BT power */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true,
+					   0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8812a2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	if ((ap_enable == true) || (BTC_RSSI_HIGH(wifi_rssi_state) &&
+				    (!BTC_RSSI_LOW(bt_rssi_state))))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 true, 0x0, 0x0);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 true, 0x0, 0x0);
+	else
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, true,
+						 0x50, 0x4);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, true, false, 3);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, true, true, 3);
+	else {
+		coex_dm->auto_tdma_adjust = false;
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 86);
+	}
+
+	/* decrease BT power */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true,
+					   0x8);
+
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_hid_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state */
+	halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, true,
+					 0x0, 0x0);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, true, false, 2);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, true, true, 2);
+	else
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, true, true, 2);
+
+	/* decrease BT power */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true,
+					   0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8812a2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state = BTC_RSSI_STATE_HIGH,
+			bt_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32		wifi_bw;
+	u8		bt_thresh0 = 0, bt_thresh1 = 0;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	halbtc8812a2ant_get_bt_rssi_threshold(btcoexist, &bt_thresh0,
+					      &bt_thresh1);
+	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, bt_thresh0,
+			bt_thresh1);
+
+	wifi_rssi_state = halbtc8812a2ant_wifi_rssi_state(btcoexist, 0, 2, 34,
+			  0);
+	/*	bt_rssi_state = halbtc8812a2ant_bt_rssi_state(3, 34, 42); */
+
+	/* power save state	 */
+	if ((ap_enable == true) || (BTC_RSSI_HIGH(wifi_rssi_state) &&
+				    (!BTC_RSSI_LOW(bt_rssi_state))))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 true, 0x0, 0x0);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 true, 0x0, 0x0);
+	else
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, true,
+						 0x50, 0x4);
+
+	/* coex table */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 3);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 5);
+	else
+		halbtc8812a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	/* pstdma */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, true, false, 2);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_tdma_duration_adjust(btcoexist, true, true, 2);
+	else {
+		coex_dm->auto_tdma_adjust = false;
+		halbtc8812a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 82);
+	}
+
+	/* decrease BT power */
+	if (BTC_RSSI_LOW(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8812a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 4);
+
+	/* limited Rx */
+	if (BTC_RSSI_HIGH(wifi_rssi_state) && (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else if (BTC_RSSI_LOW(wifi_rssi_state) &&
+		 (!BTC_RSSI_LOW(bt_rssi_state)))
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+	else
+		halbtc8812a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true,
+					   0x8);
+
+	/* fw dac swing level */
+	halbtc8812a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if (BTC_RSSI_HIGH(wifi_rssi_state)) {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8812a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8812a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+
+void halbtc8812a2ant_coex_under_5g(IN struct btc_coexist *btcoexist)
+{
+	halbtc8812a2ant_coex_all_off(btcoexist);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Under 5G, force set BT to ignore Wlan active!!\n");
+	BTC_TRACE(trace_buf);
+	halbtc8812a2ant_ignore_wlan_act(btcoexist, NORMAL_EXEC, true);
+}
+/* **************************************************** */
+void halbtc8812a2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	boolean				wifi_under_5g = false;
+	u8				algorithm = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), run 5G coex setting!!<===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8812a2ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+
+	algorithm = halbtc8812a2ant_action_algorithm(btcoexist);
+	if (coex_sta->c2h_bt_inquiry_page &&
+	    (BT_8812A_2ANT_COEX_ALGO_PANHS != algorithm)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8812a2ant_action_bt_inquiry(btcoexist);
+		return;
+	}
+
+	coex_dm->cur_algorithm = algorithm;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Algorithm = %d\n",
+		    coex_dm->cur_algorithm);
+	BTC_TRACE(trace_buf);
+
+	if (halbtc8812a2ant_is_common_action(btcoexist)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant common.\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->auto_tdma_adjust = false;
+		coex_dm->auto_tdma_adjust_low_rssi = false;
+	} else {
+		if (coex_dm->cur_algorithm != coex_dm->pre_algorithm) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], pre_algorithm=%d, cur_algorithm=%d\n",
+				coex_dm->pre_algorithm, coex_dm->cur_algorithm);
+			BTC_TRACE(trace_buf);
+			coex_dm->auto_tdma_adjust = false;
+			coex_dm->auto_tdma_adjust_low_rssi = false;
+		}
+		switch (coex_dm->cur_algorithm) {
+		case BT_8812A_2ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_sco(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_SCO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_sco_hid(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_hid(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_a2dp(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_a2dp_pan_hs(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_pan_edr(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_pan_hs(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_pan_edr_a2dp(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_pan_edr_hid(btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_hid_a2dp_pan_edr(
+				btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_hid_a2dp_pan_hs(
+				btcoexist);
+			break;
+		case BT_8812A_2ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_action_hid_a2dp(btcoexist);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_coex_all_off(btcoexist);
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+
+}
+
+void halbtc8812a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up)
+{
+	u8	u8tmp = 0;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	if (back_up) {
+		/* backup rf 0x1e value */
+		coex_dm->bt_rf_0x1e_backup =
+			btcoexist->btc_get_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+						  0xfffff);
+
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	}
+
+	/* ant sw control to BT */
+	halbtc8812a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_CPL_AUX, true,
+				     false);
+
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* PTA parameter */
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, 0x0);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, 0xffff);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, 0x55555555);
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, 0x55555555);
+
+	/* coex parameters */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x1);
+
+	/* enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	/* enable PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x40, 0x20);
+
+	/* bt clock related */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x4);
+	u8tmp |= BIT(7);
+	btcoexist->btc_write_1byte(btcoexist, 0x4, u8tmp);
+
+	/* bt clock related */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x7);
+	u8tmp |= BIT(1);
+	btcoexist->btc_write_1byte(btcoexist, 0x7, u8tmp);
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8812a2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8812a2ant_
+ * ************************************************************ */
+void ex_halbtc8812a2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8812a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8812a2ant_init_hw_config(btcoexist, true);
+	btcoexist->stop_coex_dm = false;
+}
+
+void ex_halbtc8812a2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+	btcoexist->stop_coex_dm = false;
+	halbtc8812a2ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8812a2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fw_ver = 0, bt_patch_ver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%d/ 0x%x/ 0x%x(%d)",
+		   "CoexVer/ FwVer/ PatchVer",
+		   glcoex_ver_date_8812a_2ant, glcoex_ver_8812a_2ant, fw_ver,
+		   bt_patch_ver, bt_patch_ver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8812A_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8812A_2ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_BT_LINK_INFO);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8812A_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8812a_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	/* Sw mechanism	 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Sw mechanism]============");
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ",
+		   "SM1[ShRf/ LpRA/ LimDig]",
+		   coex_dm->cur_rf_rx_lpf_shrink, coex_dm->cur_low_penalty_ra,
+		   coex_dm->limited_dig);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ",
+		   "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]",
+		   coex_dm->cur_agc_table_en, coex_dm->cur_adc_back_off,
+		   coex_dm->cur_dac_swing_on, coex_dm->cur_dac_swing_lvl);
+	CL_PRINTF(cli_buf);
+
+	/* Fw mechanism		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Fw mechanism]============");
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		"\r\n %-35s = %02x %02x %02x %02x %02x case-%d (auto:%d/%d)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4],
+		   ps_tdma_case, coex_dm->auto_tdma_adjust,
+		   coex_dm->auto_tdma_adjust_low_rssi);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "DecBtPwr/ IgnWlanAct",
+		   coex_dm->cur_bt_dec_pwr_lvl, coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x",
+		   "RF-A, 0x1e initVal",
+		   coex_dm->bt_rf_0x1e_backup);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "backup ARFR1/ARFR2/RL/AMaxTime",
+		   coex_dm->backup_arfr_cnt1, coex_dm->backup_arfr_cnt2,
+		   coex_dm->backup_retry_limit,
+		   coex_dm->backup_ampdu_max_time);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "0x430/0x434/0x42a/0x456",
+		   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x ",
+		   "0x778 (W_Act)/ 0x6cc (CoTab Sel)",
+		   u8tmp[0], u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x8db);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xc5b);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x8db(ADC)/0xc5b[29:25](DAC)",
+		   ((u8tmp[0] & 0x60) >> 5), ((u8tmp[1] & 0x3e) >> 1));
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xcb3);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xcb7);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xcb3/ 0xcb7",
+		   u8tmp[0], u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x974);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x40/ 0x4c[24:23]/ 0x974",
+		   u8tmp[0], ((u32tmp[0] & 0x01800000) >> 23), u32tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xa0a);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xc50(DIG)/0xa0a(CCK-TH)",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xf48);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xa5b);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xa5c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xf48/ 0xa5b (FA cnt-- OFDM : CCK)",
+		   u32tmp[0], (u8tmp[0] << 8) + u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8812A_2ANT == 1)
+	halbtc8812a2ant_monitor_bt_ctr(btcoexist);
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8812a2ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	boolean	wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		halbtc8812a2ant_coex_all_off(btcoexist);
+		halbtc8812a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_CPL_AUX,
+					     false, true);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], IPS notify, force set BT to ignore Wlan active!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8812a2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		ex_halbtc8812a2ant_media_status_notify(btcoexist,
+						       BTC_MEDIA_DISCONNECT);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G,
+				   &wifi_under_5g);
+		if (!wifi_under_5g) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], IPS notify, force set BT NOT to ignore Wlan active!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8812a2ant_ignore_wlan_act(btcoexist, FORCE_EXEC,
+							false);
+		}
+	}
+}
+
+void ex_halbtc8812a2ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8812a2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	if (BTC_SCAN_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_SCAN_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8812a2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	if (BTC_ASSOCIATE_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_ASSOCIATE_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8812a2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			data_len = 5;
+	u8			buf[6] = {0};
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] = 0x1;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	buf[0] = data_len;
+	buf[1] = 0x5;				/* OP_Code */
+	buf[2] = 0x3;				/* OP_Code_Length */
+	buf[3] = h2c_parameter[0];	/* OP_Code_Content */
+	buf[4] = h2c_parameter[1];
+	buf[5] = h2c_parameter[2];
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_CTRL_BT_COEX,
+			   (void *)&buf[0]);
+}
+
+void ex_halbtc8812a2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	if (type == BTC_PACKET_DHCP) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], DHCP Packet notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+}
+
+void ex_halbtc8812a2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			bt_info = 0;
+	u8			i, rsp_source = 0;
+	boolean			bt_busy = false, limited_dig = false;
+	boolean			wifi_connected = false, wifi_under_5g = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8812A_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8812A_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (BT_INFO_SRC_8812A_2ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if ((coex_sta->bt_info_ext & BIT(1))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8812a2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8812a2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if ((coex_sta->bt_info_ext & BIT(3)) && !wifi_under_5g) {
+			/* BT already ignored WlanAct */
+			if (!btcoexist->manual_control &&
+			    !btcoexist->stop_coex_dm) {
+				if (!coex_sta->under_ips) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+					BTC_TRACE(trace_buf);
+					halbtc8812a2ant_ignore_wlan_act(
+						btcoexist, FORCE_EXEC, false);
+				}
+			}
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+
+			if (coex_sta->under_ips) {
+				/* work around for 8812a combo hw bug => when IPS, wlanAct is always high. */
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], wifi is under IPS, set BT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8812a2ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, true);
+			}
+		}
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8812A_2ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8812A_2ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+		coex_sta->acl_busy = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8812A_2ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8812A_2ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8812A_2ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8812A_2ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+		if (bt_info & BT_INFO_8812A_2ANT_B_ACL_BUSY)
+			coex_sta->acl_busy = true;
+		else
+			coex_sta->acl_busy = false;
+
+	}
+
+	halbtc8812a2ant_update_bt_link_info(btcoexist);
+
+	if (!(bt_info & BT_INFO_8812A_2ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8812A_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8812A_2ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8812A_2ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8812A_2ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8812A_2ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8812A_2ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8812A_2ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8812A_2ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8812A_2ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8812A_2ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8812A_2ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8812A_2ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status)) {
+		bt_busy = true;
+		if (!wifi_under_5g)
+			limited_dig = true;
+	} else {
+		bt_busy = false;
+		limited_dig = false;
+	}
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	coex_dm->limited_dig = limited_dig;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_LIMITED_DIG, &limited_dig);
+
+	halbtc8812a2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8812a2ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], RF Status notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_RF_ON == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned ON!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+	}
+	if (BTC_RF_OFF == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], RF is turned OFF!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8812a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 true, 0x0, 0x0);
+		halbtc8812a2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);
+		/* halbtc8812a2ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, FORCE_EXEC, false, true); */
+		halbtc8812a2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		btcoexist->stop_coex_dm = true;
+
+	}
+}
+
+
+void ex_halbtc8812a2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8812a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_CPL_AUX, false,
+				     true);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Halt notify, force set BT to ignore Wlan active!!\n");
+	BTC_TRACE(trace_buf);
+	halbtc8812a2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+	ex_halbtc8812a2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	/* 0x522=0xff, pause tx */
+	btcoexist->btc_write_1byte(btcoexist, 0x522, 0xff);
+	/* 0x40[7:6]=2'b01, modify BT mode. */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0xc0, 0x2);
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8812a2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+#if (BT_AUTO_REPORT_ONLY_8812A_2ANT == 0)
+	halbtc8812a2ant_query_bt_info(btcoexist);
+	halbtc8812a2ant_monitor_bt_ctr(btcoexist);
+	halbtc8812a2ant_monitor_bt_enable_disable(btcoexist);
+#else
+	if (halbtc8812a2ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust ||
+	    coex_dm->auto_tdma_adjust_low_rssi)
+		halbtc8812a2ant_run_coexist_mechanism(btcoexist);
+#endif
+}
+
+void ex_halbtc8812a2ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata)
+{
+	switch (op_code) {
+	case BTC_DBG_SET_COEX_DEC_BT_PWR:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set Dec BT power\n");
+		BTC_TRACE(trace_buf);
+		{
+			u8	data_len = 4;
+			u8	buf[6] = {0};
+			u8	dec_bt_pwr = 0, pwr_level = 0;
+			if (op_len == 2) {
+				dec_bt_pwr = pdata[0];
+				pwr_level = pdata[1];
+
+				buf[0] = data_len;
+				buf[1] = 0x3;		/* OP_Code */
+				buf[2] = 0x2;		/* OP_Code_Length */
+
+				buf[3] = dec_bt_pwr;	/* OP_Code_Content */
+				buf[4] = pwr_level;
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Set Dec BT power=%d, pwr_level=%d\n",
+					    dec_bt_pwr, pwr_level);
+				BTC_TRACE(trace_buf);
+				btcoexist->btc_set(btcoexist,
+						   BTC_SET_ACT_CTRL_BT_COEX,
+						   (void *)&buf[0]);
+			}
+		}
+		break;
+
+	case BTC_DBG_SET_COEX_BT_AFH_MAP:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set BT AFH Map\n");
+		BTC_TRACE(trace_buf);
+		{
+			u8	data_len = 5;
+			u8	buf[6] = {0};
+			if (op_len == 3) {
+				buf[0] = data_len;
+				buf[1] = 0x5;				/* OP_Code */
+				buf[2] = 0x3;				/* OP_Code_Length */
+
+				buf[3] = pdata[0];			/* OP_Code_Content */
+				buf[4] = pdata[1];
+				buf[5] = pdata[2];
+
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Set BT AFH Map = %02x %02x %02x\n",
+					    pdata[0], pdata[1], pdata[2]);
+				BTC_TRACE(trace_buf);
+				btcoexist->btc_set(btcoexist,
+						   BTC_SET_ACT_CTRL_BT_COEX,
+						   (void *)&buf[0]);
+			}
+		}
+		break;
+
+	case BTC_DBG_SET_COEX_BT_IGNORE_WLAN_ACT:
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Set BT Ignore Wlan Active\n");
+		BTC_TRACE(trace_buf);
+		{
+			u8	data_len = 3;
+			u8	buf[6] = {0};
+			if (op_len == 1) {
+				buf[0] = data_len;
+				buf[1] = 0x1;			/* OP_Code */
+				buf[2] = 0x1;			/* OP_Code_Length */
+
+				buf[3] = pdata[0];		/* OP_Code_Content */
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Set BT Ignore Wlan Active = 0x%x\n",
+					    pdata[0]);
+				BTC_TRACE(trace_buf);
+
+				btcoexist->btc_set(btcoexist,
+						   BTC_SET_ACT_CTRL_BT_COEX,
+						   (void *)&buf[0]);
+			}
+		}
+		break;
+
+	default:
+		break;
+	}
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a2Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a2Ant.h
new file mode 100644
index 000000000..be08dd391
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8812a2Ant.h
@@ -0,0 +1,202 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8812A_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8812A 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8812A_2ANT				0
+
+#define	BT_INFO_8812A_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8812A_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8812A_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8812A_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8812A_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8812A_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8812A_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8812A_2ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8812A_2ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8812A_2ANT		2
+
+enum bt_info_src_8812a_2ant {
+	BT_INFO_SRC_8812A_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8812A_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8812A_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8812A_2ANT_MAX
+};
+
+enum bt_8812a_2ant_bt_status {
+	BT_8812A_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8812A_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8812A_2ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8812A_2ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8812A_2ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8812A_2ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8812A_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8812a_2ant_coex_algo {
+	BT_8812A_2ANT_COEX_ALGO_UNDEFINED		= 0x0,
+	BT_8812A_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8812A_2ANT_COEX_ALGO_SCO_HID		= 0x2,
+	BT_8812A_2ANT_COEX_ALGO_HID				= 0x3,
+	BT_8812A_2ANT_COEX_ALGO_A2DP			= 0x4,
+	BT_8812A_2ANT_COEX_ALGO_A2DP_PANHS		= 0x5,
+	BT_8812A_2ANT_COEX_ALGO_PANEDR			= 0x6,
+	BT_8812A_2ANT_COEX_ALGO_PANHS			= 0x7,
+	BT_8812A_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x8,
+	BT_8812A_2ANT_COEX_ALGO_PANEDR_HID		= 0x9,
+	BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0xa,
+	BT_8812A_2ANT_COEX_ALGO_HID_A2DP_PANHS	= 0xb,
+	BT_8812A_2ANT_COEX_ALGO_HID_A2DP		= 0xc,
+	BT_8812A_2ANT_COEX_ALGO_MAX				= 0xd
+};
+
+struct coex_dm_8812a_2ant {
+	/* fw mechanism */
+	u8		pre_bt_dec_pwr_lvl;
+	u8		cur_bt_dec_pwr_lvl;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		auto_tdma_adjust_low_rssi;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	u32		bt_rf_0x1e_backup;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		cur_ra_mask_type;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+};
+
+struct coex_sta_8812a_2ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+	boolean					acl_busy;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	u8					bt_rssi;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8812A_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8812A_2ANT_MAX];
+	u32					bt_info_query_cnt;
+	boolean					c2h_bt_inquiry_page;
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8812a2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8812a2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8812a2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8812a2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8812a2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8812a2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8812a2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8812a2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8812a2ant_rf_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+
+void ex_halbtc8812a2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+void ex_halbtc8812a2ant_dbg_control(IN struct btc_coexist *btcoexist,
+				    IN u8 op_code, IN u8 op_len, IN u8 *pdata);
+
+#else
+#define	ex_halbtc8812a2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8812a2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8812a2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8812a2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8812a2ant_rf_status_notify(btcoexist, type)
+#define	ex_halbtc8812a2ant_halt_notify(btcoexist)
+#define	ex_halbtc8812a2ant_periodical(btcoexist)
+#define	ex_halbtc8812a2ant_display_coex_info(btcoexist)
+#define	ex_halbtc8812a2ant_dbg_control(btcoexist, op_code, op_len, pdata)
+#endif
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a1Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a1Ant.c
new file mode 100644
index 000000000..81ddf0351
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a1Ant.c
@@ -0,0 +1,3100 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for 8821A_1ANT Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************
+ * SY modify 2015/04/27
+ * ************************************************************
+ * include files
+ * ************************************************************ */
+#include "Mp_Precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8821a_1ant		glcoex_dm_8821a_1ant;
+static struct  coex_dm_8821a_1ant	*coex_dm = &glcoex_dm_8821a_1ant;
+static struct  coex_sta_8821a_1ant		glcoex_sta_8821a_1ant;
+static struct  coex_sta_8821a_1ant	*coex_sta = &glcoex_sta_8821a_1ant;
+
+const char *const glbt_info_src_8821a_1ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8821a_1ant = 20150615;
+u32	glcoex_ver_8821a_1ant = 0x61;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8821a1ant_
+ * ************************************************************ */
+u8 halbtc8821a1ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8821a1ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8821a1ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8821a1ant_auto_rate_fallback_retry(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8821a1ant_retry_limit(IN struct btc_coexist *btcoexist,
+				 IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8821a1ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8821a1ant_limited_tx(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+				IN u8 retry_limit_type, IN u8 ampdu_time_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8821a1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8821a1ant_update_ra_mask(btcoexist, force_exec,
+					       0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8821a1ant_update_ra_mask(btcoexist, force_exec,
+					       0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8821a1ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8821a1ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8821a1ant_ampdu_max_time(btcoexist, force_exec, ampdu_time_type);
+}
+
+
+/* ture/xxxx/x:1
+ * false/false/x: 64
+ * false/ture/x:x */
+void halbtc8821a1ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+
+
+}
+
+void halbtc8821a1ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+#if 0
+	/* to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS */
+	if (!(btcoexist->btc_read_1byte(btcoexist, 0x76e) & 0x8)) {
+		coex_sta->high_priority_tx = 65535;
+		coex_sta->high_priority_rx = 65535;
+		coex_sta->low_priority_tx = 65535;
+		coex_sta->low_priority_rx = 65535;
+		return;
+	}
+#endif
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+}
+
+void halbtc8821a1ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+boolean halbtc8821a1ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void halbtc8821a1ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8821a1ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8821A_1ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Profile = SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8821A_1ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = HID + A2DP\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_HID_A2DP;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT Profile = SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_1ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_1ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! BT Profile = SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT Profile = SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_1ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8821a1ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8821a1ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8821a1ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8821a1ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf5;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xa0;  /* MCS6 or OFDM48// */
+		h2c_parameter[5] = 0xa0; /* MCS5 or OFDM36	// */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8821a1ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8821a1ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8821a1ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8821a1ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8821a1ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8821a1ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], ********** CoexTable(%d) **********\n", type);
+	BTC_TRACE(trace_buf);
+
+	switch (type) {
+	case 0:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x5a5a5a5a, 0xaaaa5a5a, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0xaaaa5a5a, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8821a1ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8821a1ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable) {
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8821a1ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8821a1ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8821a1ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+	u8			real_byte1 = byte1, real_byte5 = byte5;
+	boolean			ap_enable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+
+	if (ap_enable) {
+		if (byte1 & BIT(4) && !(byte1 & BIT(5))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], FW for 1Ant AP mode\n");
+			BTC_TRACE(trace_buf);
+			real_byte1 &= ~BIT(4);
+			real_byte1 |= BIT(5);
+
+			real_byte5 |= BIT(5);
+			real_byte5 &= ~BIT(6);
+		}
+	}
+
+	h2c_parameter[0] = real_byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = real_byte5;
+
+	coex_dm->ps_tdma_para[0] = real_byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = real_byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8821a1ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8821a1ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8821a1ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8821a1ant_sw_mechanism(IN struct btc_coexist *btcoexist,
+				  IN boolean low_penalty_ra)
+{
+	halbtc8821a1ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+void halbtc8821a1ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	struct  btc_board_info *board_info = &btcoexist->board_info;
+	u32			u32tmp = 0;
+	u8			h2c_parameter[2] = {0};
+
+	if (init_hwcfg) {
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		/* 0x765 = 0x18 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x3);
+
+		if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT) {
+			/* tell firmware "antenna inverse"  ==> WRONG firmware antenna control code.==>need fw to fix */
+			h2c_parameter[0] = 1;
+			h2c_parameter[1] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+						h2c_parameter);
+
+			/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x64, 0x1, 0x1); //Main Ant to  BT for IPS case 0x4c[23]=1 */
+		} else {
+			/* tell firmware "no antenna inverse" ==> WRONG firmware antenna control code.==>need fw to fix */
+			h2c_parameter[0] = 0;
+			h2c_parameter[1] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+						h2c_parameter);
+
+			/* btcoexist->btc_write_1byte_bitmask(btcoexist, 0x64, 0x1, 0x0); //Aux Ant to  BT for IPS case 0x4c[23]=1 */
+		}
+	} else if (wifi_off) {
+		/* 0x4c[24:23]=00, Set Antenna control by BT_RFE_CTRL	BT Vendor 0xac=0xf002 */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp &= ~BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		/* 0x765 = 0x18 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x3);
+	} else {
+		/* 0x765 = 0x0 */
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x0);
+	}
+
+	/* ext switch setting */
+	switch (ant_pos_type) {
+	case BTC_ANT_PATH_WIFI:
+		btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x77);
+		if (board_info->btdm_ant_pos ==
+		    BTC_ANTENNA_AT_MAIN_PORT)
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x1);
+		else
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x2);
+		break;
+	case BTC_ANT_PATH_BT:
+		btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x77);
+		if (board_info->btdm_ant_pos ==
+		    BTC_ANTENNA_AT_MAIN_PORT)
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x2);
+		else
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x1);
+		break;
+	default:
+	case BTC_ANT_PATH_PTA:
+		btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x66);
+		if (board_info->btdm_ant_pos ==
+		    BTC_ANTENNA_AT_MAIN_PORT)
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x1);
+		else
+			btcoexist->btc_write_1byte_bitmask(btcoexist,
+							   0xcb7, 0x30, 0x2);
+		break;
+	}
+}
+
+void halbtc8821a1ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	u8			rssi_adjust_val = 0;
+	/* u32			fw_ver=0; */
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (coex_dm->cur_ps_tdma_on) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(on, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], ********** TDMA(off, %d) **********\n",
+			    coex_dm->cur_ps_tdma);
+		BTC_TRACE(trace_buf);
+	}
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+	if (turn_on) {
+		switch (type) {
+		default:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x1a, 0x1a, 0x0, 0x50);
+			break;
+		case 1:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x3a, 0x03, 0x10, 0x50);
+			rssi_adjust_val = 11;
+			break;
+		case 2:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x2b, 0x03, 0x10, 0x50);
+			rssi_adjust_val = 14;
+			break;
+		case 3:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x1d, 0x1d, 0x0, 0x52);
+			break;
+		case 4:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x14, 0x0);
+			rssi_adjust_val = 17;
+			break;
+		case 5:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x15, 0x3, 0x11, 0x10);
+			break;
+		case 6:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x20, 0x3, 0x11, 0x13);
+			break;
+		case 7:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xc, 0x5, 0x0, 0x0);
+			break;
+		case 8:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			break;
+		case 9:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x21, 0x3, 0x10, 0x50);
+			rssi_adjust_val = 18;
+			break;
+		case 10:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0xa, 0x0, 0x40);
+			break;
+		case 11:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x15, 0x03, 0x10, 0x50);
+			rssi_adjust_val = 20;
+			break;
+		case 12:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x0a, 0x0a, 0x0, 0x50);
+			break;
+		case 13:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x12, 0x12, 0x0, 0x50);
+			break;
+		case 14:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x1e, 0x3, 0x10, 0x14);
+			break;
+		case 15:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x13,
+						      0xa, 0x3, 0x8, 0x0);
+			break;
+		case 16:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x15, 0x3, 0x10, 0x0);
+			rssi_adjust_val = 18;
+			break;
+		case 18:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x93,
+						      0x25, 0x3, 0x10, 0x0);
+			rssi_adjust_val = 14;
+			break;
+		case 20:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x03, 0x11, 0x10);
+			break;
+		case 21:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x11);
+			break;
+		case 22:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x25, 0x03, 0x11, 0x10);
+			break;
+		case 23:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x18);
+			rssi_adjust_val = 22;
+			break;
+		case 24:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x3, 0x31, 0x18);
+			rssi_adjust_val = 22;
+			break;
+		case 25:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			rssi_adjust_val = 22;
+			break;
+		case 26:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0xa, 0x3, 0x31, 0x18);
+			rssi_adjust_val = 22;
+			break;
+		case 27:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x3, 0x31, 0x98);
+			rssi_adjust_val = 22;
+			break;
+		case 28:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x69,
+						      0x25, 0x3, 0x31, 0x0);
+			break;
+		case 29:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xab,
+						      0x1a, 0x1a, 0x1, 0x10);
+			break;
+		case 30:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x10);
+			break;
+		case 31:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1a, 0x1a, 0, 0x58);
+			break;
+		case 32:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x61,
+						      0x35, 0x3, 0x11, 0x11);
+			break;
+		case 33:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x25, 0x3, 0x30, 0x90);
+			break;
+		case 34:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x53,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 35:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x63,
+						      0x1a, 0x1a, 0x0, 0x10);
+			break;
+		case 36:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x12, 0x3, 0x14, 0x50);
+			break;
+		case 40: /* SoftAP only with no sta associated,BT disable ,TDMA mode for power saving */
+			/* here softap mode screen off will cost 70-80mA for phone */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x23,
+						      0x18, 0x00, 0x10, 0x24);
+			break;
+		case 41:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x15, 0x3, 0x11, 0x11);
+			break;
+		case 42:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x20, 0x3, 0x11, 0x11);
+			break;
+		case 43:
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x51,
+						      0x30, 0x3, 0x10, 0x11);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 8: /* PTA Control */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x8,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8821a1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_PTA, false, false);
+			break;
+		case 0:
+		default:  /* Software control, Antenna at BT side */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8821a1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_BT, false, false);
+			break;
+		case 9:   /* Software control, Antenna at WiFi side */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x0, 0x0);
+			halbtc8821a1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_WIFI, false, false);
+			break;
+		case 10:	/* under 5G */
+			halbtc8821a1ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x8, 0x0);
+			halbtc8821a1ant_set_ant_path(btcoexist,
+					     BTC_ANT_PATH_BT, false, false);
+			break;
+		}
+	}
+	rssi_adjust_val = 0;
+	btcoexist->btc_set(btcoexist,
+		BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE, &rssi_adjust_val);
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8821a1ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* sw all off */
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+	/* hw all off */
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+boolean halbtc8821a1ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+	    coex_dm->bt_status) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+		common = true;
+	} else if (!wifi_connected &&
+		(BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi non connected-idle + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+		common = true;
+	} else if (wifi_connected &&
+		(BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT connected-idle!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+		common = true;
+	} else if (!wifi_connected &&
+		(BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE != coex_dm->bt_status)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non connected-idle + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+		common = true;
+	} else {
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+		}
+
+		common = false;
+	}
+
+	return common;
+}
+
+void halbtc8821a1ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						0);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8821a1ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8821a1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8821a1ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma. */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8821a1ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8821a1ant_coex_under_5g(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8821a1ant_ignore_wlan_act(btcoexist, NORMAL_EXEC, true);
+
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 10);
+
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+
+	halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 5);
+}
+
+void halbtc8821a1ant_action_wifi_only(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 9);
+}
+
+void halbtc8821a1ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32		bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_wifi_only(btcoexist);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		if (!bt_disabled) {
+		} else {
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+					   NULL);
+			btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+					   NULL);
+		}
+	}
+}
+
+/* *********************************************
+ *
+ *	Software Coex Mechanism start
+ *
+ * ********************************************* */
+
+void halbtc8821a1ant_action_bt_whck_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	/* halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, false, false); */
+	halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, false, false);
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+/* SCO only or SCO+PAN(HS) */
+void halbtc8821a1ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, true);
+}
+
+void halbtc8821a1ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, true);
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8821a1ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8821a1ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8821a1ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+}
+
+/* PAN(HS) only */
+void halbtc8821a1ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+}
+
+/* PAN(EDR)+A2DP */
+void halbtc8821a1ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+}
+
+void halbtc8821a1ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, true);
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8821a1ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, true);
+}
+
+void halbtc8821a1ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_sw_mechanism(btcoexist, true);
+}
+
+/* *********************************************
+ *
+ *	Non-Software Coex Mechanism start
+ *
+ * ********************************************* */
+void halbtc8821a1ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8821a1ant_action_hs(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 5);
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+}
+
+void halbtc8821a1ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean			wifi_connected = false, ap_enable = false, wifi_busy = false,
+				bt_busy = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	if ((!wifi_connected) && (!coex_sta->wifi_is_high_pri_task)) {
+		halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+	}
+
+	/* sy modify	 */
+	else if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+		 (bt_link_info->a2dp_exist)) {
+		/* SCO/HID/A2DP  busy */
+		halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+
+	/* sy modify */
+
+	else if ((bt_link_info->a2dp_exist) &&
+		 (bt_link_info->hid_exist)) {
+		/* A2DP+HID	busy */
+		halbtc8821a1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+					14);
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist,
+						     NORMAL_EXEC, 1);
+	}
+
+
+	else if ((bt_link_info->pan_exist) || (wifi_busy)) {
+		halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	}
+}
+
+void halbtc8821a1ant_action_bt_sco_hid_only_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	/* tdma and coex table */
+
+	if (bt_link_info->sco_exist) {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 41);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	} else { /* HID */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 42);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8821a1ant_action_wifi_connected_bt_acl_busy(IN struct btc_coexist
+		*btcoexist, IN u8 wifi_status)
+{
+	u8		bt_rssi_state;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	bt_rssi_state = halbtc8821a1ant_bt_rssi_state(2, 28, 0);
+
+	if (bt_link_info->hid_only) { /* HID */
+		halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				wifi_status);
+		coex_dm->auto_tdma_adjust = false;
+		return;
+	} else if (bt_link_info->a2dp_only) { /* A2DP		 */
+		if (BT_8821A_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifi_status) {
+			/* halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8); */
+			/* halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2); */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						32);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+			coex_dm->auto_tdma_adjust = false;
+		} else if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+			   (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			/* halbtc8821a1ant_tdma_duration_adjust_for_acl(btcoexist, wifi_status); */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		} else { /* for low BT RSSI */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+			coex_dm->auto_tdma_adjust = false;
+		}
+	} else if (bt_link_info->hid_exist &&
+		   bt_link_info->a2dp_exist) { /* HID+A2DP */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+			coex_dm->auto_tdma_adjust = false;
+		} else { /* for low BT RSSI */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+			coex_dm->auto_tdma_adjust = false;
+		}
+
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+	} else if ((bt_link_info->pan_only) || (bt_link_info->hid_exist &&
+		bt_link_info->pan_exist)) { /* PAN(OPP,FTP), HID+PAN(OPP,FTP)			 */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 6);
+		coex_dm->auto_tdma_adjust = false;
+	} else if (((bt_link_info->a2dp_exist) && (bt_link_info->pan_exist)) ||
+		   (bt_link_info->hid_exist && bt_link_info->a2dp_exist &&
+		bt_link_info->pan_exist)) { /* A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP) */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 43);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 11);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+		coex_dm->auto_tdma_adjust = false;
+	}
+}
+
+void halbtc8821a1ant_action_wifi_not_connected(IN struct btc_coexist *btcoexist)
+{
+	/* power save state */
+	halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table	 */
+	halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8);
+	halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8821a1ant_action_wifi_not_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if (BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			/* sy modify */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		} else if (bt_link_info->a2dp_exist && bt_link_info->pan_exist) {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8821A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8821A_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20); */
+		/* halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1); */
+
+		/* Bryant Add */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8821a1ant_action_wifi_not_connected_asso_auth(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if ((bt_link_info->sco_exist)  || (bt_link_info->hid_exist)) {
+		/* sy modify */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 14);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1);
+	} else if ((bt_link_info->a2dp_exist)  || (bt_link_info->pan_exist)) {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8821a1ant_action_wifi_connected_scan(IN struct btc_coexist
+		*btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	if (BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+		if (bt_link_info->a2dp_exist) {
+			/* sy modify */
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						14);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 1);
+		} else if (bt_link_info->a2dp_exist &&
+			   bt_link_info->pan_exist) {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						22);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		} else {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						20);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 4);
+		}
+	} else if ((BT_8821A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+		   (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+		    coex_dm->bt_status)) {
+		halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8821A_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	} else {
+		/* halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20); */
+		/* halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 1); */
+
+		/* Bryant Add */
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8821a1ant_action_wifi_connected_specific_packet(
+	IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	/* tdma and coex table */
+	/* sy modify */
+	if ((bt_link_info->sco_exist) || (bt_link_info->hid_exist) ||
+	    (bt_link_info->a2dp_exist)) {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 32);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	}
+
+	if ((bt_link_info->hid_exist) && (bt_link_info->a2dp_exist)) {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+					14);
+		halbtc8821a1ant_coex_table_with_type(btcoexist,
+						     NORMAL_EXEC, 1);
+	}
+
+
+	else if (bt_link_info->pan_exist) {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 20);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 4);
+	} else {
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 8);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	}
+}
+
+void halbtc8821a1ant_action_wifi_connected(IN struct btc_coexist *btcoexist)
+{
+	boolean	wifi_busy = false;
+	boolean	scan = false, link = false, roam = false;
+	boolean		under_4way = false, ap_enable = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], CoexForWifiConnect()===>\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+	if (under_4way) {
+		halbtc8821a1ant_action_wifi_connected_specific_packet(btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under 4way<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+	if (scan || link || roam) {
+		if (scan)
+			halbtc8821a1ant_action_wifi_connected_scan(btcoexist);
+		else
+			halbtc8821a1ant_action_wifi_connected_specific_packet(
+				btcoexist);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], CoexForWifiConnect(), return for wifi is under scan<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+			   &ap_enable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	/* power save state */
+	if (!ap_enable &&
+	    BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status &&
+	    !btcoexist->bt_link_info.hid_only) {
+		if (!wifi_busy && btcoexist->bt_link_info.a2dp_only)	/* A2DP */
+			halbtc8821a1ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		else
+			halbtc8821a1ant_power_save_state(btcoexist,
+						 BTC_PS_LPS_ON, 0x50, 0x4);
+	} else
+		halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+
+	/* tdma and coex table */
+	if (!wifi_busy) {
+		if (BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8821a1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8821A_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else if ((BT_8821A_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8821A_1ANT_WIFI_STATUS_CONNECTED_IDLE);
+		} else {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+		}
+	} else {
+		if (BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) {
+			halbtc8821a1ant_action_wifi_connected_bt_acl_busy(
+				btcoexist,
+				BT_8821A_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else if ((BT_8821A_1ANT_BT_STATUS_SCO_BUSY ==
+			    coex_dm->bt_status) ||
+			   (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY ==
+			    coex_dm->bt_status)) {
+			halbtc8821a1ant_action_bt_sco_hid_only_busy(btcoexist,
+				BT_8821A_1ANT_WIFI_STATUS_CONNECTED_BUSY);
+		} else {
+			halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						8);
+			halbtc8821a1ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 2);
+		}
+	}
+}
+
+void halbtc8821a1ant_run_sw_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	u8	algorithm = 0;
+
+	algorithm = halbtc8821a1ant_action_algorithm(btcoexist);
+	coex_dm->cur_algorithm = algorithm;
+
+	if (halbtc8821a1ant_is_common_action(btcoexist)) {
+
+	} else {
+		switch (coex_dm->cur_algorithm) {
+		case BT_8821A_1ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_sco(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_hid(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_a2dp(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_a2dp_pan_hs(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_pan_edr(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_pan_hs(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_pan_edr_a2dp(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_pan_edr_hid(btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_hid_a2dp_pan_edr(
+				btcoexist);
+			break;
+		case BT_8821A_1ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a1ant_action_hid_a2dp(btcoexist);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			/* halbtc8821a1ant_coex_all_off(btcoexist); */
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8821a1ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean	wifi_connected = false, bt_hs_on = false;
+	boolean	increase_scan_dev_num = false;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+	u8	wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	wifi_under_5g = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (btcoexist->stop_coex_dm) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Stop Coex DM <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_action_bt_whck_test(btcoexist);
+		return;
+	}
+
+	if ((BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		increase_scan_dev_num = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_INC_SCAN_DEV_NUM,
+			   &increase_scan_dev_num);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8821a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (!bt_link_info->sco_exist && !bt_link_info->hid_exist)
+		halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+	else {
+		if (wifi_connected) {
+			wifi_rssi_state = halbtc8821a1ant_wifi_rssi_state(
+						  btcoexist, 1, 2, 30, 0);
+			if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+			    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+				/* halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1, 1, 1); */
+				halbtc8821a1ant_limited_tx(btcoexist,
+						   NORMAL_EXEC, 1, 1, 0, 1);
+			} else {
+				/* halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 1, 1, 1, 1); */
+				halbtc8821a1ant_limited_tx(btcoexist,
+						   NORMAL_EXEC, 1, 1, 0, 1);
+			}
+		} else
+			halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0,
+						   0, 0);
+
+	}
+
+	if (bt_link_info->sco_exist) {
+		bt_ctrl_agg_buf_size = true;
+		agg_buf_size = 0x3;
+	} else if (bt_link_info->hid_exist) {
+		bt_ctrl_agg_buf_size = true;
+		agg_buf_size = 0x5;
+	} else if (bt_link_info->a2dp_exist || bt_link_info->pan_exist) {
+		bt_ctrl_agg_buf_size = true;
+		agg_buf_size = 0x8;
+	}
+	halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+				   bt_ctrl_agg_buf_size, agg_buf_size);
+
+	halbtc8821a1ant_run_sw_coexist_mechanism(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8821a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8821a1ant_action_hs(btcoexist);
+		return;
+	}
+
+
+	if (!wifi_connected) {
+		boolean	scan = false, link = false, roam = false;
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is non connected-idle !!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (scan || link || roam) {
+			if (scan)
+				halbtc8821a1ant_action_wifi_not_connected_scan(
+					btcoexist);
+			else
+				halbtc8821a1ant_action_wifi_not_connected_asso_auth(
+					btcoexist);
+		} else
+			halbtc8821a1ant_action_wifi_not_connected(btcoexist);
+	} else	/* wifi LPS/Busy */
+		halbtc8821a1ant_action_wifi_connected(btcoexist);
+}
+
+void halbtc8821a1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+	/* sw all off */
+	halbtc8821a1ant_sw_mechanism(btcoexist, false);
+
+	/* halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 8); */
+	halbtc8821a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+}
+
+void halbtc8821a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up, IN boolean wifi_only)
+{
+	u8	u8tmp = 0;
+	boolean			wifi_under_5g = false;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 1Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	if (wifi_only)
+		return;
+
+	if (back_up) {
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+	}
+
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	/* Antenna config */
+	if (wifi_under_5g)
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, true,
+					     false);
+	else
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_PTA, true,
+					     false);
+
+	/* PTA parameter */
+	halbtc8821a1ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	/* Enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e,
+			   0xc); /* 0x76e[3] =1, WLAN_Act control by PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x3);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8821a1ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8821a1ant_
+ * ************************************************************ */
+void ex_halbtc8821a1ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8821a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8821a1ant_init_hw_config(btcoexist, true, wifi_only);
+}
+
+void ex_halbtc8821a1ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	btcoexist->stop_coex_dm = false;
+
+	halbtc8821a1ant_init_coex_dm(btcoexist);
+
+	halbtc8821a1ant_query_bt_info(btcoexist);
+}
+
+void ex_halbtc8821a1ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u16				u16tmp[4];
+	u32				u32tmp[4];
+	u32				fw_ver = 0, bt_patch_ver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+	if (btcoexist->stop_coex_dm) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ============[Coex is STOPPED]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d",
+		   "Ant PG Num/ Ant Mech/ Ant Pos:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num,
+		   board_info->btdm_ant_pos);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%x/ 0x%x/ 0x%x(%d)",
+		   "CoexVer/ FwVer/ PatchVer",
+		   glcoex_ver_date_8821a_1ant, glcoex_ver_8821a_1ant, fw_ver,
+		   bt_patch_ver, bt_patch_ver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_BT_LINK_INFO);
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8821A_1ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8821a_1ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	if (!btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+			   "SM[LowPenaltyRA]",
+			   coex_dm->cur_low_penalty_ra);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "============[mechanisms]============");
+		CL_PRINTF(cli_buf);
+
+		ps_tdma_case = coex_dm->cur_ps_tdma;
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n %-35s = %02x %02x %02x %02x %02x case-%d (auto:%d)",
+			   "PS TDMA",
+			   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+			   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+			   coex_dm->ps_tdma_para[4], ps_tdma_case,
+			   coex_dm->auto_tdma_adjust);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ",
+			   "IgnWlanAct",
+			   coex_dm->cur_ignore_wlan_act);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ",
+			   "Latest error condition(should be 0)",
+			   coex_dm->error_condition);
+		CL_PRINTF(cli_buf);
+	}
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "backup ARFR1/ARFR2/RL/AMaxTime",
+		   coex_dm->backup_arfr_cnt1, coex_dm->backup_arfr_cnt2,
+		   coex_dm->backup_retry_limit,
+		   coex_dm->backup_ampdu_max_time);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x430);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x434);
+	u16tmp[0] = btcoexist->btc_read_2byte(btcoexist, 0x42a);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x456);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/0x%x/0x%x/0x%x",
+		   "0x430/0x434/0x42a/0x456",
+		   u32tmp[0], u32tmp[1], u16tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc58);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x778/ 0xc58[29:25]",
+		   u8tmp[0], (u32tmp[0] & 0x3e000000) >> 25);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x8db);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x8db[6:5]",
+		   ((u8tmp[0] & 0x60) >> 5));
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x975);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0xcb4[29:28]/0xcb4[7:0]/0x974[9:8]",
+		   (u32tmp[0] & 0x30000000) >> 28, u32tmp[0] & 0xff,
+		   u8tmp[0] & 0x3);
+	CL_PRINTF(cli_buf);
+
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x64);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x40/0x4c[24:23]/0x64[0]",
+		   u8tmp[0], ((u32tmp[0] & 0x01800000) >> 23), u8tmp[1] & 0x1);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0xc50(dig)",
+		   u32tmp[0] & 0xff);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xf48);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xa5d);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xa5c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "OFDM-FA/ CCK-FA",
+		   u32tmp[0], (u8tmp[0] << 8) + u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8821A_1ANT == 1)
+	halbtc8821a1ant_monitor_bt_ctr(btcoexist);
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8821a1ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	boolean	wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||	btcoexist->stop_coex_dm)
+		return;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G,
+			   &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false,
+					     true);
+		/* halbtc8821a1ant_set_ant_path_d_cut(btcoexist, false, false, false, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF); */
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+
+		halbtc8821a1ant_init_hw_config(btcoexist, false, false);
+		halbtc8821a1ant_init_coex_dm(btcoexist);
+		halbtc8821a1ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8821a1ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+
+
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8821a1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	boolean wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+	boolean	wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm)
+		return;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, false,
+			8);  /* Force antenna setup for no scan result issue */
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if (coex_sta->bt_disabled)
+		return;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	halbtc8821a1ant_query_bt_info(btcoexist);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8821a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8821a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8821a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_SCAN_START == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8821a1ant_action_wifi_not_connected_scan(
+				btcoexist);
+		else	/* wifi is connected */
+			halbtc8821a1ant_action_wifi_connected_scan(btcoexist);
+	} else if (BTC_SCAN_FINISH == type) {
+		if (!wifi_connected)	/* non-connected scan */
+			halbtc8821a1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8821a1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8821a1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	boolean	wifi_connected = false, bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+	boolean	wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (BTC_ASSOCIATE_START == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8821a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8821a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8821a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_ASSOCIATE_START == type)
+		halbtc8821a1ant_action_wifi_not_connected_asso_auth(btcoexist);
+	else if (BTC_ASSOCIATE_FINISH == type) {
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+				   &wifi_connected);
+		if (!wifi_connected) /* non-connected scan */
+			halbtc8821a1ant_action_wifi_not_connected(btcoexist);
+		else
+			halbtc8821a1ant_action_wifi_connected(btcoexist);
+	}
+}
+
+void ex_halbtc8821a1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	boolean	wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->arp_cnt = 0;
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		/* h2c_parameter[0] = 0x1; */
+		h2c_parameter[0] = 0x0;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8821a1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	boolean	bt_hs_on = false;
+	u32	wifi_link_status = 0;
+	u32	num_of_wifi_link = 0;
+	boolean	bt_ctrl_agg_buf_size = false;
+	u8	agg_buf_size = 5;
+	boolean	wifi_under_5g = false;
+
+	if (btcoexist->manual_control ||
+	    btcoexist->stop_coex_dm ||
+	    coex_sta->bt_disabled)
+		return;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    BTC_PACKET_ARP == type) {
+		coex_sta->wifi_is_high_pri_task = true;
+
+		if (BTC_PACKET_ARP == type) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], specific Packet ARP notify\n");
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], specific Packet DHCP or EAPOL notify\n");
+			BTC_TRACE(trace_buf);
+		}
+	} else {
+		coex_sta->wifi_is_high_pri_task = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], specific Packet [Type = %d] notify\n", type);
+		BTC_TRACE(trace_buf);
+	}
+
+	coex_sta->specific_pkt_period_cnt = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+	if (num_of_wifi_link >= 2) {
+		halbtc8821a1ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					   bt_ctrl_agg_buf_size, agg_buf_size);
+		halbtc8821a1ant_action_wifi_multi_port(btcoexist);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	if (coex_sta->c2h_bt_inquiry_page) {
+		halbtc8821a1ant_action_bt_inquiry(btcoexist);
+		return;
+	} else if (bt_hs_on) {
+		halbtc8821a1ant_action_hs(btcoexist);
+		return;
+	}
+
+	if (BTC_PACKET_DHCP == type ||
+	    BTC_PACKET_EAPOL == type ||
+	    BTC_PACKET_ARP == type) {
+		if (BTC_PACKET_ARP == type) {
+			coex_dm->arp_cnt++;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], ARP Packet Count = %d\n",
+				    coex_dm->arp_cnt);
+			BTC_TRACE(trace_buf);
+			if (coex_dm->arp_cnt >=
+			    10) /* if APR PKT > 10 after connect, do not go to ActionWifiConnectedSpecificPacket(btcoexist) */
+				return;
+		}
+
+		halbtc8821a1ant_action_wifi_connected_specific_packet(btcoexist);
+	}
+}
+
+void ex_halbtc8821a1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8				bt_info = 0;
+	u8				i, rsp_source = 0;
+	boolean				wifi_connected = false;
+	boolean				bt_busy = false;
+	boolean				wifi_under_5g = false;
+
+
+	coex_sta->c2h_bt_info_req_sent = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8821A_1ANT_MAX)
+		rsp_source = BT_INFO_SRC_8821A_1ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+	/* if 0xff, it means BT is under WHCK test */
+	if (bt_info == 0xff)
+		coex_sta->bt_whck_test = true;
+	else
+		coex_sta->bt_whck_test = false;
+
+	if (BT_INFO_SRC_8821A_1ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		if (coex_sta->bt_info_c2h[rsp_source][2] & 0x20)
+			coex_sta->c2h_bt_page = true;
+		else
+			coex_sta->c2h_bt_page = false;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+		if (!coex_sta->bt_tx_rx_mask) {
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x15\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+						  0x3c, 0x15);
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if (coex_sta->bt_info_ext & BIT(1)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+					   &wifi_connected);
+			if (wifi_connected)
+				ex_halbtc8821a1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8821a1ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+		if ((coex_sta->bt_info_ext & BIT(3)) && !wifi_under_5g) {
+			if (!btcoexist->manual_control &&
+			    !btcoexist->stop_coex_dm) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821a1ant_ignore_wlan_act(btcoexist,
+							FORCE_EXEC, false);
+			}
+		} else {
+			/* BT already NOT ignore Wlan active, do nothing here. */
+		}
+#if (BT_AUTO_REPORT_ONLY_8821A_1ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8821a1ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8821A_1ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8821A_1ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8821A_1ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8821A_1ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8821A_1ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8821A_1ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+	}
+
+	halbtc8821a1ant_update_bt_link_info(btcoexist);
+
+	bt_info = bt_info &
+		0x1f;  /* mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41) */
+
+	if (!(bt_info & BT_INFO_8821A_1ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8821A_1ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8821A_1ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8821A_1ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8821A_1ANT_B_ACL_BUSY) {
+		if (BT_8821A_1ANT_BT_STATUS_ACL_BUSY != coex_dm->bt_status)
+			coex_dm->auto_tdma_adjust = false;
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8821A_1ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8821A_1ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_1ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status))
+		bt_busy = true;
+	else
+		bt_busy = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	halbtc8821a1ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8821a1ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	boolean	wifi_under_5g = false;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8821a1ant_ps_tdma(btcoexist, FORCE_EXEC, false, 0);
+	halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false, true);
+	/* halbtc8821a1ant_set_ant_path_d_cut(btcoexist, false, false, false, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF); */
+
+	halbtc8821a1ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8821a1ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+
+	btcoexist->stop_coex_dm = true;
+}
+
+void ex_halbtc8821a1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	boolean wifi_under_5g = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for 5G <===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a1ant_coex_under_5g(btcoexist);
+		return;
+	}
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a1ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8821a1ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8821a1ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+		halbtc8821a1ant_set_ant_path(btcoexist, BTC_ANT_PATH_BT, false,
+					     true);
+		/* halbtc8821a1ant_set_ant_path_d_cut(btcoexist, false, false, false, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF); */
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+		btcoexist->stop_coex_dm = true;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->stop_coex_dm = false;
+		halbtc8821a1ant_init_hw_config(btcoexist, false, false);
+		halbtc8821a1ant_init_coex_dm(btcoexist);
+		halbtc8821a1ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8821a1ant_periodical(IN struct btc_coexist *btcoexist)
+{
+#if (BT_AUTO_REPORT_ONLY_8821A_1ANT == 0)
+	halbtc8821a1ant_query_bt_info(btcoexist);
+	halbtc8821a1ant_monitor_bt_ctr(btcoexist);
+	halbtc8821a1ant_monitor_bt_enable_disable(btcoexist);
+#else
+	if (halbtc8821a1ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust) {
+		/* if(coex_sta->specific_pkt_period_cnt > 2) */
+		/* { */
+		halbtc8821a1ant_run_coexist_mechanism(btcoexist);
+		/* } */
+	}
+
+	coex_sta->specific_pkt_period_cnt++;
+#endif
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
+
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a1Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a1Ant.h
new file mode 100644
index 000000000..6c9c327e3
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a1Ant.h
@@ -0,0 +1,197 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8821A 1ANT BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8821A_1ANT				1
+
+#define	BT_INFO_8821A_1ANT_B_FTP						BIT(7)
+#define	BT_INFO_8821A_1ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8821A_1ANT_B_HID						BIT(5)
+#define	BT_INFO_8821A_1ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8821A_1ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8821A_1ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8821A_1ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8821A_1ANT_B_CONNECTION				BIT(0)
+
+#define	BT_INFO_8821A_1ANT_A2DP_BASIC_RATE(_BT_INFO_EXT_)	\
+		(((_BT_INFO_EXT_&BIT(0))) ? true : false)
+
+#define	BTC_RSSI_COEX_THRESH_TOL_8821A_1ANT		2
+
+enum bt_info_src_8821a_1ant {
+	BT_INFO_SRC_8821A_1ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8821A_1ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8821A_1ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8821A_1ANT_MAX
+};
+
+enum bt_8821a_1ant_bt_status {
+	BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8821A_1ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8821A_1ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8821A_1ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8821A_1ANT_BT_STATUS_MAX
+};
+
+enum bt_8821a_1ant_wifi_status {
+	BT_8821A_1ANT_WIFI_STATUS_NON_CONNECTED_IDLE				= 0x0,
+	BT_8821A_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN		= 0x1,
+	BT_8821A_1ANT_WIFI_STATUS_CONNECTED_SCAN					= 0x2,
+	BT_8821A_1ANT_WIFI_STATUS_CONNECTED_SPECIFIC_PKT				= 0x3,
+	BT_8821A_1ANT_WIFI_STATUS_CONNECTED_IDLE					= 0x4,
+	BT_8821A_1ANT_WIFI_STATUS_CONNECTED_BUSY					= 0x5,
+	BT_8821A_1ANT_WIFI_STATUS_MAX
+};
+
+enum bt_8821a_1ant_coex_algo {
+	BT_8821A_1ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8821A_1ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8821A_1ANT_COEX_ALGO_HID				= 0x2,
+	BT_8821A_1ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8821A_1ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8821A_1ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8821A_1ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8821A_1ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8821A_1ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8821A_1ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8821A_1ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8821A_1ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8821a_1ant {
+	/* fw mechanism */
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+
+	/* sw mechanism */
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+
+	u32		backup_arfr_cnt1;	/* Auto Rate Fallback Retry cnt */
+	u32		backup_arfr_cnt2;	/* Auto Rate Fallback Retry cnt */
+	u16		backup_retry_limit;
+	u8		backup_ampdu_max_time;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+	u8		pre_arfr_type;
+	u8		cur_arfr_type;
+	u8		pre_retry_limit_type;
+	u8		cur_retry_limit_type;
+	u8		pre_ampdu_time_type;
+	u8		cur_ampdu_time_type;
+	u32		arp_cnt;
+
+	u8		error_condition;
+};
+
+struct coex_sta_8821a_1ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					specific_pkt_period_cnt;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	u8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8821A_1ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8821A_1ANT_MAX];
+	boolean					c2h_bt_inquiry_page;
+	boolean					c2h_bt_page;				/* Add for win8.1 page out issue */
+	boolean					wifi_is_high_pri_task;		/* Add for win8.1 page out issue */
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+	boolean
+	bt_whck_test;                        /* Add for ASUS WHQL TEST that enable wifi test bt */
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8821a1ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a1ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8821a1ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a1ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821a1ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821a1ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8821a1ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8821a1ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a1ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a1ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8821a1ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a1ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8821a1ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a1ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8821a1ant_power_on_setting(btcoexist)
+#define	ex_halbtc8821a1ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8821a1ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8821a1ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8821a1ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8821a1ant_halt_notify(btcoexist)
+#define	ex_halbtc8821a1ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8821a1ant_periodical(btcoexist)
+#define	ex_halbtc8821a1ant_display_coex_info(btcoexist)
+
+#endif
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a2Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a2Ant.c
new file mode 100644
index 000000000..010a42200
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a2Ant.c
@@ -0,0 +1,4560 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8821A Co-exist mechanism
+ *
+ * History
+ * 2012/11/15 Cosa first check in.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "Mp_Precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8821a_2ant		glcoex_dm_8821a_2ant;
+static struct  coex_dm_8821a_2ant	*coex_dm = &glcoex_dm_8821a_2ant;
+static struct  coex_sta_8821a_2ant		glcoex_sta_8821a_2ant;
+static struct  coex_sta_8821a_2ant	*coex_sta = &glcoex_sta_8821a_2ant;
+
+const char *const glbt_info_src_8821a_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32	glcoex_ver_date_8821a_2ant = 20150921;
+u32	glcoex_ver_8821a_2ant = 0x58;
+/* modify 20140903v43 a2dpandhid tdmaonoff a2dp glitch _ tdma off 778=3(case1)->778=1(case0)
+ * and to improve tp while a2dphid case23->case25 , case123->case125 for asus spec
+ * and modify for asus bt WHQL test _ tdma off_ 778=3->1_
+ * ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8821a2ant_
+ * ************************************************************ */
+u8 halbtc8821a2ant_bt_rssi_state(u8 level_num, u8 rssi_thresh, u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+					BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8821a2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	   IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+					  BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8821a2ant_monitor_bt_enable_disable(IN struct btc_coexist *btcoexist)
+{
+	static u32	bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		if (!bt_disabled) {
+		} else {
+		}
+	}
+}
+
+void halbtc8821a2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+}
+
+void halbtc8821a2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	if ((coex_sta->low_priority_rx >= 950)  &&
+	    (coex_sta->low_priority_rx >= coex_sta->low_priority_tx) &&
+	    (!coex_sta->under_ips))
+		bt_link_info->slave_role = true;
+	else
+		bt_link_info->slave_role = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_hp_txrx, reg_hp_tx, reg_hp_tx, reg_hp_rx, reg_hp_rx);
+	BTC_TRACE(trace_buf);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_lp_txrx, reg_lp_tx, reg_lp_tx, reg_lp_rx, reg_lp_rx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0xc);
+}
+
+void halbtc8821a2ant_monitor_wifi_ctr(IN struct btc_coexist *btcoexist)
+{
+	if (coex_sta->under_ips) {
+		coex_sta->crc_ok_cck = 0;
+		coex_sta->crc_ok_11g = 0;
+		coex_sta->crc_ok_11n = 0;
+		coex_sta->crc_ok_11n_agg = 0;
+
+		coex_sta->crc_err_cck = 0;
+		coex_sta->crc_err_11g = 0;
+		coex_sta->crc_err_11n = 0;
+		coex_sta->crc_err_11n_agg = 0;
+	} else {
+		coex_sta->crc_ok_cck	= btcoexist->btc_read_4byte(btcoexist,
+					  0xf88);
+		coex_sta->crc_ok_11g	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf94);
+		coex_sta->crc_ok_11n	= btcoexist->btc_read_2byte(btcoexist,
+					  0xf90);
+		coex_sta->crc_ok_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					   0xfb8);
+
+		coex_sta->crc_err_cck	 = btcoexist->btc_read_4byte(btcoexist,
+					   0xf84);
+		coex_sta->crc_err_11g	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf96);
+		coex_sta->crc_err_11n	 = btcoexist->btc_read_2byte(btcoexist,
+					   0xf92);
+		coex_sta->crc_err_11n_agg = btcoexist->btc_read_2byte(btcoexist,
+					    0xfba);
+	}
+
+	/* reset counter */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xf16, 0x1, 0x1);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xf16, 0x1, 0x0);
+}
+
+void halbtc8821a2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+boolean halbtc8821a2ant_is_wifi_status_changed(IN struct btc_coexist *btcoexist)
+{
+	static boolean	pre_wifi_busy = false, pre_under_4way = false,
+			pre_bt_hs_on = false;
+	boolean			wifi_busy = false, under_4way = false, bt_hs_on = false;
+	boolean			wifi_connected = false;
+	u8			wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+			   &under_4way);
+
+	if (wifi_connected) {
+		if (wifi_busy != pre_wifi_busy) {
+			pre_wifi_busy = wifi_busy;
+			return true;
+		}
+		if (under_4way != pre_under_4way) {
+			pre_under_4way = under_4way;
+			return true;
+		}
+		if (bt_hs_on != pre_bt_hs_on) {
+			pre_bt_hs_on = bt_hs_on;
+			return true;
+		}
+
+
+		wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 3,
+			  2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+
+		if ((BTC_RSSI_STATE_HIGH == wifi_rssi_state) ||
+		    (BTC_RSSI_STATE_LOW == wifi_rssi_state))
+			return true;
+
+	}
+
+	return false;
+}
+
+void halbtc8821a2ant_update_bt_link_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	bt_link_info->bt_link_exist = coex_sta->bt_link_exist;
+	bt_link_info->sco_exist = coex_sta->sco_exist;
+	bt_link_info->a2dp_exist = coex_sta->a2dp_exist;
+	bt_link_info->pan_exist = coex_sta->pan_exist;
+	bt_link_info->hid_exist = coex_sta->hid_exist;
+
+	/* work around for HS mode. */
+	if (bt_hs_on) {
+		bt_link_info->pan_exist = true;
+		bt_link_info->bt_link_exist = true;
+	}
+
+	/* check if Sco only */
+	if (bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->sco_only = true;
+	else
+		bt_link_info->sco_only = false;
+
+	/* check if A2dp only */
+	if (!bt_link_info->sco_exist &&
+	    bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->a2dp_only = true;
+	else
+		bt_link_info->a2dp_only = false;
+
+	/* check if Pan only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    bt_link_info->pan_exist &&
+	    !bt_link_info->hid_exist)
+		bt_link_info->pan_only = true;
+	else
+		bt_link_info->pan_only = false;
+
+	/* check if Hid only */
+	if (!bt_link_info->sco_exist &&
+	    !bt_link_info->a2dp_exist &&
+	    !bt_link_info->pan_exist &&
+	    bt_link_info->hid_exist)
+		bt_link_info->hid_only = true;
+	else
+		bt_link_info->hid_only = false;
+}
+
+u8 halbtc8821a2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8821A_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (!bt_link_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No BT link exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (bt_link_info->sco_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->hid_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->pan_exist)
+		num_of_diff_profile++;
+	if (bt_link_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (bt_link_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_HID;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_A2DP;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				{
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+			} else if (bt_link_info->hid_exist &&
+				   bt_link_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS) ==> SCO\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR) ==> SCO\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				}
+			} else if (bt_link_info->pan_exist &&
+				   bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				}
+			}
+		} else {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (bt_link_info->sco_exist) {
+			if (bt_link_info->hid_exist &&
+			    bt_link_info->pan_exist &&
+			    bt_link_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm = BT_8821A_2ANT_COEX_ALGO_SCO;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+void halbtc8821a2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8821a2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				       IN u8 dec_bt_pwr_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = dec_bt_pwr_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x62, 1, h2c_parameter);
+}
+
+void halbtc8821a2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN u8 dec_bt_pwr_lvl)
+{
+	coex_dm->cur_bt_dec_pwr_lvl = dec_bt_pwr_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_dec_pwr_lvl == coex_dm->cur_bt_dec_pwr_lvl)
+			return;
+	}
+	halbtc8821a2ant_set_fw_dec_bt_pwr(btcoexist,
+					  coex_dm->cur_bt_dec_pwr_lvl);
+
+	coex_dm->pre_bt_dec_pwr_lvl = coex_dm->cur_bt_dec_pwr_lvl;
+}
+
+void halbtc8821a2ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+					IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8821a2ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		    IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	halbtc8821a2ant_set_bt_auto_report(btcoexist,
+					   coex_dm->cur_bt_auto_report);
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8821a2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+			      IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8821a2ant_set_fw_dac_swing_level(btcoexist,
+					       coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+void halbtc8821a2ant_set_sw_rf_rx_lpf_corner(IN struct btc_coexist *btcoexist,
+		IN boolean rx_rf_shrink_on)
+{
+	if (rx_rf_shrink_on) {
+		/* Shrink RF Rx LPF corner */
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Shrink RF Rx LPF corner!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff,
+					  0xffffc);
+	} else {
+		/* Resume RF Rx LPF corner */
+		/* After initialized, we can use coex_dm->bt_rf_0x1e_backup */
+		if (btcoexist->initilized) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Resume RF Rx LPF corner!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+					  0xfffff, coex_dm->bt_rf_0x1e_backup);
+		}
+	}
+}
+
+void halbtc8821a2ant_rf_shrink(IN struct btc_coexist *btcoexist,
+		       IN boolean force_exec, IN boolean rx_rf_shrink_on)
+{
+	coex_dm->cur_rf_rx_lpf_shrink = rx_rf_shrink_on;
+
+	if (!force_exec) {
+		if (coex_dm->pre_rf_rx_lpf_shrink ==
+		    coex_dm->cur_rf_rx_lpf_shrink)
+			return;
+	}
+	halbtc8821a2ant_set_sw_rf_rx_lpf_corner(btcoexist,
+						coex_dm->cur_rf_rx_lpf_shrink);
+
+	coex_dm->pre_rf_rx_lpf_shrink = coex_dm->cur_rf_rx_lpf_shrink;
+}
+
+void halbtc8821a2ant_set_sw_penalty_tx_rate_adaptive(IN struct btc_coexist
+		*btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf5;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xa0;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xa0;	/* MCS5 or OFDM36 */
+		/* h2c_parameter[3] = 0xf7;  //MCS7 or OFDM54 */
+		/* h2c_parameter[4] = 0xf8;  //MCS6 or OFDM48 */
+		/* h2c_parameter[5] = 0xf9;	//MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8821a2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			    IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8821a2ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8821a2ant_set_dac_swing_reg(IN struct btc_coexist *btcoexist,
+				       IN u32 level)
+{
+	u8	val = (u8)level;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Write SwDacSwing = 0x%x\n", level);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc5b, 0x3e, val);
+}
+
+void halbtc8821a2ant_set_sw_full_time_dac_swing(IN struct btc_coexist
+		*btcoexist, IN boolean sw_dac_swing_on, IN u32 sw_dac_swing_lvl)
+{
+	if (sw_dac_swing_on)
+		halbtc8821a2ant_set_dac_swing_reg(btcoexist, sw_dac_swing_lvl);
+	else
+		halbtc8821a2ant_set_dac_swing_reg(btcoexist, 0x18);
+}
+
+
+void halbtc8821a2ant_dac_swing(IN struct btc_coexist *btcoexist,
+	IN boolean force_exec, IN boolean dac_swing_on, IN u32 dac_swing_lvl)
+{
+	coex_dm->cur_dac_swing_on = dac_swing_on;
+	coex_dm->cur_dac_swing_lvl = dac_swing_lvl;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_dac_swing_on == coex_dm->cur_dac_swing_on) &&
+		    (coex_dm->pre_dac_swing_lvl ==
+		     coex_dm->cur_dac_swing_lvl))
+			return;
+	}
+	delay_ms(30);
+	halbtc8821a2ant_set_sw_full_time_dac_swing(btcoexist, dac_swing_on,
+			dac_swing_lvl);
+
+	coex_dm->pre_dac_swing_on = coex_dm->cur_dac_swing_on;
+	coex_dm->pre_dac_swing_lvl = coex_dm->cur_dac_swing_lvl;
+}
+
+void halbtc8821a2ant_set_adc_back_off(IN struct btc_coexist *btcoexist,
+				      IN boolean adc_back_off)
+{
+	if (adc_back_off) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x8db, 0x60, 0x3);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x8db, 0x60, 0x1);
+	}
+}
+
+void halbtc8821a2ant_adc_back_off(IN struct btc_coexist *btcoexist,
+			  IN boolean force_exec, IN boolean adc_back_off)
+{
+	coex_dm->cur_adc_back_off = adc_back_off;
+
+	if (!force_exec) {
+		if (coex_dm->pre_adc_back_off == coex_dm->cur_adc_back_off)
+			return;
+	}
+	halbtc8821a2ant_set_adc_back_off(btcoexist, coex_dm->cur_adc_back_off);
+
+	coex_dm->pre_adc_back_off = coex_dm->cur_adc_back_off;
+}
+
+void halbtc8821a2ant_set_agc_table(IN struct btc_coexist *btcoexist,
+				   IN boolean agc_table_en)
+{
+	u8		rssi_adjust_val = 0;
+
+	/* =================BB AGC Gain Table */
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6e1A0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6d1B0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6c1C0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6b1D0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x6a1E0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x691F0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0x68200001);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xaa1A0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa91B0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa81C0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa71D0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa61E0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa51F0001);
+		btcoexist->btc_write_4byte(btcoexist, 0xc78, 0xa4200001);
+	}
+
+
+	/* =================RF Gain */
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x02000);
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x38fff);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x38ffe);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x380c3);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x28ce6);
+	}
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xed, 0xfffff, 0x1);
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x38fff);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x38ffe);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x380c3);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x40, 0xfffff,
+					  0x28ce6);
+	}
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xed, 0xfffff, 0x0);
+
+	/* set rssi_adjust_val for wifi module. */
+	if (agc_table_en)
+		rssi_adjust_val = 8;
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON,
+			   &rssi_adjust_val);
+}
+
+void halbtc8821a2ant_agc_table(IN struct btc_coexist *btcoexist,
+			       IN boolean force_exec, IN boolean agc_table_en)
+{
+	coex_dm->cur_agc_table_en = agc_table_en;
+
+	if (!force_exec) {
+		if (coex_dm->pre_agc_table_en == coex_dm->cur_agc_table_en)
+			return;
+	}
+	halbtc8821a2ant_set_agc_table(btcoexist, agc_table_en);
+
+	coex_dm->pre_agc_table_en = coex_dm->cur_agc_table_en;
+}
+
+void halbtc8821a2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	    IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8821a2ant_coex_table(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8821a2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4, val0x6c8,
+				       val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8821a2ant_coex_table_with_type(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 type)
+{
+	coex_sta->coex_table_type = type;
+
+	switch (type) {
+	case 0:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x55555555, 0xffffff, 0x3);
+		break;
+	case 1:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55555555, 0x5afa5afa, 0xffffff, 0x3);
+		break;
+	case 2:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5ada5ada, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 3:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 4:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0xffffffff, 0xffffffff, 0xffffff, 0x3);
+		break;
+	case 5:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5fff5fff, 0xffffff, 0x3);
+		break;
+	case 6:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55ff55ff, 0x5a5a5a5a, 0xffffff, 0x3);
+		break;
+	case 7:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 8:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 9:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 10:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 11:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 12:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 13:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 14:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5fff5fff, 0x5ada5ada, 0xffffff, 0x3);
+		break;
+	case 15:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x55dd55dd, 0xaaaaaaaa, 0xffffff, 0x3);
+		break;
+	case 16:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0x5fdf5fdf, 0x5fdb5fdb, 0xffffff, 0x3);
+		break;
+	case 17:
+		halbtc8821a2ant_coex_table(btcoexist, force_exec,
+				   0xfafafafa, 0xfafafafa, 0xffffff, 0x3);
+		break;
+	default:
+		break;
+	}
+}
+
+void halbtc8821a2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable) {
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8821a2ant_set_lps_rpwm(IN struct btc_coexist *btcoexist,
+				  IN u8 lps_val, IN u8 rpwm_val)
+{
+	u8	lps = lps_val;
+	u8	rpwm = rpwm_val;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_LPS_VAL, &lps);
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+void halbtc8821a2ant_lps_rpwm(IN struct btc_coexist *btcoexist,
+		      IN boolean force_exec, IN u8 lps_val, IN u8 rpwm_val)
+{
+	coex_dm->cur_lps = lps_val;
+	coex_dm->cur_rpwm = rpwm_val;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_lps == coex_dm->cur_lps) &&
+		    (coex_dm->pre_rpwm == coex_dm->cur_rpwm))
+			return;
+	}
+	halbtc8821a2ant_set_lps_rpwm(btcoexist, lps_val, rpwm_val);
+
+	coex_dm->pre_lps = coex_dm->cur_lps;
+	coex_dm->pre_rpwm = coex_dm->cur_rpwm;
+}
+
+void halbtc8821a2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				     IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	halbtc8821a2ant_set_fw_ignore_wlan_act(btcoexist, enable);
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8821a2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	   IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[5] = {0};
+
+	h2c_parameter[0] = byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = byte5;
+
+	coex_dm->ps_tdma_para[0] = byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = byte5;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 5, h2c_parameter);
+}
+
+void halbtc8821a2ant_sw_mechanism1(IN struct btc_coexist *btcoexist,
+			   IN boolean shrink_rx_lpf, IN boolean low_penalty_ra,
+			   IN boolean limited_dig, IN boolean bt_lna_constrain)
+{
+	/*
+	u32	wifi_bw;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if(BTC_WIFI_BW_HT40 != wifi_bw)
+	{
+		if (shrink_rx_lpf)
+			shrink_rx_lpf = false;
+	}
+	*/
+
+	/* halbtc8821a2ant_rf_shrink(btcoexist, NORMAL_EXEC, shrink_rx_lpf); */
+	halbtc8821a2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, low_penalty_ra);
+}
+
+void halbtc8821a2ant_sw_mechanism2(IN struct btc_coexist *btcoexist,
+			   IN boolean agc_table_shift, IN boolean adc_back_off,
+			   IN boolean sw_dac_swing, IN u32 dac_swing_lvl)
+{
+	/* halbtc8821a2ant_agc_table(btcoexist, NORMAL_EXEC, agc_table_shift); */
+	/* halbtc8821a2ant_adc_back_off(btcoexist, NORMAL_EXEC, adc_back_off); */
+	halbtc8821a2ant_dac_swing(btcoexist, NORMAL_EXEC, sw_dac_swing,
+				  dac_swing_lvl);
+}
+
+void halbtc8821a2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	  IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u32				u32tmp = 0;
+	u8				h2c_parameter[2] = {0};
+
+	if (init_hwcfg) {
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		btcoexist->btc_write_4byte(btcoexist, 0x974, 0x3ff);
+		/* btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x77); */
+
+		if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT) {
+			/* tell firmware "antenna inverse"  ==> WRONG firmware antenna control code.==>need fw to fix */
+			h2c_parameter[0] = 1;
+			h2c_parameter[1] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+						h2c_parameter);
+		} else {
+			/* tell firmware "no antenna inverse" ==> WRONG firmware antenna control code.==>need fw to fix */
+			h2c_parameter[0] = 0;
+			h2c_parameter[1] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+						h2c_parameter);
+		}
+	}
+
+	/* ext switch setting */
+	switch (ant_pos_type) {
+	case BTC_ANT_WIFI_AT_MAIN:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb7,
+						   0x30, 0x1);
+		break;
+	case BTC_ANT_WIFI_AT_AUX:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb7,
+						   0x30, 0x2);
+		break;
+	}
+}
+
+void halbtc8821a2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+		     IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	u8			wifi_rssi_state1, bt_rssi_state;
+
+
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	if (!(BTC_RSSI_HIGH(wifi_rssi_state1) &&
+	      BTC_RSSI_HIGH(bt_rssi_state)) && turn_on) {
+		type = type + 100; /* for WiFi RSSI low or BT RSSI low */
+	}
+
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+	if (turn_on) {
+		switch (type) {
+		case 1:
+		default:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90);
+			break;
+		case 2:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x12, 0x12, 0xe1, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x2d, 0x03, 0xf1, 0x90);
+			break;
+		case 3:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1, 0x90);
+			break;
+		case 4:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x03, 0xf1, 0x90);
+			break;
+		case 5:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x3, 0x70, 0x90);
+			break;
+		case 6:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x12, 0x12, 0x60, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x2d, 0x3, 0x70, 0x90);
+			break;
+		case 7:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x70, 0x90);
+			break;
+		case 8:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x10, 0x3, 0x70, 0x90);
+			break;
+		case 9:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90);
+			break;
+		case 10:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x12, 0x12, 0xe1, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x2d, 0x03, 0xf1, 0x90);
+			break;
+		case 11:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0xa, 0xa, 0xe1, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0xf1, 0x90);
+			break;
+		case 12:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x5, 0x5, 0xe1, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0xf1, 0x90);
+			break;
+		case 13:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x3, 0x70, 0x90);
+			break;
+		case 14:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x12, 0x12, 0x60, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x2d, 0x3, 0x70, 0x90);
+			break;
+		case 15:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0xa, 0xa, 0x60, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1c, 0x3, 0x70, 0x90);
+			break;
+		case 16:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x5, 0x5, 0x60, 0x90); */
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x10, 0x3, 0x70, 0x90);
+			break;
+		case 17:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xa3,
+						      0x2f, 0x2f, 0x60, 0x90);
+			break;
+		case 18:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x5, 0x5, 0xe1, 0x90);
+			break;
+		case 19:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0xe1, 0x90);
+			break;
+		case 20:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x25, 0x25, 0x60, 0x90);
+			break;
+		case 21:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x03, 0x70, 0x90);
+			break;
+		case 23:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x1e, 0x03, 0xf0, 0x14);
+			break;
+		case 24:
+		case 124:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x3c, 0x03, 0x70, 0x50);
+			break;
+		/* case25/case125 : for lenovo bt pan tp degrade<30% while wifi downlink */
+		case 25:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x14, 0x03, 0xf1, 0x90);
+			break;
+		case 26:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x30, 0x03, 0xf1, 0x90);
+			break;
+		case 71:
+			/* halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90); */
+
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90);
+			break;
+		case 101:
+		case 105:
+		case 171:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x3a, 0x03, 0x70, 0x50);
+			break;
+		case 102:
+		case 106:
+		case 110:
+		case 114:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x2d, 0x03, 0x70, 0x50);
+			break;
+		case 103:
+		case 107:
+		case 111:
+		case 115:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1c, 0x03, 0x70, 0x50);
+			break;
+		case 104:
+		case 108:
+		case 112:
+		case 116:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x10, 0x03, 0x70, 0x50);
+			break;
+		case 109:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0xf1, 0x90);
+			break;
+		case 113:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x3c, 0x03, 0x70, 0x90);
+			break;
+		case 121:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x15, 0x03, 0x70, 0x90);
+			break;
+		case 22:
+		case 122:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xe3,
+						      0x35, 0x03, 0x71, 0x11);
+			break;
+		case 123:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x1c, 0x03, 0x70, 0x54);
+			break;
+		/* case25/case125 : for lenovo bt pan tp degrade<30% while wifi downlink */
+		case 125:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x14, 0x03, 0x70, 0x50);
+			break;
+		case 126:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0xd3,
+						      0x30, 0x03, 0x70, 0x50);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 0:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		case 1:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x48, 0x0);
+			break;
+		default:
+			halbtc8821a2ant_set_fw_pstdma(btcoexist, 0x0,
+						      0x0, 0x0, 0x40, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8821a2ant_ps_tdma_check_for_power_save_state(
+	IN struct btc_coexist *btcoexist, IN boolean new_ps_state)
+{
+	u8	lps_mode = 0x0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_LPS_MODE, &lps_mode);
+
+	if (lps_mode) {	/* already under LPS state */
+		if (new_ps_state) {
+			/* keep state under LPS, do nothing. */
+		} else {
+			/* will leave LPS state, turn off psTdma first */
+			halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+		}
+	} else {					/* NO PS state */
+		if (new_ps_state) {
+			/* will enter LPS state, turn off psTdma first */
+			halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+		} else {
+			/* keep state under NO PS state, do nothing. */
+		}
+	}
+}
+
+void halbtc8821a2ant_power_save_state(IN struct btc_coexist *btcoexist,
+			      IN u8 ps_type, IN u8 lps_val, IN u8 rpwm_val)
+{
+	boolean		low_pwr_disable = false;
+
+	switch (ps_type) {
+	case BTC_PS_WIFI_NATIVE:
+		/* recover to original 32k low power setting */
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_NORMAL_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	case BTC_PS_LPS_ON:
+		halbtc8821a2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, true);
+		halbtc8821a2ant_lps_rpwm(btcoexist, NORMAL_EXEC,
+					 lps_val, rpwm_val);
+		/* when coex force to enter LPS, do not enter 32k low power. */
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist,
+				   BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		/* power save must executed before psTdma.			 */
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_ENTER_LPS,
+				   NULL);
+		coex_sta->force_lps_on = true;
+		break;
+	case BTC_PS_LPS_OFF:
+		halbtc8821a2ant_ps_tdma_check_for_power_save_state(
+			btcoexist, false);
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_LEAVE_LPS,
+				   NULL);
+		coex_sta->force_lps_on = false;
+		break;
+	default:
+		break;
+	}
+}
+
+
+void halbtc8821a2ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* fw all off */
+	halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8821a2ant_coex_under_5g(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a2ant_coex_all_off(btcoexist);
+
+	halbtc8821a2ant_ignore_wlan_act(btcoexist, NORMAL_EXEC, true);
+}
+
+void halbtc8821a2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8821a2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8821a2ant_dec_bt_pwr(btcoexist, FORCE_EXEC, 0);
+
+	halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+void halbtc8821a2ant_action_bt_inquiry(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	boolean	wifi_connected = false;
+	boolean	low_pwr_disable = true;
+	boolean		scan = false, link = false, roam = false;
+
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+			   &low_pwr_disable);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+
+	halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	if (scan || link || roam) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi link process + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     15);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+	} else if (wifi_connected) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi connected + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     15);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi no-link + BT Inq/Page!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	}
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+}
+
+
+void halbtc8821a2ant_action_wifi_link_process(IN struct btc_coexist *btcoexist)
+{
+	u8	u8tmpa, u8tmpb;
+
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 15);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+
+	halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+
+
+	u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "############# [BTCoex], 0x765=0x%x, 0x76e=0x%x\n", u8tmpa,
+		    u8tmpb);
+	BTC_TRACE(trace_buf);
+}
+
+boolean halbtc8821a2ant_action_wifi_idle_process(IN struct btc_coexist
+		*btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u8		ap_num = 0;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	/* wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2, BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0); */
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES - 20, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM, &ap_num);
+
+	/* define the office environment */
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) &&
+	    (coex_sta->hid_exist == true) &&
+	    (coex_sta->a2dp_exist == true)) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi  idle process for BT HID+A2DP exist!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_dac_swing(btcoexist, NORMAL_EXEC, true, 0x6);
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		/* sw all off */
+		halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+		return true;
+	}
+
+	/*  */
+	else if (coex_sta->pan_exist == true) {
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Wifi  idle process for BT PAN exist!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821a2ant_dac_swing(btcoexist, NORMAL_EXEC, true, 0x6);
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		/* sw all off */
+		halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+		return true;
+	}
+
+	else {
+		halbtc8821a2ant_dac_swing(btcoexist, NORMAL_EXEC, true, 0x18);
+		return false;
+	}
+
+
+}
+
+
+
+boolean halbtc8821a2ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+	boolean			bt_hs_on = false, low_pwr_disable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected) {
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+		halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi non-connected idle!!\n");
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+		halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false,
+					      false);
+		halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false,
+					      0x18);
+
+		common = true;
+	} else {
+		if (BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+		    coex_dm->bt_status) {
+			low_pwr_disable = false;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+			halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, false, 0x8);
+
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT non connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+			halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+			halbtc8821a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+			halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 0xb);
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false,
+						      false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else if (BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE ==
+			   coex_dm->bt_status) {
+			low_pwr_disable = true;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+
+			if (bt_hs_on)
+				return false;
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Wifi connected + BT connected-idle!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC,
+						   false, false, 0x8);
+
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+			halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 0);
+
+			halbtc8821a2ant_power_save_state(btcoexist,
+						 BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+			halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+						1);
+			halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 0xb);
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+
+			common = true;
+		} else {
+			low_pwr_disable = true;
+			btcoexist->btc_set(btcoexist,
+					   BTC_SET_ACT_DISABLE_LOW_POWER,
+					   &low_pwr_disable);
+
+			if (wifi_busy) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Busy + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				common = false;
+				/* common = halbtc8821a2ant_action_wifi_idle_process(btcoexist);	 */
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Wifi Connected-Idle + BT Busy!!\n");
+				BTC_TRACE(trace_buf);
+				/* common = false;	 */
+				common = halbtc8821a2ant_action_wifi_idle_process(
+						 btcoexist);
+			}
+		}
+	}
+
+	return common;
+}
+void halbtc8821a2ant_tdma_duration_adjust(IN struct btc_coexist *btcoexist,
+		IN boolean sco_hid, IN boolean tx_pause, IN u8 max_interval)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0;
+
+	if (!coex_dm->auto_tdma_adjust) {
+		coex_dm->auto_tdma_adjust = true;
+		{
+			if (sco_hid) {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					} else if (max_interval == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (max_interval == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					} else if (max_interval == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (max_interval == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			} else {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (max_interval == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (max_interval == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (max_interval == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (max_interval == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					}
+				}
+			}
+		}
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* accquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if s n 2 retry count0, heWiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if s 2 2 retry count< 3, hWiFi duration */
+				if (wait_count <= 2)
+					m++; /* K@blevel^ */
+				else
+					m = 1;
+
+				if (m >= 20)  /* m j = 20 ' j120 recheckO_ WiFi duration. */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, un1 retry count > 3, hWiFi duration */
+			if (wait_count == 1)
+				m++; /* K@blevel^ */
+			else
+				m = 1;
+
+			if (m >= 20)  /* m j = 20 ' j120 recheckO_ WiFi duration. */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (max_interval == 1) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 71) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 13);
+					coex_dm->ps_tdma_du_adj_type = 13;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 71);
+					coex_dm->ps_tdma_du_adj_type = 71;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 9);
+					coex_dm->ps_tdma_du_adj_type = 9;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 71) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 71);
+						coex_dm->ps_tdma_du_adj_type =
+							71;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					}
+				}
+			}
+		} else if (max_interval == 2) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					}
+				}
+			}
+		} else if (max_interval == 3) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8821a2ant_ps_tdma(btcoexist,
+							NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821a2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			}
+		}
+	}
+
+	/* if current PsTdma not match with the recorded one (when scan, dhcp...), */
+	/* then we have to adjust it back to the previous record one. */
+	if (coex_dm->cur_ps_tdma != coex_dm->ps_tdma_du_adj_type) {
+		boolean	scan = false, link = false, roam = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], PsTdma type dismatch!!!, cur_ps_tdma=%d, recordPsTdma=%d\n",
+			    coex_dm->cur_ps_tdma, coex_dm->ps_tdma_du_adj_type);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (!scan && !link && !roam)
+			halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						coex_dm->ps_tdma_du_adj_type);
+		else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+}
+
+/* SCO only or SCO+PAN(HS) */
+void halbtc8821a2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8	wifi_rssi_state, bt_rssi_state;
+	u32	wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 4);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for SCO quality at 11b/g mode */
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+	else { /* for SCO quality & wifi performance balance at 11n mode */
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 8);
+		else {
+			if (bt_link_info->sco_only)
+				halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 17);
+			else
+				halbtc8821a2ant_coex_table_with_type(btcoexist,
+							     NORMAL_EXEC, 12);
+		}
+	}
+
+	halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false,
+				0); /* for voice quality */
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      true, 0x18);
+		}
+	}
+}
+
+
+void halbtc8821a2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	u8	wifi_rssi_state, bt_rssi_state;
+	u32	wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for HID at 11b/g mode */
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+	else  /* for HID quality & wifi performance balance at 11n mode */
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 2);
+
+	halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 24);
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8821a2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+	u8		ap_num = 0;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM, &ap_num);
+
+	/* define the office environment */
+	if ((ap_num >= 10) && BTC_RSSI_HIGH(wifi_rssi_state1) &&
+	    BTC_RSSI_HIGH(bt_rssi_state)) {
+		/* dbg_print(" AP#>10(%d)\n", ap_num); */
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+		halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false,
+					   0x8);
+		halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+		/* halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1); */
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+
+		/* sw mechanism */
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      true, 0x6);
+		}
+		return;
+
+	}
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	}
+
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		/* halbtc8821a2ant_tdma_duration_adjust(btcoexist, false, false, 1); */
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+	} else {
+		/* halbtc8821a2ant_tdma_duration_adjust(btcoexist, false, true, 1); */
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+	}
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8821a2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	}
+
+	halbtc8821a2ant_tdma_duration_adjust(btcoexist, false, true, 2);
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8821a2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     10);
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	}
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 26);
+	else
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 26);
+
+	/* sw mechanism */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+
+/* PAN(HS) only */
+void halbtc8821a2ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+
+	halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* PAN(EDR)+A2DP */
+void halbtc8821a2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	else
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     12);
+
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			halbtc8821a2ant_tdma_duration_adjust(btcoexist, false,
+							     true, 3);
+		else
+			halbtc8821a2ant_tdma_duration_adjust(btcoexist, false,
+							     false, 3);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     13);
+		halbtc8821a2ant_tdma_duration_adjust(btcoexist, false, true, 3);
+	}
+
+	/* sw mechanism	 */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, false,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8821a2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     14);
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	}
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		if (BTC_WIFI_BW_HT40 == wifi_bw) {
+			halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 3);
+			/* halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 11); */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x780);
+		} else {
+			halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+							 6);
+			/* halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7); */
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1,
+						  0xfffff, 0x0);
+		}
+		halbtc8821a2ant_tdma_duration_adjust(btcoexist, true, false, 2);
+	} else {
+		halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		/* halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 14); */
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+					  0x0);
+		halbtc8821a2ant_tdma_duration_adjust(btcoexist, true, true, 2);
+	}
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8821a2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1,  bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, false, 0x8);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (BTC_RSSI_HIGH(bt_rssi_state))
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+	else
+		halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     14);
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			halbtc8821a2ant_tdma_duration_adjust(btcoexist, true,
+							     true, 3);
+		else
+			halbtc8821a2ant_tdma_duration_adjust(btcoexist, true,
+							     false, 3);
+	} else
+		halbtc8821a2ant_tdma_duration_adjust(btcoexist, true, true, 3);
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8821a2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, wifi_rssi_state1, bt_rssi_state;
+	u32		wifi_bw;
+	u8		ap_num = 0;
+
+	wifi_rssi_state = halbtc8821a2ant_wifi_rssi_state(btcoexist, 0, 2, 15,
+			  0);
+	/* bt_rssi_state = halbtc8821a2ant_bt_rssi_state(2, 29, 0); */
+	wifi_rssi_state1 = halbtc8821a2ant_wifi_rssi_state(btcoexist, 1, 2,
+			   BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	bt_rssi_state = halbtc8821a2ant_bt_rssi_state(3,
+			BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES, 37);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+
+	halbtc8821a2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true, 0x5);
+
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) {
+		if (BTC_RSSI_HIGH(bt_rssi_state))
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	} else {
+		/* only 802.11N mode we have to dec bt power to 4 degree */
+		if (BTC_RSSI_HIGH(bt_rssi_state)) {
+			btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+					   &ap_num);
+			/* need to check ap Number of Not */
+			if (ap_num < 10)
+				halbtc8821a2ant_dec_bt_pwr(btcoexist,
+							   NORMAL_EXEC, 4);
+			else
+				halbtc8821a2ant_dec_bt_pwr(btcoexist,
+							   NORMAL_EXEC, 2);
+		} else if (BTC_RSSI_MEDIUM(bt_rssi_state))
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 2);
+		else
+			halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+	}
+
+	if (BTC_RSSI_HIGH(wifi_rssi_state1) && BTC_RSSI_HIGH(bt_rssi_state)) {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 7);
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE,
+						 0x0, 0x0);
+	} else {
+		halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC,
+						     14);
+		halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_LPS_ON, 0x50,
+						 0x4);
+	}
+
+	if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+	    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+		/* halbtc8821a2ant_tdma_duration_adjust(btcoexist, true, false, 3); */
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+	} else {
+		/* halbtc8821a2ant_tdma_duration_adjust(btcoexist, true, true, 3); */
+		halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+	}
+
+	/* sw mechanism */
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, true, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	} else {
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, true, false,
+						      false, 0x18);
+		} else {
+			halbtc8821a2ant_sw_mechanism1(btcoexist, false, true,
+						      false, false);
+			halbtc8821a2ant_sw_mechanism2(btcoexist, false, false,
+						      false, 0x18);
+		}
+	}
+}
+
+void halbtc8821a2ant_action_bt_whck_test(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+}
+
+void halbtc8821a2ant_action_wifi_multi_port(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821a2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8821a2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, 0);
+
+	/* sw all off */
+	halbtc8821a2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821a2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	/* btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); */
+	halbtc8821a2ant_coex_table_with_type(btcoexist, NORMAL_EXEC, 0);
+
+	halbtc8821a2ant_power_save_state(btcoexist, BTC_PS_WIFI_NATIVE, 0x0,
+					 0x0);
+	halbtc8821a2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+}
+
+void halbtc8821a2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	boolean				wifi_under_5g = false;
+	u8				algorithm = 0;
+	u32				num_of_wifi_link = 0;
+	u32				wifi_link_status = 0;
+	struct  btc_bt_link_info *bt_link_info = &btcoexist->bt_link_info;
+	boolean				miracast_plus_bt = false;
+	boolean				scan = false, link = false, roam = false;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], RunCoexistMechanism()===>\n");
+	BTC_TRACE(trace_buf);
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), return for Manual CTRL <===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), run 5G coex setting!!<===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	if (coex_sta->under_ips) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], wifi is under IPS !!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	if (coex_sta->bt_whck_test) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under WHCK TEST!!!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_bt_whck_test(btcoexist);
+		return;
+	}
+
+	algorithm = halbtc8821a2ant_action_algorithm(btcoexist);
+	if (coex_sta->c2h_bt_inquiry_page &&
+	    (BT_8821A_2ANT_COEX_ALGO_PANHS != algorithm)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is under inquiry/page scan !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_bt_inquiry(btcoexist);
+		return;
+	} else {
+
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+	if (scan || link || roam) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], WiFi is under Link Process !!\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_action_wifi_link_process(btcoexist);
+		return;
+	}
+
+	/* for P2P */
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_LINK_STATUS,
+			   &wifi_link_status);
+	num_of_wifi_link = wifi_link_status >> 16;
+
+	if ((num_of_wifi_link >= 2) ||
+	    (wifi_link_status & WIFI_P2P_GO_CONNECTED)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"############# [BTCoex],  Multi-Port num_of_wifi_link = %d, wifi_link_status = 0x%x\n",
+			    num_of_wifi_link, wifi_link_status);
+		BTC_TRACE(trace_buf);
+
+		if (bt_link_info->bt_link_exist)
+			miracast_plus_bt = true;
+		else
+			miracast_plus_bt = false;
+
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+		halbtc8821a2ant_action_wifi_multi_port(btcoexist);
+
+		return;
+	} else {
+		miracast_plus_bt = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_MIRACAST_PLUS_BT,
+				   &miracast_plus_bt);
+	}
+
+	coex_dm->cur_algorithm = algorithm;
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Algorithm = %d\n",
+		    coex_dm->cur_algorithm);
+	BTC_TRACE(trace_buf);
+
+	if (halbtc8821a2ant_is_common_action(btcoexist)) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Action 2-Ant common.\n");
+		BTC_TRACE(trace_buf);
+		coex_dm->auto_tdma_adjust = false;
+	} else {
+		if (coex_dm->cur_algorithm != coex_dm->pre_algorithm) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], pre_algorithm=%d, cur_algorithm=%d\n",
+				coex_dm->pre_algorithm, coex_dm->cur_algorithm);
+			BTC_TRACE(trace_buf);
+			coex_dm->auto_tdma_adjust = false;
+		}
+		switch (coex_dm->cur_algorithm) {
+		case BT_8821A_2ANT_COEX_ALGO_SCO:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_sco(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_hid(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_a2dp(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_A2DP_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_a2dp_pan_hs(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_pan_edr(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_PANHS:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HS mode.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_pan_hs(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_PANEDR_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_pan_edr_a2dp(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_PANEDR_HID:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_pan_edr_hid(btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_hid_a2dp_pan_edr(
+				btcoexist);
+			break;
+		case BT_8821A_2ANT_COEX_ALGO_HID_A2DP:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_action_hid_a2dp(btcoexist);
+			break;
+		default:
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_coex_all_off(btcoexist);
+			break;
+		}
+		coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+	}
+}
+
+void halbtc8821a2ant_wifi_off_hw_cfg(IN struct btc_coexist *btcoexist)
+{
+	u8 h2c_parameter[2] = {0};
+	u32 fw_ver = 0;
+
+	/* set wlan_act to low */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x4);
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1, 0xfffff,
+			  0x780); /* WiFi goto standby while GNT_BT 0-->1 */
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	if (fw_ver >= 0x180000) {
+		/* Use H2C to set GNT_BT to HIGH */
+		h2c_parameter[0] = 1;
+		btcoexist->btc_fill_h2c(btcoexist, 0x6E, 1, h2c_parameter);
+	} else
+		btcoexist->btc_write_1byte(btcoexist, 0x765, 0x18);
+}
+
+void halbtc8821a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				    IN boolean back_up)
+{
+	u8	u8tmp = 0;
+
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	/* backup rf 0x1e value */
+	coex_dm->bt_rf_0x1e_backup =
+		btcoexist->btc_get_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff);
+
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+
+	/* Antenna config	 */
+	halbtc8821a2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN, true,
+				     false);
+	coex_sta->dis_ver_info_cnt = 0;
+
+	/* PTA parameter */
+	halbtc8821a2ant_coex_table_with_type(btcoexist, FORCE_EXEC, 0);
+
+	/* Enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e,
+			   0x4); /* 0x76e[3] =1, WLAN_Act control by PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x3);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+}
+
+/* ************************************************************
+ * work around function start with wa_halbtc8821a2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8821a2ant_
+ * ************************************************************ */
+void ex_halbtc8821a2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+
+}
+
+void ex_halbtc8821a2ant_pre_load_firmware(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u8 u8tmp = 0x4; /* Set BIT2 by default since it's 2ant case */
+
+	/*  */
+	/* S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info) */
+	/* Local setting bit define */
+	/*	BIT0: "0" for no antenna inverse; "1" for antenna inverse  */
+	/*	BIT1: "0" for internal switch; "1" for external switch */
+	/*	BIT2: "0" for one antenna; "1" for two antenna */
+	/* NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0 */
+	if (btcoexist->chip_interface == BTC_INTF_USB) {
+		/* fixed at S0 for USB interface */
+		u8tmp |= 0x1;	/* antenna inverse */
+		btcoexist->btc_write_local_reg_1byte(btcoexist, 0xfe08, u8tmp);
+	} else {
+		/* for PCIE and SDIO interface, we check efuse 0xc3[6] */
+		if (board_info->single_ant_path == 0) {
+		} else if (board_info->single_ant_path == 1) {
+			/* set to S0 */
+			u8tmp |= 0x1;	/* antenna inverse */
+		}
+
+		if (btcoexist->chip_interface == BTC_INTF_PCI)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x384,
+							     u8tmp);
+		else if (btcoexist->chip_interface == BTC_INTF_SDIO)
+			btcoexist->btc_write_local_reg_1byte(btcoexist, 0x60,
+							     u8tmp);
+	}
+}
+
+void ex_halbtc8821a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only)
+{
+	halbtc8821a2ant_init_hw_config(btcoexist, true);
+}
+
+void ex_halbtc8821a2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821a2ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8821a2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_bt_link_info	*bt_link_info = &btcoexist->bt_link_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u32				fa_of_dm, fa_cck;
+	u32				fw_ver = 0, bt_patch_ver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			"\r\n ============[Under Manual Control]============");
+		CL_PRINTF(cli_buf);
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n ==========================================");
+		CL_PRINTF(cli_buf);
+	}
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%x/ 0x%x/ 0x%x(%d)",
+		   "CoexVer/ FwVer/ PatchVer",
+		   glcoex_ver_date_8821a_2ant, glcoex_ver_8821a_2ant, fw_ver,
+		   bt_patch_ver, bt_patch_ver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %ddBm/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->bt_disabled) ? ("disabled") :	((
+		   coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan")
+			   : ((BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE ==
+			       coex_dm->bt_status) ? "non-connected idle" :
+		((BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE == coex_dm->bt_status)
+				       ? "connected-idle" : "busy")))),
+		   coex_sta->bt_rssi - 100, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d",
+		   "SCO/HID/PAN/A2DP",
+		   bt_link_info->sco_exist, bt_link_info->hid_exist,
+		   bt_link_info->pan_exist, bt_link_info->a2dp_exist);
+	CL_PRINTF(cli_buf);
+
+	{
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+			   "BT Role",
+			   (bt_link_info->slave_role) ? "Slave" : "Master");
+		CL_PRINTF(cli_buf);
+	}
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8821A_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8821a_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	/* Sw mechanism	 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Sw mechanism]============");
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ",
+		   "SM1[ShRf/ LpRA/ LimDig]",
+		   coex_dm->cur_rf_rx_lpf_shrink, coex_dm->cur_low_penalty_ra,
+		   coex_dm->limited_dig);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ",
+		   "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]",
+		   coex_dm->cur_agc_table_en, coex_dm->cur_adc_back_off,
+		   coex_dm->cur_dac_swing_on, coex_dm->cur_dac_swing_lvl);
+	CL_PRINTF(cli_buf);
+
+	/* Fw mechanism		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Fw mechanism]============");
+	CL_PRINTF(cli_buf);
+
+	ps_tdma_case = coex_dm->cur_ps_tdma;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d (auto:%d)",
+		   "PS TDMA",
+		   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+		   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+		   coex_dm->ps_tdma_para[4], ps_tdma_case,
+		   coex_dm->auto_tdma_adjust);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d",
+		   "Coex Table Type",
+		   coex_sta->coex_table_type);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "DecBtPwr/ IgnWlanAct",
+		   coex_dm->cur_bt_dec_pwr_lvl, coex_dm->cur_ignore_wlan_act);
+	CL_PRINTF(cli_buf);
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x",
+		   "RF-A, 0x1e initVal",
+		   coex_dm->bt_rf_0x1e_backup);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xc5b);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x880);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x778/0x880[29:25]/0xc58[29:25]",
+		   u8tmp[0], (u32tmp[0] & 0x3e000000) >> 25,
+		   ((u8tmp[1] & 0x3e) >> 1));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x764);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x764/ 0x765/ 0x76e",
+		   (u32tmp[0] & 0xff), (u32tmp[0] & 0xff00) >> 8, u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xcb4[7:0](ctrl)/ 0xcb4[29:28](val)",
+		   u32tmp[0] & 0xff, ((u32tmp[0] & 0x30000000) >> 28));
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x974);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x40/ 0x4c[24:23]/ 0x974",
+		   u8tmp[0], ((u32tmp[0] & 0x01800000) >> 23), u32tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x49c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xc50(dig)/0x49c(null-drop)",
+		   u32tmp[0] & 0xff, u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xda0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0xda4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0xda8);
+	u32tmp[3] = btcoexist->btc_read_4byte(btcoexist, 0xcf0);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xa5b);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xa5c);
+
+	fa_of_dm = ((u32tmp[0] & 0xffff0000) >> 16) + ((u32tmp[1] & 0xffff0000)
+			>> 16) + (u32tmp[1] & 0xffff) + (u32tmp[2] & 0xffff) + \
+		   ((u32tmp[3] & 0xffff0000) >> 16) + (u32tmp[3] &
+				   0xffff) ;
+	fa_cck = (u8tmp[0] << 8) + u8tmp[1];
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "OFDM-CCA/OFDM-FA/CCK-FA",
+		   u32tmp[0] & 0xffff, fa_of_dm, fa_cck);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_OK CCK/11g/11n/11n-Agg",
+		   coex_sta->crc_ok_cck, coex_sta->crc_ok_11g,
+		   coex_sta->crc_ok_11n, coex_sta->crc_ok_11n_agg);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d",
+		   "CRC_Err CCK/11g/11n/11n-Agg",
+		   coex_sta->crc_err_cck, coex_sta->crc_err_11g,
+		   coex_sta->crc_err_11n, coex_sta->crc_err_11n_agg);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)",
+		   u32tmp[0], u32tmp[1], u32tmp[2], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770(high-pri rx/tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri rx/tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+#if (BT_AUTO_REPORT_ONLY_8821A_2ANT == 1)
+	/* halbtc8821a2ant_monitor_bt_ctr(btcoexist); */
+#endif
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8821a2ant_ips_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		halbtc8821a2ant_wifi_off_hw_cfg(btcoexist);
+		halbtc8821a2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+		halbtc8821a2ant_coex_all_off(btcoexist);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+		halbtc8821a2ant_init_hw_config(btcoexist, false);
+		halbtc8821a2ant_init_coex_dm(btcoexist);
+		halbtc8821a2ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8821a2ant_lps_notify(IN struct btc_coexist *btcoexist, IN u8 type)
+{
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8821a2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type)
+{
+	u8	u8tmpa, u8tmpb;
+
+	u8tmpa = btcoexist->btc_read_1byte(btcoexist, 0x765);
+	u8tmpb = btcoexist->btc_read_1byte(btcoexist, 0x76e);
+
+	if (BTC_SCAN_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_SCAN_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "############# [BTCoex], 0x765=0x%x, 0x76e=0x%x\n", u8tmpa,
+		    u8tmpb);
+	BTC_TRACE(trace_buf);
+}
+
+void ex_halbtc8821a2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	if (BTC_ASSOCIATE_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_ASSOCIATE_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8821a2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+	u8			ap_num = 0;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] = 0x1;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else {
+			btcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM,
+					   &ap_num);
+			if (ap_num < 10)
+				h2c_parameter[2] = 0x30;
+			else
+				h2c_parameter[2] = 0x20;
+		}
+	}
+
+	coex_dm->wifi_chnl_info[0] = h2c_parameter[0];
+	coex_dm->wifi_chnl_info[1] = h2c_parameter[1];
+	coex_dm->wifi_chnl_info[2] = h2c_parameter[2];
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x66, 3, h2c_parameter);
+}
+
+void ex_halbtc8821a2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	if (type == BTC_PACKET_DHCP) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], DHCP Packet notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8821a2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length)
+{
+	u8			bt_info = 0;
+	u8			i, rsp_source = 0;
+	boolean			bt_busy = false, limited_dig = false;
+	boolean			wifi_connected = false, wifi_under_5g = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8821A_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8821A_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), return for Manual CTRL<===\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	/* if 0xff, it means BT is under WHCK test */
+	if (bt_info == 0xff)
+		coex_sta->bt_whck_test = true;
+	else
+		coex_sta->bt_whck_test = false;
+
+	if (BT_INFO_SRC_8821A_2ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+		coex_sta->bt_tx_rx_mask = (coex_sta->bt_info_c2h[rsp_source][2]
+					   & 0x40);
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TX_RX_MASK,
+				   &coex_sta->bt_tx_rx_mask);
+		if (coex_sta->bt_tx_rx_mask) {
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x01 => Need to switch BT TRx Mask */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x01\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF,
+						  0x3c, 0x01);
+		}
+
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if ((coex_sta->bt_info_ext & BIT(1))) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT ext info bit1 check, send wifi BW&Chnl to BT!!\n");
+			BTC_TRACE(trace_buf);
+			if (wifi_connected)
+				ex_halbtc8821a2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8821a2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+
+
+		if (!btcoexist->manual_control && !wifi_under_5g) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT ext info = 0x%x!!\n",
+				    coex_sta->bt_info_ext);
+			BTC_TRACE(trace_buf);
+			if ((coex_sta->bt_info_ext & BIT(3))) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3=1, wifi_connected=%d\n",
+					    wifi_connected);
+				BTC_TRACE(trace_buf);
+				if (wifi_connected) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n");
+					BTC_TRACE(trace_buf);
+					halbtc8821a2ant_ignore_wlan_act(
+						btcoexist, FORCE_EXEC, false);
+				}
+			} else {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], BT ext info bit3=0, wifi_connected=%d\n",
+					    wifi_connected);
+				BTC_TRACE(trace_buf);
+				/* BT already NOT ignore Wlan active, do nothing here. */
+				if (!wifi_connected) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], BT ext info bit3 check, set BT to ignore Wlan active!!\n");
+					BTC_TRACE(trace_buf);
+					halbtc8821a2ant_ignore_wlan_act(
+						btcoexist, FORCE_EXEC, true);
+				}
+			}
+		}
+
+#if (BT_AUTO_REPORT_ONLY_8821A_2ANT == 0)
+		if ((coex_sta->bt_info_ext & BIT(4))) {
+			/* BT auto report already enabled, do nothing */
+		} else
+			halbtc8821a2ant_bt_auto_report(btcoexist, FORCE_EXEC,
+						       true);
+#endif
+	}
+
+	/* check BIT2 first ==> check if bt is under inquiry or page scan */
+	if (bt_info & BT_INFO_8821A_2ANT_B_INQ_PAGE)
+		coex_sta->c2h_bt_inquiry_page = true;
+	else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+	/* set link exist status */
+	if (!(bt_info & BT_INFO_8821A_2ANT_B_CONNECTION)) {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+	} else {	/* connection exists */
+		coex_sta->bt_link_exist = true;
+		if (bt_info & BT_INFO_8821A_2ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+		if (bt_info & BT_INFO_8821A_2ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+		if (bt_info & BT_INFO_8821A_2ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+		if (bt_info & BT_INFO_8821A_2ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+
+		if ((coex_sta->hid_exist == false) &&
+		    (coex_sta->c2h_bt_inquiry_page == false) &&
+		    (coex_sta->sco_exist == false)) {
+			if (coex_sta->high_priority_tx  +
+			    coex_sta->high_priority_rx >= 160)
+				coex_sta->hid_exist = true;
+		}
+	}
+
+	halbtc8821a2ant_update_bt_link_info(btcoexist);
+
+	if (!(bt_info & BT_INFO_8821A_2ANT_B_CONNECTION)) {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Connected idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info ==
+		BT_INFO_8821A_2ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT Connected-idle!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if ((bt_info & BT_INFO_8821A_2ANT_B_SCO_ESCO) ||
+		   (bt_info & BT_INFO_8821A_2ANT_B_SCO_BUSY)) {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_SCO_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT SCO busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else if (bt_info & BT_INFO_8821A_2ANT_B_ACL_BUSY) {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_ACL_BUSY;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BtInfoNotify(), BT ACL busy!!!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		coex_dm->bt_status = BT_8821A_2ANT_BT_STATUS_MAX;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], BtInfoNotify(), BT Non-Defined state!!!\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	if ((BT_8821A_2ANT_BT_STATUS_ACL_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_2ANT_BT_STATUS_SCO_BUSY == coex_dm->bt_status) ||
+	    (BT_8821A_2ANT_BT_STATUS_ACL_SCO_BUSY == coex_dm->bt_status)) {
+		bt_busy = true;
+		limited_dig = true;
+	} else {
+		bt_busy = false;
+		limited_dig = false;
+	}
+
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	coex_dm->limited_dig = limited_dig;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_LIMITED_DIG, &limited_dig);
+
+	halbtc8821a2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8821a2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821a2ant_wifi_off_hw_cfg(btcoexist);
+	/* remove due to interrupt is disabled that polling c2h will fail and delay 100ms. */
+	/* btcoexist->btc_set_bt_reg(btcoexist, BTC_BT_REG_RF, 0x3c, 0x15); //BT goto standby while GNT_BT 1-->0 */
+	halbtc8821a2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+	ex_halbtc8821a2ant_media_status_notify(btcoexist, BTC_MEDIA_DISCONNECT);
+}
+
+void ex_halbtc8821a2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821a2ant_init_hw_config(btcoexist, false);
+		halbtc8821a2ant_init_coex_dm(btcoexist);
+		halbtc8821a2ant_query_bt_info(btcoexist);
+	}
+}
+
+void ex_halbtc8821a2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], ==========================Periodical===========================\n");
+	BTC_TRACE(trace_buf);
+
+	if (coex_sta->dis_ver_info_cnt <= 5) {
+		coex_sta->dis_ver_info_cnt += 1;
+		if (coex_sta->dis_ver_info_cnt == 3) {
+			/* Antenna config to set 0x765 = 0x0 (GNT_BT control by PTA) after initial */
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Set GNT_BT control by PTA\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821a2ant_set_ant_path(btcoexist,
+				     BTC_ANT_WIFI_AT_MAIN, false, false);
+		}
+	}
+
+#if (BT_AUTO_REPORT_ONLY_8821A_2ANT == 0)
+	halbtc8821a2ant_query_bt_info(btcoexist);
+	halbtc8821a2ant_monitor_bt_enable_disable(btcoexist);
+#else
+	halbtc8821a2ant_monitor_bt_ctr(btcoexist);
+	halbtc8821a2ant_monitor_wifi_ctr(btcoexist);
+
+	if (halbtc8821a2ant_is_wifi_status_changed(btcoexist) ||
+	    coex_dm->auto_tdma_adjust)
+		halbtc8821a2ant_run_coexist_mechanism(btcoexist);
+#endif
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a2Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a2Ant.h
new file mode 100644
index 000000000..73252dd1f
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821a2Ant.h
@@ -0,0 +1,205 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8821A 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_AUTO_REPORT_ONLY_8821A_2ANT				1
+
+
+#define	BT_INFO_8821A_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8821A_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8821A_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8821A_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8821A_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8821A_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8821A_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8821A_2ANT_B_CONNECTION				BIT(0)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8821A_2ANT		2
+
+
+#define	BT_8821A_2ANT_WIFI_RSSI_COEXSWITCH_THRES				42  /* WiFi RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation */
+#define	BT_8821A_2ANT_BT_RSSI_COEXSWITCH_THRES				46 /* BT RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation */
+
+enum bt_info_src_8821a_2ant {
+	BT_INFO_SRC_8821A_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8821A_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8821A_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8821A_2ANT_MAX
+};
+
+enum bt_8821a_2ant_bt_status {
+	BT_8821A_2ANT_BT_STATUS_NON_CONNECTED_IDLE	= 0x0,
+	BT_8821A_2ANT_BT_STATUS_CONNECTED_IDLE		= 0x1,
+	BT_8821A_2ANT_BT_STATUS_INQ_PAGE				= 0x2,
+	BT_8821A_2ANT_BT_STATUS_ACL_BUSY				= 0x3,
+	BT_8821A_2ANT_BT_STATUS_SCO_BUSY				= 0x4,
+	BT_8821A_2ANT_BT_STATUS_ACL_SCO_BUSY			= 0x5,
+	BT_8821A_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8821a_2ant_coex_algo {
+	BT_8821A_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8821A_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8821A_2ANT_COEX_ALGO_HID				= 0x2,
+	BT_8821A_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8821A_2ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8821A_2ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8821A_2ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8821A_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8821A_2ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8821A_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8821A_2ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8821A_2ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8821a_2ant {
+	/* fw mechanism */
+	u8		pre_bt_dec_pwr_lvl;
+	u8		cur_bt_dec_pwr_lvl;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[5];
+	u8		ps_tdma_du_adj_type;
+	boolean		reset_tdma_adjust;
+	boolean		auto_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	u32		bt_rf_0x1e_backup;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+
+	boolean		need_recover0x948;
+	u32		backup0x948;
+
+	u8		pre_lps;
+	u8		cur_lps;
+	u8		pre_rpwm;
+	u8		cur_rpwm;
+};
+
+struct coex_sta_8821a_2ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	u8					bt_rssi;
+	boolean					bt_tx_rx_mask;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8821A_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8821A_2ANT_MAX];
+	boolean				bt_whck_test;
+	boolean					c2h_bt_inquiry_page;
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+
+	u32					crc_ok_cck;
+	u32					crc_ok_11g;
+	u32					crc_ok_11n;
+	u32					crc_ok_11n_agg;
+
+	u32					crc_err_cck;
+	u32					crc_err_11g;
+	u32					crc_err_11n;
+	u32					crc_err_11n_agg;
+
+	u8					coex_table_type;
+	boolean					force_lps_on;
+
+	u8					dis_ver_info_cnt;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8821a2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_pre_load_firmware(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+				       IN boolean wifi_only);
+void ex_halbtc8821a2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821a2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 type);
+void ex_halbtc8821a2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				    IN u8 type);
+void ex_halbtc8821a2ant_connect_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8821a2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a2ant_specific_packet_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821a2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8821a2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				   IN u8 pnp_state);
+void ex_halbtc8821a2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821a2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8821a2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8821a2ant_pre_load_firmware(btcoexist)
+#define	ex_halbtc8821a2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8821a2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8821a2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8821a2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8821a2ant_halt_notify(btcoexist)
+#define	ex_halbtc8821a2ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8821a2ant_periodical(btcoexist)
+#define	ex_halbtc8821a2ant_display_coex_info(btcoexist)
+#endif
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821aCsr2Ant.c b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821aCsr2Ant.c
new file mode 100644
index 000000000..b69d15668
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821aCsr2Ant.c
@@ -0,0 +1,3997 @@
+/* ************************************************************
+ * Description:
+ *
+ * This file is for RTL8821A_CSR_CSR Co-exist mechanism
+ *
+ * History
+ * 2012/08/22 Cosa first check in.
+ * 2012/11/14 Cosa Revise for 8821A_CSR 2Ant out sourcing.
+ *
+ * ************************************************************ */
+
+/* ************************************************************
+ * include files
+ * ************************************************************ */
+#include "Mp_Precomp.h"
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+
+#define _BTCOEX_CSR 1
+
+#ifndef rtw_warn_on_8821acsr2ant
+#define rtw_warn_on_8821acsr2ant(condition) do {} while (0)
+#endif
+/* ************************************************************
+ * Global variables, these are static variables
+ * ************************************************************ */
+static u8	 *trace_buf = &gl_btc_trace_buf[0];
+static struct  coex_dm_8821a_csr_2ant	glcoex_dm_8821a_csr_2ant;
+static struct  coex_dm_8821a_csr_2ant	*coex_dm = &glcoex_dm_8821a_csr_2ant;
+static struct  coex_sta_8821a_csr_2ant	glcoex_sta_8821a_csr_2ant;
+static struct  coex_sta_8821a_csr_2ant	*coex_sta = &glcoex_sta_8821a_csr_2ant;
+
+const char *const glbt_info_src_8821a_csr_2ant[] = {
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u32 glcoex_ver_date_8821a_csr_2ant = 20140901;
+u32 glcoex_ver_8821a_csr_2ant = 0x51;
+
+/* ************************************************************
+ * local function proto type if needed
+ * ************************************************************
+ * ************************************************************
+ * local function start with halbtc8821aCsr2ant_
+ * ************************************************************ */
+u8 halbtc8821aCsr2ant_bt_rssi_state(u8 level_num, u8 rssi_thresh,
+				    u8 rssi_thresh1)
+{
+	s32			bt_rssi = 0;
+	u8			bt_rssi_state = coex_sta->pre_bt_rssi_state;
+
+	bt_rssi = coex_sta->bt_rssi;
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+				BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT Rssi thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_bt_rssi_state;
+		}
+
+		if ((coex_sta->pre_bt_rssi_state == BTC_RSSI_STATE_LOW) ||
+		    (coex_sta->pre_bt_rssi_state ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (bt_rssi >= (rssi_thresh +
+				BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_bt_rssi_state ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (bt_rssi >= (rssi_thresh1 +
+				BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT))
+				bt_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (bt_rssi < rssi_thresh)
+				bt_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (bt_rssi < rssi_thresh1)
+				bt_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				bt_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_bt_rssi_state = bt_rssi_state;
+
+	return bt_rssi_state;
+}
+
+u8 halbtc8821aCsr2ant_wifi_rssi_state(IN struct btc_coexist *btcoexist,
+	IN u8 index, IN u8 level_num, IN u8 rssi_thresh, IN u8 rssi_thresh1)
+{
+	s32			wifi_rssi = 0;
+	u8			wifi_rssi_state = coex_sta->pre_wifi_rssi_state[index];
+
+	btcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);
+
+	if (level_num == 2) {
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+				  BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else {
+			if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	} else if (level_num == 3) {
+		if (rssi_thresh > rssi_thresh1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], wifi RSSI thresh error!!\n");
+			BTC_TRACE(trace_buf);
+			return coex_sta->pre_wifi_rssi_state[index];
+		}
+
+		if ((coex_sta->pre_wifi_rssi_state[index] == BTC_RSSI_STATE_LOW)
+		    ||
+		    (coex_sta->pre_wifi_rssi_state[index] ==
+		     BTC_RSSI_STATE_STAY_LOW)) {
+			if (wifi_rssi >= (rssi_thresh +
+				  BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_LOW;
+		} else if ((coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_MEDIUM) ||
+			   (coex_sta->pre_wifi_rssi_state[index] ==
+			    BTC_RSSI_STATE_STAY_MEDIUM)) {
+			if (wifi_rssi >= (rssi_thresh1 +
+				  BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT))
+				wifi_rssi_state = BTC_RSSI_STATE_HIGH;
+			else if (wifi_rssi < rssi_thresh)
+				wifi_rssi_state = BTC_RSSI_STATE_LOW;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_MEDIUM;
+		} else {
+			if (wifi_rssi < rssi_thresh1)
+				wifi_rssi_state = BTC_RSSI_STATE_MEDIUM;
+			else
+				wifi_rssi_state = BTC_RSSI_STATE_STAY_HIGH;
+		}
+	}
+
+	coex_sta->pre_wifi_rssi_state[index] = wifi_rssi_state;
+
+	return wifi_rssi_state;
+}
+
+void halbtc8821aCsr2ant_monitor_bt_enable_disable(IN struct btc_coexist
+		*btcoexist)
+{
+	static u32	bt_disable_cnt = 0;
+	boolean			bt_active = true, bt_disabled = false;
+
+	/* This function check if bt is disabled */
+
+	if (coex_sta->high_priority_tx == 0 &&
+	    coex_sta->high_priority_rx == 0 &&
+	    coex_sta->low_priority_tx == 0 &&
+	    coex_sta->low_priority_rx == 0)
+		bt_active = false;
+	if (coex_sta->high_priority_tx == 0xffff &&
+	    coex_sta->high_priority_rx == 0xffff &&
+	    coex_sta->low_priority_tx == 0xffff &&
+	    coex_sta->low_priority_rx == 0xffff)
+		bt_active = false;
+	if (bt_active) {
+		bt_disable_cnt = 0;
+		bt_disabled = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+				   &bt_disabled);
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is enabled !!\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		bt_disable_cnt++;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], bt all counters=0, %d times!!\n",
+			    bt_disable_cnt);
+		BTC_TRACE(trace_buf);
+		if (bt_disable_cnt >= 2) {
+			bt_disabled = true;
+			btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_DISABLE,
+					   &bt_disabled);
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], BT is disabled !!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+	if (coex_sta->bt_disabled != bt_disabled) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BT is from %s to %s!!\n",
+			    (coex_sta->bt_disabled ? "disabled" : "enabled"),
+			    (bt_disabled ? "disabled" : "enabled"));
+		BTC_TRACE(trace_buf);
+		coex_sta->bt_disabled = bt_disabled;
+		if (!bt_disabled) {
+		} else {
+		}
+	}
+}
+
+void halbtc8821aCsr2ant_monitor_bt_ctr(IN struct btc_coexist *btcoexist)
+{
+	u32			reg_hp_txrx, reg_lp_txrx, u32tmp;
+	u32			reg_hp_tx = 0, reg_hp_rx = 0, reg_lp_tx = 0, reg_lp_rx = 0;
+
+	reg_hp_txrx = 0x770;
+	reg_lp_txrx = 0x774;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_hp_txrx);
+	reg_hp_tx = u32tmp & MASKLWORD;
+	reg_hp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	u32tmp = btcoexist->btc_read_4byte(btcoexist, reg_lp_txrx);
+	reg_lp_tx = u32tmp & MASKLWORD;
+	reg_lp_rx = (u32tmp & MASKHWORD) >> 16;
+
+	coex_sta->high_priority_tx = reg_hp_tx;
+	coex_sta->high_priority_rx = reg_hp_rx;
+	coex_sta->low_priority_tx = reg_lp_tx;
+	coex_sta->low_priority_rx = reg_lp_rx;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_hp_txrx, reg_hp_tx, reg_hp_tx, reg_hp_rx, reg_hp_rx);
+	BTC_TRACE(trace_buf);
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		"[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n",
+		    reg_lp_txrx, reg_lp_tx, reg_lp_tx, reg_lp_rx, reg_lp_rx);
+	BTC_TRACE(trace_buf);
+
+	/* reset counter */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e, 0x5d);
+}
+
+void halbtc8821aCsr2ant_update_ra_mask(IN struct btc_coexist *btcoexist,
+			       IN boolean force_exec, IN u32 dis_rate_mask)
+{
+	coex_dm->cur_ra_mask = dis_rate_mask;
+
+	if (force_exec || (coex_dm->pre_ra_mask != coex_dm->cur_ra_mask))
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_UPDATE_RAMASK,
+				   &coex_dm->cur_ra_mask);
+	coex_dm->pre_ra_mask = coex_dm->cur_ra_mask;
+}
+
+void halbtc8821aCsr2ant_auto_rate_fallback_retry(IN struct btc_coexist
+		*btcoexist, IN boolean force_exec, IN u8 type)
+{
+	boolean	wifi_under_b_mode = false;
+
+	coex_dm->cur_arfr_type = type;
+
+	if (force_exec || (coex_dm->pre_arfr_type != coex_dm->cur_arfr_type)) {
+		switch (coex_dm->cur_arfr_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_4byte(btcoexist, 0x430,
+						   coex_dm->backup_arfr_cnt1);
+			btcoexist->btc_write_4byte(btcoexist, 0x434,
+						   coex_dm->backup_arfr_cnt2);
+			break;
+		case 1:
+			btcoexist->btc_get(btcoexist,
+					   BTC_GET_BL_WIFI_UNDER_B_MODE,
+					   &wifi_under_b_mode);
+			if (wifi_under_b_mode) {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x01010101);
+			} else {
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x430, 0x0);
+				btcoexist->btc_write_4byte(btcoexist,
+							   0x434, 0x04030201);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_arfr_type = coex_dm->cur_arfr_type;
+}
+
+void halbtc8821aCsr2ant_retry_limit(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_retry_limit_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_retry_limit_type !=
+	     coex_dm->cur_retry_limit_type)) {
+		switch (coex_dm->cur_retry_limit_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   coex_dm->backup_retry_limit);
+			break;
+		case 1:	/* retry limit=8 */
+			btcoexist->btc_write_2byte(btcoexist, 0x42a,
+						   0x0808);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_retry_limit_type = coex_dm->cur_retry_limit_type;
+}
+
+void halbtc8821aCsr2ant_ampdu_max_time(IN struct btc_coexist *btcoexist,
+				       IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_time_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_time_type != coex_dm->cur_ampdu_time_type)) {
+		switch (coex_dm->cur_ampdu_time_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+					   coex_dm->backup_ampdu_max_time);
+			break;
+		case 1:	/* AMPDU timw = 0x38 * 32us */
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x38);
+			break;
+		case 2:
+			btcoexist->btc_write_1byte(btcoexist, 0x456,
+						   0x17);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_time_type = coex_dm->cur_ampdu_time_type;
+}
+
+void halbtc8821aCsr2Ant_AmpduMaxNum(IN struct btc_coexist *btcoexist,
+				    IN boolean force_exec, IN u8 type)
+{
+	coex_dm->cur_ampdu_num_type = type;
+
+	if (force_exec ||
+	    (coex_dm->pre_ampdu_num_type != coex_dm->cur_ampdu_num_type)) {
+		switch (coex_dm->cur_ampdu_num_type) {
+		case 0:	/* normal mode */
+			btcoexist->btc_write_2byte(btcoexist, 0x4ca,
+					   coex_dm->backup_ampdu_max_num);
+			break;
+		case 1:
+			btcoexist->btc_write_2byte(btcoexist, 0x4ca,
+						   0x0808);
+			break;
+		case 2:
+			btcoexist->btc_write_2byte(btcoexist, 0x4ca,
+						   0x1f1f);
+			break;
+		default:
+			break;
+		}
+	}
+
+	coex_dm->pre_ampdu_num_type = coex_dm->cur_ampdu_num_type;
+
+}
+
+void halbtc8821aCsr2ant_limited_tx(IN struct btc_coexist *btcoexist,
+		   IN boolean force_exec, IN u8 ra_mask_type, IN u8 arfr_type,
+	   IN u8 retry_limit_type, IN u8 ampdu_time_type, IN u8 ampdu_num_type)
+{
+	switch (ra_mask_type) {
+	case 0:	/* normal mode */
+		halbtc8821aCsr2ant_update_ra_mask(btcoexist, force_exec,
+						  0x0);
+		break;
+	case 1:	/* disable cck 1/2 */
+		halbtc8821aCsr2ant_update_ra_mask(btcoexist, force_exec,
+						  0x00000003);
+		break;
+	case 2:	/* disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4 */
+		halbtc8821aCsr2ant_update_ra_mask(btcoexist, force_exec,
+						  0x0001f1f7);
+		break;
+	default:
+		break;
+	}
+
+	halbtc8821aCsr2ant_auto_rate_fallback_retry(btcoexist, force_exec,
+			arfr_type);
+	halbtc8821aCsr2ant_retry_limit(btcoexist, force_exec, retry_limit_type);
+	halbtc8821aCsr2ant_ampdu_max_time(btcoexist, force_exec,
+					  ampdu_time_type);
+	halbtc8821aCsr2Ant_AmpduMaxNum(btcoexist, force_exec, ampdu_num_type);
+}
+
+
+
+void halbtc8821aCsr2ant_limited_rx(IN struct btc_coexist *btcoexist,
+			   IN boolean force_exec, IN boolean rej_ap_agg_pkt,
+			   IN boolean bt_ctrl_agg_buf_size, IN u8 agg_buf_size)
+{
+	boolean	reject_rx_agg = rej_ap_agg_pkt;
+	boolean	bt_ctrl_rx_agg_size = bt_ctrl_agg_buf_size;
+	u8	rx_agg_size = agg_buf_size;
+
+	/* ============================================ */
+	/*	Rx Aggregation related setting */
+	/* ============================================ */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+			   &reject_rx_agg);
+	/* decide BT control aggregation buf size or not */
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE,
+			   &bt_ctrl_rx_agg_size);
+	/* aggregation buf size, only work when BT control Rx aggregation size. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_AGG_BUF_SIZE, &rx_agg_size);
+	/* real update aggregation setting */
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+}
+
+void halbtc8821aCsr2ant_query_bt_info(IN struct btc_coexist *btcoexist)
+{
+	u8			h2c_parameter[1] = {0};
+
+	coex_sta->c2h_bt_info_req_sent = true;
+
+	h2c_parameter[0] |= BIT(0);	/* trigger */
+
+	rtw_warn_on_8821acsr2ant(_BTCOEX_CSR);
+	btcoexist->btc_fill_h2c(btcoexist, 0x61, 1, h2c_parameter);
+}
+
+u8 halbtc8821aCsr2ant_action_algorithm(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_stack_info		*stack_info = &btcoexist->stack_info;
+	boolean				bt_hs_on = false;
+	u8				algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_UNDEFINED;
+	u8				num_of_diff_profile = 0;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	/* sync StackInfo with BT firmware and stack */
+	stack_info->hid_exist = coex_sta->hid_exist;
+	stack_info->bt_link_exist = coex_sta->bt_link_exist;
+	stack_info->sco_exist = coex_sta->sco_exist;
+	stack_info->pan_exist = coex_sta->pan_exist;
+	stack_info->a2dp_exist = coex_sta->a2dp_exist;
+
+	if (!stack_info->bt_link_exist) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], No profile exists!!!\n");
+		BTC_TRACE(trace_buf);
+		return algorithm;
+	}
+
+	if (stack_info->sco_exist)
+		num_of_diff_profile++;
+	if (stack_info->hid_exist)
+		num_of_diff_profile++;
+	if (stack_info->pan_exist)
+		num_of_diff_profile++;
+	if (stack_info->a2dp_exist)
+		num_of_diff_profile++;
+
+	if (num_of_diff_profile == 1) {
+		if (stack_info->sco_exist) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], SCO only\n");
+			BTC_TRACE(trace_buf);
+			algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_SCO;
+		} else {
+			if (stack_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], HID only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_HID;
+			} else if (stack_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], A2DP only\n");
+				BTC_TRACE(trace_buf);
+				algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_A2DP;
+			} else if (stack_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], PAN(HS) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], PAN(EDR) only\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 2) {
+		if (stack_info->sco_exist) {
+			if (stack_info->hid_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm =
+					BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (stack_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					    "[BTCoex], SCO + A2DP ==> SCO\n");
+				BTC_TRACE(trace_buf);
+				algorithm =
+					BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (stack_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_SCO;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (stack_info->hid_exist &&
+			    stack_info->a2dp_exist) {
+				if (stack_info->num_of_hid >= 2) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID*2 + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						    "[BTCoex], HID + A2DP\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			} else if (stack_info->hid_exist &&
+				   stack_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (stack_info->pan_exist &&
+				   stack_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_A2DP_PANHS;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	} else if (num_of_diff_profile == 3) {
+		if (stack_info->sco_exist) {
+			if (stack_info->hid_exist &&
+			    stack_info->a2dp_exist) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], SCO + HID + A2DP ==> HID\n");
+				BTC_TRACE(trace_buf);
+				algorithm =
+					BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+			} else if (stack_info->hid_exist &&
+				   stack_info->pan_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			} else if (stack_info->pan_exist &&
+				   stack_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		} else {
+			if (stack_info->hid_exist &&
+			    stack_info->pan_exist &&
+			    stack_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP;
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], HID + A2DP + PAN(EDR)\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	} else if (num_of_diff_profile >= 3) {
+		if (stack_info->sco_exist) {
+			if (stack_info->hid_exist &&
+			    stack_info->pan_exist &&
+			    stack_info->a2dp_exist) {
+				if (bt_hs_on) {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
+					BTC_TRACE(trace_buf);
+
+				} else {
+					BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+						"[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n");
+					BTC_TRACE(trace_buf);
+					algorithm =
+						BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+boolean halbtc8821aCsr2ant_need_to_dec_bt_pwr(IN struct btc_coexist *btcoexist)
+{
+	boolean		ret = false;
+	boolean		bt_hs_on = false, wifi_connected = false;
+	s32		bt_hs_rssi = 0;
+	u8		bt_rssi_state;
+
+	if (!btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on))
+		return false;
+	if (!btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+				&wifi_connected))
+		return false;
+	if (!btcoexist->btc_get(btcoexist, BTC_GET_S4_HS_RSSI, &bt_hs_rssi))
+		return false;
+
+	bt_rssi_state = halbtc8821aCsr2ant_bt_rssi_state(2, 35, 0);
+
+	if (wifi_connected) {
+		if (bt_hs_on) {
+			if (bt_hs_rssi > 37)
+				ret = true;
+		} else {
+			if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+			    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+				ret = true;
+		}
+	}
+
+	return ret;
+}
+
+void halbtc8821aCsr2ant_set_fw_dac_swing_level(IN struct btc_coexist *btcoexist,
+		IN u8 dac_swing_lvl)
+{
+	u8			h2c_parameter[1] = {0};
+
+	/* There are several type of dacswing */
+	/* 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6 */
+	h2c_parameter[0] = dac_swing_lvl;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x64, 1, h2c_parameter);
+}
+
+void halbtc8821aCsr2ant_set_fw_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+		IN boolean dec_bt_pwr)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (dec_bt_pwr)
+		h2c_parameter[0] |= BIT(1);
+
+	rtw_warn_on_8821acsr2ant(_BTCOEX_CSR);
+	btcoexist->btc_fill_h2c(btcoexist, 0x62, 1, h2c_parameter);
+}
+
+void halbtc8821aCsr2ant_dec_bt_pwr(IN struct btc_coexist *btcoexist,
+				   IN boolean force_exec, IN boolean dec_bt_pwr)
+{
+	coex_dm->cur_dec_bt_pwr = dec_bt_pwr;
+
+	if (!force_exec) {
+		if (coex_dm->pre_dec_bt_pwr == coex_dm->cur_dec_bt_pwr)
+			return;
+	}
+
+	/* TODO: may CSR consider to decrease BT power? */
+	/* halbtc8821aCsr2ant_set_fw_dec_bt_pwr(btcoexist, coex_dm->cur_dec_bt_pwr); */
+
+	coex_dm->pre_dec_bt_pwr = coex_dm->cur_dec_bt_pwr;
+}
+
+void halbtc8821aCsr2ant_set_bt_auto_report(IN struct btc_coexist *btcoexist,
+		IN boolean enable_auto_report)
+{
+	u8			h2c_parameter[1] = {0};
+
+	h2c_parameter[0] = 0;
+
+	if (enable_auto_report)
+		h2c_parameter[0] |= BIT(0);
+
+	rtw_warn_on_8821acsr2ant(_BTCOEX_CSR);
+	btcoexist->btc_fill_h2c(btcoexist, 0x68, 1, h2c_parameter);
+}
+
+void halbtc8821aCsr2ant_bt_auto_report(IN struct btc_coexist *btcoexist,
+		       IN boolean force_exec, IN boolean enable_auto_report)
+{
+	coex_dm->cur_bt_auto_report = enable_auto_report;
+
+	if (!force_exec) {
+		if (coex_dm->pre_bt_auto_report == coex_dm->cur_bt_auto_report)
+			return;
+	}
+	/* halbtc8821aCsr2ant_set_bt_auto_report(btcoexist, coex_dm->cur_bt_auto_report); */
+
+	coex_dm->pre_bt_auto_report = coex_dm->cur_bt_auto_report;
+}
+
+void halbtc8821aCsr2ant_fw_dac_swing_lvl(IN struct btc_coexist *btcoexist,
+		IN boolean force_exec, IN u8 fw_dac_swing_lvl)
+{
+	coex_dm->cur_fw_dac_swing_lvl = fw_dac_swing_lvl;
+
+	if (!force_exec) {
+		if (coex_dm->pre_fw_dac_swing_lvl ==
+		    coex_dm->cur_fw_dac_swing_lvl)
+			return;
+	}
+
+	halbtc8821aCsr2ant_set_fw_dac_swing_level(btcoexist,
+			coex_dm->cur_fw_dac_swing_lvl);
+
+	coex_dm->pre_fw_dac_swing_lvl = coex_dm->cur_fw_dac_swing_lvl;
+}
+
+void halbtc8821aCsr2ant_set_sw_rf_rx_lpf_corner(IN struct btc_coexist
+		*btcoexist, IN boolean rx_rf_shrink_on)
+{
+	if (rx_rf_shrink_on) {
+		/* Shrink RF Rx LPF corner */
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Shrink RF Rx LPF corner!!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e, 0xfffff,
+					  0xffffc);
+	} else {
+		/* Resume RF Rx LPF corner */
+		/* After initialized, we can use coex_dm->bt_rf_0x1e_backup */
+		if (btcoexist->initilized) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Resume RF Rx LPF corner!!\n");
+			BTC_TRACE(trace_buf);
+			btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x1e,
+					  0xfffff, coex_dm->bt_rf_0x1e_backup);
+		}
+	}
+}
+
+void halbtc8821aCsr2ant_rf_shrink(IN struct btc_coexist *btcoexist,
+			  IN boolean force_exec, IN boolean rx_rf_shrink_on)
+{
+	coex_dm->cur_rf_rx_lpf_shrink = rx_rf_shrink_on;
+
+	if (!force_exec) {
+		if (coex_dm->pre_rf_rx_lpf_shrink ==
+		    coex_dm->cur_rf_rx_lpf_shrink)
+			return;
+	}
+	halbtc8821aCsr2ant_set_sw_rf_rx_lpf_corner(btcoexist,
+			coex_dm->cur_rf_rx_lpf_shrink);
+
+	coex_dm->pre_rf_rx_lpf_shrink = coex_dm->cur_rf_rx_lpf_shrink;
+}
+
+void halbtc8821aCsr2ant_set_sw_penalty_tx_rate_adaptive(
+	IN struct btc_coexist *btcoexist, IN boolean low_penalty_ra)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = 0x6;	/* op_code, 0x6= Retry_Penalty */
+
+	if (low_penalty_ra) {
+		h2c_parameter[1] |= BIT(0);
+		h2c_parameter[2] =
+			0x00;  /* normal rate except MCS7/6/5, OFDM54/48/36 */
+		h2c_parameter[3] = 0xf7;  /* MCS7 or OFDM54 */
+		h2c_parameter[4] = 0xf8;  /* MCS6 or OFDM48 */
+		h2c_parameter[5] = 0xf9;	/* MCS5 or OFDM36	 */
+	}
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x69, 6, h2c_parameter);
+}
+
+void halbtc8821aCsr2ant_low_penalty_ra(IN struct btc_coexist *btcoexist,
+			       IN boolean force_exec, IN boolean low_penalty_ra)
+{
+	coex_dm->cur_low_penalty_ra = low_penalty_ra;
+
+	if (!force_exec) {
+		if (coex_dm->pre_low_penalty_ra == coex_dm->cur_low_penalty_ra)
+			return;
+	}
+	halbtc8821aCsr2ant_set_sw_penalty_tx_rate_adaptive(btcoexist,
+			coex_dm->cur_low_penalty_ra);
+
+	coex_dm->pre_low_penalty_ra = coex_dm->cur_low_penalty_ra;
+}
+
+void halbtc8821aCsr2ant_set_dac_swing_reg(IN struct btc_coexist *btcoexist,
+		IN u32 level)
+{
+	u8	val = (u8)level;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Write SwDacSwing = 0x%x\n", level);
+	BTC_TRACE(trace_buf);
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0xc5b, 0x3e, val);
+}
+
+void halbtc8821aCsr2ant_set_sw_full_time_dac_swing(IN struct btc_coexist
+		*btcoexist, IN boolean sw_dac_swing_on, IN u32 sw_dac_swing_lvl)
+{
+	if (sw_dac_swing_on)
+		halbtc8821aCsr2ant_set_dac_swing_reg(btcoexist,
+						     sw_dac_swing_lvl);
+	else
+		halbtc8821aCsr2ant_set_dac_swing_reg(btcoexist, 0x18);
+}
+
+
+void halbtc8821aCsr2ant_dac_swing(IN struct btc_coexist *btcoexist,
+	  IN boolean force_exec, IN boolean dac_swing_on, IN u32 dac_swing_lvl)
+{
+	coex_dm->cur_dac_swing_on = dac_swing_on;
+	coex_dm->cur_dac_swing_lvl = dac_swing_lvl;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_dac_swing_on == coex_dm->cur_dac_swing_on) &&
+		    (coex_dm->pre_dac_swing_lvl ==
+		     coex_dm->cur_dac_swing_lvl))
+			return;
+	}
+	delay_ms(30);
+	halbtc8821aCsr2ant_set_sw_full_time_dac_swing(btcoexist, dac_swing_on,
+			dac_swing_lvl);
+
+	coex_dm->pre_dac_swing_on = coex_dm->cur_dac_swing_on;
+	coex_dm->pre_dac_swing_lvl = coex_dm->cur_dac_swing_lvl;
+}
+
+void halbtc8821aCsr2ant_set_adc_back_off(IN struct btc_coexist *btcoexist,
+		IN boolean adc_back_off)
+{
+	if (adc_back_off) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x8db, 0x60, 0x3);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], BB BackOff Level Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0x8db, 0x60, 0x1);
+	}
+}
+
+void halbtc8821aCsr2ant_adc_back_off(IN struct btc_coexist *btcoexist,
+			     IN boolean force_exec, IN boolean adc_back_off)
+{
+	coex_dm->cur_adc_back_off = adc_back_off;
+
+	if (!force_exec) {
+		if (coex_dm->pre_adc_back_off == coex_dm->cur_adc_back_off)
+			return;
+	}
+	halbtc8821aCsr2ant_set_adc_back_off(btcoexist,
+					    coex_dm->cur_adc_back_off);
+
+	coex_dm->pre_adc_back_off = coex_dm->cur_adc_back_off;
+}
+
+void halbtc8821aCsr2ant_set_agc_table(IN struct btc_coexist *btcoexist,
+				      IN boolean agc_table_en)
+{
+	u8		rssi_adjust_val = 0;
+
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x02000);
+	if (agc_table_en) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table On!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x28F4B);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x10AB2);
+		rssi_adjust_val = 8;
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Agc Table Off!\n");
+		BTC_TRACE(trace_buf);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x2884B);
+		btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0x3b, 0xfffff,
+					  0x104B2);
+	}
+	btcoexist->btc_set_rf_reg(btcoexist, BTC_RF_A, 0xef, 0xfffff, 0x0);
+
+	/* set rssi_adjust_val for wifi module. */
+	btcoexist->btc_set(btcoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON,
+			   &rssi_adjust_val);
+}
+
+void halbtc8821aCsr2ant_agc_table(IN struct btc_coexist *btcoexist,
+			  IN boolean force_exec, IN boolean agc_table_en)
+{
+	coex_dm->cur_agc_table_en = agc_table_en;
+
+	if (!force_exec) {
+		if (coex_dm->pre_agc_table_en == coex_dm->cur_agc_table_en)
+			return;
+	}
+	halbtc8821aCsr2ant_set_agc_table(btcoexist, agc_table_en);
+
+	coex_dm->pre_agc_table_en = coex_dm->cur_agc_table_en;
+}
+
+void halbtc8821aCsr2ant_set_coex_table(IN struct btc_coexist *btcoexist,
+	IN u32 val0x6c0, IN u32 val0x6c4, IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	btcoexist->btc_write_4byte(btcoexist, 0x6c0, val0x6c0);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c4, val0x6c4);
+
+	btcoexist->btc_write_4byte(btcoexist, 0x6c8, val0x6c8);
+
+	btcoexist->btc_write_1byte(btcoexist, 0x6cc, val0x6cc);
+}
+
+void halbtc8821aCsr2ant_coex_table(IN struct btc_coexist *btcoexist,
+		   IN boolean force_exec, IN u32 val0x6c0, IN u32 val0x6c4,
+				   IN u32 val0x6c8, IN u8 val0x6cc)
+{
+	coex_dm->cur_val0x6c0 = val0x6c0;
+	coex_dm->cur_val0x6c4 = val0x6c4;
+	coex_dm->cur_val0x6c8 = val0x6c8;
+	coex_dm->cur_val0x6cc = val0x6cc;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_val0x6c0 == coex_dm->cur_val0x6c0) &&
+		    (coex_dm->pre_val0x6c4 == coex_dm->cur_val0x6c4) &&
+		    (coex_dm->pre_val0x6c8 == coex_dm->cur_val0x6c8) &&
+		    (coex_dm->pre_val0x6cc == coex_dm->cur_val0x6cc))
+			return;
+	}
+	halbtc8821aCsr2ant_set_coex_table(btcoexist, val0x6c0, val0x6c4,
+					  val0x6c8, val0x6cc);
+
+	coex_dm->pre_val0x6c0 = coex_dm->cur_val0x6c0;
+	coex_dm->pre_val0x6c4 = coex_dm->cur_val0x6c4;
+	coex_dm->pre_val0x6c8 = coex_dm->cur_val0x6c8;
+	coex_dm->pre_val0x6cc = coex_dm->cur_val0x6cc;
+}
+
+void halbtc8821aCsr2ant_set_fw_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+		IN boolean enable)
+{
+	u8			h2c_parameter[1] = {0};
+
+	if (enable) {
+		h2c_parameter[0] |= BIT(0);		/* function enable */
+	}
+
+	rtw_warn_on_8821acsr2ant(_BTCOEX_CSR);
+	btcoexist->btc_fill_h2c(btcoexist, 0x63, 1, h2c_parameter);
+}
+
+void halbtc8821aCsr2ant_ignore_wlan_act(IN struct btc_coexist *btcoexist,
+				IN boolean force_exec, IN boolean enable)
+{
+	coex_dm->cur_ignore_wlan_act = enable;
+
+	if (!force_exec) {
+		if (coex_dm->pre_ignore_wlan_act ==
+		    coex_dm->cur_ignore_wlan_act)
+			return;
+	}
+	/* halbtc8821aCsr2ant_set_fw_ignore_wlan_act(btcoexist, enable); */
+
+	coex_dm->pre_ignore_wlan_act = coex_dm->cur_ignore_wlan_act;
+}
+
+void halbtc8821aCsr2ant_set_fw_pstdma(IN struct btc_coexist *btcoexist,
+	      IN u8 byte1, IN u8 byte2, IN u8 byte3, IN u8 byte4, IN u8 byte5)
+{
+	u8			h2c_parameter[6] = {0};
+
+	h2c_parameter[0] = byte1;
+	h2c_parameter[1] = byte2;
+	h2c_parameter[2] = byte3;
+	h2c_parameter[3] = byte4;
+	h2c_parameter[4] = byte5;
+	h2c_parameter[5] = 0x01;
+
+	coex_dm->ps_tdma_para[0] = byte1;
+	coex_dm->ps_tdma_para[1] = byte2;
+	coex_dm->ps_tdma_para[2] = byte3;
+	coex_dm->ps_tdma_para[3] = byte4;
+	coex_dm->ps_tdma_para[4] = byte5;
+	coex_dm->ps_tdma_para[5] = 0x01;
+
+	btcoexist->btc_fill_h2c(btcoexist, 0x60, 6, h2c_parameter);
+}
+
+void halbtc8821aCsr2ant_sw_mechanism1(IN struct btc_coexist *btcoexist,
+		      IN boolean shrink_rx_lpf, IN boolean low_penalty_ra,
+		      IN boolean limited_dig, IN boolean bt_lna_constrain)
+{
+	u32	wifi_bw;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_HT40 != wifi_bw) { /* only shrink RF Rx LPF for HT40 */
+		if (shrink_rx_lpf)
+			shrink_rx_lpf = false;
+	}
+
+	halbtc8821aCsr2ant_rf_shrink(btcoexist, NORMAL_EXEC, shrink_rx_lpf);
+	halbtc8821aCsr2ant_low_penalty_ra(btcoexist, NORMAL_EXEC,
+					  low_penalty_ra);
+
+	/* no limited DIG */
+	/* halbtc8821aCsr2ant_setBtLnaConstrain(btcoexist, NORMAL_EXEC, bt_lna_constrain); */
+}
+
+void halbtc8821aCsr2ant_sw_mechanism2(IN struct btc_coexist *btcoexist,
+		      IN boolean agc_table_shift, IN boolean adc_back_off,
+			      IN boolean sw_dac_swing, IN u32 dac_swing_lvl)
+{
+	/* halbtc8821aCsr2ant_agc_table(btcoexist, NORMAL_EXEC, agc_table_shift); */
+	halbtc8821aCsr2ant_adc_back_off(btcoexist, NORMAL_EXEC, adc_back_off);
+	halbtc8821aCsr2ant_dac_swing(btcoexist, NORMAL_EXEC, sw_dac_swing,
+				     dac_swing_lvl);
+}
+
+void halbtc8821aCsr2ant_set_ant_path(IN struct btc_coexist *btcoexist,
+	     IN u8 ant_pos_type, IN boolean init_hwcfg, IN boolean wifi_off)
+{
+	struct  btc_board_info	*board_info = &btcoexist->board_info;
+	u32				u32tmp = 0;
+	u8				h2c_parameter[2] = {0};
+
+	if (init_hwcfg) {
+		/* 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT */
+		u32tmp = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+		u32tmp &= ~BIT(23);
+		u32tmp |= BIT(24);
+		btcoexist->btc_write_4byte(btcoexist, 0x4c, u32tmp);
+
+		btcoexist->btc_write_4byte(btcoexist, 0x974, 0x3ff);
+		btcoexist->btc_write_1byte(btcoexist, 0xcb4, 0x77);
+
+		if (board_info->btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT) {
+			/* tell firmware "antenna inverse"  ==> WRONG firmware antenna control code.==>need fw to fix */
+			h2c_parameter[0] = 1;
+			h2c_parameter[1] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+						h2c_parameter);
+		} else {
+			/* tell firmware "no antenna inverse" ==> WRONG firmware antenna control code.==>need fw to fix */
+			h2c_parameter[0] = 0;
+			h2c_parameter[1] = 1;
+			btcoexist->btc_fill_h2c(btcoexist, 0x65, 2,
+						h2c_parameter);
+		}
+	}
+
+	/* ext switch setting */
+	switch (ant_pos_type) {
+	case BTC_ANT_WIFI_AT_MAIN:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb7,
+						   0x30, 0x1);
+		break;
+	case BTC_ANT_WIFI_AT_AUX:
+		btcoexist->btc_write_1byte_bitmask(btcoexist, 0xcb7,
+						   0x30, 0x2);
+		break;
+	}
+}
+
+void halbtc8821aCsr2ant_ps_tdma(IN struct btc_coexist *btcoexist,
+			IN boolean force_exec, IN boolean turn_on, IN u8 type)
+{
+	coex_dm->cur_ps_tdma_on = turn_on;
+	coex_dm->cur_ps_tdma = type;
+
+	if (!force_exec) {
+		if ((coex_dm->pre_ps_tdma_on == coex_dm->cur_ps_tdma_on) &&
+		    (coex_dm->pre_ps_tdma == coex_dm->cur_ps_tdma))
+			return;
+	}
+	if (turn_on) {
+		switch (type) {
+		case 1:
+		default:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+			break;
+		case 2:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x12, 0x12, 0xe1, 0x90);
+			break;
+		case 3:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x1c, 0x3, 0xf1, 0x90);
+			break;
+		case 4:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x10, 0x03, 0xf1, 0x90);
+			break;
+		case 5:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x1a, 0x1a, 0x60, 0x90);
+			break;
+		case 6:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x12, 0x12, 0x60, 0x90);
+			break;
+		case 7:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x1c, 0x3, 0x70, 0x90);
+			break;
+		case 8:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xa3, 0x10, 0x3, 0x70, 0x90);
+			break;
+		case 9:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+			break;
+		case 10:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x12, 0x12, 0xe1, 0x90);
+			break;
+		case 11:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0xa, 0xa, 0xe1, 0x90);
+			break;
+		case 12:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x5, 0x5, 0xe1, 0x90);
+			break;
+		case 13:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x1a, 0x1a, 0x60, 0x90);
+			break;
+		case 14:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x12, 0x12, 0x60, 0x90);
+			break;
+		case 15:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0xa, 0xa, 0x60, 0x90);
+			break;
+		case 16:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x5, 0x5, 0x60, 0x90);
+			break;
+		case 17:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xa3, 0x2f, 0x2f, 0x60, 0x90);
+			break;
+		case 18:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x5, 0x5, 0xe1, 0x90);
+			break;
+		case 19:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x25, 0x25, 0xe1, 0x90);
+			break;
+		case 20:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x25, 0x25, 0x60, 0x90);
+			break;
+		case 21:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x15, 0x03, 0x70, 0x90);
+			break;
+		case 22:	/* ad2dp master */
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xeb, 0x11, 0x11, 0x21, 0x10);
+			break;
+		case 23:	/* a2dp slave */
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xeb, 0x12, 0x12, 0x20, 0x10);
+			break;
+		case 71:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist,
+						 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+			break;
+		}
+	} else {
+		/* disable PS tdma */
+		switch (type) {
+		case 0:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist, 0x0,
+							 0x0, 0x0, 0x40, 0x0);
+			break;
+		case 1:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist, 0x0,
+							 0x0, 0x0, 0x48, 0x0);
+			break;
+		default:
+			halbtc8821aCsr2ant_set_fw_pstdma(btcoexist, 0x0,
+							 0x0, 0x0, 0x40, 0x0);
+			break;
+		}
+	}
+
+	/* update pre state */
+	coex_dm->pre_ps_tdma_on = coex_dm->cur_ps_tdma_on;
+	coex_dm->pre_ps_tdma = coex_dm->cur_ps_tdma;
+}
+
+void halbtc8821aCsr2ant_coex_all_off(IN struct btc_coexist *btcoexist)
+{
+	/* fw all off */
+	halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+	halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+	halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+	/* sw all off */
+	halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+
+	/* hw all off */
+	halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC, 0x55555555,
+				      0x55555555, 0xffff, 0x3);
+}
+
+void halbtc8821aCsr2ant_coex_under_5g(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821aCsr2ant_coex_all_off(btcoexist);
+
+	halbtc8821aCsr2ant_ignore_wlan_act(btcoexist, NORMAL_EXEC, true);
+}
+
+void halbtc8821aCsr2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	/* force to reset coex mechanism */
+	halbtc8821aCsr2ant_coex_table(btcoexist, FORCE_EXEC, 0x55555555,
+				      0x55555555, 0xffff, 0x3);
+
+	halbtc8821aCsr2ant_ps_tdma(btcoexist, FORCE_EXEC, false, 1);
+	halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, FORCE_EXEC, 6);
+	halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, FORCE_EXEC, false);
+
+	halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false, false, false, false);
+	halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false, false, false, 0x18);
+}
+
+void halbtc8821aCsr2ant_bt_inquiry_page(IN struct btc_coexist *btcoexist)
+{
+	boolean	low_pwr_disable = true;
+
+	btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+			   &low_pwr_disable);
+
+	halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC, 0x55ff55ff,
+				      0x5afa5afa, 0xffff, 0x3);
+	halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 3);
+}
+boolean halbtc8821aCsr2ant_is_common_action(IN struct btc_coexist *btcoexist)
+{
+	boolean			common = false, wifi_connected = false, wifi_busy = false;
+	boolean			low_pwr_disable = false;
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);
+
+	if (!wifi_connected &&
+	    BT_8821A_CSR_2ANT_BT_STATUS_IDLE == coex_dm->bt_status) {
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi IPS + BT IPS!!\n");
+		BTC_TRACE(trace_buf);
+
+
+		halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+		halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+		halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false, false, false,
+						 false);
+		halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false, false, false,
+						 0x18);
+		halbtc8821aCsr2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0,
+					      0, 0);
+		halbtc8821aCsr2ant_limited_rx(btcoexist, NORMAL_EXEC, 0, 0, 0);
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8821A_CSR_2ANT_BT_STATUS_IDLE ==
+		    coex_dm->bt_status)) {
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Wifi Busy + BT IPS!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						   false, 1);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Wifi LPS + BT IPS!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						   false, 1);
+		}
+
+		halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+		halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false, false, false,
+						 false);
+		halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false, false, false,
+						 0x18);
+		halbtc8821aCsr2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0,
+					      0, 0);
+		halbtc8821aCsr2ant_limited_rx(btcoexist, NORMAL_EXEC, 0, 0, 0);
+
+		common = true;
+	} else if (!wifi_connected &&
+		   (BT_8821A_CSR_2ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi IPS + BT LPS!!\n");
+		BTC_TRACE(trace_buf);
+
+		halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+		halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+		halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false, false, false,
+						 false);
+		halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false, false, false,
+						 0x18);
+		halbtc8821aCsr2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0,
+					      0, 0);
+		halbtc8821aCsr2ant_limited_rx(btcoexist, NORMAL_EXEC, 0, 0, 0);
+
+		common = true;
+	} else if (wifi_connected &&
+		   (BT_8821A_CSR_2ANT_BT_STATUS_CONNECTED_IDLE ==
+		    coex_dm->bt_status)) {
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Wifi Busy + BT LPS!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						   false, 1);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Wifi LPS + BT LPS!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						   false, 1);
+		}
+
+		halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+		halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true, true, true,
+						 true);
+		halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false, false, false,
+						 0x18);
+		halbtc8821aCsr2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0,
+					      0, 0);
+		halbtc8821aCsr2ant_limited_rx(btcoexist, NORMAL_EXEC, 0, 0, 0);
+
+		common = true;
+	} else if (!wifi_connected &&
+		   (BT_8821A_CSR_2ANT_BT_STATUS_NON_IDLE ==
+		    coex_dm->bt_status)) {
+		low_pwr_disable = false;
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Wifi IPS + BT Busy!!\n");
+		BTC_TRACE(trace_buf);
+
+		/* halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1); */
+		halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+		halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+		halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false, false, false,
+						 false);
+		halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false, false, false,
+						 0x18);
+		halbtc8821aCsr2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0,
+					      0, 0);
+		halbtc8821aCsr2ant_limited_rx(btcoexist, NORMAL_EXEC, 0, 0, 0);
+
+		common = true;
+	} else {
+		low_pwr_disable = true;
+		btcoexist->btc_set(btcoexist, BTC_SET_ACT_DISABLE_LOW_POWER,
+				   &low_pwr_disable);
+
+		if (wifi_busy) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Wifi Busy + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+			common = false;
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Wifi LPS + BT Busy!!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   21);
+
+			if (halbtc8821aCsr2ant_need_to_dec_bt_pwr(btcoexist))
+				halbtc8821aCsr2ant_dec_bt_pwr(btcoexist,
+						      NORMAL_EXEC, true);
+			else
+				halbtc8821aCsr2ant_dec_bt_pwr(btcoexist,
+						      NORMAL_EXEC, false);
+
+			common = true;
+		}
+
+		halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true, true, true,
+						 true);
+	}
+
+	if (common == true)
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5afa5afa, 0xffff, 0x3);
+
+	return common;
+}
+void halbtc8821aCsr2ant_tdma_duration_adjust(IN struct btc_coexist *btcoexist,
+		IN boolean sco_hid, IN boolean tx_pause, IN u8 max_interval)
+{
+	static s32		up, dn, m, n, wait_count;
+	s32			result;   /* 0: no change, +1: increase WiFi duration, -1: decrease WiFi duration */
+	u8			retry_count = 0;
+
+	if (coex_dm->reset_tdma_adjust) {
+		coex_dm->reset_tdma_adjust = false;
+		{
+			if (sco_hid) {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					} else if (max_interval == 2) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (max_interval == 3) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					} else if (max_interval == 2) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (max_interval == 3) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			} else {
+				if (tx_pause) {
+					if (max_interval == 1) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (max_interval == 2) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (max_interval == 3) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					}
+				} else {
+					if (max_interval == 1) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (max_interval == 2) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (max_interval == 3) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					}
+				}
+			}
+		}
+		/* ============ */
+		up = 0;
+		dn = 0;
+		m = 1;
+		n = 3;
+		result = 0;
+		wait_count = 0;
+	} else {
+		/* accquire the BT TRx retry count from BT_Info byte2 */
+		retry_count = coex_sta->bt_retry_cnt;
+		result = 0;
+		wait_count++;
+
+		if (retry_count ==
+		    0) { /* no retry in the last 2-second duration */
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;
+
+			if (up >= n) {	/* if s n 2 retry count0, heWiFi duration */
+				wait_count = 0;
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1;
+			}
+		} else if (retry_count <=
+			   3) {	/* <=3 retry in the last 2-second duration */
+			up--;
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2) {	/* if s 2 2 retry count< 3, hWiFi duration */
+				if (wait_count <= 2)
+					m++; /* K@blevel^ */
+				else
+					m = 1;
+
+				if (m >= 20)  /* m j = 20 ' j120 recheckO_ WiFi duration. */
+					m = 20;
+
+				n = 3 * m;
+				up = 0;
+				dn = 0;
+				wait_count = 0;
+				result = -1;
+			}
+		} else { /* retry count > 3, un1 retry count > 3, hWiFi duration */
+			if (wait_count == 1)
+				m++; /* K@blevel^ */
+			else
+				m = 1;
+
+			if (m >= 20)  /* m j = 20 ' j120 recheckO_ WiFi duration. */
+				m = 20;
+
+			n = 3 * m;
+			up = 0;
+			dn = 0;
+			wait_count = 0;
+			result = -1;
+		}
+
+		if (max_interval == 1) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 71) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 5);
+					coex_dm->ps_tdma_du_adj_type = 5;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 13);
+					coex_dm->ps_tdma_du_adj_type = 13;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 5);
+						coex_dm->ps_tdma_du_adj_type =
+							5;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 13);
+						coex_dm->ps_tdma_du_adj_type =
+							13;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 71);
+					coex_dm->ps_tdma_du_adj_type = 71;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 9);
+					coex_dm->ps_tdma_du_adj_type = 9;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 71) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 1);
+						coex_dm->ps_tdma_du_adj_type =
+							1;
+					} else if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 71);
+						coex_dm->ps_tdma_du_adj_type =
+							71;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 9);
+						coex_dm->ps_tdma_du_adj_type =
+							9;
+					}
+				}
+			}
+		} else if (max_interval == 2) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 6);
+					coex_dm->ps_tdma_du_adj_type = 6;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 14);
+					coex_dm->ps_tdma_du_adj_type = 14;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 6);
+						coex_dm->ps_tdma_du_adj_type =
+							6;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 14);
+						coex_dm->ps_tdma_du_adj_type =
+							14;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 2);
+					coex_dm->ps_tdma_du_adj_type = 2;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 10);
+					coex_dm->ps_tdma_du_adj_type = 10;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 2);
+						coex_dm->ps_tdma_du_adj_type =
+							2;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 10);
+						coex_dm->ps_tdma_du_adj_type =
+							10;
+					}
+				}
+			}
+		} else if (max_interval == 3) {
+			if (tx_pause) {
+				if (coex_dm->cur_ps_tdma == 1) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 2) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 3) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 7);
+					coex_dm->ps_tdma_du_adj_type = 7;
+				} else if (coex_dm->cur_ps_tdma == 4) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 8);
+					coex_dm->ps_tdma_du_adj_type = 8;
+				}
+				if (coex_dm->cur_ps_tdma == 9) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 10) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 11) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 15);
+					coex_dm->ps_tdma_du_adj_type = 15;
+				} else if (coex_dm->cur_ps_tdma == 12) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 16);
+					coex_dm->ps_tdma_du_adj_type = 16;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 5) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 8);
+						coex_dm->ps_tdma_du_adj_type =
+							8;
+					} else if (coex_dm->cur_ps_tdma == 13) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 16);
+						coex_dm->ps_tdma_du_adj_type =
+							16;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 8) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 7) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 6) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 7);
+						coex_dm->ps_tdma_du_adj_type =
+							7;
+					} else if (coex_dm->cur_ps_tdma == 16) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 15) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					} else if (coex_dm->cur_ps_tdma == 14) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 15);
+						coex_dm->ps_tdma_du_adj_type =
+							15;
+					}
+				}
+			} else {
+				if (coex_dm->cur_ps_tdma == 5) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 6) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 7) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 3);
+					coex_dm->ps_tdma_du_adj_type = 3;
+				} else if (coex_dm->cur_ps_tdma == 8) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 4);
+					coex_dm->ps_tdma_du_adj_type = 4;
+				}
+				if (coex_dm->cur_ps_tdma == 13) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 14) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 15) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 11);
+					coex_dm->ps_tdma_du_adj_type = 11;
+				} else if (coex_dm->cur_ps_tdma == 16) {
+					halbtc8821aCsr2ant_ps_tdma(btcoexist,
+						   NORMAL_EXEC, true, 12);
+					coex_dm->ps_tdma_du_adj_type = 12;
+				}
+				if (result == -1) {
+					if (coex_dm->cur_ps_tdma == 1) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 4);
+						coex_dm->ps_tdma_du_adj_type =
+							4;
+					} else if (coex_dm->cur_ps_tdma == 9) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 12);
+						coex_dm->ps_tdma_du_adj_type =
+							12;
+					}
+				} else if (result == 1) {
+					if (coex_dm->cur_ps_tdma == 4) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 3) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 2) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 3);
+						coex_dm->ps_tdma_du_adj_type =
+							3;
+					} else if (coex_dm->cur_ps_tdma == 12) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 11) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					} else if (coex_dm->cur_ps_tdma == 10) {
+						halbtc8821aCsr2ant_ps_tdma(
+							btcoexist, NORMAL_EXEC,
+							true, 11);
+						coex_dm->ps_tdma_du_adj_type =
+							11;
+					}
+				}
+			}
+		}
+	}
+
+	/* if current PsTdma not match with the recorded one (when scan, dhcp...), */
+	/* then we have to adjust it back to the previous record one. */
+	if (coex_dm->cur_ps_tdma != coex_dm->ps_tdma_du_adj_type) {
+		boolean	scan = false, link = false, roam = false;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], PsTdma type dismatch!!!, cur_ps_tdma=%d, recordPsTdma=%d\n",
+			    coex_dm->cur_ps_tdma, coex_dm->ps_tdma_du_adj_type);
+		BTC_TRACE(trace_buf);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);
+		btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);
+
+		if (!scan && !link && !roam)
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+					   coex_dm->ps_tdma_du_adj_type);
+		else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	/* when halbtc8821aCsr2ant_tdma_duration_adjust() is called, fw dac swing is included in the function. */
+	/* if(coex_dm->ps_tdma_du_adj_type == 71) */
+	/*	halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 0xc); //Skip because A2DP get worse at HT40 */
+	/* else */
+	halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC,
+					    0x6);
+}
+
+/* SCO only or SCO+PAN(HS) */
+void halbtc8821aCsr2ant_action_sco(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC, 0x55555555,
+				      0x55555555, 0xffffff, 0x3);
+	halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+
+	halbtc8821aCsr2ant_low_penalty_ra(btcoexist, NORMAL_EXEC, true);
+
+	halbtc8821aCsr2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 1, 0, 2, 0);
+
+	if (coex_sta->slave == false)
+		halbtc8821aCsr2ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					      true, 0x4);
+	else
+		halbtc8821aCsr2ant_limited_rx(btcoexist, NORMAL_EXEC, false,
+					      true, 0x2);
+
+	/*
+		wifi_rssi_state = halbtc8821aCsr2ant_wifi_rssi_state(btcoexist, 0, 2, 15, 0);
+		bt_rssi_state = halbtc8821aCsr2ant_bt_rssi_state(2, 35, 0);
+
+		halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 4);
+
+		if(halbtc8821aCsr2ant_need_to_dec_bt_pwr(btcoexist))
+			halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, true);
+		else
+			halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+		if (BTC_WIFI_BW_LEGACY == wifi_bw)
+		{
+			halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC, 0x5a5a5a5a, 0x5a5a5a5a, 0xffff, 0x3);
+		}
+		else
+		{
+			halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC, 0x5aea5aea, 0x5aea5aea, 0xffff, 0x3);
+		}
+
+		if(BTC_WIFI_BW_HT40 == wifi_bw)
+		{
+
+
+
+
+			if( (bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+				(bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+			}
+			else
+			{
+				halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+			}
+
+
+			if( (wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+				(wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8821aCsr2ant_sw_mechanism1(btcoexist,true,true,false,false);
+				halbtc8821aCsr2ant_sw_mechanism2(btcoexist,true,false,false,0x18);
+			}
+			else
+			{
+				halbtc8821aCsr2ant_sw_mechanism1(btcoexist,true,true,false,false);
+				halbtc8821aCsr2ant_sw_mechanism2(btcoexist,false,false,false,0x18);
+			}
+		}
+		else
+		{
+
+
+
+			if( (bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+				(bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+			}
+			else
+			{
+				halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 0);
+			}
+
+
+			if( (wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+				(wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				 halbtc8821aCsr2ant_sw_mechanism1(btcoexist,false,true,false,false);
+				 halbtc8821aCsr2ant_sw_mechanism2(btcoexist,true,false,false,0x18);
+			}
+			else
+			{
+				 halbtc8821aCsr2ant_sw_mechanism1(btcoexist,false,true,false,false);
+				 halbtc8821aCsr2ant_sw_mechanism2(btcoexist,false,false,false,0x18);
+			}
+		}
+	*/
+}
+
+
+void halbtc8821aCsr2ant_action_hid(IN struct btc_coexist *btcoexist)
+{
+	u8	wifi_rssi_state, bt_rssi_state;
+	u32	wifi_bw;
+
+	wifi_rssi_state = halbtc8821aCsr2ant_wifi_rssi_state(btcoexist, 0, 2,
+			  15, 0);
+	bt_rssi_state = halbtc8821aCsr2ant_bt_rssi_state(2, 35, 0);
+
+	halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (halbtc8821aCsr2ant_need_to_dec_bt_pwr(btcoexist))
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, true);
+	else
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for HID at 11b/g mode */
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5a5a5a5a, 0xffff, 0x3);
+	else  /* for HID quality & wifi performance balance at 11n mode */
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5aea5aea, 0xffff, 0x3);
+
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		/* fw mechanism */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   9);
+		else
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   13);
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true, true,
+							 false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true, true,
+							 false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	} else {
+		/* fw mechanism */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   9);
+		else
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   13);
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 true, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 true, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	}
+}
+
+/* A2DP only / PAN(EDR) only/ A2DP+PAN(HS) */
+void halbtc8821aCsr2ant_action_a2dp(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821aCsr2ant_limited_rx(btcoexist, NORMAL_EXEC, false, true, 0x8);
+
+	if (coex_sta->slave == false) {
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0xfdfdfdfd, 0xdfdadfda, 0xffffff, 0x3);
+		halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 22);
+		halbtc8821aCsr2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0,
+					      0, 1);
+		halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false, false, true,
+						 0x0c);
+	} else {
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0xfdfdfdfd, 0xdfdadfda, 0xffffff, 0x3);
+		halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true, 23);
+		halbtc8821aCsr2ant_limited_tx(btcoexist, NORMAL_EXEC, 0, 0, 0,
+					      0, 2);
+		halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false, false, true,
+						 0x18);
+	}
+
+	/*
+		wifi_rssi_state = halbtc8821aCsr2ant_wifi_rssi_state(btcoexist, 0, 2, 15, 0);
+		bt_rssi_state = halbtc8821aCsr2ant_bt_rssi_state(2, 35, 0);
+
+
+
+
+
+		if(halbtc8821aCsr2ant_need_to_dec_bt_pwr(btcoexist))
+			halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, true);
+		else
+			halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+		if(BTC_WIFI_BW_HT40 == wifi_bw)
+		{
+
+			if( (bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+				(bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8821aCsr2ant_tdma_duration_adjust(btcoexist, false, false, 1);
+			}
+			else
+			{
+				halbtc8821aCsr2ant_tdma_duration_adjust(btcoexist, false, true, 1);
+			}
+
+
+			if( (wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+				(wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				 halbtc8821aCsr2ant_sw_mechanism1(btcoexist,true,false,false,false);
+				 halbtc8821aCsr2ant_sw_mechanism2(btcoexist,true,false,false,0x18);
+			}
+			else
+			{
+				 halbtc8821aCsr2ant_sw_mechanism1(btcoexist,true,false,false,false);
+				 halbtc8821aCsr2ant_sw_mechanism2(btcoexist,false,false,false,0x18);
+			}
+		}
+		else
+		{
+
+			if( (bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+				(bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				halbtc8821aCsr2ant_tdma_duration_adjust(btcoexist, false, false, 1);
+			}
+			else
+			{
+				halbtc8821aCsr2ant_tdma_duration_adjust(btcoexist, false, true, 1);
+			}
+
+
+			if( (wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+				(wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+				 halbtc8821aCsr2ant_sw_mechanism1(btcoexist,false,false,false,false);
+				 halbtc8821aCsr2ant_sw_mechanism2(btcoexist,true,false,false,0x18);
+			}
+			else
+			{
+				 halbtc8821aCsr2ant_sw_mechanism1(btcoexist,false,false,false,false);
+				 halbtc8821aCsr2ant_sw_mechanism2(btcoexist,false,false,false,0x18);
+			}
+		}
+	*/
+}
+
+void halbtc8821aCsr2ant_action_a2dp_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state, bt_info_ext;
+	u32		wifi_bw;
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	wifi_rssi_state = halbtc8821aCsr2ant_wifi_rssi_state(btcoexist, 0, 2,
+			  15, 0);
+	bt_rssi_state = halbtc8821aCsr2ant_bt_rssi_state(2, 35, 0);
+
+	/* fw dac swing is called in halbtc8821aCsr2ant_tdma_duration_adjust() */
+	/* halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6); */
+
+
+	if (halbtc8821aCsr2ant_need_to_dec_bt_pwr(btcoexist))
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, true);
+	else
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		/* fw mechanism */
+		if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+			halbtc8821aCsr2ant_tdma_duration_adjust(btcoexist,
+								false, true, 2);
+		else				/* a2dp edr rate */
+			halbtc8821aCsr2ant_tdma_duration_adjust(btcoexist,
+								false, true, 1);
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	} else {
+		/* fw mechanism */
+		if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+			halbtc8821aCsr2ant_tdma_duration_adjust(btcoexist,
+								false, true, 2);
+		else				/* a2dp edr rate */
+			halbtc8821aCsr2ant_tdma_duration_adjust(btcoexist,
+								false, true, 1);
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	}
+}
+
+void halbtc8821aCsr2ant_action_pan_edr(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821aCsr2ant_wifi_rssi_state(btcoexist, 0, 2,
+			  15, 0);
+	bt_rssi_state = halbtc8821aCsr2ant_bt_rssi_state(2, 35, 0);
+
+	halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (halbtc8821aCsr2ant_need_to_dec_bt_pwr(btcoexist))
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, true);
+	else
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for HID at 11b/g mode */
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5aff5aff, 0xffff, 0x3);
+	else  /* for HID quality & wifi performance balance at 11n mode */
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5aff5aff, 0xffff, 0x3);
+
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		/* fw mechanism */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   1);
+		else
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   5);
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	} else {
+		/* fw mechanism */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   1);
+		else
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   5);
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	}
+}
+
+
+/* PAN(HS) only */
+void halbtc8821aCsr2ant_action_pan_hs(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821aCsr2ant_wifi_rssi_state(btcoexist, 0, 2,
+			  15, 0);
+	bt_rssi_state = halbtc8821aCsr2ant_bt_rssi_state(2, 35, 0);
+
+	halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		/* fw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+			halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC,
+						      true);
+		else
+			halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC,
+						      false);
+		halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, false, 1);
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	} else {
+		/* fw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+			halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC,
+						      true);
+		else
+			halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC,
+						      false);
+
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						   false, 1);
+		else
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC,
+						   false, 1);
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	}
+}
+
+/* PAN(EDR)+A2DP */
+void halbtc8821aCsr2ant_action_pan_edr_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state, bt_info_ext;
+	u32		wifi_bw;
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	wifi_rssi_state = halbtc8821aCsr2ant_wifi_rssi_state(btcoexist, 0, 2,
+			  15, 0);
+	bt_rssi_state = halbtc8821aCsr2ant_bt_rssi_state(2, 35, 0);
+
+	halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (halbtc8821aCsr2ant_need_to_dec_bt_pwr(btcoexist))
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, true);
+	else
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for HID at 11b/g mode */
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5afa5afa, 0xffff, 0x3);
+	else  /* for HID quality & wifi performance balance at 11n mode */
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5afa5afa, 0xffff, 0x3);
+
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		/* fw mechanism */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, false, false, 3);
+			else				/* a2dp edr rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, false, false, 3);
+		} else {
+			if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, false, true, 3);
+			else				/* a2dp edr rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, false, true, 3);
+		}
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		};
+	} else {
+		/* fw mechanism */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, false, false, 3);
+			else				/* a2dp edr rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, false, false, 3);
+		} else {
+			if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, false, true, 3);
+			else				/* a2dp edr rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, false, true, 3);
+		}
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 false, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	}
+}
+
+void halbtc8821aCsr2ant_action_pan_edr_hid(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state;
+	u32		wifi_bw;
+
+	wifi_rssi_state = halbtc8821aCsr2ant_wifi_rssi_state(btcoexist, 0, 2,
+			  15, 0);
+	bt_rssi_state = halbtc8821aCsr2ant_bt_rssi_state(2, 35, 0);
+
+	halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (halbtc8821aCsr2ant_need_to_dec_bt_pwr(btcoexist))
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, true);
+	else
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for HID at 11b/g mode */
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5a5f5a5f, 0xffff, 0x3);
+	else  /* for HID quality & wifi performance balance at 11n mode */
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5a5f5a5f, 0xffff, 0x3);
+
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 3);
+		/* fw mechanism */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   10);
+		else
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   14);
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true, true,
+							 false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true, true,
+							 false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	} else {
+		halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+		/* fw mechanism */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH))
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   10);
+		else
+			halbtc8821aCsr2ant_ps_tdma(btcoexist, NORMAL_EXEC, true,
+						   14);
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 true, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 true, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	}
+}
+
+/* HID+A2DP+PAN(EDR) */
+void halbtc8821aCsr2ant_action_hid_a2dp_pan_edr(IN struct btc_coexist
+		*btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state, bt_info_ext;
+	u32		wifi_bw;
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	wifi_rssi_state = halbtc8821aCsr2ant_wifi_rssi_state(btcoexist, 0, 2,
+			  15, 0);
+	bt_rssi_state = halbtc8821aCsr2ant_bt_rssi_state(2, 35, 0);
+
+	halbtc8821aCsr2ant_fw_dac_swing_lvl(btcoexist, NORMAL_EXEC, 6);
+
+	if (halbtc8821aCsr2ant_need_to_dec_bt_pwr(btcoexist))
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, true);
+	else
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) /* for HID at 11b/g mode */
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5a5a5a5a, 0xffff, 0x3);
+	else  /* for HID quality & wifi performance balance at 11n mode */
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5a5a5a5a, 0xffff, 0x3);
+
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		/* fw mechanism */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 3);
+			else				/* a2dp edr rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 3);
+		} else {
+			if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 3);
+			else				/* a2dp edr rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 3);
+		}
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true, true,
+							 false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true, true,
+							 false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	} else {
+		/* fw mechanism */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, false, 3);
+			else				/* a2dp edr rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, false, 3);
+		} else {
+			if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 3);
+			else				/* a2dp edr rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 3);
+		}
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 true, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 true, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	}
+}
+
+void halbtc8821aCsr2ant_action_hid_a2dp(IN struct btc_coexist *btcoexist)
+{
+	u8		wifi_rssi_state, bt_rssi_state, bt_info_ext;
+	u32		wifi_bw;
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	wifi_rssi_state = halbtc8821aCsr2ant_wifi_rssi_state(btcoexist, 0, 2,
+			  15, 0);
+	bt_rssi_state = halbtc8821aCsr2ant_bt_rssi_state(2, 35, 0);
+
+	if (halbtc8821aCsr2ant_need_to_dec_bt_pwr(btcoexist))
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, true);
+	else
+		halbtc8821aCsr2ant_dec_bt_pwr(btcoexist, NORMAL_EXEC, false);
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+
+	if (BTC_WIFI_BW_LEGACY == wifi_bw) { /* for HID at 11b/g mode */
+		/* Allen		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC, 0x55ff55ff, 0x5a5a5a5a, 0xffff, 0x3); */
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5f5b5f5b, 0xffffff, 0x3);
+	} else { /* for HID quality & wifi performance balance at 11n mode */
+		/* Allen		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC, 0x55ff55ff, 0x5a5a5a5a, 0xffff, 0x3); */
+		halbtc8821aCsr2ant_coex_table(btcoexist, NORMAL_EXEC,
+				      0x55ff55ff, 0x5f5b5f5b, 0xffffff, 0x3);
+
+	}
+
+	if (BTC_WIFI_BW_HT40 == wifi_bw) {
+		/* fw mechanism */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 2);
+			else				/* a2dp edr rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 2);
+		} else {
+			if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 2);
+			else				/* a2dp edr rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 2);
+		}
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true, true,
+							 false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, true, true,
+							 false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	} else {
+		/* fw mechanism */
+		if ((bt_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (bt_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			if (bt_info_ext & BIT(0)) {	/* a2dp basic rate */
+				/*				halbtc8821aCsr2ant_tdma_duration_adjust(btcoexist, true, false, 2); */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 2);
+
+			} else {			/* a2dp edr rate */
+				/* Allen				halbtc8821aCsr2ant_tdma_duration_adjust(btcoexist, true, false, 2); */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 2);
+			}
+		} else {
+			if (bt_info_ext & BIT(0))	/* a2dp basic rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 2);
+			else				/* a2dp edr rate */
+				halbtc8821aCsr2ant_tdma_duration_adjust(
+					btcoexist, true, true, 2);
+		}
+
+		/* sw mechanism */
+		if ((wifi_rssi_state == BTC_RSSI_STATE_HIGH) ||
+		    (wifi_rssi_state == BTC_RSSI_STATE_STAY_HIGH)) {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 true, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, true,
+							 false, false, 0x18);
+		} else {
+			halbtc8821aCsr2ant_sw_mechanism1(btcoexist, false,
+							 true, false, false);
+			halbtc8821aCsr2ant_sw_mechanism2(btcoexist, false,
+							 false, false, 0x18);
+		}
+	}
+}
+
+void halbtc8821aCsr2ant_run_coexist_mechanism(IN struct btc_coexist *btcoexist)
+{
+	boolean				wifi_under_5g = false;
+	u8				algorithm = 0;
+
+	if (btcoexist->manual_control) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Manual control!!!\n");
+		BTC_TRACE(trace_buf);
+		return;
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	if (wifi_under_5g) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], RunCoexistMechanism(), run 5G coex setting!!<===\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821aCsr2ant_coex_under_5g(btcoexist);
+		return;
+	}
+
+	{
+		algorithm = halbtc8821aCsr2ant_action_algorithm(btcoexist);
+		if (coex_sta->c2h_bt_inquiry_page &&
+		    (BT_8821A_CSR_2ANT_COEX_ALGO_PANHS != algorithm)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				"[BTCoex], BT is under inquiry/page scan !!\n");
+			BTC_TRACE(trace_buf);
+			halbtc8821aCsr2ant_bt_inquiry_page(btcoexist);
+			return;
+		}
+
+		coex_dm->cur_algorithm = algorithm;
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			"[BTCoex], Algorithm = %d\n", coex_dm->cur_algorithm);
+		BTC_TRACE(trace_buf);
+
+		if (halbtc8821aCsr2ant_is_common_action(btcoexist)) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+				    "[BTCoex], Action 2-Ant common.\n");
+			BTC_TRACE(trace_buf);
+			coex_dm->reset_tdma_adjust = true;
+		} else {
+			if (coex_dm->cur_algorithm != coex_dm->pre_algorithm) {
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], pre_algorithm=%d, cur_algorithm=%d\n",
+					    coex_dm->pre_algorithm,
+					    coex_dm->cur_algorithm);
+				BTC_TRACE(trace_buf);
+				coex_dm->reset_tdma_adjust = true;
+			}
+			switch (coex_dm->cur_algorithm) {
+			case BT_8821A_CSR_2ANT_COEX_ALGO_SCO:
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Action 2-Ant, algorithm = SCO.\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821aCsr2ant_action_sco(
+					btcoexist);
+				break;
+			case BT_8821A_CSR_2ANT_COEX_ALGO_HID:
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Action 2-Ant, algorithm = HID.\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821aCsr2ant_action_hid(
+					btcoexist);
+				break;
+			case BT_8821A_CSR_2ANT_COEX_ALGO_A2DP:
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Action 2-Ant, algorithm = A2DP.\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821aCsr2ant_action_a2dp(
+					btcoexist);
+				break;
+			case BT_8821A_CSR_2ANT_COEX_ALGO_A2DP_PANHS:
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821aCsr2ant_action_a2dp_pan_hs(
+					btcoexist);
+				break;
+			case BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR:
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821aCsr2ant_action_pan_edr(
+					btcoexist);
+				break;
+			case BT_8821A_CSR_2ANT_COEX_ALGO_PANHS:
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Action 2-Ant, algorithm = HS mode.\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821aCsr2ant_action_pan_hs(
+					btcoexist);
+				break;
+			case BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_A2DP:
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821aCsr2ant_action_pan_edr_a2dp(
+					btcoexist);
+				break;
+			case BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID:
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821aCsr2ant_action_pan_edr_hid(
+					btcoexist);
+				break;
+			case BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP_PANEDR
+					:
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821aCsr2ant_action_hid_a2dp_pan_edr(
+					btcoexist);
+				break;
+			case BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP:
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821aCsr2ant_action_hid_a2dp(
+					btcoexist);
+				break;
+			default:
+				BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+					"[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n");
+				BTC_TRACE(trace_buf);
+				halbtc8821aCsr2ant_coex_all_off(
+					btcoexist);
+				break;
+			}
+			coex_dm->pre_algorithm = coex_dm->cur_algorithm;
+		}
+	}
+}
+
+
+
+/* ************************************************************
+ * work around function start with wa_halbtc8821aCsr2ant_
+ * ************************************************************
+ * ************************************************************
+ * extern function start with ex_halbtc8821aCsr2ant_
+ * ************************************************************ */
+void ex_halbtc8821aCsr2ant_power_on_setting(IN struct btc_coexist *btcoexist)
+{
+}
+
+void ex_halbtc8821aCsr2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+		IN boolean wifi_only)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], 2Ant Init HW Config!!\n");
+	BTC_TRACE(trace_buf);
+
+	if (wifi_only)
+		return;
+
+	/* if(back_up) */
+	{
+		/* backup rf 0x1e value */
+		coex_dm->bt_rf_0x1e_backup = btcoexist->btc_get_rf_reg(
+				     btcoexist, BTC_RF_A, 0x1e, 0xfffff);
+		coex_dm->backup_arfr_cnt1 = btcoexist->btc_read_4byte(btcoexist,
+					    0x430);
+		coex_dm->backup_arfr_cnt2 = btcoexist->btc_read_4byte(btcoexist,
+					    0x434);
+		coex_dm->backup_retry_limit = btcoexist->btc_read_2byte(
+						      btcoexist, 0x42a);
+		coex_dm->backup_ampdu_max_time = btcoexist->btc_read_1byte(
+				btcoexist, 0x456);
+		coex_dm->backup_ampdu_max_num = btcoexist->btc_read_2byte(
+							btcoexist, 0x4ca);
+	}
+
+#if 0 /* REMOVE */
+	/* 0x790[5:0]=0x5 */
+	u8tmp = btcoexist->btc_read_1byte(btcoexist, 0x790);
+	u8tmp &= 0xc0;
+	u8tmp |= 0x5;
+	btcoexist->btc_write_1byte(btcoexist, 0x790, u8tmp);
+#endif
+
+	/* Antenna config */
+	halbtc8821aCsr2ant_set_ant_path(btcoexist, BTC_ANT_WIFI_AT_MAIN, true,
+					false);
+
+	/* PTA parameter */
+	halbtc8821aCsr2ant_coex_table(btcoexist, FORCE_EXEC, 0x55555555,
+				      0x55555555, 0xffff, 0x3);
+
+	/* Enable counter statistics */
+	btcoexist->btc_write_1byte(btcoexist, 0x76e,
+			   0xc); /* 0x76e[3] =1, WLAN_Act control by PTA */
+	btcoexist->btc_write_1byte(btcoexist, 0x778, 0x3);
+
+#if 0 /* REMOVE */
+	btcoexist->btc_write_1byte_bitmask(btcoexist, 0x40, 0x20, 0x1);
+#endif
+}
+
+void ex_halbtc8821aCsr2ant_init_coex_dm(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Coex Mechanism Init!!\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821aCsr2ant_init_coex_dm(btcoexist);
+}
+
+void ex_halbtc8821aCsr2ant_display_coex_info(IN struct btc_coexist *btcoexist)
+{
+	struct  btc_board_info		*board_info = &btcoexist->board_info;
+	struct  btc_stack_info		*stack_info = &btcoexist->stack_info;
+	u8				*cli_buf = btcoexist->cli_buf;
+	u8				u8tmp[4], i, bt_info_ext, ps_tdma_case = 0;
+	u32				u32tmp[4];
+	u32				fw_ver = 0, bt_patch_ver = 0;
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+		   "Ant PG number/ Ant mechanism:",
+		   board_info->pg_ant_num, board_info->btdm_ant_num);
+	CL_PRINTF(cli_buf);
+
+	if (btcoexist->manual_control) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+			   "[Action Manual control]!!");
+		CL_PRINTF(cli_buf);
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_BT_PATCH_VER, &bt_patch_ver);
+	btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_FW_VER, &fw_ver);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+		   "\r\n %-35s = %d_%d/ 0x%x/ 0x%x(%d)",
+		   "CoexVer/ FwVer/ PatchVer",
+		   glcoex_ver_date_8821a_csr_2ant, glcoex_ver_8821a_csr_2ant,
+		   fw_ver, bt_patch_ver, bt_patch_ver);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ",
+		   "Wifi channel informed to BT",
+		   coex_dm->wifi_chnl_info[0], coex_dm->wifi_chnl_info[1],
+		   coex_dm->wifi_chnl_info[2]);
+	CL_PRINTF(cli_buf);
+
+	/* wifi status */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Wifi Status]============");
+	CL_PRINTF(cli_buf);
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[BT Status]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ",
+		   "BT [status/ rssi/ retryCnt]",
+		   ((coex_sta->c2h_bt_inquiry_page) ? ("inquiry/page scan") : ((
+		   BT_8821A_CSR_2ANT_BT_STATUS_IDLE == coex_dm->bt_status)
+		   ? "idle" : ((BT_8821A_CSR_2ANT_BT_STATUS_CONNECTED_IDLE
+			== coex_dm->bt_status) ? "connected-idle" : "busy"))),
+		   coex_sta->bt_rssi, coex_sta->bt_retry_cnt);
+	CL_PRINTF(cli_buf);
+
+	if (stack_info->profile_notified) {
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %d / %d / %d / %d", "SCO/HID/PAN/A2DP",
+			   stack_info->sco_exist, stack_info->hid_exist,
+			   stack_info->pan_exist, stack_info->a2dp_exist);
+		CL_PRINTF(cli_buf);
+
+		btcoexist->btc_disp_dbg_msg(btcoexist,
+					    BTC_DBG_DISP_BT_LINK_INFO);
+	}
+
+	bt_info_ext = coex_sta->bt_info_ext;
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s",
+		   "BT Info A2DP rate",
+		   (bt_info_ext & BIT(0)) ? "Basic rate" : "EDR rate");
+	CL_PRINTF(cli_buf);
+
+	for (i = 0; i < BT_INFO_SRC_8821A_CSR_2ANT_MAX; i++) {
+		if (coex_sta->bt_info_c2h_cnt[i]) {
+			CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+				"\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)",
+				   glbt_info_src_8821a_csr_2ant[i],
+				   coex_sta->bt_info_c2h[i][0],
+				   coex_sta->bt_info_c2h[i][1],
+				   coex_sta->bt_info_c2h[i][2],
+				   coex_sta->bt_info_c2h[i][3],
+				   coex_sta->bt_info_c2h[i][4],
+				   coex_sta->bt_info_c2h[i][5],
+				   coex_sta->bt_info_c2h[i][6],
+				   coex_sta->bt_info_c2h_cnt[i]);
+			CL_PRINTF(cli_buf);
+		}
+	}
+
+	/* Sw mechanism	 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Sw mechanism]============");
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ",
+		   "SM1[ShRf/ LpRA/ LimDig]",
+		   coex_dm->cur_rf_rx_lpf_shrink, coex_dm->cur_low_penalty_ra,
+		   coex_dm->limited_dig);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ",
+		   "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]",
+		   coex_dm->cur_agc_table_en, coex_dm->cur_adc_back_off,
+		   coex_dm->cur_dac_swing_on, coex_dm->cur_dac_swing_lvl);
+	CL_PRINTF(cli_buf);
+
+	/* Fw mechanism		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Fw mechanism]============");
+	CL_PRINTF(cli_buf);
+
+	if (!btcoexist->manual_control) {
+		ps_tdma_case = coex_dm->cur_ps_tdma;
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE,
+			   "\r\n %-35s = %02x %02x %02x %02x %02x case-%d",
+			   "PS TDMA",
+			   coex_dm->ps_tdma_para[0], coex_dm->ps_tdma_para[1],
+			   coex_dm->ps_tdma_para[2], coex_dm->ps_tdma_para[3],
+			   coex_dm->ps_tdma_para[4], ps_tdma_case);
+		CL_PRINTF(cli_buf);
+
+		CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ",
+			   "DecBtPwr/ IgnWlanAct",
+			coex_dm->cur_dec_bt_pwr, coex_dm->cur_ignore_wlan_act);
+		CL_PRINTF(cli_buf);
+	}
+
+	/* Hw setting		 */
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s",
+		   "============[Hw setting]============");
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x",
+		   "RF-A, 0x1e initVal",
+		   coex_dm->bt_rf_0x1e_backup);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x778);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0x6cc);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x ",
+		   "0x778 (W_Act)/ 0x6cc (CoTab Sel)",
+		   u8tmp[0], u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x8db);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xc5b);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x8db(ADC)/0xc5b[29:25](DAC)",
+		   ((u8tmp[0] & 0x60) >> 5), ((u8tmp[1] & 0x3e) >> 1));
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xcb4);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xcb4[7:0](ctrl)/ 0xcb4[29:28](val)",
+		   u32tmp[0] & 0xff, ((u32tmp[0] & 0x30000000) >> 28));
+	CL_PRINTF(cli_buf);
+
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x40);
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x4c);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x974);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x40/ 0x4c[24:23]/ 0x974",
+		   u8tmp[0], ((u32tmp[0] & 0x01800000) >> 23), u32tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x550);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0x522);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0x550(bcn ctrl)/0x522",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xc50);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xa0a);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "0xc50(DIG)/0xa0a(CCK-TH)",
+		   u32tmp[0], u8tmp[0]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0xf48);
+	u8tmp[0] = btcoexist->btc_read_1byte(btcoexist, 0xa5b);
+	u8tmp[1] = btcoexist->btc_read_1byte(btcoexist, 0xa5c);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x",
+		   "OFDM-FA/ CCK-FA",
+		   u32tmp[0], (u8tmp[0] << 8) + u8tmp[1]);
+	CL_PRINTF(cli_buf);
+
+	u32tmp[0] = btcoexist->btc_read_4byte(btcoexist, 0x6c0);
+	u32tmp[1] = btcoexist->btc_read_4byte(btcoexist, 0x6c4);
+	u32tmp[2] = btcoexist->btc_read_4byte(btcoexist, 0x6c8);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x",
+		   "0x6c0/0x6c4/0x6c8",
+		   u32tmp[0], u32tmp[1], u32tmp[2]);
+	CL_PRINTF(cli_buf);
+
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x770 (hi-pri Rx/Tx)",
+		   coex_sta->high_priority_rx, coex_sta->high_priority_tx);
+	CL_PRINTF(cli_buf);
+	CL_SPRINTF(cli_buf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d",
+		   "0x774(low-pri Rx/Tx)",
+		   coex_sta->low_priority_rx, coex_sta->low_priority_tx);
+	CL_PRINTF(cli_buf);
+
+	btcoexist->btc_disp_dbg_msg(btcoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+void ex_halbtc8821aCsr2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				      IN u8 type)
+{
+	if (BTC_IPS_ENTER == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS ENTER notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = true;
+		halbtc8821aCsr2ant_coex_all_off(btcoexist);
+	} else if (BTC_IPS_LEAVE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], IPS LEAVE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_ips = false;
+		/* halbtc8821aCsr2ant_init_coex_dm(btcoexist); */
+	}
+}
+
+void ex_halbtc8821aCsr2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				      IN u8 type)
+{
+	if (BTC_LPS_ENABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS ENABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = true;
+	} else if (BTC_LPS_DISABLE == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], LPS DISABLE notify\n");
+		BTC_TRACE(trace_buf);
+		coex_sta->under_lps = false;
+	}
+}
+
+void ex_halbtc8821aCsr2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type)
+{
+	if (BTC_SCAN_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_SCAN_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], SCAN FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8821aCsr2ant_connect_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	if (BTC_ASSOCIATE_START == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT START notify\n");
+		BTC_TRACE(trace_buf);
+	} else if (BTC_ASSOCIATE_FINISH == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], CONNECT FINISH notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8821aCsr2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type)
+{
+	u8			h2c_parameter[3] = {0};
+	u32			wifi_bw;
+	u8			wifi_central_chnl;
+
+	if (BTC_MEDIA_CONNECT == type) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA connect notify\n");
+		BTC_TRACE(trace_buf);
+	} else {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], MEDIA disconnect notify\n");
+		BTC_TRACE(trace_buf);
+	}
+
+	/* only 2.4G we need to inform bt the chnl mask */
+	btcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL,
+			   &wifi_central_chnl);
+	if ((BTC_MEDIA_CONNECT == type) &&
+	    (wifi_central_chnl <= 14)) {
+		h2c_parameter[0] = 0x1;
+		h2c_parameter[1] = wifi_central_chnl;
+		btcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);
+		if (BTC_WIFI_BW_HT40 == wifi_bw)
+			h2c_parameter[2] = 0x30;
+		else
+			h2c_parameter[2] = 0x20;
+	}
+
+}
+
+void ex_halbtc8821aCsr2ant_specific_packet_notify(IN struct btc_coexist
+		*btcoexist, IN u8 type)
+{
+	if (type == BTC_PACKET_DHCP) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], DHCP Packet notify\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8821aCsr2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+		IN u8 *tmp_buf, IN u8 length)
+{
+	u8			bt_info = 0;
+	u8			i, rsp_source = 0;
+	boolean			bt_busy = false, limited_dig = false;
+	boolean			wifi_connected = false, bt_hs_on = false,
+				wifi_under_5g = false;
+
+	coex_sta->c2h_bt_info_req_sent = false;
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);
+
+	rsp_source = tmp_buf[0] & 0xf;
+	if (rsp_source >= BT_INFO_SRC_8821A_CSR_2ANT_MAX)
+		rsp_source = BT_INFO_SRC_8821A_CSR_2ANT_WIFI_FW;
+	coex_sta->bt_info_c2h_cnt[rsp_source]++;
+
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+		    "[BTCoex], Bt info[%d], length=%d, hex data=[", rsp_source,
+		    length);
+	BTC_TRACE(trace_buf);
+	for (i = 0; i < length; i++) {
+		coex_sta->bt_info_c2h[rsp_source][i] = tmp_buf[i];
+		if (i == 1)
+			bt_info = tmp_buf[i];
+		if (i == length - 1) {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x]\n",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		} else {
+			BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "0x%02x, ",
+				    tmp_buf[i]);
+			BTC_TRACE(trace_buf);
+		}
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_CONNECTED,
+			   &wifi_connected);
+	if (BT_INFO_SRC_8821A_CSR_2ANT_WIFI_FW != rsp_source) {
+		coex_sta->bt_retry_cnt =	/* [3:0] */
+			coex_sta->bt_info_c2h[rsp_source][2] & 0xf;
+
+		coex_sta->bt_rssi =
+			coex_sta->bt_info_c2h[rsp_source][3] * 2 + 10;
+
+		coex_sta->bt_info_ext =
+			coex_sta->bt_info_c2h[rsp_source][4];
+
+#if 0 /* REMOVE */
+		/* Here we need to resend some wifi info to BT */
+		/* because bt is reset and loss of the info. */
+		if ((coex_sta->bt_info_ext & BIT(1))) {
+
+			if (wifi_connected)
+				ex_halbtc8821aCsr2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_CONNECT);
+			else
+				ex_halbtc8821aCsr2ant_media_status_notify(
+					btcoexist, BTC_MEDIA_DISCONNECT);
+		}
+#endif
+
+	}
+
+	btcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);
+
+	if (bt_info ==
+	    BT_INFO_8821A_CSR_2ANT_B_CONNECTION) {	/* connection exists but no busy */
+		coex_sta->bt_link_exist = true;
+		coex_dm->bt_status =
+			BT_8821A_CSR_2ANT_BT_STATUS_CONNECTED_IDLE;
+	} else if (bt_info &
+		BT_INFO_8821A_CSR_2ANT_B_CONNECTION) {	/* connection exists and some link is busy */
+		coex_sta->bt_link_exist = true;
+
+		if (bt_info & BT_INFO_8821A_CSR_2ANT_B_FTP)
+			coex_sta->pan_exist = true;
+		else
+			coex_sta->pan_exist = false;
+
+		if (bt_info & BT_INFO_8821A_CSR_2ANT_B_A2DP)
+			coex_sta->a2dp_exist = true;
+		else
+			coex_sta->a2dp_exist = false;
+
+		if (bt_info & BT_INFO_8821A_CSR_2ANT_B_HID)
+			coex_sta->hid_exist = true;
+		else
+			coex_sta->hid_exist = false;
+
+		if (bt_info & BT_INFO_8821A_CSR_2ANT_B_SCO_ESCO)
+			coex_sta->sco_exist = true;
+		else
+			coex_sta->sco_exist = false;
+
+		if (coex_sta->bt_info_ext & 0x80)
+			coex_sta->slave = true; /* Slave */
+		else
+			coex_sta->slave = false; /* Master */
+
+		coex_dm->bt_status =
+			BT_8821A_CSR_2ANT_BT_STATUS_NON_IDLE;
+	} else {
+		coex_sta->bt_link_exist = false;
+		coex_sta->pan_exist = false;
+		coex_sta->a2dp_exist = false;
+		coex_sta->slave = false;
+		coex_sta->hid_exist = false;
+		coex_sta->sco_exist = false;
+		coex_dm->bt_status = BT_8821A_CSR_2ANT_BT_STATUS_IDLE;
+	}
+
+	if (bt_hs_on)
+		coex_dm->bt_status =
+			BT_8821A_CSR_2ANT_BT_STATUS_NON_IDLE;
+
+	if (bt_info & BT_INFO_8821A_CSR_2ANT_B_INQ_PAGE) {
+		coex_sta->c2h_bt_inquiry_page = true;
+		coex_dm->bt_status = BT_8821A_CSR_2ANT_BT_STATUS_NON_IDLE;
+	} else
+		coex_sta->c2h_bt_inquiry_page = false;
+
+
+	if (BT_8821A_CSR_2ANT_BT_STATUS_NON_IDLE == coex_dm->bt_status)
+		bt_busy = true;
+	else
+		bt_busy = false;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bt_busy);
+
+	if (BT_8821A_CSR_2ANT_BT_STATUS_IDLE != coex_dm->bt_status)
+		limited_dig = true;
+	else
+		limited_dig = false;
+	coex_dm->limited_dig = limited_dig;
+	btcoexist->btc_set(btcoexist, BTC_SET_BL_BT_LIMITED_DIG, &limited_dig);
+
+	halbtc8821aCsr2ant_run_coexist_mechanism(btcoexist);
+}
+
+void ex_halbtc8821aCsr2ant_halt_notify(IN struct btc_coexist *btcoexist)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Halt notify\n");
+	BTC_TRACE(trace_buf);
+
+	halbtc8821aCsr2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+	ex_halbtc8821aCsr2ant_media_status_notify(btcoexist,
+			BTC_MEDIA_DISCONNECT);
+}
+
+void ex_halbtc8821aCsr2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				      IN u8 pnp_state)
+{
+	BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE, "[BTCoex], Pnp notify\n");
+	BTC_TRACE(trace_buf);
+
+	if (BTC_WIFI_PNP_SLEEP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to SLEEP\n");
+		BTC_TRACE(trace_buf);
+		halbtc8821aCsr2ant_ignore_wlan_act(btcoexist, FORCE_EXEC, true);
+
+		/* Sinda 20150819, workaround for driver skip leave IPS/LPS to speed up sleep time. */
+		/* Driver do not leave IPS/LPS when driver is going to sleep, so BTCoexistence think wifi is still under IPS/LPS */
+		/* BT should clear UnderIPS/UnderLPS state to avoid mismatch state after wakeup. */
+		coex_sta->under_ips = false;
+		coex_sta->under_lps = false;
+	} else if (BTC_WIFI_PNP_WAKE_UP == pnp_state) {
+		BTC_SPRINTF(trace_buf, BT_TMP_BUF_SIZE,
+			    "[BTCoex], Pnp notify to WAKE UP\n");
+		BTC_TRACE(trace_buf);
+	}
+}
+
+void ex_halbtc8821aCsr2ant_periodical(IN struct btc_coexist *btcoexist)
+{
+	halbtc8821aCsr2ant_monitor_bt_ctr(btcoexist);
+	halbtc8821aCsr2ant_monitor_bt_enable_disable(btcoexist);
+}
+
+#endif
+
+#endif	/* #if (BT_SUPPORT == 1 && COEX_SUPPORT == 1) */
\ No newline at end of file
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821aCsr2Ant.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821aCsr2Ant.h
new file mode 100644
index 000000000..8d228fb17
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtc8821aCsr2Ant.h
@@ -0,0 +1,188 @@
+
+#if (BT_SUPPORT == 1 && COEX_SUPPORT == 1)
+
+#if (RTL8821A_SUPPORT == 1)
+
+/* *******************************************
+ * The following is for 8821A_CSR 2Ant BT Co-exist definition
+ * ******************************************* */
+#define	BT_INFO_8821A_CSR_2ANT_B_FTP						BIT(7)
+#define	BT_INFO_8821A_CSR_2ANT_B_A2DP					BIT(6)
+#define	BT_INFO_8821A_CSR_2ANT_B_HID						BIT(5)
+#define	BT_INFO_8821A_CSR_2ANT_B_SCO_BUSY				BIT(4)
+#define	BT_INFO_8821A_CSR_2ANT_B_ACL_BUSY				BIT(3)
+#define	BT_INFO_8821A_CSR_2ANT_B_INQ_PAGE				BIT(2)
+#define	BT_INFO_8821A_CSR_2ANT_B_SCO_ESCO				BIT(1)
+#define	BT_INFO_8821A_CSR_2ANT_B_CONNECTION				BIT(0)
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT		2
+
+enum bt_info_src_8821a_csr_2ant {
+	BT_INFO_SRC_8821A_CSR_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8821A_CSR_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8821A_CSR_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8821A_CSR_2ANT_MAX
+};
+
+enum bt_8821a_csr_2ant_bt_status {
+	BT_8821A_CSR_2ANT_BT_STATUS_IDLE				= 0x0,
+	BT_8821A_CSR_2ANT_BT_STATUS_CONNECTED_IDLE	= 0x1,
+	BT_8821A_CSR_2ANT_BT_STATUS_NON_IDLE			= 0x2,
+	BT_8821A_CSR_2ANT_BT_STATUS_MAX
+};
+
+enum bt_8821a_csr_2ant_coex_algo {
+	BT_8821A_CSR_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8821A_CSR_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8821A_CSR_2ANT_COEX_ALGO_HID				= 0x2,
+	BT_8821A_CSR_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8821A_CSR_2ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8821A_CSR_2ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8821A_CSR_2ANT_COEX_ALGO_MAX				= 0xb,
+};
+
+struct coex_dm_8821a_csr_2ant {
+	/* fw mechanism */
+	boolean		pre_dec_bt_pwr;
+	boolean		cur_dec_bt_pwr;
+	u8		pre_fw_dac_swing_lvl;
+	u8		cur_fw_dac_swing_lvl;
+	boolean		cur_ignore_wlan_act;
+	boolean		pre_ignore_wlan_act;
+	u8		pre_ps_tdma;
+	u8		cur_ps_tdma;
+	u8		ps_tdma_para[6];
+	u8		ps_tdma_du_adj_type;
+	boolean		reset_tdma_adjust;
+	boolean		pre_ps_tdma_on;
+	boolean		cur_ps_tdma_on;
+	boolean		pre_bt_auto_report;
+	boolean		cur_bt_auto_report;
+
+	/* sw mechanism */
+	boolean		pre_rf_rx_lpf_shrink;
+	boolean		cur_rf_rx_lpf_shrink;
+	u32		bt_rf_0x1e_backup;
+	boolean	pre_low_penalty_ra;
+	boolean		cur_low_penalty_ra;
+	boolean		pre_dac_swing_on;
+	u32		pre_dac_swing_lvl;
+	boolean		cur_dac_swing_on;
+	u32		cur_dac_swing_lvl;
+	boolean		pre_adc_back_off;
+	boolean		cur_adc_back_off;
+	boolean	pre_agc_table_en;
+	boolean		cur_agc_table_en;
+	u32		pre_val0x6c0;
+	u32		cur_val0x6c0;
+	u32		pre_val0x6c4;
+	u32		cur_val0x6c4;
+	u32		pre_val0x6c8;
+	u32		cur_val0x6c8;
+	u8		pre_val0x6cc;
+	u8		cur_val0x6cc;
+	boolean		limited_dig;
+
+	u32		pre_ra_mask;
+	u32		cur_ra_mask;
+
+	u8 cur_ampdu_num_type;
+	u8 pre_ampdu_num_type;
+	u16 backup_ampdu_max_num;
+
+	u8 cur_ampdu_time_type;
+	u8 pre_ampdu_time_type;
+	u8 backup_ampdu_max_time;
+
+	u8		cur_arfr_type;
+	u8		pre_arfr_type;
+	u32		backup_arfr_cnt1;
+	u32		backup_arfr_cnt2;
+
+	u8		cur_retry_limit_type;
+	u8		pre_retry_limit_type;
+	u16		backup_retry_limit;
+
+	/* algorithm related */
+	u8		pre_algorithm;
+	u8		cur_algorithm;
+	u8		bt_status;
+	u8		wifi_chnl_info[3];
+};
+
+struct coex_sta_8821a_csr_2ant {
+	boolean					bt_disabled;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					a2dp_exist;
+	boolean					slave;
+	boolean					hid_exist;
+	boolean					pan_exist;
+
+	boolean					under_lps;
+	boolean					under_ips;
+	u32					high_priority_tx;
+	u32					high_priority_rx;
+	u32					low_priority_tx;
+	u32					low_priority_rx;
+	u8					bt_rssi;
+	u8					pre_bt_rssi_state;
+	u8					pre_wifi_rssi_state[4];
+	boolean					c2h_bt_info_req_sent;
+	u8					bt_info_c2h[BT_INFO_SRC_8821A_CSR_2ANT_MAX][10];
+	u32					bt_info_c2h_cnt[BT_INFO_SRC_8821A_CSR_2ANT_MAX];
+	boolean					c2h_bt_inquiry_page;
+	u8					bt_retry_cnt;
+	u8					bt_info_ext;
+};
+
+/* *******************************************
+ * The following is interface which will notify coex module.
+ * ******************************************* */
+void ex_halbtc8821aCsr2ant_power_on_setting(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821aCsr2ant_init_hw_config(IN struct btc_coexist *btcoexist,
+		IN boolean wifi_only);
+void ex_halbtc8821aCsr2ant_init_coex_dm(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821aCsr2ant_ips_notify(IN struct btc_coexist *btcoexist,
+				      IN u8 type);
+void ex_halbtc8821aCsr2ant_lps_notify(IN struct btc_coexist *btcoexist,
+				      IN u8 type);
+void ex_halbtc8821aCsr2ant_scan_notify(IN struct btc_coexist *btcoexist,
+				       IN u8 type);
+void ex_halbtc8821aCsr2ant_connect_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821aCsr2ant_media_status_notify(IN struct btc_coexist *btcoexist,
+		IN u8 type);
+void ex_halbtc8821aCsr2ant_specific_packet_notify(IN struct btc_coexist
+		*btcoexist, IN u8 type);
+void ex_halbtc8821aCsr2ant_bt_info_notify(IN struct btc_coexist *btcoexist,
+		IN u8 *tmp_buf, IN u8 length);
+void ex_halbtc8821aCsr2ant_halt_notify(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821aCsr2ant_pnp_notify(IN struct btc_coexist *btcoexist,
+				      IN u8 pnp_state);
+void ex_halbtc8821aCsr2ant_periodical(IN struct btc_coexist *btcoexist);
+void ex_halbtc8821aCsr2ant_display_coex_info(IN struct btc_coexist *btcoexist);
+
+#else
+#define	ex_halbtc8821aCsr2ant_power_on_setting(btcoexist)
+#define	ex_halbtc8821aCsr2ant_init_hw_config(btcoexist, wifi_only)
+#define	ex_halbtc8821aCsr2ant_init_coex_dm(btcoexist)
+#define	ex_halbtc8821aCsr2ant_ips_notify(btcoexist, type)
+#define	ex_halbtc8821aCsr2ant_lps_notify(btcoexist, type)
+#define	ex_halbtc8821aCsr2ant_scan_notify(btcoexist, type)
+#define	ex_halbtc8821aCsr2ant_connect_notify(btcoexist, type)
+#define	ex_halbtc8821aCsr2ant_media_status_notify(btcoexist, type)
+#define	ex_halbtc8821aCsr2ant_specific_packet_notify(btcoexist, type)
+#define	ex_halbtc8821aCsr2ant_bt_info_notify(btcoexist, tmp_buf, length)
+#define	ex_halbtc8821aCsr2ant_halt_notify(btcoexist)
+#define	ex_halbtc8821aCsr2ant_pnp_notify(btcoexist, pnp_state)
+#define	ex_halbtc8821aCsr2ant_periodical(btcoexist)
+#define	ex_halbtc8821aCsr2ant_display_coex_info(btcoexist)
+#endif
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtcOutSrc.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtcOutSrc.h
new file mode 100644
index 000000000..9da98e367
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/HalBtcOutSrc.h
@@ -0,0 +1,900 @@
+#ifndef	__HALBTC_OUT_SRC_H__
+#define __HALBTC_OUT_SRC_H__
+
+
+#define		BTC_COEX_OFFLOAD			0
+#define		BTC_TMP_BUF_SHORT		20
+
+extern u1Byte	gl_btc_trace_buf[];
+#define		BTC_SPRINTF			rsprintf
+#define		BTC_TRACE(_MSG_) 		RT_TRACE(COMP_COEX, DBG_LOUD, (_MSG_))
+#define		BT_PrintData(adapter, _MSG_, len, data)	RT_PRINT_DATA(COMP_COEX, DBG_LOUD, (_MSG_), data, len)
+
+
+#define		NORMAL_EXEC					FALSE
+#define		FORCE_EXEC						TRUE
+
+#define		BTC_RF_OFF					0x0
+#define		BTC_RF_ON					0x1
+
+#define		BTC_RF_A					0x0
+#define		BTC_RF_B					0x1
+#define		BTC_RF_C					0x2
+#define		BTC_RF_D					0x3
+
+#define		BTC_SMSP				SINGLEMAC_SINGLEPHY
+#define		BTC_DMDP				DUALMAC_DUALPHY
+#define		BTC_DMSP				DUALMAC_SINGLEPHY
+#define		BTC_MP_UNKNOWN		0xff
+
+#define		BT_COEX_ANT_TYPE_PG			0
+#define		BT_COEX_ANT_TYPE_ANTDIV		1
+#define		BT_COEX_ANT_TYPE_DETECTED	2
+
+#define		BTC_MIMO_PS_STATIC			0	// 1ss
+#define		BTC_MIMO_PS_DYNAMIC			1	// 2ss
+
+#define		BTC_RATE_DISABLE			0
+#define		BTC_RATE_ENABLE				1
+
+// single Antenna definition
+#define		BTC_ANT_PATH_WIFI			0
+#define		BTC_ANT_PATH_BT				1
+#define		BTC_ANT_PATH_PTA			2
+// dual Antenna definition
+#define		BTC_ANT_WIFI_AT_MAIN		0
+#define		BTC_ANT_WIFI_AT_AUX			1
+// coupler Antenna definition
+#define		BTC_ANT_WIFI_AT_CPL_MAIN	0
+#define		BTC_ANT_WIFI_AT_CPL_AUX		1
+
+typedef enum _BTC_POWERSAVE_TYPE{
+	BTC_PS_WIFI_NATIVE			= 0,	// wifi original power save behavior
+	BTC_PS_LPS_ON				= 1,
+	BTC_PS_LPS_OFF				= 2,
+	BTC_PS_MAX
+} BTC_POWERSAVE_TYPE, *PBTC_POWERSAVE_TYPE;
+
+typedef enum _BTC_BT_REG_TYPE{
+	BTC_BT_REG_RF						= 0,
+	BTC_BT_REG_MODEM					= 1,
+	BTC_BT_REG_BLUEWIZE					= 2,
+	BTC_BT_REG_VENDOR					= 3,
+	BTC_BT_REG_LE						= 4,
+	BTC_BT_REG_MAX
+} BTC_BT_REG_TYPE, *PBTC_BT_REG_TYPE;
+
+typedef enum _BTC_CHIP_INTERFACE{
+	BTC_INTF_UNKNOWN	= 0,
+	BTC_INTF_PCI			= 1,
+	BTC_INTF_USB			= 2,
+	BTC_INTF_SDIO		= 3,
+	BTC_INTF_MAX
+} BTC_CHIP_INTERFACE, *PBTC_CHIP_INTERFACE;
+
+typedef enum _BTC_CHIP_TYPE{
+	BTC_CHIP_UNDEF		= 0,
+	BTC_CHIP_CSR_BC4		= 1,
+	BTC_CHIP_CSR_BC8		= 2,
+	BTC_CHIP_RTL8723A 	= 3,
+	BTC_CHIP_RTL8821	= 4,
+	BTC_CHIP_RTL8723B 	= 5,
+	BTC_CHIP_MAX
+} BTC_CHIP_TYPE, *PBTC_CHIP_TYPE;
+
+// following is for wifi link status
+#define		WIFI_STA_CONNECTED				BIT0
+#define		WIFI_AP_CONNECTED				BIT1
+#define		WIFI_HS_CONNECTED				BIT2
+#define		WIFI_P2P_GO_CONNECTED			BIT3
+#define		WIFI_P2P_GC_CONNECTED			BIT4
+
+// following is for command line utility
+#define	CL_SPRINTF	rsprintf
+#define	CL_PRINTF	DCMD_Printf
+
+struct btc_board_info{
+	/* The following is some board information */
+	u8				bt_chip_type;
+	u8				pg_ant_num;	/* pg ant number */
+	u8				btdm_ant_num;	/* ant number for btdm */
+	u8				btdm_ant_num_by_ant_det;	/* ant number for btdm after antenna detection */
+	u8				btdm_ant_pos;		/* Bryant Add to indicate Antenna Position for (pg_ant_num = 2) && (btdm_ant_num =1)  (DPDT+1Ant case) */
+	u8				single_ant_path;	/* current used for 8723b only, 1=>s0,  0=>s1 */
+	boolean			tfbga_package;    /* for Antenna detect threshold */
+	boolean			btdm_ant_det_finish;
+	u8				ant_type;
+};
+
+typedef enum _BTC_DBG_OPCODE{
+	BTC_DBG_SET_COEX_NORMAL				= 0x0,
+	BTC_DBG_SET_COEX_WIFI_ONLY				= 0x1,
+	BTC_DBG_SET_COEX_BT_ONLY				= 0x2,
+	BTC_DBG_SET_COEX_DEC_BT_PWR				= 0x3,
+	BTC_DBG_SET_COEX_BT_AFH_MAP				= 0x4,
+	BTC_DBG_SET_COEX_BT_IGNORE_WLAN_ACT		= 0x5,
+	BTC_DBG_SET_COEX_MANUAL_CTRL				= 0x6,
+	BTC_DBG_MAX
+}BTC_DBG_OPCODE,*PBTC_DBG_OPCODE;
+
+typedef enum _BTC_RSSI_STATE{
+	BTC_RSSI_STATE_HIGH						= 0x0,
+	BTC_RSSI_STATE_MEDIUM					= 0x1,
+	BTC_RSSI_STATE_LOW						= 0x2,
+	BTC_RSSI_STATE_STAY_HIGH					= 0x3,
+	BTC_RSSI_STATE_STAY_MEDIUM				= 0x4,
+	BTC_RSSI_STATE_STAY_LOW					= 0x5,
+	BTC_RSSI_MAX
+}BTC_RSSI_STATE,*PBTC_RSSI_STATE;
+#define	BTC_RSSI_HIGH(_rssi_)	((_rssi_==BTC_RSSI_STATE_HIGH||_rssi_==BTC_RSSI_STATE_STAY_HIGH)? TRUE:FALSE)
+#define	BTC_RSSI_MEDIUM(_rssi_)	((_rssi_==BTC_RSSI_STATE_MEDIUM||_rssi_==BTC_RSSI_STATE_STAY_MEDIUM)? TRUE:FALSE)
+#define	BTC_RSSI_LOW(_rssi_)	((_rssi_==BTC_RSSI_STATE_LOW||_rssi_==BTC_RSSI_STATE_STAY_LOW)? TRUE:FALSE)
+
+typedef enum _BTC_WIFI_ROLE{
+	BTC_ROLE_STATION						= 0x0,
+	BTC_ROLE_AP								= 0x1,
+	BTC_ROLE_IBSS							= 0x2,
+	BTC_ROLE_HS_MODE						= 0x3,
+	BTC_ROLE_MAX
+}BTC_WIFI_ROLE,*PBTC_WIFI_ROLE;
+
+typedef enum _BTC_WIRELESS_FREQ{
+	BTC_FREQ_2_4G					= 0x0,
+	BTC_FREQ_5G						= 0x1,
+	BTC_FREQ_MAX	
+}BTC_WIRELESS_FREQ,*PBTC_WIRELESS_FREQ;
+
+typedef enum _BTC_WIFI_BW_MODE{
+	BTC_WIFI_BW_LEGACY					= 0x0,
+	BTC_WIFI_BW_HT20					= 0x1,
+	BTC_WIFI_BW_HT40					= 0x2,
+	BTC_WIFI_BW_HT80					= 0x3,
+	BTC_WIFI_BW_HT160					= 0x4,
+	BTC_WIFI_BW_MAX	
+}BTC_WIFI_BW_MODE,*PBTC_WIFI_BW_MODE;
+
+typedef enum _BTC_WIFI_TRAFFIC_DIR{
+	BTC_WIFI_TRAFFIC_TX					= 0x0,
+	BTC_WIFI_TRAFFIC_RX					= 0x1,
+	BTC_WIFI_TRAFFIC_MAX	
+}BTC_WIFI_TRAFFIC_DIR,*PBTC_WIFI_TRAFFIC_DIR;
+
+typedef enum _BTC_WIFI_PNP{
+	BTC_WIFI_PNP_WAKE_UP					= 0x0,
+	BTC_WIFI_PNP_SLEEP						= 0x1,
+	BTC_WIFI_PNP_MAX
+}BTC_WIFI_PNP,*PBTC_WIFI_PNP;
+
+typedef enum _BTC_IOT_PEER
+{
+	BTC_IOT_PEER_UNKNOWN = 0,
+	BTC_IOT_PEER_REALTEK = 1,
+	BTC_IOT_PEER_REALTEK_92SE = 2,
+	BTC_IOT_PEER_BROADCOM = 3,
+	BTC_IOT_PEER_RALINK = 4,
+	BTC_IOT_PEER_ATHEROS = 5,
+	BTC_IOT_PEER_CISCO = 6,
+	BTC_IOT_PEER_MERU = 7,	
+	BTC_IOT_PEER_MARVELL = 8,
+	BTC_IOT_PEER_REALTEK_SOFTAP = 9,// peer is RealTek SOFT_AP, by Bohn, 2009.12.17
+	BTC_IOT_PEER_SELF_SOFTAP = 10, // Self is SoftAP
+	BTC_IOT_PEER_AIRGO = 11,
+	BTC_IOT_PEER_INTEL 				= 12, 
+	BTC_IOT_PEER_RTK_APCLIENT 		= 13, 
+	BTC_IOT_PEER_REALTEK_81XX 		= 14,	
+	BTC_IOT_PEER_REALTEK_WOW 		= 15,
+	BTC_IOT_PEER_REALTEK_JAGUAR_BCUTAP = 16,
+	BTC_IOT_PEER_REALTEK_JAGUAR_CCUTAP = 17,
+	BTC_IOT_PEER_MAX,
+}BTC_IOT_PEER, *PBTC_IOT_PEER;
+
+//for 8723b-d cut large current issue
+typedef enum _BTC_WIFI_COEX_STATE{
+	BTC_WIFI_STAT_INIT,
+	BTC_WIFI_STAT_IQK,
+	BTC_WIFI_STAT_NORMAL_OFF,
+	BTC_WIFI_STAT_MP_OFF,
+	BTC_WIFI_STAT_NORMAL,
+	BTC_WIFI_STAT_ANT_DIV,
+	BTC_WIFI_STAT_MAX
+}BTC_WIFI_COEX_STATE,*PBTC_WIFI_COEX_STATE;
+
+typedef enum _BTC_ANT_TYPE{
+	BTC_ANT_TYPE_0,
+	BTC_ANT_TYPE_1,
+	BTC_ANT_TYPE_2,
+	BTC_ANT_TYPE_3,
+	BTC_ANT_TYPE_4,
+	BTC_ANT_TYPE_MAX
+}BTC_ANT_TYPE,*PBTC_ANT_TYPE;
+
+typedef enum _BTC_VENDOR{
+	BTC_VENDOR_LENOVO,
+	BTC_VENDOR_ASUS,	
+	BTC_VENDOR_OTHER
+}BTC_VENDOR,*PBTC_VENDOR;
+
+
+// defined for BFP_BTC_GET
+typedef enum _BTC_GET_TYPE{
+	// type BOOLEAN
+	BTC_GET_BL_HS_OPERATION,
+	BTC_GET_BL_HS_CONNECTING,
+	BTC_GET_BL_WIFI_CONNECTED,
+	BTC_GET_BL_WIFI_BUSY,
+	BTC_GET_BL_WIFI_SCAN,
+	BTC_GET_BL_WIFI_LINK,
+	BTC_GET_BL_WIFI_ROAM,
+	BTC_GET_BL_WIFI_4_WAY_PROGRESS,
+	BTC_GET_BL_WIFI_UNDER_5G,
+	BTC_GET_BL_WIFI_AP_MODE_ENABLE,
+	BTC_GET_BL_WIFI_ENABLE_ENCRYPTION,
+	BTC_GET_BL_WIFI_UNDER_B_MODE,
+	BTC_GET_BL_EXT_SWITCH,
+	BTC_GET_BL_WIFI_IS_IN_MP_MODE,
+	BTC_GET_BL_IS_ASUS_8723B,
+
+	// type s4Byte
+	BTC_GET_S4_WIFI_RSSI,
+	BTC_GET_S4_HS_RSSI,
+	
+	// type u4Byte
+	BTC_GET_U4_WIFI_BW,
+	BTC_GET_U4_WIFI_TRAFFIC_DIRECTION,
+	BTC_GET_U4_WIFI_FW_VER,
+	BTC_GET_U4_WIFI_LINK_STATUS,
+	BTC_GET_U4_BT_PATCH_VER,
+	BTC_GET_U4_VENDOR,
+
+	// type u1Byte
+	BTC_GET_U1_WIFI_DOT11_CHNL,
+	BTC_GET_U1_WIFI_CENTRAL_CHNL,
+	BTC_GET_U1_WIFI_HS_CHNL,
+	BTC_GET_U1_MAC_PHY_MODE,
+	BTC_GET_U1_AP_NUM,
+	BTC_GET_U1_ANT_TYPE,
+	BTC_GET_U1_IOT_PEER,
+
+	//===== for 1Ant ======
+	BTC_GET_U1_LPS_MODE,
+
+	BTC_GET_MAX
+}BTC_GET_TYPE,*PBTC_GET_TYPE;
+
+// defined for BFP_BTC_SET
+typedef enum _BTC_SET_TYPE{
+	// type BOOLEAN
+	BTC_SET_BL_BT_DISABLE,
+	BTC_SET_BL_BT_TRAFFIC_BUSY,
+	BTC_SET_BL_BT_LIMITED_DIG,
+	BTC_SET_BL_FORCE_TO_ROAM,
+	BTC_SET_BL_TO_REJ_AP_AGG_PKT,
+	BTC_SET_BL_BT_CTRL_AGG_SIZE,
+	BTC_SET_BL_INC_SCAN_DEV_NUM,
+	BTC_SET_BL_BT_TX_RX_MASK,
+	BTC_SET_BL_MIRACAST_PLUS_BT,
+
+	// type u1Byte
+	BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON,
+	BTC_SET_U1_AGG_BUF_SIZE,
+
+	// type trigger some action
+	BTC_SET_ACT_GET_BT_RSSI,
+	BTC_SET_ACT_AGGREGATE_CTRL,
+	BTC_SET_ACT_ANTPOSREGRISTRY_CTRL,
+	//===== for 1Ant ======
+	// type BOOLEAN
+
+	// type u1Byte
+	BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE,
+	BTC_SET_U1_LPS_VAL,
+	BTC_SET_U1_RPWM_VAL,
+	// type trigger some action
+	BTC_SET_ACT_LEAVE_LPS,
+	BTC_SET_ACT_ENTER_LPS,
+	BTC_SET_ACT_NORMAL_LPS,
+	BTC_SET_ACT_DISABLE_LOW_POWER,
+	BTC_SET_ACT_UPDATE_RAMASK,
+	BTC_SET_ACT_SEND_MIMO_PS,
+	// BT Coex related
+	BTC_SET_ACT_CTRL_BT_INFO,
+	BTC_SET_ACT_CTRL_BT_COEX,
+	BTC_SET_ACT_CTRL_8723B_ANT,
+	//=================
+	BTC_SET_MAX
+}BTC_SET_TYPE,*PBTC_SET_TYPE;
+
+typedef enum _BTC_DBG_DISP_TYPE{
+	BTC_DBG_DISP_COEX_STATISTICS				= 0x0,
+	BTC_DBG_DISP_BT_LINK_INFO				= 0x1,
+	BTC_DBG_DISP_WIFI_STATUS				= 0x2,
+	BTC_DBG_DISP_MAX
+}BTC_DBG_DISP_TYPE,*PBTC_DBG_DISP_TYPE;
+
+typedef enum _BTC_NOTIFY_TYPE_IPS{
+	BTC_IPS_LEAVE							= 0x0,
+	BTC_IPS_ENTER							= 0x1,
+	BTC_IPS_MAX
+}BTC_NOTIFY_TYPE_IPS,*PBTC_NOTIFY_TYPE_IPS;
+typedef enum _BTC_NOTIFY_TYPE_LPS{
+	BTC_LPS_DISABLE							= 0x0,
+	BTC_LPS_ENABLE							= 0x1,
+	BTC_LPS_MAX
+}BTC_NOTIFY_TYPE_LPS,*PBTC_NOTIFY_TYPE_LPS;
+typedef enum _BTC_NOTIFY_TYPE_SCAN{
+	BTC_SCAN_FINISH							= 0x0,
+	BTC_SCAN_START							= 0x1,
+	BTC_SCAN_MAX
+}BTC_NOTIFY_TYPE_SCAN,*PBTC_NOTIFY_TYPE_SCAN;
+typedef enum _BTC_NOTIFY_TYPE_ASSOCIATE{
+	BTC_ASSOCIATE_FINISH						= 0x0,
+	BTC_ASSOCIATE_START						= 0x1,
+	BTC_ASSOCIATE_MAX
+}BTC_NOTIFY_TYPE_ASSOCIATE,*PBTC_NOTIFY_TYPE_ASSOCIATE;
+typedef enum _BTC_NOTIFY_TYPE_MEDIA_STATUS{
+	BTC_MEDIA_DISCONNECT					= 0x0,
+	BTC_MEDIA_CONNECT						= 0x1,
+	BTC_MEDIA_MAX
+}BTC_NOTIFY_TYPE_MEDIA_STATUS,*PBTC_NOTIFY_TYPE_MEDIA_STATUS;
+typedef enum _BTC_NOTIFY_TYPE_SPECIFIC_PACKET{
+	BTC_PACKET_UNKNOWN					= 0x0,
+	BTC_PACKET_DHCP							= 0x1,
+	BTC_PACKET_ARP							= 0x2,
+	BTC_PACKET_EAPOL						= 0x3,
+	BTC_PACKET_MAX
+}BTC_NOTIFY_TYPE_SPECIFIC_PACKET,*PBTC_NOTIFY_TYPE_SPECIFIC_PACKET;
+typedef enum _BTC_NOTIFY_TYPE_STACK_OPERATION{
+	BTC_STACK_OP_NONE					= 0x0,
+	BTC_STACK_OP_INQ_PAGE_PAIR_START		= 0x1,
+	BTC_STACK_OP_INQ_PAGE_PAIR_FINISH	= 0x2,
+	BTC_STACK_OP_MAX
+}BTC_NOTIFY_TYPE_STACK_OPERATION,*PBTC_NOTIFY_TYPE_STACK_OPERATION;
+
+//Bryant Add
+typedef enum _BTC_ANTENNA_POS{
+	BTC_ANTENNA_AT_MAIN_PORT				= 0x1,
+	BTC_ANTENNA_AT_AUX_PORT				= 0x2,
+}BTC_ANTENNA_POS,*PBTC_ANTENNA_POS;
+
+//Bryant Add
+typedef enum _BTC_BT_OFFON{
+	BTC_BT_OFF				= 0x0,
+	BTC_BT_ON				= 0x1,
+}BTC_BTOFFON,*PBTC_BT_OFFON;
+
+//==================================================
+// For following block is for coex offload
+//==================================================
+typedef struct _COL_H2C{
+	u1Byte	opcode;
+	u1Byte	opcode_ver:4;
+	u1Byte	req_num:4;
+	u1Byte	buf[1];
+}COL_H2C, *PCOL_H2C;
+
+#define	COL_C2H_ACK_HDR_LEN	3
+typedef struct _COL_C2H_ACK{
+	u1Byte	status;
+	u1Byte	opcode_ver:4;
+	u1Byte	req_num:4;
+	u1Byte	ret_len;
+	u1Byte	buf[1];
+}COL_C2H_ACK, *PCOL_C2H_ACK;
+
+#define	COL_C2H_IND_HDR_LEN	3
+typedef struct _COL_C2H_IND{
+	u1Byte	type;
+	u1Byte	version;
+	u1Byte	length;
+	u1Byte	data[1];
+}COL_C2H_IND, *PCOL_C2H_IND;
+
+//============================================
+// NOTE: for debug message, the following define should match
+// the strings in coexH2cResultString.
+//============================================
+typedef enum _COL_H2C_STATUS{
+	// c2h status
+	COL_STATUS_C2H_OK								= 0x00, // Wifi received H2C request and check content ok.
+	COL_STATUS_C2H_UNKNOWN							= 0x01,	// Not handled routine
+	COL_STATUS_C2H_UNKNOWN_OPCODE					= 0x02,	// Invalid OP code, It means that wifi firmware received an undefiend OP code.
+	COL_STATUS_C2H_OPCODE_VER_MISMATCH			= 0x03, // Wifi firmware and wifi driver mismatch, need to update wifi driver or wifi or.
+	COL_STATUS_C2H_PARAMETER_ERROR				= 0x04, // Error paraneter.(ex: parameters = NULL but it should have values)
+	COL_STATUS_C2H_PARAMETER_OUT_OF_RANGE		= 0x05, // Wifi firmware needs to check the parameters from H2C request and return the status.(ex: ch = 500, it's wrong)
+	// other COL status start from here
+	COL_STATUS_C2H_REQ_NUM_MISMATCH			, // c2h req_num mismatch, means this c2h is not we expected.
+	COL_STATUS_H2C_HALMAC_FAIL					, // HALMAC return fail.
+	COL_STATUS_H2C_TIMTOUT						, // not received the c2h response from fw
+	COL_STATUS_INVALID_C2H_LEN					, // invalid coex offload c2h ack length, must >= 3
+	COL_STATUS_COEX_DATA_OVERFLOW				, // coex returned length over the c2h ack length.
+	COL_STATUS_MAX
+}COL_H2C_STATUS,*PCOL_H2C_STATUS;
+
+#define	COL_MAX_H2C_REQ_NUM		16
+
+#define	COL_H2C_BUF_LEN			20
+typedef enum _COL_OPCODE{
+	COL_OP_WIFI_STATUS_NOTIFY					= 0x0,
+	COL_OP_WIFI_PROGRESS_NOTIFY					= 0x1,
+	COL_OP_WIFI_INFO_NOTIFY						= 0x2,
+	COL_OP_WIFI_POWER_STATE_NOTIFY				= 0x3,
+	COL_OP_SET_CONTROL							= 0x4,
+	COL_OP_GET_CONTROL							= 0x5,
+	COL_OP_WIFI_OPCODE_MAX
+}COL_OPCODE,*PCOL_OPCODE;
+
+typedef enum _COL_IND_TYPE{
+	COL_IND_BT_INFO								= 0x0,
+	COL_IND_PSTDMA								= 0x1,
+	COL_IND_LIMITED_TX_RX						= 0x2,
+	COL_IND_COEX_TABLE							= 0x3,
+	COL_IND_REQ									= 0x4,
+	COL_IND_MAX
+}COL_IND_TYPE,*PCOL_IND_TYPE;
+
+typedef struct _COL_SINGLE_H2C_RECORD{
+	u1Byte					h2c_buf[COL_H2C_BUF_LEN];	// the latest sent h2c buffer
+	u4Byte					h2c_len;
+	u1Byte					c2h_ack_buf[COL_H2C_BUF_LEN];	// the latest received c2h buffer
+	u4Byte					c2h_ack_len;
+	u4Byte					count;									// the total number of the sent h2c command
+	u4Byte					status[COL_STATUS_MAX];					// the c2h status for the sent h2c command
+} COL_SINGLE_H2C_RECORD, *PCOL_SINGLE_H2C_RECORD;
+
+typedef struct _COL_SINGLE_C2H_IND_RECORD{
+	u1Byte					ind_buf[COL_H2C_BUF_LEN];	// the latest received c2h indication buffer
+	u4Byte					ind_len;
+	u4Byte					count;									// the total number of the rcvd c2h indication
+	u4Byte					status[COL_STATUS_MAX];					// the c2h indication verified status 
+} COL_SINGLE_C2H_IND_RECORD, *PCOL_SINGLE_C2H_IND_RECORD;
+
+typedef struct _BTC_OFFLOAD{
+	// H2C command related
+	u1Byte					h2c_req_num;
+	u4Byte					cnt_h2c_sent;
+	COL_SINGLE_H2C_RECORD	h2c_record[COL_OP_WIFI_OPCODE_MAX];
+
+	// C2H Ack related
+	u4Byte					cnt_c2h_ack;
+	u4Byte					status[COL_STATUS_MAX];
+	struct completion		c2h_event[COL_MAX_H2C_REQ_NUM];	// for req_num = 1~COL_MAX_H2C_REQ_NUM
+	u1Byte					c2h_ack_buf[COL_MAX_H2C_REQ_NUM][COL_H2C_BUF_LEN];
+	u1Byte					c2h_ack_len[COL_MAX_H2C_REQ_NUM];
+
+	// C2H Indication related
+	u4Byte						cnt_c2h_ind;
+	COL_SINGLE_C2H_IND_RECORD	c2h_ind_record[COL_IND_MAX];
+	u4Byte						c2h_ind_status[COL_STATUS_MAX];
+	u1Byte						c2h_ind_buf[COL_H2C_BUF_LEN];
+	u1Byte						c2h_ind_len;
+} BTC_OFFLOAD, *PBTC_OFFLOAD;
+extern BTC_OFFLOAD				gl_coex_offload;
+//==================================================
+
+typedef u1Byte
+(*BFP_BTC_R1)(
+	IN 	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr
+	);
+typedef u2Byte
+(*BFP_BTC_R2)(
+	IN 	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr
+	);
+typedef u4Byte
+(*BFP_BTC_R4)(
+	IN 	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr
+	);
+typedef VOID
+(*BFP_BTC_W1)(
+	IN 	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u1Byte			Data
+	);
+typedef VOID
+(*BFP_BTC_W1_BIT_MASK)(
+	IN 	PVOID			pBtcContext,
+	IN	u4Byte			regAddr,
+	IN	u1Byte			bitMask,
+	IN	u1Byte			data1b
+	);
+typedef VOID
+(*BFP_BTC_W2)(
+	IN 	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u2Byte			Data
+	);
+typedef VOID
+(*BFP_BTC_W4)(
+	IN 	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			Data
+	);
+typedef VOID
+(*BFP_BTC_LOCAL_REG_W1)(
+	IN 	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u1Byte			Data
+	);
+typedef VOID
+(*BFP_BTC_SET_BB_REG)(
+	IN 	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			BitMask,
+	IN	u4Byte			Data
+	);
+typedef u4Byte 
+(*BFP_BTC_GET_BB_REG)(
+	IN 	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			BitMask
+	);
+typedef VOID
+(*BFP_BTC_SET_RF_REG)(	
+	IN 	PVOID			pBtcContext,
+	IN	u1Byte			eRFPath,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			BitMask,
+	IN	u4Byte			Data
+	);
+typedef u4Byte 
+(*BFP_BTC_GET_RF_REG)(
+	IN 	PVOID			pBtcContext,
+	IN	u1Byte			eRFPath,
+	IN	u4Byte			RegAddr,
+	IN	u4Byte			BitMask
+	);
+typedef VOID
+(*BFP_BTC_FILL_H2C)(
+	IN 	PVOID			pBtcContext,
+	IN	u1Byte 			elementId,
+	IN	u4Byte 			cmdLen,
+	IN	pu1Byte			pCmdBuffer
+	);
+
+typedef	BOOLEAN
+(*BFP_BTC_GET)(
+	IN	PVOID			pBtCoexist,
+	IN	u1Byte			getType,
+	OUT	PVOID			pOutBuf
+	);
+
+typedef	BOOLEAN
+(*BFP_BTC_SET)(
+	IN	PVOID			pBtCoexist,
+	IN	u1Byte			setType,
+	OUT	PVOID			pInBuf
+	);
+typedef u2Byte
+(*BFP_BTC_SET_BT_REG)(
+	IN 	PVOID			pBtcContext,
+	IN	u1Byte			regType,
+	IN	u4Byte			offset,
+	IN	u4Byte			value
+	);
+typedef BOOLEAN
+(*BFP_BTC_SET_BT_ANT_DETECTION)(
+	IN 	PVOID			pBtcContext,
+	IN	u1Byte			txTime,
+	IN	u1Byte			btChnl
+	);
+typedef u2Byte 
+(*BFP_BTC_GET_BT_REG)(
+	IN 	PVOID			pBtcContext,
+	IN	u1Byte			regType,
+	IN	u4Byte			offset,
+	IN	pu4Byte			data
+	);
+typedef VOID
+(*BFP_BTC_DISP_DBG_MSG)(
+	IN	PVOID			pBtCoexist,
+	IN	u1Byte			dispType
+	);
+
+typedef COL_H2C_STATUS
+(*BFP_BTC_COEX_H2C_PROCESS)(
+	IN	PVOID			pBtCoexist,
+	IN	u1Byte			opcode,
+	IN	u1Byte			opcode_ver,
+	IN	pu1Byte			ph2c_par,
+	IN	u1Byte			h2c_par_len
+	);
+
+typedef struct _BTC_BT_INFO{
+	BOOLEAN					bBtDisabled;
+	u1Byte					rssiAdjustForAgcTableOn;
+	u1Byte					rssiAdjustFor1AntCoexType;
+	BOOLEAN					bPreBtCtrlAggBufSize;
+	BOOLEAN					bBtCtrlAggBufSize;
+	BOOLEAN					bPreRejectAggPkt;
+	BOOLEAN					bRejectAggPkt;
+	BOOLEAN					bIncreaseScanDevNum;
+	BOOLEAN					bBtTxRxMask;
+	u1Byte					preAggBufSize;
+	u1Byte					aggBufSize;
+	BOOLEAN					bBtBusy;
+	BOOLEAN					bLimitedDig;
+	u2Byte					btHciVer;
+	u2Byte					btRealFwVer;
+	u1Byte					btFwVer;
+	u4Byte					getBtFwVerCnt;
+	BOOLEAN					bMiracastPlusBt;
+
+	BOOLEAN					bBtDisableLowPwr;
+
+	BOOLEAN					bBtCtrlLps;
+	BOOLEAN					bBtLpsOn;
+	BOOLEAN					bForceToRoam;	// for 1Ant solution
+	u1Byte					lpsVal;
+	u1Byte					rpwmVal;
+	u4Byte					raMask;
+} BTC_BT_INFO, *PBTC_BT_INFO;
+
+struct btc_stack_info {
+	boolean					profile_notified;
+	u16					hci_version;	/* stack hci version */
+	u8					num_of_link;
+	boolean					bt_link_exist;
+	boolean					sco_exist;
+	boolean					acl_exist;
+	boolean					a2dp_exist;
+	boolean					hid_exist;
+	u8					num_of_hid;
+	boolean					pan_exist;
+	boolean					unknown_acl_exist;
+	s8					min_bt_rssi;
+};
+
+struct btc_bt_link_info {
+	boolean					bt_link_exist;
+	boolean					bt_hi_pri_link_exist;
+	boolean					sco_exist;
+	boolean					sco_only;
+	boolean					a2dp_exist;
+	boolean					a2dp_only;
+	boolean					hid_exist;
+	boolean					hid_only;
+	boolean					pan_exist;
+	boolean					pan_only;
+	boolean					slave_role;
+	boolean					acl_busy;
+};
+
+typedef struct _BTC_STATISTICS{
+	u4Byte					cntBind;
+	u4Byte					cntPowerOn;
+	u4Byte					cntPreLoadFirmware;
+	u4Byte					cntInitHwConfig;
+	u4Byte					cntInitCoexDm;
+	u4Byte					cntIpsNotify;
+	u4Byte					cntLpsNotify;
+	u4Byte					cntScanNotify;
+	u4Byte					cntConnectNotify;
+	u4Byte					cntMediaStatusNotify;
+	u4Byte					cntSpecificPacketNotify;
+	u4Byte					cntBtInfoNotify;
+	u4Byte					cntRfStatusNotify;
+	u4Byte					cntPeriodical;
+	u4Byte					cntCoexDmSwitch;
+	u4Byte					cntStackOperationNotify;
+	u4Byte					cntDbgCtrl;
+} BTC_STATISTICS, *PBTC_STATISTICS;
+
+struct btc_coexist{
+	BOOLEAN				bBinded;		// make sure only one adapter can bind the data context
+	PVOID				Adapter;		// default adapter
+	struct  btc_board_info		board_info;
+	BTC_BT_INFO			btInfo;		// some bt info referenced by non-bt module
+	struct  btc_stack_info		stack_info;
+	struct  btc_bt_link_info		bt_link_info;
+	BTC_CHIP_INTERFACE		chip_interface;
+
+	BOOLEAN					initilized;
+	BOOLEAN					stop_coex_dm;
+	BOOLEAN					manual_control;
+	pu1Byte					cli_buf;
+	BTC_STATISTICS		statistics;
+	u1Byte				pwrModeVal[10];
+
+	// function pointers
+	// io related
+	BFP_BTC_R1			btc_read_1byte;
+	BFP_BTC_W1			btc_write_1byte;
+	BFP_BTC_W1_BIT_MASK	btc_write_1byte_bitmask;
+	BFP_BTC_R2			btc_read_2byte;
+	BFP_BTC_W2			btc_write_2byte;
+	BFP_BTC_R4			btc_read_4byte;
+	BFP_BTC_W4			btc_write_4byte;
+	BFP_BTC_LOCAL_REG_W1	btc_write_local_reg_1byte;
+	// read/write bb related
+	BFP_BTC_SET_BB_REG	btc_set_bb_reg;
+	BFP_BTC_GET_BB_REG	btc_get_bb_reg;
+
+	// read/write rf related
+	BFP_BTC_SET_RF_REG	btc_set_rf_reg;
+	BFP_BTC_GET_RF_REG	btc_get_rf_reg;
+
+	// fill h2c related
+	BFP_BTC_FILL_H2C		btc_fill_h2c;
+	// other
+	BFP_BTC_DISP_DBG_MSG	btc_disp_dbg_msg;
+	// normal get/set related
+	BFP_BTC_GET			btc_get;
+	BFP_BTC_SET			btc_set;
+
+	BFP_BTC_GET_BT_REG	btc_get_bt_reg;
+	BFP_BTC_SET_BT_REG	btc_set_bt_reg;
+
+	BFP_BTC_SET_BT_ANT_DETECTION	btc_set_bt_ant_detection;
+
+	BFP_BTC_COEX_H2C_PROCESS	btc_coex_h2c_process;
+};
+typedef struct btc_coexist *PBTC_COEXIST;
+
+extern struct btc_coexist	GLBtCoexist;
+
+BOOLEAN
+EXhalbtcoutsrc_InitlizeVariables(
+	IN	PVOID		Adapter	
+	);
+VOID
+EXhalbtcoutsrc_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_PreLoadFirmware(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
+EXhalbtcoutsrc_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			action
+	);
+VOID
+EXhalbtcoutsrc_MediaStatusNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	RT_MEDIA_STATUS	mediaStatus
+	);
+VOID
+EXhalbtcoutsrc_SpecificPacketNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			pktType
+	);
+VOID
+EXhalbtcoutsrc_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	);
+VOID
+EXhalbtcoutsrc_RfStatusNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte 				type
+	);
+VOID
+EXhalbtcoutsrc_StackOperationNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtcoutsrc_HaltNotify(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_PnpNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			pnpState
+	);
+VOID
+EXhalbtcoutsrc_ScoreBoardStatusNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	);
+VOID
+EXhalbtcoutsrc_CoexDmSwitch(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_Periodical(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_DbgControl(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				opCode,
+	IN	u1Byte				opLen,
+	IN	pu1Byte				pData
+	);
+VOID
+EXhalbtcoutsrc_AntennaDetection(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u4Byte					centFreq,
+	IN	u4Byte					offset,
+	IN	u4Byte					span,
+	IN	u4Byte					seconds
+	);
+VOID
+EXhalbtcoutsrc_StackUpdateProfileInfo(
+	VOID
+	);
+VOID
+EXhalbtcoutsrc_SetHciVersion(
+	IN	u2Byte	hciVersion
+	);
+VOID
+EXhalbtcoutsrc_SetBtPatchVersion(
+	IN	u2Byte	btHciVersion,
+	IN	u2Byte	btPatchVersion
+	);
+VOID
+EXhalbtcoutsrc_UpdateMinBtRssi(
+	IN	s1Byte	btRssi
+	);
+#if 0
+VOID
+EXhalbtcoutsrc_SetBtExist(
+	IN	BOOLEAN		bBtExist
+	);
+#endif
+VOID
+EXhalbtcoutsrc_SetChipType(
+	IN	u1Byte		chipType
+	);
+VOID
+EXhalbtcoutsrc_SetAntNum(
+	IN	u1Byte		type,
+	IN	u1Byte		antNum
+	);
+VOID
+EXhalbtcoutsrc_SetSingleAntPath(
+	IN	u1Byte		singleAntPath
+	);
+VOID
+EXhalbtcoutsrc_DisplayBtCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_DisplayAntDetection(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+
+
+#define	MASKBYTE0		0xff
+#define	MASKBYTE1		0xff00
+#define	MASKBYTE2		0xff0000
+#define	MASKBYTE3		0xff000000
+#define	MASKHWORD	0xffff0000
+#define	MASKLWORD		0x0000ffff
+#define	MASKDWORD	0xffffffff
+#define	MASK12BITS		0xfff
+#define	MASKH4BITS		0xf0000000
+#define	MASKOFDM_D	0xffc00000
+#define	MASKCCK		0x3f3f3f3f
+
+#endif
diff --git a/drivers/net/wireless/realtek/rtl8723cs/hal/btc/Mp_Precomp.h b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/Mp_Precomp.h
new file mode 100644
index 000000000..c70f83288
--- /dev/null
+++ b/drivers/net/wireless/realtek/rtl8723cs/hal/btc/Mp_Precomp.h
@@ -0,0 +1,98 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __MP_PRECOMP_H__
+#define __MP_PRECOMP_H__
+
+#include <drv_types.h>
+#include <hal_data.h>
+
+#define BT_TMP_BUF_SIZE	100
+
+#ifdef PLATFORM_LINUX
+#define rsprintf snprintf
+#elif defined(PLATFORM_WINDOWS)
+#define rsprintf sprintf_s
+#endif
+
+#define DCMD_Printf			DBG_BT_INFO
+
+#define delay_ms(ms)		rtw_mdelay_os(ms)
+
+#ifdef bEnable
+#undef bEnable
+#endif
+
+#define WPP_SOFTWARE_TRACE 0
+
+typedef enum _BTC_MSG_COMP_TYPE{
+	COMP_COEX		= 0,
+	COMP_MAX
+}BTC_MSG_COMP_TYPE;
+extern u4Byte GLBtcDbgType[];
+
+#define DBG_OFF			0
+#define DBG_SEC			1
+#define DBG_SERIOUS		2
+#define DBG_WARNING		3
+#define DBG_LOUD		4
+#define DBG_TRACE		5
+
+#if DBG
+#ifdef RT_TRACE
+#undef RT_TRACE
+#define RT_TRACE(dbgtype, dbgflag, printstr)\
+do {\
+	if (GLBtcDbgType[dbgtype] & BIT(dbgflag))\
+	{\
+		DbgPrint printstr;\
+	}\
+} while (0)
+#endif
+#else
+#define RT_TRACE(dbgtype, dbgflag, printstr)
+#endif
+
+#ifdef CONFIG_BT_COEXIST
+#define BT_SUPPORT		1
+#define COEX_SUPPORT	1
+#define HS_SUPPORT		1
+#else
+#define BT_SUPPORT		0
+#define COEX_SUPPORT	0
+#define HS_SUPPORT		0
+#endif
+
+#include "HalBtcOutSrc.h"
+#include "HalBtc8188c2Ant.h"
+#include "HalBtc8192d2Ant.h"
+#include "HalBtc8192e1Ant.h"
+#include "HalBtc8192e2Ant.h"
+#include "HalBtc8723a1Ant.h"
+#include "HalBtc8723a2Ant.h"
+#include "HalBtc8723b1Ant.h"
+#include "HalBtc8723b2Ant.h"
+#include "HalBtc8812a1Ant.h"
+#include "HalBtc8812a2Ant.h"
+#include "HalBtc8821a1Ant.h"
+#include "HalBtc8821a2Ant.h"
+#include "HalBtc8821aCsr2Ant.h"
+#include "HalBtc8703b1Ant.h"
+
+#endif // __MP_PRECOMP_H__
-- 
2.34.1

